[
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_vowggxyj()\n{\n    TwoIntsClass * data;\n    switch(6)\n    {\n    case 6:\n        \n        data = NULL;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n        break;\n    }\n}\n\n\nstatic void f_atrsqztj()\n{\n    TwoIntsClass * data;\n    switch(6)\n    {\n    case 6:\n        \n        data = NULL;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_eedasfsb()\n{\n    TwoIntsClass * data;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        TwoIntsClass * tmpData = new TwoIntsClass;\n        tmpData->intOne = 0;\n        tmpData->intTwo = 0;\n        \n        data = tmpData;\n    }\n    break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_wlbigsqd()\n{\n    TwoIntsClass * data;\n    switch(6)\n    {\n    case 6:\n    {\n        TwoIntsClass * tmpData = new TwoIntsClass;\n        tmpData->intOne = 0;\n        tmpData->intTwo = 0;\n        \n        data = tmpData;\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_nctiuwcv()\n{\n    f_vowggxyj();\n    f_atrsqztj();\n    f_eedasfsb();\n    f_wlbigsqd();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nctiuwcv();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401820,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_15.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _A_namespace\n{\n\n\nvoid f_zljawqyj()\n{\n    TwoIntsClass * data;\n    switch(6)\n    {\n    case 6:\n        \n        data = NULL;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_zljawqyj();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401821,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_15.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\n\n\nstatic void f_lzhalham()\n{\n    twoIntsStruct * data;\n    switch(6)\n    {\n    case 6:\n        \n        data = NULL;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n        break;\n    }\n}\n\n\nstatic void f_rgaozala()\n{\n    twoIntsStruct * data;\n    switch(6)\n    {\n    case 6:\n        \n        data = NULL;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_lczvzzsb()\n{\n    twoIntsStruct * data;\n    twoIntsStruct tmpData;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n    {\n        tmpData.intOne = 0;\n        tmpData.intTwo = 0;\n        data = &tmpData;\n    }\n    break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(data->intOne);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_yfajddql()\n{\n    twoIntsStruct * data;\n    twoIntsStruct tmpData;\n    switch(6)\n    {\n    case 6:\n        \n    {\n        tmpData.intOne = 0;\n        tmpData.intTwo = 0;\n        data = &tmpData;\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(data->intOne);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_rotfuwij()\n{\n    f_lzhalham();\n    f_rgaozala();\n    f_lczvzzsb();\n    f_yfajddql();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rotfuwij();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401822,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__struct_15.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nvoid f_znyisbme()\n{\n    twoIntsStruct * data;\n    switch(6)\n    {\n    case 6:\n        \n        data = NULL;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(data->intOne);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_znyisbme();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401823,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__struct_15.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\n\n\nstatic void f_ileqihxy()\n{\n    long * data;\n    switch(6)\n    {\n    case 6:\n        \n        data = NULL;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        if (data != NULL)\n        {\n            printLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n        break;\n    }\n}\n\n\nstatic void f_cnivgyvu()\n{\n    long * data;\n    switch(6)\n    {\n    case 6:\n        \n        data = NULL;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        if (data != NULL)\n        {\n            printLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_qlbfmnhx()\n{\n    long * data;\n    long tmpData = 5L;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n    {\n        data = &tmpData;\n    }\n    break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLine(*data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_dgmhfpwu()\n{\n    long * data;\n    long tmpData = 5L;\n    switch(6)\n    {\n    case 6:\n        \n    {\n        data = &tmpData;\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLine(*data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_dgkyqkeg()\n{\n    f_ileqihxy();\n    f_cnivgyvu();\n    f_qlbfmnhx();\n    f_dgmhfpwu();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_dgkyqkeg();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401824,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__long_15.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nvoid f_fmzuhlrk()\n{\n    long * data;\n    switch(6)\n    {\n    case 6:\n        \n        data = NULL;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLine(*data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_fmzuhlrk();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401825,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__long_15.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\n\n\nstatic void f_bsgmmrpu()\n{\n    int * data;\n    switch(6)\n    {\n    case 6:\n        \n        data = NULL;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        if (data != NULL)\n        {\n            printIntLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n        break;\n    }\n}\n\n\nstatic void f_bkfjfrhm()\n{\n    int * data;\n    switch(6)\n    {\n    case 6:\n        \n        data = NULL;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        if (data != NULL)\n        {\n            printIntLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_pnffoavo()\n{\n    int * data;\n    int tmpData = 5;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n    {\n        data = &tmpData;\n    }\n    break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(*data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_fjifdwub()\n{\n    int * data;\n    int tmpData = 5;\n    switch(6)\n    {\n    case 6:\n        \n    {\n        data = &tmpData;\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(*data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_geggfugs()\n{\n    f_bsgmmrpu();\n    f_bkfjfrhm();\n    f_pnffoavo();\n    f_fjifdwub();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_geggfugs();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401826,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int_15.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nvoid f_clnyyttg()\n{\n    int * data;\n    switch(6)\n    {\n    case 6:\n        \n        data = NULL;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printIntLine(*data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_clnyyttg();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401827,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int_15.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\n\n\nstatic void f_uhohfcco()\n{\n    int64_t * data;\n    switch(6)\n    {\n    case 6:\n        \n        data = NULL;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        if (data != NULL)\n        {\n            printLongLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n        break;\n    }\n}\n\n\nstatic void f_brkfpdzz()\n{\n    int64_t * data;\n    switch(6)\n    {\n    case 6:\n        \n        data = NULL;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        if (data != NULL)\n        {\n            printLongLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_pwxqozrr()\n{\n    int64_t * data;\n    int64_t tmpData = 5LL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n    {\n        data = &tmpData;\n    }\n    break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLongLine(*data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_bwlpeohj()\n{\n    int64_t * data;\n    int64_t tmpData = 5LL;\n    switch(6)\n    {\n    case 6:\n        \n    {\n        data = &tmpData;\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLongLine(*data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_szyzaisc()\n{\n    f_uhohfcco();\n    f_brkfpdzz();\n    f_pwxqozrr();\n    f_bwlpeohj();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_szyzaisc();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401828,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int64_t_15.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nvoid f_qmlpdybe()\n{\n    int64_t * data;\n    switch(6)\n    {\n    case 6:\n        \n        data = NULL;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        printLongLongLine(*data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qmlpdybe();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401829,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int64_t_15.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\n\n\nstatic void f_rrbgizmc()\n{\n    wchar_t * data;\n    switch(6)\n    {\n    case 6:\n        \n        data = NULL;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        if (data != NULL)\n        {\n            \n            printWcharLine(data[0]);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n        break;\n    }\n}\n\n\nstatic void f_blashxdm()\n{\n    wchar_t * data;\n    switch(6)\n    {\n    case 6:\n        \n        data = NULL;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        if (data != NULL)\n        {\n            \n            printWcharLine(data[0]);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_vcdjxedh()\n{\n    wchar_t * data;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        data = L\"\";\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        printWcharLine(data[0]);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_frtzophe()\n{\n    wchar_t * data;\n    switch(6)\n    {\n    case 6:\n        \n        data = L\"\";\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        printWcharLine(data[0]);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_kyascyfp()\n{\n    f_rrbgizmc();\n    f_blashxdm();\n    f_vcdjxedh();\n    f_frtzophe();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_kyascyfp();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401830,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__wchar_t_15.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nvoid f_hdewvyzz()\n{\n    wchar_t * data;\n    switch(6)\n    {\n    case 6:\n        \n        data = NULL;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        printWcharLine(data[0]);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_hdewvyzz();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401831,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__wchar_t_15.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\n\n\nstatic void f_qmlfavqu()\n{\n    char * data;\n    switch(6)\n    {\n    case 6:\n        \n        data = NULL;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        if (data != NULL)\n        {\n            \n            printHexCharLine(data[0]);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n        break;\n    }\n}\n\n\nstatic void f_oxgfckef()\n{\n    char * data;\n    switch(6)\n    {\n    case 6:\n        \n        data = NULL;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        if (data != NULL)\n        {\n            \n            printHexCharLine(data[0]);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_dkqplarc()\n{\n    char * data;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        data = \"\";\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        printHexCharLine(data[0]);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_sllilfrh()\n{\n    char * data;\n    switch(6)\n    {\n    case 6:\n        \n        data = \"\";\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        printHexCharLine(data[0]);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_aicfobsy()\n{\n    f_qmlfavqu();\n    f_oxgfckef();\n    f_dkqplarc();\n    f_sllilfrh();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_aicfobsy();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401832,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__char_15.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nvoid f_reydskbr()\n{\n    char * data;\n    switch(6)\n    {\n    case 6:\n        \n        data = NULL;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        \n        printHexCharLine(data[0]);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_reydskbr();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401833,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__char_15.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_srfgasjd()\n{\n    TwoIntsClass * data;\n    if(staticReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_pspyytjn()\n{\n    TwoIntsClass * data;\n    if(staticReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_uqodqqzp()\n{\n    TwoIntsClass * data;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\nstatic void f_ajkeppph()\n{\n    TwoIntsClass * data;\n    if(staticReturnsTrue())\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\nvoid f_qqjlcqly()\n{\n    f_srfgasjd();\n    f_pspyytjn();\n    f_uqodqqzp();\n    f_ajkeppph();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qqjlcqly();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401834,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_08.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\nnamespace _A_namespace\n{\n\n\nvoid f_rtggkfwa()\n{\n    TwoIntsClass * data;\n    if(staticReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rtggkfwa();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401835,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_08.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_tcreaxwt()\n{\n    TwoIntsClass * data;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_wlflfjut()\n{\n    TwoIntsClass * data;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_egykvtbr()\n{\n    TwoIntsClass * data;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\nstatic void f_vzaqifft()\n{\n    TwoIntsClass * data;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\nvoid f_gkkmgxrt()\n{\n    f_tcreaxwt();\n    f_wlflfjut();\n    f_egykvtbr();\n    f_vzaqifft();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_gkkmgxrt();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401836,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_04.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\nnamespace _A_namespace\n{\n\n\nvoid f_txwfkmea()\n{\n    TwoIntsClass * data;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_txwfkmea();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401837,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_04.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_ufslcxvr()\n{\n    TwoIntsClass * data;\n    if(staticTrue)\n    {\n        \n        data = NULL;\n    }\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_wxolxqhm()\n{\n    TwoIntsClass * data;\n    if(staticTrue)\n    {\n        \n        data = NULL;\n    }\n    if(staticTrue)\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_jqvsdfdk()\n{\n    TwoIntsClass * data;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(staticTrue)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\nstatic void f_xxbffqol()\n{\n    TwoIntsClass * data;\n    if(staticTrue)\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(staticTrue)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\nvoid f_xxvulleb()\n{\n    f_ufslcxvr();\n    f_wxolxqhm();\n    f_jqvsdfdk();\n    f_xxbffqol();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_xxvulleb();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401838,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_05.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\nnamespace _A_namespace\n{\n\n\nvoid f_ucfkezmi()\n{\n    TwoIntsClass * data;\n    if(staticTrue)\n    {\n        \n        data = NULL;\n    }\n    if(staticTrue)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ucfkezmi();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401839,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_05.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n\nstatic int staticFive = 5;\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_krzxtegx()\n{\n    TwoIntsClass * data;\n    if(staticFive==5)\n    {\n        \n        data = NULL;\n    }\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_kkpbfsrc()\n{\n    TwoIntsClass * data;\n    if(staticFive==5)\n    {\n        \n        data = NULL;\n    }\n    if(staticFive==5)\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_iontbqus()\n{\n    TwoIntsClass * data;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(staticFive==5)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\nstatic void f_odyzexce()\n{\n    TwoIntsClass * data;\n    if(staticFive==5)\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(staticFive==5)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\nvoid f_uouzmlvt()\n{\n    f_krzxtegx();\n    f_kkpbfsrc();\n    f_iontbqus();\n    f_odyzexce();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_uouzmlvt();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401840,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_07.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n\nstatic int staticFive = 5;\n\nnamespace _A_namespace\n{\n\n\nvoid f_uwfhravr()\n{\n    TwoIntsClass * data;\n    if(staticFive==5)\n    {\n        \n        data = NULL;\n    }\n    if(staticFive==5)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_uwfhravr();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401841,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_07.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_oxlurnmd()\n{\n    TwoIntsClass * data;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_frelofso()\n{\n    TwoIntsClass * data;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_kkkyvwdc()\n{\n    TwoIntsClass * data;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\nstatic void f_ljhajkag()\n{\n    TwoIntsClass * data;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\nvoid f_ttcpwgxg()\n{\n    f_oxlurnmd();\n    f_frelofso();\n    f_kkkyvwdc();\n    f_ljhajkag();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ttcpwgxg();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401842,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_06.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\nnamespace _A_namespace\n{\n\n\nvoid f_uniwstmp()\n{\n    TwoIntsClass * data;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_uniwstmp();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401843,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_06.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_wpwfcsmu()\n{\n    TwoIntsClass * data;\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        data = NULL;\n    }\n    else\n    {\n        \n        data = NULL;\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_wmvurcme()\n{\n    TwoIntsClass * data;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    else\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n    else\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\nvoid f_pbwvdqce()\n{\n    f_wpwfcsmu();\n    f_wmvurcme();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_pbwvdqce();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401844,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_12.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _A_namespace\n{\n\n\nvoid f_zgbisxyy()\n{\n    TwoIntsClass * data;\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        data = NULL;\n    }\n    else\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_zgbisxyy();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401845,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_12.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_eixgbcyk()\n{\n    TwoIntsClass * data;\n    if(1)\n    {\n        \n        data = NULL;\n    }\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_iimdugbk()\n{\n    TwoIntsClass * data;\n    if(1)\n    {\n        \n        data = NULL;\n    }\n    if(1)\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_kaagvegw()\n{\n    TwoIntsClass * data;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(1)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\nstatic void f_nxbnidzj()\n{\n    TwoIntsClass * data;\n    if(1)\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(1)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\nvoid f_hspbkjdh()\n{\n    f_eixgbcyk();\n    f_iimdugbk();\n    f_kaagvegw();\n    f_nxbnidzj();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_hspbkjdh();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401846,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_02.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _A_namespace\n{\n\n\nvoid f_splpgoaa()\n{\n    TwoIntsClass * data;\n    if(1)\n    {\n        \n        data = NULL;\n    }\n    if(1)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_splpgoaa();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401847,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_02.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\n\n\nstatic void f_nmsletje()\n{\n    twoIntsStruct * data;\n    if(staticReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_qzudyqlm()\n{\n    twoIntsStruct * data;\n    if(staticReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_efvrgxfr()\n{\n    twoIntsStruct * data;\n    twoIntsStruct tmpData;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        {\n            tmpData.intOne = 0;\n            tmpData.intTwo = 0;\n            data = &tmpData;\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printIntLine(data->intOne);\n    }\n}\n\n\nstatic void f_nsqmkbis()\n{\n    twoIntsStruct * data;\n    twoIntsStruct tmpData;\n    if(staticReturnsTrue())\n    {\n        \n        {\n            tmpData.intOne = 0;\n            tmpData.intTwo = 0;\n            data = &tmpData;\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printIntLine(data->intOne);\n    }\n}\n\nvoid f_qxjneedj()\n{\n    f_nmsletje();\n    f_qzudyqlm();\n    f_efvrgxfr();\n    f_nsqmkbis();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qxjneedj();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401848,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__struct_08.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\nvoid f_xzghgbkp()\n{\n    twoIntsStruct * data;\n    if(staticReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printIntLine(data->intOne);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_xzghgbkp();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401849,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__struct_08.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_oucmnwks()\n{\n    TwoIntsClass * data;\n    if(5==5)\n    {\n        \n        data = NULL;\n    }\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_udoaluzi()\n{\n    TwoIntsClass * data;\n    if(5==5)\n    {\n        \n        data = NULL;\n    }\n    if(5==5)\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_fcwjhunf()\n{\n    TwoIntsClass * data;\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(5==5)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\nstatic void f_eqbzpkqn()\n{\n    TwoIntsClass * data;\n    if(5==5)\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(5==5)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\nvoid f_zgmknhgr()\n{\n    f_oucmnwks();\n    f_udoaluzi();\n    f_fcwjhunf();\n    f_eqbzpkqn();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_zgmknhgr();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401850,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_03.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _A_namespace\n{\n\n\nvoid f_selydwet()\n{\n    TwoIntsClass * data;\n    if(5==5)\n    {\n        \n        data = NULL;\n    }\n    if(5==5)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_selydwet();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401851,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_03.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_tdjhumoi()\n{\n    TwoIntsClass * data;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_zdmdilhi()\n{\n    TwoIntsClass * data;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_euhyfbwd()\n{\n    TwoIntsClass * data;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\nstatic void f_djqthdxy()\n{\n    TwoIntsClass * data;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\nvoid f_gcrhytcu()\n{\n    f_tdjhumoi();\n    f_zdmdilhi();\n    f_euhyfbwd();\n    f_djqthdxy();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_gcrhytcu();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401852,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_09.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _A_namespace\n{\n\n\nvoid f_pqwjhewt()\n{\n    TwoIntsClass * data;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_pqwjhewt();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401853,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_09.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_iduukurg()\n{\n    TwoIntsClass * data;\n    if(globalTrue)\n    {\n        \n        data = NULL;\n    }\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_yaeuwvlv()\n{\n    TwoIntsClass * data;\n    if(globalTrue)\n    {\n        \n        data = NULL;\n    }\n    if(globalTrue)\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_irjntixv()\n{\n    TwoIntsClass * data;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(globalTrue)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\nstatic void f_tgmkaqup()\n{\n    TwoIntsClass * data;\n    if(globalTrue)\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(globalTrue)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\nvoid f_umksfbiy()\n{\n    f_iduukurg();\n    f_yaeuwvlv();\n    f_irjntixv();\n    f_tgmkaqup();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_umksfbiy();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401854,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_10.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _A_namespace\n{\n\n\nvoid f_rnjudukk()\n{\n    TwoIntsClass * data;\n    if(globalTrue)\n    {\n        \n        data = NULL;\n    }\n    if(globalTrue)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rnjudukk();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401855,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_10.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_jydevwjp()\n{\n    TwoIntsClass * data;\n    if(globalFive==5)\n    {\n        \n        data = NULL;\n    }\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_amwbfobj()\n{\n    TwoIntsClass * data;\n    if(globalFive==5)\n    {\n        \n        data = NULL;\n    }\n    if(globalFive==5)\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_fetdfkzt()\n{\n    TwoIntsClass * data;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(globalFive==5)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\nstatic void f_nghjmljb()\n{\n    TwoIntsClass * data;\n    if(globalFive==5)\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(globalFive==5)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\nvoid f_rfjnvosu()\n{\n    f_jydevwjp();\n    f_amwbfobj();\n    f_fetdfkzt();\n    f_nghjmljb();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rfjnvosu();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401856,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_14.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _A_namespace\n{\n\n\nvoid f_tqhistgz()\n{\n    TwoIntsClass * data;\n    if(globalFive==5)\n    {\n        \n        data = NULL;\n    }\n    if(globalFive==5)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_tqhistgz();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401857,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_14.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_pyttsxxw()\n{\n    TwoIntsClass * data;\n    if(globalReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_nvdlgaio()\n{\n    TwoIntsClass * data;\n    if(globalReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(globalReturnsTrue())\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_ujasjnvr()\n{\n    TwoIntsClass * data;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(globalReturnsTrue())\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\nstatic void f_vppalxwt()\n{\n    TwoIntsClass * data;\n    if(globalReturnsTrue())\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(globalReturnsTrue())\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\nvoid f_ffvsuuku()\n{\n    f_pyttsxxw();\n    f_nvdlgaio();\n    f_ujasjnvr();\n    f_vppalxwt();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ffvsuuku();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401858,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_11.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _A_namespace\n{\n\n\nvoid f_lcopmowo()\n{\n    TwoIntsClass * data;\n    if(globalReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(globalReturnsTrue())\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_lcopmowo();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401859,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_11.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_shxpabtv()\n{\n    TwoIntsClass * data;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_xxvyrkna()\n{\n    TwoIntsClass * data;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_jalikazf()\n{\n    TwoIntsClass * data;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\nstatic void f_pkfgucvk()\n{\n    TwoIntsClass * data;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            TwoIntsClass * tmpData = new TwoIntsClass;\n            tmpData->intOne = 0;\n            tmpData->intTwo = 0;\n            \n            data = tmpData;\n        }\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\nvoid f_bzebouvl()\n{\n    f_shxpabtv();\n    f_xxvyrkna();\n    f_jalikazf();\n    f_pkfgucvk();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_bzebouvl();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401860,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_13.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _A_namespace\n{\n\n\nvoid f_jrazgpci()\n{\n    TwoIntsClass * data;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_jrazgpci();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401861,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_13.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\n\n\nstatic void f_hwelsise()\n{\n    int64_t * data;\n    if(staticReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printLongLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_owkollcb()\n{\n    int64_t * data;\n    if(staticReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        if (data != NULL)\n        {\n            printLongLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_qdhrlclw()\n{\n    int64_t * data;\n    int64_t tmpData = 5LL;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printLongLongLine(*data);\n    }\n}\n\n\nstatic void f_nkxslkmt()\n{\n    int64_t * data;\n    int64_t tmpData = 5LL;\n    if(staticReturnsTrue())\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printLongLongLine(*data);\n    }\n}\n\nvoid f_sylbaper()\n{\n    f_hwelsise();\n    f_owkollcb();\n    f_qdhrlclw();\n    f_nkxslkmt();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_sylbaper();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401862,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int64_t_08.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\nvoid f_mshpyrjg()\n{\n    int64_t * data;\n    if(staticReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printLongLongLine(*data);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_mshpyrjg();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401863,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int64_t_08.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\n\n\nstatic void f_kbrdacug()\n{\n    long * data;\n    if(staticReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_plrsalny()\n{\n    long * data;\n    if(staticReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        if (data != NULL)\n        {\n            printLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_rnxmflid()\n{\n    long * data;\n    long tmpData = 5L;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printLongLine(*data);\n    }\n}\n\n\nstatic void f_zzpiguye()\n{\n    long * data;\n    long tmpData = 5L;\n    if(staticReturnsTrue())\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printLongLine(*data);\n    }\n}\n\nvoid f_nbmsvwtx()\n{\n    f_kbrdacug();\n    f_plrsalny();\n    f_rnxmflid();\n    f_zzpiguye();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nbmsvwtx();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401864,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__long_08.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\nvoid f_cghcvfey()\n{\n    long * data;\n    if(staticReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printLongLine(*data);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_cghcvfey();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401865,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__long_08.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\n\n\nstatic void f_ufiaxbxe()\n{\n    int * data;\n    if(staticReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_iiwpukqp()\n{\n    int * data;\n    if(staticReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_qneejnbp()\n{\n    int * data;\n    int tmpData = 5;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printIntLine(*data);\n    }\n}\n\n\nstatic void f_nmusicel()\n{\n    int * data;\n    int tmpData = 5;\n    if(staticReturnsTrue())\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printIntLine(*data);\n    }\n}\n\nvoid f_iqwiavhd()\n{\n    f_ufiaxbxe();\n    f_iiwpukqp();\n    f_qneejnbp();\n    f_nmusicel();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_iqwiavhd();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401866,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int_08.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\nvoid f_toftdvhs()\n{\n    int * data;\n    if(staticReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        printIntLine(*data);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_toftdvhs();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401867,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int_08.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\n\n\nstatic void f_phprpgci()\n{\n    char * data;\n    if(staticReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            \n            printHexCharLine(data[0]);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_kihzhpdz()\n{\n    char * data;\n    if(staticReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        if (data != NULL)\n        {\n            \n            printHexCharLine(data[0]);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_bbjztmkg()\n{\n    char * data;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = \"\";\n    }\n    if(staticReturnsTrue())\n    {\n        \n        \n        printHexCharLine(data[0]);\n    }\n}\n\n\nstatic void f_xijwzdux()\n{\n    char * data;\n    if(staticReturnsTrue())\n    {\n        \n        data = \"\";\n    }\n    if(staticReturnsTrue())\n    {\n        \n        \n        printHexCharLine(data[0]);\n    }\n}\n\nvoid f_uvcyousj()\n{\n    f_phprpgci();\n    f_kihzhpdz();\n    f_bbjztmkg();\n    f_xijwzdux();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_uvcyousj();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401868,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__char_08.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\nvoid f_kkrlkyax()\n{\n    char * data;\n    if(staticReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        \n        printHexCharLine(data[0]);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_kkrlkyax();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401869,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__char_08.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\n\n\nstatic void f_ixmxnkid()\n{\n    wchar_t * data;\n    if(staticReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            \n            printWcharLine(data[0]);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_eexgzopr()\n{\n    wchar_t * data;\n    if(staticReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        if (data != NULL)\n        {\n            \n            printWcharLine(data[0]);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_nwtsgxny()\n{\n    wchar_t * data;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = L\"\";\n    }\n    if(staticReturnsTrue())\n    {\n        \n        \n        printWcharLine(data[0]);\n    }\n}\n\n\nstatic void f_aqpmodwd()\n{\n    wchar_t * data;\n    if(staticReturnsTrue())\n    {\n        \n        data = L\"\";\n    }\n    if(staticReturnsTrue())\n    {\n        \n        \n        printWcharLine(data[0]);\n    }\n}\n\nvoid f_cquktroa()\n{\n    f_ixmxnkid();\n    f_eexgzopr();\n    f_nwtsgxny();\n    f_aqpmodwd();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_cquktroa();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401870,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__wchar_t_08.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\nvoid f_dtcscaex()\n{\n    wchar_t * data;\n    if(staticReturnsTrue())\n    {\n        \n        data = NULL;\n    }\n    if(staticReturnsTrue())\n    {\n        \n        \n        printWcharLine(data[0]);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_dtcscaex();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401871,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__wchar_t_08.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\n\n\nstatic void f_zkhtljgh()\n{\n    twoIntsStruct * data;\n    if(staticTrue)\n    {\n        \n        data = NULL;\n    }\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_ppdnsbwt()\n{\n    twoIntsStruct * data;\n    if(staticTrue)\n    {\n        \n        data = NULL;\n    }\n    if(staticTrue)\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_rpqzfwav()\n{\n    twoIntsStruct * data;\n    twoIntsStruct tmpData;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        {\n            tmpData.intOne = 0;\n            tmpData.intTwo = 0;\n            data = &tmpData;\n        }\n    }\n    if(staticTrue)\n    {\n        \n        printIntLine(data->intOne);\n    }\n}\n\n\nstatic void f_chesvkmu()\n{\n    twoIntsStruct * data;\n    twoIntsStruct tmpData;\n    if(staticTrue)\n    {\n        \n        {\n            tmpData.intOne = 0;\n            tmpData.intTwo = 0;\n            data = &tmpData;\n        }\n    }\n    if(staticTrue)\n    {\n        \n        printIntLine(data->intOne);\n    }\n}\n\nvoid f_sreodgfi()\n{\n    f_zkhtljgh();\n    f_ppdnsbwt();\n    f_rpqzfwav();\n    f_chesvkmu();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_sreodgfi();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401872,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__struct_05.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\nvoid f_izytwcxx()\n{\n    twoIntsStruct * data;\n    if(staticTrue)\n    {\n        \n        data = NULL;\n    }\n    if(staticTrue)\n    {\n        \n        printIntLine(data->intOne);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_izytwcxx();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401873,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__struct_05.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\n\n\nstatic void f_otruecro()\n{\n    twoIntsStruct * data;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_yckamyrr()\n{\n    twoIntsStruct * data;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_cwbzeexd()\n{\n    twoIntsStruct * data;\n    twoIntsStruct tmpData;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        {\n            tmpData.intOne = 0;\n            tmpData.intTwo = 0;\n            data = &tmpData;\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printIntLine(data->intOne);\n    }\n}\n\n\nstatic void f_ozftqcne()\n{\n    twoIntsStruct * data;\n    twoIntsStruct tmpData;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        {\n            tmpData.intOne = 0;\n            tmpData.intTwo = 0;\n            data = &tmpData;\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printIntLine(data->intOne);\n    }\n}\n\nvoid f_rbtejtzc()\n{\n    f_otruecro();\n    f_yckamyrr();\n    f_cwbzeexd();\n    f_ozftqcne();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rbtejtzc();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401874,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__struct_04.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\nvoid f_uzqjftpc()\n{\n    twoIntsStruct * data;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printIntLine(data->intOne);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_uzqjftpc();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401875,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__struct_04.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\n\n\nstatic void f_rtjlvdxr()\n{\n    twoIntsStruct * data;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_dmcspwcp()\n{\n    twoIntsStruct * data;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_rrlqbgnk()\n{\n    twoIntsStruct * data;\n    twoIntsStruct tmpData;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        {\n            tmpData.intOne = 0;\n            tmpData.intTwo = 0;\n            data = &tmpData;\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printIntLine(data->intOne);\n    }\n}\n\n\nstatic void f_fvqahwuu()\n{\n    twoIntsStruct * data;\n    twoIntsStruct tmpData;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        {\n            tmpData.intOne = 0;\n            tmpData.intTwo = 0;\n            data = &tmpData;\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printIntLine(data->intOne);\n    }\n}\n\nvoid f_cxdbtceo()\n{\n    f_rtjlvdxr();\n    f_dmcspwcp();\n    f_rrlqbgnk();\n    f_fvqahwuu();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_cxdbtceo();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401876,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__struct_06.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\nvoid f_vnqximgp()\n{\n    twoIntsStruct * data;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printIntLine(data->intOne);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_vnqximgp();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401877,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__struct_06.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticFive = 5;\n\n\n\n\nstatic void f_rcflitrg()\n{\n    twoIntsStruct * data;\n    if(staticFive==5)\n    {\n        \n        data = NULL;\n    }\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_lvvebgfg()\n{\n    twoIntsStruct * data;\n    if(staticFive==5)\n    {\n        \n        data = NULL;\n    }\n    if(staticFive==5)\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_jqarerwp()\n{\n    twoIntsStruct * data;\n    twoIntsStruct tmpData;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        {\n            tmpData.intOne = 0;\n            tmpData.intTwo = 0;\n            data = &tmpData;\n        }\n    }\n    if(staticFive==5)\n    {\n        \n        printIntLine(data->intOne);\n    }\n}\n\n\nstatic void f_xrjiwtuc()\n{\n    twoIntsStruct * data;\n    twoIntsStruct tmpData;\n    if(staticFive==5)\n    {\n        \n        {\n            tmpData.intOne = 0;\n            tmpData.intTwo = 0;\n            data = &tmpData;\n        }\n    }\n    if(staticFive==5)\n    {\n        \n        printIntLine(data->intOne);\n    }\n}\n\nvoid f_qlcsrjjo()\n{\n    f_rcflitrg();\n    f_lvvebgfg();\n    f_jqarerwp();\n    f_xrjiwtuc();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qlcsrjjo();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401878,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__struct_07.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticFive = 5;\n\n\nvoid f_ehtrlrwc()\n{\n    twoIntsStruct * data;\n    if(staticFive==5)\n    {\n        \n        data = NULL;\n    }\n    if(staticFive==5)\n    {\n        \n        printIntLine(data->intOne);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ehtrlrwc();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401879,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__struct_07.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic int B2G1Static = 0;\nstatic int B2G2Static = 0;\nstatic int G2bStatic = 0;\n\n\nstatic void f_kxklfdzc(TwoIntsClass * data)\n{\n    if(B2G1Static)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\nstatic void f_zravhknz()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    B2G1Static = 0; \n    f_kxklfdzc(data);\n}\n\n\nstatic void f_xfuvgvrh(TwoIntsClass * data)\n{\n    if(B2G2Static)\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n            delete data;\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\nstatic void f_ikpilmjh()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    B2G2Static = 1; \n    f_xfuvgvrh(data);\n}\n\n\nstatic void f_uqxzoxrg(TwoIntsClass * data)\n{\n    if(G2bStatic)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\nstatic void f_dtuflcol()\n{\n    TwoIntsClass * data;\n    {\n        TwoIntsClass * tmpData = new TwoIntsClass;\n        tmpData->intOne = 0;\n        tmpData->intTwo = 0;\n        \n        data = tmpData;\n    }\n    G2bStatic = 1; \n    f_uqxzoxrg(data);\n}\n\nvoid f_dbyzcvpk()\n{\n    f_zravhknz();\n    f_ikpilmjh();\n    f_dtuflcol();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_dbyzcvpk();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401880,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_21.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _A_namespace\n{\n\n\n\nstatic int Static = 0;\n\nstatic void f_baoheqks(TwoIntsClass * data)\n{\n    if(Static)\n    {\n        \n        printIntLine(data->intOne);\n        \n        delete data;\n    }\n}\n\nvoid f_kdhtrhmv()\n{\n    TwoIntsClass * data;\n    \n    data = NULL;\n    Static = 1; \n    f_baoheqks(data);\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_kdhtrhmv();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401881,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__class_21.cpp",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\n\n\nstatic void f_actxsmgy()\n{\n    int64_t * data;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printLongLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_foordmtu()\n{\n    int64_t * data;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        if (data != NULL)\n        {\n            printLongLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_fhnslxuh()\n{\n    int64_t * data;\n    int64_t tmpData = 5LL;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printLongLongLine(*data);\n    }\n}\n\n\nstatic void f_pdtgkpzw()\n{\n    int64_t * data;\n    int64_t tmpData = 5LL;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printLongLongLine(*data);\n    }\n}\n\nvoid f_rqruuuwl()\n{\n    f_actxsmgy();\n    f_foordmtu();\n    f_fhnslxuh();\n    f_pdtgkpzw();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rqruuuwl();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401882,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int64_t_04.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\nvoid f_ljnccria()\n{\n    int64_t * data;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printLongLongLine(*data);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ljnccria();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401883,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int64_t_04.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\n\n\nstatic void f_lojxqqwh()\n{\n    int * data;\n    if(staticTrue)\n    {\n        \n        data = NULL;\n    }\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_hixuvyzf()\n{\n    int * data;\n    if(staticTrue)\n    {\n        \n        data = NULL;\n    }\n    if(staticTrue)\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_zmgqhnuk()\n{\n    int * data;\n    int tmpData = 5;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(staticTrue)\n    {\n        \n        printIntLine(*data);\n    }\n}\n\n\nstatic void f_gpoyqjqr()\n{\n    int * data;\n    int tmpData = 5;\n    if(staticTrue)\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(staticTrue)\n    {\n        \n        printIntLine(*data);\n    }\n}\n\nvoid f_xtjalaqj()\n{\n    f_lojxqqwh();\n    f_hixuvyzf();\n    f_zmgqhnuk();\n    f_gpoyqjqr();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_xtjalaqj();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401884,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int_05.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\nvoid f_qvocoajd()\n{\n    int * data;\n    if(staticTrue)\n    {\n        \n        data = NULL;\n    }\n    if(staticTrue)\n    {\n        \n        printIntLine(*data);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qvocoajd();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401885,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int_05.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\n\n\nstatic void f_amolnkap()\n{\n    int * data;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_cckyeniu()\n{\n    int * data;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_gaqujpdq()\n{\n    int * data;\n    int tmpData = 5;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printIntLine(*data);\n    }\n}\n\n\nstatic void f_kkvwiwmz()\n{\n    int * data;\n    int tmpData = 5;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printIntLine(*data);\n    }\n}\n\nvoid f_zcamqzqd()\n{\n    f_amolnkap();\n    f_cckyeniu();\n    f_gaqujpdq();\n    f_kkvwiwmz();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_zcamqzqd();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401886,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int_04.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\nvoid f_yumexpxt()\n{\n    int * data;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printIntLine(*data);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_yumexpxt();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401887,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int_04.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\n\n\nstatic void f_srvrsqxs()\n{\n    long * data;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_rpibfyhu()\n{\n    long * data;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        if (data != NULL)\n        {\n            printLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_fccejimj()\n{\n    long * data;\n    long tmpData = 5L;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printLongLine(*data);\n    }\n}\n\n\nstatic void f_uolgfhga()\n{\n    long * data;\n    long tmpData = 5L;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printLongLine(*data);\n    }\n}\n\nvoid f_skqsgggn()\n{\n    f_srvrsqxs();\n    f_rpibfyhu();\n    f_fccejimj();\n    f_uolgfhga();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_skqsgggn();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401888,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__long_04.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\nvoid f_nrxwdjql()\n{\n    long * data;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        printLongLine(*data);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nrxwdjql();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401889,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__long_04.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\n\n\nstatic void f_dntcutcm()\n{\n    long * data;\n    if(staticTrue)\n    {\n        \n        data = NULL;\n    }\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_ptrbuact()\n{\n    long * data;\n    if(staticTrue)\n    {\n        \n        data = NULL;\n    }\n    if(staticTrue)\n    {\n        \n        if (data != NULL)\n        {\n            printLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_tcczqfyz()\n{\n    long * data;\n    long tmpData = 5L;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(staticTrue)\n    {\n        \n        printLongLine(*data);\n    }\n}\n\n\nstatic void f_pgvqrjfp()\n{\n    long * data;\n    long tmpData = 5L;\n    if(staticTrue)\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(staticTrue)\n    {\n        \n        printLongLine(*data);\n    }\n}\n\nvoid f_yyevppiz()\n{\n    f_dntcutcm();\n    f_ptrbuact();\n    f_tcczqfyz();\n    f_pgvqrjfp();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_yyevppiz();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401890,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__long_05.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\nvoid f_anznairl()\n{\n    long * data;\n    if(staticTrue)\n    {\n        \n        data = NULL;\n    }\n    if(staticTrue)\n    {\n        \n        printLongLine(*data);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_anznairl();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401891,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__long_05.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\n\n\nstatic void f_btpggnnt()\n{\n    int64_t * data;\n    if(staticTrue)\n    {\n        \n        data = NULL;\n    }\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printLongLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_hkbklmwf()\n{\n    int64_t * data;\n    if(staticTrue)\n    {\n        \n        data = NULL;\n    }\n    if(staticTrue)\n    {\n        \n        if (data != NULL)\n        {\n            printLongLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_dtsosukr()\n{\n    int64_t * data;\n    int64_t tmpData = 5LL;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(staticTrue)\n    {\n        \n        printLongLongLine(*data);\n    }\n}\n\n\nstatic void f_ttxmlxms()\n{\n    int64_t * data;\n    int64_t tmpData = 5LL;\n    if(staticTrue)\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(staticTrue)\n    {\n        \n        printLongLongLine(*data);\n    }\n}\n\nvoid f_wsgcvndq()\n{\n    f_btpggnnt();\n    f_hkbklmwf();\n    f_dtsosukr();\n    f_ttxmlxms();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wsgcvndq();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401892,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int64_t_05.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\nvoid f_gudvxtps()\n{\n    int64_t * data;\n    if(staticTrue)\n    {\n        \n        data = NULL;\n    }\n    if(staticTrue)\n    {\n        \n        printLongLongLine(*data);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_gudvxtps();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401893,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int64_t_05.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\n\n\nstatic void f_kiuhwvcm()\n{\n    twoIntsStruct * data;\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        data = NULL;\n    }\n    else\n    {\n        \n        data = NULL;\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_mdfkeyvr()\n{\n    twoIntsStruct * data;\n    twoIntsStruct tmpData;\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        {\n            tmpData.intOne = 0;\n            tmpData.intTwo = 0;\n            data = &tmpData;\n        }\n    }\n    else\n    {\n        \n        {\n            tmpData.intOne = 0;\n            tmpData.intTwo = 0;\n            data = &tmpData;\n        }\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        printIntLine(data->intOne);\n    }\n    else\n    {\n        \n        printIntLine(data->intOne);\n    }\n}\n\nvoid f_esuahbre()\n{\n    f_kiuhwvcm();\n    f_mdfkeyvr();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_esuahbre();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401894,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__struct_12.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nvoid f_kroowzcg()\n{\n    twoIntsStruct * data;\n    twoIntsStruct tmpData;\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        data = NULL;\n    }\n    else\n    {\n        \n        {\n            tmpData.intOne = 0;\n            tmpData.intTwo = 0;\n            data = &tmpData;\n        }\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        printIntLine(data->intOne);\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_kroowzcg();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401895,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__struct_12.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\n\n\nstatic void f_nmdmkinu()\n{\n    wchar_t * data;\n    if(staticTrue)\n    {\n        \n        data = NULL;\n    }\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            \n            printWcharLine(data[0]);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_limjowke()\n{\n    wchar_t * data;\n    if(staticTrue)\n    {\n        \n        data = NULL;\n    }\n    if(staticTrue)\n    {\n        \n        if (data != NULL)\n        {\n            \n            printWcharLine(data[0]);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_menaradz()\n{\n    wchar_t * data;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = L\"\";\n    }\n    if(staticTrue)\n    {\n        \n        \n        printWcharLine(data[0]);\n    }\n}\n\n\nstatic void f_culkxqng()\n{\n    wchar_t * data;\n    if(staticTrue)\n    {\n        \n        data = L\"\";\n    }\n    if(staticTrue)\n    {\n        \n        \n        printWcharLine(data[0]);\n    }\n}\n\nvoid f_qxixfurp()\n{\n    f_nmdmkinu();\n    f_limjowke();\n    f_menaradz();\n    f_culkxqng();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qxixfurp();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401896,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__wchar_t_05.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\nvoid f_gdxrscbf()\n{\n    wchar_t * data;\n    if(staticTrue)\n    {\n        \n        data = NULL;\n    }\n    if(staticTrue)\n    {\n        \n        \n        printWcharLine(data[0]);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_gdxrscbf();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401897,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__wchar_t_05.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\n\n\nstatic void f_hmtduwvy()\n{\n    int * data;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_rvyjvxnt()\n{\n    int * data;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_zhwomlod()\n{\n    int * data;\n    int tmpData = 5;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printIntLine(*data);\n    }\n}\n\n\nstatic void f_qohmzwdt()\n{\n    int * data;\n    int tmpData = 5;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printIntLine(*data);\n    }\n}\n\nvoid f_risktwqn()\n{\n    f_hmtduwvy();\n    f_rvyjvxnt();\n    f_zhwomlod();\n    f_qohmzwdt();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_risktwqn();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401898,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int_06.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\nvoid f_knbamykn()\n{\n    int * data;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printIntLine(*data);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_knbamykn();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401899,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int_06.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\n\n\nstatic void f_tbujsfpa()\n{\n    char * data;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            \n            printHexCharLine(data[0]);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_nklmyaqy()\n{\n    char * data;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        if (data != NULL)\n        {\n            \n            printHexCharLine(data[0]);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_mjxhiskl()\n{\n    char * data;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = \"\";\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        \n        printHexCharLine(data[0]);\n    }\n}\n\n\nstatic void f_yekthize()\n{\n    char * data;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = \"\";\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        \n        printHexCharLine(data[0]);\n    }\n}\n\nvoid f_btiaenfo()\n{\n    f_tbujsfpa();\n    f_nklmyaqy();\n    f_mjxhiskl();\n    f_yekthize();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_btiaenfo();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401900,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__char_04.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\nvoid f_esshbium()\n{\n    char * data;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        \n        printHexCharLine(data[0]);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_esshbium();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401901,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__char_04.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\n\n\nstatic void f_woqlrpsz()\n{\n    char * data;\n    if(staticTrue)\n    {\n        \n        data = NULL;\n    }\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            \n            printHexCharLine(data[0]);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_kelxxkkd()\n{\n    char * data;\n    if(staticTrue)\n    {\n        \n        data = NULL;\n    }\n    if(staticTrue)\n    {\n        \n        if (data != NULL)\n        {\n            \n            printHexCharLine(data[0]);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_segxuxuv()\n{\n    char * data;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = \"\";\n    }\n    if(staticTrue)\n    {\n        \n        \n        printHexCharLine(data[0]);\n    }\n}\n\n\nstatic void f_osbccfxe()\n{\n    char * data;\n    if(staticTrue)\n    {\n        \n        data = \"\";\n    }\n    if(staticTrue)\n    {\n        \n        \n        printHexCharLine(data[0]);\n    }\n}\n\nvoid f_sqzkhapj()\n{\n    f_woqlrpsz();\n    f_kelxxkkd();\n    f_segxuxuv();\n    f_osbccfxe();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_sqzkhapj();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401902,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__char_05.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\nvoid f_kxujltlz()\n{\n    char * data;\n    if(staticTrue)\n    {\n        \n        data = NULL;\n    }\n    if(staticTrue)\n    {\n        \n        \n        printHexCharLine(data[0]);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_kxujltlz();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401903,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__char_05.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticFive = 5;\n\n\n\n\nstatic void f_xsxhzfwt()\n{\n    long * data;\n    if(staticFive==5)\n    {\n        \n        data = NULL;\n    }\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_mwdkupkx()\n{\n    long * data;\n    if(staticFive==5)\n    {\n        \n        data = NULL;\n    }\n    if(staticFive==5)\n    {\n        \n        if (data != NULL)\n        {\n            printLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_ptdumzuq()\n{\n    long * data;\n    long tmpData = 5L;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(staticFive==5)\n    {\n        \n        printLongLine(*data);\n    }\n}\n\n\nstatic void f_opxtvhyn()\n{\n    long * data;\n    long tmpData = 5L;\n    if(staticFive==5)\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(staticFive==5)\n    {\n        \n        printLongLine(*data);\n    }\n}\n\nvoid f_mklaxyeo()\n{\n    f_xsxhzfwt();\n    f_mwdkupkx();\n    f_ptdumzuq();\n    f_opxtvhyn();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_mklaxyeo();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401904,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__long_07.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticFive = 5;\n\n\nvoid f_ytmvzoov()\n{\n    long * data;\n    if(staticFive==5)\n    {\n        \n        data = NULL;\n    }\n    if(staticFive==5)\n    {\n        \n        printLongLine(*data);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ytmvzoov();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401905,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__long_07.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticFive = 5;\n\n\n\n\nstatic void f_nysprkge()\n{\n    int * data;\n    if(staticFive==5)\n    {\n        \n        data = NULL;\n    }\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_jgskejag()\n{\n    int * data;\n    if(staticFive==5)\n    {\n        \n        data = NULL;\n    }\n    if(staticFive==5)\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_nokuvjyk()\n{\n    int * data;\n    int tmpData = 5;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(staticFive==5)\n    {\n        \n        printIntLine(*data);\n    }\n}\n\n\nstatic void f_zcfjocxb()\n{\n    int * data;\n    int tmpData = 5;\n    if(staticFive==5)\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(staticFive==5)\n    {\n        \n        printIntLine(*data);\n    }\n}\n\nvoid f_rzxyxveh()\n{\n    f_nysprkge();\n    f_jgskejag();\n    f_nokuvjyk();\n    f_zcfjocxb();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rzxyxveh();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401906,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int_07.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticFive = 5;\n\n\nvoid f_umrxpurb()\n{\n    int * data;\n    if(staticFive==5)\n    {\n        \n        data = NULL;\n    }\n    if(staticFive==5)\n    {\n        \n        printIntLine(*data);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_umrxpurb();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401907,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int_07.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\n\n\nstatic void f_paurfxlj()\n{\n    long * data;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_jfstbqtc()\n{\n    long * data;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        if (data != NULL)\n        {\n            printLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_nwrdkyuy()\n{\n    long * data;\n    long tmpData = 5L;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printLongLine(*data);\n    }\n}\n\n\nstatic void f_gjesrjpc()\n{\n    long * data;\n    long tmpData = 5L;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printLongLine(*data);\n    }\n}\n\nvoid f_fkyjqdvy()\n{\n    f_paurfxlj();\n    f_jfstbqtc();\n    f_nwrdkyuy();\n    f_gjesrjpc();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_fkyjqdvy();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401908,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__long_06.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\nvoid f_bvtlpuda()\n{\n    long * data;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printLongLine(*data);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_bvtlpuda();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401909,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__long_06.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\n\n\nstatic void f_ttwxrhfh()\n{\n    int64_t * data;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printLongLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_cahtemcw()\n{\n    int64_t * data;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        if (data != NULL)\n        {\n            printLongLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_xfuttwxl()\n{\n    int64_t * data;\n    int64_t tmpData = 5LL;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printLongLongLine(*data);\n    }\n}\n\n\nstatic void f_hctshhlp()\n{\n    int64_t * data;\n    int64_t tmpData = 5LL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printLongLongLine(*data);\n    }\n}\n\nvoid f_minbfsak()\n{\n    f_ttwxrhfh();\n    f_cahtemcw();\n    f_xfuttwxl();\n    f_hctshhlp();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_minbfsak();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401910,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int64_t_06.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\nvoid f_lnfmyunj()\n{\n    int64_t * data;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        printLongLongLine(*data);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_lnfmyunj();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401911,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int64_t_06.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticFive = 5;\n\n\n\n\nstatic void f_joynnvyf()\n{\n    int64_t * data;\n    if(staticFive==5)\n    {\n        \n        data = NULL;\n    }\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printLongLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_eitehpfk()\n{\n    int64_t * data;\n    if(staticFive==5)\n    {\n        \n        data = NULL;\n    }\n    if(staticFive==5)\n    {\n        \n        if (data != NULL)\n        {\n            printLongLongLine(*data);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_fnespgec()\n{\n    int64_t * data;\n    int64_t tmpData = 5LL;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(staticFive==5)\n    {\n        \n        printLongLongLine(*data);\n    }\n}\n\n\nstatic void f_rzhclicv()\n{\n    int64_t * data;\n    int64_t tmpData = 5LL;\n    if(staticFive==5)\n    {\n        \n        {\n            data = &tmpData;\n        }\n    }\n    if(staticFive==5)\n    {\n        \n        printLongLongLine(*data);\n    }\n}\n\nvoid f_tnmvwmao()\n{\n    f_joynnvyf();\n    f_eitehpfk();\n    f_fnespgec();\n    f_rzhclicv();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_tnmvwmao();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401912,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int64_t_07.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic int staticFive = 5;\n\n\nvoid f_tccizjlg()\n{\n    int64_t * data;\n    if(staticFive==5)\n    {\n        \n        data = NULL;\n    }\n    if(staticFive==5)\n    {\n        \n        printLongLongLine(*data);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_tccizjlg();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401913,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__int64_t_07.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\n\n\nstatic void f_jcmgonak()\n{\n    wchar_t * data;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            \n            printWcharLine(data[0]);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_tpjtcaik()\n{\n    wchar_t * data;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        if (data != NULL)\n        {\n            \n            printWcharLine(data[0]);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_umsghirc()\n{\n    wchar_t * data;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = L\"\";\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        \n        printWcharLine(data[0]);\n    }\n}\n\n\nstatic void f_jfghnupt()\n{\n    wchar_t * data;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = L\"\";\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        \n        printWcharLine(data[0]);\n    }\n}\n\nvoid f_szdoorhr()\n{\n    f_jcmgonak();\n    f_tpjtcaik();\n    f_umsghirc();\n    f_jfghnupt();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_szdoorhr();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401914,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__wchar_t_04.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\nvoid f_pvxydgnf()\n{\n    wchar_t * data;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        \n        \n        printWcharLine(data[0]);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_pvxydgnf();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401915,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__wchar_t_04.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\n\n\nstatic void f_akyvjkxu()\n{\n    twoIntsStruct * data;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_xwksvchb()\n{\n    twoIntsStruct * data;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        if (data != NULL)\n        {\n            printIntLine(data->intOne);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_tbumkizj()\n{\n    twoIntsStruct * data;\n    twoIntsStruct tmpData;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        {\n            tmpData.intOne = 0;\n            tmpData.intTwo = 0;\n            data = &tmpData;\n        }\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        printIntLine(data->intOne);\n    }\n}\n\n\nstatic void f_aftfndhd()\n{\n    twoIntsStruct * data;\n    twoIntsStruct tmpData;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        {\n            tmpData.intOne = 0;\n            tmpData.intTwo = 0;\n            data = &tmpData;\n        }\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        printIntLine(data->intOne);\n    }\n}\n\nvoid f_ryxuoxew()\n{\n    f_akyvjkxu();\n    f_xwksvchb();\n    f_tbumkizj();\n    f_aftfndhd();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ryxuoxew();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401916,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__struct_13.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nvoid f_lyyxnqlz()\n{\n    twoIntsStruct * data;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        printIntLine(data->intOne);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_lyyxnqlz();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401917,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__struct_13.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\n\n\nstatic void f_oqbzpucl()\n{\n    char * data;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        if (data != NULL)\n        {\n            \n            printHexCharLine(data[0]);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_jyipxokm()\n{\n    char * data;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        if (data != NULL)\n        {\n            \n            printHexCharLine(data[0]);\n        }\n        else\n        {\n            printLine(\"data is NULL\");\n        }\n    }\n}\n\n\nstatic void f_hcokzrru()\n{\n    char * data;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        data = \"\";\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        \n        printHexCharLine(data[0]);\n    }\n}\n\n\nstatic void f_njvrfwgl()\n{\n    char * data;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = \"\";\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        \n        printHexCharLine(data[0]);\n    }\n}\n\nvoid f_zgysqppr()\n{\n    f_oqbzpucl();\n    f_jyipxokm();\n    f_hcokzrru();\n    f_njvrfwgl();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_zgysqppr();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401918,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__char_06.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\nvoid f_scrmhbnu()\n{\n    char * data;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        data = NULL;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        \n        printHexCharLine(data[0]);\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_scrmhbnu();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401919,
    "original_file": "testcases/CWE476_NULL_Pointer_Dereference/CWE476_NULL_Pointer_Dereference__char_06.c",
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tPurpleXfer *xfer = data;\n\tstruct im_connection *ic = purple_ic_by_pa(xfer->account);\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\tPurpleBuddy *buddy;\n\tconst char *who;\n\n\tbuddy = purple_find_buddy(xfer->account, xfer->who);\n\twho = buddy ? purple_buddy_get_name(buddy) : xfer->who;\n\n\t/* TODO(wilmer): After spreading some more const goodness in BitlBee,\n\t   remove the evil cast below. */\n\tpx->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);\n\tpx->ft->data = px;\n\n\tpx->ft->accept = prpl_xfer_accept;\n\tpx->ft->canceled = prpl_xfer_canceled;\n\tpx->ft->free = prpl_xfer_free;\n\tpx->ft->write_request = prpl_xfer_write_request;\n\n\treturn FALSE;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149616,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tPurpleXfer *xfer = data;\n\tstruct im_connection *ic = purple_ic_by_pa(xfer->account);\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\tPurpleBuddy *buddy;\n\tconst char *who;\n\n\tbuddy = purple_find_buddy(xfer->account, xfer->who);\n\twho = buddy ? purple_buddy_get_name(buddy) : xfer->who;\n\n\t/* TODO(wilmer): After spreading some more const goodness in BitlBee,\n\t   remove the evil cast below. */\n\tpx->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);\n\n\tif (!px->ft) {\n\t\treturn FALSE;\n\t}\n\tpx->ft->data = px;\n\n\tpx->ft->accept = prpl_xfer_accept;\n\tpx->ft->canceled = prpl_xfer_canceled;\n\tpx->ft->free = prpl_xfer_free;\n\tpx->ft->write_request = prpl_xfer_write_request;\n\n\treturn FALSE;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149617,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int changedline (const Proto *p, int oldpc, int newpc) {\n  while (oldpc++ < newpc) {\n    if (p->lineinfo[oldpc] != 0)\n      return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));\n  }\n  return 0;  /* no line changes in the way */\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149618,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int changedline (const Proto *p, int oldpc, int newpc) {\n  if (p->lineinfo == NULL)  /* no debug information? */\n    return 0;\n  while (oldpc++ < newpc) {\n    if (p->lineinfo[oldpc] != 0)\n      return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));\n  }\n  return 0;  /* no line changes between positions */\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149619,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static ExprList *exprListAppendList(\n  Parse *pParse,          /* Parsing context */\n  ExprList *pList,        /* List to which to append. Might be NULL */\n  ExprList *pAppend,      /* List of values to append. Might be NULL */\n  int bIntToNull\n){\n  if( pAppend ){\n    int i;\n    int nInit = pList ? pList->nExpr : 0;\n    for(i=0; i<pAppend->nExpr; i++){\n      Expr *pDup = sqlite3ExprDup(pParse->db, pAppend->a[i].pExpr, 0);\n      if( bIntToNull && pDup && pDup->op==TK_INTEGER ){\n        pDup->op = TK_NULL;\n        pDup->flags &= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);\n      }\n      pList = sqlite3ExprListAppend(pParse, pList, pDup);\n      if( pList ) pList->a[nInit+i].sortFlags = pAppend->a[i].sortFlags;\n    }\n  }\n  return pList;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149620,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static ExprList *exprListAppendList(\n  Parse *pParse,          /* Parsing context */\n  ExprList *pList,        /* List to which to append. Might be NULL */\n  ExprList *pAppend,      /* List of values to append. Might be NULL */\n  int bIntToNull\n){\n  if( pAppend ){\n    int i;\n    int nInit = pList ? pList->nExpr : 0;\n    for(i=0; i<pAppend->nExpr; i++){\n      Expr *pDup = sqlite3ExprDup(pParse->db, pAppend->a[i].pExpr, 0);\n      assert( pDup==0 || !ExprHasProperty(pDup, EP_MemToken) );\n      if( bIntToNull && pDup && pDup->op==TK_INTEGER ){\n        pDup->op = TK_NULL;\n        pDup->flags &= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);\n        pDup->u.zToken = 0;\n      }\n      pList = sqlite3ExprListAppend(pParse, pList, pDup);\n      if( pList ) pList->a[nInit+i].sortFlags = pAppend->a[i].sortFlags;\n    }\n  }\n  return pList;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149621,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct rtmsg *rtm;\n\tstruct nlattr *tb[RTA_MAX+1];\n\tstruct fib_result res = {};\n\tstruct rtable *rt = NULL;\n\tstruct flowi4 fl4;\n\t__be32 dst = 0;\n\t__be32 src = 0;\n\tu32 iif;\n\tint err;\n\tint mark;\n\tstruct sk_buff *skb;\n\tu32 table_id = RT_TABLE_MAIN;\n\tkuid_t uid;\n\n\terr = nlmsg_parse(nlh, sizeof(*rtm), tb, RTA_MAX, rtm_ipv4_policy,\n\t\t\t  extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\trtm = nlmsg_data(nlh);\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb) {\n\t\terr = -ENOBUFS;\n\t\tgoto errout;\n\t}\n\n\t/* Reserve room for dummy headers, this skb can pass\n\t   through good chunk of routing engine.\n\t */\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\n\tsrc = tb[RTA_SRC] ? nla_get_in_addr(tb[RTA_SRC]) : 0;\n\tdst = tb[RTA_DST] ? nla_get_in_addr(tb[RTA_DST]) : 0;\n\tiif = tb[RTA_IIF] ? nla_get_u32(tb[RTA_IIF]) : 0;\n\tmark = tb[RTA_MARK] ? nla_get_u32(tb[RTA_MARK]) : 0;\n\tif (tb[RTA_UID])\n\t\tuid = make_kuid(current_user_ns(), nla_get_u32(tb[RTA_UID]));\n\telse\n\t\tuid = (iif ? INVALID_UID : current_uid());\n\n\t/* Bugfix: need to give ip_route_input enough of an IP header to\n\t * not gag.\n\t */\n\tip_hdr(skb)->protocol = IPPROTO_UDP;\n\tip_hdr(skb)->saddr = src;\n\tip_hdr(skb)->daddr = dst;\n\n\tskb_reserve(skb, MAX_HEADER + sizeof(struct iphdr));\n\n\tmemset(&fl4, 0, sizeof(fl4));\n\tfl4.daddr = dst;\n\tfl4.saddr = src;\n\tfl4.flowi4_tos = rtm->rtm_tos;\n\tfl4.flowi4_oif = tb[RTA_OIF] ? nla_get_u32(tb[RTA_OIF]) : 0;\n\tfl4.flowi4_mark = mark;\n\tfl4.flowi4_uid = uid;\n\n\trcu_read_lock();\n\n\tif (iif) {\n\t\tstruct net_device *dev;\n\n\t\tdev = dev_get_by_index_rcu(net, iif);\n\t\tif (!dev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto errout_free;\n\t\t}\n\n\t\tskb->protocol\t= htons(ETH_P_IP);\n\t\tskb->dev\t= dev;\n\t\tskb->mark\t= mark;\n\t\terr = ip_route_input_rcu(skb, dst, src, rtm->rtm_tos,\n\t\t\t\t\t dev, &res);\n\n\t\trt = skb_rtable(skb);\n\t\tif (err == 0 && rt->dst.error)\n\t\t\terr = -rt->dst.error;\n\t} else {\n\t\trt = ip_route_output_key_hash_rcu(net, &fl4, &res, skb);\n\t\terr = 0;\n\t\tif (IS_ERR(rt))\n\t\t\terr = PTR_ERR(rt);\n\t\telse\n\t\t\tskb_dst_set(skb, &rt->dst);\n\t}\n\n\tif (err)\n\t\tgoto errout_free;\n\n\tif (rtm->rtm_flags & RTM_F_NOTIFY)\n\t\trt->rt_flags |= RTCF_NOTIFY;\n\n\tif (rtm->rtm_flags & RTM_F_LOOKUP_TABLE)\n\t\ttable_id = rt->rt_table_id;\n\n\tif (rtm->rtm_flags & RTM_F_FIB_MATCH)\n\t\terr = fib_dump_info(skb, NETLINK_CB(in_skb).portid,\n\t\t\t\t    nlh->nlmsg_seq, RTM_NEWROUTE, table_id,\n\t\t\t\t    rt->rt_type, res.prefix, res.prefixlen,\n\t\t\t\t    fl4.flowi4_tos, res.fi, 0);\n\telse\n\t\terr = rt_fill_info(net, dst, src, table_id, &fl4, skb,\n\t\t\t\t   NETLINK_CB(in_skb).portid, nlh->nlmsg_seq);\n\tif (err < 0)\n\t\tgoto errout_free;\n\n\trcu_read_unlock();\n\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nerrout:\n\treturn err;\n\nerrout_free:\n\trcu_read_unlock();\n\tkfree_skb(skb);\n\tgoto errout;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149622,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct rtmsg *rtm;\n\tstruct nlattr *tb[RTA_MAX+1];\n\tstruct fib_result res = {};\n\tstruct rtable *rt = NULL;\n\tstruct flowi4 fl4;\n\t__be32 dst = 0;\n\t__be32 src = 0;\n\tu32 iif;\n\tint err;\n\tint mark;\n\tstruct sk_buff *skb;\n\tu32 table_id = RT_TABLE_MAIN;\n\tkuid_t uid;\n\n\terr = nlmsg_parse(nlh, sizeof(*rtm), tb, RTA_MAX, rtm_ipv4_policy,\n\t\t\t  extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\trtm = nlmsg_data(nlh);\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb) {\n\t\terr = -ENOBUFS;\n\t\tgoto errout;\n\t}\n\n\t/* Reserve room for dummy headers, this skb can pass\n\t   through good chunk of routing engine.\n\t */\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\n\tsrc = tb[RTA_SRC] ? nla_get_in_addr(tb[RTA_SRC]) : 0;\n\tdst = tb[RTA_DST] ? nla_get_in_addr(tb[RTA_DST]) : 0;\n\tiif = tb[RTA_IIF] ? nla_get_u32(tb[RTA_IIF]) : 0;\n\tmark = tb[RTA_MARK] ? nla_get_u32(tb[RTA_MARK]) : 0;\n\tif (tb[RTA_UID])\n\t\tuid = make_kuid(current_user_ns(), nla_get_u32(tb[RTA_UID]));\n\telse\n\t\tuid = (iif ? INVALID_UID : current_uid());\n\n\t/* Bugfix: need to give ip_route_input enough of an IP header to\n\t * not gag.\n\t */\n\tip_hdr(skb)->protocol = IPPROTO_UDP;\n\tip_hdr(skb)->saddr = src;\n\tip_hdr(skb)->daddr = dst;\n\n\tskb_reserve(skb, MAX_HEADER + sizeof(struct iphdr));\n\n\tmemset(&fl4, 0, sizeof(fl4));\n\tfl4.daddr = dst;\n\tfl4.saddr = src;\n\tfl4.flowi4_tos = rtm->rtm_tos;\n\tfl4.flowi4_oif = tb[RTA_OIF] ? nla_get_u32(tb[RTA_OIF]) : 0;\n\tfl4.flowi4_mark = mark;\n\tfl4.flowi4_uid = uid;\n\n\trcu_read_lock();\n\n\tif (iif) {\n\t\tstruct net_device *dev;\n\n\t\tdev = dev_get_by_index_rcu(net, iif);\n\t\tif (!dev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto errout_free;\n\t\t}\n\n\t\tskb->protocol\t= htons(ETH_P_IP);\n\t\tskb->dev\t= dev;\n\t\tskb->mark\t= mark;\n\t\terr = ip_route_input_rcu(skb, dst, src, rtm->rtm_tos,\n\t\t\t\t\t dev, &res);\n\n\t\trt = skb_rtable(skb);\n\t\tif (err == 0 && rt->dst.error)\n\t\t\terr = -rt->dst.error;\n\t} else {\n\t\trt = ip_route_output_key_hash_rcu(net, &fl4, &res, skb);\n\t\terr = 0;\n\t\tif (IS_ERR(rt))\n\t\t\terr = PTR_ERR(rt);\n\t\telse\n\t\t\tskb_dst_set(skb, &rt->dst);\n\t}\n\n\tif (err)\n\t\tgoto errout_free;\n\n\tif (rtm->rtm_flags & RTM_F_NOTIFY)\n\t\trt->rt_flags |= RTCF_NOTIFY;\n\n\tif (rtm->rtm_flags & RTM_F_LOOKUP_TABLE)\n\t\ttable_id = rt->rt_table_id;\n\n\tif (rtm->rtm_flags & RTM_F_FIB_MATCH) {\n\t\tif (!res.fi) {\n\t\t\terr = fib_props[res.type].error;\n\t\t\tif (!err)\n\t\t\t\terr = -EHOSTUNREACH;\n\t\t\tgoto errout_free;\n\t\t}\n\t\terr = fib_dump_info(skb, NETLINK_CB(in_skb).portid,\n\t\t\t\t    nlh->nlmsg_seq, RTM_NEWROUTE, table_id,\n\t\t\t\t    rt->rt_type, res.prefix, res.prefixlen,\n\t\t\t\t    fl4.flowi4_tos, res.fi, 0);\n\t} else {\n\t\terr = rt_fill_info(net, dst, src, table_id, &fl4, skb,\n\t\t\t\t   NETLINK_CB(in_skb).portid, nlh->nlmsg_seq);\n\t}\n\tif (err < 0)\n\t\tgoto errout_free;\n\n\trcu_read_unlock();\n\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nerrout:\n\treturn err;\n\nerrout_free:\n\trcu_read_unlock();\n\tkfree_skb(skb);\n\tgoto errout;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149623,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "LookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,\n              enum expr_value_type type, xkb_mod_mask_t *val_rtrn)\n{\n    const char *str;\n    xkb_mod_index_t ndx;\n    const LookupModMaskPriv *arg = priv;\n    const struct xkb_mod_set *mods = arg->mods;\n    enum mod_type mod_type = arg->mod_type;\n\n    if (type != EXPR_TYPE_INT)\n        return false;\n\n    str = xkb_atom_text(ctx, field);\n\n    if (istreq(str, \"all\")) {\n        *val_rtrn  = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n    if (istreq(str, \"none\")) {\n        *val_rtrn = 0;\n        return true;\n    }\n\n    ndx = XkbModNameToIndex(mods, field, mod_type);\n    if (ndx == XKB_MOD_INVALID)\n        return false;\n\n    *val_rtrn = (1u << ndx);\n    return true;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149624,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "LookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,\n              enum expr_value_type type, xkb_mod_mask_t *val_rtrn)\n{\n    const char *str;\n    xkb_mod_index_t ndx;\n    const LookupModMaskPriv *arg = priv;\n    const struct xkb_mod_set *mods = arg->mods;\n    enum mod_type mod_type = arg->mod_type;\n\n    if (type != EXPR_TYPE_INT)\n        return false;\n\n    str = xkb_atom_text(ctx, field);\n    if (!str)\n        return false;\n\n    if (istreq(str, \"all\")) {\n        *val_rtrn  = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n    if (istreq(str, \"none\")) {\n        *val_rtrn = 0;\n        return true;\n    }\n\n    ndx = XkbModNameToIndex(mods, field, mod_type);\n    if (ndx == XKB_MOD_INVALID)\n        return false;\n\n    *val_rtrn = (1u << ndx);\n    return true;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149625,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "validate_as_request(kdc_realm_t *kdc_active_realm,\n                    register krb5_kdc_req *request, krb5_db_entry client,\n                    krb5_db_entry server, krb5_timestamp kdc_time,\n                    const char **status, krb5_pa_data ***e_data)\n{\n    int errcode;\n    krb5_error_code ret;\n\n    /*\n     * If an option is set that is only allowed in TGS requests, complain.\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KDC_ERR_BADOPTION;\n    }\n\n    /* The client must not be expired */\n    if (client.expiration && client.expiration < kdc_time) {\n        *status = \"CLIENT EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_NAME_EXP);\n    }\n\n    /* The client's password must not be expired, unless the server is\n       a KRB5_KDC_PWCHANGE_SERVICE. */\n    if (client.pw_expiration && client.pw_expiration < kdc_time &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"CLIENT KEY EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_KEY_EXP);\n    }\n\n    /* The server must not be expired */\n    if (server.expiration && server.expiration < kdc_time) {\n        *status = \"SERVICE EXPIRED\";\n        return(KDC_ERR_SERVICE_EXP);\n    }\n\n    /*\n     * If the client requires password changing, then only allow the\n     * pwchange service.\n     */\n    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"REQUIRED PWCHANGE\";\n        return(KDC_ERR_KEY_EXP);\n    }\n\n    /* Client and server must allow postdating tickets */\n    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||\n         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {\n        *status = \"POSTDATE NOT ALLOWED\";\n        return(KDC_ERR_CANNOT_POSTDATE);\n    }\n\n    /*\n     * A Windows KDC will return KDC_ERR_PREAUTH_REQUIRED instead of\n     * KDC_ERR_POLICY in the following case:\n     *\n     *   - KDC_OPT_FORWARDABLE is set in KDCOptions but local\n     *     policy has KRB5_KDB_DISALLOW_FORWARDABLE set for the\n     *     client, and;\n     *   - KRB5_KDB_REQUIRES_PRE_AUTH is set for the client but\n     *     preauthentication data is absent in the request.\n     *\n     * Hence, this check most be done after the check for preauth\n     * data, and is now performed by validate_forwardable() (the\n     * contents of which were previously below).\n     */\n\n    /* Client and server must allow proxiable tickets */\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_PROXIABLE) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_PROXIABLE))) {\n        *status = \"PROXIABLE NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Check to see if client is locked out */\n    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"CLIENT LOCKED OUT\";\n        return(KDC_ERR_CLIENT_REVOKED);\n    }\n\n    /* Check to see if server is locked out */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"SERVICE LOCKED OUT\";\n        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);\n    }\n\n    /* Check to see if server is allowed to be a service */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {\n        *status = \"SERVICE NOT ALLOWED\";\n        return(KDC_ERR_MUST_USE_USER2USER);\n    }\n\n    if (check_anon(kdc_active_realm, request->client, request->server) != 0) {\n        *status = \"ANONYMOUS NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Perform KDB module policy checks. */\n    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,\n                                  kdc_time, status, e_data);\n    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)\n        return errcode_to_protocol(ret);\n\n    /* Check against local policy. */\n    errcode = against_local_policy_as(request, client, server,\n                                      kdc_time, status, e_data);\n    if (errcode)\n        return errcode;\n\n    return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149626,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "validate_as_request(kdc_realm_t *kdc_active_realm,\n                    register krb5_kdc_req *request, krb5_db_entry client,\n                    krb5_db_entry server, krb5_timestamp kdc_time,\n                    const char **status, krb5_pa_data ***e_data)\n{\n    int errcode;\n    krb5_error_code ret;\n\n    /*\n     * If an option is set that is only allowed in TGS requests, complain.\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KDC_ERR_BADOPTION;\n    }\n\n    /* The client must not be expired */\n    if (client.expiration && client.expiration < kdc_time) {\n        *status = \"CLIENT EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_NAME_EXP);\n    }\n\n    /* The client's password must not be expired, unless the server is\n       a KRB5_KDC_PWCHANGE_SERVICE. */\n    if (client.pw_expiration && client.pw_expiration < kdc_time &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"CLIENT KEY EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_KEY_EXP);\n    }\n\n    /* The server must not be expired */\n    if (server.expiration && server.expiration < kdc_time) {\n        *status = \"SERVICE EXPIRED\";\n        return(KDC_ERR_SERVICE_EXP);\n    }\n\n    /*\n     * If the client requires password changing, then only allow the\n     * pwchange service.\n     */\n    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"REQUIRED PWCHANGE\";\n        return(KDC_ERR_KEY_EXP);\n    }\n\n    /* Client and server must allow postdating tickets */\n    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||\n         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {\n        *status = \"POSTDATE NOT ALLOWED\";\n        return(KDC_ERR_CANNOT_POSTDATE);\n    }\n\n    /*\n     * A Windows KDC will return KDC_ERR_PREAUTH_REQUIRED instead of\n     * KDC_ERR_POLICY in the following case:\n     *\n     *   - KDC_OPT_FORWARDABLE is set in KDCOptions but local\n     *     policy has KRB5_KDB_DISALLOW_FORWARDABLE set for the\n     *     client, and;\n     *   - KRB5_KDB_REQUIRES_PRE_AUTH is set for the client but\n     *     preauthentication data is absent in the request.\n     *\n     * Hence, this check most be done after the check for preauth\n     * data, and is now performed by validate_forwardable() (the\n     * contents of which were previously below).\n     */\n\n    /* Client and server must allow proxiable tickets */\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_PROXIABLE) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_PROXIABLE))) {\n        *status = \"PROXIABLE NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Check to see if client is locked out */\n    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"CLIENT LOCKED OUT\";\n        return(KDC_ERR_CLIENT_REVOKED);\n    }\n\n    /* Check to see if server is locked out */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"SERVICE LOCKED OUT\";\n        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);\n    }\n\n    /* Check to see if server is allowed to be a service */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {\n        *status = \"SERVICE NOT ALLOWED\";\n        return(KDC_ERR_MUST_USE_USER2USER);\n    }\n\n    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {\n        *status = \"ANONYMOUS NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Perform KDB module policy checks. */\n    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,\n                                  kdc_time, status, e_data);\n    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)\n        return errcode_to_protocol(ret);\n\n    /* Check against local policy. */\n    errcode = against_local_policy_as(request, client, server,\n                                      kdc_time, status, e_data);\n    if (errcode)\n        return errcode;\n\n    return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149627,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n\tint chan = sa->rc_channel;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->rc_bdaddr);\n\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\twrite_lock(&rfcomm_sk_list.lock);\n\n\tif (chan && __rfcomm_get_listen_sock_by_addr(chan, &sa->rc_bdaddr)) {\n\t\terr = -EADDRINUSE;\n\t} else {\n\t\t/* Save source address */\n\t\tbacpy(&rfcomm_pi(sk)->src, &sa->rc_bdaddr);\n\t\trfcomm_pi(sk)->channel = chan;\n\t\tsk->sk_state = BT_BOUND;\n\t}\n\n\twrite_unlock(&rfcomm_sk_list.lock);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149628,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tstruct sockaddr_rc sa;\n\tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tmemset(&sa, 0, sizeof(sa));\n\tlen = min_t(unsigned int, sizeof(sa), addr_len);\n\tmemcpy(&sa, addr, len);\n\n\tBT_DBG(\"sk %p %pMR\", sk, &sa.rc_bdaddr);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\twrite_lock(&rfcomm_sk_list.lock);\n\n\tif (sa.rc_channel &&\n\t    __rfcomm_get_listen_sock_by_addr(sa.rc_channel, &sa.rc_bdaddr)) {\n\t\terr = -EADDRINUSE;\n\t} else {\n\t\t/* Save source address */\n\t\tbacpy(&rfcomm_pi(sk)->src, &sa.rc_bdaddr);\n\t\trfcomm_pi(sk)->channel = sa.rc_channel;\n\t\tsk->sk_state = BT_BOUND;\n\t}\n\n\twrite_unlock(&rfcomm_sk_list.lock);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149629,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)\n{\n\tint r;\n\t/* Assume we're using HV mode when the HV module is loaded */\n\tint hv_enabled = kvmppc_hv_ops ? 1 : 0;\n\n\tif (kvm) {\n\t\t/*\n\t\t * Hooray - we know which VM type we're running on. Depend on\n\t\t * that rather than the guess above.\n\t\t */\n\t\thv_enabled = is_kvmppc_hv_enabled(kvm);\n\t}\n\n\tswitch (ext) {\n#ifdef CONFIG_BOOKE\n\tcase KVM_CAP_PPC_BOOKE_SREGS:\n\tcase KVM_CAP_PPC_BOOKE_WATCHDOG:\n\tcase KVM_CAP_PPC_EPR:\n#else\n\tcase KVM_CAP_PPC_SEGSTATE:\n\tcase KVM_CAP_PPC_HIOR:\n\tcase KVM_CAP_PPC_PAPR:\n#endif\n\tcase KVM_CAP_PPC_UNSET_IRQ:\n\tcase KVM_CAP_PPC_IRQ_LEVEL:\n\tcase KVM_CAP_ENABLE_CAP:\n\tcase KVM_CAP_ENABLE_CAP_VM:\n\tcase KVM_CAP_ONE_REG:\n\tcase KVM_CAP_IOEVENTFD:\n\tcase KVM_CAP_DEVICE_CTRL:\n\tcase KVM_CAP_IMMEDIATE_EXIT:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_PPC_PAIRED_SINGLES:\n\tcase KVM_CAP_PPC_OSI:\n\tcase KVM_CAP_PPC_GET_PVINFO:\n#if defined(CONFIG_KVM_E500V2) || defined(CONFIG_KVM_E500MC)\n\tcase KVM_CAP_SW_TLB:\n#endif\n\t\t/* We support this only for PR */\n\t\tr = !hv_enabled;\n\t\tbreak;\n#ifdef CONFIG_KVM_MPIC\n\tcase KVM_CAP_IRQ_MPIC:\n\t\tr = 1;\n\t\tbreak;\n#endif\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\tcase KVM_CAP_SPAPR_TCE:\n\tcase KVM_CAP_SPAPR_TCE_64:\n\t\t/* fallthrough */\n\tcase KVM_CAP_SPAPR_TCE_VFIO:\n\tcase KVM_CAP_PPC_RTAS:\n\tcase KVM_CAP_PPC_FIXUP_HCALL:\n\tcase KVM_CAP_PPC_ENABLE_HCALL:\n#ifdef CONFIG_KVM_XICS\n\tcase KVM_CAP_IRQ_XICS:\n#endif\n\t\tr = 1;\n\t\tbreak;\n\n\tcase KVM_CAP_PPC_ALLOC_HTAB:\n\t\tr = hv_enabled;\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3S_64 */\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_SMT:\n\t\tr = 0;\n\t\tif (kvm) {\n\t\t\tif (kvm->arch.emul_smt_mode > 1)\n\t\t\t\tr = kvm->arch.emul_smt_mode;\n\t\t\telse\n\t\t\t\tr = kvm->arch.smt_mode;\n\t\t} else if (hv_enabled) {\n\t\t\tif (cpu_has_feature(CPU_FTR_ARCH_300))\n\t\t\t\tr = 1;\n\t\t\telse\n\t\t\t\tr = threads_per_subcore;\n\t\t}\n\t\tbreak;\n\tcase KVM_CAP_PPC_SMT_POSSIBLE:\n\t\tr = 1;\n\t\tif (hv_enabled) {\n\t\t\tif (!cpu_has_feature(CPU_FTR_ARCH_300))\n\t\t\t\tr = ((threads_per_subcore << 1) - 1);\n\t\t\telse\n\t\t\t\t/* P9 can emulate dbells, so allow any mode */\n\t\t\t\tr = 8 | 4 | 2 | 1;\n\t\t}\n\t\tbreak;\n\tcase KVM_CAP_PPC_RMA:\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_PPC_HWRNG:\n\t\tr = kvmppc_hwrng_present();\n\t\tbreak;\n\tcase KVM_CAP_PPC_MMU_RADIX:\n\t\tr = !!(hv_enabled && radix_enabled());\n\t\tbreak;\n\tcase KVM_CAP_PPC_MMU_HASH_V3:\n\t\tr = !!(hv_enabled && !radix_enabled() &&\n\t\t       cpu_has_feature(CPU_FTR_ARCH_300));\n\t\tbreak;\n#endif\n\tcase KVM_CAP_SYNC_MMU:\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\t\tr = hv_enabled;\n#elif defined(KVM_ARCH_WANT_MMU_NOTIFIER)\n\t\tr = 1;\n#else\n\t\tr = 0;\n#endif\n\t\tbreak;\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_HTAB_FD:\n\t\tr = hv_enabled;\n\t\tbreak;\n#endif\n\tcase KVM_CAP_NR_VCPUS:\n\t\t/*\n\t\t * Recommending a number of CPUs is somewhat arbitrary; we\n\t\t * return the number of present CPUs for -HV (since a host\n\t\t * will have secondary threads \"offline\"), and for other KVM\n\t\t * implementations just count online CPUs.\n\t\t */\n\t\tif (hv_enabled)\n\t\t\tr = num_present_cpus();\n\t\telse\n\t\t\tr = num_online_cpus();\n\t\tbreak;\n\tcase KVM_CAP_NR_MEMSLOTS:\n\t\tr = KVM_USER_MEM_SLOTS;\n\t\tbreak;\n\tcase KVM_CAP_MAX_VCPUS:\n\t\tr = KVM_MAX_VCPUS;\n\t\tbreak;\n#ifdef CONFIG_PPC_BOOK3S_64\n\tcase KVM_CAP_PPC_GET_SMMU_INFO:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_SPAPR_MULTITCE:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_SPAPR_RESIZE_HPT:\n\t\t/* Disable this on POWER9 until code handles new HPTE format */\n\t\tr = !!hv_enabled && !cpu_has_feature(CPU_FTR_ARCH_300);\n\t\tbreak;\n#endif\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_FWNMI:\n\t\tr = hv_enabled;\n\t\tbreak;\n#endif\n\tcase KVM_CAP_PPC_HTM:\n\t\tr = cpu_has_feature(CPU_FTR_TM_COMP) &&\n\t\t    is_kvmppc_hv_enabled(kvm);\n\t\tbreak;\n\tdefault:\n\t\tr = 0;\n\t\tbreak;\n\t}\n\treturn r;\n\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149634,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)\n{\n\tint r;\n\t/* Assume we're using HV mode when the HV module is loaded */\n\tint hv_enabled = kvmppc_hv_ops ? 1 : 0;\n\n\tif (kvm) {\n\t\t/*\n\t\t * Hooray - we know which VM type we're running on. Depend on\n\t\t * that rather than the guess above.\n\t\t */\n\t\thv_enabled = is_kvmppc_hv_enabled(kvm);\n\t}\n\n\tswitch (ext) {\n#ifdef CONFIG_BOOKE\n\tcase KVM_CAP_PPC_BOOKE_SREGS:\n\tcase KVM_CAP_PPC_BOOKE_WATCHDOG:\n\tcase KVM_CAP_PPC_EPR:\n#else\n\tcase KVM_CAP_PPC_SEGSTATE:\n\tcase KVM_CAP_PPC_HIOR:\n\tcase KVM_CAP_PPC_PAPR:\n#endif\n\tcase KVM_CAP_PPC_UNSET_IRQ:\n\tcase KVM_CAP_PPC_IRQ_LEVEL:\n\tcase KVM_CAP_ENABLE_CAP:\n\tcase KVM_CAP_ENABLE_CAP_VM:\n\tcase KVM_CAP_ONE_REG:\n\tcase KVM_CAP_IOEVENTFD:\n\tcase KVM_CAP_DEVICE_CTRL:\n\tcase KVM_CAP_IMMEDIATE_EXIT:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_PPC_PAIRED_SINGLES:\n\tcase KVM_CAP_PPC_OSI:\n\tcase KVM_CAP_PPC_GET_PVINFO:\n#if defined(CONFIG_KVM_E500V2) || defined(CONFIG_KVM_E500MC)\n\tcase KVM_CAP_SW_TLB:\n#endif\n\t\t/* We support this only for PR */\n\t\tr = !hv_enabled;\n\t\tbreak;\n#ifdef CONFIG_KVM_MPIC\n\tcase KVM_CAP_IRQ_MPIC:\n\t\tr = 1;\n\t\tbreak;\n#endif\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\tcase KVM_CAP_SPAPR_TCE:\n\tcase KVM_CAP_SPAPR_TCE_64:\n\t\t/* fallthrough */\n\tcase KVM_CAP_SPAPR_TCE_VFIO:\n\tcase KVM_CAP_PPC_RTAS:\n\tcase KVM_CAP_PPC_FIXUP_HCALL:\n\tcase KVM_CAP_PPC_ENABLE_HCALL:\n#ifdef CONFIG_KVM_XICS\n\tcase KVM_CAP_IRQ_XICS:\n#endif\n\t\tr = 1;\n\t\tbreak;\n\n\tcase KVM_CAP_PPC_ALLOC_HTAB:\n\t\tr = hv_enabled;\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3S_64 */\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_SMT:\n\t\tr = 0;\n\t\tif (kvm) {\n\t\t\tif (kvm->arch.emul_smt_mode > 1)\n\t\t\t\tr = kvm->arch.emul_smt_mode;\n\t\t\telse\n\t\t\t\tr = kvm->arch.smt_mode;\n\t\t} else if (hv_enabled) {\n\t\t\tif (cpu_has_feature(CPU_FTR_ARCH_300))\n\t\t\t\tr = 1;\n\t\t\telse\n\t\t\t\tr = threads_per_subcore;\n\t\t}\n\t\tbreak;\n\tcase KVM_CAP_PPC_SMT_POSSIBLE:\n\t\tr = 1;\n\t\tif (hv_enabled) {\n\t\t\tif (!cpu_has_feature(CPU_FTR_ARCH_300))\n\t\t\t\tr = ((threads_per_subcore << 1) - 1);\n\t\t\telse\n\t\t\t\t/* P9 can emulate dbells, so allow any mode */\n\t\t\t\tr = 8 | 4 | 2 | 1;\n\t\t}\n\t\tbreak;\n\tcase KVM_CAP_PPC_RMA:\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_PPC_HWRNG:\n\t\tr = kvmppc_hwrng_present();\n\t\tbreak;\n\tcase KVM_CAP_PPC_MMU_RADIX:\n\t\tr = !!(hv_enabled && radix_enabled());\n\t\tbreak;\n\tcase KVM_CAP_PPC_MMU_HASH_V3:\n\t\tr = !!(hv_enabled && !radix_enabled() &&\n\t\t       cpu_has_feature(CPU_FTR_ARCH_300));\n\t\tbreak;\n#endif\n\tcase KVM_CAP_SYNC_MMU:\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\t\tr = hv_enabled;\n#elif defined(KVM_ARCH_WANT_MMU_NOTIFIER)\n\t\tr = 1;\n#else\n\t\tr = 0;\n#endif\n\t\tbreak;\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_HTAB_FD:\n\t\tr = hv_enabled;\n\t\tbreak;\n#endif\n\tcase KVM_CAP_NR_VCPUS:\n\t\t/*\n\t\t * Recommending a number of CPUs is somewhat arbitrary; we\n\t\t * return the number of present CPUs for -HV (since a host\n\t\t * will have secondary threads \"offline\"), and for other KVM\n\t\t * implementations just count online CPUs.\n\t\t */\n\t\tif (hv_enabled)\n\t\t\tr = num_present_cpus();\n\t\telse\n\t\t\tr = num_online_cpus();\n\t\tbreak;\n\tcase KVM_CAP_NR_MEMSLOTS:\n\t\tr = KVM_USER_MEM_SLOTS;\n\t\tbreak;\n\tcase KVM_CAP_MAX_VCPUS:\n\t\tr = KVM_MAX_VCPUS;\n\t\tbreak;\n#ifdef CONFIG_PPC_BOOK3S_64\n\tcase KVM_CAP_PPC_GET_SMMU_INFO:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_SPAPR_MULTITCE:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_SPAPR_RESIZE_HPT:\n\t\t/* Disable this on POWER9 until code handles new HPTE format */\n\t\tr = !!hv_enabled && !cpu_has_feature(CPU_FTR_ARCH_300);\n\t\tbreak;\n#endif\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_FWNMI:\n\t\tr = hv_enabled;\n\t\tbreak;\n#endif\n\tcase KVM_CAP_PPC_HTM:\n\t\tr = cpu_has_feature(CPU_FTR_TM_COMP) && hv_enabled;\n\t\tbreak;\n\tdefault:\n\t\tr = 0;\n\t\tbreak;\n\t}\n\treturn r;\n\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149635,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static bool handle_client_startup(PgSocket *client, PktHdr *pkt)\n{\n\tconst char *passwd;\n\tconst uint8_t *key;\n\tbool ok;\n\n\tSBuf *sbuf = &client->sbuf;\n\n\t/* don't tolerate partial packets */\n\tif (incomplete_pkt(pkt)) {\n\t\tdisconnect_client(client, true, \"client sent partial pkt in startup phase\");\n\t\treturn false;\n\t}\n\n\tif (client->wait_for_welcome) {\n\t\tif  (finish_client_login(client)) {\n\t\t\t/* the packet was already parsed */\n\t\t\tsbuf_prepare_skip(sbuf, pkt->len);\n\t\t\treturn true;\n\t\t} else\n\t\t\treturn false;\n\t}\n\n\tswitch (pkt->type) {\n\tcase PKT_SSLREQ:\n\t\tslog_noise(client, \"C: req SSL\");\n\t\tslog_noise(client, \"P: nak\");\n\n\t\t/* reject SSL attempt */\n\t\tif (!sbuf_answer(&client->sbuf, \"N\", 1)) {\n\t\t\tdisconnect_client(client, false, \"failed to nak SSL\");\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase PKT_STARTUP_V2:\n\t\tdisconnect_client(client, true, \"Old V2 protocol not supported\");\n\t\treturn false;\n\tcase PKT_STARTUP:\n\t\tif (client->pool) {\n\t\t\tdisconnect_client(client, true, \"client re-sent startup pkt\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!decide_startup_pool(client, pkt))\n\t\t\treturn false;\n\n\t\tif (client->pool->db->admin) {\n\t\t\tif (!admin_pre_login(client))\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif (cf_auth_type <= AUTH_TRUST || client->own_user) {\n\t\t\tif (!finish_client_login(client))\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (!send_client_authreq(client)) {\n\t\t\t\tdisconnect_client(client, false, \"failed to send auth req\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'p':\t\t/* PasswordMessage */\n\t\t/* haven't requested it */\n\t\tif (cf_auth_type <= AUTH_TRUST) {\n\t\t\tdisconnect_client(client, true, \"unrequested passwd pkt\");\n\t\t\treturn false;\n\t\t}\n\n\t\tok = mbuf_get_string(&pkt->data, &passwd);\n\t\tif (ok && check_client_passwd(client, passwd)) {\n\t\t\tif (!finish_client_login(client))\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tdisconnect_client(client, true, \"Auth failed\");\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase PKT_CANCEL:\n\t\tif (mbuf_avail_for_read(&pkt->data) == BACKENDKEY_LEN\n\t\t    && mbuf_get_bytes(&pkt->data, BACKENDKEY_LEN, &key))\n\t\t{\n\t\t\tmemcpy(client->cancel_key, key, BACKENDKEY_LEN);\n\t\t\taccept_cancel_request(client);\n\t\t} else\n\t\t\tdisconnect_client(client, false, \"bad cancel request\");\n\t\treturn false;\n\tdefault:\n\t\tdisconnect_client(client, false, \"bad packet\");\n\t\treturn false;\n\t}\n\tsbuf_prepare_skip(sbuf, pkt->len);\n\tclient->request_time = get_cached_time();\n\treturn true;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149636,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static bool handle_client_startup(PgSocket *client, PktHdr *pkt)\n{\n\tconst char *passwd;\n\tconst uint8_t *key;\n\tbool ok;\n\n\tSBuf *sbuf = &client->sbuf;\n\n\t/* don't tolerate partial packets */\n\tif (incomplete_pkt(pkt)) {\n\t\tdisconnect_client(client, true, \"client sent partial pkt in startup phase\");\n\t\treturn false;\n\t}\n\n\tif (client->wait_for_welcome) {\n\t\tif  (finish_client_login(client)) {\n\t\t\t/* the packet was already parsed */\n\t\t\tsbuf_prepare_skip(sbuf, pkt->len);\n\t\t\treturn true;\n\t\t} else\n\t\t\treturn false;\n\t}\n\n\tswitch (pkt->type) {\n\tcase PKT_SSLREQ:\n\t\tslog_noise(client, \"C: req SSL\");\n\t\tslog_noise(client, \"P: nak\");\n\n\t\t/* reject SSL attempt */\n\t\tif (!sbuf_answer(&client->sbuf, \"N\", 1)) {\n\t\t\tdisconnect_client(client, false, \"failed to nak SSL\");\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase PKT_STARTUP_V2:\n\t\tdisconnect_client(client, true, \"Old V2 protocol not supported\");\n\t\treturn false;\n\tcase PKT_STARTUP:\n\t\tif (client->pool) {\n\t\t\tdisconnect_client(client, true, \"client re-sent startup pkt\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!decide_startup_pool(client, pkt))\n\t\t\treturn false;\n\n\t\tif (client->pool->db->admin) {\n\t\t\tif (!admin_pre_login(client))\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif (cf_auth_type <= AUTH_TRUST || client->own_user) {\n\t\t\tif (!finish_client_login(client))\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (!send_client_authreq(client)) {\n\t\t\t\tdisconnect_client(client, false, \"failed to send auth req\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'p':\t\t/* PasswordMessage */\n\t\t/* too early */\n\t\tif (!client->auth_user) {\n\t\t\tdisconnect_client(client, true, \"client password pkt before startup packet\");\n\t\t\treturn false;\n\t\t}\n\n\t\t/* haven't requested it */\n\t\tif (cf_auth_type <= AUTH_TRUST) {\n\t\t\tdisconnect_client(client, true, \"unrequested passwd pkt\");\n\t\t\treturn false;\n\t\t}\n\n\t\tok = mbuf_get_string(&pkt->data, &passwd);\n\t\tif (ok && check_client_passwd(client, passwd)) {\n\t\t\tif (!finish_client_login(client))\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tdisconnect_client(client, true, \"Auth failed\");\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase PKT_CANCEL:\n\t\tif (mbuf_avail_for_read(&pkt->data) == BACKENDKEY_LEN\n\t\t    && mbuf_get_bytes(&pkt->data, BACKENDKEY_LEN, &key))\n\t\t{\n\t\t\tmemcpy(client->cancel_key, key, BACKENDKEY_LEN);\n\t\t\taccept_cancel_request(client);\n\t\t} else\n\t\t\tdisconnect_client(client, false, \"bad cancel request\");\n\t\treturn false;\n\tdefault:\n\t\tdisconnect_client(client, false, \"bad packet\");\n\t\treturn false;\n\t}\n\tsbuf_prepare_skip(sbuf, pkt->len);\n\tclient->request_time = get_cached_time();\n\treturn true;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149637,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "mrb_class_real(struct RClass* cl)\n{\n  if (cl == 0)\n    return NULL;\n  while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n    cl = cl->super;\n  }\n  return cl;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149638,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "mrb_class_real(struct RClass* cl)\n{\n  if (cl == 0) return NULL;\n  while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n    cl = cl->super;\n    if (cl == 0) return NULL;\n  }\n  return cl;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149639,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int nsv_read_chunk(AVFormatContext *s, int fill_header)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st[2] = {NULL, NULL};\n    NSVStream *nst;\n    AVPacket *pkt;\n    int i, err = 0;\n    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */\n    uint32_t vsize;\n    uint16_t asize;\n    uint16_t auxsize;\n\n    if (nsv->ahead[0].data || nsv->ahead[1].data)\n        return 0; //-1; /* hey! eat what you've in your plate first! */\n\nnull_chunk_retry:\n    if (pb->eof_reached)\n        return -1;\n\n    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)\n        err = nsv_resync(s);\n    if (err < 0)\n        return err;\n    if (nsv->state == NSV_FOUND_NSVS)\n        err = nsv_parse_NSVs_header(s);\n    if (err < 0)\n        return err;\n    if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)\n        return -1;\n\n    auxcount = avio_r8(pb);\n    vsize = avio_rl16(pb);\n    asize = avio_rl16(pb);\n    vsize = (vsize << 4) | (auxcount >> 4);\n    auxcount &= 0x0f;\n    av_log(s, AV_LOG_TRACE, \"NSV CHUNK %\"PRIu8\" aux, %\"PRIu32\" bytes video, %\"PRIu16\" bytes audio\\n\",\n           auxcount, vsize, asize);\n    /* skip aux stuff */\n    for (i = 0; i < auxcount; i++) {\n        uint32_t av_unused auxtag;\n        auxsize = avio_rl16(pb);\n        auxtag = avio_rl32(pb);\n        avio_skip(pb, auxsize);\n        vsize -= auxsize + sizeof(uint16_t) + sizeof(uint32_t); /* that's becoming brain-dead */\n    }\n\n    if (pb->eof_reached)\n        return -1;\n    if (!vsize && !asize) {\n        nsv->state = NSV_UNSYNC;\n        goto null_chunk_retry;\n    }\n\n    /* map back streams to v,a */\n    if (s->nb_streams > 0)\n        st[s->streams[0]->id] = s->streams[0];\n    if (s->nb_streams > 1)\n        st[s->streams[1]->id] = s->streams[1];\n\n    if (vsize && st[NSV_ST_VIDEO]) {\n        nst = st[NSV_ST_VIDEO]->priv_data;\n        pkt = &nsv->ahead[NSV_ST_VIDEO];\n        av_get_packet(pb, pkt, vsize);\n        pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;\n        pkt->dts = nst->frame_offset;\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n        for (i = 0; i < FFMIN(8, vsize); i++)\n            av_log(s, AV_LOG_TRACE, \"NSV video: [%d] = %02\"PRIx8\"\\n\",\n                   i, pkt->data[i]);\n    }\n    if(st[NSV_ST_VIDEO])\n        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;\n\n    if (asize && st[NSV_ST_AUDIO]) {\n        nst = st[NSV_ST_AUDIO]->priv_data;\n        pkt = &nsv->ahead[NSV_ST_AUDIO];\n        /* read raw audio specific header on the first audio chunk... */\n        /* on ALL audio chunks ?? seems so! */\n        if (asize && st[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C', 'M', ' ')/* && fill_header*/) {\n            uint8_t bps;\n            uint8_t channels;\n            uint16_t samplerate;\n            bps = avio_r8(pb);\n            channels = avio_r8(pb);\n            samplerate = avio_rl16(pb);\n            if (!channels || !samplerate)\n                return AVERROR_INVALIDDATA;\n            asize-=4;\n            av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                   bps, channels, samplerate);\n            if (fill_header) {\n                st[NSV_ST_AUDIO]->need_parsing = AVSTREAM_PARSE_NONE; /* we know everything */\n                if (bps != 16) {\n                    av_log(s, AV_LOG_TRACE, \"NSV AUDIO bit/sample != 16 (%\"PRIu8\")!!!\\n\", bps);\n                }\n                bps /= channels; // ???\n                if (bps == 8)\n                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n                samplerate /= 4;/* UGH ??? XXX */\n                channels = 1;\n                st[NSV_ST_AUDIO]->codecpar->channels = channels;\n                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;\n                av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                       bps, channels, samplerate);\n            }\n        }\n        av_get_packet(pb, pkt, asize);\n        pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n        if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n            /* on a nsvs frame we have new information on a/v sync */\n            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);\n            pkt->dts *= (int64_t)1000        * nsv->framerate.den;\n            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;\n            av_log(s, AV_LOG_TRACE, \"NSV AUDIO: sync:%\"PRId16\", dts:%\"PRId64,\n                   nsv->avsync, pkt->dts);\n        }\n        nst->frame_offset++;\n    }\n\n    nsv->state = NSV_UNSYNC;\n    return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149640,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int nsv_read_chunk(AVFormatContext *s, int fill_header)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st[2] = {NULL, NULL};\n    NSVStream *nst;\n    AVPacket *pkt;\n    int i, err = 0;\n    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */\n    uint32_t vsize;\n    uint16_t asize;\n    uint16_t auxsize;\n    int ret;\n\n    if (nsv->ahead[0].data || nsv->ahead[1].data)\n        return 0; //-1; /* hey! eat what you've in your plate first! */\n\nnull_chunk_retry:\n    if (pb->eof_reached)\n        return -1;\n\n    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)\n        err = nsv_resync(s);\n    if (err < 0)\n        return err;\n    if (nsv->state == NSV_FOUND_NSVS)\n        err = nsv_parse_NSVs_header(s);\n    if (err < 0)\n        return err;\n    if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)\n        return -1;\n\n    auxcount = avio_r8(pb);\n    vsize = avio_rl16(pb);\n    asize = avio_rl16(pb);\n    vsize = (vsize << 4) | (auxcount >> 4);\n    auxcount &= 0x0f;\n    av_log(s, AV_LOG_TRACE, \"NSV CHUNK %\"PRIu8\" aux, %\"PRIu32\" bytes video, %\"PRIu16\" bytes audio\\n\",\n           auxcount, vsize, asize);\n    /* skip aux stuff */\n    for (i = 0; i < auxcount; i++) {\n        uint32_t av_unused auxtag;\n        auxsize = avio_rl16(pb);\n        auxtag = avio_rl32(pb);\n        avio_skip(pb, auxsize);\n        vsize -= auxsize + sizeof(uint16_t) + sizeof(uint32_t); /* that's becoming brain-dead */\n    }\n\n    if (pb->eof_reached)\n        return -1;\n    if (!vsize && !asize) {\n        nsv->state = NSV_UNSYNC;\n        goto null_chunk_retry;\n    }\n\n    /* map back streams to v,a */\n    if (s->nb_streams > 0)\n        st[s->streams[0]->id] = s->streams[0];\n    if (s->nb_streams > 1)\n        st[s->streams[1]->id] = s->streams[1];\n\n    if (vsize && st[NSV_ST_VIDEO]) {\n        nst = st[NSV_ST_VIDEO]->priv_data;\n        pkt = &nsv->ahead[NSV_ST_VIDEO];\n        if ((ret = av_get_packet(pb, pkt, vsize)) < 0)\n            return ret;\n        pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;\n        pkt->dts = nst->frame_offset;\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n        for (i = 0; i < FFMIN(8, vsize); i++)\n            av_log(s, AV_LOG_TRACE, \"NSV video: [%d] = %02\"PRIx8\"\\n\",\n                   i, pkt->data[i]);\n    }\n    if(st[NSV_ST_VIDEO])\n        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;\n\n    if (asize && st[NSV_ST_AUDIO]) {\n        nst = st[NSV_ST_AUDIO]->priv_data;\n        pkt = &nsv->ahead[NSV_ST_AUDIO];\n        /* read raw audio specific header on the first audio chunk... */\n        /* on ALL audio chunks ?? seems so! */\n        if (asize && st[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C', 'M', ' ')/* && fill_header*/) {\n            uint8_t bps;\n            uint8_t channels;\n            uint16_t samplerate;\n            bps = avio_r8(pb);\n            channels = avio_r8(pb);\n            samplerate = avio_rl16(pb);\n            if (!channels || !samplerate)\n                return AVERROR_INVALIDDATA;\n            asize-=4;\n            av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                   bps, channels, samplerate);\n            if (fill_header) {\n                st[NSV_ST_AUDIO]->need_parsing = AVSTREAM_PARSE_NONE; /* we know everything */\n                if (bps != 16) {\n                    av_log(s, AV_LOG_TRACE, \"NSV AUDIO bit/sample != 16 (%\"PRIu8\")!!!\\n\", bps);\n                }\n                bps /= channels; // ???\n                if (bps == 8)\n                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n                samplerate /= 4;/* UGH ??? XXX */\n                channels = 1;\n                st[NSV_ST_AUDIO]->codecpar->channels = channels;\n                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;\n                av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                       bps, channels, samplerate);\n            }\n        }\n        if ((ret = av_get_packet(pb, pkt, asize)) < 0)\n            return ret;\n        pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n        if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n            /* on a nsvs frame we have new information on a/v sync */\n            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);\n            pkt->dts *= (int64_t)1000        * nsv->framerate.den;\n            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;\n            av_log(s, AV_LOG_TRACE, \"NSV AUDIO: sync:%\"PRId16\", dts:%\"PRId64,\n                   nsv->avsync, pkt->dts);\n        }\n        nst->frame_offset++;\n    }\n\n    nsv->state = NSV_UNSYNC;\n    return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149641,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "_kdc_as_rep(kdc_request_t r,\n\t    krb5_data *reply,\n\t    const char *from,\n\t    struct sockaddr *from_addr,\n\t    int datagram_reply)\n{\n    krb5_context context = r->context;\n    krb5_kdc_configuration *config = r->config;\n    KDC_REQ *req = &r->req;\n    KDC_REQ_BODY *b = NULL;\n    AS_REP rep;\n    KDCOptions f;\n    krb5_enctype setype;\n    krb5_error_code ret = 0;\n    Key *skey;\n    int found_pa = 0;\n    int i, flags = HDB_F_FOR_AS_REQ;\n    METHOD_DATA error_method;\n    const PA_DATA *pa;\n\n    memset(&rep, 0, sizeof(rep));\n    error_method.len = 0;\n    error_method.val = NULL;\n\n    /*\n     * Look for FAST armor and unwrap\n     */\n    ret = _kdc_fast_unwrap_request(r);\n    if (ret) {\n\t_kdc_r_log(r, 0, \"FAST unwrap request from %s failed: %d\", from, ret);\n\tgoto out;\n    }\n\n    b = &req->req_body;\n    f = b->kdc_options;\n\n    if (f.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->sname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \"No server in request\");\n    } else{\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->server_princ,\n\t\t\t\t\t\t  *(b->sname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret == 0)\n\t    ret = krb5_unparse_name(context, r->server_princ, &r->server_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"AS-REQ malformed server name from %s\", from);\n\tgoto out;\n    }\n    if(b->cname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \"No client in request\");\n    } else {\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->client_princ,\n\t\t\t\t\t\t  *(b->cname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, r->client_princ, &r->client_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"AS-REQ malformed client name from %s\", from);\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \"AS-REQ %s from %s for %s\",\n\t    r->client_name, from, r->server_name);\n\n    /*\n     *\n     */\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tif (!_kdc_is_anon_request(b)) {\n\t    kdc_log(context, config, 0, \"Anonymous ticket w/o anonymous flag\");\n\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    goto out;\n\t}\n    } else if (_kdc_is_anon_request(b)) {\n\tkdc_log(context, config, 0,\n\t\t\"Request for a anonymous ticket with non \"\n\t\t\"anonymous client name: %s\", r->client_name);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_db_fetch(context, config, r->client_princ,\n\t\t\tHDB_F_GET_CLIENT | flags, NULL,\n\t\t\t&r->clientdb, &r->client);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"client %s does not have secrets at this KDC, need to proxy\",\n\t\tr->client_name);\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n\tchar *fixed_client_name = NULL;\n\n\tret = krb5_unparse_name(context, r->client->entry.principal,\n\t\t\t\t&fixed_client_name);\n\tif (ret) {\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"WRONG_REALM - %s -> %s\",\n\t\tr->client_name, fixed_client_name);\n\tfree(fixed_client_name);\n\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t KRB5_KDC_ERR_WRONG_REALM,\n\t\t\t\t NULL,\n\t\t\t\t r->server_princ,\n\t\t\t\t NULL,\n\t\t\t\t &r->client->entry.principal->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->client_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n    ret = _kdc_db_fetch(context, config, r->server_princ,\n\t\t\tHDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,\n\t\t\tNULL, NULL, &r->server);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\",\n\t\tr->server_name);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->server_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     * Select a session enctype from the list of the crypto system\n     * supported enctypes that is supported by the client and is one of\n     * the enctype of the enctype of the service (likely krbtgt).\n     *\n     * The latter is used as a hint of what enctypes all KDC support,\n     * to make sure a newer version of KDC won't generate a session\n     * enctype that an older version of a KDC in the same realm can't\n     * decrypt.\n     */\n\n    ret = _kdc_find_etype(context,\n\t\t\t  krb5_principal_is_krbtgt(context, r->server_princ) ?\n\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t  r->client, b->etype.val, b->etype.len, &r->sessionetype,\n\t\t\t  NULL);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"Client (%s) from %s has no common enctypes with KDC \"\n\t\t\"to use for the session key\",\n\t\tr->client_name, from);\n\tgoto out;\n    }\n\n    /*\n     * Pre-auth processing\n     */\n\n    if(req->padata){\n\tunsigned int n;\n\n\tlog_patypes(context, config, req->padata);\n\n\t/* Check if preauth matching */\n\n\tfor (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if (pat[n].validate == NULL)\n\t\tcontinue;\n\t    if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))\n\t\tcontinue;\n\n\t    kdc_log(context, config, 5,\n\t\t    \"Looking for %s pa-data -- %s\", pat[n].name, r->client_name);\n\t    i = 0;\n\t    pa = _kdc_find_padata(req, &i, pat[n].type);\n\t    if (pa) {\n\t\tret = pat[n].validate(r, pa);\n\t\tif (ret != 0) {\n\t\t    goto out;\n\t\t}\n\t\tkdc_log(context, config, 0,\n\t\t\t\"%s pre-authentication succeeded -- %s\",\n\t\t\tpat[n].name, r->client_name);\n\t\tfound_pa = 1;\n\t\tr->et.flags.pre_authent = 1;\n\t    }\n\t}\n    }\n\n    if (found_pa == 0) {\n\tKey *ckey = NULL;\n\tsize_t n;\n\n\tfor (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if ((pat[n].flags & PA_ANNOUNCE) == 0)\n\t\tcontinue;\n\t    ret = krb5_padata_add(context, &error_method,\n\t\t\t\t  pat[n].type, NULL, 0);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is a client key, send ETYPE_INFO{,2}\n\t */\n\tret = _kdc_find_etype(context,\n\t\t\t      config->preauth_use_strongest_session_key, TRUE,\n\t\t\t      r->client, b->etype.val, b->etype.len, NULL, &ckey);\n\tif (ret == 0) {\n\n\t    /*\n\t     * RFC4120 requires:\n\t     * - If the client only knows about old enctypes, then send\n\t     *   both info replies (we send 'info' first in the list).\n\t     * - If the client is 'modern', because it knows about 'new'\n\t     *   enctype types, then only send the 'info2' reply.\n\t     *\n\t     * Before we send the full list of etype-info data, we pick\n\t     * the client key we would have used anyway below, just pick\n\t     * that instead.\n\t     */\n\n\t    if (older_enctype(ckey->key.keytype)) {\n\t\tret = get_pa_etype_info(context, config,\n\t\t\t\t\t&error_method, ckey);\n\t\tif (ret)\n\t\t    goto out;\n\t    }\n\t    ret = get_pa_etype_info2(context, config,\n\t\t\t\t     &error_method, ckey);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/* \n\t * send requre preauth is its required or anon is requested,\n\t * anon is today only allowed via preauth mechanisms.\n\t */\n\tif (require_preauth_p(r) || _kdc_is_anon_request(b)) {\n\t    ret = KRB5KDC_ERR_PREAUTH_REQUIRED;\n\t    _kdc_set_e_text(r, \"Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ\");\n\t    goto out;\n\t}\n\n\tif (ckey == NULL) {\n\t    ret = KRB5KDC_ERR_CLIENT_NOTYET;\n\t    _kdc_set_e_text(r, \"Doesn't have a client key available\");\n\t    goto out;\n\t}\n\tkrb5_free_keyblock_contents(r->context,  &r->reply_key);\n\tret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->clientdb->hdb_auth_status) {\n\tr->clientdb->hdb_auth_status(context, r->clientdb, r->client, \n\t\t\t\t     HDB_AUTH_SUCCESS);\n    }\n\n    /*\n     * Verify flags after the user been required to prove its identity\n     * with in a preauth mech.\n     */\n\n    ret = _kdc_check_access(context, config, r->client, r->client_name,\n\t\t\t    r->server, r->server_name,\n\t\t\t    req, &error_method);\n    if(ret)\n\tgoto out;\n\n    /*\n     * Select the best encryption type for the KDC with out regard to\n     * the client since the client never needs to read that data.\n     */\n\n    ret = _kdc_get_preferred_key(context, config,\n\t\t\t\t r->server, r->server_name,\n\t\t\t\t &setype, &skey);\n    if(ret)\n\tgoto out;\n\n    if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey\n       || (_kdc_is_anon_request(b) && !config->allow_anonymous)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\t_kdc_set_e_text(r, \"Bad KDC options\");\n\tgoto out;\n    }\n\n    /*\n     * Build reply\n     */\n\n    rep.pvno = 5;\n    rep.msg_type = krb_as_rep;\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tRealm anon_realm=KRB5_ANON_REALM;\n\tret = copy_Realm(&anon_realm, &rep.crealm);\n    } else\n\tret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);\n    if (ret)\n\tgoto out;\n    ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);\n    if (ret)\n\tgoto out;\n\n    rep.ticket.tkt_vno = 5;\n    ret = copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);\n    if (ret)\n\tgoto out;\n    _krb5_principal2principalname(&rep.ticket.sname,\n\t\t\t\t  r->server->entry.principal);\n    /* java 1.6 expects the name to be the same type, lets allow that\n     * uncomplicated name-types. */\n#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)\n    if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))\n\trep.ticket.sname.name_type = b->sname->name_type;\n#undef CNT\n\n    r->et.flags.initial = 1;\n    if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)\n\tr->et.flags.forwardable = f.forwardable;\n    else if (f.forwardable) {\n\t_kdc_set_e_text(r, \"Ticket may not be forwardable\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)\n\tr->et.flags.proxiable = f.proxiable;\n    else if (f.proxiable) {\n\t_kdc_set_e_text(r, \"Ticket may not be proxiable\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)\n\tr->et.flags.may_postdate = f.allow_postdate;\n    else if (f.allow_postdate){\n\t_kdc_set_e_text(r, \"Ticket may not be postdate\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {\n\t_kdc_set_e_text(r, \"Bad address list in requested\");\n\tret = KRB5KRB_AP_ERR_BADADDR;\n\tgoto out;\n    }\n\n    ret = copy_PrincipalName(&rep.cname, &r->et.cname);\n    if (ret)\n\tgoto out;\n    ret = copy_Realm(&rep.crealm, &r->et.crealm);\n    if (ret)\n\tgoto out;\n\n    {\n\ttime_t start;\n\ttime_t t;\n\t\n\tstart = r->et.authtime = kdc_time;\n\n\tif(f.postdated && req->req_body.from){\n\t    ALLOC(r->et.starttime);\n\t    start = *r->et.starttime = *req->req_body.from;\n\t    r->et.flags.invalid = 1;\n\t    r->et.flags.postdated = 1; /* XXX ??? */\n\t}\n\t_kdc_fix_time(&b->till);\n\tt = *b->till;\n\n\t/* be careful not overflowing */\n\n\tif(r->client->entry.max_life)\n\t    t = start + min(t - start, *r->client->entry.max_life);\n\tif(r->server->entry.max_life)\n\t    t = start + min(t - start, *r->server->entry.max_life);\n#if 0\n\tt = min(t, start + realm->max_life);\n#endif\n\tr->et.endtime = t;\n\tif(f.renewable_ok && r->et.endtime < *b->till){\n\t    f.renewable = 1;\n\t    if(b->rtime == NULL){\n\t\tALLOC(b->rtime);\n\t\t*b->rtime = 0;\n\t    }\n\t    if(*b->rtime < *b->till)\n\t\t*b->rtime = *b->till;\n\t}\n\tif(f.renewable && b->rtime){\n\t    t = *b->rtime;\n\t    if(t == 0)\n\t\tt = MAX_TIME;\n\t    if(r->client->entry.max_renew)\n\t\tt = start + min(t - start, *r->client->entry.max_renew);\n\t    if(r->server->entry.max_renew)\n\t\tt = start + min(t - start, *r->server->entry.max_renew);\n#if 0\n\t    t = min(t, start + realm->max_renew);\n#endif\n\t    ALLOC(r->et.renew_till);\n\t    *r->et.renew_till = t;\n\t    r->et.flags.renewable = 1;\n\t}\n    }\n\n    if (_kdc_is_anon_request(b))\n\tr->et.flags.anonymous = 1;\n\n    if(b->addresses){\n\tALLOC(r->et.caddr);\n\tcopy_HostAddresses(b->addresses, r->et.caddr);\n    }\n\n    r->et.transited.tr_type = DOMAIN_X500_COMPRESS;\n    krb5_data_zero(&r->et.transited.contents);\n\n    /* The MIT ASN.1 library (obviously) doesn't tell lengths encoded\n     * as 0 and as 0x80 (meaning indefinite length) apart, and is thus\n     * incapable of correctly decoding SEQUENCE OF's of zero length.\n     *\n     * To fix this, always send at least one no-op last_req\n     *\n     * If there's a pw_end or valid_end we will use that,\n     * otherwise just a dummy lr.\n     */\n    r->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));\n    if (r->ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    r->ek.last_req.len = 0;\n    if (r->client->entry.pw_end\n\t&& (config->kdc_warn_pwexpire == 0\n\t    || kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->client->entry.valid_end) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->ek.last_req.len == 0) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = 0;\n\t++r->ek.last_req.len;\n    }\n    r->ek.nonce = b->nonce;\n    if (r->client->entry.valid_end || r->client->entry.pw_end) {\n\tALLOC(r->ek.key_expiration);\n\tif (r->client->entry.valid_end) {\n\t    if (r->client->entry.pw_end)\n\t\t*r->ek.key_expiration = min(*r->client->entry.valid_end,\n\t\t\t\t\t *r->client->entry.pw_end);\n\t    else\n\t\t*r->ek.key_expiration = *r->client->entry.valid_end;\n\t} else\n\t    *r->ek.key_expiration = *r->client->entry.pw_end;\n    } else\n\tr->ek.key_expiration = NULL;\n    r->ek.flags = r->et.flags;\n    r->ek.authtime = r->et.authtime;\n    if (r->et.starttime) {\n\tALLOC(r->ek.starttime);\n\t*r->ek.starttime = *r->et.starttime;\n    }\n    r->ek.endtime = r->et.endtime;\n    if (r->et.renew_till) {\n\tALLOC(r->ek.renew_till);\n\t*r->ek.renew_till = *r->et.renew_till;\n    }\n    ret = copy_Realm(&rep.ticket.realm, &r->ek.srealm);\n    if (ret)\n\tgoto out;\n    ret = copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);\n    if (ret)\n\tgoto out;\n    if(r->et.caddr){\n\tALLOC(r->ek.caddr);\n\tcopy_HostAddresses(r->et.caddr, r->ek.caddr);\n    }\n\n    /*\n     * Check and session and reply keys\n     */\n\n    if (r->session_key.keytype == ETYPE_NULL) {\n\tret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->reply_key.keytype == ETYPE_NULL) {\n\t_kdc_set_e_text(r, \"Client have no reply key\");\n\tret = KRB5KDC_ERR_CLIENT_NOTYET;\n\tgoto out;\n    }\n\n    ret = copy_EncryptionKey(&r->session_key, &r->et.key);\n    if (ret)\n\tgoto out;\n\n    ret = copy_EncryptionKey(&r->session_key, &r->ek.key);\n    if (ret)\n\tgoto out;\n\n    if (r->outpadata.len) {\n\n\tALLOC(rep.padata);\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(&r->outpadata, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    /* Add the PAC */\n    if (send_pac_p(context, req)) {\n\tgenerate_pac(r, skey);\n    }\n\n    _kdc_log_timestamp(context, config, \"AS-REQ\", r->et.authtime, r->et.starttime,\n\t\t       r->et.endtime, r->et.renew_till);\n\n    /* do this as the last thing since this signs the EncTicketPart */\n    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t  config,\n\t\t\t\t  r->server,\n\t\t\t\t  setype,\n\t\t\t\t  r->client->entry.principal,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  &r->et);\n    if (ret)\n\tgoto out;\n\n    log_as_req(context, config, r->reply_key.keytype, setype, b);\n\n    /*\n     * We always say we support FAST/enc-pa-rep\n     */\n\n    r->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;\n\n    /*\n     * Add REQ_ENC_PA_REP if client supports it\n     */\n\n    i = 0;\n    pa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);\n    if (pa) {\n\n\tret = add_enc_pa_rep(r);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(r->context, ret);\n\t    _kdc_r_log(r, 0, \"add_enc_pa_rep failed: %s: %d\", msg, ret);\n\t    krb5_free_error_message(r->context, msg);\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_encode_reply(context, config,\n\t\t\t    r->armor_crypto, req->req_body.nonce,\n\t\t\t    &rep, &r->et, &r->ek, setype, r->server->entry.kvno,\n\t\t\t    &skey->key, r->client->entry.kvno,\n\t\t\t    &r->reply_key, 0, &r->e_text, reply);\n    if (ret)\n\tgoto out;\n\n    /*\n     * Check if message too large\n     */\n    if (datagram_reply && reply->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(reply);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\t_kdc_set_e_text(r, \"Reply packet too large\");\n    }\n\nout:\n    free_AS_REP(&rep);\n\n    /*\n     * In case of a non proxy error, build an error message.\n     */\n    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t ret, r->e_text,\n\t\t\t\t r->server_princ,\n\t\t\t\t &r->client_princ->name,\n\t\t\t\t &r->client_princ->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tif (ret)\n\t    goto out2;\n    }\nout2:\n    free_EncTicketPart(&r->et);\n    free_EncKDCRepPart(&r->ek);\n    free_KDCFastState(&r->fast);\n\n    if (error_method.len)\n\tfree_METHOD_DATA(&error_method);\n    if (r->outpadata.len)\n\tfree_METHOD_DATA(&r->outpadata);\n    if (r->client_princ) {\n\tkrb5_free_principal(context, r->client_princ);\n\tr->client_princ = NULL;\n    }\n    if (r->client_name) {\n\tfree(r->client_name);\n\tr->client_name = NULL;\n    }\n    if (r->server_princ){\n\tkrb5_free_principal(context, r->server_princ);\n\tr->server_princ = NULL;\n    }\n    if (r->server_name) {\n\tfree(r->server_name);\n\tr->server_name = NULL;\n    }\n    if (r->client)\n\t_kdc_free_ent(context, r->client);\n    if (r->server)\n\t_kdc_free_ent(context, r->server);\n    if (r->armor_crypto) {\n\tkrb5_crypto_destroy(r->context, r->armor_crypto);\n\tr->armor_crypto = NULL;\n    }\n    krb5_free_keyblock_contents(r->context, &r->reply_key);\n    krb5_free_keyblock_contents(r->context, &r->session_key);\n    return ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149642,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "_kdc_as_rep(kdc_request_t r,\n\t    krb5_data *reply,\n\t    const char *from,\n\t    struct sockaddr *from_addr,\n\t    int datagram_reply)\n{\n    krb5_context context = r->context;\n    krb5_kdc_configuration *config = r->config;\n    KDC_REQ *req = &r->req;\n    KDC_REQ_BODY *b = NULL;\n    AS_REP rep;\n    KDCOptions f;\n    krb5_enctype setype;\n    krb5_error_code ret = 0;\n    Key *skey;\n    int found_pa = 0;\n    int i, flags = HDB_F_FOR_AS_REQ;\n    METHOD_DATA error_method;\n    const PA_DATA *pa;\n\n    memset(&rep, 0, sizeof(rep));\n    error_method.len = 0;\n    error_method.val = NULL;\n\n    /*\n     * Look for FAST armor and unwrap\n     */\n    ret = _kdc_fast_unwrap_request(r);\n    if (ret) {\n\t_kdc_r_log(r, 0, \"FAST unwrap request from %s failed: %d\", from, ret);\n\tgoto out;\n    }\n\n    b = &req->req_body;\n    f = b->kdc_options;\n\n    if (f.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->sname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \"No server in request\");\n    } else{\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->server_princ,\n\t\t\t\t\t\t  *(b->sname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret == 0)\n\t    ret = krb5_unparse_name(context, r->server_princ, &r->server_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"AS-REQ malformed server name from %s\", from);\n\tgoto out;\n    }\n    if(b->cname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \"No client in request\");\n    } else {\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->client_princ,\n\t\t\t\t\t\t  *(b->cname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, r->client_princ, &r->client_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"AS-REQ malformed client name from %s\", from);\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \"AS-REQ %s from %s for %s\",\n\t    r->client_name, from, r->server_name);\n\n    /*\n     *\n     */\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tif (!_kdc_is_anon_request(b)) {\n\t    kdc_log(context, config, 0, \"Anonymous ticket w/o anonymous flag\");\n\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    goto out;\n\t}\n    } else if (_kdc_is_anon_request(b)) {\n\tkdc_log(context, config, 0,\n\t\t\"Request for a anonymous ticket with non \"\n\t\t\"anonymous client name: %s\", r->client_name);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_db_fetch(context, config, r->client_princ,\n\t\t\tHDB_F_GET_CLIENT | flags, NULL,\n\t\t\t&r->clientdb, &r->client);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"client %s does not have secrets at this KDC, need to proxy\",\n\t\tr->client_name);\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n\tchar *fixed_client_name = NULL;\n\n\tret = krb5_unparse_name(context, r->client->entry.principal,\n\t\t\t\t&fixed_client_name);\n\tif (ret) {\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"WRONG_REALM - %s -> %s\",\n\t\tr->client_name, fixed_client_name);\n\tfree(fixed_client_name);\n\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t KRB5_KDC_ERR_WRONG_REALM,\n\t\t\t\t NULL,\n\t\t\t\t r->server_princ,\n\t\t\t\t NULL,\n\t\t\t\t &r->client->entry.principal->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->client_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n    ret = _kdc_db_fetch(context, config, r->server_princ,\n\t\t\tHDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,\n\t\t\tNULL, NULL, &r->server);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\",\n\t\tr->server_name);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->server_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     * Select a session enctype from the list of the crypto system\n     * supported enctypes that is supported by the client and is one of\n     * the enctype of the enctype of the service (likely krbtgt).\n     *\n     * The latter is used as a hint of what enctypes all KDC support,\n     * to make sure a newer version of KDC won't generate a session\n     * enctype that an older version of a KDC in the same realm can't\n     * decrypt.\n     */\n\n    ret = _kdc_find_etype(context,\n\t\t\t  krb5_principal_is_krbtgt(context, r->server_princ) ?\n\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t  r->client, b->etype.val, b->etype.len, &r->sessionetype,\n\t\t\t  NULL);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"Client (%s) from %s has no common enctypes with KDC \"\n\t\t\"to use for the session key\",\n\t\tr->client_name, from);\n\tgoto out;\n    }\n\n    /*\n     * Pre-auth processing\n     */\n\n    if(req->padata){\n\tunsigned int n;\n\n\tlog_patypes(context, config, req->padata);\n\n\t/* Check if preauth matching */\n\n\tfor (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if (pat[n].validate == NULL)\n\t\tcontinue;\n\t    if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))\n\t\tcontinue;\n\n\t    kdc_log(context, config, 5,\n\t\t    \"Looking for %s pa-data -- %s\", pat[n].name, r->client_name);\n\t    i = 0;\n\t    pa = _kdc_find_padata(req, &i, pat[n].type);\n\t    if (pa) {\n\t\tret = pat[n].validate(r, pa);\n\t\tif (ret != 0) {\n\t\t    goto out;\n\t\t}\n\t\tkdc_log(context, config, 0,\n\t\t\t\"%s pre-authentication succeeded -- %s\",\n\t\t\tpat[n].name, r->client_name);\n\t\tfound_pa = 1;\n\t\tr->et.flags.pre_authent = 1;\n\t    }\n\t}\n    }\n\n    if (found_pa == 0) {\n\tKey *ckey = NULL;\n\tsize_t n;\n\n\tfor (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if ((pat[n].flags & PA_ANNOUNCE) == 0)\n\t\tcontinue;\n\t    ret = krb5_padata_add(context, &error_method,\n\t\t\t\t  pat[n].type, NULL, 0);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is a client key, send ETYPE_INFO{,2}\n\t */\n\tret = _kdc_find_etype(context,\n\t\t\t      config->preauth_use_strongest_session_key, TRUE,\n\t\t\t      r->client, b->etype.val, b->etype.len, NULL, &ckey);\n\tif (ret == 0) {\n\n\t    /*\n\t     * RFC4120 requires:\n\t     * - If the client only knows about old enctypes, then send\n\t     *   both info replies (we send 'info' first in the list).\n\t     * - If the client is 'modern', because it knows about 'new'\n\t     *   enctype types, then only send the 'info2' reply.\n\t     *\n\t     * Before we send the full list of etype-info data, we pick\n\t     * the client key we would have used anyway below, just pick\n\t     * that instead.\n\t     */\n\n\t    if (older_enctype(ckey->key.keytype)) {\n\t\tret = get_pa_etype_info(context, config,\n\t\t\t\t\t&error_method, ckey);\n\t\tif (ret)\n\t\t    goto out;\n\t    }\n\t    ret = get_pa_etype_info2(context, config,\n\t\t\t\t     &error_method, ckey);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/* \n\t * send requre preauth is its required or anon is requested,\n\t * anon is today only allowed via preauth mechanisms.\n\t */\n\tif (require_preauth_p(r) || _kdc_is_anon_request(b)) {\n\t    ret = KRB5KDC_ERR_PREAUTH_REQUIRED;\n\t    _kdc_set_e_text(r, \"Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ\");\n\t    goto out;\n\t}\n\n\tif (ckey == NULL) {\n\t    ret = KRB5KDC_ERR_CLIENT_NOTYET;\n\t    _kdc_set_e_text(r, \"Doesn't have a client key available\");\n\t    goto out;\n\t}\n\tkrb5_free_keyblock_contents(r->context,  &r->reply_key);\n\tret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->clientdb->hdb_auth_status) {\n\tr->clientdb->hdb_auth_status(context, r->clientdb, r->client, \n\t\t\t\t     HDB_AUTH_SUCCESS);\n    }\n\n    /*\n     * Verify flags after the user been required to prove its identity\n     * with in a preauth mech.\n     */\n\n    ret = _kdc_check_access(context, config, r->client, r->client_name,\n\t\t\t    r->server, r->server_name,\n\t\t\t    req, &error_method);\n    if(ret)\n\tgoto out;\n\n    /*\n     * Select the best encryption type for the KDC with out regard to\n     * the client since the client never needs to read that data.\n     */\n\n    ret = _kdc_get_preferred_key(context, config,\n\t\t\t\t r->server, r->server_name,\n\t\t\t\t &setype, &skey);\n    if(ret)\n\tgoto out;\n\n    if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey\n       || (_kdc_is_anon_request(b) && !config->allow_anonymous)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\t_kdc_set_e_text(r, \"Bad KDC options\");\n\tgoto out;\n    }\n\n    /*\n     * Build reply\n     */\n\n    rep.pvno = 5;\n    rep.msg_type = krb_as_rep;\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tRealm anon_realm=KRB5_ANON_REALM;\n\tret = copy_Realm(&anon_realm, &rep.crealm);\n    } else\n\tret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);\n    if (ret)\n\tgoto out;\n    ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);\n    if (ret)\n\tgoto out;\n\n    rep.ticket.tkt_vno = 5;\n    ret = copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);\n    if (ret)\n\tgoto out;\n    _krb5_principal2principalname(&rep.ticket.sname,\n\t\t\t\t  r->server->entry.principal);\n    /* java 1.6 expects the name to be the same type, lets allow that\n     * uncomplicated name-types. */\n#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)\n    if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))\n\trep.ticket.sname.name_type = b->sname->name_type;\n#undef CNT\n\n    r->et.flags.initial = 1;\n    if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)\n\tr->et.flags.forwardable = f.forwardable;\n    else if (f.forwardable) {\n\t_kdc_set_e_text(r, \"Ticket may not be forwardable\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)\n\tr->et.flags.proxiable = f.proxiable;\n    else if (f.proxiable) {\n\t_kdc_set_e_text(r, \"Ticket may not be proxiable\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)\n\tr->et.flags.may_postdate = f.allow_postdate;\n    else if (f.allow_postdate){\n\t_kdc_set_e_text(r, \"Ticket may not be postdate\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {\n\t_kdc_set_e_text(r, \"Bad address list in requested\");\n\tret = KRB5KRB_AP_ERR_BADADDR;\n\tgoto out;\n    }\n\n    ret = copy_PrincipalName(&rep.cname, &r->et.cname);\n    if (ret)\n\tgoto out;\n    ret = copy_Realm(&rep.crealm, &r->et.crealm);\n    if (ret)\n\tgoto out;\n\n    {\n\ttime_t start;\n\ttime_t t;\n\t\n\tstart = r->et.authtime = kdc_time;\n\n\tif(f.postdated && req->req_body.from){\n\t    ALLOC(r->et.starttime);\n\t    start = *r->et.starttime = *req->req_body.from;\n\t    r->et.flags.invalid = 1;\n\t    r->et.flags.postdated = 1; /* XXX ??? */\n\t}\n\t_kdc_fix_time(&b->till);\n\tt = *b->till;\n\n\t/* be careful not overflowing */\n\n\tif(r->client->entry.max_life)\n\t    t = start + min(t - start, *r->client->entry.max_life);\n\tif(r->server->entry.max_life)\n\t    t = start + min(t - start, *r->server->entry.max_life);\n#if 0\n\tt = min(t, start + realm->max_life);\n#endif\n\tr->et.endtime = t;\n\tif(f.renewable_ok && r->et.endtime < *b->till){\n\t    f.renewable = 1;\n\t    if(b->rtime == NULL){\n\t\tALLOC(b->rtime);\n\t\t*b->rtime = 0;\n\t    }\n\t    if(*b->rtime < *b->till)\n\t\t*b->rtime = *b->till;\n\t}\n\tif(f.renewable && b->rtime){\n\t    t = *b->rtime;\n\t    if(t == 0)\n\t\tt = MAX_TIME;\n\t    if(r->client->entry.max_renew)\n\t\tt = start + min(t - start, *r->client->entry.max_renew);\n\t    if(r->server->entry.max_renew)\n\t\tt = start + min(t - start, *r->server->entry.max_renew);\n#if 0\n\t    t = min(t, start + realm->max_renew);\n#endif\n\t    ALLOC(r->et.renew_till);\n\t    *r->et.renew_till = t;\n\t    r->et.flags.renewable = 1;\n\t}\n    }\n\n    if (_kdc_is_anon_request(b))\n\tr->et.flags.anonymous = 1;\n\n    if(b->addresses){\n\tALLOC(r->et.caddr);\n\tcopy_HostAddresses(b->addresses, r->et.caddr);\n    }\n\n    r->et.transited.tr_type = DOMAIN_X500_COMPRESS;\n    krb5_data_zero(&r->et.transited.contents);\n\n    /* The MIT ASN.1 library (obviously) doesn't tell lengths encoded\n     * as 0 and as 0x80 (meaning indefinite length) apart, and is thus\n     * incapable of correctly decoding SEQUENCE OF's of zero length.\n     *\n     * To fix this, always send at least one no-op last_req\n     *\n     * If there's a pw_end or valid_end we will use that,\n     * otherwise just a dummy lr.\n     */\n    r->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));\n    if (r->ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    r->ek.last_req.len = 0;\n    if (r->client->entry.pw_end\n\t&& (config->kdc_warn_pwexpire == 0\n\t    || kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->client->entry.valid_end) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->ek.last_req.len == 0) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = 0;\n\t++r->ek.last_req.len;\n    }\n    r->ek.nonce = b->nonce;\n    if (r->client->entry.valid_end || r->client->entry.pw_end) {\n\tALLOC(r->ek.key_expiration);\n\tif (r->client->entry.valid_end) {\n\t    if (r->client->entry.pw_end)\n\t\t*r->ek.key_expiration = min(*r->client->entry.valid_end,\n\t\t\t\t\t *r->client->entry.pw_end);\n\t    else\n\t\t*r->ek.key_expiration = *r->client->entry.valid_end;\n\t} else\n\t    *r->ek.key_expiration = *r->client->entry.pw_end;\n    } else\n\tr->ek.key_expiration = NULL;\n    r->ek.flags = r->et.flags;\n    r->ek.authtime = r->et.authtime;\n    if (r->et.starttime) {\n\tALLOC(r->ek.starttime);\n\t*r->ek.starttime = *r->et.starttime;\n    }\n    r->ek.endtime = r->et.endtime;\n    if (r->et.renew_till) {\n\tALLOC(r->ek.renew_till);\n\t*r->ek.renew_till = *r->et.renew_till;\n    }\n    ret = copy_Realm(&rep.ticket.realm, &r->ek.srealm);\n    if (ret)\n\tgoto out;\n    ret = copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);\n    if (ret)\n\tgoto out;\n    if(r->et.caddr){\n\tALLOC(r->ek.caddr);\n\tcopy_HostAddresses(r->et.caddr, r->ek.caddr);\n    }\n\n    /*\n     * Check and session and reply keys\n     */\n\n    if (r->session_key.keytype == ETYPE_NULL) {\n\tret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->reply_key.keytype == ETYPE_NULL) {\n\t_kdc_set_e_text(r, \"Client have no reply key\");\n\tret = KRB5KDC_ERR_CLIENT_NOTYET;\n\tgoto out;\n    }\n\n    ret = copy_EncryptionKey(&r->session_key, &r->et.key);\n    if (ret)\n\tgoto out;\n\n    ret = copy_EncryptionKey(&r->session_key, &r->ek.key);\n    if (ret)\n\tgoto out;\n\n    if (r->outpadata.len) {\n\n\tALLOC(rep.padata);\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(&r->outpadata, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    /* Add the PAC */\n    if (send_pac_p(context, req)) {\n\tgenerate_pac(r, skey);\n    }\n\n    _kdc_log_timestamp(context, config, \"AS-REQ\", r->et.authtime, r->et.starttime,\n\t\t       r->et.endtime, r->et.renew_till);\n\n    /* do this as the last thing since this signs the EncTicketPart */\n    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t  config,\n\t\t\t\t  r->server,\n\t\t\t\t  setype,\n\t\t\t\t  r->client->entry.principal,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  &r->et);\n    if (ret)\n\tgoto out;\n\n    log_as_req(context, config, r->reply_key.keytype, setype, b);\n\n    /*\n     * We always say we support FAST/enc-pa-rep\n     */\n\n    r->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;\n\n    /*\n     * Add REQ_ENC_PA_REP if client supports it\n     */\n\n    i = 0;\n    pa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);\n    if (pa) {\n\n\tret = add_enc_pa_rep(r);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(r->context, ret);\n\t    _kdc_r_log(r, 0, \"add_enc_pa_rep failed: %s: %d\", msg, ret);\n\t    krb5_free_error_message(r->context, msg);\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_encode_reply(context, config,\n\t\t\t    r->armor_crypto, req->req_body.nonce,\n\t\t\t    &rep, &r->et, &r->ek, setype, r->server->entry.kvno,\n\t\t\t    &skey->key, r->client->entry.kvno,\n\t\t\t    &r->reply_key, 0, &r->e_text, reply);\n    if (ret)\n\tgoto out;\n\n    /*\n     * Check if message too large\n     */\n    if (datagram_reply && reply->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(reply);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\t_kdc_set_e_text(r, \"Reply packet too large\");\n    }\n\nout:\n    free_AS_REP(&rep);\n\n    /*\n     * In case of a non proxy error, build an error message.\n     */\n    if (ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t ret, r->e_text,\n\t\t\t\t r->server_princ,\n\t\t\t\t r->client_princ ?\n                                     &r->client_princ->name : NULL,\n\t\t\t\t r->client_princ ?\n                                     &r->client_princ->realm : NULL,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tif (ret)\n\t    goto out2;\n    }\nout2:\n    free_EncTicketPart(&r->et);\n    free_EncKDCRepPart(&r->ek);\n    free_KDCFastState(&r->fast);\n\n    if (error_method.len)\n\tfree_METHOD_DATA(&error_method);\n    if (r->outpadata.len)\n\tfree_METHOD_DATA(&r->outpadata);\n    if (r->client_princ) {\n\tkrb5_free_principal(context, r->client_princ);\n\tr->client_princ = NULL;\n    }\n    if (r->client_name) {\n\tfree(r->client_name);\n\tr->client_name = NULL;\n    }\n    if (r->server_princ){\n\tkrb5_free_principal(context, r->server_princ);\n\tr->server_princ = NULL;\n    }\n    if (r->server_name) {\n\tfree(r->server_name);\n\tr->server_name = NULL;\n    }\n    if (r->client)\n\t_kdc_free_ent(context, r->client);\n    if (r->server)\n\t_kdc_free_ent(context, r->server);\n    if (r->armor_crypto) {\n\tkrb5_crypto_destroy(r->context, r->armor_crypto);\n\tr->armor_crypto = NULL;\n    }\n    krb5_free_keyblock_contents(r->context, &r->reply_key);\n    krb5_free_keyblock_contents(r->context, &r->session_key);\n    return ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149643,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (buf->currentLine == NULL ||\n\t    spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n\trows = form->rows ? form->rows : 1;\n\tcol = COLPOS(l, a->start.pos);\n\tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n\t    if (rows > 1) {\n\t\tpos = columnPos(l, col);\n\t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len ||\n\t\tspos < 0 || epos < 0 || COLPOS(l, epos) < col)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149644,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (buf->currentLine == NULL ||\n\t    spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n\trows = form->rows ? form->rows : 1;\n\tcol = COLPOS(l, a->start.pos);\n\tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n\t    if (l == NULL)\n\t\tbreak;\n\t    if (rows > 1) {\n\t\tpos = columnPos(l, col);\n\t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len ||\n\t\tspos < 0 || epos < 0 || COLPOS(l, epos) < col)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149645,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "lexer_process_char_literal (parser_context_t *context_p, /**< context */\n                            const uint8_t *char_p, /**< characters */\n                            size_t length, /**< length of string */\n                            uint8_t literal_type, /**< final literal type */\n                            bool has_escape) /**< has escape sequences */\n{\n  parser_list_iterator_t literal_iterator;\n  lexer_literal_t *literal_p;\n  uint32_t literal_index = 0;\n\n  JERRY_ASSERT (literal_type == LEXER_IDENT_LITERAL\n                || literal_type == LEXER_STRING_LITERAL);\n\n  JERRY_ASSERT (literal_type != LEXER_IDENT_LITERAL || length <= PARSER_MAXIMUM_IDENT_LENGTH);\n  JERRY_ASSERT (literal_type != LEXER_STRING_LITERAL || length <= PARSER_MAXIMUM_STRING_LENGTH);\n\n  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n\n  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n  {\n    if (literal_p->type == literal_type\n        && literal_p->prop.length == length\n        && memcmp (literal_p->u.char_p, char_p, length) == 0)\n    {\n      context_p->lit_object.literal_p = literal_p;\n      context_p->lit_object.index = (uint16_t) literal_index;\n      literal_p->status_flags = (uint8_t) (literal_p->status_flags & ~LEXER_FLAG_UNUSED_IDENT);\n      return;\n    }\n\n    literal_index++;\n  }\n\n  JERRY_ASSERT (literal_index == context_p->literal_count);\n\n  if (literal_index >= PARSER_MAXIMUM_NUMBER_OF_LITERALS)\n  {\n    parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);\n  }\n\n  literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);\n  literal_p->prop.length = (uint16_t) length;\n  literal_p->type = literal_type;\n  literal_p->status_flags = has_escape ? 0 : LEXER_FLAG_SOURCE_PTR;\n\n  if (has_escape)\n  {\n    literal_p->u.char_p = (uint8_t *) jmem_heap_alloc_block (length);\n    memcpy ((uint8_t *) literal_p->u.char_p, char_p, length);\n  }\n  else\n  {\n    literal_p->u.char_p = char_p;\n  }\n\n  context_p->lit_object.literal_p = literal_p;\n  context_p->lit_object.index = (uint16_t) literal_index;\n  context_p->literal_count++;\n} /* lexer_process_char_literal */",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149646,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "lexer_process_char_literal (parser_context_t *context_p, /**< context */\n                            const uint8_t *char_p, /**< characters */\n                            size_t length, /**< length of string */\n                            uint8_t literal_type, /**< final literal type */\n                            bool has_escape) /**< has escape sequences */\n{\n  parser_list_iterator_t literal_iterator;\n  lexer_literal_t *literal_p;\n  uint32_t literal_index = 0;\n\n  JERRY_ASSERT (literal_type == LEXER_IDENT_LITERAL\n                || literal_type == LEXER_STRING_LITERAL);\n\n  JERRY_ASSERT (literal_type != LEXER_IDENT_LITERAL || length <= PARSER_MAXIMUM_IDENT_LENGTH);\n  JERRY_ASSERT (literal_type != LEXER_STRING_LITERAL || length <= PARSER_MAXIMUM_STRING_LENGTH);\n\n  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n\n  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n  {\n    if (literal_p->type == literal_type\n        && literal_p->prop.length == length\n        && memcmp (literal_p->u.char_p, char_p, length) == 0)\n    {\n      context_p->lit_object.literal_p = literal_p;\n      context_p->lit_object.index = (uint16_t) literal_index;\n      literal_p->status_flags = (uint8_t) (literal_p->status_flags & ~LEXER_FLAG_UNUSED_IDENT);\n      return;\n    }\n\n    literal_index++;\n  }\n\n  JERRY_ASSERT (literal_index == context_p->literal_count);\n\n  if (literal_index >= PARSER_MAXIMUM_NUMBER_OF_LITERALS)\n  {\n    parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);\n  }\n\n  if (length == 0)\n  {\n    has_escape = false;\n  }\n\n  literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);\n  literal_p->prop.length = (uint16_t) length;\n  literal_p->type = literal_type;\n  literal_p->status_flags = has_escape ? 0 : LEXER_FLAG_SOURCE_PTR;\n\n  if (has_escape)\n  {\n    literal_p->u.char_p = (uint8_t *) jmem_heap_alloc_block (length);\n    memcpy ((uint8_t *) literal_p->u.char_p, char_p, length);\n  }\n  else\n  {\n    literal_p->u.char_p = char_p;\n  }\n\n  context_p->lit_object.literal_p = literal_p;\n  context_p->lit_object.index = (uint16_t) literal_index;\n  context_p->literal_count++;\n} /* lexer_process_char_literal */",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149647,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int unimac_mdio_probe(struct platform_device *pdev)\n{\n\tstruct unimac_mdio_pdata *pdata = pdev->dev.platform_data;\n\tstruct unimac_mdio_priv *priv;\n\tstruct device_node *np;\n\tstruct mii_bus *bus;\n\tstruct resource *r;\n\tint ret;\n\n\tnp = pdev->dev.of_node;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\n\t/* Just ioremap, as this MDIO block is usually integrated into an\n\t * Ethernet MAC controller register range\n\t */\n\tpriv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!priv->base) {\n\t\tdev_err(&pdev->dev, \"failed to remap register\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->mii_bus = mdiobus_alloc();\n\tif (!priv->mii_bus)\n\t\treturn -ENOMEM;\n\n\tbus = priv->mii_bus;\n\tbus->priv = priv;\n\tif (pdata) {\n\t\tbus->name = pdata->bus_name;\n\t\tpriv->wait_func = pdata->wait_func;\n\t\tpriv->wait_func_data = pdata->wait_func_data;\n\t\tbus->phy_mask = ~pdata->phy_mask;\n\t} else {\n\t\tbus->name = \"unimac MII bus\";\n\t\tpriv->wait_func_data = priv;\n\t\tpriv->wait_func = unimac_mdio_poll;\n\t}\n\tbus->parent = &pdev->dev;\n\tbus->read = unimac_mdio_read;\n\tbus->write = unimac_mdio_write;\n\tbus->reset = unimac_mdio_reset;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-%d\", pdev->name, pdev->id);\n\n\tret = of_mdiobus_register(bus, np);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"MDIO bus registration failed\\n\");\n\t\tgoto out_mdio_free;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tdev_info(&pdev->dev, \"Broadcom UniMAC MDIO bus at 0x%p\\n\", priv->base);\n\n\treturn 0;\n\nout_mdio_free:\n\tmdiobus_free(bus);\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149648,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int unimac_mdio_probe(struct platform_device *pdev)\n{\n\tstruct unimac_mdio_pdata *pdata = pdev->dev.platform_data;\n\tstruct unimac_mdio_priv *priv;\n\tstruct device_node *np;\n\tstruct mii_bus *bus;\n\tstruct resource *r;\n\tint ret;\n\n\tnp = pdev->dev.of_node;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r)\n\t\treturn -EINVAL;\n\n\t/* Just ioremap, as this MDIO block is usually integrated into an\n\t * Ethernet MAC controller register range\n\t */\n\tpriv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!priv->base) {\n\t\tdev_err(&pdev->dev, \"failed to remap register\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->mii_bus = mdiobus_alloc();\n\tif (!priv->mii_bus)\n\t\treturn -ENOMEM;\n\n\tbus = priv->mii_bus;\n\tbus->priv = priv;\n\tif (pdata) {\n\t\tbus->name = pdata->bus_name;\n\t\tpriv->wait_func = pdata->wait_func;\n\t\tpriv->wait_func_data = pdata->wait_func_data;\n\t\tbus->phy_mask = ~pdata->phy_mask;\n\t} else {\n\t\tbus->name = \"unimac MII bus\";\n\t\tpriv->wait_func_data = priv;\n\t\tpriv->wait_func = unimac_mdio_poll;\n\t}\n\tbus->parent = &pdev->dev;\n\tbus->read = unimac_mdio_read;\n\tbus->write = unimac_mdio_write;\n\tbus->reset = unimac_mdio_reset;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-%d\", pdev->name, pdev->id);\n\n\tret = of_mdiobus_register(bus, np);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"MDIO bus registration failed\\n\");\n\t\tgoto out_mdio_free;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tdev_info(&pdev->dev, \"Broadcom UniMAC MDIO bus at 0x%p\\n\", priv->base);\n\n\treturn 0;\n\nout_mdio_free:\n\tmdiobus_free(bus);\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149649,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int hi3660_stub_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tunsigned int i;\n\tint ret;\n\n\t/* Use mailbox client without blocking */\n\tstub_clk_chan.cl.dev = dev;\n\tstub_clk_chan.cl.tx_done = NULL;\n\tstub_clk_chan.cl.tx_block = false;\n\tstub_clk_chan.cl.knows_txdone = false;\n\n\t/* Allocate mailbox channel */\n\tstub_clk_chan.mbox = mbox_request_channel(&stub_clk_chan.cl, 0);\n\tif (IS_ERR(stub_clk_chan.mbox))\n\t\treturn PTR_ERR(stub_clk_chan.mbox);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tfreq_reg = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!freq_reg)\n\t\treturn -ENOMEM;\n\n\tfreq_reg += HI3660_STUB_CLOCK_DATA;\n\n\tfor (i = 0; i < HI3660_CLK_STUB_NUM; i++) {\n\t\tret = devm_clk_hw_register(&pdev->dev, &hi3660_stub_clks[i].hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, hi3660_stub_clk_hw_get,\n\t\t\t\t\t   hi3660_stub_clks);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149650,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int hi3660_stub_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tunsigned int i;\n\tint ret;\n\n\t/* Use mailbox client without blocking */\n\tstub_clk_chan.cl.dev = dev;\n\tstub_clk_chan.cl.tx_done = NULL;\n\tstub_clk_chan.cl.tx_block = false;\n\tstub_clk_chan.cl.knows_txdone = false;\n\n\t/* Allocate mailbox channel */\n\tstub_clk_chan.mbox = mbox_request_channel(&stub_clk_chan.cl, 0);\n\tif (IS_ERR(stub_clk_chan.mbox))\n\t\treturn PTR_ERR(stub_clk_chan.mbox);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\tfreq_reg = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!freq_reg)\n\t\treturn -ENOMEM;\n\n\tfreq_reg += HI3660_STUB_CLOCK_DATA;\n\n\tfor (i = 0; i < HI3660_CLK_STUB_NUM; i++) {\n\t\tret = devm_clk_hw_register(&pdev->dev, &hi3660_stub_clks[i].hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, hi3660_stub_clk_hw_get,\n\t\t\t\t\t   hi3660_stub_clks);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149651,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,\n\t\t\t\t\t\t  const struct assoc_array_ops *ops,\n\t\t\t\t\t\t  const void *index_key,\n\t\t\t\t\t\t  struct assoc_array_walk_result *result)\n{\n\tstruct assoc_array_shortcut *shortcut, *new_s0;\n\tstruct assoc_array_node *node, *new_n0, *new_n1, *side;\n\tstruct assoc_array_ptr *ptr;\n\tunsigned long dissimilarity, base_seg, blank;\n\tsize_t keylen;\n\tbool have_meta;\n\tint level, diff;\n\tint slot, next_slot, free_slot, i, j;\n\n\tnode\t= result->terminal_node.node;\n\tlevel\t= result->terminal_node.level;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = result->terminal_node.slot;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\t/* We arrived at a node which doesn't have an onward node or shortcut\n\t * pointer that we have to follow.  This means that (a) the leaf we\n\t * want must go here (either by insertion or replacement) or (b) we\n\t * need to split this node and insert in one of the fragments.\n\t */\n\tfree_slot = -1;\n\n\t/* Firstly, we have to check the leaves in this node to see if there's\n\t * a matching one we should replace in place.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (!ptr) {\n\t\t\tfree_slot = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ops->compare_object(assoc_array_ptr_to_leaf(ptr), index_key)) {\n\t\t\tpr_devel(\"replace in slot %d\\n\", i);\n\t\t\tedit->leaf_p = &node->slots[i];\n\t\t\tedit->dead_leaf = node->slots[i];\n\t\t\tpr_devel(\"<--%s() = ok [replace]\\n\", __func__);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* If there is a free slot in this node then we can just insert the\n\t * leaf here.\n\t */\n\tif (free_slot >= 0) {\n\t\tpr_devel(\"insert in free slot %d\\n\", free_slot);\n\t\tedit->leaf_p = &node->slots[free_slot];\n\t\tedit->adjust_count_on = node;\n\t\tpr_devel(\"<--%s() = ok [insert]\\n\", __func__);\n\t\treturn true;\n\t}\n\n\t/* The node has no spare slots - so we're either going to have to split\n\t * it or insert another node before it.\n\t *\n\t * Whatever, we're going to need at least two new nodes - so allocate\n\t * those now.  We may also need a new shortcut, but we deal with that\n\t * when we need it.\n\t */\n\tnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n0)\n\t\treturn false;\n\tedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\n\tnew_n1 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n1)\n\t\treturn false;\n\tedit->new_meta[1] = assoc_array_node_to_ptr(new_n1);\n\n\t/* We need to find out how similar the leaves are. */\n\tpr_devel(\"no spare slots\\n\");\n\thave_meta = false;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (assoc_array_ptr_is_meta(ptr)) {\n\t\t\tedit->segment_cache[i] = 0xff;\n\t\t\thave_meta = true;\n\t\t\tcontinue;\n\t\t}\n\t\tbase_seg = ops->get_object_key_chunk(\n\t\t\tassoc_array_ptr_to_leaf(ptr), level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tif (have_meta) {\n\t\tpr_devel(\"have meta\\n\");\n\t\tgoto split_node;\n\t}\n\n\t/* The node contains only leaves */\n\tdissimilarity = 0;\n\tbase_seg = edit->segment_cache[0];\n\tfor (i = 1; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tdissimilarity |= edit->segment_cache[i] ^ base_seg;\n\n\tpr_devel(\"only leaves; dissimilarity=%lx\\n\", dissimilarity);\n\n\tif ((dissimilarity & ASSOC_ARRAY_FAN_MASK) == 0) {\n\t\t/* The old leaves all cluster in the same slot.  We will need\n\t\t * to insert a shortcut if the new node wants to cluster with them.\n\t\t */\n\t\tif ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0)\n\t\t\tgoto all_leaves_cluster_together;\n\n\t\t/* Otherwise we can just insert a new node ahead of the old\n\t\t * one.\n\t\t */\n\t\tgoto present_leaves_cluster_but_not_new_leaf;\n\t}\n\nsplit_node:\n\tpr_devel(\"split node\\n\");\n\n\t/* We need to split the current node; we know that the node doesn't\n\t * simply contain a full set of leaves that cluster together (it\n\t * contains meta pointers and/or non-clustering leaves).\n\t *\n\t * We need to expel at least two leaves out of a set consisting of the\n\t * leaves in the node and the new leaf.\n\t *\n\t * We need a new node (n0) to replace the current one and a new node to\n\t * take the expelled nodes (n1).\n\t */\n\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = node->back_pointer;\n\tnew_n0->parent_slot = node->parent_slot;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to calculate this */\n\ndo_split_node:\n\tpr_devel(\"do_split_node\\n\");\n\n\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tnew_n1->nr_leaves_on_branch = 0;\n\n\t/* Begin by finding two matching leaves.  There have to be at least two\n\t * that match - even if there are meta pointers - because any leaf that\n\t * would match a slot with a meta pointer in it must be somewhere\n\t * behind that meta pointer and cannot be here.  Further, given N\n\t * remaining leaf slots, we now have N+1 leaves to go in them.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tslot = edit->segment_cache[i];\n\t\tif (slot != 0xff)\n\t\t\tfor (j = i + 1; j < ASSOC_ARRAY_FAN_OUT + 1; j++)\n\t\t\t\tif (edit->segment_cache[j] == slot)\n\t\t\t\t\tgoto found_slot_for_multiple_occupancy;\n\t}\nfound_slot_for_multiple_occupancy:\n\tpr_devel(\"same slot: %x %x [%02x]\\n\", i, j, slot);\n\tBUG_ON(i >= ASSOC_ARRAY_FAN_OUT);\n\tBUG_ON(j >= ASSOC_ARRAY_FAN_OUT + 1);\n\tBUG_ON(slot >= ASSOC_ARRAY_FAN_OUT);\n\n\tnew_n1->parent_slot = slot;\n\n\t/* Metadata pointers cannot change slot */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tnew_n0->slots[i] = node->slots[i];\n\t\telse\n\t\t\tnew_n0->slots[i] = NULL;\n\tBUG_ON(new_n0->slots[slot] != NULL);\n\tnew_n0->slots[slot] = assoc_array_node_to_ptr(new_n1);\n\n\t/* Filter the leaf pointers between the new nodes */\n\tfree_slot = -1;\n\tnext_slot = 0;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tcontinue;\n\t\tif (edit->segment_cache[i] == slot) {\n\t\t\tnew_n1->slots[next_slot++] = node->slots[i];\n\t\t\tnew_n1->nr_leaves_on_branch++;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tfree_slot++;\n\t\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\t\tnew_n0->slots[free_slot] = node->slots[i];\n\t\t}\n\t}\n\n\tpr_devel(\"filtered: f=%x n=%x\\n\", free_slot, next_slot);\n\n\tif (edit->segment_cache[ASSOC_ARRAY_FAN_OUT] != slot) {\n\t\tdo {\n\t\t\tfree_slot++;\n\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\tedit->leaf_p = &new_n0->slots[free_slot];\n\t\tedit->adjust_count_on = new_n0;\n\t} else {\n\t\tedit->leaf_p = &new_n1->slots[next_slot++];\n\t\tedit->adjust_count_on = new_n1;\n\t}\n\n\tBUG_ON(next_slot <= 1);\n\n\tedit->set_backpointers_to = assoc_array_node_to_ptr(new_n0);\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (edit->segment_cache[i] == 0xff) {\n\t\t\tptr = node->slots[i];\n\t\t\tBUG_ON(assoc_array_ptr_is_leaf(ptr));\n\t\t\tif (assoc_array_ptr_is_node(ptr)) {\n\t\t\t\tside = assoc_array_ptr_to_node(ptr);\n\t\t\t\tedit->set_backpointers[i] = &side->back_pointer;\n\t\t\t} else {\n\t\t\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\t\t\tedit->set_backpointers[i] = &shortcut->back_pointer;\n\t\t\t}\n\t\t}\n\t}\n\n\tptr = node->back_pointer;\n\tif (!ptr)\n\t\tedit->set[0].ptr = &edit->array->root;\n\telse if (assoc_array_ptr_is_node(ptr))\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_node(ptr)->slots[node->parent_slot];\n\telse\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_shortcut(ptr)->next_node;\n\tedit->excised_meta[0] = assoc_array_node_to_ptr(node);\n\tpr_devel(\"<--%s() = ok [split node]\\n\", __func__);\n\treturn true;\n\npresent_leaves_cluster_but_not_new_leaf:\n\t/* All the old leaves cluster in the same slot, but the new leaf wants\n\t * to go into a different slot, so we create a new node to hold the new\n\t * leaf and a pointer to a new node holding all the old leaves.\n\t */\n\tpr_devel(\"present leaves cluster but not new leaf\\n\");\n\n\tnew_n0->back_pointer = node->back_pointer;\n\tnew_n0->parent_slot = node->parent_slot;\n\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = edit->segment_cache[0];\n\tnew_n1->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tedit->adjust_count_on = new_n0;\n\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tnew_n1->slots[i] = node->slots[i];\n\n\tnew_n0->slots[edit->segment_cache[0]] = assoc_array_node_to_ptr(new_n0);\n\tedit->leaf_p = &new_n0->slots[edit->segment_cache[ASSOC_ARRAY_FAN_OUT]];\n\n\tedit->set[0].ptr = &assoc_array_ptr_to_node(node->back_pointer)->slots[node->parent_slot];\n\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\tedit->excised_meta[0] = assoc_array_node_to_ptr(node);\n\tpr_devel(\"<--%s() = ok [insert node before]\\n\", __func__);\n\treturn true;\n\nall_leaves_cluster_together:\n\t/* All the leaves, new and old, want to cluster together in this node\n\t * in the same slot, so we have to replace this node with a shortcut to\n\t * skip over the identical parts of the key and then place a pair of\n\t * nodes, one inside the other, at the end of the shortcut and\n\t * distribute the keys between them.\n\t *\n\t * Firstly we need to work out where the leaves start diverging as a\n\t * bit position into their keys so that we know how big the shortcut\n\t * needs to be.\n\t *\n\t * We only need to make a single pass of N of the N+1 leaves because if\n\t * any keys differ between themselves at bit X then at least one of\n\t * them must also differ with the base key at bit X or before.\n\t */\n\tpr_devel(\"all leaves cluster together\\n\");\n\tdiff = INT_MAX;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tint x = ops->diff_objects(assoc_array_ptr_to_leaf(node->slots[i]),\n\t\t\t\t\t  index_key);\n\t\tif (x < diff) {\n\t\t\tBUG_ON(x < 0);\n\t\t\tdiff = x;\n\t\t}\n\t}\n\tBUG_ON(diff == INT_MAX);\n\tBUG_ON(diff < level + ASSOC_ARRAY_LEVEL_STEP);\n\n\tkeylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\tkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\n\n\tnew_s0 = kzalloc(sizeof(struct assoc_array_shortcut) +\n\t\t\t keylen * sizeof(unsigned long), GFP_KERNEL);\n\tif (!new_s0)\n\t\treturn false;\n\tedit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s0);\n\n\tedit->set[0].to = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_s0->back_pointer = node->back_pointer;\n\tnew_s0->parent_slot = node->parent_slot;\n\tnew_s0->next_node = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_n0->parent_slot = 0;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to calculate this */\n\n\tnew_s0->skip_to_level = level = diff & ~ASSOC_ARRAY_LEVEL_STEP_MASK;\n\tpr_devel(\"skip_to_level = %d [diff %d]\\n\", level, diff);\n\tBUG_ON(level <= 0);\n\n\tfor (i = 0; i < keylen; i++)\n\t\tnew_s0->index_key[i] =\n\t\t\tops->get_key_chunk(index_key, i * ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\n\tblank = ULONG_MAX << (level & ASSOC_ARRAY_KEY_CHUNK_MASK);\n\tpr_devel(\"blank off [%zu] %d: %lx\\n\", keylen - 1, level, blank);\n\tnew_s0->index_key[keylen - 1] &= ~blank;\n\n\t/* This now reduces to a node splitting exercise for which we'll need\n\t * to regenerate the disparity table.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tbase_seg = ops->get_object_key_chunk(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\t\t     level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tbase_seg = ops->get_key_chunk(index_key, level);\n\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\tgoto do_split_node;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149652,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,\n\t\t\t\t\t\t  const struct assoc_array_ops *ops,\n\t\t\t\t\t\t  const void *index_key,\n\t\t\t\t\t\t  struct assoc_array_walk_result *result)\n{\n\tstruct assoc_array_shortcut *shortcut, *new_s0;\n\tstruct assoc_array_node *node, *new_n0, *new_n1, *side;\n\tstruct assoc_array_ptr *ptr;\n\tunsigned long dissimilarity, base_seg, blank;\n\tsize_t keylen;\n\tbool have_meta;\n\tint level, diff;\n\tint slot, next_slot, free_slot, i, j;\n\n\tnode\t= result->terminal_node.node;\n\tlevel\t= result->terminal_node.level;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = result->terminal_node.slot;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\t/* We arrived at a node which doesn't have an onward node or shortcut\n\t * pointer that we have to follow.  This means that (a) the leaf we\n\t * want must go here (either by insertion or replacement) or (b) we\n\t * need to split this node and insert in one of the fragments.\n\t */\n\tfree_slot = -1;\n\n\t/* Firstly, we have to check the leaves in this node to see if there's\n\t * a matching one we should replace in place.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (!ptr) {\n\t\t\tfree_slot = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (assoc_array_ptr_is_leaf(ptr) &&\n\t\t    ops->compare_object(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\tindex_key)) {\n\t\t\tpr_devel(\"replace in slot %d\\n\", i);\n\t\t\tedit->leaf_p = &node->slots[i];\n\t\t\tedit->dead_leaf = node->slots[i];\n\t\t\tpr_devel(\"<--%s() = ok [replace]\\n\", __func__);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* If there is a free slot in this node then we can just insert the\n\t * leaf here.\n\t */\n\tif (free_slot >= 0) {\n\t\tpr_devel(\"insert in free slot %d\\n\", free_slot);\n\t\tedit->leaf_p = &node->slots[free_slot];\n\t\tedit->adjust_count_on = node;\n\t\tpr_devel(\"<--%s() = ok [insert]\\n\", __func__);\n\t\treturn true;\n\t}\n\n\t/* The node has no spare slots - so we're either going to have to split\n\t * it or insert another node before it.\n\t *\n\t * Whatever, we're going to need at least two new nodes - so allocate\n\t * those now.  We may also need a new shortcut, but we deal with that\n\t * when we need it.\n\t */\n\tnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n0)\n\t\treturn false;\n\tedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\n\tnew_n1 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n1)\n\t\treturn false;\n\tedit->new_meta[1] = assoc_array_node_to_ptr(new_n1);\n\n\t/* We need to find out how similar the leaves are. */\n\tpr_devel(\"no spare slots\\n\");\n\thave_meta = false;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (assoc_array_ptr_is_meta(ptr)) {\n\t\t\tedit->segment_cache[i] = 0xff;\n\t\t\thave_meta = true;\n\t\t\tcontinue;\n\t\t}\n\t\tbase_seg = ops->get_object_key_chunk(\n\t\t\tassoc_array_ptr_to_leaf(ptr), level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tif (have_meta) {\n\t\tpr_devel(\"have meta\\n\");\n\t\tgoto split_node;\n\t}\n\n\t/* The node contains only leaves */\n\tdissimilarity = 0;\n\tbase_seg = edit->segment_cache[0];\n\tfor (i = 1; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tdissimilarity |= edit->segment_cache[i] ^ base_seg;\n\n\tpr_devel(\"only leaves; dissimilarity=%lx\\n\", dissimilarity);\n\n\tif ((dissimilarity & ASSOC_ARRAY_FAN_MASK) == 0) {\n\t\t/* The old leaves all cluster in the same slot.  We will need\n\t\t * to insert a shortcut if the new node wants to cluster with them.\n\t\t */\n\t\tif ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0)\n\t\t\tgoto all_leaves_cluster_together;\n\n\t\t/* Otherwise we can just insert a new node ahead of the old\n\t\t * one.\n\t\t */\n\t\tgoto present_leaves_cluster_but_not_new_leaf;\n\t}\n\nsplit_node:\n\tpr_devel(\"split node\\n\");\n\n\t/* We need to split the current node; we know that the node doesn't\n\t * simply contain a full set of leaves that cluster together (it\n\t * contains meta pointers and/or non-clustering leaves).\n\t *\n\t * We need to expel at least two leaves out of a set consisting of the\n\t * leaves in the node and the new leaf.\n\t *\n\t * We need a new node (n0) to replace the current one and a new node to\n\t * take the expelled nodes (n1).\n\t */\n\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = node->back_pointer;\n\tnew_n0->parent_slot = node->parent_slot;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to calculate this */\n\ndo_split_node:\n\tpr_devel(\"do_split_node\\n\");\n\n\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tnew_n1->nr_leaves_on_branch = 0;\n\n\t/* Begin by finding two matching leaves.  There have to be at least two\n\t * that match - even if there are meta pointers - because any leaf that\n\t * would match a slot with a meta pointer in it must be somewhere\n\t * behind that meta pointer and cannot be here.  Further, given N\n\t * remaining leaf slots, we now have N+1 leaves to go in them.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tslot = edit->segment_cache[i];\n\t\tif (slot != 0xff)\n\t\t\tfor (j = i + 1; j < ASSOC_ARRAY_FAN_OUT + 1; j++)\n\t\t\t\tif (edit->segment_cache[j] == slot)\n\t\t\t\t\tgoto found_slot_for_multiple_occupancy;\n\t}\nfound_slot_for_multiple_occupancy:\n\tpr_devel(\"same slot: %x %x [%02x]\\n\", i, j, slot);\n\tBUG_ON(i >= ASSOC_ARRAY_FAN_OUT);\n\tBUG_ON(j >= ASSOC_ARRAY_FAN_OUT + 1);\n\tBUG_ON(slot >= ASSOC_ARRAY_FAN_OUT);\n\n\tnew_n1->parent_slot = slot;\n\n\t/* Metadata pointers cannot change slot */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tnew_n0->slots[i] = node->slots[i];\n\t\telse\n\t\t\tnew_n0->slots[i] = NULL;\n\tBUG_ON(new_n0->slots[slot] != NULL);\n\tnew_n0->slots[slot] = assoc_array_node_to_ptr(new_n1);\n\n\t/* Filter the leaf pointers between the new nodes */\n\tfree_slot = -1;\n\tnext_slot = 0;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tcontinue;\n\t\tif (edit->segment_cache[i] == slot) {\n\t\t\tnew_n1->slots[next_slot++] = node->slots[i];\n\t\t\tnew_n1->nr_leaves_on_branch++;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tfree_slot++;\n\t\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\t\tnew_n0->slots[free_slot] = node->slots[i];\n\t\t}\n\t}\n\n\tpr_devel(\"filtered: f=%x n=%x\\n\", free_slot, next_slot);\n\n\tif (edit->segment_cache[ASSOC_ARRAY_FAN_OUT] != slot) {\n\t\tdo {\n\t\t\tfree_slot++;\n\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\tedit->leaf_p = &new_n0->slots[free_slot];\n\t\tedit->adjust_count_on = new_n0;\n\t} else {\n\t\tedit->leaf_p = &new_n1->slots[next_slot++];\n\t\tedit->adjust_count_on = new_n1;\n\t}\n\n\tBUG_ON(next_slot <= 1);\n\n\tedit->set_backpointers_to = assoc_array_node_to_ptr(new_n0);\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (edit->segment_cache[i] == 0xff) {\n\t\t\tptr = node->slots[i];\n\t\t\tBUG_ON(assoc_array_ptr_is_leaf(ptr));\n\t\t\tif (assoc_array_ptr_is_node(ptr)) {\n\t\t\t\tside = assoc_array_ptr_to_node(ptr);\n\t\t\t\tedit->set_backpointers[i] = &side->back_pointer;\n\t\t\t} else {\n\t\t\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\t\t\tedit->set_backpointers[i] = &shortcut->back_pointer;\n\t\t\t}\n\t\t}\n\t}\n\n\tptr = node->back_pointer;\n\tif (!ptr)\n\t\tedit->set[0].ptr = &edit->array->root;\n\telse if (assoc_array_ptr_is_node(ptr))\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_node(ptr)->slots[node->parent_slot];\n\telse\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_shortcut(ptr)->next_node;\n\tedit->excised_meta[0] = assoc_array_node_to_ptr(node);\n\tpr_devel(\"<--%s() = ok [split node]\\n\", __func__);\n\treturn true;\n\npresent_leaves_cluster_but_not_new_leaf:\n\t/* All the old leaves cluster in the same slot, but the new leaf wants\n\t * to go into a different slot, so we create a new node to hold the new\n\t * leaf and a pointer to a new node holding all the old leaves.\n\t */\n\tpr_devel(\"present leaves cluster but not new leaf\\n\");\n\n\tnew_n0->back_pointer = node->back_pointer;\n\tnew_n0->parent_slot = node->parent_slot;\n\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = edit->segment_cache[0];\n\tnew_n1->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tedit->adjust_count_on = new_n0;\n\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tnew_n1->slots[i] = node->slots[i];\n\n\tnew_n0->slots[edit->segment_cache[0]] = assoc_array_node_to_ptr(new_n0);\n\tedit->leaf_p = &new_n0->slots[edit->segment_cache[ASSOC_ARRAY_FAN_OUT]];\n\n\tedit->set[0].ptr = &assoc_array_ptr_to_node(node->back_pointer)->slots[node->parent_slot];\n\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\tedit->excised_meta[0] = assoc_array_node_to_ptr(node);\n\tpr_devel(\"<--%s() = ok [insert node before]\\n\", __func__);\n\treturn true;\n\nall_leaves_cluster_together:\n\t/* All the leaves, new and old, want to cluster together in this node\n\t * in the same slot, so we have to replace this node with a shortcut to\n\t * skip over the identical parts of the key and then place a pair of\n\t * nodes, one inside the other, at the end of the shortcut and\n\t * distribute the keys between them.\n\t *\n\t * Firstly we need to work out where the leaves start diverging as a\n\t * bit position into their keys so that we know how big the shortcut\n\t * needs to be.\n\t *\n\t * We only need to make a single pass of N of the N+1 leaves because if\n\t * any keys differ between themselves at bit X then at least one of\n\t * them must also differ with the base key at bit X or before.\n\t */\n\tpr_devel(\"all leaves cluster together\\n\");\n\tdiff = INT_MAX;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tint x = ops->diff_objects(assoc_array_ptr_to_leaf(node->slots[i]),\n\t\t\t\t\t  index_key);\n\t\tif (x < diff) {\n\t\t\tBUG_ON(x < 0);\n\t\t\tdiff = x;\n\t\t}\n\t}\n\tBUG_ON(diff == INT_MAX);\n\tBUG_ON(diff < level + ASSOC_ARRAY_LEVEL_STEP);\n\n\tkeylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\tkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\n\n\tnew_s0 = kzalloc(sizeof(struct assoc_array_shortcut) +\n\t\t\t keylen * sizeof(unsigned long), GFP_KERNEL);\n\tif (!new_s0)\n\t\treturn false;\n\tedit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s0);\n\n\tedit->set[0].to = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_s0->back_pointer = node->back_pointer;\n\tnew_s0->parent_slot = node->parent_slot;\n\tnew_s0->next_node = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_n0->parent_slot = 0;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to calculate this */\n\n\tnew_s0->skip_to_level = level = diff & ~ASSOC_ARRAY_LEVEL_STEP_MASK;\n\tpr_devel(\"skip_to_level = %d [diff %d]\\n\", level, diff);\n\tBUG_ON(level <= 0);\n\n\tfor (i = 0; i < keylen; i++)\n\t\tnew_s0->index_key[i] =\n\t\t\tops->get_key_chunk(index_key, i * ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\n\tblank = ULONG_MAX << (level & ASSOC_ARRAY_KEY_CHUNK_MASK);\n\tpr_devel(\"blank off [%zu] %d: %lx\\n\", keylen - 1, level, blank);\n\tnew_s0->index_key[keylen - 1] &= ~blank;\n\n\t/* This now reduces to a node splitting exercise for which we'll need\n\t * to regenerate the disparity table.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tbase_seg = ops->get_object_key_chunk(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\t\t     level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tbase_seg = ops->get_key_chunk(index_key, level);\n\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\tgoto do_split_node;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149653,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\n\tif (prepare && skb_rtable(skb)) {\n\t\t/* skb->cb is overloaded: prior to this point it is IP{6}CB\n\t\t * which has interface index (iif) as the first member of the\n\t\t * underlying inet{6}_skb_parm struct. This code then overlays\n\t\t * PKTINFO_SKB_CB and in_pktinfo also has iif as the first\n\t\t * element so the iif is picked up from the prior IPCB. If iif\n\t\t * is the loopback interface, then return the sending interface\n\t\t * (e.g., process binds socket to eth0 for Tx which is\n\t\t * redirected to loopback in the rtable/dst).\n\t\t */\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\tskb_dst_drop(skb);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149654,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\n\tif (prepare && skb_rtable(skb)) {\n\t\t/* skb->cb is overloaded: prior to this point it is IP{6}CB\n\t\t * which has interface index (iif) as the first member of the\n\t\t * underlying inet{6}_skb_parm struct. This code then overlays\n\t\t * PKTINFO_SKB_CB and in_pktinfo also has iif as the first\n\t\t * element so the iif is picked up from the prior IPCB. If iif\n\t\t * is the loopback interface, then return the sending interface\n\t\t * (e.g., process binds socket to eth0 for Tx which is\n\t\t * redirected to loopback in the rtable/dst).\n\t\t */\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\t/* We need to keep the dst for __ip_options_echo()\n\t * We could restrict the test to opt.ts_needtime || opt.srr,\n\t * but the following is good enough as IP options are not often used.\n\t */\n\tif (unlikely(IPCB(skb)->opt.optlen))\n\t\tskb_dst_force(skb);\n\telse\n\t\tskb_dst_drop(skb);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149655,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,\n\t\t\t\t  RBinDexClass *c, int MI, int MA, int paddr, int ins_size,\n\t\t\t\t  int insns_size, char *class_name, int regsz,\n\t\t\t\t  int debug_info_off) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\tconst ut8 *p4 = r_buf_get_at (binfile->buf, debug_info_off, NULL);\n\tconst ut8 *p4_end = p4 + binfile->buf->length - debug_info_off;\n\tut64 line_start;\n\tut64 parameters_size;\n\tut64 param_type_idx;\n\tut16 argReg = regsz - ins_size;\n\tut64 source_file_idx = c->source_file;\n\tRList *params, *debug_positions, *emitted_debug_locals = NULL; \n\tbool keep = true;\n\tif (argReg > regsz) {\n\t\treturn; // this return breaks tests\n\t}\n\tp4 = r_uleb128 (p4, p4_end - p4, &line_start);\n\tp4 = r_uleb128 (p4, p4_end - p4, &parameters_size);\n\t// TODO: check when we should use source_file\n\t// The state machine consists of five registers\n\tut32 address = 0;\n\tut32 line = line_start;\n\tif (!(debug_positions = r_list_newf ((RListFree)free))) {\n\t\treturn;\t\n\t}\n\tif (!(emitted_debug_locals = r_list_newf ((RListFree)free))) {\n\t\tr_list_free (debug_positions);\n\t\treturn;\n\t}\n\n\tstruct dex_debug_local_t debug_locals[regsz];\n\tmemset (debug_locals, 0, sizeof (struct dex_debug_local_t) * regsz);\n\tif (!(MA & 0x0008)) {\n\t\tdebug_locals[argReg].name = \"this\";\n\t\tdebug_locals[argReg].descriptor = r_str_newf(\"%s;\", class_name);\n\t\tdebug_locals[argReg].startAddress = 0;\n\t\tdebug_locals[argReg].signature = NULL;\n\t\tdebug_locals[argReg].live = true;\n\t\targReg++;\n\t}\n\tif (!(params = dex_method_signature2 (bin, MI))) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\treturn;\n\t}\n\n\tRListIter *iter = r_list_iterator (params);\n\tchar *name;\n\tchar *type;\n\tint reg;\n\n\tr_list_foreach (params, iter, type) {\n\t\tif ((argReg >= regsz) || !type || parameters_size <= 0) {\n\t\t\tr_list_free (debug_positions);\n\t\t\tr_list_free (params);\n\t\t\tr_list_free (emitted_debug_locals);\n\t\t\treturn;\n\t\t}\n\t\tp4 = r_uleb128 (p4, p4_end - p4, &param_type_idx); // read uleb128p1\n\t\tparam_type_idx -= 1;\n\t\tname = getstr (bin, param_type_idx);\n\t\treg = argReg;\n\t\tswitch (type[0]) {\n\t\tcase 'D':\n\t\tcase 'J':\n\t\t\targReg += 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\targReg += 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (name) {\n\t\t\tdebug_locals[reg].name = name;\n\t\t\tdebug_locals[reg].descriptor = type;\n\t\t\tdebug_locals[reg].signature = NULL;\n\t\t\tdebug_locals[reg].startAddress = address;\n\t\t\tdebug_locals[reg].live = true;\n\t\t}\n\t\t--parameters_size;\n\t}\n\n\tut8 opcode = *(p4++) & 0xff;\n\twhile (keep) {\n\t\tswitch (opcode) {\n\t\tcase 0x0: // DBG_END_SEQUENCE\n\t\t\tkeep = false;\n\t\t\tbreak;\n\t\tcase 0x1: // DBG_ADVANCE_PC\n\t\t\t{\n\t\t\tut64 addr_diff;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &addr_diff);\n\t\t\taddress += addr_diff;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x2: // DBG_ADVANCE_LINE\n\t\t\t{\n\t\t\tst64 line_diff = r_sleb128 (&p4, p4_end);\n\t\t\tline += line_diff;\n\t\t\t}\n\t\t\tbreak;\t\n\t\tcase 0x3: // DBG_START_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx); \n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx); \n\t\t\ttype_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = NULL;\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t//eprintf(\"DBG_START_LOCAL %x %x %x\\n\", register_num, name_idx, type_idx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x4: //DBG_START_LOCAL_EXTENDED\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tut64 sig_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx);\n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx);\n\t\t\ttype_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &sig_idx);\n\t\t\tsig_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = getstr (bin, sig_idx);\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x5: // DBG_END_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].live = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x6: // DBG_RESTART_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tif (!debug_locals[register_num].live) {\n\t\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x7: //DBG_SET_PROLOGUE_END\n\t\t\tbreak;\n\t\tcase 0x8: //DBG_SET_PROLOGUE_BEGIN\n\t\t\tbreak;\n\t\tcase 0x9:\n\t\t\t{\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &source_file_idx);\n\t\t\tsource_file_idx--;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\tint adjusted_opcode = opcode - 0x0a;\n\t\t\taddress += (adjusted_opcode / 15);\n\t\t\tline += -4 + (adjusted_opcode % 15);\n\t\t\tstruct dex_debug_position_t *position =\n\t\t\t\tmalloc (sizeof (struct dex_debug_position_t));\n\t\t\tif (!position) {\n\t\t\t\tkeep = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tposition->source_file_idx = source_file_idx;\n\t\t\tposition->address = address;\n\t\t\tposition->line = line;\n\t\t\tr_list_append (debug_positions, position);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\topcode = *(p4++) & 0xff;\n\t}\n\n\tif (!binfile->sdb_addrinfo) {\n\t\tbinfile->sdb_addrinfo = sdb_new0 ();\n\t}\n\n\tchar *fileline;\n\tchar offset[64];\n\tchar *offset_ptr;\n\n\tRListIter *iter1;\n\tstruct dex_debug_position_t *pos;\n\tr_list_foreach (debug_positions, iter1, pos) {\n\t\tfileline = r_str_newf (\"%s|%\"PFMT64d, getstr (bin, pos->source_file_idx), pos->line);\n\t\toffset_ptr = sdb_itoa (pos->address + paddr, offset, 16);\n\t\tsdb_set (binfile->sdb_addrinfo, offset_ptr, fileline, 0);\n\t\tsdb_set (binfile->sdb_addrinfo, fileline, offset_ptr, 0);\n\t}\n\n\tif (!dexdump) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\tr_list_free (params);\n\t\treturn;\n\t}\n\n\tRListIter *iter2;\n\tstruct dex_debug_position_t *position;\n\n\trbin->cb_printf (\"      positions     :\\n\");\n\tr_list_foreach (debug_positions, iter2, position) {\n\t\trbin->cb_printf (\"        0x%04llx line=%llu\\n\",\n\t\t\t\t position->address, position->line);\n\t}\n\n\trbin->cb_printf (\"      locals        :\\n\");\n\n\tRListIter *iter3;\n\tstruct dex_debug_local_t *local;\n\tr_list_foreach (emitted_debug_locals, iter3, local) {\n\t\tif (local->signature) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor,\n\t\t\t\tlocal->signature);\n\t\t} else {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor);\n\t\t}\n\t}\n\n\tfor (reg = 0; reg < regsz; reg++) {\n\t\tif (debug_locals[reg].live) {\n\t\t\tif (debug_locals[reg].signature) {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s \"\n\t\t\t\t\t\"%s\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor,\n\t\t\t\t\tdebug_locals[reg].signature);\n\t\t\t} else {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\"\n\t\t\t\t\t\"\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor);\n\t\t\t}\n\t\t}\n\t}\n\tr_list_free (debug_positions);\n\tr_list_free (emitted_debug_locals);\n\tr_list_free (params);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149656,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,\n\t\t\t\t  RBinDexClass *c, int MI, int MA, int paddr, int ins_size,\n\t\t\t\t  int insns_size, char *class_name, int regsz,\n\t\t\t\t  int debug_info_off) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\tconst ut8 *p4 = r_buf_get_at (binfile->buf, debug_info_off, NULL);\n\tconst ut8 *p4_end = p4 + binfile->buf->length - debug_info_off;\n\tut64 line_start;\n\tut64 parameters_size;\n\tut64 param_type_idx;\n\tut16 argReg = regsz - ins_size;\n\tut64 source_file_idx = c->source_file;\n\tRList *params, *debug_positions, *emitted_debug_locals = NULL; \n\tbool keep = true;\n\tif (argReg > regsz) {\n\t\treturn; // this return breaks tests\n\t}\n\tp4 = r_uleb128 (p4, p4_end - p4, &line_start);\n\tp4 = r_uleb128 (p4, p4_end - p4, &parameters_size);\n\t// TODO: check when we should use source_file\n\t// The state machine consists of five registers\n\tut32 address = 0;\n\tut32 line = line_start;\n\tif (!(debug_positions = r_list_newf ((RListFree)free))) {\n\t\treturn;\t\n\t}\n\tif (!(emitted_debug_locals = r_list_newf ((RListFree)free))) {\n\t\tr_list_free (debug_positions);\n\t\treturn;\n\t}\n\n\tstruct dex_debug_local_t debug_locals[regsz];\n\tmemset (debug_locals, 0, sizeof (struct dex_debug_local_t) * regsz);\n\tif (!(MA & 0x0008)) {\n\t\tdebug_locals[argReg].name = \"this\";\n\t\tdebug_locals[argReg].descriptor = r_str_newf(\"%s;\", class_name);\n\t\tdebug_locals[argReg].startAddress = 0;\n\t\tdebug_locals[argReg].signature = NULL;\n\t\tdebug_locals[argReg].live = true;\n\t\targReg++;\n\t}\n\tif (!(params = dex_method_signature2 (bin, MI))) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\treturn;\n\t}\n\n\tRListIter *iter = r_list_iterator (params);\n\tchar *name;\n\tchar *type;\n\tint reg;\n\n\tr_list_foreach (params, iter, type) {\n\t\tif ((argReg >= regsz) || !type || parameters_size <= 0) {\n\t\t\tr_list_free (debug_positions);\n\t\t\tr_list_free (params);\n\t\t\tr_list_free (emitted_debug_locals);\n\t\t\treturn;\n\t\t}\n\t\tp4 = r_uleb128 (p4, p4_end - p4, &param_type_idx); // read uleb128p1\n\t\tparam_type_idx -= 1;\n\t\tname = getstr (bin, param_type_idx);\n\t\treg = argReg;\n\t\tswitch (type[0]) {\n\t\tcase 'D':\n\t\tcase 'J':\n\t\t\targReg += 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\targReg += 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (name) {\n\t\t\tdebug_locals[reg].name = name;\n\t\t\tdebug_locals[reg].descriptor = type;\n\t\t\tdebug_locals[reg].signature = NULL;\n\t\t\tdebug_locals[reg].startAddress = address;\n\t\t\tdebug_locals[reg].live = true;\n\t\t}\n\t\t--parameters_size;\n\t}\n\n\tif (p4 <= 0) {\n\t\treturn;\n\t}\n\tut8 opcode = *(p4++) & 0xff;\n\twhile (keep) {\n\t\tswitch (opcode) {\n\t\tcase 0x0: // DBG_END_SEQUENCE\n\t\t\tkeep = false;\n\t\t\tbreak;\n\t\tcase 0x1: // DBG_ADVANCE_PC\n\t\t\t{\n\t\t\tut64 addr_diff;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &addr_diff);\n\t\t\taddress += addr_diff;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x2: // DBG_ADVANCE_LINE\n\t\t\t{\n\t\t\tst64 line_diff = r_sleb128 (&p4, p4_end);\n\t\t\tline += line_diff;\n\t\t\t}\n\t\t\tbreak;\t\n\t\tcase 0x3: // DBG_START_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx); \n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx); \n\t\t\ttype_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = NULL;\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t//eprintf(\"DBG_START_LOCAL %x %x %x\\n\", register_num, name_idx, type_idx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x4: //DBG_START_LOCAL_EXTENDED\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tut64 sig_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx);\n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx);\n\t\t\ttype_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &sig_idx);\n\t\t\tsig_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = getstr (bin, sig_idx);\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x5: // DBG_END_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].live = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x6: // DBG_RESTART_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tif (!debug_locals[register_num].live) {\n\t\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x7: //DBG_SET_PROLOGUE_END\n\t\t\tbreak;\n\t\tcase 0x8: //DBG_SET_PROLOGUE_BEGIN\n\t\t\tbreak;\n\t\tcase 0x9:\n\t\t\t{\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &source_file_idx);\n\t\t\tsource_file_idx--;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\tint adjusted_opcode = opcode - 0x0a;\n\t\t\taddress += (adjusted_opcode / 15);\n\t\t\tline += -4 + (adjusted_opcode % 15);\n\t\t\tstruct dex_debug_position_t *position =\n\t\t\t\tmalloc (sizeof (struct dex_debug_position_t));\n\t\t\tif (!position) {\n\t\t\t\tkeep = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tposition->source_file_idx = source_file_idx;\n\t\t\tposition->address = address;\n\t\t\tposition->line = line;\n\t\t\tr_list_append (debug_positions, position);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\topcode = *(p4++) & 0xff;\n\t}\n\n\tif (!binfile->sdb_addrinfo) {\n\t\tbinfile->sdb_addrinfo = sdb_new0 ();\n\t}\n\n\tchar *fileline;\n\tchar offset[64];\n\tchar *offset_ptr;\n\n\tRListIter *iter1;\n\tstruct dex_debug_position_t *pos;\n\tr_list_foreach (debug_positions, iter1, pos) {\n\t\tfileline = r_str_newf (\"%s|%\"PFMT64d, getstr (bin, pos->source_file_idx), pos->line);\n\t\toffset_ptr = sdb_itoa (pos->address + paddr, offset, 16);\n\t\tsdb_set (binfile->sdb_addrinfo, offset_ptr, fileline, 0);\n\t\tsdb_set (binfile->sdb_addrinfo, fileline, offset_ptr, 0);\n\t}\n\n\tif (!dexdump) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\tr_list_free (params);\n\t\treturn;\n\t}\n\n\tRListIter *iter2;\n\tstruct dex_debug_position_t *position;\n\n\trbin->cb_printf (\"      positions     :\\n\");\n\tr_list_foreach (debug_positions, iter2, position) {\n\t\trbin->cb_printf (\"        0x%04llx line=%llu\\n\",\n\t\t\t\t position->address, position->line);\n\t}\n\n\trbin->cb_printf (\"      locals        :\\n\");\n\n\tRListIter *iter3;\n\tstruct dex_debug_local_t *local;\n\tr_list_foreach (emitted_debug_locals, iter3, local) {\n\t\tif (local->signature) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor,\n\t\t\t\tlocal->signature);\n\t\t} else {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor);\n\t\t}\n\t}\n\n\tfor (reg = 0; reg < regsz; reg++) {\n\t\tif (debug_locals[reg].live) {\n\t\t\tif (debug_locals[reg].signature) {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s \"\n\t\t\t\t\t\"%s\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor,\n\t\t\t\t\tdebug_locals[reg].signature);\n\t\t\t} else {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\"\n\t\t\t\t\t\"\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor);\n\t\t\t}\n\t\t}\n\t}\n\tr_list_free (debug_positions);\n\tr_list_free (emitted_debug_locals);\n\tr_list_free (params);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149657,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int rds_cmsg_atomic(struct rds_sock *rs, struct rds_message *rm,\n\t\t    struct cmsghdr *cmsg)\n{\n\tstruct page *page = NULL;\n\tstruct rds_atomic_args *args;\n\tint ret = 0;\n\n\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct rds_atomic_args))\n\t || rm->atomic.op_active)\n\t\treturn -EINVAL;\n\n\targs = CMSG_DATA(cmsg);\n\n\t/* Nonmasked & masked cmsg ops converted to masked hw ops */\n\tswitch (cmsg->cmsg_type) {\n\tcase RDS_CMSG_ATOMIC_FADD:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_FADD;\n\t\trm->atomic.op_m_fadd.add = args->fadd.add;\n\t\trm->atomic.op_m_fadd.nocarry_mask = 0;\n\t\tbreak;\n\tcase RDS_CMSG_MASKED_ATOMIC_FADD:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_FADD;\n\t\trm->atomic.op_m_fadd.add = args->m_fadd.add;\n\t\trm->atomic.op_m_fadd.nocarry_mask = args->m_fadd.nocarry_mask;\n\t\tbreak;\n\tcase RDS_CMSG_ATOMIC_CSWP:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP;\n\t\trm->atomic.op_m_cswp.compare = args->cswp.compare;\n\t\trm->atomic.op_m_cswp.swap = args->cswp.swap;\n\t\trm->atomic.op_m_cswp.compare_mask = ~0;\n\t\trm->atomic.op_m_cswp.swap_mask = ~0;\n\t\tbreak;\n\tcase RDS_CMSG_MASKED_ATOMIC_CSWP:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP;\n\t\trm->atomic.op_m_cswp.compare = args->m_cswp.compare;\n\t\trm->atomic.op_m_cswp.swap = args->m_cswp.swap;\n\t\trm->atomic.op_m_cswp.compare_mask = args->m_cswp.compare_mask;\n\t\trm->atomic.op_m_cswp.swap_mask = args->m_cswp.swap_mask;\n\t\tbreak;\n\tdefault:\n\t\tBUG(); /* should never happen */\n\t}\n\n\trm->atomic.op_notify = !!(args->flags & RDS_RDMA_NOTIFY_ME);\n\trm->atomic.op_silent = !!(args->flags & RDS_RDMA_SILENT);\n\trm->atomic.op_active = 1;\n\trm->atomic.op_recverr = rs->rs_recverr;\n\trm->atomic.op_sg = rds_message_alloc_sgs(rm, 1);\n\tif (!rm->atomic.op_sg) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* verify 8 byte-aligned */\n\tif (args->local_addr & 0x7) {\n\t\tret = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tret = rds_pin_pages(args->local_addr, 1, &page, 1);\n\tif (ret != 1)\n\t\tgoto err;\n\tret = 0;\n\n\tsg_set_page(rm->atomic.op_sg, page, 8, offset_in_page(args->local_addr));\n\n\tif (rm->atomic.op_notify || rm->atomic.op_recverr) {\n\t\t/* We allocate an uninitialized notifier here, because\n\t\t * we don't want to do that in the completion handler. We\n\t\t * would have to use GFP_ATOMIC there, and don't want to deal\n\t\t * with failed allocations.\n\t\t */\n\t\trm->atomic.op_notifier = kmalloc(sizeof(*rm->atomic.op_notifier), GFP_KERNEL);\n\t\tif (!rm->atomic.op_notifier) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\trm->atomic.op_notifier->n_user_token = args->user_token;\n\t\trm->atomic.op_notifier->n_status = RDS_RDMA_SUCCESS;\n\t}\n\n\trm->atomic.op_rkey = rds_rdma_cookie_key(args->cookie);\n\trm->atomic.op_remote_addr = args->remote_addr + rds_rdma_cookie_offset(args->cookie);\n\n\treturn ret;\nerr:\n\tif (page)\n\t\tput_page(page);\n\tkfree(rm->atomic.op_notifier);\n\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149658,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int rds_cmsg_atomic(struct rds_sock *rs, struct rds_message *rm,\n\t\t    struct cmsghdr *cmsg)\n{\n\tstruct page *page = NULL;\n\tstruct rds_atomic_args *args;\n\tint ret = 0;\n\n\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct rds_atomic_args))\n\t || rm->atomic.op_active)\n\t\treturn -EINVAL;\n\n\targs = CMSG_DATA(cmsg);\n\n\t/* Nonmasked & masked cmsg ops converted to masked hw ops */\n\tswitch (cmsg->cmsg_type) {\n\tcase RDS_CMSG_ATOMIC_FADD:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_FADD;\n\t\trm->atomic.op_m_fadd.add = args->fadd.add;\n\t\trm->atomic.op_m_fadd.nocarry_mask = 0;\n\t\tbreak;\n\tcase RDS_CMSG_MASKED_ATOMIC_FADD:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_FADD;\n\t\trm->atomic.op_m_fadd.add = args->m_fadd.add;\n\t\trm->atomic.op_m_fadd.nocarry_mask = args->m_fadd.nocarry_mask;\n\t\tbreak;\n\tcase RDS_CMSG_ATOMIC_CSWP:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP;\n\t\trm->atomic.op_m_cswp.compare = args->cswp.compare;\n\t\trm->atomic.op_m_cswp.swap = args->cswp.swap;\n\t\trm->atomic.op_m_cswp.compare_mask = ~0;\n\t\trm->atomic.op_m_cswp.swap_mask = ~0;\n\t\tbreak;\n\tcase RDS_CMSG_MASKED_ATOMIC_CSWP:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP;\n\t\trm->atomic.op_m_cswp.compare = args->m_cswp.compare;\n\t\trm->atomic.op_m_cswp.swap = args->m_cswp.swap;\n\t\trm->atomic.op_m_cswp.compare_mask = args->m_cswp.compare_mask;\n\t\trm->atomic.op_m_cswp.swap_mask = args->m_cswp.swap_mask;\n\t\tbreak;\n\tdefault:\n\t\tBUG(); /* should never happen */\n\t}\n\n\trm->atomic.op_notify = !!(args->flags & RDS_RDMA_NOTIFY_ME);\n\trm->atomic.op_silent = !!(args->flags & RDS_RDMA_SILENT);\n\trm->atomic.op_active = 1;\n\trm->atomic.op_recverr = rs->rs_recverr;\n\trm->atomic.op_sg = rds_message_alloc_sgs(rm, 1);\n\tif (!rm->atomic.op_sg) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* verify 8 byte-aligned */\n\tif (args->local_addr & 0x7) {\n\t\tret = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tret = rds_pin_pages(args->local_addr, 1, &page, 1);\n\tif (ret != 1)\n\t\tgoto err;\n\tret = 0;\n\n\tsg_set_page(rm->atomic.op_sg, page, 8, offset_in_page(args->local_addr));\n\n\tif (rm->atomic.op_notify || rm->atomic.op_recverr) {\n\t\t/* We allocate an uninitialized notifier here, because\n\t\t * we don't want to do that in the completion handler. We\n\t\t * would have to use GFP_ATOMIC there, and don't want to deal\n\t\t * with failed allocations.\n\t\t */\n\t\trm->atomic.op_notifier = kmalloc(sizeof(*rm->atomic.op_notifier), GFP_KERNEL);\n\t\tif (!rm->atomic.op_notifier) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\trm->atomic.op_notifier->n_user_token = args->user_token;\n\t\trm->atomic.op_notifier->n_status = RDS_RDMA_SUCCESS;\n\t}\n\n\trm->atomic.op_rkey = rds_rdma_cookie_key(args->cookie);\n\trm->atomic.op_remote_addr = args->remote_addr + rds_rdma_cookie_offset(args->cookie);\n\n\treturn ret;\nerr:\n\tif (page)\n\t\tput_page(page);\n\trm->atomic.op_active = 0;\n\tkfree(rm->atomic.op_notifier);\n\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149659,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size)\n{\n\tbee_t *bee = ic->bee;\n\tbee_user_t *bu = bee_user_by_handle(bee, ic, handle);\n\n\tif (bee->ui->ft_in_start) {\n\t\treturn bee->ui->ft_in_start(bee, bu, file_name, file_size);\n\t} else {\n\t\treturn NULL;\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149662,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size)\n{\n\tbee_t *bee = ic->bee;\n\tbee_user_t *bu = bee_user_by_handle(bee, ic, handle);\n\n\tif (bee->ui->ft_in_start && bu) {\n\t\treturn bee->ui->ft_in_start(bee, bu, file_name, file_size);\n\t} else {\n\t\treturn NULL;\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149663,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int mpeg4video_probe(AVProbeData *probe_packet)\n{\n    uint32_t temp_buffer = -1;\n    int VO = 0, VOL = 0, VOP = 0, VISO = 0, res = 0;\n    int i;\n\n    for (i = 0; i < probe_packet->buf_size; i++) {\n        temp_buffer = (temp_buffer << 8) + probe_packet->buf[i];\n        if ((temp_buffer & 0xffffff00) != 0x100)\n            continue;\n\n        if (temp_buffer == VOP_START_CODE)\n            VOP++;\n        else if (temp_buffer == VISUAL_OBJECT_START_CODE)\n            VISO++;\n        else if (temp_buffer < 0x120)\n            VO++;\n        else if (temp_buffer < 0x130)\n            VOL++;\n        else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) &&\n                 !(0x1B9 < temp_buffer && temp_buffer < 0x1C4))\n            res++;\n    }\n\n    if (VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0)\n        return AVPROBE_SCORE_EXTENSION;\n    return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149664,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int mpeg4video_probe(AVProbeData *probe_packet)\n{\n    uint32_t temp_buffer = -1;\n    int VO = 0, VOL = 0, VOP = 0, VISO = 0, res = 0;\n    int i;\n\n    for (i = 0; i < probe_packet->buf_size; i++) {\n        temp_buffer = (temp_buffer << 8) + probe_packet->buf[i];\n        if (temp_buffer & 0xfffffe00)\n            continue;\n        if (temp_buffer < 2)\n            continue;\n\n        if (temp_buffer == VOP_START_CODE)\n            VOP++;\n        else if (temp_buffer == VISUAL_OBJECT_START_CODE)\n            VISO++;\n        else if (temp_buffer >= 0x100 && temp_buffer < 0x120)\n            VO++;\n        else if (temp_buffer >= 0x120 && temp_buffer < 0x130)\n            VOL++;\n        else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) &&\n                 !(0x1B9 < temp_buffer && temp_buffer < 0x1C4))\n            res++;\n    }\n\n    if (VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0)\n        return AVPROBE_SCORE_EXTENSION;\n    return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149665,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int megasas_alloc_cmds(struct megasas_instance *instance)\n{\n\tint i;\n\tint j;\n\tu16 max_cmd;\n\tstruct megasas_cmd *cmd;\n\n\tmax_cmd = instance->max_mfi_cmds;\n\n\t/*\n\t * instance->cmd_list is an array of struct megasas_cmd pointers.\n\t * Allocate the dynamic array first and then allocate individual\n\t * commands.\n\t */\n\tinstance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);\n\n\tif (!instance->cmd_list) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);\n\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tinstance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),\n\t\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!instance->cmd_list[i]) {\n\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tkfree(instance->cmd_list[j]);\n\n\t\t\tkfree(instance->cmd_list);\n\t\t\tinstance->cmd_list = NULL;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tmemset(cmd, 0, sizeof(struct megasas_cmd));\n\t\tcmd->index = i;\n\t\tcmd->scmd = NULL;\n\t\tcmd->instance = instance;\n\n\t\tlist_add_tail(&cmd->list, &instance->cmd_pool);\n\t}\n\n\t/*\n\t * Create a frame pool and assign one frame to each cmd\n\t */\n\tif (megasas_create_frame_pool(instance)) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error creating frame DMA pool\\n\");\n\t\tmegasas_free_cmds(instance);\n\t}\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149666,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int megasas_alloc_cmds(struct megasas_instance *instance)\n{\n\tint i;\n\tint j;\n\tu16 max_cmd;\n\tstruct megasas_cmd *cmd;\n\n\tmax_cmd = instance->max_mfi_cmds;\n\n\t/*\n\t * instance->cmd_list is an array of struct megasas_cmd pointers.\n\t * Allocate the dynamic array first and then allocate individual\n\t * commands.\n\t */\n\tinstance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);\n\n\tif (!instance->cmd_list) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);\n\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tinstance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),\n\t\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!instance->cmd_list[i]) {\n\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tkfree(instance->cmd_list[j]);\n\n\t\t\tkfree(instance->cmd_list);\n\t\t\tinstance->cmd_list = NULL;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tmemset(cmd, 0, sizeof(struct megasas_cmd));\n\t\tcmd->index = i;\n\t\tcmd->scmd = NULL;\n\t\tcmd->instance = instance;\n\n\t\tlist_add_tail(&cmd->list, &instance->cmd_pool);\n\t}\n\n\t/*\n\t * Create a frame pool and assign one frame to each cmd\n\t */\n\tif (megasas_create_frame_pool(instance)) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error creating frame DMA pool\\n\");\n\t\tmegasas_free_cmds(instance);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149667,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "IRC_PROTOCOL_CALLBACK(352)\n{\n    char *pos_attr, *pos_hopcount, *pos_realname, *str_host;\n    int arg_start, length;\n    struct t_irc_channel *ptr_channel;\n    struct t_irc_nick *ptr_nick;\n\n    IRC_PROTOCOL_MIN_ARGS(5);\n\n    /* silently ignore malformed 352 message (missing infos) */\n    if (argc < 8)\n        return WEECHAT_RC_OK;\n\n    pos_attr = NULL;\n    pos_hopcount = NULL;\n    pos_realname = NULL;\n\n    if (argc > 8)\n    {\n        arg_start = (strcmp (argv[8], \"*\") == 0) ? 9 : 8;\n        if (argv[arg_start][0] == ':')\n        {\n            pos_attr = NULL;\n            pos_hopcount = (argc > arg_start) ? argv[arg_start] + 1 : NULL;\n            pos_realname = (argc > arg_start + 1) ? argv_eol[arg_start + 1] : NULL;\n        }\n        else\n        {\n            pos_attr = argv[arg_start];\n            pos_hopcount = (argc > arg_start + 1) ? argv[arg_start + 1] + 1 : NULL;\n            pos_realname = (argc > arg_start + 2) ? argv_eol[arg_start + 2] : NULL;\n        }\n    }\n\n    ptr_channel = irc_channel_search (server, argv[3]);\n    ptr_nick = (ptr_channel) ?\n        irc_nick_search (server, ptr_channel, argv[7]) : NULL;\n\n    /* update host in nick */\n    if (ptr_nick)\n    {\n        length = strlen (argv[4]) + 1 + strlen (argv[5]) + 1;\n        str_host = malloc (length);\n        if (str_host)\n        {\n            snprintf (str_host, length, \"%s@%s\", argv[4], argv[5]);\n            irc_nick_set_host (ptr_nick, str_host);\n            free (str_host);\n        }\n    }\n\n    /* update away flag in nick */\n    if (ptr_channel && ptr_nick && pos_attr)\n    {\n        irc_nick_set_away (server, ptr_channel, ptr_nick,\n                           (pos_attr[0] == 'G') ? 1 : 0);\n    }\n\n    /* update realname in nick */\n    if (ptr_channel && ptr_nick && pos_realname)\n    {\n        if (ptr_nick->realname)\n            free (ptr_nick->realname);\n        if (pos_realname &&\n            weechat_hashtable_has_key (server->cap_list, \"extended-join\"))\n        {\n            ptr_nick->realname = strdup (pos_realname);\n        }\n        else\n        {\n            ptr_nick->realname = NULL;\n        }\n    }\n\n    /* display output of who (manual who from user) */\n    if (!ptr_channel || (ptr_channel->checking_whox <= 0))\n    {\n        weechat_printf_date_tags (\n            irc_msgbuffer_get_target_buffer (\n                server, NULL, command, \"who\", NULL),\n            date,\n            irc_protocol_tags (command, \"irc_numeric\", NULL, NULL),\n            \"%s%s[%s%s%s] %s%s %s(%s%s@%s%s)%s %s%s%s%s(%s)\",\n            weechat_prefix (\"network\"),\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_CHAT_CHANNEL,\n            argv[3],\n            IRC_COLOR_CHAT_DELIMITERS,\n            irc_nick_color_for_msg (server, 1, NULL, argv[7]),\n            argv[7],\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_CHAT_HOST,\n            argv[4],\n            argv[5],\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_RESET,\n            (pos_attr) ? pos_attr : \"\",\n            (pos_attr) ? \" \" : \"\",\n            (pos_hopcount) ? pos_hopcount : \"\",\n            (pos_hopcount) ? \" \" : \"\",\n            (pos_realname) ? pos_realname : \"\");\n    }\n\n    return WEECHAT_RC_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149668,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "IRC_PROTOCOL_CALLBACK(352)\n{\n    char *pos_attr, *pos_hopcount, *pos_realname, *str_host;\n    int arg_start, length;\n    struct t_irc_channel *ptr_channel;\n    struct t_irc_nick *ptr_nick;\n\n    IRC_PROTOCOL_MIN_ARGS(5);\n\n    /* silently ignore malformed 352 message (missing infos) */\n    if (argc < 8)\n        return WEECHAT_RC_OK;\n\n    pos_attr = NULL;\n    pos_hopcount = NULL;\n    pos_realname = NULL;\n\n    if (argc > 8)\n    {\n        arg_start = ((argc > 9) && (strcmp (argv[8], \"*\") == 0)) ? 9 : 8;\n        if (argv[arg_start][0] == ':')\n        {\n            pos_attr = NULL;\n            pos_hopcount = (argc > arg_start) ? argv[arg_start] + 1 : NULL;\n            pos_realname = (argc > arg_start + 1) ? argv_eol[arg_start + 1] : NULL;\n        }\n        else\n        {\n            pos_attr = argv[arg_start];\n            pos_hopcount = (argc > arg_start + 1) ? argv[arg_start + 1] + 1 : NULL;\n            pos_realname = (argc > arg_start + 2) ? argv_eol[arg_start + 2] : NULL;\n        }\n    }\n\n    ptr_channel = irc_channel_search (server, argv[3]);\n    ptr_nick = (ptr_channel) ?\n        irc_nick_search (server, ptr_channel, argv[7]) : NULL;\n\n    /* update host in nick */\n    if (ptr_nick)\n    {\n        length = strlen (argv[4]) + 1 + strlen (argv[5]) + 1;\n        str_host = malloc (length);\n        if (str_host)\n        {\n            snprintf (str_host, length, \"%s@%s\", argv[4], argv[5]);\n            irc_nick_set_host (ptr_nick, str_host);\n            free (str_host);\n        }\n    }\n\n    /* update away flag in nick */\n    if (ptr_channel && ptr_nick && pos_attr)\n    {\n        irc_nick_set_away (server, ptr_channel, ptr_nick,\n                           (pos_attr[0] == 'G') ? 1 : 0);\n    }\n\n    /* update realname in nick */\n    if (ptr_channel && ptr_nick && pos_realname)\n    {\n        if (ptr_nick->realname)\n            free (ptr_nick->realname);\n        if (pos_realname &&\n            weechat_hashtable_has_key (server->cap_list, \"extended-join\"))\n        {\n            ptr_nick->realname = strdup (pos_realname);\n        }\n        else\n        {\n            ptr_nick->realname = NULL;\n        }\n    }\n\n    /* display output of who (manual who from user) */\n    if (!ptr_channel || (ptr_channel->checking_whox <= 0))\n    {\n        weechat_printf_date_tags (\n            irc_msgbuffer_get_target_buffer (\n                server, NULL, command, \"who\", NULL),\n            date,\n            irc_protocol_tags (command, \"irc_numeric\", NULL, NULL),\n            \"%s%s[%s%s%s] %s%s %s(%s%s@%s%s)%s %s%s%s%s(%s)\",\n            weechat_prefix (\"network\"),\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_CHAT_CHANNEL,\n            argv[3],\n            IRC_COLOR_CHAT_DELIMITERS,\n            irc_nick_color_for_msg (server, 1, NULL, argv[7]),\n            argv[7],\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_CHAT_HOST,\n            argv[4],\n            argv[5],\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_RESET,\n            (pos_attr) ? pos_attr : \"\",\n            (pos_attr) ? \" \" : \"\",\n            (pos_hopcount) ? pos_hopcount : \"\",\n            (pos_hopcount) ? \" \" : \"\",\n            (pos_realname) ? pos_realname : \"\");\n    }\n\n    return WEECHAT_RC_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149669,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "xfs_attr_shortform_to_leaf(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t**leaf_bp)\n{\n\txfs_inode_t *dp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_da_args_t nargs;\n\tchar *tmpbuffer;\n\tint error, i, size;\n\txfs_dablk_t blkno;\n\tstruct xfs_buf *bp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_to_leaf(args);\n\n\tdp = args->dp;\n\tifp = dp->i_afp;\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsize = be16_to_cpu(sf->hdr.totsize);\n\ttmpbuffer = kmem_alloc(size, KM_SLEEP);\n\tASSERT(tmpbuffer != NULL);\n\tmemcpy(tmpbuffer, ifp->if_u1.if_data, size);\n\tsf = (xfs_attr_shortform_t *)tmpbuffer;\n\n\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\txfs_bmap_local_to_extents_empty(dp, XFS_ATTR_FORK);\n\n\tbp = NULL;\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error) {\n\t\t/*\n\t\t * If we hit an IO error middle of the transaction inside\n\t\t * grow_inode(), we may have inconsistent data. Bail out.\n\t\t */\n\t\tif (error == -EIO)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tASSERT(blkno == 0);\n\terror = xfs_attr3_leaf_create(args, blkno, &bp);\n\tif (error) {\n\t\terror = xfs_da_shrink_inode(args, 0, bp);\n\t\tbp = NULL;\n\t\tif (error)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.dp = dp;\n\tnargs.geo = args->geo;\n\tnargs.firstblock = args->firstblock;\n\tnargs.dfops = args->dfops;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; i++) {\n\t\tnargs.name = sfe->nameval;\n\t\tnargs.namelen = sfe->namelen;\n\t\tnargs.value = &sfe->nameval[nargs.namelen];\n\t\tnargs.valuelen = sfe->valuelen;\n\t\tnargs.hashval = xfs_da_hashname(sfe->nameval,\n\t\t\t\t\t\tsfe->namelen);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(sfe->flags);\n\t\terror = xfs_attr3_leaf_lookup_int(bp, &nargs); /* set a->index */\n\t\tASSERT(error == -ENOATTR);\n\t\terror = xfs_attr3_leaf_add(bp, &nargs);\n\t\tASSERT(error != -ENOSPC);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t}\n\terror = 0;\n\t*leaf_bp = bp;\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149670,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "xfs_attr_shortform_to_leaf(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t**leaf_bp)\n{\n\txfs_inode_t *dp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_da_args_t nargs;\n\tchar *tmpbuffer;\n\tint error, i, size;\n\txfs_dablk_t blkno;\n\tstruct xfs_buf *bp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_to_leaf(args);\n\n\tdp = args->dp;\n\tifp = dp->i_afp;\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsize = be16_to_cpu(sf->hdr.totsize);\n\ttmpbuffer = kmem_alloc(size, KM_SLEEP);\n\tASSERT(tmpbuffer != NULL);\n\tmemcpy(tmpbuffer, ifp->if_u1.if_data, size);\n\tsf = (xfs_attr_shortform_t *)tmpbuffer;\n\n\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\txfs_bmap_local_to_extents_empty(dp, XFS_ATTR_FORK);\n\n\tbp = NULL;\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error) {\n\t\t/*\n\t\t * If we hit an IO error middle of the transaction inside\n\t\t * grow_inode(), we may have inconsistent data. Bail out.\n\t\t */\n\t\tif (error == -EIO)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tASSERT(blkno == 0);\n\terror = xfs_attr3_leaf_create(args, blkno, &bp);\n\tif (error) {\n\t\t/* xfs_attr3_leaf_create may not have instantiated a block */\n\t\tif (bp && (xfs_da_shrink_inode(args, 0, bp) != 0))\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.dp = dp;\n\tnargs.geo = args->geo;\n\tnargs.firstblock = args->firstblock;\n\tnargs.dfops = args->dfops;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; i++) {\n\t\tnargs.name = sfe->nameval;\n\t\tnargs.namelen = sfe->namelen;\n\t\tnargs.value = &sfe->nameval[nargs.namelen];\n\t\tnargs.valuelen = sfe->valuelen;\n\t\tnargs.hashval = xfs_da_hashname(sfe->nameval,\n\t\t\t\t\t\tsfe->namelen);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(sfe->flags);\n\t\terror = xfs_attr3_leaf_lookup_int(bp, &nargs); /* set a->index */\n\t\tASSERT(error == -ENOATTR);\n\t\terror = xfs_attr3_leaf_add(bp, &nargs);\n\t\tASSERT(error != -ENOSPC);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t}\n\terror = 0;\n\t*leaf_bp = bp;\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149671,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "lys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)\n{\n    struct lys_restr *result;\n    int i;\n\n    if (!size) {\n        return NULL;\n    }\n\n    result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);\n\n    for (i = 0; i < size; i++) {\n        result[i].ext_size = old[i].ext_size;\n        lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);\n        result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);\n        result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);\n        result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);\n        result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);\n        result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);\n    }\n\n    return result;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149672,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "lys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)\n{\n    struct lys_restr *result;\n    int i;\n\n    if (!size) {\n        return NULL;\n    }\n\n    result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);\n\n    for (i = 0; i < size; i++) {\n        /* copying unresolved extensions is not supported */\n        if (unres_schema_find(unres, -1, (void *)&old[i].ext, UNRES_EXT) == -1) {\n            result[i].ext_size = old[i].ext_size;\n            lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);\n        }\n        result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);\n        result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);\n        result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);\n        result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);\n        result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);\n    }\n\n    return result;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149673,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\n\trc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149674,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_TARGET_INDEX])\n\t\treturn -EINVAL;\n\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\n\trc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149675,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) /* EOF considered as end of frame */\n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                dctx->w = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 42) {\n                int cid = (state >> 32) & 0xFFFFFFFF;\n\n                if (cid <= 0)\n                    continue;\n\n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (dctx->remaining <= 0) {\n                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (dctx->remaining <= 0)\n                        return dctx->remaining;\n                }\n                if (buf_size - i + 47 >= dctx->remaining) {\n                    int remaining = dctx->remaining;\n\n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    return END_NOT_FOUND;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149676,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) /* EOF considered as end of frame */\n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                dctx->w = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 42) {\n                int cid = (state >> 32) & 0xFFFFFFFF;\n                int remaining;\n\n                if (cid <= 0)\n                    continue;\n\n                remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (remaining <= 0) {\n                    remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (remaining <= 0)\n                        continue;\n                }\n                dctx->remaining = remaining;\n                if (buf_size - i + 47 >= dctx->remaining) {\n                    int remaining = dctx->remaining;\n\n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    return END_NOT_FOUND;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149677,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int __rds_rdma_map(struct rds_sock *rs, struct rds_get_mr_args *args,\n\t\t\t\tu64 *cookie_ret, struct rds_mr **mr_ret)\n{\n\tstruct rds_mr *mr = NULL, *found;\n\tunsigned int nr_pages;\n\tstruct page **pages = NULL;\n\tstruct scatterlist *sg;\n\tvoid *trans_private;\n\tunsigned long flags;\n\trds_rdma_cookie_t cookie;\n\tunsigned int nents;\n\tlong i;\n\tint ret;\n\n\tif (rs->rs_bound_addr == 0) {\n\t\tret = -ENOTCONN; /* XXX not a great errno */\n\t\tgoto out;\n\t}\n\n\tif (!rs->rs_transport->get_mr) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tnr_pages = rds_pages_in_vec(&args->vec);\n\tif (nr_pages == 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Restrict the size of mr irrespective of underlying transport\n\t * To account for unaligned mr regions, subtract one from nr_pages\n\t */\n\tif ((nr_pages - 1) > (RDS_MAX_MSG_SIZE >> PAGE_SHIFT)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\trdsdebug(\"RDS: get_mr addr %llx len %llu nr_pages %u\\n\",\n\t\targs->vec.addr, args->vec.bytes, nr_pages);\n\n\t/* XXX clamp nr_pages to limit the size of this alloc? */\n\tpages = kcalloc(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmr = kzalloc(sizeof(struct rds_mr), GFP_KERNEL);\n\tif (!mr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trefcount_set(&mr->r_refcount, 1);\n\tRB_CLEAR_NODE(&mr->r_rb_node);\n\tmr->r_trans = rs->rs_transport;\n\tmr->r_sock = rs;\n\n\tif (args->flags & RDS_RDMA_USE_ONCE)\n\t\tmr->r_use_once = 1;\n\tif (args->flags & RDS_RDMA_INVALIDATE)\n\t\tmr->r_invalidate = 1;\n\tif (args->flags & RDS_RDMA_READWRITE)\n\t\tmr->r_write = 1;\n\n\t/*\n\t * Pin the pages that make up the user buffer and transfer the page\n\t * pointers to the mr's sg array.  We check to see if we've mapped\n\t * the whole region after transferring the partial page references\n\t * to the sg array so that we can have one page ref cleanup path.\n\t *\n\t * For now we have no flag that tells us whether the mapping is\n\t * r/o or r/w. We need to assume r/w, or we'll do a lot of RDMA to\n\t * the zero page.\n\t */\n\tret = rds_pin_pages(args->vec.addr, nr_pages, pages, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnents = ret;\n\tsg = kcalloc(nents, sizeof(*sg), GFP_KERNEL);\n\tif (!sg) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tWARN_ON(!nents);\n\tsg_init_table(sg, nents);\n\n\t/* Stick all pages into the scatterlist */\n\tfor (i = 0 ; i < nents; i++)\n\t\tsg_set_page(&sg[i], pages[i], PAGE_SIZE, 0);\n\n\trdsdebug(\"RDS: trans_private nents is %u\\n\", nents);\n\n\t/* Obtain a transport specific MR. If this succeeds, the\n\t * s/g list is now owned by the MR.\n\t * Note that dma_map() implies that pending writes are\n\t * flushed to RAM, so no dma_sync is needed here. */\n\ttrans_private = rs->rs_transport->get_mr(sg, nents, rs,\n\t\t\t\t\t\t &mr->r_key);\n\n\tif (IS_ERR(trans_private)) {\n\t\tfor (i = 0 ; i < nents; i++)\n\t\t\tput_page(sg_page(&sg[i]));\n\t\tkfree(sg);\n\t\tret = PTR_ERR(trans_private);\n\t\tgoto out;\n\t}\n\n\tmr->r_trans_private = trans_private;\n\n\trdsdebug(\"RDS: get_mr put_user key is %x cookie_addr %p\\n\",\n\t       mr->r_key, (void *)(unsigned long) args->cookie_addr);\n\n\t/* The user may pass us an unaligned address, but we can only\n\t * map page aligned regions. So we keep the offset, and build\n\t * a 64bit cookie containing <R_Key, offset> and pass that\n\t * around. */\n\tcookie = rds_rdma_make_cookie(mr->r_key, args->vec.addr & ~PAGE_MASK);\n\tif (cookie_ret)\n\t\t*cookie_ret = cookie;\n\n\tif (args->cookie_addr && put_user(cookie, (u64 __user *)(unsigned long) args->cookie_addr)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/* Inserting the new MR into the rbtree bumps its\n\t * reference count. */\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\tfound = rds_mr_tree_walk(&rs->rs_rdma_keys, mr->r_key, mr);\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\n\tBUG_ON(found && found != mr);\n\n\trdsdebug(\"RDS: get_mr key is %x\\n\", mr->r_key);\n\tif (mr_ret) {\n\t\trefcount_inc(&mr->r_refcount);\n\t\t*mr_ret = mr;\n\t}\n\n\tret = 0;\nout:\n\tkfree(pages);\n\tif (mr)\n\t\trds_mr_put(mr);\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149678,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int __rds_rdma_map(struct rds_sock *rs, struct rds_get_mr_args *args,\n\t\t\t\tu64 *cookie_ret, struct rds_mr **mr_ret)\n{\n\tstruct rds_mr *mr = NULL, *found;\n\tunsigned int nr_pages;\n\tstruct page **pages = NULL;\n\tstruct scatterlist *sg;\n\tvoid *trans_private;\n\tunsigned long flags;\n\trds_rdma_cookie_t cookie;\n\tunsigned int nents;\n\tlong i;\n\tint ret;\n\n\tif (rs->rs_bound_addr == 0 || !rs->rs_transport) {\n\t\tret = -ENOTCONN; /* XXX not a great errno */\n\t\tgoto out;\n\t}\n\n\tif (!rs->rs_transport->get_mr) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tnr_pages = rds_pages_in_vec(&args->vec);\n\tif (nr_pages == 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Restrict the size of mr irrespective of underlying transport\n\t * To account for unaligned mr regions, subtract one from nr_pages\n\t */\n\tif ((nr_pages - 1) > (RDS_MAX_MSG_SIZE >> PAGE_SHIFT)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\trdsdebug(\"RDS: get_mr addr %llx len %llu nr_pages %u\\n\",\n\t\targs->vec.addr, args->vec.bytes, nr_pages);\n\n\t/* XXX clamp nr_pages to limit the size of this alloc? */\n\tpages = kcalloc(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmr = kzalloc(sizeof(struct rds_mr), GFP_KERNEL);\n\tif (!mr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trefcount_set(&mr->r_refcount, 1);\n\tRB_CLEAR_NODE(&mr->r_rb_node);\n\tmr->r_trans = rs->rs_transport;\n\tmr->r_sock = rs;\n\n\tif (args->flags & RDS_RDMA_USE_ONCE)\n\t\tmr->r_use_once = 1;\n\tif (args->flags & RDS_RDMA_INVALIDATE)\n\t\tmr->r_invalidate = 1;\n\tif (args->flags & RDS_RDMA_READWRITE)\n\t\tmr->r_write = 1;\n\n\t/*\n\t * Pin the pages that make up the user buffer and transfer the page\n\t * pointers to the mr's sg array.  We check to see if we've mapped\n\t * the whole region after transferring the partial page references\n\t * to the sg array so that we can have one page ref cleanup path.\n\t *\n\t * For now we have no flag that tells us whether the mapping is\n\t * r/o or r/w. We need to assume r/w, or we'll do a lot of RDMA to\n\t * the zero page.\n\t */\n\tret = rds_pin_pages(args->vec.addr, nr_pages, pages, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnents = ret;\n\tsg = kcalloc(nents, sizeof(*sg), GFP_KERNEL);\n\tif (!sg) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tWARN_ON(!nents);\n\tsg_init_table(sg, nents);\n\n\t/* Stick all pages into the scatterlist */\n\tfor (i = 0 ; i < nents; i++)\n\t\tsg_set_page(&sg[i], pages[i], PAGE_SIZE, 0);\n\n\trdsdebug(\"RDS: trans_private nents is %u\\n\", nents);\n\n\t/* Obtain a transport specific MR. If this succeeds, the\n\t * s/g list is now owned by the MR.\n\t * Note that dma_map() implies that pending writes are\n\t * flushed to RAM, so no dma_sync is needed here. */\n\ttrans_private = rs->rs_transport->get_mr(sg, nents, rs,\n\t\t\t\t\t\t &mr->r_key);\n\n\tif (IS_ERR(trans_private)) {\n\t\tfor (i = 0 ; i < nents; i++)\n\t\t\tput_page(sg_page(&sg[i]));\n\t\tkfree(sg);\n\t\tret = PTR_ERR(trans_private);\n\t\tgoto out;\n\t}\n\n\tmr->r_trans_private = trans_private;\n\n\trdsdebug(\"RDS: get_mr put_user key is %x cookie_addr %p\\n\",\n\t       mr->r_key, (void *)(unsigned long) args->cookie_addr);\n\n\t/* The user may pass us an unaligned address, but we can only\n\t * map page aligned regions. So we keep the offset, and build\n\t * a 64bit cookie containing <R_Key, offset> and pass that\n\t * around. */\n\tcookie = rds_rdma_make_cookie(mr->r_key, args->vec.addr & ~PAGE_MASK);\n\tif (cookie_ret)\n\t\t*cookie_ret = cookie;\n\n\tif (args->cookie_addr && put_user(cookie, (u64 __user *)(unsigned long) args->cookie_addr)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/* Inserting the new MR into the rbtree bumps its\n\t * reference count. */\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\tfound = rds_mr_tree_walk(&rs->rs_rdma_keys, mr->r_key, mr);\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\n\tBUG_ON(found && found != mr);\n\n\trdsdebug(\"RDS: get_mr key is %x\\n\", mr->r_key);\n\tif (mr_ret) {\n\t\trefcount_inc(&mr->r_refcount);\n\t\t*mr_ret = mr;\n\t}\n\n\tret = 0;\nout:\n\tkfree(pages);\n\tif (mr)\n\t\trds_mr_put(mr);\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149679,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "daemon_AuthUserPwd(char *username, char *password, char *errbuf)\n{\n#ifdef _WIN32\n\t/*\n\t * Warning: the user which launches the process must have the\n\t * SE_TCB_NAME right.\n\t * This corresponds to have the \"Act as part of the Operating System\"\n\t * turned on (administrative tools, local security settings, local\n\t * policies, user right assignment)\n\t * However, it seems to me that if you run it as a service, this\n\t * right should be provided by default.\n\t *\n\t * XXX - hopefully, this returns errors such as ERROR_LOGON_FAILURE,\n\t * which merely indicates that the user name or password is\n\t * incorrect, not whether it's the user name or the password\n\t * that's incorrect, so a client that's trying to brute-force\n\t * accounts doesn't know whether it's the user name or the\n\t * password that's incorrect, so it doesn't know whether to\n\t * stop trying to log in with a given user name and move on\n\t * to another user name.\n\t */\n\tHANDLE Token;\n\tif (LogonUser(username, \".\", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"LogonUser() failed\");\n\t\treturn -1;\n\t}\n\n\t// This call should change the current thread to the selected user.\n\t// I didn't test it.\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}\n\n\tCloseHandle(Token);\n\treturn 0;\n\n#else\n\t/*\n\t * See\n\t *\n\t *\thttp://www.unixpapa.com/incnote/passwd.html\n\t *\n\t * We use the Solaris/Linux shadow password authentication if\n\t * we have getspnam(), otherwise we just do traditional\n\t * authentication, which, on some platforms, might work, even\n\t * with shadow passwords, if we're running as root.  Traditional\n\t * authenticaion won't work if we're not running as root, as\n\t * I think these days all UN*Xes either won't return the password\n\t * at all with getpwnam() or will only do so if you're root.\n\t *\n\t * XXX - perhaps what we *should* be using is PAM, if we have\n\t * it.  That might hide all the details of username/password\n\t * authentication, whether it's done with a visible-to-root-\n\t * only password database or some other authentication mechanism,\n\t * behind its API.\n\t */\n\tstruct passwd *user;\n\tchar *user_password;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd *usersp;\n#endif\n\n\t// This call is needed to get the uid\n\tif ((user = getpwnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_GETSPNAM\n\t// This call is needed to get the password; otherwise 'x' is returned\n\tif ((usersp = getspnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\tuser_password = usersp->sp_pwdp;\n#else\n\t/*\n\t * XXX - what about other platforms?\n\t * The unixpapa.com page claims this Just Works on *BSD if you're\n\t * running as root - it's from 2000, so it doesn't indicate whether\n\t * macOS (which didn't come out until 2001, under the name Mac OS\n\t * X) behaves like the *BSDs or not, and might also work on AIX.\n\t * HP-UX does something else.\n\t *\n\t * Again, hopefully PAM hides all that.\n\t */\n\tuser_password = user->pw_passwd;\n#endif\n\n\tif (strcmp(user_password, (char *) crypt(password, user_password)) != 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\n\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}\n\n/*\tif (setgid(user->pw_gid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setgid\");\n\t\treturn -1;\n\t}\n*/\n\treturn 0;\n\n#endif\n\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149680,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "daemon_AuthUserPwd(char *username, char *password, char *errbuf)\n{\n#ifdef _WIN32\n\t/*\n\t * Warning: the user which launches the process must have the\n\t * SE_TCB_NAME right.\n\t * This corresponds to have the \"Act as part of the Operating System\"\n\t * turned on (administrative tools, local security settings, local\n\t * policies, user right assignment)\n\t * However, it seems to me that if you run it as a service, this\n\t * right should be provided by default.\n\t *\n\t * XXX - hopefully, this returns errors such as ERROR_LOGON_FAILURE,\n\t * which merely indicates that the user name or password is\n\t * incorrect, not whether it's the user name or the password\n\t * that's incorrect, so a client that's trying to brute-force\n\t * accounts doesn't know whether it's the user name or the\n\t * password that's incorrect, so it doesn't know whether to\n\t * stop trying to log in with a given user name and move on\n\t * to another user name.\n\t */\n\tHANDLE Token;\n\tif (LogonUser(username, \".\", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"LogonUser() failed\");\n\t\treturn -1;\n\t}\n\n\t// This call should change the current thread to the selected user.\n\t// I didn't test it.\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}\n\n\tCloseHandle(Token);\n\treturn 0;\n\n#else\n\t/*\n\t * See\n\t *\n\t *\thttp://www.unixpapa.com/incnote/passwd.html\n\t *\n\t * We use the Solaris/Linux shadow password authentication if\n\t * we have getspnam(), otherwise we just do traditional\n\t * authentication, which, on some platforms, might work, even\n\t * with shadow passwords, if we're running as root.  Traditional\n\t * authenticaion won't work if we're not running as root, as\n\t * I think these days all UN*Xes either won't return the password\n\t * at all with getpwnam() or will only do so if you're root.\n\t *\n\t * XXX - perhaps what we *should* be using is PAM, if we have\n\t * it.  That might hide all the details of username/password\n\t * authentication, whether it's done with a visible-to-root-\n\t * only password database or some other authentication mechanism,\n\t * behind its API.\n\t */\n\tstruct passwd *user;\n\tchar *user_password;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd *usersp;\n#endif\n\tchar *crypt_password;\n\n\t// This call is needed to get the uid\n\tif ((user = getpwnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_GETSPNAM\n\t// This call is needed to get the password; otherwise 'x' is returned\n\tif ((usersp = getspnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\tuser_password = usersp->sp_pwdp;\n#else\n\t/*\n\t * XXX - what about other platforms?\n\t * The unixpapa.com page claims this Just Works on *BSD if you're\n\t * running as root - it's from 2000, so it doesn't indicate whether\n\t * macOS (which didn't come out until 2001, under the name Mac OS\n\t * X) behaves like the *BSDs or not, and might also work on AIX.\n\t * HP-UX does something else.\n\t *\n\t * Again, hopefully PAM hides all that.\n\t */\n\tuser_password = user->pw_passwd;\n#endif\n\n\tcrypt_password = crypt(password, user_password);\n\tif (crypt_password == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n\t\treturn -1;\n\t}\n\tif (strcmp(user_password, crypt_password) != 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\n\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}\n\n/*\tif (setgid(user->pw_gid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setgid\");\n\t\treturn -1;\n\t}\n*/\n\treturn 0;\n\n#endif\n\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149681,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "open_ssl_connection (rfbClient *client, int sockfd, rfbBool anonTLS, rfbCredential *cred)\n{\n  SSL_CTX *ssl_ctx = NULL;\n  SSL *ssl = NULL;\n  int n, finished = 0;\n  X509_VERIFY_PARAM *param;\n  uint8_t verify_crls = cred->x509Credential.x509CrlVerifyMode;\n\n  if (!(ssl_ctx = SSL_CTX_new(SSLv23_client_method())))\n  {\n    rfbClientLog(\"Could not create new SSL context.\\n\");\n    return NULL;\n  }\n\n  param = X509_VERIFY_PARAM_new();\n\n  /* Setup verification if not anonymous */\n  if (!anonTLS)\n  {\n    if (cred->x509Credential.x509CACertFile)\n    {\n      if (!SSL_CTX_load_verify_locations(ssl_ctx, cred->x509Credential.x509CACertFile, NULL))\n      {\n        rfbClientLog(\"Failed to load CA certificate from %s.\\n\",\n                     cred->x509Credential.x509CACertFile);\n        goto error_free_ctx;\n      }\n    } else {\n      rfbClientLog(\"Using default paths for certificate verification.\\n\");\n      SSL_CTX_set_default_verify_paths (ssl_ctx);\n    }\n\n    if (cred->x509Credential.x509CACrlFile)\n    {\n      if (!load_crls_from_file(cred->x509Credential.x509CACrlFile, ssl_ctx))\n      {\n        rfbClientLog(\"CRLs could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n      if (verify_crls == rfbX509CrlVerifyNone) verify_crls = rfbX509CrlVerifyAll;\n    }\n\n    if (cred->x509Credential.x509ClientCertFile && cred->x509Credential.x509ClientKeyFile)\n    {\n      if (SSL_CTX_use_certificate_chain_file(ssl_ctx, cred->x509Credential.x509ClientCertFile) != 1)\n      {\n        rfbClientLog(\"Client certificate could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_use_PrivateKey_file(ssl_ctx, cred->x509Credential.x509ClientKeyFile,\n                                      SSL_FILETYPE_PEM) != 1)\n      {\n        rfbClientLog(\"Client private key could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_check_private_key(ssl_ctx) == 0) {\n        rfbClientLog(\"Client certificate and private key do not match.\\n\");\n        goto error_free_ctx;\n      }\n    }\n\n    SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);\n\n    if (verify_crls == rfbX509CrlVerifyClient) \n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK);\n    else if (verify_crls == rfbX509CrlVerifyAll)\n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n\n    if(!X509_VERIFY_PARAM_set1_host(param, client->serverHost, strlen(client->serverHost)))\n    {\n      rfbClientLog(\"Could not set server name for verification.\\n\");\n      goto error_free_ctx;\n    }\n    SSL_CTX_set1_param(ssl_ctx, param);\n  }\n\n  if (!(ssl = SSL_new (ssl_ctx)))\n  {\n    rfbClientLog(\"Could not create a new SSL session.\\n\");\n    goto error_free_ctx;\n  }\n\n  /* TODO: finetune this list, take into account anonTLS bool */\n  SSL_set_cipher_list(ssl, \"ALL\");\n\n  SSL_set_fd (ssl, sockfd);\n  SSL_CTX_set_app_data (ssl_ctx, client);\n\n  do\n  {\n    n = SSL_connect(ssl);\n\t\t\n    if (n != 1) \n    {\n      if (wait_for_data(ssl, n, 1) != 1) \n      {\n        finished = 1;\n        SSL_shutdown(ssl);\n\n        goto error_free_ssl;\n      }\n    }\n  } while( n != 1 && finished != 1 );\n\n  X509_VERIFY_PARAM_free(param);\n  return ssl;\n\nerror_free_ssl:\n  SSL_free(ssl);\n\nerror_free_ctx:\n  X509_VERIFY_PARAM_free(param);\n  SSL_CTX_free(ssl_ctx);\n\n  return NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149684,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "open_ssl_connection (rfbClient *client, int sockfd, rfbBool anonTLS, rfbCredential *cred)\n{\n  SSL_CTX *ssl_ctx = NULL;\n  SSL *ssl = NULL;\n  int n, finished = 0;\n  X509_VERIFY_PARAM *param;\n  uint8_t verify_crls;\n\n  if (!(ssl_ctx = SSL_CTX_new(SSLv23_client_method())))\n  {\n    rfbClientLog(\"Could not create new SSL context.\\n\");\n    return NULL;\n  }\n\n  param = X509_VERIFY_PARAM_new();\n\n  /* Setup verification if not anonymous */\n  if (!anonTLS)\n  {\n    verify_crls = cred->x509Credential.x509CrlVerifyMode;\n    if (cred->x509Credential.x509CACertFile)\n    {\n      if (!SSL_CTX_load_verify_locations(ssl_ctx, cred->x509Credential.x509CACertFile, NULL))\n      {\n        rfbClientLog(\"Failed to load CA certificate from %s.\\n\",\n                     cred->x509Credential.x509CACertFile);\n        goto error_free_ctx;\n      }\n    } else {\n      rfbClientLog(\"Using default paths for certificate verification.\\n\");\n      SSL_CTX_set_default_verify_paths (ssl_ctx);\n    }\n\n    if (cred->x509Credential.x509CACrlFile)\n    {\n      if (!load_crls_from_file(cred->x509Credential.x509CACrlFile, ssl_ctx))\n      {\n        rfbClientLog(\"CRLs could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n      if (verify_crls == rfbX509CrlVerifyNone) verify_crls = rfbX509CrlVerifyAll;\n    }\n\n    if (cred->x509Credential.x509ClientCertFile && cred->x509Credential.x509ClientKeyFile)\n    {\n      if (SSL_CTX_use_certificate_chain_file(ssl_ctx, cred->x509Credential.x509ClientCertFile) != 1)\n      {\n        rfbClientLog(\"Client certificate could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_use_PrivateKey_file(ssl_ctx, cred->x509Credential.x509ClientKeyFile,\n                                      SSL_FILETYPE_PEM) != 1)\n      {\n        rfbClientLog(\"Client private key could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_check_private_key(ssl_ctx) == 0) {\n        rfbClientLog(\"Client certificate and private key do not match.\\n\");\n        goto error_free_ctx;\n      }\n    }\n\n    SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);\n\n    if (verify_crls == rfbX509CrlVerifyClient) \n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK);\n    else if (verify_crls == rfbX509CrlVerifyAll)\n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n\n    if(!X509_VERIFY_PARAM_set1_host(param, client->serverHost, strlen(client->serverHost)))\n    {\n      rfbClientLog(\"Could not set server name for verification.\\n\");\n      goto error_free_ctx;\n    }\n    SSL_CTX_set1_param(ssl_ctx, param);\n  }\n\n  if (!(ssl = SSL_new (ssl_ctx)))\n  {\n    rfbClientLog(\"Could not create a new SSL session.\\n\");\n    goto error_free_ctx;\n  }\n\n  /* TODO: finetune this list, take into account anonTLS bool */\n  SSL_set_cipher_list(ssl, \"ALL\");\n\n  SSL_set_fd (ssl, sockfd);\n  SSL_CTX_set_app_data (ssl_ctx, client);\n\n  do\n  {\n    n = SSL_connect(ssl);\n\t\t\n    if (n != 1) \n    {\n      if (wait_for_data(ssl, n, 1) != 1) \n      {\n        finished = 1;\n        SSL_shutdown(ssl);\n\n        goto error_free_ssl;\n      }\n    }\n  } while( n != 1 && finished != 1 );\n\n  X509_VERIFY_PARAM_free(param);\n  return ssl;\n\nerror_free_ssl:\n  SSL_free(ssl);\n\nerror_free_ctx:\n  X509_VERIFY_PARAM_free(param);\n  SSL_CTX_free(ssl_ctx);\n\n  return NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149685,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void copyIPv6IfDifferent(void * dest, const void * src)\n{\n\tif(dest != src) {\n\t\tmemcpy(dest, src, sizeof(struct in6_addr));\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149686,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void copyIPv6IfDifferent(void * dest, const void * src)\n{\n\tif(dest != src && src != NULL) {\n\t\tmemcpy(dest, src, sizeof(struct in6_addr));\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149687,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "archive_acl_from_text_l(struct archive_acl *acl, const char *text,\n    int want_type, struct archive_string_conv *sc)\n{\n\tstruct {\n\t\tconst char *start;\n\t\tconst char *end;\n\t} field[6], name;\n\n\tconst char *s, *st;\n\tint numfields, fields, n, r, sol, ret;\n\tint type, types, tag, permset, id;\n\tsize_t len;\n\tchar sep;\n\n\tswitch (want_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:\n\t\twant_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;\n\t\t__LA_FALLTHROUGH;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tnumfields = 5;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tnumfields = 6;\n\t\tbreak;\n\tdefault:\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tret = ARCHIVE_OK;\n\ttypes = 0;\n\n\twhile (text != NULL &&  *text != '\\0') {\n\t\t/*\n\t\t * Parse the fields out of the next entry,\n\t\t * advance 'text' to start of next entry.\n\t\t */\n\t\tfields = 0;\n\t\tdo {\n\t\t\tconst char *start, *end;\n\t\t\tnext_field(&text, &start, &end, &sep);\n\t\t\tif (fields < numfields) {\n\t\t\t\tfield[fields].start = start;\n\t\t\t\tfield[fields].end = end;\n\t\t\t}\n\t\t\t++fields;\n\t\t} while (sep == ':');\n\n\t\t/* Set remaining fields to blank. */\n\t\tfor (n = fields; n < numfields; ++n)\n\t\t\tfield[n].start = field[n].end = NULL;\n\n\t\tif (field[0].start != NULL && *(field[0].start) == '#') {\n\t\t\t/* Comment, skip entry */\n\t\t\tcontinue;\n\t\t}\n\n\t\tn = 0;\n\t\tsol = 0;\n\t\tid = -1;\n\t\tpermset = 0;\n\t\tname.start = name.end = NULL;\n\n\t\tif (want_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\t/* POSIX.1e ACLs */\n\t\t\t/*\n\t\t\t * Default keyword \"default:user::rwx\"\n\t\t\t * if found, we have one more field\n\t\t\t *\n\t\t\t * We also support old Solaris extension:\n\t\t\t * \"defaultuser::rwx\" is the default ACL corresponding\n\t\t\t * to \"user::rwx\", etc. valid only for first field\n\t\t\t */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\tif (*s == 'd' && (len == 1 || (len >= 7\n\t\t\t    && memcmp((s + 1), \"efault\", 6) == 0))) {\n\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;\n\t\t\t\tif (len > 7)\n\t\t\t\t\tfield[0].start += 7;\n\t\t\t\telse\n\t\t\t\t\tn = 1;\n\t\t\t} else\n\t\t\t\ttype = want_type;\n\n\t\t\t/* Check for a numeric ID in field n+1 or n+3. */\n\t\t\tisint(field[n + 1].start, field[n + 1].end, &id);\n\t\t\t/* Field n+3 is optional. */\n\t\t\tif (id == -1 && fields > (n + 3))\n\t\t\t\tisint(field[n + 3].start, field[n + 3].end,\n\t\t\t\t    &id);\n\n\t\t\ttag = 0;\n\t\t\ts = field[n].start;\n\t\t\tst = field[n].start + 1;\n\t\t\tlen = field[n].end - field[n].start;\n\n\t\t\tswitch (*s) {\n\t\t\tcase 'u':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \"ser\", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \"roup\", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \"ther\", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_OTHER;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \"ask\", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_MASK;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (tag) {\n\t\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\t\tif (fields == (n + 2)\n\t\t\t\t    && field[n + 1].start < field[n + 1].end\n\t\t\t\t    && ismode(field[n + 1].start,\n\t\t\t\t    field[n + 1].end, &permset)) {\n\t\t\t\t\t/* This is Solaris-style \"other:rwx\" */\n\t\t\t\t\tsol = 1;\n\t\t\t\t} else if (fields == (n + 3) &&\n\t\t\t\t    field[n + 1].start < field[n + 1].end) {\n\t\t\t\t\t/* Invalid mask or other field */\n\t\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\t\tif (id != -1 ||\n\t\t\t\t    field[n + 1].start < field[n + 1].end) {\n\t\t\t\t\tname = field[n + 1];\n\t\t\t\t\tif (tag == ARCHIVE_ENTRY_ACL_USER_OBJ)\n\t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\t\telse\n\t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* Invalid tag, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Without \"default:\" we expect mode in field 3\n\t\t\t * Exception: Solaris other and mask fields\n\t\t\t */\n\t\t\tif (permset == 0 && !ismode(field[n + 2 - sol].start,\n\t\t\t    field[n + 2 - sol].end, &permset)) {\n\t\t\t\t/* Invalid mode, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\t/* NFS4 ACLs */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\ttag = 0;\n\n\t\t\tswitch (len) {\n\t\t\tcase 4:\n\t\t\t\tif (memcmp(s, \"user\", 4) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tif (memcmp(s, \"group\", 5) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tif (memcmp(s, \"owner@\", 6) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\telse if (memcmp(s, \"group@\", 6) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tif (memcmp(s, \"everyone@\", 9) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_EVERYONE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (tag == 0) {\n\t\t\t\t/* Invalid tag, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t} else if (tag == ARCHIVE_ENTRY_ACL_USER ||\n\t\t\t    tag == ARCHIVE_ENTRY_ACL_GROUP) {\n\t\t\t\tn = 1;\n\t\t\t\tname = field[1];\n\t\t\t\tisint(name.start, name.end, &id);\n\t\t\t} else\n\t\t\t\tn = 0;\n\n\t\t\tif (!is_nfs4_perms(field[1 + n].start,\n\t\t\t    field[1 + n].end, &permset)) {\n\t\t\t\t/* Invalid NFSv4 perms, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!is_nfs4_flags(field[2 + n].start,\n\t\t\t    field[2 + n].end, &permset)) {\n\t\t\t\t/* Invalid NFSv4 flags, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts = field[3 + n].start;\n\t\t\tlen = field[3 + n].end - field[3 + n].start;\n\t\t\ttype = 0;\n\t\t\tif (len == 4) {\n\t\t\t\tif (memcmp(s, \"deny\", 4) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DENY;\n\t\t\t} else if (len == 5) {\n\t\t\t\tif (memcmp(s, \"allow\", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;\n\t\t\t\telse if (memcmp(s, \"audit\", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_AUDIT;\n\t\t\t\telse if (memcmp(s, \"alarm\", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALARM;\n\t\t\t}\n\t\t\tif (type == 0) {\n\t\t\t\t/* Invalid entry type, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tisint(field[4 + n].start, field[4 + n].end,\n\t\t\t    &id);\n\t\t}\n\n\t\t/* Add entry to the internal list. */\n\t\tr = archive_acl_add_entry_len_l(acl, type, permset,\n\t\t    tag, id, name.start, name.end - name.start, sc);\n\t\tif (r < ARCHIVE_WARN)\n\t\t\treturn (r);\n\t\tif (r != ARCHIVE_OK)\n\t\t\tret = ARCHIVE_WARN;\n\t\ttypes |= type;\n\t}\n\n\t/* Reset ACL */\n\tarchive_acl_reset(acl, types);\n\n\treturn (ret);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149688,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "archive_acl_from_text_l(struct archive_acl *acl, const char *text,\n    int want_type, struct archive_string_conv *sc)\n{\n\tstruct {\n\t\tconst char *start;\n\t\tconst char *end;\n\t} field[6], name;\n\n\tconst char *s, *st;\n\tint numfields, fields, n, r, sol, ret;\n\tint type, types, tag, permset, id;\n\tsize_t len;\n\tchar sep;\n\n\tswitch (want_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:\n\t\twant_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;\n\t\t__LA_FALLTHROUGH;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tnumfields = 5;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tnumfields = 6;\n\t\tbreak;\n\tdefault:\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tret = ARCHIVE_OK;\n\ttypes = 0;\n\n\twhile (text != NULL &&  *text != '\\0') {\n\t\t/*\n\t\t * Parse the fields out of the next entry,\n\t\t * advance 'text' to start of next entry.\n\t\t */\n\t\tfields = 0;\n\t\tdo {\n\t\t\tconst char *start, *end;\n\t\t\tnext_field(&text, &start, &end, &sep);\n\t\t\tif (fields < numfields) {\n\t\t\t\tfield[fields].start = start;\n\t\t\t\tfield[fields].end = end;\n\t\t\t}\n\t\t\t++fields;\n\t\t} while (sep == ':');\n\n\t\t/* Set remaining fields to blank. */\n\t\tfor (n = fields; n < numfields; ++n)\n\t\t\tfield[n].start = field[n].end = NULL;\n\n\t\tif (field[0].start != NULL && *(field[0].start) == '#') {\n\t\t\t/* Comment, skip entry */\n\t\t\tcontinue;\n\t\t}\n\n\t\tn = 0;\n\t\tsol = 0;\n\t\tid = -1;\n\t\tpermset = 0;\n\t\tname.start = name.end = NULL;\n\n\t\tif (want_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\t/* POSIX.1e ACLs */\n\t\t\t/*\n\t\t\t * Default keyword \"default:user::rwx\"\n\t\t\t * if found, we have one more field\n\t\t\t *\n\t\t\t * We also support old Solaris extension:\n\t\t\t * \"defaultuser::rwx\" is the default ACL corresponding\n\t\t\t * to \"user::rwx\", etc. valid only for first field\n\t\t\t */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\tif (*s == 'd' && (len == 1 || (len >= 7\n\t\t\t    && memcmp((s + 1), \"efault\", 6) == 0))) {\n\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;\n\t\t\t\tif (len > 7)\n\t\t\t\t\tfield[0].start += 7;\n\t\t\t\telse\n\t\t\t\t\tn = 1;\n\t\t\t} else\n\t\t\t\ttype = want_type;\n\n\t\t\t/* Check for a numeric ID in field n+1 or n+3. */\n\t\t\tisint(field[n + 1].start, field[n + 1].end, &id);\n\t\t\t/* Field n+3 is optional. */\n\t\t\tif (id == -1 && fields > (n + 3))\n\t\t\t\tisint(field[n + 3].start, field[n + 3].end,\n\t\t\t\t    &id);\n\n\t\t\ttag = 0;\n\t\t\ts = field[n].start;\n\t\t\tst = field[n].start + 1;\n\t\t\tlen = field[n].end - field[n].start;\n\n\t\t\tif (len == 0) {\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (*s) {\n\t\t\tcase 'u':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \"ser\", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \"roup\", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \"ther\", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_OTHER;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \"ask\", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_MASK;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (tag) {\n\t\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\t\tif (fields == (n + 2)\n\t\t\t\t    && field[n + 1].start < field[n + 1].end\n\t\t\t\t    && ismode(field[n + 1].start,\n\t\t\t\t    field[n + 1].end, &permset)) {\n\t\t\t\t\t/* This is Solaris-style \"other:rwx\" */\n\t\t\t\t\tsol = 1;\n\t\t\t\t} else if (fields == (n + 3) &&\n\t\t\t\t    field[n + 1].start < field[n + 1].end) {\n\t\t\t\t\t/* Invalid mask or other field */\n\t\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\t\tif (id != -1 ||\n\t\t\t\t    field[n + 1].start < field[n + 1].end) {\n\t\t\t\t\tname = field[n + 1];\n\t\t\t\t\tif (tag == ARCHIVE_ENTRY_ACL_USER_OBJ)\n\t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\t\telse\n\t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* Invalid tag, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Without \"default:\" we expect mode in field 3\n\t\t\t * Exception: Solaris other and mask fields\n\t\t\t */\n\t\t\tif (permset == 0 && !ismode(field[n + 2 - sol].start,\n\t\t\t    field[n + 2 - sol].end, &permset)) {\n\t\t\t\t/* Invalid mode, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\t/* NFS4 ACLs */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\ttag = 0;\n\n\t\t\tswitch (len) {\n\t\t\tcase 4:\n\t\t\t\tif (memcmp(s, \"user\", 4) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tif (memcmp(s, \"group\", 5) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tif (memcmp(s, \"owner@\", 6) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\telse if (memcmp(s, \"group@\", 6) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tif (memcmp(s, \"everyone@\", 9) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_EVERYONE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (tag == 0) {\n\t\t\t\t/* Invalid tag, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t} else if (tag == ARCHIVE_ENTRY_ACL_USER ||\n\t\t\t    tag == ARCHIVE_ENTRY_ACL_GROUP) {\n\t\t\t\tn = 1;\n\t\t\t\tname = field[1];\n\t\t\t\tisint(name.start, name.end, &id);\n\t\t\t} else\n\t\t\t\tn = 0;\n\n\t\t\tif (!is_nfs4_perms(field[1 + n].start,\n\t\t\t    field[1 + n].end, &permset)) {\n\t\t\t\t/* Invalid NFSv4 perms, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!is_nfs4_flags(field[2 + n].start,\n\t\t\t    field[2 + n].end, &permset)) {\n\t\t\t\t/* Invalid NFSv4 flags, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts = field[3 + n].start;\n\t\t\tlen = field[3 + n].end - field[3 + n].start;\n\t\t\ttype = 0;\n\t\t\tif (len == 4) {\n\t\t\t\tif (memcmp(s, \"deny\", 4) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DENY;\n\t\t\t} else if (len == 5) {\n\t\t\t\tif (memcmp(s, \"allow\", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;\n\t\t\t\telse if (memcmp(s, \"audit\", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_AUDIT;\n\t\t\t\telse if (memcmp(s, \"alarm\", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALARM;\n\t\t\t}\n\t\t\tif (type == 0) {\n\t\t\t\t/* Invalid entry type, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tisint(field[4 + n].start, field[4 + n].end,\n\t\t\t    &id);\n\t\t}\n\n\t\t/* Add entry to the internal list. */\n\t\tr = archive_acl_add_entry_len_l(acl, type, permset,\n\t\t    tag, id, name.start, name.end - name.start, sc);\n\t\tif (r < ARCHIVE_WARN)\n\t\t\treturn (r);\n\t\tif (r != ARCHIVE_OK)\n\t\t\tret = ARCHIVE_WARN;\n\t\ttypes |= type;\n\t}\n\n\t/* Reset ACL */\n\tarchive_acl_reset(acl, types);\n\n\treturn (ret);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149689,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int attribute_align_arg avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)\n{\n    int ret = 0;\n    int codec_init_ok = 0;\n    AVDictionary *tmp = NULL;\n    const AVPixFmtDescriptor *pixdesc;\n\n    if (avcodec_is_open(avctx))\n        return 0;\n\n    if ((!codec && !avctx->codec)) {\n        av_log(avctx, AV_LOG_ERROR, \"No codec provided to avcodec_open2()\\n\");\n        return AVERROR(EINVAL);\n    }\n    if ((codec && avctx->codec && codec != avctx->codec)) {\n        av_log(avctx, AV_LOG_ERROR, \"This AVCodecContext was allocated for %s, \"\n                                    \"but %s passed to avcodec_open2()\\n\", avctx->codec->name, codec->name);\n        return AVERROR(EINVAL);\n    }\n    if (!codec)\n        codec = avctx->codec;\n\n    if (avctx->extradata_size < 0 || avctx->extradata_size >= FF_MAX_EXTRADATA_SIZE)\n        return AVERROR(EINVAL);\n\n    if (options)\n        av_dict_copy(&tmp, *options, 0);\n\n    ff_lock_avcodec(avctx, codec);\n\n    avctx->internal = av_mallocz(sizeof(*avctx->internal));\n    if (!avctx->internal) {\n        ret = AVERROR(ENOMEM);\n        goto end;\n    }\n\n    avctx->internal->pool = av_mallocz(sizeof(*avctx->internal->pool));\n    if (!avctx->internal->pool) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->to_free = av_frame_alloc();\n    if (!avctx->internal->to_free) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->compat_decode_frame = av_frame_alloc();\n    if (!avctx->internal->compat_decode_frame) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->buffer_frame = av_frame_alloc();\n    if (!avctx->internal->buffer_frame) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->buffer_pkt = av_packet_alloc();\n    if (!avctx->internal->buffer_pkt) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->ds.in_pkt = av_packet_alloc();\n    if (!avctx->internal->ds.in_pkt) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->last_pkt_props = av_packet_alloc();\n    if (!avctx->internal->last_pkt_props) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->skip_samples_multiplier = 1;\n\n    if (codec->priv_data_size > 0) {\n        if (!avctx->priv_data) {\n            avctx->priv_data = av_mallocz(codec->priv_data_size);\n            if (!avctx->priv_data) {\n                ret = AVERROR(ENOMEM);\n                goto end;\n            }\n            if (codec->priv_class) {\n                *(const AVClass **)avctx->priv_data = codec->priv_class;\n                av_opt_set_defaults(avctx->priv_data);\n            }\n        }\n        if (codec->priv_class && (ret = av_opt_set_dict(avctx->priv_data, &tmp)) < 0)\n            goto free_and_end;\n    } else {\n        avctx->priv_data = NULL;\n    }\n    if ((ret = av_opt_set_dict(avctx, &tmp)) < 0)\n        goto free_and_end;\n\n    if (avctx->codec_whitelist && av_match_list(codec->name, avctx->codec_whitelist, ',') <= 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Codec (%s) not on whitelist \\'%s\\'\\n\", codec->name, avctx->codec_whitelist);\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n\n    // only call ff_set_dimensions() for non H.264/VP6F/DXV codecs so as not to overwrite previously setup dimensions\n    if (!(avctx->coded_width && avctx->coded_height && avctx->width && avctx->height &&\n          (avctx->codec_id == AV_CODEC_ID_H264 || avctx->codec_id == AV_CODEC_ID_VP6F || avctx->codec_id == AV_CODEC_ID_DXV))) {\n    if (avctx->coded_width && avctx->coded_height)\n        ret = ff_set_dimensions(avctx, avctx->coded_width, avctx->coded_height);\n    else if (avctx->width && avctx->height)\n        ret = ff_set_dimensions(avctx, avctx->width, avctx->height);\n    if (ret < 0)\n        goto free_and_end;\n    }\n\n    if ((avctx->coded_width || avctx->coded_height || avctx->width || avctx->height)\n        && (  av_image_check_size2(avctx->coded_width, avctx->coded_height, avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx) < 0\n           || av_image_check_size2(avctx->width,       avctx->height,       avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx) < 0)) {\n        av_log(avctx, AV_LOG_WARNING, \"Ignoring invalid width/height values\\n\");\n        ff_set_dimensions(avctx, 0, 0);\n    }\n\n    if (avctx->width > 0 && avctx->height > 0) {\n        if (av_image_check_sar(avctx->width, avctx->height,\n                               avctx->sample_aspect_ratio) < 0) {\n            av_log(avctx, AV_LOG_WARNING, \"ignoring invalid SAR: %u/%u\\n\",\n                   avctx->sample_aspect_ratio.num,\n                   avctx->sample_aspect_ratio.den);\n            avctx->sample_aspect_ratio = (AVRational){ 0, 1 };\n        }\n    }\n\n    /* if the decoder init function was already called previously,\n     * free the already allocated subtitle_header before overwriting it */\n    if (av_codec_is_decoder(codec))\n        av_freep(&avctx->subtitle_header);\n\n    if (avctx->channels > FF_SANE_NB_CHANNELS) {\n        av_log(avctx, AV_LOG_ERROR, \"Too many channels: %d\\n\", avctx->channels);\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n\n    avctx->codec = codec;\n    if ((avctx->codec_type == AVMEDIA_TYPE_UNKNOWN || avctx->codec_type == codec->type) &&\n        avctx->codec_id == AV_CODEC_ID_NONE) {\n        avctx->codec_type = codec->type;\n        avctx->codec_id   = codec->id;\n    }\n    if (avctx->codec_id != codec->id || (avctx->codec_type != codec->type\n                                         && avctx->codec_type != AVMEDIA_TYPE_ATTACHMENT)) {\n        av_log(avctx, AV_LOG_ERROR, \"Codec type or id mismatches\\n\");\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n    avctx->frame_number = 0;\n    avctx->codec_descriptor = avcodec_descriptor_get(avctx->codec_id);\n\n    if ((avctx->codec->capabilities & AV_CODEC_CAP_EXPERIMENTAL) &&\n        avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n        const char *codec_string = av_codec_is_encoder(codec) ? \"encoder\" : \"decoder\";\n        AVCodec *codec2;\n        av_log(avctx, AV_LOG_ERROR,\n               \"The %s '%s' is experimental but experimental codecs are not enabled, \"\n               \"add '-strict %d' if you want to use it.\\n\",\n               codec_string, codec->name, FF_COMPLIANCE_EXPERIMENTAL);\n        codec2 = av_codec_is_encoder(codec) ? avcodec_find_encoder(codec->id) : avcodec_find_decoder(codec->id);\n        if (!(codec2->capabilities & AV_CODEC_CAP_EXPERIMENTAL))\n            av_log(avctx, AV_LOG_ERROR, \"Alternatively use the non experimental %s '%s'.\\n\",\n                codec_string, codec2->name);\n        ret = AVERROR_EXPERIMENTAL;\n        goto free_and_end;\n    }\n\n    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO &&\n        (!avctx->time_base.num || !avctx->time_base.den)) {\n        avctx->time_base.num = 1;\n        avctx->time_base.den = avctx->sample_rate;\n    }\n\n    if (!HAVE_THREADS)\n        av_log(avctx, AV_LOG_WARNING, \"Warning: not compiled with thread support, using thread emulation\\n\");\n\n    if (CONFIG_FRAME_THREAD_ENCODER && av_codec_is_encoder(avctx->codec)) {\n        ff_unlock_avcodec(codec); //we will instantiate a few encoders thus kick the counter to prevent false detection of a problem\n        ret = ff_frame_thread_encoder_init(avctx, options ? *options : NULL);\n        ff_lock_avcodec(avctx, codec);\n        if (ret < 0)\n            goto free_and_end;\n    }\n\n    if (av_codec_is_decoder(avctx->codec)) {\n        ret = ff_decode_bsfs_init(avctx);\n        if (ret < 0)\n            goto free_and_end;\n    }\n\n    if (HAVE_THREADS\n        && !(avctx->internal->frame_thread_encoder && (avctx->active_thread_type&FF_THREAD_FRAME))) {\n        ret = ff_thread_init(avctx);\n        if (ret < 0) {\n            goto free_and_end;\n        }\n    }\n    if (!HAVE_THREADS && !(codec->capabilities & AV_CODEC_CAP_AUTO_THREADS))\n        avctx->thread_count = 1;\n\n    if (avctx->codec->max_lowres < avctx->lowres || avctx->lowres < 0) {\n        av_log(avctx, AV_LOG_WARNING, \"The maximum value for lowres supported by the decoder is %d\\n\",\n               avctx->codec->max_lowres);\n        avctx->lowres = avctx->codec->max_lowres;\n    }\n\n    if (av_codec_is_encoder(avctx->codec)) {\n        int i;\n#if FF_API_CODED_FRAME\nFF_DISABLE_DEPRECATION_WARNINGS\n        avctx->coded_frame = av_frame_alloc();\n        if (!avctx->coded_frame) {\n            ret = AVERROR(ENOMEM);\n            goto free_and_end;\n        }\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n        if (avctx->time_base.num <= 0 || avctx->time_base.den <= 0) {\n            av_log(avctx, AV_LOG_ERROR, \"The encoder timebase is not set.\\n\");\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n\n        if (avctx->codec->sample_fmts) {\n            for (i = 0; avctx->codec->sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {\n                if (avctx->sample_fmt == avctx->codec->sample_fmts[i])\n                    break;\n                if (avctx->channels == 1 &&\n                    av_get_planar_sample_fmt(avctx->sample_fmt) ==\n                    av_get_planar_sample_fmt(avctx->codec->sample_fmts[i])) {\n                    avctx->sample_fmt = avctx->codec->sample_fmts[i];\n                    break;\n                }\n            }\n            if (avctx->codec->sample_fmts[i] == AV_SAMPLE_FMT_NONE) {\n                char buf[128];\n                snprintf(buf, sizeof(buf), \"%d\", avctx->sample_fmt);\n                av_log(avctx, AV_LOG_ERROR, \"Specified sample format %s is invalid or not supported\\n\",\n                       (char *)av_x_if_null(av_get_sample_fmt_name(avctx->sample_fmt), buf));\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (avctx->codec->pix_fmts) {\n            for (i = 0; avctx->codec->pix_fmts[i] != AV_PIX_FMT_NONE; i++)\n                if (avctx->pix_fmt == avctx->codec->pix_fmts[i])\n                    break;\n            if (avctx->codec->pix_fmts[i] == AV_PIX_FMT_NONE\n                && !((avctx->codec_id == AV_CODEC_ID_MJPEG || avctx->codec_id == AV_CODEC_ID_LJPEG)\n                     && avctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL)) {\n                char buf[128];\n                snprintf(buf, sizeof(buf), \"%d\", avctx->pix_fmt);\n                av_log(avctx, AV_LOG_ERROR, \"Specified pixel format %s is invalid or not supported\\n\",\n                       (char *)av_x_if_null(av_get_pix_fmt_name(avctx->pix_fmt), buf));\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n            if (avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ420P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ411P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ422P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ440P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ444P)\n                avctx->color_range = AVCOL_RANGE_JPEG;\n        }\n        if (avctx->codec->supported_samplerates) {\n            for (i = 0; avctx->codec->supported_samplerates[i] != 0; i++)\n                if (avctx->sample_rate == avctx->codec->supported_samplerates[i])\n                    break;\n            if (avctx->codec->supported_samplerates[i] == 0) {\n                av_log(avctx, AV_LOG_ERROR, \"Specified sample rate %d is not supported\\n\",\n                       avctx->sample_rate);\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (avctx->sample_rate < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Specified sample rate %d is not supported\\n\",\n                    avctx->sample_rate);\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if (avctx->codec->channel_layouts) {\n            if (!avctx->channel_layout) {\n                av_log(avctx, AV_LOG_WARNING, \"Channel layout not specified\\n\");\n            } else {\n                for (i = 0; avctx->codec->channel_layouts[i] != 0; i++)\n                    if (avctx->channel_layout == avctx->codec->channel_layouts[i])\n                        break;\n                if (avctx->codec->channel_layouts[i] == 0) {\n                    char buf[512];\n                    av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);\n                    av_log(avctx, AV_LOG_ERROR, \"Specified channel layout '%s' is not supported\\n\", buf);\n                    ret = AVERROR(EINVAL);\n                    goto free_and_end;\n                }\n            }\n        }\n        if (avctx->channel_layout && avctx->channels) {\n            int channels = av_get_channel_layout_nb_channels(avctx->channel_layout);\n            if (channels != avctx->channels) {\n                char buf[512];\n                av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Channel layout '%s' with %d channels does not match number of specified channels %d\\n\",\n                       buf, channels, avctx->channels);\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        } else if (avctx->channel_layout) {\n            avctx->channels = av_get_channel_layout_nb_channels(avctx->channel_layout);\n        }\n        if (avctx->channels < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Specified number of channels %d is not supported\\n\",\n                    avctx->channels);\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if(avctx->codec_type == AVMEDIA_TYPE_VIDEO) {\n            pixdesc = av_pix_fmt_desc_get(avctx->pix_fmt);\n            if (    avctx->bits_per_raw_sample < 0\n                || (avctx->bits_per_raw_sample > 8 && pixdesc->comp[0].depth <= 8)) {\n                av_log(avctx, AV_LOG_WARNING, \"Specified bit depth %d not possible with the specified pixel formats depth %d\\n\",\n                    avctx->bits_per_raw_sample, pixdesc->comp[0].depth);\n                avctx->bits_per_raw_sample = pixdesc->comp[0].depth;\n            }\n            if (avctx->width <= 0 || avctx->height <= 0) {\n                av_log(avctx, AV_LOG_ERROR, \"dimensions not set\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (   (avctx->codec_type == AVMEDIA_TYPE_VIDEO || avctx->codec_type == AVMEDIA_TYPE_AUDIO)\n            && avctx->bit_rate>0 && avctx->bit_rate<1000) {\n            av_log(avctx, AV_LOG_WARNING, \"Bitrate %\"PRId64\" is extremely low, maybe you mean %\"PRId64\"k\\n\", avctx->bit_rate, avctx->bit_rate);\n        }\n\n        if (!avctx->rc_initial_buffer_occupancy)\n            avctx->rc_initial_buffer_occupancy = avctx->rc_buffer_size * 3LL / 4;\n\n        if (avctx->ticks_per_frame && avctx->time_base.num &&\n            avctx->ticks_per_frame > INT_MAX / avctx->time_base.num) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"ticks_per_frame %d too large for the timebase %d/%d.\",\n                   avctx->ticks_per_frame,\n                   avctx->time_base.num,\n                   avctx->time_base.den);\n            goto free_and_end;\n        }\n\n        if (avctx->hw_frames_ctx) {\n            AVHWFramesContext *frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n            if (frames_ctx->format != avctx->pix_fmt) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Mismatching AVCodecContext.pix_fmt and AVHWFramesContext.format\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n            if (avctx->sw_pix_fmt != AV_PIX_FMT_NONE &&\n                avctx->sw_pix_fmt != frames_ctx->sw_format) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Mismatching AVCodecContext.sw_pix_fmt (%s) \"\n                       \"and AVHWFramesContext.sw_format (%s)\\n\",\n                       av_get_pix_fmt_name(avctx->sw_pix_fmt),\n                       av_get_pix_fmt_name(frames_ctx->sw_format));\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n            avctx->sw_pix_fmt = frames_ctx->sw_format;\n        }\n    }\n\n    avctx->pts_correction_num_faulty_pts =\n    avctx->pts_correction_num_faulty_dts = 0;\n    avctx->pts_correction_last_pts =\n    avctx->pts_correction_last_dts = INT64_MIN;\n\n    if (   !CONFIG_GRAY && avctx->flags & AV_CODEC_FLAG_GRAY\n        && avctx->codec_descriptor->type == AVMEDIA_TYPE_VIDEO)\n        av_log(avctx, AV_LOG_WARNING,\n               \"gray decoding requested but not enabled at configuration time\\n\");\n\n    if (   avctx->codec->init && (!(avctx->active_thread_type&FF_THREAD_FRAME)\n        || avctx->internal->frame_thread_encoder)) {\n        ret = avctx->codec->init(avctx);\n        if (ret < 0) {\n            goto free_and_end;\n        }\n        codec_init_ok = 1;\n    }\n\n    ret=0;\n\n    if (av_codec_is_decoder(avctx->codec)) {\n        if (!avctx->bit_rate)\n            avctx->bit_rate = get_bit_rate(avctx);\n        /* validate channel layout from the decoder */\n        if (avctx->channel_layout) {\n            int channels = av_get_channel_layout_nb_channels(avctx->channel_layout);\n            if (!avctx->channels)\n                avctx->channels = channels;\n            else if (channels != avctx->channels) {\n                char buf[512];\n                av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);\n                av_log(avctx, AV_LOG_WARNING,\n                       \"Channel layout '%s' with %d channels does not match specified number of channels %d: \"\n                       \"ignoring specified channel layout\\n\",\n                       buf, channels, avctx->channels);\n                avctx->channel_layout = 0;\n            }\n        }\n        if (avctx->channels && avctx->channels < 0 ||\n            avctx->channels > FF_SANE_NB_CHANNELS) {\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if (avctx->bits_per_coded_sample < 0) {\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if (avctx->sub_charenc) {\n            if (avctx->codec_type != AVMEDIA_TYPE_SUBTITLE) {\n                av_log(avctx, AV_LOG_ERROR, \"Character encoding is only \"\n                       \"supported with subtitles codecs\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            } else if (avctx->codec_descriptor->props & AV_CODEC_PROP_BITMAP_SUB) {\n                av_log(avctx, AV_LOG_WARNING, \"Codec '%s' is bitmap-based, \"\n                       \"subtitles character encoding will be ignored\\n\",\n                       avctx->codec_descriptor->name);\n                avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_DO_NOTHING;\n            } else {\n                /* input character encoding is set for a text based subtitle\n                 * codec at this point */\n                if (avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_AUTOMATIC)\n                    avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_PRE_DECODER;\n\n                if (avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_PRE_DECODER) {\n#if CONFIG_ICONV\n                    iconv_t cd = iconv_open(\"UTF-8\", avctx->sub_charenc);\n                    if (cd == (iconv_t)-1) {\n                        ret = AVERROR(errno);\n                        av_log(avctx, AV_LOG_ERROR, \"Unable to open iconv context \"\n                               \"with input character encoding \\\"%s\\\"\\n\", avctx->sub_charenc);\n                        goto free_and_end;\n                    }\n                    iconv_close(cd);\n#else\n                    av_log(avctx, AV_LOG_ERROR, \"Character encoding subtitles \"\n                           \"conversion needs a libavcodec built with iconv support \"\n                           \"for this codec\\n\");\n                    ret = AVERROR(ENOSYS);\n                    goto free_and_end;\n#endif\n                }\n            }\n        }\n\n#if FF_API_AVCTX_TIMEBASE\n        if (avctx->framerate.num > 0 && avctx->framerate.den > 0)\n            avctx->time_base = av_inv_q(av_mul_q(avctx->framerate, (AVRational){avctx->ticks_per_frame, 1}));\n#endif\n    }\n    if (codec->priv_data_size > 0 && avctx->priv_data && codec->priv_class) {\n        av_assert0(*(const AVClass **)avctx->priv_data == codec->priv_class);\n    }\n\nend:\n    ff_unlock_avcodec(codec);\n    if (options) {\n        av_dict_free(options);\n        *options = tmp;\n    }\n\n    return ret;\nfree_and_end:\n    if (avctx->codec &&\n        (codec_init_ok ||\n         (avctx->codec->caps_internal & FF_CODEC_CAP_INIT_CLEANUP)))\n        avctx->codec->close(avctx);\n\n    if (codec->priv_class && codec->priv_data_size)\n        av_opt_free(avctx->priv_data);\n    av_opt_free(avctx);\n\n#if FF_API_CODED_FRAME\nFF_DISABLE_DEPRECATION_WARNINGS\n    av_frame_free(&avctx->coded_frame);\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n    av_dict_free(&tmp);\n    av_freep(&avctx->priv_data);\n    if (avctx->internal) {\n        av_frame_free(&avctx->internal->to_free);\n        av_frame_free(&avctx->internal->compat_decode_frame);\n        av_frame_free(&avctx->internal->buffer_frame);\n        av_packet_free(&avctx->internal->buffer_pkt);\n        av_packet_free(&avctx->internal->last_pkt_props);\n\n        av_packet_free(&avctx->internal->ds.in_pkt);\n        ff_decode_bsfs_uninit(avctx);\n\n        av_freep(&avctx->internal->pool);\n    }\n    av_freep(&avctx->internal);\n    avctx->codec = NULL;\n    goto end;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149690,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int attribute_align_arg avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)\n{\n    int ret = 0;\n    int codec_init_ok = 0;\n    AVDictionary *tmp = NULL;\n    const AVPixFmtDescriptor *pixdesc;\n\n    if (avcodec_is_open(avctx))\n        return 0;\n\n    if ((!codec && !avctx->codec)) {\n        av_log(avctx, AV_LOG_ERROR, \"No codec provided to avcodec_open2()\\n\");\n        return AVERROR(EINVAL);\n    }\n    if ((codec && avctx->codec && codec != avctx->codec)) {\n        av_log(avctx, AV_LOG_ERROR, \"This AVCodecContext was allocated for %s, \"\n                                    \"but %s passed to avcodec_open2()\\n\", avctx->codec->name, codec->name);\n        return AVERROR(EINVAL);\n    }\n    if (!codec)\n        codec = avctx->codec;\n\n    if (avctx->extradata_size < 0 || avctx->extradata_size >= FF_MAX_EXTRADATA_SIZE)\n        return AVERROR(EINVAL);\n\n    if (options)\n        av_dict_copy(&tmp, *options, 0);\n\n    ff_lock_avcodec(avctx, codec);\n\n    avctx->internal = av_mallocz(sizeof(*avctx->internal));\n    if (!avctx->internal) {\n        ret = AVERROR(ENOMEM);\n        goto end;\n    }\n\n    avctx->internal->pool = av_mallocz(sizeof(*avctx->internal->pool));\n    if (!avctx->internal->pool) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->to_free = av_frame_alloc();\n    if (!avctx->internal->to_free) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->compat_decode_frame = av_frame_alloc();\n    if (!avctx->internal->compat_decode_frame) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->buffer_frame = av_frame_alloc();\n    if (!avctx->internal->buffer_frame) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->buffer_pkt = av_packet_alloc();\n    if (!avctx->internal->buffer_pkt) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->ds.in_pkt = av_packet_alloc();\n    if (!avctx->internal->ds.in_pkt) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->last_pkt_props = av_packet_alloc();\n    if (!avctx->internal->last_pkt_props) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->skip_samples_multiplier = 1;\n\n    if (codec->priv_data_size > 0) {\n        if (!avctx->priv_data) {\n            avctx->priv_data = av_mallocz(codec->priv_data_size);\n            if (!avctx->priv_data) {\n                ret = AVERROR(ENOMEM);\n                goto end;\n            }\n            if (codec->priv_class) {\n                *(const AVClass **)avctx->priv_data = codec->priv_class;\n                av_opt_set_defaults(avctx->priv_data);\n            }\n        }\n        if (codec->priv_class && (ret = av_opt_set_dict(avctx->priv_data, &tmp)) < 0)\n            goto free_and_end;\n    } else {\n        avctx->priv_data = NULL;\n    }\n    if ((ret = av_opt_set_dict(avctx, &tmp)) < 0)\n        goto free_and_end;\n\n    if (avctx->codec_whitelist && av_match_list(codec->name, avctx->codec_whitelist, ',') <= 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Codec (%s) not on whitelist \\'%s\\'\\n\", codec->name, avctx->codec_whitelist);\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n\n    // only call ff_set_dimensions() for non H.264/VP6F/DXV codecs so as not to overwrite previously setup dimensions\n    if (!(avctx->coded_width && avctx->coded_height && avctx->width && avctx->height &&\n          (avctx->codec_id == AV_CODEC_ID_H264 || avctx->codec_id == AV_CODEC_ID_VP6F || avctx->codec_id == AV_CODEC_ID_DXV))) {\n    if (avctx->coded_width && avctx->coded_height)\n        ret = ff_set_dimensions(avctx, avctx->coded_width, avctx->coded_height);\n    else if (avctx->width && avctx->height)\n        ret = ff_set_dimensions(avctx, avctx->width, avctx->height);\n    if (ret < 0)\n        goto free_and_end;\n    }\n\n    if ((avctx->coded_width || avctx->coded_height || avctx->width || avctx->height)\n        && (  av_image_check_size2(avctx->coded_width, avctx->coded_height, avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx) < 0\n           || av_image_check_size2(avctx->width,       avctx->height,       avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx) < 0)) {\n        av_log(avctx, AV_LOG_WARNING, \"Ignoring invalid width/height values\\n\");\n        ff_set_dimensions(avctx, 0, 0);\n    }\n\n    if (avctx->width > 0 && avctx->height > 0) {\n        if (av_image_check_sar(avctx->width, avctx->height,\n                               avctx->sample_aspect_ratio) < 0) {\n            av_log(avctx, AV_LOG_WARNING, \"ignoring invalid SAR: %u/%u\\n\",\n                   avctx->sample_aspect_ratio.num,\n                   avctx->sample_aspect_ratio.den);\n            avctx->sample_aspect_ratio = (AVRational){ 0, 1 };\n        }\n    }\n\n    /* if the decoder init function was already called previously,\n     * free the already allocated subtitle_header before overwriting it */\n    if (av_codec_is_decoder(codec))\n        av_freep(&avctx->subtitle_header);\n\n    if (avctx->channels > FF_SANE_NB_CHANNELS) {\n        av_log(avctx, AV_LOG_ERROR, \"Too many channels: %d\\n\", avctx->channels);\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n\n    avctx->codec = codec;\n    if ((avctx->codec_type == AVMEDIA_TYPE_UNKNOWN || avctx->codec_type == codec->type) &&\n        avctx->codec_id == AV_CODEC_ID_NONE) {\n        avctx->codec_type = codec->type;\n        avctx->codec_id   = codec->id;\n    }\n    if (avctx->codec_id != codec->id || (avctx->codec_type != codec->type\n                                         && avctx->codec_type != AVMEDIA_TYPE_ATTACHMENT)) {\n        av_log(avctx, AV_LOG_ERROR, \"Codec type or id mismatches\\n\");\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n    avctx->frame_number = 0;\n    avctx->codec_descriptor = avcodec_descriptor_get(avctx->codec_id);\n\n    if ((avctx->codec->capabilities & AV_CODEC_CAP_EXPERIMENTAL) &&\n        avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n        const char *codec_string = av_codec_is_encoder(codec) ? \"encoder\" : \"decoder\";\n        AVCodec *codec2;\n        av_log(avctx, AV_LOG_ERROR,\n               \"The %s '%s' is experimental but experimental codecs are not enabled, \"\n               \"add '-strict %d' if you want to use it.\\n\",\n               codec_string, codec->name, FF_COMPLIANCE_EXPERIMENTAL);\n        codec2 = av_codec_is_encoder(codec) ? avcodec_find_encoder(codec->id) : avcodec_find_decoder(codec->id);\n        if (!(codec2->capabilities & AV_CODEC_CAP_EXPERIMENTAL))\n            av_log(avctx, AV_LOG_ERROR, \"Alternatively use the non experimental %s '%s'.\\n\",\n                codec_string, codec2->name);\n        ret = AVERROR_EXPERIMENTAL;\n        goto free_and_end;\n    }\n\n    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO &&\n        (!avctx->time_base.num || !avctx->time_base.den)) {\n        avctx->time_base.num = 1;\n        avctx->time_base.den = avctx->sample_rate;\n    }\n\n    if (!HAVE_THREADS)\n        av_log(avctx, AV_LOG_WARNING, \"Warning: not compiled with thread support, using thread emulation\\n\");\n\n    if (CONFIG_FRAME_THREAD_ENCODER && av_codec_is_encoder(avctx->codec)) {\n        ff_unlock_avcodec(codec); //we will instantiate a few encoders thus kick the counter to prevent false detection of a problem\n        ret = ff_frame_thread_encoder_init(avctx, options ? *options : NULL);\n        ff_lock_avcodec(avctx, codec);\n        if (ret < 0)\n            goto free_and_end;\n    }\n\n    if (av_codec_is_decoder(avctx->codec)) {\n        ret = ff_decode_bsfs_init(avctx);\n        if (ret < 0)\n            goto free_and_end;\n    }\n\n    if (HAVE_THREADS\n        && !(avctx->internal->frame_thread_encoder && (avctx->active_thread_type&FF_THREAD_FRAME))) {\n        ret = ff_thread_init(avctx);\n        if (ret < 0) {\n            goto free_and_end;\n        }\n    }\n    if (!HAVE_THREADS && !(codec->capabilities & AV_CODEC_CAP_AUTO_THREADS))\n        avctx->thread_count = 1;\n\n    if (avctx->codec->max_lowres < avctx->lowres || avctx->lowres < 0) {\n        av_log(avctx, AV_LOG_WARNING, \"The maximum value for lowres supported by the decoder is %d\\n\",\n               avctx->codec->max_lowres);\n        avctx->lowres = avctx->codec->max_lowres;\n    }\n\n    if (av_codec_is_encoder(avctx->codec)) {\n        int i;\n#if FF_API_CODED_FRAME\nFF_DISABLE_DEPRECATION_WARNINGS\n        avctx->coded_frame = av_frame_alloc();\n        if (!avctx->coded_frame) {\n            ret = AVERROR(ENOMEM);\n            goto free_and_end;\n        }\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n        if (avctx->time_base.num <= 0 || avctx->time_base.den <= 0) {\n            av_log(avctx, AV_LOG_ERROR, \"The encoder timebase is not set.\\n\");\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n\n        if (avctx->codec->sample_fmts) {\n            for (i = 0; avctx->codec->sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {\n                if (avctx->sample_fmt == avctx->codec->sample_fmts[i])\n                    break;\n                if (avctx->channels == 1 &&\n                    av_get_planar_sample_fmt(avctx->sample_fmt) ==\n                    av_get_planar_sample_fmt(avctx->codec->sample_fmts[i])) {\n                    avctx->sample_fmt = avctx->codec->sample_fmts[i];\n                    break;\n                }\n            }\n            if (avctx->codec->sample_fmts[i] == AV_SAMPLE_FMT_NONE) {\n                char buf[128];\n                snprintf(buf, sizeof(buf), \"%d\", avctx->sample_fmt);\n                av_log(avctx, AV_LOG_ERROR, \"Specified sample format %s is invalid or not supported\\n\",\n                       (char *)av_x_if_null(av_get_sample_fmt_name(avctx->sample_fmt), buf));\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (avctx->codec->pix_fmts) {\n            for (i = 0; avctx->codec->pix_fmts[i] != AV_PIX_FMT_NONE; i++)\n                if (avctx->pix_fmt == avctx->codec->pix_fmts[i])\n                    break;\n            if (avctx->codec->pix_fmts[i] == AV_PIX_FMT_NONE\n                && !((avctx->codec_id == AV_CODEC_ID_MJPEG || avctx->codec_id == AV_CODEC_ID_LJPEG)\n                     && avctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL)) {\n                char buf[128];\n                snprintf(buf, sizeof(buf), \"%d\", avctx->pix_fmt);\n                av_log(avctx, AV_LOG_ERROR, \"Specified pixel format %s is invalid or not supported\\n\",\n                       (char *)av_x_if_null(av_get_pix_fmt_name(avctx->pix_fmt), buf));\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n            if (avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ420P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ411P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ422P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ440P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ444P)\n                avctx->color_range = AVCOL_RANGE_JPEG;\n        }\n        if (avctx->codec->supported_samplerates) {\n            for (i = 0; avctx->codec->supported_samplerates[i] != 0; i++)\n                if (avctx->sample_rate == avctx->codec->supported_samplerates[i])\n                    break;\n            if (avctx->codec->supported_samplerates[i] == 0) {\n                av_log(avctx, AV_LOG_ERROR, \"Specified sample rate %d is not supported\\n\",\n                       avctx->sample_rate);\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (avctx->sample_rate < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Specified sample rate %d is not supported\\n\",\n                    avctx->sample_rate);\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if (avctx->codec->channel_layouts) {\n            if (!avctx->channel_layout) {\n                av_log(avctx, AV_LOG_WARNING, \"Channel layout not specified\\n\");\n            } else {\n                for (i = 0; avctx->codec->channel_layouts[i] != 0; i++)\n                    if (avctx->channel_layout == avctx->codec->channel_layouts[i])\n                        break;\n                if (avctx->codec->channel_layouts[i] == 0) {\n                    char buf[512];\n                    av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);\n                    av_log(avctx, AV_LOG_ERROR, \"Specified channel layout '%s' is not supported\\n\", buf);\n                    ret = AVERROR(EINVAL);\n                    goto free_and_end;\n                }\n            }\n        }\n        if (avctx->channel_layout && avctx->channels) {\n            int channels = av_get_channel_layout_nb_channels(avctx->channel_layout);\n            if (channels != avctx->channels) {\n                char buf[512];\n                av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Channel layout '%s' with %d channels does not match number of specified channels %d\\n\",\n                       buf, channels, avctx->channels);\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        } else if (avctx->channel_layout) {\n            avctx->channels = av_get_channel_layout_nb_channels(avctx->channel_layout);\n        }\n        if (avctx->channels < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Specified number of channels %d is not supported\\n\",\n                    avctx->channels);\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if(avctx->codec_type == AVMEDIA_TYPE_VIDEO) {\n            pixdesc = av_pix_fmt_desc_get(avctx->pix_fmt);\n            if (    avctx->bits_per_raw_sample < 0\n                || (avctx->bits_per_raw_sample > 8 && pixdesc->comp[0].depth <= 8)) {\n                av_log(avctx, AV_LOG_WARNING, \"Specified bit depth %d not possible with the specified pixel formats depth %d\\n\",\n                    avctx->bits_per_raw_sample, pixdesc->comp[0].depth);\n                avctx->bits_per_raw_sample = pixdesc->comp[0].depth;\n            }\n            if (avctx->width <= 0 || avctx->height <= 0) {\n                av_log(avctx, AV_LOG_ERROR, \"dimensions not set\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (   (avctx->codec_type == AVMEDIA_TYPE_VIDEO || avctx->codec_type == AVMEDIA_TYPE_AUDIO)\n            && avctx->bit_rate>0 && avctx->bit_rate<1000) {\n            av_log(avctx, AV_LOG_WARNING, \"Bitrate %\"PRId64\" is extremely low, maybe you mean %\"PRId64\"k\\n\", avctx->bit_rate, avctx->bit_rate);\n        }\n\n        if (!avctx->rc_initial_buffer_occupancy)\n            avctx->rc_initial_buffer_occupancy = avctx->rc_buffer_size * 3LL / 4;\n\n        if (avctx->ticks_per_frame && avctx->time_base.num &&\n            avctx->ticks_per_frame > INT_MAX / avctx->time_base.num) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"ticks_per_frame %d too large for the timebase %d/%d.\",\n                   avctx->ticks_per_frame,\n                   avctx->time_base.num,\n                   avctx->time_base.den);\n            goto free_and_end;\n        }\n\n        if (avctx->hw_frames_ctx) {\n            AVHWFramesContext *frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n            if (frames_ctx->format != avctx->pix_fmt) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Mismatching AVCodecContext.pix_fmt and AVHWFramesContext.format\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n            if (avctx->sw_pix_fmt != AV_PIX_FMT_NONE &&\n                avctx->sw_pix_fmt != frames_ctx->sw_format) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Mismatching AVCodecContext.sw_pix_fmt (%s) \"\n                       \"and AVHWFramesContext.sw_format (%s)\\n\",\n                       av_get_pix_fmt_name(avctx->sw_pix_fmt),\n                       av_get_pix_fmt_name(frames_ctx->sw_format));\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n            avctx->sw_pix_fmt = frames_ctx->sw_format;\n        }\n    }\n\n    avctx->pts_correction_num_faulty_pts =\n    avctx->pts_correction_num_faulty_dts = 0;\n    avctx->pts_correction_last_pts =\n    avctx->pts_correction_last_dts = INT64_MIN;\n\n    if (   !CONFIG_GRAY && avctx->flags & AV_CODEC_FLAG_GRAY\n        && avctx->codec_descriptor->type == AVMEDIA_TYPE_VIDEO)\n        av_log(avctx, AV_LOG_WARNING,\n               \"gray decoding requested but not enabled at configuration time\\n\");\n\n    if (   avctx->codec->init && (!(avctx->active_thread_type&FF_THREAD_FRAME)\n        || avctx->internal->frame_thread_encoder)) {\n        ret = avctx->codec->init(avctx);\n        if (ret < 0) {\n            goto free_and_end;\n        }\n        codec_init_ok = 1;\n    }\n\n    ret=0;\n\n    if (av_codec_is_decoder(avctx->codec)) {\n        if (!avctx->bit_rate)\n            avctx->bit_rate = get_bit_rate(avctx);\n        /* validate channel layout from the decoder */\n        if (avctx->channel_layout) {\n            int channels = av_get_channel_layout_nb_channels(avctx->channel_layout);\n            if (!avctx->channels)\n                avctx->channels = channels;\n            else if (channels != avctx->channels) {\n                char buf[512];\n                av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);\n                av_log(avctx, AV_LOG_WARNING,\n                       \"Channel layout '%s' with %d channels does not match specified number of channels %d: \"\n                       \"ignoring specified channel layout\\n\",\n                       buf, channels, avctx->channels);\n                avctx->channel_layout = 0;\n            }\n        }\n        if (avctx->channels && avctx->channels < 0 ||\n            avctx->channels > FF_SANE_NB_CHANNELS) {\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if (avctx->bits_per_coded_sample < 0) {\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if (avctx->sub_charenc) {\n            if (avctx->codec_type != AVMEDIA_TYPE_SUBTITLE) {\n                av_log(avctx, AV_LOG_ERROR, \"Character encoding is only \"\n                       \"supported with subtitles codecs\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            } else if (avctx->codec_descriptor->props & AV_CODEC_PROP_BITMAP_SUB) {\n                av_log(avctx, AV_LOG_WARNING, \"Codec '%s' is bitmap-based, \"\n                       \"subtitles character encoding will be ignored\\n\",\n                       avctx->codec_descriptor->name);\n                avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_DO_NOTHING;\n            } else {\n                /* input character encoding is set for a text based subtitle\n                 * codec at this point */\n                if (avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_AUTOMATIC)\n                    avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_PRE_DECODER;\n\n                if (avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_PRE_DECODER) {\n#if CONFIG_ICONV\n                    iconv_t cd = iconv_open(\"UTF-8\", avctx->sub_charenc);\n                    if (cd == (iconv_t)-1) {\n                        ret = AVERROR(errno);\n                        av_log(avctx, AV_LOG_ERROR, \"Unable to open iconv context \"\n                               \"with input character encoding \\\"%s\\\"\\n\", avctx->sub_charenc);\n                        goto free_and_end;\n                    }\n                    iconv_close(cd);\n#else\n                    av_log(avctx, AV_LOG_ERROR, \"Character encoding subtitles \"\n                           \"conversion needs a libavcodec built with iconv support \"\n                           \"for this codec\\n\");\n                    ret = AVERROR(ENOSYS);\n                    goto free_and_end;\n#endif\n                }\n            }\n        }\n\n#if FF_API_AVCTX_TIMEBASE\n        if (avctx->framerate.num > 0 && avctx->framerate.den > 0)\n            avctx->time_base = av_inv_q(av_mul_q(avctx->framerate, (AVRational){avctx->ticks_per_frame, 1}));\n#endif\n    }\n    if (codec->priv_data_size > 0 && avctx->priv_data && codec->priv_class) {\n        av_assert0(*(const AVClass **)avctx->priv_data == codec->priv_class);\n    }\n\nend:\n    ff_unlock_avcodec(codec);\n    if (options) {\n        av_dict_free(options);\n        *options = tmp;\n    }\n\n    return ret;\nfree_and_end:\n    if (avctx->codec && avctx->codec->close &&\n        (codec_init_ok ||\n         (avctx->codec->caps_internal & FF_CODEC_CAP_INIT_CLEANUP)))\n        avctx->codec->close(avctx);\n\n    if (codec->priv_class && codec->priv_data_size)\n        av_opt_free(avctx->priv_data);\n    av_opt_free(avctx);\n\n#if FF_API_CODED_FRAME\nFF_DISABLE_DEPRECATION_WARNINGS\n    av_frame_free(&avctx->coded_frame);\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n    av_dict_free(&tmp);\n    av_freep(&avctx->priv_data);\n    if (avctx->internal) {\n        av_frame_free(&avctx->internal->to_free);\n        av_frame_free(&avctx->internal->compat_decode_frame);\n        av_frame_free(&avctx->internal->buffer_frame);\n        av_packet_free(&avctx->internal->buffer_pkt);\n        av_packet_free(&avctx->internal->last_pkt_props);\n\n        av_packet_free(&avctx->internal->ds.in_pkt);\n        ff_decode_bsfs_uninit(avctx);\n\n        av_freep(&avctx->internal->pool);\n    }\n    av_freep(&avctx->internal);\n    avctx->codec = NULL;\n    goto end;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149691,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tchar *end = NULL;\n\tElf_(Shdr) *link_shdr = NULL;\n\tut8 dfs[sizeof (Elf_(Verdef))] = {0};\n\tSdb *sdb;\n\tint cnt, i;\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\treturn false;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif (shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {\n\t\treturn false;\n\t}\n\tElf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));\n\tif (!defs) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!defs) {\n\t\tbprintf (\"Warning: Cannot allocate memory (Check Elf_(Verdef))\\n\");\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tend = (char *)defs + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tfor (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {\n\t\tSdb *sdb_verdef = sdb_new0 ();\n\t\tchar *vstart = ((char*)defs) + i;\n\t\tchar key[32] = {0};\n\t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;\n\t\tElf_(Verdaux) aux = {0};\n\t\tint j = 0;\n\t\tint isum = 0;\n\n\t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));\n\t\tverdef->vd_version = READ16 (dfs, j)\n\t\tverdef->vd_flags = READ16 (dfs, j)\n\t\tverdef->vd_ndx = READ16 (dfs, j)\n\t\tverdef->vd_cnt = READ16 (dfs, j)\n\t\tverdef->vd_hash = READ32 (dfs, j)\n\t\tverdef->vd_aux = READ32 (dfs, j)\n\t\tverdef->vd_next = READ32 (dfs, j)\n\t\tint vdaux = verdef->vd_aux;\n\t\tif (vdaux < 1) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tvstart += vdaux;\n\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tj = 0;\n\t\taux.vda_name = READ32 (vstart, j)\n\t\taux.vda_next = READ32 (vstart, j)\n\n\t\tisum = i + verdef->vd_aux;\n\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsdb_num_set (sdb_verdef, \"idx\", i, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_version\", verdef->vd_version, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_ndx\", verdef->vd_ndx, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_cnt\", verdef->vd_cnt, 0);\n\t\tsdb_set (sdb_verdef, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\tsdb_set (sdb_verdef, \"flags\", get_ver_flags (verdef->vd_flags), 0);\n\n\t\tfor (j = 1; j < verdef->vd_cnt; ++j) {\n\t\t\tint k;\n\t\t\tSdb *sdb_parent = sdb_new0 ();\n\t\t\tisum += aux.vda_next;\n\t\t\tvstart += aux.vda_next;\n\t\t\tif (vstart > end || vstart + sizeof(Elf_(Verdaux)) > end) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tk = 0;\n\t\t\taux.vda_name = READ32 (vstart, k)\n\t\t\taux.vda_next = READ32 (vstart, k)\n\t\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_parent, \"idx\", isum, 0);\n\t\t\tsdb_num_set (sdb_parent, \"parent\", j, 0);\n\t\t\tsdb_set (sdb_parent, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\t\tsnprintf (key, sizeof (key), \"parent%d\", j - 1);\n\t\t\tsdb_ns_set (sdb_verdef, key, sdb_parent);\n\t\t}\n\n\t\tsnprintf (key, sizeof (key), \"verdef%d\", cnt);\n\t\tsdb_ns_set (sdb, key, sdb_verdef);\n\t\tif (!verdef->vd_next) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif ((st32)verdef->vd_next < 1) {\n\t\t\teprintf (\"Warning: Invalid vd_next in the ELF version\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ti += verdef->vd_next;\n\t}\n\tfree (defs);\n\treturn sdb;\nout_error:\n\tfree (defs);\n\tsdb_free (sdb);\n\treturn NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149694,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tchar *end = NULL;\n\tElf_(Shdr) *link_shdr = NULL;\n\tut8 dfs[sizeof (Elf_(Verdef))] = {0};\n\tSdb *sdb;\n\tint cnt, i;\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\treturn false;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif (shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {\n\t\treturn false;\n\t}\n\tElf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));\n\tif (!defs) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!defs) {\n\t\tbprintf (\"Warning: Cannot allocate memory (Check Elf_(Verdef))\\n\");\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tend = (char *)defs + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tfor (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && (end - (char *)defs > i); ++cnt) {\n\t\tSdb *sdb_verdef = sdb_new0 ();\n\t\tchar *vstart = ((char*)defs) + i;\n\t\tchar key[32] = {0};\n\t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;\n\t\tElf_(Verdaux) aux = {0};\n\t\tint j = 0;\n\t\tint isum = 0;\n\n\t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));\n\t\tverdef->vd_version = READ16 (dfs, j)\n\t\tverdef->vd_flags = READ16 (dfs, j)\n\t\tverdef->vd_ndx = READ16 (dfs, j)\n\t\tverdef->vd_cnt = READ16 (dfs, j)\n\t\tverdef->vd_hash = READ32 (dfs, j)\n\t\tverdef->vd_aux = READ32 (dfs, j)\n\t\tverdef->vd_next = READ32 (dfs, j)\n\t\tint vdaux = verdef->vd_aux;\n\t\tif (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tvstart += vdaux;\n\t\tif (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tj = 0;\n\t\taux.vda_name = READ32 (vstart, j)\n\t\taux.vda_next = READ32 (vstart, j)\n\n\t\tisum = i + verdef->vd_aux;\n\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsdb_num_set (sdb_verdef, \"idx\", i, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_version\", verdef->vd_version, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_ndx\", verdef->vd_ndx, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_cnt\", verdef->vd_cnt, 0);\n\t\tsdb_set (sdb_verdef, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\tsdb_set (sdb_verdef, \"flags\", get_ver_flags (verdef->vd_flags), 0);\n\n\t\tfor (j = 1; j < verdef->vd_cnt; ++j) {\n\t\t\tint k;\n\t\t\tSdb *sdb_parent = sdb_new0 ();\n\t\t\tisum += aux.vda_next;\n\t\t\tvstart += aux.vda_next;\n\t\t\tif (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tk = 0;\n\t\t\taux.vda_name = READ32 (vstart, k)\n\t\t\taux.vda_next = READ32 (vstart, k)\n\t\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_parent, \"idx\", isum, 0);\n\t\t\tsdb_num_set (sdb_parent, \"parent\", j, 0);\n\t\t\tsdb_set (sdb_parent, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\t\tsnprintf (key, sizeof (key), \"parent%d\", j - 1);\n\t\t\tsdb_ns_set (sdb_verdef, key, sdb_parent);\n\t\t}\n\n\t\tsnprintf (key, sizeof (key), \"verdef%d\", cnt);\n\t\tsdb_ns_set (sdb, key, sdb_verdef);\n\t\tif (!verdef->vd_next) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif ((st32)verdef->vd_next < 1) {\n\t\t\teprintf (\"Warning: Invalid vd_next in the ELF version\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ti += verdef->vd_next;\n\t}\n\tfree (defs);\n\treturn sdb;\nout_error:\n\tfree (defs);\n\tsdb_free (sdb);\n\treturn NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149695,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "upnp_redirect(const char * rhost, unsigned short eport,\n              const char * iaddr, unsigned short iport,\n              const char * protocol, const char * desc,\n              unsigned int leaseduration)\n{\n\tint proto, r;\n\tchar iaddr_old[32];\n\tchar rhost_old[32];\n\tunsigned short iport_old;\n\tstruct in_addr address;\n\tunsigned int timestamp;\n\n\tproto = proto_atoi(protocol);\n\tif(inet_aton(iaddr, &address) <= 0) {\n\t\tsyslog(LOG_ERR, \"inet_aton(%s) FAILED\", iaddr);\n\t\treturn -1;\n\t}\n\n\tif(!check_upnp_rule_against_permissions(upnppermlist, num_upnpperm,\n\t                                        eport, address, iport)) {\n\t\tsyslog(LOG_INFO, \"redirection permission check failed for \"\n\t\t                 \"%hu->%s:%hu %s\", eport, iaddr, iport, protocol);\n\t\treturn -3;\n\t}\n\t/* IGDv1 (WANIPConnection:1 Service Template Version 1.01 / Nov 12, 2001)\n\t * - 2.2.20.PortMappingDescription :\n\t *  Overwriting Previous / Existing Port Mappings:\n\t * If the RemoteHost, ExternalPort, PortMappingProtocol and InternalClient\n\t * are exactly the same as an existing mapping, the existing mapping values\n\t * for InternalPort, PortMappingDescription, PortMappingEnabled and\n\t * PortMappingLeaseDuration are overwritten.\n\t *  Rejecting a New Port Mapping:\n\t * In cases where the RemoteHost, ExternalPort and PortMappingProtocol\n\t * are the same as an existing mapping, but the InternalClient is\n\t * different, the action is rejected with an appropriate error.\n\t *  Add or Reject New Port Mapping behavior based on vendor implementation:\n\t * In cases where the ExternalPort, PortMappingProtocol and InternalClient\n\t * are the same, but RemoteHost is different, the vendor can choose to\n\t * support both mappings simultaneously, or reject the second mapping\n\t * with an appropriate error.\n\t *\n\t * - 2.4.16.AddPortMapping\n\t * This action creates a new port mapping or overwrites an existing\n\t * mapping with the same internal client. If the ExternalPort and\n\t * PortMappingProtocol pair is already mapped to another internal client,\n\t * an error is returned.\n\t *\n\t * IGDv2 (WANIPConnection:2 Service Standardized DCP (SDCP) Sep 10, 2010)\n\t * Protocol ExternalPort RemoteHost InternalClient Result\n\t *     =         =           \u2260           \u2260         Failure\n\t *     =         =           \u2260           =         Failure or success\n\t *                                                 (vendor specific)\n\t *     =         =           =           \u2260         Failure\n\t *     =         =           =           =         Success (overwrite)\n\t */\n\trhost_old[0] = '\\0';\n\tr = get_redirect_rule(ext_if_name, eport, proto,\n\t                      iaddr_old, sizeof(iaddr_old), &iport_old, 0, 0,\n\t                      rhost_old, sizeof(rhost_old),\n\t                      &timestamp, 0, 0);\n\tif(r == 0) {\n\t\tif(strcmp(iaddr, iaddr_old)==0 &&\n\t\t   ((rhost == NULL && rhost_old[0]=='\\0') ||\n\t\t    (rhost && (strcmp(rhost, \"*\") == 0) && rhost_old[0]=='\\0') ||\n\t\t    (rhost && (strcmp(rhost, rhost_old) == 0)))) {\n\t\t\tsyslog(LOG_INFO, \"updating existing port mapping %hu %s (rhost '%s') => %s:%hu\",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\ttimestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;\n\t\t\tif(iport != iport_old) {\n\t\t\t\tr = update_portmapping(ext_if_name, eport, proto, iport, desc, timestamp);\n\t\t\t} else {\n\t\t\t\tr = update_portmapping_desc_timestamp(ext_if_name, eport, proto, desc, timestamp);\n\t\t\t}\n#ifdef ENABLE_LEASEFILE\n\t\t\tif(r == 0) {\n\t\t\t\tlease_file_remove(eport, proto);\n\t\t\t\tlease_file_add(eport, iaddr, iport, proto, desc, timestamp);\n\t\t\t}\n#endif /* ENABLE_LEASEFILE */\n\t\t\treturn r;\n\t\t} else {\n\t\t\tsyslog(LOG_INFO, \"port %hu %s (rhost '%s') already redirected to %s:%hu\",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\treturn -2;\n\t\t}\n#ifdef CHECK_PORTINUSE\n\t} else if (port_in_use(ext_if_name, eport, proto, iaddr, iport) > 0) {\n\t\tsyslog(LOG_INFO, \"port %hu protocol %s already in use\",\n\t\t       eport, protocol);\n\t\treturn -4;\n#endif /* CHECK_PORTINUSE */\n\t} else {\n\t\ttimestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;\n\t\tsyslog(LOG_INFO, \"redirecting port %hu to %s:%hu protocol %s for: %s\",\n\t\t\teport, iaddr, iport, protocol, desc);\n\t\treturn upnp_redirect_internal(rhost, eport, iaddr, iport, proto,\n\t\t                              desc, timestamp);\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149696,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "upnp_redirect(const char * rhost, unsigned short eport,\n              const char * iaddr, unsigned short iport,\n              const char * protocol, const char * desc,\n              unsigned int leaseduration)\n{\n\tint proto, r;\n\tchar iaddr_old[32];\n\tchar rhost_old[32];\n\tunsigned short iport_old;\n\tstruct in_addr address;\n\tunsigned int timestamp;\n\n\tproto = proto_atoi(protocol);\n\tif(inet_aton(iaddr, &address) <= 0) {\n\t\tsyslog(LOG_ERR, \"inet_aton(%s) FAILED\", iaddr);\n\t\treturn -1;\n\t}\n\n\tif(!check_upnp_rule_against_permissions(upnppermlist, num_upnpperm,\n\t                                        eport, address, iport)) {\n\t\tsyslog(LOG_INFO, \"redirection permission check failed for \"\n\t\t                 \"%hu->%s:%hu %s\", eport, iaddr, iport, protocol);\n\t\treturn -3;\n\t}\n\n\tif (desc == NULL)\n\t\tdesc = \"\";\t/* assume empty description */\n\n\t/* IGDv1 (WANIPConnection:1 Service Template Version 1.01 / Nov 12, 2001)\n\t * - 2.2.20.PortMappingDescription :\n\t *  Overwriting Previous / Existing Port Mappings:\n\t * If the RemoteHost, ExternalPort, PortMappingProtocol and InternalClient\n\t * are exactly the same as an existing mapping, the existing mapping values\n\t * for InternalPort, PortMappingDescription, PortMappingEnabled and\n\t * PortMappingLeaseDuration are overwritten.\n\t *  Rejecting a New Port Mapping:\n\t * In cases where the RemoteHost, ExternalPort and PortMappingProtocol\n\t * are the same as an existing mapping, but the InternalClient is\n\t * different, the action is rejected with an appropriate error.\n\t *  Add or Reject New Port Mapping behavior based on vendor implementation:\n\t * In cases where the ExternalPort, PortMappingProtocol and InternalClient\n\t * are the same, but RemoteHost is different, the vendor can choose to\n\t * support both mappings simultaneously, or reject the second mapping\n\t * with an appropriate error.\n\t *\n\t * - 2.4.16.AddPortMapping\n\t * This action creates a new port mapping or overwrites an existing\n\t * mapping with the same internal client. If the ExternalPort and\n\t * PortMappingProtocol pair is already mapped to another internal client,\n\t * an error is returned.\n\t *\n\t * IGDv2 (WANIPConnection:2 Service Standardized DCP (SDCP) Sep 10, 2010)\n\t * Protocol ExternalPort RemoteHost InternalClient Result\n\t *     =         =           \u2260           \u2260         Failure\n\t *     =         =           \u2260           =         Failure or success\n\t *                                                 (vendor specific)\n\t *     =         =           =           \u2260         Failure\n\t *     =         =           =           =         Success (overwrite)\n\t */\n\trhost_old[0] = '\\0';\n\tr = get_redirect_rule(ext_if_name, eport, proto,\n\t                      iaddr_old, sizeof(iaddr_old), &iport_old, 0, 0,\n\t                      rhost_old, sizeof(rhost_old),\n\t                      &timestamp, 0, 0);\n\tif(r == 0) {\n\t\tif(strcmp(iaddr, iaddr_old)==0 &&\n\t\t   ((rhost == NULL && rhost_old[0]=='\\0') ||\n\t\t    (rhost && (strcmp(rhost, \"*\") == 0) && rhost_old[0]=='\\0') ||\n\t\t    (rhost && (strcmp(rhost, rhost_old) == 0)))) {\n\t\t\tsyslog(LOG_INFO, \"updating existing port mapping %hu %s (rhost '%s') => %s:%hu\",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\ttimestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;\n\t\t\tif(iport != iport_old) {\n\t\t\t\tr = update_portmapping(ext_if_name, eport, proto, iport, desc, timestamp);\n\t\t\t} else {\n\t\t\t\tr = update_portmapping_desc_timestamp(ext_if_name, eport, proto, desc, timestamp);\n\t\t\t}\n#ifdef ENABLE_LEASEFILE\n\t\t\tif(r == 0) {\n\t\t\t\tlease_file_remove(eport, proto);\n\t\t\t\tlease_file_add(eport, iaddr, iport, proto, desc, timestamp);\n\t\t\t}\n#endif /* ENABLE_LEASEFILE */\n\t\t\treturn r;\n\t\t} else {\n\t\t\tsyslog(LOG_INFO, \"port %hu %s (rhost '%s') already redirected to %s:%hu\",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\treturn -2;\n\t\t}\n#ifdef CHECK_PORTINUSE\n\t} else if (port_in_use(ext_if_name, eport, proto, iaddr, iport) > 0) {\n\t\tsyslog(LOG_INFO, \"port %hu protocol %s already in use\",\n\t\t       eport, protocol);\n\t\treturn -4;\n#endif /* CHECK_PORTINUSE */\n\t} else {\n\t\ttimestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;\n\t\tsyslog(LOG_INFO, \"redirecting port %hu to %s:%hu protocol %s for: %s\",\n\t\t\teport, iaddr, iport, protocol, desc);\n\t\treturn upnp_redirect_internal(rhost, eport, iaddr, iport, proto,\n\t\t                              desc, timestamp);\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149697,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,\n  const ImageInfo *IMimage_info,Image *IMimage,ExceptionInfo *exception)\n{\n  char\n    im_vers[32],\n    libpng_runv[32],\n    libpng_vers[32],\n    zlib_runv[32],\n    zlib_vers[32];\n\n  Image\n    *image;\n\n  ImageInfo\n    *image_info;\n\n  char\n    s[2];\n\n  const char\n    *name,\n    *property,\n    *value;\n\n  const StringInfo\n    *profile;\n\n  int\n    num_passes,\n    pass,\n    ping_wrote_caNv;\n\n  png_byte\n     ping_trans_alpha[256];\n\n  png_color\n     palette[257];\n\n  png_color_16\n    ping_background,\n    ping_trans_color;\n\n  png_info\n    *ping_info;\n\n  png_struct\n    *ping;\n\n  png_uint_32\n    ping_height,\n    ping_width;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    image_matte,\n    logging,\n    matte,\n\n    ping_have_blob,\n    ping_have_cheap_transparency,\n    ping_have_color,\n    ping_have_non_bw,\n    ping_have_PLTE,\n    ping_have_bKGD,\n    ping_have_eXIf,\n    ping_have_iCCP,\n    ping_have_pHYs,\n    ping_have_sRGB,\n    ping_have_tRNS,\n\n    ping_exclude_bKGD,\n    ping_exclude_cHRM,\n    ping_exclude_date,\n    /* ping_exclude_EXIF, */\n    ping_exclude_eXIf,\n    ping_exclude_gAMA,\n    ping_exclude_iCCP,\n    /* ping_exclude_iTXt, */\n    ping_exclude_oFFs,\n    ping_exclude_pHYs,\n    ping_exclude_sRGB,\n    ping_exclude_tEXt,\n    ping_exclude_tIME,\n    /* ping_exclude_tRNS, */\n    ping_exclude_vpAg,\n    ping_exclude_caNv,\n    ping_exclude_zCCP, /* hex-encoded iCCP */\n    ping_exclude_zTXt,\n\n    ping_preserve_colormap,\n    ping_preserve_iCCP,\n    ping_need_colortype_warning,\n\n    status,\n    tried_332,\n    tried_333,\n    tried_444;\n\n  MemoryInfo\n    *volatile pixel_info;\n\n  QuantumInfo\n    *quantum_info;\n\n  PNGErrorInfo\n    error_info;\n\n  register ssize_t\n    i,\n    x;\n\n  unsigned char\n    *ping_pixels;\n\n  volatile int\n    image_colors,\n    ping_bit_depth,\n    ping_color_type,\n    ping_interlace_method,\n    ping_compression_method,\n    ping_filter_method,\n    ping_num_trans;\n\n  volatile size_t\n    image_depth,\n    old_bit_depth;\n\n  size_t\n    quality,\n    rowbytes,\n    save_image_depth;\n\n  int\n    j,\n    number_colors,\n    number_opaque,\n    number_semitransparent,\n    number_transparent,\n    ping_pHYs_unit_type;\n\n  png_uint_32\n    ping_pHYs_x_resolution,\n    ping_pHYs_y_resolution;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter WriteOnePNGImage()\");\n\n  image = CloneImage(IMimage,0,0,MagickFalse,exception);\n  image_info=(ImageInfo *) CloneImageInfo(IMimage_info);\n  if (image_info == (ImageInfo *) NULL)\n     ThrowWriterException(ResourceLimitError, \"MemoryAllocationFailed\");\n\n  /* Define these outside of the following \"if logging()\" block so they will\n   * show in debuggers.\n   */\n  *im_vers='\\0';\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibVersionText,MagickPathExtent);\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibAddendum,MagickPathExtent);\n\n  *libpng_vers='\\0';\n  (void) ConcatenateMagickString(libpng_vers,\n         PNG_LIBPNG_VER_STRING,32);\n  *libpng_runv='\\0';\n  (void) ConcatenateMagickString(libpng_runv,\n         png_get_libpng_ver(NULL),32);\n\n  *zlib_vers='\\0';\n  (void) ConcatenateMagickString(zlib_vers,\n         ZLIB_VERSION,32);\n  *zlib_runv='\\0';\n  (void) ConcatenateMagickString(zlib_runv,\n         zlib_version,32);\n\n  if (logging != MagickFalse)\n    {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    IM version     = %s\",\n           im_vers);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Libpng version = %s\",\n           libpng_vers);\n       if (LocaleCompare(libpng_vers,libpng_runv) != 0)\n       {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n           libpng_runv);\n       }\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Zlib version   = %s\",\n           zlib_vers);\n       if (LocaleCompare(zlib_vers,zlib_runv) != 0)\n       {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n           zlib_runv);\n       }\n    }\n\n  /* Initialize some stuff */\n  ping_bit_depth=0,\n  ping_color_type=0,\n  ping_interlace_method=0,\n  ping_compression_method=0,\n  ping_filter_method=0,\n  ping_num_trans = 0;\n\n  ping_background.red = 0;\n  ping_background.green = 0;\n  ping_background.blue = 0;\n  ping_background.gray = 0;\n  ping_background.index = 0;\n\n  ping_trans_color.red=0;\n  ping_trans_color.green=0;\n  ping_trans_color.blue=0;\n  ping_trans_color.gray=0;\n\n  ping_pHYs_unit_type = 0;\n  ping_pHYs_x_resolution = 0;\n  ping_pHYs_y_resolution = 0;\n\n  ping_have_blob=MagickFalse;\n  ping_have_cheap_transparency=MagickFalse;\n  ping_have_color=MagickTrue;\n  ping_have_non_bw=MagickTrue;\n  ping_have_PLTE=MagickFalse;\n  ping_have_bKGD=MagickFalse;\n  ping_have_eXIf=MagickTrue;\n  ping_have_iCCP=MagickFalse;\n  ping_have_pHYs=MagickFalse;\n  ping_have_sRGB=MagickFalse;\n  ping_have_tRNS=MagickFalse;\n\n  ping_exclude_bKGD=mng_info->ping_exclude_bKGD;\n  ping_exclude_caNv=mng_info->ping_exclude_caNv;\n  ping_exclude_cHRM=mng_info->ping_exclude_cHRM;\n  ping_exclude_date=mng_info->ping_exclude_date;\n  ping_exclude_eXIf=mng_info->ping_exclude_eXIf;\n  ping_exclude_gAMA=mng_info->ping_exclude_gAMA;\n  ping_exclude_iCCP=mng_info->ping_exclude_iCCP;\n  /* ping_exclude_iTXt=mng_info->ping_exclude_iTXt; */\n  ping_exclude_oFFs=mng_info->ping_exclude_oFFs;\n  ping_exclude_pHYs=mng_info->ping_exclude_pHYs;\n  ping_exclude_sRGB=mng_info->ping_exclude_sRGB;\n  ping_exclude_tEXt=mng_info->ping_exclude_tEXt;\n  ping_exclude_tIME=mng_info->ping_exclude_tIME;\n  /* ping_exclude_tRNS=mng_info->ping_exclude_tRNS; */\n  ping_exclude_vpAg=mng_info->ping_exclude_vpAg;\n  ping_exclude_zCCP=mng_info->ping_exclude_zCCP; /* hex-encoded iCCP in zTXt */\n  ping_exclude_zTXt=mng_info->ping_exclude_zTXt;\n\n  ping_preserve_colormap = mng_info->ping_preserve_colormap;\n  ping_preserve_iCCP = mng_info->ping_preserve_iCCP;\n  ping_need_colortype_warning = MagickFalse;\n\n  /* Recognize the ICC sRGB profile and convert it to the sRGB chunk,\n   * i.e., eliminate the ICC profile and set image->rendering_intent.\n   * Note that this will not involve any changes to the actual pixels\n   * but merely passes information to applications that read the resulting\n   * PNG image.\n   *\n   * To do: recognize other variants of the sRGB profile, using the CRC to\n   * verify all recognized variants including the 7 already known.\n   *\n   * Work around libpng16+ rejecting some \"known invalid sRGB profiles\".\n   *\n   * Use something other than image->rendering_intent to record the fact\n   * that the sRGB profile was found.\n   *\n   * Record the ICC version (currently v2 or v4) of the incoming sRGB ICC\n   * profile.  Record the Blackpoint Compensation, if any.\n   */\n   if (ping_exclude_sRGB == MagickFalse && ping_preserve_iCCP == MagickFalse)\n   {\n      char\n        *name;\n\n      const StringInfo\n        *profile;\n\n      ResetImageProfileIterator(image);\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        profile=GetImageProfile(image,name);\n\n        if (profile != (StringInfo *) NULL)\n          {\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0))\n\n             {\n                 int\n                   icheck,\n                   got_crc=0;\n\n\n                 png_uint_32\n                   length,\n                   profile_crc=0;\n\n                 unsigned char\n                   *data;\n\n                 length=(png_uint_32) GetStringInfoLength(profile);\n\n                 for (icheck=0; sRGB_info[icheck].len > 0; icheck++)\n                 {\n                   if (length == sRGB_info[icheck].len)\n                   {\n                     if (got_crc == 0)\n                     {\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Got a %lu-byte ICC profile (potentially sRGB)\",\n                         (unsigned long) length);\n\n                       data=GetStringInfoDatum(profile);\n                       profile_crc=crc32(0,data,length);\n\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"      with crc=%8x\",(unsigned int) profile_crc);\n                       got_crc++;\n                     }\n\n                     if (profile_crc == sRGB_info[icheck].crc)\n                     {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"      It is sRGB with rendering intent = %s\",\n                        Magick_RenderingIntentString_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent));\n                        if (image->rendering_intent==UndefinedIntent)\n                        {\n                          image->rendering_intent=\n                          Magick_RenderingIntent_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent);\n                        }\n                        ping_exclude_iCCP = MagickTrue;\n                        ping_exclude_zCCP = MagickTrue;\n                        ping_have_sRGB = MagickTrue;\n                        break;\n                     }\n                   }\n                 }\n                 if (sRGB_info[icheck].len == 0)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"    Got %lu-byte ICC profile not recognized as sRGB\",\n                        (unsigned long) length);\n              }\n          }\n        name=GetNextImageProfile(image);\n      }\n  }\n\n  number_opaque = 0;\n  number_semitransparent = 0;\n  number_transparent = 0;\n\n  if (logging != MagickFalse)\n    {\n      if (image->storage_class == UndefinedClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=UndefinedClass\");\n      if (image->storage_class == DirectClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=DirectClass\");\n      if (image->storage_class == PseudoClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=PseudoClass\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(), image->taint ?\n          \"    image->taint=MagickTrue\":\n          \"    image->taint=MagickFalse\");\n    }\n\n  if (image->storage_class == PseudoClass &&\n     (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32 ||\n     mng_info->write_png48 || mng_info->write_png64 ||\n     (mng_info->write_png_colortype != 1 &&\n     mng_info->write_png_colortype != 5)))\n    {\n      (void) SyncImage(image,exception);\n      image->storage_class = DirectClass;\n    }\n\n  if (ping_preserve_colormap == MagickFalse)\n    {\n      if (image->storage_class != PseudoClass && image->colormap != NULL)\n        {\n          /* Free the bogus colormap; it can cause trouble later */\n           if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Freeing bogus colormap\");\n           (void) RelinquishMagickMemory(image->colormap);\n           image->colormap=NULL;\n        }\n    }\n\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n\n  /*\n    Sometimes we get PseudoClass images whose RGB values don't match\n    the colors in the colormap.  This code syncs the RGB values.\n  */\n  if (image->depth <= 8 && image->taint && image->storage_class == PseudoClass)\n     (void) SyncImage(image,exception);\n\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n  if (image->depth > 8)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Reducing PNG bit depth to 8 since this is a Q8 build.\");\n\n      image->depth=8;\n    }\n#endif\n\n  /* Respect the -depth option */\n  if (image->depth < 4)\n    {\n       register Quantum\n         *r;\n\n       if (image->depth > 2)\n         {\n           /* Scale to 4-bit */\n           LBR04PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR04PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR04PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n       else if (image->depth > 1)\n         {\n           /* Scale to 2-bit */\n           LBR02PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR02PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR02PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n       else\n         {\n           /* Scale to 1-bit */\n           LBR01PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR01PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR01PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n    }\n\n  /* To do: set to next higher multiple of 8 */\n  if (image->depth < 8)\n     image->depth=8;\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n  /* PNG does not handle depths greater than 16 so reduce it even\n   * if lossy\n   */\n  if (image->depth > 8)\n      image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\n  if (image->depth > 8)\n    {\n      /* To do: fill low byte properly */\n      image->depth=16;\n    }\n\n  if (image->depth == 16 && mng_info->write_png_depth != 16)\n    if (mng_info->write_png8 ||\n        LosslessReduceDepthOK(image,exception) != MagickFalse)\n      image->depth = 8;\n#endif\n\n  image_colors = (int) image->colors;\n  number_opaque = (int) image->colors;\n  number_transparent = 0;\n  number_semitransparent = 0;\n\n  if (mng_info->write_png_colortype &&\n     (mng_info->write_png_colortype > 4 || (mng_info->write_png_depth >= 8 &&\n     mng_info->write_png_colortype < 4 &&\n     image->alpha_trait == UndefinedPixelTrait)))\n  {\n     /* Avoid the expensive BUILD_PALETTE operation if we're sure that we\n      * are not going to need the result.\n      */\n     if (mng_info->write_png_colortype == 1 ||\n        mng_info->write_png_colortype == 5)\n       ping_have_color=MagickFalse;\n\n     if (image->alpha_trait != UndefinedPixelTrait)\n       {\n         number_transparent = 2;\n         number_semitransparent = 1;\n       }\n  }\n\n  if (mng_info->write_png_colortype < 7)\n  {\n  /* BUILD_PALETTE\n   *\n   * Normally we run this just once, but in the case of writing PNG8\n   * we reduce the transparency to binary and run again, then if there\n   * are still too many colors we reduce to a simple 4-4-4-1, then 3-3-3-1\n   * RGBA palette and run again, and then to a simple 3-3-2-1 RGBA\n   * palette.  Then (To do) we take care of a final reduction that is only\n   * needed if there are still 256 colors present and one of them has both\n   * transparent and opaque instances.\n   */\n\n  tried_332 = MagickFalse;\n  tried_333 = MagickFalse;\n  tried_444 = MagickFalse;\n\n  for (j=0; j<6; j++)\n  {\n    /*\n     * Sometimes we get DirectClass images that have 256 colors or fewer.\n     * This code will build a colormap.\n     *\n     * Also, sometimes we get PseudoClass images with an out-of-date\n     * colormap.  This code will replace the colormap with a new one.\n     * Sometimes we get PseudoClass images that have more than 256 colors.\n     * This code will delete the colormap and change the image to\n     * DirectClass.\n     *\n     * If image->alpha_trait is MagickFalse, we ignore the alpha channel\n     * even though it sometimes contains left-over non-opaque values.\n     *\n     * Also we gather some information (number of opaque, transparent,\n     * and semitransparent pixels, and whether the image has any non-gray\n     * pixels or only black-and-white pixels) that we might need later.\n     *\n     * Even if the user wants to force GrayAlpha or RGBA (colortype 4 or 6)\n     * we need to check for bogus non-opaque values, at least.\n     */\n\n   int\n     n;\n\n   PixelInfo\n     opaque[260],\n     semitransparent[260],\n     transparent[260];\n\n   register const Quantum\n     *s;\n\n   register Quantum\n     *q,\n     *r;\n\n   if (logging != MagickFalse)\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    Enter BUILD_PALETTE:\");\n\n   if (logging != MagickFalse)\n     {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->columns=%.20g\",(double) image->columns);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->rows=%.20g\",(double) image->rows);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->alpha_trait=%.20g\",(double) image->alpha_trait);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->depth=%.20g\",(double) image->depth);\n\n       if (image->storage_class == PseudoClass && image->colormap != NULL)\n       {\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      Original colormap:\");\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"        i    (red,green,blue,alpha)\");\n\n         for (i=0; i < 256; i++)\n         {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"        %d    (%d,%d,%d,%d)\",\n                    (int) i,\n                    (int) image->colormap[i].red,\n                    (int) image->colormap[i].green,\n                    (int) image->colormap[i].blue,\n                    (int) image->colormap[i].alpha);\n         }\n\n         for (i=image->colors - 10; i < (ssize_t) image->colors; i++)\n         {\n           if (i > 255)\n             {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"        %d    (%d,%d,%d,%d)\",\n                    (int) i,\n                    (int) image->colormap[i].red,\n                    (int) image->colormap[i].green,\n                    (int) image->colormap[i].blue,\n                    (int) image->colormap[i].alpha);\n             }\n         }\n       }\n\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"      image->colors=%d\",(int) image->colors);\n\n       if (image->colors == 0)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"        (zero means unknown)\");\n\n       if (ping_preserve_colormap == MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"      Regenerate the colormap\");\n     }\n\n     image_colors=0;\n     number_opaque = 0;\n     number_semitransparent = 0;\n     number_transparent = 0;\n\n     for (y=0; y < (ssize_t) image->rows; y++)\n     {\n       q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n       if (q == (Quantum *) NULL)\n         break;\n\n       for (x=0; x < (ssize_t) image->columns; x++)\n       {\n           if (image->alpha_trait == UndefinedPixelTrait ||\n              GetPixelAlpha(image,q) == OpaqueAlpha)\n             {\n               if (number_opaque < 259)\n                 {\n                   if (number_opaque == 0)\n                     {\n                       GetPixelInfoPixel(image, q, opaque);\n                       opaque[0].alpha=OpaqueAlpha;\n                       number_opaque=1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_opaque; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,opaque+i))\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_opaque && number_opaque < 259)\n                     {\n                       number_opaque++;\n                       GetPixelInfoPixel(image, q, opaque+i);\n                       opaque[i].alpha=OpaqueAlpha;\n                     }\n                 }\n             }\n           else if (GetPixelAlpha(image,q) == TransparentAlpha)\n             {\n               if (number_transparent < 259)\n                 {\n                   if (number_transparent == 0)\n                     {\n                       GetPixelInfoPixel(image, q, transparent);\n                       ping_trans_color.red=(unsigned short)\n                         GetPixelRed(image,q);\n                       ping_trans_color.green=(unsigned short)\n                         GetPixelGreen(image,q);\n                       ping_trans_color.blue=(unsigned short)\n                         GetPixelBlue(image,q);\n                       ping_trans_color.gray=(unsigned short)\n                         GetPixelGray(image,q);\n                       number_transparent = 1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_transparent; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,transparent+i))\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_transparent &&\n                       number_transparent < 259)\n                     {\n                       number_transparent++;\n                       GetPixelInfoPixel(image,q,transparent+i);\n                     }\n                 }\n             }\n           else\n             {\n               if (number_semitransparent < 259)\n                 {\n                   if (number_semitransparent == 0)\n                     {\n                       GetPixelInfoPixel(image,q,semitransparent);\n                       number_semitransparent = 1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_semitransparent; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,semitransparent+i)\n                           && GetPixelAlpha(image,q) ==\n                           semitransparent[i].alpha)\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_semitransparent &&\n                       number_semitransparent < 259)\n                     {\n                       number_semitransparent++;\n                       GetPixelInfoPixel(image, q, semitransparent+i);\n                     }\n                 }\n             }\n           q+=GetPixelChannels(image);\n        }\n     }\n\n     if (mng_info->write_png8 == MagickFalse &&\n         ping_exclude_bKGD == MagickFalse)\n       {\n         /* Add the background color to the palette, if it\n          * isn't already there.\n          */\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      Check colormap for background (%d,%d,%d)\",\n                  (int) image->background_color.red,\n                  (int) image->background_color.green,\n                  (int) image->background_color.blue);\n            }\n          for (i=0; i<number_opaque; i++)\n          {\n             if (opaque[i].red == image->background_color.red &&\n                 opaque[i].green == image->background_color.green &&\n                 opaque[i].blue == image->background_color.blue)\n               break;\n          }\n          if (number_opaque < 259 && i == number_opaque)\n            {\n               opaque[i] = image->background_color;\n               ping_background.index = i;\n               number_opaque++;\n               if (logging != MagickFalse)\n                 {\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"      background_color index is %d\",(int) i);\n                 }\n\n            }\n          else if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      No room in the colormap to add background color\");\n       }\n\n     image_colors=number_opaque+number_transparent+number_semitransparent;\n\n     if (logging != MagickFalse)\n       {\n         if (image_colors > 256)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      image has more than 256 colors\");\n\n         else\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      image has %d colors\",image_colors);\n       }\n\n     if (ping_preserve_colormap != MagickFalse)\n       break;\n\n     if (mng_info->write_png_colortype != 7) /* We won't need this info */\n       {\n         ping_have_color=MagickFalse;\n         ping_have_non_bw=MagickFalse;\n\n         if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n         {\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"incompatible colorspace\");\n           ping_have_color=MagickTrue;\n           ping_have_non_bw=MagickTrue;\n         }\n\n         if(image_colors > 256)\n           {\n             for (y=0; y < (ssize_t) image->rows; y++)\n             {\n               q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n               if (q == (Quantum *) NULL)\n                 break;\n\n               s=q;\n               for (x=0; x < (ssize_t) image->columns; x++)\n               {\n                 if (GetPixelRed(image,s) != GetPixelGreen(image,s) ||\n                     GetPixelRed(image,s) != GetPixelBlue(image,s))\n                   {\n                      ping_have_color=MagickTrue;\n                      ping_have_non_bw=MagickTrue;\n                      break;\n                   }\n                 s+=GetPixelChannels(image);\n               }\n\n               if (ping_have_color != MagickFalse)\n                 break;\n\n               /* Worst case is black-and-white; we are looking at every\n                * pixel twice.\n                */\n\n               if (ping_have_non_bw == MagickFalse)\n                 {\n                   s=q;\n                   for (x=0; x < (ssize_t) image->columns; x++)\n                   {\n                     if (GetPixelRed(image,s) != 0 &&\n                         GetPixelRed(image,s) != QuantumRange)\n                       {\n                         ping_have_non_bw=MagickTrue;\n                         break;\n                       }\n                     s+=GetPixelChannels(image);\n                   }\n               }\n             }\n           }\n       }\n\n     if (image_colors < 257)\n       {\n         PixelInfo\n           colormap[260];\n\n         /*\n          * Initialize image colormap.\n          */\n\n         if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      Sort the new colormap\");\n\n        /* Sort palette, transparent first */;\n\n         n = 0;\n\n         for (i=0; i<number_transparent; i++)\n            colormap[n++] = transparent[i];\n\n         for (i=0; i<number_semitransparent; i++)\n            colormap[n++] = semitransparent[i];\n\n         for (i=0; i<number_opaque; i++)\n            colormap[n++] = opaque[i];\n\n         ping_background.index +=\n           (number_transparent + number_semitransparent);\n\n         /* image_colors < 257; search the colormap instead of the pixels\n          * to get ping_have_color and ping_have_non_bw\n          */\n         for (i=0; i<n; i++)\n         {\n           if (ping_have_color == MagickFalse)\n             {\n                if (colormap[i].red != colormap[i].green ||\n                    colormap[i].red != colormap[i].blue)\n                  {\n                     ping_have_color=MagickTrue;\n                     ping_have_non_bw=MagickTrue;\n                     break;\n                  }\n              }\n\n           if (ping_have_non_bw == MagickFalse)\n             {\n               if (colormap[i].red != 0 && colormap[i].red != QuantumRange)\n                   ping_have_non_bw=MagickTrue;\n             }\n          }\n\n        if ((mng_info->ping_exclude_tRNS == MagickFalse ||\n            (number_transparent == 0 && number_semitransparent == 0)) &&\n            (((mng_info->write_png_colortype-1) ==\n            PNG_COLOR_TYPE_PALETTE) ||\n            (mng_info->write_png_colortype == 0)))\n          {\n            if (logging != MagickFalse)\n              {\n                if (n !=  (ssize_t) image_colors)\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"   image_colors (%d) and n (%d)  don't match\",\n                   image_colors, n);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      AcquireImageColormap\");\n              }\n\n            image->colors = image_colors;\n\n            if (AcquireImageColormap(image,image_colors,exception) ==\n                MagickFalse)\n               ThrowWriterException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");\n\n            for (i=0; i< (ssize_t) image_colors; i++)\n               image->colormap[i] = colormap[i];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"      image->colors=%d (%d)\",\n                      (int) image->colors, image_colors);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"      Update the pixel indexes\");\n              }\n\n            /* Sync the pixel indices with the new colormap */\n\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n              if (q == (Quantum *) NULL)\n                break;\n\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                for (i=0; i< (ssize_t) image_colors; i++)\n                {\n                  if ((image->alpha_trait == UndefinedPixelTrait ||\n                      image->colormap[i].alpha == GetPixelAlpha(image,q)) &&\n                      image->colormap[i].red == GetPixelRed(image,q) &&\n                      image->colormap[i].green == GetPixelGreen(image,q) &&\n                      image->colormap[i].blue == GetPixelBlue(image,q))\n                  {\n                    SetPixelIndex(image,i,q);\n                    break;\n                  }\n                }\n                q+=GetPixelChannels(image);\n              }\n\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                 break;\n            }\n          }\n       }\n\n     if (logging != MagickFalse)\n       {\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      image->colors=%d\", (int) image->colors);\n\n         if (image->colormap != NULL)\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"       i     (red,green,blue,alpha)\");\n\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               if (i < 300 || i >= (ssize_t) image->colors - 10)\n                 {\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"       %d     (%d,%d,%d,%d)\",\n                        (int) i,\n                        (int) image->colormap[i].red,\n                        (int) image->colormap[i].green,\n                        (int) image->colormap[i].blue,\n                        (int) image->colormap[i].alpha);\n                 }\n             }\n           }\n\n           if (number_transparent < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_transparent     = %d\",\n                   number_transparent);\n           else\n\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_transparent     > 256\");\n\n           if (number_opaque < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_opaque          = %d\",\n                   number_opaque);\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_opaque          > 256\");\n\n           if (number_semitransparent < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_semitransparent = %d\",\n                   number_semitransparent);\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_semitransparent > 256\");\n\n           if (ping_have_non_bw == MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      All pixels and the background are black or white\");\n\n           else if (ping_have_color == MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      All pixels and the background are gray\");\n\n           else\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      At least one pixel or the background is non-gray\");\n\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Exit BUILD_PALETTE:\");\n       }\n\n   if (mng_info->write_png8 == MagickFalse)\n      break;\n\n   /* Make any reductions necessary for the PNG8 format */\n    if (image_colors <= 256 &&\n        image_colors != 0 && image->colormap != NULL &&\n        number_semitransparent == 0 &&\n        number_transparent <= 1)\n      break;\n\n    /* PNG8 can't have semitransparent colors so we threshold the\n     * opacity to 0 or OpaqueOpacity, and PNG8 can only have one\n     * transparent color so if more than one is transparent we merge\n     * them into image->background_color.\n     */\n    if (number_semitransparent != 0 || number_transparent > 1)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Thresholding the alpha channel to binary\");\n\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (r == (Quantum *) NULL)\n            break;\n\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n              if (GetPixelAlpha(image,r) < OpaqueAlpha/2)\n                {\n                  SetPixelViaPixelInfo(image,&image->background_color,r);\n                  SetPixelAlpha(image,TransparentAlpha,r);\n                }\n              else\n                  SetPixelAlpha(image,OpaqueAlpha,r);\n              r+=GetPixelChannels(image);\n          }\n\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n\n          if (image_colors != 0 && image_colors <= 256 &&\n             image->colormap != NULL)\n            for (i=0; i<image_colors; i++)\n                image->colormap[i].alpha =\n                    (image->colormap[i].alpha > TransparentAlpha/2 ?\n                    TransparentAlpha : OpaqueAlpha);\n        }\n      continue;\n    }\n\n    /* PNG8 can't have more than 256 colors so we quantize the pixels and\n     * background color to the 4-4-4-1, 3-3-3-1 or 3-3-2-1 palette.  If the\n     * image is mostly gray, the 4-4-4-1 palette is likely to end up with 256\n     * colors or less.\n     */\n    if (tried_444 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 4-4-4\");\n\n        tried_444 = MagickTrue;\n\n        LBR04PacketRGB(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 4-4-4\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR04PixelRGB(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 4-4-4\");\n\n          for (i=0; i<image_colors; i++)\n          {\n            LBR04PacketRGB(image->colormap[i]);\n          }\n        }\n        continue;\n      }\n\n    if (tried_333 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 3-3-3\");\n\n        tried_333 = MagickTrue;\n\n        LBR03PacketRGB(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 3-3-3-1\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR03RGB(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 3-3-3-1\");\n          for (i=0; i<image_colors; i++)\n          {\n              LBR03PacketRGB(image->colormap[i]);\n          }\n        }\n        continue;\n      }\n\n    if (tried_332 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 3-3-2\");\n\n        tried_332 = MagickTrue;\n\n        /* Red and green were already done so we only quantize the blue\n         * channel\n         */\n\n        LBR02PacketBlue(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 3-3-2-1\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR02PixelBlue(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 3-3-2-1\");\n          for (i=0; i<image_colors; i++)\n          {\n              LBR02PacketBlue(image->colormap[i]);\n          }\n      }\n      continue;\n    }\n\n    if (image_colors == 0 || image_colors > 256)\n    {\n      /* Take care of special case with 256 opaque colors + 1 transparent\n       * color.  We don't need to quantize to 2-3-2-1; we only need to\n       * eliminate one color, so we'll merge the two darkest red\n       * colors (0x49, 0, 0) -> (0x24, 0, 0).\n       */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Merging two dark red background colors to 3-3-2-1\");\n\n      if (ScaleQuantumToChar(image->background_color.red) == 0x49 &&\n          ScaleQuantumToChar(image->background_color.green) == 0x00 &&\n          ScaleQuantumToChar(image->background_color.blue) == 0x00)\n      {\n         image->background_color.red=ScaleCharToQuantum(0x24);\n      }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Merging two dark red pixel colors to 3-3-2-1\");\n\n      if (image->colormap == NULL)\n      {\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (r == (Quantum *) NULL)\n            break;\n\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (ScaleQuantumToChar(GetPixelRed(image,r)) == 0x49 &&\n                ScaleQuantumToChar(GetPixelGreen(image,r)) == 0x00 &&\n                ScaleQuantumToChar(GetPixelBlue(image,r)) == 0x00 &&\n                GetPixelAlpha(image,r) == OpaqueAlpha)\n              {\n                SetPixelRed(image,ScaleCharToQuantum(0x24),r);\n              }\n            r+=GetPixelChannels(image);\n          }\n\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n\n        }\n      }\n\n      else\n      {\n         for (i=0; i<image_colors; i++)\n         {\n            if (ScaleQuantumToChar(image->colormap[i].red) == 0x49 &&\n                ScaleQuantumToChar(image->colormap[i].green) == 0x00 &&\n                ScaleQuantumToChar(image->colormap[i].blue) == 0x00)\n            {\n               image->colormap[i].red=ScaleCharToQuantum(0x24);\n            }\n         }\n      }\n    }\n  }\n  }\n  /* END OF BUILD_PALETTE */\n\n  /* If we are excluding the tRNS chunk and there is transparency,\n   * then we must write a Gray-Alpha (color-type 4) or RGBA (color-type 6)\n   * PNG.\n   */\n  if (mng_info->ping_exclude_tRNS != MagickFalse &&\n     (number_transparent != 0 || number_semitransparent != 0))\n    {\n      unsigned int colortype=mng_info->write_png_colortype;\n\n      if (ping_have_color == MagickFalse)\n        mng_info->write_png_colortype = 5;\n\n      else\n        mng_info->write_png_colortype = 7;\n\n      if (colortype != 0 &&\n         mng_info->write_png_colortype != colortype)\n        ping_need_colortype_warning=MagickTrue;\n\n    }\n\n  /* See if cheap transparency is possible.  It is only possible\n   * when there is a single transparent color, no semitransparent\n   * color, and no opaque color that has the same RGB components\n   * as the transparent color.  We only need this information if\n   * we are writing a PNG with colortype 0 or 2, and we have not\n   * excluded the tRNS chunk.\n   */\n  if (number_transparent == 1 &&\n      mng_info->write_png_colortype < 4)\n    {\n       ping_have_cheap_transparency = MagickTrue;\n\n       if (number_semitransparent != 0)\n         ping_have_cheap_transparency = MagickFalse;\n\n       else if (image_colors == 0 || image_colors > 256 ||\n           image->colormap == NULL)\n         {\n           register const Quantum\n             *q;\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             q=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n             if (q == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                 if (GetPixelAlpha(image,q) != TransparentAlpha &&\n                     (unsigned short) GetPixelRed(image,q) ==\n                                     ping_trans_color.red &&\n                     (unsigned short) GetPixelGreen(image,q) ==\n                                     ping_trans_color.green &&\n                     (unsigned short) GetPixelBlue(image,q) ==\n                                     ping_trans_color.blue)\n                   {\n                     ping_have_cheap_transparency = MagickFalse;\n                     break;\n                   }\n\n                 q+=GetPixelChannels(image);\n             }\n\n             if (ping_have_cheap_transparency == MagickFalse)\n                break;\n           }\n         }\n       else\n         {\n            /* Assuming that image->colormap[0] is the one transparent color\n             * and that all others are opaque.\n             */\n            if (image_colors > 1)\n              for (i=1; i<image_colors; i++)\n                if (image->colormap[i].red == image->colormap[0].red &&\n                    image->colormap[i].green == image->colormap[0].green &&\n                    image->colormap[i].blue == image->colormap[0].blue)\n                  {\n                     ping_have_cheap_transparency = MagickFalse;\n                     break;\n                  }\n         }\n\n       if (logging != MagickFalse)\n         {\n           if (ping_have_cheap_transparency == MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"   Cheap transparency is not possible.\");\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"   Cheap transparency is possible.\");\n         }\n     }\n  else\n    ping_have_cheap_transparency = MagickFalse;\n\n  image_depth=image->depth;\n\n  quantum_info = (QuantumInfo *) NULL;\n  number_colors=0;\n  image_colors=(int) image->colors;\n  image_matte=image->alpha_trait !=\n        UndefinedPixelTrait ? MagickTrue : MagickFalse;\n\n  if (mng_info->write_png_colortype < 5)\n    mng_info->IsPalette=image->storage_class == PseudoClass &&\n      image_colors <= 256 && image->colormap != NULL;\n  else\n    mng_info->IsPalette = MagickFalse;\n\n  if ((mng_info->write_png_colortype == 4 || mng_info->write_png8) &&\n     (image->colors == 0 || image->colormap == NULL))\n    {\n      image_info=DestroyImageInfo(image_info);\n      image=DestroyImage(image);\n      (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          \"Cannot write PNG8 or color-type 3; colormap is NULL\",\n          \"`%s'\",IMimage->filename);\n      return(MagickFalse);\n    }\n\n  /*\n    Allocate the PNG structures\n  */\n#ifdef PNG_USER_MEM_SUPPORTED\n error_info.image=image;\n error_info.exception=exception;\n  ping=png_create_write_struct_2(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler,(void *) NULL,\n    (png_malloc_ptr) Magick_png_malloc,(png_free_ptr) Magick_png_free);\n\n#else\n  ping=png_create_write_struct(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler);\n\n#endif\n  if (ping == (png_struct *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  ping_info=png_create_info_struct(ping);\n\n  if (ping_info == (png_info *) NULL)\n    {\n      png_destroy_write_struct(&ping,(png_info **) NULL);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n\n  png_set_write_fn(ping,image,png_put_data,png_flush_data);\n  pixel_info=(MemoryInfo *) NULL;\n\n  if (setjmp(png_jmpbuf(ping)))\n    {\n      /*\n        PNG write failed.\n      */\n#ifdef PNG_DEBUG\n     if (image_info->verbose)\n        (void) printf(\"PNG write has failed.\\n\");\n#endif\n      png_destroy_write_struct(&ping,&ping_info);\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n      UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n      if (pixel_info != (MemoryInfo *) NULL)\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n\n      if (quantum_info != (QuantumInfo *) NULL)\n        quantum_info=DestroyQuantumInfo(quantum_info);\n\n      if (ping_have_blob != MagickFalse)\n          (void) CloseBlob(image);\n      image_info=DestroyImageInfo(image_info);\n      image=DestroyImage(image);\n      return(MagickFalse);\n    }\n\n  /* {  For navigation to end of SETJMP-protected block.  Within this\n   *    block, use png_error() instead of Throwing an Exception, to ensure\n   *    that libpng is able to clean up, and that the semaphore is unlocked.\n   */\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  LockSemaphoreInfo(ping_semaphore);\n#endif\n\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\n  /* Allow benign errors */\n  png_set_benign_errors(ping, 1);\n#endif\n\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n  /* Reject images with too many rows or columns */\n  png_set_user_limits(ping,\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(WidthResource)),\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(HeightResource)));\n#endif /* PNG_SET_USER_LIMITS_SUPPORTED */\n\n  /*\n    Prepare PNG for writing.\n  */\n\n#if defined(PNG_MNG_FEATURES_SUPPORTED)\n  if (mng_info->write_mng)\n  {\n     (void) png_permit_mng_features(ping,PNG_ALL_MNG_FEATURES);\n# ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED\n     /* Disable new libpng-1.5.10 feature when writing a MNG because\n      * zero-length PLTE is OK\n      */\n     png_set_check_for_invalid_index (ping, 0);\n# endif\n  }\n\n#else\n# ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED\n  if (mng_info->write_mng)\n     png_permit_empty_plte(ping,MagickTrue);\n\n# endif\n#endif\n\n  x=0;\n\n  ping_width=(png_uint_32) image->columns;\n  ping_height=(png_uint_32) image->rows;\n\n  if (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32)\n     image_depth=8;\n\n  if (mng_info->write_png48 || mng_info->write_png64)\n     image_depth=16;\n\n  if (mng_info->write_png_depth != 0)\n     image_depth=mng_info->write_png_depth;\n\n  /* Adjust requested depth to next higher valid depth if necessary */\n  if (image_depth > 8)\n     image_depth=16;\n\n  if ((image_depth > 4) && (image_depth < 8))\n     image_depth=8;\n\n  if (image_depth == 3)\n     image_depth=4;\n\n  if (logging != MagickFalse)\n    {\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    width=%.20g\",(double) ping_width);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    height=%.20g\",(double) ping_height);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_matte=%.20g\",(double) image->alpha_trait);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image->depth=%.20g\",(double) image->depth);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Tentative ping_bit_depth=%.20g\",(double) image_depth);\n    }\n\n  save_image_depth=image_depth;\n  ping_bit_depth=(png_byte) save_image_depth;\n\n\n#if defined(PNG_pHYs_SUPPORTED)\n  if (ping_exclude_pHYs == MagickFalse)\n  {\n  if ((image->resolution.x != 0) && (image->resolution.y != 0) &&\n      (!mng_info->write_mng || !mng_info->equal_physs))\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Setting up pHYs chunk\");\n\n      if (image->units == PixelsPerInchResolution)\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_METER;\n          ping_pHYs_x_resolution=\n             (png_uint_32) ((100.0*image->resolution.x+0.5)/2.54);\n          ping_pHYs_y_resolution=\n             (png_uint_32) ((100.0*image->resolution.y+0.5)/2.54);\n        }\n\n      else if (image->units == PixelsPerCentimeterResolution)\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_METER;\n          ping_pHYs_x_resolution=(png_uint_32) (100.0*image->resolution.x+0.5);\n          ping_pHYs_y_resolution=(png_uint_32) (100.0*image->resolution.y+0.5);\n        }\n\n      else\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_UNKNOWN;\n          ping_pHYs_x_resolution=(png_uint_32) image->resolution.x;\n          ping_pHYs_y_resolution=(png_uint_32) image->resolution.y;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Set up PNG pHYs chunk: xres: %.20g, yres: %.20g, units: %d.\",\n          (double) ping_pHYs_x_resolution,(double) ping_pHYs_y_resolution,\n          (int) ping_pHYs_unit_type);\n       ping_have_pHYs = MagickTrue;\n    }\n  }\n#endif\n\n  if (ping_exclude_bKGD == MagickFalse)\n  {\n  if ((!mng_info->adjoin || !mng_info->equal_backgrounds))\n    {\n       unsigned int\n         mask;\n\n       mask=0xffff;\n       if (ping_bit_depth == 8)\n          mask=0x00ff;\n\n       if (ping_bit_depth == 4)\n          mask=0x000f;\n\n       if (ping_bit_depth == 2)\n          mask=0x0003;\n\n       if (ping_bit_depth == 1)\n          mask=0x0001;\n\n       ping_background.red=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.red) & mask);\n\n       ping_background.green=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.green) & mask);\n\n       ping_background.blue=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.blue) & mask);\n\n       ping_background.gray=(png_uint_16) ping_background.green;\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Setting up bKGD chunk (1)\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"      background_color index is %d\",\n          (int) ping_background.index);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    ping_bit_depth=%d\",ping_bit_depth);\n    }\n\n  ping_have_bKGD = MagickTrue;\n  }\n\n  /*\n    Select the color type.\n  */\n  matte=image_matte;\n  old_bit_depth=0;\n\n  if (mng_info->IsPalette && mng_info->write_png8)\n    {\n      /* To do: make this a function cause it's used twice, except\n         for reducing the sample depth from 8. */\n\n      number_colors=image_colors;\n\n      ping_have_tRNS=MagickFalse;\n\n      /*\n        Set image palette.\n      */\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Setting up PLTE chunk with %d colors (%d)\",\n            number_colors, image_colors);\n\n      for (i=0; i < (ssize_t) number_colors; i++)\n      {\n        palette[i].red=ScaleQuantumToChar(image->colormap[i].red);\n        palette[i].green=ScaleQuantumToChar(image->colormap[i].green);\n        palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n#if MAGICKCORE_QUANTUM_DEPTH == 8\n            \"    %3ld (%3d,%3d,%3d)\",\n#else\n            \"    %5ld (%5d,%5d,%5d)\",\n#endif\n            (long) i,palette[i].red,palette[i].green,palette[i].blue);\n\n      }\n\n      ping_have_PLTE=MagickTrue;\n      image_depth=ping_bit_depth;\n      ping_num_trans=0;\n\n      if (matte != MagickFalse)\n      {\n          /*\n            Identify which colormap entry is transparent.\n          */\n          assert(number_colors <= 256);\n          assert(image->colormap != NULL);\n\n          for (i=0; i < (ssize_t) number_transparent; i++)\n             ping_trans_alpha[i]=0;\n\n\n          ping_num_trans=(unsigned short) (number_transparent +\n             number_semitransparent);\n\n          if (ping_num_trans == 0)\n             ping_have_tRNS=MagickFalse;\n\n          else\n             ping_have_tRNS=MagickTrue;\n      }\n\n      if (ping_exclude_bKGD == MagickFalse)\n      {\n       /*\n        * Identify which colormap entry is the background color.\n        */\n\n        for (i=0; i < (ssize_t) MagickMax(1L*number_colors-1L,1L); i++)\n          if (IsPNGColorEqual(ping_background,image->colormap[i]))\n            break;\n\n        ping_background.index=(png_byte) i;\n\n        if (logging != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"      background_color index is %d\",\n                 (int) ping_background.index);\n          }\n      }\n    } /* end of write_png8 */\n\n  else if (mng_info->write_png_colortype == 1)\n    {\n      image_matte=MagickFalse;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;\n    }\n\n  else if (mng_info->write_png24 || mng_info->write_png48 ||\n      mng_info->write_png_colortype == 3)\n    {\n      image_matte=MagickFalse;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n    }\n\n  else if (mng_info->write_png32 || mng_info->write_png64 ||\n      mng_info->write_png_colortype == 7)\n    {\n      image_matte=MagickTrue;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;\n    }\n\n  else /* mng_info->write_pngNN not specified */\n    {\n      image_depth=ping_bit_depth;\n\n      if (mng_info->write_png_colortype != 0)\n        {\n          ping_color_type=(png_byte) mng_info->write_png_colortype-1;\n\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\n              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            image_matte=MagickTrue;\n\n          else\n            image_matte=MagickFalse;\n\n          if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"   PNG colortype %d was specified:\",(int) ping_color_type);\n        }\n\n      else /* write_png_colortype not specified */\n        {\n          if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Selecting PNG colortype:\");\n\n          ping_color_type=(png_byte) ((matte != MagickFalse)?\n            PNG_COLOR_TYPE_RGB_ALPHA:PNG_COLOR_TYPE_RGB);\n\n          if (image_info->type == TrueColorType)\n            {\n              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n              image_matte=MagickFalse;\n            }\n\n          if (image_info->type == TrueColorAlphaType)\n            {\n              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;\n              image_matte=MagickTrue;\n            }\n\n          if (image_info->type == PaletteType ||\n              image_info->type == PaletteAlphaType)\n            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n          if (mng_info->write_png_colortype == 0 &&\n             image_info->type == UndefinedType)\n            {\n              if (ping_have_color == MagickFalse)\n                {\n                  if (image_matte == MagickFalse)\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;\n                      image_matte=MagickFalse;\n                    }\n\n                  else\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY_ALPHA;\n                      image_matte=MagickTrue;\n                    }\n                }\n              else\n                {\n                  if (image_matte == MagickFalse)\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n                      image_matte=MagickFalse;\n                    }\n\n                  else\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGBA;\n                      image_matte=MagickTrue;\n                    }\n                 }\n            }\n\n        }\n\n      if (logging != MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    Selected PNG colortype=%d\",ping_color_type);\n\n      if (ping_bit_depth < 8)\n        {\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\n              ping_color_type == PNG_COLOR_TYPE_RGB ||\n              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            ping_bit_depth=8;\n        }\n\n      old_bit_depth=ping_bit_depth;\n\n      if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n        {\n          if (image->alpha_trait == UndefinedPixelTrait &&\n               ping_have_non_bw == MagickFalse)\n             ping_bit_depth=1;\n        }\n\n      if (ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        {\n           size_t one = 1;\n           ping_bit_depth=1;\n\n           if (image->colors == 0)\n           {\n              /* DO SOMETHING */\n                png_error(ping,\"image has 0 colors\");\n           }\n\n           while ((int) (one << ping_bit_depth) < (ssize_t) image_colors)\n             ping_bit_depth <<= 1;\n        }\n\n      if (logging != MagickFalse)\n         {\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Number of colors: %.20g\",(double) image_colors);\n\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Tentative PNG bit depth: %d\",ping_bit_depth);\n         }\n\n      if (ping_bit_depth < (int) mng_info->write_png_depth)\n         ping_bit_depth = mng_info->write_png_depth;\n    }\n\n  image_depth=ping_bit_depth;\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Tentative PNG color type: %s (%.20g)\",\n        PngColorTypeToString(ping_color_type),\n        (double) ping_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_info->type: %.20g\",(double) image_info->type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_depth: %.20g\",(double) image_depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\n        \"    image->depth: %.20g\",(double) image->depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    ping_bit_depth: %.20g\",(double) ping_bit_depth);\n    }\n\n  if (matte != MagickFalse)\n    {\n      if (mng_info->IsPalette)\n        {\n          if (mng_info->write_png_colortype == 0)\n            {\n              ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;\n\n              if (ping_have_color != MagickFalse)\n                 ping_color_type=PNG_COLOR_TYPE_RGBA;\n            }\n\n          /*\n           * Determine if there is any transparent color.\n          */\n          if (number_transparent + number_semitransparent == 0)\n            {\n              /*\n                No transparent pixels are present.  Change 4 or 6 to 0 or 2.\n              */\n\n              image_matte=MagickFalse;\n\n              if (mng_info->write_png_colortype == 0)\n                ping_color_type&=0x03;\n            }\n\n          else\n            {\n              unsigned int\n                mask;\n\n              mask=0xffff;\n\n              if (ping_bit_depth == 8)\n                 mask=0x00ff;\n\n              if (ping_bit_depth == 4)\n                 mask=0x000f;\n\n              if (ping_bit_depth == 2)\n                 mask=0x0003;\n\n              if (ping_bit_depth == 1)\n                 mask=0x0001;\n\n              ping_trans_color.red=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].red) & mask);\n\n              ping_trans_color.green=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].green) & mask);\n\n              ping_trans_color.blue=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].blue) & mask);\n\n              ping_trans_color.gray=(png_uint_16)\n                (ScaleQuantumToShort(GetPixelInfoIntensity(image,\n                   image->colormap)) & mask);\n\n              ping_trans_color.index=(png_byte) 0;\n\n              ping_have_tRNS=MagickTrue;\n            }\n\n          if (ping_have_tRNS != MagickFalse)\n            {\n              /*\n               * Determine if there is one and only one transparent color\n               * and if so if it is fully transparent.\n               */\n              if (ping_have_cheap_transparency == MagickFalse)\n                ping_have_tRNS=MagickFalse;\n            }\n\n          if (ping_have_tRNS != MagickFalse)\n            {\n              if (mng_info->write_png_colortype == 0)\n                ping_color_type &= 0x03;  /* changes 4 or 6 to 0 or 2 */\n\n              if (image_depth == 8)\n                {\n                  ping_trans_color.red&=0xff;\n                  ping_trans_color.green&=0xff;\n                  ping_trans_color.blue&=0xff;\n                  ping_trans_color.gray&=0xff;\n                }\n            }\n        }\n      else\n        {\n          if (image_depth == 8)\n            {\n              ping_trans_color.red&=0xff;\n              ping_trans_color.green&=0xff;\n              ping_trans_color.blue&=0xff;\n              ping_trans_color.gray&=0xff;\n            }\n        }\n    }\n\n    matte=image_matte;\n\n    if (ping_have_tRNS != MagickFalse)\n      image_matte=MagickFalse;\n\n    if ((mng_info->IsPalette) &&\n        mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE &&\n        ping_have_color == MagickFalse &&\n        (image_matte == MagickFalse || image_depth >= 8))\n      {\n        size_t one=1;\n\n        if (image_matte != MagickFalse)\n          ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;\n\n        else if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_GRAY_ALPHA)\n          {\n            ping_color_type=PNG_COLOR_TYPE_GRAY;\n\n            if (save_image_depth == 16 && image_depth == 8)\n              {\n                if (logging != MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Scaling ping_trans_color (0)\");\n                  }\n                    ping_trans_color.gray*=0x0101;\n              }\n          }\n\n        if (image_depth > MAGICKCORE_QUANTUM_DEPTH)\n          image_depth=MAGICKCORE_QUANTUM_DEPTH;\n\n        if ((image_colors == 0) ||\n             ((ssize_t) (image_colors-1) > (ssize_t) MaxColormapSize))\n          image_colors=(int) (one << image_depth);\n\n        if (image_depth > 8)\n          ping_bit_depth=16;\n\n        else\n          {\n            ping_bit_depth=8;\n            if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n              {\n                if(!mng_info->write_png_depth)\n                  {\n                    ping_bit_depth=1;\n\n                    while ((int) (one << ping_bit_depth)\n                        < (ssize_t) image_colors)\n                      ping_bit_depth <<= 1;\n                  }\n              }\n\n            else if (ping_color_type ==\n                PNG_COLOR_TYPE_GRAY && image_colors < 17 &&\n                mng_info->IsPalette)\n              {\n              /* Check if grayscale is reducible */\n\n                int\n                  depth_4_ok=MagickTrue,\n                  depth_2_ok=MagickTrue,\n                  depth_1_ok=MagickTrue;\n\n                for (i=0; i < (ssize_t) image_colors; i++)\n                {\n                   unsigned char\n                     intensity;\n\n                   intensity=ScaleQuantumToChar(image->colormap[i].red);\n\n                   if ((intensity & 0x0f) != ((intensity & 0xf0) >> 4))\n                     depth_4_ok=depth_2_ok=depth_1_ok=MagickFalse;\n                   else if ((intensity & 0x03) != ((intensity & 0x0c) >> 2))\n                     depth_2_ok=depth_1_ok=MagickFalse;\n                   else if ((intensity & 0x01) != ((intensity & 0x02) >> 1))\n                     depth_1_ok=MagickFalse;\n                }\n\n                if (depth_1_ok && mng_info->write_png_depth <= 1)\n                  ping_bit_depth=1;\n\n                else if (depth_2_ok && mng_info->write_png_depth <= 2)\n                  ping_bit_depth=2;\n\n                else if (depth_4_ok && mng_info->write_png_depth <= 4)\n                  ping_bit_depth=4;\n              }\n          }\n\n          image_depth=ping_bit_depth;\n      }\n\n    else\n\n      if (mng_info->IsPalette)\n      {\n        number_colors=image_colors;\n\n        if (image_depth <= 8)\n          {\n            /*\n              Set image palette.\n            */\n            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n            if (!(mng_info->have_write_global_plte && matte == MagickFalse))\n              {\n                for (i=0; i < (ssize_t) number_colors; i++)\n                {\n                  palette[i].red=ScaleQuantumToChar(image->colormap[i].red);\n                  palette[i].green=\n                    ScaleQuantumToChar(image->colormap[i].green);\n                  palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);\n                }\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Setting up PLTE chunk with %d colors\",\n                    number_colors);\n\n                ping_have_PLTE=MagickTrue;\n              }\n\n            /* color_type is PNG_COLOR_TYPE_PALETTE */\n            if (mng_info->write_png_depth == 0)\n              {\n                size_t\n                  one;\n\n                ping_bit_depth=1;\n                one=1;\n\n                while ((one << ping_bit_depth) < (size_t) number_colors)\n                  ping_bit_depth <<= 1;\n              }\n\n            ping_num_trans=0;\n\n            if (matte != MagickFalse)\n              {\n                /*\n                 * Set up trans_colors array.\n                 */\n                assert(number_colors <= 256);\n\n                ping_num_trans=(unsigned short) (number_transparent +\n                  number_semitransparent);\n\n                if (ping_num_trans == 0)\n                  ping_have_tRNS=MagickFalse;\n\n                else\n                  {\n                    if (logging != MagickFalse)\n                      {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Scaling ping_trans_color (1)\");\n                      }\n                    ping_have_tRNS=MagickTrue;\n\n                    for (i=0; i < ping_num_trans; i++)\n                    {\n                       ping_trans_alpha[i]= (png_byte)\n                         ScaleQuantumToChar(image->colormap[i].alpha);\n                    }\n                  }\n              }\n          }\n      }\n\n    else\n      {\n\n        if (image_depth < 8)\n          image_depth=8;\n\n        if ((save_image_depth == 16) && (image_depth == 8))\n          {\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Scaling ping_trans_color from (%d,%d,%d)\",\n                  (int) ping_trans_color.red,\n                  (int) ping_trans_color.green,\n                  (int) ping_trans_color.blue);\n              }\n\n            ping_trans_color.red*=0x0101;\n            ping_trans_color.green*=0x0101;\n            ping_trans_color.blue*=0x0101;\n            ping_trans_color.gray*=0x0101;\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    to (%d,%d,%d)\",\n                  (int) ping_trans_color.red,\n                  (int) ping_trans_color.green,\n                  (int) ping_trans_color.blue);\n              }\n          }\n      }\n\n    if (ping_bit_depth <  (ssize_t) mng_info->write_png_depth)\n         ping_bit_depth =  (ssize_t) mng_info->write_png_depth;\n\n    /*\n      Adjust background and transparency samples in sub-8-bit grayscale files.\n    */\n    if (ping_bit_depth < 8 && ping_color_type ==\n        PNG_COLOR_TYPE_GRAY)\n      {\n         png_uint_16\n           maxval;\n\n         size_t\n           one=1;\n\n         maxval=(png_uint_16) ((one << ping_bit_depth)-1);\n\n         if (ping_exclude_bKGD == MagickFalse)\n         {\n\n         ping_background.gray=(png_uint_16) ((maxval/65535.)*\n           (ScaleQuantumToShort(((GetPixelInfoIntensity(image,\n           &image->background_color))) +.5)));\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Setting up bKGD chunk (2)\");\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      background_color index is %d\",\n             (int) ping_background.index);\n\n         ping_have_bKGD = MagickTrue;\n         }\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Scaling ping_trans_color.gray from %d\",\n             (int)ping_trans_color.gray);\n\n         ping_trans_color.gray=(png_uint_16) ((maxval/255.)*(\n           ping_trans_color.gray)+.5);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      to %d\", (int)ping_trans_color.gray);\n      }\n\n  if (ping_exclude_bKGD == MagickFalse)\n  {\n    if (mng_info->IsPalette && (int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n      {\n        /*\n           Identify which colormap entry is the background color.\n        */\n\n        number_colors=image_colors;\n\n        for (i=0; i < (ssize_t) MagickMax(1L*number_colors,1L); i++)\n          if (IsPNGColorEqual(image->background_color,image->colormap[i]))\n            break;\n\n        ping_background.index=(png_byte) i;\n\n        if (logging != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Setting up bKGD chunk with index=%d\",(int) i);\n          }\n\n        if (i < (ssize_t) number_colors)\n          {\n            ping_have_bKGD = MagickTrue;\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"     background   =(%d,%d,%d)\",\n                        (int) ping_background.red,\n                        (int) ping_background.green,\n                        (int) ping_background.blue);\n              }\n          }\n\n        else  /* Can't happen */\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      No room in PLTE to add bKGD color\");\n            ping_have_bKGD = MagickFalse;\n          }\n      }\n  }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    PNG color type: %s (%d)\", PngColorTypeToString(ping_color_type),\n      ping_color_type);\n  /*\n    Initialize compression level and filtering.\n  */\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Setting up deflate compression\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Compression buffer size: 32768\");\n    }\n\n  png_set_compression_buffer_size(ping,32768L);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Compression mem level: 9\");\n\n  png_set_compression_mem_level(ping, 9);\n\n  /* Untangle the \"-quality\" setting:\n\n     Undefined is 0; the default is used.\n     Default is 75\n\n     10's digit:\n\n        0 or omitted: Use Z_HUFFMAN_ONLY strategy with the\n           zlib default compression level\n\n        1-9: the zlib compression level\n\n     1's digit:\n\n        0-4: the PNG filter method\n\n        5:   libpng adaptive filtering if compression level > 5\n             libpng filter type \"none\" if compression level <= 5\n                or if image is grayscale or palette\n\n        6:   libpng adaptive filtering\n\n        7:   \"LOCO\" filtering (intrapixel differing) if writing\n             a MNG, otherwise \"none\".  Did not work in IM-6.7.0-9\n             and earlier because of a missing \"else\".\n\n        8:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), adaptive\n             filtering. Unused prior to IM-6.7.0-10, was same as 6\n\n        9:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), no PNG filters\n             Unused prior to IM-6.7.0-10, was same as 6\n\n    Note that using the -quality option, not all combinations of\n    PNG filter type, zlib compression level, and zlib compression\n    strategy are possible.  This will be addressed soon in a\n    release that accomodates \"-define png:compression-strategy\", etc.\n\n   */\n\n  quality=image_info->quality == UndefinedCompressionQuality ? 75UL :\n     image_info->quality;\n\n  if (quality <= 9)\n    {\n      if (mng_info->write_png_compression_strategy == 0)\n        mng_info->write_png_compression_strategy = Z_HUFFMAN_ONLY+1;\n    }\n\n  else if (mng_info->write_png_compression_level == 0)\n    {\n      int\n        level;\n\n      level=(int) MagickMin((ssize_t) quality/10,9);\n\n      mng_info->write_png_compression_level = level+1;\n    }\n\n  if (mng_info->write_png_compression_strategy == 0)\n    {\n        if ((quality %10) == 8 || (quality %10) == 9)\n#ifdef Z_RLE  /* Z_RLE was added to zlib-1.2.0 */\n          mng_info->write_png_compression_strategy=Z_RLE+1;\n#else\n          mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;\n#endif\n    }\n\n  if (mng_info->write_png_compression_filter == 0)\n        mng_info->write_png_compression_filter=((int) quality % 10) + 1;\n\n  if (logging != MagickFalse)\n    {\n        if (mng_info->write_png_compression_level)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Compression level:    %d\",\n            (int) mng_info->write_png_compression_level-1);\n\n        if (mng_info->write_png_compression_strategy)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Compression strategy: %d\",\n            (int) mng_info->write_png_compression_strategy-1);\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Setting up filtering\");\n\n        if (mng_info->write_png_compression_filter == 6)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: ADAPTIVE\");\n        else if (mng_info->write_png_compression_filter == 0 ||\n                 mng_info->write_png_compression_filter == 1)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: NONE\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: %d\",\n            (int) mng_info->write_png_compression_filter-1);\n    }\n\n  if (mng_info->write_png_compression_level != 0)\n    png_set_compression_level(ping,mng_info->write_png_compression_level-1);\n\n  if (mng_info->write_png_compression_filter == 6)\n    {\n      if (((int) ping_color_type == PNG_COLOR_TYPE_GRAY) ||\n         ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE) ||\n         (quality < 50))\n        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n      else\n        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);\n     }\n  else if (mng_info->write_png_compression_filter == 7 ||\n      mng_info->write_png_compression_filter == 10)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);\n\n  else if (mng_info->write_png_compression_filter == 8)\n    {\n#if defined(PNG_MNG_FEATURES_SUPPORTED) && defined(PNG_INTRAPIXEL_DIFFERENCING)\n      if (mng_info->write_mng)\n      {\n         if (((int) ping_color_type == PNG_COLOR_TYPE_RGB) ||\n             ((int) ping_color_type == PNG_COLOR_TYPE_RGBA))\n        ping_filter_method=PNG_INTRAPIXEL_DIFFERENCING;\n      }\n#endif\n      png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n    }\n\n  else if (mng_info->write_png_compression_filter == 9)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n\n  else if (mng_info->write_png_compression_filter != 0)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,\n       mng_info->write_png_compression_filter-1);\n\n  if (mng_info->write_png_compression_strategy != 0)\n    png_set_compression_strategy(ping,\n       mng_info->write_png_compression_strategy-1);\n\n  ping_interlace_method=image_info->interlace != NoInterlace;\n\n  if (mng_info->write_mng)\n    png_set_sig_bytes(ping,8);\n\n  /* Bail out if cannot meet defined png:bit-depth or png:color-type */\n\n  if (mng_info->write_png_colortype != 0)\n    {\n     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY)\n       if (ping_have_color != MagickFalse)\n         {\n           ping_color_type = PNG_COLOR_TYPE_RGB;\n\n           if (ping_bit_depth < 8)\n             ping_bit_depth=8;\n         }\n\n     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY_ALPHA)\n       if (ping_have_color != MagickFalse)\n         ping_color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n    }\n\n  if (ping_need_colortype_warning != MagickFalse ||\n     ((mng_info->write_png_depth &&\n     (int) mng_info->write_png_depth != ping_bit_depth) ||\n     (mng_info->write_png_colortype &&\n     ((int) mng_info->write_png_colortype-1 != ping_color_type &&\n      mng_info->write_png_colortype != 7 &&\n      !(mng_info->write_png_colortype == 5 && ping_color_type == 0)))))\n    {\n      if (logging != MagickFalse)\n        {\n          if (ping_need_colortype_warning != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Image has transparency but tRNS chunk was excluded\");\n            }\n\n          if (mng_info->write_png_depth)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Defined png:bit-depth=%u, Computed depth=%u\",\n                  mng_info->write_png_depth,\n                  ping_bit_depth);\n            }\n\n          if (mng_info->write_png_colortype)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Defined png:color-type=%u, Computed color type=%u\",\n                  mng_info->write_png_colortype-1,\n                  ping_color_type);\n            }\n        }\n\n      png_warning(ping,\n        \"Cannot write image with defined png:bit-depth or png:color-type.\");\n    }\n\n  if (image_matte != MagickFalse && image->alpha_trait == UndefinedPixelTrait)\n    {\n      /* Add an opaque matte channel */\n      image->alpha_trait = BlendPixelTrait;\n      (void) SetImageAlpha(image,OpaqueAlpha,exception);\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Added an opaque matte channel\");\n    }\n\n  if (number_transparent != 0 || number_semitransparent != 0)\n    {\n      if (ping_color_type < 4)\n        {\n           ping_have_tRNS=MagickTrue;\n           if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Setting ping_have_tRNS=MagickTrue.\");\n        }\n    }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Writing PNG header chunks\");\n\n  png_set_IHDR(ping,ping_info,ping_width,ping_height,\n               ping_bit_depth,ping_color_type,\n               ping_interlace_method,ping_compression_method,\n               ping_filter_method);\n\n  if (ping_color_type == 3 && ping_have_PLTE != MagickFalse)\n    {\n      png_set_PLTE(ping,ping_info,palette,number_colors);\n\n      if (logging != MagickFalse)\n        {\n          for (i=0; i< (ssize_t) number_colors; i++)\n          {\n            if (i < ping_num_trans)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"     PLTE[%d] = (%d,%d,%d), tRNS[%d] = (%d)\",\n                      (int) i,\n                      (int) palette[i].red,\n                      (int) palette[i].green,\n                      (int) palette[i].blue,\n                      (int) i,\n                      (int) ping_trans_alpha[i]);\n             else\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"     PLTE[%d] = (%d,%d,%d)\",\n                      (int) i,\n                      (int) palette[i].red,\n                      (int) palette[i].green,\n                      (int) palette[i].blue);\n           }\n         }\n    }\n\n  /* Only write the iCCP chunk if we are not writing the sRGB chunk. */\n  if (ping_exclude_sRGB != MagickFalse ||\n     (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n  {\n    if ((ping_exclude_tEXt == MagickFalse ||\n       ping_exclude_zTXt == MagickFalse) &&\n       (ping_exclude_iCCP == MagickFalse || ping_exclude_zCCP == MagickFalse))\n    {\n      ResetImageProfileIterator(image);\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        profile=GetImageProfile(image,name);\n\n        if (profile != (StringInfo *) NULL)\n          {\n#ifdef PNG_WRITE_iCCP_SUPPORTED\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0))\n              {\n                ping_have_iCCP = MagickTrue;\n                if (ping_exclude_iCCP == MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Setting up iCCP chunk\");\n\n                    png_set_iCCP(ping,ping_info,(png_charp) name,0,\n#if (PNG_LIBPNG_VER < 10500)\n                    (png_charp) GetStringInfoDatum(profile),\n#else\n                    (const png_byte *) GetStringInfoDatum(profile),\n#endif\n                    (png_uint_32) GetStringInfoLength(profile));\n                  }\n                else\n                  {\n                    /* Do not write hex-encoded ICC chunk */\n                       name=GetNextImageProfile(image);\n                       continue;\n                  }\n              }\n#endif /* WRITE_iCCP */\n\n            if (LocaleCompare(name,\"exif\") == 0)\n              {\n                   /* Do not write hex-encoded ICC chunk; we will\n                      write it later as an eXIf chunk */\n                   name=GetNextImageProfile(image);\n                   continue;\n              }\n\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Setting up zTXt chunk with uuencoded %s profile\",\n                 name);\n              Magick_png_write_raw_profile(image_info,ping,ping_info,\n                (unsigned char *) name,(unsigned char *) name,\n                GetStringInfoDatum(profile),\n                (png_uint_32) GetStringInfoLength(profile));\n          }\n        name=GetNextImageProfile(image);\n      }\n    }\n  }\n\n#if defined(PNG_WRITE_sRGB_SUPPORTED)\n  if ((mng_info->have_write_global_srgb == 0) &&\n      ping_have_iCCP != MagickTrue &&\n      (ping_have_sRGB != MagickFalse ||\n      png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n    {\n      if (ping_exclude_sRGB == MagickFalse)\n        {\n          /*\n            Note image rendering intent.\n          */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Setting up sRGB chunk\");\n\n          (void) png_set_sRGB(ping,ping_info,(\n            Magick_RenderingIntent_to_PNG_RenderingIntent(\n              image->rendering_intent)));\n\n          ping_have_sRGB = MagickTrue;\n        }\n    }\n\n  if ((!mng_info->write_mng) || (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n#endif\n    {\n      if (ping_exclude_gAMA == MagickFalse &&\n          ping_have_iCCP == MagickFalse &&\n          ping_have_sRGB == MagickFalse &&\n          (ping_exclude_sRGB == MagickFalse ||\n          (image->gamma < .45 || image->gamma > .46)))\n      {\n      if ((mng_info->have_write_global_gama == 0) && (image->gamma != 0.0))\n        {\n          /*\n            Note image gamma.\n            To do: check for cHRM+gAMA == sRGB, and write sRGB instead.\n          */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Setting up gAMA chunk\");\n\n          png_set_gAMA(ping,ping_info,image->gamma);\n        }\n      }\n\n      if (ping_exclude_cHRM == MagickFalse && ping_have_sRGB == MagickFalse)\n        {\n          if ((mng_info->have_write_global_chrm == 0) &&\n              (image->chromaticity.red_primary.x != 0.0))\n            {\n              /*\n                Note image chromaticity.\n                Note: if cHRM+gAMA == sRGB write sRGB instead.\n              */\n               PrimaryInfo\n                 bp,\n                 gp,\n                 rp,\n                 wp;\n\n               wp=image->chromaticity.white_point;\n               rp=image->chromaticity.red_primary;\n               gp=image->chromaticity.green_primary;\n               bp=image->chromaticity.blue_primary;\n\n               if (logging != MagickFalse)\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Setting up cHRM chunk\");\n\n               png_set_cHRM(ping,ping_info,wp.x,wp.y,rp.x,rp.y,gp.x,gp.y,\n                   bp.x,bp.y);\n           }\n        }\n    }\n\n  if (ping_exclude_bKGD == MagickFalse)\n    {\n      if (ping_have_bKGD != MagickFalse)\n        {\n          png_set_bKGD(ping,ping_info,&ping_background);\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Setting up bKGD chunk\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      background color = (%d,%d,%d)\",\n                        (int) ping_background.red,\n                        (int) ping_background.green,\n                        (int) ping_background.blue);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      index = %d, gray=%d\",\n                        (int) ping_background.index,\n                        (int) ping_background.gray);\n            }\n         }\n    }\n\n  if (ping_exclude_pHYs == MagickFalse)\n    {\n      if (ping_have_pHYs != MagickFalse)\n        {\n          png_set_pHYs(ping,ping_info,\n             ping_pHYs_x_resolution,\n             ping_pHYs_y_resolution,\n             ping_pHYs_unit_type);\n\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Setting up pHYs chunk\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      x_resolution=%lu\",\n                   (unsigned long) ping_pHYs_x_resolution);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      y_resolution=%lu\",\n                   (unsigned long) ping_pHYs_y_resolution);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      unit_type=%lu\",\n                   (unsigned long) ping_pHYs_unit_type);\n            }\n        }\n    }\n\n#if defined(PNG_tIME_SUPPORTED)\n  if (ping_exclude_tIME == MagickFalse)\n    {\n      const char\n        *timestamp;\n\n      if (image->taint == MagickFalse)\n        {\n          timestamp=GetImageOption(image_info,\"png:tIME\");\n\n          if (timestamp == (const char *) NULL)\n            timestamp=GetImageProperty(image,\"png:tIME\",exception);\n        }\n\n      else\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Reset tIME in tainted image\");\n\n          timestamp=GetImageProperty(image,\"date:modify\",exception);\n        }\n\n      if (timestamp != (const char *) NULL)\n          write_tIME_chunk(image,ping,ping_info,timestamp,exception);\n    }\n#endif\n\n  if (mng_info->need_blob != MagickFalse)\n  {\n    if (OpenBlob(image_info,image,WriteBinaryBlobMode,exception) ==\n       MagickFalse)\n       png_error(ping,\"WriteBlob Failed\");\n\n     ping_have_blob=MagickTrue;\n  }\n\n  png_write_info_before_PLTE(ping, ping_info);\n\n  if (ping_have_tRNS != MagickFalse && ping_color_type < 4)\n    {\n      if (logging != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Calling png_set_tRNS with num_trans=%d\",ping_num_trans);\n        }\n\n      if (ping_color_type == 3)\n         (void) png_set_tRNS(ping, ping_info,\n                ping_trans_alpha,\n                ping_num_trans,\n                NULL);\n\n      else\n        {\n           (void) png_set_tRNS(ping, ping_info,\n                  NULL,\n                  0,\n                  &ping_trans_color);\n\n           if (logging != MagickFalse)\n             {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"     tRNS color   =(%d,%d,%d)\",\n                       (int) ping_trans_color.red,\n                       (int) ping_trans_color.green,\n                       (int) ping_trans_color.blue);\n             }\n         }\n    }\n\n  /* write any png-chunk-b profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-b\",logging);\n\n  png_write_info(ping,ping_info);\n\n  /* write any PNG-chunk-m profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-m\",logging);\n\n  ping_wrote_caNv = MagickFalse;\n\n  /* write caNv chunk */\n  if (ping_exclude_caNv == MagickFalse)\n    {\n      if ((image->page.width != 0 && image->page.width != image->columns) ||\n          (image->page.height != 0 && image->page.height != image->rows) ||\n          image->page.x != 0 || image->page.y != 0)\n        {\n          unsigned char\n            chunk[20];\n\n          (void) WriteBlobMSBULong(image,16L);  /* data length=8 */\n          PNGType(chunk,mng_caNv);\n          LogPNGChunk(logging,mng_caNv,16L);\n          PNGLong(chunk+4,(png_uint_32) image->page.width);\n          PNGLong(chunk+8,(png_uint_32) image->page.height);\n          PNGsLong(chunk+12,(png_int_32) image->page.x);\n          PNGsLong(chunk+16,(png_int_32) image->page.y);\n          (void) WriteBlob(image,20,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,20));\n          ping_wrote_caNv = MagickTrue;\n        }\n    }\n\n#if defined(PNG_oFFs_SUPPORTED)\n  if (ping_exclude_oFFs == MagickFalse && ping_wrote_caNv == MagickFalse)\n    {\n      if (image->page.x || image->page.y)\n        {\n           png_set_oFFs(ping,ping_info,(png_int_32) image->page.x,\n              (png_int_32) image->page.y, 0);\n\n           if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Setting up oFFs chunk with x=%d, y=%d, units=0\",\n                 (int) image->page.x, (int) image->page.y);\n        }\n    }\n#endif\n\n  /* write vpAg chunk (deprecated, replaced by caNv) */\n  if (ping_exclude_vpAg == MagickFalse && ping_wrote_caNv == MagickFalse)\n    {\n      if ((image->page.width != 0 && image->page.width != image->columns) ||\n          (image->page.height != 0 && image->page.height != image->rows))\n        {\n          unsigned char\n            chunk[14];\n\n          (void) WriteBlobMSBULong(image,9L);  /* data length=8 */\n          PNGType(chunk,mng_vpAg);\n          LogPNGChunk(logging,mng_vpAg,9L);\n          PNGLong(chunk+4,(png_uint_32) image->page.width);\n          PNGLong(chunk+8,(png_uint_32) image->page.height);\n          chunk[12]=0;   /* unit = pixels */\n          (void) WriteBlob(image,13,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,13));\n        }\n    }\n\n#if (PNG_LIBPNG_VER == 10206)\n    /* avoid libpng-1.2.6 bug by setting PNG_HAVE_IDAT flag */\n#define PNG_HAVE_IDAT               0x04\n    ping->mode |= PNG_HAVE_IDAT;\n#undef PNG_HAVE_IDAT\n#endif\n\n  png_set_packing(ping);\n  /*\n    Allocate memory.\n  */\n  rowbytes=image->columns;\n  if (image_depth > 8)\n    rowbytes*=2;\n  switch (ping_color_type)\n    {\n      case PNG_COLOR_TYPE_RGB:\n        rowbytes*=3;\n        break;\n\n      case PNG_COLOR_TYPE_GRAY_ALPHA:\n        rowbytes*=2;\n        break;\n\n      case PNG_COLOR_TYPE_RGBA:\n        rowbytes*=4;\n        break;\n\n      default:\n        break;\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Writing PNG image data\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Allocating %.20g bytes of memory for pixels\",(double) rowbytes);\n    }\n  pixel_info=AcquireVirtualMemory(rowbytes,sizeof(*ping_pixels));\n  if (pixel_info == (MemoryInfo *) NULL)\n    png_error(ping,\"Allocation of memory for pixels failed\");\n  ping_pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n\n  /*\n    Initialize image scanlines.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    png_error(ping,\"Memory allocation for quantum_info failed\");\n  quantum_info->format=UndefinedQuantumFormat;\n  SetQuantumDepth(image,quantum_info,image_depth);\n  (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n  num_passes=png_set_interlace_handling(ping);\n\n  if ((!mng_info->write_png8 && !mng_info->write_png24 &&\n       !mng_info->write_png48 && !mng_info->write_png64 &&\n       !mng_info->write_png32) &&\n       (mng_info->IsPalette ||\n       (image_info->type == BilevelType)) &&\n       image_matte == MagickFalse &&\n       ping_have_non_bw == MagickFalse)\n    {\n      /* Palette, Bilevel, or Opaque Monochrome */\n      register const Quantum\n        *p;\n\n      SetQuantumDepth(image,quantum_info,8);\n      for (pass=0; pass < num_passes; pass++)\n      {\n        /*\n          Convert PseudoClass image to a PNG monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          if (logging != MagickFalse && y == 0)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Writing row of pixels (0)\");\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n          if (p == (const Quantum *) NULL)\n            break;\n\n          if (mng_info->IsPalette)\n            {\n              (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                quantum_info,GrayQuantum,ping_pixels,exception);\n              if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_PALETTE &&\n                  mng_info->write_png_depth &&\n                  mng_info->write_png_depth != old_bit_depth)\n                {\n                  /* Undo pixel scaling */\n                  for (i=0; i < (ssize_t) image->columns; i++)\n                     *(ping_pixels+i)=(unsigned char) (*(ping_pixels+i)\n                     >> (8-old_bit_depth));\n                }\n            }\n\n          else\n            {\n              (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                quantum_info,RedQuantum,ping_pixels,exception);\n            }\n\n          if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE)\n            for (i=0; i < (ssize_t) image->columns; i++)\n               *(ping_pixels+i)=(unsigned char) ((*(ping_pixels+i) > 127) ?\n                      255 : 0);\n\n          if (logging != MagickFalse && y == 0)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Writing row of pixels (1)\");\n\n          png_write_row(ping,ping_pixels);\n\n          status=SetImageProgress(image,SaveImageTag,\n              (MagickOffsetType) (pass * image->rows + y),\n              num_passes * image->rows);\n\n          if (status == MagickFalse)\n            break;\n        }\n      }\n    }\n\n  else   /* Not Palette, Bilevel, or Opaque Monochrome */\n    {\n      if ((!mng_info->write_png8 && !mng_info->write_png24 &&\n          !mng_info->write_png48 && !mng_info->write_png64 &&\n          !mng_info->write_png32) && (image_matte != MagickFalse ||\n          (ping_bit_depth >= MAGICKCORE_QUANTUM_DEPTH)) &&\n          (mng_info->IsPalette) && ping_have_color == MagickFalse)\n        {\n          register const Quantum\n            *p;\n\n          for (pass=0; pass < num_passes; pass++)\n          {\n\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n            if (p == (const Quantum *) NULL)\n              break;\n\n            if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n              {\n                if (mng_info->IsPalette)\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,GrayQuantum,ping_pixels,exception);\n\n                else\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RedQuantum,ping_pixels,exception);\n\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"    Writing GRAY PNG pixels (2)\");\n              }\n\n            else /* PNG_COLOR_TYPE_GRAY_ALPHA */\n              {\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Writing GRAY_ALPHA PNG pixels (2)\");\n\n                (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,GrayAlphaQuantum,ping_pixels,exception);\n              }\n\n            if (logging != MagickFalse && y == 0)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Writing row of pixels (2)\");\n\n            png_write_row(ping,ping_pixels);\n\n            status=SetImageProgress(image,SaveImageTag,\n              (MagickOffsetType) (pass * image->rows + y),\n              num_passes * image->rows);\n\n            if (status == MagickFalse)\n              break;\n            }\n          }\n        }\n\n      else\n        {\n          register const Quantum\n            *p;\n\n          for (pass=0; pass < num_passes; pass++)\n          {\n            if ((image_depth > 8) ||\n                mng_info->write_png24 ||\n                mng_info->write_png32 ||\n                mng_info->write_png48 ||\n                mng_info->write_png64 ||\n                (!mng_info->write_png8 && !mng_info->IsPalette))\n            {\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n                if (p == (const Quantum *) NULL)\n                  break;\n\n                if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n                  {\n                    if (image->storage_class == DirectClass)\n                      (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                        quantum_info,RedQuantum,ping_pixels,exception);\n\n                    else\n                      (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                        quantum_info,GrayQuantum,ping_pixels,exception);\n                  }\n\n                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n                  {\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                      quantum_info,GrayAlphaQuantum,ping_pixels,\n                      exception);\n\n                    if (logging != MagickFalse && y == 0)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"    Writing GRAY_ALPHA PNG pixels (3)\");\n                  }\n\n                else if (image_matte != MagickFalse)\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RGBAQuantum,ping_pixels,exception);\n\n                else\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RGBQuantum,ping_pixels,exception);\n\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"    Writing row of pixels (3)\");\n\n                png_write_row(ping,ping_pixels);\n\n                status=SetImageProgress(image,SaveImageTag,\n                  (MagickOffsetType) (pass * image->rows + y),\n                  num_passes * image->rows);\n\n                if (status == MagickFalse)\n                  break;\n              }\n            }\n\n          else\n            /* not ((image_depth > 8) ||\n                mng_info->write_png24 || mng_info->write_png32 ||\n                mng_info->write_png48 || mng_info->write_png64 ||\n                (!mng_info->write_png8 && !mng_info->IsPalette))\n             */\n            {\n              if ((ping_color_type != PNG_COLOR_TYPE_GRAY) &&\n                  (ping_color_type != PNG_COLOR_TYPE_GRAY_ALPHA))\n                {\n                  if (logging != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"  pass %d, Image Is not GRAY or GRAY_ALPHA\",pass);\n\n                  SetQuantumDepth(image,quantum_info,8);\n                  image_depth=8;\n                }\n\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  pass %d, Image Is RGB, 16-bit GRAY, or GRAY_ALPHA\",\n                    pass);\n\n                p=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n                if (p == (const Quantum *) NULL)\n                  break;\n\n                if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n                  {\n                    SetQuantumDepth(image,quantum_info,image->depth);\n\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                       quantum_info,GrayQuantum,ping_pixels,exception);\n                  }\n\n                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n                  {\n                    if (logging != MagickFalse && y == 0)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"  Writing GRAY_ALPHA PNG pixels (4)\");\n\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                         quantum_info,GrayAlphaQuantum,ping_pixels,\n                         exception);\n                  }\n\n                else\n                  {\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                      quantum_info,IndexQuantum,ping_pixels,exception);\n\n                    if (logging != MagickFalse && y <= 2)\n                    {\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Writing row of non-gray pixels (4)\");\n\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  ping_pixels[0]=%d,ping_pixels[1]=%d\",\n                          (int)ping_pixels[0],(int)ping_pixels[1]);\n                    }\n                  }\n                png_write_row(ping,ping_pixels);\n\n                status=SetImageProgress(image,SaveImageTag,\n                  (MagickOffsetType) (pass * image->rows + y),\n                  num_passes * image->rows);\n\n                if (status == MagickFalse)\n                  break;\n              }\n            }\n          }\n        }\n    }\n\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Wrote PNG image data\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Width: %.20g\",(double) ping_width);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Height: %.20g\",(double) ping_height);\n\n      if (mng_info->write_png_depth)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Defined png:bit-depth: %d\",mng_info->write_png_depth);\n        }\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG bit-depth written: %d\",ping_bit_depth);\n\n      if (mng_info->write_png_colortype)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Defined png:color-type: %d\",mng_info->write_png_colortype-1);\n        }\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG color-type written: %d\",ping_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG Interlace method: %d\",ping_interlace_method);\n    }\n  /*\n    Generate text chunks after IDAT.\n  */\n  if (ping_exclude_tEXt == MagickFalse || ping_exclude_zTXt == MagickFalse)\n  {\n    ResetImagePropertyIterator(image);\n    property=GetNextImageProperty(image);\n    while (property != (const char *) NULL)\n    {\n      png_textp\n        text;\n\n      value=GetImageProperty(image,property,exception);\n\n      /* Don't write any \"png:\" or \"jpeg:\" properties; those are just for\n       * \"identify\" or for passing through to another JPEG\n       */\n      if ((LocaleNCompare(property,\"png:\",4) != 0 &&\n           LocaleNCompare(property,\"jpeg:\",5) != 0) &&\n\n\n          /* Suppress density and units if we wrote a pHYs chunk */\n          (ping_exclude_pHYs != MagickFalse      ||\n          LocaleCompare(property,\"density\") != 0 ||\n          LocaleCompare(property,\"units\") != 0) &&\n\n          /* Suppress the IM-generated Date:create and Date:modify */\n          (ping_exclude_date == MagickFalse      ||\n          LocaleNCompare(property, \"Date:\",5) != 0))\n        {\n        if (value != (const char *) NULL)\n          {\n\n#if PNG_LIBPNG_VER >= 10400\n            text=(png_textp) png_malloc(ping,\n                 (png_alloc_size_t) sizeof(png_text));\n#else\n            text=(png_textp) png_malloc(ping,(png_size_t) sizeof(png_text));\n#endif\n            text[0].key=(char *) property;\n            text[0].text=(char *) value;\n            text[0].text_length=strlen(value);\n\n            if (ping_exclude_tEXt != MagickFalse)\n               text[0].compression=PNG_TEXT_COMPRESSION_zTXt;\n\n            else if (ping_exclude_zTXt != MagickFalse)\n               text[0].compression=PNG_TEXT_COMPRESSION_NONE;\n\n            else\n            {\n               text[0].compression=image_info->compression == NoCompression ||\n                 (image_info->compression == UndefinedCompression &&\n                 text[0].text_length < 128) ? PNG_TEXT_COMPRESSION_NONE :\n                 PNG_TEXT_COMPRESSION_zTXt ;\n            }\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Setting up text chunk\");\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    keyword: '%s'\",text[0].key);\n              }\n\n            png_set_text(ping,ping_info,text,1);\n            png_free(ping,text);\n          }\n        }\n      property=GetNextImageProperty(image);\n    }\n  }\n\n  /* write any PNG-chunk-e profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-e\",logging);\n\n  /* write exIf profile */\n  if (ping_have_eXIf != MagickFalse && ping_exclude_eXIf == MagickFalse)\n    {\n      char\n        *name;\n\n      ResetImageProfileIterator(image);\n\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        if (LocaleCompare(name,\"exif\") == 0)\n          {\n            const StringInfo\n              *profile;\n\n            profile=GetImageProfile(image,name);\n\n            if (profile != (StringInfo *) NULL)\n              {\n                png_uint_32\n                  length;\n\n                unsigned char\n                  chunk[4],\n                  *data;\n\n               StringInfo\n                 *ping_profile;\n\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Have eXIf profile\");\n\n               ping_profile=CloneStringInfo(profile);\n               data=GetStringInfoDatum(ping_profile),\n               length=(png_uint_32) GetStringInfoLength(ping_profile);\n\n               PNGType(chunk,mng_eXIf);\n               if (length < 7)\n                 {\n                   ping_profile=DestroyStringInfo(ping_profile);\n                   break;  /* otherwise crashes */\n                 }\n\n               /* skip the \"Exif\\0\\0\" JFIF Exif Header ID */\n               length -= 6;\n\n               LogPNGChunk(logging,chunk,length);\n               (void) WriteBlobMSBULong(image,length);\n               (void) WriteBlob(image,4,chunk);\n               (void) WriteBlob(image,length,data+6);\n               (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),\n                 data+6, (uInt) length));\n               ping_profile=DestroyStringInfo(ping_profile);\n               break;\n             }\n         }\n       name=GetNextImageProfile(image);\n     }\n  }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Writing PNG end info\");\n\n  png_write_end(ping,ping_info);\n\n  if (mng_info->need_fram && (int) image->dispose == BackgroundDispose)\n    {\n      if (mng_info->page.x || mng_info->page.y ||\n          (ping_width != mng_info->page.width) ||\n          (ping_height != mng_info->page.height))\n        {\n          unsigned char\n            chunk[32];\n\n          /*\n            Write FRAM 4 with clipping boundaries followed by FRAM 1.\n          */\n          (void) WriteBlobMSBULong(image,27L);  /* data length=27 */\n          PNGType(chunk,mng_FRAM);\n          LogPNGChunk(logging,mng_FRAM,27L);\n          chunk[4]=4;\n          chunk[5]=0;  /* frame name separator (no name) */\n          chunk[6]=1;  /* flag for changing delay, for next frame only */\n          chunk[7]=0;  /* flag for changing frame timeout */\n          chunk[8]=1;  /* flag for changing frame clipping for next frame */\n          chunk[9]=0;  /* flag for changing frame sync_id */\n          PNGLong(chunk+10,(png_uint_32) (0L)); /* temporary 0 delay */\n          chunk[14]=0; /* clipping boundaries delta type */\n          PNGLong(chunk+15,(png_uint_32) (mng_info->page.x)); /* left cb */\n          PNGLong(chunk+19,\n             (png_uint_32) (mng_info->page.x + ping_width));\n          PNGLong(chunk+23,(png_uint_32) (mng_info->page.y)); /* top cb */\n          PNGLong(chunk+27,\n             (png_uint_32) (mng_info->page.y + ping_height));\n          (void) WriteBlob(image,31,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,31));\n          mng_info->old_framing_mode=4;\n          mng_info->framing_mode=1;\n        }\n\n      else\n        mng_info->framing_mode=3;\n    }\n  if (mng_info->write_mng && !mng_info->need_fram &&\n      ((int) image->dispose == 3))\n     png_error(ping, \"Cannot convert GIF with disposal method 3 to MNG-LC\");\n\n  /*\n    Free PNG resources.\n  */\n\n  png_destroy_write_struct(&ping,&ping_info);\n\n  pixel_info=RelinquishVirtualMemory(pixel_info);\n\n  if (ping_have_blob != MagickFalse)\n     (void) CloseBlob(image);\n\n  image_info=DestroyImageInfo(image_info);\n  image=DestroyImage(image);\n\n  /* Store bit depth actually written */\n  s[0]=(char) ping_bit_depth;\n  s[1]='\\0';\n\n  (void) SetImageProperty(IMimage,\"png:bit-depth-written\",s,exception);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit WriteOnePNGImage()\");\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n   /* }  for navigation to beginning of SETJMP-protected block. Revert to\n    *    Throwing an Exception when an error occurs.\n    */\n\n  return(MagickTrue);\n/*  End write one PNG image */\n\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149698,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,\n  const ImageInfo *IMimage_info,Image *IMimage,ExceptionInfo *exception)\n{\n  char\n    im_vers[32],\n    libpng_runv[32],\n    libpng_vers[32],\n    zlib_runv[32],\n    zlib_vers[32];\n\n  Image\n    *image;\n\n  ImageInfo\n    *image_info;\n\n  char\n    s[2];\n\n  const char\n    *name,\n    *property,\n    *value;\n\n  const StringInfo\n    *profile;\n\n  int\n    num_passes,\n    pass,\n    ping_wrote_caNv;\n\n  png_byte\n     ping_trans_alpha[256];\n\n  png_color\n     palette[257];\n\n  png_color_16\n    ping_background,\n    ping_trans_color;\n\n  png_info\n    *ping_info;\n\n  png_struct\n    *ping;\n\n  png_uint_32\n    ping_height,\n    ping_width;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    image_matte,\n    logging,\n    matte,\n\n    ping_have_blob,\n    ping_have_cheap_transparency,\n    ping_have_color,\n    ping_have_non_bw,\n    ping_have_PLTE,\n    ping_have_bKGD,\n    ping_have_eXIf,\n    ping_have_iCCP,\n    ping_have_pHYs,\n    ping_have_sRGB,\n    ping_have_tRNS,\n\n    ping_exclude_bKGD,\n    ping_exclude_cHRM,\n    ping_exclude_date,\n    /* ping_exclude_EXIF, */\n    ping_exclude_eXIf,\n    ping_exclude_gAMA,\n    ping_exclude_iCCP,\n    /* ping_exclude_iTXt, */\n    ping_exclude_oFFs,\n    ping_exclude_pHYs,\n    ping_exclude_sRGB,\n    ping_exclude_tEXt,\n    ping_exclude_tIME,\n    /* ping_exclude_tRNS, */\n    ping_exclude_vpAg,\n    ping_exclude_caNv,\n    ping_exclude_zCCP, /* hex-encoded iCCP */\n    ping_exclude_zTXt,\n\n    ping_preserve_colormap,\n    ping_preserve_iCCP,\n    ping_need_colortype_warning,\n\n    status,\n    tried_332,\n    tried_333,\n    tried_444;\n\n  MemoryInfo\n    *volatile pixel_info;\n\n  QuantumInfo\n    *quantum_info;\n\n  PNGErrorInfo\n    error_info;\n\n  register ssize_t\n    i,\n    x;\n\n  unsigned char\n    *ping_pixels;\n\n  volatile int\n    image_colors,\n    ping_bit_depth,\n    ping_color_type,\n    ping_interlace_method,\n    ping_compression_method,\n    ping_filter_method,\n    ping_num_trans;\n\n  volatile size_t\n    image_depth,\n    old_bit_depth;\n\n  size_t\n    quality,\n    rowbytes,\n    save_image_depth;\n\n  int\n    j,\n    number_colors,\n    number_opaque,\n    number_semitransparent,\n    number_transparent,\n    ping_pHYs_unit_type;\n\n  png_uint_32\n    ping_pHYs_x_resolution,\n    ping_pHYs_y_resolution;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter WriteOnePNGImage()\");\n\n  image = CloneImage(IMimage,0,0,MagickFalse,exception);\n  if (image == (Image *) NULL)\n    return(MagickFalse);\n  image_info=(ImageInfo *) CloneImageInfo(IMimage_info);\n  if (image_info == (ImageInfo *) NULL)\n    ThrowWriterException(ResourceLimitError, \"MemoryAllocationFailed\");\n\n  /* Define these outside of the following \"if logging()\" block so they will\n   * show in debuggers.\n   */\n  *im_vers='\\0';\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibVersionText,MagickPathExtent);\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibAddendum,MagickPathExtent);\n\n  *libpng_vers='\\0';\n  (void) ConcatenateMagickString(libpng_vers,\n         PNG_LIBPNG_VER_STRING,32);\n  *libpng_runv='\\0';\n  (void) ConcatenateMagickString(libpng_runv,\n         png_get_libpng_ver(NULL),32);\n\n  *zlib_vers='\\0';\n  (void) ConcatenateMagickString(zlib_vers,\n         ZLIB_VERSION,32);\n  *zlib_runv='\\0';\n  (void) ConcatenateMagickString(zlib_runv,\n         zlib_version,32);\n\n  if (logging != MagickFalse)\n    {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    IM version     = %s\",\n           im_vers);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Libpng version = %s\",\n           libpng_vers);\n       if (LocaleCompare(libpng_vers,libpng_runv) != 0)\n       {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n           libpng_runv);\n       }\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Zlib version   = %s\",\n           zlib_vers);\n       if (LocaleCompare(zlib_vers,zlib_runv) != 0)\n       {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n           zlib_runv);\n       }\n    }\n\n  /* Initialize some stuff */\n  ping_bit_depth=0,\n  ping_color_type=0,\n  ping_interlace_method=0,\n  ping_compression_method=0,\n  ping_filter_method=0,\n  ping_num_trans = 0;\n\n  ping_background.red = 0;\n  ping_background.green = 0;\n  ping_background.blue = 0;\n  ping_background.gray = 0;\n  ping_background.index = 0;\n\n  ping_trans_color.red=0;\n  ping_trans_color.green=0;\n  ping_trans_color.blue=0;\n  ping_trans_color.gray=0;\n\n  ping_pHYs_unit_type = 0;\n  ping_pHYs_x_resolution = 0;\n  ping_pHYs_y_resolution = 0;\n\n  ping_have_blob=MagickFalse;\n  ping_have_cheap_transparency=MagickFalse;\n  ping_have_color=MagickTrue;\n  ping_have_non_bw=MagickTrue;\n  ping_have_PLTE=MagickFalse;\n  ping_have_bKGD=MagickFalse;\n  ping_have_eXIf=MagickTrue;\n  ping_have_iCCP=MagickFalse;\n  ping_have_pHYs=MagickFalse;\n  ping_have_sRGB=MagickFalse;\n  ping_have_tRNS=MagickFalse;\n\n  ping_exclude_bKGD=mng_info->ping_exclude_bKGD;\n  ping_exclude_caNv=mng_info->ping_exclude_caNv;\n  ping_exclude_cHRM=mng_info->ping_exclude_cHRM;\n  ping_exclude_date=mng_info->ping_exclude_date;\n  ping_exclude_eXIf=mng_info->ping_exclude_eXIf;\n  ping_exclude_gAMA=mng_info->ping_exclude_gAMA;\n  ping_exclude_iCCP=mng_info->ping_exclude_iCCP;\n  /* ping_exclude_iTXt=mng_info->ping_exclude_iTXt; */\n  ping_exclude_oFFs=mng_info->ping_exclude_oFFs;\n  ping_exclude_pHYs=mng_info->ping_exclude_pHYs;\n  ping_exclude_sRGB=mng_info->ping_exclude_sRGB;\n  ping_exclude_tEXt=mng_info->ping_exclude_tEXt;\n  ping_exclude_tIME=mng_info->ping_exclude_tIME;\n  /* ping_exclude_tRNS=mng_info->ping_exclude_tRNS; */\n  ping_exclude_vpAg=mng_info->ping_exclude_vpAg;\n  ping_exclude_zCCP=mng_info->ping_exclude_zCCP; /* hex-encoded iCCP in zTXt */\n  ping_exclude_zTXt=mng_info->ping_exclude_zTXt;\n\n  ping_preserve_colormap = mng_info->ping_preserve_colormap;\n  ping_preserve_iCCP = mng_info->ping_preserve_iCCP;\n  ping_need_colortype_warning = MagickFalse;\n\n  /* Recognize the ICC sRGB profile and convert it to the sRGB chunk,\n   * i.e., eliminate the ICC profile and set image->rendering_intent.\n   * Note that this will not involve any changes to the actual pixels\n   * but merely passes information to applications that read the resulting\n   * PNG image.\n   *\n   * To do: recognize other variants of the sRGB profile, using the CRC to\n   * verify all recognized variants including the 7 already known.\n   *\n   * Work around libpng16+ rejecting some \"known invalid sRGB profiles\".\n   *\n   * Use something other than image->rendering_intent to record the fact\n   * that the sRGB profile was found.\n   *\n   * Record the ICC version (currently v2 or v4) of the incoming sRGB ICC\n   * profile.  Record the Blackpoint Compensation, if any.\n   */\n   if (ping_exclude_sRGB == MagickFalse && ping_preserve_iCCP == MagickFalse)\n   {\n      char\n        *name;\n\n      const StringInfo\n        *profile;\n\n      ResetImageProfileIterator(image);\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        profile=GetImageProfile(image,name);\n\n        if (profile != (StringInfo *) NULL)\n          {\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0))\n\n             {\n                 int\n                   icheck,\n                   got_crc=0;\n\n\n                 png_uint_32\n                   length,\n                   profile_crc=0;\n\n                 unsigned char\n                   *data;\n\n                 length=(png_uint_32) GetStringInfoLength(profile);\n\n                 for (icheck=0; sRGB_info[icheck].len > 0; icheck++)\n                 {\n                   if (length == sRGB_info[icheck].len)\n                   {\n                     if (got_crc == 0)\n                     {\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Got a %lu-byte ICC profile (potentially sRGB)\",\n                         (unsigned long) length);\n\n                       data=GetStringInfoDatum(profile);\n                       profile_crc=crc32(0,data,length);\n\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"      with crc=%8x\",(unsigned int) profile_crc);\n                       got_crc++;\n                     }\n\n                     if (profile_crc == sRGB_info[icheck].crc)\n                     {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"      It is sRGB with rendering intent = %s\",\n                        Magick_RenderingIntentString_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent));\n                        if (image->rendering_intent==UndefinedIntent)\n                        {\n                          image->rendering_intent=\n                          Magick_RenderingIntent_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent);\n                        }\n                        ping_exclude_iCCP = MagickTrue;\n                        ping_exclude_zCCP = MagickTrue;\n                        ping_have_sRGB = MagickTrue;\n                        break;\n                     }\n                   }\n                 }\n                 if (sRGB_info[icheck].len == 0)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"    Got %lu-byte ICC profile not recognized as sRGB\",\n                        (unsigned long) length);\n              }\n          }\n        name=GetNextImageProfile(image);\n      }\n  }\n\n  number_opaque = 0;\n  number_semitransparent = 0;\n  number_transparent = 0;\n\n  if (logging != MagickFalse)\n    {\n      if (image->storage_class == UndefinedClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=UndefinedClass\");\n      if (image->storage_class == DirectClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=DirectClass\");\n      if (image->storage_class == PseudoClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=PseudoClass\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(), image->taint ?\n          \"    image->taint=MagickTrue\":\n          \"    image->taint=MagickFalse\");\n    }\n\n  if (image->storage_class == PseudoClass &&\n     (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32 ||\n     mng_info->write_png48 || mng_info->write_png64 ||\n     (mng_info->write_png_colortype != 1 &&\n     mng_info->write_png_colortype != 5)))\n    {\n      (void) SyncImage(image,exception);\n      image->storage_class = DirectClass;\n    }\n\n  if (ping_preserve_colormap == MagickFalse)\n    {\n      if (image->storage_class != PseudoClass && image->colormap != NULL)\n        {\n          /* Free the bogus colormap; it can cause trouble later */\n           if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Freeing bogus colormap\");\n           (void) RelinquishMagickMemory(image->colormap);\n           image->colormap=NULL;\n        }\n    }\n\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n\n  /*\n    Sometimes we get PseudoClass images whose RGB values don't match\n    the colors in the colormap.  This code syncs the RGB values.\n  */\n  if (image->depth <= 8 && image->taint && image->storage_class == PseudoClass)\n     (void) SyncImage(image,exception);\n\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n  if (image->depth > 8)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Reducing PNG bit depth to 8 since this is a Q8 build.\");\n\n      image->depth=8;\n    }\n#endif\n\n  /* Respect the -depth option */\n  if (image->depth < 4)\n    {\n       register Quantum\n         *r;\n\n       if (image->depth > 2)\n         {\n           /* Scale to 4-bit */\n           LBR04PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR04PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR04PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n       else if (image->depth > 1)\n         {\n           /* Scale to 2-bit */\n           LBR02PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR02PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR02PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n       else\n         {\n           /* Scale to 1-bit */\n           LBR01PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR01PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR01PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n    }\n\n  /* To do: set to next higher multiple of 8 */\n  if (image->depth < 8)\n     image->depth=8;\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n  /* PNG does not handle depths greater than 16 so reduce it even\n   * if lossy\n   */\n  if (image->depth > 8)\n      image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\n  if (image->depth > 8)\n    {\n      /* To do: fill low byte properly */\n      image->depth=16;\n    }\n\n  if (image->depth == 16 && mng_info->write_png_depth != 16)\n    if (mng_info->write_png8 ||\n        LosslessReduceDepthOK(image,exception) != MagickFalse)\n      image->depth = 8;\n#endif\n\n  image_colors = (int) image->colors;\n  number_opaque = (int) image->colors;\n  number_transparent = 0;\n  number_semitransparent = 0;\n\n  if (mng_info->write_png_colortype &&\n     (mng_info->write_png_colortype > 4 || (mng_info->write_png_depth >= 8 &&\n     mng_info->write_png_colortype < 4 &&\n     image->alpha_trait == UndefinedPixelTrait)))\n  {\n     /* Avoid the expensive BUILD_PALETTE operation if we're sure that we\n      * are not going to need the result.\n      */\n     if (mng_info->write_png_colortype == 1 ||\n        mng_info->write_png_colortype == 5)\n       ping_have_color=MagickFalse;\n\n     if (image->alpha_trait != UndefinedPixelTrait)\n       {\n         number_transparent = 2;\n         number_semitransparent = 1;\n       }\n  }\n\n  if (mng_info->write_png_colortype < 7)\n  {\n  /* BUILD_PALETTE\n   *\n   * Normally we run this just once, but in the case of writing PNG8\n   * we reduce the transparency to binary and run again, then if there\n   * are still too many colors we reduce to a simple 4-4-4-1, then 3-3-3-1\n   * RGBA palette and run again, and then to a simple 3-3-2-1 RGBA\n   * palette.  Then (To do) we take care of a final reduction that is only\n   * needed if there are still 256 colors present and one of them has both\n   * transparent and opaque instances.\n   */\n\n  tried_332 = MagickFalse;\n  tried_333 = MagickFalse;\n  tried_444 = MagickFalse;\n\n  for (j=0; j<6; j++)\n  {\n    /*\n     * Sometimes we get DirectClass images that have 256 colors or fewer.\n     * This code will build a colormap.\n     *\n     * Also, sometimes we get PseudoClass images with an out-of-date\n     * colormap.  This code will replace the colormap with a new one.\n     * Sometimes we get PseudoClass images that have more than 256 colors.\n     * This code will delete the colormap and change the image to\n     * DirectClass.\n     *\n     * If image->alpha_trait is MagickFalse, we ignore the alpha channel\n     * even though it sometimes contains left-over non-opaque values.\n     *\n     * Also we gather some information (number of opaque, transparent,\n     * and semitransparent pixels, and whether the image has any non-gray\n     * pixels or only black-and-white pixels) that we might need later.\n     *\n     * Even if the user wants to force GrayAlpha or RGBA (colortype 4 or 6)\n     * we need to check for bogus non-opaque values, at least.\n     */\n\n   int\n     n;\n\n   PixelInfo\n     opaque[260],\n     semitransparent[260],\n     transparent[260];\n\n   register const Quantum\n     *s;\n\n   register Quantum\n     *q,\n     *r;\n\n   if (logging != MagickFalse)\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    Enter BUILD_PALETTE:\");\n\n   if (logging != MagickFalse)\n     {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->columns=%.20g\",(double) image->columns);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->rows=%.20g\",(double) image->rows);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->alpha_trait=%.20g\",(double) image->alpha_trait);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->depth=%.20g\",(double) image->depth);\n\n       if (image->storage_class == PseudoClass && image->colormap != NULL)\n       {\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      Original colormap:\");\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"        i    (red,green,blue,alpha)\");\n\n         for (i=0; i < 256; i++)\n         {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"        %d    (%d,%d,%d,%d)\",\n                    (int) i,\n                    (int) image->colormap[i].red,\n                    (int) image->colormap[i].green,\n                    (int) image->colormap[i].blue,\n                    (int) image->colormap[i].alpha);\n         }\n\n         for (i=image->colors - 10; i < (ssize_t) image->colors; i++)\n         {\n           if (i > 255)\n             {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"        %d    (%d,%d,%d,%d)\",\n                    (int) i,\n                    (int) image->colormap[i].red,\n                    (int) image->colormap[i].green,\n                    (int) image->colormap[i].blue,\n                    (int) image->colormap[i].alpha);\n             }\n         }\n       }\n\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"      image->colors=%d\",(int) image->colors);\n\n       if (image->colors == 0)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"        (zero means unknown)\");\n\n       if (ping_preserve_colormap == MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"      Regenerate the colormap\");\n     }\n\n     image_colors=0;\n     number_opaque = 0;\n     number_semitransparent = 0;\n     number_transparent = 0;\n\n     for (y=0; y < (ssize_t) image->rows; y++)\n     {\n       q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n       if (q == (Quantum *) NULL)\n         break;\n\n       for (x=0; x < (ssize_t) image->columns; x++)\n       {\n           if (image->alpha_trait == UndefinedPixelTrait ||\n              GetPixelAlpha(image,q) == OpaqueAlpha)\n             {\n               if (number_opaque < 259)\n                 {\n                   if (number_opaque == 0)\n                     {\n                       GetPixelInfoPixel(image, q, opaque);\n                       opaque[0].alpha=OpaqueAlpha;\n                       number_opaque=1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_opaque; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,opaque+i))\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_opaque && number_opaque < 259)\n                     {\n                       number_opaque++;\n                       GetPixelInfoPixel(image, q, opaque+i);\n                       opaque[i].alpha=OpaqueAlpha;\n                     }\n                 }\n             }\n           else if (GetPixelAlpha(image,q) == TransparentAlpha)\n             {\n               if (number_transparent < 259)\n                 {\n                   if (number_transparent == 0)\n                     {\n                       GetPixelInfoPixel(image, q, transparent);\n                       ping_trans_color.red=(unsigned short)\n                         GetPixelRed(image,q);\n                       ping_trans_color.green=(unsigned short)\n                         GetPixelGreen(image,q);\n                       ping_trans_color.blue=(unsigned short)\n                         GetPixelBlue(image,q);\n                       ping_trans_color.gray=(unsigned short)\n                         GetPixelGray(image,q);\n                       number_transparent = 1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_transparent; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,transparent+i))\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_transparent &&\n                       number_transparent < 259)\n                     {\n                       number_transparent++;\n                       GetPixelInfoPixel(image,q,transparent+i);\n                     }\n                 }\n             }\n           else\n             {\n               if (number_semitransparent < 259)\n                 {\n                   if (number_semitransparent == 0)\n                     {\n                       GetPixelInfoPixel(image,q,semitransparent);\n                       number_semitransparent = 1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_semitransparent; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,semitransparent+i)\n                           && GetPixelAlpha(image,q) ==\n                           semitransparent[i].alpha)\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_semitransparent &&\n                       number_semitransparent < 259)\n                     {\n                       number_semitransparent++;\n                       GetPixelInfoPixel(image, q, semitransparent+i);\n                     }\n                 }\n             }\n           q+=GetPixelChannels(image);\n        }\n     }\n\n     if (mng_info->write_png8 == MagickFalse &&\n         ping_exclude_bKGD == MagickFalse)\n       {\n         /* Add the background color to the palette, if it\n          * isn't already there.\n          */\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      Check colormap for background (%d,%d,%d)\",\n                  (int) image->background_color.red,\n                  (int) image->background_color.green,\n                  (int) image->background_color.blue);\n            }\n          for (i=0; i<number_opaque; i++)\n          {\n             if (opaque[i].red == image->background_color.red &&\n                 opaque[i].green == image->background_color.green &&\n                 opaque[i].blue == image->background_color.blue)\n               break;\n          }\n          if (number_opaque < 259 && i == number_opaque)\n            {\n               opaque[i] = image->background_color;\n               ping_background.index = i;\n               number_opaque++;\n               if (logging != MagickFalse)\n                 {\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"      background_color index is %d\",(int) i);\n                 }\n\n            }\n          else if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      No room in the colormap to add background color\");\n       }\n\n     image_colors=number_opaque+number_transparent+number_semitransparent;\n\n     if (logging != MagickFalse)\n       {\n         if (image_colors > 256)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      image has more than 256 colors\");\n\n         else\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      image has %d colors\",image_colors);\n       }\n\n     if (ping_preserve_colormap != MagickFalse)\n       break;\n\n     if (mng_info->write_png_colortype != 7) /* We won't need this info */\n       {\n         ping_have_color=MagickFalse;\n         ping_have_non_bw=MagickFalse;\n\n         if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n         {\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"incompatible colorspace\");\n           ping_have_color=MagickTrue;\n           ping_have_non_bw=MagickTrue;\n         }\n\n         if(image_colors > 256)\n           {\n             for (y=0; y < (ssize_t) image->rows; y++)\n             {\n               q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n               if (q == (Quantum *) NULL)\n                 break;\n\n               s=q;\n               for (x=0; x < (ssize_t) image->columns; x++)\n               {\n                 if (GetPixelRed(image,s) != GetPixelGreen(image,s) ||\n                     GetPixelRed(image,s) != GetPixelBlue(image,s))\n                   {\n                      ping_have_color=MagickTrue;\n                      ping_have_non_bw=MagickTrue;\n                      break;\n                   }\n                 s+=GetPixelChannels(image);\n               }\n\n               if (ping_have_color != MagickFalse)\n                 break;\n\n               /* Worst case is black-and-white; we are looking at every\n                * pixel twice.\n                */\n\n               if (ping_have_non_bw == MagickFalse)\n                 {\n                   s=q;\n                   for (x=0; x < (ssize_t) image->columns; x++)\n                   {\n                     if (GetPixelRed(image,s) != 0 &&\n                         GetPixelRed(image,s) != QuantumRange)\n                       {\n                         ping_have_non_bw=MagickTrue;\n                         break;\n                       }\n                     s+=GetPixelChannels(image);\n                   }\n               }\n             }\n           }\n       }\n\n     if (image_colors < 257)\n       {\n         PixelInfo\n           colormap[260];\n\n         /*\n          * Initialize image colormap.\n          */\n\n         if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      Sort the new colormap\");\n\n        /* Sort palette, transparent first */;\n\n         n = 0;\n\n         for (i=0; i<number_transparent; i++)\n            colormap[n++] = transparent[i];\n\n         for (i=0; i<number_semitransparent; i++)\n            colormap[n++] = semitransparent[i];\n\n         for (i=0; i<number_opaque; i++)\n            colormap[n++] = opaque[i];\n\n         ping_background.index +=\n           (number_transparent + number_semitransparent);\n\n         /* image_colors < 257; search the colormap instead of the pixels\n          * to get ping_have_color and ping_have_non_bw\n          */\n         for (i=0; i<n; i++)\n         {\n           if (ping_have_color == MagickFalse)\n             {\n                if (colormap[i].red != colormap[i].green ||\n                    colormap[i].red != colormap[i].blue)\n                  {\n                     ping_have_color=MagickTrue;\n                     ping_have_non_bw=MagickTrue;\n                     break;\n                  }\n              }\n\n           if (ping_have_non_bw == MagickFalse)\n             {\n               if (colormap[i].red != 0 && colormap[i].red != QuantumRange)\n                   ping_have_non_bw=MagickTrue;\n             }\n          }\n\n        if ((mng_info->ping_exclude_tRNS == MagickFalse ||\n            (number_transparent == 0 && number_semitransparent == 0)) &&\n            (((mng_info->write_png_colortype-1) ==\n            PNG_COLOR_TYPE_PALETTE) ||\n            (mng_info->write_png_colortype == 0)))\n          {\n            if (logging != MagickFalse)\n              {\n                if (n !=  (ssize_t) image_colors)\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"   image_colors (%d) and n (%d)  don't match\",\n                   image_colors, n);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      AcquireImageColormap\");\n              }\n\n            image->colors = image_colors;\n\n            if (AcquireImageColormap(image,image_colors,exception) ==\n                MagickFalse)\n               ThrowWriterException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");\n\n            for (i=0; i< (ssize_t) image_colors; i++)\n               image->colormap[i] = colormap[i];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"      image->colors=%d (%d)\",\n                      (int) image->colors, image_colors);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"      Update the pixel indexes\");\n              }\n\n            /* Sync the pixel indices with the new colormap */\n\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n              if (q == (Quantum *) NULL)\n                break;\n\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                for (i=0; i< (ssize_t) image_colors; i++)\n                {\n                  if ((image->alpha_trait == UndefinedPixelTrait ||\n                      image->colormap[i].alpha == GetPixelAlpha(image,q)) &&\n                      image->colormap[i].red == GetPixelRed(image,q) &&\n                      image->colormap[i].green == GetPixelGreen(image,q) &&\n                      image->colormap[i].blue == GetPixelBlue(image,q))\n                  {\n                    SetPixelIndex(image,i,q);\n                    break;\n                  }\n                }\n                q+=GetPixelChannels(image);\n              }\n\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                 break;\n            }\n          }\n       }\n\n     if (logging != MagickFalse)\n       {\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      image->colors=%d\", (int) image->colors);\n\n         if (image->colormap != NULL)\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"       i     (red,green,blue,alpha)\");\n\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               if (i < 300 || i >= (ssize_t) image->colors - 10)\n                 {\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"       %d     (%d,%d,%d,%d)\",\n                        (int) i,\n                        (int) image->colormap[i].red,\n                        (int) image->colormap[i].green,\n                        (int) image->colormap[i].blue,\n                        (int) image->colormap[i].alpha);\n                 }\n             }\n           }\n\n           if (number_transparent < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_transparent     = %d\",\n                   number_transparent);\n           else\n\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_transparent     > 256\");\n\n           if (number_opaque < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_opaque          = %d\",\n                   number_opaque);\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_opaque          > 256\");\n\n           if (number_semitransparent < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_semitransparent = %d\",\n                   number_semitransparent);\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_semitransparent > 256\");\n\n           if (ping_have_non_bw == MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      All pixels and the background are black or white\");\n\n           else if (ping_have_color == MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      All pixels and the background are gray\");\n\n           else\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      At least one pixel or the background is non-gray\");\n\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Exit BUILD_PALETTE:\");\n       }\n\n   if (mng_info->write_png8 == MagickFalse)\n      break;\n\n   /* Make any reductions necessary for the PNG8 format */\n    if (image_colors <= 256 &&\n        image_colors != 0 && image->colormap != NULL &&\n        number_semitransparent == 0 &&\n        number_transparent <= 1)\n      break;\n\n    /* PNG8 can't have semitransparent colors so we threshold the\n     * opacity to 0 or OpaqueOpacity, and PNG8 can only have one\n     * transparent color so if more than one is transparent we merge\n     * them into image->background_color.\n     */\n    if (number_semitransparent != 0 || number_transparent > 1)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Thresholding the alpha channel to binary\");\n\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (r == (Quantum *) NULL)\n            break;\n\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n              if (GetPixelAlpha(image,r) < OpaqueAlpha/2)\n                {\n                  SetPixelViaPixelInfo(image,&image->background_color,r);\n                  SetPixelAlpha(image,TransparentAlpha,r);\n                }\n              else\n                  SetPixelAlpha(image,OpaqueAlpha,r);\n              r+=GetPixelChannels(image);\n          }\n\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n\n          if (image_colors != 0 && image_colors <= 256 &&\n             image->colormap != NULL)\n            for (i=0; i<image_colors; i++)\n                image->colormap[i].alpha =\n                    (image->colormap[i].alpha > TransparentAlpha/2 ?\n                    TransparentAlpha : OpaqueAlpha);\n        }\n      continue;\n    }\n\n    /* PNG8 can't have more than 256 colors so we quantize the pixels and\n     * background color to the 4-4-4-1, 3-3-3-1 or 3-3-2-1 palette.  If the\n     * image is mostly gray, the 4-4-4-1 palette is likely to end up with 256\n     * colors or less.\n     */\n    if (tried_444 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 4-4-4\");\n\n        tried_444 = MagickTrue;\n\n        LBR04PacketRGB(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 4-4-4\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR04PixelRGB(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 4-4-4\");\n\n          for (i=0; i<image_colors; i++)\n          {\n            LBR04PacketRGB(image->colormap[i]);\n          }\n        }\n        continue;\n      }\n\n    if (tried_333 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 3-3-3\");\n\n        tried_333 = MagickTrue;\n\n        LBR03PacketRGB(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 3-3-3-1\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR03RGB(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 3-3-3-1\");\n          for (i=0; i<image_colors; i++)\n          {\n              LBR03PacketRGB(image->colormap[i]);\n          }\n        }\n        continue;\n      }\n\n    if (tried_332 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 3-3-2\");\n\n        tried_332 = MagickTrue;\n\n        /* Red and green were already done so we only quantize the blue\n         * channel\n         */\n\n        LBR02PacketBlue(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 3-3-2-1\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR02PixelBlue(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 3-3-2-1\");\n          for (i=0; i<image_colors; i++)\n          {\n              LBR02PacketBlue(image->colormap[i]);\n          }\n      }\n      continue;\n    }\n\n    if (image_colors == 0 || image_colors > 256)\n    {\n      /* Take care of special case with 256 opaque colors + 1 transparent\n       * color.  We don't need to quantize to 2-3-2-1; we only need to\n       * eliminate one color, so we'll merge the two darkest red\n       * colors (0x49, 0, 0) -> (0x24, 0, 0).\n       */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Merging two dark red background colors to 3-3-2-1\");\n\n      if (ScaleQuantumToChar(image->background_color.red) == 0x49 &&\n          ScaleQuantumToChar(image->background_color.green) == 0x00 &&\n          ScaleQuantumToChar(image->background_color.blue) == 0x00)\n      {\n         image->background_color.red=ScaleCharToQuantum(0x24);\n      }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Merging two dark red pixel colors to 3-3-2-1\");\n\n      if (image->colormap == NULL)\n      {\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (r == (Quantum *) NULL)\n            break;\n\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (ScaleQuantumToChar(GetPixelRed(image,r)) == 0x49 &&\n                ScaleQuantumToChar(GetPixelGreen(image,r)) == 0x00 &&\n                ScaleQuantumToChar(GetPixelBlue(image,r)) == 0x00 &&\n                GetPixelAlpha(image,r) == OpaqueAlpha)\n              {\n                SetPixelRed(image,ScaleCharToQuantum(0x24),r);\n              }\n            r+=GetPixelChannels(image);\n          }\n\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n\n        }\n      }\n\n      else\n      {\n         for (i=0; i<image_colors; i++)\n         {\n            if (ScaleQuantumToChar(image->colormap[i].red) == 0x49 &&\n                ScaleQuantumToChar(image->colormap[i].green) == 0x00 &&\n                ScaleQuantumToChar(image->colormap[i].blue) == 0x00)\n            {\n               image->colormap[i].red=ScaleCharToQuantum(0x24);\n            }\n         }\n      }\n    }\n  }\n  }\n  /* END OF BUILD_PALETTE */\n\n  /* If we are excluding the tRNS chunk and there is transparency,\n   * then we must write a Gray-Alpha (color-type 4) or RGBA (color-type 6)\n   * PNG.\n   */\n  if (mng_info->ping_exclude_tRNS != MagickFalse &&\n     (number_transparent != 0 || number_semitransparent != 0))\n    {\n      unsigned int colortype=mng_info->write_png_colortype;\n\n      if (ping_have_color == MagickFalse)\n        mng_info->write_png_colortype = 5;\n\n      else\n        mng_info->write_png_colortype = 7;\n\n      if (colortype != 0 &&\n         mng_info->write_png_colortype != colortype)\n        ping_need_colortype_warning=MagickTrue;\n\n    }\n\n  /* See if cheap transparency is possible.  It is only possible\n   * when there is a single transparent color, no semitransparent\n   * color, and no opaque color that has the same RGB components\n   * as the transparent color.  We only need this information if\n   * we are writing a PNG with colortype 0 or 2, and we have not\n   * excluded the tRNS chunk.\n   */\n  if (number_transparent == 1 &&\n      mng_info->write_png_colortype < 4)\n    {\n       ping_have_cheap_transparency = MagickTrue;\n\n       if (number_semitransparent != 0)\n         ping_have_cheap_transparency = MagickFalse;\n\n       else if (image_colors == 0 || image_colors > 256 ||\n           image->colormap == NULL)\n         {\n           register const Quantum\n             *q;\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             q=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n             if (q == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                 if (GetPixelAlpha(image,q) != TransparentAlpha &&\n                     (unsigned short) GetPixelRed(image,q) ==\n                                     ping_trans_color.red &&\n                     (unsigned short) GetPixelGreen(image,q) ==\n                                     ping_trans_color.green &&\n                     (unsigned short) GetPixelBlue(image,q) ==\n                                     ping_trans_color.blue)\n                   {\n                     ping_have_cheap_transparency = MagickFalse;\n                     break;\n                   }\n\n                 q+=GetPixelChannels(image);\n             }\n\n             if (ping_have_cheap_transparency == MagickFalse)\n                break;\n           }\n         }\n       else\n         {\n            /* Assuming that image->colormap[0] is the one transparent color\n             * and that all others are opaque.\n             */\n            if (image_colors > 1)\n              for (i=1; i<image_colors; i++)\n                if (image->colormap[i].red == image->colormap[0].red &&\n                    image->colormap[i].green == image->colormap[0].green &&\n                    image->colormap[i].blue == image->colormap[0].blue)\n                  {\n                     ping_have_cheap_transparency = MagickFalse;\n                     break;\n                  }\n         }\n\n       if (logging != MagickFalse)\n         {\n           if (ping_have_cheap_transparency == MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"   Cheap transparency is not possible.\");\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"   Cheap transparency is possible.\");\n         }\n     }\n  else\n    ping_have_cheap_transparency = MagickFalse;\n\n  image_depth=image->depth;\n\n  quantum_info = (QuantumInfo *) NULL;\n  number_colors=0;\n  image_colors=(int) image->colors;\n  image_matte=image->alpha_trait !=\n        UndefinedPixelTrait ? MagickTrue : MagickFalse;\n\n  if (mng_info->write_png_colortype < 5)\n    mng_info->IsPalette=image->storage_class == PseudoClass &&\n      image_colors <= 256 && image->colormap != NULL;\n  else\n    mng_info->IsPalette = MagickFalse;\n\n  if ((mng_info->write_png_colortype == 4 || mng_info->write_png8) &&\n     (image->colors == 0 || image->colormap == NULL))\n    {\n      image_info=DestroyImageInfo(image_info);\n      image=DestroyImage(image);\n      (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          \"Cannot write PNG8 or color-type 3; colormap is NULL\",\n          \"`%s'\",IMimage->filename);\n      return(MagickFalse);\n    }\n\n  /*\n    Allocate the PNG structures\n  */\n#ifdef PNG_USER_MEM_SUPPORTED\n error_info.image=image;\n error_info.exception=exception;\n  ping=png_create_write_struct_2(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler,(void *) NULL,\n    (png_malloc_ptr) Magick_png_malloc,(png_free_ptr) Magick_png_free);\n\n#else\n  ping=png_create_write_struct(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler);\n\n#endif\n  if (ping == (png_struct *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  ping_info=png_create_info_struct(ping);\n\n  if (ping_info == (png_info *) NULL)\n    {\n      png_destroy_write_struct(&ping,(png_info **) NULL);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n\n  png_set_write_fn(ping,image,png_put_data,png_flush_data);\n  pixel_info=(MemoryInfo *) NULL;\n\n  if (setjmp(png_jmpbuf(ping)))\n    {\n      /*\n        PNG write failed.\n      */\n#ifdef PNG_DEBUG\n     if (image_info->verbose)\n        (void) printf(\"PNG write has failed.\\n\");\n#endif\n      png_destroy_write_struct(&ping,&ping_info);\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n      UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n      if (pixel_info != (MemoryInfo *) NULL)\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n\n      if (quantum_info != (QuantumInfo *) NULL)\n        quantum_info=DestroyQuantumInfo(quantum_info);\n\n      if (ping_have_blob != MagickFalse)\n          (void) CloseBlob(image);\n      image_info=DestroyImageInfo(image_info);\n      image=DestroyImage(image);\n      return(MagickFalse);\n    }\n\n  /* {  For navigation to end of SETJMP-protected block.  Within this\n   *    block, use png_error() instead of Throwing an Exception, to ensure\n   *    that libpng is able to clean up, and that the semaphore is unlocked.\n   */\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  LockSemaphoreInfo(ping_semaphore);\n#endif\n\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\n  /* Allow benign errors */\n  png_set_benign_errors(ping, 1);\n#endif\n\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n  /* Reject images with too many rows or columns */\n  png_set_user_limits(ping,\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(WidthResource)),\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(HeightResource)));\n#endif /* PNG_SET_USER_LIMITS_SUPPORTED */\n\n  /*\n    Prepare PNG for writing.\n  */\n\n#if defined(PNG_MNG_FEATURES_SUPPORTED)\n  if (mng_info->write_mng)\n  {\n     (void) png_permit_mng_features(ping,PNG_ALL_MNG_FEATURES);\n# ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED\n     /* Disable new libpng-1.5.10 feature when writing a MNG because\n      * zero-length PLTE is OK\n      */\n     png_set_check_for_invalid_index (ping, 0);\n# endif\n  }\n\n#else\n# ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED\n  if (mng_info->write_mng)\n     png_permit_empty_plte(ping,MagickTrue);\n\n# endif\n#endif\n\n  x=0;\n\n  ping_width=(png_uint_32) image->columns;\n  ping_height=(png_uint_32) image->rows;\n\n  if (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32)\n     image_depth=8;\n\n  if (mng_info->write_png48 || mng_info->write_png64)\n     image_depth=16;\n\n  if (mng_info->write_png_depth != 0)\n     image_depth=mng_info->write_png_depth;\n\n  /* Adjust requested depth to next higher valid depth if necessary */\n  if (image_depth > 8)\n     image_depth=16;\n\n  if ((image_depth > 4) && (image_depth < 8))\n     image_depth=8;\n\n  if (image_depth == 3)\n     image_depth=4;\n\n  if (logging != MagickFalse)\n    {\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    width=%.20g\",(double) ping_width);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    height=%.20g\",(double) ping_height);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_matte=%.20g\",(double) image->alpha_trait);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image->depth=%.20g\",(double) image->depth);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Tentative ping_bit_depth=%.20g\",(double) image_depth);\n    }\n\n  save_image_depth=image_depth;\n  ping_bit_depth=(png_byte) save_image_depth;\n\n\n#if defined(PNG_pHYs_SUPPORTED)\n  if (ping_exclude_pHYs == MagickFalse)\n  {\n  if ((image->resolution.x != 0) && (image->resolution.y != 0) &&\n      (!mng_info->write_mng || !mng_info->equal_physs))\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Setting up pHYs chunk\");\n\n      if (image->units == PixelsPerInchResolution)\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_METER;\n          ping_pHYs_x_resolution=\n             (png_uint_32) ((100.0*image->resolution.x+0.5)/2.54);\n          ping_pHYs_y_resolution=\n             (png_uint_32) ((100.0*image->resolution.y+0.5)/2.54);\n        }\n\n      else if (image->units == PixelsPerCentimeterResolution)\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_METER;\n          ping_pHYs_x_resolution=(png_uint_32) (100.0*image->resolution.x+0.5);\n          ping_pHYs_y_resolution=(png_uint_32) (100.0*image->resolution.y+0.5);\n        }\n\n      else\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_UNKNOWN;\n          ping_pHYs_x_resolution=(png_uint_32) image->resolution.x;\n          ping_pHYs_y_resolution=(png_uint_32) image->resolution.y;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Set up PNG pHYs chunk: xres: %.20g, yres: %.20g, units: %d.\",\n          (double) ping_pHYs_x_resolution,(double) ping_pHYs_y_resolution,\n          (int) ping_pHYs_unit_type);\n       ping_have_pHYs = MagickTrue;\n    }\n  }\n#endif\n\n  if (ping_exclude_bKGD == MagickFalse)\n  {\n  if ((!mng_info->adjoin || !mng_info->equal_backgrounds))\n    {\n       unsigned int\n         mask;\n\n       mask=0xffff;\n       if (ping_bit_depth == 8)\n          mask=0x00ff;\n\n       if (ping_bit_depth == 4)\n          mask=0x000f;\n\n       if (ping_bit_depth == 2)\n          mask=0x0003;\n\n       if (ping_bit_depth == 1)\n          mask=0x0001;\n\n       ping_background.red=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.red) & mask);\n\n       ping_background.green=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.green) & mask);\n\n       ping_background.blue=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.blue) & mask);\n\n       ping_background.gray=(png_uint_16) ping_background.green;\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Setting up bKGD chunk (1)\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"      background_color index is %d\",\n          (int) ping_background.index);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    ping_bit_depth=%d\",ping_bit_depth);\n    }\n\n  ping_have_bKGD = MagickTrue;\n  }\n\n  /*\n    Select the color type.\n  */\n  matte=image_matte;\n  old_bit_depth=0;\n\n  if (mng_info->IsPalette && mng_info->write_png8)\n    {\n      /* To do: make this a function cause it's used twice, except\n         for reducing the sample depth from 8. */\n\n      number_colors=image_colors;\n\n      ping_have_tRNS=MagickFalse;\n\n      /*\n        Set image palette.\n      */\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Setting up PLTE chunk with %d colors (%d)\",\n            number_colors, image_colors);\n\n      for (i=0; i < (ssize_t) number_colors; i++)\n      {\n        palette[i].red=ScaleQuantumToChar(image->colormap[i].red);\n        palette[i].green=ScaleQuantumToChar(image->colormap[i].green);\n        palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n#if MAGICKCORE_QUANTUM_DEPTH == 8\n            \"    %3ld (%3d,%3d,%3d)\",\n#else\n            \"    %5ld (%5d,%5d,%5d)\",\n#endif\n            (long) i,palette[i].red,palette[i].green,palette[i].blue);\n\n      }\n\n      ping_have_PLTE=MagickTrue;\n      image_depth=ping_bit_depth;\n      ping_num_trans=0;\n\n      if (matte != MagickFalse)\n      {\n          /*\n            Identify which colormap entry is transparent.\n          */\n          assert(number_colors <= 256);\n          assert(image->colormap != NULL);\n\n          for (i=0; i < (ssize_t) number_transparent; i++)\n             ping_trans_alpha[i]=0;\n\n\n          ping_num_trans=(unsigned short) (number_transparent +\n             number_semitransparent);\n\n          if (ping_num_trans == 0)\n             ping_have_tRNS=MagickFalse;\n\n          else\n             ping_have_tRNS=MagickTrue;\n      }\n\n      if (ping_exclude_bKGD == MagickFalse)\n      {\n       /*\n        * Identify which colormap entry is the background color.\n        */\n\n        for (i=0; i < (ssize_t) MagickMax(1L*number_colors-1L,1L); i++)\n          if (IsPNGColorEqual(ping_background,image->colormap[i]))\n            break;\n\n        ping_background.index=(png_byte) i;\n\n        if (logging != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"      background_color index is %d\",\n                 (int) ping_background.index);\n          }\n      }\n    } /* end of write_png8 */\n\n  else if (mng_info->write_png_colortype == 1)\n    {\n      image_matte=MagickFalse;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;\n    }\n\n  else if (mng_info->write_png24 || mng_info->write_png48 ||\n      mng_info->write_png_colortype == 3)\n    {\n      image_matte=MagickFalse;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n    }\n\n  else if (mng_info->write_png32 || mng_info->write_png64 ||\n      mng_info->write_png_colortype == 7)\n    {\n      image_matte=MagickTrue;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;\n    }\n\n  else /* mng_info->write_pngNN not specified */\n    {\n      image_depth=ping_bit_depth;\n\n      if (mng_info->write_png_colortype != 0)\n        {\n          ping_color_type=(png_byte) mng_info->write_png_colortype-1;\n\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\n              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            image_matte=MagickTrue;\n\n          else\n            image_matte=MagickFalse;\n\n          if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"   PNG colortype %d was specified:\",(int) ping_color_type);\n        }\n\n      else /* write_png_colortype not specified */\n        {\n          if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Selecting PNG colortype:\");\n\n          ping_color_type=(png_byte) ((matte != MagickFalse)?\n            PNG_COLOR_TYPE_RGB_ALPHA:PNG_COLOR_TYPE_RGB);\n\n          if (image_info->type == TrueColorType)\n            {\n              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n              image_matte=MagickFalse;\n            }\n\n          if (image_info->type == TrueColorAlphaType)\n            {\n              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;\n              image_matte=MagickTrue;\n            }\n\n          if (image_info->type == PaletteType ||\n              image_info->type == PaletteAlphaType)\n            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n          if (mng_info->write_png_colortype == 0 &&\n             image_info->type == UndefinedType)\n            {\n              if (ping_have_color == MagickFalse)\n                {\n                  if (image_matte == MagickFalse)\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;\n                      image_matte=MagickFalse;\n                    }\n\n                  else\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY_ALPHA;\n                      image_matte=MagickTrue;\n                    }\n                }\n              else\n                {\n                  if (image_matte == MagickFalse)\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n                      image_matte=MagickFalse;\n                    }\n\n                  else\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGBA;\n                      image_matte=MagickTrue;\n                    }\n                 }\n            }\n\n        }\n\n      if (logging != MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    Selected PNG colortype=%d\",ping_color_type);\n\n      if (ping_bit_depth < 8)\n        {\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\n              ping_color_type == PNG_COLOR_TYPE_RGB ||\n              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            ping_bit_depth=8;\n        }\n\n      old_bit_depth=ping_bit_depth;\n\n      if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n        {\n          if (image->alpha_trait == UndefinedPixelTrait &&\n               ping_have_non_bw == MagickFalse)\n             ping_bit_depth=1;\n        }\n\n      if (ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        {\n           size_t one = 1;\n           ping_bit_depth=1;\n\n           if (image->colors == 0)\n           {\n              /* DO SOMETHING */\n                png_error(ping,\"image has 0 colors\");\n           }\n\n           while ((int) (one << ping_bit_depth) < (ssize_t) image_colors)\n             ping_bit_depth <<= 1;\n        }\n\n      if (logging != MagickFalse)\n         {\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Number of colors: %.20g\",(double) image_colors);\n\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Tentative PNG bit depth: %d\",ping_bit_depth);\n         }\n\n      if (ping_bit_depth < (int) mng_info->write_png_depth)\n         ping_bit_depth = mng_info->write_png_depth;\n    }\n\n  image_depth=ping_bit_depth;\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Tentative PNG color type: %s (%.20g)\",\n        PngColorTypeToString(ping_color_type),\n        (double) ping_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_info->type: %.20g\",(double) image_info->type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_depth: %.20g\",(double) image_depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\n        \"    image->depth: %.20g\",(double) image->depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    ping_bit_depth: %.20g\",(double) ping_bit_depth);\n    }\n\n  if (matte != MagickFalse)\n    {\n      if (mng_info->IsPalette)\n        {\n          if (mng_info->write_png_colortype == 0)\n            {\n              ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;\n\n              if (ping_have_color != MagickFalse)\n                 ping_color_type=PNG_COLOR_TYPE_RGBA;\n            }\n\n          /*\n           * Determine if there is any transparent color.\n          */\n          if (number_transparent + number_semitransparent == 0)\n            {\n              /*\n                No transparent pixels are present.  Change 4 or 6 to 0 or 2.\n              */\n\n              image_matte=MagickFalse;\n\n              if (mng_info->write_png_colortype == 0)\n                ping_color_type&=0x03;\n            }\n\n          else\n            {\n              unsigned int\n                mask;\n\n              mask=0xffff;\n\n              if (ping_bit_depth == 8)\n                 mask=0x00ff;\n\n              if (ping_bit_depth == 4)\n                 mask=0x000f;\n\n              if (ping_bit_depth == 2)\n                 mask=0x0003;\n\n              if (ping_bit_depth == 1)\n                 mask=0x0001;\n\n              ping_trans_color.red=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].red) & mask);\n\n              ping_trans_color.green=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].green) & mask);\n\n              ping_trans_color.blue=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].blue) & mask);\n\n              ping_trans_color.gray=(png_uint_16)\n                (ScaleQuantumToShort(GetPixelInfoIntensity(image,\n                   image->colormap)) & mask);\n\n              ping_trans_color.index=(png_byte) 0;\n\n              ping_have_tRNS=MagickTrue;\n            }\n\n          if (ping_have_tRNS != MagickFalse)\n            {\n              /*\n               * Determine if there is one and only one transparent color\n               * and if so if it is fully transparent.\n               */\n              if (ping_have_cheap_transparency == MagickFalse)\n                ping_have_tRNS=MagickFalse;\n            }\n\n          if (ping_have_tRNS != MagickFalse)\n            {\n              if (mng_info->write_png_colortype == 0)\n                ping_color_type &= 0x03;  /* changes 4 or 6 to 0 or 2 */\n\n              if (image_depth == 8)\n                {\n                  ping_trans_color.red&=0xff;\n                  ping_trans_color.green&=0xff;\n                  ping_trans_color.blue&=0xff;\n                  ping_trans_color.gray&=0xff;\n                }\n            }\n        }\n      else\n        {\n          if (image_depth == 8)\n            {\n              ping_trans_color.red&=0xff;\n              ping_trans_color.green&=0xff;\n              ping_trans_color.blue&=0xff;\n              ping_trans_color.gray&=0xff;\n            }\n        }\n    }\n\n    matte=image_matte;\n\n    if (ping_have_tRNS != MagickFalse)\n      image_matte=MagickFalse;\n\n    if ((mng_info->IsPalette) &&\n        mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE &&\n        ping_have_color == MagickFalse &&\n        (image_matte == MagickFalse || image_depth >= 8))\n      {\n        size_t one=1;\n\n        if (image_matte != MagickFalse)\n          ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;\n\n        else if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_GRAY_ALPHA)\n          {\n            ping_color_type=PNG_COLOR_TYPE_GRAY;\n\n            if (save_image_depth == 16 && image_depth == 8)\n              {\n                if (logging != MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Scaling ping_trans_color (0)\");\n                  }\n                    ping_trans_color.gray*=0x0101;\n              }\n          }\n\n        if (image_depth > MAGICKCORE_QUANTUM_DEPTH)\n          image_depth=MAGICKCORE_QUANTUM_DEPTH;\n\n        if ((image_colors == 0) ||\n             ((ssize_t) (image_colors-1) > (ssize_t) MaxColormapSize))\n          image_colors=(int) (one << image_depth);\n\n        if (image_depth > 8)\n          ping_bit_depth=16;\n\n        else\n          {\n            ping_bit_depth=8;\n            if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n              {\n                if(!mng_info->write_png_depth)\n                  {\n                    ping_bit_depth=1;\n\n                    while ((int) (one << ping_bit_depth)\n                        < (ssize_t) image_colors)\n                      ping_bit_depth <<= 1;\n                  }\n              }\n\n            else if (ping_color_type ==\n                PNG_COLOR_TYPE_GRAY && image_colors < 17 &&\n                mng_info->IsPalette)\n              {\n              /* Check if grayscale is reducible */\n\n                int\n                  depth_4_ok=MagickTrue,\n                  depth_2_ok=MagickTrue,\n                  depth_1_ok=MagickTrue;\n\n                for (i=0; i < (ssize_t) image_colors; i++)\n                {\n                   unsigned char\n                     intensity;\n\n                   intensity=ScaleQuantumToChar(image->colormap[i].red);\n\n                   if ((intensity & 0x0f) != ((intensity & 0xf0) >> 4))\n                     depth_4_ok=depth_2_ok=depth_1_ok=MagickFalse;\n                   else if ((intensity & 0x03) != ((intensity & 0x0c) >> 2))\n                     depth_2_ok=depth_1_ok=MagickFalse;\n                   else if ((intensity & 0x01) != ((intensity & 0x02) >> 1))\n                     depth_1_ok=MagickFalse;\n                }\n\n                if (depth_1_ok && mng_info->write_png_depth <= 1)\n                  ping_bit_depth=1;\n\n                else if (depth_2_ok && mng_info->write_png_depth <= 2)\n                  ping_bit_depth=2;\n\n                else if (depth_4_ok && mng_info->write_png_depth <= 4)\n                  ping_bit_depth=4;\n              }\n          }\n\n          image_depth=ping_bit_depth;\n      }\n\n    else\n\n      if (mng_info->IsPalette)\n      {\n        number_colors=image_colors;\n\n        if (image_depth <= 8)\n          {\n            /*\n              Set image palette.\n            */\n            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n            if (!(mng_info->have_write_global_plte && matte == MagickFalse))\n              {\n                for (i=0; i < (ssize_t) number_colors; i++)\n                {\n                  palette[i].red=ScaleQuantumToChar(image->colormap[i].red);\n                  palette[i].green=\n                    ScaleQuantumToChar(image->colormap[i].green);\n                  palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);\n                }\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Setting up PLTE chunk with %d colors\",\n                    number_colors);\n\n                ping_have_PLTE=MagickTrue;\n              }\n\n            /* color_type is PNG_COLOR_TYPE_PALETTE */\n            if (mng_info->write_png_depth == 0)\n              {\n                size_t\n                  one;\n\n                ping_bit_depth=1;\n                one=1;\n\n                while ((one << ping_bit_depth) < (size_t) number_colors)\n                  ping_bit_depth <<= 1;\n              }\n\n            ping_num_trans=0;\n\n            if (matte != MagickFalse)\n              {\n                /*\n                 * Set up trans_colors array.\n                 */\n                assert(number_colors <= 256);\n\n                ping_num_trans=(unsigned short) (number_transparent +\n                  number_semitransparent);\n\n                if (ping_num_trans == 0)\n                  ping_have_tRNS=MagickFalse;\n\n                else\n                  {\n                    if (logging != MagickFalse)\n                      {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Scaling ping_trans_color (1)\");\n                      }\n                    ping_have_tRNS=MagickTrue;\n\n                    for (i=0; i < ping_num_trans; i++)\n                    {\n                       ping_trans_alpha[i]= (png_byte)\n                         ScaleQuantumToChar(image->colormap[i].alpha);\n                    }\n                  }\n              }\n          }\n      }\n\n    else\n      {\n\n        if (image_depth < 8)\n          image_depth=8;\n\n        if ((save_image_depth == 16) && (image_depth == 8))\n          {\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Scaling ping_trans_color from (%d,%d,%d)\",\n                  (int) ping_trans_color.red,\n                  (int) ping_trans_color.green,\n                  (int) ping_trans_color.blue);\n              }\n\n            ping_trans_color.red*=0x0101;\n            ping_trans_color.green*=0x0101;\n            ping_trans_color.blue*=0x0101;\n            ping_trans_color.gray*=0x0101;\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    to (%d,%d,%d)\",\n                  (int) ping_trans_color.red,\n                  (int) ping_trans_color.green,\n                  (int) ping_trans_color.blue);\n              }\n          }\n      }\n\n    if (ping_bit_depth <  (ssize_t) mng_info->write_png_depth)\n         ping_bit_depth =  (ssize_t) mng_info->write_png_depth;\n\n    /*\n      Adjust background and transparency samples in sub-8-bit grayscale files.\n    */\n    if (ping_bit_depth < 8 && ping_color_type ==\n        PNG_COLOR_TYPE_GRAY)\n      {\n         png_uint_16\n           maxval;\n\n         size_t\n           one=1;\n\n         maxval=(png_uint_16) ((one << ping_bit_depth)-1);\n\n         if (ping_exclude_bKGD == MagickFalse)\n         {\n\n         ping_background.gray=(png_uint_16) ((maxval/65535.)*\n           (ScaleQuantumToShort(((GetPixelInfoIntensity(image,\n           &image->background_color))) +.5)));\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Setting up bKGD chunk (2)\");\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      background_color index is %d\",\n             (int) ping_background.index);\n\n         ping_have_bKGD = MagickTrue;\n         }\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Scaling ping_trans_color.gray from %d\",\n             (int)ping_trans_color.gray);\n\n         ping_trans_color.gray=(png_uint_16) ((maxval/255.)*(\n           ping_trans_color.gray)+.5);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      to %d\", (int)ping_trans_color.gray);\n      }\n\n  if (ping_exclude_bKGD == MagickFalse)\n  {\n    if (mng_info->IsPalette && (int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n      {\n        /*\n           Identify which colormap entry is the background color.\n        */\n\n        number_colors=image_colors;\n\n        for (i=0; i < (ssize_t) MagickMax(1L*number_colors,1L); i++)\n          if (IsPNGColorEqual(image->background_color,image->colormap[i]))\n            break;\n\n        ping_background.index=(png_byte) i;\n\n        if (logging != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Setting up bKGD chunk with index=%d\",(int) i);\n          }\n\n        if (i < (ssize_t) number_colors)\n          {\n            ping_have_bKGD = MagickTrue;\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"     background   =(%d,%d,%d)\",\n                        (int) ping_background.red,\n                        (int) ping_background.green,\n                        (int) ping_background.blue);\n              }\n          }\n\n        else  /* Can't happen */\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      No room in PLTE to add bKGD color\");\n            ping_have_bKGD = MagickFalse;\n          }\n      }\n  }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    PNG color type: %s (%d)\", PngColorTypeToString(ping_color_type),\n      ping_color_type);\n  /*\n    Initialize compression level and filtering.\n  */\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Setting up deflate compression\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Compression buffer size: 32768\");\n    }\n\n  png_set_compression_buffer_size(ping,32768L);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Compression mem level: 9\");\n\n  png_set_compression_mem_level(ping, 9);\n\n  /* Untangle the \"-quality\" setting:\n\n     Undefined is 0; the default is used.\n     Default is 75\n\n     10's digit:\n\n        0 or omitted: Use Z_HUFFMAN_ONLY strategy with the\n           zlib default compression level\n\n        1-9: the zlib compression level\n\n     1's digit:\n\n        0-4: the PNG filter method\n\n        5:   libpng adaptive filtering if compression level > 5\n             libpng filter type \"none\" if compression level <= 5\n                or if image is grayscale or palette\n\n        6:   libpng adaptive filtering\n\n        7:   \"LOCO\" filtering (intrapixel differing) if writing\n             a MNG, otherwise \"none\".  Did not work in IM-6.7.0-9\n             and earlier because of a missing \"else\".\n\n        8:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), adaptive\n             filtering. Unused prior to IM-6.7.0-10, was same as 6\n\n        9:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), no PNG filters\n             Unused prior to IM-6.7.0-10, was same as 6\n\n    Note that using the -quality option, not all combinations of\n    PNG filter type, zlib compression level, and zlib compression\n    strategy are possible.  This will be addressed soon in a\n    release that accomodates \"-define png:compression-strategy\", etc.\n\n   */\n\n  quality=image_info->quality == UndefinedCompressionQuality ? 75UL :\n     image_info->quality;\n\n  if (quality <= 9)\n    {\n      if (mng_info->write_png_compression_strategy == 0)\n        mng_info->write_png_compression_strategy = Z_HUFFMAN_ONLY+1;\n    }\n\n  else if (mng_info->write_png_compression_level == 0)\n    {\n      int\n        level;\n\n      level=(int) MagickMin((ssize_t) quality/10,9);\n\n      mng_info->write_png_compression_level = level+1;\n    }\n\n  if (mng_info->write_png_compression_strategy == 0)\n    {\n        if ((quality %10) == 8 || (quality %10) == 9)\n#ifdef Z_RLE  /* Z_RLE was added to zlib-1.2.0 */\n          mng_info->write_png_compression_strategy=Z_RLE+1;\n#else\n          mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;\n#endif\n    }\n\n  if (mng_info->write_png_compression_filter == 0)\n        mng_info->write_png_compression_filter=((int) quality % 10) + 1;\n\n  if (logging != MagickFalse)\n    {\n        if (mng_info->write_png_compression_level)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Compression level:    %d\",\n            (int) mng_info->write_png_compression_level-1);\n\n        if (mng_info->write_png_compression_strategy)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Compression strategy: %d\",\n            (int) mng_info->write_png_compression_strategy-1);\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Setting up filtering\");\n\n        if (mng_info->write_png_compression_filter == 6)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: ADAPTIVE\");\n        else if (mng_info->write_png_compression_filter == 0 ||\n                 mng_info->write_png_compression_filter == 1)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: NONE\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: %d\",\n            (int) mng_info->write_png_compression_filter-1);\n    }\n\n  if (mng_info->write_png_compression_level != 0)\n    png_set_compression_level(ping,mng_info->write_png_compression_level-1);\n\n  if (mng_info->write_png_compression_filter == 6)\n    {\n      if (((int) ping_color_type == PNG_COLOR_TYPE_GRAY) ||\n         ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE) ||\n         (quality < 50))\n        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n      else\n        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);\n     }\n  else if (mng_info->write_png_compression_filter == 7 ||\n      mng_info->write_png_compression_filter == 10)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);\n\n  else if (mng_info->write_png_compression_filter == 8)\n    {\n#if defined(PNG_MNG_FEATURES_SUPPORTED) && defined(PNG_INTRAPIXEL_DIFFERENCING)\n      if (mng_info->write_mng)\n      {\n         if (((int) ping_color_type == PNG_COLOR_TYPE_RGB) ||\n             ((int) ping_color_type == PNG_COLOR_TYPE_RGBA))\n        ping_filter_method=PNG_INTRAPIXEL_DIFFERENCING;\n      }\n#endif\n      png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n    }\n\n  else if (mng_info->write_png_compression_filter == 9)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n\n  else if (mng_info->write_png_compression_filter != 0)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,\n       mng_info->write_png_compression_filter-1);\n\n  if (mng_info->write_png_compression_strategy != 0)\n    png_set_compression_strategy(ping,\n       mng_info->write_png_compression_strategy-1);\n\n  ping_interlace_method=image_info->interlace != NoInterlace;\n\n  if (mng_info->write_mng)\n    png_set_sig_bytes(ping,8);\n\n  /* Bail out if cannot meet defined png:bit-depth or png:color-type */\n\n  if (mng_info->write_png_colortype != 0)\n    {\n     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY)\n       if (ping_have_color != MagickFalse)\n         {\n           ping_color_type = PNG_COLOR_TYPE_RGB;\n\n           if (ping_bit_depth < 8)\n             ping_bit_depth=8;\n         }\n\n     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY_ALPHA)\n       if (ping_have_color != MagickFalse)\n         ping_color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n    }\n\n  if (ping_need_colortype_warning != MagickFalse ||\n     ((mng_info->write_png_depth &&\n     (int) mng_info->write_png_depth != ping_bit_depth) ||\n     (mng_info->write_png_colortype &&\n     ((int) mng_info->write_png_colortype-1 != ping_color_type &&\n      mng_info->write_png_colortype != 7 &&\n      !(mng_info->write_png_colortype == 5 && ping_color_type == 0)))))\n    {\n      if (logging != MagickFalse)\n        {\n          if (ping_need_colortype_warning != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Image has transparency but tRNS chunk was excluded\");\n            }\n\n          if (mng_info->write_png_depth)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Defined png:bit-depth=%u, Computed depth=%u\",\n                  mng_info->write_png_depth,\n                  ping_bit_depth);\n            }\n\n          if (mng_info->write_png_colortype)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Defined png:color-type=%u, Computed color type=%u\",\n                  mng_info->write_png_colortype-1,\n                  ping_color_type);\n            }\n        }\n\n      png_warning(ping,\n        \"Cannot write image with defined png:bit-depth or png:color-type.\");\n    }\n\n  if (image_matte != MagickFalse && image->alpha_trait == UndefinedPixelTrait)\n    {\n      /* Add an opaque matte channel */\n      image->alpha_trait = BlendPixelTrait;\n      (void) SetImageAlpha(image,OpaqueAlpha,exception);\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Added an opaque matte channel\");\n    }\n\n  if (number_transparent != 0 || number_semitransparent != 0)\n    {\n      if (ping_color_type < 4)\n        {\n           ping_have_tRNS=MagickTrue;\n           if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Setting ping_have_tRNS=MagickTrue.\");\n        }\n    }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Writing PNG header chunks\");\n\n  png_set_IHDR(ping,ping_info,ping_width,ping_height,\n               ping_bit_depth,ping_color_type,\n               ping_interlace_method,ping_compression_method,\n               ping_filter_method);\n\n  if (ping_color_type == 3 && ping_have_PLTE != MagickFalse)\n    {\n      png_set_PLTE(ping,ping_info,palette,number_colors);\n\n      if (logging != MagickFalse)\n        {\n          for (i=0; i< (ssize_t) number_colors; i++)\n          {\n            if (i < ping_num_trans)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"     PLTE[%d] = (%d,%d,%d), tRNS[%d] = (%d)\",\n                      (int) i,\n                      (int) palette[i].red,\n                      (int) palette[i].green,\n                      (int) palette[i].blue,\n                      (int) i,\n                      (int) ping_trans_alpha[i]);\n             else\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"     PLTE[%d] = (%d,%d,%d)\",\n                      (int) i,\n                      (int) palette[i].red,\n                      (int) palette[i].green,\n                      (int) palette[i].blue);\n           }\n         }\n    }\n\n  /* Only write the iCCP chunk if we are not writing the sRGB chunk. */\n  if (ping_exclude_sRGB != MagickFalse ||\n     (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n  {\n    if ((ping_exclude_tEXt == MagickFalse ||\n       ping_exclude_zTXt == MagickFalse) &&\n       (ping_exclude_iCCP == MagickFalse || ping_exclude_zCCP == MagickFalse))\n    {\n      ResetImageProfileIterator(image);\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        profile=GetImageProfile(image,name);\n\n        if (profile != (StringInfo *) NULL)\n          {\n#ifdef PNG_WRITE_iCCP_SUPPORTED\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0))\n              {\n                ping_have_iCCP = MagickTrue;\n                if (ping_exclude_iCCP == MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Setting up iCCP chunk\");\n\n                    png_set_iCCP(ping,ping_info,(png_charp) name,0,\n#if (PNG_LIBPNG_VER < 10500)\n                    (png_charp) GetStringInfoDatum(profile),\n#else\n                    (const png_byte *) GetStringInfoDatum(profile),\n#endif\n                    (png_uint_32) GetStringInfoLength(profile));\n                  }\n                else\n                  {\n                    /* Do not write hex-encoded ICC chunk */\n                       name=GetNextImageProfile(image);\n                       continue;\n                  }\n              }\n#endif /* WRITE_iCCP */\n\n            if (LocaleCompare(name,\"exif\") == 0)\n              {\n                   /* Do not write hex-encoded ICC chunk; we will\n                      write it later as an eXIf chunk */\n                   name=GetNextImageProfile(image);\n                   continue;\n              }\n\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Setting up zTXt chunk with uuencoded %s profile\",\n                 name);\n              Magick_png_write_raw_profile(image_info,ping,ping_info,\n                (unsigned char *) name,(unsigned char *) name,\n                GetStringInfoDatum(profile),\n                (png_uint_32) GetStringInfoLength(profile));\n          }\n        name=GetNextImageProfile(image);\n      }\n    }\n  }\n\n#if defined(PNG_WRITE_sRGB_SUPPORTED)\n  if ((mng_info->have_write_global_srgb == 0) &&\n      ping_have_iCCP != MagickTrue &&\n      (ping_have_sRGB != MagickFalse ||\n      png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n    {\n      if (ping_exclude_sRGB == MagickFalse)\n        {\n          /*\n            Note image rendering intent.\n          */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Setting up sRGB chunk\");\n\n          (void) png_set_sRGB(ping,ping_info,(\n            Magick_RenderingIntent_to_PNG_RenderingIntent(\n              image->rendering_intent)));\n\n          ping_have_sRGB = MagickTrue;\n        }\n    }\n\n  if ((!mng_info->write_mng) || (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n#endif\n    {\n      if (ping_exclude_gAMA == MagickFalse &&\n          ping_have_iCCP == MagickFalse &&\n          ping_have_sRGB == MagickFalse &&\n          (ping_exclude_sRGB == MagickFalse ||\n          (image->gamma < .45 || image->gamma > .46)))\n      {\n      if ((mng_info->have_write_global_gama == 0) && (image->gamma != 0.0))\n        {\n          /*\n            Note image gamma.\n            To do: check for cHRM+gAMA == sRGB, and write sRGB instead.\n          */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Setting up gAMA chunk\");\n\n          png_set_gAMA(ping,ping_info,image->gamma);\n        }\n      }\n\n      if (ping_exclude_cHRM == MagickFalse && ping_have_sRGB == MagickFalse)\n        {\n          if ((mng_info->have_write_global_chrm == 0) &&\n              (image->chromaticity.red_primary.x != 0.0))\n            {\n              /*\n                Note image chromaticity.\n                Note: if cHRM+gAMA == sRGB write sRGB instead.\n              */\n               PrimaryInfo\n                 bp,\n                 gp,\n                 rp,\n                 wp;\n\n               wp=image->chromaticity.white_point;\n               rp=image->chromaticity.red_primary;\n               gp=image->chromaticity.green_primary;\n               bp=image->chromaticity.blue_primary;\n\n               if (logging != MagickFalse)\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Setting up cHRM chunk\");\n\n               png_set_cHRM(ping,ping_info,wp.x,wp.y,rp.x,rp.y,gp.x,gp.y,\n                   bp.x,bp.y);\n           }\n        }\n    }\n\n  if (ping_exclude_bKGD == MagickFalse)\n    {\n      if (ping_have_bKGD != MagickFalse)\n        {\n          png_set_bKGD(ping,ping_info,&ping_background);\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Setting up bKGD chunk\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      background color = (%d,%d,%d)\",\n                        (int) ping_background.red,\n                        (int) ping_background.green,\n                        (int) ping_background.blue);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      index = %d, gray=%d\",\n                        (int) ping_background.index,\n                        (int) ping_background.gray);\n            }\n         }\n    }\n\n  if (ping_exclude_pHYs == MagickFalse)\n    {\n      if (ping_have_pHYs != MagickFalse)\n        {\n          png_set_pHYs(ping,ping_info,\n             ping_pHYs_x_resolution,\n             ping_pHYs_y_resolution,\n             ping_pHYs_unit_type);\n\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Setting up pHYs chunk\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      x_resolution=%lu\",\n                   (unsigned long) ping_pHYs_x_resolution);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      y_resolution=%lu\",\n                   (unsigned long) ping_pHYs_y_resolution);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      unit_type=%lu\",\n                   (unsigned long) ping_pHYs_unit_type);\n            }\n        }\n    }\n\n#if defined(PNG_tIME_SUPPORTED)\n  if (ping_exclude_tIME == MagickFalse)\n    {\n      const char\n        *timestamp;\n\n      if (image->taint == MagickFalse)\n        {\n          timestamp=GetImageOption(image_info,\"png:tIME\");\n\n          if (timestamp == (const char *) NULL)\n            timestamp=GetImageProperty(image,\"png:tIME\",exception);\n        }\n\n      else\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Reset tIME in tainted image\");\n\n          timestamp=GetImageProperty(image,\"date:modify\",exception);\n        }\n\n      if (timestamp != (const char *) NULL)\n          write_tIME_chunk(image,ping,ping_info,timestamp,exception);\n    }\n#endif\n\n  if (mng_info->need_blob != MagickFalse)\n  {\n    if (OpenBlob(image_info,image,WriteBinaryBlobMode,exception) ==\n       MagickFalse)\n       png_error(ping,\"WriteBlob Failed\");\n\n     ping_have_blob=MagickTrue;\n  }\n\n  png_write_info_before_PLTE(ping, ping_info);\n\n  if (ping_have_tRNS != MagickFalse && ping_color_type < 4)\n    {\n      if (logging != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Calling png_set_tRNS with num_trans=%d\",ping_num_trans);\n        }\n\n      if (ping_color_type == 3)\n         (void) png_set_tRNS(ping, ping_info,\n                ping_trans_alpha,\n                ping_num_trans,\n                NULL);\n\n      else\n        {\n           (void) png_set_tRNS(ping, ping_info,\n                  NULL,\n                  0,\n                  &ping_trans_color);\n\n           if (logging != MagickFalse)\n             {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"     tRNS color   =(%d,%d,%d)\",\n                       (int) ping_trans_color.red,\n                       (int) ping_trans_color.green,\n                       (int) ping_trans_color.blue);\n             }\n         }\n    }\n\n  /* write any png-chunk-b profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-b\",logging);\n\n  png_write_info(ping,ping_info);\n\n  /* write any PNG-chunk-m profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-m\",logging);\n\n  ping_wrote_caNv = MagickFalse;\n\n  /* write caNv chunk */\n  if (ping_exclude_caNv == MagickFalse)\n    {\n      if ((image->page.width != 0 && image->page.width != image->columns) ||\n          (image->page.height != 0 && image->page.height != image->rows) ||\n          image->page.x != 0 || image->page.y != 0)\n        {\n          unsigned char\n            chunk[20];\n\n          (void) WriteBlobMSBULong(image,16L);  /* data length=8 */\n          PNGType(chunk,mng_caNv);\n          LogPNGChunk(logging,mng_caNv,16L);\n          PNGLong(chunk+4,(png_uint_32) image->page.width);\n          PNGLong(chunk+8,(png_uint_32) image->page.height);\n          PNGsLong(chunk+12,(png_int_32) image->page.x);\n          PNGsLong(chunk+16,(png_int_32) image->page.y);\n          (void) WriteBlob(image,20,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,20));\n          ping_wrote_caNv = MagickTrue;\n        }\n    }\n\n#if defined(PNG_oFFs_SUPPORTED)\n  if (ping_exclude_oFFs == MagickFalse && ping_wrote_caNv == MagickFalse)\n    {\n      if (image->page.x || image->page.y)\n        {\n           png_set_oFFs(ping,ping_info,(png_int_32) image->page.x,\n              (png_int_32) image->page.y, 0);\n\n           if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Setting up oFFs chunk with x=%d, y=%d, units=0\",\n                 (int) image->page.x, (int) image->page.y);\n        }\n    }\n#endif\n\n  /* write vpAg chunk (deprecated, replaced by caNv) */\n  if (ping_exclude_vpAg == MagickFalse && ping_wrote_caNv == MagickFalse)\n    {\n      if ((image->page.width != 0 && image->page.width != image->columns) ||\n          (image->page.height != 0 && image->page.height != image->rows))\n        {\n          unsigned char\n            chunk[14];\n\n          (void) WriteBlobMSBULong(image,9L);  /* data length=8 */\n          PNGType(chunk,mng_vpAg);\n          LogPNGChunk(logging,mng_vpAg,9L);\n          PNGLong(chunk+4,(png_uint_32) image->page.width);\n          PNGLong(chunk+8,(png_uint_32) image->page.height);\n          chunk[12]=0;   /* unit = pixels */\n          (void) WriteBlob(image,13,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,13));\n        }\n    }\n\n#if (PNG_LIBPNG_VER == 10206)\n    /* avoid libpng-1.2.6 bug by setting PNG_HAVE_IDAT flag */\n#define PNG_HAVE_IDAT               0x04\n    ping->mode |= PNG_HAVE_IDAT;\n#undef PNG_HAVE_IDAT\n#endif\n\n  png_set_packing(ping);\n  /*\n    Allocate memory.\n  */\n  rowbytes=image->columns;\n  if (image_depth > 8)\n    rowbytes*=2;\n  switch (ping_color_type)\n    {\n      case PNG_COLOR_TYPE_RGB:\n        rowbytes*=3;\n        break;\n\n      case PNG_COLOR_TYPE_GRAY_ALPHA:\n        rowbytes*=2;\n        break;\n\n      case PNG_COLOR_TYPE_RGBA:\n        rowbytes*=4;\n        break;\n\n      default:\n        break;\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Writing PNG image data\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Allocating %.20g bytes of memory for pixels\",(double) rowbytes);\n    }\n  pixel_info=AcquireVirtualMemory(rowbytes,sizeof(*ping_pixels));\n  if (pixel_info == (MemoryInfo *) NULL)\n    png_error(ping,\"Allocation of memory for pixels failed\");\n  ping_pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n\n  /*\n    Initialize image scanlines.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    png_error(ping,\"Memory allocation for quantum_info failed\");\n  quantum_info->format=UndefinedQuantumFormat;\n  SetQuantumDepth(image,quantum_info,image_depth);\n  (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n  num_passes=png_set_interlace_handling(ping);\n\n  if ((!mng_info->write_png8 && !mng_info->write_png24 &&\n       !mng_info->write_png48 && !mng_info->write_png64 &&\n       !mng_info->write_png32) &&\n       (mng_info->IsPalette ||\n       (image_info->type == BilevelType)) &&\n       image_matte == MagickFalse &&\n       ping_have_non_bw == MagickFalse)\n    {\n      /* Palette, Bilevel, or Opaque Monochrome */\n      register const Quantum\n        *p;\n\n      SetQuantumDepth(image,quantum_info,8);\n      for (pass=0; pass < num_passes; pass++)\n      {\n        /*\n          Convert PseudoClass image to a PNG monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          if (logging != MagickFalse && y == 0)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Writing row of pixels (0)\");\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n          if (p == (const Quantum *) NULL)\n            break;\n\n          if (mng_info->IsPalette)\n            {\n              (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                quantum_info,GrayQuantum,ping_pixels,exception);\n              if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_PALETTE &&\n                  mng_info->write_png_depth &&\n                  mng_info->write_png_depth != old_bit_depth)\n                {\n                  /* Undo pixel scaling */\n                  for (i=0; i < (ssize_t) image->columns; i++)\n                     *(ping_pixels+i)=(unsigned char) (*(ping_pixels+i)\n                     >> (8-old_bit_depth));\n                }\n            }\n\n          else\n            {\n              (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                quantum_info,RedQuantum,ping_pixels,exception);\n            }\n\n          if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE)\n            for (i=0; i < (ssize_t) image->columns; i++)\n               *(ping_pixels+i)=(unsigned char) ((*(ping_pixels+i) > 127) ?\n                      255 : 0);\n\n          if (logging != MagickFalse && y == 0)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Writing row of pixels (1)\");\n\n          png_write_row(ping,ping_pixels);\n\n          status=SetImageProgress(image,SaveImageTag,\n              (MagickOffsetType) (pass * image->rows + y),\n              num_passes * image->rows);\n\n          if (status == MagickFalse)\n            break;\n        }\n      }\n    }\n\n  else   /* Not Palette, Bilevel, or Opaque Monochrome */\n    {\n      if ((!mng_info->write_png8 && !mng_info->write_png24 &&\n          !mng_info->write_png48 && !mng_info->write_png64 &&\n          !mng_info->write_png32) && (image_matte != MagickFalse ||\n          (ping_bit_depth >= MAGICKCORE_QUANTUM_DEPTH)) &&\n          (mng_info->IsPalette) && ping_have_color == MagickFalse)\n        {\n          register const Quantum\n            *p;\n\n          for (pass=0; pass < num_passes; pass++)\n          {\n\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n            if (p == (const Quantum *) NULL)\n              break;\n\n            if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n              {\n                if (mng_info->IsPalette)\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,GrayQuantum,ping_pixels,exception);\n\n                else\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RedQuantum,ping_pixels,exception);\n\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"    Writing GRAY PNG pixels (2)\");\n              }\n\n            else /* PNG_COLOR_TYPE_GRAY_ALPHA */\n              {\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Writing GRAY_ALPHA PNG pixels (2)\");\n\n                (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,GrayAlphaQuantum,ping_pixels,exception);\n              }\n\n            if (logging != MagickFalse && y == 0)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Writing row of pixels (2)\");\n\n            png_write_row(ping,ping_pixels);\n\n            status=SetImageProgress(image,SaveImageTag,\n              (MagickOffsetType) (pass * image->rows + y),\n              num_passes * image->rows);\n\n            if (status == MagickFalse)\n              break;\n            }\n          }\n        }\n\n      else\n        {\n          register const Quantum\n            *p;\n\n          for (pass=0; pass < num_passes; pass++)\n          {\n            if ((image_depth > 8) ||\n                mng_info->write_png24 ||\n                mng_info->write_png32 ||\n                mng_info->write_png48 ||\n                mng_info->write_png64 ||\n                (!mng_info->write_png8 && !mng_info->IsPalette))\n            {\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n                if (p == (const Quantum *) NULL)\n                  break;\n\n                if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n                  {\n                    if (image->storage_class == DirectClass)\n                      (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                        quantum_info,RedQuantum,ping_pixels,exception);\n\n                    else\n                      (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                        quantum_info,GrayQuantum,ping_pixels,exception);\n                  }\n\n                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n                  {\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                      quantum_info,GrayAlphaQuantum,ping_pixels,\n                      exception);\n\n                    if (logging != MagickFalse && y == 0)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"    Writing GRAY_ALPHA PNG pixels (3)\");\n                  }\n\n                else if (image_matte != MagickFalse)\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RGBAQuantum,ping_pixels,exception);\n\n                else\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RGBQuantum,ping_pixels,exception);\n\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"    Writing row of pixels (3)\");\n\n                png_write_row(ping,ping_pixels);\n\n                status=SetImageProgress(image,SaveImageTag,\n                  (MagickOffsetType) (pass * image->rows + y),\n                  num_passes * image->rows);\n\n                if (status == MagickFalse)\n                  break;\n              }\n            }\n\n          else\n            /* not ((image_depth > 8) ||\n                mng_info->write_png24 || mng_info->write_png32 ||\n                mng_info->write_png48 || mng_info->write_png64 ||\n                (!mng_info->write_png8 && !mng_info->IsPalette))\n             */\n            {\n              if ((ping_color_type != PNG_COLOR_TYPE_GRAY) &&\n                  (ping_color_type != PNG_COLOR_TYPE_GRAY_ALPHA))\n                {\n                  if (logging != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"  pass %d, Image Is not GRAY or GRAY_ALPHA\",pass);\n\n                  SetQuantumDepth(image,quantum_info,8);\n                  image_depth=8;\n                }\n\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  pass %d, Image Is RGB, 16-bit GRAY, or GRAY_ALPHA\",\n                    pass);\n\n                p=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n                if (p == (const Quantum *) NULL)\n                  break;\n\n                if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n                  {\n                    SetQuantumDepth(image,quantum_info,image->depth);\n\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                       quantum_info,GrayQuantum,ping_pixels,exception);\n                  }\n\n                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n                  {\n                    if (logging != MagickFalse && y == 0)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"  Writing GRAY_ALPHA PNG pixels (4)\");\n\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                         quantum_info,GrayAlphaQuantum,ping_pixels,\n                         exception);\n                  }\n\n                else\n                  {\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                      quantum_info,IndexQuantum,ping_pixels,exception);\n\n                    if (logging != MagickFalse && y <= 2)\n                    {\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Writing row of non-gray pixels (4)\");\n\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  ping_pixels[0]=%d,ping_pixels[1]=%d\",\n                          (int)ping_pixels[0],(int)ping_pixels[1]);\n                    }\n                  }\n                png_write_row(ping,ping_pixels);\n\n                status=SetImageProgress(image,SaveImageTag,\n                  (MagickOffsetType) (pass * image->rows + y),\n                  num_passes * image->rows);\n\n                if (status == MagickFalse)\n                  break;\n              }\n            }\n          }\n        }\n    }\n\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Wrote PNG image data\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Width: %.20g\",(double) ping_width);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Height: %.20g\",(double) ping_height);\n\n      if (mng_info->write_png_depth)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Defined png:bit-depth: %d\",mng_info->write_png_depth);\n        }\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG bit-depth written: %d\",ping_bit_depth);\n\n      if (mng_info->write_png_colortype)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Defined png:color-type: %d\",mng_info->write_png_colortype-1);\n        }\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG color-type written: %d\",ping_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG Interlace method: %d\",ping_interlace_method);\n    }\n  /*\n    Generate text chunks after IDAT.\n  */\n  if (ping_exclude_tEXt == MagickFalse || ping_exclude_zTXt == MagickFalse)\n  {\n    ResetImagePropertyIterator(image);\n    property=GetNextImageProperty(image);\n    while (property != (const char *) NULL)\n    {\n      png_textp\n        text;\n\n      value=GetImageProperty(image,property,exception);\n\n      /* Don't write any \"png:\" or \"jpeg:\" properties; those are just for\n       * \"identify\" or for passing through to another JPEG\n       */\n      if ((LocaleNCompare(property,\"png:\",4) != 0 &&\n           LocaleNCompare(property,\"jpeg:\",5) != 0) &&\n\n\n          /* Suppress density and units if we wrote a pHYs chunk */\n          (ping_exclude_pHYs != MagickFalse      ||\n          LocaleCompare(property,\"density\") != 0 ||\n          LocaleCompare(property,\"units\") != 0) &&\n\n          /* Suppress the IM-generated Date:create and Date:modify */\n          (ping_exclude_date == MagickFalse      ||\n          LocaleNCompare(property, \"Date:\",5) != 0))\n        {\n        if (value != (const char *) NULL)\n          {\n\n#if PNG_LIBPNG_VER >= 10400\n            text=(png_textp) png_malloc(ping,\n                 (png_alloc_size_t) sizeof(png_text));\n#else\n            text=(png_textp) png_malloc(ping,(png_size_t) sizeof(png_text));\n#endif\n            text[0].key=(char *) property;\n            text[0].text=(char *) value;\n            text[0].text_length=strlen(value);\n\n            if (ping_exclude_tEXt != MagickFalse)\n               text[0].compression=PNG_TEXT_COMPRESSION_zTXt;\n\n            else if (ping_exclude_zTXt != MagickFalse)\n               text[0].compression=PNG_TEXT_COMPRESSION_NONE;\n\n            else\n            {\n               text[0].compression=image_info->compression == NoCompression ||\n                 (image_info->compression == UndefinedCompression &&\n                 text[0].text_length < 128) ? PNG_TEXT_COMPRESSION_NONE :\n                 PNG_TEXT_COMPRESSION_zTXt ;\n            }\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Setting up text chunk\");\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    keyword: '%s'\",text[0].key);\n              }\n\n            png_set_text(ping,ping_info,text,1);\n            png_free(ping,text);\n          }\n        }\n      property=GetNextImageProperty(image);\n    }\n  }\n\n  /* write any PNG-chunk-e profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-e\",logging);\n\n  /* write exIf profile */\n  if (ping_have_eXIf != MagickFalse && ping_exclude_eXIf == MagickFalse)\n    {\n      char\n        *name;\n\n      ResetImageProfileIterator(image);\n\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        if (LocaleCompare(name,\"exif\") == 0)\n          {\n            const StringInfo\n              *profile;\n\n            profile=GetImageProfile(image,name);\n\n            if (profile != (StringInfo *) NULL)\n              {\n                png_uint_32\n                  length;\n\n                unsigned char\n                  chunk[4],\n                  *data;\n\n               StringInfo\n                 *ping_profile;\n\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Have eXIf profile\");\n\n               ping_profile=CloneStringInfo(profile);\n               data=GetStringInfoDatum(ping_profile),\n               length=(png_uint_32) GetStringInfoLength(ping_profile);\n\n               PNGType(chunk,mng_eXIf);\n               if (length < 7)\n                 {\n                   ping_profile=DestroyStringInfo(ping_profile);\n                   break;  /* otherwise crashes */\n                 }\n\n               /* skip the \"Exif\\0\\0\" JFIF Exif Header ID */\n               length -= 6;\n\n               LogPNGChunk(logging,chunk,length);\n               (void) WriteBlobMSBULong(image,length);\n               (void) WriteBlob(image,4,chunk);\n               (void) WriteBlob(image,length,data+6);\n               (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),\n                 data+6, (uInt) length));\n               ping_profile=DestroyStringInfo(ping_profile);\n               break;\n             }\n         }\n       name=GetNextImageProfile(image);\n     }\n  }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Writing PNG end info\");\n\n  png_write_end(ping,ping_info);\n\n  if (mng_info->need_fram && (int) image->dispose == BackgroundDispose)\n    {\n      if (mng_info->page.x || mng_info->page.y ||\n          (ping_width != mng_info->page.width) ||\n          (ping_height != mng_info->page.height))\n        {\n          unsigned char\n            chunk[32];\n\n          /*\n            Write FRAM 4 with clipping boundaries followed by FRAM 1.\n          */\n          (void) WriteBlobMSBULong(image,27L);  /* data length=27 */\n          PNGType(chunk,mng_FRAM);\n          LogPNGChunk(logging,mng_FRAM,27L);\n          chunk[4]=4;\n          chunk[5]=0;  /* frame name separator (no name) */\n          chunk[6]=1;  /* flag for changing delay, for next frame only */\n          chunk[7]=0;  /* flag for changing frame timeout */\n          chunk[8]=1;  /* flag for changing frame clipping for next frame */\n          chunk[9]=0;  /* flag for changing frame sync_id */\n          PNGLong(chunk+10,(png_uint_32) (0L)); /* temporary 0 delay */\n          chunk[14]=0; /* clipping boundaries delta type */\n          PNGLong(chunk+15,(png_uint_32) (mng_info->page.x)); /* left cb */\n          PNGLong(chunk+19,\n             (png_uint_32) (mng_info->page.x + ping_width));\n          PNGLong(chunk+23,(png_uint_32) (mng_info->page.y)); /* top cb */\n          PNGLong(chunk+27,\n             (png_uint_32) (mng_info->page.y + ping_height));\n          (void) WriteBlob(image,31,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,31));\n          mng_info->old_framing_mode=4;\n          mng_info->framing_mode=1;\n        }\n\n      else\n        mng_info->framing_mode=3;\n    }\n  if (mng_info->write_mng && !mng_info->need_fram &&\n      ((int) image->dispose == 3))\n     png_error(ping, \"Cannot convert GIF with disposal method 3 to MNG-LC\");\n\n  /*\n    Free PNG resources.\n  */\n\n  png_destroy_write_struct(&ping,&ping_info);\n\n  pixel_info=RelinquishVirtualMemory(pixel_info);\n\n  if (ping_have_blob != MagickFalse)\n     (void) CloseBlob(image);\n\n  image_info=DestroyImageInfo(image_info);\n  image=DestroyImage(image);\n\n  /* Store bit depth actually written */\n  s[0]=(char) ping_bit_depth;\n  s[1]='\\0';\n\n  (void) SetImageProperty(IMimage,\"png:bit-depth-written\",s,exception);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit WriteOnePNGImage()\");\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n   /* }  for navigation to beginning of SETJMP-protected block. Revert to\n    *    Throwing an Exception when an error occurs.\n    */\n\n  return(MagickTrue);\n/*  End write one PNG image */\n\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149699,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static MagickBooleanType ReadPSDChannel(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,\n  const size_t channel,const PSDCompressionType compression,\n  ExceptionInfo *exception)\n{\n  Image\n    *channel_image,\n    *mask;\n\n  MagickOffsetType\n    offset;\n\n  MagickBooleanType\n    status;\n\n  channel_image=image;\n  mask=(Image *) NULL;\n  if (layer_info->channel_info[channel].type < -1)\n    {\n      const char\n        *option;\n      /*\n        Ignore mask that is not a user supplied layer mask, if the mask is\n        disabled or if the flags have unsupported values.\n      */\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n      if ((layer_info->channel_info[channel].type != -2) ||\n          (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&\n           (IsStringTrue(option) == MagickFalse)))\n      {\n        SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);\n        return(MagickTrue);\n      }\n      mask=CloneImage(image,layer_info->mask.page.width,\n        layer_info->mask.page.height,MagickFalse,exception);\n      mask->matte=MagickFalse;\n      channel_image=mask;\n    }\n\n  offset=TellBlob(image);\n  status=MagickTrue;\n  switch(compression)\n  {\n    case Raw:\n      status=ReadPSDChannelRaw(channel_image,psd_info->channels,\n        layer_info->channel_info[channel].type,exception);\n      break;\n    case RLE:\n      {\n        MagickOffsetType\n          *sizes;\n\n        sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);\n        if (sizes == (MagickOffsetType *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        status=ReadPSDChannelRLE(channel_image,psd_info,\n          layer_info->channel_info[channel].type,sizes,exception);\n        sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n      }\n      break;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n      status=ReadPSDChannelZip(channel_image,layer_info->channels,\n        layer_info->channel_info[channel].type,compression,\n        layer_info->channel_info[channel].size-2,exception);\n#else\n      (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n            \"'%s' (ZLIB)\",image->filename);\n#endif\n      break;\n    default:\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n        \"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      break;\n  }\n\n  SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n  if (status == MagickFalse)\n    {\n      if (mask != (Image *) NULL)\n        DestroyImage(mask);\n      ThrowBinaryException(CoderError,\"UnableToDecompressImage\",\n        image->filename);\n    }\n  layer_info->mask.image=mask;\n  return(status);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149700,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static MagickBooleanType ReadPSDChannel(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,\n  const size_t channel,const PSDCompressionType compression,\n  ExceptionInfo *exception)\n{\n  Image\n    *channel_image,\n    *mask;\n\n  MagickOffsetType\n    offset;\n\n  MagickBooleanType\n    status;\n\n  channel_image=image;\n  mask=(Image *) NULL;\n  if (layer_info->channel_info[channel].type < -1)\n    {\n      const char\n        *option;\n      /*\n        Ignore mask that is not a user supplied layer mask, if the mask is\n        disabled or if the flags have unsupported values.\n      */\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n      if ((layer_info->channel_info[channel].type != -2) ||\n          (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&\n           (IsStringTrue(option) == MagickFalse)))\n      {\n        SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);\n        return(MagickTrue);\n      }\n      mask=CloneImage(image,layer_info->mask.page.width,\n        layer_info->mask.page.height,MagickFalse,exception);\n      if (mask != (Image *) NULL)\n        {\n          mask->matte=MagickFalse;\n          channel_image=mask;\n        }\n    }\n\n  offset=TellBlob(image);\n  status=MagickTrue;\n  switch(compression)\n  {\n    case Raw:\n      status=ReadPSDChannelRaw(channel_image,psd_info->channels,\n        layer_info->channel_info[channel].type,exception);\n      break;\n    case RLE:\n      {\n        MagickOffsetType\n          *sizes;\n\n        sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);\n        if (sizes == (MagickOffsetType *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        status=ReadPSDChannelRLE(channel_image,psd_info,\n          layer_info->channel_info[channel].type,sizes,exception);\n        sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n      }\n      break;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n      status=ReadPSDChannelZip(channel_image,layer_info->channels,\n        layer_info->channel_info[channel].type,compression,\n        layer_info->channel_info[channel].size-2,exception);\n#else\n      (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n            \"'%s' (ZLIB)\",image->filename);\n#endif\n      break;\n    default:\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n        \"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      break;\n  }\n\n  SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n  if (status == MagickFalse)\n    {\n      if (mask != (Image *) NULL)\n        DestroyImage(mask);\n      ThrowBinaryException(CoderError,\"UnableToDecompressImage\",\n        image->filename);\n    }\n  layer_info->mask.image=mask;\n  return(status);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149701,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\t/* find the key first */\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* see if we can read it directly */\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error2;\n\n\t/* we can't; see if it's searchable from this process's keyrings\n\t * - we automatically take account of the fact that it may be\n\t *   dangling off an instantiation key\n\t */\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n\n\t/* the key is probably readable - now try to read it */\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key->type->read) {\n\t\t/* Read the data with the semaphore held (since we might sleep)\n\t\t * to protect against the key being updated or revoked.\n\t\t */\n\t\tdown_read(&key->sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\tup_read(&key->sem);\n\t}\n\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149702,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\t/* find the key first */\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n\t\tret = -ENOKEY;\n\t\tgoto error2;\n\t}\n\n\t/* see if we can read it directly */\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error2;\n\n\t/* we can't; see if it's searchable from this process's keyrings\n\t * - we automatically take account of the fact that it may be\n\t *   dangling off an instantiation key\n\t */\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n\n\t/* the key is probably readable - now try to read it */\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key->type->read) {\n\t\t/* Read the data with the semaphore held (since we might sleep)\n\t\t * to protect against the key being updated or revoked.\n\t\t */\n\t\tdown_read(&key->sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\tup_read(&key->sem);\n\t}\n\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149703,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return (*field_rtrn != NULL);\n    case EXPR_FIELD_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_ARRAY_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n        *index_rtrn = expr->array_ref.entry;\n        return true;\n    default:\n        break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149704,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return (*field_rtrn != NULL);\n    case EXPR_FIELD_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return (*elem_rtrn != NULL && *field_rtrn != NULL);\n    case EXPR_ARRAY_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n        *index_rtrn = expr->array_ref.entry;\n\tif (expr->array_ref.element != XKB_ATOM_NONE && *elem_rtrn == NULL)\n\t\treturn false;\n\tif (*field_rtrn == NULL)\n\t\treturn false;\n        return true;\n    default:\n        break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149705,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)\n{\n\tconst char *s = name;\n\n\twhile (1) {\n\t\tconst char *s0 = s;\n\t\tchar *dirname;\n\n\t\t/* Find a directory component, if any.  */\n\t\twhile (1) {\n\t\t\tif (*s == 0) {\n\t\t\t\tif (last && s != s0)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\treturn dir;\n\t\t\t}\n\t\t\t/* This is deliberately slash-only.  */\n\t\t\tif (*s == '/')\n\t\t\t\tbreak;\n\t\t\ts++;\n\t\t}\n\n\t\tdirname = g_strndup (s0, s - s0);\n\t\twhile (*s == '/')\n\t\t\ts++;\n\n\t\tif (strcmp (dirname, \".\") != 0) {\n\t\t\tGsfInput *subdir =\n\t\t\t\tgsf_infile_child_by_name (GSF_INFILE (dir),\n\t\t\t\t\t\t\t  dirname);\n\t\t\tif (subdir) {\n\t\t\t\t/* Undo the ref. */\n\t\t\t\tg_object_unref (subdir);\n\t\t\t\tdir = GSF_INFILE_TAR (subdir);\n\t\t\t} else\n\t\t\t\tdir = tar_create_dir (dir, dirname);\n\t\t}\n\n\t\tg_free (dirname);\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149706,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)\n{\n\tconst char *s = name;\n\n\twhile (1) {\n\t\tconst char *s0 = s;\n\t\tchar *dirname;\n\n\t\t/* Find a directory component, if any.  */\n\t\twhile (1) {\n\t\t\tif (*s == 0) {\n\t\t\t\tif (last && s != s0)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\treturn dir;\n\t\t\t}\n\t\t\t/* This is deliberately slash-only.  */\n\t\t\tif (*s == '/')\n\t\t\t\tbreak;\n\t\t\ts++;\n\t\t}\n\n\t\tdirname = g_strndup (s0, s - s0);\n\t\twhile (*s == '/')\n\t\t\ts++;\n\n\t\tif (strcmp (dirname, \".\") != 0) {\n\t\t\tGsfInput *subdir =\n\t\t\t\tgsf_infile_child_by_name (GSF_INFILE (dir),\n\t\t\t\t\t\t\t  dirname);\n\t\t\tif (subdir) {\n\t\t\t\tdir = GSF_IS_INFILE_TAR (subdir)\n\t\t\t\t\t? GSF_INFILE_TAR (subdir)\n\t\t\t\t\t: dir;\n\t\t\t\t/* Undo the ref. */\n\t\t\t\tg_object_unref (subdir);\n\t\t\t} else\n\t\t\t\tdir = tar_create_dir (dir, dirname);\n\t\t}\n\n\t\tg_free (dirname);\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149707,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(skcipher);\n\n\tif (tfm->__crt_alg->cra_type == &crypto_blkcipher_type)\n\t\treturn crypto_init_skcipher_ops_blkcipher(tfm);\n\n\tif (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type ||\n\t    tfm->__crt_alg->cra_type == &crypto_givcipher_type)\n\t\treturn crypto_init_skcipher_ops_ablkcipher(tfm);\n\n\tskcipher->setkey = alg->setkey;\n\tskcipher->encrypt = alg->encrypt;\n\tskcipher->decrypt = alg->decrypt;\n\tskcipher->ivsize = alg->ivsize;\n\tskcipher->keysize = alg->max_keysize;\n\n\tif (alg->exit)\n\t\tskcipher->base.exit = crypto_skcipher_exit_tfm;\n\n\tif (alg->init)\n\t\treturn alg->init(skcipher);\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149708,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(skcipher);\n\n\tif (tfm->__crt_alg->cra_type == &crypto_blkcipher_type)\n\t\treturn crypto_init_skcipher_ops_blkcipher(tfm);\n\n\tif (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type ||\n\t    tfm->__crt_alg->cra_type == &crypto_givcipher_type)\n\t\treturn crypto_init_skcipher_ops_ablkcipher(tfm);\n\n\tskcipher->setkey = skcipher_setkey;\n\tskcipher->encrypt = alg->encrypt;\n\tskcipher->decrypt = alg->decrypt;\n\tskcipher->ivsize = alg->ivsize;\n\tskcipher->keysize = alg->max_keysize;\n\n\tif (alg->exit)\n\t\tskcipher->base.exit = crypto_skcipher_exit_tfm;\n\n\tif (alg->init)\n\t\treturn alg->init(skcipher);\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149709,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int __init fm10k_init_module(void)\n{\n\tpr_info(\"%s - version %s\\n\", fm10k_driver_string, fm10k_driver_version);\n\tpr_info(\"%s\\n\", fm10k_copyright);\n\n\t/* create driver workqueue */\n\tfm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0,\n\t\t\t\t\t  fm10k_driver_name);\n\n\tfm10k_dbg_init();\n\n\treturn fm10k_register_pci_driver();\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149710,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int __init fm10k_init_module(void)\n{\n\tpr_info(\"%s - version %s\\n\", fm10k_driver_string, fm10k_driver_version);\n\tpr_info(\"%s\\n\", fm10k_copyright);\n\n\t/* create driver workqueue */\n\tfm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0,\n\t\t\t\t\t  fm10k_driver_name);\n\tif (!fm10k_workqueue)\n\t\treturn -ENOMEM;\n\n\tfm10k_dbg_init();\n\n\treturn fm10k_register_pci_driver();\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149711,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void parse_class(RBinFile *binfile, RBinDexObj *bin, RBinDexClass *c,\n\t\t\t int class_index, int *methods, int *sym_count) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\n\tchar *class_name;\n\tint z;\n\tconst ut8 *p, *p_end;\n\n\tif (!c) {\n\t\treturn;\n\t}\n\n\tclass_name = dex_class_name (bin, c);\n\tclass_name = r_str_replace (class_name, \";\", \"\", 0); //TODO: move to func\n\n\tif (!class_name || !*class_name) {\n\t\treturn;\n\t}\n\n\tRBinClass *cls = R_NEW0 (RBinClass);\n\tif (!cls) {\n\t\treturn;\n\t}\n\tcls->name = class_name;\n\tcls->index = class_index;\n\tcls->addr = bin->header.class_offset + class_index * DEX_CLASS_SIZE;\n\tcls->methods = r_list_new ();\n\tif (!cls->methods) {\n\t\tfree (cls);\n\t\treturn;\n\t}\n\tcls->fields = r_list_new ();\n\tif (!cls->fields) {\n\t\tr_list_free (cls->methods);\n\t\tfree (cls);\n\t\treturn;\n\t}\n\tr_list_append (bin->classes_list, cls);\n\tif (dexdump) {\n\t\trbin->cb_printf (\"  Class descriptor  : '%s;'\\n\", class_name);\n\t\trbin->cb_printf (\n\t\t\t\"  Access flags      : 0x%04x (%s)\\n\", c->access_flags,\n\t\t\tcreateAccessFlagStr (c->access_flags, kAccessForClass));\n\t\trbin->cb_printf (\"  Superclass        : '%s'\\n\",\n\t\t\t\t dex_class_super_name (bin, c));\n\t\trbin->cb_printf (\"  Interfaces        -\\n\");\n\t}\n\n\tif (c->interfaces_offset > 0 &&\n\t    bin->header.data_offset < c->interfaces_offset &&\n\t    c->interfaces_offset <\n\t\t    bin->header.data_offset + bin->header.data_size) {\n\t\tp = r_buf_get_at (binfile->buf, c->interfaces_offset, NULL);\n\t\tint types_list_size = r_read_le32(p);\n\t\tif (types_list_size < 0 || types_list_size >= bin->header.types_size ) {\n\t\t\treturn;\n\t\t}\n\t\tfor (z = 0; z < types_list_size; z++) {\n\t\t\tint t = r_read_le16 (p + 4 + z * 2);\n\t\t\tif (t > 0 && t < bin->header.types_size ) {\n\t\t\t\tint tid = bin->types[t].descriptor_id;\n\t\t\t\tif (dexdump) {\n\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\"    #%d              : '%s'\\n\",\n\t\t\t\t\t\tz, getstr (bin, tid));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO: this is quite ugly\n\tif (!c || !c->class_data_offset) {\n\t\tif (dexdump) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"  Static fields     -\\n  Instance fields   \"\n\t\t\t\t\"-\\n  Direct methods    -\\n  Virtual methods   \"\n\t\t\t\t\"-\\n\");\n\t\t}\n\t} else {\n\t\t// TODO: move to func, def or inline\n\t\t// class_data_offset => [class_offset, class_defs_off+class_defs_size*32]\n\t\tif (bin->header.class_offset > c->class_data_offset ||\n\t\t    c->class_data_offset <\n\t\t\t    bin->header.class_offset +\n\t\t\t\t    bin->header.class_size * DEX_CLASS_SIZE) {\n\t\t\treturn;\n\t\t}\n\n\t\tp = r_buf_get_at (binfile->buf, c->class_data_offset, NULL);\n\t\tp_end = p + binfile->buf->length - c->class_data_offset;\n\t\t//XXX check for NULL!!\n\t\tc->class_data = (struct dex_class_data_item_t *)malloc (\n\t\t\tsizeof (struct dex_class_data_item_t));\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->static_fields_size);\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->instance_fields_size);\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->direct_methods_size);\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->virtual_methods_size);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Static fields     -\\n\"); \n\t\t}\n\t\tp = parse_dex_class_fields (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->static_fields_size, true);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Instance fields   -\\n\");\n\t\t}\n\t\tp = parse_dex_class_fields (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->instance_fields_size, false);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Direct methods    -\\n\");\n\t\t}\n\t\tp = parse_dex_class_method (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->direct_methods_size, methods, true);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Virtual methods   -\\n\");\n\t\t}\n\t\tp = parse_dex_class_method (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->virtual_methods_size, methods, false);\n\t}\n\n\tif (dexdump) { \n\t\tchar *source_file = getstr (bin, c->source_file);\n\t\tif (!source_file) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"  source_file_idx   : %d (unknown)\\n\\n\",\n\t\t\t\tc->source_file);\n\t\t} else {\n\t\t\trbin->cb_printf (\"  source_file_idx   : %d (%s)\\n\\n\",\n\t\t\t\t\t c->source_file, source_file);\n\t\t}\n\t}\n\t// TODO:!!!!\n\t// FIX: FREE BEFORE ALLOCATE!!!\n\t//free (class_name);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149712,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void parse_class(RBinFile *binfile, RBinDexObj *bin, RBinDexClass *c,\n\t\t\t int class_index, int *methods, int *sym_count) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\n\tchar *class_name;\n\tint z;\n\tconst ut8 *p, *p_end;\n\n\tif (!c) {\n\t\treturn;\n\t}\n\n\tclass_name = dex_class_name (bin, c);\n\tclass_name = r_str_replace (class_name, \";\", \"\", 0); //TODO: move to func\n\n\tif (!class_name || !*class_name) {\n\t\treturn;\n\t}\n\n\tRBinClass *cls = R_NEW0 (RBinClass);\n\tif (!cls) {\n\t\treturn;\n\t}\n\tcls->name = class_name;\n\tcls->index = class_index;\n\tcls->addr = bin->header.class_offset + class_index * DEX_CLASS_SIZE;\n\tcls->methods = r_list_new ();\n\tif (!cls->methods) {\n\t\tfree (cls);\n\t\treturn;\n\t}\n\tcls->fields = r_list_new ();\n\tif (!cls->fields) {\n\t\tr_list_free (cls->methods);\n\t\tfree (cls);\n\t\treturn;\n\t}\n\tr_list_append (bin->classes_list, cls);\n\tif (dexdump) {\n\t\trbin->cb_printf (\"  Class descriptor  : '%s;'\\n\", class_name);\n\t\trbin->cb_printf (\n\t\t\t\"  Access flags      : 0x%04x (%s)\\n\", c->access_flags,\n\t\t\tcreateAccessFlagStr (c->access_flags, kAccessForClass));\n\t\trbin->cb_printf (\"  Superclass        : '%s'\\n\",\n\t\t\t\t dex_class_super_name (bin, c));\n\t\trbin->cb_printf (\"  Interfaces        -\\n\");\n\t}\n\n\tif (c->interfaces_offset > 0 &&\n\t    bin->header.data_offset < c->interfaces_offset &&\n\t    c->interfaces_offset <\n\t\t    bin->header.data_offset + bin->header.data_size) {\n\t\tp = r_buf_get_at (binfile->buf, c->interfaces_offset, NULL);\n\t\tint types_list_size = r_read_le32 (p);\n\t\tif (types_list_size < 0 || types_list_size >= bin->header.types_size ) {\n\t\t\treturn;\n\t\t}\n\t\tfor (z = 0; z < types_list_size; z++) {\n\t\t\tint t = r_read_le16 (p + 4 + z * 2);\n\t\t\tif (t > 0 && t < bin->header.types_size ) {\n\t\t\t\tint tid = bin->types[t].descriptor_id;\n\t\t\t\tif (dexdump) {\n\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\"    #%d              : '%s'\\n\",\n\t\t\t\t\t\tz, getstr (bin, tid));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO: this is quite ugly\n\tif (!c || !c->class_data_offset) {\n\t\tif (dexdump) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"  Static fields     -\\n  Instance fields   \"\n\t\t\t\t\"-\\n  Direct methods    -\\n  Virtual methods   \"\n\t\t\t\t\"-\\n\");\n\t\t}\n\t} else {\n\t\t// TODO: move to func, def or inline\n\t\t// class_data_offset => [class_offset, class_defs_off+class_defs_size*32]\n\t\tif (bin->header.class_offset > c->class_data_offset ||\n\t\t    c->class_data_offset <\n\t\t\t    bin->header.class_offset +\n\t\t\t\t    bin->header.class_size * DEX_CLASS_SIZE) {\n\t\t\treturn;\n\t\t}\n\n\t\tp = r_buf_get_at (binfile->buf, c->class_data_offset, NULL);\n\t\tp_end = p + binfile->buf->length - c->class_data_offset;\n\t\t//XXX check for NULL!!\n\t\tc->class_data = (struct dex_class_data_item_t *)malloc (\n\t\t\tsizeof (struct dex_class_data_item_t));\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->static_fields_size);\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->instance_fields_size);\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->direct_methods_size);\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->virtual_methods_size);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Static fields     -\\n\"); \n\t\t}\n\t\tp = parse_dex_class_fields (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->static_fields_size, true);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Instance fields   -\\n\");\n\t\t}\n\t\tp = parse_dex_class_fields (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->instance_fields_size, false);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Direct methods    -\\n\");\n\t\t}\n\t\tp = parse_dex_class_method (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->direct_methods_size, methods, true);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Virtual methods   -\\n\");\n\t\t}\n\t\tp = parse_dex_class_method (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->virtual_methods_size, methods, false);\n\t}\n\n\tif (dexdump) { \n\t\tchar *source_file = getstr (bin, c->source_file);\n\t\tif (!source_file) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"  source_file_idx   : %d (unknown)\\n\\n\",\n\t\t\t\tc->source_file);\n\t\t} else {\n\t\t\trbin->cb_printf (\"  source_file_idx   : %d (%s)\\n\\n\",\n\t\t\t\t\t c->source_file, source_file);\n\t\t}\n\t}\n\t// TODO:!!!!\n\t// FIX: FREE BEFORE ALLOCATE!!!\n\t//free (class_name);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149713,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "struct edid *drm_load_edid_firmware(struct drm_connector *connector)\n{\n\tconst char *connector_name = connector->name;\n\tchar *edidname, *last, *colon, *fwstr, *edidstr, *fallback = NULL;\n\tstruct edid *edid;\n\n\tif (edid_firmware[0] == '\\0')\n\t\treturn ERR_PTR(-ENOENT);\n\n\t/*\n\t * If there are multiple edid files specified and separated\n\t * by commas, search through the list looking for one that\n\t * matches the connector.\n\t *\n\t * If there's one or more that doesn't specify a connector, keep\n \t * the last one found one as a fallback.\n \t */\n \tfwstr = kstrdup(edid_firmware, GFP_KERNEL);\n \tedidstr = fwstr;\n \n \twhile ((edidname = strsep(&edidstr, \",\"))) {\n\t\t\tif (strncmp(connector_name, edidname, colon - edidname))\n\t\t\t\tcontinue;\n\t\t\tedidname = colon + 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*edidname != '\\0') /* corner case: multiple ',' */\n\t\t\tfallback = edidname;\n\t}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141409,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "struct edid *drm_load_edid_firmware(struct drm_connector *connector)\n{\n\tconst char *connector_name = connector->name;\n\tchar *edidname, *last, *colon, *fwstr, *edidstr, *fallback = NULL;\n\tstruct edid *edid;\n\n\tif (edid_firmware[0] == '\\0')\n\t\treturn ERR_PTR(-ENOENT);\n\n\t/*\n\t * If there are multiple edid files specified and separated\n\t * by commas, search through the list looking for one that\n\t * matches the connector.\n\t *\n\t * If there's one or more that doesn't specify a connector, keep\n \t * the last one found one as a fallback.\n \t */\n \tfwstr = kstrdup(edid_firmware, GFP_KERNEL);\n\tif (!fwstr)\n\t\treturn ERR_PTR(-ENOMEM);\n \tedidstr = fwstr;\n \n \twhile ((edidname = strsep(&edidstr, \",\"))) {\n\t\t\tif (strncmp(connector_name, edidname, colon - edidname))\n\t\t\t\tcontinue;\n\t\t\tedidname = colon + 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*edidname != '\\0') /* corner case: multiple ',' */\n\t\t\tfallback = edidname;\n\t}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141410,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *alg,\n                                      X509_ALGOR **pmaskHash)\n{\n    const unsigned char *p;\n    int plen;\n    RSA_PSS_PARAMS *pss;\n\n    *pmaskHash = NULL;\n\n    if (!alg->parameter || alg->parameter->type != V_ASN1_SEQUENCE)\n        return NULL;\n    p = alg->parameter->value.sequence->data;\n    plen = alg->parameter->value.sequence->length;\n    pss = d2i_RSA_PSS_PARAMS(NULL, &p, plen);\n\n    if (!pss)\n        return NULL;\n\n     if (pss->maskGenAlgorithm) {\n         ASN1_TYPE *param = pss->maskGenAlgorithm->parameter;\n         if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) == NID_mgf1\n            && param->type == V_ASN1_SEQUENCE) {\n             p = param->value.sequence->data;\n             plen = param->value.sequence->length;\n             *pmaskHash = d2i_X509_ALGOR(NULL, &p, plen);\n        }\n    }\n\n    return pss;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141417,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *alg,\n                                      X509_ALGOR **pmaskHash)\n{\n    const unsigned char *p;\n    int plen;\n    RSA_PSS_PARAMS *pss;\n\n    *pmaskHash = NULL;\n\n    if (!alg->parameter || alg->parameter->type != V_ASN1_SEQUENCE)\n        return NULL;\n    p = alg->parameter->value.sequence->data;\n    plen = alg->parameter->value.sequence->length;\n    pss = d2i_RSA_PSS_PARAMS(NULL, &p, plen);\n\n    if (!pss)\n        return NULL;\n\n     if (pss->maskGenAlgorithm) {\n         ASN1_TYPE *param = pss->maskGenAlgorithm->parameter;\n         if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) == NID_mgf1\n            && param && param->type == V_ASN1_SEQUENCE) {\n             p = param->value.sequence->data;\n             plen = param->value.sequence->length;\n             *pmaskHash = d2i_X509_ALGOR(NULL, &p, plen);\n        }\n    }\n\n    return pss;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141418,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static X509_ALGOR *rsa_mgf1_decode(X509_ALGOR *alg)\n {\n     const unsigned char *p;\n     int plen;\n    if (alg == NULL)\n         return NULL;\n     if (OBJ_obj2nid(alg->algorithm) != NID_mgf1)\n         return NULL;\n    if (alg->parameter->type != V_ASN1_SEQUENCE)\n        return NULL;\n\n    p = alg->parameter->value.sequence->data;\n    plen = alg->parameter->value.sequence->length;\n    return d2i_X509_ALGOR(NULL, &p, plen);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141419,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static X509_ALGOR *rsa_mgf1_decode(X509_ALGOR *alg)\n {\n     const unsigned char *p;\n     int plen;\n    if (alg == NULL || alg->parameter == NULL)\n         return NULL;\n     if (OBJ_obj2nid(alg->algorithm) != NID_mgf1)\n         return NULL;\n    if (alg->parameter->type != V_ASN1_SEQUENCE)\n        return NULL;\n\n    p = alg->parameter->value.sequence->data;\n    plen = alg->parameter->value.sequence->length;\n    return d2i_X509_ALGOR(NULL, &p, plen);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141420,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "pax_decode_header (struct tar_sparse_file *file)\n{\n  if (file->stat_info->sparse_major > 0)\n    {\n      uintmax_t u;\n      char nbuf[UINTMAX_STRSIZE_BOUND];\n      union block *blk;\n      char *p;\n      size_t i;\n      off_t start;\n      \n#define COPY_BUF(b,buf,src) do                                     \\\n {                                                                 \\\n   char *endp = b->buffer + BLOCKSIZE;                             \\\n   char *dst = buf;                                                \\\n   do                                                              \\\n     {                                                             \\\n       if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \\\n         {                                                         \\\n           ERROR ((0, 0, _(\"%s: numeric overflow in sparse archive member\"), \\\n\t          file->stat_info->orig_file_name));               \\\n           return false;                                           \\\n         }                                                         \\\n       if (src == endp)                                            \\\n \t {                                                         \\\n \t   set_next_block_after (b);                               \\\n            b = find_next_block ();                                 \\\n            src = b->buffer;                                        \\\n \t   endp = b->buffer + BLOCKSIZE;                           \\\n \t }                                                         \\\n   while (*dst++ != '\\n');                                         \\\n   dst[-1] = 0;                                                    \\\n } while (0)\n\n      start = current_block_ordinal ();\n      set_next_block_after (current_header);\n       start = current_block_ordinal ();\n       set_next_block_after (current_header);\n       blk = find_next_block ();\n       p = blk->buffer;\n       COPY_BUF (blk,nbuf,p);\n       if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))\n\t}\n      file->stat_info->sparse_map_size = u;\n      file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,\n\t\t\t\t\t     sizeof (*file->stat_info->sparse_map));\n      file->stat_info->sparse_map_avail = 0;\n      for (i = 0; i < file->stat_info->sparse_map_size; i++)\n\t{\n\t  struct sp_array sp;\n\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.offset = u;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.numbytes = u;\n\t  sparse_add_map (file->stat_info, &sp);\n\t}\n      set_next_block_after (blk);\n\n      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);\n    }\n\n  return true;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141433,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "pax_decode_header (struct tar_sparse_file *file)\n{\n  if (file->stat_info->sparse_major > 0)\n    {\n      uintmax_t u;\n      char nbuf[UINTMAX_STRSIZE_BOUND];\n      union block *blk;\n      char *p;\n      size_t i;\n      off_t start;\n      \n#define COPY_BUF(b,buf,src) do                                     \\\n {                                                                 \\\n   char *endp = b->buffer + BLOCKSIZE;                             \\\n   char *dst = buf;                                                \\\n   do                                                              \\\n     {                                                             \\\n       if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \\\n         {                                                         \\\n           ERROR ((0, 0, _(\"%s: numeric overflow in sparse archive member\"), \\\n\t          file->stat_info->orig_file_name));               \\\n           return false;                                           \\\n         }                                                         \\\n       if (src == endp)                                            \\\n \t {                                                         \\\n \t   set_next_block_after (b);                               \\\n            b = find_next_block ();                                 \\\n           if (!b)                                                 \\\n             FATAL_ERROR ((0, 0, _(\"Unexpected EOF in archive\"))); \\\n            src = b->buffer;                                        \\\n \t   endp = b->buffer + BLOCKSIZE;                           \\\n \t }                                                         \\\n   while (*dst++ != '\\n');                                         \\\n   dst[-1] = 0;                                                    \\\n } while (0)\n\n      start = current_block_ordinal ();\n      set_next_block_after (current_header);\n       start = current_block_ordinal ();\n       set_next_block_after (current_header);\n       blk = find_next_block ();\n      if (!blk)\n        FATAL_ERROR ((0, 0, _(\"Unexpected EOF in archive\")));\n       p = blk->buffer;\n       COPY_BUF (blk,nbuf,p);\n       if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))\n\t}\n      file->stat_info->sparse_map_size = u;\n      file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,\n\t\t\t\t\t     sizeof (*file->stat_info->sparse_map));\n      file->stat_info->sparse_map_avail = 0;\n      for (i = 0; i < file->stat_info->sparse_map_size; i++)\n\t{\n\t  struct sp_array sp;\n\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.offset = u;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.numbytes = u;\n\t  sparse_add_map (file->stat_info, &sp);\n\t}\n      set_next_block_after (blk);\n\n      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);\n    }\n\n  return true;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141434,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int main (int argc, char *argv[])\n{\n  int objectsCount = 0;\n  Guint numOffset = 0;\n  std::vector<Object> pages;\n  std::vector<Guint> offsets;\n  XRef *yRef, *countRef;\n  FILE *f;\n  OutStream *outStr;\n  int i;\n  int j, rootNum;\n  std::vector<PDFDoc *>docs;\n  int majorVersion = 0;\n  int minorVersion = 0;\n  char *fileName = argv[argc - 1];\n  int exitCode;\n\n  exitCode = 99;\n  const GBool ok = parseArgs (argDesc, &argc, argv);\n  if (!ok || argc < 3 || printVersion || printHelp) {\n    fprintf(stderr, \"pdfunite version %s\\n\", PACKAGE_VERSION);\n    fprintf(stderr, \"%s\\n\", popplerCopyright);\n    fprintf(stderr, \"%s\\n\", xpdfCopyright);\n    if (!printVersion) {\n      printUsage(\"pdfunite\", \"<PDF-sourcefile-1>..<PDF-sourcefile-n> <PDF-destfile>\",\n\targDesc);\n    }\n    if (printVersion || printHelp)\n      exitCode = 0;\n    return exitCode;\n  }\n  exitCode = 0;\n  globalParams = new GlobalParams();\n\n  for (i = 1; i < argc - 1; i++) {\n    GooString *gfileName = new GooString(argv[i]);\n    PDFDoc *doc = new PDFDoc(gfileName, NULL, NULL, NULL);\n    if (doc->isOk() && !doc->isEncrypted()) {\n      docs.push_back(doc);\n      if (doc->getPDFMajorVersion() > majorVersion) {\n        majorVersion = doc->getPDFMajorVersion();\n        minorVersion = doc->getPDFMinorVersion();\n      } else if (doc->getPDFMajorVersion() == majorVersion) {\n        if (doc->getPDFMinorVersion() > minorVersion) {\n          minorVersion = doc->getPDFMinorVersion();\n        }\n      }\n    } else if (doc->isOk()) {\n      error(errUnimplemented, -1, \"Could not merge encrypted files ('{0:s}')\", argv[i]);\n      return -1;\n    } else {\n      error(errSyntaxError, -1, \"Could not merge damaged documents ('{0:s}')\", argv[i]);\n      return -1;\n    }\n  }\n\n  if (!(f = fopen(fileName, \"wb\"))) {\n    error(errIO, -1, \"Could not open file '{0:s}'\", fileName);\n    return -1;\n  }\n  outStr = new FileOutStream(f, 0);\n\n  yRef = new XRef();\n  countRef = new XRef();\n  yRef->add(0, 65535, 0, gFalse);\n  PDFDoc::writeHeader(outStr, majorVersion, minorVersion);\n\n  Object intents;\n  Object afObj;\n  Object ocObj;\n  Object names;\n  if (docs.size() >= 1) {\n    Object catObj;\n    docs[0]->getXRef()->getCatalog(&catObj);\n    Dict *catDict = catObj.getDict();\n     catDict->lookup(\"OutputIntents\", &intents);\n     catDict->lookupNF(\"AcroForm\", &afObj);\n     Ref *refPage = docs[0]->getCatalog()->getPageRef(1);\n    if (!afObj.isNull()) {\n       docs[0]->markAcroForm(&afObj, yRef, countRef, 0, refPage->num, refPage->num);\n     }\n     catDict->lookupNF(\"OCProperties\", &ocObj);\n    if (!ocObj.isNull() && ocObj.isDict()) {\n       docs[0]->markPageObjects(ocObj.getDict(), yRef, countRef, 0, refPage->num, refPage->num);\n     }\n     catDict->lookup(\"Names\", &names);\n    if (!names.isNull() && names.isDict()) {\n       docs[0]->markPageObjects(names.getDict(), yRef, countRef, 0, refPage->num, refPage->num);\n     }\n     if (intents.isArray() && intents.arrayGetLength() > 0) {\n      for (i = 1; i < (int) docs.size(); i++) {\n        Object pagecatObj, pageintents;\n        docs[i]->getXRef()->getCatalog(&pagecatObj);\n        Dict *pagecatDict = pagecatObj.getDict();\n        pagecatDict->lookup(\"OutputIntents\", &pageintents);\n        if (pageintents.isArray() && pageintents.arrayGetLength() > 0) {\n          for (j = intents.arrayGetLength() - 1; j >= 0; j--) {\n            Object intent;\n            intents.arrayGet(j, &intent, 0);\n            if (intent.isDict()) {\n              Object idf;\n              intent.dictLookup(\"OutputConditionIdentifier\", &idf);\n              if (idf.isString()) {\n                GooString *gidf = idf.getString();\n                GBool removeIntent = gTrue;\n                for (int k = 0; k < pageintents.arrayGetLength(); k++) {\n                  Object pgintent;\n                  pageintents.arrayGet(k, &pgintent, 0);\n                  if (pgintent.isDict()) {\n                    Object pgidf;\n                    pgintent.dictLookup(\"OutputConditionIdentifier\", &pgidf);\n                    if (pgidf.isString()) {\n                      GooString *gpgidf = pgidf.getString();\n                      if (gpgidf->cmp(gidf) == 0) {\n                        pgidf.free();\n                        removeIntent = gFalse;\n                        break;\n                      }\n                    }\n                    pgidf.free();\n                  }\n                }\n                if (removeIntent) {\n                  intents.arrayRemove(j);\n                  error(errSyntaxWarning, -1, \"Output intent {0:s} missing in pdf {1:s}, removed\",\n                   gidf->getCString(), docs[i]->getFileName()->getCString());\n                }\n              } else {\n                intents.arrayRemove(j);\n                error(errSyntaxWarning, -1, \"Invalid output intent dict, missing required OutputConditionIdentifier\");\n              }\n              idf.free();\n            } else {\n              intents.arrayRemove(j);\n            }\n            intent.free();\n          }\n        } else {\n          error(errSyntaxWarning, -1, \"Output intents differs, remove them all\");\n          intents.free();\n          break;\n        }\n        pagecatObj.free();\n        pageintents.free();\n      }\n    }\n    if (intents.isArray() && intents.arrayGetLength() > 0) {\n      for (j = intents.arrayGetLength() - 1; j >= 0; j--) {\n        Object intent;\n        intents.arrayGet(j, &intent, 0);\n        if (intent.isDict()) {\n          docs[0]->markPageObjects(intent.getDict(), yRef, countRef, numOffset, 0, 0);\n        } else {\n          intents.arrayRemove(j);\n        }\n        intent.free();\n      }\n    }\n    catObj.free();\n  }\n \n   for (i = 0; i < (int) docs.size(); i++) {\n     for (j = 1; j <= docs[i]->getNumPages(); j++) {\n       PDFRectangle *cropBox = NULL;\n       if (docs[i]->getCatalog()->getPage(j)->isCropped())\n         cropBox = docs[i]->getCatalog()->getPage(j)->getCropBox();\n      Object page;\n      docs[i]->getXRef()->fetch(refPage->num, refPage->gen, &page);\n      Dict *pageDict = page.getDict();\n      Dict *resDict = docs[i]->getCatalog()->getPage(j)->getResourceDict();\n      if (resDict) {\n        Object *newResource = new Object();\n        newResource->initDict(resDict);\n        pageDict->set(\"Resources\", newResource);\n        delete newResource;\n      }\n      pages.push_back(page);\n      offsets.push_back(numOffset);\n      docs[i]->markPageObjects(pageDict, yRef, countRef, numOffset, refPage->num, refPage->num);\n      Object annotsObj;\n      pageDict->lookupNF(\"Annots\", &annotsObj);\n      if (!annotsObj.isNull()) {\n        docs[i]->markAnnotations(&annotsObj, yRef, countRef, numOffset, refPage->num, refPage->num);\n        annotsObj.free();\n      }\n    }\n    Object pageCatObj, pageNames, pageForm;\n    docs[i]->getXRef()->getCatalog(&pageCatObj);\n    Dict *pageCatDict = pageCatObj.getDict();\n    pageCatDict->lookup(\"Names\", &pageNames);\n    if (!pageNames.isNull() && pageNames.isDict()) {\n      if (!names.isDict()) {\n        names.free();\n        names.initDict(yRef);\n      }\n      doMergeNameDict(docs[i], yRef, countRef, 0, 0, names.getDict(), pageNames.getDict(), numOffset);\n    }\n    pageCatDict->lookup(\"AcroForm\", &pageForm);\n    if (i > 0 && !pageForm.isNull() && pageForm.isDict()) {\n      if (afObj.isNull()) {\n        pageCatDict->lookupNF(\"AcroForm\", &afObj);\n      } else if (afObj.isDict()) {\n        doMergeFormDict(afObj.getDict(), pageForm.getDict(), numOffset);\n      }\n    }\n    pageForm.free();\n    pageNames.free();\n    pageCatObj.free();\n    objectsCount += docs[i]->writePageObjects(outStr, yRef, numOffset, gTrue);\n    numOffset = yRef->getNumObjects() + 1;\n  }\n\n  rootNum = yRef->getNumObjects() + 1;\n  yRef->add(rootNum, 0, outStr->getPos(), gTrue);\n  outStr->printf(\"%d 0 obj\\n\", rootNum);\n  outStr->printf(\"<< /Type /Catalog /Pages %d 0 R\", rootNum + 1);\n  if (intents.isArray() && intents.arrayGetLength() > 0) {\n    outStr->printf(\" /OutputIntents [\");\n    for (j = 0; j < intents.arrayGetLength(); j++) {\n      Object intent;\n      intents.arrayGet(j, &intent, 0);\n      if (intent.isDict()) {\n        PDFDoc::writeObject(&intent, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n      }\n      intent.free();\n    }\n    outStr->printf(\"]\");\n  }\n  intents.free();\n  if (!afObj.isNull()) {\n    outStr->printf(\" /AcroForm \");\n    PDFDoc::writeObject(&afObj, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n    afObj.free();\n  }\n  if (!ocObj.isNull() && ocObj.isDict()) {\n    outStr->printf(\" /OCProperties \");\n    PDFDoc::writeObject(&ocObj, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n    ocObj.free();\n  }\n  if (!names.isNull() && names.isDict()) {\n    outStr->printf(\" /Names \");\n    PDFDoc::writeObject(&names, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n    names.free();\n  }\n  outStr->printf(\">>\\nendobj\\n\");\n  objectsCount++;\n\n  yRef->add(rootNum + 1, 0, outStr->getPos(), gTrue);\n  outStr->printf(\"%d 0 obj\\n\", rootNum + 1);\n  outStr->printf(\"<< /Type /Pages /Kids [\");\n  for (j = 0; j < (int) pages.size(); j++)\n    outStr->printf(\" %d 0 R\", rootNum + j + 2);\n  outStr->printf(\" ] /Count %zd >>\\nendobj\\n\", pages.size());\n  objectsCount++;\n\n  for (i = 0; i < (int) pages.size(); i++) {\n    yRef->add(rootNum + i + 2, 0, outStr->getPos(), gTrue);\n    outStr->printf(\"%d 0 obj\\n\", rootNum + i + 2);\n    outStr->printf(\"<< \");\n    Dict *pageDict = pages[i].getDict();\n    for (j = 0; j < pageDict->getLength(); j++) {\n      if (j > 0)\n\toutStr->printf(\" \");\n      const char *key = pageDict->getKey(j);\n      Object value;\n      pageDict->getValNF(j, &value);\n      if (strcmp(key, \"Parent\") == 0) {\n        outStr->printf(\"/Parent %d 0 R\", rootNum + 1);\n      } else {\n        outStr->printf(\"/%s \", key);\n        PDFDoc::writeObject(&value, outStr, yRef, offsets[i], NULL, cryptRC4, 0, 0, 0);\n      }\n      value.free();\n    }\n    outStr->printf(\" >>\\nendobj\\n\");\n    objectsCount++;\n  }\n  Goffset uxrefOffset = outStr->getPos();\n  Ref ref;\n  ref.num = rootNum;\n  ref.gen = 0;\n  Dict *trailerDict = PDFDoc::createTrailerDict(objectsCount, gFalse, 0, &ref, yRef,\n                                                fileName, outStr->getPos());\n  PDFDoc::writeXRefTableTrailer(trailerDict, yRef, gTrue, // write all entries according to ISO 32000-1, 7.5.4 Cross-Reference Table: \"For a file that has never been incrementally updated, the cross-reference section shall contain only one subsection, whose object numbering begins at 0.\"\n                                uxrefOffset, outStr, yRef);\n  delete trailerDict;\n\n  outStr->close();\n  delete outStr;\n  fclose(f);\n  delete yRef;\n  delete countRef;\n  for (j = 0; j < (int) pages.size (); j++) pages[j].free();\n  for (i = 0; i < (int) docs.size (); i++) delete docs[i];\n  delete globalParams;\n  return exitCode;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141477,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int main (int argc, char *argv[])\n{\n  int objectsCount = 0;\n  Guint numOffset = 0;\n  std::vector<Object> pages;\n  std::vector<Guint> offsets;\n  XRef *yRef, *countRef;\n  FILE *f;\n  OutStream *outStr;\n  int i;\n  int j, rootNum;\n  std::vector<PDFDoc *>docs;\n  int majorVersion = 0;\n  int minorVersion = 0;\n  char *fileName = argv[argc - 1];\n  int exitCode;\n\n  exitCode = 99;\n  const GBool ok = parseArgs (argDesc, &argc, argv);\n  if (!ok || argc < 3 || printVersion || printHelp) {\n    fprintf(stderr, \"pdfunite version %s\\n\", PACKAGE_VERSION);\n    fprintf(stderr, \"%s\\n\", popplerCopyright);\n    fprintf(stderr, \"%s\\n\", xpdfCopyright);\n    if (!printVersion) {\n      printUsage(\"pdfunite\", \"<PDF-sourcefile-1>..<PDF-sourcefile-n> <PDF-destfile>\",\n\targDesc);\n    }\n    if (printVersion || printHelp)\n      exitCode = 0;\n    return exitCode;\n  }\n  exitCode = 0;\n  globalParams = new GlobalParams();\n\n  for (i = 1; i < argc - 1; i++) {\n    GooString *gfileName = new GooString(argv[i]);\n    PDFDoc *doc = new PDFDoc(gfileName, NULL, NULL, NULL);\n    if (doc->isOk() && !doc->isEncrypted()) {\n      docs.push_back(doc);\n      if (doc->getPDFMajorVersion() > majorVersion) {\n        majorVersion = doc->getPDFMajorVersion();\n        minorVersion = doc->getPDFMinorVersion();\n      } else if (doc->getPDFMajorVersion() == majorVersion) {\n        if (doc->getPDFMinorVersion() > minorVersion) {\n          minorVersion = doc->getPDFMinorVersion();\n        }\n      }\n    } else if (doc->isOk()) {\n      error(errUnimplemented, -1, \"Could not merge encrypted files ('{0:s}')\", argv[i]);\n      return -1;\n    } else {\n      error(errSyntaxError, -1, \"Could not merge damaged documents ('{0:s}')\", argv[i]);\n      return -1;\n    }\n  }\n\n  if (!(f = fopen(fileName, \"wb\"))) {\n    error(errIO, -1, \"Could not open file '{0:s}'\", fileName);\n    return -1;\n  }\n  outStr = new FileOutStream(f, 0);\n\n  yRef = new XRef();\n  countRef = new XRef();\n  yRef->add(0, 65535, 0, gFalse);\n  PDFDoc::writeHeader(outStr, majorVersion, minorVersion);\n\n  Object intents;\n  Object afObj;\n  Object ocObj;\n  Object names;\n  if (docs.size() >= 1) {\n    Object catObj;\n    docs[0]->getXRef()->getCatalog(&catObj);\n    Dict *catDict = catObj.getDict();\n     catDict->lookup(\"OutputIntents\", &intents);\n     catDict->lookupNF(\"AcroForm\", &afObj);\n     Ref *refPage = docs[0]->getCatalog()->getPageRef(1);\n    if (!afObj.isNull() && refPage) {\n       docs[0]->markAcroForm(&afObj, yRef, countRef, 0, refPage->num, refPage->num);\n     }\n     catDict->lookupNF(\"OCProperties\", &ocObj);\n    if (!ocObj.isNull() && ocObj.isDict() && refPage) {\n       docs[0]->markPageObjects(ocObj.getDict(), yRef, countRef, 0, refPage->num, refPage->num);\n     }\n     catDict->lookup(\"Names\", &names);\n    if (!names.isNull() && names.isDict() && refPage) {\n       docs[0]->markPageObjects(names.getDict(), yRef, countRef, 0, refPage->num, refPage->num);\n     }\n     if (intents.isArray() && intents.arrayGetLength() > 0) {\n      for (i = 1; i < (int) docs.size(); i++) {\n        Object pagecatObj, pageintents;\n        docs[i]->getXRef()->getCatalog(&pagecatObj);\n        Dict *pagecatDict = pagecatObj.getDict();\n        pagecatDict->lookup(\"OutputIntents\", &pageintents);\n        if (pageintents.isArray() && pageintents.arrayGetLength() > 0) {\n          for (j = intents.arrayGetLength() - 1; j >= 0; j--) {\n            Object intent;\n            intents.arrayGet(j, &intent, 0);\n            if (intent.isDict()) {\n              Object idf;\n              intent.dictLookup(\"OutputConditionIdentifier\", &idf);\n              if (idf.isString()) {\n                GooString *gidf = idf.getString();\n                GBool removeIntent = gTrue;\n                for (int k = 0; k < pageintents.arrayGetLength(); k++) {\n                  Object pgintent;\n                  pageintents.arrayGet(k, &pgintent, 0);\n                  if (pgintent.isDict()) {\n                    Object pgidf;\n                    pgintent.dictLookup(\"OutputConditionIdentifier\", &pgidf);\n                    if (pgidf.isString()) {\n                      GooString *gpgidf = pgidf.getString();\n                      if (gpgidf->cmp(gidf) == 0) {\n                        pgidf.free();\n                        removeIntent = gFalse;\n                        break;\n                      }\n                    }\n                    pgidf.free();\n                  }\n                }\n                if (removeIntent) {\n                  intents.arrayRemove(j);\n                  error(errSyntaxWarning, -1, \"Output intent {0:s} missing in pdf {1:s}, removed\",\n                   gidf->getCString(), docs[i]->getFileName()->getCString());\n                }\n              } else {\n                intents.arrayRemove(j);\n                error(errSyntaxWarning, -1, \"Invalid output intent dict, missing required OutputConditionIdentifier\");\n              }\n              idf.free();\n            } else {\n              intents.arrayRemove(j);\n            }\n            intent.free();\n          }\n        } else {\n          error(errSyntaxWarning, -1, \"Output intents differs, remove them all\");\n          intents.free();\n          break;\n        }\n        pagecatObj.free();\n        pageintents.free();\n      }\n    }\n    if (intents.isArray() && intents.arrayGetLength() > 0) {\n      for (j = intents.arrayGetLength() - 1; j >= 0; j--) {\n        Object intent;\n        intents.arrayGet(j, &intent, 0);\n        if (intent.isDict()) {\n          docs[0]->markPageObjects(intent.getDict(), yRef, countRef, numOffset, 0, 0);\n        } else {\n          intents.arrayRemove(j);\n        }\n        intent.free();\n      }\n    }\n    catObj.free();\n  }\n \n   for (i = 0; i < (int) docs.size(); i++) {\n     for (j = 1; j <= docs[i]->getNumPages(); j++) {\n      if (!docs[i]->getCatalog()->getPage(j)) {\n        continue;\n      }\n\n       PDFRectangle *cropBox = NULL;\n       if (docs[i]->getCatalog()->getPage(j)->isCropped())\n         cropBox = docs[i]->getCatalog()->getPage(j)->getCropBox();\n      Object page;\n      docs[i]->getXRef()->fetch(refPage->num, refPage->gen, &page);\n      Dict *pageDict = page.getDict();\n      Dict *resDict = docs[i]->getCatalog()->getPage(j)->getResourceDict();\n      if (resDict) {\n        Object *newResource = new Object();\n        newResource->initDict(resDict);\n        pageDict->set(\"Resources\", newResource);\n        delete newResource;\n      }\n      pages.push_back(page);\n      offsets.push_back(numOffset);\n      docs[i]->markPageObjects(pageDict, yRef, countRef, numOffset, refPage->num, refPage->num);\n      Object annotsObj;\n      pageDict->lookupNF(\"Annots\", &annotsObj);\n      if (!annotsObj.isNull()) {\n        docs[i]->markAnnotations(&annotsObj, yRef, countRef, numOffset, refPage->num, refPage->num);\n        annotsObj.free();\n      }\n    }\n    Object pageCatObj, pageNames, pageForm;\n    docs[i]->getXRef()->getCatalog(&pageCatObj);\n    Dict *pageCatDict = pageCatObj.getDict();\n    pageCatDict->lookup(\"Names\", &pageNames);\n    if (!pageNames.isNull() && pageNames.isDict()) {\n      if (!names.isDict()) {\n        names.free();\n        names.initDict(yRef);\n      }\n      doMergeNameDict(docs[i], yRef, countRef, 0, 0, names.getDict(), pageNames.getDict(), numOffset);\n    }\n    pageCatDict->lookup(\"AcroForm\", &pageForm);\n    if (i > 0 && !pageForm.isNull() && pageForm.isDict()) {\n      if (afObj.isNull()) {\n        pageCatDict->lookupNF(\"AcroForm\", &afObj);\n      } else if (afObj.isDict()) {\n        doMergeFormDict(afObj.getDict(), pageForm.getDict(), numOffset);\n      }\n    }\n    pageForm.free();\n    pageNames.free();\n    pageCatObj.free();\n    objectsCount += docs[i]->writePageObjects(outStr, yRef, numOffset, gTrue);\n    numOffset = yRef->getNumObjects() + 1;\n  }\n\n  rootNum = yRef->getNumObjects() + 1;\n  yRef->add(rootNum, 0, outStr->getPos(), gTrue);\n  outStr->printf(\"%d 0 obj\\n\", rootNum);\n  outStr->printf(\"<< /Type /Catalog /Pages %d 0 R\", rootNum + 1);\n  if (intents.isArray() && intents.arrayGetLength() > 0) {\n    outStr->printf(\" /OutputIntents [\");\n    for (j = 0; j < intents.arrayGetLength(); j++) {\n      Object intent;\n      intents.arrayGet(j, &intent, 0);\n      if (intent.isDict()) {\n        PDFDoc::writeObject(&intent, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n      }\n      intent.free();\n    }\n    outStr->printf(\"]\");\n  }\n  intents.free();\n  if (!afObj.isNull()) {\n    outStr->printf(\" /AcroForm \");\n    PDFDoc::writeObject(&afObj, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n    afObj.free();\n  }\n  if (!ocObj.isNull() && ocObj.isDict()) {\n    outStr->printf(\" /OCProperties \");\n    PDFDoc::writeObject(&ocObj, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n    ocObj.free();\n  }\n  if (!names.isNull() && names.isDict()) {\n    outStr->printf(\" /Names \");\n    PDFDoc::writeObject(&names, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n    names.free();\n  }\n  outStr->printf(\">>\\nendobj\\n\");\n  objectsCount++;\n\n  yRef->add(rootNum + 1, 0, outStr->getPos(), gTrue);\n  outStr->printf(\"%d 0 obj\\n\", rootNum + 1);\n  outStr->printf(\"<< /Type /Pages /Kids [\");\n  for (j = 0; j < (int) pages.size(); j++)\n    outStr->printf(\" %d 0 R\", rootNum + j + 2);\n  outStr->printf(\" ] /Count %zd >>\\nendobj\\n\", pages.size());\n  objectsCount++;\n\n  for (i = 0; i < (int) pages.size(); i++) {\n    yRef->add(rootNum + i + 2, 0, outStr->getPos(), gTrue);\n    outStr->printf(\"%d 0 obj\\n\", rootNum + i + 2);\n    outStr->printf(\"<< \");\n    Dict *pageDict = pages[i].getDict();\n    for (j = 0; j < pageDict->getLength(); j++) {\n      if (j > 0)\n\toutStr->printf(\" \");\n      const char *key = pageDict->getKey(j);\n      Object value;\n      pageDict->getValNF(j, &value);\n      if (strcmp(key, \"Parent\") == 0) {\n        outStr->printf(\"/Parent %d 0 R\", rootNum + 1);\n      } else {\n        outStr->printf(\"/%s \", key);\n        PDFDoc::writeObject(&value, outStr, yRef, offsets[i], NULL, cryptRC4, 0, 0, 0);\n      }\n      value.free();\n    }\n    outStr->printf(\" >>\\nendobj\\n\");\n    objectsCount++;\n  }\n  Goffset uxrefOffset = outStr->getPos();\n  Ref ref;\n  ref.num = rootNum;\n  ref.gen = 0;\n  Dict *trailerDict = PDFDoc::createTrailerDict(objectsCount, gFalse, 0, &ref, yRef,\n                                                fileName, outStr->getPos());\n  PDFDoc::writeXRefTableTrailer(trailerDict, yRef, gTrue, // write all entries according to ISO 32000-1, 7.5.4 Cross-Reference Table: \"For a file that has never been incrementally updated, the cross-reference section shall contain only one subsection, whose object numbering begins at 0.\"\n                                uxrefOffset, outStr, yRef);\n  delete trailerDict;\n\n  outStr->close();\n  delete outStr;\n  fclose(f);\n  delete yRef;\n  delete countRef;\n  for (j = 0; j < (int) pages.size (); j++) pages[j].free();\n  for (i = 0; i < (int) docs.size (); i++) delete docs[i];\n  delete globalParams;\n  return exitCode;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141478,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static inline int hpel_motion(MpegEncContext *s,\n                              uint8_t *dest, uint8_t *src,\n                              int src_x, int src_y,\n                              op_pixels_func *pix_op,\n                              int motion_x, int motion_y)\n{\n    int dxy = 0;\n    int emu = 0;\n\n    src_x += motion_x >> 1;\n    src_y += motion_y >> 1;\n\n    /* WARNING: do no forget half pels */\n    src_x = av_clip(src_x, -16, s->width); // FIXME unneeded for emu?\n    if (src_x != s->width)\n        dxy |= motion_x & 1;\n    src_y = av_clip(src_y, -16, s->height);\n    if (src_y != s->height)\n         dxy |= (motion_y & 1) << 1;\n     src += src_y * s->linesize + src_x;\n \n    if (s->unrestricted_mv) {\n        if ((unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) - 8, 0) ||\n            (unsigned)src_y > FFMAX(s->v_edge_pos - (motion_y & 1) - 8, 0)) {\n            s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, src,\n                                     s->linesize, s->linesize,\n                                     9, 9,\n                                     src_x, src_y, s->h_edge_pos,\n                                     s->v_edge_pos);\n            src = s->sc.edge_emu_buffer;\n            emu = 1;\n        }\n     }\n     pix_op[dxy](dest, src, s->linesize, 8);\n     return emu;\n    }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141491,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static inline int hpel_motion(MpegEncContext *s,\n                              uint8_t *dest, uint8_t *src,\n                              int src_x, int src_y,\n                              op_pixels_func *pix_op,\n                              int motion_x, int motion_y)\n{\n    int dxy = 0;\n    int emu = 0;\n\n    src_x += motion_x >> 1;\n    src_y += motion_y >> 1;\n\n    /* WARNING: do no forget half pels */\n    src_x = av_clip(src_x, -16, s->width); // FIXME unneeded for emu?\n    if (src_x != s->width)\n        dxy |= motion_x & 1;\n    src_y = av_clip(src_y, -16, s->height);\n    if (src_y != s->height)\n         dxy |= (motion_y & 1) << 1;\n     src += src_y * s->linesize + src_x;\n \n    if ((unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) - 8, 0) ||\n        (unsigned)src_y > FFMAX(s->v_edge_pos - (motion_y & 1) - 8, 0)) {\n        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, src,\n                                 s->linesize, s->linesize,\n                                 9, 9, src_x, src_y,\n                                 s->h_edge_pos, s->v_edge_pos);\n        src = s->sc.edge_emu_buffer;\n        emu = 1;\n     }\n     pix_op[dxy](dest, src, s->linesize, 8);\n     return emu;\n    }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141492,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,\n                      X509 **pissuer, int *pscore, unsigned int *preasons,\n                      STACK_OF(X509_CRL) *crls)\n{\n    int i, crl_score, best_score = *pscore;\n    unsigned int reasons, best_reasons = 0;\n    X509 *x = ctx->current_cert;\n    X509_CRL *crl, *best_crl = NULL;\n    X509 *crl_issuer = NULL, *best_crl_issuer = NULL;\n\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n         crl = sk_X509_CRL_value(crls, i);\n         reasons = *preasons;\n         crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);\n        if (crl_score < best_score)\n             continue;\n         /* If current CRL is equivalent use it if it is newer */\n        if (crl_score == best_score) {\n             int day, sec;\n             if (ASN1_TIME_diff(&day, &sec, X509_CRL_get_lastUpdate(best_crl),\n                                X509_CRL_get_lastUpdate(crl)) == 0)\n                continue;\n            /*\n             * ASN1_TIME_diff never returns inconsistent signs for |day|\n             * and |sec|.\n             */\n            if (day <= 0 && sec <= 0)\n                continue;\n        }\n        best_crl = crl;\n        best_crl_issuer = crl_issuer;\n        best_score = crl_score;\n        best_reasons = reasons;\n    }\n\n    if (best_crl) {\n        if (*pcrl)\n            X509_CRL_free(*pcrl);\n        *pcrl = best_crl;\n        *pissuer = best_crl_issuer;\n        *pscore = best_score;\n        *preasons = best_reasons;\n        CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL);\n        if (*pdcrl) {\n            X509_CRL_free(*pdcrl);\n            *pdcrl = NULL;\n        }\n        get_delta_sk(ctx, pdcrl, pscore, best_crl, crls);\n    }\n\n    if (best_score >= CRL_SCORE_VALID)\n        return 1;\n\n    return 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141495,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,\n                      X509 **pissuer, int *pscore, unsigned int *preasons,\n                      STACK_OF(X509_CRL) *crls)\n{\n    int i, crl_score, best_score = *pscore;\n    unsigned int reasons, best_reasons = 0;\n    X509 *x = ctx->current_cert;\n    X509_CRL *crl, *best_crl = NULL;\n    X509 *crl_issuer = NULL, *best_crl_issuer = NULL;\n\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n         crl = sk_X509_CRL_value(crls, i);\n         reasons = *preasons;\n         crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);\n        if (crl_score < best_score || crl_score == 0)\n             continue;\n         /* If current CRL is equivalent use it if it is newer */\n        if (crl_score == best_score && best_crl != NULL) {\n             int day, sec;\n             if (ASN1_TIME_diff(&day, &sec, X509_CRL_get_lastUpdate(best_crl),\n                                X509_CRL_get_lastUpdate(crl)) == 0)\n                continue;\n            /*\n             * ASN1_TIME_diff never returns inconsistent signs for |day|\n             * and |sec|.\n             */\n            if (day <= 0 && sec <= 0)\n                continue;\n        }\n        best_crl = crl;\n        best_crl_issuer = crl_issuer;\n        best_score = crl_score;\n        best_reasons = reasons;\n    }\n\n    if (best_crl) {\n        if (*pcrl)\n            X509_CRL_free(*pcrl);\n        *pcrl = best_crl;\n        *pissuer = best_crl_issuer;\n        *pscore = best_score;\n        *preasons = best_reasons;\n        CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL);\n        if (*pdcrl) {\n            X509_CRL_free(*pdcrl);\n            *pdcrl = NULL;\n        }\n        get_delta_sk(ctx, pdcrl, pscore, best_crl, crls);\n    }\n\n    if (best_score >= CRL_SCORE_VALID)\n        return 1;\n\n    return 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141496,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void vrend_renderer_context_destroy(uint32_t handle)\n{\n   struct vrend_decode_ctx *ctx;\n   bool ret;\n\n    if (handle >= VREND_MAX_CTX)\n       return;\n \n    ctx = dec_ctx[handle];\n    if (!ctx)\n       return;\n      vrend_hw_switch_context(dec_ctx[0]->grctx, true);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141503,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void vrend_renderer_context_destroy(uint32_t handle)\n{\n   struct vrend_decode_ctx *ctx;\n   bool ret;\n\n    if (handle >= VREND_MAX_CTX)\n       return;\n \n   /* never destroy context 0 here, it will be destroyed in vrend_decode_reset()*/\n   if (handle == 0) {\n      return;\n   }\n\n    ctx = dec_ctx[handle];\n    if (!ctx)\n       return;\n      vrend_hw_switch_context(dec_ctx[0]->grctx, true);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141504,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "intuit_diff_type (bool need_header, mode_t *p_file_type)\n{\n    file_offset this_line = 0;\n    file_offset first_command_line = -1;\n    char first_ed_command_letter = 0;\n    lin fcl_line = 0; /* Pacify 'gcc -W'.  */\n    bool this_is_a_command = false;\n    bool stars_this_line = false;\n    bool extended_headers = false;\n    enum nametype i;\n    struct stat st[3];\n    int stat_errno[3];\n    int version_controlled[3];\n    enum diff retval;\n    mode_t file_type;\n    size_t indent = 0;\n\n    for (i = OLD;  i <= INDEX;  i++)\n      if (p_name[i]) {\n\t  free (p_name[i]);\n\t  p_name[i] = 0;\n        }\n    for (i = 0; i < ARRAY_SIZE (invalid_names); i++)\n\tinvalid_names[i] = NULL;\n    for (i = OLD; i <= NEW; i++)\n      if (p_timestr[i])\n\t{\n\t  free(p_timestr[i]);\n\t  p_timestr[i] = 0;\n\t}\n    for (i = OLD; i <= NEW; i++)\n      if (p_sha1[i])\n\t{\n\t  free (p_sha1[i]);\n\t  p_sha1[i] = 0;\n\t}\n    p_git_diff = false;\n    for (i = OLD; i <= NEW; i++)\n      {\n\tp_mode[i] = 0;\n\tp_copy[i] = false;\n\tp_rename[i] = false;\n      }\n\n    /* Ed and normal format patches don't have filename headers.  */\n    if (diff_type == ED_DIFF || diff_type == NORMAL_DIFF)\n      need_header = false;\n\n    version_controlled[OLD] = -1;\n    version_controlled[NEW] = -1;\n    version_controlled[INDEX] = -1;\n    p_rfc934_nesting = 0;\n    p_timestamp[OLD].tv_sec = p_timestamp[NEW].tv_sec = -1;\n    p_says_nonexistent[OLD] = p_says_nonexistent[NEW] = 0;\n    Fseek (pfp, p_base, SEEK_SET);\n    p_input_line = p_bline - 1;\n    for (;;) {\n\tchar *s;\n\tchar *t;\n\tfile_offset previous_line = this_line;\n\tbool last_line_was_command = this_is_a_command;\n\tbool stars_last_line = stars_this_line;\n\tsize_t indent_last_line = indent;\n\tchar ed_command_letter;\n\tbool strip_trailing_cr;\n\tsize_t chars_read;\n\n\tindent = 0;\n\tthis_line = file_tell (pfp);\n\tchars_read = pget_line (0, 0, false, false);\n\tif (chars_read == (size_t) -1)\n\t  xalloc_die ();\n\tif (! chars_read) {\n\t    if (first_ed_command_letter) {\n\t\t\t\t\t/* nothing but deletes!? */\n\t\tp_start = first_command_line;\n\t\tp_sline = fcl_line;\n\t\tretval = ED_DIFF;\n\t\tgoto scan_exit;\n\t    }\n\t    else {\n\t\tp_start = this_line;\n\t\tp_sline = p_input_line;\n\t\tif (extended_headers)\n\t\t  {\n\t\t    /* Patch contains no hunks; any diff type will do. */\n\t\t    retval = UNI_DIFF;\n\t\t    goto scan_exit;\n\t\t  }\n\t\treturn NO_DIFF;\n\t    }\n\t}\n\tstrip_trailing_cr = 2 <= chars_read && buf[chars_read - 2] == '\\r';\n\tfor (s = buf; *s == ' ' || *s == '\\t' || *s == 'X'; s++) {\n\t    if (*s == '\\t')\n\t\tindent = (indent + 8) & ~7;\n\t    else\n\t\tindent++;\n\t}\n\tif (ISDIGIT (*s))\n\t  {\n\t    for (t = s + 1; ISDIGIT (*t) || *t == ',';  t++)\n\t      /* do nothing */ ;\n\t    if (*t == 'd' || *t == 'c' || *t == 'a')\n\t      {\n\t\tfor (t++;  ISDIGIT (*t) || *t == ',';  t++)\n\t\t  /* do nothing */ ;\n\t\tfor (; *t == ' ' || *t == '\\t'; t++)\n\t\t  /* do nothing */ ;\n\t\tif (*t == '\\r')\n\t\t  t++;\n\t\tthis_is_a_command = (*t == '\\n');\n\t      }\n\t  }\n\tif (! need_header\n\t    && first_command_line < 0\n\t    && ((ed_command_letter = get_ed_command_letter (s))\n\t\t|| this_is_a_command)) {\n\t    first_command_line = this_line;\n\t    first_ed_command_letter = ed_command_letter;\n\t    fcl_line = p_input_line;\n\t    p_indent = indent;\t\t/* assume this for now */\n\t    p_strip_trailing_cr = strip_trailing_cr;\n\t}\n\tif (!stars_last_line && strnEQ(s, \"*** \", 4))\n\t  {\n\t    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],\n\t\t       &p_timestamp[OLD]);\n\t    need_header = false;\n\t  }\n\telse if (strnEQ(s, \"+++ \", 4))\n\t  {\n\t    /* Swap with NEW below.  */\n\t    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],\n\t\t       &p_timestamp[OLD]);\n\t    need_header = false;\n\t    p_strip_trailing_cr = strip_trailing_cr;\n\t  }\n\telse if (strnEQ(s, \"Index:\", 6))\n\t  {\n\t    fetchname (s+6, strippath, &p_name[INDEX], (char **) 0, NULL);\n\t    need_header = false;\n\t    p_strip_trailing_cr = strip_trailing_cr;\n\t  }\n\telse if (strnEQ(s, \"Prereq:\", 7))\n\t  {\n\t    for (t = s + 7;  ISSPACE ((unsigned char) *t);  t++)\n\t      /* do nothing */ ;\n\t    revision = t;\n\t    for (t = revision;  *t;  t++)\n\t      if (ISSPACE ((unsigned char) *t))\n\t\t{\n\t\t  char const *u;\n\t\t  for (u = t + 1;  ISSPACE ((unsigned char) *u);  u++)\n\t\t    /* do nothing */ ;\n\t\t  if (*u)\n\t\t    {\n\t\t      char numbuf[LINENUM_LENGTH_BOUND + 1];\n\t\t      say (\"Prereq: with multiple words at line %s of patch\\n\",\n\t\t\t   format_linenum (numbuf, this_line));\n\t\t    }\n\t\t  break;\n\t\t}\n\t    if (t == revision)\n\t\trevision = 0;\n\t    else {\n\t\tchar oldc = *t;\n\t\t*t = '\\0';\n\t\trevision = xstrdup (revision);\n\t\t*t = oldc;\n\t    }\n\t  }\n\telse if (strnEQ (s, \"diff --git \", 11))\n\t  {\n\t    char const *u;\n\n\t    if (extended_headers)\n\t      {\n\t\tp_start = this_line;\n\t\tp_sline = p_input_line;\n\t\t/* Patch contains no hunks; any diff type will do. */\n\t\tretval = UNI_DIFF;\n\t\tgoto scan_exit;\n\t      }\n\n\t    for (i = OLD; i <= NEW; i++)\n\t      {\n\t\tfree (p_name[i]);\n\t\tp_name[i] = 0;\n\t      }\n\t    if (! ((p_name[OLD] = parse_name (s + 11, strippath, &u))\n\t\t   && ISSPACE ((unsigned char) *u)\n\t\t   && (p_name[NEW] = parse_name (u, strippath, &u))\n\t\t   && (u = skip_spaces (u), ! *u)))\n\t      for (i = OLD; i <= NEW; i++)\n\t\t{\n\t\t  free (p_name[i]);\n\t\t  p_name[i] = 0;\n\t\t}\n\t    p_git_diff = true;\n\t    need_header = false;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"index \", 6))\n\t  {\n\t    char const *u, *v;\n\t    if ((u = skip_hex_digits (s + 6))\n\t\t&& u[0] == '.' && u[1] == '.'\n\t\t&& (v = skip_hex_digits (u + 2))\n\t\t&& (! *v || ISSPACE ((unsigned char) *v)))\n\t      {\n\t\tget_sha1(&p_sha1[OLD], s + 6, u);\n\t\tget_sha1(&p_sha1[NEW], u + 2, v);\n\t\tp_says_nonexistent[OLD] = sha1_says_nonexistent (p_sha1[OLD]);\n\t\tp_says_nonexistent[NEW] = sha1_says_nonexistent (p_sha1[NEW]);\n\t\tif (*(v = skip_spaces (v)))\n\t\t  p_mode[OLD] = p_mode[NEW] = fetchmode (v);\n\t\textended_headers = true;\n\t      }\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"old mode \", 9))\n\t  {\n\t    p_mode[OLD] = fetchmode (s + 9);\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"new mode \", 9))\n\t  {\n\t    p_mode[NEW] = fetchmode (s + 9);\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"deleted file mode \", 18))\n\t  {\n\t    p_mode[OLD] = fetchmode (s + 18);\n\t    p_says_nonexistent[NEW] = 2;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"new file mode \", 14))\n\t  {\n\t    p_mode[NEW] = fetchmode (s + 14);\n\t    p_says_nonexistent[OLD] = 2;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"rename from \", 12))\n\t  {\n\t    /* Git leaves out the prefix in the file name in this header,\n\t       so we can only ignore the file name.  */\n\t    p_rename[OLD] = true;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"rename to \", 10))\n\t  {\n\t    /* Git leaves out the prefix in the file name in this header,\n\t       so we can only ignore the file name.  */\n\t    p_rename[NEW] = true;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"copy from \", 10))\n\t  {\n\t    /* Git leaves out the prefix in the file name in this header,\n\t       so we can only ignore the file name.  */\n\t    p_copy[OLD] = true;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"copy to \", 8))\n\t  {\n\t    /* Git leaves out the prefix in the file name in this header,\n\t       so we can only ignore the file name.  */\n\t    p_copy[NEW] = true;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"GIT binary patch\", 16))\n\t  {\n\t    p_start = this_line;\n\t    p_sline = p_input_line;\n\t    retval = GIT_BINARY_DIFF;\n\t    goto scan_exit;\n\t  }\n\telse\n\t  {\n\t    for (t = s;  t[0] == '-' && t[1] == ' ';  t += 2)\n\t      /* do nothing */ ;\n\t    if (strnEQ(t, \"--- \", 4))\n\t      {\n\t\tstruct timespec timestamp;\n\t\ttimestamp.tv_sec = -1;\n\t\tfetchname (t+4, strippath, &p_name[NEW], &p_timestr[NEW],\n\t\t\t   &timestamp);\n\t\tneed_header = false;\n\t\tif (timestamp.tv_sec != -1)\n\t\t  {\n\t\t    p_timestamp[NEW] = timestamp;\n\t\t    p_rfc934_nesting = (t - s) >> 1;\n\t\t  }\n\t\tp_strip_trailing_cr = strip_trailing_cr;\n\t      }\n\t  }\n\tif (need_header)\n\t  continue;\n\tif ((diff_type == NO_DIFF || diff_type == ED_DIFF) &&\n\t  first_command_line >= 0 &&\n\t  strEQ(s, \".\\n\") ) {\n\t    p_start = first_command_line;\n\t    p_sline = fcl_line;\n\t    retval = ED_DIFF;\n\t    goto scan_exit;\n\t}\n\tif ((diff_type == NO_DIFF || diff_type == UNI_DIFF)\n\t    && strnEQ(s, \"@@ -\", 4)) {\n\n\t    /* 'p_name', 'p_timestr', and 'p_timestamp' are backwards;\n\t       swap them.  */\n\t    struct timespec ti = p_timestamp[OLD];\n\t    p_timestamp[OLD] = p_timestamp[NEW];\n\t    p_timestamp[NEW] = ti;\n\t    t = p_name[OLD];\n\t    p_name[OLD] = p_name[NEW];\n\t    p_name[NEW] = t;\n\t    t = p_timestr[OLD];\n\t    p_timestr[OLD] = p_timestr[NEW];\n\t    p_timestr[NEW] = t;\n\n\t    s += 4;\n\t    if (s[0] == '0' && !ISDIGIT (s[1]))\n\t      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;\n\t    while (*s != ' ' && *s != '\\n')\n\t      s++;\n\t    while (*s == ' ')\n\t      s++;\n\t    if (s[0] == '+' && s[1] == '0' && !ISDIGIT (s[2]))\n\t      p_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;\n\t    p_indent = indent;\n\t    p_start = this_line;\n\t    p_sline = p_input_line;\n\t    retval = UNI_DIFF;\n\t    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)\n\t\t   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))\n\t\t&& ! p_name[INDEX] && need_header)\n\t      {\n\t\tchar numbuf[LINENUM_LENGTH_BOUND + 1];\n\t\tsay (\"missing header for unified diff at line %s of patch\\n\",\n\t\t     format_linenum (numbuf, p_sline));\n\t      }\n\t    goto scan_exit;\n\t}\n\tstars_this_line = strnEQ(s, \"********\", 8);\n\tif ((diff_type == NO_DIFF\n\t     || diff_type == CONTEXT_DIFF\n\t     || diff_type == NEW_CONTEXT_DIFF)\n\t    && stars_last_line && indent_last_line == indent\n\t    && strnEQ (s, \"*** \", 4)) {\n\t    s += 4;\n\t    if (s[0] == '0' && !ISDIGIT (s[1]))\n\t      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;\n\t    /* if this is a new context diff the character just before */\n\t    /* the newline is a '*'. */\n\t    while (*s != '\\n')\n\t\ts++;\n\t    p_indent = indent;\n\t    p_strip_trailing_cr = strip_trailing_cr;\n\t    p_start = previous_line;\n\t    p_sline = p_input_line - 1;\n\t    retval = (*(s-1) == '*' ? NEW_CONTEXT_DIFF : CONTEXT_DIFF);\n\n\t    {\n\t      /* Scan the first hunk to see whether the file contents\n\t\t appear to have been deleted.  */\n\t      file_offset saved_p_base = p_base;\n\t      lin saved_p_bline = p_bline;\n\t      Fseek (pfp, previous_line, SEEK_SET);\n\t      p_input_line -= 2;\n\t      if (another_hunk (retval, false)\n\t\t  && ! p_repl_lines && p_newfirst == 1)\n\t\tp_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;\n\t      next_intuit_at (saved_p_base, saved_p_bline);\n\t    }\n\n\t    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)\n\t\t   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))\n\t\t&& ! p_name[INDEX] && need_header)\n\t      {\n\t\tchar numbuf[LINENUM_LENGTH_BOUND + 1];\n\t\tsay (\"missing header for context diff at line %s of patch\\n\",\n\t\t     format_linenum (numbuf, p_sline));\n\t      }\n\t    goto scan_exit;\n\t}\n\tif ((diff_type == NO_DIFF || diff_type == NORMAL_DIFF) &&\n\t  last_line_was_command &&\n\t  (strnEQ(s, \"< \", 2) || strnEQ(s, \"> \", 2)) ) {\n\t    p_start = previous_line;\n\t    p_sline = p_input_line - 1;\n\t    p_indent = indent;\n\t    retval = NORMAL_DIFF;\n\t    goto scan_exit;\n\t}\n    }\n\n  scan_exit:\n\n    /* The old, new, or old and new file types may be defined.  When both\n       file types are defined, make sure they are the same, or else assume\n       we do not know the file type.  */\n    file_type = p_mode[OLD] & S_IFMT;\n    if (file_type)\n      {\n\tmode_t new_file_type = p_mode[NEW] & S_IFMT;\n\tif (new_file_type && file_type != new_file_type)\n\t  file_type = 0;\n      }\n    else\n      {\n\tfile_type = p_mode[NEW] & S_IFMT;\n\tif (! file_type)\n\t  file_type = S_IFREG;\n      }\n    *p_file_type = file_type;\n\n    /* To intuit 'inname', the name of the file to patch,\n       use the algorithm specified by POSIX 1003.1-2001 XCU lines 25680-26599\n       (with some modifications if posixly_correct is zero):\n\n       - Take the old and new names from the context header if present,\n\t and take the index name from the 'Index:' line if present and\n\t if either the old and new names are both absent\n\t or posixly_correct is nonzero.\n\t Consider the file names to be in the order (old, new, index).\n       - If some named files exist, use the first one if posixly_correct\n\t is nonzero, the best one otherwise.\n       - If patch_get is nonzero, and no named files exist,\n\t but an RCS or SCCS master file exists,\n\t use the first named file with an RCS or SCCS master.\n       - If no named files exist, no RCS or SCCS master was found,\n\t some names are given, posixly_correct is zero,\n\t and the patch appears to create a file, then use the best name\n\t requiring the creation of the fewest directories.\n       - Otherwise, report failure by setting 'inname' to 0;\n\t this causes our invoker to ask the user for a file name.  */\n\n    i = NONE;\n\n    if (!inname)\n      {\n\tenum nametype i0 = NONE;\n\n\tif (! posixly_correct && (p_name[OLD] || p_name[NEW]) && p_name[INDEX])\n\t  {\n\t    free (p_name[INDEX]);\n\t    p_name[INDEX] = 0;\n\t  }\n\n\tfor (i = OLD;  i <= INDEX;  i++)\n\t  if (p_name[i])\n\t    {\n\t      if (i0 != NONE && strcmp (p_name[i0], p_name[i]) == 0)\n\t\t{\n\t\t  /* It's the same name as before; reuse stat results.  */\n\t\t  stat_errno[i] = stat_errno[i0];\n\t\t  if (! stat_errno[i])\n\t\t    st[i] = st[i0];\n\t\t}\n\t      else\n\t\t{\n\t\t  stat_errno[i] = stat_file (p_name[i], &st[i]);\n\t\t  if (! stat_errno[i])\n\t\t    {\n\t\t      if (lookup_file_id (&st[i]) == DELETE_LATER)\n\t\t\tstat_errno[i] = ENOENT;\n\t\t      else if (posixly_correct && name_is_valid (p_name[i]))\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t      i0 = i;\n\t    }\n\n\tif (! posixly_correct)\n\t  {\n\t    /* The best of all existing files. */\n\t    i = best_name (p_name, stat_errno);\n\n\t    if (i == NONE && patch_get)\n\t      {\n\t\tenum nametype nope = NONE;\n\n\t\tfor (i = OLD;  i <= INDEX;  i++)\n\t\t  if (p_name[i])\n\t\t    {\n\t\t      char const *cs;\n\t\t      char *getbuf;\n\t\t      char *diffbuf;\n\t\t      bool readonly = (outfile\n\t\t\t\t       && strcmp (outfile, p_name[i]) != 0);\n\n\t\t      if (nope == NONE || strcmp (p_name[nope], p_name[i]) != 0)\n\t\t\t{\n\t\t\t  cs = (version_controller\n\t\t\t        (p_name[i], readonly, (struct stat *) 0,\n\t\t\t\t &getbuf, &diffbuf));\n\t\t\t  version_controlled[i] = !! cs;\n\t\t\t  if (cs)\n\t\t\t    {\n\t\t\t      if (version_get (p_name[i], cs, false, readonly,\n\t\t\t\t\t       getbuf, &st[i]))\n\t\t\t\tstat_errno[i] = 0;\n\t\t\t      else\n\t\t\t\tversion_controlled[i] = 0;\n\n\t\t\t      free (getbuf);\n\t\t\t      free (diffbuf);\n\n\t\t\t      if (! stat_errno[i])\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t      nope = i;\n\t\t    }\n\t      }\n\n\t    if (i0 != NONE\n\t\t&& (i == NONE || (st[i].st_mode & S_IFMT) == file_type)\n\t\t&& maybe_reverse (p_name[i == NONE ? i0 : i], i == NONE,\n\t\t\t\t  i == NONE || st[i].st_size == 0)\n\t\t&& i == NONE)\n\t      i = i0;\n\n\t    if (i == NONE && p_says_nonexistent[reverse])\n\t      {\n\t\tint newdirs[3];\n\t\tint newdirs_min = INT_MAX;\n\t\tint distance_from_minimum[3];\n\n\t\tfor (i = OLD;  i <= INDEX;  i++)\n\t\t  if (p_name[i])\n\t\t    {\n\t\t      newdirs[i] = (prefix_components (p_name[i], false)\n\t\t\t\t    - prefix_components (p_name[i], true));\n\t\t      if (newdirs[i] < newdirs_min)\n\t\t\tnewdirs_min = newdirs[i];\n\t\t    }\n\n\t\tfor (i = OLD;  i <= INDEX;  i++)\n\t\t  if (p_name[i])\n\t\t    distance_from_minimum[i] = newdirs[i] - newdirs_min;\n\n\t\t/* The best of the filenames which create the fewest directories. */\n\t\ti = best_name (p_name, distance_from_minimum);\n\t      }\n\t  }\n      }\n\n     if ((pch_rename () || pch_copy ())\n \t&& ! inname\n \t&& ! ((i == OLD || i == NEW) &&\n\t      p_name[! reverse] &&\n \t      name_is_valid (p_name[! reverse])))\n       {\n \tsay (\"Cannot %s file without two valid file names\\n\", pch_rename () ? \"rename\" : \"copy\");\n      }\n\n    if (i == NONE)\n      {\n\tif (inname)\n\t  {\n\t    inerrno = stat_file (inname, &instat);\n\t    if (inerrno || (instat.st_mode & S_IFMT) == file_type)\n\t      maybe_reverse (inname, inerrno, inerrno || instat.st_size == 0);\n\t  }\n\telse\n          inerrno = -1;\n      }\n    else\n      {\n\tinname = xstrdup (p_name[i]);\n\tinerrno = stat_errno[i];\n\tinvc = version_controlled[i];\n\tinstat = st[i];\n      }\n\n    return retval;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141531,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "intuit_diff_type (bool need_header, mode_t *p_file_type)\n{\n    file_offset this_line = 0;\n    file_offset first_command_line = -1;\n    char first_ed_command_letter = 0;\n    lin fcl_line = 0; /* Pacify 'gcc -W'.  */\n    bool this_is_a_command = false;\n    bool stars_this_line = false;\n    bool extended_headers = false;\n    enum nametype i;\n    struct stat st[3];\n    int stat_errno[3];\n    int version_controlled[3];\n    enum diff retval;\n    mode_t file_type;\n    size_t indent = 0;\n\n    for (i = OLD;  i <= INDEX;  i++)\n      if (p_name[i]) {\n\t  free (p_name[i]);\n\t  p_name[i] = 0;\n        }\n    for (i = 0; i < ARRAY_SIZE (invalid_names); i++)\n\tinvalid_names[i] = NULL;\n    for (i = OLD; i <= NEW; i++)\n      if (p_timestr[i])\n\t{\n\t  free(p_timestr[i]);\n\t  p_timestr[i] = 0;\n\t}\n    for (i = OLD; i <= NEW; i++)\n      if (p_sha1[i])\n\t{\n\t  free (p_sha1[i]);\n\t  p_sha1[i] = 0;\n\t}\n    p_git_diff = false;\n    for (i = OLD; i <= NEW; i++)\n      {\n\tp_mode[i] = 0;\n\tp_copy[i] = false;\n\tp_rename[i] = false;\n      }\n\n    /* Ed and normal format patches don't have filename headers.  */\n    if (diff_type == ED_DIFF || diff_type == NORMAL_DIFF)\n      need_header = false;\n\n    version_controlled[OLD] = -1;\n    version_controlled[NEW] = -1;\n    version_controlled[INDEX] = -1;\n    p_rfc934_nesting = 0;\n    p_timestamp[OLD].tv_sec = p_timestamp[NEW].tv_sec = -1;\n    p_says_nonexistent[OLD] = p_says_nonexistent[NEW] = 0;\n    Fseek (pfp, p_base, SEEK_SET);\n    p_input_line = p_bline - 1;\n    for (;;) {\n\tchar *s;\n\tchar *t;\n\tfile_offset previous_line = this_line;\n\tbool last_line_was_command = this_is_a_command;\n\tbool stars_last_line = stars_this_line;\n\tsize_t indent_last_line = indent;\n\tchar ed_command_letter;\n\tbool strip_trailing_cr;\n\tsize_t chars_read;\n\n\tindent = 0;\n\tthis_line = file_tell (pfp);\n\tchars_read = pget_line (0, 0, false, false);\n\tif (chars_read == (size_t) -1)\n\t  xalloc_die ();\n\tif (! chars_read) {\n\t    if (first_ed_command_letter) {\n\t\t\t\t\t/* nothing but deletes!? */\n\t\tp_start = first_command_line;\n\t\tp_sline = fcl_line;\n\t\tretval = ED_DIFF;\n\t\tgoto scan_exit;\n\t    }\n\t    else {\n\t\tp_start = this_line;\n\t\tp_sline = p_input_line;\n\t\tif (extended_headers)\n\t\t  {\n\t\t    /* Patch contains no hunks; any diff type will do. */\n\t\t    retval = UNI_DIFF;\n\t\t    goto scan_exit;\n\t\t  }\n\t\treturn NO_DIFF;\n\t    }\n\t}\n\tstrip_trailing_cr = 2 <= chars_read && buf[chars_read - 2] == '\\r';\n\tfor (s = buf; *s == ' ' || *s == '\\t' || *s == 'X'; s++) {\n\t    if (*s == '\\t')\n\t\tindent = (indent + 8) & ~7;\n\t    else\n\t\tindent++;\n\t}\n\tif (ISDIGIT (*s))\n\t  {\n\t    for (t = s + 1; ISDIGIT (*t) || *t == ',';  t++)\n\t      /* do nothing */ ;\n\t    if (*t == 'd' || *t == 'c' || *t == 'a')\n\t      {\n\t\tfor (t++;  ISDIGIT (*t) || *t == ',';  t++)\n\t\t  /* do nothing */ ;\n\t\tfor (; *t == ' ' || *t == '\\t'; t++)\n\t\t  /* do nothing */ ;\n\t\tif (*t == '\\r')\n\t\t  t++;\n\t\tthis_is_a_command = (*t == '\\n');\n\t      }\n\t  }\n\tif (! need_header\n\t    && first_command_line < 0\n\t    && ((ed_command_letter = get_ed_command_letter (s))\n\t\t|| this_is_a_command)) {\n\t    first_command_line = this_line;\n\t    first_ed_command_letter = ed_command_letter;\n\t    fcl_line = p_input_line;\n\t    p_indent = indent;\t\t/* assume this for now */\n\t    p_strip_trailing_cr = strip_trailing_cr;\n\t}\n\tif (!stars_last_line && strnEQ(s, \"*** \", 4))\n\t  {\n\t    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],\n\t\t       &p_timestamp[OLD]);\n\t    need_header = false;\n\t  }\n\telse if (strnEQ(s, \"+++ \", 4))\n\t  {\n\t    /* Swap with NEW below.  */\n\t    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],\n\t\t       &p_timestamp[OLD]);\n\t    need_header = false;\n\t    p_strip_trailing_cr = strip_trailing_cr;\n\t  }\n\telse if (strnEQ(s, \"Index:\", 6))\n\t  {\n\t    fetchname (s+6, strippath, &p_name[INDEX], (char **) 0, NULL);\n\t    need_header = false;\n\t    p_strip_trailing_cr = strip_trailing_cr;\n\t  }\n\telse if (strnEQ(s, \"Prereq:\", 7))\n\t  {\n\t    for (t = s + 7;  ISSPACE ((unsigned char) *t);  t++)\n\t      /* do nothing */ ;\n\t    revision = t;\n\t    for (t = revision;  *t;  t++)\n\t      if (ISSPACE ((unsigned char) *t))\n\t\t{\n\t\t  char const *u;\n\t\t  for (u = t + 1;  ISSPACE ((unsigned char) *u);  u++)\n\t\t    /* do nothing */ ;\n\t\t  if (*u)\n\t\t    {\n\t\t      char numbuf[LINENUM_LENGTH_BOUND + 1];\n\t\t      say (\"Prereq: with multiple words at line %s of patch\\n\",\n\t\t\t   format_linenum (numbuf, this_line));\n\t\t    }\n\t\t  break;\n\t\t}\n\t    if (t == revision)\n\t\trevision = 0;\n\t    else {\n\t\tchar oldc = *t;\n\t\t*t = '\\0';\n\t\trevision = xstrdup (revision);\n\t\t*t = oldc;\n\t    }\n\t  }\n\telse if (strnEQ (s, \"diff --git \", 11))\n\t  {\n\t    char const *u;\n\n\t    if (extended_headers)\n\t      {\n\t\tp_start = this_line;\n\t\tp_sline = p_input_line;\n\t\t/* Patch contains no hunks; any diff type will do. */\n\t\tretval = UNI_DIFF;\n\t\tgoto scan_exit;\n\t      }\n\n\t    for (i = OLD; i <= NEW; i++)\n\t      {\n\t\tfree (p_name[i]);\n\t\tp_name[i] = 0;\n\t      }\n\t    if (! ((p_name[OLD] = parse_name (s + 11, strippath, &u))\n\t\t   && ISSPACE ((unsigned char) *u)\n\t\t   && (p_name[NEW] = parse_name (u, strippath, &u))\n\t\t   && (u = skip_spaces (u), ! *u)))\n\t      for (i = OLD; i <= NEW; i++)\n\t\t{\n\t\t  free (p_name[i]);\n\t\t  p_name[i] = 0;\n\t\t}\n\t    p_git_diff = true;\n\t    need_header = false;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"index \", 6))\n\t  {\n\t    char const *u, *v;\n\t    if ((u = skip_hex_digits (s + 6))\n\t\t&& u[0] == '.' && u[1] == '.'\n\t\t&& (v = skip_hex_digits (u + 2))\n\t\t&& (! *v || ISSPACE ((unsigned char) *v)))\n\t      {\n\t\tget_sha1(&p_sha1[OLD], s + 6, u);\n\t\tget_sha1(&p_sha1[NEW], u + 2, v);\n\t\tp_says_nonexistent[OLD] = sha1_says_nonexistent (p_sha1[OLD]);\n\t\tp_says_nonexistent[NEW] = sha1_says_nonexistent (p_sha1[NEW]);\n\t\tif (*(v = skip_spaces (v)))\n\t\t  p_mode[OLD] = p_mode[NEW] = fetchmode (v);\n\t\textended_headers = true;\n\t      }\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"old mode \", 9))\n\t  {\n\t    p_mode[OLD] = fetchmode (s + 9);\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"new mode \", 9))\n\t  {\n\t    p_mode[NEW] = fetchmode (s + 9);\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"deleted file mode \", 18))\n\t  {\n\t    p_mode[OLD] = fetchmode (s + 18);\n\t    p_says_nonexistent[NEW] = 2;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"new file mode \", 14))\n\t  {\n\t    p_mode[NEW] = fetchmode (s + 14);\n\t    p_says_nonexistent[OLD] = 2;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"rename from \", 12))\n\t  {\n\t    /* Git leaves out the prefix in the file name in this header,\n\t       so we can only ignore the file name.  */\n\t    p_rename[OLD] = true;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"rename to \", 10))\n\t  {\n\t    /* Git leaves out the prefix in the file name in this header,\n\t       so we can only ignore the file name.  */\n\t    p_rename[NEW] = true;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"copy from \", 10))\n\t  {\n\t    /* Git leaves out the prefix in the file name in this header,\n\t       so we can only ignore the file name.  */\n\t    p_copy[OLD] = true;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"copy to \", 8))\n\t  {\n\t    /* Git leaves out the prefix in the file name in this header,\n\t       so we can only ignore the file name.  */\n\t    p_copy[NEW] = true;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"GIT binary patch\", 16))\n\t  {\n\t    p_start = this_line;\n\t    p_sline = p_input_line;\n\t    retval = GIT_BINARY_DIFF;\n\t    goto scan_exit;\n\t  }\n\telse\n\t  {\n\t    for (t = s;  t[0] == '-' && t[1] == ' ';  t += 2)\n\t      /* do nothing */ ;\n\t    if (strnEQ(t, \"--- \", 4))\n\t      {\n\t\tstruct timespec timestamp;\n\t\ttimestamp.tv_sec = -1;\n\t\tfetchname (t+4, strippath, &p_name[NEW], &p_timestr[NEW],\n\t\t\t   &timestamp);\n\t\tneed_header = false;\n\t\tif (timestamp.tv_sec != -1)\n\t\t  {\n\t\t    p_timestamp[NEW] = timestamp;\n\t\t    p_rfc934_nesting = (t - s) >> 1;\n\t\t  }\n\t\tp_strip_trailing_cr = strip_trailing_cr;\n\t      }\n\t  }\n\tif (need_header)\n\t  continue;\n\tif ((diff_type == NO_DIFF || diff_type == ED_DIFF) &&\n\t  first_command_line >= 0 &&\n\t  strEQ(s, \".\\n\") ) {\n\t    p_start = first_command_line;\n\t    p_sline = fcl_line;\n\t    retval = ED_DIFF;\n\t    goto scan_exit;\n\t}\n\tif ((diff_type == NO_DIFF || diff_type == UNI_DIFF)\n\t    && strnEQ(s, \"@@ -\", 4)) {\n\n\t    /* 'p_name', 'p_timestr', and 'p_timestamp' are backwards;\n\t       swap them.  */\n\t    struct timespec ti = p_timestamp[OLD];\n\t    p_timestamp[OLD] = p_timestamp[NEW];\n\t    p_timestamp[NEW] = ti;\n\t    t = p_name[OLD];\n\t    p_name[OLD] = p_name[NEW];\n\t    p_name[NEW] = t;\n\t    t = p_timestr[OLD];\n\t    p_timestr[OLD] = p_timestr[NEW];\n\t    p_timestr[NEW] = t;\n\n\t    s += 4;\n\t    if (s[0] == '0' && !ISDIGIT (s[1]))\n\t      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;\n\t    while (*s != ' ' && *s != '\\n')\n\t      s++;\n\t    while (*s == ' ')\n\t      s++;\n\t    if (s[0] == '+' && s[1] == '0' && !ISDIGIT (s[2]))\n\t      p_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;\n\t    p_indent = indent;\n\t    p_start = this_line;\n\t    p_sline = p_input_line;\n\t    retval = UNI_DIFF;\n\t    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)\n\t\t   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))\n\t\t&& ! p_name[INDEX] && need_header)\n\t      {\n\t\tchar numbuf[LINENUM_LENGTH_BOUND + 1];\n\t\tsay (\"missing header for unified diff at line %s of patch\\n\",\n\t\t     format_linenum (numbuf, p_sline));\n\t      }\n\t    goto scan_exit;\n\t}\n\tstars_this_line = strnEQ(s, \"********\", 8);\n\tif ((diff_type == NO_DIFF\n\t     || diff_type == CONTEXT_DIFF\n\t     || diff_type == NEW_CONTEXT_DIFF)\n\t    && stars_last_line && indent_last_line == indent\n\t    && strnEQ (s, \"*** \", 4)) {\n\t    s += 4;\n\t    if (s[0] == '0' && !ISDIGIT (s[1]))\n\t      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;\n\t    /* if this is a new context diff the character just before */\n\t    /* the newline is a '*'. */\n\t    while (*s != '\\n')\n\t\ts++;\n\t    p_indent = indent;\n\t    p_strip_trailing_cr = strip_trailing_cr;\n\t    p_start = previous_line;\n\t    p_sline = p_input_line - 1;\n\t    retval = (*(s-1) == '*' ? NEW_CONTEXT_DIFF : CONTEXT_DIFF);\n\n\t    {\n\t      /* Scan the first hunk to see whether the file contents\n\t\t appear to have been deleted.  */\n\t      file_offset saved_p_base = p_base;\n\t      lin saved_p_bline = p_bline;\n\t      Fseek (pfp, previous_line, SEEK_SET);\n\t      p_input_line -= 2;\n\t      if (another_hunk (retval, false)\n\t\t  && ! p_repl_lines && p_newfirst == 1)\n\t\tp_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;\n\t      next_intuit_at (saved_p_base, saved_p_bline);\n\t    }\n\n\t    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)\n\t\t   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))\n\t\t&& ! p_name[INDEX] && need_header)\n\t      {\n\t\tchar numbuf[LINENUM_LENGTH_BOUND + 1];\n\t\tsay (\"missing header for context diff at line %s of patch\\n\",\n\t\t     format_linenum (numbuf, p_sline));\n\t      }\n\t    goto scan_exit;\n\t}\n\tif ((diff_type == NO_DIFF || diff_type == NORMAL_DIFF) &&\n\t  last_line_was_command &&\n\t  (strnEQ(s, \"< \", 2) || strnEQ(s, \"> \", 2)) ) {\n\t    p_start = previous_line;\n\t    p_sline = p_input_line - 1;\n\t    p_indent = indent;\n\t    retval = NORMAL_DIFF;\n\t    goto scan_exit;\n\t}\n    }\n\n  scan_exit:\n\n    /* The old, new, or old and new file types may be defined.  When both\n       file types are defined, make sure they are the same, or else assume\n       we do not know the file type.  */\n    file_type = p_mode[OLD] & S_IFMT;\n    if (file_type)\n      {\n\tmode_t new_file_type = p_mode[NEW] & S_IFMT;\n\tif (new_file_type && file_type != new_file_type)\n\t  file_type = 0;\n      }\n    else\n      {\n\tfile_type = p_mode[NEW] & S_IFMT;\n\tif (! file_type)\n\t  file_type = S_IFREG;\n      }\n    *p_file_type = file_type;\n\n    /* To intuit 'inname', the name of the file to patch,\n       use the algorithm specified by POSIX 1003.1-2001 XCU lines 25680-26599\n       (with some modifications if posixly_correct is zero):\n\n       - Take the old and new names from the context header if present,\n\t and take the index name from the 'Index:' line if present and\n\t if either the old and new names are both absent\n\t or posixly_correct is nonzero.\n\t Consider the file names to be in the order (old, new, index).\n       - If some named files exist, use the first one if posixly_correct\n\t is nonzero, the best one otherwise.\n       - If patch_get is nonzero, and no named files exist,\n\t but an RCS or SCCS master file exists,\n\t use the first named file with an RCS or SCCS master.\n       - If no named files exist, no RCS or SCCS master was found,\n\t some names are given, posixly_correct is zero,\n\t and the patch appears to create a file, then use the best name\n\t requiring the creation of the fewest directories.\n       - Otherwise, report failure by setting 'inname' to 0;\n\t this causes our invoker to ask the user for a file name.  */\n\n    i = NONE;\n\n    if (!inname)\n      {\n\tenum nametype i0 = NONE;\n\n\tif (! posixly_correct && (p_name[OLD] || p_name[NEW]) && p_name[INDEX])\n\t  {\n\t    free (p_name[INDEX]);\n\t    p_name[INDEX] = 0;\n\t  }\n\n\tfor (i = OLD;  i <= INDEX;  i++)\n\t  if (p_name[i])\n\t    {\n\t      if (i0 != NONE && strcmp (p_name[i0], p_name[i]) == 0)\n\t\t{\n\t\t  /* It's the same name as before; reuse stat results.  */\n\t\t  stat_errno[i] = stat_errno[i0];\n\t\t  if (! stat_errno[i])\n\t\t    st[i] = st[i0];\n\t\t}\n\t      else\n\t\t{\n\t\t  stat_errno[i] = stat_file (p_name[i], &st[i]);\n\t\t  if (! stat_errno[i])\n\t\t    {\n\t\t      if (lookup_file_id (&st[i]) == DELETE_LATER)\n\t\t\tstat_errno[i] = ENOENT;\n\t\t      else if (posixly_correct && name_is_valid (p_name[i]))\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t      i0 = i;\n\t    }\n\n\tif (! posixly_correct)\n\t  {\n\t    /* The best of all existing files. */\n\t    i = best_name (p_name, stat_errno);\n\n\t    if (i == NONE && patch_get)\n\t      {\n\t\tenum nametype nope = NONE;\n\n\t\tfor (i = OLD;  i <= INDEX;  i++)\n\t\t  if (p_name[i])\n\t\t    {\n\t\t      char const *cs;\n\t\t      char *getbuf;\n\t\t      char *diffbuf;\n\t\t      bool readonly = (outfile\n\t\t\t\t       && strcmp (outfile, p_name[i]) != 0);\n\n\t\t      if (nope == NONE || strcmp (p_name[nope], p_name[i]) != 0)\n\t\t\t{\n\t\t\t  cs = (version_controller\n\t\t\t        (p_name[i], readonly, (struct stat *) 0,\n\t\t\t\t &getbuf, &diffbuf));\n\t\t\t  version_controlled[i] = !! cs;\n\t\t\t  if (cs)\n\t\t\t    {\n\t\t\t      if (version_get (p_name[i], cs, false, readonly,\n\t\t\t\t\t       getbuf, &st[i]))\n\t\t\t\tstat_errno[i] = 0;\n\t\t\t      else\n\t\t\t\tversion_controlled[i] = 0;\n\n\t\t\t      free (getbuf);\n\t\t\t      free (diffbuf);\n\n\t\t\t      if (! stat_errno[i])\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t      nope = i;\n\t\t    }\n\t      }\n\n\t    if (i0 != NONE\n\t\t&& (i == NONE || (st[i].st_mode & S_IFMT) == file_type)\n\t\t&& maybe_reverse (p_name[i == NONE ? i0 : i], i == NONE,\n\t\t\t\t  i == NONE || st[i].st_size == 0)\n\t\t&& i == NONE)\n\t      i = i0;\n\n\t    if (i == NONE && p_says_nonexistent[reverse])\n\t      {\n\t\tint newdirs[3];\n\t\tint newdirs_min = INT_MAX;\n\t\tint distance_from_minimum[3];\n\n\t\tfor (i = OLD;  i <= INDEX;  i++)\n\t\t  if (p_name[i])\n\t\t    {\n\t\t      newdirs[i] = (prefix_components (p_name[i], false)\n\t\t\t\t    - prefix_components (p_name[i], true));\n\t\t      if (newdirs[i] < newdirs_min)\n\t\t\tnewdirs_min = newdirs[i];\n\t\t    }\n\n\t\tfor (i = OLD;  i <= INDEX;  i++)\n\t\t  if (p_name[i])\n\t\t    distance_from_minimum[i] = newdirs[i] - newdirs_min;\n\n\t\t/* The best of the filenames which create the fewest directories. */\n\t\ti = best_name (p_name, distance_from_minimum);\n\t      }\n\t  }\n      }\n\n     if ((pch_rename () || pch_copy ())\n \t&& ! inname\n \t&& ! ((i == OLD || i == NEW) &&\n\t      p_name[reverse] && p_name[! reverse] &&\n\t      name_is_valid (p_name[reverse]) &&\n \t      name_is_valid (p_name[! reverse])))\n       {\n \tsay (\"Cannot %s file without two valid file names\\n\", pch_rename () ? \"rename\" : \"copy\");\n      }\n\n    if (i == NONE)\n      {\n\tif (inname)\n\t  {\n\t    inerrno = stat_file (inname, &instat);\n\t    if (inerrno || (instat.st_mode & S_IFMT) == file_type)\n\t      maybe_reverse (inname, inerrno, inerrno || instat.st_size == 0);\n\t  }\n\telse\n          inerrno = -1;\n      }\n    else\n      {\n\tinname = xstrdup (p_name[i]);\n\tinerrno = stat_errno[i];\n\tinvc = version_controlled[i];\n\tinstat = st[i];\n      }\n\n    return retval;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141532,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  Ins_GETVARIATION( TT_ExecContext  exc,\n                    FT_Long*        args )\n  {\n    FT_UInt    num_axes = exc->face->blend->num_axis;\n    FT_Fixed*  coords   = exc->face->blend->normalizedcoords;\n\n    FT_UInt  i;\n\n\n    if ( BOUNDS( num_axes, exc->stackSize + 1 - exc->top ) )\n    {\n      exc->error = FT_THROW( Stack_Overflow );\n       return;\n     }\n \n    for ( i = 0; i < num_axes; i++ )\n      args[i] = coords[i] >> 2; /* convert 16.16 to 2.14 format */\n   }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141533,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  Ins_GETVARIATION( TT_ExecContext  exc,\n                    FT_Long*        args )\n  {\n    FT_UInt    num_axes = exc->face->blend->num_axis;\n    FT_Fixed*  coords   = exc->face->blend->normalizedcoords;\n\n    FT_UInt  i;\n\n\n    if ( BOUNDS( num_axes, exc->stackSize + 1 - exc->top ) )\n    {\n      exc->error = FT_THROW( Stack_Overflow );\n       return;\n     }\n \n    if ( coords )\n    {\n      for ( i = 0; i < num_axes; i++ )\n        args[i] = coords[i] >> 2; /* convert 16.16 to 2.14 format */\n    }\n    else\n    {\n      for ( i = 0; i < num_axes; i++ )\n        args[i] = 0;\n    }\n   }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141534,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "pdf14_pop_transparency_group(gs_gstate *pgs, pdf14_ctx *ctx,\n    const pdf14_nonseparable_blending_procs_t * pblend_procs,\n    int tos_num_color_comp, cmm_profile_t *curr_icc_profile, gx_device *dev)\n{\n    pdf14_buf *tos = ctx->stack;\n    pdf14_buf *nos = tos->saved;\n    pdf14_mask_t *mask_stack = tos->mask_stack;\n    pdf14_buf *maskbuf;\n    int x0, x1, y0, y1;\n    byte *new_data_buf = NULL;\n    int num_noncolor_planes, new_num_planes;\n    int num_cols, num_rows, nos_num_color_comp;\n    bool icc_match;\n    gsicc_rendering_param_t rendering_params;\n    gsicc_link_t *icc_link;\n    gsicc_bufferdesc_t input_buff_desc;\n    gsicc_bufferdesc_t output_buff_desc;\n    pdf14_device *pdev = (pdf14_device *)dev;\n    bool overprint = pdev->overprint;\n     gx_color_index drawn_comps = pdev->drawn_comps;\n     bool nonicc_conversion = true;\n \n     nos_num_color_comp = nos->parent_color_info_procs->num_components - nos->num_spots;\n     tos_num_color_comp = tos_num_color_comp - tos->num_spots;\n    if (mask_stack == NULL) {\n        maskbuf = NULL;\n    } else {\n        maskbuf = mask_stack->rc_mask->mask_buf;\n    }\n    if (nos == NULL)\n        return_error(gs_error_rangecheck);\n    /* Sanitise the dirty rectangles, in case some of the drawing routines\n     * have made them overly large. */\n    rect_intersect(tos->dirty, tos->rect);\n    rect_intersect(nos->dirty, nos->rect);\n    /* dirty = the marked bbox. rect = the entire bounds of the buffer. */\n    /* Everything marked on tos that fits onto nos needs to be merged down. */\n    y0 = max(tos->dirty.p.y, nos->rect.p.y);\n    y1 = min(tos->dirty.q.y, nos->rect.q.y);\n    x0 = max(tos->dirty.p.x, nos->rect.p.x);\n    x1 = min(tos->dirty.q.x, nos->rect.q.x);\n    if (ctx->mask_stack) {\n        /* This can occur when we have a situation where we are ending out of\n           a group that has internal to it a soft mask and another group.\n           The soft mask left over from the previous trans group pop is put\n           into ctx->masbuf, since it is still active if another trans group\n           push occurs to use it.  If one does not occur, but instead we find\n           ourselves popping from a parent group, then this softmask is no\n           longer needed.  We will rc_decrement and set it to NULL. */\n        rc_decrement(ctx->mask_stack->rc_mask, \"pdf14_pop_transparency_group\");\n        if (ctx->mask_stack->rc_mask == NULL ){\n            gs_free_object(ctx->memory, ctx->mask_stack, \"pdf14_pop_transparency_group\");\n        }\n        ctx->mask_stack = NULL;\n    }\n    ctx->mask_stack = mask_stack;  /* Restore the mask saved by pdf14_push_transparency_group. */\n    tos->mask_stack = NULL;        /* Clean the pointer sinse the mask ownership is now passed to ctx. */\n    if (tos->idle)\n        goto exit;\n    if (maskbuf != NULL && maskbuf->data == NULL && maskbuf->alpha == 255)\n        goto exit;\n\n#if RAW_DUMP\n    /* Dump the current buffer to see what we have. */\n    dump_raw_buffer(ctx->stack->rect.q.y-ctx->stack->rect.p.y,\n                ctx->stack->rowstride, ctx->stack->n_planes,\n                ctx->stack->planestride, ctx->stack->rowstride,\n                \"aaTrans_Group_Pop\",ctx->stack->data);\n#endif\n/* Note currently if a pattern space has transparency, the ICC profile is not used\n   for blending purposes.  Instead we rely upon the gray, rgb, or cmyk parent space.\n   This is partially due to the fact that pdf14_pop_transparency_group and\n   pdf14_push_transparnecy_group have no real ICC interaction and those are the\n   operations called in the tile transparency code.  Instead we may want to\n   look at pdf14_begin_transparency_group and pdf14_end_transparency group which\n   is where all the ICC information is handled.  We will return to look at that later */\n    if (nos->parent_color_info_procs->icc_profile != NULL) {\n        icc_match = (nos->parent_color_info_procs->icc_profile->hashcode !=\n                        curr_icc_profile->hashcode);\n    } else {\n        /* Let the other tests make the decision if we need to transform */\n        icc_match = false;\n    }\n    /* If the color spaces are different and we actually did do a swap of\n       the procs for color */\n    if ((nos->parent_color_info_procs->parent_color_mapping_procs != NULL &&\n        nos_num_color_comp != tos_num_color_comp) || icc_match) {\n        if (x0 < x1 && y0 < y1) {\n            /* The NOS blending color space is different than that of the\n               TOS.  It is necessary to transform the TOS buffer data to the\n               color space of the NOS prior to doing the pdf14_compose_group\n               operation.  */\n            num_noncolor_planes = tos->n_planes - tos_num_color_comp;\n            new_num_planes = num_noncolor_planes + nos_num_color_comp;\n\n            /* See if we are doing ICC based conversion */\n            if (nos->parent_color_info_procs->icc_profile != NULL &&\n                curr_icc_profile != NULL) {\n                /* Use the ICC color management for buffer color conversion */\n                /* Define the rendering intents */\n                rendering_params.black_point_comp = gsBLACKPTCOMP_ON;\n                rendering_params.graphics_type_tag = GS_IMAGE_TAG;\n                rendering_params.override_icc = false;\n                rendering_params.preserve_black = gsBKPRESNOTSPECIFIED;\n                rendering_params.rendering_intent = gsPERCEPTUAL;\n                rendering_params.cmm = gsCMM_DEFAULT;\n                /* Request the ICC link for the transform that we will need to use */\n                /* Note that if pgs is NULL we assume the same color space.  This\n                   is due to a call to pop the group from fill_mask when filling\n                   with a mask with transparency.  In that case, the parent\n                   and the child will have the same color space anyway */\n                icc_link = gsicc_get_link_profile(pgs, dev, curr_icc_profile,\n                                    nos->parent_color_info_procs->icc_profile,\n                                    &rendering_params, pgs->memory, false);\n                if (icc_link != NULL) {\n                    /* if problem with link we will do non-ICC approach */\n                    nonicc_conversion = false;\n                    /* If the link is the identity, then we don't need to do\n                       any color conversions */\n                    if ( !(icc_link->is_identity) ) {\n                        /* Before we do any allocations check if we can get away with\n                           reusing the existing buffer if it is the same size ( if it is\n                           smaller go ahead and allocate).  We could reuse it in this\n                           case too.  We need to do a bit of testing to determine what\n                           would be best.  */\n                        /* FIXME: RJW: Could we get away with just color converting\n                         * the area that's actually active (i.e. dirty, not rect)?\n                         */\n                        if(nos_num_color_comp != tos_num_color_comp) {\n                            /* Different size.  We will need to allocate */\n                            new_data_buf = gs_alloc_bytes(ctx->memory,\n                                                tos->planestride * new_num_planes,\n                                                    \"pdf14_pop_transparency_group\");\n                            if (new_data_buf == NULL)\n                                return_error(gs_error_VMerror);\n                            /* Copy over the noncolor planes. */\n                            memcpy(new_data_buf + tos->planestride * nos_num_color_comp,\n                                   tos->data + tos->planestride * tos_num_color_comp,\n                                   tos->planestride * num_noncolor_planes);\n                        } else {\n                            /* In place color conversion! */\n                            new_data_buf = tos->data;\n                        }\n                        /* Set up the buffer descriptors. Note that pdf14 always has\n                           the alpha channels at the back end (last planes).\n                           We will just handle that here and let the CMM know\n                           nothing about it */\n                        num_rows = tos->rect.q.y - tos->rect.p.y;\n                        num_cols = tos->rect.q.x - tos->rect.p.x;\n                        gsicc_init_buffer(&input_buff_desc, tos_num_color_comp, 1,\n                                          false, false, true,\n                                          tos->planestride, tos->rowstride,\n                                          num_rows, num_cols);\n                        gsicc_init_buffer(&output_buff_desc, nos_num_color_comp,\n                                          1, false, false, true, tos->planestride,\n                                          tos->rowstride, num_rows, num_cols);\n                        /* Transform the data. Since the pdf14 device should be\n                           using RGB, CMYK or Gray buffers, this transform\n                           does not need to worry about the cmap procs of\n                           the target device.  Those are handled when we do\n                           the pdf14 put image operation */\n                        (icc_link->procs.map_buffer)(dev, icc_link, &input_buff_desc,\n                                                     &output_buff_desc, tos->data,\n                                                     new_data_buf);\n                    }\n                    /* Release the link */\n                    gsicc_release_link(icc_link);\n                    /* free the old object if the color spaces were different sizes */\n                    if(!(icc_link->is_identity) &&\n                        nos_num_color_comp != tos_num_color_comp) {\n                        gs_free_object(ctx->memory, tos->data,\n                            \"pdf14_pop_transparency_group\");\n                        tos->data = new_data_buf;\n                    }\n                }\n            }\n            if (nonicc_conversion) {\n                /* Non ICC based transform */\n                new_data_buf = gs_alloc_bytes(ctx->memory,\n                                    tos->planestride * new_num_planes,\n                                    \"pdf14_pop_transparency_group\");\n                if (new_data_buf == NULL)\n                    return_error(gs_error_VMerror);\n                gs_transform_color_buffer_generic(tos->data, tos->rowstride,\n                            tos->planestride, tos_num_color_comp, tos->rect,\n                            new_data_buf, nos_num_color_comp, num_noncolor_planes);\n                /* Free the old object */\n                gs_free_object(ctx->memory, tos->data,\n                                \"pdf14_pop_transparency_group\");\n                 tos->data = new_data_buf;\n            }\n             /* Adjust the plane and channel size now */\n             tos->n_chan = nos->n_chan;\n             tos->n_planes = nos->n_planes;\n#if RAW_DUMP\n            /* Dump the current buffer to see what we have. */\n            dump_raw_buffer(ctx->stack->rect.q.y-ctx->stack->rect.p.y,\n                            ctx->stack->rowstride, ctx->stack->n_chan,\n                            ctx->stack->planestride, ctx->stack->rowstride,\n                            \"aCMTrans_Group_ColorConv\",ctx->stack->data);\n#endif\n             /* compose. never do overprint in this case */\n            pdf14_compose_group(tos, nos, maskbuf, x0, x1, y0, y1, nos->n_chan,\n                 nos->parent_color_info_procs->isadditive,\n                 nos->parent_color_info_procs->parent_blending_procs,\n                 false, drawn_comps, ctx->memory, dev);\n        }\n    } else {\n        /* Group color spaces are the same.  No color conversions needed */\n        if (x0 < x1 && y0 < y1)\n            pdf14_compose_group(tos, nos, maskbuf, x0, x1, y0, y1, nos->n_chan,\n                                ctx->additive, pblend_procs, overprint,\n                                drawn_comps, ctx->memory, dev);\n    }\nexit:\n    ctx->stack = nos;\n    /* We want to detect the cases where we have luminosity soft masks embedded\n       within one another.  The \"alpha\" channel really needs to be merged into\n       the luminosity channel in this case.  This will occur during the mask pop */\n    if (ctx->smask_depth > 0 && maskbuf != NULL) {\n        /* Set the trigger so that we will blend if not alpha. Since\n           we have softmasks embedded in softmasks */\n        ctx->smask_blend = true;\n    }\n    if_debug1m('v', ctx->memory, \"[v]pop buf, idle=%d\\n\", tos->idle);\n    pdf14_buf_free(tos, ctx->memory);\n    return 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141583,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "pdf14_pop_transparency_group(gs_gstate *pgs, pdf14_ctx *ctx,\n    const pdf14_nonseparable_blending_procs_t * pblend_procs,\n    int tos_num_color_comp, cmm_profile_t *curr_icc_profile, gx_device *dev)\n{\n    pdf14_buf *tos = ctx->stack;\n    pdf14_buf *nos = tos->saved;\n    pdf14_mask_t *mask_stack = tos->mask_stack;\n    pdf14_buf *maskbuf;\n    int x0, x1, y0, y1;\n    byte *new_data_buf = NULL;\n    int num_noncolor_planes, new_num_planes;\n    int num_cols, num_rows, nos_num_color_comp;\n    bool icc_match;\n    gsicc_rendering_param_t rendering_params;\n    gsicc_link_t *icc_link;\n    gsicc_bufferdesc_t input_buff_desc;\n    gsicc_bufferdesc_t output_buff_desc;\n    pdf14_device *pdev = (pdf14_device *)dev;\n    bool overprint = pdev->overprint;\n     gx_color_index drawn_comps = pdev->drawn_comps;\n     bool nonicc_conversion = true;\n \n    if (nos == NULL)\n        return_error(gs_error_unknownerror);  /* Unmatched group pop */\n\n     nos_num_color_comp = nos->parent_color_info_procs->num_components - nos->num_spots;\n     tos_num_color_comp = tos_num_color_comp - tos->num_spots;\n    if (mask_stack == NULL) {\n        maskbuf = NULL;\n    } else {\n        maskbuf = mask_stack->rc_mask->mask_buf;\n    }\n    if (nos == NULL)\n        return_error(gs_error_rangecheck);\n    /* Sanitise the dirty rectangles, in case some of the drawing routines\n     * have made them overly large. */\n    rect_intersect(tos->dirty, tos->rect);\n    rect_intersect(nos->dirty, nos->rect);\n    /* dirty = the marked bbox. rect = the entire bounds of the buffer. */\n    /* Everything marked on tos that fits onto nos needs to be merged down. */\n    y0 = max(tos->dirty.p.y, nos->rect.p.y);\n    y1 = min(tos->dirty.q.y, nos->rect.q.y);\n    x0 = max(tos->dirty.p.x, nos->rect.p.x);\n    x1 = min(tos->dirty.q.x, nos->rect.q.x);\n    if (ctx->mask_stack) {\n        /* This can occur when we have a situation where we are ending out of\n           a group that has internal to it a soft mask and another group.\n           The soft mask left over from the previous trans group pop is put\n           into ctx->masbuf, since it is still active if another trans group\n           push occurs to use it.  If one does not occur, but instead we find\n           ourselves popping from a parent group, then this softmask is no\n           longer needed.  We will rc_decrement and set it to NULL. */\n        rc_decrement(ctx->mask_stack->rc_mask, \"pdf14_pop_transparency_group\");\n        if (ctx->mask_stack->rc_mask == NULL ){\n            gs_free_object(ctx->memory, ctx->mask_stack, \"pdf14_pop_transparency_group\");\n        }\n        ctx->mask_stack = NULL;\n    }\n    ctx->mask_stack = mask_stack;  /* Restore the mask saved by pdf14_push_transparency_group. */\n    tos->mask_stack = NULL;        /* Clean the pointer sinse the mask ownership is now passed to ctx. */\n    if (tos->idle)\n        goto exit;\n    if (maskbuf != NULL && maskbuf->data == NULL && maskbuf->alpha == 255)\n        goto exit;\n\n#if RAW_DUMP\n    /* Dump the current buffer to see what we have. */\n    dump_raw_buffer(ctx->stack->rect.q.y-ctx->stack->rect.p.y,\n                ctx->stack->rowstride, ctx->stack->n_planes,\n                ctx->stack->planestride, ctx->stack->rowstride,\n                \"aaTrans_Group_Pop\",ctx->stack->data);\n#endif\n/* Note currently if a pattern space has transparency, the ICC profile is not used\n   for blending purposes.  Instead we rely upon the gray, rgb, or cmyk parent space.\n   This is partially due to the fact that pdf14_pop_transparency_group and\n   pdf14_push_transparnecy_group have no real ICC interaction and those are the\n   operations called in the tile transparency code.  Instead we may want to\n   look at pdf14_begin_transparency_group and pdf14_end_transparency group which\n   is where all the ICC information is handled.  We will return to look at that later */\n    if (nos->parent_color_info_procs->icc_profile != NULL) {\n        icc_match = (nos->parent_color_info_procs->icc_profile->hashcode !=\n                        curr_icc_profile->hashcode);\n    } else {\n        /* Let the other tests make the decision if we need to transform */\n        icc_match = false;\n    }\n    /* If the color spaces are different and we actually did do a swap of\n       the procs for color */\n    if ((nos->parent_color_info_procs->parent_color_mapping_procs != NULL &&\n        nos_num_color_comp != tos_num_color_comp) || icc_match) {\n        if (x0 < x1 && y0 < y1) {\n            /* The NOS blending color space is different than that of the\n               TOS.  It is necessary to transform the TOS buffer data to the\n               color space of the NOS prior to doing the pdf14_compose_group\n               operation.  */\n            num_noncolor_planes = tos->n_planes - tos_num_color_comp;\n            new_num_planes = num_noncolor_planes + nos_num_color_comp;\n\n            /* See if we are doing ICC based conversion */\n            if (nos->parent_color_info_procs->icc_profile != NULL &&\n                curr_icc_profile != NULL) {\n                /* Use the ICC color management for buffer color conversion */\n                /* Define the rendering intents */\n                rendering_params.black_point_comp = gsBLACKPTCOMP_ON;\n                rendering_params.graphics_type_tag = GS_IMAGE_TAG;\n                rendering_params.override_icc = false;\n                rendering_params.preserve_black = gsBKPRESNOTSPECIFIED;\n                rendering_params.rendering_intent = gsPERCEPTUAL;\n                rendering_params.cmm = gsCMM_DEFAULT;\n                /* Request the ICC link for the transform that we will need to use */\n                /* Note that if pgs is NULL we assume the same color space.  This\n                   is due to a call to pop the group from fill_mask when filling\n                   with a mask with transparency.  In that case, the parent\n                   and the child will have the same color space anyway */\n                icc_link = gsicc_get_link_profile(pgs, dev, curr_icc_profile,\n                                    nos->parent_color_info_procs->icc_profile,\n                                    &rendering_params, pgs->memory, false);\n                if (icc_link != NULL) {\n                    /* if problem with link we will do non-ICC approach */\n                    nonicc_conversion = false;\n                    /* If the link is the identity, then we don't need to do\n                       any color conversions */\n                    if ( !(icc_link->is_identity) ) {\n                        /* Before we do any allocations check if we can get away with\n                           reusing the existing buffer if it is the same size ( if it is\n                           smaller go ahead and allocate).  We could reuse it in this\n                           case too.  We need to do a bit of testing to determine what\n                           would be best.  */\n                        /* FIXME: RJW: Could we get away with just color converting\n                         * the area that's actually active (i.e. dirty, not rect)?\n                         */\n                        if(nos_num_color_comp != tos_num_color_comp) {\n                            /* Different size.  We will need to allocate */\n                            new_data_buf = gs_alloc_bytes(ctx->memory,\n                                                tos->planestride * new_num_planes,\n                                                    \"pdf14_pop_transparency_group\");\n                            if (new_data_buf == NULL)\n                                return_error(gs_error_VMerror);\n                            /* Copy over the noncolor planes. */\n                            memcpy(new_data_buf + tos->planestride * nos_num_color_comp,\n                                   tos->data + tos->planestride * tos_num_color_comp,\n                                   tos->planestride * num_noncolor_planes);\n                        } else {\n                            /* In place color conversion! */\n                            new_data_buf = tos->data;\n                        }\n                        /* Set up the buffer descriptors. Note that pdf14 always has\n                           the alpha channels at the back end (last planes).\n                           We will just handle that here and let the CMM know\n                           nothing about it */\n                        num_rows = tos->rect.q.y - tos->rect.p.y;\n                        num_cols = tos->rect.q.x - tos->rect.p.x;\n                        gsicc_init_buffer(&input_buff_desc, tos_num_color_comp, 1,\n                                          false, false, true,\n                                          tos->planestride, tos->rowstride,\n                                          num_rows, num_cols);\n                        gsicc_init_buffer(&output_buff_desc, nos_num_color_comp,\n                                          1, false, false, true, tos->planestride,\n                                          tos->rowstride, num_rows, num_cols);\n                        /* Transform the data. Since the pdf14 device should be\n                           using RGB, CMYK or Gray buffers, this transform\n                           does not need to worry about the cmap procs of\n                           the target device.  Those are handled when we do\n                           the pdf14 put image operation */\n                        (icc_link->procs.map_buffer)(dev, icc_link, &input_buff_desc,\n                                                     &output_buff_desc, tos->data,\n                                                     new_data_buf);\n                    }\n                    /* Release the link */\n                    gsicc_release_link(icc_link);\n                    /* free the old object if the color spaces were different sizes */\n                    if(!(icc_link->is_identity) &&\n                        nos_num_color_comp != tos_num_color_comp) {\n                        gs_free_object(ctx->memory, tos->data,\n                            \"pdf14_pop_transparency_group\");\n                        tos->data = new_data_buf;\n                    }\n                }\n            }\n            if (nonicc_conversion) {\n                /* Non ICC based transform */\n                new_data_buf = gs_alloc_bytes(ctx->memory,\n                                    tos->planestride * new_num_planes,\n                                    \"pdf14_pop_transparency_group\");\n                if (new_data_buf == NULL)\n                    return_error(gs_error_VMerror);\n                gs_transform_color_buffer_generic(tos->data, tos->rowstride,\n                            tos->planestride, tos_num_color_comp, tos->rect,\n                            new_data_buf, nos_num_color_comp, num_noncolor_planes);\n                /* Free the old object */\n                gs_free_object(ctx->memory, tos->data,\n                                \"pdf14_pop_transparency_group\");\n                 tos->data = new_data_buf;\n            }\n             /* Adjust the plane and channel size now */\n             tos->n_chan = nos->n_chan;\n             tos->n_planes = nos->n_planes;\n#if RAW_DUMP\n            /* Dump the current buffer to see what we have. */\n            dump_raw_buffer(ctx->stack->rect.q.y-ctx->stack->rect.p.y,\n                            ctx->stack->rowstride, ctx->stack->n_chan,\n                            ctx->stack->planestride, ctx->stack->rowstride,\n                            \"aCMTrans_Group_ColorConv\",ctx->stack->data);\n#endif\n             /* compose. never do overprint in this case */\n            pdf14_compose_group(tos, nos, maskbuf, x0, x1, y0, y1, nos->n_chan,\n                 nos->parent_color_info_procs->isadditive,\n                 nos->parent_color_info_procs->parent_blending_procs,\n                 false, drawn_comps, ctx->memory, dev);\n        }\n    } else {\n        /* Group color spaces are the same.  No color conversions needed */\n        if (x0 < x1 && y0 < y1)\n            pdf14_compose_group(tos, nos, maskbuf, x0, x1, y0, y1, nos->n_chan,\n                                ctx->additive, pblend_procs, overprint,\n                                drawn_comps, ctx->memory, dev);\n    }\nexit:\n    ctx->stack = nos;\n    /* We want to detect the cases where we have luminosity soft masks embedded\n       within one another.  The \"alpha\" channel really needs to be merged into\n       the luminosity channel in this case.  This will occur during the mask pop */\n    if (ctx->smask_depth > 0 && maskbuf != NULL) {\n        /* Set the trigger so that we will blend if not alpha. Since\n           we have softmasks embedded in softmasks */\n        ctx->smask_blend = true;\n    }\n    if_debug1m('v', ctx->memory, \"[v]pop buf, idle=%d\\n\", tos->idle);\n    pdf14_buf_free(tos, ctx->memory);\n    return 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141584,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int huft_build(const unsigned *b, const unsigned n,\n\t\t\tconst unsigned s, const unsigned short *d,\n\t\t\tconst unsigned char *e, huft_t **t, unsigned *m)\n{\n\tunsigned a;             /* counter for codes of length k */\n\tunsigned c[BMAX + 1];   /* bit length count table */\n\tunsigned eob_len;       /* length of end-of-block code (value 256) */\n\tunsigned f;             /* i repeats in table every f entries */\n\tint g;                  /* maximum code length */\n\tint htl;                /* table level */\n \tunsigned i;             /* counter, current code */\n \tunsigned j;             /* counter */\n \tint k;                  /* number of bits in current code */\n\tunsigned *p;            /* pointer into c[], b[], or v[] */\n \thuft_t *q;              /* points to current table */\n \thuft_t r;               /* table entry for structure assignment */\n \thuft_t *u[BMAX];        /* table stack */\n \tunsigned v[N_MAX];      /* values in order of bit length */\n \tint ws[BMAX + 1];       /* bits decoded stack */\n \tint w;                  /* bits decoded */\n \tunsigned x[BMAX + 1];   /* bit offsets, then code stack */\n\tint y;                  /* number of dummy codes added */\n\tunsigned z;             /* number of entries in current table */\n\n\t/* Length of EOB code, if any */\n\teob_len = n > 256 ? b[256] : BMAX;\n\n\t*t = NULL;\n\n \n \t/* Generate counts for each bit length */\n \tmemset(c, 0, sizeof(c));\n\tp = (unsigned *) b; /* cast allows us to reuse p for pointing to b */\n \ti = n;\n \tdo {\n \t\tc[*p]++; /* assume all entries <= BMAX */\n\t} while (--i);\n\tif (c[0] == n) {  /* null input - all zero length codes */\n\t\t*m = 0;\n\t\treturn 2;\n\t}\n\n\t/* Find minimum and maximum length, bound *m by those */\n\tfor (j = 1; (j <= BMAX) && (c[j] == 0); j++)\n\t\tcontinue;\n\tk = j; /* minimum code length */\n\tfor (i = BMAX; (c[i] == 0) && i; i--)\n\t\tcontinue;\n\tg = i; /* maximum code length */\n\t*m = (*m < j) ? j : ((*m > i) ? i : *m);\n\n\t/* Adjust last length count to fill out codes, if needed */\n\tfor (y = 1 << j; j < i; j++, y <<= 1) {\n\t\ty -= c[j];\n\t\tif (y < 0)\n\t\t\treturn 2; /* bad input: more codes than bits */\n\t}\n\ty -= c[i];\n\tif (y < 0)\n\t\treturn 2;\n\tc[i] += y;\n\n\t/* Generate starting offsets into the value table for each length */\n\tx[1] = j = 0;\n\tp = c + 1;\n\txp = x + 2;\n\twhile (--i) { /* note that i == g from above */\n\t\tj += *p++;\n\t\t*xp++ = j;\n\t}\n \t}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141661,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int huft_build(const unsigned *b, const unsigned n,\n\t\t\tconst unsigned s, const unsigned short *d,\n\t\t\tconst unsigned char *e, huft_t **t, unsigned *m)\n{\n\tunsigned a;             /* counter for codes of length k */\n\tunsigned c[BMAX + 1];   /* bit length count table */\n\tunsigned eob_len;       /* length of end-of-block code (value 256) */\n\tunsigned f;             /* i repeats in table every f entries */\n\tint g;                  /* maximum code length */\n\tint htl;                /* table level */\n \tunsigned i;             /* counter, current code */\n \tunsigned j;             /* counter */\n \tint k;                  /* number of bits in current code */\n\tconst unsigned *p;      /* pointer into c[], b[], or v[] */\n \thuft_t *q;              /* points to current table */\n \thuft_t r;               /* table entry for structure assignment */\n \thuft_t *u[BMAX];        /* table stack */\n \tunsigned v[N_MAX];      /* values in order of bit length */\n\tunsigned v_end;\n \tint ws[BMAX + 1];       /* bits decoded stack */\n \tint w;                  /* bits decoded */\n \tunsigned x[BMAX + 1];   /* bit offsets, then code stack */\n\tint y;                  /* number of dummy codes added */\n\tunsigned z;             /* number of entries in current table */\n\n\t/* Length of EOB code, if any */\n\teob_len = n > 256 ? b[256] : BMAX;\n\n\t*t = NULL;\n\n \n \t/* Generate counts for each bit length */\n \tmemset(c, 0, sizeof(c));\n\tp = b;\n \ti = n;\n \tdo {\n \t\tc[*p]++; /* assume all entries <= BMAX */\n\t} while (--i);\n\tif (c[0] == n) {  /* null input - all zero length codes */\n\t\t*m = 0;\n\t\treturn 2;\n\t}\n\n\t/* Find minimum and maximum length, bound *m by those */\n\tfor (j = 1; (j <= BMAX) && (c[j] == 0); j++)\n\t\tcontinue;\n\tk = j; /* minimum code length */\n\tfor (i = BMAX; (c[i] == 0) && i; i--)\n\t\tcontinue;\n\tg = i; /* maximum code length */\n\t*m = (*m < j) ? j : ((*m > i) ? i : *m);\n\n\t/* Adjust last length count to fill out codes, if needed */\n\tfor (y = 1 << j; j < i; j++, y <<= 1) {\n\t\ty -= c[j];\n\t\tif (y < 0)\n\t\t\treturn 2; /* bad input: more codes than bits */\n\t}\n\ty -= c[i];\n\tif (y < 0)\n\t\treturn 2;\n\tc[i] += y;\n\n\t/* Generate starting offsets into the value table for each length */\n\tx[1] = j = 0;\n\tp = c + 1;\n\txp = x + 2;\n\twhile (--i) { /* note that i == g from above */\n\t\tj += *p++;\n\t\t*xp++ = j;\n\t}\n \t}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141662,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\n\t/*\n\t * NT_PRSTATUS is the one special case, because the regset data\n\t * goes into the pr_reg field inside the note contents, rather\n\t * than being the whole note contents.  We fill the reset in here.\n\t * We assume that regset 0 is NT_PRSTATUS.\n\t */\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0],\n\t\t\t\t    0, sizeof(t->prstatus.pr_reg),\n\t\t\t\t    &t->prstatus.pr_reg, NULL);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(t->prstatus), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n\n\t/*\n\t * Each other regset might generate a note too.  For each regset\n\t * that has no core_note_type or is inactive, we leave t->notes[i]\n\t * all zero and we'll know to skip writing it later.\n\t */\n \tfor (i = 1; i < view->n; ++i) {\n \t\tconst struct user_regset *regset = &view->regsets[i];\n \t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type &&\n \t\t    (!regset->active || regset->active(t->task, regset))) {\n \t\t\tint ret;\n \t\t\tsize_t size = regset->n * regset->size;\n\t\t\tvoid *data = kmalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tt->prstatus.pr_fpvalid = 1;\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141673,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\n\t/*\n\t * NT_PRSTATUS is the one special case, because the regset data\n\t * goes into the pr_reg field inside the note contents, rather\n\t * than being the whole note contents.  We fill the reset in here.\n\t * We assume that regset 0 is NT_PRSTATUS.\n\t */\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0],\n\t\t\t\t    0, sizeof(t->prstatus.pr_reg),\n\t\t\t\t    &t->prstatus.pr_reg, NULL);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(t->prstatus), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n\n\t/*\n\t * Each other regset might generate a note too.  For each regset\n\t * that has no core_note_type or is inactive, we leave t->notes[i]\n\t * all zero and we'll know to skip writing it later.\n\t */\n \tfor (i = 1; i < view->n; ++i) {\n \t\tconst struct user_regset *regset = &view->regsets[i];\n \t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type && regset->get &&\n \t\t    (!regset->active || regset->active(t->task, regset))) {\n \t\t\tint ret;\n \t\t\tsize_t size = regset->n * regset->size;\n\t\t\tvoid *data = kmalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tt->prstatus.pr_fpvalid = 1;\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141674,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int __sys_sendmsg(struct socket *sock, struct msghdr __user *msg,\n\t\t\t struct msghdr *msg_sys, unsigned flags,\n\t\t\t struct used_address *used_address)\n{\n\tstruct compat_msghdr __user *msg_compat =\n\t    (struct compat_msghdr __user *)msg;\n\tstruct sockaddr_storage address;\n\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\n\tunsigned char ctl[sizeof(struct cmsghdr) + 20]\n\t    __attribute__ ((aligned(sizeof(__kernel_size_t))));\n\t/* 20 is size of ipv6_pktinfo */\n\tunsigned char *ctl_buf = ctl;\n\tint err, ctl_len, iov_size, total_len;\n\n\terr = -EFAULT;\n\tif (MSG_CMSG_COMPAT & flags) {\n\t\tif (get_compat_msghdr(msg_sys, msg_compat))\n\t\t\treturn -EFAULT;\n\t} else if (copy_from_user(msg_sys, msg, sizeof(struct msghdr)))\n\t\treturn -EFAULT;\n\n\t/* do not move before msg_sys is valid */\n\terr = -EMSGSIZE;\n\tif (msg_sys->msg_iovlen > UIO_MAXIOV)\n\t\tgoto out;\n\n\t/* Check whether to allocate the iovec area */\n\terr = -ENOMEM;\n\tiov_size = msg_sys->msg_iovlen * sizeof(struct iovec);\n\tif (msg_sys->msg_iovlen > UIO_FASTIOV) {\n\t\tiov = sock_kmalloc(sock->sk, iov_size, GFP_KERNEL);\n\t\tif (!iov)\n\t\t\tgoto out;\n\t}\n\n\t/* This will also move the address data into kernel space */\n\tif (MSG_CMSG_COMPAT & flags) {\n\t\terr = verify_compat_iovec(msg_sys, iov,\n\t\t\t\t\t  (struct sockaddr *)&address,\n\t\t\t\t\t  VERIFY_READ);\n\t} else\n\t\terr = verify_iovec(msg_sys, iov,\n\t\t\t\t   (struct sockaddr *)&address,\n\t\t\t\t   VERIFY_READ);\n\tif (err < 0)\n\t\tgoto out_freeiov;\n\ttotal_len = err;\n\n\terr = -ENOBUFS;\n\n\tif (msg_sys->msg_controllen > INT_MAX)\n\t\tgoto out_freeiov;\n\tctl_len = msg_sys->msg_controllen;\n\tif ((MSG_CMSG_COMPAT & flags) && ctl_len) {\n\t\terr =\n\t\t    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,\n\t\t\t\t\t\t     sizeof(ctl));\n\t\tif (err)\n\t\t\tgoto out_freeiov;\n\t\tctl_buf = msg_sys->msg_control;\n\t\tctl_len = msg_sys->msg_controllen;\n\t} else if (ctl_len) {\n\t\tif (ctl_len > sizeof(ctl)) {\n\t\t\tctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);\n\t\t\tif (ctl_buf == NULL)\n\t\t\t\tgoto out_freeiov;\n\t\t}\n\t\terr = -EFAULT;\n\t\t/*\n\t\t * Careful! Before this, msg_sys->msg_control contains a user pointer.\n\t\t * Afterwards, it will be a kernel pointer. Thus the compiler-assisted\n\t\t * checking falls down on this.\n\t\t */\n\t\tif (copy_from_user(ctl_buf,\n\t\t\t\t   (void __user __force *)msg_sys->msg_control,\n\t\t\t\t   ctl_len))\n\t\t\tgoto out_freectl;\n\t\tmsg_sys->msg_control = ctl_buf;\n\t}\n\tmsg_sys->msg_flags = flags;\n\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tmsg_sys->msg_flags |= MSG_DONTWAIT;\n\t/*\n\t * If this is sendmmsg() and current destination address is same as\n\t * previously succeeded address, omit asking LSM's decision.\n \t * used_address->name_len is initialized to UINT_MAX so that the first\n \t * destination address never matches.\n \t */\n\tif (used_address && used_address->name_len == msg_sys->msg_namelen &&\n\t    !memcmp(&used_address->name, msg->msg_name,\n \t\t    used_address->name_len)) {\n \t\terr = sock_sendmsg_nosec(sock, msg_sys, total_len);\n \t\tgoto out_freectl;\n\t}\n\terr = sock_sendmsg(sock, msg_sys, total_len);\n\t/*\n\t * If this is sendmmsg() and sending to current destination address was\n\t * successful, remember it.\n \t */\n \tif (used_address && err >= 0) {\n \t\tused_address->name_len = msg_sys->msg_namelen;\n\t\tmemcpy(&used_address->name, msg->msg_name,\n\t\t       used_address->name_len);\n \t}\n \n out_freectl:\n\tif (ctl_buf != ctl)\n\t\tsock_kfree_s(sock->sk, ctl_buf, ctl_len);\nout_freeiov:\n\tif (iov != iovstack)\n\t\tsock_kfree_s(sock->sk, iov, iov_size);\nout:\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141681,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int __sys_sendmsg(struct socket *sock, struct msghdr __user *msg,\n\t\t\t struct msghdr *msg_sys, unsigned flags,\n\t\t\t struct used_address *used_address)\n{\n\tstruct compat_msghdr __user *msg_compat =\n\t    (struct compat_msghdr __user *)msg;\n\tstruct sockaddr_storage address;\n\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\n\tunsigned char ctl[sizeof(struct cmsghdr) + 20]\n\t    __attribute__ ((aligned(sizeof(__kernel_size_t))));\n\t/* 20 is size of ipv6_pktinfo */\n\tunsigned char *ctl_buf = ctl;\n\tint err, ctl_len, iov_size, total_len;\n\n\terr = -EFAULT;\n\tif (MSG_CMSG_COMPAT & flags) {\n\t\tif (get_compat_msghdr(msg_sys, msg_compat))\n\t\t\treturn -EFAULT;\n\t} else if (copy_from_user(msg_sys, msg, sizeof(struct msghdr)))\n\t\treturn -EFAULT;\n\n\t/* do not move before msg_sys is valid */\n\terr = -EMSGSIZE;\n\tif (msg_sys->msg_iovlen > UIO_MAXIOV)\n\t\tgoto out;\n\n\t/* Check whether to allocate the iovec area */\n\terr = -ENOMEM;\n\tiov_size = msg_sys->msg_iovlen * sizeof(struct iovec);\n\tif (msg_sys->msg_iovlen > UIO_FASTIOV) {\n\t\tiov = sock_kmalloc(sock->sk, iov_size, GFP_KERNEL);\n\t\tif (!iov)\n\t\t\tgoto out;\n\t}\n\n\t/* This will also move the address data into kernel space */\n\tif (MSG_CMSG_COMPAT & flags) {\n\t\terr = verify_compat_iovec(msg_sys, iov,\n\t\t\t\t\t  (struct sockaddr *)&address,\n\t\t\t\t\t  VERIFY_READ);\n\t} else\n\t\terr = verify_iovec(msg_sys, iov,\n\t\t\t\t   (struct sockaddr *)&address,\n\t\t\t\t   VERIFY_READ);\n\tif (err < 0)\n\t\tgoto out_freeiov;\n\ttotal_len = err;\n\n\terr = -ENOBUFS;\n\n\tif (msg_sys->msg_controllen > INT_MAX)\n\t\tgoto out_freeiov;\n\tctl_len = msg_sys->msg_controllen;\n\tif ((MSG_CMSG_COMPAT & flags) && ctl_len) {\n\t\terr =\n\t\t    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,\n\t\t\t\t\t\t     sizeof(ctl));\n\t\tif (err)\n\t\t\tgoto out_freeiov;\n\t\tctl_buf = msg_sys->msg_control;\n\t\tctl_len = msg_sys->msg_controllen;\n\t} else if (ctl_len) {\n\t\tif (ctl_len > sizeof(ctl)) {\n\t\t\tctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);\n\t\t\tif (ctl_buf == NULL)\n\t\t\t\tgoto out_freeiov;\n\t\t}\n\t\terr = -EFAULT;\n\t\t/*\n\t\t * Careful! Before this, msg_sys->msg_control contains a user pointer.\n\t\t * Afterwards, it will be a kernel pointer. Thus the compiler-assisted\n\t\t * checking falls down on this.\n\t\t */\n\t\tif (copy_from_user(ctl_buf,\n\t\t\t\t   (void __user __force *)msg_sys->msg_control,\n\t\t\t\t   ctl_len))\n\t\t\tgoto out_freectl;\n\t\tmsg_sys->msg_control = ctl_buf;\n\t}\n\tmsg_sys->msg_flags = flags;\n\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tmsg_sys->msg_flags |= MSG_DONTWAIT;\n\t/*\n\t * If this is sendmmsg() and current destination address is same as\n\t * previously succeeded address, omit asking LSM's decision.\n \t * used_address->name_len is initialized to UINT_MAX so that the first\n \t * destination address never matches.\n \t */\n\tif (used_address && msg_sys->msg_name &&\n\t    used_address->name_len == msg_sys->msg_namelen &&\n\t    !memcmp(&used_address->name, msg_sys->msg_name,\n \t\t    used_address->name_len)) {\n \t\terr = sock_sendmsg_nosec(sock, msg_sys, total_len);\n \t\tgoto out_freectl;\n\t}\n\terr = sock_sendmsg(sock, msg_sys, total_len);\n\t/*\n\t * If this is sendmmsg() and sending to current destination address was\n\t * successful, remember it.\n \t */\n \tif (used_address && err >= 0) {\n \t\tused_address->name_len = msg_sys->msg_namelen;\n\t\tif (msg_sys->msg_name)\n\t\t\tmemcpy(&used_address->name, msg_sys->msg_name,\n\t\t\t       used_address->name_len);\n \t}\n \n out_freectl:\n\tif (ctl_buf != ctl)\n\t\tsock_kfree_s(sock->sk, ctl_buf, ctl_len);\nout_freeiov:\n\tif (iov != iovstack)\n\t\tsock_kfree_s(sock->sk, iov, iov_size);\nout:\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141682,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n {\n     void **ptrptr = ptr;\n     *ptrptr = av_realloc_f(*ptrptr, nmemb, size);\n    if (!*ptrptr && !(nmemb && size))\n         return AVERROR(ENOMEM);\n     return 0;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141751,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n {\n     void **ptrptr = ptr;\n     *ptrptr = av_realloc_f(*ptrptr, nmemb, size);\n    if (!*ptrptr && nmemb && size)\n         return AVERROR(ENOMEM);\n     return 0;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141752,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "pkinit_check_kdc_pkid(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      unsigned char *pdid_buf,\n                      unsigned int pkid_len,\n                      int *valid_kdcPkId)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    const unsigned char *p = pdid_buf;\n    int status = 1;\n    X509 *kdc_cert = sk_X509_value(id_cryptoctx->my_certs, id_cryptoctx->cert_index);\n\n    *valid_kdcPkId = 0;\n     pkiDebug(\"found kdcPkId in AS REQ\\n\");\n     is = d2i_PKCS7_ISSUER_AND_SERIAL(NULL, &p, (int)pkid_len);\n     if (is == NULL)\n        goto cleanup;\n \n     status = X509_NAME_cmp(X509_get_issuer_name(kdc_cert), is->issuer);\n     if (!status) {\n        status = ASN1_INTEGER_cmp(X509_get_serialNumber(kdc_cert), is->serial);\n        if (!status)\n            *valid_kdcPkId = 1;\n     }\n \n     retval = 0;\ncleanup:\n     X509_NAME_free(is->issuer);\n     ASN1_INTEGER_free(is->serial);\n     free(is);\n\n    return retval;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141803,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "pkinit_check_kdc_pkid(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      unsigned char *pdid_buf,\n                      unsigned int pkid_len,\n                      int *valid_kdcPkId)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    const unsigned char *p = pdid_buf;\n    int status = 1;\n    X509 *kdc_cert = sk_X509_value(id_cryptoctx->my_certs, id_cryptoctx->cert_index);\n\n    *valid_kdcPkId = 0;\n     pkiDebug(\"found kdcPkId in AS REQ\\n\");\n     is = d2i_PKCS7_ISSUER_AND_SERIAL(NULL, &p, (int)pkid_len);\n     if (is == NULL)\n        return retval;\n \n     status = X509_NAME_cmp(X509_get_issuer_name(kdc_cert), is->issuer);\n     if (!status) {\n        status = ASN1_INTEGER_cmp(X509_get_serialNumber(kdc_cert), is->serial);\n        if (!status)\n            *valid_kdcPkId = 1;\n     }\n \n     retval = 0;\n     X509_NAME_free(is->issuer);\n     ASN1_INTEGER_free(is->serial);\n     free(is);\n\n    return retval;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141804,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "pkinit_server_return_padata(krb5_context context,\n                            krb5_pa_data * padata,\n                            krb5_data *req_pkt,\n                            krb5_kdc_req * request,\n                            krb5_kdc_rep * reply,\n                            krb5_keyblock * encrypting_key,\n                            krb5_pa_data ** send_pa,\n                            krb5_kdcpreauth_callbacks cb,\n                            krb5_kdcpreauth_rock rock,\n                            krb5_kdcpreauth_moddata moddata,\n                            krb5_kdcpreauth_modreq modreq)\n{\n    krb5_error_code retval = 0;\n    krb5_data scratch = {0, 0, NULL};\n    krb5_pa_pk_as_req *reqp = NULL;\n    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;\n    int i = 0;\n\n    unsigned char *subjectPublicKey = NULL;\n    unsigned char *dh_pubkey = NULL, *server_key = NULL;\n    unsigned int subjectPublicKey_len = 0;\n    unsigned int server_key_len = 0, dh_pubkey_len = 0;\n\n    krb5_kdc_dh_key_info dhkey_info;\n    krb5_data *encoded_dhkey_info = NULL;\n    krb5_pa_pk_as_rep *rep = NULL;\n    krb5_pa_pk_as_rep_draft9 *rep9 = NULL;\n    krb5_data *out_data = NULL;\n    krb5_octet_data secret;\n\n    krb5_enctype enctype = -1;\n\n    krb5_reply_key_pack *key_pack = NULL;\n    krb5_reply_key_pack_draft9 *key_pack9 = NULL;\n    krb5_data *encoded_key_pack = NULL;\n\n    pkinit_kdc_context plgctx;\n    pkinit_kdc_req_context reqctx;\n\n    int fixed_keypack = 0;\n\n    *send_pa = NULL;\n    if (padata->pa_type == KRB5_PADATA_PKINIT_KX) {\n        return return_pkinit_kx(context, request, reply,\n                                encrypting_key, send_pa);\n    }\n    if (padata->length <= 0 || padata->contents == NULL)\n        return 0;\n\n    if (modreq == NULL) {\n        pkiDebug(\"missing request context \\n\");\n        return EINVAL;\n    }\n\n    plgctx = pkinit_find_realm_context(context, moddata, request->server);\n    if (plgctx == NULL) {\n        pkiDebug(\"Unable to locate correct realm context\\n\");\n        return ENOENT;\n    }\n\n    pkiDebug(\"pkinit_return_padata: entered!\\n\");\n    reqctx = (pkinit_kdc_req_context)modreq;\n\n    if (encrypting_key->contents) {\n        free(encrypting_key->contents);\n        encrypting_key->length = 0;\n        encrypting_key->contents = NULL;\n    }\n\n    for(i = 0; i < request->nktypes; i++) {\n        enctype = request->ktype[i];\n        if (!krb5_c_valid_enctype(enctype))\n            continue;\n        else {\n            pkiDebug(\"KDC picked etype = %d\\n\", enctype);\n            break;\n        }\n    }\n\n    if (i == request->nktypes) {\n        retval = KRB5KDC_ERR_ETYPE_NOSUPP;\n        goto cleanup;\n    }\n\n    switch((int)reqctx->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        init_krb5_pa_pk_as_rep(&rep);\n        if (rep == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        /* let's assume it's RSA. we'll reset it to DH if needed */\n        rep->choice = choice_pa_pk_as_rep_encKeyPack;\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        init_krb5_pa_pk_as_rep_draft9(&rep9);\n        if (rep9 == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        rep9->choice = choice_pa_pk_as_rep_draft9_encKeyPack;\n        break;\n    default:\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        goto cleanup;\n    }\n\n    if (reqctx->rcv_auth_pack != NULL &&\n        reqctx->rcv_auth_pack->clientPublicValue != NULL) {\n        subjectPublicKey =\n            reqctx->rcv_auth_pack->clientPublicValue->subjectPublicKey.data;\n        subjectPublicKey_len =\n            reqctx->rcv_auth_pack->clientPublicValue->subjectPublicKey.length;\n        rep->choice = choice_pa_pk_as_rep_dhInfo;\n    } else if (reqctx->rcv_auth_pack9 != NULL &&\n               reqctx->rcv_auth_pack9->clientPublicValue != NULL) {\n        subjectPublicKey =\n            reqctx->rcv_auth_pack9->clientPublicValue->subjectPublicKey.data;\n        subjectPublicKey_len =\n            reqctx->rcv_auth_pack9->clientPublicValue->subjectPublicKey.length;\n        rep9->choice = choice_pa_pk_as_rep_draft9_dhSignedData;\n    }\n\n    /* if this DH, then process finish computing DH key */\n    if (rep != NULL && (rep->choice == choice_pa_pk_as_rep_dhInfo ||\n                        rep->choice == choice_pa_pk_as_rep_draft9_dhSignedData)) {\n        pkiDebug(\"received DH key delivery AS REQ\\n\");\n        retval = server_process_dh(context, plgctx->cryptoctx,\n                                   reqctx->cryptoctx, plgctx->idctx, subjectPublicKey,\n                                   subjectPublicKey_len, &dh_pubkey, &dh_pubkey_len,\n                                   &server_key, &server_key_len);\n        if (retval) {\n            pkiDebug(\"failed to process/create dh paramters\\n\");\n            goto cleanup;\n        }\n    }\n    if ((rep9 != NULL &&\n         rep9->choice == choice_pa_pk_as_rep_draft9_dhSignedData) ||\n        (rep != NULL && rep->choice == choice_pa_pk_as_rep_dhInfo)) {\n\n        /*\n         * This is DH, so don't generate the key until after we\n         * encode the reply, because the encoded reply is needed\n         * to generate the key in some cases.\n         */\n\n        dhkey_info.subjectPublicKey.length = dh_pubkey_len;\n        dhkey_info.subjectPublicKey.data = dh_pubkey;\n        dhkey_info.nonce = request->nonce;\n        dhkey_info.dhKeyExpiration = 0;\n\n        retval = k5int_encode_krb5_kdc_dh_key_info(&dhkey_info,\n                                                   &encoded_dhkey_info);\n        if (retval) {\n            pkiDebug(\"encode_krb5_kdc_dh_key_info failed\\n\");\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin((unsigned char *)encoded_dhkey_info->data,\n                         encoded_dhkey_info->length,\n                         \"/tmp/kdc_dh_key_info\");\n#endif\n\n        switch ((int)padata->pa_type) {\n        case KRB5_PADATA_PK_AS_REQ:\n            retval = cms_signeddata_create(context, plgctx->cryptoctx,\n                                           reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_SERVER, 1,\n                                           (unsigned char *)encoded_dhkey_info->data,\n                                           encoded_dhkey_info->length,\n                                           &rep->u.dh_Info.dhSignedData.data,\n                                           &rep->u.dh_Info.dhSignedData.length);\n            if (retval) {\n                pkiDebug(\"failed to create pkcs7 signed data\\n\");\n                goto cleanup;\n            }\n            break;\n        case KRB5_PADATA_PK_AS_REP_OLD:\n        case KRB5_PADATA_PK_AS_REQ_OLD:\n            retval = cms_signeddata_create(context, plgctx->cryptoctx,\n                                           reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9, 1,\n                                           (unsigned char *)encoded_dhkey_info->data,\n                                           encoded_dhkey_info->length,\n                                           &rep9->u.dhSignedData.data,\n                                           &rep9->u.dhSignedData.length);\n            if (retval) {\n                pkiDebug(\"failed to create pkcs7 signed data\\n\");\n                goto cleanup;\n            }\n            break;\n        }\n\n    } else {\n        pkiDebug(\"received RSA key delivery AS REQ\\n\");\n\n        retval = krb5_c_make_random_key(context, enctype, encrypting_key);\n        if (retval) {\n            pkiDebug(\"unable to make a session key\\n\");\n            goto cleanup;\n        }\n\n        /* check if PA_TYPE of 132 is present which means the client is\n         * requesting that a checksum is send back instead of the nonce\n         */\n        for (i = 0; request->padata[i] != NULL; i++) {\n            pkiDebug(\"%s: Checking pa_type 0x%08x\\n\",\n                     __FUNCTION__, request->padata[i]->pa_type);\n            if (request->padata[i]->pa_type == 132)\n                fixed_keypack = 1;\n        }\n        pkiDebug(\"%s: return checksum instead of nonce = %d\\n\",\n                 __FUNCTION__, fixed_keypack);\n\n        /* if this is an RFC reply or draft9 client requested a checksum\n         * in the reply instead of the nonce, create an RFC-style keypack\n         */\n        if ((int)padata->pa_type == KRB5_PADATA_PK_AS_REQ || fixed_keypack) {\n            init_krb5_reply_key_pack(&key_pack);\n            if (key_pack == NULL) {\n                retval = ENOMEM;\n                goto cleanup;\n            }\n\n            retval = krb5_c_make_checksum(context, 0,\n                                          encrypting_key, KRB5_KEYUSAGE_TGS_REQ_AUTH_CKSUM,\n                                          req_pkt, &key_pack->asChecksum);\n            if (retval) {\n                pkiDebug(\"unable to calculate AS REQ checksum\\n\");\n                goto cleanup;\n            }\n#ifdef DEBUG_CKSUM\n            pkiDebug(\"calculating checksum on buf size = %d\\n\", req_pkt->length);\n            print_buffer(req_pkt->data, req_pkt->length);\n            pkiDebug(\"checksum size = %d\\n\", key_pack->asChecksum.length);\n            print_buffer(key_pack->asChecksum.contents,\n                         key_pack->asChecksum.length);\n            pkiDebug(\"encrypting key (%d)\\n\", encrypting_key->length);\n            print_buffer(encrypting_key->contents, encrypting_key->length);\n#endif\n\n            krb5_copy_keyblock_contents(context, encrypting_key,\n                                        &key_pack->replyKey);\n\n            retval = k5int_encode_krb5_reply_key_pack(key_pack,\n                                                      &encoded_key_pack);\n            if (retval) {\n                pkiDebug(\"failed to encode reply_key_pack\\n\");\n                goto cleanup;\n            }\n        }\n\n        switch ((int)padata->pa_type) {\n        case KRB5_PADATA_PK_AS_REQ:\n            rep->choice = choice_pa_pk_as_rep_encKeyPack;\n            retval = cms_envelopeddata_create(context, plgctx->cryptoctx,\n                                              reqctx->cryptoctx, plgctx->idctx, padata->pa_type, 1,\n                                              (unsigned char *)encoded_key_pack->data,\n                                              encoded_key_pack->length,\n                                              &rep->u.encKeyPack.data, &rep->u.encKeyPack.length);\n            break;\n        case KRB5_PADATA_PK_AS_REP_OLD:\n        case KRB5_PADATA_PK_AS_REQ_OLD:\n            /* if the request is from the broken draft9 client that\n             * expects back a nonce, create it now\n             */\n            if (!fixed_keypack) {\n                init_krb5_reply_key_pack_draft9(&key_pack9);\n                if (key_pack9 == NULL) {\n                    retval = ENOMEM;\n                    goto cleanup;\n                }\n                key_pack9->nonce = reqctx->rcv_auth_pack9->pkAuthenticator.nonce;\n                krb5_copy_keyblock_contents(context, encrypting_key,\n                                            &key_pack9->replyKey);\n\n                retval = k5int_encode_krb5_reply_key_pack_draft9(key_pack9,\n                                                                 &encoded_key_pack);\n                if (retval) {\n                    pkiDebug(\"failed to encode reply_key_pack\\n\");\n                    goto cleanup;\n                }\n            }\n\n            rep9->choice = choice_pa_pk_as_rep_draft9_encKeyPack;\n            retval = cms_envelopeddata_create(context, plgctx->cryptoctx,\n                                              reqctx->cryptoctx, plgctx->idctx, padata->pa_type, 1,\n                                              (unsigned char *)encoded_key_pack->data,\n                                              encoded_key_pack->length,\n                                              &rep9->u.encKeyPack.data, &rep9->u.encKeyPack.length);\n            break;\n        }\n        if (retval) {\n            pkiDebug(\"failed to create pkcs7 enveloped data: %s\\n\",\n                     error_message(retval));\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin((unsigned char *)encoded_key_pack->data,\n                         encoded_key_pack->length,\n                         \"/tmp/kdc_key_pack\");\n        switch ((int)padata->pa_type) {\n        case KRB5_PADATA_PK_AS_REQ:\n            print_buffer_bin(rep->u.encKeyPack.data,\n                             rep->u.encKeyPack.length,\n                             \"/tmp/kdc_enc_key_pack\");\n            break;\n        case KRB5_PADATA_PK_AS_REP_OLD:\n        case KRB5_PADATA_PK_AS_REQ_OLD:\n            print_buffer_bin(rep9->u.encKeyPack.data,\n                             rep9->u.encKeyPack.length,\n                             \"/tmp/kdc_enc_key_pack\");\n            break;\n        }\n#endif\n    }\n\n    if ((rep != NULL && rep->choice == choice_pa_pk_as_rep_dhInfo) &&\n        ((reqctx->rcv_auth_pack != NULL &&\n          reqctx->rcv_auth_pack->supportedKDFs != NULL))) {\n\n        /* If using the alg-agility KDF, put the algorithm in the reply\n         * before encoding it.\n         */\n        if (reqctx->rcv_auth_pack != NULL &&\n            reqctx->rcv_auth_pack->supportedKDFs != NULL) {\n            retval = pkinit_pick_kdf_alg(context, reqctx->rcv_auth_pack->supportedKDFs,\n                                         &(rep->u.dh_Info.kdfID));\n            if (retval) {\n                pkiDebug(\"pkinit_pick_kdf_alg failed: %s\\n\",\n                         error_message(retval));\n                goto cleanup;\n            }\n        }\n    }\n\n    switch ((int)padata->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        retval = k5int_encode_krb5_pa_pk_as_rep(rep, &out_data);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        retval = k5int_encode_krb5_pa_pk_as_rep_draft9(rep9, &out_data);\n        break;\n    }\n    if (retval) {\n        pkiDebug(\"failed to encode AS_REP\\n\");\n        goto cleanup;\n    }\n#ifdef DEBUG_ASN1\n    if (out_data != NULL)\n        print_buffer_bin((unsigned char *)out_data->data, out_data->length,\n                         \"/tmp/kdc_as_rep\");\n#endif\n\n    /* If this is DH, we haven't computed the key yet, so do it now. */\n    if ((rep9 != NULL &&\n          rep9->choice == choice_pa_pk_as_rep_draft9_dhSignedData) ||\n         (rep != NULL && rep->choice == choice_pa_pk_as_rep_dhInfo)) {\n \n        /* If mutually supported KDFs were found, use the alg agility KDF */\n        if (rep->u.dh_Info.kdfID) {\n            secret.data = server_key;\n             secret.length = server_key_len;\n \n             retval = pkinit_alg_agility_kdf(context, &secret,\n                                            rep->u.dh_Info.kdfID,\n                                            request->client, request->server,\n                                            enctype,\n                                            (krb5_octet_data *)req_pkt,\n                                            (krb5_octet_data *)out_data,\n                                            encrypting_key);\n            if (retval) {\n                pkiDebug(\"pkinit_alg_agility_kdf failed: %s\\n\",\n                         error_message(retval));\n                goto cleanup;\n            }\n\n            /* Otherwise, use the older octetstring2key() function */\n        } else {\n            retval = pkinit_octetstring2key(context, enctype, server_key,\n                                            server_key_len, encrypting_key);\n            if (retval) {\n                pkiDebug(\"pkinit_octetstring2key failed: %s\\n\",\n                         error_message(retval));\n                goto cleanup;\n            }\n        }\n    }\n\n    *send_pa = malloc(sizeof(krb5_pa_data));\n    if (*send_pa == NULL) {\n        retval = ENOMEM;\n        free(out_data->data);\n        free(out_data);\n        out_data = NULL;\n        goto cleanup;\n    }\n    (*send_pa)->magic = KV5M_PA_DATA;\n    switch ((int)padata->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        (*send_pa)->pa_type = KRB5_PADATA_PK_AS_REP;\n        break;\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n    case KRB5_PADATA_PK_AS_REP_OLD:\n        (*send_pa)->pa_type = KRB5_PADATA_PK_AS_REP_OLD;\n        break;\n    }\n    (*send_pa)->length = out_data->length;\n    (*send_pa)->contents = (krb5_octet *) out_data->data;\n\ncleanup:\n    pkinit_fini_kdc_req_context(context, reqctx);\n    free(scratch.data);\n    free(out_data);\n    if (encoded_dhkey_info != NULL)\n        krb5_free_data(context, encoded_dhkey_info);\n    if (encoded_key_pack != NULL)\n        krb5_free_data(context, encoded_key_pack);\n    free(dh_pubkey);\n    free(server_key);\n\n    switch ((int)padata->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        free_krb5_pa_pk_as_req(&reqp);\n        free_krb5_pa_pk_as_rep(&rep);\n        free_krb5_reply_key_pack(&key_pack);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        free_krb5_pa_pk_as_req_draft9(&reqp9);\n        free_krb5_pa_pk_as_rep_draft9(&rep9);\n        if (!fixed_keypack)\n            free_krb5_reply_key_pack_draft9(&key_pack9);\n        else\n            free_krb5_reply_key_pack(&key_pack);\n        break;\n    }\n\n    if (retval)\n        pkiDebug(\"pkinit_verify_padata failure\");\n\n    return retval;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141827,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "pkinit_server_return_padata(krb5_context context,\n                            krb5_pa_data * padata,\n                            krb5_data *req_pkt,\n                            krb5_kdc_req * request,\n                            krb5_kdc_rep * reply,\n                            krb5_keyblock * encrypting_key,\n                            krb5_pa_data ** send_pa,\n                            krb5_kdcpreauth_callbacks cb,\n                            krb5_kdcpreauth_rock rock,\n                            krb5_kdcpreauth_moddata moddata,\n                            krb5_kdcpreauth_modreq modreq)\n{\n    krb5_error_code retval = 0;\n    krb5_data scratch = {0, 0, NULL};\n    krb5_pa_pk_as_req *reqp = NULL;\n    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;\n    int i = 0;\n\n    unsigned char *subjectPublicKey = NULL;\n    unsigned char *dh_pubkey = NULL, *server_key = NULL;\n    unsigned int subjectPublicKey_len = 0;\n    unsigned int server_key_len = 0, dh_pubkey_len = 0;\n\n    krb5_kdc_dh_key_info dhkey_info;\n    krb5_data *encoded_dhkey_info = NULL;\n    krb5_pa_pk_as_rep *rep = NULL;\n    krb5_pa_pk_as_rep_draft9 *rep9 = NULL;\n    krb5_data *out_data = NULL;\n    krb5_octet_data secret;\n\n    krb5_enctype enctype = -1;\n\n    krb5_reply_key_pack *key_pack = NULL;\n    krb5_reply_key_pack_draft9 *key_pack9 = NULL;\n    krb5_data *encoded_key_pack = NULL;\n\n    pkinit_kdc_context plgctx;\n    pkinit_kdc_req_context reqctx;\n\n    int fixed_keypack = 0;\n\n    *send_pa = NULL;\n    if (padata->pa_type == KRB5_PADATA_PKINIT_KX) {\n        return return_pkinit_kx(context, request, reply,\n                                encrypting_key, send_pa);\n    }\n    if (padata->length <= 0 || padata->contents == NULL)\n        return 0;\n\n    if (modreq == NULL) {\n        pkiDebug(\"missing request context \\n\");\n        return EINVAL;\n    }\n\n    plgctx = pkinit_find_realm_context(context, moddata, request->server);\n    if (plgctx == NULL) {\n        pkiDebug(\"Unable to locate correct realm context\\n\");\n        return ENOENT;\n    }\n\n    pkiDebug(\"pkinit_return_padata: entered!\\n\");\n    reqctx = (pkinit_kdc_req_context)modreq;\n\n    if (encrypting_key->contents) {\n        free(encrypting_key->contents);\n        encrypting_key->length = 0;\n        encrypting_key->contents = NULL;\n    }\n\n    for(i = 0; i < request->nktypes; i++) {\n        enctype = request->ktype[i];\n        if (!krb5_c_valid_enctype(enctype))\n            continue;\n        else {\n            pkiDebug(\"KDC picked etype = %d\\n\", enctype);\n            break;\n        }\n    }\n\n    if (i == request->nktypes) {\n        retval = KRB5KDC_ERR_ETYPE_NOSUPP;\n        goto cleanup;\n    }\n\n    switch((int)reqctx->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        init_krb5_pa_pk_as_rep(&rep);\n        if (rep == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        /* let's assume it's RSA. we'll reset it to DH if needed */\n        rep->choice = choice_pa_pk_as_rep_encKeyPack;\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        init_krb5_pa_pk_as_rep_draft9(&rep9);\n        if (rep9 == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        rep9->choice = choice_pa_pk_as_rep_draft9_encKeyPack;\n        break;\n    default:\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        goto cleanup;\n    }\n\n    if (reqctx->rcv_auth_pack != NULL &&\n        reqctx->rcv_auth_pack->clientPublicValue != NULL) {\n        subjectPublicKey =\n            reqctx->rcv_auth_pack->clientPublicValue->subjectPublicKey.data;\n        subjectPublicKey_len =\n            reqctx->rcv_auth_pack->clientPublicValue->subjectPublicKey.length;\n        rep->choice = choice_pa_pk_as_rep_dhInfo;\n    } else if (reqctx->rcv_auth_pack9 != NULL &&\n               reqctx->rcv_auth_pack9->clientPublicValue != NULL) {\n        subjectPublicKey =\n            reqctx->rcv_auth_pack9->clientPublicValue->subjectPublicKey.data;\n        subjectPublicKey_len =\n            reqctx->rcv_auth_pack9->clientPublicValue->subjectPublicKey.length;\n        rep9->choice = choice_pa_pk_as_rep_draft9_dhSignedData;\n    }\n\n    /* if this DH, then process finish computing DH key */\n    if (rep != NULL && (rep->choice == choice_pa_pk_as_rep_dhInfo ||\n                        rep->choice == choice_pa_pk_as_rep_draft9_dhSignedData)) {\n        pkiDebug(\"received DH key delivery AS REQ\\n\");\n        retval = server_process_dh(context, plgctx->cryptoctx,\n                                   reqctx->cryptoctx, plgctx->idctx, subjectPublicKey,\n                                   subjectPublicKey_len, &dh_pubkey, &dh_pubkey_len,\n                                   &server_key, &server_key_len);\n        if (retval) {\n            pkiDebug(\"failed to process/create dh paramters\\n\");\n            goto cleanup;\n        }\n    }\n    if ((rep9 != NULL &&\n         rep9->choice == choice_pa_pk_as_rep_draft9_dhSignedData) ||\n        (rep != NULL && rep->choice == choice_pa_pk_as_rep_dhInfo)) {\n\n        /*\n         * This is DH, so don't generate the key until after we\n         * encode the reply, because the encoded reply is needed\n         * to generate the key in some cases.\n         */\n\n        dhkey_info.subjectPublicKey.length = dh_pubkey_len;\n        dhkey_info.subjectPublicKey.data = dh_pubkey;\n        dhkey_info.nonce = request->nonce;\n        dhkey_info.dhKeyExpiration = 0;\n\n        retval = k5int_encode_krb5_kdc_dh_key_info(&dhkey_info,\n                                                   &encoded_dhkey_info);\n        if (retval) {\n            pkiDebug(\"encode_krb5_kdc_dh_key_info failed\\n\");\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin((unsigned char *)encoded_dhkey_info->data,\n                         encoded_dhkey_info->length,\n                         \"/tmp/kdc_dh_key_info\");\n#endif\n\n        switch ((int)padata->pa_type) {\n        case KRB5_PADATA_PK_AS_REQ:\n            retval = cms_signeddata_create(context, plgctx->cryptoctx,\n                                           reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_SERVER, 1,\n                                           (unsigned char *)encoded_dhkey_info->data,\n                                           encoded_dhkey_info->length,\n                                           &rep->u.dh_Info.dhSignedData.data,\n                                           &rep->u.dh_Info.dhSignedData.length);\n            if (retval) {\n                pkiDebug(\"failed to create pkcs7 signed data\\n\");\n                goto cleanup;\n            }\n            break;\n        case KRB5_PADATA_PK_AS_REP_OLD:\n        case KRB5_PADATA_PK_AS_REQ_OLD:\n            retval = cms_signeddata_create(context, plgctx->cryptoctx,\n                                           reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9, 1,\n                                           (unsigned char *)encoded_dhkey_info->data,\n                                           encoded_dhkey_info->length,\n                                           &rep9->u.dhSignedData.data,\n                                           &rep9->u.dhSignedData.length);\n            if (retval) {\n                pkiDebug(\"failed to create pkcs7 signed data\\n\");\n                goto cleanup;\n            }\n            break;\n        }\n\n    } else {\n        pkiDebug(\"received RSA key delivery AS REQ\\n\");\n\n        retval = krb5_c_make_random_key(context, enctype, encrypting_key);\n        if (retval) {\n            pkiDebug(\"unable to make a session key\\n\");\n            goto cleanup;\n        }\n\n        /* check if PA_TYPE of 132 is present which means the client is\n         * requesting that a checksum is send back instead of the nonce\n         */\n        for (i = 0; request->padata[i] != NULL; i++) {\n            pkiDebug(\"%s: Checking pa_type 0x%08x\\n\",\n                     __FUNCTION__, request->padata[i]->pa_type);\n            if (request->padata[i]->pa_type == 132)\n                fixed_keypack = 1;\n        }\n        pkiDebug(\"%s: return checksum instead of nonce = %d\\n\",\n                 __FUNCTION__, fixed_keypack);\n\n        /* if this is an RFC reply or draft9 client requested a checksum\n         * in the reply instead of the nonce, create an RFC-style keypack\n         */\n        if ((int)padata->pa_type == KRB5_PADATA_PK_AS_REQ || fixed_keypack) {\n            init_krb5_reply_key_pack(&key_pack);\n            if (key_pack == NULL) {\n                retval = ENOMEM;\n                goto cleanup;\n            }\n\n            retval = krb5_c_make_checksum(context, 0,\n                                          encrypting_key, KRB5_KEYUSAGE_TGS_REQ_AUTH_CKSUM,\n                                          req_pkt, &key_pack->asChecksum);\n            if (retval) {\n                pkiDebug(\"unable to calculate AS REQ checksum\\n\");\n                goto cleanup;\n            }\n#ifdef DEBUG_CKSUM\n            pkiDebug(\"calculating checksum on buf size = %d\\n\", req_pkt->length);\n            print_buffer(req_pkt->data, req_pkt->length);\n            pkiDebug(\"checksum size = %d\\n\", key_pack->asChecksum.length);\n            print_buffer(key_pack->asChecksum.contents,\n                         key_pack->asChecksum.length);\n            pkiDebug(\"encrypting key (%d)\\n\", encrypting_key->length);\n            print_buffer(encrypting_key->contents, encrypting_key->length);\n#endif\n\n            krb5_copy_keyblock_contents(context, encrypting_key,\n                                        &key_pack->replyKey);\n\n            retval = k5int_encode_krb5_reply_key_pack(key_pack,\n                                                      &encoded_key_pack);\n            if (retval) {\n                pkiDebug(\"failed to encode reply_key_pack\\n\");\n                goto cleanup;\n            }\n        }\n\n        switch ((int)padata->pa_type) {\n        case KRB5_PADATA_PK_AS_REQ:\n            rep->choice = choice_pa_pk_as_rep_encKeyPack;\n            retval = cms_envelopeddata_create(context, plgctx->cryptoctx,\n                                              reqctx->cryptoctx, plgctx->idctx, padata->pa_type, 1,\n                                              (unsigned char *)encoded_key_pack->data,\n                                              encoded_key_pack->length,\n                                              &rep->u.encKeyPack.data, &rep->u.encKeyPack.length);\n            break;\n        case KRB5_PADATA_PK_AS_REP_OLD:\n        case KRB5_PADATA_PK_AS_REQ_OLD:\n            /* if the request is from the broken draft9 client that\n             * expects back a nonce, create it now\n             */\n            if (!fixed_keypack) {\n                init_krb5_reply_key_pack_draft9(&key_pack9);\n                if (key_pack9 == NULL) {\n                    retval = ENOMEM;\n                    goto cleanup;\n                }\n                key_pack9->nonce = reqctx->rcv_auth_pack9->pkAuthenticator.nonce;\n                krb5_copy_keyblock_contents(context, encrypting_key,\n                                            &key_pack9->replyKey);\n\n                retval = k5int_encode_krb5_reply_key_pack_draft9(key_pack9,\n                                                                 &encoded_key_pack);\n                if (retval) {\n                    pkiDebug(\"failed to encode reply_key_pack\\n\");\n                    goto cleanup;\n                }\n            }\n\n            rep9->choice = choice_pa_pk_as_rep_draft9_encKeyPack;\n            retval = cms_envelopeddata_create(context, plgctx->cryptoctx,\n                                              reqctx->cryptoctx, plgctx->idctx, padata->pa_type, 1,\n                                              (unsigned char *)encoded_key_pack->data,\n                                              encoded_key_pack->length,\n                                              &rep9->u.encKeyPack.data, &rep9->u.encKeyPack.length);\n            break;\n        }\n        if (retval) {\n            pkiDebug(\"failed to create pkcs7 enveloped data: %s\\n\",\n                     error_message(retval));\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin((unsigned char *)encoded_key_pack->data,\n                         encoded_key_pack->length,\n                         \"/tmp/kdc_key_pack\");\n        switch ((int)padata->pa_type) {\n        case KRB5_PADATA_PK_AS_REQ:\n            print_buffer_bin(rep->u.encKeyPack.data,\n                             rep->u.encKeyPack.length,\n                             \"/tmp/kdc_enc_key_pack\");\n            break;\n        case KRB5_PADATA_PK_AS_REP_OLD:\n        case KRB5_PADATA_PK_AS_REQ_OLD:\n            print_buffer_bin(rep9->u.encKeyPack.data,\n                             rep9->u.encKeyPack.length,\n                             \"/tmp/kdc_enc_key_pack\");\n            break;\n        }\n#endif\n    }\n\n    if ((rep != NULL && rep->choice == choice_pa_pk_as_rep_dhInfo) &&\n        ((reqctx->rcv_auth_pack != NULL &&\n          reqctx->rcv_auth_pack->supportedKDFs != NULL))) {\n\n        /* If using the alg-agility KDF, put the algorithm in the reply\n         * before encoding it.\n         */\n        if (reqctx->rcv_auth_pack != NULL &&\n            reqctx->rcv_auth_pack->supportedKDFs != NULL) {\n            retval = pkinit_pick_kdf_alg(context, reqctx->rcv_auth_pack->supportedKDFs,\n                                         &(rep->u.dh_Info.kdfID));\n            if (retval) {\n                pkiDebug(\"pkinit_pick_kdf_alg failed: %s\\n\",\n                         error_message(retval));\n                goto cleanup;\n            }\n        }\n    }\n\n    switch ((int)padata->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        retval = k5int_encode_krb5_pa_pk_as_rep(rep, &out_data);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        retval = k5int_encode_krb5_pa_pk_as_rep_draft9(rep9, &out_data);\n        break;\n    }\n    if (retval) {\n        pkiDebug(\"failed to encode AS_REP\\n\");\n        goto cleanup;\n    }\n#ifdef DEBUG_ASN1\n    if (out_data != NULL)\n        print_buffer_bin((unsigned char *)out_data->data, out_data->length,\n                         \"/tmp/kdc_as_rep\");\n#endif\n\n    /* If this is DH, we haven't computed the key yet, so do it now. */\n    if ((rep9 != NULL &&\n          rep9->choice == choice_pa_pk_as_rep_draft9_dhSignedData) ||\n         (rep != NULL && rep->choice == choice_pa_pk_as_rep_dhInfo)) {\n \n        /* If we're not doing draft 9, and mutually supported KDFs were found,\n         * use the algorithm agility KDF. */\n        if (rep != NULL && rep->u.dh_Info.kdfID) {\n            secret.data = (char *)server_key;\n             secret.length = server_key_len;\n \n             retval = pkinit_alg_agility_kdf(context, &secret,\n                                            rep->u.dh_Info.kdfID,\n                                            request->client, request->server,\n                                            enctype,\n                                            (krb5_octet_data *)req_pkt,\n                                            (krb5_octet_data *)out_data,\n                                            encrypting_key);\n            if (retval) {\n                pkiDebug(\"pkinit_alg_agility_kdf failed: %s\\n\",\n                         error_message(retval));\n                goto cleanup;\n            }\n\n            /* Otherwise, use the older octetstring2key() function */\n        } else {\n            retval = pkinit_octetstring2key(context, enctype, server_key,\n                                            server_key_len, encrypting_key);\n            if (retval) {\n                pkiDebug(\"pkinit_octetstring2key failed: %s\\n\",\n                         error_message(retval));\n                goto cleanup;\n            }\n        }\n    }\n\n    *send_pa = malloc(sizeof(krb5_pa_data));\n    if (*send_pa == NULL) {\n        retval = ENOMEM;\n        free(out_data->data);\n        free(out_data);\n        out_data = NULL;\n        goto cleanup;\n    }\n    (*send_pa)->magic = KV5M_PA_DATA;\n    switch ((int)padata->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        (*send_pa)->pa_type = KRB5_PADATA_PK_AS_REP;\n        break;\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n    case KRB5_PADATA_PK_AS_REP_OLD:\n        (*send_pa)->pa_type = KRB5_PADATA_PK_AS_REP_OLD;\n        break;\n    }\n    (*send_pa)->length = out_data->length;\n    (*send_pa)->contents = (krb5_octet *) out_data->data;\n\ncleanup:\n    pkinit_fini_kdc_req_context(context, reqctx);\n    free(scratch.data);\n    free(out_data);\n    if (encoded_dhkey_info != NULL)\n        krb5_free_data(context, encoded_dhkey_info);\n    if (encoded_key_pack != NULL)\n        krb5_free_data(context, encoded_key_pack);\n    free(dh_pubkey);\n    free(server_key);\n\n    switch ((int)padata->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        free_krb5_pa_pk_as_req(&reqp);\n        free_krb5_pa_pk_as_rep(&rep);\n        free_krb5_reply_key_pack(&key_pack);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        free_krb5_pa_pk_as_req_draft9(&reqp9);\n        free_krb5_pa_pk_as_rep_draft9(&rep9);\n        if (!fixed_keypack)\n            free_krb5_reply_key_pack_draft9(&key_pack9);\n        else\n            free_krb5_reply_key_pack(&key_pack);\n        break;\n    }\n\n    if (retval)\n        pkiDebug(\"pkinit_verify_padata failure\");\n\n    return retval;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141828,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,\n\t\t\t      struct sctp_association *assoc,\n\t\t\t      sctp_socket_type_t type)\n{\n\tstruct sctp_sock *oldsp = sctp_sk(oldsk);\n\tstruct sctp_sock *newsp = sctp_sk(newsk);\n\tstruct sctp_bind_bucket *pp; /* hash list port iterator */\n\tstruct sctp_endpoint *newep = newsp->ep;\n\tstruct sk_buff *skb, *tmp;\n\tstruct sctp_ulpevent *event;\n\tint flags = 0;\n\n\t/* Migrate socket buffer sizes and all the socket level options to the\n\t * new socket.\n\t */\n\tnewsk->sk_sndbuf = oldsk->sk_sndbuf;\n\tnewsk->sk_rcvbuf = oldsk->sk_rcvbuf;\n\t/* Brute force copy old sctp opt. */\n\tinet_sk_copy_descendant(newsk, oldsk);\n\n\t/* Restore the ep value that was overwritten with the above structure\n\t * copy.\n\t */\n\tnewsp->ep = newep;\n\tnewsp->hmac = NULL;\n\n\t/* Hook this new socket in to the bind_hash list. */\n\tpp = sctp_sk(oldsk)->bind_hash;\n\tsk_add_bind_node(newsk, &pp->owner);\n\tsctp_sk(newsk)->bind_hash = pp;\n\tinet_sk(newsk)->num = inet_sk(oldsk)->num;\n\n\t/* Copy the bind_addr list from the original endpoint to the new\n\t * endpoint so that we can handle restarts properly\n\t */\n\tif (PF_INET6 == assoc->base.sk->sk_family)\n\t\tflags = SCTP_ADDR6_ALLOWED;\n\tif (assoc->peer.ipv4_address)\n\t\tflags |= SCTP_ADDR4_PEERSUPP;\n\tif (assoc->peer.ipv6_address)\n\t\tflags |= SCTP_ADDR6_PEERSUPP;\n\tsctp_bind_addr_copy(&newsp->ep->base.bind_addr,\n\t\t\t     &oldsp->ep->base.bind_addr,\n\t\t\t     SCTP_SCOPE_GLOBAL, GFP_KERNEL, flags);\n\n\t/* Move any messages in the old socket's receive queue that are for the\n\t * peeled off association to the new socket's receive queue.\n\t */\n \tsctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n \t\tevent = sctp_skb2event(skb);\n \t\tif (event->asoc == assoc) {\n\t\t\tsctp_sock_rfree(skb);\n \t\t\t__skb_unlink(skb, &oldsk->sk_receive_queue);\n \t\t\t__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_set_owner_r(skb, newsk);\n \t\t}\n \t}\n \n\t/* Clean up any messages pending delivery due to partial\n\t * delivery.   Three cases:\n\t * 1) No partial deliver;  no work.\n\t * 2) Peeling off partial delivery; keep pd_lobby in new pd_lobby.\n\t * 3) Peeling off non-partial delivery; move pd_lobby to receive_queue.\n\t */\n\tskb_queue_head_init(&newsp->pd_lobby);\n\tsctp_sk(newsk)->pd_mode = assoc->ulpq.pd_mode;\n\n\tif (sctp_sk(oldsk)->pd_mode) {\n\t\tstruct sk_buff_head *queue;\n\n\t\t/* Decide which queue to move pd_lobby skbs to. */\n\t\tif (assoc->ulpq.pd_mode) {\n\t\t\tqueue = &newsp->pd_lobby;\n\t\t} else\n\t\t\tqueue = &newsk->sk_receive_queue;\n\n\t\t/* Walk through the pd_lobby, looking for skbs that\n\t\t * need moved to the new socket.\n\t\t */\n \t\tsctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n \t\t\tevent = sctp_skb2event(skb);\n \t\t\tif (event->asoc == assoc) {\n\t\t\t\tsctp_sock_rfree(skb);\n \t\t\t\t__skb_unlink(skb, &oldsp->pd_lobby);\n \t\t\t\t__skb_queue_tail(queue, skb);\n\t\t\t\tsctp_skb_set_owner_r(skb, newsk);\n \t\t\t}\n \t\t}\n \n\t\t/* Clear up any skbs waiting for the partial\n\t\t * delivery to finish.\n\t\t */\n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_clear_pd(oldsk);\n \n \t}\n \n \t/* Set the type of socket to indicate that it is peeled off from the\n \t * original UDP-style socket or created with the accept() call on a\n \t * TCP-style socket..\n\t */\n\tnewsp->type = type;\n\n\t/* Mark the new socket \"in-use\" by the user so that any packets\n\t * that may arrive on the association after we've moved it are\n\t * queued to the backlog.  This prevents a potential race between\n\t * backlog processing on the old socket and new-packet processing\n\t * on the new socket.\n\t */\n\tsctp_lock_sock(newsk);\n\tsctp_assoc_migrate(assoc, newsk);\n\n\t/* If the association on the newsk is already closed before accept()\n\t * is called, set RCV_SHUTDOWN flag.\n\t */\n\tif (sctp_state(assoc, CLOSED) && sctp_style(newsk, TCP))\n\t\tnewsk->sk_shutdown |= RCV_SHUTDOWN;\n\n\tnewsk->sk_state = SCTP_SS_ESTABLISHED;\n\tsctp_release_sock(newsk);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141837,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,\n\t\t\t      struct sctp_association *assoc,\n\t\t\t      sctp_socket_type_t type)\n{\n\tstruct sctp_sock *oldsp = sctp_sk(oldsk);\n\tstruct sctp_sock *newsp = sctp_sk(newsk);\n\tstruct sctp_bind_bucket *pp; /* hash list port iterator */\n\tstruct sctp_endpoint *newep = newsp->ep;\n\tstruct sk_buff *skb, *tmp;\n\tstruct sctp_ulpevent *event;\n\tint flags = 0;\n\n\t/* Migrate socket buffer sizes and all the socket level options to the\n\t * new socket.\n\t */\n\tnewsk->sk_sndbuf = oldsk->sk_sndbuf;\n\tnewsk->sk_rcvbuf = oldsk->sk_rcvbuf;\n\t/* Brute force copy old sctp opt. */\n\tinet_sk_copy_descendant(newsk, oldsk);\n\n\t/* Restore the ep value that was overwritten with the above structure\n\t * copy.\n\t */\n\tnewsp->ep = newep;\n\tnewsp->hmac = NULL;\n\n\t/* Hook this new socket in to the bind_hash list. */\n\tpp = sctp_sk(oldsk)->bind_hash;\n\tsk_add_bind_node(newsk, &pp->owner);\n\tsctp_sk(newsk)->bind_hash = pp;\n\tinet_sk(newsk)->num = inet_sk(oldsk)->num;\n\n\t/* Copy the bind_addr list from the original endpoint to the new\n\t * endpoint so that we can handle restarts properly\n\t */\n\tif (PF_INET6 == assoc->base.sk->sk_family)\n\t\tflags = SCTP_ADDR6_ALLOWED;\n\tif (assoc->peer.ipv4_address)\n\t\tflags |= SCTP_ADDR4_PEERSUPP;\n\tif (assoc->peer.ipv6_address)\n\t\tflags |= SCTP_ADDR6_PEERSUPP;\n\tsctp_bind_addr_copy(&newsp->ep->base.bind_addr,\n\t\t\t     &oldsp->ep->base.bind_addr,\n\t\t\t     SCTP_SCOPE_GLOBAL, GFP_KERNEL, flags);\n\n\t/* Move any messages in the old socket's receive queue that are for the\n\t * peeled off association to the new socket's receive queue.\n\t */\n \tsctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n \t\tevent = sctp_skb2event(skb);\n \t\tif (event->asoc == assoc) {\n\t\t\tsctp_sock_rfree_frag(skb);\n \t\t\t__skb_unlink(skb, &oldsk->sk_receive_queue);\n \t\t\t__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n \t\t}\n \t}\n \n\t/* Clean up any messages pending delivery due to partial\n\t * delivery.   Three cases:\n\t * 1) No partial deliver;  no work.\n\t * 2) Peeling off partial delivery; keep pd_lobby in new pd_lobby.\n\t * 3) Peeling off non-partial delivery; move pd_lobby to receive_queue.\n\t */\n\tskb_queue_head_init(&newsp->pd_lobby);\n\tsctp_sk(newsk)->pd_mode = assoc->ulpq.pd_mode;\n\n\tif (sctp_sk(oldsk)->pd_mode) {\n\t\tstruct sk_buff_head *queue;\n\n\t\t/* Decide which queue to move pd_lobby skbs to. */\n\t\tif (assoc->ulpq.pd_mode) {\n\t\t\tqueue = &newsp->pd_lobby;\n\t\t} else\n\t\t\tqueue = &newsk->sk_receive_queue;\n\n\t\t/* Walk through the pd_lobby, looking for skbs that\n\t\t * need moved to the new socket.\n\t\t */\n \t\tsctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n \t\t\tevent = sctp_skb2event(skb);\n \t\t\tif (event->asoc == assoc) {\n\t\t\t\tsctp_sock_rfree_frag(skb);\n \t\t\t\t__skb_unlink(skb, &oldsp->pd_lobby);\n \t\t\t\t__skb_queue_tail(queue, skb);\n\t\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n \t\t\t}\n \t\t}\n \n\t\t/* Clear up any skbs waiting for the partial\n\t\t * delivery to finish.\n\t\t */\n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_clear_pd(oldsk);\n \n \t}\n \n\tsctp_skb_for_each(skb, &assoc->ulpq.reasm, tmp) {\n\t\tsctp_sock_rfree_frag(skb);\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t}\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.lobby, tmp) {\n\t\tsctp_sock_rfree_frag(skb);\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t}\n\n \t/* Set the type of socket to indicate that it is peeled off from the\n \t * original UDP-style socket or created with the accept() call on a\n \t * TCP-style socket..\n\t */\n\tnewsp->type = type;\n\n\t/* Mark the new socket \"in-use\" by the user so that any packets\n\t * that may arrive on the association after we've moved it are\n\t * queued to the backlog.  This prevents a potential race between\n\t * backlog processing on the old socket and new-packet processing\n\t * on the new socket.\n\t */\n\tsctp_lock_sock(newsk);\n\tsctp_assoc_migrate(assoc, newsk);\n\n\t/* If the association on the newsk is already closed before accept()\n\t * is called, set RCV_SHUTDOWN flag.\n\t */\n\tif (sctp_state(assoc, CLOSED) && sctp_style(newsk, TCP))\n\t\tnewsk->sk_shutdown |= RCV_SHUTDOWN;\n\n\tnewsk->sk_state = SCTP_SS_ESTABLISHED;\n\tsctp_release_sock(newsk);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141838,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)\n{\n\tconst char *s = name;\n\n\twhile (1) {\n\t\tconst char *s0 = s;\n\t\tchar *dirname;\n\n\t\t/* Find a directory component, if any.  */\n\t\twhile (1) {\n\t\t\tif (*s == 0) {\n\t\t\t\tif (last && s != s0)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\treturn dir;\n\t\t\t}\n\t\t\t/* This is deliberately slash-only.  */\n\t\t\tif (*s == '/')\n\t\t\t\tbreak;\n\t\t\ts++;\n\t\t}\n\n\t\tdirname = g_strndup (s0, s - s0);\n\t\twhile (*s == '/')\n\t\t\ts++;\n\n\t\tif (strcmp (dirname, \".\") != 0) {\n\t\t\tGsfInput *subdir =\n \t\t\t\tgsf_infile_child_by_name (GSF_INFILE (dir),\n \t\t\t\t\t\t\t  dirname);\n \t\t\tif (subdir) {\n \t\t\t\t/* Undo the ref. */\n \t\t\t\tg_object_unref (subdir);\n\t\t\t\tdir = GSF_INFILE_TAR (subdir);\n \t\t\t} else\n \t\t\t\tdir = tar_create_dir (dir, dirname);\n \t\t}\n\n\t\tg_free (dirname);\n\t}\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142029,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)\n{\n\tconst char *s = name;\n\n\twhile (1) {\n\t\tconst char *s0 = s;\n\t\tchar *dirname;\n\n\t\t/* Find a directory component, if any.  */\n\t\twhile (1) {\n\t\t\tif (*s == 0) {\n\t\t\t\tif (last && s != s0)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\treturn dir;\n\t\t\t}\n\t\t\t/* This is deliberately slash-only.  */\n\t\t\tif (*s == '/')\n\t\t\t\tbreak;\n\t\t\ts++;\n\t\t}\n\n\t\tdirname = g_strndup (s0, s - s0);\n\t\twhile (*s == '/')\n\t\t\ts++;\n\n\t\tif (strcmp (dirname, \".\") != 0) {\n\t\t\tGsfInput *subdir =\n \t\t\t\tgsf_infile_child_by_name (GSF_INFILE (dir),\n \t\t\t\t\t\t\t  dirname);\n \t\t\tif (subdir) {\n\t\t\t\tdir = GSF_IS_INFILE_TAR (subdir)\n\t\t\t\t\t? GSF_INFILE_TAR (subdir)\n\t\t\t\t\t: dir;\n \t\t\t\t/* Undo the ref. */\n \t\t\t\tg_object_unref (subdir);\n \t\t\t} else\n \t\t\t\tdir = tar_create_dir (dir, dirname);\n \t\t}\n\n\t\tg_free (dirname);\n\t}\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142030,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n \tstruct sock *sk2;\n \tstruct alg_sock *ask2;\n \tstruct hash_ctx *ctx2;\n \tint err;\n \n\terr = crypto_ahash_export(req, state);\n \tif (err)\n \t\treturn err;\n \n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\n \tsk2 = newsock->sk;\n \task2 = alg_sk(sk2);\n \tctx2 = ask2->private;\n\tctx2->more = 1;\n \n \terr = crypto_ahash_import(&ctx2->req, state);\n \tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142059,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n \tstruct sock *sk2;\n \tstruct alg_sock *ask2;\n \tstruct hash_ctx *ctx2;\n\tbool more;\n \tint err;\n \n\tlock_sock(sk);\n\tmore = ctx->more;\n\terr = more ? crypto_ahash_export(req, state) : 0;\n\trelease_sock(sk);\n\n \tif (err)\n \t\treturn err;\n \n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\n \tsk2 = newsock->sk;\n \task2 = alg_sk(sk2);\n \tctx2 = ask2->private;\n\tctx2->more = more;\n\n\tif (!more)\n\t\treturn err;\n \n \terr = crypto_ahash_import(&ctx2->req, state);\n \tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142060,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "validate_as_request(kdc_realm_t *kdc_active_realm,\n                    register krb5_kdc_req *request, krb5_db_entry client,\n                    krb5_db_entry server, krb5_timestamp kdc_time,\n                    const char **status, krb5_pa_data ***e_data)\n{\n    int errcode;\n    krb5_error_code ret;\n\n    /*\n     * If an option is set that is only allowed in TGS requests, complain.\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KDC_ERR_BADOPTION;\n    }\n\n    /* The client must not be expired */\n    if (client.expiration && client.expiration < kdc_time) {\n        *status = \"CLIENT EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_NAME_EXP);\n    }\n\n    /* The client's password must not be expired, unless the server is\n       a KRB5_KDC_PWCHANGE_SERVICE. */\n    if (client.pw_expiration && client.pw_expiration < kdc_time &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"CLIENT KEY EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_KEY_EXP);\n    }\n\n    /* The server must not be expired */\n    if (server.expiration && server.expiration < kdc_time) {\n        *status = \"SERVICE EXPIRED\";\n        return(KDC_ERR_SERVICE_EXP);\n    }\n\n    /*\n     * If the client requires password changing, then only allow the\n     * pwchange service.\n     */\n    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"REQUIRED PWCHANGE\";\n        return(KDC_ERR_KEY_EXP);\n    }\n\n    /* Client and server must allow postdating tickets */\n    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||\n         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {\n        *status = \"POSTDATE NOT ALLOWED\";\n        return(KDC_ERR_CANNOT_POSTDATE);\n    }\n\n    /*\n     * A Windows KDC will return KDC_ERR_PREAUTH_REQUIRED instead of\n     * KDC_ERR_POLICY in the following case:\n     *\n     *   - KDC_OPT_FORWARDABLE is set in KDCOptions but local\n     *     policy has KRB5_KDB_DISALLOW_FORWARDABLE set for the\n     *     client, and;\n     *   - KRB5_KDB_REQUIRES_PRE_AUTH is set for the client but\n     *     preauthentication data is absent in the request.\n     *\n     * Hence, this check most be done after the check for preauth\n     * data, and is now performed by validate_forwardable() (the\n     * contents of which were previously below).\n     */\n\n    /* Client and server must allow proxiable tickets */\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_PROXIABLE) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_PROXIABLE))) {\n        *status = \"PROXIABLE NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Check to see if client is locked out */\n    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"CLIENT LOCKED OUT\";\n        return(KDC_ERR_CLIENT_REVOKED);\n    }\n\n    /* Check to see if server is locked out */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"SERVICE LOCKED OUT\";\n        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);\n    }\n\n    /* Check to see if server is allowed to be a service */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {\n        *status = \"SERVICE NOT ALLOWED\";\n         return(KDC_ERR_MUST_USE_USER2USER);\n     }\n \n    if (check_anon(kdc_active_realm, request->client, request->server) != 0) {\n         *status = \"ANONYMOUS NOT ALLOWED\";\n         return(KDC_ERR_POLICY);\n     }\n\n    /* Perform KDB module policy checks. */\n    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,\n                                  kdc_time, status, e_data);\n    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)\n        return errcode_to_protocol(ret);\n\n    /* Check against local policy. */\n    errcode = against_local_policy_as(request, client, server,\n                                      kdc_time, status, e_data);\n    if (errcode)\n        return errcode;\n\n    return 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142161,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "validate_as_request(kdc_realm_t *kdc_active_realm,\n                    register krb5_kdc_req *request, krb5_db_entry client,\n                    krb5_db_entry server, krb5_timestamp kdc_time,\n                    const char **status, krb5_pa_data ***e_data)\n{\n    int errcode;\n    krb5_error_code ret;\n\n    /*\n     * If an option is set that is only allowed in TGS requests, complain.\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KDC_ERR_BADOPTION;\n    }\n\n    /* The client must not be expired */\n    if (client.expiration && client.expiration < kdc_time) {\n        *status = \"CLIENT EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_NAME_EXP);\n    }\n\n    /* The client's password must not be expired, unless the server is\n       a KRB5_KDC_PWCHANGE_SERVICE. */\n    if (client.pw_expiration && client.pw_expiration < kdc_time &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"CLIENT KEY EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_KEY_EXP);\n    }\n\n    /* The server must not be expired */\n    if (server.expiration && server.expiration < kdc_time) {\n        *status = \"SERVICE EXPIRED\";\n        return(KDC_ERR_SERVICE_EXP);\n    }\n\n    /*\n     * If the client requires password changing, then only allow the\n     * pwchange service.\n     */\n    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"REQUIRED PWCHANGE\";\n        return(KDC_ERR_KEY_EXP);\n    }\n\n    /* Client and server must allow postdating tickets */\n    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||\n         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {\n        *status = \"POSTDATE NOT ALLOWED\";\n        return(KDC_ERR_CANNOT_POSTDATE);\n    }\n\n    /*\n     * A Windows KDC will return KDC_ERR_PREAUTH_REQUIRED instead of\n     * KDC_ERR_POLICY in the following case:\n     *\n     *   - KDC_OPT_FORWARDABLE is set in KDCOptions but local\n     *     policy has KRB5_KDB_DISALLOW_FORWARDABLE set for the\n     *     client, and;\n     *   - KRB5_KDB_REQUIRES_PRE_AUTH is set for the client but\n     *     preauthentication data is absent in the request.\n     *\n     * Hence, this check most be done after the check for preauth\n     * data, and is now performed by validate_forwardable() (the\n     * contents of which were previously below).\n     */\n\n    /* Client and server must allow proxiable tickets */\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_PROXIABLE) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_PROXIABLE))) {\n        *status = \"PROXIABLE NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Check to see if client is locked out */\n    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"CLIENT LOCKED OUT\";\n        return(KDC_ERR_CLIENT_REVOKED);\n    }\n\n    /* Check to see if server is locked out */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"SERVICE LOCKED OUT\";\n        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);\n    }\n\n    /* Check to see if server is allowed to be a service */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {\n        *status = \"SERVICE NOT ALLOWED\";\n         return(KDC_ERR_MUST_USE_USER2USER);\n     }\n \n    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {\n         *status = \"ANONYMOUS NOT ALLOWED\";\n         return(KDC_ERR_POLICY);\n     }\n\n    /* Perform KDB module policy checks. */\n    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,\n                                  kdc_time, status, e_data);\n    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)\n        return errcode_to_protocol(ret);\n\n    /* Check against local policy. */\n    errcode = against_local_policy_as(request, client, server,\n                                      kdc_time, status, e_data);\n    if (errcode)\n        return errcode;\n\n    return 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142162,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n {\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n \tstruct sock *sk = sock->sk;\n\tint chan = sa->rc_channel;\n\tint err = 0;\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->rc_bdaddr);\n \n \tif (!addr || addr->sa_family != AF_BLUETOOTH)\n \t\treturn -EINVAL;\n \n \tlock_sock(sk);\n \n \tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n \n \twrite_lock(&rfcomm_sk_list.lock);\n \n\tif (chan && __rfcomm_get_listen_sock_by_addr(chan, &sa->rc_bdaddr)) {\n \t\terr = -EADDRINUSE;\n \t} else {\n \t\t/* Save source address */\n\t\tbacpy(&rfcomm_pi(sk)->src, &sa->rc_bdaddr);\n\t\trfcomm_pi(sk)->channel = chan;\n \t\tsk->sk_state = BT_BOUND;\n \t}\n \n\twrite_unlock(&rfcomm_sk_list.lock);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142203,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n {\n\tstruct sockaddr_rc sa;\n \tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n \n \tif (!addr || addr->sa_family != AF_BLUETOOTH)\n \t\treturn -EINVAL;\n \n\tmemset(&sa, 0, sizeof(sa));\n\tlen = min_t(unsigned int, sizeof(sa), addr_len);\n\tmemcpy(&sa, addr, len);\n\n\tBT_DBG(\"sk %p %pMR\", sk, &sa.rc_bdaddr);\n\n \tlock_sock(sk);\n \n \tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n \n \twrite_lock(&rfcomm_sk_list.lock);\n \n\tif (sa.rc_channel &&\n\t    __rfcomm_get_listen_sock_by_addr(sa.rc_channel, &sa.rc_bdaddr)) {\n \t\terr = -EADDRINUSE;\n \t} else {\n \t\t/* Save source address */\n\t\tbacpy(&rfcomm_pi(sk)->src, &sa.rc_bdaddr);\n\t\trfcomm_pi(sk)->channel = sa.rc_channel;\n \t\tsk->sk_state = BT_BOUND;\n \t}\n \n\twrite_unlock(&rfcomm_sk_list.lock);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142204,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "on_unregister_handler(TCMUService1HandlerManager1 *interface,\n\t\t      GDBusMethodInvocation *invocation,\n\t\t      gchar *subtype,\n\t\t      gpointer user_data)\n{\n\tstruct tcmur_handler *handler = find_handler_by_subtype(subtype);\n\tstruct dbus_info *info = handler ? handler->opaque : NULL;\n\n\tif (!handler) {\n\t\tg_dbus_method_invocation_return_value(invocation,\n\t\t\tg_variant_new(\"(bs)\", FALSE,\n \t\t\t\t      \"unknown subtype\"));\n \t\treturn TRUE;\n \t}\n \tdbus_unexport_handler(handler);\n\ttcmur_unregister_handler(handler);\n \tg_bus_unwatch_name(info->watcher_id);\n \tg_free(info);\n \tg_free(handler);\n\tg_dbus_method_invocation_return_value(invocation,\n\t\tg_variant_new(\"(bs)\", TRUE, \"succeeded\"));\n\treturn TRUE;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142253,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "on_unregister_handler(TCMUService1HandlerManager1 *interface,\n\t\t      GDBusMethodInvocation *invocation,\n\t\t      gchar *subtype,\n\t\t      gpointer user_data)\n{\n\tstruct tcmur_handler *handler = find_handler_by_subtype(subtype);\n\tstruct dbus_info *info = handler ? handler->opaque : NULL;\n\n\tif (!handler) {\n\t\tg_dbus_method_invocation_return_value(invocation,\n\t\t\tg_variant_new(\"(bs)\", FALSE,\n \t\t\t\t      \"unknown subtype\"));\n \t\treturn TRUE;\n \t}\n\telse if (handler->_is_dbus_handler != 1) {\n\t\tg_dbus_method_invocation_return_value(invocation,\n\t\t\tg_variant_new(\"(bs)\", FALSE,\n\t\t\t\t      \"cannot unregister internal handler\"));\n\t\treturn TRUE;\n\t}\n\n \tdbus_unexport_handler(handler);\n\ttcmur_unregister_dbus_handler(handler);\n\n \tg_bus_unwatch_name(info->watcher_id);\n \tg_free(info);\n \tg_free(handler);\n\tg_dbus_method_invocation_return_value(invocation,\n\t\tg_variant_new(\"(bs)\", TRUE, \"succeeded\"));\n\treturn TRUE;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142254,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "_kdc_as_rep(kdc_request_t r,\n\t    krb5_data *reply,\n\t    const char *from,\n\t    struct sockaddr *from_addr,\n\t    int datagram_reply)\n{\n    krb5_context context = r->context;\n    krb5_kdc_configuration *config = r->config;\n    KDC_REQ *req = &r->req;\n    KDC_REQ_BODY *b = NULL;\n    AS_REP rep;\n    KDCOptions f;\n    krb5_enctype setype;\n    krb5_error_code ret = 0;\n    Key *skey;\n    int found_pa = 0;\n    int i, flags = HDB_F_FOR_AS_REQ;\n    METHOD_DATA error_method;\n    const PA_DATA *pa;\n\n    memset(&rep, 0, sizeof(rep));\n    error_method.len = 0;\n    error_method.val = NULL;\n\n    /*\n     * Look for FAST armor and unwrap\n     */\n    ret = _kdc_fast_unwrap_request(r);\n    if (ret) {\n\t_kdc_r_log(r, 0, \"FAST unwrap request from %s failed: %d\", from, ret);\n\tgoto out;\n    }\n\n    b = &req->req_body;\n    f = b->kdc_options;\n\n    if (f.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->sname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \"No server in request\");\n    } else{\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->server_princ,\n\t\t\t\t\t\t  *(b->sname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret == 0)\n\t    ret = krb5_unparse_name(context, r->server_princ, &r->server_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"AS-REQ malformed server name from %s\", from);\n\tgoto out;\n    }\n    if(b->cname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \"No client in request\");\n    } else {\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->client_princ,\n\t\t\t\t\t\t  *(b->cname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, r->client_princ, &r->client_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"AS-REQ malformed client name from %s\", from);\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \"AS-REQ %s from %s for %s\",\n\t    r->client_name, from, r->server_name);\n\n    /*\n     *\n     */\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tif (!_kdc_is_anon_request(b)) {\n\t    kdc_log(context, config, 0, \"Anonymous ticket w/o anonymous flag\");\n\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    goto out;\n\t}\n    } else if (_kdc_is_anon_request(b)) {\n\tkdc_log(context, config, 0,\n\t\t\"Request for a anonymous ticket with non \"\n\t\t\"anonymous client name: %s\", r->client_name);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_db_fetch(context, config, r->client_princ,\n\t\t\tHDB_F_GET_CLIENT | flags, NULL,\n\t\t\t&r->clientdb, &r->client);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"client %s does not have secrets at this KDC, need to proxy\",\n\t\tr->client_name);\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n\tchar *fixed_client_name = NULL;\n\n\tret = krb5_unparse_name(context, r->client->entry.principal,\n\t\t\t\t&fixed_client_name);\n\tif (ret) {\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"WRONG_REALM - %s -> %s\",\n\t\tr->client_name, fixed_client_name);\n\tfree(fixed_client_name);\n\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t KRB5_KDC_ERR_WRONG_REALM,\n\t\t\t\t NULL,\n\t\t\t\t r->server_princ,\n\t\t\t\t NULL,\n\t\t\t\t &r->client->entry.principal->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->client_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n    ret = _kdc_db_fetch(context, config, r->server_princ,\n\t\t\tHDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,\n\t\t\tNULL, NULL, &r->server);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\",\n\t\tr->server_name);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->server_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     * Select a session enctype from the list of the crypto system\n     * supported enctypes that is supported by the client and is one of\n     * the enctype of the enctype of the service (likely krbtgt).\n     *\n     * The latter is used as a hint of what enctypes all KDC support,\n     * to make sure a newer version of KDC won't generate a session\n     * enctype that an older version of a KDC in the same realm can't\n     * decrypt.\n     */\n\n    ret = _kdc_find_etype(context,\n\t\t\t  krb5_principal_is_krbtgt(context, r->server_princ) ?\n\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t  r->client, b->etype.val, b->etype.len, &r->sessionetype,\n\t\t\t  NULL);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"Client (%s) from %s has no common enctypes with KDC \"\n\t\t\"to use for the session key\",\n\t\tr->client_name, from);\n\tgoto out;\n    }\n\n    /*\n     * Pre-auth processing\n     */\n\n    if(req->padata){\n\tunsigned int n;\n\n\tlog_patypes(context, config, req->padata);\n\n\t/* Check if preauth matching */\n\n\tfor (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if (pat[n].validate == NULL)\n\t\tcontinue;\n\t    if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))\n\t\tcontinue;\n\n\t    kdc_log(context, config, 5,\n\t\t    \"Looking for %s pa-data -- %s\", pat[n].name, r->client_name);\n\t    i = 0;\n\t    pa = _kdc_find_padata(req, &i, pat[n].type);\n\t    if (pa) {\n\t\tret = pat[n].validate(r, pa);\n\t\tif (ret != 0) {\n\t\t    goto out;\n\t\t}\n\t\tkdc_log(context, config, 0,\n\t\t\t\"%s pre-authentication succeeded -- %s\",\n\t\t\tpat[n].name, r->client_name);\n\t\tfound_pa = 1;\n\t\tr->et.flags.pre_authent = 1;\n\t    }\n\t}\n    }\n\n    if (found_pa == 0) {\n\tKey *ckey = NULL;\n\tsize_t n;\n\n\tfor (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if ((pat[n].flags & PA_ANNOUNCE) == 0)\n\t\tcontinue;\n\t    ret = krb5_padata_add(context, &error_method,\n\t\t\t\t  pat[n].type, NULL, 0);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is a client key, send ETYPE_INFO{,2}\n\t */\n\tret = _kdc_find_etype(context,\n\t\t\t      config->preauth_use_strongest_session_key, TRUE,\n\t\t\t      r->client, b->etype.val, b->etype.len, NULL, &ckey);\n\tif (ret == 0) {\n\n\t    /*\n\t     * RFC4120 requires:\n\t     * - If the client only knows about old enctypes, then send\n\t     *   both info replies (we send 'info' first in the list).\n\t     * - If the client is 'modern', because it knows about 'new'\n\t     *   enctype types, then only send the 'info2' reply.\n\t     *\n\t     * Before we send the full list of etype-info data, we pick\n\t     * the client key we would have used anyway below, just pick\n\t     * that instead.\n\t     */\n\n\t    if (older_enctype(ckey->key.keytype)) {\n\t\tret = get_pa_etype_info(context, config,\n\t\t\t\t\t&error_method, ckey);\n\t\tif (ret)\n\t\t    goto out;\n\t    }\n\t    ret = get_pa_etype_info2(context, config,\n\t\t\t\t     &error_method, ckey);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/* \n\t * send requre preauth is its required or anon is requested,\n\t * anon is today only allowed via preauth mechanisms.\n\t */\n\tif (require_preauth_p(r) || _kdc_is_anon_request(b)) {\n\t    ret = KRB5KDC_ERR_PREAUTH_REQUIRED;\n\t    _kdc_set_e_text(r, \"Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ\");\n\t    goto out;\n\t}\n\n\tif (ckey == NULL) {\n\t    ret = KRB5KDC_ERR_CLIENT_NOTYET;\n\t    _kdc_set_e_text(r, \"Doesn't have a client key available\");\n\t    goto out;\n\t}\n\tkrb5_free_keyblock_contents(r->context,  &r->reply_key);\n\tret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->clientdb->hdb_auth_status) {\n\tr->clientdb->hdb_auth_status(context, r->clientdb, r->client, \n\t\t\t\t     HDB_AUTH_SUCCESS);\n    }\n\n    /*\n     * Verify flags after the user been required to prove its identity\n     * with in a preauth mech.\n     */\n\n    ret = _kdc_check_access(context, config, r->client, r->client_name,\n\t\t\t    r->server, r->server_name,\n\t\t\t    req, &error_method);\n    if(ret)\n\tgoto out;\n\n    /*\n     * Select the best encryption type for the KDC with out regard to\n     * the client since the client never needs to read that data.\n     */\n\n    ret = _kdc_get_preferred_key(context, config,\n\t\t\t\t r->server, r->server_name,\n\t\t\t\t &setype, &skey);\n    if(ret)\n\tgoto out;\n\n    if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey\n       || (_kdc_is_anon_request(b) && !config->allow_anonymous)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\t_kdc_set_e_text(r, \"Bad KDC options\");\n\tgoto out;\n    }\n\n    /*\n     * Build reply\n     */\n\n    rep.pvno = 5;\n    rep.msg_type = krb_as_rep;\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tRealm anon_realm=KRB5_ANON_REALM;\n\tret = copy_Realm(&anon_realm, &rep.crealm);\n    } else\n\tret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);\n    if (ret)\n\tgoto out;\n    ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);\n    if (ret)\n\tgoto out;\n\n    rep.ticket.tkt_vno = 5;\n    ret = copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);\n    if (ret)\n\tgoto out;\n    _krb5_principal2principalname(&rep.ticket.sname,\n\t\t\t\t  r->server->entry.principal);\n    /* java 1.6 expects the name to be the same type, lets allow that\n     * uncomplicated name-types. */\n#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)\n    if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))\n\trep.ticket.sname.name_type = b->sname->name_type;\n#undef CNT\n\n    r->et.flags.initial = 1;\n    if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)\n\tr->et.flags.forwardable = f.forwardable;\n    else if (f.forwardable) {\n\t_kdc_set_e_text(r, \"Ticket may not be forwardable\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)\n\tr->et.flags.proxiable = f.proxiable;\n    else if (f.proxiable) {\n\t_kdc_set_e_text(r, \"Ticket may not be proxiable\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)\n\tr->et.flags.may_postdate = f.allow_postdate;\n    else if (f.allow_postdate){\n\t_kdc_set_e_text(r, \"Ticket may not be postdate\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {\n\t_kdc_set_e_text(r, \"Bad address list in requested\");\n\tret = KRB5KRB_AP_ERR_BADADDR;\n\tgoto out;\n    }\n\n    ret = copy_PrincipalName(&rep.cname, &r->et.cname);\n    if (ret)\n\tgoto out;\n    ret = copy_Realm(&rep.crealm, &r->et.crealm);\n    if (ret)\n\tgoto out;\n\n    {\n\ttime_t start;\n\ttime_t t;\n\t\n\tstart = r->et.authtime = kdc_time;\n\n\tif(f.postdated && req->req_body.from){\n\t    ALLOC(r->et.starttime);\n\t    start = *r->et.starttime = *req->req_body.from;\n\t    r->et.flags.invalid = 1;\n\t    r->et.flags.postdated = 1; /* XXX ??? */\n\t}\n\t_kdc_fix_time(&b->till);\n\tt = *b->till;\n\n\t/* be careful not overflowing */\n\n\tif(r->client->entry.max_life)\n\t    t = start + min(t - start, *r->client->entry.max_life);\n\tif(r->server->entry.max_life)\n\t    t = start + min(t - start, *r->server->entry.max_life);\n#if 0\n\tt = min(t, start + realm->max_life);\n#endif\n\tr->et.endtime = t;\n\tif(f.renewable_ok && r->et.endtime < *b->till){\n\t    f.renewable = 1;\n\t    if(b->rtime == NULL){\n\t\tALLOC(b->rtime);\n\t\t*b->rtime = 0;\n\t    }\n\t    if(*b->rtime < *b->till)\n\t\t*b->rtime = *b->till;\n\t}\n\tif(f.renewable && b->rtime){\n\t    t = *b->rtime;\n\t    if(t == 0)\n\t\tt = MAX_TIME;\n\t    if(r->client->entry.max_renew)\n\t\tt = start + min(t - start, *r->client->entry.max_renew);\n\t    if(r->server->entry.max_renew)\n\t\tt = start + min(t - start, *r->server->entry.max_renew);\n#if 0\n\t    t = min(t, start + realm->max_renew);\n#endif\n\t    ALLOC(r->et.renew_till);\n\t    *r->et.renew_till = t;\n\t    r->et.flags.renewable = 1;\n\t}\n    }\n\n    if (_kdc_is_anon_request(b))\n\tr->et.flags.anonymous = 1;\n\n    if(b->addresses){\n\tALLOC(r->et.caddr);\n\tcopy_HostAddresses(b->addresses, r->et.caddr);\n    }\n\n    r->et.transited.tr_type = DOMAIN_X500_COMPRESS;\n    krb5_data_zero(&r->et.transited.contents);\n\n    /* The MIT ASN.1 library (obviously) doesn't tell lengths encoded\n     * as 0 and as 0x80 (meaning indefinite length) apart, and is thus\n     * incapable of correctly decoding SEQUENCE OF's of zero length.\n     *\n     * To fix this, always send at least one no-op last_req\n     *\n     * If there's a pw_end or valid_end we will use that,\n     * otherwise just a dummy lr.\n     */\n    r->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));\n    if (r->ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    r->ek.last_req.len = 0;\n    if (r->client->entry.pw_end\n\t&& (config->kdc_warn_pwexpire == 0\n\t    || kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->client->entry.valid_end) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->ek.last_req.len == 0) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = 0;\n\t++r->ek.last_req.len;\n    }\n    r->ek.nonce = b->nonce;\n    if (r->client->entry.valid_end || r->client->entry.pw_end) {\n\tALLOC(r->ek.key_expiration);\n\tif (r->client->entry.valid_end) {\n\t    if (r->client->entry.pw_end)\n\t\t*r->ek.key_expiration = min(*r->client->entry.valid_end,\n\t\t\t\t\t *r->client->entry.pw_end);\n\t    else\n\t\t*r->ek.key_expiration = *r->client->entry.valid_end;\n\t} else\n\t    *r->ek.key_expiration = *r->client->entry.pw_end;\n    } else\n\tr->ek.key_expiration = NULL;\n    r->ek.flags = r->et.flags;\n    r->ek.authtime = r->et.authtime;\n    if (r->et.starttime) {\n\tALLOC(r->ek.starttime);\n\t*r->ek.starttime = *r->et.starttime;\n    }\n    r->ek.endtime = r->et.endtime;\n    if (r->et.renew_till) {\n\tALLOC(r->ek.renew_till);\n\t*r->ek.renew_till = *r->et.renew_till;\n    }\n    ret = copy_Realm(&rep.ticket.realm, &r->ek.srealm);\n    if (ret)\n\tgoto out;\n    ret = copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);\n    if (ret)\n\tgoto out;\n    if(r->et.caddr){\n\tALLOC(r->ek.caddr);\n\tcopy_HostAddresses(r->et.caddr, r->ek.caddr);\n    }\n\n    /*\n     * Check and session and reply keys\n     */\n\n    if (r->session_key.keytype == ETYPE_NULL) {\n\tret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->reply_key.keytype == ETYPE_NULL) {\n\t_kdc_set_e_text(r, \"Client have no reply key\");\n\tret = KRB5KDC_ERR_CLIENT_NOTYET;\n\tgoto out;\n    }\n\n    ret = copy_EncryptionKey(&r->session_key, &r->et.key);\n    if (ret)\n\tgoto out;\n\n    ret = copy_EncryptionKey(&r->session_key, &r->ek.key);\n    if (ret)\n\tgoto out;\n\n    if (r->outpadata.len) {\n\n\tALLOC(rep.padata);\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(&r->outpadata, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    /* Add the PAC */\n    if (send_pac_p(context, req)) {\n\tgenerate_pac(r, skey);\n    }\n\n    _kdc_log_timestamp(context, config, \"AS-REQ\", r->et.authtime, r->et.starttime,\n\t\t       r->et.endtime, r->et.renew_till);\n\n    /* do this as the last thing since this signs the EncTicketPart */\n    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t  config,\n\t\t\t\t  r->server,\n\t\t\t\t  setype,\n\t\t\t\t  r->client->entry.principal,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  &r->et);\n    if (ret)\n\tgoto out;\n\n    log_as_req(context, config, r->reply_key.keytype, setype, b);\n\n    /*\n     * We always say we support FAST/enc-pa-rep\n     */\n\n    r->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;\n\n    /*\n     * Add REQ_ENC_PA_REP if client supports it\n     */\n\n    i = 0;\n    pa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);\n    if (pa) {\n\n\tret = add_enc_pa_rep(r);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(r->context, ret);\n\t    _kdc_r_log(r, 0, \"add_enc_pa_rep failed: %s: %d\", msg, ret);\n\t    krb5_free_error_message(r->context, msg);\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_encode_reply(context, config,\n\t\t\t    r->armor_crypto, req->req_body.nonce,\n\t\t\t    &rep, &r->et, &r->ek, setype, r->server->entry.kvno,\n\t\t\t    &skey->key, r->client->entry.kvno,\n\t\t\t    &r->reply_key, 0, &r->e_text, reply);\n    if (ret)\n\tgoto out;\n\n    /*\n     * Check if message too large\n     */\n    if (datagram_reply && reply->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(reply);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\t_kdc_set_e_text(r, \"Reply packet too large\");\n    }\n\nout:\n    free_AS_REP(&rep);\n\n     /*\n      * In case of a non proxy error, build an error message.\n      */\n    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n \tret = _kdc_fast_mk_error(context, r,\n \t\t\t\t &error_method,\n \t\t\t\t r->armor_crypto,\n \t\t\t\t &req->req_body,\n \t\t\t\t ret, r->e_text,\n \t\t\t\t r->server_princ,\n\t\t\t\t &r->client_princ->name,\n\t\t\t\t &r->client_princ->realm,\n \t\t\t\t NULL, NULL,\n \t\t\t\t reply);\n \tif (ret)\n\t    goto out2;\n    }\nout2:\n    free_EncTicketPart(&r->et);\n    free_EncKDCRepPart(&r->ek);\n    free_KDCFastState(&r->fast);\n\n    if (error_method.len)\n\tfree_METHOD_DATA(&error_method);\n    if (r->outpadata.len)\n\tfree_METHOD_DATA(&r->outpadata);\n    if (r->client_princ) {\n\tkrb5_free_principal(context, r->client_princ);\n\tr->client_princ = NULL;\n    }\n    if (r->client_name) {\n\tfree(r->client_name);\n\tr->client_name = NULL;\n    }\n    if (r->server_princ){\n\tkrb5_free_principal(context, r->server_princ);\n\tr->server_princ = NULL;\n    }\n    if (r->server_name) {\n\tfree(r->server_name);\n\tr->server_name = NULL;\n    }\n    if (r->client)\n\t_kdc_free_ent(context, r->client);\n    if (r->server)\n\t_kdc_free_ent(context, r->server);\n    if (r->armor_crypto) {\n\tkrb5_crypto_destroy(r->context, r->armor_crypto);\n\tr->armor_crypto = NULL;\n    }\n    krb5_free_keyblock_contents(r->context, &r->reply_key);\n    krb5_free_keyblock_contents(r->context, &r->session_key);\n    return ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142267,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "_kdc_as_rep(kdc_request_t r,\n\t    krb5_data *reply,\n\t    const char *from,\n\t    struct sockaddr *from_addr,\n\t    int datagram_reply)\n{\n    krb5_context context = r->context;\n    krb5_kdc_configuration *config = r->config;\n    KDC_REQ *req = &r->req;\n    KDC_REQ_BODY *b = NULL;\n    AS_REP rep;\n    KDCOptions f;\n    krb5_enctype setype;\n    krb5_error_code ret = 0;\n    Key *skey;\n    int found_pa = 0;\n    int i, flags = HDB_F_FOR_AS_REQ;\n    METHOD_DATA error_method;\n    const PA_DATA *pa;\n\n    memset(&rep, 0, sizeof(rep));\n    error_method.len = 0;\n    error_method.val = NULL;\n\n    /*\n     * Look for FAST armor and unwrap\n     */\n    ret = _kdc_fast_unwrap_request(r);\n    if (ret) {\n\t_kdc_r_log(r, 0, \"FAST unwrap request from %s failed: %d\", from, ret);\n\tgoto out;\n    }\n\n    b = &req->req_body;\n    f = b->kdc_options;\n\n    if (f.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->sname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \"No server in request\");\n    } else{\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->server_princ,\n\t\t\t\t\t\t  *(b->sname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret == 0)\n\t    ret = krb5_unparse_name(context, r->server_princ, &r->server_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"AS-REQ malformed server name from %s\", from);\n\tgoto out;\n    }\n    if(b->cname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \"No client in request\");\n    } else {\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->client_princ,\n\t\t\t\t\t\t  *(b->cname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, r->client_princ, &r->client_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"AS-REQ malformed client name from %s\", from);\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \"AS-REQ %s from %s for %s\",\n\t    r->client_name, from, r->server_name);\n\n    /*\n     *\n     */\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tif (!_kdc_is_anon_request(b)) {\n\t    kdc_log(context, config, 0, \"Anonymous ticket w/o anonymous flag\");\n\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    goto out;\n\t}\n    } else if (_kdc_is_anon_request(b)) {\n\tkdc_log(context, config, 0,\n\t\t\"Request for a anonymous ticket with non \"\n\t\t\"anonymous client name: %s\", r->client_name);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_db_fetch(context, config, r->client_princ,\n\t\t\tHDB_F_GET_CLIENT | flags, NULL,\n\t\t\t&r->clientdb, &r->client);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"client %s does not have secrets at this KDC, need to proxy\",\n\t\tr->client_name);\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n\tchar *fixed_client_name = NULL;\n\n\tret = krb5_unparse_name(context, r->client->entry.principal,\n\t\t\t\t&fixed_client_name);\n\tif (ret) {\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"WRONG_REALM - %s -> %s\",\n\t\tr->client_name, fixed_client_name);\n\tfree(fixed_client_name);\n\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t KRB5_KDC_ERR_WRONG_REALM,\n\t\t\t\t NULL,\n\t\t\t\t r->server_princ,\n\t\t\t\t NULL,\n\t\t\t\t &r->client->entry.principal->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->client_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n    ret = _kdc_db_fetch(context, config, r->server_princ,\n\t\t\tHDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,\n\t\t\tNULL, NULL, &r->server);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\",\n\t\tr->server_name);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->server_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     * Select a session enctype from the list of the crypto system\n     * supported enctypes that is supported by the client and is one of\n     * the enctype of the enctype of the service (likely krbtgt).\n     *\n     * The latter is used as a hint of what enctypes all KDC support,\n     * to make sure a newer version of KDC won't generate a session\n     * enctype that an older version of a KDC in the same realm can't\n     * decrypt.\n     */\n\n    ret = _kdc_find_etype(context,\n\t\t\t  krb5_principal_is_krbtgt(context, r->server_princ) ?\n\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t  r->client, b->etype.val, b->etype.len, &r->sessionetype,\n\t\t\t  NULL);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"Client (%s) from %s has no common enctypes with KDC \"\n\t\t\"to use for the session key\",\n\t\tr->client_name, from);\n\tgoto out;\n    }\n\n    /*\n     * Pre-auth processing\n     */\n\n    if(req->padata){\n\tunsigned int n;\n\n\tlog_patypes(context, config, req->padata);\n\n\t/* Check if preauth matching */\n\n\tfor (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if (pat[n].validate == NULL)\n\t\tcontinue;\n\t    if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))\n\t\tcontinue;\n\n\t    kdc_log(context, config, 5,\n\t\t    \"Looking for %s pa-data -- %s\", pat[n].name, r->client_name);\n\t    i = 0;\n\t    pa = _kdc_find_padata(req, &i, pat[n].type);\n\t    if (pa) {\n\t\tret = pat[n].validate(r, pa);\n\t\tif (ret != 0) {\n\t\t    goto out;\n\t\t}\n\t\tkdc_log(context, config, 0,\n\t\t\t\"%s pre-authentication succeeded -- %s\",\n\t\t\tpat[n].name, r->client_name);\n\t\tfound_pa = 1;\n\t\tr->et.flags.pre_authent = 1;\n\t    }\n\t}\n    }\n\n    if (found_pa == 0) {\n\tKey *ckey = NULL;\n\tsize_t n;\n\n\tfor (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if ((pat[n].flags & PA_ANNOUNCE) == 0)\n\t\tcontinue;\n\t    ret = krb5_padata_add(context, &error_method,\n\t\t\t\t  pat[n].type, NULL, 0);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is a client key, send ETYPE_INFO{,2}\n\t */\n\tret = _kdc_find_etype(context,\n\t\t\t      config->preauth_use_strongest_session_key, TRUE,\n\t\t\t      r->client, b->etype.val, b->etype.len, NULL, &ckey);\n\tif (ret == 0) {\n\n\t    /*\n\t     * RFC4120 requires:\n\t     * - If the client only knows about old enctypes, then send\n\t     *   both info replies (we send 'info' first in the list).\n\t     * - If the client is 'modern', because it knows about 'new'\n\t     *   enctype types, then only send the 'info2' reply.\n\t     *\n\t     * Before we send the full list of etype-info data, we pick\n\t     * the client key we would have used anyway below, just pick\n\t     * that instead.\n\t     */\n\n\t    if (older_enctype(ckey->key.keytype)) {\n\t\tret = get_pa_etype_info(context, config,\n\t\t\t\t\t&error_method, ckey);\n\t\tif (ret)\n\t\t    goto out;\n\t    }\n\t    ret = get_pa_etype_info2(context, config,\n\t\t\t\t     &error_method, ckey);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/* \n\t * send requre preauth is its required or anon is requested,\n\t * anon is today only allowed via preauth mechanisms.\n\t */\n\tif (require_preauth_p(r) || _kdc_is_anon_request(b)) {\n\t    ret = KRB5KDC_ERR_PREAUTH_REQUIRED;\n\t    _kdc_set_e_text(r, \"Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ\");\n\t    goto out;\n\t}\n\n\tif (ckey == NULL) {\n\t    ret = KRB5KDC_ERR_CLIENT_NOTYET;\n\t    _kdc_set_e_text(r, \"Doesn't have a client key available\");\n\t    goto out;\n\t}\n\tkrb5_free_keyblock_contents(r->context,  &r->reply_key);\n\tret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->clientdb->hdb_auth_status) {\n\tr->clientdb->hdb_auth_status(context, r->clientdb, r->client, \n\t\t\t\t     HDB_AUTH_SUCCESS);\n    }\n\n    /*\n     * Verify flags after the user been required to prove its identity\n     * with in a preauth mech.\n     */\n\n    ret = _kdc_check_access(context, config, r->client, r->client_name,\n\t\t\t    r->server, r->server_name,\n\t\t\t    req, &error_method);\n    if(ret)\n\tgoto out;\n\n    /*\n     * Select the best encryption type for the KDC with out regard to\n     * the client since the client never needs to read that data.\n     */\n\n    ret = _kdc_get_preferred_key(context, config,\n\t\t\t\t r->server, r->server_name,\n\t\t\t\t &setype, &skey);\n    if(ret)\n\tgoto out;\n\n    if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey\n       || (_kdc_is_anon_request(b) && !config->allow_anonymous)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\t_kdc_set_e_text(r, \"Bad KDC options\");\n\tgoto out;\n    }\n\n    /*\n     * Build reply\n     */\n\n    rep.pvno = 5;\n    rep.msg_type = krb_as_rep;\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tRealm anon_realm=KRB5_ANON_REALM;\n\tret = copy_Realm(&anon_realm, &rep.crealm);\n    } else\n\tret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);\n    if (ret)\n\tgoto out;\n    ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);\n    if (ret)\n\tgoto out;\n\n    rep.ticket.tkt_vno = 5;\n    ret = copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);\n    if (ret)\n\tgoto out;\n    _krb5_principal2principalname(&rep.ticket.sname,\n\t\t\t\t  r->server->entry.principal);\n    /* java 1.6 expects the name to be the same type, lets allow that\n     * uncomplicated name-types. */\n#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)\n    if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))\n\trep.ticket.sname.name_type = b->sname->name_type;\n#undef CNT\n\n    r->et.flags.initial = 1;\n    if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)\n\tr->et.flags.forwardable = f.forwardable;\n    else if (f.forwardable) {\n\t_kdc_set_e_text(r, \"Ticket may not be forwardable\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)\n\tr->et.flags.proxiable = f.proxiable;\n    else if (f.proxiable) {\n\t_kdc_set_e_text(r, \"Ticket may not be proxiable\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)\n\tr->et.flags.may_postdate = f.allow_postdate;\n    else if (f.allow_postdate){\n\t_kdc_set_e_text(r, \"Ticket may not be postdate\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {\n\t_kdc_set_e_text(r, \"Bad address list in requested\");\n\tret = KRB5KRB_AP_ERR_BADADDR;\n\tgoto out;\n    }\n\n    ret = copy_PrincipalName(&rep.cname, &r->et.cname);\n    if (ret)\n\tgoto out;\n    ret = copy_Realm(&rep.crealm, &r->et.crealm);\n    if (ret)\n\tgoto out;\n\n    {\n\ttime_t start;\n\ttime_t t;\n\t\n\tstart = r->et.authtime = kdc_time;\n\n\tif(f.postdated && req->req_body.from){\n\t    ALLOC(r->et.starttime);\n\t    start = *r->et.starttime = *req->req_body.from;\n\t    r->et.flags.invalid = 1;\n\t    r->et.flags.postdated = 1; /* XXX ??? */\n\t}\n\t_kdc_fix_time(&b->till);\n\tt = *b->till;\n\n\t/* be careful not overflowing */\n\n\tif(r->client->entry.max_life)\n\t    t = start + min(t - start, *r->client->entry.max_life);\n\tif(r->server->entry.max_life)\n\t    t = start + min(t - start, *r->server->entry.max_life);\n#if 0\n\tt = min(t, start + realm->max_life);\n#endif\n\tr->et.endtime = t;\n\tif(f.renewable_ok && r->et.endtime < *b->till){\n\t    f.renewable = 1;\n\t    if(b->rtime == NULL){\n\t\tALLOC(b->rtime);\n\t\t*b->rtime = 0;\n\t    }\n\t    if(*b->rtime < *b->till)\n\t\t*b->rtime = *b->till;\n\t}\n\tif(f.renewable && b->rtime){\n\t    t = *b->rtime;\n\t    if(t == 0)\n\t\tt = MAX_TIME;\n\t    if(r->client->entry.max_renew)\n\t\tt = start + min(t - start, *r->client->entry.max_renew);\n\t    if(r->server->entry.max_renew)\n\t\tt = start + min(t - start, *r->server->entry.max_renew);\n#if 0\n\t    t = min(t, start + realm->max_renew);\n#endif\n\t    ALLOC(r->et.renew_till);\n\t    *r->et.renew_till = t;\n\t    r->et.flags.renewable = 1;\n\t}\n    }\n\n    if (_kdc_is_anon_request(b))\n\tr->et.flags.anonymous = 1;\n\n    if(b->addresses){\n\tALLOC(r->et.caddr);\n\tcopy_HostAddresses(b->addresses, r->et.caddr);\n    }\n\n    r->et.transited.tr_type = DOMAIN_X500_COMPRESS;\n    krb5_data_zero(&r->et.transited.contents);\n\n    /* The MIT ASN.1 library (obviously) doesn't tell lengths encoded\n     * as 0 and as 0x80 (meaning indefinite length) apart, and is thus\n     * incapable of correctly decoding SEQUENCE OF's of zero length.\n     *\n     * To fix this, always send at least one no-op last_req\n     *\n     * If there's a pw_end or valid_end we will use that,\n     * otherwise just a dummy lr.\n     */\n    r->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));\n    if (r->ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    r->ek.last_req.len = 0;\n    if (r->client->entry.pw_end\n\t&& (config->kdc_warn_pwexpire == 0\n\t    || kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->client->entry.valid_end) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->ek.last_req.len == 0) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = 0;\n\t++r->ek.last_req.len;\n    }\n    r->ek.nonce = b->nonce;\n    if (r->client->entry.valid_end || r->client->entry.pw_end) {\n\tALLOC(r->ek.key_expiration);\n\tif (r->client->entry.valid_end) {\n\t    if (r->client->entry.pw_end)\n\t\t*r->ek.key_expiration = min(*r->client->entry.valid_end,\n\t\t\t\t\t *r->client->entry.pw_end);\n\t    else\n\t\t*r->ek.key_expiration = *r->client->entry.valid_end;\n\t} else\n\t    *r->ek.key_expiration = *r->client->entry.pw_end;\n    } else\n\tr->ek.key_expiration = NULL;\n    r->ek.flags = r->et.flags;\n    r->ek.authtime = r->et.authtime;\n    if (r->et.starttime) {\n\tALLOC(r->ek.starttime);\n\t*r->ek.starttime = *r->et.starttime;\n    }\n    r->ek.endtime = r->et.endtime;\n    if (r->et.renew_till) {\n\tALLOC(r->ek.renew_till);\n\t*r->ek.renew_till = *r->et.renew_till;\n    }\n    ret = copy_Realm(&rep.ticket.realm, &r->ek.srealm);\n    if (ret)\n\tgoto out;\n    ret = copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);\n    if (ret)\n\tgoto out;\n    if(r->et.caddr){\n\tALLOC(r->ek.caddr);\n\tcopy_HostAddresses(r->et.caddr, r->ek.caddr);\n    }\n\n    /*\n     * Check and session and reply keys\n     */\n\n    if (r->session_key.keytype == ETYPE_NULL) {\n\tret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->reply_key.keytype == ETYPE_NULL) {\n\t_kdc_set_e_text(r, \"Client have no reply key\");\n\tret = KRB5KDC_ERR_CLIENT_NOTYET;\n\tgoto out;\n    }\n\n    ret = copy_EncryptionKey(&r->session_key, &r->et.key);\n    if (ret)\n\tgoto out;\n\n    ret = copy_EncryptionKey(&r->session_key, &r->ek.key);\n    if (ret)\n\tgoto out;\n\n    if (r->outpadata.len) {\n\n\tALLOC(rep.padata);\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(&r->outpadata, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    /* Add the PAC */\n    if (send_pac_p(context, req)) {\n\tgenerate_pac(r, skey);\n    }\n\n    _kdc_log_timestamp(context, config, \"AS-REQ\", r->et.authtime, r->et.starttime,\n\t\t       r->et.endtime, r->et.renew_till);\n\n    /* do this as the last thing since this signs the EncTicketPart */\n    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t  config,\n\t\t\t\t  r->server,\n\t\t\t\t  setype,\n\t\t\t\t  r->client->entry.principal,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  &r->et);\n    if (ret)\n\tgoto out;\n\n    log_as_req(context, config, r->reply_key.keytype, setype, b);\n\n    /*\n     * We always say we support FAST/enc-pa-rep\n     */\n\n    r->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;\n\n    /*\n     * Add REQ_ENC_PA_REP if client supports it\n     */\n\n    i = 0;\n    pa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);\n    if (pa) {\n\n\tret = add_enc_pa_rep(r);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(r->context, ret);\n\t    _kdc_r_log(r, 0, \"add_enc_pa_rep failed: %s: %d\", msg, ret);\n\t    krb5_free_error_message(r->context, msg);\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_encode_reply(context, config,\n\t\t\t    r->armor_crypto, req->req_body.nonce,\n\t\t\t    &rep, &r->et, &r->ek, setype, r->server->entry.kvno,\n\t\t\t    &skey->key, r->client->entry.kvno,\n\t\t\t    &r->reply_key, 0, &r->e_text, reply);\n    if (ret)\n\tgoto out;\n\n    /*\n     * Check if message too large\n     */\n    if (datagram_reply && reply->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(reply);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\t_kdc_set_e_text(r, \"Reply packet too large\");\n    }\n\nout:\n    free_AS_REP(&rep);\n\n     /*\n      * In case of a non proxy error, build an error message.\n      */\n    if (ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n \tret = _kdc_fast_mk_error(context, r,\n \t\t\t\t &error_method,\n \t\t\t\t r->armor_crypto,\n \t\t\t\t &req->req_body,\n \t\t\t\t ret, r->e_text,\n \t\t\t\t r->server_princ,\n\t\t\t\t r->client_princ ?\n                                     &r->client_princ->name : NULL,\n\t\t\t\t r->client_princ ?\n                                     &r->client_princ->realm : NULL,\n \t\t\t\t NULL, NULL,\n \t\t\t\t reply);\n \tif (ret)\n\t    goto out2;\n    }\nout2:\n    free_EncTicketPart(&r->et);\n    free_EncKDCRepPart(&r->ek);\n    free_KDCFastState(&r->fast);\n\n    if (error_method.len)\n\tfree_METHOD_DATA(&error_method);\n    if (r->outpadata.len)\n\tfree_METHOD_DATA(&r->outpadata);\n    if (r->client_princ) {\n\tkrb5_free_principal(context, r->client_princ);\n\tr->client_princ = NULL;\n    }\n    if (r->client_name) {\n\tfree(r->client_name);\n\tr->client_name = NULL;\n    }\n    if (r->server_princ){\n\tkrb5_free_principal(context, r->server_princ);\n\tr->server_princ = NULL;\n    }\n    if (r->server_name) {\n\tfree(r->server_name);\n\tr->server_name = NULL;\n    }\n    if (r->client)\n\t_kdc_free_ent(context, r->client);\n    if (r->server)\n\t_kdc_free_ent(context, r->server);\n    if (r->armor_crypto) {\n\tkrb5_crypto_destroy(r->context, r->armor_crypto);\n\tr->armor_crypto = NULL;\n    }\n    krb5_free_keyblock_contents(r->context, &r->reply_key);\n    krb5_free_keyblock_contents(r->context, &r->session_key);\n    return ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142268,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)\n{\n\tint r;\n\t/* Assume we're using HV mode when the HV module is loaded */\n\tint hv_enabled = kvmppc_hv_ops ? 1 : 0;\n\n\tif (kvm) {\n\t\t/*\n\t\t * Hooray - we know which VM type we're running on. Depend on\n\t\t * that rather than the guess above.\n\t\t */\n\t\thv_enabled = is_kvmppc_hv_enabled(kvm);\n\t}\n\n\tswitch (ext) {\n#ifdef CONFIG_BOOKE\n\tcase KVM_CAP_PPC_BOOKE_SREGS:\n\tcase KVM_CAP_PPC_BOOKE_WATCHDOG:\n\tcase KVM_CAP_PPC_EPR:\n#else\n\tcase KVM_CAP_PPC_SEGSTATE:\n\tcase KVM_CAP_PPC_HIOR:\n\tcase KVM_CAP_PPC_PAPR:\n#endif\n\tcase KVM_CAP_PPC_UNSET_IRQ:\n\tcase KVM_CAP_PPC_IRQ_LEVEL:\n\tcase KVM_CAP_ENABLE_CAP:\n\tcase KVM_CAP_ENABLE_CAP_VM:\n\tcase KVM_CAP_ONE_REG:\n\tcase KVM_CAP_IOEVENTFD:\n\tcase KVM_CAP_DEVICE_CTRL:\n\tcase KVM_CAP_IMMEDIATE_EXIT:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_PPC_PAIRED_SINGLES:\n\tcase KVM_CAP_PPC_OSI:\n\tcase KVM_CAP_PPC_GET_PVINFO:\n#if defined(CONFIG_KVM_E500V2) || defined(CONFIG_KVM_E500MC)\n\tcase KVM_CAP_SW_TLB:\n#endif\n\t\t/* We support this only for PR */\n\t\tr = !hv_enabled;\n\t\tbreak;\n#ifdef CONFIG_KVM_MPIC\n\tcase KVM_CAP_IRQ_MPIC:\n\t\tr = 1;\n\t\tbreak;\n#endif\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\tcase KVM_CAP_SPAPR_TCE:\n\tcase KVM_CAP_SPAPR_TCE_64:\n\t\t/* fallthrough */\n\tcase KVM_CAP_SPAPR_TCE_VFIO:\n\tcase KVM_CAP_PPC_RTAS:\n\tcase KVM_CAP_PPC_FIXUP_HCALL:\n\tcase KVM_CAP_PPC_ENABLE_HCALL:\n#ifdef CONFIG_KVM_XICS\n\tcase KVM_CAP_IRQ_XICS:\n#endif\n\t\tr = 1;\n\t\tbreak;\n\n\tcase KVM_CAP_PPC_ALLOC_HTAB:\n\t\tr = hv_enabled;\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3S_64 */\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_SMT:\n\t\tr = 0;\n\t\tif (kvm) {\n\t\t\tif (kvm->arch.emul_smt_mode > 1)\n\t\t\t\tr = kvm->arch.emul_smt_mode;\n\t\t\telse\n\t\t\t\tr = kvm->arch.smt_mode;\n\t\t} else if (hv_enabled) {\n\t\t\tif (cpu_has_feature(CPU_FTR_ARCH_300))\n\t\t\t\tr = 1;\n\t\t\telse\n\t\t\t\tr = threads_per_subcore;\n\t\t}\n\t\tbreak;\n\tcase KVM_CAP_PPC_SMT_POSSIBLE:\n\t\tr = 1;\n\t\tif (hv_enabled) {\n\t\t\tif (!cpu_has_feature(CPU_FTR_ARCH_300))\n\t\t\t\tr = ((threads_per_subcore << 1) - 1);\n\t\t\telse\n\t\t\t\t/* P9 can emulate dbells, so allow any mode */\n\t\t\t\tr = 8 | 4 | 2 | 1;\n\t\t}\n\t\tbreak;\n\tcase KVM_CAP_PPC_RMA:\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_PPC_HWRNG:\n\t\tr = kvmppc_hwrng_present();\n\t\tbreak;\n\tcase KVM_CAP_PPC_MMU_RADIX:\n\t\tr = !!(hv_enabled && radix_enabled());\n\t\tbreak;\n\tcase KVM_CAP_PPC_MMU_HASH_V3:\n\t\tr = !!(hv_enabled && !radix_enabled() &&\n\t\t       cpu_has_feature(CPU_FTR_ARCH_300));\n\t\tbreak;\n#endif\n\tcase KVM_CAP_SYNC_MMU:\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\t\tr = hv_enabled;\n#elif defined(KVM_ARCH_WANT_MMU_NOTIFIER)\n\t\tr = 1;\n#else\n\t\tr = 0;\n#endif\n\t\tbreak;\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_HTAB_FD:\n\t\tr = hv_enabled;\n\t\tbreak;\n#endif\n\tcase KVM_CAP_NR_VCPUS:\n\t\t/*\n\t\t * Recommending a number of CPUs is somewhat arbitrary; we\n\t\t * return the number of present CPUs for -HV (since a host\n\t\t * will have secondary threads \"offline\"), and for other KVM\n\t\t * implementations just count online CPUs.\n\t\t */\n\t\tif (hv_enabled)\n\t\t\tr = num_present_cpus();\n\t\telse\n\t\t\tr = num_online_cpus();\n\t\tbreak;\n\tcase KVM_CAP_NR_MEMSLOTS:\n\t\tr = KVM_USER_MEM_SLOTS;\n\t\tbreak;\n\tcase KVM_CAP_MAX_VCPUS:\n\t\tr = KVM_MAX_VCPUS;\n\t\tbreak;\n#ifdef CONFIG_PPC_BOOK3S_64\n\tcase KVM_CAP_PPC_GET_SMMU_INFO:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_SPAPR_MULTITCE:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_SPAPR_RESIZE_HPT:\n\t\t/* Disable this on POWER9 until code handles new HPTE format */\n\t\tr = !!hv_enabled && !cpu_has_feature(CPU_FTR_ARCH_300);\n\t\tbreak;\n#endif\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_FWNMI:\n\t\tr = hv_enabled;\n \t\tbreak;\n #endif\n \tcase KVM_CAP_PPC_HTM:\n\t\tr = cpu_has_feature(CPU_FTR_TM_COMP) &&\n\t\t    is_kvmppc_hv_enabled(kvm);\n \t\tbreak;\n \tdefault:\n \t\tr = 0;\n\t\tbreak;\n\t}\n\treturn r;\n\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142307,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)\n{\n\tint r;\n\t/* Assume we're using HV mode when the HV module is loaded */\n\tint hv_enabled = kvmppc_hv_ops ? 1 : 0;\n\n\tif (kvm) {\n\t\t/*\n\t\t * Hooray - we know which VM type we're running on. Depend on\n\t\t * that rather than the guess above.\n\t\t */\n\t\thv_enabled = is_kvmppc_hv_enabled(kvm);\n\t}\n\n\tswitch (ext) {\n#ifdef CONFIG_BOOKE\n\tcase KVM_CAP_PPC_BOOKE_SREGS:\n\tcase KVM_CAP_PPC_BOOKE_WATCHDOG:\n\tcase KVM_CAP_PPC_EPR:\n#else\n\tcase KVM_CAP_PPC_SEGSTATE:\n\tcase KVM_CAP_PPC_HIOR:\n\tcase KVM_CAP_PPC_PAPR:\n#endif\n\tcase KVM_CAP_PPC_UNSET_IRQ:\n\tcase KVM_CAP_PPC_IRQ_LEVEL:\n\tcase KVM_CAP_ENABLE_CAP:\n\tcase KVM_CAP_ENABLE_CAP_VM:\n\tcase KVM_CAP_ONE_REG:\n\tcase KVM_CAP_IOEVENTFD:\n\tcase KVM_CAP_DEVICE_CTRL:\n\tcase KVM_CAP_IMMEDIATE_EXIT:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_PPC_PAIRED_SINGLES:\n\tcase KVM_CAP_PPC_OSI:\n\tcase KVM_CAP_PPC_GET_PVINFO:\n#if defined(CONFIG_KVM_E500V2) || defined(CONFIG_KVM_E500MC)\n\tcase KVM_CAP_SW_TLB:\n#endif\n\t\t/* We support this only for PR */\n\t\tr = !hv_enabled;\n\t\tbreak;\n#ifdef CONFIG_KVM_MPIC\n\tcase KVM_CAP_IRQ_MPIC:\n\t\tr = 1;\n\t\tbreak;\n#endif\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\tcase KVM_CAP_SPAPR_TCE:\n\tcase KVM_CAP_SPAPR_TCE_64:\n\t\t/* fallthrough */\n\tcase KVM_CAP_SPAPR_TCE_VFIO:\n\tcase KVM_CAP_PPC_RTAS:\n\tcase KVM_CAP_PPC_FIXUP_HCALL:\n\tcase KVM_CAP_PPC_ENABLE_HCALL:\n#ifdef CONFIG_KVM_XICS\n\tcase KVM_CAP_IRQ_XICS:\n#endif\n\t\tr = 1;\n\t\tbreak;\n\n\tcase KVM_CAP_PPC_ALLOC_HTAB:\n\t\tr = hv_enabled;\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3S_64 */\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_SMT:\n\t\tr = 0;\n\t\tif (kvm) {\n\t\t\tif (kvm->arch.emul_smt_mode > 1)\n\t\t\t\tr = kvm->arch.emul_smt_mode;\n\t\t\telse\n\t\t\t\tr = kvm->arch.smt_mode;\n\t\t} else if (hv_enabled) {\n\t\t\tif (cpu_has_feature(CPU_FTR_ARCH_300))\n\t\t\t\tr = 1;\n\t\t\telse\n\t\t\t\tr = threads_per_subcore;\n\t\t}\n\t\tbreak;\n\tcase KVM_CAP_PPC_SMT_POSSIBLE:\n\t\tr = 1;\n\t\tif (hv_enabled) {\n\t\t\tif (!cpu_has_feature(CPU_FTR_ARCH_300))\n\t\t\t\tr = ((threads_per_subcore << 1) - 1);\n\t\t\telse\n\t\t\t\t/* P9 can emulate dbells, so allow any mode */\n\t\t\t\tr = 8 | 4 | 2 | 1;\n\t\t}\n\t\tbreak;\n\tcase KVM_CAP_PPC_RMA:\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_PPC_HWRNG:\n\t\tr = kvmppc_hwrng_present();\n\t\tbreak;\n\tcase KVM_CAP_PPC_MMU_RADIX:\n\t\tr = !!(hv_enabled && radix_enabled());\n\t\tbreak;\n\tcase KVM_CAP_PPC_MMU_HASH_V3:\n\t\tr = !!(hv_enabled && !radix_enabled() &&\n\t\t       cpu_has_feature(CPU_FTR_ARCH_300));\n\t\tbreak;\n#endif\n\tcase KVM_CAP_SYNC_MMU:\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\t\tr = hv_enabled;\n#elif defined(KVM_ARCH_WANT_MMU_NOTIFIER)\n\t\tr = 1;\n#else\n\t\tr = 0;\n#endif\n\t\tbreak;\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_HTAB_FD:\n\t\tr = hv_enabled;\n\t\tbreak;\n#endif\n\tcase KVM_CAP_NR_VCPUS:\n\t\t/*\n\t\t * Recommending a number of CPUs is somewhat arbitrary; we\n\t\t * return the number of present CPUs for -HV (since a host\n\t\t * will have secondary threads \"offline\"), and for other KVM\n\t\t * implementations just count online CPUs.\n\t\t */\n\t\tif (hv_enabled)\n\t\t\tr = num_present_cpus();\n\t\telse\n\t\t\tr = num_online_cpus();\n\t\tbreak;\n\tcase KVM_CAP_NR_MEMSLOTS:\n\t\tr = KVM_USER_MEM_SLOTS;\n\t\tbreak;\n\tcase KVM_CAP_MAX_VCPUS:\n\t\tr = KVM_MAX_VCPUS;\n\t\tbreak;\n#ifdef CONFIG_PPC_BOOK3S_64\n\tcase KVM_CAP_PPC_GET_SMMU_INFO:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_SPAPR_MULTITCE:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_SPAPR_RESIZE_HPT:\n\t\t/* Disable this on POWER9 until code handles new HPTE format */\n\t\tr = !!hv_enabled && !cpu_has_feature(CPU_FTR_ARCH_300);\n\t\tbreak;\n#endif\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_FWNMI:\n\t\tr = hv_enabled;\n \t\tbreak;\n #endif\n \tcase KVM_CAP_PPC_HTM:\n\t\tr = cpu_has_feature(CPU_FTR_TM_COMP) && hv_enabled;\n \t\tbreak;\n \tdefault:\n \t\tr = 0;\n\t\tbreak;\n\t}\n\treturn r;\n\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142308,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,\n\t\t\tunsigned int slen)\n{\n\tu8 *buf = NULL;\n\tu8 *src = (u8 *)seed;\n\tint err;\n\tif (slen) {\n\t\tbuf = kmalloc(slen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(buf, seed, slen);\n\t\tsrc = buf;\n\t}\n\terr = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);\n\tkzfree(buf);\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142315,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n {\n \tu8 *buf = NULL;\n\tint err;\n\n\tif (!seed && slen) {\n\t\tbuf = kmalloc(slen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\tget_random_bytes(buf, slen);\n \t\tseed = buf;\n \t}\n \n\terr = crypto_rng_alg(tfm)->seed(tfm, seed, slen);\n \n \tkfree(buf);\n \treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142316,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int tower_probe (struct usb_interface *interface, const struct usb_device_id *id)\n{\n\tstruct device *idev = &interface->dev;\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct lego_usb_tower *dev = NULL;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor* endpoint;\n\tstruct tower_get_version_reply get_version_reply;\n\tint i;\n\tint retval = -ENOMEM;\n\tint result;\n\n\t/* allocate memory for our device state and initialize it */\n\n\tdev = kmalloc (sizeof(struct lego_usb_tower), GFP_KERNEL);\n\n\tif (!dev)\n\t\tgoto exit;\n\n\tmutex_init(&dev->lock);\n\n\tdev->udev = udev;\n\tdev->open_count = 0;\n\n\tdev->read_buffer = NULL;\n\tdev->read_buffer_length = 0;\n\tdev->read_packet_length = 0;\n\tspin_lock_init (&dev->read_buffer_lock);\n\tdev->packet_timeout_jiffies = msecs_to_jiffies(packet_timeout);\n\tdev->read_last_arrival = jiffies;\n\n\tinit_waitqueue_head (&dev->read_wait);\n\tinit_waitqueue_head (&dev->write_wait);\n\n\tdev->interrupt_in_buffer = NULL;\n\tdev->interrupt_in_endpoint = NULL;\n\tdev->interrupt_in_urb = NULL;\n\tdev->interrupt_in_running = 0;\n\tdev->interrupt_in_done = 0;\n\n\tdev->interrupt_out_buffer = NULL;\n\tdev->interrupt_out_endpoint = NULL;\n\tdev->interrupt_out_urb = NULL;\n\tdev->interrupt_out_busy = 0;\n\n\tiface_desc = interface->cur_altsetting;\n\n\t/* set up the endpoint information */\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\n\t\tif (usb_endpoint_xfer_int(endpoint)) {\n\t\t\tif (usb_endpoint_dir_in(endpoint))\n\t\t\t\tdev->interrupt_in_endpoint = endpoint;\n\t\t\telse\n\t\t\t\tdev->interrupt_out_endpoint = endpoint;\n\t\t}\n\t}\n\tif(dev->interrupt_in_endpoint == NULL) {\n\t\tdev_err(idev, \"interrupt in endpoint not found\\n\");\n\t\tgoto error;\n\t}\n\tif (dev->interrupt_out_endpoint == NULL) {\n\t\tdev_err(idev, \"interrupt out endpoint not found\\n\");\n\t\tgoto error;\n\t}\n\n\tdev->read_buffer = kmalloc (read_buffer_size, GFP_KERNEL);\n\tif (!dev->read_buffer)\n\t\tgoto error;\n\tdev->interrupt_in_buffer = kmalloc (usb_endpoint_maxp(dev->interrupt_in_endpoint), GFP_KERNEL);\n\tif (!dev->interrupt_in_buffer)\n\t\tgoto error;\n\tdev->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->interrupt_in_urb)\n\t\tgoto error;\n\tdev->interrupt_out_buffer = kmalloc (write_buffer_size, GFP_KERNEL);\n\tif (!dev->interrupt_out_buffer)\n\t\tgoto error;\n\tdev->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->interrupt_out_urb)\n\t\tgoto error;\n \tdev->interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev->interrupt_in_endpoint->bInterval;\n \tdev->interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev->interrupt_out_endpoint->bInterval;\n \n\t/* we can register the device now, as it is ready */\n\tusb_set_intfdata (interface, dev);\n\tretval = usb_register_dev (interface, &tower_class);\n\tif (retval) {\n\t\t/* something prevented us from registering this driver */\n\t\tdev_err(idev, \"Not able to get a minor for this device.\\n\");\n\t\tusb_set_intfdata (interface, NULL);\n\t\tgoto error;\n\t}\n\tdev->minor = interface->minor;\n\t/* let the user know what node this device is now attached to */\n\tdev_info(&interface->dev, \"LEGO USB Tower #%d now attached to major \"\n\t\t \"%d minor %d\\n\", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),\n\t\t USB_MAJOR, dev->minor);\n \t/* get the firmware version and log it */\n \tresult = usb_control_msg (udev,\n \t\t\t\t  usb_rcvctrlpipe(udev, 0),\n\t\t\t\t  LEGO_USB_TOWER_REQUEST_GET_VERSION,\n\t\t\t\t  USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE,\n\t\t\t\t  0,\n\t\t\t\t  0,\n\t\t\t\t  &get_version_reply,\n\t\t\t\t  sizeof(get_version_reply),\n\t\t\t\t  1000);\n\tif (result < 0) {\n\t\tdev_err(idev, \"LEGO USB Tower get version control request failed\\n\");\n\t\tretval = result;\n\t\tgoto error;\n\t}\n\tdev_info(&interface->dev, \"LEGO USB Tower firmware version is %d.%d \"\n\t\t \"build %d\\n\", get_version_reply.major,\n \t\t get_version_reply.minor,\n \t\t le16_to_cpu(get_version_reply.build_no));\n \n \n exit:\n \treturn retval;\n\nerror:\n\ttower_delete(dev);\n\treturn retval;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142319,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int tower_probe (struct usb_interface *interface, const struct usb_device_id *id)\n{\n\tstruct device *idev = &interface->dev;\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct lego_usb_tower *dev = NULL;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor* endpoint;\n\tstruct tower_get_version_reply get_version_reply;\n\tint i;\n\tint retval = -ENOMEM;\n\tint result;\n\n\t/* allocate memory for our device state and initialize it */\n\n\tdev = kmalloc (sizeof(struct lego_usb_tower), GFP_KERNEL);\n\n\tif (!dev)\n\t\tgoto exit;\n\n\tmutex_init(&dev->lock);\n\n\tdev->udev = udev;\n\tdev->open_count = 0;\n\n\tdev->read_buffer = NULL;\n\tdev->read_buffer_length = 0;\n\tdev->read_packet_length = 0;\n\tspin_lock_init (&dev->read_buffer_lock);\n\tdev->packet_timeout_jiffies = msecs_to_jiffies(packet_timeout);\n\tdev->read_last_arrival = jiffies;\n\n\tinit_waitqueue_head (&dev->read_wait);\n\tinit_waitqueue_head (&dev->write_wait);\n\n\tdev->interrupt_in_buffer = NULL;\n\tdev->interrupt_in_endpoint = NULL;\n\tdev->interrupt_in_urb = NULL;\n\tdev->interrupt_in_running = 0;\n\tdev->interrupt_in_done = 0;\n\n\tdev->interrupt_out_buffer = NULL;\n\tdev->interrupt_out_endpoint = NULL;\n\tdev->interrupt_out_urb = NULL;\n\tdev->interrupt_out_busy = 0;\n\n\tiface_desc = interface->cur_altsetting;\n\n\t/* set up the endpoint information */\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\n\t\tif (usb_endpoint_xfer_int(endpoint)) {\n\t\t\tif (usb_endpoint_dir_in(endpoint))\n\t\t\t\tdev->interrupt_in_endpoint = endpoint;\n\t\t\telse\n\t\t\t\tdev->interrupt_out_endpoint = endpoint;\n\t\t}\n\t}\n\tif(dev->interrupt_in_endpoint == NULL) {\n\t\tdev_err(idev, \"interrupt in endpoint not found\\n\");\n\t\tgoto error;\n\t}\n\tif (dev->interrupt_out_endpoint == NULL) {\n\t\tdev_err(idev, \"interrupt out endpoint not found\\n\");\n\t\tgoto error;\n\t}\n\n\tdev->read_buffer = kmalloc (read_buffer_size, GFP_KERNEL);\n\tif (!dev->read_buffer)\n\t\tgoto error;\n\tdev->interrupt_in_buffer = kmalloc (usb_endpoint_maxp(dev->interrupt_in_endpoint), GFP_KERNEL);\n\tif (!dev->interrupt_in_buffer)\n\t\tgoto error;\n\tdev->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->interrupt_in_urb)\n\t\tgoto error;\n\tdev->interrupt_out_buffer = kmalloc (write_buffer_size, GFP_KERNEL);\n\tif (!dev->interrupt_out_buffer)\n\t\tgoto error;\n\tdev->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->interrupt_out_urb)\n\t\tgoto error;\n \tdev->interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev->interrupt_in_endpoint->bInterval;\n \tdev->interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev->interrupt_out_endpoint->bInterval;\n \n \t/* get the firmware version and log it */\n \tresult = usb_control_msg (udev,\n \t\t\t\t  usb_rcvctrlpipe(udev, 0),\n\t\t\t\t  LEGO_USB_TOWER_REQUEST_GET_VERSION,\n\t\t\t\t  USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE,\n\t\t\t\t  0,\n\t\t\t\t  0,\n\t\t\t\t  &get_version_reply,\n\t\t\t\t  sizeof(get_version_reply),\n\t\t\t\t  1000);\n\tif (result < 0) {\n\t\tdev_err(idev, \"LEGO USB Tower get version control request failed\\n\");\n\t\tretval = result;\n\t\tgoto error;\n\t}\n\tdev_info(&interface->dev, \"LEGO USB Tower firmware version is %d.%d \"\n\t\t \"build %d\\n\", get_version_reply.major,\n \t\t get_version_reply.minor,\n \t\t le16_to_cpu(get_version_reply.build_no));\n \n\t/* we can register the device now, as it is ready */\n\tusb_set_intfdata (interface, dev);\n\n\tretval = usb_register_dev (interface, &tower_class);\n\n\tif (retval) {\n\t\t/* something prevented us from registering this driver */\n\t\tdev_err(idev, \"Not able to get a minor for this device.\\n\");\n\t\tusb_set_intfdata (interface, NULL);\n\t\tgoto error;\n\t}\n\tdev->minor = interface->minor;\n\n\t/* let the user know what node this device is now attached to */\n\tdev_info(&interface->dev, \"LEGO USB Tower #%d now attached to major \"\n\t\t \"%d minor %d\\n\", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),\n\t\t USB_MAJOR, dev->minor);\n \n exit:\n \treturn retval;\n\nerror:\n\ttower_delete(dev);\n\treturn retval;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142320,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct rtmsg *rtm;\n\tstruct nlattr *tb[RTA_MAX+1];\n\tstruct fib_result res = {};\n\tstruct rtable *rt = NULL;\n\tstruct flowi4 fl4;\n\t__be32 dst = 0;\n\t__be32 src = 0;\n\tu32 iif;\n\tint err;\n\tint mark;\n\tstruct sk_buff *skb;\n\tu32 table_id = RT_TABLE_MAIN;\n\tkuid_t uid;\n\n\terr = nlmsg_parse(nlh, sizeof(*rtm), tb, RTA_MAX, rtm_ipv4_policy,\n\t\t\t  extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\trtm = nlmsg_data(nlh);\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb) {\n\t\terr = -ENOBUFS;\n\t\tgoto errout;\n\t}\n\n\t/* Reserve room for dummy headers, this skb can pass\n\t   through good chunk of routing engine.\n\t */\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\n\tsrc = tb[RTA_SRC] ? nla_get_in_addr(tb[RTA_SRC]) : 0;\n\tdst = tb[RTA_DST] ? nla_get_in_addr(tb[RTA_DST]) : 0;\n\tiif = tb[RTA_IIF] ? nla_get_u32(tb[RTA_IIF]) : 0;\n\tmark = tb[RTA_MARK] ? nla_get_u32(tb[RTA_MARK]) : 0;\n\tif (tb[RTA_UID])\n\t\tuid = make_kuid(current_user_ns(), nla_get_u32(tb[RTA_UID]));\n\telse\n\t\tuid = (iif ? INVALID_UID : current_uid());\n\n\t/* Bugfix: need to give ip_route_input enough of an IP header to\n\t * not gag.\n\t */\n\tip_hdr(skb)->protocol = IPPROTO_UDP;\n\tip_hdr(skb)->saddr = src;\n\tip_hdr(skb)->daddr = dst;\n\n\tskb_reserve(skb, MAX_HEADER + sizeof(struct iphdr));\n\n\tmemset(&fl4, 0, sizeof(fl4));\n\tfl4.daddr = dst;\n\tfl4.saddr = src;\n\tfl4.flowi4_tos = rtm->rtm_tos;\n\tfl4.flowi4_oif = tb[RTA_OIF] ? nla_get_u32(tb[RTA_OIF]) : 0;\n\tfl4.flowi4_mark = mark;\n\tfl4.flowi4_uid = uid;\n\n\trcu_read_lock();\n\n\tif (iif) {\n\t\tstruct net_device *dev;\n\n\t\tdev = dev_get_by_index_rcu(net, iif);\n\t\tif (!dev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto errout_free;\n\t\t}\n\n\t\tskb->protocol\t= htons(ETH_P_IP);\n\t\tskb->dev\t= dev;\n\t\tskb->mark\t= mark;\n\t\terr = ip_route_input_rcu(skb, dst, src, rtm->rtm_tos,\n\t\t\t\t\t dev, &res);\n\n\t\trt = skb_rtable(skb);\n\t\tif (err == 0 && rt->dst.error)\n\t\t\terr = -rt->dst.error;\n\t} else {\n\t\trt = ip_route_output_key_hash_rcu(net, &fl4, &res, skb);\n\t\terr = 0;\n\t\tif (IS_ERR(rt))\n\t\t\terr = PTR_ERR(rt);\n\t\telse\n\t\t\tskb_dst_set(skb, &rt->dst);\n\t}\n\n\tif (err)\n\t\tgoto errout_free;\n\n\tif (rtm->rtm_flags & RTM_F_NOTIFY)\n\t\trt->rt_flags |= RTCF_NOTIFY;\n\n \tif (rtm->rtm_flags & RTM_F_LOOKUP_TABLE)\n \t\ttable_id = rt->rt_table_id;\n \n\tif (rtm->rtm_flags & RTM_F_FIB_MATCH)\n \t\terr = fib_dump_info(skb, NETLINK_CB(in_skb).portid,\n \t\t\t\t    nlh->nlmsg_seq, RTM_NEWROUTE, table_id,\n \t\t\t\t    rt->rt_type, res.prefix, res.prefixlen,\n \t\t\t\t    fl4.flowi4_tos, res.fi, 0);\n\telse\n \t\terr = rt_fill_info(net, dst, src, table_id, &fl4, skb,\n \t\t\t\t   NETLINK_CB(in_skb).portid, nlh->nlmsg_seq);\n \tif (err < 0)\n \t\tgoto errout_free;\n \n\trcu_read_unlock();\n\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nerrout:\n\treturn err;\n\nerrout_free:\n\trcu_read_unlock();\n\tkfree_skb(skb);\n\tgoto errout;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142369,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct rtmsg *rtm;\n\tstruct nlattr *tb[RTA_MAX+1];\n\tstruct fib_result res = {};\n\tstruct rtable *rt = NULL;\n\tstruct flowi4 fl4;\n\t__be32 dst = 0;\n\t__be32 src = 0;\n\tu32 iif;\n\tint err;\n\tint mark;\n\tstruct sk_buff *skb;\n\tu32 table_id = RT_TABLE_MAIN;\n\tkuid_t uid;\n\n\terr = nlmsg_parse(nlh, sizeof(*rtm), tb, RTA_MAX, rtm_ipv4_policy,\n\t\t\t  extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\trtm = nlmsg_data(nlh);\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb) {\n\t\terr = -ENOBUFS;\n\t\tgoto errout;\n\t}\n\n\t/* Reserve room for dummy headers, this skb can pass\n\t   through good chunk of routing engine.\n\t */\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\n\tsrc = tb[RTA_SRC] ? nla_get_in_addr(tb[RTA_SRC]) : 0;\n\tdst = tb[RTA_DST] ? nla_get_in_addr(tb[RTA_DST]) : 0;\n\tiif = tb[RTA_IIF] ? nla_get_u32(tb[RTA_IIF]) : 0;\n\tmark = tb[RTA_MARK] ? nla_get_u32(tb[RTA_MARK]) : 0;\n\tif (tb[RTA_UID])\n\t\tuid = make_kuid(current_user_ns(), nla_get_u32(tb[RTA_UID]));\n\telse\n\t\tuid = (iif ? INVALID_UID : current_uid());\n\n\t/* Bugfix: need to give ip_route_input enough of an IP header to\n\t * not gag.\n\t */\n\tip_hdr(skb)->protocol = IPPROTO_UDP;\n\tip_hdr(skb)->saddr = src;\n\tip_hdr(skb)->daddr = dst;\n\n\tskb_reserve(skb, MAX_HEADER + sizeof(struct iphdr));\n\n\tmemset(&fl4, 0, sizeof(fl4));\n\tfl4.daddr = dst;\n\tfl4.saddr = src;\n\tfl4.flowi4_tos = rtm->rtm_tos;\n\tfl4.flowi4_oif = tb[RTA_OIF] ? nla_get_u32(tb[RTA_OIF]) : 0;\n\tfl4.flowi4_mark = mark;\n\tfl4.flowi4_uid = uid;\n\n\trcu_read_lock();\n\n\tif (iif) {\n\t\tstruct net_device *dev;\n\n\t\tdev = dev_get_by_index_rcu(net, iif);\n\t\tif (!dev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto errout_free;\n\t\t}\n\n\t\tskb->protocol\t= htons(ETH_P_IP);\n\t\tskb->dev\t= dev;\n\t\tskb->mark\t= mark;\n\t\terr = ip_route_input_rcu(skb, dst, src, rtm->rtm_tos,\n\t\t\t\t\t dev, &res);\n\n\t\trt = skb_rtable(skb);\n\t\tif (err == 0 && rt->dst.error)\n\t\t\terr = -rt->dst.error;\n\t} else {\n\t\trt = ip_route_output_key_hash_rcu(net, &fl4, &res, skb);\n\t\terr = 0;\n\t\tif (IS_ERR(rt))\n\t\t\terr = PTR_ERR(rt);\n\t\telse\n\t\t\tskb_dst_set(skb, &rt->dst);\n\t}\n\n\tif (err)\n\t\tgoto errout_free;\n\n\tif (rtm->rtm_flags & RTM_F_NOTIFY)\n\t\trt->rt_flags |= RTCF_NOTIFY;\n\n \tif (rtm->rtm_flags & RTM_F_LOOKUP_TABLE)\n \t\ttable_id = rt->rt_table_id;\n \n\tif (rtm->rtm_flags & RTM_F_FIB_MATCH) {\n\t\tif (!res.fi) {\n\t\t\terr = fib_props[res.type].error;\n\t\t\tif (!err)\n\t\t\t\terr = -EHOSTUNREACH;\n\t\t\tgoto errout_free;\n\t\t}\n \t\terr = fib_dump_info(skb, NETLINK_CB(in_skb).portid,\n \t\t\t\t    nlh->nlmsg_seq, RTM_NEWROUTE, table_id,\n \t\t\t\t    rt->rt_type, res.prefix, res.prefixlen,\n \t\t\t\t    fl4.flowi4_tos, res.fi, 0);\n\t} else {\n \t\terr = rt_fill_info(net, dst, src, table_id, &fl4, skb,\n \t\t\t\t   NETLINK_CB(in_skb).portid, nlh->nlmsg_seq);\n\t}\n \tif (err < 0)\n \t\tgoto errout_free;\n \n\trcu_read_unlock();\n\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nerrout:\n\treturn err;\n\nerrout_free:\n\trcu_read_unlock();\n\tkfree_skb(skb);\n\tgoto errout;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142370,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,\n\t\t\t\t\t\t  const struct assoc_array_ops *ops,\n\t\t\t\t\t\t  const void *index_key,\n\t\t\t\t\t\t  struct assoc_array_walk_result *result)\n{\n\tstruct assoc_array_shortcut *shortcut, *new_s0;\n\tstruct assoc_array_node *node, *new_n0, *new_n1, *side;\n\tstruct assoc_array_ptr *ptr;\n\tunsigned long dissimilarity, base_seg, blank;\n\tsize_t keylen;\n\tbool have_meta;\n\tint level, diff;\n\tint slot, next_slot, free_slot, i, j;\n\n\tnode\t= result->terminal_node.node;\n\tlevel\t= result->terminal_node.level;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = result->terminal_node.slot;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\t/* We arrived at a node which doesn't have an onward node or shortcut\n\t * pointer that we have to follow.  This means that (a) the leaf we\n\t * want must go here (either by insertion or replacement) or (b) we\n\t * need to split this node and insert in one of the fragments.\n\t */\n\tfree_slot = -1;\n\n\t/* Firstly, we have to check the leaves in this node to see if there's\n\t * a matching one we should replace in place.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (!ptr) {\n\t\t\tfree_slot = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (assoc_array_ptr_is_leaf(ptr) &&\n\t\t    ops->compare_object(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\tindex_key)) {\n\t\t\tpr_devel(\"replace in slot %d\\n\", i);\n\t\t\tedit->leaf_p = &node->slots[i];\n\t\t\tedit->dead_leaf = node->slots[i];\n\t\t\tpr_devel(\"<--%s() = ok [replace]\\n\", __func__);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* If there is a free slot in this node then we can just insert the\n\t * leaf here.\n\t */\n\tif (free_slot >= 0) {\n\t\tpr_devel(\"insert in free slot %d\\n\", free_slot);\n\t\tedit->leaf_p = &node->slots[free_slot];\n\t\tedit->adjust_count_on = node;\n\t\tpr_devel(\"<--%s() = ok [insert]\\n\", __func__);\n\t\treturn true;\n\t}\n\n\t/* The node has no spare slots - so we're either going to have to split\n\t * it or insert another node before it.\n\t *\n\t * Whatever, we're going to need at least two new nodes - so allocate\n\t * those now.  We may also need a new shortcut, but we deal with that\n\t * when we need it.\n\t */\n\tnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n0)\n\t\treturn false;\n\tedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\n\tnew_n1 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n1)\n\t\treturn false;\n\tedit->new_meta[1] = assoc_array_node_to_ptr(new_n1);\n\n\t/* We need to find out how similar the leaves are. */\n\tpr_devel(\"no spare slots\\n\");\n\thave_meta = false;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (assoc_array_ptr_is_meta(ptr)) {\n\t\t\tedit->segment_cache[i] = 0xff;\n\t\t\thave_meta = true;\n\t\t\tcontinue;\n\t\t}\n\t\tbase_seg = ops->get_object_key_chunk(\n\t\t\tassoc_array_ptr_to_leaf(ptr), level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tif (have_meta) {\n\t\tpr_devel(\"have meta\\n\");\n\t\tgoto split_node;\n\t}\n\n\t/* The node contains only leaves */\n\tdissimilarity = 0;\n\tbase_seg = edit->segment_cache[0];\n\tfor (i = 1; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tdissimilarity |= edit->segment_cache[i] ^ base_seg;\n\n\tpr_devel(\"only leaves; dissimilarity=%lx\\n\", dissimilarity);\n\n\tif ((dissimilarity & ASSOC_ARRAY_FAN_MASK) == 0) {\n\t\t/* The old leaves all cluster in the same slot.  We will need\n\t\t * to insert a shortcut if the new node wants to cluster with them.\n\t\t */\n \t\tif ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0)\n \t\t\tgoto all_leaves_cluster_together;\n \n\t\t/* Otherwise we can just insert a new node ahead of the old\n\t\t * one.\n \t\t */\n\t\tgoto present_leaves_cluster_but_not_new_leaf;\n \t}\n \n split_node:\n \tpr_devel(\"split node\\n\");\n \n\t/* We need to split the current node; we know that the node doesn't\n\t * simply contain a full set of leaves that cluster together (it\n\t * contains meta pointers and/or non-clustering leaves).\n \t *\n \t * We need to expel at least two leaves out of a set consisting of the\n\t * leaves in the node and the new leaf.\n \t *\n \t * We need a new node (n0) to replace the current one and a new node to\n \t * take the expelled nodes (n1).\n\t */\n\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = node->back_pointer;\n\tnew_n0->parent_slot = node->parent_slot;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to calculate this */\n\ndo_split_node:\n\tpr_devel(\"do_split_node\\n\");\n\n\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tnew_n1->nr_leaves_on_branch = 0;\n\n\t/* Begin by finding two matching leaves.  There have to be at least two\n\t * that match - even if there are meta pointers - because any leaf that\n\t * would match a slot with a meta pointer in it must be somewhere\n\t * behind that meta pointer and cannot be here.  Further, given N\n\t * remaining leaf slots, we now have N+1 leaves to go in them.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tslot = edit->segment_cache[i];\n\t\tif (slot != 0xff)\n\t\t\tfor (j = i + 1; j < ASSOC_ARRAY_FAN_OUT + 1; j++)\n\t\t\t\tif (edit->segment_cache[j] == slot)\n\t\t\t\t\tgoto found_slot_for_multiple_occupancy;\n\t}\nfound_slot_for_multiple_occupancy:\n\tpr_devel(\"same slot: %x %x [%02x]\\n\", i, j, slot);\n\tBUG_ON(i >= ASSOC_ARRAY_FAN_OUT);\n\tBUG_ON(j >= ASSOC_ARRAY_FAN_OUT + 1);\n\tBUG_ON(slot >= ASSOC_ARRAY_FAN_OUT);\n\n\tnew_n1->parent_slot = slot;\n\n\t/* Metadata pointers cannot change slot */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tnew_n0->slots[i] = node->slots[i];\n\t\telse\n\t\t\tnew_n0->slots[i] = NULL;\n\tBUG_ON(new_n0->slots[slot] != NULL);\n\tnew_n0->slots[slot] = assoc_array_node_to_ptr(new_n1);\n\n\t/* Filter the leaf pointers between the new nodes */\n\tfree_slot = -1;\n\tnext_slot = 0;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tcontinue;\n\t\tif (edit->segment_cache[i] == slot) {\n\t\t\tnew_n1->slots[next_slot++] = node->slots[i];\n\t\t\tnew_n1->nr_leaves_on_branch++;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tfree_slot++;\n\t\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\t\tnew_n0->slots[free_slot] = node->slots[i];\n\t\t}\n\t}\n\n\tpr_devel(\"filtered: f=%x n=%x\\n\", free_slot, next_slot);\n\n\tif (edit->segment_cache[ASSOC_ARRAY_FAN_OUT] != slot) {\n\t\tdo {\n\t\t\tfree_slot++;\n\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\tedit->leaf_p = &new_n0->slots[free_slot];\n\t\tedit->adjust_count_on = new_n0;\n\t} else {\n\t\tedit->leaf_p = &new_n1->slots[next_slot++];\n\t\tedit->adjust_count_on = new_n1;\n\t}\n\n\tBUG_ON(next_slot <= 1);\n\n\tedit->set_backpointers_to = assoc_array_node_to_ptr(new_n0);\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (edit->segment_cache[i] == 0xff) {\n\t\t\tptr = node->slots[i];\n\t\t\tBUG_ON(assoc_array_ptr_is_leaf(ptr));\n\t\t\tif (assoc_array_ptr_is_node(ptr)) {\n\t\t\t\tside = assoc_array_ptr_to_node(ptr);\n\t\t\t\tedit->set_backpointers[i] = &side->back_pointer;\n\t\t\t} else {\n\t\t\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\t\t\tedit->set_backpointers[i] = &shortcut->back_pointer;\n\t\t\t}\n\t\t}\n\t}\n\n\tptr = node->back_pointer;\n\tif (!ptr)\n\t\tedit->set[0].ptr = &edit->array->root;\n\telse if (assoc_array_ptr_is_node(ptr))\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_node(ptr)->slots[node->parent_slot];\n\telse\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_shortcut(ptr)->next_node;\n\tedit->excised_meta[0] = assoc_array_node_to_ptr(node);\n \tpr_devel(\"<--%s() = ok [split node]\\n\", __func__);\n \treturn true;\n \npresent_leaves_cluster_but_not_new_leaf:\n\t/* All the old leaves cluster in the same slot, but the new leaf wants\n\t * to go into a different slot, so we create a new node to hold the new\n\t * leaf and a pointer to a new node holding all the old leaves.\n\t */\n\tpr_devel(\"present leaves cluster but not new leaf\\n\");\n\tnew_n0->back_pointer = node->back_pointer;\n\tnew_n0->parent_slot = node->parent_slot;\n\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = edit->segment_cache[0];\n\tnew_n1->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tedit->adjust_count_on = new_n0;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tnew_n1->slots[i] = node->slots[i];\n\tnew_n0->slots[edit->segment_cache[0]] = assoc_array_node_to_ptr(new_n0);\n\tedit->leaf_p = &new_n0->slots[edit->segment_cache[ASSOC_ARRAY_FAN_OUT]];\n\tedit->set[0].ptr = &assoc_array_ptr_to_node(node->back_pointer)->slots[node->parent_slot];\n\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\tedit->excised_meta[0] = assoc_array_node_to_ptr(node);\n\tpr_devel(\"<--%s() = ok [insert node before]\\n\", __func__);\n\treturn true;\n all_leaves_cluster_together:\n \t/* All the leaves, new and old, want to cluster together in this node\n \t * in the same slot, so we have to replace this node with a shortcut to\n\t * skip over the identical parts of the key and then place a pair of\n\t * nodes, one inside the other, at the end of the shortcut and\n\t * distribute the keys between them.\n\t *\n\t * Firstly we need to work out where the leaves start diverging as a\n\t * bit position into their keys so that we know how big the shortcut\n\t * needs to be.\n\t *\n\t * We only need to make a single pass of N of the N+1 leaves because if\n\t * any keys differ between themselves at bit X then at least one of\n\t * them must also differ with the base key at bit X or before.\n\t */\n\tpr_devel(\"all leaves cluster together\\n\");\n\tdiff = INT_MAX;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tint x = ops->diff_objects(assoc_array_ptr_to_leaf(node->slots[i]),\n\t\t\t\t\t  index_key);\n\t\tif (x < diff) {\n\t\t\tBUG_ON(x < 0);\n\t\t\tdiff = x;\n\t\t}\n\t}\n\tBUG_ON(diff == INT_MAX);\n\tBUG_ON(diff < level + ASSOC_ARRAY_LEVEL_STEP);\n\n\tkeylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\tkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\n\n\tnew_s0 = kzalloc(sizeof(struct assoc_array_shortcut) +\n\t\t\t keylen * sizeof(unsigned long), GFP_KERNEL);\n\tif (!new_s0)\n\t\treturn false;\n\tedit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s0);\n\n\tedit->set[0].to = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_s0->back_pointer = node->back_pointer;\n\tnew_s0->parent_slot = node->parent_slot;\n\tnew_s0->next_node = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_n0->parent_slot = 0;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to calculate this */\n\n\tnew_s0->skip_to_level = level = diff & ~ASSOC_ARRAY_LEVEL_STEP_MASK;\n\tpr_devel(\"skip_to_level = %d [diff %d]\\n\", level, diff);\n\tBUG_ON(level <= 0);\n\n\tfor (i = 0; i < keylen; i++)\n\t\tnew_s0->index_key[i] =\n\t\t\tops->get_key_chunk(index_key, i * ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\n\tblank = ULONG_MAX << (level & ASSOC_ARRAY_KEY_CHUNK_MASK);\n\tpr_devel(\"blank off [%zu] %d: %lx\\n\", keylen - 1, level, blank);\n\tnew_s0->index_key[keylen - 1] &= ~blank;\n\n\t/* This now reduces to a node splitting exercise for which we'll need\n\t * to regenerate the disparity table.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tbase_seg = ops->get_object_key_chunk(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\t\t     level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tbase_seg = ops->get_key_chunk(index_key, level);\n\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\tgoto do_split_node;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142469,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,\n\t\t\t\t\t\t  const struct assoc_array_ops *ops,\n\t\t\t\t\t\t  const void *index_key,\n\t\t\t\t\t\t  struct assoc_array_walk_result *result)\n{\n\tstruct assoc_array_shortcut *shortcut, *new_s0;\n\tstruct assoc_array_node *node, *new_n0, *new_n1, *side;\n\tstruct assoc_array_ptr *ptr;\n\tunsigned long dissimilarity, base_seg, blank;\n\tsize_t keylen;\n\tbool have_meta;\n\tint level, diff;\n\tint slot, next_slot, free_slot, i, j;\n\n\tnode\t= result->terminal_node.node;\n\tlevel\t= result->terminal_node.level;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = result->terminal_node.slot;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\t/* We arrived at a node which doesn't have an onward node or shortcut\n\t * pointer that we have to follow.  This means that (a) the leaf we\n\t * want must go here (either by insertion or replacement) or (b) we\n\t * need to split this node and insert in one of the fragments.\n\t */\n\tfree_slot = -1;\n\n\t/* Firstly, we have to check the leaves in this node to see if there's\n\t * a matching one we should replace in place.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (!ptr) {\n\t\t\tfree_slot = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (assoc_array_ptr_is_leaf(ptr) &&\n\t\t    ops->compare_object(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\tindex_key)) {\n\t\t\tpr_devel(\"replace in slot %d\\n\", i);\n\t\t\tedit->leaf_p = &node->slots[i];\n\t\t\tedit->dead_leaf = node->slots[i];\n\t\t\tpr_devel(\"<--%s() = ok [replace]\\n\", __func__);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* If there is a free slot in this node then we can just insert the\n\t * leaf here.\n\t */\n\tif (free_slot >= 0) {\n\t\tpr_devel(\"insert in free slot %d\\n\", free_slot);\n\t\tedit->leaf_p = &node->slots[free_slot];\n\t\tedit->adjust_count_on = node;\n\t\tpr_devel(\"<--%s() = ok [insert]\\n\", __func__);\n\t\treturn true;\n\t}\n\n\t/* The node has no spare slots - so we're either going to have to split\n\t * it or insert another node before it.\n\t *\n\t * Whatever, we're going to need at least two new nodes - so allocate\n\t * those now.  We may also need a new shortcut, but we deal with that\n\t * when we need it.\n\t */\n\tnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n0)\n\t\treturn false;\n\tedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\n\tnew_n1 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n1)\n\t\treturn false;\n\tedit->new_meta[1] = assoc_array_node_to_ptr(new_n1);\n\n\t/* We need to find out how similar the leaves are. */\n\tpr_devel(\"no spare slots\\n\");\n\thave_meta = false;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (assoc_array_ptr_is_meta(ptr)) {\n\t\t\tedit->segment_cache[i] = 0xff;\n\t\t\thave_meta = true;\n\t\t\tcontinue;\n\t\t}\n\t\tbase_seg = ops->get_object_key_chunk(\n\t\t\tassoc_array_ptr_to_leaf(ptr), level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tif (have_meta) {\n\t\tpr_devel(\"have meta\\n\");\n\t\tgoto split_node;\n\t}\n\n\t/* The node contains only leaves */\n\tdissimilarity = 0;\n\tbase_seg = edit->segment_cache[0];\n\tfor (i = 1; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tdissimilarity |= edit->segment_cache[i] ^ base_seg;\n\n\tpr_devel(\"only leaves; dissimilarity=%lx\\n\", dissimilarity);\n\n\tif ((dissimilarity & ASSOC_ARRAY_FAN_MASK) == 0) {\n\t\t/* The old leaves all cluster in the same slot.  We will need\n\t\t * to insert a shortcut if the new node wants to cluster with them.\n\t\t */\n \t\tif ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0)\n \t\t\tgoto all_leaves_cluster_together;\n \n\t\t/* Otherwise all the old leaves cluster in the same slot, but\n\t\t * the new leaf wants to go into a different slot - so we\n\t\t * create a new node (n0) to hold the new leaf and a pointer to\n\t\t * a new node (n1) holding all the old leaves.\n\t\t *\n\t\t * This can be done by falling through to the node splitting\n\t\t * path.\n \t\t */\n\t\tpr_devel(\"present leaves cluster but not new leaf\\n\");\n \t}\n \n split_node:\n \tpr_devel(\"split node\\n\");\n \n\t/* We need to split the current node.  The node must contain anything\n\t * from a single leaf (in the one leaf case, this leaf will cluster\n\t * with the new leaf) and the rest meta-pointers, to all leaves, some\n\t * of which may cluster.\n\t *\n\t * It won't contain the case in which all the current leaves plus the\n\t * new leaves want to cluster in the same slot.\n \t *\n \t * We need to expel at least two leaves out of a set consisting of the\n\t * leaves in the node and the new leaf.  The current meta pointers can\n\t * just be copied as they shouldn't cluster with any of the leaves.\n \t *\n \t * We need a new node (n0) to replace the current one and a new node to\n \t * take the expelled nodes (n1).\n\t */\n\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = node->back_pointer;\n\tnew_n0->parent_slot = node->parent_slot;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to calculate this */\n\ndo_split_node:\n\tpr_devel(\"do_split_node\\n\");\n\n\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tnew_n1->nr_leaves_on_branch = 0;\n\n\t/* Begin by finding two matching leaves.  There have to be at least two\n\t * that match - even if there are meta pointers - because any leaf that\n\t * would match a slot with a meta pointer in it must be somewhere\n\t * behind that meta pointer and cannot be here.  Further, given N\n\t * remaining leaf slots, we now have N+1 leaves to go in them.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tslot = edit->segment_cache[i];\n\t\tif (slot != 0xff)\n\t\t\tfor (j = i + 1; j < ASSOC_ARRAY_FAN_OUT + 1; j++)\n\t\t\t\tif (edit->segment_cache[j] == slot)\n\t\t\t\t\tgoto found_slot_for_multiple_occupancy;\n\t}\nfound_slot_for_multiple_occupancy:\n\tpr_devel(\"same slot: %x %x [%02x]\\n\", i, j, slot);\n\tBUG_ON(i >= ASSOC_ARRAY_FAN_OUT);\n\tBUG_ON(j >= ASSOC_ARRAY_FAN_OUT + 1);\n\tBUG_ON(slot >= ASSOC_ARRAY_FAN_OUT);\n\n\tnew_n1->parent_slot = slot;\n\n\t/* Metadata pointers cannot change slot */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tnew_n0->slots[i] = node->slots[i];\n\t\telse\n\t\t\tnew_n0->slots[i] = NULL;\n\tBUG_ON(new_n0->slots[slot] != NULL);\n\tnew_n0->slots[slot] = assoc_array_node_to_ptr(new_n1);\n\n\t/* Filter the leaf pointers between the new nodes */\n\tfree_slot = -1;\n\tnext_slot = 0;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tcontinue;\n\t\tif (edit->segment_cache[i] == slot) {\n\t\t\tnew_n1->slots[next_slot++] = node->slots[i];\n\t\t\tnew_n1->nr_leaves_on_branch++;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tfree_slot++;\n\t\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\t\tnew_n0->slots[free_slot] = node->slots[i];\n\t\t}\n\t}\n\n\tpr_devel(\"filtered: f=%x n=%x\\n\", free_slot, next_slot);\n\n\tif (edit->segment_cache[ASSOC_ARRAY_FAN_OUT] != slot) {\n\t\tdo {\n\t\t\tfree_slot++;\n\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\tedit->leaf_p = &new_n0->slots[free_slot];\n\t\tedit->adjust_count_on = new_n0;\n\t} else {\n\t\tedit->leaf_p = &new_n1->slots[next_slot++];\n\t\tedit->adjust_count_on = new_n1;\n\t}\n\n\tBUG_ON(next_slot <= 1);\n\n\tedit->set_backpointers_to = assoc_array_node_to_ptr(new_n0);\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (edit->segment_cache[i] == 0xff) {\n\t\t\tptr = node->slots[i];\n\t\t\tBUG_ON(assoc_array_ptr_is_leaf(ptr));\n\t\t\tif (assoc_array_ptr_is_node(ptr)) {\n\t\t\t\tside = assoc_array_ptr_to_node(ptr);\n\t\t\t\tedit->set_backpointers[i] = &side->back_pointer;\n\t\t\t} else {\n\t\t\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\t\t\tedit->set_backpointers[i] = &shortcut->back_pointer;\n\t\t\t}\n\t\t}\n\t}\n\n\tptr = node->back_pointer;\n\tif (!ptr)\n\t\tedit->set[0].ptr = &edit->array->root;\n\telse if (assoc_array_ptr_is_node(ptr))\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_node(ptr)->slots[node->parent_slot];\n\telse\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_shortcut(ptr)->next_node;\n\tedit->excised_meta[0] = assoc_array_node_to_ptr(node);\n \tpr_devel(\"<--%s() = ok [split node]\\n\", __func__);\n \treturn true;\n \n all_leaves_cluster_together:\n \t/* All the leaves, new and old, want to cluster together in this node\n \t * in the same slot, so we have to replace this node with a shortcut to\n\t * skip over the identical parts of the key and then place a pair of\n\t * nodes, one inside the other, at the end of the shortcut and\n\t * distribute the keys between them.\n\t *\n\t * Firstly we need to work out where the leaves start diverging as a\n\t * bit position into their keys so that we know how big the shortcut\n\t * needs to be.\n\t *\n\t * We only need to make a single pass of N of the N+1 leaves because if\n\t * any keys differ between themselves at bit X then at least one of\n\t * them must also differ with the base key at bit X or before.\n\t */\n\tpr_devel(\"all leaves cluster together\\n\");\n\tdiff = INT_MAX;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tint x = ops->diff_objects(assoc_array_ptr_to_leaf(node->slots[i]),\n\t\t\t\t\t  index_key);\n\t\tif (x < diff) {\n\t\t\tBUG_ON(x < 0);\n\t\t\tdiff = x;\n\t\t}\n\t}\n\tBUG_ON(diff == INT_MAX);\n\tBUG_ON(diff < level + ASSOC_ARRAY_LEVEL_STEP);\n\n\tkeylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\tkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\n\n\tnew_s0 = kzalloc(sizeof(struct assoc_array_shortcut) +\n\t\t\t keylen * sizeof(unsigned long), GFP_KERNEL);\n\tif (!new_s0)\n\t\treturn false;\n\tedit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s0);\n\n\tedit->set[0].to = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_s0->back_pointer = node->back_pointer;\n\tnew_s0->parent_slot = node->parent_slot;\n\tnew_s0->next_node = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_n0->parent_slot = 0;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to calculate this */\n\n\tnew_s0->skip_to_level = level = diff & ~ASSOC_ARRAY_LEVEL_STEP_MASK;\n\tpr_devel(\"skip_to_level = %d [diff %d]\\n\", level, diff);\n\tBUG_ON(level <= 0);\n\n\tfor (i = 0; i < keylen; i++)\n\t\tnew_s0->index_key[i] =\n\t\t\tops->get_key_chunk(index_key, i * ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\n\tblank = ULONG_MAX << (level & ASSOC_ARRAY_KEY_CHUNK_MASK);\n\tpr_devel(\"blank off [%zu] %d: %lx\\n\", keylen - 1, level, blank);\n\tnew_s0->index_key[keylen - 1] &= ~blank;\n\n\t/* This now reduces to a node splitting exercise for which we'll need\n\t * to regenerate the disparity table.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tbase_seg = ops->get_object_key_chunk(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\t\t     level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tbase_seg = ops->get_key_chunk(index_key, level);\n\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\tgoto do_split_node;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142470,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,\n  const ImageInfo *IMimage_info,Image *IMimage,ExceptionInfo *exception)\n{\n  char\n    im_vers[32],\n    libpng_runv[32],\n    libpng_vers[32],\n    zlib_runv[32],\n    zlib_vers[32];\n\n  Image\n    *image;\n\n  ImageInfo\n    *image_info;\n\n  char\n    s[2];\n\n  const char\n    *name,\n    *property,\n    *value;\n\n  const StringInfo\n    *profile;\n\n  int\n    num_passes,\n    pass,\n    ping_wrote_caNv;\n\n  png_byte\n     ping_trans_alpha[256];\n\n  png_color\n     palette[257];\n\n  png_color_16\n    ping_background,\n    ping_trans_color;\n\n  png_info\n    *ping_info;\n\n  png_struct\n    *ping;\n\n  png_uint_32\n    ping_height,\n    ping_width;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    image_matte,\n    logging,\n    matte,\n\n    ping_have_blob,\n    ping_have_cheap_transparency,\n    ping_have_color,\n    ping_have_non_bw,\n    ping_have_PLTE,\n    ping_have_bKGD,\n    ping_have_eXIf,\n    ping_have_iCCP,\n    ping_have_pHYs,\n    ping_have_sRGB,\n    ping_have_tRNS,\n\n    ping_exclude_bKGD,\n    ping_exclude_cHRM,\n    ping_exclude_date,\n    /* ping_exclude_EXIF, */\n    ping_exclude_eXIf,\n    ping_exclude_gAMA,\n    ping_exclude_iCCP,\n    /* ping_exclude_iTXt, */\n    ping_exclude_oFFs,\n    ping_exclude_pHYs,\n    ping_exclude_sRGB,\n    ping_exclude_tEXt,\n    ping_exclude_tIME,\n    /* ping_exclude_tRNS, */\n    ping_exclude_vpAg,\n    ping_exclude_caNv,\n    ping_exclude_zCCP, /* hex-encoded iCCP */\n    ping_exclude_zTXt,\n\n    ping_preserve_colormap,\n    ping_preserve_iCCP,\n    ping_need_colortype_warning,\n\n    status,\n    tried_332,\n    tried_333,\n    tried_444;\n\n  MemoryInfo\n    *volatile pixel_info;\n\n  QuantumInfo\n    *quantum_info;\n\n  PNGErrorInfo\n    error_info;\n\n  register ssize_t\n    i,\n    x;\n\n  unsigned char\n    *ping_pixels;\n\n  volatile int\n    image_colors,\n    ping_bit_depth,\n    ping_color_type,\n    ping_interlace_method,\n    ping_compression_method,\n    ping_filter_method,\n    ping_num_trans;\n\n  volatile size_t\n    image_depth,\n    old_bit_depth;\n\n  size_t\n    quality,\n    rowbytes,\n    save_image_depth;\n\n  int\n    j,\n    number_colors,\n    number_opaque,\n    number_semitransparent,\n    number_transparent,\n    ping_pHYs_unit_type;\n\n  png_uint_32\n    ping_pHYs_x_resolution,\n    ping_pHYs_y_resolution;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n     \"  Enter WriteOnePNGImage()\");\n \n   image = CloneImage(IMimage,0,0,MagickFalse,exception);\n   image_info=(ImageInfo *) CloneImageInfo(IMimage_info);\n   if (image_info == (ImageInfo *) NULL)\n     ThrowWriterException(ResourceLimitError, \"MemoryAllocationFailed\");\n \n   /* Define these outside of the following \"if logging()\" block so they will\n    * show in debuggers.\n   */\n  *im_vers='\\0';\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibVersionText,MagickPathExtent);\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibAddendum,MagickPathExtent);\n\n  *libpng_vers='\\0';\n  (void) ConcatenateMagickString(libpng_vers,\n         PNG_LIBPNG_VER_STRING,32);\n  *libpng_runv='\\0';\n  (void) ConcatenateMagickString(libpng_runv,\n         png_get_libpng_ver(NULL),32);\n\n  *zlib_vers='\\0';\n  (void) ConcatenateMagickString(zlib_vers,\n         ZLIB_VERSION,32);\n  *zlib_runv='\\0';\n  (void) ConcatenateMagickString(zlib_runv,\n         zlib_version,32);\n\n  if (logging != MagickFalse)\n    {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    IM version     = %s\",\n           im_vers);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Libpng version = %s\",\n           libpng_vers);\n       if (LocaleCompare(libpng_vers,libpng_runv) != 0)\n       {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n           libpng_runv);\n       }\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Zlib version   = %s\",\n           zlib_vers);\n       if (LocaleCompare(zlib_vers,zlib_runv) != 0)\n       {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n           zlib_runv);\n       }\n    }\n\n  /* Initialize some stuff */\n  ping_bit_depth=0,\n  ping_color_type=0,\n  ping_interlace_method=0,\n  ping_compression_method=0,\n  ping_filter_method=0,\n  ping_num_trans = 0;\n\n  ping_background.red = 0;\n  ping_background.green = 0;\n  ping_background.blue = 0;\n  ping_background.gray = 0;\n  ping_background.index = 0;\n\n  ping_trans_color.red=0;\n  ping_trans_color.green=0;\n  ping_trans_color.blue=0;\n  ping_trans_color.gray=0;\n\n  ping_pHYs_unit_type = 0;\n  ping_pHYs_x_resolution = 0;\n  ping_pHYs_y_resolution = 0;\n\n  ping_have_blob=MagickFalse;\n  ping_have_cheap_transparency=MagickFalse;\n  ping_have_color=MagickTrue;\n  ping_have_non_bw=MagickTrue;\n  ping_have_PLTE=MagickFalse;\n  ping_have_bKGD=MagickFalse;\n  ping_have_eXIf=MagickTrue;\n  ping_have_iCCP=MagickFalse;\n  ping_have_pHYs=MagickFalse;\n  ping_have_sRGB=MagickFalse;\n  ping_have_tRNS=MagickFalse;\n\n  ping_exclude_bKGD=mng_info->ping_exclude_bKGD;\n  ping_exclude_caNv=mng_info->ping_exclude_caNv;\n  ping_exclude_cHRM=mng_info->ping_exclude_cHRM;\n  ping_exclude_date=mng_info->ping_exclude_date;\n  ping_exclude_eXIf=mng_info->ping_exclude_eXIf;\n  ping_exclude_gAMA=mng_info->ping_exclude_gAMA;\n  ping_exclude_iCCP=mng_info->ping_exclude_iCCP;\n  /* ping_exclude_iTXt=mng_info->ping_exclude_iTXt; */\n  ping_exclude_oFFs=mng_info->ping_exclude_oFFs;\n  ping_exclude_pHYs=mng_info->ping_exclude_pHYs;\n  ping_exclude_sRGB=mng_info->ping_exclude_sRGB;\n  ping_exclude_tEXt=mng_info->ping_exclude_tEXt;\n  ping_exclude_tIME=mng_info->ping_exclude_tIME;\n  /* ping_exclude_tRNS=mng_info->ping_exclude_tRNS; */\n  ping_exclude_vpAg=mng_info->ping_exclude_vpAg;\n  ping_exclude_zCCP=mng_info->ping_exclude_zCCP; /* hex-encoded iCCP in zTXt */\n  ping_exclude_zTXt=mng_info->ping_exclude_zTXt;\n\n  ping_preserve_colormap = mng_info->ping_preserve_colormap;\n  ping_preserve_iCCP = mng_info->ping_preserve_iCCP;\n  ping_need_colortype_warning = MagickFalse;\n\n  /* Recognize the ICC sRGB profile and convert it to the sRGB chunk,\n   * i.e., eliminate the ICC profile and set image->rendering_intent.\n   * Note that this will not involve any changes to the actual pixels\n   * but merely passes information to applications that read the resulting\n   * PNG image.\n   *\n   * To do: recognize other variants of the sRGB profile, using the CRC to\n   * verify all recognized variants including the 7 already known.\n   *\n   * Work around libpng16+ rejecting some \"known invalid sRGB profiles\".\n   *\n   * Use something other than image->rendering_intent to record the fact\n   * that the sRGB profile was found.\n   *\n   * Record the ICC version (currently v2 or v4) of the incoming sRGB ICC\n   * profile.  Record the Blackpoint Compensation, if any.\n   */\n   if (ping_exclude_sRGB == MagickFalse && ping_preserve_iCCP == MagickFalse)\n   {\n      char\n        *name;\n\n      const StringInfo\n        *profile;\n\n      ResetImageProfileIterator(image);\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        profile=GetImageProfile(image,name);\n\n        if (profile != (StringInfo *) NULL)\n          {\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0))\n\n             {\n                 int\n                   icheck,\n                   got_crc=0;\n\n\n                 png_uint_32\n                   length,\n                   profile_crc=0;\n\n                 unsigned char\n                   *data;\n\n                 length=(png_uint_32) GetStringInfoLength(profile);\n\n                 for (icheck=0; sRGB_info[icheck].len > 0; icheck++)\n                 {\n                   if (length == sRGB_info[icheck].len)\n                   {\n                     if (got_crc == 0)\n                     {\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Got a %lu-byte ICC profile (potentially sRGB)\",\n                         (unsigned long) length);\n\n                       data=GetStringInfoDatum(profile);\n                       profile_crc=crc32(0,data,length);\n\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"      with crc=%8x\",(unsigned int) profile_crc);\n                       got_crc++;\n                     }\n\n                     if (profile_crc == sRGB_info[icheck].crc)\n                     {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"      It is sRGB with rendering intent = %s\",\n                        Magick_RenderingIntentString_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent));\n                        if (image->rendering_intent==UndefinedIntent)\n                        {\n                          image->rendering_intent=\n                          Magick_RenderingIntent_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent);\n                        }\n                        ping_exclude_iCCP = MagickTrue;\n                        ping_exclude_zCCP = MagickTrue;\n                        ping_have_sRGB = MagickTrue;\n                        break;\n                     }\n                   }\n                 }\n                 if (sRGB_info[icheck].len == 0)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"    Got %lu-byte ICC profile not recognized as sRGB\",\n                        (unsigned long) length);\n              }\n          }\n        name=GetNextImageProfile(image);\n      }\n  }\n\n  number_opaque = 0;\n  number_semitransparent = 0;\n  number_transparent = 0;\n\n  if (logging != MagickFalse)\n    {\n      if (image->storage_class == UndefinedClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=UndefinedClass\");\n      if (image->storage_class == DirectClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=DirectClass\");\n      if (image->storage_class == PseudoClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=PseudoClass\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(), image->taint ?\n          \"    image->taint=MagickTrue\":\n          \"    image->taint=MagickFalse\");\n    }\n\n  if (image->storage_class == PseudoClass &&\n     (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32 ||\n     mng_info->write_png48 || mng_info->write_png64 ||\n     (mng_info->write_png_colortype != 1 &&\n     mng_info->write_png_colortype != 5)))\n    {\n      (void) SyncImage(image,exception);\n      image->storage_class = DirectClass;\n    }\n\n  if (ping_preserve_colormap == MagickFalse)\n    {\n      if (image->storage_class != PseudoClass && image->colormap != NULL)\n        {\n          /* Free the bogus colormap; it can cause trouble later */\n           if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Freeing bogus colormap\");\n           (void) RelinquishMagickMemory(image->colormap);\n           image->colormap=NULL;\n        }\n    }\n\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n\n  /*\n    Sometimes we get PseudoClass images whose RGB values don't match\n    the colors in the colormap.  This code syncs the RGB values.\n  */\n  if (image->depth <= 8 && image->taint && image->storage_class == PseudoClass)\n     (void) SyncImage(image,exception);\n\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n  if (image->depth > 8)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Reducing PNG bit depth to 8 since this is a Q8 build.\");\n\n      image->depth=8;\n    }\n#endif\n\n  /* Respect the -depth option */\n  if (image->depth < 4)\n    {\n       register Quantum\n         *r;\n\n       if (image->depth > 2)\n         {\n           /* Scale to 4-bit */\n           LBR04PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR04PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR04PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n       else if (image->depth > 1)\n         {\n           /* Scale to 2-bit */\n           LBR02PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR02PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR02PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n       else\n         {\n           /* Scale to 1-bit */\n           LBR01PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR01PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR01PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n    }\n\n  /* To do: set to next higher multiple of 8 */\n  if (image->depth < 8)\n     image->depth=8;\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n  /* PNG does not handle depths greater than 16 so reduce it even\n   * if lossy\n   */\n  if (image->depth > 8)\n      image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\n  if (image->depth > 8)\n    {\n      /* To do: fill low byte properly */\n      image->depth=16;\n    }\n\n  if (image->depth == 16 && mng_info->write_png_depth != 16)\n    if (mng_info->write_png8 ||\n        LosslessReduceDepthOK(image,exception) != MagickFalse)\n      image->depth = 8;\n#endif\n\n  image_colors = (int) image->colors;\n  number_opaque = (int) image->colors;\n  number_transparent = 0;\n  number_semitransparent = 0;\n\n  if (mng_info->write_png_colortype &&\n     (mng_info->write_png_colortype > 4 || (mng_info->write_png_depth >= 8 &&\n     mng_info->write_png_colortype < 4 &&\n     image->alpha_trait == UndefinedPixelTrait)))\n  {\n     /* Avoid the expensive BUILD_PALETTE operation if we're sure that we\n      * are not going to need the result.\n      */\n     if (mng_info->write_png_colortype == 1 ||\n        mng_info->write_png_colortype == 5)\n       ping_have_color=MagickFalse;\n\n     if (image->alpha_trait != UndefinedPixelTrait)\n       {\n         number_transparent = 2;\n         number_semitransparent = 1;\n       }\n  }\n\n  if (mng_info->write_png_colortype < 7)\n  {\n  /* BUILD_PALETTE\n   *\n   * Normally we run this just once, but in the case of writing PNG8\n   * we reduce the transparency to binary and run again, then if there\n   * are still too many colors we reduce to a simple 4-4-4-1, then 3-3-3-1\n   * RGBA palette and run again, and then to a simple 3-3-2-1 RGBA\n   * palette.  Then (To do) we take care of a final reduction that is only\n   * needed if there are still 256 colors present and one of them has both\n   * transparent and opaque instances.\n   */\n\n  tried_332 = MagickFalse;\n  tried_333 = MagickFalse;\n  tried_444 = MagickFalse;\n\n  for (j=0; j<6; j++)\n  {\n    /*\n     * Sometimes we get DirectClass images that have 256 colors or fewer.\n     * This code will build a colormap.\n     *\n     * Also, sometimes we get PseudoClass images with an out-of-date\n     * colormap.  This code will replace the colormap with a new one.\n     * Sometimes we get PseudoClass images that have more than 256 colors.\n     * This code will delete the colormap and change the image to\n     * DirectClass.\n     *\n     * If image->alpha_trait is MagickFalse, we ignore the alpha channel\n     * even though it sometimes contains left-over non-opaque values.\n     *\n     * Also we gather some information (number of opaque, transparent,\n     * and semitransparent pixels, and whether the image has any non-gray\n     * pixels or only black-and-white pixels) that we might need later.\n     *\n     * Even if the user wants to force GrayAlpha or RGBA (colortype 4 or 6)\n     * we need to check for bogus non-opaque values, at least.\n     */\n\n   int\n     n;\n\n   PixelInfo\n     opaque[260],\n     semitransparent[260],\n     transparent[260];\n\n   register const Quantum\n     *s;\n\n   register Quantum\n     *q,\n     *r;\n\n   if (logging != MagickFalse)\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    Enter BUILD_PALETTE:\");\n\n   if (logging != MagickFalse)\n     {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->columns=%.20g\",(double) image->columns);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->rows=%.20g\",(double) image->rows);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->alpha_trait=%.20g\",(double) image->alpha_trait);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->depth=%.20g\",(double) image->depth);\n\n       if (image->storage_class == PseudoClass && image->colormap != NULL)\n       {\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      Original colormap:\");\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"        i    (red,green,blue,alpha)\");\n\n         for (i=0; i < 256; i++)\n         {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"        %d    (%d,%d,%d,%d)\",\n                    (int) i,\n                    (int) image->colormap[i].red,\n                    (int) image->colormap[i].green,\n                    (int) image->colormap[i].blue,\n                    (int) image->colormap[i].alpha);\n         }\n\n         for (i=image->colors - 10; i < (ssize_t) image->colors; i++)\n         {\n           if (i > 255)\n             {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"        %d    (%d,%d,%d,%d)\",\n                    (int) i,\n                    (int) image->colormap[i].red,\n                    (int) image->colormap[i].green,\n                    (int) image->colormap[i].blue,\n                    (int) image->colormap[i].alpha);\n             }\n         }\n       }\n\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"      image->colors=%d\",(int) image->colors);\n\n       if (image->colors == 0)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"        (zero means unknown)\");\n\n       if (ping_preserve_colormap == MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"      Regenerate the colormap\");\n     }\n\n     image_colors=0;\n     number_opaque = 0;\n     number_semitransparent = 0;\n     number_transparent = 0;\n\n     for (y=0; y < (ssize_t) image->rows; y++)\n     {\n       q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n       if (q == (Quantum *) NULL)\n         break;\n\n       for (x=0; x < (ssize_t) image->columns; x++)\n       {\n           if (image->alpha_trait == UndefinedPixelTrait ||\n              GetPixelAlpha(image,q) == OpaqueAlpha)\n             {\n               if (number_opaque < 259)\n                 {\n                   if (number_opaque == 0)\n                     {\n                       GetPixelInfoPixel(image, q, opaque);\n                       opaque[0].alpha=OpaqueAlpha;\n                       number_opaque=1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_opaque; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,opaque+i))\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_opaque && number_opaque < 259)\n                     {\n                       number_opaque++;\n                       GetPixelInfoPixel(image, q, opaque+i);\n                       opaque[i].alpha=OpaqueAlpha;\n                     }\n                 }\n             }\n           else if (GetPixelAlpha(image,q) == TransparentAlpha)\n             {\n               if (number_transparent < 259)\n                 {\n                   if (number_transparent == 0)\n                     {\n                       GetPixelInfoPixel(image, q, transparent);\n                       ping_trans_color.red=(unsigned short)\n                         GetPixelRed(image,q);\n                       ping_trans_color.green=(unsigned short)\n                         GetPixelGreen(image,q);\n                       ping_trans_color.blue=(unsigned short)\n                         GetPixelBlue(image,q);\n                       ping_trans_color.gray=(unsigned short)\n                         GetPixelGray(image,q);\n                       number_transparent = 1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_transparent; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,transparent+i))\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_transparent &&\n                       number_transparent < 259)\n                     {\n                       number_transparent++;\n                       GetPixelInfoPixel(image,q,transparent+i);\n                     }\n                 }\n             }\n           else\n             {\n               if (number_semitransparent < 259)\n                 {\n                   if (number_semitransparent == 0)\n                     {\n                       GetPixelInfoPixel(image,q,semitransparent);\n                       number_semitransparent = 1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_semitransparent; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,semitransparent+i)\n                           && GetPixelAlpha(image,q) ==\n                           semitransparent[i].alpha)\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_semitransparent &&\n                       number_semitransparent < 259)\n                     {\n                       number_semitransparent++;\n                       GetPixelInfoPixel(image, q, semitransparent+i);\n                     }\n                 }\n             }\n           q+=GetPixelChannels(image);\n        }\n     }\n\n     if (mng_info->write_png8 == MagickFalse &&\n         ping_exclude_bKGD == MagickFalse)\n       {\n         /* Add the background color to the palette, if it\n          * isn't already there.\n          */\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      Check colormap for background (%d,%d,%d)\",\n                  (int) image->background_color.red,\n                  (int) image->background_color.green,\n                  (int) image->background_color.blue);\n            }\n          for (i=0; i<number_opaque; i++)\n          {\n             if (opaque[i].red == image->background_color.red &&\n                 opaque[i].green == image->background_color.green &&\n                 opaque[i].blue == image->background_color.blue)\n               break;\n          }\n          if (number_opaque < 259 && i == number_opaque)\n            {\n               opaque[i] = image->background_color;\n               ping_background.index = i;\n               number_opaque++;\n               if (logging != MagickFalse)\n                 {\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"      background_color index is %d\",(int) i);\n                 }\n\n            }\n          else if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      No room in the colormap to add background color\");\n       }\n\n     image_colors=number_opaque+number_transparent+number_semitransparent;\n\n     if (logging != MagickFalse)\n       {\n         if (image_colors > 256)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      image has more than 256 colors\");\n\n         else\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      image has %d colors\",image_colors);\n       }\n\n     if (ping_preserve_colormap != MagickFalse)\n       break;\n\n     if (mng_info->write_png_colortype != 7) /* We won't need this info */\n       {\n         ping_have_color=MagickFalse;\n         ping_have_non_bw=MagickFalse;\n\n         if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n         {\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"incompatible colorspace\");\n           ping_have_color=MagickTrue;\n           ping_have_non_bw=MagickTrue;\n         }\n\n         if(image_colors > 256)\n           {\n             for (y=0; y < (ssize_t) image->rows; y++)\n             {\n               q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n               if (q == (Quantum *) NULL)\n                 break;\n\n               s=q;\n               for (x=0; x < (ssize_t) image->columns; x++)\n               {\n                 if (GetPixelRed(image,s) != GetPixelGreen(image,s) ||\n                     GetPixelRed(image,s) != GetPixelBlue(image,s))\n                   {\n                      ping_have_color=MagickTrue;\n                      ping_have_non_bw=MagickTrue;\n                      break;\n                   }\n                 s+=GetPixelChannels(image);\n               }\n\n               if (ping_have_color != MagickFalse)\n                 break;\n\n               /* Worst case is black-and-white; we are looking at every\n                * pixel twice.\n                */\n\n               if (ping_have_non_bw == MagickFalse)\n                 {\n                   s=q;\n                   for (x=0; x < (ssize_t) image->columns; x++)\n                   {\n                     if (GetPixelRed(image,s) != 0 &&\n                         GetPixelRed(image,s) != QuantumRange)\n                       {\n                         ping_have_non_bw=MagickTrue;\n                         break;\n                       }\n                     s+=GetPixelChannels(image);\n                   }\n               }\n             }\n           }\n       }\n\n     if (image_colors < 257)\n       {\n         PixelInfo\n           colormap[260];\n\n         /*\n          * Initialize image colormap.\n          */\n\n         if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      Sort the new colormap\");\n\n        /* Sort palette, transparent first */;\n\n         n = 0;\n\n         for (i=0; i<number_transparent; i++)\n            colormap[n++] = transparent[i];\n\n         for (i=0; i<number_semitransparent; i++)\n            colormap[n++] = semitransparent[i];\n\n         for (i=0; i<number_opaque; i++)\n            colormap[n++] = opaque[i];\n\n         ping_background.index +=\n           (number_transparent + number_semitransparent);\n\n         /* image_colors < 257; search the colormap instead of the pixels\n          * to get ping_have_color and ping_have_non_bw\n          */\n         for (i=0; i<n; i++)\n         {\n           if (ping_have_color == MagickFalse)\n             {\n                if (colormap[i].red != colormap[i].green ||\n                    colormap[i].red != colormap[i].blue)\n                  {\n                     ping_have_color=MagickTrue;\n                     ping_have_non_bw=MagickTrue;\n                     break;\n                  }\n              }\n\n           if (ping_have_non_bw == MagickFalse)\n             {\n               if (colormap[i].red != 0 && colormap[i].red != QuantumRange)\n                   ping_have_non_bw=MagickTrue;\n             }\n          }\n\n        if ((mng_info->ping_exclude_tRNS == MagickFalse ||\n            (number_transparent == 0 && number_semitransparent == 0)) &&\n            (((mng_info->write_png_colortype-1) ==\n            PNG_COLOR_TYPE_PALETTE) ||\n            (mng_info->write_png_colortype == 0)))\n          {\n            if (logging != MagickFalse)\n              {\n                if (n !=  (ssize_t) image_colors)\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"   image_colors (%d) and n (%d)  don't match\",\n                   image_colors, n);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      AcquireImageColormap\");\n              }\n\n            image->colors = image_colors;\n\n            if (AcquireImageColormap(image,image_colors,exception) ==\n                MagickFalse)\n               ThrowWriterException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");\n\n            for (i=0; i< (ssize_t) image_colors; i++)\n               image->colormap[i] = colormap[i];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"      image->colors=%d (%d)\",\n                      (int) image->colors, image_colors);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"      Update the pixel indexes\");\n              }\n\n            /* Sync the pixel indices with the new colormap */\n\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n              if (q == (Quantum *) NULL)\n                break;\n\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                for (i=0; i< (ssize_t) image_colors; i++)\n                {\n                  if ((image->alpha_trait == UndefinedPixelTrait ||\n                      image->colormap[i].alpha == GetPixelAlpha(image,q)) &&\n                      image->colormap[i].red == GetPixelRed(image,q) &&\n                      image->colormap[i].green == GetPixelGreen(image,q) &&\n                      image->colormap[i].blue == GetPixelBlue(image,q))\n                  {\n                    SetPixelIndex(image,i,q);\n                    break;\n                  }\n                }\n                q+=GetPixelChannels(image);\n              }\n\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                 break;\n            }\n          }\n       }\n\n     if (logging != MagickFalse)\n       {\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      image->colors=%d\", (int) image->colors);\n\n         if (image->colormap != NULL)\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"       i     (red,green,blue,alpha)\");\n\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               if (i < 300 || i >= (ssize_t) image->colors - 10)\n                 {\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"       %d     (%d,%d,%d,%d)\",\n                        (int) i,\n                        (int) image->colormap[i].red,\n                        (int) image->colormap[i].green,\n                        (int) image->colormap[i].blue,\n                        (int) image->colormap[i].alpha);\n                 }\n             }\n           }\n\n           if (number_transparent < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_transparent     = %d\",\n                   number_transparent);\n           else\n\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_transparent     > 256\");\n\n           if (number_opaque < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_opaque          = %d\",\n                   number_opaque);\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_opaque          > 256\");\n\n           if (number_semitransparent < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_semitransparent = %d\",\n                   number_semitransparent);\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_semitransparent > 256\");\n\n           if (ping_have_non_bw == MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      All pixels and the background are black or white\");\n\n           else if (ping_have_color == MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      All pixels and the background are gray\");\n\n           else\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      At least one pixel or the background is non-gray\");\n\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Exit BUILD_PALETTE:\");\n       }\n\n   if (mng_info->write_png8 == MagickFalse)\n      break;\n\n   /* Make any reductions necessary for the PNG8 format */\n    if (image_colors <= 256 &&\n        image_colors != 0 && image->colormap != NULL &&\n        number_semitransparent == 0 &&\n        number_transparent <= 1)\n      break;\n\n    /* PNG8 can't have semitransparent colors so we threshold the\n     * opacity to 0 or OpaqueOpacity, and PNG8 can only have one\n     * transparent color so if more than one is transparent we merge\n     * them into image->background_color.\n     */\n    if (number_semitransparent != 0 || number_transparent > 1)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Thresholding the alpha channel to binary\");\n\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (r == (Quantum *) NULL)\n            break;\n\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n              if (GetPixelAlpha(image,r) < OpaqueAlpha/2)\n                {\n                  SetPixelViaPixelInfo(image,&image->background_color,r);\n                  SetPixelAlpha(image,TransparentAlpha,r);\n                }\n              else\n                  SetPixelAlpha(image,OpaqueAlpha,r);\n              r+=GetPixelChannels(image);\n          }\n\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n\n          if (image_colors != 0 && image_colors <= 256 &&\n             image->colormap != NULL)\n            for (i=0; i<image_colors; i++)\n                image->colormap[i].alpha =\n                    (image->colormap[i].alpha > TransparentAlpha/2 ?\n                    TransparentAlpha : OpaqueAlpha);\n        }\n      continue;\n    }\n\n    /* PNG8 can't have more than 256 colors so we quantize the pixels and\n     * background color to the 4-4-4-1, 3-3-3-1 or 3-3-2-1 palette.  If the\n     * image is mostly gray, the 4-4-4-1 palette is likely to end up with 256\n     * colors or less.\n     */\n    if (tried_444 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 4-4-4\");\n\n        tried_444 = MagickTrue;\n\n        LBR04PacketRGB(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 4-4-4\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR04PixelRGB(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 4-4-4\");\n\n          for (i=0; i<image_colors; i++)\n          {\n            LBR04PacketRGB(image->colormap[i]);\n          }\n        }\n        continue;\n      }\n\n    if (tried_333 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 3-3-3\");\n\n        tried_333 = MagickTrue;\n\n        LBR03PacketRGB(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 3-3-3-1\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR03RGB(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 3-3-3-1\");\n          for (i=0; i<image_colors; i++)\n          {\n              LBR03PacketRGB(image->colormap[i]);\n          }\n        }\n        continue;\n      }\n\n    if (tried_332 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 3-3-2\");\n\n        tried_332 = MagickTrue;\n\n        /* Red and green were already done so we only quantize the blue\n         * channel\n         */\n\n        LBR02PacketBlue(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 3-3-2-1\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR02PixelBlue(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 3-3-2-1\");\n          for (i=0; i<image_colors; i++)\n          {\n              LBR02PacketBlue(image->colormap[i]);\n          }\n      }\n      continue;\n    }\n\n    if (image_colors == 0 || image_colors > 256)\n    {\n      /* Take care of special case with 256 opaque colors + 1 transparent\n       * color.  We don't need to quantize to 2-3-2-1; we only need to\n       * eliminate one color, so we'll merge the two darkest red\n       * colors (0x49, 0, 0) -> (0x24, 0, 0).\n       */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Merging two dark red background colors to 3-3-2-1\");\n\n      if (ScaleQuantumToChar(image->background_color.red) == 0x49 &&\n          ScaleQuantumToChar(image->background_color.green) == 0x00 &&\n          ScaleQuantumToChar(image->background_color.blue) == 0x00)\n      {\n         image->background_color.red=ScaleCharToQuantum(0x24);\n      }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Merging two dark red pixel colors to 3-3-2-1\");\n\n      if (image->colormap == NULL)\n      {\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (r == (Quantum *) NULL)\n            break;\n\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (ScaleQuantumToChar(GetPixelRed(image,r)) == 0x49 &&\n                ScaleQuantumToChar(GetPixelGreen(image,r)) == 0x00 &&\n                ScaleQuantumToChar(GetPixelBlue(image,r)) == 0x00 &&\n                GetPixelAlpha(image,r) == OpaqueAlpha)\n              {\n                SetPixelRed(image,ScaleCharToQuantum(0x24),r);\n              }\n            r+=GetPixelChannels(image);\n          }\n\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n\n        }\n      }\n\n      else\n      {\n         for (i=0; i<image_colors; i++)\n         {\n            if (ScaleQuantumToChar(image->colormap[i].red) == 0x49 &&\n                ScaleQuantumToChar(image->colormap[i].green) == 0x00 &&\n                ScaleQuantumToChar(image->colormap[i].blue) == 0x00)\n            {\n               image->colormap[i].red=ScaleCharToQuantum(0x24);\n            }\n         }\n      }\n    }\n  }\n  }\n  /* END OF BUILD_PALETTE */\n\n  /* If we are excluding the tRNS chunk and there is transparency,\n   * then we must write a Gray-Alpha (color-type 4) or RGBA (color-type 6)\n   * PNG.\n   */\n  if (mng_info->ping_exclude_tRNS != MagickFalse &&\n     (number_transparent != 0 || number_semitransparent != 0))\n    {\n      unsigned int colortype=mng_info->write_png_colortype;\n\n      if (ping_have_color == MagickFalse)\n        mng_info->write_png_colortype = 5;\n\n      else\n        mng_info->write_png_colortype = 7;\n\n      if (colortype != 0 &&\n         mng_info->write_png_colortype != colortype)\n        ping_need_colortype_warning=MagickTrue;\n\n    }\n\n  /* See if cheap transparency is possible.  It is only possible\n   * when there is a single transparent color, no semitransparent\n   * color, and no opaque color that has the same RGB components\n   * as the transparent color.  We only need this information if\n   * we are writing a PNG with colortype 0 or 2, and we have not\n   * excluded the tRNS chunk.\n   */\n  if (number_transparent == 1 &&\n      mng_info->write_png_colortype < 4)\n    {\n       ping_have_cheap_transparency = MagickTrue;\n\n       if (number_semitransparent != 0)\n         ping_have_cheap_transparency = MagickFalse;\n\n       else if (image_colors == 0 || image_colors > 256 ||\n           image->colormap == NULL)\n         {\n           register const Quantum\n             *q;\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             q=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n             if (q == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                 if (GetPixelAlpha(image,q) != TransparentAlpha &&\n                     (unsigned short) GetPixelRed(image,q) ==\n                                     ping_trans_color.red &&\n                     (unsigned short) GetPixelGreen(image,q) ==\n                                     ping_trans_color.green &&\n                     (unsigned short) GetPixelBlue(image,q) ==\n                                     ping_trans_color.blue)\n                   {\n                     ping_have_cheap_transparency = MagickFalse;\n                     break;\n                   }\n\n                 q+=GetPixelChannels(image);\n             }\n\n             if (ping_have_cheap_transparency == MagickFalse)\n                break;\n           }\n         }\n       else\n         {\n            /* Assuming that image->colormap[0] is the one transparent color\n             * and that all others are opaque.\n             */\n            if (image_colors > 1)\n              for (i=1; i<image_colors; i++)\n                if (image->colormap[i].red == image->colormap[0].red &&\n                    image->colormap[i].green == image->colormap[0].green &&\n                    image->colormap[i].blue == image->colormap[0].blue)\n                  {\n                     ping_have_cheap_transparency = MagickFalse;\n                     break;\n                  }\n         }\n\n       if (logging != MagickFalse)\n         {\n           if (ping_have_cheap_transparency == MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"   Cheap transparency is not possible.\");\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"   Cheap transparency is possible.\");\n         }\n     }\n  else\n    ping_have_cheap_transparency = MagickFalse;\n\n  image_depth=image->depth;\n\n  quantum_info = (QuantumInfo *) NULL;\n  number_colors=0;\n  image_colors=(int) image->colors;\n  image_matte=image->alpha_trait !=\n        UndefinedPixelTrait ? MagickTrue : MagickFalse;\n\n  if (mng_info->write_png_colortype < 5)\n    mng_info->IsPalette=image->storage_class == PseudoClass &&\n      image_colors <= 256 && image->colormap != NULL;\n  else\n    mng_info->IsPalette = MagickFalse;\n\n  if ((mng_info->write_png_colortype == 4 || mng_info->write_png8) &&\n     (image->colors == 0 || image->colormap == NULL))\n    {\n      image_info=DestroyImageInfo(image_info);\n      image=DestroyImage(image);\n      (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          \"Cannot write PNG8 or color-type 3; colormap is NULL\",\n          \"`%s'\",IMimage->filename);\n      return(MagickFalse);\n    }\n\n  /*\n    Allocate the PNG structures\n  */\n#ifdef PNG_USER_MEM_SUPPORTED\n error_info.image=image;\n error_info.exception=exception;\n  ping=png_create_write_struct_2(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler,(void *) NULL,\n    (png_malloc_ptr) Magick_png_malloc,(png_free_ptr) Magick_png_free);\n\n#else\n  ping=png_create_write_struct(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler);\n\n#endif\n  if (ping == (png_struct *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  ping_info=png_create_info_struct(ping);\n\n  if (ping_info == (png_info *) NULL)\n    {\n      png_destroy_write_struct(&ping,(png_info **) NULL);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n\n  png_set_write_fn(ping,image,png_put_data,png_flush_data);\n  pixel_info=(MemoryInfo *) NULL;\n\n  if (setjmp(png_jmpbuf(ping)))\n    {\n      /*\n        PNG write failed.\n      */\n#ifdef PNG_DEBUG\n     if (image_info->verbose)\n        (void) printf(\"PNG write has failed.\\n\");\n#endif\n      png_destroy_write_struct(&ping,&ping_info);\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n      UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n      if (pixel_info != (MemoryInfo *) NULL)\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n\n      if (quantum_info != (QuantumInfo *) NULL)\n        quantum_info=DestroyQuantumInfo(quantum_info);\n\n      if (ping_have_blob != MagickFalse)\n          (void) CloseBlob(image);\n      image_info=DestroyImageInfo(image_info);\n      image=DestroyImage(image);\n      return(MagickFalse);\n    }\n\n  /* {  For navigation to end of SETJMP-protected block.  Within this\n   *    block, use png_error() instead of Throwing an Exception, to ensure\n   *    that libpng is able to clean up, and that the semaphore is unlocked.\n   */\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  LockSemaphoreInfo(ping_semaphore);\n#endif\n\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\n  /* Allow benign errors */\n  png_set_benign_errors(ping, 1);\n#endif\n\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n  /* Reject images with too many rows or columns */\n  png_set_user_limits(ping,\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(WidthResource)),\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(HeightResource)));\n#endif /* PNG_SET_USER_LIMITS_SUPPORTED */\n\n  /*\n    Prepare PNG for writing.\n  */\n\n#if defined(PNG_MNG_FEATURES_SUPPORTED)\n  if (mng_info->write_mng)\n  {\n     (void) png_permit_mng_features(ping,PNG_ALL_MNG_FEATURES);\n# ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED\n     /* Disable new libpng-1.5.10 feature when writing a MNG because\n      * zero-length PLTE is OK\n      */\n     png_set_check_for_invalid_index (ping, 0);\n# endif\n  }\n\n#else\n# ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED\n  if (mng_info->write_mng)\n     png_permit_empty_plte(ping,MagickTrue);\n\n# endif\n#endif\n\n  x=0;\n\n  ping_width=(png_uint_32) image->columns;\n  ping_height=(png_uint_32) image->rows;\n\n  if (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32)\n     image_depth=8;\n\n  if (mng_info->write_png48 || mng_info->write_png64)\n     image_depth=16;\n\n  if (mng_info->write_png_depth != 0)\n     image_depth=mng_info->write_png_depth;\n\n  /* Adjust requested depth to next higher valid depth if necessary */\n  if (image_depth > 8)\n     image_depth=16;\n\n  if ((image_depth > 4) && (image_depth < 8))\n     image_depth=8;\n\n  if (image_depth == 3)\n     image_depth=4;\n\n  if (logging != MagickFalse)\n    {\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    width=%.20g\",(double) ping_width);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    height=%.20g\",(double) ping_height);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_matte=%.20g\",(double) image->alpha_trait);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image->depth=%.20g\",(double) image->depth);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Tentative ping_bit_depth=%.20g\",(double) image_depth);\n    }\n\n  save_image_depth=image_depth;\n  ping_bit_depth=(png_byte) save_image_depth;\n\n\n#if defined(PNG_pHYs_SUPPORTED)\n  if (ping_exclude_pHYs == MagickFalse)\n  {\n  if ((image->resolution.x != 0) && (image->resolution.y != 0) &&\n      (!mng_info->write_mng || !mng_info->equal_physs))\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Setting up pHYs chunk\");\n\n      if (image->units == PixelsPerInchResolution)\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_METER;\n          ping_pHYs_x_resolution=\n             (png_uint_32) ((100.0*image->resolution.x+0.5)/2.54);\n          ping_pHYs_y_resolution=\n             (png_uint_32) ((100.0*image->resolution.y+0.5)/2.54);\n        }\n\n      else if (image->units == PixelsPerCentimeterResolution)\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_METER;\n          ping_pHYs_x_resolution=(png_uint_32) (100.0*image->resolution.x+0.5);\n          ping_pHYs_y_resolution=(png_uint_32) (100.0*image->resolution.y+0.5);\n        }\n\n      else\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_UNKNOWN;\n          ping_pHYs_x_resolution=(png_uint_32) image->resolution.x;\n          ping_pHYs_y_resolution=(png_uint_32) image->resolution.y;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Set up PNG pHYs chunk: xres: %.20g, yres: %.20g, units: %d.\",\n          (double) ping_pHYs_x_resolution,(double) ping_pHYs_y_resolution,\n          (int) ping_pHYs_unit_type);\n       ping_have_pHYs = MagickTrue;\n    }\n  }\n#endif\n\n  if (ping_exclude_bKGD == MagickFalse)\n  {\n  if ((!mng_info->adjoin || !mng_info->equal_backgrounds))\n    {\n       unsigned int\n         mask;\n\n       mask=0xffff;\n       if (ping_bit_depth == 8)\n          mask=0x00ff;\n\n       if (ping_bit_depth == 4)\n          mask=0x000f;\n\n       if (ping_bit_depth == 2)\n          mask=0x0003;\n\n       if (ping_bit_depth == 1)\n          mask=0x0001;\n\n       ping_background.red=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.red) & mask);\n\n       ping_background.green=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.green) & mask);\n\n       ping_background.blue=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.blue) & mask);\n\n       ping_background.gray=(png_uint_16) ping_background.green;\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Setting up bKGD chunk (1)\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"      background_color index is %d\",\n          (int) ping_background.index);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    ping_bit_depth=%d\",ping_bit_depth);\n    }\n\n  ping_have_bKGD = MagickTrue;\n  }\n\n  /*\n    Select the color type.\n  */\n  matte=image_matte;\n  old_bit_depth=0;\n\n  if (mng_info->IsPalette && mng_info->write_png8)\n    {\n      /* To do: make this a function cause it's used twice, except\n         for reducing the sample depth from 8. */\n\n      number_colors=image_colors;\n\n      ping_have_tRNS=MagickFalse;\n\n      /*\n        Set image palette.\n      */\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Setting up PLTE chunk with %d colors (%d)\",\n            number_colors, image_colors);\n\n      for (i=0; i < (ssize_t) number_colors; i++)\n      {\n        palette[i].red=ScaleQuantumToChar(image->colormap[i].red);\n        palette[i].green=ScaleQuantumToChar(image->colormap[i].green);\n        palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n#if MAGICKCORE_QUANTUM_DEPTH == 8\n            \"    %3ld (%3d,%3d,%3d)\",\n#else\n            \"    %5ld (%5d,%5d,%5d)\",\n#endif\n            (long) i,palette[i].red,palette[i].green,palette[i].blue);\n\n      }\n\n      ping_have_PLTE=MagickTrue;\n      image_depth=ping_bit_depth;\n      ping_num_trans=0;\n\n      if (matte != MagickFalse)\n      {\n          /*\n            Identify which colormap entry is transparent.\n          */\n          assert(number_colors <= 256);\n          assert(image->colormap != NULL);\n\n          for (i=0; i < (ssize_t) number_transparent; i++)\n             ping_trans_alpha[i]=0;\n\n\n          ping_num_trans=(unsigned short) (number_transparent +\n             number_semitransparent);\n\n          if (ping_num_trans == 0)\n             ping_have_tRNS=MagickFalse;\n\n          else\n             ping_have_tRNS=MagickTrue;\n      }\n\n      if (ping_exclude_bKGD == MagickFalse)\n      {\n       /*\n        * Identify which colormap entry is the background color.\n        */\n\n        for (i=0; i < (ssize_t) MagickMax(1L*number_colors-1L,1L); i++)\n          if (IsPNGColorEqual(ping_background,image->colormap[i]))\n            break;\n\n        ping_background.index=(png_byte) i;\n\n        if (logging != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"      background_color index is %d\",\n                 (int) ping_background.index);\n          }\n      }\n    } /* end of write_png8 */\n\n  else if (mng_info->write_png_colortype == 1)\n    {\n      image_matte=MagickFalse;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;\n    }\n\n  else if (mng_info->write_png24 || mng_info->write_png48 ||\n      mng_info->write_png_colortype == 3)\n    {\n      image_matte=MagickFalse;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n    }\n\n  else if (mng_info->write_png32 || mng_info->write_png64 ||\n      mng_info->write_png_colortype == 7)\n    {\n      image_matte=MagickTrue;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;\n    }\n\n  else /* mng_info->write_pngNN not specified */\n    {\n      image_depth=ping_bit_depth;\n\n      if (mng_info->write_png_colortype != 0)\n        {\n          ping_color_type=(png_byte) mng_info->write_png_colortype-1;\n\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\n              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            image_matte=MagickTrue;\n\n          else\n            image_matte=MagickFalse;\n\n          if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"   PNG colortype %d was specified:\",(int) ping_color_type);\n        }\n\n      else /* write_png_colortype not specified */\n        {\n          if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Selecting PNG colortype:\");\n\n          ping_color_type=(png_byte) ((matte != MagickFalse)?\n            PNG_COLOR_TYPE_RGB_ALPHA:PNG_COLOR_TYPE_RGB);\n\n          if (image_info->type == TrueColorType)\n            {\n              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n              image_matte=MagickFalse;\n            }\n\n          if (image_info->type == TrueColorAlphaType)\n            {\n              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;\n              image_matte=MagickTrue;\n            }\n\n          if (image_info->type == PaletteType ||\n              image_info->type == PaletteAlphaType)\n            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n          if (mng_info->write_png_colortype == 0 &&\n             image_info->type == UndefinedType)\n            {\n              if (ping_have_color == MagickFalse)\n                {\n                  if (image_matte == MagickFalse)\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;\n                      image_matte=MagickFalse;\n                    }\n\n                  else\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY_ALPHA;\n                      image_matte=MagickTrue;\n                    }\n                }\n              else\n                {\n                  if (image_matte == MagickFalse)\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n                      image_matte=MagickFalse;\n                    }\n\n                  else\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGBA;\n                      image_matte=MagickTrue;\n                    }\n                 }\n            }\n\n        }\n\n      if (logging != MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    Selected PNG colortype=%d\",ping_color_type);\n\n      if (ping_bit_depth < 8)\n        {\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\n              ping_color_type == PNG_COLOR_TYPE_RGB ||\n              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            ping_bit_depth=8;\n        }\n\n      old_bit_depth=ping_bit_depth;\n\n      if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n        {\n          if (image->alpha_trait == UndefinedPixelTrait &&\n               ping_have_non_bw == MagickFalse)\n             ping_bit_depth=1;\n        }\n\n      if (ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        {\n           size_t one = 1;\n           ping_bit_depth=1;\n\n           if (image->colors == 0)\n           {\n              /* DO SOMETHING */\n                png_error(ping,\"image has 0 colors\");\n           }\n\n           while ((int) (one << ping_bit_depth) < (ssize_t) image_colors)\n             ping_bit_depth <<= 1;\n        }\n\n      if (logging != MagickFalse)\n         {\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Number of colors: %.20g\",(double) image_colors);\n\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Tentative PNG bit depth: %d\",ping_bit_depth);\n         }\n\n      if (ping_bit_depth < (int) mng_info->write_png_depth)\n         ping_bit_depth = mng_info->write_png_depth;\n    }\n\n  image_depth=ping_bit_depth;\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Tentative PNG color type: %s (%.20g)\",\n        PngColorTypeToString(ping_color_type),\n        (double) ping_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_info->type: %.20g\",(double) image_info->type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_depth: %.20g\",(double) image_depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\n        \"    image->depth: %.20g\",(double) image->depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    ping_bit_depth: %.20g\",(double) ping_bit_depth);\n    }\n\n  if (matte != MagickFalse)\n    {\n      if (mng_info->IsPalette)\n        {\n          if (mng_info->write_png_colortype == 0)\n            {\n              ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;\n\n              if (ping_have_color != MagickFalse)\n                 ping_color_type=PNG_COLOR_TYPE_RGBA;\n            }\n\n          /*\n           * Determine if there is any transparent color.\n          */\n          if (number_transparent + number_semitransparent == 0)\n            {\n              /*\n                No transparent pixels are present.  Change 4 or 6 to 0 or 2.\n              */\n\n              image_matte=MagickFalse;\n\n              if (mng_info->write_png_colortype == 0)\n                ping_color_type&=0x03;\n            }\n\n          else\n            {\n              unsigned int\n                mask;\n\n              mask=0xffff;\n\n              if (ping_bit_depth == 8)\n                 mask=0x00ff;\n\n              if (ping_bit_depth == 4)\n                 mask=0x000f;\n\n              if (ping_bit_depth == 2)\n                 mask=0x0003;\n\n              if (ping_bit_depth == 1)\n                 mask=0x0001;\n\n              ping_trans_color.red=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].red) & mask);\n\n              ping_trans_color.green=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].green) & mask);\n\n              ping_trans_color.blue=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].blue) & mask);\n\n              ping_trans_color.gray=(png_uint_16)\n                (ScaleQuantumToShort(GetPixelInfoIntensity(image,\n                   image->colormap)) & mask);\n\n              ping_trans_color.index=(png_byte) 0;\n\n              ping_have_tRNS=MagickTrue;\n            }\n\n          if (ping_have_tRNS != MagickFalse)\n            {\n              /*\n               * Determine if there is one and only one transparent color\n               * and if so if it is fully transparent.\n               */\n              if (ping_have_cheap_transparency == MagickFalse)\n                ping_have_tRNS=MagickFalse;\n            }\n\n          if (ping_have_tRNS != MagickFalse)\n            {\n              if (mng_info->write_png_colortype == 0)\n                ping_color_type &= 0x03;  /* changes 4 or 6 to 0 or 2 */\n\n              if (image_depth == 8)\n                {\n                  ping_trans_color.red&=0xff;\n                  ping_trans_color.green&=0xff;\n                  ping_trans_color.blue&=0xff;\n                  ping_trans_color.gray&=0xff;\n                }\n            }\n        }\n      else\n        {\n          if (image_depth == 8)\n            {\n              ping_trans_color.red&=0xff;\n              ping_trans_color.green&=0xff;\n              ping_trans_color.blue&=0xff;\n              ping_trans_color.gray&=0xff;\n            }\n        }\n    }\n\n    matte=image_matte;\n\n    if (ping_have_tRNS != MagickFalse)\n      image_matte=MagickFalse;\n\n    if ((mng_info->IsPalette) &&\n        mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE &&\n        ping_have_color == MagickFalse &&\n        (image_matte == MagickFalse || image_depth >= 8))\n      {\n        size_t one=1;\n\n        if (image_matte != MagickFalse)\n          ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;\n\n        else if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_GRAY_ALPHA)\n          {\n            ping_color_type=PNG_COLOR_TYPE_GRAY;\n\n            if (save_image_depth == 16 && image_depth == 8)\n              {\n                if (logging != MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Scaling ping_trans_color (0)\");\n                  }\n                    ping_trans_color.gray*=0x0101;\n              }\n          }\n\n        if (image_depth > MAGICKCORE_QUANTUM_DEPTH)\n          image_depth=MAGICKCORE_QUANTUM_DEPTH;\n\n        if ((image_colors == 0) ||\n             ((ssize_t) (image_colors-1) > (ssize_t) MaxColormapSize))\n          image_colors=(int) (one << image_depth);\n\n        if (image_depth > 8)\n          ping_bit_depth=16;\n\n        else\n          {\n            ping_bit_depth=8;\n            if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n              {\n                if(!mng_info->write_png_depth)\n                  {\n                    ping_bit_depth=1;\n\n                    while ((int) (one << ping_bit_depth)\n                        < (ssize_t) image_colors)\n                      ping_bit_depth <<= 1;\n                  }\n              }\n\n            else if (ping_color_type ==\n                PNG_COLOR_TYPE_GRAY && image_colors < 17 &&\n                mng_info->IsPalette)\n              {\n              /* Check if grayscale is reducible */\n\n                int\n                  depth_4_ok=MagickTrue,\n                  depth_2_ok=MagickTrue,\n                  depth_1_ok=MagickTrue;\n\n                for (i=0; i < (ssize_t) image_colors; i++)\n                {\n                   unsigned char\n                     intensity;\n\n                   intensity=ScaleQuantumToChar(image->colormap[i].red);\n\n                   if ((intensity & 0x0f) != ((intensity & 0xf0) >> 4))\n                     depth_4_ok=depth_2_ok=depth_1_ok=MagickFalse;\n                   else if ((intensity & 0x03) != ((intensity & 0x0c) >> 2))\n                     depth_2_ok=depth_1_ok=MagickFalse;\n                   else if ((intensity & 0x01) != ((intensity & 0x02) >> 1))\n                     depth_1_ok=MagickFalse;\n                }\n\n                if (depth_1_ok && mng_info->write_png_depth <= 1)\n                  ping_bit_depth=1;\n\n                else if (depth_2_ok && mng_info->write_png_depth <= 2)\n                  ping_bit_depth=2;\n\n                else if (depth_4_ok && mng_info->write_png_depth <= 4)\n                  ping_bit_depth=4;\n              }\n          }\n\n          image_depth=ping_bit_depth;\n      }\n\n    else\n\n      if (mng_info->IsPalette)\n      {\n        number_colors=image_colors;\n\n        if (image_depth <= 8)\n          {\n            /*\n              Set image palette.\n            */\n            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n            if (!(mng_info->have_write_global_plte && matte == MagickFalse))\n              {\n                for (i=0; i < (ssize_t) number_colors; i++)\n                {\n                  palette[i].red=ScaleQuantumToChar(image->colormap[i].red);\n                  palette[i].green=\n                    ScaleQuantumToChar(image->colormap[i].green);\n                  palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);\n                }\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Setting up PLTE chunk with %d colors\",\n                    number_colors);\n\n                ping_have_PLTE=MagickTrue;\n              }\n\n            /* color_type is PNG_COLOR_TYPE_PALETTE */\n            if (mng_info->write_png_depth == 0)\n              {\n                size_t\n                  one;\n\n                ping_bit_depth=1;\n                one=1;\n\n                while ((one << ping_bit_depth) < (size_t) number_colors)\n                  ping_bit_depth <<= 1;\n              }\n\n            ping_num_trans=0;\n\n            if (matte != MagickFalse)\n              {\n                /*\n                 * Set up trans_colors array.\n                 */\n                assert(number_colors <= 256);\n\n                ping_num_trans=(unsigned short) (number_transparent +\n                  number_semitransparent);\n\n                if (ping_num_trans == 0)\n                  ping_have_tRNS=MagickFalse;\n\n                else\n                  {\n                    if (logging != MagickFalse)\n                      {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Scaling ping_trans_color (1)\");\n                      }\n                    ping_have_tRNS=MagickTrue;\n\n                    for (i=0; i < ping_num_trans; i++)\n                    {\n                       ping_trans_alpha[i]= (png_byte)\n                         ScaleQuantumToChar(image->colormap[i].alpha);\n                    }\n                  }\n              }\n          }\n      }\n\n    else\n      {\n\n        if (image_depth < 8)\n          image_depth=8;\n\n        if ((save_image_depth == 16) && (image_depth == 8))\n          {\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Scaling ping_trans_color from (%d,%d,%d)\",\n                  (int) ping_trans_color.red,\n                  (int) ping_trans_color.green,\n                  (int) ping_trans_color.blue);\n              }\n\n            ping_trans_color.red*=0x0101;\n            ping_trans_color.green*=0x0101;\n            ping_trans_color.blue*=0x0101;\n            ping_trans_color.gray*=0x0101;\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    to (%d,%d,%d)\",\n                  (int) ping_trans_color.red,\n                  (int) ping_trans_color.green,\n                  (int) ping_trans_color.blue);\n              }\n          }\n      }\n\n    if (ping_bit_depth <  (ssize_t) mng_info->write_png_depth)\n         ping_bit_depth =  (ssize_t) mng_info->write_png_depth;\n\n    /*\n      Adjust background and transparency samples in sub-8-bit grayscale files.\n    */\n    if (ping_bit_depth < 8 && ping_color_type ==\n        PNG_COLOR_TYPE_GRAY)\n      {\n         png_uint_16\n           maxval;\n\n         size_t\n           one=1;\n\n         maxval=(png_uint_16) ((one << ping_bit_depth)-1);\n\n         if (ping_exclude_bKGD == MagickFalse)\n         {\n\n         ping_background.gray=(png_uint_16) ((maxval/65535.)*\n           (ScaleQuantumToShort(((GetPixelInfoIntensity(image,\n           &image->background_color))) +.5)));\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Setting up bKGD chunk (2)\");\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      background_color index is %d\",\n             (int) ping_background.index);\n\n         ping_have_bKGD = MagickTrue;\n         }\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Scaling ping_trans_color.gray from %d\",\n             (int)ping_trans_color.gray);\n\n         ping_trans_color.gray=(png_uint_16) ((maxval/255.)*(\n           ping_trans_color.gray)+.5);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      to %d\", (int)ping_trans_color.gray);\n      }\n\n  if (ping_exclude_bKGD == MagickFalse)\n  {\n    if (mng_info->IsPalette && (int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n      {\n        /*\n           Identify which colormap entry is the background color.\n        */\n\n        number_colors=image_colors;\n\n        for (i=0; i < (ssize_t) MagickMax(1L*number_colors,1L); i++)\n          if (IsPNGColorEqual(image->background_color,image->colormap[i]))\n            break;\n\n        ping_background.index=(png_byte) i;\n\n        if (logging != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Setting up bKGD chunk with index=%d\",(int) i);\n          }\n\n        if (i < (ssize_t) number_colors)\n          {\n            ping_have_bKGD = MagickTrue;\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"     background   =(%d,%d,%d)\",\n                        (int) ping_background.red,\n                        (int) ping_background.green,\n                        (int) ping_background.blue);\n              }\n          }\n\n        else  /* Can't happen */\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      No room in PLTE to add bKGD color\");\n            ping_have_bKGD = MagickFalse;\n          }\n      }\n  }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    PNG color type: %s (%d)\", PngColorTypeToString(ping_color_type),\n      ping_color_type);\n  /*\n    Initialize compression level and filtering.\n  */\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Setting up deflate compression\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Compression buffer size: 32768\");\n    }\n\n  png_set_compression_buffer_size(ping,32768L);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Compression mem level: 9\");\n\n  png_set_compression_mem_level(ping, 9);\n\n  /* Untangle the \"-quality\" setting:\n\n     Undefined is 0; the default is used.\n     Default is 75\n\n     10's digit:\n\n        0 or omitted: Use Z_HUFFMAN_ONLY strategy with the\n           zlib default compression level\n\n        1-9: the zlib compression level\n\n     1's digit:\n\n        0-4: the PNG filter method\n\n        5:   libpng adaptive filtering if compression level > 5\n             libpng filter type \"none\" if compression level <= 5\n                or if image is grayscale or palette\n\n        6:   libpng adaptive filtering\n\n        7:   \"LOCO\" filtering (intrapixel differing) if writing\n             a MNG, otherwise \"none\".  Did not work in IM-6.7.0-9\n             and earlier because of a missing \"else\".\n\n        8:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), adaptive\n             filtering. Unused prior to IM-6.7.0-10, was same as 6\n\n        9:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), no PNG filters\n             Unused prior to IM-6.7.0-10, was same as 6\n\n    Note that using the -quality option, not all combinations of\n    PNG filter type, zlib compression level, and zlib compression\n    strategy are possible.  This will be addressed soon in a\n    release that accomodates \"-define png:compression-strategy\", etc.\n\n   */\n\n  quality=image_info->quality == UndefinedCompressionQuality ? 75UL :\n     image_info->quality;\n\n  if (quality <= 9)\n    {\n      if (mng_info->write_png_compression_strategy == 0)\n        mng_info->write_png_compression_strategy = Z_HUFFMAN_ONLY+1;\n    }\n\n  else if (mng_info->write_png_compression_level == 0)\n    {\n      int\n        level;\n\n      level=(int) MagickMin((ssize_t) quality/10,9);\n\n      mng_info->write_png_compression_level = level+1;\n    }\n\n  if (mng_info->write_png_compression_strategy == 0)\n    {\n        if ((quality %10) == 8 || (quality %10) == 9)\n#ifdef Z_RLE  /* Z_RLE was added to zlib-1.2.0 */\n          mng_info->write_png_compression_strategy=Z_RLE+1;\n#else\n          mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;\n#endif\n    }\n\n  if (mng_info->write_png_compression_filter == 0)\n        mng_info->write_png_compression_filter=((int) quality % 10) + 1;\n\n  if (logging != MagickFalse)\n    {\n        if (mng_info->write_png_compression_level)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Compression level:    %d\",\n            (int) mng_info->write_png_compression_level-1);\n\n        if (mng_info->write_png_compression_strategy)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Compression strategy: %d\",\n            (int) mng_info->write_png_compression_strategy-1);\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Setting up filtering\");\n\n        if (mng_info->write_png_compression_filter == 6)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: ADAPTIVE\");\n        else if (mng_info->write_png_compression_filter == 0 ||\n                 mng_info->write_png_compression_filter == 1)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: NONE\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: %d\",\n            (int) mng_info->write_png_compression_filter-1);\n    }\n\n  if (mng_info->write_png_compression_level != 0)\n    png_set_compression_level(ping,mng_info->write_png_compression_level-1);\n\n  if (mng_info->write_png_compression_filter == 6)\n    {\n      if (((int) ping_color_type == PNG_COLOR_TYPE_GRAY) ||\n         ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE) ||\n         (quality < 50))\n        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n      else\n        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);\n     }\n  else if (mng_info->write_png_compression_filter == 7 ||\n      mng_info->write_png_compression_filter == 10)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);\n\n  else if (mng_info->write_png_compression_filter == 8)\n    {\n#if defined(PNG_MNG_FEATURES_SUPPORTED) && defined(PNG_INTRAPIXEL_DIFFERENCING)\n      if (mng_info->write_mng)\n      {\n         if (((int) ping_color_type == PNG_COLOR_TYPE_RGB) ||\n             ((int) ping_color_type == PNG_COLOR_TYPE_RGBA))\n        ping_filter_method=PNG_INTRAPIXEL_DIFFERENCING;\n      }\n#endif\n      png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n    }\n\n  else if (mng_info->write_png_compression_filter == 9)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n\n  else if (mng_info->write_png_compression_filter != 0)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,\n       mng_info->write_png_compression_filter-1);\n\n  if (mng_info->write_png_compression_strategy != 0)\n    png_set_compression_strategy(ping,\n       mng_info->write_png_compression_strategy-1);\n\n  ping_interlace_method=image_info->interlace != NoInterlace;\n\n  if (mng_info->write_mng)\n    png_set_sig_bytes(ping,8);\n\n  /* Bail out if cannot meet defined png:bit-depth or png:color-type */\n\n  if (mng_info->write_png_colortype != 0)\n    {\n     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY)\n       if (ping_have_color != MagickFalse)\n         {\n           ping_color_type = PNG_COLOR_TYPE_RGB;\n\n           if (ping_bit_depth < 8)\n             ping_bit_depth=8;\n         }\n\n     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY_ALPHA)\n       if (ping_have_color != MagickFalse)\n         ping_color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n    }\n\n  if (ping_need_colortype_warning != MagickFalse ||\n     ((mng_info->write_png_depth &&\n     (int) mng_info->write_png_depth != ping_bit_depth) ||\n     (mng_info->write_png_colortype &&\n     ((int) mng_info->write_png_colortype-1 != ping_color_type &&\n      mng_info->write_png_colortype != 7 &&\n      !(mng_info->write_png_colortype == 5 && ping_color_type == 0)))))\n    {\n      if (logging != MagickFalse)\n        {\n          if (ping_need_colortype_warning != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Image has transparency but tRNS chunk was excluded\");\n            }\n\n          if (mng_info->write_png_depth)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Defined png:bit-depth=%u, Computed depth=%u\",\n                  mng_info->write_png_depth,\n                  ping_bit_depth);\n            }\n\n          if (mng_info->write_png_colortype)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Defined png:color-type=%u, Computed color type=%u\",\n                  mng_info->write_png_colortype-1,\n                  ping_color_type);\n            }\n        }\n\n      png_warning(ping,\n        \"Cannot write image with defined png:bit-depth or png:color-type.\");\n    }\n\n  if (image_matte != MagickFalse && image->alpha_trait == UndefinedPixelTrait)\n    {\n      /* Add an opaque matte channel */\n      image->alpha_trait = BlendPixelTrait;\n      (void) SetImageAlpha(image,OpaqueAlpha,exception);\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Added an opaque matte channel\");\n    }\n\n  if (number_transparent != 0 || number_semitransparent != 0)\n    {\n      if (ping_color_type < 4)\n        {\n           ping_have_tRNS=MagickTrue;\n           if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Setting ping_have_tRNS=MagickTrue.\");\n        }\n    }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Writing PNG header chunks\");\n\n  png_set_IHDR(ping,ping_info,ping_width,ping_height,\n               ping_bit_depth,ping_color_type,\n               ping_interlace_method,ping_compression_method,\n               ping_filter_method);\n\n  if (ping_color_type == 3 && ping_have_PLTE != MagickFalse)\n    {\n      png_set_PLTE(ping,ping_info,palette,number_colors);\n\n      if (logging != MagickFalse)\n        {\n          for (i=0; i< (ssize_t) number_colors; i++)\n          {\n            if (i < ping_num_trans)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"     PLTE[%d] = (%d,%d,%d), tRNS[%d] = (%d)\",\n                      (int) i,\n                      (int) palette[i].red,\n                      (int) palette[i].green,\n                      (int) palette[i].blue,\n                      (int) i,\n                      (int) ping_trans_alpha[i]);\n             else\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"     PLTE[%d] = (%d,%d,%d)\",\n                      (int) i,\n                      (int) palette[i].red,\n                      (int) palette[i].green,\n                      (int) palette[i].blue);\n           }\n         }\n    }\n\n  /* Only write the iCCP chunk if we are not writing the sRGB chunk. */\n  if (ping_exclude_sRGB != MagickFalse ||\n     (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n  {\n    if ((ping_exclude_tEXt == MagickFalse ||\n       ping_exclude_zTXt == MagickFalse) &&\n       (ping_exclude_iCCP == MagickFalse || ping_exclude_zCCP == MagickFalse))\n    {\n      ResetImageProfileIterator(image);\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        profile=GetImageProfile(image,name);\n\n        if (profile != (StringInfo *) NULL)\n          {\n#ifdef PNG_WRITE_iCCP_SUPPORTED\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0))\n              {\n                ping_have_iCCP = MagickTrue;\n                if (ping_exclude_iCCP == MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Setting up iCCP chunk\");\n\n                    png_set_iCCP(ping,ping_info,(png_charp) name,0,\n#if (PNG_LIBPNG_VER < 10500)\n                    (png_charp) GetStringInfoDatum(profile),\n#else\n                    (const png_byte *) GetStringInfoDatum(profile),\n#endif\n                    (png_uint_32) GetStringInfoLength(profile));\n                  }\n                else\n                  {\n                    /* Do not write hex-encoded ICC chunk */\n                       name=GetNextImageProfile(image);\n                       continue;\n                  }\n              }\n#endif /* WRITE_iCCP */\n\n            if (LocaleCompare(name,\"exif\") == 0)\n              {\n                   /* Do not write hex-encoded ICC chunk; we will\n                      write it later as an eXIf chunk */\n                   name=GetNextImageProfile(image);\n                   continue;\n              }\n\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Setting up zTXt chunk with uuencoded %s profile\",\n                 name);\n              Magick_png_write_raw_profile(image_info,ping,ping_info,\n                (unsigned char *) name,(unsigned char *) name,\n                GetStringInfoDatum(profile),\n                (png_uint_32) GetStringInfoLength(profile));\n          }\n        name=GetNextImageProfile(image);\n      }\n    }\n  }\n\n#if defined(PNG_WRITE_sRGB_SUPPORTED)\n  if ((mng_info->have_write_global_srgb == 0) &&\n      ping_have_iCCP != MagickTrue &&\n      (ping_have_sRGB != MagickFalse ||\n      png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n    {\n      if (ping_exclude_sRGB == MagickFalse)\n        {\n          /*\n            Note image rendering intent.\n          */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Setting up sRGB chunk\");\n\n          (void) png_set_sRGB(ping,ping_info,(\n            Magick_RenderingIntent_to_PNG_RenderingIntent(\n              image->rendering_intent)));\n\n          ping_have_sRGB = MagickTrue;\n        }\n    }\n\n  if ((!mng_info->write_mng) || (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n#endif\n    {\n      if (ping_exclude_gAMA == MagickFalse &&\n          ping_have_iCCP == MagickFalse &&\n          ping_have_sRGB == MagickFalse &&\n          (ping_exclude_sRGB == MagickFalse ||\n          (image->gamma < .45 || image->gamma > .46)))\n      {\n      if ((mng_info->have_write_global_gama == 0) && (image->gamma != 0.0))\n        {\n          /*\n            Note image gamma.\n            To do: check for cHRM+gAMA == sRGB, and write sRGB instead.\n          */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Setting up gAMA chunk\");\n\n          png_set_gAMA(ping,ping_info,image->gamma);\n        }\n      }\n\n      if (ping_exclude_cHRM == MagickFalse && ping_have_sRGB == MagickFalse)\n        {\n          if ((mng_info->have_write_global_chrm == 0) &&\n              (image->chromaticity.red_primary.x != 0.0))\n            {\n              /*\n                Note image chromaticity.\n                Note: if cHRM+gAMA == sRGB write sRGB instead.\n              */\n               PrimaryInfo\n                 bp,\n                 gp,\n                 rp,\n                 wp;\n\n               wp=image->chromaticity.white_point;\n               rp=image->chromaticity.red_primary;\n               gp=image->chromaticity.green_primary;\n               bp=image->chromaticity.blue_primary;\n\n               if (logging != MagickFalse)\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Setting up cHRM chunk\");\n\n               png_set_cHRM(ping,ping_info,wp.x,wp.y,rp.x,rp.y,gp.x,gp.y,\n                   bp.x,bp.y);\n           }\n        }\n    }\n\n  if (ping_exclude_bKGD == MagickFalse)\n    {\n      if (ping_have_bKGD != MagickFalse)\n        {\n          png_set_bKGD(ping,ping_info,&ping_background);\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Setting up bKGD chunk\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      background color = (%d,%d,%d)\",\n                        (int) ping_background.red,\n                        (int) ping_background.green,\n                        (int) ping_background.blue);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      index = %d, gray=%d\",\n                        (int) ping_background.index,\n                        (int) ping_background.gray);\n            }\n         }\n    }\n\n  if (ping_exclude_pHYs == MagickFalse)\n    {\n      if (ping_have_pHYs != MagickFalse)\n        {\n          png_set_pHYs(ping,ping_info,\n             ping_pHYs_x_resolution,\n             ping_pHYs_y_resolution,\n             ping_pHYs_unit_type);\n\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Setting up pHYs chunk\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      x_resolution=%lu\",\n                   (unsigned long) ping_pHYs_x_resolution);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      y_resolution=%lu\",\n                   (unsigned long) ping_pHYs_y_resolution);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      unit_type=%lu\",\n                   (unsigned long) ping_pHYs_unit_type);\n            }\n        }\n    }\n\n#if defined(PNG_tIME_SUPPORTED)\n  if (ping_exclude_tIME == MagickFalse)\n    {\n      const char\n        *timestamp;\n\n      if (image->taint == MagickFalse)\n        {\n          timestamp=GetImageOption(image_info,\"png:tIME\");\n\n          if (timestamp == (const char *) NULL)\n            timestamp=GetImageProperty(image,\"png:tIME\",exception);\n        }\n\n      else\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Reset tIME in tainted image\");\n\n          timestamp=GetImageProperty(image,\"date:modify\",exception);\n        }\n\n      if (timestamp != (const char *) NULL)\n          write_tIME_chunk(image,ping,ping_info,timestamp,exception);\n    }\n#endif\n\n  if (mng_info->need_blob != MagickFalse)\n  {\n    if (OpenBlob(image_info,image,WriteBinaryBlobMode,exception) ==\n       MagickFalse)\n       png_error(ping,\"WriteBlob Failed\");\n\n     ping_have_blob=MagickTrue;\n  }\n\n  png_write_info_before_PLTE(ping, ping_info);\n\n  if (ping_have_tRNS != MagickFalse && ping_color_type < 4)\n    {\n      if (logging != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Calling png_set_tRNS with num_trans=%d\",ping_num_trans);\n        }\n\n      if (ping_color_type == 3)\n         (void) png_set_tRNS(ping, ping_info,\n                ping_trans_alpha,\n                ping_num_trans,\n                NULL);\n\n      else\n        {\n           (void) png_set_tRNS(ping, ping_info,\n                  NULL,\n                  0,\n                  &ping_trans_color);\n\n           if (logging != MagickFalse)\n             {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"     tRNS color   =(%d,%d,%d)\",\n                       (int) ping_trans_color.red,\n                       (int) ping_trans_color.green,\n                       (int) ping_trans_color.blue);\n             }\n         }\n    }\n\n  /* write any png-chunk-b profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-b\",logging);\n\n  png_write_info(ping,ping_info);\n\n  /* write any PNG-chunk-m profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-m\",logging);\n\n  ping_wrote_caNv = MagickFalse;\n\n  /* write caNv chunk */\n  if (ping_exclude_caNv == MagickFalse)\n    {\n      if ((image->page.width != 0 && image->page.width != image->columns) ||\n          (image->page.height != 0 && image->page.height != image->rows) ||\n          image->page.x != 0 || image->page.y != 0)\n        {\n          unsigned char\n            chunk[20];\n\n          (void) WriteBlobMSBULong(image,16L);  /* data length=8 */\n          PNGType(chunk,mng_caNv);\n          LogPNGChunk(logging,mng_caNv,16L);\n          PNGLong(chunk+4,(png_uint_32) image->page.width);\n          PNGLong(chunk+8,(png_uint_32) image->page.height);\n          PNGsLong(chunk+12,(png_int_32) image->page.x);\n          PNGsLong(chunk+16,(png_int_32) image->page.y);\n          (void) WriteBlob(image,20,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,20));\n          ping_wrote_caNv = MagickTrue;\n        }\n    }\n\n#if defined(PNG_oFFs_SUPPORTED)\n  if (ping_exclude_oFFs == MagickFalse && ping_wrote_caNv == MagickFalse)\n    {\n      if (image->page.x || image->page.y)\n        {\n           png_set_oFFs(ping,ping_info,(png_int_32) image->page.x,\n              (png_int_32) image->page.y, 0);\n\n           if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Setting up oFFs chunk with x=%d, y=%d, units=0\",\n                 (int) image->page.x, (int) image->page.y);\n        }\n    }\n#endif\n\n  /* write vpAg chunk (deprecated, replaced by caNv) */\n  if (ping_exclude_vpAg == MagickFalse && ping_wrote_caNv == MagickFalse)\n    {\n      if ((image->page.width != 0 && image->page.width != image->columns) ||\n          (image->page.height != 0 && image->page.height != image->rows))\n        {\n          unsigned char\n            chunk[14];\n\n          (void) WriteBlobMSBULong(image,9L);  /* data length=8 */\n          PNGType(chunk,mng_vpAg);\n          LogPNGChunk(logging,mng_vpAg,9L);\n          PNGLong(chunk+4,(png_uint_32) image->page.width);\n          PNGLong(chunk+8,(png_uint_32) image->page.height);\n          chunk[12]=0;   /* unit = pixels */\n          (void) WriteBlob(image,13,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,13));\n        }\n    }\n\n#if (PNG_LIBPNG_VER == 10206)\n    /* avoid libpng-1.2.6 bug by setting PNG_HAVE_IDAT flag */\n#define PNG_HAVE_IDAT               0x04\n    ping->mode |= PNG_HAVE_IDAT;\n#undef PNG_HAVE_IDAT\n#endif\n\n  png_set_packing(ping);\n  /*\n    Allocate memory.\n  */\n  rowbytes=image->columns;\n  if (image_depth > 8)\n    rowbytes*=2;\n  switch (ping_color_type)\n    {\n      case PNG_COLOR_TYPE_RGB:\n        rowbytes*=3;\n        break;\n\n      case PNG_COLOR_TYPE_GRAY_ALPHA:\n        rowbytes*=2;\n        break;\n\n      case PNG_COLOR_TYPE_RGBA:\n        rowbytes*=4;\n        break;\n\n      default:\n        break;\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Writing PNG image data\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Allocating %.20g bytes of memory for pixels\",(double) rowbytes);\n    }\n  pixel_info=AcquireVirtualMemory(rowbytes,sizeof(*ping_pixels));\n  if (pixel_info == (MemoryInfo *) NULL)\n    png_error(ping,\"Allocation of memory for pixels failed\");\n  ping_pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n\n  /*\n    Initialize image scanlines.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    png_error(ping,\"Memory allocation for quantum_info failed\");\n  quantum_info->format=UndefinedQuantumFormat;\n  SetQuantumDepth(image,quantum_info,image_depth);\n  (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n  num_passes=png_set_interlace_handling(ping);\n\n  if ((!mng_info->write_png8 && !mng_info->write_png24 &&\n       !mng_info->write_png48 && !mng_info->write_png64 &&\n       !mng_info->write_png32) &&\n       (mng_info->IsPalette ||\n       (image_info->type == BilevelType)) &&\n       image_matte == MagickFalse &&\n       ping_have_non_bw == MagickFalse)\n    {\n      /* Palette, Bilevel, or Opaque Monochrome */\n      register const Quantum\n        *p;\n\n      SetQuantumDepth(image,quantum_info,8);\n      for (pass=0; pass < num_passes; pass++)\n      {\n        /*\n          Convert PseudoClass image to a PNG monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          if (logging != MagickFalse && y == 0)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Writing row of pixels (0)\");\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n          if (p == (const Quantum *) NULL)\n            break;\n\n          if (mng_info->IsPalette)\n            {\n              (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                quantum_info,GrayQuantum,ping_pixels,exception);\n              if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_PALETTE &&\n                  mng_info->write_png_depth &&\n                  mng_info->write_png_depth != old_bit_depth)\n                {\n                  /* Undo pixel scaling */\n                  for (i=0; i < (ssize_t) image->columns; i++)\n                     *(ping_pixels+i)=(unsigned char) (*(ping_pixels+i)\n                     >> (8-old_bit_depth));\n                }\n            }\n\n          else\n            {\n              (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                quantum_info,RedQuantum,ping_pixels,exception);\n            }\n\n          if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE)\n            for (i=0; i < (ssize_t) image->columns; i++)\n               *(ping_pixels+i)=(unsigned char) ((*(ping_pixels+i) > 127) ?\n                      255 : 0);\n\n          if (logging != MagickFalse && y == 0)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Writing row of pixels (1)\");\n\n          png_write_row(ping,ping_pixels);\n\n          status=SetImageProgress(image,SaveImageTag,\n              (MagickOffsetType) (pass * image->rows + y),\n              num_passes * image->rows);\n\n          if (status == MagickFalse)\n            break;\n        }\n      }\n    }\n\n  else   /* Not Palette, Bilevel, or Opaque Monochrome */\n    {\n      if ((!mng_info->write_png8 && !mng_info->write_png24 &&\n          !mng_info->write_png48 && !mng_info->write_png64 &&\n          !mng_info->write_png32) && (image_matte != MagickFalse ||\n          (ping_bit_depth >= MAGICKCORE_QUANTUM_DEPTH)) &&\n          (mng_info->IsPalette) && ping_have_color == MagickFalse)\n        {\n          register const Quantum\n            *p;\n\n          for (pass=0; pass < num_passes; pass++)\n          {\n\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n            if (p == (const Quantum *) NULL)\n              break;\n\n            if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n              {\n                if (mng_info->IsPalette)\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,GrayQuantum,ping_pixels,exception);\n\n                else\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RedQuantum,ping_pixels,exception);\n\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"    Writing GRAY PNG pixels (2)\");\n              }\n\n            else /* PNG_COLOR_TYPE_GRAY_ALPHA */\n              {\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Writing GRAY_ALPHA PNG pixels (2)\");\n\n                (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,GrayAlphaQuantum,ping_pixels,exception);\n              }\n\n            if (logging != MagickFalse && y == 0)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Writing row of pixels (2)\");\n\n            png_write_row(ping,ping_pixels);\n\n            status=SetImageProgress(image,SaveImageTag,\n              (MagickOffsetType) (pass * image->rows + y),\n              num_passes * image->rows);\n\n            if (status == MagickFalse)\n              break;\n            }\n          }\n        }\n\n      else\n        {\n          register const Quantum\n            *p;\n\n          for (pass=0; pass < num_passes; pass++)\n          {\n            if ((image_depth > 8) ||\n                mng_info->write_png24 ||\n                mng_info->write_png32 ||\n                mng_info->write_png48 ||\n                mng_info->write_png64 ||\n                (!mng_info->write_png8 && !mng_info->IsPalette))\n            {\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n                if (p == (const Quantum *) NULL)\n                  break;\n\n                if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n                  {\n                    if (image->storage_class == DirectClass)\n                      (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                        quantum_info,RedQuantum,ping_pixels,exception);\n\n                    else\n                      (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                        quantum_info,GrayQuantum,ping_pixels,exception);\n                  }\n\n                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n                  {\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                      quantum_info,GrayAlphaQuantum,ping_pixels,\n                      exception);\n\n                    if (logging != MagickFalse && y == 0)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"    Writing GRAY_ALPHA PNG pixels (3)\");\n                  }\n\n                else if (image_matte != MagickFalse)\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RGBAQuantum,ping_pixels,exception);\n\n                else\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RGBQuantum,ping_pixels,exception);\n\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"    Writing row of pixels (3)\");\n\n                png_write_row(ping,ping_pixels);\n\n                status=SetImageProgress(image,SaveImageTag,\n                  (MagickOffsetType) (pass * image->rows + y),\n                  num_passes * image->rows);\n\n                if (status == MagickFalse)\n                  break;\n              }\n            }\n\n          else\n            /* not ((image_depth > 8) ||\n                mng_info->write_png24 || mng_info->write_png32 ||\n                mng_info->write_png48 || mng_info->write_png64 ||\n                (!mng_info->write_png8 && !mng_info->IsPalette))\n             */\n            {\n              if ((ping_color_type != PNG_COLOR_TYPE_GRAY) &&\n                  (ping_color_type != PNG_COLOR_TYPE_GRAY_ALPHA))\n                {\n                  if (logging != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"  pass %d, Image Is not GRAY or GRAY_ALPHA\",pass);\n\n                  SetQuantumDepth(image,quantum_info,8);\n                  image_depth=8;\n                }\n\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  pass %d, Image Is RGB, 16-bit GRAY, or GRAY_ALPHA\",\n                    pass);\n\n                p=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n                if (p == (const Quantum *) NULL)\n                  break;\n\n                if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n                  {\n                    SetQuantumDepth(image,quantum_info,image->depth);\n\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                       quantum_info,GrayQuantum,ping_pixels,exception);\n                  }\n\n                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n                  {\n                    if (logging != MagickFalse && y == 0)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"  Writing GRAY_ALPHA PNG pixels (4)\");\n\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                         quantum_info,GrayAlphaQuantum,ping_pixels,\n                         exception);\n                  }\n\n                else\n                  {\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                      quantum_info,IndexQuantum,ping_pixels,exception);\n\n                    if (logging != MagickFalse && y <= 2)\n                    {\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Writing row of non-gray pixels (4)\");\n\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  ping_pixels[0]=%d,ping_pixels[1]=%d\",\n                          (int)ping_pixels[0],(int)ping_pixels[1]);\n                    }\n                  }\n                png_write_row(ping,ping_pixels);\n\n                status=SetImageProgress(image,SaveImageTag,\n                  (MagickOffsetType) (pass * image->rows + y),\n                  num_passes * image->rows);\n\n                if (status == MagickFalse)\n                  break;\n              }\n            }\n          }\n        }\n    }\n\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Wrote PNG image data\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Width: %.20g\",(double) ping_width);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Height: %.20g\",(double) ping_height);\n\n      if (mng_info->write_png_depth)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Defined png:bit-depth: %d\",mng_info->write_png_depth);\n        }\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG bit-depth written: %d\",ping_bit_depth);\n\n      if (mng_info->write_png_colortype)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Defined png:color-type: %d\",mng_info->write_png_colortype-1);\n        }\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG color-type written: %d\",ping_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG Interlace method: %d\",ping_interlace_method);\n    }\n  /*\n    Generate text chunks after IDAT.\n  */\n  if (ping_exclude_tEXt == MagickFalse || ping_exclude_zTXt == MagickFalse)\n  {\n    ResetImagePropertyIterator(image);\n    property=GetNextImageProperty(image);\n    while (property != (const char *) NULL)\n    {\n      png_textp\n        text;\n\n      value=GetImageProperty(image,property,exception);\n\n      /* Don't write any \"png:\" or \"jpeg:\" properties; those are just for\n       * \"identify\" or for passing through to another JPEG\n       */\n      if ((LocaleNCompare(property,\"png:\",4) != 0 &&\n           LocaleNCompare(property,\"jpeg:\",5) != 0) &&\n\n\n          /* Suppress density and units if we wrote a pHYs chunk */\n          (ping_exclude_pHYs != MagickFalse      ||\n          LocaleCompare(property,\"density\") != 0 ||\n          LocaleCompare(property,\"units\") != 0) &&\n\n          /* Suppress the IM-generated Date:create and Date:modify */\n          (ping_exclude_date == MagickFalse      ||\n          LocaleNCompare(property, \"Date:\",5) != 0))\n        {\n        if (value != (const char *) NULL)\n          {\n\n#if PNG_LIBPNG_VER >= 10400\n            text=(png_textp) png_malloc(ping,\n                 (png_alloc_size_t) sizeof(png_text));\n#else\n            text=(png_textp) png_malloc(ping,(png_size_t) sizeof(png_text));\n#endif\n            text[0].key=(char *) property;\n            text[0].text=(char *) value;\n            text[0].text_length=strlen(value);\n\n            if (ping_exclude_tEXt != MagickFalse)\n               text[0].compression=PNG_TEXT_COMPRESSION_zTXt;\n\n            else if (ping_exclude_zTXt != MagickFalse)\n               text[0].compression=PNG_TEXT_COMPRESSION_NONE;\n\n            else\n            {\n               text[0].compression=image_info->compression == NoCompression ||\n                 (image_info->compression == UndefinedCompression &&\n                 text[0].text_length < 128) ? PNG_TEXT_COMPRESSION_NONE :\n                 PNG_TEXT_COMPRESSION_zTXt ;\n            }\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Setting up text chunk\");\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    keyword: '%s'\",text[0].key);\n              }\n\n            png_set_text(ping,ping_info,text,1);\n            png_free(ping,text);\n          }\n        }\n      property=GetNextImageProperty(image);\n    }\n  }\n\n  /* write any PNG-chunk-e profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-e\",logging);\n\n  /* write exIf profile */\n  if (ping_have_eXIf != MagickFalse && ping_exclude_eXIf == MagickFalse)\n    {\n      char\n        *name;\n\n      ResetImageProfileIterator(image);\n\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        if (LocaleCompare(name,\"exif\") == 0)\n          {\n            const StringInfo\n              *profile;\n\n            profile=GetImageProfile(image,name);\n\n            if (profile != (StringInfo *) NULL)\n              {\n                png_uint_32\n                  length;\n\n                unsigned char\n                  chunk[4],\n                  *data;\n\n               StringInfo\n                 *ping_profile;\n\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Have eXIf profile\");\n\n               ping_profile=CloneStringInfo(profile);\n               data=GetStringInfoDatum(ping_profile),\n               length=(png_uint_32) GetStringInfoLength(ping_profile);\n\n               PNGType(chunk,mng_eXIf);\n               if (length < 7)\n                 {\n                   ping_profile=DestroyStringInfo(ping_profile);\n                   break;  /* otherwise crashes */\n                 }\n\n               /* skip the \"Exif\\0\\0\" JFIF Exif Header ID */\n               length -= 6;\n\n               LogPNGChunk(logging,chunk,length);\n               (void) WriteBlobMSBULong(image,length);\n               (void) WriteBlob(image,4,chunk);\n               (void) WriteBlob(image,length,data+6);\n               (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),\n                 data+6, (uInt) length));\n               ping_profile=DestroyStringInfo(ping_profile);\n               break;\n             }\n         }\n       name=GetNextImageProfile(image);\n     }\n  }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Writing PNG end info\");\n\n  png_write_end(ping,ping_info);\n\n  if (mng_info->need_fram && (int) image->dispose == BackgroundDispose)\n    {\n      if (mng_info->page.x || mng_info->page.y ||\n          (ping_width != mng_info->page.width) ||\n          (ping_height != mng_info->page.height))\n        {\n          unsigned char\n            chunk[32];\n\n          /*\n            Write FRAM 4 with clipping boundaries followed by FRAM 1.\n          */\n          (void) WriteBlobMSBULong(image,27L);  /* data length=27 */\n          PNGType(chunk,mng_FRAM);\n          LogPNGChunk(logging,mng_FRAM,27L);\n          chunk[4]=4;\n          chunk[5]=0;  /* frame name separator (no name) */\n          chunk[6]=1;  /* flag for changing delay, for next frame only */\n          chunk[7]=0;  /* flag for changing frame timeout */\n          chunk[8]=1;  /* flag for changing frame clipping for next frame */\n          chunk[9]=0;  /* flag for changing frame sync_id */\n          PNGLong(chunk+10,(png_uint_32) (0L)); /* temporary 0 delay */\n          chunk[14]=0; /* clipping boundaries delta type */\n          PNGLong(chunk+15,(png_uint_32) (mng_info->page.x)); /* left cb */\n          PNGLong(chunk+19,\n             (png_uint_32) (mng_info->page.x + ping_width));\n          PNGLong(chunk+23,(png_uint_32) (mng_info->page.y)); /* top cb */\n          PNGLong(chunk+27,\n             (png_uint_32) (mng_info->page.y + ping_height));\n          (void) WriteBlob(image,31,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,31));\n          mng_info->old_framing_mode=4;\n          mng_info->framing_mode=1;\n        }\n\n      else\n        mng_info->framing_mode=3;\n    }\n  if (mng_info->write_mng && !mng_info->need_fram &&\n      ((int) image->dispose == 3))\n     png_error(ping, \"Cannot convert GIF with disposal method 3 to MNG-LC\");\n\n  /*\n    Free PNG resources.\n  */\n\n  png_destroy_write_struct(&ping,&ping_info);\n\n  pixel_info=RelinquishVirtualMemory(pixel_info);\n\n  if (ping_have_blob != MagickFalse)\n     (void) CloseBlob(image);\n\n  image_info=DestroyImageInfo(image_info);\n  image=DestroyImage(image);\n\n  /* Store bit depth actually written */\n  s[0]=(char) ping_bit_depth;\n  s[1]='\\0';\n\n  (void) SetImageProperty(IMimage,\"png:bit-depth-written\",s,exception);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit WriteOnePNGImage()\");\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n   /* }  for navigation to beginning of SETJMP-protected block. Revert to\n    *    Throwing an Exception when an error occurs.\n    */\n\n  return(MagickTrue);\n/*  End write one PNG image */\n\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142475,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,\n  const ImageInfo *IMimage_info,Image *IMimage,ExceptionInfo *exception)\n{\n  char\n    im_vers[32],\n    libpng_runv[32],\n    libpng_vers[32],\n    zlib_runv[32],\n    zlib_vers[32];\n\n  Image\n    *image;\n\n  ImageInfo\n    *image_info;\n\n  char\n    s[2];\n\n  const char\n    *name,\n    *property,\n    *value;\n\n  const StringInfo\n    *profile;\n\n  int\n    num_passes,\n    pass,\n    ping_wrote_caNv;\n\n  png_byte\n     ping_trans_alpha[256];\n\n  png_color\n     palette[257];\n\n  png_color_16\n    ping_background,\n    ping_trans_color;\n\n  png_info\n    *ping_info;\n\n  png_struct\n    *ping;\n\n  png_uint_32\n    ping_height,\n    ping_width;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    image_matte,\n    logging,\n    matte,\n\n    ping_have_blob,\n    ping_have_cheap_transparency,\n    ping_have_color,\n    ping_have_non_bw,\n    ping_have_PLTE,\n    ping_have_bKGD,\n    ping_have_eXIf,\n    ping_have_iCCP,\n    ping_have_pHYs,\n    ping_have_sRGB,\n    ping_have_tRNS,\n\n    ping_exclude_bKGD,\n    ping_exclude_cHRM,\n    ping_exclude_date,\n    /* ping_exclude_EXIF, */\n    ping_exclude_eXIf,\n    ping_exclude_gAMA,\n    ping_exclude_iCCP,\n    /* ping_exclude_iTXt, */\n    ping_exclude_oFFs,\n    ping_exclude_pHYs,\n    ping_exclude_sRGB,\n    ping_exclude_tEXt,\n    ping_exclude_tIME,\n    /* ping_exclude_tRNS, */\n    ping_exclude_vpAg,\n    ping_exclude_caNv,\n    ping_exclude_zCCP, /* hex-encoded iCCP */\n    ping_exclude_zTXt,\n\n    ping_preserve_colormap,\n    ping_preserve_iCCP,\n    ping_need_colortype_warning,\n\n    status,\n    tried_332,\n    tried_333,\n    tried_444;\n\n  MemoryInfo\n    *volatile pixel_info;\n\n  QuantumInfo\n    *quantum_info;\n\n  PNGErrorInfo\n    error_info;\n\n  register ssize_t\n    i,\n    x;\n\n  unsigned char\n    *ping_pixels;\n\n  volatile int\n    image_colors,\n    ping_bit_depth,\n    ping_color_type,\n    ping_interlace_method,\n    ping_compression_method,\n    ping_filter_method,\n    ping_num_trans;\n\n  volatile size_t\n    image_depth,\n    old_bit_depth;\n\n  size_t\n    quality,\n    rowbytes,\n    save_image_depth;\n\n  int\n    j,\n    number_colors,\n    number_opaque,\n    number_semitransparent,\n    number_transparent,\n    ping_pHYs_unit_type;\n\n  png_uint_32\n    ping_pHYs_x_resolution,\n    ping_pHYs_y_resolution;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n     \"  Enter WriteOnePNGImage()\");\n \n   image = CloneImage(IMimage,0,0,MagickFalse,exception);\n  if (image == (Image *) NULL)\n    return(MagickFalse);\n   image_info=(ImageInfo *) CloneImageInfo(IMimage_info);\n   if (image_info == (ImageInfo *) NULL)\n    ThrowWriterException(ResourceLimitError, \"MemoryAllocationFailed\");\n \n   /* Define these outside of the following \"if logging()\" block so they will\n    * show in debuggers.\n   */\n  *im_vers='\\0';\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibVersionText,MagickPathExtent);\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibAddendum,MagickPathExtent);\n\n  *libpng_vers='\\0';\n  (void) ConcatenateMagickString(libpng_vers,\n         PNG_LIBPNG_VER_STRING,32);\n  *libpng_runv='\\0';\n  (void) ConcatenateMagickString(libpng_runv,\n         png_get_libpng_ver(NULL),32);\n\n  *zlib_vers='\\0';\n  (void) ConcatenateMagickString(zlib_vers,\n         ZLIB_VERSION,32);\n  *zlib_runv='\\0';\n  (void) ConcatenateMagickString(zlib_runv,\n         zlib_version,32);\n\n  if (logging != MagickFalse)\n    {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    IM version     = %s\",\n           im_vers);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Libpng version = %s\",\n           libpng_vers);\n       if (LocaleCompare(libpng_vers,libpng_runv) != 0)\n       {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n           libpng_runv);\n       }\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Zlib version   = %s\",\n           zlib_vers);\n       if (LocaleCompare(zlib_vers,zlib_runv) != 0)\n       {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n           zlib_runv);\n       }\n    }\n\n  /* Initialize some stuff */\n  ping_bit_depth=0,\n  ping_color_type=0,\n  ping_interlace_method=0,\n  ping_compression_method=0,\n  ping_filter_method=0,\n  ping_num_trans = 0;\n\n  ping_background.red = 0;\n  ping_background.green = 0;\n  ping_background.blue = 0;\n  ping_background.gray = 0;\n  ping_background.index = 0;\n\n  ping_trans_color.red=0;\n  ping_trans_color.green=0;\n  ping_trans_color.blue=0;\n  ping_trans_color.gray=0;\n\n  ping_pHYs_unit_type = 0;\n  ping_pHYs_x_resolution = 0;\n  ping_pHYs_y_resolution = 0;\n\n  ping_have_blob=MagickFalse;\n  ping_have_cheap_transparency=MagickFalse;\n  ping_have_color=MagickTrue;\n  ping_have_non_bw=MagickTrue;\n  ping_have_PLTE=MagickFalse;\n  ping_have_bKGD=MagickFalse;\n  ping_have_eXIf=MagickTrue;\n  ping_have_iCCP=MagickFalse;\n  ping_have_pHYs=MagickFalse;\n  ping_have_sRGB=MagickFalse;\n  ping_have_tRNS=MagickFalse;\n\n  ping_exclude_bKGD=mng_info->ping_exclude_bKGD;\n  ping_exclude_caNv=mng_info->ping_exclude_caNv;\n  ping_exclude_cHRM=mng_info->ping_exclude_cHRM;\n  ping_exclude_date=mng_info->ping_exclude_date;\n  ping_exclude_eXIf=mng_info->ping_exclude_eXIf;\n  ping_exclude_gAMA=mng_info->ping_exclude_gAMA;\n  ping_exclude_iCCP=mng_info->ping_exclude_iCCP;\n  /* ping_exclude_iTXt=mng_info->ping_exclude_iTXt; */\n  ping_exclude_oFFs=mng_info->ping_exclude_oFFs;\n  ping_exclude_pHYs=mng_info->ping_exclude_pHYs;\n  ping_exclude_sRGB=mng_info->ping_exclude_sRGB;\n  ping_exclude_tEXt=mng_info->ping_exclude_tEXt;\n  ping_exclude_tIME=mng_info->ping_exclude_tIME;\n  /* ping_exclude_tRNS=mng_info->ping_exclude_tRNS; */\n  ping_exclude_vpAg=mng_info->ping_exclude_vpAg;\n  ping_exclude_zCCP=mng_info->ping_exclude_zCCP; /* hex-encoded iCCP in zTXt */\n  ping_exclude_zTXt=mng_info->ping_exclude_zTXt;\n\n  ping_preserve_colormap = mng_info->ping_preserve_colormap;\n  ping_preserve_iCCP = mng_info->ping_preserve_iCCP;\n  ping_need_colortype_warning = MagickFalse;\n\n  /* Recognize the ICC sRGB profile and convert it to the sRGB chunk,\n   * i.e., eliminate the ICC profile and set image->rendering_intent.\n   * Note that this will not involve any changes to the actual pixels\n   * but merely passes information to applications that read the resulting\n   * PNG image.\n   *\n   * To do: recognize other variants of the sRGB profile, using the CRC to\n   * verify all recognized variants including the 7 already known.\n   *\n   * Work around libpng16+ rejecting some \"known invalid sRGB profiles\".\n   *\n   * Use something other than image->rendering_intent to record the fact\n   * that the sRGB profile was found.\n   *\n   * Record the ICC version (currently v2 or v4) of the incoming sRGB ICC\n   * profile.  Record the Blackpoint Compensation, if any.\n   */\n   if (ping_exclude_sRGB == MagickFalse && ping_preserve_iCCP == MagickFalse)\n   {\n      char\n        *name;\n\n      const StringInfo\n        *profile;\n\n      ResetImageProfileIterator(image);\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        profile=GetImageProfile(image,name);\n\n        if (profile != (StringInfo *) NULL)\n          {\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0))\n\n             {\n                 int\n                   icheck,\n                   got_crc=0;\n\n\n                 png_uint_32\n                   length,\n                   profile_crc=0;\n\n                 unsigned char\n                   *data;\n\n                 length=(png_uint_32) GetStringInfoLength(profile);\n\n                 for (icheck=0; sRGB_info[icheck].len > 0; icheck++)\n                 {\n                   if (length == sRGB_info[icheck].len)\n                   {\n                     if (got_crc == 0)\n                     {\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Got a %lu-byte ICC profile (potentially sRGB)\",\n                         (unsigned long) length);\n\n                       data=GetStringInfoDatum(profile);\n                       profile_crc=crc32(0,data,length);\n\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"      with crc=%8x\",(unsigned int) profile_crc);\n                       got_crc++;\n                     }\n\n                     if (profile_crc == sRGB_info[icheck].crc)\n                     {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"      It is sRGB with rendering intent = %s\",\n                        Magick_RenderingIntentString_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent));\n                        if (image->rendering_intent==UndefinedIntent)\n                        {\n                          image->rendering_intent=\n                          Magick_RenderingIntent_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent);\n                        }\n                        ping_exclude_iCCP = MagickTrue;\n                        ping_exclude_zCCP = MagickTrue;\n                        ping_have_sRGB = MagickTrue;\n                        break;\n                     }\n                   }\n                 }\n                 if (sRGB_info[icheck].len == 0)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"    Got %lu-byte ICC profile not recognized as sRGB\",\n                        (unsigned long) length);\n              }\n          }\n        name=GetNextImageProfile(image);\n      }\n  }\n\n  number_opaque = 0;\n  number_semitransparent = 0;\n  number_transparent = 0;\n\n  if (logging != MagickFalse)\n    {\n      if (image->storage_class == UndefinedClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=UndefinedClass\");\n      if (image->storage_class == DirectClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=DirectClass\");\n      if (image->storage_class == PseudoClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=PseudoClass\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(), image->taint ?\n          \"    image->taint=MagickTrue\":\n          \"    image->taint=MagickFalse\");\n    }\n\n  if (image->storage_class == PseudoClass &&\n     (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32 ||\n     mng_info->write_png48 || mng_info->write_png64 ||\n     (mng_info->write_png_colortype != 1 &&\n     mng_info->write_png_colortype != 5)))\n    {\n      (void) SyncImage(image,exception);\n      image->storage_class = DirectClass;\n    }\n\n  if (ping_preserve_colormap == MagickFalse)\n    {\n      if (image->storage_class != PseudoClass && image->colormap != NULL)\n        {\n          /* Free the bogus colormap; it can cause trouble later */\n           if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Freeing bogus colormap\");\n           (void) RelinquishMagickMemory(image->colormap);\n           image->colormap=NULL;\n        }\n    }\n\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n\n  /*\n    Sometimes we get PseudoClass images whose RGB values don't match\n    the colors in the colormap.  This code syncs the RGB values.\n  */\n  if (image->depth <= 8 && image->taint && image->storage_class == PseudoClass)\n     (void) SyncImage(image,exception);\n\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n  if (image->depth > 8)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Reducing PNG bit depth to 8 since this is a Q8 build.\");\n\n      image->depth=8;\n    }\n#endif\n\n  /* Respect the -depth option */\n  if (image->depth < 4)\n    {\n       register Quantum\n         *r;\n\n       if (image->depth > 2)\n         {\n           /* Scale to 4-bit */\n           LBR04PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR04PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR04PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n       else if (image->depth > 1)\n         {\n           /* Scale to 2-bit */\n           LBR02PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR02PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR02PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n       else\n         {\n           /* Scale to 1-bit */\n           LBR01PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR01PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR01PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n    }\n\n  /* To do: set to next higher multiple of 8 */\n  if (image->depth < 8)\n     image->depth=8;\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n  /* PNG does not handle depths greater than 16 so reduce it even\n   * if lossy\n   */\n  if (image->depth > 8)\n      image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\n  if (image->depth > 8)\n    {\n      /* To do: fill low byte properly */\n      image->depth=16;\n    }\n\n  if (image->depth == 16 && mng_info->write_png_depth != 16)\n    if (mng_info->write_png8 ||\n        LosslessReduceDepthOK(image,exception) != MagickFalse)\n      image->depth = 8;\n#endif\n\n  image_colors = (int) image->colors;\n  number_opaque = (int) image->colors;\n  number_transparent = 0;\n  number_semitransparent = 0;\n\n  if (mng_info->write_png_colortype &&\n     (mng_info->write_png_colortype > 4 || (mng_info->write_png_depth >= 8 &&\n     mng_info->write_png_colortype < 4 &&\n     image->alpha_trait == UndefinedPixelTrait)))\n  {\n     /* Avoid the expensive BUILD_PALETTE operation if we're sure that we\n      * are not going to need the result.\n      */\n     if (mng_info->write_png_colortype == 1 ||\n        mng_info->write_png_colortype == 5)\n       ping_have_color=MagickFalse;\n\n     if (image->alpha_trait != UndefinedPixelTrait)\n       {\n         number_transparent = 2;\n         number_semitransparent = 1;\n       }\n  }\n\n  if (mng_info->write_png_colortype < 7)\n  {\n  /* BUILD_PALETTE\n   *\n   * Normally we run this just once, but in the case of writing PNG8\n   * we reduce the transparency to binary and run again, then if there\n   * are still too many colors we reduce to a simple 4-4-4-1, then 3-3-3-1\n   * RGBA palette and run again, and then to a simple 3-3-2-1 RGBA\n   * palette.  Then (To do) we take care of a final reduction that is only\n   * needed if there are still 256 colors present and one of them has both\n   * transparent and opaque instances.\n   */\n\n  tried_332 = MagickFalse;\n  tried_333 = MagickFalse;\n  tried_444 = MagickFalse;\n\n  for (j=0; j<6; j++)\n  {\n    /*\n     * Sometimes we get DirectClass images that have 256 colors or fewer.\n     * This code will build a colormap.\n     *\n     * Also, sometimes we get PseudoClass images with an out-of-date\n     * colormap.  This code will replace the colormap with a new one.\n     * Sometimes we get PseudoClass images that have more than 256 colors.\n     * This code will delete the colormap and change the image to\n     * DirectClass.\n     *\n     * If image->alpha_trait is MagickFalse, we ignore the alpha channel\n     * even though it sometimes contains left-over non-opaque values.\n     *\n     * Also we gather some information (number of opaque, transparent,\n     * and semitransparent pixels, and whether the image has any non-gray\n     * pixels or only black-and-white pixels) that we might need later.\n     *\n     * Even if the user wants to force GrayAlpha or RGBA (colortype 4 or 6)\n     * we need to check for bogus non-opaque values, at least.\n     */\n\n   int\n     n;\n\n   PixelInfo\n     opaque[260],\n     semitransparent[260],\n     transparent[260];\n\n   register const Quantum\n     *s;\n\n   register Quantum\n     *q,\n     *r;\n\n   if (logging != MagickFalse)\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    Enter BUILD_PALETTE:\");\n\n   if (logging != MagickFalse)\n     {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->columns=%.20g\",(double) image->columns);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->rows=%.20g\",(double) image->rows);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->alpha_trait=%.20g\",(double) image->alpha_trait);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->depth=%.20g\",(double) image->depth);\n\n       if (image->storage_class == PseudoClass && image->colormap != NULL)\n       {\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      Original colormap:\");\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"        i    (red,green,blue,alpha)\");\n\n         for (i=0; i < 256; i++)\n         {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"        %d    (%d,%d,%d,%d)\",\n                    (int) i,\n                    (int) image->colormap[i].red,\n                    (int) image->colormap[i].green,\n                    (int) image->colormap[i].blue,\n                    (int) image->colormap[i].alpha);\n         }\n\n         for (i=image->colors - 10; i < (ssize_t) image->colors; i++)\n         {\n           if (i > 255)\n             {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"        %d    (%d,%d,%d,%d)\",\n                    (int) i,\n                    (int) image->colormap[i].red,\n                    (int) image->colormap[i].green,\n                    (int) image->colormap[i].blue,\n                    (int) image->colormap[i].alpha);\n             }\n         }\n       }\n\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"      image->colors=%d\",(int) image->colors);\n\n       if (image->colors == 0)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"        (zero means unknown)\");\n\n       if (ping_preserve_colormap == MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"      Regenerate the colormap\");\n     }\n\n     image_colors=0;\n     number_opaque = 0;\n     number_semitransparent = 0;\n     number_transparent = 0;\n\n     for (y=0; y < (ssize_t) image->rows; y++)\n     {\n       q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n       if (q == (Quantum *) NULL)\n         break;\n\n       for (x=0; x < (ssize_t) image->columns; x++)\n       {\n           if (image->alpha_trait == UndefinedPixelTrait ||\n              GetPixelAlpha(image,q) == OpaqueAlpha)\n             {\n               if (number_opaque < 259)\n                 {\n                   if (number_opaque == 0)\n                     {\n                       GetPixelInfoPixel(image, q, opaque);\n                       opaque[0].alpha=OpaqueAlpha;\n                       number_opaque=1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_opaque; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,opaque+i))\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_opaque && number_opaque < 259)\n                     {\n                       number_opaque++;\n                       GetPixelInfoPixel(image, q, opaque+i);\n                       opaque[i].alpha=OpaqueAlpha;\n                     }\n                 }\n             }\n           else if (GetPixelAlpha(image,q) == TransparentAlpha)\n             {\n               if (number_transparent < 259)\n                 {\n                   if (number_transparent == 0)\n                     {\n                       GetPixelInfoPixel(image, q, transparent);\n                       ping_trans_color.red=(unsigned short)\n                         GetPixelRed(image,q);\n                       ping_trans_color.green=(unsigned short)\n                         GetPixelGreen(image,q);\n                       ping_trans_color.blue=(unsigned short)\n                         GetPixelBlue(image,q);\n                       ping_trans_color.gray=(unsigned short)\n                         GetPixelGray(image,q);\n                       number_transparent = 1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_transparent; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,transparent+i))\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_transparent &&\n                       number_transparent < 259)\n                     {\n                       number_transparent++;\n                       GetPixelInfoPixel(image,q,transparent+i);\n                     }\n                 }\n             }\n           else\n             {\n               if (number_semitransparent < 259)\n                 {\n                   if (number_semitransparent == 0)\n                     {\n                       GetPixelInfoPixel(image,q,semitransparent);\n                       number_semitransparent = 1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_semitransparent; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,semitransparent+i)\n                           && GetPixelAlpha(image,q) ==\n                           semitransparent[i].alpha)\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_semitransparent &&\n                       number_semitransparent < 259)\n                     {\n                       number_semitransparent++;\n                       GetPixelInfoPixel(image, q, semitransparent+i);\n                     }\n                 }\n             }\n           q+=GetPixelChannels(image);\n        }\n     }\n\n     if (mng_info->write_png8 == MagickFalse &&\n         ping_exclude_bKGD == MagickFalse)\n       {\n         /* Add the background color to the palette, if it\n          * isn't already there.\n          */\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      Check colormap for background (%d,%d,%d)\",\n                  (int) image->background_color.red,\n                  (int) image->background_color.green,\n                  (int) image->background_color.blue);\n            }\n          for (i=0; i<number_opaque; i++)\n          {\n             if (opaque[i].red == image->background_color.red &&\n                 opaque[i].green == image->background_color.green &&\n                 opaque[i].blue == image->background_color.blue)\n               break;\n          }\n          if (number_opaque < 259 && i == number_opaque)\n            {\n               opaque[i] = image->background_color;\n               ping_background.index = i;\n               number_opaque++;\n               if (logging != MagickFalse)\n                 {\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"      background_color index is %d\",(int) i);\n                 }\n\n            }\n          else if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      No room in the colormap to add background color\");\n       }\n\n     image_colors=number_opaque+number_transparent+number_semitransparent;\n\n     if (logging != MagickFalse)\n       {\n         if (image_colors > 256)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      image has more than 256 colors\");\n\n         else\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      image has %d colors\",image_colors);\n       }\n\n     if (ping_preserve_colormap != MagickFalse)\n       break;\n\n     if (mng_info->write_png_colortype != 7) /* We won't need this info */\n       {\n         ping_have_color=MagickFalse;\n         ping_have_non_bw=MagickFalse;\n\n         if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n         {\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"incompatible colorspace\");\n           ping_have_color=MagickTrue;\n           ping_have_non_bw=MagickTrue;\n         }\n\n         if(image_colors > 256)\n           {\n             for (y=0; y < (ssize_t) image->rows; y++)\n             {\n               q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n               if (q == (Quantum *) NULL)\n                 break;\n\n               s=q;\n               for (x=0; x < (ssize_t) image->columns; x++)\n               {\n                 if (GetPixelRed(image,s) != GetPixelGreen(image,s) ||\n                     GetPixelRed(image,s) != GetPixelBlue(image,s))\n                   {\n                      ping_have_color=MagickTrue;\n                      ping_have_non_bw=MagickTrue;\n                      break;\n                   }\n                 s+=GetPixelChannels(image);\n               }\n\n               if (ping_have_color != MagickFalse)\n                 break;\n\n               /* Worst case is black-and-white; we are looking at every\n                * pixel twice.\n                */\n\n               if (ping_have_non_bw == MagickFalse)\n                 {\n                   s=q;\n                   for (x=0; x < (ssize_t) image->columns; x++)\n                   {\n                     if (GetPixelRed(image,s) != 0 &&\n                         GetPixelRed(image,s) != QuantumRange)\n                       {\n                         ping_have_non_bw=MagickTrue;\n                         break;\n                       }\n                     s+=GetPixelChannels(image);\n                   }\n               }\n             }\n           }\n       }\n\n     if (image_colors < 257)\n       {\n         PixelInfo\n           colormap[260];\n\n         /*\n          * Initialize image colormap.\n          */\n\n         if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      Sort the new colormap\");\n\n        /* Sort palette, transparent first */;\n\n         n = 0;\n\n         for (i=0; i<number_transparent; i++)\n            colormap[n++] = transparent[i];\n\n         for (i=0; i<number_semitransparent; i++)\n            colormap[n++] = semitransparent[i];\n\n         for (i=0; i<number_opaque; i++)\n            colormap[n++] = opaque[i];\n\n         ping_background.index +=\n           (number_transparent + number_semitransparent);\n\n         /* image_colors < 257; search the colormap instead of the pixels\n          * to get ping_have_color and ping_have_non_bw\n          */\n         for (i=0; i<n; i++)\n         {\n           if (ping_have_color == MagickFalse)\n             {\n                if (colormap[i].red != colormap[i].green ||\n                    colormap[i].red != colormap[i].blue)\n                  {\n                     ping_have_color=MagickTrue;\n                     ping_have_non_bw=MagickTrue;\n                     break;\n                  }\n              }\n\n           if (ping_have_non_bw == MagickFalse)\n             {\n               if (colormap[i].red != 0 && colormap[i].red != QuantumRange)\n                   ping_have_non_bw=MagickTrue;\n             }\n          }\n\n        if ((mng_info->ping_exclude_tRNS == MagickFalse ||\n            (number_transparent == 0 && number_semitransparent == 0)) &&\n            (((mng_info->write_png_colortype-1) ==\n            PNG_COLOR_TYPE_PALETTE) ||\n            (mng_info->write_png_colortype == 0)))\n          {\n            if (logging != MagickFalse)\n              {\n                if (n !=  (ssize_t) image_colors)\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"   image_colors (%d) and n (%d)  don't match\",\n                   image_colors, n);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      AcquireImageColormap\");\n              }\n\n            image->colors = image_colors;\n\n            if (AcquireImageColormap(image,image_colors,exception) ==\n                MagickFalse)\n               ThrowWriterException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");\n\n            for (i=0; i< (ssize_t) image_colors; i++)\n               image->colormap[i] = colormap[i];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"      image->colors=%d (%d)\",\n                      (int) image->colors, image_colors);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"      Update the pixel indexes\");\n              }\n\n            /* Sync the pixel indices with the new colormap */\n\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n              if (q == (Quantum *) NULL)\n                break;\n\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                for (i=0; i< (ssize_t) image_colors; i++)\n                {\n                  if ((image->alpha_trait == UndefinedPixelTrait ||\n                      image->colormap[i].alpha == GetPixelAlpha(image,q)) &&\n                      image->colormap[i].red == GetPixelRed(image,q) &&\n                      image->colormap[i].green == GetPixelGreen(image,q) &&\n                      image->colormap[i].blue == GetPixelBlue(image,q))\n                  {\n                    SetPixelIndex(image,i,q);\n                    break;\n                  }\n                }\n                q+=GetPixelChannels(image);\n              }\n\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                 break;\n            }\n          }\n       }\n\n     if (logging != MagickFalse)\n       {\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      image->colors=%d\", (int) image->colors);\n\n         if (image->colormap != NULL)\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"       i     (red,green,blue,alpha)\");\n\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               if (i < 300 || i >= (ssize_t) image->colors - 10)\n                 {\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"       %d     (%d,%d,%d,%d)\",\n                        (int) i,\n                        (int) image->colormap[i].red,\n                        (int) image->colormap[i].green,\n                        (int) image->colormap[i].blue,\n                        (int) image->colormap[i].alpha);\n                 }\n             }\n           }\n\n           if (number_transparent < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_transparent     = %d\",\n                   number_transparent);\n           else\n\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_transparent     > 256\");\n\n           if (number_opaque < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_opaque          = %d\",\n                   number_opaque);\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_opaque          > 256\");\n\n           if (number_semitransparent < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_semitransparent = %d\",\n                   number_semitransparent);\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_semitransparent > 256\");\n\n           if (ping_have_non_bw == MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      All pixels and the background are black or white\");\n\n           else if (ping_have_color == MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      All pixels and the background are gray\");\n\n           else\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      At least one pixel or the background is non-gray\");\n\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Exit BUILD_PALETTE:\");\n       }\n\n   if (mng_info->write_png8 == MagickFalse)\n      break;\n\n   /* Make any reductions necessary for the PNG8 format */\n    if (image_colors <= 256 &&\n        image_colors != 0 && image->colormap != NULL &&\n        number_semitransparent == 0 &&\n        number_transparent <= 1)\n      break;\n\n    /* PNG8 can't have semitransparent colors so we threshold the\n     * opacity to 0 or OpaqueOpacity, and PNG8 can only have one\n     * transparent color so if more than one is transparent we merge\n     * them into image->background_color.\n     */\n    if (number_semitransparent != 0 || number_transparent > 1)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Thresholding the alpha channel to binary\");\n\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (r == (Quantum *) NULL)\n            break;\n\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n              if (GetPixelAlpha(image,r) < OpaqueAlpha/2)\n                {\n                  SetPixelViaPixelInfo(image,&image->background_color,r);\n                  SetPixelAlpha(image,TransparentAlpha,r);\n                }\n              else\n                  SetPixelAlpha(image,OpaqueAlpha,r);\n              r+=GetPixelChannels(image);\n          }\n\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n\n          if (image_colors != 0 && image_colors <= 256 &&\n             image->colormap != NULL)\n            for (i=0; i<image_colors; i++)\n                image->colormap[i].alpha =\n                    (image->colormap[i].alpha > TransparentAlpha/2 ?\n                    TransparentAlpha : OpaqueAlpha);\n        }\n      continue;\n    }\n\n    /* PNG8 can't have more than 256 colors so we quantize the pixels and\n     * background color to the 4-4-4-1, 3-3-3-1 or 3-3-2-1 palette.  If the\n     * image is mostly gray, the 4-4-4-1 palette is likely to end up with 256\n     * colors or less.\n     */\n    if (tried_444 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 4-4-4\");\n\n        tried_444 = MagickTrue;\n\n        LBR04PacketRGB(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 4-4-4\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR04PixelRGB(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 4-4-4\");\n\n          for (i=0; i<image_colors; i++)\n          {\n            LBR04PacketRGB(image->colormap[i]);\n          }\n        }\n        continue;\n      }\n\n    if (tried_333 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 3-3-3\");\n\n        tried_333 = MagickTrue;\n\n        LBR03PacketRGB(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 3-3-3-1\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR03RGB(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 3-3-3-1\");\n          for (i=0; i<image_colors; i++)\n          {\n              LBR03PacketRGB(image->colormap[i]);\n          }\n        }\n        continue;\n      }\n\n    if (tried_332 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 3-3-2\");\n\n        tried_332 = MagickTrue;\n\n        /* Red and green were already done so we only quantize the blue\n         * channel\n         */\n\n        LBR02PacketBlue(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 3-3-2-1\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR02PixelBlue(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 3-3-2-1\");\n          for (i=0; i<image_colors; i++)\n          {\n              LBR02PacketBlue(image->colormap[i]);\n          }\n      }\n      continue;\n    }\n\n    if (image_colors == 0 || image_colors > 256)\n    {\n      /* Take care of special case with 256 opaque colors + 1 transparent\n       * color.  We don't need to quantize to 2-3-2-1; we only need to\n       * eliminate one color, so we'll merge the two darkest red\n       * colors (0x49, 0, 0) -> (0x24, 0, 0).\n       */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Merging two dark red background colors to 3-3-2-1\");\n\n      if (ScaleQuantumToChar(image->background_color.red) == 0x49 &&\n          ScaleQuantumToChar(image->background_color.green) == 0x00 &&\n          ScaleQuantumToChar(image->background_color.blue) == 0x00)\n      {\n         image->background_color.red=ScaleCharToQuantum(0x24);\n      }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Merging two dark red pixel colors to 3-3-2-1\");\n\n      if (image->colormap == NULL)\n      {\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (r == (Quantum *) NULL)\n            break;\n\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (ScaleQuantumToChar(GetPixelRed(image,r)) == 0x49 &&\n                ScaleQuantumToChar(GetPixelGreen(image,r)) == 0x00 &&\n                ScaleQuantumToChar(GetPixelBlue(image,r)) == 0x00 &&\n                GetPixelAlpha(image,r) == OpaqueAlpha)\n              {\n                SetPixelRed(image,ScaleCharToQuantum(0x24),r);\n              }\n            r+=GetPixelChannels(image);\n          }\n\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n\n        }\n      }\n\n      else\n      {\n         for (i=0; i<image_colors; i++)\n         {\n            if (ScaleQuantumToChar(image->colormap[i].red) == 0x49 &&\n                ScaleQuantumToChar(image->colormap[i].green) == 0x00 &&\n                ScaleQuantumToChar(image->colormap[i].blue) == 0x00)\n            {\n               image->colormap[i].red=ScaleCharToQuantum(0x24);\n            }\n         }\n      }\n    }\n  }\n  }\n  /* END OF BUILD_PALETTE */\n\n  /* If we are excluding the tRNS chunk and there is transparency,\n   * then we must write a Gray-Alpha (color-type 4) or RGBA (color-type 6)\n   * PNG.\n   */\n  if (mng_info->ping_exclude_tRNS != MagickFalse &&\n     (number_transparent != 0 || number_semitransparent != 0))\n    {\n      unsigned int colortype=mng_info->write_png_colortype;\n\n      if (ping_have_color == MagickFalse)\n        mng_info->write_png_colortype = 5;\n\n      else\n        mng_info->write_png_colortype = 7;\n\n      if (colortype != 0 &&\n         mng_info->write_png_colortype != colortype)\n        ping_need_colortype_warning=MagickTrue;\n\n    }\n\n  /* See if cheap transparency is possible.  It is only possible\n   * when there is a single transparent color, no semitransparent\n   * color, and no opaque color that has the same RGB components\n   * as the transparent color.  We only need this information if\n   * we are writing a PNG with colortype 0 or 2, and we have not\n   * excluded the tRNS chunk.\n   */\n  if (number_transparent == 1 &&\n      mng_info->write_png_colortype < 4)\n    {\n       ping_have_cheap_transparency = MagickTrue;\n\n       if (number_semitransparent != 0)\n         ping_have_cheap_transparency = MagickFalse;\n\n       else if (image_colors == 0 || image_colors > 256 ||\n           image->colormap == NULL)\n         {\n           register const Quantum\n             *q;\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             q=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n             if (q == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                 if (GetPixelAlpha(image,q) != TransparentAlpha &&\n                     (unsigned short) GetPixelRed(image,q) ==\n                                     ping_trans_color.red &&\n                     (unsigned short) GetPixelGreen(image,q) ==\n                                     ping_trans_color.green &&\n                     (unsigned short) GetPixelBlue(image,q) ==\n                                     ping_trans_color.blue)\n                   {\n                     ping_have_cheap_transparency = MagickFalse;\n                     break;\n                   }\n\n                 q+=GetPixelChannels(image);\n             }\n\n             if (ping_have_cheap_transparency == MagickFalse)\n                break;\n           }\n         }\n       else\n         {\n            /* Assuming that image->colormap[0] is the one transparent color\n             * and that all others are opaque.\n             */\n            if (image_colors > 1)\n              for (i=1; i<image_colors; i++)\n                if (image->colormap[i].red == image->colormap[0].red &&\n                    image->colormap[i].green == image->colormap[0].green &&\n                    image->colormap[i].blue == image->colormap[0].blue)\n                  {\n                     ping_have_cheap_transparency = MagickFalse;\n                     break;\n                  }\n         }\n\n       if (logging != MagickFalse)\n         {\n           if (ping_have_cheap_transparency == MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"   Cheap transparency is not possible.\");\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"   Cheap transparency is possible.\");\n         }\n     }\n  else\n    ping_have_cheap_transparency = MagickFalse;\n\n  image_depth=image->depth;\n\n  quantum_info = (QuantumInfo *) NULL;\n  number_colors=0;\n  image_colors=(int) image->colors;\n  image_matte=image->alpha_trait !=\n        UndefinedPixelTrait ? MagickTrue : MagickFalse;\n\n  if (mng_info->write_png_colortype < 5)\n    mng_info->IsPalette=image->storage_class == PseudoClass &&\n      image_colors <= 256 && image->colormap != NULL;\n  else\n    mng_info->IsPalette = MagickFalse;\n\n  if ((mng_info->write_png_colortype == 4 || mng_info->write_png8) &&\n     (image->colors == 0 || image->colormap == NULL))\n    {\n      image_info=DestroyImageInfo(image_info);\n      image=DestroyImage(image);\n      (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          \"Cannot write PNG8 or color-type 3; colormap is NULL\",\n          \"`%s'\",IMimage->filename);\n      return(MagickFalse);\n    }\n\n  /*\n    Allocate the PNG structures\n  */\n#ifdef PNG_USER_MEM_SUPPORTED\n error_info.image=image;\n error_info.exception=exception;\n  ping=png_create_write_struct_2(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler,(void *) NULL,\n    (png_malloc_ptr) Magick_png_malloc,(png_free_ptr) Magick_png_free);\n\n#else\n  ping=png_create_write_struct(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler);\n\n#endif\n  if (ping == (png_struct *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  ping_info=png_create_info_struct(ping);\n\n  if (ping_info == (png_info *) NULL)\n    {\n      png_destroy_write_struct(&ping,(png_info **) NULL);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n\n  png_set_write_fn(ping,image,png_put_data,png_flush_data);\n  pixel_info=(MemoryInfo *) NULL;\n\n  if (setjmp(png_jmpbuf(ping)))\n    {\n      /*\n        PNG write failed.\n      */\n#ifdef PNG_DEBUG\n     if (image_info->verbose)\n        (void) printf(\"PNG write has failed.\\n\");\n#endif\n      png_destroy_write_struct(&ping,&ping_info);\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n      UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n      if (pixel_info != (MemoryInfo *) NULL)\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n\n      if (quantum_info != (QuantumInfo *) NULL)\n        quantum_info=DestroyQuantumInfo(quantum_info);\n\n      if (ping_have_blob != MagickFalse)\n          (void) CloseBlob(image);\n      image_info=DestroyImageInfo(image_info);\n      image=DestroyImage(image);\n      return(MagickFalse);\n    }\n\n  /* {  For navigation to end of SETJMP-protected block.  Within this\n   *    block, use png_error() instead of Throwing an Exception, to ensure\n   *    that libpng is able to clean up, and that the semaphore is unlocked.\n   */\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  LockSemaphoreInfo(ping_semaphore);\n#endif\n\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\n  /* Allow benign errors */\n  png_set_benign_errors(ping, 1);\n#endif\n\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n  /* Reject images with too many rows or columns */\n  png_set_user_limits(ping,\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(WidthResource)),\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(HeightResource)));\n#endif /* PNG_SET_USER_LIMITS_SUPPORTED */\n\n  /*\n    Prepare PNG for writing.\n  */\n\n#if defined(PNG_MNG_FEATURES_SUPPORTED)\n  if (mng_info->write_mng)\n  {\n     (void) png_permit_mng_features(ping,PNG_ALL_MNG_FEATURES);\n# ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED\n     /* Disable new libpng-1.5.10 feature when writing a MNG because\n      * zero-length PLTE is OK\n      */\n     png_set_check_for_invalid_index (ping, 0);\n# endif\n  }\n\n#else\n# ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED\n  if (mng_info->write_mng)\n     png_permit_empty_plte(ping,MagickTrue);\n\n# endif\n#endif\n\n  x=0;\n\n  ping_width=(png_uint_32) image->columns;\n  ping_height=(png_uint_32) image->rows;\n\n  if (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32)\n     image_depth=8;\n\n  if (mng_info->write_png48 || mng_info->write_png64)\n     image_depth=16;\n\n  if (mng_info->write_png_depth != 0)\n     image_depth=mng_info->write_png_depth;\n\n  /* Adjust requested depth to next higher valid depth if necessary */\n  if (image_depth > 8)\n     image_depth=16;\n\n  if ((image_depth > 4) && (image_depth < 8))\n     image_depth=8;\n\n  if (image_depth == 3)\n     image_depth=4;\n\n  if (logging != MagickFalse)\n    {\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    width=%.20g\",(double) ping_width);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    height=%.20g\",(double) ping_height);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_matte=%.20g\",(double) image->alpha_trait);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image->depth=%.20g\",(double) image->depth);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Tentative ping_bit_depth=%.20g\",(double) image_depth);\n    }\n\n  save_image_depth=image_depth;\n  ping_bit_depth=(png_byte) save_image_depth;\n\n\n#if defined(PNG_pHYs_SUPPORTED)\n  if (ping_exclude_pHYs == MagickFalse)\n  {\n  if ((image->resolution.x != 0) && (image->resolution.y != 0) &&\n      (!mng_info->write_mng || !mng_info->equal_physs))\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Setting up pHYs chunk\");\n\n      if (image->units == PixelsPerInchResolution)\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_METER;\n          ping_pHYs_x_resolution=\n             (png_uint_32) ((100.0*image->resolution.x+0.5)/2.54);\n          ping_pHYs_y_resolution=\n             (png_uint_32) ((100.0*image->resolution.y+0.5)/2.54);\n        }\n\n      else if (image->units == PixelsPerCentimeterResolution)\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_METER;\n          ping_pHYs_x_resolution=(png_uint_32) (100.0*image->resolution.x+0.5);\n          ping_pHYs_y_resolution=(png_uint_32) (100.0*image->resolution.y+0.5);\n        }\n\n      else\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_UNKNOWN;\n          ping_pHYs_x_resolution=(png_uint_32) image->resolution.x;\n          ping_pHYs_y_resolution=(png_uint_32) image->resolution.y;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Set up PNG pHYs chunk: xres: %.20g, yres: %.20g, units: %d.\",\n          (double) ping_pHYs_x_resolution,(double) ping_pHYs_y_resolution,\n          (int) ping_pHYs_unit_type);\n       ping_have_pHYs = MagickTrue;\n    }\n  }\n#endif\n\n  if (ping_exclude_bKGD == MagickFalse)\n  {\n  if ((!mng_info->adjoin || !mng_info->equal_backgrounds))\n    {\n       unsigned int\n         mask;\n\n       mask=0xffff;\n       if (ping_bit_depth == 8)\n          mask=0x00ff;\n\n       if (ping_bit_depth == 4)\n          mask=0x000f;\n\n       if (ping_bit_depth == 2)\n          mask=0x0003;\n\n       if (ping_bit_depth == 1)\n          mask=0x0001;\n\n       ping_background.red=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.red) & mask);\n\n       ping_background.green=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.green) & mask);\n\n       ping_background.blue=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.blue) & mask);\n\n       ping_background.gray=(png_uint_16) ping_background.green;\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Setting up bKGD chunk (1)\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"      background_color index is %d\",\n          (int) ping_background.index);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    ping_bit_depth=%d\",ping_bit_depth);\n    }\n\n  ping_have_bKGD = MagickTrue;\n  }\n\n  /*\n    Select the color type.\n  */\n  matte=image_matte;\n  old_bit_depth=0;\n\n  if (mng_info->IsPalette && mng_info->write_png8)\n    {\n      /* To do: make this a function cause it's used twice, except\n         for reducing the sample depth from 8. */\n\n      number_colors=image_colors;\n\n      ping_have_tRNS=MagickFalse;\n\n      /*\n        Set image palette.\n      */\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Setting up PLTE chunk with %d colors (%d)\",\n            number_colors, image_colors);\n\n      for (i=0; i < (ssize_t) number_colors; i++)\n      {\n        palette[i].red=ScaleQuantumToChar(image->colormap[i].red);\n        palette[i].green=ScaleQuantumToChar(image->colormap[i].green);\n        palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n#if MAGICKCORE_QUANTUM_DEPTH == 8\n            \"    %3ld (%3d,%3d,%3d)\",\n#else\n            \"    %5ld (%5d,%5d,%5d)\",\n#endif\n            (long) i,palette[i].red,palette[i].green,palette[i].blue);\n\n      }\n\n      ping_have_PLTE=MagickTrue;\n      image_depth=ping_bit_depth;\n      ping_num_trans=0;\n\n      if (matte != MagickFalse)\n      {\n          /*\n            Identify which colormap entry is transparent.\n          */\n          assert(number_colors <= 256);\n          assert(image->colormap != NULL);\n\n          for (i=0; i < (ssize_t) number_transparent; i++)\n             ping_trans_alpha[i]=0;\n\n\n          ping_num_trans=(unsigned short) (number_transparent +\n             number_semitransparent);\n\n          if (ping_num_trans == 0)\n             ping_have_tRNS=MagickFalse;\n\n          else\n             ping_have_tRNS=MagickTrue;\n      }\n\n      if (ping_exclude_bKGD == MagickFalse)\n      {\n       /*\n        * Identify which colormap entry is the background color.\n        */\n\n        for (i=0; i < (ssize_t) MagickMax(1L*number_colors-1L,1L); i++)\n          if (IsPNGColorEqual(ping_background,image->colormap[i]))\n            break;\n\n        ping_background.index=(png_byte) i;\n\n        if (logging != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"      background_color index is %d\",\n                 (int) ping_background.index);\n          }\n      }\n    } /* end of write_png8 */\n\n  else if (mng_info->write_png_colortype == 1)\n    {\n      image_matte=MagickFalse;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;\n    }\n\n  else if (mng_info->write_png24 || mng_info->write_png48 ||\n      mng_info->write_png_colortype == 3)\n    {\n      image_matte=MagickFalse;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n    }\n\n  else if (mng_info->write_png32 || mng_info->write_png64 ||\n      mng_info->write_png_colortype == 7)\n    {\n      image_matte=MagickTrue;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;\n    }\n\n  else /* mng_info->write_pngNN not specified */\n    {\n      image_depth=ping_bit_depth;\n\n      if (mng_info->write_png_colortype != 0)\n        {\n          ping_color_type=(png_byte) mng_info->write_png_colortype-1;\n\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\n              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            image_matte=MagickTrue;\n\n          else\n            image_matte=MagickFalse;\n\n          if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"   PNG colortype %d was specified:\",(int) ping_color_type);\n        }\n\n      else /* write_png_colortype not specified */\n        {\n          if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Selecting PNG colortype:\");\n\n          ping_color_type=(png_byte) ((matte != MagickFalse)?\n            PNG_COLOR_TYPE_RGB_ALPHA:PNG_COLOR_TYPE_RGB);\n\n          if (image_info->type == TrueColorType)\n            {\n              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n              image_matte=MagickFalse;\n            }\n\n          if (image_info->type == TrueColorAlphaType)\n            {\n              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;\n              image_matte=MagickTrue;\n            }\n\n          if (image_info->type == PaletteType ||\n              image_info->type == PaletteAlphaType)\n            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n          if (mng_info->write_png_colortype == 0 &&\n             image_info->type == UndefinedType)\n            {\n              if (ping_have_color == MagickFalse)\n                {\n                  if (image_matte == MagickFalse)\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;\n                      image_matte=MagickFalse;\n                    }\n\n                  else\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY_ALPHA;\n                      image_matte=MagickTrue;\n                    }\n                }\n              else\n                {\n                  if (image_matte == MagickFalse)\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n                      image_matte=MagickFalse;\n                    }\n\n                  else\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGBA;\n                      image_matte=MagickTrue;\n                    }\n                 }\n            }\n\n        }\n\n      if (logging != MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    Selected PNG colortype=%d\",ping_color_type);\n\n      if (ping_bit_depth < 8)\n        {\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\n              ping_color_type == PNG_COLOR_TYPE_RGB ||\n              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            ping_bit_depth=8;\n        }\n\n      old_bit_depth=ping_bit_depth;\n\n      if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n        {\n          if (image->alpha_trait == UndefinedPixelTrait &&\n               ping_have_non_bw == MagickFalse)\n             ping_bit_depth=1;\n        }\n\n      if (ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        {\n           size_t one = 1;\n           ping_bit_depth=1;\n\n           if (image->colors == 0)\n           {\n              /* DO SOMETHING */\n                png_error(ping,\"image has 0 colors\");\n           }\n\n           while ((int) (one << ping_bit_depth) < (ssize_t) image_colors)\n             ping_bit_depth <<= 1;\n        }\n\n      if (logging != MagickFalse)\n         {\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Number of colors: %.20g\",(double) image_colors);\n\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Tentative PNG bit depth: %d\",ping_bit_depth);\n         }\n\n      if (ping_bit_depth < (int) mng_info->write_png_depth)\n         ping_bit_depth = mng_info->write_png_depth;\n    }\n\n  image_depth=ping_bit_depth;\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Tentative PNG color type: %s (%.20g)\",\n        PngColorTypeToString(ping_color_type),\n        (double) ping_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_info->type: %.20g\",(double) image_info->type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_depth: %.20g\",(double) image_depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\n        \"    image->depth: %.20g\",(double) image->depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    ping_bit_depth: %.20g\",(double) ping_bit_depth);\n    }\n\n  if (matte != MagickFalse)\n    {\n      if (mng_info->IsPalette)\n        {\n          if (mng_info->write_png_colortype == 0)\n            {\n              ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;\n\n              if (ping_have_color != MagickFalse)\n                 ping_color_type=PNG_COLOR_TYPE_RGBA;\n            }\n\n          /*\n           * Determine if there is any transparent color.\n          */\n          if (number_transparent + number_semitransparent == 0)\n            {\n              /*\n                No transparent pixels are present.  Change 4 or 6 to 0 or 2.\n              */\n\n              image_matte=MagickFalse;\n\n              if (mng_info->write_png_colortype == 0)\n                ping_color_type&=0x03;\n            }\n\n          else\n            {\n              unsigned int\n                mask;\n\n              mask=0xffff;\n\n              if (ping_bit_depth == 8)\n                 mask=0x00ff;\n\n              if (ping_bit_depth == 4)\n                 mask=0x000f;\n\n              if (ping_bit_depth == 2)\n                 mask=0x0003;\n\n              if (ping_bit_depth == 1)\n                 mask=0x0001;\n\n              ping_trans_color.red=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].red) & mask);\n\n              ping_trans_color.green=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].green) & mask);\n\n              ping_trans_color.blue=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].blue) & mask);\n\n              ping_trans_color.gray=(png_uint_16)\n                (ScaleQuantumToShort(GetPixelInfoIntensity(image,\n                   image->colormap)) & mask);\n\n              ping_trans_color.index=(png_byte) 0;\n\n              ping_have_tRNS=MagickTrue;\n            }\n\n          if (ping_have_tRNS != MagickFalse)\n            {\n              /*\n               * Determine if there is one and only one transparent color\n               * and if so if it is fully transparent.\n               */\n              if (ping_have_cheap_transparency == MagickFalse)\n                ping_have_tRNS=MagickFalse;\n            }\n\n          if (ping_have_tRNS != MagickFalse)\n            {\n              if (mng_info->write_png_colortype == 0)\n                ping_color_type &= 0x03;  /* changes 4 or 6 to 0 or 2 */\n\n              if (image_depth == 8)\n                {\n                  ping_trans_color.red&=0xff;\n                  ping_trans_color.green&=0xff;\n                  ping_trans_color.blue&=0xff;\n                  ping_trans_color.gray&=0xff;\n                }\n            }\n        }\n      else\n        {\n          if (image_depth == 8)\n            {\n              ping_trans_color.red&=0xff;\n              ping_trans_color.green&=0xff;\n              ping_trans_color.blue&=0xff;\n              ping_trans_color.gray&=0xff;\n            }\n        }\n    }\n\n    matte=image_matte;\n\n    if (ping_have_tRNS != MagickFalse)\n      image_matte=MagickFalse;\n\n    if ((mng_info->IsPalette) &&\n        mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE &&\n        ping_have_color == MagickFalse &&\n        (image_matte == MagickFalse || image_depth >= 8))\n      {\n        size_t one=1;\n\n        if (image_matte != MagickFalse)\n          ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;\n\n        else if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_GRAY_ALPHA)\n          {\n            ping_color_type=PNG_COLOR_TYPE_GRAY;\n\n            if (save_image_depth == 16 && image_depth == 8)\n              {\n                if (logging != MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Scaling ping_trans_color (0)\");\n                  }\n                    ping_trans_color.gray*=0x0101;\n              }\n          }\n\n        if (image_depth > MAGICKCORE_QUANTUM_DEPTH)\n          image_depth=MAGICKCORE_QUANTUM_DEPTH;\n\n        if ((image_colors == 0) ||\n             ((ssize_t) (image_colors-1) > (ssize_t) MaxColormapSize))\n          image_colors=(int) (one << image_depth);\n\n        if (image_depth > 8)\n          ping_bit_depth=16;\n\n        else\n          {\n            ping_bit_depth=8;\n            if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n              {\n                if(!mng_info->write_png_depth)\n                  {\n                    ping_bit_depth=1;\n\n                    while ((int) (one << ping_bit_depth)\n                        < (ssize_t) image_colors)\n                      ping_bit_depth <<= 1;\n                  }\n              }\n\n            else if (ping_color_type ==\n                PNG_COLOR_TYPE_GRAY && image_colors < 17 &&\n                mng_info->IsPalette)\n              {\n              /* Check if grayscale is reducible */\n\n                int\n                  depth_4_ok=MagickTrue,\n                  depth_2_ok=MagickTrue,\n                  depth_1_ok=MagickTrue;\n\n                for (i=0; i < (ssize_t) image_colors; i++)\n                {\n                   unsigned char\n                     intensity;\n\n                   intensity=ScaleQuantumToChar(image->colormap[i].red);\n\n                   if ((intensity & 0x0f) != ((intensity & 0xf0) >> 4))\n                     depth_4_ok=depth_2_ok=depth_1_ok=MagickFalse;\n                   else if ((intensity & 0x03) != ((intensity & 0x0c) >> 2))\n                     depth_2_ok=depth_1_ok=MagickFalse;\n                   else if ((intensity & 0x01) != ((intensity & 0x02) >> 1))\n                     depth_1_ok=MagickFalse;\n                }\n\n                if (depth_1_ok && mng_info->write_png_depth <= 1)\n                  ping_bit_depth=1;\n\n                else if (depth_2_ok && mng_info->write_png_depth <= 2)\n                  ping_bit_depth=2;\n\n                else if (depth_4_ok && mng_info->write_png_depth <= 4)\n                  ping_bit_depth=4;\n              }\n          }\n\n          image_depth=ping_bit_depth;\n      }\n\n    else\n\n      if (mng_info->IsPalette)\n      {\n        number_colors=image_colors;\n\n        if (image_depth <= 8)\n          {\n            /*\n              Set image palette.\n            */\n            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n            if (!(mng_info->have_write_global_plte && matte == MagickFalse))\n              {\n                for (i=0; i < (ssize_t) number_colors; i++)\n                {\n                  palette[i].red=ScaleQuantumToChar(image->colormap[i].red);\n                  palette[i].green=\n                    ScaleQuantumToChar(image->colormap[i].green);\n                  palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);\n                }\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Setting up PLTE chunk with %d colors\",\n                    number_colors);\n\n                ping_have_PLTE=MagickTrue;\n              }\n\n            /* color_type is PNG_COLOR_TYPE_PALETTE */\n            if (mng_info->write_png_depth == 0)\n              {\n                size_t\n                  one;\n\n                ping_bit_depth=1;\n                one=1;\n\n                while ((one << ping_bit_depth) < (size_t) number_colors)\n                  ping_bit_depth <<= 1;\n              }\n\n            ping_num_trans=0;\n\n            if (matte != MagickFalse)\n              {\n                /*\n                 * Set up trans_colors array.\n                 */\n                assert(number_colors <= 256);\n\n                ping_num_trans=(unsigned short) (number_transparent +\n                  number_semitransparent);\n\n                if (ping_num_trans == 0)\n                  ping_have_tRNS=MagickFalse;\n\n                else\n                  {\n                    if (logging != MagickFalse)\n                      {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Scaling ping_trans_color (1)\");\n                      }\n                    ping_have_tRNS=MagickTrue;\n\n                    for (i=0; i < ping_num_trans; i++)\n                    {\n                       ping_trans_alpha[i]= (png_byte)\n                         ScaleQuantumToChar(image->colormap[i].alpha);\n                    }\n                  }\n              }\n          }\n      }\n\n    else\n      {\n\n        if (image_depth < 8)\n          image_depth=8;\n\n        if ((save_image_depth == 16) && (image_depth == 8))\n          {\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Scaling ping_trans_color from (%d,%d,%d)\",\n                  (int) ping_trans_color.red,\n                  (int) ping_trans_color.green,\n                  (int) ping_trans_color.blue);\n              }\n\n            ping_trans_color.red*=0x0101;\n            ping_trans_color.green*=0x0101;\n            ping_trans_color.blue*=0x0101;\n            ping_trans_color.gray*=0x0101;\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    to (%d,%d,%d)\",\n                  (int) ping_trans_color.red,\n                  (int) ping_trans_color.green,\n                  (int) ping_trans_color.blue);\n              }\n          }\n      }\n\n    if (ping_bit_depth <  (ssize_t) mng_info->write_png_depth)\n         ping_bit_depth =  (ssize_t) mng_info->write_png_depth;\n\n    /*\n      Adjust background and transparency samples in sub-8-bit grayscale files.\n    */\n    if (ping_bit_depth < 8 && ping_color_type ==\n        PNG_COLOR_TYPE_GRAY)\n      {\n         png_uint_16\n           maxval;\n\n         size_t\n           one=1;\n\n         maxval=(png_uint_16) ((one << ping_bit_depth)-1);\n\n         if (ping_exclude_bKGD == MagickFalse)\n         {\n\n         ping_background.gray=(png_uint_16) ((maxval/65535.)*\n           (ScaleQuantumToShort(((GetPixelInfoIntensity(image,\n           &image->background_color))) +.5)));\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Setting up bKGD chunk (2)\");\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      background_color index is %d\",\n             (int) ping_background.index);\n\n         ping_have_bKGD = MagickTrue;\n         }\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Scaling ping_trans_color.gray from %d\",\n             (int)ping_trans_color.gray);\n\n         ping_trans_color.gray=(png_uint_16) ((maxval/255.)*(\n           ping_trans_color.gray)+.5);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      to %d\", (int)ping_trans_color.gray);\n      }\n\n  if (ping_exclude_bKGD == MagickFalse)\n  {\n    if (mng_info->IsPalette && (int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n      {\n        /*\n           Identify which colormap entry is the background color.\n        */\n\n        number_colors=image_colors;\n\n        for (i=0; i < (ssize_t) MagickMax(1L*number_colors,1L); i++)\n          if (IsPNGColorEqual(image->background_color,image->colormap[i]))\n            break;\n\n        ping_background.index=(png_byte) i;\n\n        if (logging != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Setting up bKGD chunk with index=%d\",(int) i);\n          }\n\n        if (i < (ssize_t) number_colors)\n          {\n            ping_have_bKGD = MagickTrue;\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"     background   =(%d,%d,%d)\",\n                        (int) ping_background.red,\n                        (int) ping_background.green,\n                        (int) ping_background.blue);\n              }\n          }\n\n        else  /* Can't happen */\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      No room in PLTE to add bKGD color\");\n            ping_have_bKGD = MagickFalse;\n          }\n      }\n  }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    PNG color type: %s (%d)\", PngColorTypeToString(ping_color_type),\n      ping_color_type);\n  /*\n    Initialize compression level and filtering.\n  */\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Setting up deflate compression\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Compression buffer size: 32768\");\n    }\n\n  png_set_compression_buffer_size(ping,32768L);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Compression mem level: 9\");\n\n  png_set_compression_mem_level(ping, 9);\n\n  /* Untangle the \"-quality\" setting:\n\n     Undefined is 0; the default is used.\n     Default is 75\n\n     10's digit:\n\n        0 or omitted: Use Z_HUFFMAN_ONLY strategy with the\n           zlib default compression level\n\n        1-9: the zlib compression level\n\n     1's digit:\n\n        0-4: the PNG filter method\n\n        5:   libpng adaptive filtering if compression level > 5\n             libpng filter type \"none\" if compression level <= 5\n                or if image is grayscale or palette\n\n        6:   libpng adaptive filtering\n\n        7:   \"LOCO\" filtering (intrapixel differing) if writing\n             a MNG, otherwise \"none\".  Did not work in IM-6.7.0-9\n             and earlier because of a missing \"else\".\n\n        8:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), adaptive\n             filtering. Unused prior to IM-6.7.0-10, was same as 6\n\n        9:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), no PNG filters\n             Unused prior to IM-6.7.0-10, was same as 6\n\n    Note that using the -quality option, not all combinations of\n    PNG filter type, zlib compression level, and zlib compression\n    strategy are possible.  This will be addressed soon in a\n    release that accomodates \"-define png:compression-strategy\", etc.\n\n   */\n\n  quality=image_info->quality == UndefinedCompressionQuality ? 75UL :\n     image_info->quality;\n\n  if (quality <= 9)\n    {\n      if (mng_info->write_png_compression_strategy == 0)\n        mng_info->write_png_compression_strategy = Z_HUFFMAN_ONLY+1;\n    }\n\n  else if (mng_info->write_png_compression_level == 0)\n    {\n      int\n        level;\n\n      level=(int) MagickMin((ssize_t) quality/10,9);\n\n      mng_info->write_png_compression_level = level+1;\n    }\n\n  if (mng_info->write_png_compression_strategy == 0)\n    {\n        if ((quality %10) == 8 || (quality %10) == 9)\n#ifdef Z_RLE  /* Z_RLE was added to zlib-1.2.0 */\n          mng_info->write_png_compression_strategy=Z_RLE+1;\n#else\n          mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;\n#endif\n    }\n\n  if (mng_info->write_png_compression_filter == 0)\n        mng_info->write_png_compression_filter=((int) quality % 10) + 1;\n\n  if (logging != MagickFalse)\n    {\n        if (mng_info->write_png_compression_level)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Compression level:    %d\",\n            (int) mng_info->write_png_compression_level-1);\n\n        if (mng_info->write_png_compression_strategy)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Compression strategy: %d\",\n            (int) mng_info->write_png_compression_strategy-1);\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Setting up filtering\");\n\n        if (mng_info->write_png_compression_filter == 6)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: ADAPTIVE\");\n        else if (mng_info->write_png_compression_filter == 0 ||\n                 mng_info->write_png_compression_filter == 1)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: NONE\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: %d\",\n            (int) mng_info->write_png_compression_filter-1);\n    }\n\n  if (mng_info->write_png_compression_level != 0)\n    png_set_compression_level(ping,mng_info->write_png_compression_level-1);\n\n  if (mng_info->write_png_compression_filter == 6)\n    {\n      if (((int) ping_color_type == PNG_COLOR_TYPE_GRAY) ||\n         ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE) ||\n         (quality < 50))\n        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n      else\n        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);\n     }\n  else if (mng_info->write_png_compression_filter == 7 ||\n      mng_info->write_png_compression_filter == 10)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);\n\n  else if (mng_info->write_png_compression_filter == 8)\n    {\n#if defined(PNG_MNG_FEATURES_SUPPORTED) && defined(PNG_INTRAPIXEL_DIFFERENCING)\n      if (mng_info->write_mng)\n      {\n         if (((int) ping_color_type == PNG_COLOR_TYPE_RGB) ||\n             ((int) ping_color_type == PNG_COLOR_TYPE_RGBA))\n        ping_filter_method=PNG_INTRAPIXEL_DIFFERENCING;\n      }\n#endif\n      png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n    }\n\n  else if (mng_info->write_png_compression_filter == 9)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n\n  else if (mng_info->write_png_compression_filter != 0)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,\n       mng_info->write_png_compression_filter-1);\n\n  if (mng_info->write_png_compression_strategy != 0)\n    png_set_compression_strategy(ping,\n       mng_info->write_png_compression_strategy-1);\n\n  ping_interlace_method=image_info->interlace != NoInterlace;\n\n  if (mng_info->write_mng)\n    png_set_sig_bytes(ping,8);\n\n  /* Bail out if cannot meet defined png:bit-depth or png:color-type */\n\n  if (mng_info->write_png_colortype != 0)\n    {\n     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY)\n       if (ping_have_color != MagickFalse)\n         {\n           ping_color_type = PNG_COLOR_TYPE_RGB;\n\n           if (ping_bit_depth < 8)\n             ping_bit_depth=8;\n         }\n\n     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY_ALPHA)\n       if (ping_have_color != MagickFalse)\n         ping_color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n    }\n\n  if (ping_need_colortype_warning != MagickFalse ||\n     ((mng_info->write_png_depth &&\n     (int) mng_info->write_png_depth != ping_bit_depth) ||\n     (mng_info->write_png_colortype &&\n     ((int) mng_info->write_png_colortype-1 != ping_color_type &&\n      mng_info->write_png_colortype != 7 &&\n      !(mng_info->write_png_colortype == 5 && ping_color_type == 0)))))\n    {\n      if (logging != MagickFalse)\n        {\n          if (ping_need_colortype_warning != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Image has transparency but tRNS chunk was excluded\");\n            }\n\n          if (mng_info->write_png_depth)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Defined png:bit-depth=%u, Computed depth=%u\",\n                  mng_info->write_png_depth,\n                  ping_bit_depth);\n            }\n\n          if (mng_info->write_png_colortype)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Defined png:color-type=%u, Computed color type=%u\",\n                  mng_info->write_png_colortype-1,\n                  ping_color_type);\n            }\n        }\n\n      png_warning(ping,\n        \"Cannot write image with defined png:bit-depth or png:color-type.\");\n    }\n\n  if (image_matte != MagickFalse && image->alpha_trait == UndefinedPixelTrait)\n    {\n      /* Add an opaque matte channel */\n      image->alpha_trait = BlendPixelTrait;\n      (void) SetImageAlpha(image,OpaqueAlpha,exception);\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Added an opaque matte channel\");\n    }\n\n  if (number_transparent != 0 || number_semitransparent != 0)\n    {\n      if (ping_color_type < 4)\n        {\n           ping_have_tRNS=MagickTrue;\n           if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Setting ping_have_tRNS=MagickTrue.\");\n        }\n    }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Writing PNG header chunks\");\n\n  png_set_IHDR(ping,ping_info,ping_width,ping_height,\n               ping_bit_depth,ping_color_type,\n               ping_interlace_method,ping_compression_method,\n               ping_filter_method);\n\n  if (ping_color_type == 3 && ping_have_PLTE != MagickFalse)\n    {\n      png_set_PLTE(ping,ping_info,palette,number_colors);\n\n      if (logging != MagickFalse)\n        {\n          for (i=0; i< (ssize_t) number_colors; i++)\n          {\n            if (i < ping_num_trans)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"     PLTE[%d] = (%d,%d,%d), tRNS[%d] = (%d)\",\n                      (int) i,\n                      (int) palette[i].red,\n                      (int) palette[i].green,\n                      (int) palette[i].blue,\n                      (int) i,\n                      (int) ping_trans_alpha[i]);\n             else\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"     PLTE[%d] = (%d,%d,%d)\",\n                      (int) i,\n                      (int) palette[i].red,\n                      (int) palette[i].green,\n                      (int) palette[i].blue);\n           }\n         }\n    }\n\n  /* Only write the iCCP chunk if we are not writing the sRGB chunk. */\n  if (ping_exclude_sRGB != MagickFalse ||\n     (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n  {\n    if ((ping_exclude_tEXt == MagickFalse ||\n       ping_exclude_zTXt == MagickFalse) &&\n       (ping_exclude_iCCP == MagickFalse || ping_exclude_zCCP == MagickFalse))\n    {\n      ResetImageProfileIterator(image);\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        profile=GetImageProfile(image,name);\n\n        if (profile != (StringInfo *) NULL)\n          {\n#ifdef PNG_WRITE_iCCP_SUPPORTED\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0))\n              {\n                ping_have_iCCP = MagickTrue;\n                if (ping_exclude_iCCP == MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Setting up iCCP chunk\");\n\n                    png_set_iCCP(ping,ping_info,(png_charp) name,0,\n#if (PNG_LIBPNG_VER < 10500)\n                    (png_charp) GetStringInfoDatum(profile),\n#else\n                    (const png_byte *) GetStringInfoDatum(profile),\n#endif\n                    (png_uint_32) GetStringInfoLength(profile));\n                  }\n                else\n                  {\n                    /* Do not write hex-encoded ICC chunk */\n                       name=GetNextImageProfile(image);\n                       continue;\n                  }\n              }\n#endif /* WRITE_iCCP */\n\n            if (LocaleCompare(name,\"exif\") == 0)\n              {\n                   /* Do not write hex-encoded ICC chunk; we will\n                      write it later as an eXIf chunk */\n                   name=GetNextImageProfile(image);\n                   continue;\n              }\n\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Setting up zTXt chunk with uuencoded %s profile\",\n                 name);\n              Magick_png_write_raw_profile(image_info,ping,ping_info,\n                (unsigned char *) name,(unsigned char *) name,\n                GetStringInfoDatum(profile),\n                (png_uint_32) GetStringInfoLength(profile));\n          }\n        name=GetNextImageProfile(image);\n      }\n    }\n  }\n\n#if defined(PNG_WRITE_sRGB_SUPPORTED)\n  if ((mng_info->have_write_global_srgb == 0) &&\n      ping_have_iCCP != MagickTrue &&\n      (ping_have_sRGB != MagickFalse ||\n      png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n    {\n      if (ping_exclude_sRGB == MagickFalse)\n        {\n          /*\n            Note image rendering intent.\n          */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Setting up sRGB chunk\");\n\n          (void) png_set_sRGB(ping,ping_info,(\n            Magick_RenderingIntent_to_PNG_RenderingIntent(\n              image->rendering_intent)));\n\n          ping_have_sRGB = MagickTrue;\n        }\n    }\n\n  if ((!mng_info->write_mng) || (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n#endif\n    {\n      if (ping_exclude_gAMA == MagickFalse &&\n          ping_have_iCCP == MagickFalse &&\n          ping_have_sRGB == MagickFalse &&\n          (ping_exclude_sRGB == MagickFalse ||\n          (image->gamma < .45 || image->gamma > .46)))\n      {\n      if ((mng_info->have_write_global_gama == 0) && (image->gamma != 0.0))\n        {\n          /*\n            Note image gamma.\n            To do: check for cHRM+gAMA == sRGB, and write sRGB instead.\n          */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Setting up gAMA chunk\");\n\n          png_set_gAMA(ping,ping_info,image->gamma);\n        }\n      }\n\n      if (ping_exclude_cHRM == MagickFalse && ping_have_sRGB == MagickFalse)\n        {\n          if ((mng_info->have_write_global_chrm == 0) &&\n              (image->chromaticity.red_primary.x != 0.0))\n            {\n              /*\n                Note image chromaticity.\n                Note: if cHRM+gAMA == sRGB write sRGB instead.\n              */\n               PrimaryInfo\n                 bp,\n                 gp,\n                 rp,\n                 wp;\n\n               wp=image->chromaticity.white_point;\n               rp=image->chromaticity.red_primary;\n               gp=image->chromaticity.green_primary;\n               bp=image->chromaticity.blue_primary;\n\n               if (logging != MagickFalse)\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Setting up cHRM chunk\");\n\n               png_set_cHRM(ping,ping_info,wp.x,wp.y,rp.x,rp.y,gp.x,gp.y,\n                   bp.x,bp.y);\n           }\n        }\n    }\n\n  if (ping_exclude_bKGD == MagickFalse)\n    {\n      if (ping_have_bKGD != MagickFalse)\n        {\n          png_set_bKGD(ping,ping_info,&ping_background);\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Setting up bKGD chunk\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      background color = (%d,%d,%d)\",\n                        (int) ping_background.red,\n                        (int) ping_background.green,\n                        (int) ping_background.blue);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      index = %d, gray=%d\",\n                        (int) ping_background.index,\n                        (int) ping_background.gray);\n            }\n         }\n    }\n\n  if (ping_exclude_pHYs == MagickFalse)\n    {\n      if (ping_have_pHYs != MagickFalse)\n        {\n          png_set_pHYs(ping,ping_info,\n             ping_pHYs_x_resolution,\n             ping_pHYs_y_resolution,\n             ping_pHYs_unit_type);\n\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Setting up pHYs chunk\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      x_resolution=%lu\",\n                   (unsigned long) ping_pHYs_x_resolution);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      y_resolution=%lu\",\n                   (unsigned long) ping_pHYs_y_resolution);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      unit_type=%lu\",\n                   (unsigned long) ping_pHYs_unit_type);\n            }\n        }\n    }\n\n#if defined(PNG_tIME_SUPPORTED)\n  if (ping_exclude_tIME == MagickFalse)\n    {\n      const char\n        *timestamp;\n\n      if (image->taint == MagickFalse)\n        {\n          timestamp=GetImageOption(image_info,\"png:tIME\");\n\n          if (timestamp == (const char *) NULL)\n            timestamp=GetImageProperty(image,\"png:tIME\",exception);\n        }\n\n      else\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Reset tIME in tainted image\");\n\n          timestamp=GetImageProperty(image,\"date:modify\",exception);\n        }\n\n      if (timestamp != (const char *) NULL)\n          write_tIME_chunk(image,ping,ping_info,timestamp,exception);\n    }\n#endif\n\n  if (mng_info->need_blob != MagickFalse)\n  {\n    if (OpenBlob(image_info,image,WriteBinaryBlobMode,exception) ==\n       MagickFalse)\n       png_error(ping,\"WriteBlob Failed\");\n\n     ping_have_blob=MagickTrue;\n  }\n\n  png_write_info_before_PLTE(ping, ping_info);\n\n  if (ping_have_tRNS != MagickFalse && ping_color_type < 4)\n    {\n      if (logging != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Calling png_set_tRNS with num_trans=%d\",ping_num_trans);\n        }\n\n      if (ping_color_type == 3)\n         (void) png_set_tRNS(ping, ping_info,\n                ping_trans_alpha,\n                ping_num_trans,\n                NULL);\n\n      else\n        {\n           (void) png_set_tRNS(ping, ping_info,\n                  NULL,\n                  0,\n                  &ping_trans_color);\n\n           if (logging != MagickFalse)\n             {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"     tRNS color   =(%d,%d,%d)\",\n                       (int) ping_trans_color.red,\n                       (int) ping_trans_color.green,\n                       (int) ping_trans_color.blue);\n             }\n         }\n    }\n\n  /* write any png-chunk-b profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-b\",logging);\n\n  png_write_info(ping,ping_info);\n\n  /* write any PNG-chunk-m profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-m\",logging);\n\n  ping_wrote_caNv = MagickFalse;\n\n  /* write caNv chunk */\n  if (ping_exclude_caNv == MagickFalse)\n    {\n      if ((image->page.width != 0 && image->page.width != image->columns) ||\n          (image->page.height != 0 && image->page.height != image->rows) ||\n          image->page.x != 0 || image->page.y != 0)\n        {\n          unsigned char\n            chunk[20];\n\n          (void) WriteBlobMSBULong(image,16L);  /* data length=8 */\n          PNGType(chunk,mng_caNv);\n          LogPNGChunk(logging,mng_caNv,16L);\n          PNGLong(chunk+4,(png_uint_32) image->page.width);\n          PNGLong(chunk+8,(png_uint_32) image->page.height);\n          PNGsLong(chunk+12,(png_int_32) image->page.x);\n          PNGsLong(chunk+16,(png_int_32) image->page.y);\n          (void) WriteBlob(image,20,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,20));\n          ping_wrote_caNv = MagickTrue;\n        }\n    }\n\n#if defined(PNG_oFFs_SUPPORTED)\n  if (ping_exclude_oFFs == MagickFalse && ping_wrote_caNv == MagickFalse)\n    {\n      if (image->page.x || image->page.y)\n        {\n           png_set_oFFs(ping,ping_info,(png_int_32) image->page.x,\n              (png_int_32) image->page.y, 0);\n\n           if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Setting up oFFs chunk with x=%d, y=%d, units=0\",\n                 (int) image->page.x, (int) image->page.y);\n        }\n    }\n#endif\n\n  /* write vpAg chunk (deprecated, replaced by caNv) */\n  if (ping_exclude_vpAg == MagickFalse && ping_wrote_caNv == MagickFalse)\n    {\n      if ((image->page.width != 0 && image->page.width != image->columns) ||\n          (image->page.height != 0 && image->page.height != image->rows))\n        {\n          unsigned char\n            chunk[14];\n\n          (void) WriteBlobMSBULong(image,9L);  /* data length=8 */\n          PNGType(chunk,mng_vpAg);\n          LogPNGChunk(logging,mng_vpAg,9L);\n          PNGLong(chunk+4,(png_uint_32) image->page.width);\n          PNGLong(chunk+8,(png_uint_32) image->page.height);\n          chunk[12]=0;   /* unit = pixels */\n          (void) WriteBlob(image,13,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,13));\n        }\n    }\n\n#if (PNG_LIBPNG_VER == 10206)\n    /* avoid libpng-1.2.6 bug by setting PNG_HAVE_IDAT flag */\n#define PNG_HAVE_IDAT               0x04\n    ping->mode |= PNG_HAVE_IDAT;\n#undef PNG_HAVE_IDAT\n#endif\n\n  png_set_packing(ping);\n  /*\n    Allocate memory.\n  */\n  rowbytes=image->columns;\n  if (image_depth > 8)\n    rowbytes*=2;\n  switch (ping_color_type)\n    {\n      case PNG_COLOR_TYPE_RGB:\n        rowbytes*=3;\n        break;\n\n      case PNG_COLOR_TYPE_GRAY_ALPHA:\n        rowbytes*=2;\n        break;\n\n      case PNG_COLOR_TYPE_RGBA:\n        rowbytes*=4;\n        break;\n\n      default:\n        break;\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Writing PNG image data\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Allocating %.20g bytes of memory for pixels\",(double) rowbytes);\n    }\n  pixel_info=AcquireVirtualMemory(rowbytes,sizeof(*ping_pixels));\n  if (pixel_info == (MemoryInfo *) NULL)\n    png_error(ping,\"Allocation of memory for pixels failed\");\n  ping_pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n\n  /*\n    Initialize image scanlines.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    png_error(ping,\"Memory allocation for quantum_info failed\");\n  quantum_info->format=UndefinedQuantumFormat;\n  SetQuantumDepth(image,quantum_info,image_depth);\n  (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n  num_passes=png_set_interlace_handling(ping);\n\n  if ((!mng_info->write_png8 && !mng_info->write_png24 &&\n       !mng_info->write_png48 && !mng_info->write_png64 &&\n       !mng_info->write_png32) &&\n       (mng_info->IsPalette ||\n       (image_info->type == BilevelType)) &&\n       image_matte == MagickFalse &&\n       ping_have_non_bw == MagickFalse)\n    {\n      /* Palette, Bilevel, or Opaque Monochrome */\n      register const Quantum\n        *p;\n\n      SetQuantumDepth(image,quantum_info,8);\n      for (pass=0; pass < num_passes; pass++)\n      {\n        /*\n          Convert PseudoClass image to a PNG monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          if (logging != MagickFalse && y == 0)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Writing row of pixels (0)\");\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n          if (p == (const Quantum *) NULL)\n            break;\n\n          if (mng_info->IsPalette)\n            {\n              (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                quantum_info,GrayQuantum,ping_pixels,exception);\n              if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_PALETTE &&\n                  mng_info->write_png_depth &&\n                  mng_info->write_png_depth != old_bit_depth)\n                {\n                  /* Undo pixel scaling */\n                  for (i=0; i < (ssize_t) image->columns; i++)\n                     *(ping_pixels+i)=(unsigned char) (*(ping_pixels+i)\n                     >> (8-old_bit_depth));\n                }\n            }\n\n          else\n            {\n              (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                quantum_info,RedQuantum,ping_pixels,exception);\n            }\n\n          if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE)\n            for (i=0; i < (ssize_t) image->columns; i++)\n               *(ping_pixels+i)=(unsigned char) ((*(ping_pixels+i) > 127) ?\n                      255 : 0);\n\n          if (logging != MagickFalse && y == 0)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Writing row of pixels (1)\");\n\n          png_write_row(ping,ping_pixels);\n\n          status=SetImageProgress(image,SaveImageTag,\n              (MagickOffsetType) (pass * image->rows + y),\n              num_passes * image->rows);\n\n          if (status == MagickFalse)\n            break;\n        }\n      }\n    }\n\n  else   /* Not Palette, Bilevel, or Opaque Monochrome */\n    {\n      if ((!mng_info->write_png8 && !mng_info->write_png24 &&\n          !mng_info->write_png48 && !mng_info->write_png64 &&\n          !mng_info->write_png32) && (image_matte != MagickFalse ||\n          (ping_bit_depth >= MAGICKCORE_QUANTUM_DEPTH)) &&\n          (mng_info->IsPalette) && ping_have_color == MagickFalse)\n        {\n          register const Quantum\n            *p;\n\n          for (pass=0; pass < num_passes; pass++)\n          {\n\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n            if (p == (const Quantum *) NULL)\n              break;\n\n            if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n              {\n                if (mng_info->IsPalette)\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,GrayQuantum,ping_pixels,exception);\n\n                else\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RedQuantum,ping_pixels,exception);\n\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"    Writing GRAY PNG pixels (2)\");\n              }\n\n            else /* PNG_COLOR_TYPE_GRAY_ALPHA */\n              {\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Writing GRAY_ALPHA PNG pixels (2)\");\n\n                (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,GrayAlphaQuantum,ping_pixels,exception);\n              }\n\n            if (logging != MagickFalse && y == 0)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Writing row of pixels (2)\");\n\n            png_write_row(ping,ping_pixels);\n\n            status=SetImageProgress(image,SaveImageTag,\n              (MagickOffsetType) (pass * image->rows + y),\n              num_passes * image->rows);\n\n            if (status == MagickFalse)\n              break;\n            }\n          }\n        }\n\n      else\n        {\n          register const Quantum\n            *p;\n\n          for (pass=0; pass < num_passes; pass++)\n          {\n            if ((image_depth > 8) ||\n                mng_info->write_png24 ||\n                mng_info->write_png32 ||\n                mng_info->write_png48 ||\n                mng_info->write_png64 ||\n                (!mng_info->write_png8 && !mng_info->IsPalette))\n            {\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n                if (p == (const Quantum *) NULL)\n                  break;\n\n                if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n                  {\n                    if (image->storage_class == DirectClass)\n                      (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                        quantum_info,RedQuantum,ping_pixels,exception);\n\n                    else\n                      (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                        quantum_info,GrayQuantum,ping_pixels,exception);\n                  }\n\n                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n                  {\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                      quantum_info,GrayAlphaQuantum,ping_pixels,\n                      exception);\n\n                    if (logging != MagickFalse && y == 0)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"    Writing GRAY_ALPHA PNG pixels (3)\");\n                  }\n\n                else if (image_matte != MagickFalse)\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RGBAQuantum,ping_pixels,exception);\n\n                else\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RGBQuantum,ping_pixels,exception);\n\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"    Writing row of pixels (3)\");\n\n                png_write_row(ping,ping_pixels);\n\n                status=SetImageProgress(image,SaveImageTag,\n                  (MagickOffsetType) (pass * image->rows + y),\n                  num_passes * image->rows);\n\n                if (status == MagickFalse)\n                  break;\n              }\n            }\n\n          else\n            /* not ((image_depth > 8) ||\n                mng_info->write_png24 || mng_info->write_png32 ||\n                mng_info->write_png48 || mng_info->write_png64 ||\n                (!mng_info->write_png8 && !mng_info->IsPalette))\n             */\n            {\n              if ((ping_color_type != PNG_COLOR_TYPE_GRAY) &&\n                  (ping_color_type != PNG_COLOR_TYPE_GRAY_ALPHA))\n                {\n                  if (logging != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"  pass %d, Image Is not GRAY or GRAY_ALPHA\",pass);\n\n                  SetQuantumDepth(image,quantum_info,8);\n                  image_depth=8;\n                }\n\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  pass %d, Image Is RGB, 16-bit GRAY, or GRAY_ALPHA\",\n                    pass);\n\n                p=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n                if (p == (const Quantum *) NULL)\n                  break;\n\n                if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n                  {\n                    SetQuantumDepth(image,quantum_info,image->depth);\n\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                       quantum_info,GrayQuantum,ping_pixels,exception);\n                  }\n\n                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n                  {\n                    if (logging != MagickFalse && y == 0)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"  Writing GRAY_ALPHA PNG pixels (4)\");\n\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                         quantum_info,GrayAlphaQuantum,ping_pixels,\n                         exception);\n                  }\n\n                else\n                  {\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                      quantum_info,IndexQuantum,ping_pixels,exception);\n\n                    if (logging != MagickFalse && y <= 2)\n                    {\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Writing row of non-gray pixels (4)\");\n\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  ping_pixels[0]=%d,ping_pixels[1]=%d\",\n                          (int)ping_pixels[0],(int)ping_pixels[1]);\n                    }\n                  }\n                png_write_row(ping,ping_pixels);\n\n                status=SetImageProgress(image,SaveImageTag,\n                  (MagickOffsetType) (pass * image->rows + y),\n                  num_passes * image->rows);\n\n                if (status == MagickFalse)\n                  break;\n              }\n            }\n          }\n        }\n    }\n\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Wrote PNG image data\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Width: %.20g\",(double) ping_width);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Height: %.20g\",(double) ping_height);\n\n      if (mng_info->write_png_depth)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Defined png:bit-depth: %d\",mng_info->write_png_depth);\n        }\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG bit-depth written: %d\",ping_bit_depth);\n\n      if (mng_info->write_png_colortype)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Defined png:color-type: %d\",mng_info->write_png_colortype-1);\n        }\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG color-type written: %d\",ping_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG Interlace method: %d\",ping_interlace_method);\n    }\n  /*\n    Generate text chunks after IDAT.\n  */\n  if (ping_exclude_tEXt == MagickFalse || ping_exclude_zTXt == MagickFalse)\n  {\n    ResetImagePropertyIterator(image);\n    property=GetNextImageProperty(image);\n    while (property != (const char *) NULL)\n    {\n      png_textp\n        text;\n\n      value=GetImageProperty(image,property,exception);\n\n      /* Don't write any \"png:\" or \"jpeg:\" properties; those are just for\n       * \"identify\" or for passing through to another JPEG\n       */\n      if ((LocaleNCompare(property,\"png:\",4) != 0 &&\n           LocaleNCompare(property,\"jpeg:\",5) != 0) &&\n\n\n          /* Suppress density and units if we wrote a pHYs chunk */\n          (ping_exclude_pHYs != MagickFalse      ||\n          LocaleCompare(property,\"density\") != 0 ||\n          LocaleCompare(property,\"units\") != 0) &&\n\n          /* Suppress the IM-generated Date:create and Date:modify */\n          (ping_exclude_date == MagickFalse      ||\n          LocaleNCompare(property, \"Date:\",5) != 0))\n        {\n        if (value != (const char *) NULL)\n          {\n\n#if PNG_LIBPNG_VER >= 10400\n            text=(png_textp) png_malloc(ping,\n                 (png_alloc_size_t) sizeof(png_text));\n#else\n            text=(png_textp) png_malloc(ping,(png_size_t) sizeof(png_text));\n#endif\n            text[0].key=(char *) property;\n            text[0].text=(char *) value;\n            text[0].text_length=strlen(value);\n\n            if (ping_exclude_tEXt != MagickFalse)\n               text[0].compression=PNG_TEXT_COMPRESSION_zTXt;\n\n            else if (ping_exclude_zTXt != MagickFalse)\n               text[0].compression=PNG_TEXT_COMPRESSION_NONE;\n\n            else\n            {\n               text[0].compression=image_info->compression == NoCompression ||\n                 (image_info->compression == UndefinedCompression &&\n                 text[0].text_length < 128) ? PNG_TEXT_COMPRESSION_NONE :\n                 PNG_TEXT_COMPRESSION_zTXt ;\n            }\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Setting up text chunk\");\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    keyword: '%s'\",text[0].key);\n              }\n\n            png_set_text(ping,ping_info,text,1);\n            png_free(ping,text);\n          }\n        }\n      property=GetNextImageProperty(image);\n    }\n  }\n\n  /* write any PNG-chunk-e profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-e\",logging);\n\n  /* write exIf profile */\n  if (ping_have_eXIf != MagickFalse && ping_exclude_eXIf == MagickFalse)\n    {\n      char\n        *name;\n\n      ResetImageProfileIterator(image);\n\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        if (LocaleCompare(name,\"exif\") == 0)\n          {\n            const StringInfo\n              *profile;\n\n            profile=GetImageProfile(image,name);\n\n            if (profile != (StringInfo *) NULL)\n              {\n                png_uint_32\n                  length;\n\n                unsigned char\n                  chunk[4],\n                  *data;\n\n               StringInfo\n                 *ping_profile;\n\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Have eXIf profile\");\n\n               ping_profile=CloneStringInfo(profile);\n               data=GetStringInfoDatum(ping_profile),\n               length=(png_uint_32) GetStringInfoLength(ping_profile);\n\n               PNGType(chunk,mng_eXIf);\n               if (length < 7)\n                 {\n                   ping_profile=DestroyStringInfo(ping_profile);\n                   break;  /* otherwise crashes */\n                 }\n\n               /* skip the \"Exif\\0\\0\" JFIF Exif Header ID */\n               length -= 6;\n\n               LogPNGChunk(logging,chunk,length);\n               (void) WriteBlobMSBULong(image,length);\n               (void) WriteBlob(image,4,chunk);\n               (void) WriteBlob(image,length,data+6);\n               (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),\n                 data+6, (uInt) length));\n               ping_profile=DestroyStringInfo(ping_profile);\n               break;\n             }\n         }\n       name=GetNextImageProfile(image);\n     }\n  }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Writing PNG end info\");\n\n  png_write_end(ping,ping_info);\n\n  if (mng_info->need_fram && (int) image->dispose == BackgroundDispose)\n    {\n      if (mng_info->page.x || mng_info->page.y ||\n          (ping_width != mng_info->page.width) ||\n          (ping_height != mng_info->page.height))\n        {\n          unsigned char\n            chunk[32];\n\n          /*\n            Write FRAM 4 with clipping boundaries followed by FRAM 1.\n          */\n          (void) WriteBlobMSBULong(image,27L);  /* data length=27 */\n          PNGType(chunk,mng_FRAM);\n          LogPNGChunk(logging,mng_FRAM,27L);\n          chunk[4]=4;\n          chunk[5]=0;  /* frame name separator (no name) */\n          chunk[6]=1;  /* flag for changing delay, for next frame only */\n          chunk[7]=0;  /* flag for changing frame timeout */\n          chunk[8]=1;  /* flag for changing frame clipping for next frame */\n          chunk[9]=0;  /* flag for changing frame sync_id */\n          PNGLong(chunk+10,(png_uint_32) (0L)); /* temporary 0 delay */\n          chunk[14]=0; /* clipping boundaries delta type */\n          PNGLong(chunk+15,(png_uint_32) (mng_info->page.x)); /* left cb */\n          PNGLong(chunk+19,\n             (png_uint_32) (mng_info->page.x + ping_width));\n          PNGLong(chunk+23,(png_uint_32) (mng_info->page.y)); /* top cb */\n          PNGLong(chunk+27,\n             (png_uint_32) (mng_info->page.y + ping_height));\n          (void) WriteBlob(image,31,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,31));\n          mng_info->old_framing_mode=4;\n          mng_info->framing_mode=1;\n        }\n\n      else\n        mng_info->framing_mode=3;\n    }\n  if (mng_info->write_mng && !mng_info->need_fram &&\n      ((int) image->dispose == 3))\n     png_error(ping, \"Cannot convert GIF with disposal method 3 to MNG-LC\");\n\n  /*\n    Free PNG resources.\n  */\n\n  png_destroy_write_struct(&ping,&ping_info);\n\n  pixel_info=RelinquishVirtualMemory(pixel_info);\n\n  if (ping_have_blob != MagickFalse)\n     (void) CloseBlob(image);\n\n  image_info=DestroyImageInfo(image_info);\n  image=DestroyImage(image);\n\n  /* Store bit depth actually written */\n  s[0]=(char) ping_bit_depth;\n  s[1]='\\0';\n\n  (void) SetImageProperty(IMimage,\"png:bit-depth-written\",s,exception);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit WriteOnePNGImage()\");\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n   /* }  for navigation to beginning of SETJMP-protected block. Revert to\n    *    Throwing an Exception when an error occurs.\n    */\n\n  return(MagickTrue);\n/*  End write one PNG image */\n\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142476,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "forward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,\n\t\t     UChar* range, UChar** low, UChar** high, UChar** low_prev)\n{\n  UChar *p, *pprev = (UChar* )NULL;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"forward_search_range: str: %d, end: %d, s: %d, range: %d\\n\",\n\t  (int )str, (int )end, (int )s, (int )range);\n#endif\n\n  p = s;\n  if (reg->dmin > 0) {\n    if (ONIGENC_IS_SINGLEBYTE(reg->enc)) {\n      p += reg->dmin;\n    }\n    else {\n      UChar *q = p + reg->dmin;\n\n      if (q >= end) return 0; /* fail */\n      while (p < q) p += enclen(reg->enc, p);\n    }\n  }\n\n retry:\n  switch (reg->optimize) {\n  case ONIG_OPTIMIZE_EXACT:\n    p = slow_search(reg->enc, reg->exact, reg->exact_end, p, end, range);\n    break;\n  case ONIG_OPTIMIZE_EXACT_IC:\n    p = slow_search_ic(reg->enc, reg->case_fold_flag,\n                       reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_BM:\n    p = bm_search(reg, reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_BM_NOT_REV:\n    p = bm_search_notrev(reg, reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_MAP:\n    p = map_search(reg->enc, reg->map, p, range);\n    break;\n  }\n\n  if (p && p < range) {\n    if (p - reg->dmin < s) {\n    retry_gate:\n      pprev = p;\n      p += enclen(reg->enc, p);\n      goto retry;\n    }\n\n    if (reg->sub_anchor) {\n      UChar* prev;\n\n      switch (reg->sub_anchor) {\n      case ANCHOR_BEGIN_LINE:\n        if (!ON_STR_BEGIN(p)) {\n          prev = onigenc_get_prev_char_head(reg->enc,\n                                            (pprev ? pprev : str), p);\n          if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n        }\n        break;\n\n      case ANCHOR_END_LINE:\n        if (ON_STR_END(p)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n          prev = (UChar* )onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : str), p);\n          if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n#endif\n        }\n        else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n                 && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)\n#endif\n                 )\n          goto retry_gate;\n        break;\n      }\n    }\n\n    if (reg->dmax == 0) {\n      *low = p;\n      if (low_prev) {\n        if (*low > s)\n          *low_prev = onigenc_get_prev_char_head(reg->enc, s, p);\n        else\n          *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                 (pprev ? pprev : str), p);\n      }\n     }\n     else {\n       if (reg->dmax != ONIG_INFINITE_DISTANCE) {\n        *low = p - reg->dmax;\n        if (*low > s) {\n          *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,\n                                          *low, (const UChar** )low_prev);\n          if (low_prev && IS_NULL(*low_prev))\n            *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                   (pprev ? pprev : s), *low);\n         }\n         else {\n          if (low_prev)\n            *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                   (pprev ? pprev : str), *low);\n         }\n       }\n     }\n    /* no needs to adjust *high, *high is used as range check only */\n    *high = p - reg->dmin;\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr,\n    \"forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\\n\",\n\t    (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);\n#endif\n    return 1; /* success */\n  }\n\n  return 0; /* fail */\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142529,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "forward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,\n\t\t     UChar* range, UChar** low, UChar** high, UChar** low_prev)\n{\n  UChar *p, *pprev = (UChar* )NULL;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"forward_search_range: str: %d, end: %d, s: %d, range: %d\\n\",\n\t  (int )str, (int )end, (int )s, (int )range);\n#endif\n\n  p = s;\n  if (reg->dmin > 0) {\n    if (ONIGENC_IS_SINGLEBYTE(reg->enc)) {\n      p += reg->dmin;\n    }\n    else {\n      UChar *q = p + reg->dmin;\n\n      if (q >= end) return 0; /* fail */\n      while (p < q) p += enclen(reg->enc, p);\n    }\n  }\n\n retry:\n  switch (reg->optimize) {\n  case ONIG_OPTIMIZE_EXACT:\n    p = slow_search(reg->enc, reg->exact, reg->exact_end, p, end, range);\n    break;\n  case ONIG_OPTIMIZE_EXACT_IC:\n    p = slow_search_ic(reg->enc, reg->case_fold_flag,\n                       reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_BM:\n    p = bm_search(reg, reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_BM_NOT_REV:\n    p = bm_search_notrev(reg, reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_MAP:\n    p = map_search(reg->enc, reg->map, p, range);\n    break;\n  }\n\n  if (p && p < range) {\n    if (p - reg->dmin < s) {\n    retry_gate:\n      pprev = p;\n      p += enclen(reg->enc, p);\n      goto retry;\n    }\n\n    if (reg->sub_anchor) {\n      UChar* prev;\n\n      switch (reg->sub_anchor) {\n      case ANCHOR_BEGIN_LINE:\n        if (!ON_STR_BEGIN(p)) {\n          prev = onigenc_get_prev_char_head(reg->enc,\n                                            (pprev ? pprev : str), p);\n          if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n        }\n        break;\n\n      case ANCHOR_END_LINE:\n        if (ON_STR_END(p)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n          prev = (UChar* )onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : str), p);\n          if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n#endif\n        }\n        else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n                 && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)\n#endif\n                 )\n          goto retry_gate;\n        break;\n      }\n    }\n\n    if (reg->dmax == 0) {\n      *low = p;\n      if (low_prev) {\n        if (*low > s)\n          *low_prev = onigenc_get_prev_char_head(reg->enc, s, p);\n        else\n          *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                 (pprev ? pprev : str), p);\n      }\n     }\n     else {\n       if (reg->dmax != ONIG_INFINITE_DISTANCE) {\n        if (p - str < reg->dmax) {\n          *low = (UChar* )str;\n          if (low_prev)\n            *low_prev = onigenc_get_prev_char_head(reg->enc, str, *low);\n         }\n         else {\n          *low = p - reg->dmax;\n          if (*low > s) {\n            *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,\n                                                 *low, (const UChar** )low_prev);\n            if (low_prev && IS_NULL(*low_prev))\n              *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : s), *low);\n          }\n          else {\n            if (low_prev)\n              *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : str), *low);\n          }\n         }\n       }\n     }\n    /* no needs to adjust *high, *high is used as range check only */\n    *high = p - reg->dmin;\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr,\n    \"forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\\n\",\n\t    (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);\n#endif\n    return 1; /* success */\n  }\n\n  return 0; /* fail */\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142530,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(skcipher);\n\n\tif (tfm->__crt_alg->cra_type == &crypto_blkcipher_type)\n\t\treturn crypto_init_skcipher_ops_blkcipher(tfm);\n\n\tif (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type ||\n \t    tfm->__crt_alg->cra_type == &crypto_givcipher_type)\n \t\treturn crypto_init_skcipher_ops_ablkcipher(tfm);\n \n\tskcipher->setkey = alg->setkey;\n \tskcipher->encrypt = alg->encrypt;\n \tskcipher->decrypt = alg->decrypt;\n \tskcipher->ivsize = alg->ivsize;\n\tskcipher->keysize = alg->max_keysize;\n\n\tif (alg->exit)\n\t\tskcipher->base.exit = crypto_skcipher_exit_tfm;\n\n\tif (alg->init)\n\t\treturn alg->init(skcipher);\n\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142535,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(skcipher);\n\n\tif (tfm->__crt_alg->cra_type == &crypto_blkcipher_type)\n\t\treturn crypto_init_skcipher_ops_blkcipher(tfm);\n\n\tif (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type ||\n \t    tfm->__crt_alg->cra_type == &crypto_givcipher_type)\n \t\treturn crypto_init_skcipher_ops_ablkcipher(tfm);\n \n\tskcipher->setkey = skcipher_setkey;\n \tskcipher->encrypt = alg->encrypt;\n \tskcipher->decrypt = alg->decrypt;\n \tskcipher->ivsize = alg->ivsize;\n\tskcipher->keysize = alg->max_keysize;\n\n\tif (alg->exit)\n\t\tskcipher->base.exit = crypto_skcipher_exit_tfm;\n\n\tif (alg->init)\n\t\treturn alg->init(skcipher);\n\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142536,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int nsv_read_chunk(AVFormatContext *s, int fill_header)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st[2] = {NULL, NULL};\n    NSVStream *nst;\n    AVPacket *pkt;\n    int i, err = 0;\n    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */\n     uint32_t vsize;\n     uint16_t asize;\n     uint16_t auxsize;\n \n     if (nsv->ahead[0].data || nsv->ahead[1].data)\n         return 0; //-1; /* hey! eat what you've in your plate first! */\n\nnull_chunk_retry:\n    if (pb->eof_reached)\n        return -1;\n\n    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)\n        err = nsv_resync(s);\n    if (err < 0)\n        return err;\n    if (nsv->state == NSV_FOUND_NSVS)\n        err = nsv_parse_NSVs_header(s);\n    if (err < 0)\n        return err;\n    if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)\n        return -1;\n\n    auxcount = avio_r8(pb);\n    vsize = avio_rl16(pb);\n    asize = avio_rl16(pb);\n    vsize = (vsize << 4) | (auxcount >> 4);\n    auxcount &= 0x0f;\n    av_log(s, AV_LOG_TRACE, \"NSV CHUNK %\"PRIu8\" aux, %\"PRIu32\" bytes video, %\"PRIu16\" bytes audio\\n\",\n           auxcount, vsize, asize);\n    /* skip aux stuff */\n    for (i = 0; i < auxcount; i++) {\n        uint32_t av_unused auxtag;\n        auxsize = avio_rl16(pb);\n        auxtag = avio_rl32(pb);\n        avio_skip(pb, auxsize);\n        vsize -= auxsize + sizeof(uint16_t) + sizeof(uint32_t); /* that's becoming brain-dead */\n    }\n\n    if (pb->eof_reached)\n        return -1;\n    if (!vsize && !asize) {\n        nsv->state = NSV_UNSYNC;\n        goto null_chunk_retry;\n    }\n\n    /* map back streams to v,a */\n    if (s->nb_streams > 0)\n        st[s->streams[0]->id] = s->streams[0];\n    if (s->nb_streams > 1)\n        st[s->streams[1]->id] = s->streams[1];\n\n     if (vsize && st[NSV_ST_VIDEO]) {\n         nst = st[NSV_ST_VIDEO]->priv_data;\n         pkt = &nsv->ahead[NSV_ST_VIDEO];\n        av_get_packet(pb, pkt, vsize);\n         pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;\n         pkt->dts = nst->frame_offset;\n         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n        for (i = 0; i < FFMIN(8, vsize); i++)\n            av_log(s, AV_LOG_TRACE, \"NSV video: [%d] = %02\"PRIx8\"\\n\",\n                   i, pkt->data[i]);\n    }\n    if(st[NSV_ST_VIDEO])\n        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;\n\n    if (asize && st[NSV_ST_AUDIO]) {\n        nst = st[NSV_ST_AUDIO]->priv_data;\n        pkt = &nsv->ahead[NSV_ST_AUDIO];\n        /* read raw audio specific header on the first audio chunk... */\n        /* on ALL audio chunks ?? seems so! */\n        if (asize && st[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C', 'M', ' ')/* && fill_header*/) {\n            uint8_t bps;\n            uint8_t channels;\n            uint16_t samplerate;\n            bps = avio_r8(pb);\n            channels = avio_r8(pb);\n            samplerate = avio_rl16(pb);\n            if (!channels || !samplerate)\n                return AVERROR_INVALIDDATA;\n            asize-=4;\n            av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                   bps, channels, samplerate);\n            if (fill_header) {\n                st[NSV_ST_AUDIO]->need_parsing = AVSTREAM_PARSE_NONE; /* we know everything */\n                if (bps != 16) {\n                    av_log(s, AV_LOG_TRACE, \"NSV AUDIO bit/sample != 16 (%\"PRIu8\")!!!\\n\", bps);\n                }\n                bps /= channels; // ???\n                if (bps == 8)\n                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n                samplerate /= 4;/* UGH ??? XXX */\n                channels = 1;\n                st[NSV_ST_AUDIO]->codecpar->channels = channels;\n                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;\n                av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                        bps, channels, samplerate);\n             }\n         }\n        av_get_packet(pb, pkt, asize);\n         pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;\n         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n         if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n            /* on a nsvs frame we have new information on a/v sync */\n            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);\n            pkt->dts *= (int64_t)1000        * nsv->framerate.den;\n            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;\n            av_log(s, AV_LOG_TRACE, \"NSV AUDIO: sync:%\"PRId16\", dts:%\"PRId64,\n                   nsv->avsync, pkt->dts);\n        }\n        nst->frame_offset++;\n    }\n\n    nsv->state = NSV_UNSYNC;\n    return 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142559,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int nsv_read_chunk(AVFormatContext *s, int fill_header)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st[2] = {NULL, NULL};\n    NSVStream *nst;\n    AVPacket *pkt;\n    int i, err = 0;\n    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */\n     uint32_t vsize;\n     uint16_t asize;\n     uint16_t auxsize;\n    int ret;\n \n     if (nsv->ahead[0].data || nsv->ahead[1].data)\n         return 0; //-1; /* hey! eat what you've in your plate first! */\n\nnull_chunk_retry:\n    if (pb->eof_reached)\n        return -1;\n\n    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)\n        err = nsv_resync(s);\n    if (err < 0)\n        return err;\n    if (nsv->state == NSV_FOUND_NSVS)\n        err = nsv_parse_NSVs_header(s);\n    if (err < 0)\n        return err;\n    if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)\n        return -1;\n\n    auxcount = avio_r8(pb);\n    vsize = avio_rl16(pb);\n    asize = avio_rl16(pb);\n    vsize = (vsize << 4) | (auxcount >> 4);\n    auxcount &= 0x0f;\n    av_log(s, AV_LOG_TRACE, \"NSV CHUNK %\"PRIu8\" aux, %\"PRIu32\" bytes video, %\"PRIu16\" bytes audio\\n\",\n           auxcount, vsize, asize);\n    /* skip aux stuff */\n    for (i = 0; i < auxcount; i++) {\n        uint32_t av_unused auxtag;\n        auxsize = avio_rl16(pb);\n        auxtag = avio_rl32(pb);\n        avio_skip(pb, auxsize);\n        vsize -= auxsize + sizeof(uint16_t) + sizeof(uint32_t); /* that's becoming brain-dead */\n    }\n\n    if (pb->eof_reached)\n        return -1;\n    if (!vsize && !asize) {\n        nsv->state = NSV_UNSYNC;\n        goto null_chunk_retry;\n    }\n\n    /* map back streams to v,a */\n    if (s->nb_streams > 0)\n        st[s->streams[0]->id] = s->streams[0];\n    if (s->nb_streams > 1)\n        st[s->streams[1]->id] = s->streams[1];\n\n     if (vsize && st[NSV_ST_VIDEO]) {\n         nst = st[NSV_ST_VIDEO]->priv_data;\n         pkt = &nsv->ahead[NSV_ST_VIDEO];\n        if ((ret = av_get_packet(pb, pkt, vsize)) < 0)\n            return ret;\n         pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;\n         pkt->dts = nst->frame_offset;\n         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n        for (i = 0; i < FFMIN(8, vsize); i++)\n            av_log(s, AV_LOG_TRACE, \"NSV video: [%d] = %02\"PRIx8\"\\n\",\n                   i, pkt->data[i]);\n    }\n    if(st[NSV_ST_VIDEO])\n        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;\n\n    if (asize && st[NSV_ST_AUDIO]) {\n        nst = st[NSV_ST_AUDIO]->priv_data;\n        pkt = &nsv->ahead[NSV_ST_AUDIO];\n        /* read raw audio specific header on the first audio chunk... */\n        /* on ALL audio chunks ?? seems so! */\n        if (asize && st[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C', 'M', ' ')/* && fill_header*/) {\n            uint8_t bps;\n            uint8_t channels;\n            uint16_t samplerate;\n            bps = avio_r8(pb);\n            channels = avio_r8(pb);\n            samplerate = avio_rl16(pb);\n            if (!channels || !samplerate)\n                return AVERROR_INVALIDDATA;\n            asize-=4;\n            av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                   bps, channels, samplerate);\n            if (fill_header) {\n                st[NSV_ST_AUDIO]->need_parsing = AVSTREAM_PARSE_NONE; /* we know everything */\n                if (bps != 16) {\n                    av_log(s, AV_LOG_TRACE, \"NSV AUDIO bit/sample != 16 (%\"PRIu8\")!!!\\n\", bps);\n                }\n                bps /= channels; // ???\n                if (bps == 8)\n                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n                samplerate /= 4;/* UGH ??? XXX */\n                channels = 1;\n                st[NSV_ST_AUDIO]->codecpar->channels = channels;\n                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;\n                av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                        bps, channels, samplerate);\n             }\n         }\n        if ((ret = av_get_packet(pb, pkt, asize)) < 0)\n            return ret;\n         pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;\n         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n         if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n            /* on a nsvs frame we have new information on a/v sync */\n            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);\n            pkt->dts *= (int64_t)1000        * nsv->framerate.den;\n            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;\n            av_log(s, AV_LOG_TRACE, \"NSV AUDIO: sync:%\"PRId16\", dts:%\"PRId64,\n                   nsv->avsync, pkt->dts);\n        }\n        nst->frame_offset++;\n    }\n\n    nsv->state = NSV_UNSYNC;\n    return 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142560,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int mailimf_group_parse(const char * message, size_t length,\n\t\t\t       size_t * indx,\n\t\t\t       struct mailimf_group ** result)\n{\n  size_t cur_token;\n  char * display_name;\n  struct mailimf_mailbox_list * mailbox_list;\n   struct mailimf_group * group;\n   int r;\n   int res;\n \n   cur_token = * indx;\n \n  mailbox_list = NULL;\n\n  r = mailimf_display_name_parse(message, length, &cur_token, &display_name);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_display_name;\n  }\n\n  r = mailimf_mailbox_list_parse(message, length, &cur_token, &mailbox_list);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    break;\n  case MAILIMF_ERROR_PARSE:\n    r = mailimf_cfws_parse(message, length, &cur_token);\n    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n       res = r;\n       goto free_display_name;\n     }\n     break;\n   default:\n     res = r;\n    goto free_display_name;\n  }\n\n  r = mailimf_semi_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_mailbox_list;\n  }\n\n  group = mailimf_group_new(display_name, mailbox_list);\n  if (group == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_mailbox_list;\n  }\n\n  * indx = cur_token;\n  * result = group;\n\n  return MAILIMF_NO_ERROR;\n\n free_mailbox_list:\n  if (mailbox_list != NULL) {\n    mailimf_mailbox_list_free(mailbox_list);\n  }\n free_display_name:\n  mailimf_display_name_free(display_name);\n err:\n  return res;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142567,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int mailimf_group_parse(const char * message, size_t length,\n\t\t\t       size_t * indx,\n\t\t\t       struct mailimf_group ** result)\n{\n  size_t cur_token;\n  char * display_name;\n  struct mailimf_mailbox_list * mailbox_list;\n   struct mailimf_group * group;\n   int r;\n   int res;\n  clist * list;\n \n   cur_token = * indx;\n \n  mailbox_list = NULL;\n\n  r = mailimf_display_name_parse(message, length, &cur_token, &display_name);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_display_name;\n  }\n\n  r = mailimf_mailbox_list_parse(message, length, &cur_token, &mailbox_list);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    break;\n  case MAILIMF_ERROR_PARSE:\n    r = mailimf_cfws_parse(message, length, &cur_token);\n    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n       res = r;\n       goto free_display_name;\n     }\n    list = clist_new();\n    if (list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      goto free_display_name;\n    }\n    mailbox_list = mailimf_mailbox_list_new(list);\n    if (mailbox_list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      clist_free(list);\n      goto free_display_name;\n    }\n     break;\n   default:\n     res = r;\n    goto free_display_name;\n  }\n\n  r = mailimf_semi_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_mailbox_list;\n  }\n\n  group = mailimf_group_new(display_name, mailbox_list);\n  if (group == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_mailbox_list;\n  }\n\n  * indx = cur_token;\n  * result = group;\n\n  return MAILIMF_NO_ERROR;\n\n free_mailbox_list:\n  if (mailbox_list != NULL) {\n    mailimf_mailbox_list_free(mailbox_list);\n  }\n free_display_name:\n  mailimf_display_name_free(display_name);\n err:\n  return res;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142568,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {\n\tRASN1Object *object;\n\tRCMS *container;\n\tif (!buffer || !length) {\n\t\treturn NULL;\n\t}\n\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n \t\treturn NULL;\n \t}\n \tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {\n \t\tr_asn1_free_object (object);\n \t\tfree (container);\n \t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tr_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);\n\tr_asn1_free_object (object);\n\treturn container;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142609,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {\n\tRASN1Object *object;\n\tRCMS *container;\n\tif (!buffer || !length) {\n\t\treturn NULL;\n\t}\n\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n \t\treturn NULL;\n \t}\n \tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects ||\n\t\t!object->list.objects[0] || !object->list.objects[1] ||\n\t\tobject->list.objects[1]->list.length != 1) {\n \t\tr_asn1_free_object (object);\n \t\tfree (container);\n \t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tr_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);\n\tr_asn1_free_object (object);\n\treturn container;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142610,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    magick[14];\n\n  Image\n    *image;\n\n  int\n    foundPropEnd = 0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  register ssize_t\n    i;\n\n  size_t\n    image_type,\n    length;\n\n  ssize_t\n    count;\n\n  XCFDocInfo\n    doc_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  count=ReadBlob(image,14,(unsigned char *) magick);\n  if ((count != 14) ||\n      (LocaleNCompare((char *) magick,\"gimp xcf\",8) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ResetMagickMemory(&doc_info,0,sizeof(XCFDocInfo));\n  doc_info.exception=exception;\n  doc_info.width=ReadBlobMSBLong(image);\n  doc_info.height=ReadBlobMSBLong(image);\n  if ((doc_info.width > 262144) || (doc_info.height > 262144))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  doc_info.image_type=ReadBlobMSBLong(image);\n  /*\n    Initialize image attributes.\n  */\n  image->columns=doc_info.width;\n  image->rows=doc_info.height;\n  image_type=doc_info.image_type;\n  doc_info.file_size=GetBlobSize(image);\n  image->compression=NoCompression;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (image_type == GIMP_RGB)\n    ;\n  else\n    if (image_type == GIMP_GRAY)\n      image->colorspace=GRAYColorspace;\n    else\n      if (image_type == GIMP_INDEXED)\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n  (void) SetImageOpacity(image,OpaqueOpacity); \n  (void) SetImageBackgroundColor(image);\n  /*\n    Read properties.\n  */\n  while ((foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse))\n  {\n    PropType prop_type = (PropType) ReadBlobMSBLong(image);\n    size_t prop_size = ReadBlobMSBLong(image);\n\n    switch (prop_type)\n    {\n      case PROP_END:\n        foundPropEnd=1;\n        break;\n      case PROP_COLORMAP:\n      {\n        /* Cannot rely on prop_size here--the value is set incorrectly\n           by some Gimp versions.\n        */\n        size_t num_colours = ReadBlobMSBLong(image);\n        if (DiscardBlobBytes(image,3*num_colours) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n    /*\n      if (info->file_version == 0)\n      {\n        gint i;\n\n        g_message (_(\"XCF warning: version 0 of XCF file format\\n\"\n           \"did not save indexed colormaps correctly.\\n\"\n           \"Substituting grayscale map.\"));\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        xcf_seek_pos (info, info->cp + gimage->num_cols);\n        for (i = 0; i<gimage->num_cols; i++)\n          {\n            gimage->cmap[i*3+0] = i;\n            gimage->cmap[i*3+1] = i;\n            gimage->cmap[i*3+2] = i;\n          }\n      }\n      else\n      {\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        info->cp +=\n          xcf_read_int8 (info->fp,\n                   (guint8*) gimage->cmap, gimage->num_cols*3);\n      }\n     */\n        break;\n      }\n      case PROP_COMPRESSION:\n      {\n        doc_info.compression = ReadBlobByte(image);\n        if ((doc_info.compression != COMPRESS_NONE) &&\n            (doc_info.compression != COMPRESS_RLE) &&\n            (doc_info.compression != COMPRESS_ZLIB) &&\n            (doc_info.compression != COMPRESS_FRACTAL))\n          ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n      }\n      break;\n\n      case PROP_GUIDES:\n      {\n         /* just skip it - we don't care about guides */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n      }\n      break;\n\n    case PROP_RESOLUTION:\n      {\n        /* float xres = (float) */ (void) ReadBlobMSBLong(image);\n        /* float yres = (float) */ (void) ReadBlobMSBLong(image);\n\n        /*\n        if (xres < GIMP_MIN_RESOLUTION || xres > GIMP_MAX_RESOLUTION ||\n            yres < GIMP_MIN_RESOLUTION || yres > GIMP_MAX_RESOLUTION)\n        {\n        g_message (\"Warning, resolution out of range in XCF file\");\n        xres = gimage->gimp->config->default_xresolution;\n        yres = gimage->gimp->config->default_yresolution;\n        }\n        */\n\n\n        /* BOGUS: we don't write these yet because we aren't\n              reading them properly yet :(\n              image->x_resolution = xres;\n              image->y_resolution = yres;\n        */\n      }\n      break;\n\n    case PROP_TATTOO:\n      {\n        /* we need to read it, even if we ignore it */\n        /*size_t  tattoo_state = */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PARASITES:\n      {\n        /* BOGUS: we may need these for IPTC stuff */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n        /*\n      gssize_t         base = info->cp;\n      GimpParasite *p;\n\n      while (info->cp - base < prop_size)\n        {\n          p = xcf_load_parasite (info);\n          gimp_image_parasite_attach (gimage, p);\n          gimp_parasite_free (p);\n        }\n      if (info->cp - base != prop_size)\n        g_message (\"Error detected while loading an image's parasites\");\n      */\n          }\n      break;\n\n    case PROP_UNIT:\n      {\n        /* BOGUS: ignore for now... */\n      /*size_t unit =  */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PATHS:\n      {\n      /* BOGUS: just skip it for now */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n\n        /*\n      PathList *paths = xcf_load_bzpaths (gimage, info);\n      gimp_image_set_paths (gimage, paths);\n      */\n      }\n      break;\n\n    case PROP_USER_UNIT:\n      {\n        char  unit_string[1000];\n        /*BOGUS: ignored for now */\n        /*float  factor = (float) */ (void) ReadBlobMSBLong(image);\n        /* size_t digits =  */ (void) ReadBlobMSBLong(image);\n        for (i=0; i<5; i++)\n         (void) ReadBlobStringWithLongSize(image, unit_string,\n           sizeof(unit_string));\n      }\n     break;\n\n      default:\n      {\n        int buf[16];\n        ssize_t amount;\n\n      /* read over it... */\n      while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))\n      {\n        amount=(ssize_t) MagickMin(16, prop_size);\n        amount=(ssize_t) ReadBlob(image,(size_t) amount,(unsigned char *) &buf);\n        if (!amount)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n        prop_size -= (size_t) MagickMin(16,(size_t) amount);\n      }\n    }\n    break;\n  }\n  }\n  if (foundPropEnd == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    {\n      ; /* do nothing, were just pinging! */\n    }\n  else\n    {\n      int\n        current_layer = 0,\n        foundAllLayers = MagickFalse,\n        number_layers = 0;\n\n      MagickOffsetType\n        oldPos=TellBlob(image);\n\n      XCFLayerInfo\n        *layer_info;\n\n      /*\n        The read pointer.\n      */\n      do\n      {\n        ssize_t offset = ReadBlobMSBSignedLong(image);\n        if (offset == 0)\n          foundAllLayers=MagickTrue;\n        else\n          number_layers++;\n        if (EOFBlob(image) != MagickFalse)\n          {\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n    } while (foundAllLayers == MagickFalse);\n    doc_info.number_layers=number_layers;\n    offset=SeekBlob(image,oldPos,SEEK_SET); /* restore the position! */\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    /* allocate our array of layer info blocks */\n    length=(size_t) number_layers;\n    layer_info=(XCFLayerInfo *) AcquireQuantumMemory(length,\n      sizeof(*layer_info));\n    if (layer_info == (XCFLayerInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(layer_info,0,number_layers*sizeof(XCFLayerInfo));\n    for ( ; ; )\n    {\n      MagickBooleanType\n        layer_ok;\n\n      MagickOffsetType\n        offset,\n        saved_pos;\n\n      /* read in the offset of the next layer */\n      offset=(MagickOffsetType) ReadBlobMSBLong(image);\n      /* if the offset is 0 then we are at the end\n      *  of the layer list.\n      */\n      if (offset == 0)\n        break;\n      /* save the current position as it is where the\n      *  next layer offset is stored.\n      */\n      saved_pos=TellBlob(image);\n      /* seek to the layer offset */\n      if (SeekBlob(image,offset,SEEK_SET) != offset)\n        ThrowReaderException(ResourceLimitError,\"NotEnoughPixelData\");\n      /* read in the layer */\n      layer_ok=ReadOneLayer(image_info,image,&doc_info,\n        &layer_info[current_layer],current_layer);\n      if (layer_ok == MagickFalse)\n        {\n          int j;\n\n          for (j=0; j < current_layer; j++)\n            layer_info[j].image=DestroyImage(layer_info[j].image);\n          layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      offset=SeekBlob(image, saved_pos, SEEK_SET);\n      current_layer++;\n    }\n#if 0\n        {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        signed int  j;\n        for (j=number_layers-1; j>=0; j--) {\n          /* BOGUS: need to consider layer blending modes!! */\n\n          if ( layer_info[j].visible ) { /* only visible ones, please! */\n            CompositeImage(image, OverCompositeOp, layer_info[j].image,\n                     layer_info[j].offset_x, layer_info[j].offset_y );\n             layer_info[j].image =DestroyImage( layer_info[j].image );\n\n            /* If we do this, we'll get REAL gray images! */\n            if ( image_type == GIMP_GRAY ) {\n              QuantizeInfo  qi;\n              GetQuantizeInfo(&qi);\n              qi.colorspace = GRAYColorspace;\n              QuantizeImage( &qi, layer_info[j].image );\n            }\n          }\n        }\n      }\n#else\n      {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        ssize_t  j;\n\n        /* now reverse the order of the layers as they are put\n           into subimages\n        */\n        for (j=(long) number_layers-1; j >= 0; j--)\n          AppendImageToList(&image,layer_info[j].image);\n      }\n#endif\n\n    layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n\n#if 0  /* BOGUS: do we need the channels?? */\n    while (MagickTrue)\n    {\n      /* read in the offset of the next channel */\n      info->cp += xcf_read_int32 (info->fp, &offset, 1);\n\n      /* if the offset is 0 then we are at the end\n      *  of the channel list.\n      */\n      if (offset == 0)\n        break;\n\n      /* save the current position as it is where the\n      *  next channel offset is stored.\n      */\n      saved_pos = info->cp;\n\n      /* seek to the channel offset */\n      xcf_seek_pos (info, offset);\n\n      /* read in the layer */\n      channel = xcf_load_channel (info, gimage);\n      if (channel == 0)\n        goto error;\n\n      num_successful_elements++;\n\n      /* add the channel to the image if its not the selection */\n      if (channel != gimage->selection_mask)\n        gimp_image_add_channel (gimage, channel, -1);\n\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      xcf_seek_pos (info, saved_pos);\n    }\n#endif\n   }\n \n   (void) CloseBlob(image);\n  DestroyImage(RemoveFirstImageFromList(&image));\n   if (image_type == GIMP_GRAY)\n     image->type=GrayscaleType;\n   return(GetFirstImageInList(image));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142621,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    magick[14];\n\n  Image\n    *image;\n\n  int\n    foundPropEnd = 0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  register ssize_t\n    i;\n\n  size_t\n    image_type,\n    length;\n\n  ssize_t\n    count;\n\n  XCFDocInfo\n    doc_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  count=ReadBlob(image,14,(unsigned char *) magick);\n  if ((count != 14) ||\n      (LocaleNCompare((char *) magick,\"gimp xcf\",8) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ResetMagickMemory(&doc_info,0,sizeof(XCFDocInfo));\n  doc_info.exception=exception;\n  doc_info.width=ReadBlobMSBLong(image);\n  doc_info.height=ReadBlobMSBLong(image);\n  if ((doc_info.width > 262144) || (doc_info.height > 262144))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  doc_info.image_type=ReadBlobMSBLong(image);\n  /*\n    Initialize image attributes.\n  */\n  image->columns=doc_info.width;\n  image->rows=doc_info.height;\n  image_type=doc_info.image_type;\n  doc_info.file_size=GetBlobSize(image);\n  image->compression=NoCompression;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (image_type == GIMP_RGB)\n    ;\n  else\n    if (image_type == GIMP_GRAY)\n      image->colorspace=GRAYColorspace;\n    else\n      if (image_type == GIMP_INDEXED)\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n  (void) SetImageOpacity(image,OpaqueOpacity); \n  (void) SetImageBackgroundColor(image);\n  /*\n    Read properties.\n  */\n  while ((foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse))\n  {\n    PropType prop_type = (PropType) ReadBlobMSBLong(image);\n    size_t prop_size = ReadBlobMSBLong(image);\n\n    switch (prop_type)\n    {\n      case PROP_END:\n        foundPropEnd=1;\n        break;\n      case PROP_COLORMAP:\n      {\n        /* Cannot rely on prop_size here--the value is set incorrectly\n           by some Gimp versions.\n        */\n        size_t num_colours = ReadBlobMSBLong(image);\n        if (DiscardBlobBytes(image,3*num_colours) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n    /*\n      if (info->file_version == 0)\n      {\n        gint i;\n\n        g_message (_(\"XCF warning: version 0 of XCF file format\\n\"\n           \"did not save indexed colormaps correctly.\\n\"\n           \"Substituting grayscale map.\"));\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        xcf_seek_pos (info, info->cp + gimage->num_cols);\n        for (i = 0; i<gimage->num_cols; i++)\n          {\n            gimage->cmap[i*3+0] = i;\n            gimage->cmap[i*3+1] = i;\n            gimage->cmap[i*3+2] = i;\n          }\n      }\n      else\n      {\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        info->cp +=\n          xcf_read_int8 (info->fp,\n                   (guint8*) gimage->cmap, gimage->num_cols*3);\n      }\n     */\n        break;\n      }\n      case PROP_COMPRESSION:\n      {\n        doc_info.compression = ReadBlobByte(image);\n        if ((doc_info.compression != COMPRESS_NONE) &&\n            (doc_info.compression != COMPRESS_RLE) &&\n            (doc_info.compression != COMPRESS_ZLIB) &&\n            (doc_info.compression != COMPRESS_FRACTAL))\n          ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n      }\n      break;\n\n      case PROP_GUIDES:\n      {\n         /* just skip it - we don't care about guides */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n      }\n      break;\n\n    case PROP_RESOLUTION:\n      {\n        /* float xres = (float) */ (void) ReadBlobMSBLong(image);\n        /* float yres = (float) */ (void) ReadBlobMSBLong(image);\n\n        /*\n        if (xres < GIMP_MIN_RESOLUTION || xres > GIMP_MAX_RESOLUTION ||\n            yres < GIMP_MIN_RESOLUTION || yres > GIMP_MAX_RESOLUTION)\n        {\n        g_message (\"Warning, resolution out of range in XCF file\");\n        xres = gimage->gimp->config->default_xresolution;\n        yres = gimage->gimp->config->default_yresolution;\n        }\n        */\n\n\n        /* BOGUS: we don't write these yet because we aren't\n              reading them properly yet :(\n              image->x_resolution = xres;\n              image->y_resolution = yres;\n        */\n      }\n      break;\n\n    case PROP_TATTOO:\n      {\n        /* we need to read it, even if we ignore it */\n        /*size_t  tattoo_state = */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PARASITES:\n      {\n        /* BOGUS: we may need these for IPTC stuff */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n        /*\n      gssize_t         base = info->cp;\n      GimpParasite *p;\n\n      while (info->cp - base < prop_size)\n        {\n          p = xcf_load_parasite (info);\n          gimp_image_parasite_attach (gimage, p);\n          gimp_parasite_free (p);\n        }\n      if (info->cp - base != prop_size)\n        g_message (\"Error detected while loading an image's parasites\");\n      */\n          }\n      break;\n\n    case PROP_UNIT:\n      {\n        /* BOGUS: ignore for now... */\n      /*size_t unit =  */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PATHS:\n      {\n      /* BOGUS: just skip it for now */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n\n        /*\n      PathList *paths = xcf_load_bzpaths (gimage, info);\n      gimp_image_set_paths (gimage, paths);\n      */\n      }\n      break;\n\n    case PROP_USER_UNIT:\n      {\n        char  unit_string[1000];\n        /*BOGUS: ignored for now */\n        /*float  factor = (float) */ (void) ReadBlobMSBLong(image);\n        /* size_t digits =  */ (void) ReadBlobMSBLong(image);\n        for (i=0; i<5; i++)\n         (void) ReadBlobStringWithLongSize(image, unit_string,\n           sizeof(unit_string));\n      }\n     break;\n\n      default:\n      {\n        int buf[16];\n        ssize_t amount;\n\n      /* read over it... */\n      while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))\n      {\n        amount=(ssize_t) MagickMin(16, prop_size);\n        amount=(ssize_t) ReadBlob(image,(size_t) amount,(unsigned char *) &buf);\n        if (!amount)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n        prop_size -= (size_t) MagickMin(16,(size_t) amount);\n      }\n    }\n    break;\n  }\n  }\n  if (foundPropEnd == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    {\n      ; /* do nothing, were just pinging! */\n    }\n  else\n    {\n      int\n        current_layer = 0,\n        foundAllLayers = MagickFalse,\n        number_layers = 0;\n\n      MagickOffsetType\n        oldPos=TellBlob(image);\n\n      XCFLayerInfo\n        *layer_info;\n\n      /*\n        The read pointer.\n      */\n      do\n      {\n        ssize_t offset = ReadBlobMSBSignedLong(image);\n        if (offset == 0)\n          foundAllLayers=MagickTrue;\n        else\n          number_layers++;\n        if (EOFBlob(image) != MagickFalse)\n          {\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n    } while (foundAllLayers == MagickFalse);\n    doc_info.number_layers=number_layers;\n    offset=SeekBlob(image,oldPos,SEEK_SET); /* restore the position! */\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    /* allocate our array of layer info blocks */\n    length=(size_t) number_layers;\n    layer_info=(XCFLayerInfo *) AcquireQuantumMemory(length,\n      sizeof(*layer_info));\n    if (layer_info == (XCFLayerInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(layer_info,0,number_layers*sizeof(XCFLayerInfo));\n    for ( ; ; )\n    {\n      MagickBooleanType\n        layer_ok;\n\n      MagickOffsetType\n        offset,\n        saved_pos;\n\n      /* read in the offset of the next layer */\n      offset=(MagickOffsetType) ReadBlobMSBLong(image);\n      /* if the offset is 0 then we are at the end\n      *  of the layer list.\n      */\n      if (offset == 0)\n        break;\n      /* save the current position as it is where the\n      *  next layer offset is stored.\n      */\n      saved_pos=TellBlob(image);\n      /* seek to the layer offset */\n      if (SeekBlob(image,offset,SEEK_SET) != offset)\n        ThrowReaderException(ResourceLimitError,\"NotEnoughPixelData\");\n      /* read in the layer */\n      layer_ok=ReadOneLayer(image_info,image,&doc_info,\n        &layer_info[current_layer],current_layer);\n      if (layer_ok == MagickFalse)\n        {\n          int j;\n\n          for (j=0; j < current_layer; j++)\n            layer_info[j].image=DestroyImage(layer_info[j].image);\n          layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      offset=SeekBlob(image, saved_pos, SEEK_SET);\n      current_layer++;\n    }\n#if 0\n        {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        signed int  j;\n        for (j=number_layers-1; j>=0; j--) {\n          /* BOGUS: need to consider layer blending modes!! */\n\n          if ( layer_info[j].visible ) { /* only visible ones, please! */\n            CompositeImage(image, OverCompositeOp, layer_info[j].image,\n                     layer_info[j].offset_x, layer_info[j].offset_y );\n             layer_info[j].image =DestroyImage( layer_info[j].image );\n\n            /* If we do this, we'll get REAL gray images! */\n            if ( image_type == GIMP_GRAY ) {\n              QuantizeInfo  qi;\n              GetQuantizeInfo(&qi);\n              qi.colorspace = GRAYColorspace;\n              QuantizeImage( &qi, layer_info[j].image );\n            }\n          }\n        }\n      }\n#else\n      {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        ssize_t  j;\n\n        /* now reverse the order of the layers as they are put\n           into subimages\n        */\n        for (j=(long) number_layers-1; j >= 0; j--)\n          AppendImageToList(&image,layer_info[j].image);\n      }\n#endif\n\n    layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n\n#if 0  /* BOGUS: do we need the channels?? */\n    while (MagickTrue)\n    {\n      /* read in the offset of the next channel */\n      info->cp += xcf_read_int32 (info->fp, &offset, 1);\n\n      /* if the offset is 0 then we are at the end\n      *  of the channel list.\n      */\n      if (offset == 0)\n        break;\n\n      /* save the current position as it is where the\n      *  next channel offset is stored.\n      */\n      saved_pos = info->cp;\n\n      /* seek to the channel offset */\n      xcf_seek_pos (info, offset);\n\n      /* read in the layer */\n      channel = xcf_load_channel (info, gimage);\n      if (channel == 0)\n        goto error;\n\n      num_successful_elements++;\n\n      /* add the channel to the image if its not the selection */\n      if (channel != gimage->selection_mask)\n        gimp_image_add_channel (gimage, channel, -1);\n\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      xcf_seek_pos (info, saved_pos);\n    }\n#endif\n   }\n \n   (void) CloseBlob(image);\n  if (GetNextImageInList(image) != (Image *) NULL)\n    DestroyImage(RemoveFirstImageFromList(&image));\n   if (image_type == GIMP_GRAY)\n     image->type=GrayscaleType;\n   return(GetFirstImageInList(image));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142622,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static MagickBooleanType ReadPSDChannel(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,\n  const size_t channel,const PSDCompressionType compression,\n  ExceptionInfo *exception)\n{\n  Image\n    *channel_image,\n    *mask;\n\n  MagickOffsetType\n    offset;\n\n  MagickBooleanType\n    status;\n\n  channel_image=image;\n  mask=(Image *) NULL;\n  if (layer_info->channel_info[channel].type < -1)\n    {\n      const char\n        *option;\n      /*\n        Ignore mask that is not a user supplied layer mask, if the mask is\n        disabled or if the flags have unsupported values.\n      */\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n      if ((layer_info->channel_info[channel].type != -2) ||\n          (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&\n           (IsStringTrue(option) == MagickFalse)))\n      {\n        SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);\n        return(MagickTrue);\n       }\n       mask=CloneImage(image,layer_info->mask.page.width,\n         layer_info->mask.page.height,MagickFalse,exception);\n      mask->matte=MagickFalse;\n      channel_image=mask;\n     }\n \n   offset=TellBlob(image);\n  status=MagickTrue;\n  switch(compression)\n  {\n    case Raw:\n      status=ReadPSDChannelRaw(channel_image,psd_info->channels,\n        layer_info->channel_info[channel].type,exception);\n      break;\n    case RLE:\n      {\n        MagickOffsetType\n          *sizes;\n\n        sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);\n        if (sizes == (MagickOffsetType *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        status=ReadPSDChannelRLE(channel_image,psd_info,\n          layer_info->channel_info[channel].type,sizes,exception);\n        sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n      }\n      break;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n      status=ReadPSDChannelZip(channel_image,layer_info->channels,\n        layer_info->channel_info[channel].type,compression,\n        layer_info->channel_info[channel].size-2,exception);\n#else\n      (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n            \"'%s' (ZLIB)\",image->filename);\n#endif\n      break;\n    default:\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n        \"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      break;\n  }\n\n  SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n  if (status == MagickFalse)\n    {\n      if (mask != (Image *) NULL)\n        DestroyImage(mask);\n      ThrowBinaryException(CoderError,\"UnableToDecompressImage\",\n        image->filename);\n    }\n  layer_info->mask.image=mask;\n  return(status);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142625,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static MagickBooleanType ReadPSDChannel(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,\n  const size_t channel,const PSDCompressionType compression,\n  ExceptionInfo *exception)\n{\n  Image\n    *channel_image,\n    *mask;\n\n  MagickOffsetType\n    offset;\n\n  MagickBooleanType\n    status;\n\n  channel_image=image;\n  mask=(Image *) NULL;\n  if (layer_info->channel_info[channel].type < -1)\n    {\n      const char\n        *option;\n      /*\n        Ignore mask that is not a user supplied layer mask, if the mask is\n        disabled or if the flags have unsupported values.\n      */\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n      if ((layer_info->channel_info[channel].type != -2) ||\n          (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&\n           (IsStringTrue(option) == MagickFalse)))\n      {\n        SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);\n        return(MagickTrue);\n       }\n       mask=CloneImage(image,layer_info->mask.page.width,\n         layer_info->mask.page.height,MagickFalse,exception);\n      if (mask != (Image *) NULL)\n        {\n          mask->matte=MagickFalse;\n          channel_image=mask;\n        }\n     }\n \n   offset=TellBlob(image);\n  status=MagickTrue;\n  switch(compression)\n  {\n    case Raw:\n      status=ReadPSDChannelRaw(channel_image,psd_info->channels,\n        layer_info->channel_info[channel].type,exception);\n      break;\n    case RLE:\n      {\n        MagickOffsetType\n          *sizes;\n\n        sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);\n        if (sizes == (MagickOffsetType *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        status=ReadPSDChannelRLE(channel_image,psd_info,\n          layer_info->channel_info[channel].type,sizes,exception);\n        sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n      }\n      break;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n      status=ReadPSDChannelZip(channel_image,layer_info->channels,\n        layer_info->channel_info[channel].type,compression,\n        layer_info->channel_info[channel].size-2,exception);\n#else\n      (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n            \"'%s' (ZLIB)\",image->filename);\n#endif\n      break;\n    default:\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n        \"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      break;\n  }\n\n  SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n  if (status == MagickFalse)\n    {\n      if (mask != (Image *) NULL)\n        DestroyImage(mask);\n      ThrowBinaryException(CoderError,\"UnableToDecompressImage\",\n        image->filename);\n    }\n  layer_info->mask.image=mask;\n  return(status);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142626,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tPurpleXfer *xfer = data;\n\tstruct im_connection *ic = purple_ic_by_pa(xfer->account);\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\tPurpleBuddy *buddy;\n\tconst char *who;\n\n\tbuddy = purple_find_buddy(xfer->account, xfer->who);\n\twho = buddy ? purple_buddy_get_name(buddy) : xfer->who;\n\n \t/* TODO(wilmer): After spreading some more const goodness in BitlBee,\n \t   remove the evil cast below. */\n \tpx->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);\n \tpx->ft->data = px;\n \n \tpx->ft->accept = prpl_xfer_accept;\n\tpx->ft->canceled = prpl_xfer_canceled;\n\tpx->ft->free = prpl_xfer_free;\n\tpx->ft->write_request = prpl_xfer_write_request;\n\n\treturn FALSE;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142651,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tPurpleXfer *xfer = data;\n\tstruct im_connection *ic = purple_ic_by_pa(xfer->account);\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\tPurpleBuddy *buddy;\n\tconst char *who;\n\n\tbuddy = purple_find_buddy(xfer->account, xfer->who);\n\twho = buddy ? purple_buddy_get_name(buddy) : xfer->who;\n\n \t/* TODO(wilmer): After spreading some more const goodness in BitlBee,\n \t   remove the evil cast below. */\n \tpx->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);\n\n\tif (!px->ft) {\n\t\treturn FALSE;\n\t}\n \tpx->ft->data = px;\n \n \tpx->ft->accept = prpl_xfer_accept;\n\tpx->ft->canceled = prpl_xfer_canceled;\n\tpx->ft->free = prpl_xfer_free;\n\tpx->ft->write_request = prpl_xfer_write_request;\n\n\treturn FALSE;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142652,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n \tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n \t\tgoto error;\n \t}\n \tbox->ops = &jp2_boxinfo_unk.ops;\n \tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n \t\tgoto error;\n \t}\n \tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n \tbox->len = len;\n \tJAS_DBGLOG(10, (\n \t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n \t\t\tgoto error;\n \t\t}\n \t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\tbox->ops = &jp2_boxinfo_unk.ops;\n \t\t\tjas_eprintf(\"cannot copy box data\\n\");\n \t\t\tgoto error;\n \t\t}\n \t\tjas_stream_rewind(tmpstream);\n \n \t\tif (box->ops->getdata) {\n \t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n \t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142697,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n \tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n \t\tgoto error;\n \t}\n\n\t// Mark the box data as never having been constructed\n\t// so that we will not errantly attempt to destroy it later.\n \tbox->ops = &jp2_boxinfo_unk.ops;\n\n \tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n \t\tgoto error;\n \t}\n \tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n \tbox->len = len;\n \tJAS_DBGLOG(10, (\n \t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n \t\t\tgoto error;\n \t\t}\n \t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n \t\t\tjas_eprintf(\"cannot copy box data\\n\");\n \t\t\tgoto error;\n \t\t}\n \t\tjas_stream_rewind(tmpstream);\n \n\t\t// From here onwards, the box data will need to be destroyed.\n\t\t// So, initialize the box operations.\n\t\tbox->ops = &boxinfo->ops;\n\n \t\tif (box->ops->getdata) {\n \t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n \t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142698,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n {\n\treturn (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,\n \t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),\n \t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),\n \t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142699,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n {\n\treturn (tsfb->numlvls > 0 && jas_seq2d_size(a)) ?\n\t  jpc_tsfb_synthesize2(tsfb,\n \t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),\n \t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),\n \t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142700,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int read_escaped_char(\n    yyscan_t yyscanner,\n    uint8_t* escaped_char)\n{\n  char text[4] = {0, 0, 0, 0};\n\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n \n  if (text[1] == EOF)\n     return 0;\n \n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n \n    if (text[2] == EOF)\n       return 0;\n \n     text[3] = RE_YY_INPUT(yyscanner);\n \n    if (text[3] == EOF)\n       return 0;\n   }\n \n  *escaped_char = escaped_char_value(text);\n\n  return 1;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142703,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int read_escaped_char(\n    yyscan_t yyscanner,\n    uint8_t* escaped_char)\n{\n  char text[4] = {0, 0, 0, 0};\n\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n \n  if (text[1] == EOF || text[1] == 0)\n     return 0;\n \n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n \n    if (!isxdigit(text[2]))\n       return 0;\n \n     text[3] = RE_YY_INPUT(yyscanner);\n \n    if (!isxdigit(text[3]))\n       return 0;\n   }\n \n  *escaped_char = escaped_char_value(text);\n\n  return 1;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142704,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size)\n{\n \tbee_t *bee = ic->bee;\n \tbee_user_t *bu = bee_user_by_handle(bee, ic, handle);\n \n\tif (bee->ui->ft_in_start) {\n \t\treturn bee->ui->ft_in_start(bee, bu, file_name, file_size);\n \t} else {\n \t\treturn NULL;\n\t}\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142719,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size)\n{\n \tbee_t *bee = ic->bee;\n \tbee_user_t *bu = bee_user_by_handle(bee, ic, handle);\n \n\tif (bee->ui->ft_in_start && bu) {\n \t\treturn bee->ui->ft_in_start(bee, bu, file_name, file_size);\n \t} else {\n \t\treturn NULL;\n\t}\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142720,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\tgoto error;\n\t}\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n \tbox->ops = &boxinfo->ops;\n \tbox->len = len;\n \tif (box->len == 1) {\n \t\tif (jp2_getuint64(in, &extlen)) {\n \t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n \t\t\tgoto error;\n \t\t}\n \t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n \t\t\tjas_eprintf(\"cannot copy box data\\n\");\n \t\t\tgoto error;\n \t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142771,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\tgoto error;\n\t}\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n \tbox->ops = &boxinfo->ops;\n \tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n \tif (box->len == 1) {\n \t\tif (jp2_getuint64(in, &extlen)) {\n \t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n \t\t\tgoto error;\n \t\t}\n \t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\t// Mark the box data as never having been constructed\n\t\t\t// so that we will not errantly attempt to destroy it later.\n\t\t\tbox->ops = &jp2_boxinfo_unk.ops;\n \t\t\tjas_eprintf(\"cannot copy box data\\n\");\n \t\t\tgoto error;\n \t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142772,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n \tuint_fast16_t numcmpts;\n \tlong n;\n \n \tif (optstr) {\n \t\tjas_eprintf(\"warning: ignoring BMP decoder options\\n\");\n \t}\n\n\tjas_eprintf(\n\t  \"THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\"\n\t  \"THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\"\n\t  \"IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\"\n\t  \"TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\"\n\t  );\n\n \t/* Read the bitmap header. */\n \tif (bmp_gethdr(in, &hdr)) {\n \t\tjas_eprintf(\"cannot get header\\n\");\n\t\treturn 0;\n \t}\n \tJAS_DBGLOG(1, (\n \t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",\n\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n\t  ));\n\n \t/* Read the bitmap information. */\n \tif (!(info = bmp_getinfo(in))) {\n \t\tjas_eprintf(\"cannot get info\\n\");\n\t\treturn 0;\n \t}\n \tJAS_DBGLOG(1,\n\t  (\"BMP information: len %d; width %d; height %d; numplanes %d; \"\n\t  \"depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; \"\n\t  \"mincolors %d\\n\", info->len, info->width, info->height, info->numplanes,\n\t  info->depth, info->enctype, info->siz, info->hres, info->vres,\n\t  info->numcolors, info->mincolors));\n \n \t/* Ensure that we support this type of BMP file. */\n \tif (!bmp_issupported(&hdr, info)) {\n \t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n \t}\n \n \t/* Skip over any useless data between the end of the palette\n \t  and start of the bitmap data. */\n \tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n \t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");\n\t\treturn 0;\n \t}\n \tif (n > 0) {\n \t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");\n \t\tif (bmp_gobble(in, n)) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n \t\t}\n \t}\n \n\t/* Get the number of components. */\n\tnumcmpts = bmp_numcmpts(info);\n\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->hstep = 1;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcmptparm->height = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n \t/* Create image object. */\n \tif (!(image = jas_image_create(numcmpts, cmptparms,\n \t  JAS_CLRSPC_UNKNOWN))) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n \t}\n \n \tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n \n \t/* Read the bitmap data. */\n \tif (bmp_getdata(in, info, image)) {\n\t\tbmp_info_destroy(info);\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n \t}\n \n \tbmp_info_destroy(info);\n \n \treturn image;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142773,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n \tuint_fast16_t numcmpts;\n \tlong n;\n \n\timage = 0;\n\tinfo = 0;\n\n \tif (optstr) {\n \t\tjas_eprintf(\"warning: ignoring BMP decoder options\\n\");\n \t}\n\n\tjas_eprintf(\n\t  \"THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\"\n\t  \"THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\"\n\t  \"IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\"\n\t  \"TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\"\n\t  );\n\n \t/* Read the bitmap header. */\n \tif (bmp_gethdr(in, &hdr)) {\n \t\tjas_eprintf(\"cannot get header\\n\");\n\t\tgoto error;\n\t\t//return 0;\n \t}\n \tJAS_DBGLOG(1, (\n \t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",\n\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n\t  ));\n\n \t/* Read the bitmap information. */\n \tif (!(info = bmp_getinfo(in))) {\n \t\tjas_eprintf(\"cannot get info\\n\");\n\t\t//return 0;\n\t\tgoto error;\n \t}\n \tJAS_DBGLOG(1,\n\t  (\"BMP information: len %ld; width %ld; height %ld; numplanes %d; \"\n\t  \"depth %d; enctype %ld; siz %ld; hres %ld; vres %ld; numcolors %ld; \"\n\t  \"mincolors %ld\\n\", JAS_CAST(long, info->len),\n\t  JAS_CAST(long, info->width), JAS_CAST(long, info->height),\n\t  JAS_CAST(long, info->numplanes), JAS_CAST(long, info->depth),\n\t  JAS_CAST(long, info->enctype), JAS_CAST(long, info->siz),\n\t  JAS_CAST(long, info->hres), JAS_CAST(long, info->vres),\n\t  JAS_CAST(long, info->numcolors), JAS_CAST(long, info->mincolors)));\n\n\tif (info->width < 0 || info->height < 0 || info->numplanes < 0 ||\n\t  info->depth < 0 || info->siz < 0 || info->hres < 0 || info->vres < 0) {\n\t\tjas_eprintf(\"corrupt bit stream\\n\");\n\t\tgoto error;\n\t}\n \n \t/* Ensure that we support this type of BMP file. */\n \tif (!bmp_issupported(&hdr, info)) {\n \t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");\n\t\t//bmp_info_destroy(info);\n\t\t//return 0;\n\t\tgoto error;\n \t}\n \n \t/* Skip over any useless data between the end of the palette\n \t  and start of the bitmap data. */\n \tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n \t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");\n\t\tgoto error;\n\t\t//return 0;\n \t}\n \tif (n > 0) {\n \t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");\n \t\tif (bmp_gobble(in, n)) {\n\t\t\t//bmp_info_destroy(info);\n\t\t\t//return 0;\n\t\t\tgoto error;\n \t\t}\n \t}\n \n\t/* Get the number of components. */\n\tnumcmpts = bmp_numcmpts(info);\n\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->hstep = 1;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcmptparm->height = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n \t/* Create image object. */\n \tif (!(image = jas_image_create(numcmpts, cmptparms,\n \t  JAS_CLRSPC_UNKNOWN))) {\n\t\t//bmp_info_destroy(info);\n\t\t//return 0;\n\t\tgoto error;\n \t}\n \n \tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n \n \t/* Read the bitmap data. */\n \tif (bmp_getdata(in, info, image)) {\n\t\t//bmp_info_destroy(info);\n\t\t//jas_image_destroy(image);\n\t\t//return 0;\n\t\tgoto error;\n \t}\n \n \tbmp_info_destroy(info);\n \n \treturn image;\n\nerror:\n\tif (info) {\n\t\tbmp_info_destroy(info);\n\t}\n\tif (image) {\n\t\tjas_image_destroy(image);\n\t}\n\treturn 0;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142774,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "MagickExport MagickBooleanType WriteImages(const ImageInfo *image_info,\n  Image *images,const char *filename,ExceptionInfo *exception)\n{\n#define WriteImageTag  \"Write/Image\"\n\n  ExceptionInfo\n    *sans_exception;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    proceed;\n\n  MagickOffsetType\n    progress;\n\n  MagickProgressMonitor\n    progress_monitor;\n\n  MagickSizeType\n    number_images;\n\n  MagickStatusType\n    status;\n\n  register Image\n    *p;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  write_info=CloneImageInfo(image_info);\n  *write_info->magick='\\0';\n  images=GetFirstImageInList(images);\n  if (filename != (const char *) NULL)\n    for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n      (void) CopyMagickString(p->filename,filename,MagickPathExtent);\n  (void) CopyMagickString(write_info->filename,images->filename,MagickPathExtent);\n  sans_exception=AcquireExceptionInfo();\n  (void) SetImageInfo(write_info,(unsigned int) GetImageListLength(images),\n    sans_exception);\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if (*write_info->magick == '\\0')\n     (void) CopyMagickString(write_info->magick,images->magick,MagickPathExtent);\n   p=images;\n   for ( ; GetNextImageInList(p) != (Image *) NULL; p=GetNextImageInList(p))\n    if (p->scene >= GetNextImageInList(p)->scene)\n       {\n         register ssize_t\n           i;\n\n        /*\n          Generate consistent scene numbers.\n        */\n        i=(ssize_t) images->scene;\n        for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n           p->scene=(size_t) i++;\n         break;\n       }\n   /*\n     Write images.\n   */\n  status=MagickTrue;\n  progress_monitor=(MagickProgressMonitor) NULL;\n  progress=0;\n  number_images=GetImageListLength(images);\n  for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n  {\n    if (number_images != 1)\n      progress_monitor=SetImageProgressMonitor(p,(MagickProgressMonitor) NULL,\n        p->client_data);\n    status&=WriteImage(write_info,p,exception);\n    if (number_images != 1)\n      (void) SetImageProgressMonitor(p,progress_monitor,p->client_data);\n    if (write_info->adjoin != MagickFalse)\n      break;\n    if (number_images != 1)\n      {\n        proceed=SetImageProgress(p,WriteImageTag,progress++,number_images);\n        if (proceed == MagickFalse)\n          break;\n      }\n  }\n  write_info=DestroyImageInfo(write_info);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142819,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "MagickExport MagickBooleanType WriteImages(const ImageInfo *image_info,\n  Image *images,const char *filename,ExceptionInfo *exception)\n{\n#define WriteImageTag  \"Write/Image\"\n\n  ExceptionInfo\n    *sans_exception;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    proceed;\n\n  MagickOffsetType\n    progress;\n\n  MagickProgressMonitor\n    progress_monitor;\n\n  MagickSizeType\n    number_images;\n\n  MagickStatusType\n    status;\n\n  register Image\n    *p;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  write_info=CloneImageInfo(image_info);\n  *write_info->magick='\\0';\n  images=GetFirstImageInList(images);\n  if (filename != (const char *) NULL)\n    for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n      (void) CopyMagickString(p->filename,filename,MagickPathExtent);\n  (void) CopyMagickString(write_info->filename,images->filename,MagickPathExtent);\n  sans_exception=AcquireExceptionInfo();\n  (void) SetImageInfo(write_info,(unsigned int) GetImageListLength(images),\n    sans_exception);\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if (*write_info->magick == '\\0')\n     (void) CopyMagickString(write_info->magick,images->magick,MagickPathExtent);\n   p=images;\n   for ( ; GetNextImageInList(p) != (Image *) NULL; p=GetNextImageInList(p))\n  {\n    register Image\n      *next;\n    \n    next=GetNextImageInList(p);\n    if (next == (Image *) NULL)\n      break;\n    if (p->scene >= next->scene)\n       {\n         register ssize_t\n           i;\n\n        /*\n          Generate consistent scene numbers.\n        */\n        i=(ssize_t) images->scene;\n        for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n           p->scene=(size_t) i++;\n         break;\n       }\n  }\n   /*\n     Write images.\n   */\n  status=MagickTrue;\n  progress_monitor=(MagickProgressMonitor) NULL;\n  progress=0;\n  number_images=GetImageListLength(images);\n  for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n  {\n    if (number_images != 1)\n      progress_monitor=SetImageProgressMonitor(p,(MagickProgressMonitor) NULL,\n        p->client_data);\n    status&=WriteImage(write_info,p,exception);\n    if (number_images != 1)\n      (void) SetImageProgressMonitor(p,progress_monitor,p->client_data);\n    if (write_info->adjoin != MagickFalse)\n      break;\n    if (number_images != 1)\n      {\n        proceed=SetImageProgress(p,WriteImageTag,progress++,number_images);\n        if (proceed == MagickFalse)\n          break;\n      }\n  }\n  write_info=DestroyImageInfo(write_info);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142820,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static bool handle_client_startup(PgSocket *client, PktHdr *pkt)\n{\n\tconst char *passwd;\n\tconst uint8_t *key;\n\tbool ok;\n\n\tSBuf *sbuf = &client->sbuf;\n\n\t/* don't tolerate partial packets */\n\tif (incomplete_pkt(pkt)) {\n\t\tdisconnect_client(client, true, \"client sent partial pkt in startup phase\");\n\t\treturn false;\n\t}\n\n\tif (client->wait_for_welcome) {\n\t\tif  (finish_client_login(client)) {\n\t\t\t/* the packet was already parsed */\n\t\t\tsbuf_prepare_skip(sbuf, pkt->len);\n\t\t\treturn true;\n\t\t} else\n\t\t\treturn false;\n\t}\n\n\tswitch (pkt->type) {\n\tcase PKT_SSLREQ:\n\t\tslog_noise(client, \"C: req SSL\");\n\t\tslog_noise(client, \"P: nak\");\n\n\t\t/* reject SSL attempt */\n\t\tif (!sbuf_answer(&client->sbuf, \"N\", 1)) {\n\t\t\tdisconnect_client(client, false, \"failed to nak SSL\");\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase PKT_STARTUP_V2:\n\t\tdisconnect_client(client, true, \"Old V2 protocol not supported\");\n\t\treturn false;\n\tcase PKT_STARTUP:\n\t\tif (client->pool) {\n\t\t\tdisconnect_client(client, true, \"client re-sent startup pkt\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!decide_startup_pool(client, pkt))\n\t\t\treturn false;\n\n\t\tif (client->pool->db->admin) {\n\t\t\tif (!admin_pre_login(client))\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif (cf_auth_type <= AUTH_TRUST || client->own_user) {\n\t\t\tif (!finish_client_login(client))\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (!send_client_authreq(client)) {\n\t\t\t\tdisconnect_client(client, false, \"failed to send auth req\");\n\t\t\t\treturn false;\n\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase 'p':\t\t/* PasswordMessage */\n \t\t/* haven't requested it */\n \t\tif (cf_auth_type <= AUTH_TRUST) {\n \t\t\tdisconnect_client(client, true, \"unrequested passwd pkt\");\n\t\t\treturn false;\n\t\t}\n\n\t\tok = mbuf_get_string(&pkt->data, &passwd);\n\t\tif (ok && check_client_passwd(client, passwd)) {\n\t\t\tif (!finish_client_login(client))\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tdisconnect_client(client, true, \"Auth failed\");\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase PKT_CANCEL:\n\t\tif (mbuf_avail_for_read(&pkt->data) == BACKENDKEY_LEN\n\t\t    && mbuf_get_bytes(&pkt->data, BACKENDKEY_LEN, &key))\n\t\t{\n\t\t\tmemcpy(client->cancel_key, key, BACKENDKEY_LEN);\n\t\t\taccept_cancel_request(client);\n\t\t} else\n\t\t\tdisconnect_client(client, false, \"bad cancel request\");\n\t\treturn false;\n\tdefault:\n\t\tdisconnect_client(client, false, \"bad packet\");\n\t\treturn false;\n\t}\n\tsbuf_prepare_skip(sbuf, pkt->len);\n\tclient->request_time = get_cached_time();\n\treturn true;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142831,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static bool handle_client_startup(PgSocket *client, PktHdr *pkt)\n{\n\tconst char *passwd;\n\tconst uint8_t *key;\n\tbool ok;\n\n\tSBuf *sbuf = &client->sbuf;\n\n\t/* don't tolerate partial packets */\n\tif (incomplete_pkt(pkt)) {\n\t\tdisconnect_client(client, true, \"client sent partial pkt in startup phase\");\n\t\treturn false;\n\t}\n\n\tif (client->wait_for_welcome) {\n\t\tif  (finish_client_login(client)) {\n\t\t\t/* the packet was already parsed */\n\t\t\tsbuf_prepare_skip(sbuf, pkt->len);\n\t\t\treturn true;\n\t\t} else\n\t\t\treturn false;\n\t}\n\n\tswitch (pkt->type) {\n\tcase PKT_SSLREQ:\n\t\tslog_noise(client, \"C: req SSL\");\n\t\tslog_noise(client, \"P: nak\");\n\n\t\t/* reject SSL attempt */\n\t\tif (!sbuf_answer(&client->sbuf, \"N\", 1)) {\n\t\t\tdisconnect_client(client, false, \"failed to nak SSL\");\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase PKT_STARTUP_V2:\n\t\tdisconnect_client(client, true, \"Old V2 protocol not supported\");\n\t\treturn false;\n\tcase PKT_STARTUP:\n\t\tif (client->pool) {\n\t\t\tdisconnect_client(client, true, \"client re-sent startup pkt\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!decide_startup_pool(client, pkt))\n\t\t\treturn false;\n\n\t\tif (client->pool->db->admin) {\n\t\t\tif (!admin_pre_login(client))\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif (cf_auth_type <= AUTH_TRUST || client->own_user) {\n\t\t\tif (!finish_client_login(client))\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (!send_client_authreq(client)) {\n\t\t\t\tdisconnect_client(client, false, \"failed to send auth req\");\n\t\t\t\treturn false;\n\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase 'p':\t\t/* PasswordMessage */\n\t\t/* too early */\n\t\tif (!client->auth_user) {\n\t\t\tdisconnect_client(client, true, \"client password pkt before startup packet\");\n\t\t\treturn false;\n\t\t}\n\n \t\t/* haven't requested it */\n \t\tif (cf_auth_type <= AUTH_TRUST) {\n \t\t\tdisconnect_client(client, true, \"unrequested passwd pkt\");\n\t\t\treturn false;\n\t\t}\n\n\t\tok = mbuf_get_string(&pkt->data, &passwd);\n\t\tif (ok && check_client_passwd(client, passwd)) {\n\t\t\tif (!finish_client_login(client))\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tdisconnect_client(client, true, \"Auth failed\");\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase PKT_CANCEL:\n\t\tif (mbuf_avail_for_read(&pkt->data) == BACKENDKEY_LEN\n\t\t    && mbuf_get_bytes(&pkt->data, BACKENDKEY_LEN, &key))\n\t\t{\n\t\t\tmemcpy(client->cancel_key, key, BACKENDKEY_LEN);\n\t\t\taccept_cancel_request(client);\n\t\t} else\n\t\t\tdisconnect_client(client, false, \"bad cancel request\");\n\t\treturn false;\n\tdefault:\n\t\tdisconnect_client(client, false, \"bad packet\");\n\t\treturn false;\n\t}\n\tsbuf_prepare_skip(sbuf, pkt->len);\n\tclient->request_time = get_cached_time();\n\treturn true;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142832,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "archive_acl_from_text_l(struct archive_acl *acl, const char *text,\n    int want_type, struct archive_string_conv *sc)\n{\n\tstruct {\n\t\tconst char *start;\n\t\tconst char *end;\n\t} field[6], name;\n\n\tconst char *s, *st;\n\tint numfields, fields, n, r, sol, ret;\n\tint type, types, tag, permset, id;\n\tsize_t len;\n\tchar sep;\n\n\tswitch (want_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:\n\t\twant_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;\n\t\t__LA_FALLTHROUGH;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tnumfields = 5;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tnumfields = 6;\n\t\tbreak;\n\tdefault:\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tret = ARCHIVE_OK;\n\ttypes = 0;\n\n\twhile (text != NULL &&  *text != '\\0') {\n\t\t/*\n\t\t * Parse the fields out of the next entry,\n\t\t * advance 'text' to start of next entry.\n\t\t */\n\t\tfields = 0;\n\t\tdo {\n\t\t\tconst char *start, *end;\n\t\t\tnext_field(&text, &start, &end, &sep);\n\t\t\tif (fields < numfields) {\n\t\t\t\tfield[fields].start = start;\n\t\t\t\tfield[fields].end = end;\n\t\t\t}\n\t\t\t++fields;\n\t\t} while (sep == ':');\n\n\t\t/* Set remaining fields to blank. */\n\t\tfor (n = fields; n < numfields; ++n)\n\t\t\tfield[n].start = field[n].end = NULL;\n\n\t\tif (field[0].start != NULL && *(field[0].start) == '#') {\n\t\t\t/* Comment, skip entry */\n\t\t\tcontinue;\n\t\t}\n\n\t\tn = 0;\n\t\tsol = 0;\n\t\tid = -1;\n\t\tpermset = 0;\n\t\tname.start = name.end = NULL;\n\n\t\tif (want_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\t/* POSIX.1e ACLs */\n\t\t\t/*\n\t\t\t * Default keyword \"default:user::rwx\"\n\t\t\t * if found, we have one more field\n\t\t\t *\n\t\t\t * We also support old Solaris extension:\n\t\t\t * \"defaultuser::rwx\" is the default ACL corresponding\n\t\t\t * to \"user::rwx\", etc. valid only for first field\n\t\t\t */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\tif (*s == 'd' && (len == 1 || (len >= 7\n\t\t\t    && memcmp((s + 1), \"efault\", 6) == 0))) {\n\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;\n\t\t\t\tif (len > 7)\n\t\t\t\t\tfield[0].start += 7;\n\t\t\t\telse\n\t\t\t\t\tn = 1;\n\t\t\t} else\n\t\t\t\ttype = want_type;\n\n\t\t\t/* Check for a numeric ID in field n+1 or n+3. */\n\t\t\tisint(field[n + 1].start, field[n + 1].end, &id);\n\t\t\t/* Field n+3 is optional. */\n\t\t\tif (id == -1 && fields > (n + 3))\n\t\t\t\tisint(field[n + 3].start, field[n + 3].end,\n\t\t\t\t    &id);\n\n\t\t\ttag = 0;\n\t\t\ts = field[n].start;\n \t\t\tst = field[n].start + 1;\n \t\t\tlen = field[n].end - field[n].start;\n \n \t\t\tswitch (*s) {\n \t\t\tcase 'u':\n \t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \"ser\", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \"roup\", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \"ther\", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_OTHER;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \"ask\", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_MASK;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (tag) {\n\t\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\t\tif (fields == (n + 2)\n\t\t\t\t    && field[n + 1].start < field[n + 1].end\n\t\t\t\t    && ismode(field[n + 1].start,\n\t\t\t\t    field[n + 1].end, &permset)) {\n\t\t\t\t\t/* This is Solaris-style \"other:rwx\" */\n\t\t\t\t\tsol = 1;\n\t\t\t\t} else if (fields == (n + 3) &&\n\t\t\t\t    field[n + 1].start < field[n + 1].end) {\n\t\t\t\t\t/* Invalid mask or other field */\n\t\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\t\tif (id != -1 ||\n\t\t\t\t    field[n + 1].start < field[n + 1].end) {\n\t\t\t\t\tname = field[n + 1];\n\t\t\t\t\tif (tag == ARCHIVE_ENTRY_ACL_USER_OBJ)\n\t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\t\telse\n\t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* Invalid tag, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Without \"default:\" we expect mode in field 3\n\t\t\t * Exception: Solaris other and mask fields\n\t\t\t */\n\t\t\tif (permset == 0 && !ismode(field[n + 2 - sol].start,\n\t\t\t    field[n + 2 - sol].end, &permset)) {\n\t\t\t\t/* Invalid mode, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\t/* NFS4 ACLs */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\ttag = 0;\n\n\t\t\tswitch (len) {\n\t\t\tcase 4:\n\t\t\t\tif (memcmp(s, \"user\", 4) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tif (memcmp(s, \"group\", 5) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tif (memcmp(s, \"owner@\", 6) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\telse if (memcmp(s, \"group@\", 6) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tif (memcmp(s, \"everyone@\", 9) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_EVERYONE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (tag == 0) {\n\t\t\t\t/* Invalid tag, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t} else if (tag == ARCHIVE_ENTRY_ACL_USER ||\n\t\t\t    tag == ARCHIVE_ENTRY_ACL_GROUP) {\n\t\t\t\tn = 1;\n\t\t\t\tname = field[1];\n\t\t\t\tisint(name.start, name.end, &id);\n\t\t\t} else\n\t\t\t\tn = 0;\n\n\t\t\tif (!is_nfs4_perms(field[1 + n].start,\n\t\t\t    field[1 + n].end, &permset)) {\n\t\t\t\t/* Invalid NFSv4 perms, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!is_nfs4_flags(field[2 + n].start,\n\t\t\t    field[2 + n].end, &permset)) {\n\t\t\t\t/* Invalid NFSv4 flags, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts = field[3 + n].start;\n\t\t\tlen = field[3 + n].end - field[3 + n].start;\n\t\t\ttype = 0;\n\t\t\tif (len == 4) {\n\t\t\t\tif (memcmp(s, \"deny\", 4) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DENY;\n\t\t\t} else if (len == 5) {\n\t\t\t\tif (memcmp(s, \"allow\", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;\n\t\t\t\telse if (memcmp(s, \"audit\", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_AUDIT;\n\t\t\t\telse if (memcmp(s, \"alarm\", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALARM;\n\t\t\t}\n\t\t\tif (type == 0) {\n\t\t\t\t/* Invalid entry type, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tisint(field[4 + n].start, field[4 + n].end,\n\t\t\t    &id);\n\t\t}\n\n\t\t/* Add entry to the internal list. */\n\t\tr = archive_acl_add_entry_len_l(acl, type, permset,\n\t\t    tag, id, name.start, name.end - name.start, sc);\n\t\tif (r < ARCHIVE_WARN)\n\t\t\treturn (r);\n\t\tif (r != ARCHIVE_OK)\n\t\t\tret = ARCHIVE_WARN;\n\t\ttypes |= type;\n\t}\n\n\t/* Reset ACL */\n\tarchive_acl_reset(acl, types);\n\n\treturn (ret);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142851,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "archive_acl_from_text_l(struct archive_acl *acl, const char *text,\n    int want_type, struct archive_string_conv *sc)\n{\n\tstruct {\n\t\tconst char *start;\n\t\tconst char *end;\n\t} field[6], name;\n\n\tconst char *s, *st;\n\tint numfields, fields, n, r, sol, ret;\n\tint type, types, tag, permset, id;\n\tsize_t len;\n\tchar sep;\n\n\tswitch (want_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:\n\t\twant_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;\n\t\t__LA_FALLTHROUGH;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tnumfields = 5;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tnumfields = 6;\n\t\tbreak;\n\tdefault:\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tret = ARCHIVE_OK;\n\ttypes = 0;\n\n\twhile (text != NULL &&  *text != '\\0') {\n\t\t/*\n\t\t * Parse the fields out of the next entry,\n\t\t * advance 'text' to start of next entry.\n\t\t */\n\t\tfields = 0;\n\t\tdo {\n\t\t\tconst char *start, *end;\n\t\t\tnext_field(&text, &start, &end, &sep);\n\t\t\tif (fields < numfields) {\n\t\t\t\tfield[fields].start = start;\n\t\t\t\tfield[fields].end = end;\n\t\t\t}\n\t\t\t++fields;\n\t\t} while (sep == ':');\n\n\t\t/* Set remaining fields to blank. */\n\t\tfor (n = fields; n < numfields; ++n)\n\t\t\tfield[n].start = field[n].end = NULL;\n\n\t\tif (field[0].start != NULL && *(field[0].start) == '#') {\n\t\t\t/* Comment, skip entry */\n\t\t\tcontinue;\n\t\t}\n\n\t\tn = 0;\n\t\tsol = 0;\n\t\tid = -1;\n\t\tpermset = 0;\n\t\tname.start = name.end = NULL;\n\n\t\tif (want_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\t/* POSIX.1e ACLs */\n\t\t\t/*\n\t\t\t * Default keyword \"default:user::rwx\"\n\t\t\t * if found, we have one more field\n\t\t\t *\n\t\t\t * We also support old Solaris extension:\n\t\t\t * \"defaultuser::rwx\" is the default ACL corresponding\n\t\t\t * to \"user::rwx\", etc. valid only for first field\n\t\t\t */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\tif (*s == 'd' && (len == 1 || (len >= 7\n\t\t\t    && memcmp((s + 1), \"efault\", 6) == 0))) {\n\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;\n\t\t\t\tif (len > 7)\n\t\t\t\t\tfield[0].start += 7;\n\t\t\t\telse\n\t\t\t\t\tn = 1;\n\t\t\t} else\n\t\t\t\ttype = want_type;\n\n\t\t\t/* Check for a numeric ID in field n+1 or n+3. */\n\t\t\tisint(field[n + 1].start, field[n + 1].end, &id);\n\t\t\t/* Field n+3 is optional. */\n\t\t\tif (id == -1 && fields > (n + 3))\n\t\t\t\tisint(field[n + 3].start, field[n + 3].end,\n\t\t\t\t    &id);\n\n\t\t\ttag = 0;\n\t\t\ts = field[n].start;\n \t\t\tst = field[n].start + 1;\n \t\t\tlen = field[n].end - field[n].start;\n \n\t\t\tif (len == 0) {\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n \t\t\tswitch (*s) {\n \t\t\tcase 'u':\n \t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \"ser\", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \"roup\", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \"ther\", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_OTHER;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \"ask\", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_MASK;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (tag) {\n\t\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\t\tif (fields == (n + 2)\n\t\t\t\t    && field[n + 1].start < field[n + 1].end\n\t\t\t\t    && ismode(field[n + 1].start,\n\t\t\t\t    field[n + 1].end, &permset)) {\n\t\t\t\t\t/* This is Solaris-style \"other:rwx\" */\n\t\t\t\t\tsol = 1;\n\t\t\t\t} else if (fields == (n + 3) &&\n\t\t\t\t    field[n + 1].start < field[n + 1].end) {\n\t\t\t\t\t/* Invalid mask or other field */\n\t\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\t\tif (id != -1 ||\n\t\t\t\t    field[n + 1].start < field[n + 1].end) {\n\t\t\t\t\tname = field[n + 1];\n\t\t\t\t\tif (tag == ARCHIVE_ENTRY_ACL_USER_OBJ)\n\t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\t\telse\n\t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* Invalid tag, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Without \"default:\" we expect mode in field 3\n\t\t\t * Exception: Solaris other and mask fields\n\t\t\t */\n\t\t\tif (permset == 0 && !ismode(field[n + 2 - sol].start,\n\t\t\t    field[n + 2 - sol].end, &permset)) {\n\t\t\t\t/* Invalid mode, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\t/* NFS4 ACLs */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\ttag = 0;\n\n\t\t\tswitch (len) {\n\t\t\tcase 4:\n\t\t\t\tif (memcmp(s, \"user\", 4) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tif (memcmp(s, \"group\", 5) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tif (memcmp(s, \"owner@\", 6) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\telse if (memcmp(s, \"group@\", 6) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tif (memcmp(s, \"everyone@\", 9) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_EVERYONE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (tag == 0) {\n\t\t\t\t/* Invalid tag, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t} else if (tag == ARCHIVE_ENTRY_ACL_USER ||\n\t\t\t    tag == ARCHIVE_ENTRY_ACL_GROUP) {\n\t\t\t\tn = 1;\n\t\t\t\tname = field[1];\n\t\t\t\tisint(name.start, name.end, &id);\n\t\t\t} else\n\t\t\t\tn = 0;\n\n\t\t\tif (!is_nfs4_perms(field[1 + n].start,\n\t\t\t    field[1 + n].end, &permset)) {\n\t\t\t\t/* Invalid NFSv4 perms, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!is_nfs4_flags(field[2 + n].start,\n\t\t\t    field[2 + n].end, &permset)) {\n\t\t\t\t/* Invalid NFSv4 flags, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts = field[3 + n].start;\n\t\t\tlen = field[3 + n].end - field[3 + n].start;\n\t\t\ttype = 0;\n\t\t\tif (len == 4) {\n\t\t\t\tif (memcmp(s, \"deny\", 4) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DENY;\n\t\t\t} else if (len == 5) {\n\t\t\t\tif (memcmp(s, \"allow\", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;\n\t\t\t\telse if (memcmp(s, \"audit\", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_AUDIT;\n\t\t\t\telse if (memcmp(s, \"alarm\", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALARM;\n\t\t\t}\n\t\t\tif (type == 0) {\n\t\t\t\t/* Invalid entry type, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tisint(field[4 + n].start, field[4 + n].end,\n\t\t\t    &id);\n\t\t}\n\n\t\t/* Add entry to the internal list. */\n\t\tr = archive_acl_add_entry_len_l(acl, type, permset,\n\t\t    tag, id, name.start, name.end - name.start, sc);\n\t\tif (r < ARCHIVE_WARN)\n\t\t\treturn (r);\n\t\tif (r != ARCHIVE_OK)\n\t\t\tret = ARCHIVE_WARN;\n\t\ttypes |= type;\n\t}\n\n\t/* Reset ACL */\n\tarchive_acl_reset(acl, types);\n\n\treturn (ret);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142852,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,\n\t\t\t     struct mschmd_header *chm, int entire)\n{\n  unsigned int section, name_len, x, errors, num_chunks;\n  unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;\n  struct mschmd_file *fi, *link = NULL;\n  off_t offset, length;\n  int num_entries;\n\n  /* initialise pointers */\n  chm->files         = NULL;\n  chm->sysfiles      = NULL;\n  chm->chunk_cache   = NULL;\n  chm->sec0.base.chm = chm;\n  chm->sec0.base.id  = 0;\n  chm->sec1.base.chm = chm;\n  chm->sec1.base.id  = 1;\n  chm->sec1.content  = NULL;\n  chm->sec1.control  = NULL;\n  chm->sec1.spaninfo = NULL;\n  chm->sec1.rtable   = NULL;\n\n  /* read the first header */\n  if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* check ITSF signature */\n  if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  /* check both header GUIDs */\n  if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {\n    D((\"incorrect GUIDs\"))\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  chm->version   = EndGetI32(&buf[chmhead_Version]);\n  chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);\n  chm->language  = EndGetI32(&buf[chmhead_LanguageID]);\n  if (chm->version > 3) {\n    sys->message(fh, \"WARNING; CHM version > 3\");\n  }\n\n  /* read the header section table */\n  if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* chmhst3_OffsetCS0 does not exist in version 1 or 2 CHM files.\n   * The offset will be corrected later, once HS1 is read.\n   */\n  if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||\n      read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||\n      read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))\n  {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 0 */\n  if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 0 */\n  if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n  if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 1 */\n  if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 1 */\n  if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  chm->dir_offset = sys->tell(fh);\n  chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);\n  chm->density    = EndGetI32(&buf[chmhs1_Density]);\n  chm->depth      = EndGetI32(&buf[chmhs1_Depth]);\n  chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);\n  chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);\n  chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);\n  chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);\n\n  if (chm->version < 3) {\n    /* versions before 3 don't have chmhst3_OffsetCS0 */\n    chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);\n  }\n\n  /* check if content offset or file size is wrong */\n  if (chm->sec0.offset > chm->length) {\n    D((\"content section begins after file has ended\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  \n  /* ensure there are chunks and that chunk size is\n   * large enough for signature and num_entries */\n  if (chm->chunk_size < (pmgl_Entries + 2)) {\n    D((\"chunk size not large enough\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->num_chunks == 0) {\n    D((\"no chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* The chunk_cache data structure is not great; large values for num_chunks\n   * or num_chunks*chunk_size can exhaust all memory. Until a better chunk\n   * cache is implemented, put arbitrary limits on num_chunks and chunk size.\n   */\n  if (chm->num_chunks > 100000) {\n    D((\"more than 100,000 chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }   \n  if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {\n    D((\"chunks larger than entire file\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* common sense checks on header section 1 fields */\n  if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {\n    sys->message(fh, \"WARNING; chunk size is not a power of two\");\n  }\n  if (chm->first_pmgl != 0) {\n    sys->message(fh, \"WARNING; first PMGL chunk is not zero\");\n  }\n  if (chm->first_pmgl > chm->last_pmgl) {\n    D((\"first pmgl chunk is after last pmgl chunk\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) {\n    D((\"index_root outside valid range\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* if we are doing a quick read, stop here! */\n  if (!entire) {\n    return MSPACK_ERR_OK;\n  }\n\n  /* seek to the first PMGL chunk, and reduce the number of chunks to read */\n  if ((x = chm->first_pmgl) != 0) {\n    if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {\n      return MSPACK_ERR_SEEK;\n    }\n  }\n  num_chunks = chm->last_pmgl - x + 1;\n\n  if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {\n    return MSPACK_ERR_NOMEMORY;\n  }\n\n  /* read and process all chunks from FirstPMGL to LastPMGL */\n  errors = 0;\n  while (num_chunks--) {\n    /* read next chunk */\n    if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {\n      sys->free(chunk);\n      return MSPACK_ERR_READ;\n    }\n\n    /* process only directory (PMGL) chunks */\n    if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;\n\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {\n      sys->message(fh, \"WARNING; PMGL quickref area is too small\");\n    }\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) > \n\t((int)chm->chunk_size - pmgl_Entries))\n    {\n      sys->message(fh, \"WARNING; PMGL quickref area is too large\");\n    }\n\n    p = &chunk[pmgl_Entries];\n    end = &chunk[chm->chunk_size - 2];\n    num_entries = EndGetI16(end);\n\n     while (num_entries--) {\n       READ_ENCINT(name_len);\n       if (name_len > (unsigned int) (end - p)) goto chunk_end;\n      /* consider blank filenames to be an error */\n      if (name_len == 0) goto chunk_end;\n       name = p; p += name_len;\n       READ_ENCINT(section);\n       READ_ENCINT(offset);\n       READ_ENCINT(length);\n \n       /* empty files and directory names are stored as a file entry at\n        * offset 0 with length 0. We want to keep empty files, but not\n        * directory names, which end with a \"/\" */\n      if ((offset == 0) && (length == 0)) {\n\tif ((name_len > 0) && (name[name_len-1] == '/')) continue;\n      }\n\n      if (section > 1) {\n\tsys->message(fh, \"invalid section number '%u'.\", section);\n\tcontinue;\n      }\n\n      if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {\n\tsys->free(chunk);\n\treturn MSPACK_ERR_NOMEMORY;\n      }\n\n      fi->next     = NULL;\n      fi->filename = (char *) &fi[1];\n      fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)\n\t\t                     : (struct mschmd_section *) (&chm->sec1));\n      fi->offset   = offset;\n      fi->length   = length;\n      sys->copy(name, fi->filename, (size_t) name_len);\n      fi->filename[name_len] = '\\0';\n\n      if (name[0] == ':' && name[1] == ':') {\n\t/* system file */\n\tif (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) {\n\t  if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) {\n\t    chm->sec1.content = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) {\n\t    chm->sec1.control = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {\n\t    chm->sec1.spaninfo = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) {\n\t    chm->sec1.rtable = fi;\n\t  }\n\t}\n\tfi->next = chm->sysfiles;\n\tchm->sysfiles = fi;\n      }\n      else {\n\t/* normal file */\n\tif (link) link->next = fi; else chm->files = fi;\n\tlink = fi;\n      }\n    }\n\n    /* this is reached either when num_entries runs out, or if\n     * reading data from the chunk reached a premature end of chunk */\n  chunk_end:\n    if (num_entries >= 0) {\n      D((\"chunk ended before all entries could be read\"))\n      errors++;\n    }\n\n  }\n  sys->free(chunk);\n  return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142887,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,\n\t\t\t     struct mschmd_header *chm, int entire)\n{\n  unsigned int section, name_len, x, errors, num_chunks;\n  unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;\n  struct mschmd_file *fi, *link = NULL;\n  off_t offset, length;\n  int num_entries;\n\n  /* initialise pointers */\n  chm->files         = NULL;\n  chm->sysfiles      = NULL;\n  chm->chunk_cache   = NULL;\n  chm->sec0.base.chm = chm;\n  chm->sec0.base.id  = 0;\n  chm->sec1.base.chm = chm;\n  chm->sec1.base.id  = 1;\n  chm->sec1.content  = NULL;\n  chm->sec1.control  = NULL;\n  chm->sec1.spaninfo = NULL;\n  chm->sec1.rtable   = NULL;\n\n  /* read the first header */\n  if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* check ITSF signature */\n  if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  /* check both header GUIDs */\n  if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {\n    D((\"incorrect GUIDs\"))\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  chm->version   = EndGetI32(&buf[chmhead_Version]);\n  chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);\n  chm->language  = EndGetI32(&buf[chmhead_LanguageID]);\n  if (chm->version > 3) {\n    sys->message(fh, \"WARNING; CHM version > 3\");\n  }\n\n  /* read the header section table */\n  if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* chmhst3_OffsetCS0 does not exist in version 1 or 2 CHM files.\n   * The offset will be corrected later, once HS1 is read.\n   */\n  if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||\n      read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||\n      read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))\n  {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 0 */\n  if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 0 */\n  if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n  if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 1 */\n  if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 1 */\n  if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  chm->dir_offset = sys->tell(fh);\n  chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);\n  chm->density    = EndGetI32(&buf[chmhs1_Density]);\n  chm->depth      = EndGetI32(&buf[chmhs1_Depth]);\n  chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);\n  chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);\n  chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);\n  chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);\n\n  if (chm->version < 3) {\n    /* versions before 3 don't have chmhst3_OffsetCS0 */\n    chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);\n  }\n\n  /* check if content offset or file size is wrong */\n  if (chm->sec0.offset > chm->length) {\n    D((\"content section begins after file has ended\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  \n  /* ensure there are chunks and that chunk size is\n   * large enough for signature and num_entries */\n  if (chm->chunk_size < (pmgl_Entries + 2)) {\n    D((\"chunk size not large enough\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->num_chunks == 0) {\n    D((\"no chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* The chunk_cache data structure is not great; large values for num_chunks\n   * or num_chunks*chunk_size can exhaust all memory. Until a better chunk\n   * cache is implemented, put arbitrary limits on num_chunks and chunk size.\n   */\n  if (chm->num_chunks > 100000) {\n    D((\"more than 100,000 chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }   \n  if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {\n    D((\"chunks larger than entire file\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* common sense checks on header section 1 fields */\n  if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {\n    sys->message(fh, \"WARNING; chunk size is not a power of two\");\n  }\n  if (chm->first_pmgl != 0) {\n    sys->message(fh, \"WARNING; first PMGL chunk is not zero\");\n  }\n  if (chm->first_pmgl > chm->last_pmgl) {\n    D((\"first pmgl chunk is after last pmgl chunk\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) {\n    D((\"index_root outside valid range\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* if we are doing a quick read, stop here! */\n  if (!entire) {\n    return MSPACK_ERR_OK;\n  }\n\n  /* seek to the first PMGL chunk, and reduce the number of chunks to read */\n  if ((x = chm->first_pmgl) != 0) {\n    if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {\n      return MSPACK_ERR_SEEK;\n    }\n  }\n  num_chunks = chm->last_pmgl - x + 1;\n\n  if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {\n    return MSPACK_ERR_NOMEMORY;\n  }\n\n  /* read and process all chunks from FirstPMGL to LastPMGL */\n  errors = 0;\n  while (num_chunks--) {\n    /* read next chunk */\n    if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {\n      sys->free(chunk);\n      return MSPACK_ERR_READ;\n    }\n\n    /* process only directory (PMGL) chunks */\n    if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;\n\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {\n      sys->message(fh, \"WARNING; PMGL quickref area is too small\");\n    }\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) > \n\t((int)chm->chunk_size - pmgl_Entries))\n    {\n      sys->message(fh, \"WARNING; PMGL quickref area is too large\");\n    }\n\n    p = &chunk[pmgl_Entries];\n    end = &chunk[chm->chunk_size - 2];\n    num_entries = EndGetI16(end);\n\n     while (num_entries--) {\n       READ_ENCINT(name_len);\n       if (name_len > (unsigned int) (end - p)) goto chunk_end;\n       name = p; p += name_len;\n       READ_ENCINT(section);\n       READ_ENCINT(offset);\n       READ_ENCINT(length);\n \n      /* ignore blank or one-char (e.g. \"/\") filenames we'd return as blank */\n      if (name_len < 2 || !name[0] || !name[1]) continue;\n\n       /* empty files and directory names are stored as a file entry at\n        * offset 0 with length 0. We want to keep empty files, but not\n        * directory names, which end with a \"/\" */\n      if ((offset == 0) && (length == 0)) {\n\tif ((name_len > 0) && (name[name_len-1] == '/')) continue;\n      }\n\n      if (section > 1) {\n\tsys->message(fh, \"invalid section number '%u'.\", section);\n\tcontinue;\n      }\n\n      if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {\n\tsys->free(chunk);\n\treturn MSPACK_ERR_NOMEMORY;\n      }\n\n      fi->next     = NULL;\n      fi->filename = (char *) &fi[1];\n      fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)\n\t\t                     : (struct mschmd_section *) (&chm->sec1));\n      fi->offset   = offset;\n      fi->length   = length;\n      sys->copy(name, fi->filename, (size_t) name_len);\n      fi->filename[name_len] = '\\0';\n\n      if (name[0] == ':' && name[1] == ':') {\n\t/* system file */\n\tif (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) {\n\t  if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) {\n\t    chm->sec1.content = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) {\n\t    chm->sec1.control = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {\n\t    chm->sec1.spaninfo = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) {\n\t    chm->sec1.rtable = fi;\n\t  }\n\t}\n\tfi->next = chm->sysfiles;\n\tchm->sysfiles = fi;\n      }\n      else {\n\t/* normal file */\n\tif (link) link->next = fi; else chm->files = fi;\n\tlink = fi;\n      }\n    }\n\n    /* this is reached either when num_entries runs out, or if\n     * reading data from the chunk reached a premature end of chunk */\n  chunk_end:\n    if (num_entries >= 0) {\n      D((\"chunk ended before all entries could be read\"))\n      errors++;\n    }\n\n  }\n  sys->free(chunk);\n  return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142888,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n     *pred_rtrn = MATCH_EXACTLY;\n     if (expr->expr.op == EXPR_ACTION_DECL) {\n         const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {\n             log_err(info->ctx,\n                     \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n             return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142931,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n     *pred_rtrn = MATCH_EXACTLY;\n     if (expr->expr.op == EXPR_ACTION_DECL) {\n         const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn) ||\n            !expr->action.args) {\n             log_err(info->ctx,\n                     \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n             return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142932,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return (*field_rtrn != NULL);\n    case EXPR_FIELD_REF:\n         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n         *index_rtrn = NULL;\n        return true;\n     case EXPR_ARRAY_REF:\n         *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n         *index_rtrn = expr->array_ref.entry;\n         return true;\n     default:\n         break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142933,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return (*field_rtrn != NULL);\n    case EXPR_FIELD_REF:\n         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n         *index_rtrn = NULL;\n        return (*elem_rtrn != NULL && *field_rtrn != NULL);\n     case EXPR_ARRAY_REF:\n         *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n         *index_rtrn = expr->array_ref.entry;\n\tif (expr->array_ref.element != XKB_ATOM_NONE && *elem_rtrn == NULL)\n\t\treturn false;\n\tif (*field_rtrn == NULL)\n\t\treturn false;\n         return true;\n     default:\n         break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142934,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n\n    /*\n     * Do some sanity checking on the aliases. We can't do it before\n     * because keys and their aliases may be added out-of-order.\n     */\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        /* Check that ->real is a key. */\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        /* Check that ->alias is not a key. */\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        num_key_aliases++;\n    }\n\n    /* Copy key aliases. */\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n         key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n         if (!key_aliases)\n             return false;\n    }\n \n    i = 0;\n    darray_foreach(alias, info->aliases) {\n        if (alias->real != XKB_ATOM_NONE) {\n            key_aliases[i].alias = alias->alias;\n            key_aliases[i].real = alias->real;\n            i++;\n         }\n     }\n \n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142935,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n\n    /*\n     * Do some sanity checking on the aliases. We can't do it before\n     * because keys and their aliases may be added out-of-order.\n     */\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        /* Check that ->real is a key. */\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        /* Check that ->alias is not a key. */\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        num_key_aliases++;\n    }\n\n    /* Copy key aliases. */\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n         key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n         if (!key_aliases)\n             return false;\n \n        i = 0;\n        darray_foreach(alias, info->aliases) {\n            if (alias->real != XKB_ATOM_NONE) {\n                key_aliases[i].alias = alias->alias;\n                key_aliases[i].real = alias->real;\n                i++;\n            }\n         }\n     }\n \n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142936,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n\n    /* Collect section files and check for duplicates. */\n    for (file = (XkbFile *) file->defs; file;\n          file = (XkbFile *) file->common.next) {\n         if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n             file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n                    xkb_file_type_to_string(file->file_type));\n             continue;\n         }\n \n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \"More than one %s section in keymap file; \"\n                    \"All sections after the first ignored\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        files[file->file_type] = file;\n    }\n\n    /*\n     * Check that all required section were provided.\n     * Report everything before failing.\n     */\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \"Required section %s missing from keymap\\n\",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n    if (!ok)\n        return false;\n\n    /* Compile sections. */\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \"Compiling %s \\\"%s\\\"\\n\",\n                xkb_file_type_to_string(type), files[type]->name);\n\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \"Failed to compile %s\\n\",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n\n    return UpdateDerivedKeymapFields(keymap);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142941,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n\n    /* Collect section files and check for duplicates. */\n    for (file = (XkbFile *) file->defs; file;\n          file = (XkbFile *) file->common.next) {\n         if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n             file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            if (file->file_type == FILE_TYPE_GEOMETRY) {\n                log_vrb(ctx, 1,\n                        \"Geometry sections are not supported; ignoring\\n\");\n            } else {\n                log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n                        xkb_file_type_to_string(file->file_type));\n            }\n             continue;\n         }\n \n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \"More than one %s section in keymap file; \"\n                    \"All sections after the first ignored\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        files[file->file_type] = file;\n    }\n\n    /*\n     * Check that all required section were provided.\n     * Report everything before failing.\n     */\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \"Required section %s missing from keymap\\n\",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n    if (!ok)\n        return false;\n\n    /* Compile sections. */\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \"Compiling %s \\\"%s\\\"\\n\",\n                xkb_file_type_to_string(type), files[type]->name);\n\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \"Failed to compile %s\\n\",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n\n    return UpdateDerivedKeymapFields(keymap);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142942,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo *hdr;\n    int err;\n\n    if (!*phdr)\n        *phdr = av_mallocz(sizeof(AC3HeaderInfo));\n    if (!*phdr)\n         return AVERROR(ENOMEM);\n     hdr = *phdr;\n \n    init_get_bits8(&gb, buf, size);\n     err = ff_ac3_parse_header(&gb, hdr);\n     if (err < 0)\n         return AVERROR_INVALIDDATA;\n\n    return get_bits_count(&gb);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142979,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo *hdr;\n    int err;\n\n    if (!*phdr)\n        *phdr = av_mallocz(sizeof(AC3HeaderInfo));\n    if (!*phdr)\n         return AVERROR(ENOMEM);\n     hdr = *phdr;\n \n    err = init_get_bits8(&gb, buf, size);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n     err = ff_ac3_parse_header(&gb, hdr);\n     if (err < 0)\n         return AVERROR_INVALIDDATA;\n\n    return get_bits_count(&gb);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142980,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    unsigned startcode, v;\n    int ret;\n    int vol = 0;\n\n    /* search next start code */\n    align_get_bits(gb);\n\n    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)\n        s->avctx->bits_per_raw_sample = 0;\n\n    if (s->codec_tag == AV_RL32(\"WV1F\") && show_bits(gb, 24) == 0x575630) {\n        skip_bits(gb, 24);\n        if (get_bits(gb, 8) == 0xF0)\n            goto end;\n    }\n\n    startcode = 0xff;\n    for (;;) {\n        if (get_bits_count(gb) >= gb->size_in_bits) {\n            if (gb->size_in_bits == 8 &&\n                (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(\"QMP4\")) {\n                av_log(s->avctx, AV_LOG_VERBOSE, \"frame skip %d\\n\", gb->size_in_bits);\n                return FRAME_SKIPPED;  // divx bug\n            } else\n                return AVERROR_INVALIDDATA;  // end of stream\n        }\n\n        /* use the bits after the test */\n        v = get_bits(gb, 8);\n        startcode = ((startcode << 8) | v) & 0xffffffff;\n\n        if ((startcode & 0xFFFFFF00) != 0x100)\n            continue;  // no startcode\n\n        if (s->avctx->debug & FF_DEBUG_STARTCODE) {\n            av_log(s->avctx, AV_LOG_DEBUG, \"startcode: %3X \", startcode);\n            if (startcode <= 0x11F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Start\");\n            else if (startcode <= 0x12F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Layer Start\");\n            else if (startcode <= 0x13F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\n            else if (startcode <= 0x15F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FGS bp start\");\n            else if (startcode <= 0x1AF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\n            else if (startcode == 0x1B0)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq Start\");\n            else if (startcode == 0x1B1)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq End\");\n            else if (startcode == 0x1B2)\n                av_log(s->avctx, AV_LOG_DEBUG, \"User Data\");\n            else if (startcode == 0x1B3)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Group of VOP start\");\n            else if (startcode == 0x1B4)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Session Error\");\n            else if (startcode == 0x1B5)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Start\");\n            else if (startcode == 0x1B6)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Plane start\");\n            else if (startcode == 0x1B7)\n                av_log(s->avctx, AV_LOG_DEBUG, \"slice start\");\n            else if (startcode == 0x1B8)\n                av_log(s->avctx, AV_LOG_DEBUG, \"extension start\");\n            else if (startcode == 0x1B9)\n                av_log(s->avctx, AV_LOG_DEBUG, \"fgs start\");\n            else if (startcode == 0x1BA)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object start\");\n            else if (startcode == 0x1BB)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object Plane start\");\n            else if (startcode == 0x1BC)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object start\");\n            else if (startcode == 0x1BD)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object Plane start\");\n            else if (startcode == 0x1BE)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Still Texture Object start\");\n            else if (startcode == 0x1BF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Spatial Layer start\");\n            else if (startcode == 0x1C0)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture SNR Layer start\");\n            else if (startcode == 0x1C1)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Tile start\");\n            else if (startcode == 0x1C2)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Shape Layer start\");\n            else if (startcode == 0x1C3)\n                av_log(s->avctx, AV_LOG_DEBUG, \"stuffing start\");\n            else if (startcode <= 0x1C5)\n                av_log(s->avctx, AV_LOG_DEBUG, \"reserved\");\n            else if (startcode <= 0x1FF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"System start\");\n            av_log(s->avctx, AV_LOG_DEBUG, \" at %d\\n\", get_bits_count(gb));\n        }\n\n        if (startcode >= 0x120 && startcode <= 0x12F) {\n            if (vol) {\n                av_log(s->avctx, AV_LOG_WARNING, \"Ignoring multiple VOL headers\\n\");\n                continue;\n            }\n            vol++;\n            if ((ret = decode_vol_header(ctx, gb)) < 0)\n                return ret;\n        } else if (startcode == USER_DATA_STARTCODE) {\n            decode_user_data(ctx, gb);\n         } else if (startcode == GOP_STARTCODE) {\n             mpeg4_decode_gop_header(s, gb);\n         } else if (startcode == VOS_STARTCODE) {\n            mpeg4_decode_profile_level(s, gb);\n            if (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n                (s->avctx->level > 0 && s->avctx->level < 9)) {\n                 s->studio_profile = 1;\n                 next_start_code_studio(gb);\n                 extension_and_user_data(s, gb, 0);\n             }\n         } else if (startcode == VISUAL_OBJ_STARTCODE) {\n             if (s->studio_profile) {\n                 if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n                    return ret;\n            } else\n                mpeg4_decode_visual_object(s, gb);\n        } else if (startcode == VOP_STARTCODE) {\n            break;\n        }\n\n        align_get_bits(gb);\n        startcode = 0xff;\n    }\n\nend:\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n     s->avctx->has_b_frames = !s->low_delay;\n \n     if (s->studio_profile) {\n         if (!s->avctx->bits_per_raw_sample) {\n             av_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");\n             return AVERROR_INVALIDDATA;\n        }\n        return decode_studio_vop_header(ctx, gb);\n    } else\n        return decode_vop_header(ctx, gb);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142981,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    unsigned startcode, v;\n    int ret;\n    int vol = 0;\n\n    /* search next start code */\n    align_get_bits(gb);\n\n    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)\n        s->avctx->bits_per_raw_sample = 0;\n\n    if (s->codec_tag == AV_RL32(\"WV1F\") && show_bits(gb, 24) == 0x575630) {\n        skip_bits(gb, 24);\n        if (get_bits(gb, 8) == 0xF0)\n            goto end;\n    }\n\n    startcode = 0xff;\n    for (;;) {\n        if (get_bits_count(gb) >= gb->size_in_bits) {\n            if (gb->size_in_bits == 8 &&\n                (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(\"QMP4\")) {\n                av_log(s->avctx, AV_LOG_VERBOSE, \"frame skip %d\\n\", gb->size_in_bits);\n                return FRAME_SKIPPED;  // divx bug\n            } else\n                return AVERROR_INVALIDDATA;  // end of stream\n        }\n\n        /* use the bits after the test */\n        v = get_bits(gb, 8);\n        startcode = ((startcode << 8) | v) & 0xffffffff;\n\n        if ((startcode & 0xFFFFFF00) != 0x100)\n            continue;  // no startcode\n\n        if (s->avctx->debug & FF_DEBUG_STARTCODE) {\n            av_log(s->avctx, AV_LOG_DEBUG, \"startcode: %3X \", startcode);\n            if (startcode <= 0x11F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Start\");\n            else if (startcode <= 0x12F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Layer Start\");\n            else if (startcode <= 0x13F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\n            else if (startcode <= 0x15F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FGS bp start\");\n            else if (startcode <= 0x1AF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\n            else if (startcode == 0x1B0)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq Start\");\n            else if (startcode == 0x1B1)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq End\");\n            else if (startcode == 0x1B2)\n                av_log(s->avctx, AV_LOG_DEBUG, \"User Data\");\n            else if (startcode == 0x1B3)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Group of VOP start\");\n            else if (startcode == 0x1B4)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Session Error\");\n            else if (startcode == 0x1B5)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Start\");\n            else if (startcode == 0x1B6)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Plane start\");\n            else if (startcode == 0x1B7)\n                av_log(s->avctx, AV_LOG_DEBUG, \"slice start\");\n            else if (startcode == 0x1B8)\n                av_log(s->avctx, AV_LOG_DEBUG, \"extension start\");\n            else if (startcode == 0x1B9)\n                av_log(s->avctx, AV_LOG_DEBUG, \"fgs start\");\n            else if (startcode == 0x1BA)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object start\");\n            else if (startcode == 0x1BB)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object Plane start\");\n            else if (startcode == 0x1BC)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object start\");\n            else if (startcode == 0x1BD)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object Plane start\");\n            else if (startcode == 0x1BE)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Still Texture Object start\");\n            else if (startcode == 0x1BF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Spatial Layer start\");\n            else if (startcode == 0x1C0)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture SNR Layer start\");\n            else if (startcode == 0x1C1)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Tile start\");\n            else if (startcode == 0x1C2)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Shape Layer start\");\n            else if (startcode == 0x1C3)\n                av_log(s->avctx, AV_LOG_DEBUG, \"stuffing start\");\n            else if (startcode <= 0x1C5)\n                av_log(s->avctx, AV_LOG_DEBUG, \"reserved\");\n            else if (startcode <= 0x1FF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"System start\");\n            av_log(s->avctx, AV_LOG_DEBUG, \" at %d\\n\", get_bits_count(gb));\n        }\n\n        if (startcode >= 0x120 && startcode <= 0x12F) {\n            if (vol) {\n                av_log(s->avctx, AV_LOG_WARNING, \"Ignoring multiple VOL headers\\n\");\n                continue;\n            }\n            vol++;\n            if ((ret = decode_vol_header(ctx, gb)) < 0)\n                return ret;\n        } else if (startcode == USER_DATA_STARTCODE) {\n            decode_user_data(ctx, gb);\n         } else if (startcode == GOP_STARTCODE) {\n             mpeg4_decode_gop_header(s, gb);\n         } else if (startcode == VOS_STARTCODE) {\n            int profile, level;\n            mpeg4_decode_profile_level(s, gb, &profile, &level);\n            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n                (level > 0 && level < 9)) {\n                 s->studio_profile = 1;\n                 next_start_code_studio(gb);\n                 extension_and_user_data(s, gb, 0);\n            } else if (s->studio_profile) {\n                avpriv_request_sample(s->avctx, \"Mixes studio and non studio profile\\n\");\n                return AVERROR_PATCHWELCOME;\n             }\n            s->avctx->profile = profile;\n            s->avctx->level   = level;\n         } else if (startcode == VISUAL_OBJ_STARTCODE) {\n             if (s->studio_profile) {\n                 if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n                    return ret;\n            } else\n                mpeg4_decode_visual_object(s, gb);\n        } else if (startcode == VOP_STARTCODE) {\n            break;\n        }\n\n        align_get_bits(gb);\n        startcode = 0xff;\n    }\n\nend:\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n     s->avctx->has_b_frames = !s->low_delay;\n \n     if (s->studio_profile) {\n        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n         if (!s->avctx->bits_per_raw_sample) {\n             av_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");\n             return AVERROR_INVALIDDATA;\n        }\n        return decode_studio_vop_header(ctx, gb);\n    } else\n        return decode_vop_header(ctx, gb);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142982,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " xfs_dinode_verify(\n \tstruct xfs_mount\t*mp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_dinode\t*dip)\n{\n\txfs_failaddr_t\t\tfa;\n\tuint16_t\t\tmode;\n\tuint16_t\t\tflags;\n\tuint64_t\t\tflags2;\n\tuint64_t\t\tdi_size;\n\n\tif (dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC))\n\t\treturn __this_address;\n\n\t/* Verify v3 integrity information first */\n\tif (dip->di_version >= 3) {\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn __this_address;\n\t\tif (!xfs_verify_cksum((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t\t      XFS_DINODE_CRC_OFF))\n\t\t\treturn __this_address;\n\t\tif (be64_to_cpu(dip->di_ino) != ino)\n\t\t\treturn __this_address;\n\t\tif (!uuid_equal(&dip->di_uuid, &mp->m_sb.sb_meta_uuid))\n\t\t\treturn __this_address;\n\t}\n\n\t/* don't allow invalid i_size */\n\tdi_size = be64_to_cpu(dip->di_size);\n\tif (di_size & (1ULL << 63))\n\t\treturn __this_address;\n\n\tmode = be16_to_cpu(dip->di_mode);\n\tif (mode && xfs_mode_to_ftype(mode) == XFS_DIR3_FT_UNKNOWN)\n\t\treturn __this_address;\n\n\t/* No zero-length symlinks/dirs. */\n\tif ((S_ISLNK(mode) || S_ISDIR(mode)) && di_size == 0)\n\t\treturn __this_address;\n\n\t/* Fork checks carried over from xfs_iformat_fork */\n\tif (mode &&\n\t    be32_to_cpu(dip->di_nextents) + be16_to_cpu(dip->di_anextents) >\n\t\t\tbe64_to_cpu(dip->di_nblocks))\n\t\treturn __this_address;\n\n\tif (mode && XFS_DFORK_BOFF(dip) > mp->m_sb.sb_inodesize)\n\t\treturn __this_address;\n\n\tflags = be16_to_cpu(dip->di_flags);\n\n\tif (mode && (flags & XFS_DIFLAG_REALTIME) && !mp->m_rtdev_targp)\n\t\treturn __this_address;\n\n\t/* Do we have appropriate data fork formats for the mode? */\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tif (dip->di_format != XFS_DINODE_FMT_DEV)\n\t\t\treturn __this_address;\n\t\tbreak;\n \tcase S_IFREG:\n \tcase S_IFLNK:\n \tcase S_IFDIR:\n\t\tswitch (dip->di_format) {\n\t\tcase XFS_DINODE_FMT_LOCAL:\n\t\t\t/*\n\t\t\t * no local regular files yet\n\t\t\t */\n\t\t\tif (S_ISREG(mode))\n\t\t\t\treturn __this_address;\n\t\t\tif (di_size > XFS_DFORK_DSIZE(dip, mp))\n\t\t\t\treturn __this_address;\n\t\t\tif (dip->di_nextents)\n\t\t\t\treturn __this_address;\n\t\t\t/* fall through */\n\t\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tcase XFS_DINODE_FMT_BTREE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn __this_address;\n\t\t}\n \t\tbreak;\n \tcase 0:\n \t\t/* Uninitialized inode ok. */\n\t\tbreak;\n\tdefault:\n\t\treturn __this_address;\n \t}\n \n \tif (XFS_DFORK_Q(dip)) {\n\t\tswitch (dip->di_aformat) {\n\t\tcase XFS_DINODE_FMT_LOCAL:\n\t\t\tif (dip->di_anextents)\n\t\t\t\treturn __this_address;\n\t\t/* fall through */\n\t\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tcase XFS_DINODE_FMT_BTREE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn __this_address;\n\t\t}\n \t} else {\n \t\t/*\n \t\t * If there is no fork offset, this may be a freshly-made inode\n\t\t * in a new disk cluster, in which case di_aformat is zeroed.\n\t\t * Otherwise, such an inode must be in EXTENTS format; this goes\n\t\t * for freed inodes as well.\n\t\t */\n\t\tswitch (dip->di_aformat) {\n\t\tcase 0:\n\t\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn __this_address;\n\t\t}\n\t\tif (dip->di_anextents)\n\t\t\treturn __this_address;\n\t}\n\n\t/* extent size hint validation */\n\tfa = xfs_inode_validate_extsize(mp, be32_to_cpu(dip->di_extsize),\n\t\t\tmode, flags);\n\tif (fa)\n\t\treturn fa;\n\n\t/* only version 3 or greater inodes are extensively verified here */\n\tif (dip->di_version < 3)\n\t\treturn NULL;\n\n\tflags2 = be64_to_cpu(dip->di_flags2);\n\n\t/* don't allow reflink/cowextsize if we don't have reflink */\n\tif ((flags2 & (XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE)) &&\n\t     !xfs_sb_version_hasreflink(&mp->m_sb))\n\t\treturn __this_address;\n\n\t/* only regular files get reflink */\n\tif ((flags2 & XFS_DIFLAG2_REFLINK) && (mode & S_IFMT) != S_IFREG)\n\t\treturn __this_address;\n\n\t/* don't let reflink and realtime mix */\n\tif ((flags2 & XFS_DIFLAG2_REFLINK) && (flags & XFS_DIFLAG_REALTIME))\n\t\treturn __this_address;\n\n\t/* don't let reflink and dax mix */\n\tif ((flags2 & XFS_DIFLAG2_REFLINK) && (flags2 & XFS_DIFLAG2_DAX))\n\t\treturn __this_address;\n\n\t/* COW extent size hint validation */\n\tfa = xfs_inode_validate_cowextsize(mp, be32_to_cpu(dip->di_cowextsize),\n\t\t\tmode, flags, flags2);\n\tif (fa)\n\t\treturn fa;\n\n\treturn NULL;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142983,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " xfs_dinode_verify(\n \tstruct xfs_mount\t*mp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_dinode\t*dip)\n{\n\txfs_failaddr_t\t\tfa;\n\tuint16_t\t\tmode;\n\tuint16_t\t\tflags;\n\tuint64_t\t\tflags2;\n\tuint64_t\t\tdi_size;\n\n\tif (dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC))\n\t\treturn __this_address;\n\n\t/* Verify v3 integrity information first */\n\tif (dip->di_version >= 3) {\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn __this_address;\n\t\tif (!xfs_verify_cksum((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t\t      XFS_DINODE_CRC_OFF))\n\t\t\treturn __this_address;\n\t\tif (be64_to_cpu(dip->di_ino) != ino)\n\t\t\treturn __this_address;\n\t\tif (!uuid_equal(&dip->di_uuid, &mp->m_sb.sb_meta_uuid))\n\t\t\treturn __this_address;\n\t}\n\n\t/* don't allow invalid i_size */\n\tdi_size = be64_to_cpu(dip->di_size);\n\tif (di_size & (1ULL << 63))\n\t\treturn __this_address;\n\n\tmode = be16_to_cpu(dip->di_mode);\n\tif (mode && xfs_mode_to_ftype(mode) == XFS_DIR3_FT_UNKNOWN)\n\t\treturn __this_address;\n\n\t/* No zero-length symlinks/dirs. */\n\tif ((S_ISLNK(mode) || S_ISDIR(mode)) && di_size == 0)\n\t\treturn __this_address;\n\n\t/* Fork checks carried over from xfs_iformat_fork */\n\tif (mode &&\n\t    be32_to_cpu(dip->di_nextents) + be16_to_cpu(dip->di_anextents) >\n\t\t\tbe64_to_cpu(dip->di_nblocks))\n\t\treturn __this_address;\n\n\tif (mode && XFS_DFORK_BOFF(dip) > mp->m_sb.sb_inodesize)\n\t\treturn __this_address;\n\n\tflags = be16_to_cpu(dip->di_flags);\n\n\tif (mode && (flags & XFS_DIFLAG_REALTIME) && !mp->m_rtdev_targp)\n\t\treturn __this_address;\n\n\t/* Do we have appropriate data fork formats for the mode? */\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tif (dip->di_format != XFS_DINODE_FMT_DEV)\n\t\t\treturn __this_address;\n\t\tbreak;\n \tcase S_IFREG:\n \tcase S_IFLNK:\n \tcase S_IFDIR:\n\t\tfa = xfs_dinode_verify_fork(dip, mp, XFS_DATA_FORK);\n\t\tif (fa)\n\t\t\treturn fa;\n \t\tbreak;\n \tcase 0:\n \t\t/* Uninitialized inode ok. */\n\t\tbreak;\n\tdefault:\n\t\treturn __this_address;\n \t}\n \n \tif (XFS_DFORK_Q(dip)) {\n\t\tfa = xfs_dinode_verify_fork(dip, mp, XFS_ATTR_FORK);\n\t\tif (fa)\n\t\t\treturn fa;\n \t} else {\n \t\t/*\n \t\t * If there is no fork offset, this may be a freshly-made inode\n\t\t * in a new disk cluster, in which case di_aformat is zeroed.\n\t\t * Otherwise, such an inode must be in EXTENTS format; this goes\n\t\t * for freed inodes as well.\n\t\t */\n\t\tswitch (dip->di_aformat) {\n\t\tcase 0:\n\t\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn __this_address;\n\t\t}\n\t\tif (dip->di_anextents)\n\t\t\treturn __this_address;\n\t}\n\n\t/* extent size hint validation */\n\tfa = xfs_inode_validate_extsize(mp, be32_to_cpu(dip->di_extsize),\n\t\t\tmode, flags);\n\tif (fa)\n\t\treturn fa;\n\n\t/* only version 3 or greater inodes are extensively verified here */\n\tif (dip->di_version < 3)\n\t\treturn NULL;\n\n\tflags2 = be64_to_cpu(dip->di_flags2);\n\n\t/* don't allow reflink/cowextsize if we don't have reflink */\n\tif ((flags2 & (XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE)) &&\n\t     !xfs_sb_version_hasreflink(&mp->m_sb))\n\t\treturn __this_address;\n\n\t/* only regular files get reflink */\n\tif ((flags2 & XFS_DIFLAG2_REFLINK) && (mode & S_IFMT) != S_IFREG)\n\t\treturn __this_address;\n\n\t/* don't let reflink and realtime mix */\n\tif ((flags2 & XFS_DIFLAG2_REFLINK) && (flags & XFS_DIFLAG_REALTIME))\n\t\treturn __this_address;\n\n\t/* don't let reflink and dax mix */\n\tif ((flags2 & XFS_DIFLAG2_REFLINK) && (flags2 & XFS_DIFLAG2_DAX))\n\t\treturn __this_address;\n\n\t/* COW extent size hint validation */\n\tfa = xfs_inode_validate_cowextsize(mp, be32_to_cpu(dip->di_cowextsize),\n\t\t\tmode, flags, flags2);\n\tif (fa)\n\t\treturn fa;\n\n\treturn NULL;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142984,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "xfs_attr_shortform_to_leaf(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t**leaf_bp)\n{\n\txfs_inode_t *dp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_da_args_t nargs;\n\tchar *tmpbuffer;\n\tint error, i, size;\n\txfs_dablk_t blkno;\n\tstruct xfs_buf *bp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_to_leaf(args);\n\n\tdp = args->dp;\n\tifp = dp->i_afp;\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsize = be16_to_cpu(sf->hdr.totsize);\n\ttmpbuffer = kmem_alloc(size, KM_SLEEP);\n\tASSERT(tmpbuffer != NULL);\n\tmemcpy(tmpbuffer, ifp->if_u1.if_data, size);\n\tsf = (xfs_attr_shortform_t *)tmpbuffer;\n\n\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\txfs_bmap_local_to_extents_empty(dp, XFS_ATTR_FORK);\n\n\tbp = NULL;\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error) {\n\t\t/*\n\t\t * If we hit an IO error middle of the transaction inside\n\t\t * grow_inode(), we may have inconsistent data. Bail out.\n\t\t */\n\t\tif (error == -EIO)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n \tASSERT(blkno == 0);\n \terror = xfs_attr3_leaf_create(args, blkno, &bp);\n \tif (error) {\n\t\terror = xfs_da_shrink_inode(args, 0, bp);\n\t\tbp = NULL;\n\t\tif (error)\n \t\t\tgoto out;\n \t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n \t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.dp = dp;\n\tnargs.geo = args->geo;\n\tnargs.firstblock = args->firstblock;\n\tnargs.dfops = args->dfops;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; i++) {\n\t\tnargs.name = sfe->nameval;\n\t\tnargs.namelen = sfe->namelen;\n\t\tnargs.value = &sfe->nameval[nargs.namelen];\n\t\tnargs.valuelen = sfe->valuelen;\n\t\tnargs.hashval = xfs_da_hashname(sfe->nameval,\n\t\t\t\t\t\tsfe->namelen);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(sfe->flags);\n\t\terror = xfs_attr3_leaf_lookup_int(bp, &nargs); /* set a->index */\n\t\tASSERT(error == -ENOATTR);\n\t\terror = xfs_attr3_leaf_add(bp, &nargs);\n\t\tASSERT(error != -ENOSPC);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t}\n\terror = 0;\n\t*leaf_bp = bp;\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142985,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "xfs_attr_shortform_to_leaf(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t**leaf_bp)\n{\n\txfs_inode_t *dp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_da_args_t nargs;\n\tchar *tmpbuffer;\n\tint error, i, size;\n\txfs_dablk_t blkno;\n\tstruct xfs_buf *bp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_to_leaf(args);\n\n\tdp = args->dp;\n\tifp = dp->i_afp;\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsize = be16_to_cpu(sf->hdr.totsize);\n\ttmpbuffer = kmem_alloc(size, KM_SLEEP);\n\tASSERT(tmpbuffer != NULL);\n\tmemcpy(tmpbuffer, ifp->if_u1.if_data, size);\n\tsf = (xfs_attr_shortform_t *)tmpbuffer;\n\n\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\txfs_bmap_local_to_extents_empty(dp, XFS_ATTR_FORK);\n\n\tbp = NULL;\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error) {\n\t\t/*\n\t\t * If we hit an IO error middle of the transaction inside\n\t\t * grow_inode(), we may have inconsistent data. Bail out.\n\t\t */\n\t\tif (error == -EIO)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n \tASSERT(blkno == 0);\n \terror = xfs_attr3_leaf_create(args, blkno, &bp);\n \tif (error) {\n\t\t/* xfs_attr3_leaf_create may not have instantiated a block */\n\t\tif (bp && (xfs_da_shrink_inode(args, 0, bp) != 0))\n \t\t\tgoto out;\n \t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n \t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.dp = dp;\n\tnargs.geo = args->geo;\n\tnargs.firstblock = args->firstblock;\n\tnargs.dfops = args->dfops;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; i++) {\n\t\tnargs.name = sfe->nameval;\n\t\tnargs.namelen = sfe->namelen;\n\t\tnargs.value = &sfe->nameval[nargs.namelen];\n\t\tnargs.valuelen = sfe->valuelen;\n\t\tnargs.hashval = xfs_da_hashname(sfe->nameval,\n\t\t\t\t\t\tsfe->namelen);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(sfe->flags);\n\t\terror = xfs_attr3_leaf_lookup_int(bp, &nargs); /* set a->index */\n\t\tASSERT(error == -ENOATTR);\n\t\terror = xfs_attr3_leaf_add(bp, &nargs);\n\t\tASSERT(error != -ENOSPC);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t}\n\terror = 0;\n\t*leaf_bp = bp;\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142986,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "av_cold void ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx)\n{\n    const unsigned high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n    if (avctx->lowres==1) {\n        c->idct_put  = ff_jref_idct4_put;\n        c->idct_add  = ff_jref_idct4_add;\n        c->idct      = ff_j_rev_dct4;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else if (avctx->lowres==2) {\n        c->idct_put  = ff_jref_idct2_put;\n        c->idct_add  = ff_jref_idct2_add;\n        c->idct      = ff_j_rev_dct2;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else if (avctx->lowres==3) {\n        c->idct_put  = ff_jref_idct1_put;\n        c->idct_add  = ff_jref_idct1_add;\n        c->idct      = ff_j_rev_dct1;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else {\n         if (avctx->bits_per_raw_sample == 10 || avctx->bits_per_raw_sample == 9) {\n             /* 10-bit MPEG-4 Simple Studio Profile requires a higher precision IDCT\n                However, it only uses idct_put */\n            if (avctx->codec_id == AV_CODEC_ID_MPEG4 && avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO)\n                 c->idct_put              = ff_simple_idct_put_int32_10bit;\n             else {\n                 c->idct_put              = ff_simple_idct_put_int16_10bit;\n                c->idct_add              = ff_simple_idct_add_int16_10bit;\n                c->idct                  = ff_simple_idct_int16_10bit;\n            }\n            c->perm_type             = FF_IDCT_PERM_NONE;\n        } else if (avctx->bits_per_raw_sample == 12) {\n            c->idct_put              = ff_simple_idct_put_int16_12bit;\n            c->idct_add              = ff_simple_idct_add_int16_12bit;\n            c->idct                  = ff_simple_idct_int16_12bit;\n            c->perm_type             = FF_IDCT_PERM_NONE;\n        } else {\n            if (avctx->idct_algo == FF_IDCT_INT) {\n                c->idct_put  = ff_jref_idct_put;\n                c->idct_add  = ff_jref_idct_add;\n                c->idct      = ff_j_rev_dct;\n                c->perm_type = FF_IDCT_PERM_LIBMPEG2;\n#if CONFIG_FAANIDCT\n            } else if (avctx->idct_algo == FF_IDCT_FAAN) {\n                c->idct_put  = ff_faanidct_put;\n                c->idct_add  = ff_faanidct_add;\n                c->idct      = ff_faanidct;\n                c->perm_type = FF_IDCT_PERM_NONE;\n#endif /* CONFIG_FAANIDCT */\n            } else { // accurate/default\n                /* Be sure FF_IDCT_NONE will select this one, since it uses FF_IDCT_PERM_NONE */\n                c->idct_put  = ff_simple_idct_put_int16_8bit;\n                c->idct_add  = ff_simple_idct_add_int16_8bit;\n                c->idct      = ff_simple_idct_int16_8bit;\n                c->perm_type = FF_IDCT_PERM_NONE;\n            }\n        }\n    }\n\n    c->put_pixels_clamped        = ff_put_pixels_clamped_c;\n    c->put_signed_pixels_clamped = put_signed_pixels_clamped_c;\n    c->add_pixels_clamped        = ff_add_pixels_clamped_c;\n\n    if (CONFIG_MPEG4_DECODER && avctx->idct_algo == FF_IDCT_XVID)\n        ff_xvid_idct_init(c, avctx);\n\n    if (ARCH_AARCH64)\n        ff_idctdsp_init_aarch64(c, avctx, high_bit_depth);\n    if (ARCH_ALPHA)\n        ff_idctdsp_init_alpha(c, avctx, high_bit_depth);\n    if (ARCH_ARM)\n        ff_idctdsp_init_arm(c, avctx, high_bit_depth);\n    if (ARCH_PPC)\n        ff_idctdsp_init_ppc(c, avctx, high_bit_depth);\n    if (ARCH_X86)\n        ff_idctdsp_init_x86(c, avctx, high_bit_depth);\n    if (ARCH_MIPS)\n        ff_idctdsp_init_mips(c, avctx, high_bit_depth);\n\n    ff_init_scantable_permutation(c->idct_permutation,\n                                  c->perm_type);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142991,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "av_cold void ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx)\n{\n    const unsigned high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n    if (avctx->lowres==1) {\n        c->idct_put  = ff_jref_idct4_put;\n        c->idct_add  = ff_jref_idct4_add;\n        c->idct      = ff_j_rev_dct4;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else if (avctx->lowres==2) {\n        c->idct_put  = ff_jref_idct2_put;\n        c->idct_add  = ff_jref_idct2_add;\n        c->idct      = ff_j_rev_dct2;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else if (avctx->lowres==3) {\n        c->idct_put  = ff_jref_idct1_put;\n        c->idct_add  = ff_jref_idct1_add;\n        c->idct      = ff_j_rev_dct1;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else {\n         if (avctx->bits_per_raw_sample == 10 || avctx->bits_per_raw_sample == 9) {\n             /* 10-bit MPEG-4 Simple Studio Profile requires a higher precision IDCT\n                However, it only uses idct_put */\n            if (c->mpeg4_studio_profile)\n                 c->idct_put              = ff_simple_idct_put_int32_10bit;\n             else {\n                 c->idct_put              = ff_simple_idct_put_int16_10bit;\n                c->idct_add              = ff_simple_idct_add_int16_10bit;\n                c->idct                  = ff_simple_idct_int16_10bit;\n            }\n            c->perm_type             = FF_IDCT_PERM_NONE;\n        } else if (avctx->bits_per_raw_sample == 12) {\n            c->idct_put              = ff_simple_idct_put_int16_12bit;\n            c->idct_add              = ff_simple_idct_add_int16_12bit;\n            c->idct                  = ff_simple_idct_int16_12bit;\n            c->perm_type             = FF_IDCT_PERM_NONE;\n        } else {\n            if (avctx->idct_algo == FF_IDCT_INT) {\n                c->idct_put  = ff_jref_idct_put;\n                c->idct_add  = ff_jref_idct_add;\n                c->idct      = ff_j_rev_dct;\n                c->perm_type = FF_IDCT_PERM_LIBMPEG2;\n#if CONFIG_FAANIDCT\n            } else if (avctx->idct_algo == FF_IDCT_FAAN) {\n                c->idct_put  = ff_faanidct_put;\n                c->idct_add  = ff_faanidct_add;\n                c->idct      = ff_faanidct;\n                c->perm_type = FF_IDCT_PERM_NONE;\n#endif /* CONFIG_FAANIDCT */\n            } else { // accurate/default\n                /* Be sure FF_IDCT_NONE will select this one, since it uses FF_IDCT_PERM_NONE */\n                c->idct_put  = ff_simple_idct_put_int16_8bit;\n                c->idct_add  = ff_simple_idct_add_int16_8bit;\n                c->idct      = ff_simple_idct_int16_8bit;\n                c->perm_type = FF_IDCT_PERM_NONE;\n            }\n        }\n    }\n\n    c->put_pixels_clamped        = ff_put_pixels_clamped_c;\n    c->put_signed_pixels_clamped = put_signed_pixels_clamped_c;\n    c->add_pixels_clamped        = ff_add_pixels_clamped_c;\n\n    if (CONFIG_MPEG4_DECODER && avctx->idct_algo == FF_IDCT_XVID)\n        ff_xvid_idct_init(c, avctx);\n\n    if (ARCH_AARCH64)\n        ff_idctdsp_init_aarch64(c, avctx, high_bit_depth);\n    if (ARCH_ALPHA)\n        ff_idctdsp_init_alpha(c, avctx, high_bit_depth);\n    if (ARCH_ARM)\n        ff_idctdsp_init_arm(c, avctx, high_bit_depth);\n    if (ARCH_PPC)\n        ff_idctdsp_init_ppc(c, avctx, high_bit_depth);\n    if (ARCH_X86)\n        ff_idctdsp_init_x86(c, avctx, high_bit_depth);\n    if (ARCH_MIPS)\n        ff_idctdsp_init_mips(c, avctx, high_bit_depth);\n\n    ff_init_scantable_permutation(c->idct_permutation,\n                                  c->perm_type);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142992,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " av_cold void ff_mpv_idct_init(MpegEncContext *s)\n {\n     ff_idctdsp_init(&s->idsp, s->avctx);\n \n     /* load & permutate scantables\n     * note: only wmv uses different ones\n     */\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);\n    }\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142993,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " av_cold void ff_mpv_idct_init(MpegEncContext *s)\n {\n    if (s->codec_id == AV_CODEC_ID_MPEG4)\n        s->idsp.mpeg4_studio_profile = s->studio_profile;\n     ff_idctdsp_init(&s->idsp, s->avctx);\n \n     /* load & permutate scantables\n     * note: only wmv uses different ones\n     */\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);\n    }\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142994,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " mrb_class_real(struct RClass* cl)\n {\n  if (cl == 0)\n    return NULL;\n   while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n     cl = cl->super;\n   }\n   return cl;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142999,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " mrb_class_real(struct RClass* cl)\n {\n  if (cl == 0) return NULL;\n   while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n     cl = cl->super;\n    if (cl == 0) return NULL;\n   }\n   return cl;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143000,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "mrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n\n  if (mrb_immediate_p(self)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't clone %S\", self);\n  }\n  if (mrb_type(self) == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n   mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n   clone = mrb_obj_value(p);\n   init_copy(mrb, clone, self);\n  p->flags = mrb_obj_ptr(self)->flags;\n \n   return clone;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143003,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "mrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n\n  if (mrb_immediate_p(self)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't clone %S\", self);\n  }\n  if (mrb_type(self) == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n   mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n   clone = mrb_obj_value(p);\n   init_copy(mrb, clone, self);\n  p->flags |= mrb_obj_ptr(self)->flags & MRB_FLAG_IS_FROZEN;\n \n   return clone;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143004,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void _jsvTrace(JsVar *var, int indent, JsVar *baseVar, int level) {\n#ifdef SAVE_ON_FLASH\n  jsiConsolePrint(\"Trace unimplemented in this version.\\n\");\n#else\n  int i;\n  for (i=0;i<indent;i++) jsiConsolePrint(\" \");\n\n  if (!var) {\n    jsiConsolePrint(\"undefined\");\n    return;\n  }\n\n  jsvTraceLockInfo(var);\n\n  int lowestLevel = _jsvTraceGetLowestLevel(baseVar, var);\n  if (lowestLevel < level) {\n    jsiConsolePrint(\"...\\n\");\n    return;\n  }\n\n  if (jsvIsName(var)) jsiConsolePrint(\"Name \");\n\n  char endBracket = ' ';\n  if (jsvIsObject(var)) { jsiConsolePrint(\"Object { \"); endBracket = '}'; }\n  else if (jsvIsArray(var)) { jsiConsolePrintf(\"Array(%d) [ \", var->varData.integer); endBracket = ']'; }\n  else if (jsvIsNativeFunction(var)) { jsiConsolePrintf(\"NativeFunction 0x%x (%d) { \", var->varData.native.ptr, var->varData.native.argTypes); endBracket = '}'; }\n  else if (jsvIsFunction(var)) {\n    jsiConsolePrint(\"Function { \");\n    if (jsvIsFunctionReturn(var)) jsiConsolePrint(\"return \");\n    endBracket = '}';\n  } else if (jsvIsPin(var)) jsiConsolePrintf(\"Pin %d\", jsvGetInteger(var));\n  else if (jsvIsInt(var)) jsiConsolePrintf(\"Integer %d\", jsvGetInteger(var));\n  else if (jsvIsBoolean(var)) jsiConsolePrintf(\"Bool %s\", jsvGetBool(var)?\"true\":\"false\");\n   else if (jsvIsFloat(var)) jsiConsolePrintf(\"Double %f\", jsvGetFloat(var));\n   else if (jsvIsFunctionParameter(var)) jsiConsolePrintf(\"Param %q \", var);\n   else if (jsvIsArrayBufferName(var)) jsiConsolePrintf(\"ArrayBufferName[%d] \", jsvGetInteger(var));\n  else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(\"%s \", jswGetBasicObjectName(var)); // way to get nice name\n   else if (jsvIsString(var)) {\n     size_t blocks = 1;\n     if (jsvGetLastChild(var)) {\n      JsVar *v = jsvLock(jsvGetLastChild(var));\n      blocks += jsvCountJsVarsUsed(v);\n      jsvUnLock(v);\n    }\n    if (jsvIsFlatString(var)) {\n      blocks += jsvGetFlatStringBlocks(var);\n    }\n    jsiConsolePrintf(\"%sString [%d blocks] %q\", jsvIsFlatString(var)?\"Flat\":(jsvIsNativeString(var)?\"Native\":\"\"), blocks, var);\n  } else {\n    jsiConsolePrintf(\"Unknown %d\", var->flags & (JsVarFlags)~(JSV_LOCK_MASK));\n  }\n\n  if (jsvIsNameInt(var)) {\n    jsiConsolePrintf(\"= int %d\\n\", (int)jsvGetFirstChildSigned(var));\n    return;\n  } else if (jsvIsNameIntBool(var)) {\n    jsiConsolePrintf(\"= bool %s\\n\", jsvGetFirstChild(var)?\"true\":\"false\");\n    return;\n  }\n\n  if (jsvHasSingleChild(var)) {\n    JsVar *child = jsvGetFirstChild(var) ? jsvLock(jsvGetFirstChild(var)) : 0;\n    _jsvTrace(child, indent+2, baseVar, level+1);\n    jsvUnLock(child);\n  } else if (jsvHasChildren(var)) {\n    JsvIterator it;\n    jsvIteratorNew(&it, var, JSIF_DEFINED_ARRAY_ElEMENTS);\n    bool first = true;\n    while (jsvIteratorHasElement(&it) && !jspIsInterrupted()) {\n      if (first) jsiConsolePrintf(\"\\n\");\n      first = false;\n      JsVar *child = jsvIteratorGetKey(&it);\n      _jsvTrace(child, indent+2, baseVar, level+1);\n      jsvUnLock(child);\n      jsiConsolePrintf(\"\\n\");\n      jsvIteratorNext(&it);\n    }\n    jsvIteratorFree(&it);\n    if (!first)\n      for (i=0;i<indent;i++) jsiConsolePrint(\" \");\n  }\n  jsiConsolePrintf(\"%c\", endBracket);\n#endif\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143013,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void _jsvTrace(JsVar *var, int indent, JsVar *baseVar, int level) {\n#ifdef SAVE_ON_FLASH\n  jsiConsolePrint(\"Trace unimplemented in this version.\\n\");\n#else\n  int i;\n  for (i=0;i<indent;i++) jsiConsolePrint(\" \");\n\n  if (!var) {\n    jsiConsolePrint(\"undefined\");\n    return;\n  }\n\n  jsvTraceLockInfo(var);\n\n  int lowestLevel = _jsvTraceGetLowestLevel(baseVar, var);\n  if (lowestLevel < level) {\n    jsiConsolePrint(\"...\\n\");\n    return;\n  }\n\n  if (jsvIsName(var)) jsiConsolePrint(\"Name \");\n\n  char endBracket = ' ';\n  if (jsvIsObject(var)) { jsiConsolePrint(\"Object { \"); endBracket = '}'; }\n  else if (jsvIsArray(var)) { jsiConsolePrintf(\"Array(%d) [ \", var->varData.integer); endBracket = ']'; }\n  else if (jsvIsNativeFunction(var)) { jsiConsolePrintf(\"NativeFunction 0x%x (%d) { \", var->varData.native.ptr, var->varData.native.argTypes); endBracket = '}'; }\n  else if (jsvIsFunction(var)) {\n    jsiConsolePrint(\"Function { \");\n    if (jsvIsFunctionReturn(var)) jsiConsolePrint(\"return \");\n    endBracket = '}';\n  } else if (jsvIsPin(var)) jsiConsolePrintf(\"Pin %d\", jsvGetInteger(var));\n  else if (jsvIsInt(var)) jsiConsolePrintf(\"Integer %d\", jsvGetInteger(var));\n  else if (jsvIsBoolean(var)) jsiConsolePrintf(\"Bool %s\", jsvGetBool(var)?\"true\":\"false\");\n   else if (jsvIsFloat(var)) jsiConsolePrintf(\"Double %f\", jsvGetFloat(var));\n   else if (jsvIsFunctionParameter(var)) jsiConsolePrintf(\"Param %q \", var);\n   else if (jsvIsArrayBufferName(var)) jsiConsolePrintf(\"ArrayBufferName[%d] \", jsvGetInteger(var));\n  else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(\"%s \", jswGetBasicObjectName(var)?jswGetBasicObjectName(var):\"unknown ArrayBuffer\"); // way to get nice name\n   else if (jsvIsString(var)) {\n     size_t blocks = 1;\n     if (jsvGetLastChild(var)) {\n      JsVar *v = jsvLock(jsvGetLastChild(var));\n      blocks += jsvCountJsVarsUsed(v);\n      jsvUnLock(v);\n    }\n    if (jsvIsFlatString(var)) {\n      blocks += jsvGetFlatStringBlocks(var);\n    }\n    jsiConsolePrintf(\"%sString [%d blocks] %q\", jsvIsFlatString(var)?\"Flat\":(jsvIsNativeString(var)?\"Native\":\"\"), blocks, var);\n  } else {\n    jsiConsolePrintf(\"Unknown %d\", var->flags & (JsVarFlags)~(JSV_LOCK_MASK));\n  }\n\n  if (jsvIsNameInt(var)) {\n    jsiConsolePrintf(\"= int %d\\n\", (int)jsvGetFirstChildSigned(var));\n    return;\n  } else if (jsvIsNameIntBool(var)) {\n    jsiConsolePrintf(\"= bool %s\\n\", jsvGetFirstChild(var)?\"true\":\"false\");\n    return;\n  }\n\n  if (jsvHasSingleChild(var)) {\n    JsVar *child = jsvGetFirstChild(var) ? jsvLock(jsvGetFirstChild(var)) : 0;\n    _jsvTrace(child, indent+2, baseVar, level+1);\n    jsvUnLock(child);\n  } else if (jsvHasChildren(var)) {\n    JsvIterator it;\n    jsvIteratorNew(&it, var, JSIF_DEFINED_ARRAY_ElEMENTS);\n    bool first = true;\n    while (jsvIteratorHasElement(&it) && !jspIsInterrupted()) {\n      if (first) jsiConsolePrintf(\"\\n\");\n      first = false;\n      JsVar *child = jsvIteratorGetKey(&it);\n      _jsvTrace(child, indent+2, baseVar, level+1);\n      jsvUnLock(child);\n      jsiConsolePrintf(\"\\n\");\n      jsvIteratorNext(&it);\n    }\n    jsvIteratorFree(&it);\n    if (!first)\n      for (i=0;i<indent;i++) jsiConsolePrint(\" \");\n  }\n  jsiConsolePrintf(\"%c\", endBracket);\n#endif\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143014,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int hi3660_stub_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tunsigned int i;\n\tint ret;\n\n\t/* Use mailbox client without blocking */\n\tstub_clk_chan.cl.dev = dev;\n\tstub_clk_chan.cl.tx_done = NULL;\n\tstub_clk_chan.cl.tx_block = false;\n\tstub_clk_chan.cl.knows_txdone = false;\n\n\t/* Allocate mailbox channel */\n\tstub_clk_chan.mbox = mbox_request_channel(&stub_clk_chan.cl, 0);\n\tif (IS_ERR(stub_clk_chan.mbox))\n \t\treturn PTR_ERR(stub_clk_chan.mbox);\n \n \tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n \tfreq_reg = devm_ioremap(dev, res->start, resource_size(res));\n \tif (!freq_reg)\n \t\treturn -ENOMEM;\n\n\tfreq_reg += HI3660_STUB_CLOCK_DATA;\n\n\tfor (i = 0; i < HI3660_CLK_STUB_NUM; i++) {\n\t\tret = devm_clk_hw_register(&pdev->dev, &hi3660_stub_clks[i].hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, hi3660_stub_clk_hw_get,\n\t\t\t\t\t   hi3660_stub_clks);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143045,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int hi3660_stub_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tunsigned int i;\n\tint ret;\n\n\t/* Use mailbox client without blocking */\n\tstub_clk_chan.cl.dev = dev;\n\tstub_clk_chan.cl.tx_done = NULL;\n\tstub_clk_chan.cl.tx_block = false;\n\tstub_clk_chan.cl.knows_txdone = false;\n\n\t/* Allocate mailbox channel */\n\tstub_clk_chan.mbox = mbox_request_channel(&stub_clk_chan.cl, 0);\n\tif (IS_ERR(stub_clk_chan.mbox))\n \t\treturn PTR_ERR(stub_clk_chan.mbox);\n \n \tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n \tfreq_reg = devm_ioremap(dev, res->start, resource_size(res));\n \tif (!freq_reg)\n \t\treturn -ENOMEM;\n\n\tfreq_reg += HI3660_STUB_CLOCK_DATA;\n\n\tfor (i = 0; i < HI3660_CLK_STUB_NUM; i++) {\n\t\tret = devm_clk_hw_register(&pdev->dev, &hi3660_stub_clks[i].hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, hi3660_stub_clk_hw_get,\n\t\t\t\t\t   hi3660_stub_clks);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143046,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int unimac_mdio_probe(struct platform_device *pdev)\n{\n\tstruct unimac_mdio_pdata *pdata = pdev->dev.platform_data;\n\tstruct unimac_mdio_priv *priv;\n\tstruct device_node *np;\n\tstruct mii_bus *bus;\n\tstruct resource *r;\n\tint ret;\n\n\tnp = pdev->dev.of_node;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n \t\treturn -ENOMEM;\n \n \tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n \n \t/* Just ioremap, as this MDIO block is usually integrated into an\n \t * Ethernet MAC controller register range\n\t */\n\tpriv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!priv->base) {\n\t\tdev_err(&pdev->dev, \"failed to remap register\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->mii_bus = mdiobus_alloc();\n\tif (!priv->mii_bus)\n\t\treturn -ENOMEM;\n\n\tbus = priv->mii_bus;\n\tbus->priv = priv;\n\tif (pdata) {\n\t\tbus->name = pdata->bus_name;\n\t\tpriv->wait_func = pdata->wait_func;\n\t\tpriv->wait_func_data = pdata->wait_func_data;\n\t\tbus->phy_mask = ~pdata->phy_mask;\n\t} else {\n\t\tbus->name = \"unimac MII bus\";\n\t\tpriv->wait_func_data = priv;\n\t\tpriv->wait_func = unimac_mdio_poll;\n\t}\n\tbus->parent = &pdev->dev;\n\tbus->read = unimac_mdio_read;\n\tbus->write = unimac_mdio_write;\n\tbus->reset = unimac_mdio_reset;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-%d\", pdev->name, pdev->id);\n\n\tret = of_mdiobus_register(bus, np);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"MDIO bus registration failed\\n\");\n\t\tgoto out_mdio_free;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tdev_info(&pdev->dev, \"Broadcom UniMAC MDIO bus at 0x%p\\n\", priv->base);\n\n\treturn 0;\n\nout_mdio_free:\n\tmdiobus_free(bus);\n\treturn ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143067,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int unimac_mdio_probe(struct platform_device *pdev)\n{\n\tstruct unimac_mdio_pdata *pdata = pdev->dev.platform_data;\n\tstruct unimac_mdio_priv *priv;\n\tstruct device_node *np;\n\tstruct mii_bus *bus;\n\tstruct resource *r;\n\tint ret;\n\n\tnp = pdev->dev.of_node;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n \t\treturn -ENOMEM;\n \n \tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r)\n\t\treturn -EINVAL;\n \n \t/* Just ioremap, as this MDIO block is usually integrated into an\n \t * Ethernet MAC controller register range\n\t */\n\tpriv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!priv->base) {\n\t\tdev_err(&pdev->dev, \"failed to remap register\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->mii_bus = mdiobus_alloc();\n\tif (!priv->mii_bus)\n\t\treturn -ENOMEM;\n\n\tbus = priv->mii_bus;\n\tbus->priv = priv;\n\tif (pdata) {\n\t\tbus->name = pdata->bus_name;\n\t\tpriv->wait_func = pdata->wait_func;\n\t\tpriv->wait_func_data = pdata->wait_func_data;\n\t\tbus->phy_mask = ~pdata->phy_mask;\n\t} else {\n\t\tbus->name = \"unimac MII bus\";\n\t\tpriv->wait_func_data = priv;\n\t\tpriv->wait_func = unimac_mdio_poll;\n\t}\n\tbus->parent = &pdev->dev;\n\tbus->read = unimac_mdio_read;\n\tbus->write = unimac_mdio_write;\n\tbus->reset = unimac_mdio_reset;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-%d\", pdev->name, pdev->id);\n\n\tret = of_mdiobus_register(bus, np);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"MDIO bus registration failed\\n\");\n\t\tgoto out_mdio_free;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tdev_info(&pdev->dev, \"Broadcom UniMAC MDIO bus at 0x%p\\n\", priv->base);\n\n\treturn 0;\n\nout_mdio_free:\n\tmdiobus_free(bus);\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143068,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (buf->currentLine == NULL ||\n\t    spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n \trows = form->rows ? form->rows : 1;\n \tcol = COLPOS(l, a->start.pos);\n \tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n \t    if (rows > 1) {\n \t\tpos = columnPos(l, col);\n \t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len ||\n\t\tspos < 0 || epos < 0 || COLPOS(l, epos) < col)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143087,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (buf->currentLine == NULL ||\n\t    spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n \trows = form->rows ? form->rows : 1;\n \tcol = COLPOS(l, a->start.pos);\n \tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n\t    if (l == NULL)\n\t\tbreak;\n \t    if (rows > 1) {\n \t\tpos = columnPos(l, col);\n \t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len ||\n\t\tspos < 0 || epos < 0 || COLPOS(l, epos) < col)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143088,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "ipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO))\n \t\t\t\tjumpstack[stackidx++] = e;\n \n \t\t\te = get_entry(table_base, v);\n \t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143097,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "ipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n \t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n \n \t\t\te = get_entry(table_base, v);\n \t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143098,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "unsigned int arpt_do_table(struct sk_buff *skb,\n\t\t\t   const struct nf_hook_state *state,\n\t\t\t   struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tunsigned int verdict = NF_DROP;\n\tconst struct arphdr *arp;\n\tstruct arpt_entry *e, **jumpstack;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tunsigned int cpu, stackidx = 0;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\tif (!pskb_may_pull(skb, arp_hdr_len(skb->dev)))\n\t\treturn NF_DROP;\n\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu     = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct arpt_entry **)private->jumpstack[cpu];\n\n\t/* No TEE support for arptables, so no need to switch to alternate\n\t * stack.  All targets that reenter must return absolute verdicts.\n\t */\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tacpar.state   = state;\n\tacpar.hotdrop = false;\n\n\tarp = arp_hdr(skb);\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tstruct xt_counters *counter;\n\n\t\tif (!arp_packet_match(arp, skb->dev, indev, outdev, &e->arp)) {\n\t\t\te = arpt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, arp_hdr_len(skb->dev), 1);\n\n\t\tt = arpt_get_target_c(e);\n\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t\t      private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = arpt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif (table_base + v\n \t\t\t    != arpt_next_entry(e)) {\n \t\t\t\tjumpstack[stackidx++] = e;\n \t\t\t}\n \n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tarp = arp_hdr(skb);\n\t\t\te = arpt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse\n\t\treturn verdict;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143099,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "unsigned int arpt_do_table(struct sk_buff *skb,\n\t\t\t   const struct nf_hook_state *state,\n\t\t\t   struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tunsigned int verdict = NF_DROP;\n\tconst struct arphdr *arp;\n\tstruct arpt_entry *e, **jumpstack;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tunsigned int cpu, stackidx = 0;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\tif (!pskb_may_pull(skb, arp_hdr_len(skb->dev)))\n\t\treturn NF_DROP;\n\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu     = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct arpt_entry **)private->jumpstack[cpu];\n\n\t/* No TEE support for arptables, so no need to switch to alternate\n\t * stack.  All targets that reenter must return absolute verdicts.\n\t */\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tacpar.state   = state;\n\tacpar.hotdrop = false;\n\n\tarp = arp_hdr(skb);\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tstruct xt_counters *counter;\n\n\t\tif (!arp_packet_match(arp, skb->dev, indev, outdev, &e->arp)) {\n\t\t\te = arpt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, arp_hdr_len(skb->dev), 1);\n\n\t\tt = arpt_get_target_c(e);\n\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t\t      private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = arpt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif (table_base + v\n \t\t\t    != arpt_next_entry(e)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n \t\t\t\tjumpstack[stackidx++] = e;\n \t\t\t}\n \n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tarp = arp_hdr(skb);\n\t\t\te = arpt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse\n\t\treturn verdict;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143100,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "ip6t_do_table(struct sk_buff *skb,\n\t      const struct nf_hook_state *state,\n\t      struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ip6t_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ip6t_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tacpar.thoff = 0;\n\t\tif (!ip6_packet_match(skb, indev, outdev, &e->ipv6,\n\t\t    &acpar.thoff, &acpar.fragoff, &acpar.hotdrop)) {\n no_match:\n\t\t\te = ip6t_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ip6t_get_target_c(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0)\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\telse\n\t\t\t\t\te = ip6t_next_entry(jumpstack[--stackidx]);\n\t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif (table_base + v != ip6t_next_entry(e) &&\n \t\t\t    !(e->ipv6.flags & IP6T_F_GOTO)) {\n \t\t\t\tjumpstack[stackidx++] = e;\n \t\t\t}\n \n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE)\n\t\t\te = ip6t_next_entry(e);\n\t\telse\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143101,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "ip6t_do_table(struct sk_buff *skb,\n\t      const struct nf_hook_state *state,\n\t      struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ip6t_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ip6t_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tacpar.thoff = 0;\n\t\tif (!ip6_packet_match(skb, indev, outdev, &e->ipv6,\n\t\t    &acpar.thoff, &acpar.fragoff, &acpar.hotdrop)) {\n no_match:\n\t\t\te = ip6t_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ip6t_get_target_c(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0)\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\telse\n\t\t\t\t\te = ip6t_next_entry(jumpstack[--stackidx]);\n\t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif (table_base + v != ip6t_next_entry(e) &&\n \t\t\t    !(e->ipv6.flags & IP6T_F_GOTO)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n \t\t\t\tjumpstack[stackidx++] = e;\n \t\t\t}\n \n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE)\n\t\t\te = ip6t_next_entry(e);\n\t\telse\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143102,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int __init fm10k_init_module(void)\n{\n\tpr_info(\"%s - version %s\\n\", fm10k_driver_string, fm10k_driver_version);\n\tpr_info(\"%s\\n\", fm10k_copyright);\n\n \t/* create driver workqueue */\n \tfm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0,\n \t\t\t\t\t  fm10k_driver_name);\n \n \tfm10k_dbg_init();\n \n\treturn fm10k_register_pci_driver();\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143183,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int __init fm10k_init_module(void)\n{\n\tpr_info(\"%s - version %s\\n\", fm10k_driver_string, fm10k_driver_version);\n\tpr_info(\"%s\\n\", fm10k_copyright);\n\n \t/* create driver workqueue */\n \tfm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0,\n \t\t\t\t\t  fm10k_driver_name);\n\tif (!fm10k_workqueue)\n\t\treturn -ENOMEM;\n \n \tfm10k_dbg_init();\n \n\treturn fm10k_register_pci_driver();\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143184,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " static int nfc_llcp_build_gb(struct nfc_llcp_local *local)\n {\n\tu8 *gb_cur, *version_tlv, version, version_length;\n\tu8 *lto_tlv, lto_length;\n\tu8 *wks_tlv, wks_length;\n\tu8 *miux_tlv, miux_length;\n \t__be16 wks = cpu_to_be16(local->local_wks);\n \tu8 gb_len = 0;\n \tint ret = 0;\n \n \tversion = LLCP_VERSION_11;\n \tversion_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,\n \t\t\t\t\t 1, &version_length);\n \tgb_len += version_length;\n \n \tlto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);\n \tgb_len += lto_length;\n \n \tpr_debug(\"Local wks 0x%lx\\n\", local->local_wks);\n \twks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);\n \tgb_len += wks_length;\n \n \tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,\n \t\t\t\t      &miux_length);\n \tgb_len += miux_length;\n \n \tgb_len += ARRAY_SIZE(llcp_magic);\n\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tgb_cur = local->gb;\n\n\tmemcpy(gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic));\n\tgb_cur += ARRAY_SIZE(llcp_magic);\n\n\tmemcpy(gb_cur, version_tlv, version_length);\n\tgb_cur += version_length;\n\n\tmemcpy(gb_cur, lto_tlv, lto_length);\n\tgb_cur += lto_length;\n\n\tmemcpy(gb_cur, wks_tlv, wks_length);\n\tgb_cur += wks_length;\n\n\tmemcpy(gb_cur, miux_tlv, miux_length);\n\tgb_cur += miux_length;\n\n\tlocal->gb_len = gb_len;\n\nout:\n\tkfree(version_tlv);\n\tkfree(lto_tlv);\n\tkfree(wks_tlv);\n\tkfree(miux_tlv);\n\n\treturn ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143245,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " static int nfc_llcp_build_gb(struct nfc_llcp_local *local)\n {\n\tu8 *gb_cur, version, version_length;\n\tu8 lto_length, wks_length, miux_length;\n\tu8 *version_tlv = NULL, *lto_tlv = NULL,\n\t   *wks_tlv = NULL, *miux_tlv = NULL;\n \t__be16 wks = cpu_to_be16(local->local_wks);\n \tu8 gb_len = 0;\n \tint ret = 0;\n \n \tversion = LLCP_VERSION_11;\n \tversion_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,\n \t\t\t\t\t 1, &version_length);\n\tif (!version_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n \tgb_len += version_length;\n \n \tlto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);\n\tif (!lto_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n \tgb_len += lto_length;\n \n \tpr_debug(\"Local wks 0x%lx\\n\", local->local_wks);\n \twks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);\n\tif (!wks_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n \tgb_len += wks_length;\n \n \tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,\n \t\t\t\t      &miux_length);\n\tif (!miux_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n \tgb_len += miux_length;\n \n \tgb_len += ARRAY_SIZE(llcp_magic);\n\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tgb_cur = local->gb;\n\n\tmemcpy(gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic));\n\tgb_cur += ARRAY_SIZE(llcp_magic);\n\n\tmemcpy(gb_cur, version_tlv, version_length);\n\tgb_cur += version_length;\n\n\tmemcpy(gb_cur, lto_tlv, lto_length);\n\tgb_cur += lto_length;\n\n\tmemcpy(gb_cur, wks_tlv, wks_length);\n\tgb_cur += wks_length;\n\n\tmemcpy(gb_cur, miux_tlv, miux_length);\n\tgb_cur += miux_length;\n\n\tlocal->gb_len = gb_len;\n\nout:\n\tkfree(version_tlv);\n\tkfree(lto_tlv);\n\tkfree(wks_tlv);\n\tkfree(miux_tlv);\n\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143246,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " static void copyIPv6IfDifferent(void * dest, const void * src)\n {\n\tif(dest != src) {\n \t\tmemcpy(dest, src, sizeof(struct in6_addr));\n \t}\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143249,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " static void copyIPv6IfDifferent(void * dest, const void * src)\n {\n\tif(dest != src && src != NULL) {\n \t\tmemcpy(dest, src, sizeof(struct in6_addr));\n \t}\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143250,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "upnp_redirect(const char * rhost, unsigned short eport,\n              const char * iaddr, unsigned short iport,\n              const char * protocol, const char * desc,\n              unsigned int leaseduration)\n{\n\tint proto, r;\n\tchar iaddr_old[32];\n\tchar rhost_old[32];\n\tunsigned short iport_old;\n\tstruct in_addr address;\n\tunsigned int timestamp;\n\n\tproto = proto_atoi(protocol);\n\tif(inet_aton(iaddr, &address) <= 0) {\n\t\tsyslog(LOG_ERR, \"inet_aton(%s) FAILED\", iaddr);\n\t\treturn -1;\n\t}\n\n\tif(!check_upnp_rule_against_permissions(upnppermlist, num_upnpperm,\n\t                                        eport, address, iport)) {\n\t\tsyslog(LOG_INFO, \"redirection permission check failed for \"\n \t\t                 \"%hu->%s:%hu %s\", eport, iaddr, iport, protocol);\n \t\treturn -3;\n \t}\n \t/* IGDv1 (WANIPConnection:1 Service Template Version 1.01 / Nov 12, 2001)\n \t * - 2.2.20.PortMappingDescription :\n \t *  Overwriting Previous / Existing Port Mappings:\n\t * If the RemoteHost, ExternalPort, PortMappingProtocol and InternalClient\n\t * are exactly the same as an existing mapping, the existing mapping values\n\t * for InternalPort, PortMappingDescription, PortMappingEnabled and\n\t * PortMappingLeaseDuration are overwritten.\n\t *  Rejecting a New Port Mapping:\n\t * In cases where the RemoteHost, ExternalPort and PortMappingProtocol\n\t * are the same as an existing mapping, but the InternalClient is\n\t * different, the action is rejected with an appropriate error.\n\t *  Add or Reject New Port Mapping behavior based on vendor implementation:\n\t * In cases where the ExternalPort, PortMappingProtocol and InternalClient\n\t * are the same, but RemoteHost is different, the vendor can choose to\n\t * support both mappings simultaneously, or reject the second mapping\n\t * with an appropriate error.\n\t *\n\t * - 2.4.16.AddPortMapping\n\t * This action creates a new port mapping or overwrites an existing\n\t * mapping with the same internal client. If the ExternalPort and\n\t * PortMappingProtocol pair is already mapped to another internal client,\n\t * an error is returned.\n\t *\n\t * IGDv2 (WANIPConnection:2 Service Standardized DCP (SDCP) Sep 10, 2010)\n\t * Protocol ExternalPort RemoteHost InternalClient Result\n\t *     =         =           \u2260           \u2260         Failure\n\t *     =         =           \u2260           =         Failure or success\n\t *                                                 (vendor specific)\n\t *     =         =           =           \u2260         Failure\n\t *     =         =           =           =         Success (overwrite)\n\t */\n\trhost_old[0] = '\\0';\n\tr = get_redirect_rule(ext_if_name, eport, proto,\n\t                      iaddr_old, sizeof(iaddr_old), &iport_old, 0, 0,\n\t                      rhost_old, sizeof(rhost_old),\n\t                      &timestamp, 0, 0);\n\tif(r == 0) {\n\t\tif(strcmp(iaddr, iaddr_old)==0 &&\n\t\t   ((rhost == NULL && rhost_old[0]=='\\0') ||\n\t\t    (rhost && (strcmp(rhost, \"*\") == 0) && rhost_old[0]=='\\0') ||\n\t\t    (rhost && (strcmp(rhost, rhost_old) == 0)))) {\n\t\t\tsyslog(LOG_INFO, \"updating existing port mapping %hu %s (rhost '%s') => %s:%hu\",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\ttimestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;\n\t\t\tif(iport != iport_old) {\n\t\t\t\tr = update_portmapping(ext_if_name, eport, proto, iport, desc, timestamp);\n\t\t\t} else {\n\t\t\t\tr = update_portmapping_desc_timestamp(ext_if_name, eport, proto, desc, timestamp);\n\t\t\t}\n#ifdef ENABLE_LEASEFILE\n\t\t\tif(r == 0) {\n\t\t\t\tlease_file_remove(eport, proto);\n\t\t\t\tlease_file_add(eport, iaddr, iport, proto, desc, timestamp);\n\t\t\t}\n#endif /* ENABLE_LEASEFILE */\n\t\t\treturn r;\n\t\t} else {\n\t\t\tsyslog(LOG_INFO, \"port %hu %s (rhost '%s') already redirected to %s:%hu\",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\treturn -2;\n\t\t}\n#ifdef CHECK_PORTINUSE\n\t} else if (port_in_use(ext_if_name, eport, proto, iaddr, iport) > 0) {\n\t\tsyslog(LOG_INFO, \"port %hu protocol %s already in use\",\n\t\t       eport, protocol);\n\t\treturn -4;\n#endif /* CHECK_PORTINUSE */\n\t} else {\n\t\ttimestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;\n\t\tsyslog(LOG_INFO, \"redirecting port %hu to %s:%hu protocol %s for: %s\",\n\t\t\teport, iaddr, iport, protocol, desc);\n\t\treturn upnp_redirect_internal(rhost, eport, iaddr, iport, proto,\n\t\t                              desc, timestamp);\n\t}\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143251,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "upnp_redirect(const char * rhost, unsigned short eport,\n              const char * iaddr, unsigned short iport,\n              const char * protocol, const char * desc,\n              unsigned int leaseduration)\n{\n\tint proto, r;\n\tchar iaddr_old[32];\n\tchar rhost_old[32];\n\tunsigned short iport_old;\n\tstruct in_addr address;\n\tunsigned int timestamp;\n\n\tproto = proto_atoi(protocol);\n\tif(inet_aton(iaddr, &address) <= 0) {\n\t\tsyslog(LOG_ERR, \"inet_aton(%s) FAILED\", iaddr);\n\t\treturn -1;\n\t}\n\n\tif(!check_upnp_rule_against_permissions(upnppermlist, num_upnpperm,\n\t                                        eport, address, iport)) {\n\t\tsyslog(LOG_INFO, \"redirection permission check failed for \"\n \t\t                 \"%hu->%s:%hu %s\", eport, iaddr, iport, protocol);\n \t\treturn -3;\n \t}\n\n\tif (desc == NULL)\n\t\tdesc = \"\";\t/* assume empty description */\n\n \t/* IGDv1 (WANIPConnection:1 Service Template Version 1.01 / Nov 12, 2001)\n \t * - 2.2.20.PortMappingDescription :\n \t *  Overwriting Previous / Existing Port Mappings:\n\t * If the RemoteHost, ExternalPort, PortMappingProtocol and InternalClient\n\t * are exactly the same as an existing mapping, the existing mapping values\n\t * for InternalPort, PortMappingDescription, PortMappingEnabled and\n\t * PortMappingLeaseDuration are overwritten.\n\t *  Rejecting a New Port Mapping:\n\t * In cases where the RemoteHost, ExternalPort and PortMappingProtocol\n\t * are the same as an existing mapping, but the InternalClient is\n\t * different, the action is rejected with an appropriate error.\n\t *  Add or Reject New Port Mapping behavior based on vendor implementation:\n\t * In cases where the ExternalPort, PortMappingProtocol and InternalClient\n\t * are the same, but RemoteHost is different, the vendor can choose to\n\t * support both mappings simultaneously, or reject the second mapping\n\t * with an appropriate error.\n\t *\n\t * - 2.4.16.AddPortMapping\n\t * This action creates a new port mapping or overwrites an existing\n\t * mapping with the same internal client. If the ExternalPort and\n\t * PortMappingProtocol pair is already mapped to another internal client,\n\t * an error is returned.\n\t *\n\t * IGDv2 (WANIPConnection:2 Service Standardized DCP (SDCP) Sep 10, 2010)\n\t * Protocol ExternalPort RemoteHost InternalClient Result\n\t *     =         =           \u2260           \u2260         Failure\n\t *     =         =           \u2260           =         Failure or success\n\t *                                                 (vendor specific)\n\t *     =         =           =           \u2260         Failure\n\t *     =         =           =           =         Success (overwrite)\n\t */\n\trhost_old[0] = '\\0';\n\tr = get_redirect_rule(ext_if_name, eport, proto,\n\t                      iaddr_old, sizeof(iaddr_old), &iport_old, 0, 0,\n\t                      rhost_old, sizeof(rhost_old),\n\t                      &timestamp, 0, 0);\n\tif(r == 0) {\n\t\tif(strcmp(iaddr, iaddr_old)==0 &&\n\t\t   ((rhost == NULL && rhost_old[0]=='\\0') ||\n\t\t    (rhost && (strcmp(rhost, \"*\") == 0) && rhost_old[0]=='\\0') ||\n\t\t    (rhost && (strcmp(rhost, rhost_old) == 0)))) {\n\t\t\tsyslog(LOG_INFO, \"updating existing port mapping %hu %s (rhost '%s') => %s:%hu\",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\ttimestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;\n\t\t\tif(iport != iport_old) {\n\t\t\t\tr = update_portmapping(ext_if_name, eport, proto, iport, desc, timestamp);\n\t\t\t} else {\n\t\t\t\tr = update_portmapping_desc_timestamp(ext_if_name, eport, proto, desc, timestamp);\n\t\t\t}\n#ifdef ENABLE_LEASEFILE\n\t\t\tif(r == 0) {\n\t\t\t\tlease_file_remove(eport, proto);\n\t\t\t\tlease_file_add(eport, iaddr, iport, proto, desc, timestamp);\n\t\t\t}\n#endif /* ENABLE_LEASEFILE */\n\t\t\treturn r;\n\t\t} else {\n\t\t\tsyslog(LOG_INFO, \"port %hu %s (rhost '%s') already redirected to %s:%hu\",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\treturn -2;\n\t\t}\n#ifdef CHECK_PORTINUSE\n\t} else if (port_in_use(ext_if_name, eport, proto, iaddr, iport) > 0) {\n\t\tsyslog(LOG_INFO, \"port %hu protocol %s already in use\",\n\t\t       eport, protocol);\n\t\treturn -4;\n#endif /* CHECK_PORTINUSE */\n\t} else {\n\t\ttimestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;\n\t\tsyslog(LOG_INFO, \"redirecting port %hu to %s:%hu protocol %s for: %s\",\n\t\t\teport, iaddr, iport, protocol, desc);\n\t\treturn upnp_redirect_internal(rhost, eport, iaddr, iport, proto,\n\t\t                              desc, timestamp);\n\t}\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143252,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int megasas_alloc_cmds(struct megasas_instance *instance)\n{\n\tint i;\n\tint j;\n\tu16 max_cmd;\n\tstruct megasas_cmd *cmd;\n\n\tmax_cmd = instance->max_mfi_cmds;\n\n\t/*\n\t * instance->cmd_list is an array of struct megasas_cmd pointers.\n\t * Allocate the dynamic array first and then allocate individual\n\t * commands.\n\t */\n\tinstance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);\n\n\tif (!instance->cmd_list) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);\n\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tinstance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),\n\t\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!instance->cmd_list[i]) {\n\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tkfree(instance->cmd_list[j]);\n\n\t\t\tkfree(instance->cmd_list);\n\t\t\tinstance->cmd_list = NULL;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tmemset(cmd, 0, sizeof(struct megasas_cmd));\n\t\tcmd->index = i;\n\t\tcmd->scmd = NULL;\n\t\tcmd->instance = instance;\n\n\t\tlist_add_tail(&cmd->list, &instance->cmd_pool);\n\t}\n\n\t/*\n\t * Create a frame pool and assign one frame to each cmd\n\t */\n \tif (megasas_create_frame_pool(instance)) {\n \t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error creating frame DMA pool\\n\");\n \t\tmegasas_free_cmds(instance);\n \t}\n \n \treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143265,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int megasas_alloc_cmds(struct megasas_instance *instance)\n{\n\tint i;\n\tint j;\n\tu16 max_cmd;\n\tstruct megasas_cmd *cmd;\n\n\tmax_cmd = instance->max_mfi_cmds;\n\n\t/*\n\t * instance->cmd_list is an array of struct megasas_cmd pointers.\n\t * Allocate the dynamic array first and then allocate individual\n\t * commands.\n\t */\n\tinstance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);\n\n\tif (!instance->cmd_list) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);\n\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tinstance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),\n\t\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!instance->cmd_list[i]) {\n\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tkfree(instance->cmd_list[j]);\n\n\t\t\tkfree(instance->cmd_list);\n\t\t\tinstance->cmd_list = NULL;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tmemset(cmd, 0, sizeof(struct megasas_cmd));\n\t\tcmd->index = i;\n\t\tcmd->scmd = NULL;\n\t\tcmd->instance = instance;\n\n\t\tlist_add_tail(&cmd->list, &instance->cmd_pool);\n\t}\n\n\t/*\n\t * Create a frame pool and assign one frame to each cmd\n\t */\n \tif (megasas_create_frame_pool(instance)) {\n \t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error creating frame DMA pool\\n\");\n \t\tmegasas_free_cmds(instance);\n\t\treturn -ENOMEM;\n \t}\n \n \treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143266,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int dev_get_valid_name(struct net *net,\n\t\t\t      struct net_device *dev,\n\t\t\t      const char *name)\n {\n \tBUG_ON(!net);\n \n\tif (!dev_valid_name(name))\n\t\treturn -EINVAL;\n\n\tif (strchr(name, '%'))\n\t\treturn dev_alloc_name_ns(net, dev, name);\n\telse if (__dev_get_by_name(net, name))\n\t\treturn -EEXIST;\n\telse if (dev->name != name)\n\t\tstrlcpy(dev->name, name, IFNAMSIZ);\n \n \treturn 0;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143391,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int dev_get_valid_name(struct net *net,\nint dev_get_valid_name(struct net *net, struct net_device *dev,\n\t\t       const char *name)\n {\n \tBUG_ON(!net);\n \n\tif (!dev_valid_name(name))\n\t\treturn -EINVAL;\n\n\tif (strchr(name, '%'))\n\t\treturn dev_alloc_name_ns(net, dev, name);\n\telse if (__dev_get_by_name(net, name))\n\t\treturn -EEXIST;\n\telse if (dev->name != name)\n\t\tstrlcpy(dev->name, name, IFNAMSIZ);\n \n \treturn 0;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143392,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tchar *end = NULL;\n\tElf_(Shdr) *link_shdr = NULL;\n\tut8 dfs[sizeof (Elf_(Verdef))] = {0};\n\tSdb *sdb;\n\tint cnt, i;\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\treturn false;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif (shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {\n\t\treturn false;\n\t}\n\tElf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));\n\tif (!defs) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!defs) {\n\t\tbprintf (\"Warning: Cannot allocate memory (Check Elf_(Verdef))\\n\");\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tend = (char *)defs + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tfor (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && (end - (char *)defs > i); ++cnt) {\n\t\tSdb *sdb_verdef = sdb_new0 ();\n\t\tchar *vstart = ((char*)defs) + i;\n\t\tchar key[32] = {0};\n\t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;\n\t\tElf_(Verdaux) aux = {0};\n\t\tint j = 0;\n\t\tint isum = 0;\n\n\t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));\n\t\tverdef->vd_version = READ16 (dfs, j)\n\t\tverdef->vd_flags = READ16 (dfs, j)\n\t\tverdef->vd_ndx = READ16 (dfs, j)\n\t\tverdef->vd_cnt = READ16 (dfs, j)\n\t\tverdef->vd_hash = READ32 (dfs, j)\n \t\tverdef->vd_aux = READ32 (dfs, j)\n \t\tverdef->vd_next = READ32 (dfs, j)\n \t\tint vdaux = verdef->vd_aux;\n\t\tif (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) {\n \t\t\tsdb_free (sdb_verdef);\n \t\t\tgoto out_error;\n \t\t}\n\t\tvstart += vdaux;\n\t\tif (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tj = 0;\n\t\taux.vda_name = READ32 (vstart, j)\n\t\taux.vda_next = READ32 (vstart, j)\n\n\t\tisum = i + verdef->vd_aux;\n\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsdb_num_set (sdb_verdef, \"idx\", i, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_version\", verdef->vd_version, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_ndx\", verdef->vd_ndx, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_cnt\", verdef->vd_cnt, 0);\n\t\tsdb_set (sdb_verdef, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\tsdb_set (sdb_verdef, \"flags\", get_ver_flags (verdef->vd_flags), 0);\n\n\t\tfor (j = 1; j < verdef->vd_cnt; ++j) {\n\t\t\tint k;\n\t\t\tSdb *sdb_parent = sdb_new0 ();\n\t\t\tisum += aux.vda_next;\n\t\t\tvstart += aux.vda_next;\n\t\t\tif (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tk = 0;\n\t\t\taux.vda_name = READ32 (vstart, k)\n\t\t\taux.vda_next = READ32 (vstart, k)\n\t\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_parent, \"idx\", isum, 0);\n\t\t\tsdb_num_set (sdb_parent, \"parent\", j, 0);\n\t\t\tsdb_set (sdb_parent, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\t\tsnprintf (key, sizeof (key), \"parent%d\", j - 1);\n\t\t\tsdb_ns_set (sdb_verdef, key, sdb_parent);\n\t\t}\n\n\t\tsnprintf (key, sizeof (key), \"verdef%d\", cnt);\n\t\tsdb_ns_set (sdb, key, sdb_verdef);\n\t\tif (!verdef->vd_next) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif ((st32)verdef->vd_next < 1) {\n\t\t\teprintf (\"Warning: Invalid vd_next in the ELF version\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ti += verdef->vd_next;\n\t}\n\tfree (defs);\n\treturn sdb;\nout_error:\n\tfree (defs);\n\tsdb_free (sdb);\n\treturn NULL;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143443,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tchar *end = NULL;\n\tElf_(Shdr) *link_shdr = NULL;\n\tut8 dfs[sizeof (Elf_(Verdef))] = {0};\n\tSdb *sdb;\n\tint cnt, i;\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\treturn false;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif (shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {\n\t\treturn false;\n\t}\n\tElf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));\n\tif (!defs) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!defs) {\n\t\tbprintf (\"Warning: Cannot allocate memory (Check Elf_(Verdef))\\n\");\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tend = (char *)defs + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tfor (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && (end - (char *)defs > i); ++cnt) {\n\t\tSdb *sdb_verdef = sdb_new0 ();\n\t\tchar *vstart = ((char*)defs) + i;\n\t\tchar key[32] = {0};\n\t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;\n\t\tElf_(Verdaux) aux = {0};\n\t\tint j = 0;\n\t\tint isum = 0;\n\n\t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));\n\t\tverdef->vd_version = READ16 (dfs, j)\n\t\tverdef->vd_flags = READ16 (dfs, j)\n\t\tverdef->vd_ndx = READ16 (dfs, j)\n\t\tverdef->vd_cnt = READ16 (dfs, j)\n\t\tverdef->vd_hash = READ32 (dfs, j)\n \t\tverdef->vd_aux = READ32 (dfs, j)\n \t\tverdef->vd_next = READ32 (dfs, j)\n \t\tint vdaux = verdef->vd_aux;\n\t\tif (vdaux < 1 || vstart + vdaux < vstart) {\n \t\t\tsdb_free (sdb_verdef);\n \t\t\tgoto out_error;\n \t\t}\n\t\tvstart += vdaux;\n\t\tif (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tj = 0;\n\t\taux.vda_name = READ32 (vstart, j)\n\t\taux.vda_next = READ32 (vstart, j)\n\n\t\tisum = i + verdef->vd_aux;\n\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsdb_num_set (sdb_verdef, \"idx\", i, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_version\", verdef->vd_version, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_ndx\", verdef->vd_ndx, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_cnt\", verdef->vd_cnt, 0);\n\t\tsdb_set (sdb_verdef, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\tsdb_set (sdb_verdef, \"flags\", get_ver_flags (verdef->vd_flags), 0);\n\n\t\tfor (j = 1; j < verdef->vd_cnt; ++j) {\n\t\t\tint k;\n\t\t\tSdb *sdb_parent = sdb_new0 ();\n\t\t\tisum += aux.vda_next;\n\t\t\tvstart += aux.vda_next;\n\t\t\tif (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tk = 0;\n\t\t\taux.vda_name = READ32 (vstart, k)\n\t\t\taux.vda_next = READ32 (vstart, k)\n\t\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_parent, \"idx\", isum, 0);\n\t\t\tsdb_num_set (sdb_parent, \"parent\", j, 0);\n\t\t\tsdb_set (sdb_parent, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\t\tsnprintf (key, sizeof (key), \"parent%d\", j - 1);\n\t\t\tsdb_ns_set (sdb_verdef, key, sdb_parent);\n\t\t}\n\n\t\tsnprintf (key, sizeof (key), \"verdef%d\", cnt);\n\t\tsdb_ns_set (sdb, key, sdb_verdef);\n\t\tif (!verdef->vd_next) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif ((st32)verdef->vd_next < 1) {\n\t\t\teprintf (\"Warning: Invalid vd_next in the ELF version\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ti += verdef->vd_next;\n\t}\n\tfree (defs);\n\treturn sdb;\nout_error:\n\tfree (defs);\n\tsdb_free (sdb);\n\treturn NULL;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143444,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tchar *end = NULL;\n\tElf_(Shdr) *link_shdr = NULL;\n\tut8 dfs[sizeof (Elf_(Verdef))] = {0};\n\tSdb *sdb;\n\tint cnt, i;\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\treturn false;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif ((int)shdr->sh_size < 1) {\n\t\treturn false;\n\t}\n\tElf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));\n\tif (!defs) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!defs) {\n\t\tbprintf (\"Warning: Cannot allocate memory (Check Elf_(Verdef))\\n\");\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tend = (char *)defs + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n \tfor (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {\n \t\tSdb *sdb_verdef = sdb_new0 ();\n \t\tchar *vstart = ((char*)defs) + i;\n \t\tchar key[32] = {0};\n \t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;\n \t\tElf_(Verdaux) aux = {0};\n\t\tint j = 0;\n\t\tint isum = 0;\n\n\t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));\n\t\tverdef->vd_version = READ16 (dfs, j)\n\t\tverdef->vd_flags = READ16 (dfs, j)\n\t\tverdef->vd_ndx = READ16 (dfs, j)\n\t\tverdef->vd_cnt = READ16 (dfs, j)\n\t\tverdef->vd_hash = READ32 (dfs, j)\n \t\tverdef->vd_aux = READ32 (dfs, j)\n \t\tverdef->vd_next = READ32 (dfs, j)\n \t\tint vdaux = verdef->vd_aux;\n\t\tif (vdaux < 1 || vstart + vdaux < vstart) {\n \t\t\tsdb_free (sdb_verdef);\n \t\t\tgoto out_error;\n \t\t}\n \t\tvstart += vdaux;\n \t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n \t\t\tsdb_free (sdb_verdef);\n \t\t\tgoto out_error;\n\t\t}\n\n\t\tj = 0;\n\t\taux.vda_name = READ32 (vstart, j)\n\t\taux.vda_next = READ32 (vstart, j)\n\n\t\tisum = i + verdef->vd_aux;\n\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsdb_num_set (sdb_verdef, \"idx\", i, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_version\", verdef->vd_version, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_ndx\", verdef->vd_ndx, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_cnt\", verdef->vd_cnt, 0);\n\t\tsdb_set (sdb_verdef, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\tsdb_set (sdb_verdef, \"flags\", get_ver_flags (verdef->vd_flags), 0);\n\n\t\tfor (j = 1; j < verdef->vd_cnt; ++j) {\n\t\t\tint k;\n \t\t\tSdb *sdb_parent = sdb_new0 ();\n \t\t\tisum += aux.vda_next;\n \t\t\tvstart += aux.vda_next;\n \t\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n \t\t\t\tsdb_free (sdb_verdef);\n \t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tk = 0;\n\t\t\taux.vda_name = READ32 (vstart, k)\n\t\t\taux.vda_next = READ32 (vstart, k)\n\t\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_parent, \"idx\", isum, 0);\n\t\t\tsdb_num_set (sdb_parent, \"parent\", j, 0);\n\t\t\tsdb_set (sdb_parent, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\t\tsnprintf (key, sizeof (key), \"parent%d\", j - 1);\n\t\t\tsdb_ns_set (sdb_verdef, key, sdb_parent);\n\t\t}\n\n\t\tsnprintf (key, sizeof (key), \"verdef%d\", cnt);\n\t\tsdb_ns_set (sdb, key, sdb_verdef);\n\t\tif (!verdef->vd_next) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif ((st32)verdef->vd_next < 1) {\n\t\t\teprintf (\"Warning: Invalid vd_next in the ELF version\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ti += verdef->vd_next;\n\t}\n\tfree (defs);\n\treturn sdb;\nout_error:\n\tfree (defs);\n\tsdb_free (sdb);\n\treturn NULL;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143445,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tchar *end = NULL;\n\tElf_(Shdr) *link_shdr = NULL;\n\tut8 dfs[sizeof (Elf_(Verdef))] = {0};\n\tSdb *sdb;\n\tint cnt, i;\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\treturn false;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif ((int)shdr->sh_size < 1) {\n\t\treturn false;\n\t}\n\tElf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));\n\tif (!defs) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!defs) {\n\t\tbprintf (\"Warning: Cannot allocate memory (Check Elf_(Verdef))\\n\");\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tend = (char *)defs + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n \tfor (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {\n \t\tSdb *sdb_verdef = sdb_new0 ();\n \t\tchar *vstart = ((char*)defs) + i;\n\t\tsize_t vstart_off = i;\n \t\tchar key[32] = {0};\n \t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;\n \t\tElf_(Verdaux) aux = {0};\n\t\tint j = 0;\n\t\tint isum = 0;\n\n\t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));\n\t\tverdef->vd_version = READ16 (dfs, j)\n\t\tverdef->vd_flags = READ16 (dfs, j)\n\t\tverdef->vd_ndx = READ16 (dfs, j)\n\t\tverdef->vd_cnt = READ16 (dfs, j)\n\t\tverdef->vd_hash = READ32 (dfs, j)\n \t\tverdef->vd_aux = READ32 (dfs, j)\n \t\tverdef->vd_next = READ32 (dfs, j)\n \t\tint vdaux = verdef->vd_aux;\n\t\tif (vdaux < 1 || shdr->sh_size - vstart_off < vdaux) {\n \t\t\tsdb_free (sdb_verdef);\n \t\t\tgoto out_error;\n \t\t}\n \t\tvstart += vdaux;\n\t\tvstart_off += vdaux;\n \t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n \t\t\tsdb_free (sdb_verdef);\n \t\t\tgoto out_error;\n\t\t}\n\n\t\tj = 0;\n\t\taux.vda_name = READ32 (vstart, j)\n\t\taux.vda_next = READ32 (vstart, j)\n\n\t\tisum = i + verdef->vd_aux;\n\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsdb_num_set (sdb_verdef, \"idx\", i, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_version\", verdef->vd_version, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_ndx\", verdef->vd_ndx, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_cnt\", verdef->vd_cnt, 0);\n\t\tsdb_set (sdb_verdef, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\tsdb_set (sdb_verdef, \"flags\", get_ver_flags (verdef->vd_flags), 0);\n\n\t\tfor (j = 1; j < verdef->vd_cnt; ++j) {\n\t\t\tint k;\n \t\t\tSdb *sdb_parent = sdb_new0 ();\n \t\t\tisum += aux.vda_next;\n \t\t\tvstart += aux.vda_next;\n\t\t\tvstart_off += aux.vda_next;\n \t\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n \t\t\t\tsdb_free (sdb_verdef);\n \t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tk = 0;\n\t\t\taux.vda_name = READ32 (vstart, k)\n\t\t\taux.vda_next = READ32 (vstart, k)\n\t\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_parent, \"idx\", isum, 0);\n\t\t\tsdb_num_set (sdb_parent, \"parent\", j, 0);\n\t\t\tsdb_set (sdb_parent, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\t\tsnprintf (key, sizeof (key), \"parent%d\", j - 1);\n\t\t\tsdb_ns_set (sdb_verdef, key, sdb_parent);\n\t\t}\n\n\t\tsnprintf (key, sizeof (key), \"verdef%d\", cnt);\n\t\tsdb_ns_set (sdb, key, sdb_verdef);\n\t\tif (!verdef->vd_next) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif ((st32)verdef->vd_next < 1) {\n\t\t\teprintf (\"Warning: Invalid vd_next in the ELF version\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ti += verdef->vd_next;\n\t}\n\tfree (defs);\n\treturn sdb;\nout_error:\n\tfree (defs);\n\tsdb_free (sdb);\n\treturn NULL;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143446,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) /* EOF considered as end of frame */\n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                 dctx->w = (state >> 32) & 0xFFFF;\n             } else if (dctx->cur_byte == 42) {\n                 int cid = (state >> 32) & 0xFFFFFFFF;\n \n                 if (cid <= 0)\n                     continue;\n \n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (dctx->remaining <= 0) {\n                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (dctx->remaining <= 0)\n                        return dctx->remaining;\n                 }\n                 if (buf_size - i + 47 >= dctx->remaining) {\n                     int remaining = dctx->remaining;\n \n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    return END_NOT_FOUND;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143467,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) /* EOF considered as end of frame */\n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                 dctx->w = (state >> 32) & 0xFFFF;\n             } else if (dctx->cur_byte == 42) {\n                 int cid = (state >> 32) & 0xFFFFFFFF;\n                int remaining;\n \n                 if (cid <= 0)\n                     continue;\n \n                remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (remaining <= 0) {\n                    remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (remaining <= 0)\n                        continue;\n                 }\n                dctx->remaining = remaining;\n                 if (buf_size - i + 47 >= dctx->remaining) {\n                     int remaining = dctx->remaining;\n \n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    return END_NOT_FOUND;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143468,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\n\tif (reading_from_buf) {\n\t\t/* We had an existing partial packet, so add the new\n\t\t * packet to the buffer and parse the whole thing */\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\t/* Buffer the data when the inner packet is split\n\t\t\t * across multiple sideband packets */\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\n\t\t/* Advance in the buffer */\n \t\tline_len -= (line_end - line);\n \t\tline = line_end;\n \n\t\t/* When a valid packet with no content has been\n\t\t * read, git_pkt_parse_line does not report an\n\t\t * error, but the pkt pointer has not been set.\n\t\t * Handle this by skipping over empty packets.\n\t\t */\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n \t\terror = add_push_report_pkt(push, pkt);\n \n \t\tgit_pkt_free(pkt);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\terror = 0;\n\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143479,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\n\tif (reading_from_buf) {\n\t\t/* We had an existing partial packet, so add the new\n\t\t * packet to the buffer and parse the whole thing */\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\t/* Buffer the data when the inner packet is split\n\t\t\t * across multiple sideband packets */\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\n\t\t/* Advance in the buffer */\n \t\tline_len -= (line_end - line);\n \t\tline = line_end;\n \n \t\terror = add_push_report_pkt(push, pkt);\n \n \t\tgit_pkt_free(pkt);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\terror = 0;\n\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143480,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static bool check_client_passwd(PgSocket *client, const char *passwd)\n{\n\tchar md5[MD5_PASSWD_LEN + 1];\n \tconst char *correct;\n \tPgUser *user = client->auth_user;\n \n \t/* disallow empty passwords */\n \tif (!*passwd || !*user->passwd)\n \t\treturn false;\n\n\tswitch (cf_auth_type) {\n\tcase AUTH_PLAIN:\n\t\treturn strcmp(user->passwd, passwd) == 0;\n\tcase AUTH_CRYPT:\n\t\tcorrect = crypt(user->passwd, (char *)client->tmp_login_salt);\n\t\treturn correct && strcmp(correct, passwd) == 0;\n\tcase AUTH_MD5:\n\t\tif (strlen(passwd) != MD5_PASSWD_LEN)\n\t\t\treturn false;\n\t\tif (!isMD5(user->passwd))\n\t\t\tpg_md5_encrypt(user->passwd, user->name, strlen(user->name), user->passwd);\n\t\tpg_md5_encrypt(user->passwd + 3, (char *)client->tmp_login_salt, 4, md5);\n\t\treturn strcmp(md5, passwd) == 0;\n\t}\n\treturn false;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143493,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static bool check_client_passwd(PgSocket *client, const char *passwd)\n{\n\tchar md5[MD5_PASSWD_LEN + 1];\n \tconst char *correct;\n \tPgUser *user = client->auth_user;\n \n\t/* auth_user may be missing */\n\tif (!user) {\n\t\tslog_error(client, \"Password packet before auth packet?\");\n\t\treturn false;\n\t}\n\n \t/* disallow empty passwords */\n \tif (!*passwd || !*user->passwd)\n \t\treturn false;\n\n\tswitch (cf_auth_type) {\n\tcase AUTH_PLAIN:\n\t\treturn strcmp(user->passwd, passwd) == 0;\n\tcase AUTH_CRYPT:\n\t\tcorrect = crypt(user->passwd, (char *)client->tmp_login_salt);\n\t\treturn correct && strcmp(correct, passwd) == 0;\n\tcase AUTH_MD5:\n\t\tif (strlen(passwd) != MD5_PASSWD_LEN)\n\t\t\treturn false;\n\t\tif (!isMD5(user->passwd))\n\t\t\tpg_md5_encrypt(user->passwd, user->name, strlen(user->name), user->passwd);\n\t\tpg_md5_encrypt(user->passwd + 3, (char *)client->tmp_login_salt, 4, md5);\n\t\treturn strcmp(md5, passwd) == 0;\n\t}\n\treturn false;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143494,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n \trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n \tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n \n\tif (!int_port || !ext_port || !protocol)\n \t{\n \t\tClearNameValueList(&data);\n \t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\"*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143515,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n \trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n \tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n \n\tif (!int_port || !rem_port || !protocol)\n \t{\n \t\tClearNameValueList(&data);\n \t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\"*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143516,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)\n{\n\tstruct tun_struct *tun;\n\tstruct tun_file *tfile = file->private_data;\n\tstruct net_device *dev;\n\tint err;\n\n\tif (tfile->detached)\n\t\treturn -EINVAL;\n\n\tdev = __dev_get_by_name(net, ifr->ifr_name);\n\tif (dev) {\n\t\tif (ifr->ifr_flags & IFF_TUN_EXCL)\n\t\t\treturn -EBUSY;\n\t\tif ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tif (!!(ifr->ifr_flags & IFF_MULTI_QUEUE) !=\n\t\t    !!(tun->flags & IFF_MULTI_QUEUE))\n\t\t\treturn -EINVAL;\n\n\t\tif (tun_not_capable(tun))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_open(tun->security);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = tun_attach(tun, file, ifr->ifr_flags & IFF_NOFILTER);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (tun->flags & IFF_MULTI_QUEUE &&\n\t\t    (tun->numqueues + tun->numdisabled > 1)) {\n\t\t\t/* One or more queue has already been attached, no need\n\t\t\t * to initialize the device again.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse {\n\t\tchar *name;\n\t\tunsigned long flags = 0;\n\t\tint queues = ifr->ifr_flags & IFF_MULTI_QUEUE ?\n\t\t\t     MAX_TAP_QUEUES : 1;\n\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_create();\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t/* Set dev type */\n\t\tif (ifr->ifr_flags & IFF_TUN) {\n\t\t\t/* TUN device */\n\t\t\tflags |= IFF_TUN;\n\t\t\tname = \"tun%d\";\n\t\t} else if (ifr->ifr_flags & IFF_TAP) {\n\t\t\t/* TAP device */\n\t\t\tflags |= IFF_TAP;\n\t\t\tname = \"tap%d\";\n\t\t} else\n\t\t\treturn -EINVAL;\n\n\t\tif (*ifr->ifr_name)\n\t\t\tname = ifr->ifr_name;\n\n\t\tdev = alloc_netdev_mqs(sizeof(struct tun_struct), name,\n\t\t\t\t       NET_NAME_UNKNOWN, tun_setup, queues,\n\t\t\t\t       queues);\n\n \t\tif (!dev)\n \t\t\treturn -ENOMEM;\n \t\terr = dev_get_valid_name(net, dev, name);\n\t\tif (err)\n \t\t\tgoto err_free_dev;\n \n \t\tdev_net_set(dev, net);\n\t\tdev->rtnl_link_ops = &tun_link_ops;\n\t\tdev->ifindex = tfile->ifindex;\n\t\tdev->sysfs_groups[0] = &tun_attr_group;\n\n\t\ttun = netdev_priv(dev);\n\t\ttun->dev = dev;\n\t\ttun->flags = flags;\n\t\ttun->txflt.count = 0;\n\t\ttun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);\n\n\t\ttun->align = NET_SKB_PAD;\n\t\ttun->filter_attached = false;\n\t\ttun->sndbuf = tfile->socket.sk->sk_sndbuf;\n\t\ttun->rx_batched = 0;\n\n\t\ttun->pcpu_stats = netdev_alloc_pcpu_stats(struct tun_pcpu_stats);\n\t\tif (!tun->pcpu_stats) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_free_dev;\n\t\t}\n\n\t\tspin_lock_init(&tun->lock);\n\n\t\terr = security_tun_dev_alloc_security(&tun->security);\n\t\tif (err < 0)\n\t\t\tgoto err_free_stat;\n\n\t\ttun_net_init(dev);\n\t\ttun_flow_init(tun);\n\n\t\tdev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |\n\t\t\t\t   TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t   NETIF_F_HW_VLAN_STAG_TX;\n\t\tdev->features = dev->hw_features | NETIF_F_LLTX;\n\t\tdev->vlan_features = dev->features &\n\t\t\t\t     ~(NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t       NETIF_F_HW_VLAN_STAG_TX);\n\n\t\tINIT_LIST_HEAD(&tun->disabled);\n\t\terr = tun_attach(tun, file, false);\n\t\tif (err < 0)\n\t\t\tgoto err_free_flow;\n\n\t\terr = register_netdevice(tun->dev);\n\t\tif (err < 0)\n\t\t\tgoto err_detach;\n\t}\n\n\tnetif_carrier_on(tun->dev);\n\n\ttun_debug(KERN_INFO, tun, \"tun_set_iff\\n\");\n\n\ttun->flags = (tun->flags & ~TUN_FEATURES) |\n\t\t(ifr->ifr_flags & TUN_FEATURES);\n\n\t/* Make sure persistent devices do not get stuck in\n\t * xoff state.\n\t */\n\tif (netif_running(tun->dev))\n\t\tnetif_tx_wake_all_queues(tun->dev);\n\n\tstrcpy(ifr->ifr_name, tun->dev->name);\n\treturn 0;\n\nerr_detach:\n\ttun_detach_all(dev);\n\t/* register_netdevice() already called tun_free_netdev() */\n\tgoto err_free_dev;\n\nerr_free_flow:\n\ttun_flow_uninit(tun);\n\tsecurity_tun_dev_free_security(tun->security);\nerr_free_stat:\n\tfree_percpu(tun->pcpu_stats);\nerr_free_dev:\n\tfree_netdev(dev);\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143521,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)\n{\n\tstruct tun_struct *tun;\n\tstruct tun_file *tfile = file->private_data;\n\tstruct net_device *dev;\n\tint err;\n\n\tif (tfile->detached)\n\t\treturn -EINVAL;\n\n\tdev = __dev_get_by_name(net, ifr->ifr_name);\n\tif (dev) {\n\t\tif (ifr->ifr_flags & IFF_TUN_EXCL)\n\t\t\treturn -EBUSY;\n\t\tif ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tif (!!(ifr->ifr_flags & IFF_MULTI_QUEUE) !=\n\t\t    !!(tun->flags & IFF_MULTI_QUEUE))\n\t\t\treturn -EINVAL;\n\n\t\tif (tun_not_capable(tun))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_open(tun->security);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = tun_attach(tun, file, ifr->ifr_flags & IFF_NOFILTER);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (tun->flags & IFF_MULTI_QUEUE &&\n\t\t    (tun->numqueues + tun->numdisabled > 1)) {\n\t\t\t/* One or more queue has already been attached, no need\n\t\t\t * to initialize the device again.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse {\n\t\tchar *name;\n\t\tunsigned long flags = 0;\n\t\tint queues = ifr->ifr_flags & IFF_MULTI_QUEUE ?\n\t\t\t     MAX_TAP_QUEUES : 1;\n\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_create();\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t/* Set dev type */\n\t\tif (ifr->ifr_flags & IFF_TUN) {\n\t\t\t/* TUN device */\n\t\t\tflags |= IFF_TUN;\n\t\t\tname = \"tun%d\";\n\t\t} else if (ifr->ifr_flags & IFF_TAP) {\n\t\t\t/* TAP device */\n\t\t\tflags |= IFF_TAP;\n\t\t\tname = \"tap%d\";\n\t\t} else\n\t\t\treturn -EINVAL;\n\n\t\tif (*ifr->ifr_name)\n\t\t\tname = ifr->ifr_name;\n\n\t\tdev = alloc_netdev_mqs(sizeof(struct tun_struct), name,\n\t\t\t\t       NET_NAME_UNKNOWN, tun_setup, queues,\n\t\t\t\t       queues);\n\n \t\tif (!dev)\n \t\t\treturn -ENOMEM;\n \t\terr = dev_get_valid_name(net, dev, name);\n\t\tif (err < 0)\n \t\t\tgoto err_free_dev;\n \n \t\tdev_net_set(dev, net);\n\t\tdev->rtnl_link_ops = &tun_link_ops;\n\t\tdev->ifindex = tfile->ifindex;\n\t\tdev->sysfs_groups[0] = &tun_attr_group;\n\n\t\ttun = netdev_priv(dev);\n\t\ttun->dev = dev;\n\t\ttun->flags = flags;\n\t\ttun->txflt.count = 0;\n\t\ttun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);\n\n\t\ttun->align = NET_SKB_PAD;\n\t\ttun->filter_attached = false;\n\t\ttun->sndbuf = tfile->socket.sk->sk_sndbuf;\n\t\ttun->rx_batched = 0;\n\n\t\ttun->pcpu_stats = netdev_alloc_pcpu_stats(struct tun_pcpu_stats);\n\t\tif (!tun->pcpu_stats) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_free_dev;\n\t\t}\n\n\t\tspin_lock_init(&tun->lock);\n\n\t\terr = security_tun_dev_alloc_security(&tun->security);\n\t\tif (err < 0)\n\t\t\tgoto err_free_stat;\n\n\t\ttun_net_init(dev);\n\t\ttun_flow_init(tun);\n\n\t\tdev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |\n\t\t\t\t   TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t   NETIF_F_HW_VLAN_STAG_TX;\n\t\tdev->features = dev->hw_features | NETIF_F_LLTX;\n\t\tdev->vlan_features = dev->features &\n\t\t\t\t     ~(NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t       NETIF_F_HW_VLAN_STAG_TX);\n\n\t\tINIT_LIST_HEAD(&tun->disabled);\n\t\terr = tun_attach(tun, file, false);\n\t\tif (err < 0)\n\t\t\tgoto err_free_flow;\n\n\t\terr = register_netdevice(tun->dev);\n\t\tif (err < 0)\n\t\t\tgoto err_detach;\n\t}\n\n\tnetif_carrier_on(tun->dev);\n\n\ttun_debug(KERN_INFO, tun, \"tun_set_iff\\n\");\n\n\ttun->flags = (tun->flags & ~TUN_FEATURES) |\n\t\t(ifr->ifr_flags & TUN_FEATURES);\n\n\t/* Make sure persistent devices do not get stuck in\n\t * xoff state.\n\t */\n\tif (netif_running(tun->dev))\n\t\tnetif_tx_wake_all_queues(tun->dev);\n\n\tstrcpy(ifr->ifr_name, tun->dev->name);\n\treturn 0;\n\nerr_detach:\n\ttun_detach_all(dev);\n\t/* register_netdevice() already called tun_free_netdev() */\n\tgoto err_free_dev;\n\nerr_free_flow:\n\ttun_flow_uninit(tun);\n\tsecurity_tun_dev_free_security(tun->security);\nerr_free_stat:\n\tfree_percpu(tun->pcpu_stats);\nerr_free_dev:\n\tfree_netdev(dev);\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143522,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " status_t HevcParameterSets::addNalUnit(const uint8_t* data, size_t size) {\n     uint8_t nalUnitType = (data[0] >> 1) & 0x3f;\n     status_t err = OK;\n     switch (nalUnitType) {\n         case 32:  // VPS\n             err = parseVps(data + 2, size - 2);\n             break;\n         case 33:  // SPS\n             err = parseSps(data + 2, size - 2);\n             break;\n         case 34:  // PPS\n             err = parsePps(data + 2, size - 2);\n             break;\n         case 39:  // Prefix SEI\n case 40: // Suffix SEI\n break;\n default:\n            ALOGE(\"Unrecognized NAL unit type.\");\n return ERROR_MALFORMED;\n }\n\n if (err != OK) {\n return err;\n }\n\n    sp<ABuffer> buffer = ABuffer::CreateAsCopy(data, size);\n    buffer->setInt32Data(nalUnitType);\n    mNalUnits.push(buffer);\n return OK;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143889,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " status_t HevcParameterSets::addNalUnit(const uint8_t* data, size_t size) {\n    if (size < 1) {\n        ALOGE(\"empty NAL b/35467107\");\n        return ERROR_MALFORMED;\n    }\n     uint8_t nalUnitType = (data[0] >> 1) & 0x3f;\n     status_t err = OK;\n     switch (nalUnitType) {\n         case 32:  // VPS\n            if (size < 2) {\n                ALOGE(\"invalid NAL/VPS size b/35467107\");\n                return ERROR_MALFORMED;\n            }\n             err = parseVps(data + 2, size - 2);\n             break;\n         case 33:  // SPS\n            if (size < 2) {\n                ALOGE(\"invalid NAL/SPS size b/35467107\");\n                return ERROR_MALFORMED;\n            }\n             err = parseSps(data + 2, size - 2);\n             break;\n         case 34:  // PPS\n            if (size < 2) {\n                ALOGE(\"invalid NAL/PPS size b/35467107\");\n                return ERROR_MALFORMED;\n            }\n             err = parsePps(data + 2, size - 2);\n             break;\n         case 39:  // Prefix SEI\n case 40: // Suffix SEI\n break;\n default:\n            ALOGE(\"Unrecognized NAL unit type.\");\n return ERROR_MALFORMED;\n }\n\n if (err != OK) {\n return err;\n }\n\n    sp<ABuffer> buffer = ABuffer::CreateAsCopy(data, size);\n    buffer->setInt32Data(nalUnitType);\n    mNalUnits.push(buffer);\n return OK;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143890,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "krb5_ldap_get_password_policy_from_dn(krb5_context context, char *pol_name,\n                                      char *pol_dn, osa_policy_ent_t *policy)\n{\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL,*ent=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    /* validate the input parameters */\n    if (pol_dn == NULL)\n        return EINVAL;\n\n    *policy = NULL;\n    SETUP_CONTEXT();\n    GET_HANDLE();\n\n    *(policy) = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));\n    if (*policy == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n    memset(*policy, 0, sizeof(osa_policy_ent_rec));\n\n     LDAP_SEARCH(pol_dn, LDAP_SCOPE_BASE, \"(objectclass=krbPwdPolicy)\", password_policy_attributes);\n \n     ent=ldap_first_entry(ld, result);\n    if (ent != NULL) {\n        if ((st = populate_policy(context, ld, ent, pol_name, *policy)) != 0)\n            goto cleanup;\n     }\n \n cleanup:\n     ldap_msgfree(result);\n    if (st != 0) {\n        if (*policy != NULL) {\n            krb5_ldap_free_password_policy(context, *policy);\n            *policy = NULL;\n        }\n    }\n\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return st;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144023,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "krb5_ldap_get_password_policy_from_dn(krb5_context context, char *pol_name,\n                                      char *pol_dn, osa_policy_ent_t *policy)\n{\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL,*ent=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    /* validate the input parameters */\n    if (pol_dn == NULL)\n        return EINVAL;\n\n    *policy = NULL;\n    SETUP_CONTEXT();\n    GET_HANDLE();\n\n    *(policy) = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));\n    if (*policy == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n    memset(*policy, 0, sizeof(osa_policy_ent_rec));\n\n     LDAP_SEARCH(pol_dn, LDAP_SCOPE_BASE, \"(objectclass=krbPwdPolicy)\", password_policy_attributes);\n \n     ent=ldap_first_entry(ld, result);\n    if (ent == NULL) {\n        st = KRB5_KDB_NOENTRY;\n        goto cleanup;\n     }\n    st = populate_policy(context, ld, ent, pol_name, *policy);\n \n cleanup:\n     ldap_msgfree(result);\n    if (st != 0) {\n        if (*policy != NULL) {\n            krb5_ldap_free_password_policy(context, *policy);\n            *policy = NULL;\n        }\n    }\n\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return st;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144024,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)\n{\n\tint\t\t\t\ttmp;\n\tstruct usb_host_interface\t*alt;\n\tstruct usb_host_endpoint\t*in, *out;\n\tstruct usb_host_endpoint\t*iso_in, *iso_out;\n\tstruct usb_host_endpoint\t*int_in, *int_out;\n\tstruct usb_device\t\t*udev;\n\n\tfor (tmp = 0; tmp < intf->num_altsetting; tmp++) {\n\t\tunsigned\tep;\n\n\t\tin = out = NULL;\n\t\tiso_in = iso_out = NULL;\n\t\tint_in = int_out = NULL;\n\t\talt = intf->altsetting + tmp;\n\n\t\tif (override_alt >= 0 &&\n\t\t\t\toverride_alt != alt->desc.bAlternateSetting)\n\t\t\tcontinue;\n\n\t\t/* take the first altsetting with in-bulk + out-bulk;\n\t\t * ignore other endpoints and altsettings.\n\t\t */\n\t\tfor (ep = 0; ep < alt->desc.bNumEndpoints; ep++) {\n\t\t\tstruct usb_host_endpoint\t*e;\n\t\t\tint edi;\n\n\t\t\te = alt->endpoint + ep;\n\t\t\tedi = usb_endpoint_dir_in(&e->desc);\n\n\t\t\tswitch (usb_endpoint_type(&e->desc)) {\n\t\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\t\tendpoint_update(edi, &in, &out, e);\n\t\t\t\tcontinue;\n\t\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t\tif (dev->info->intr)\n\t\t\t\t\tendpoint_update(edi, &int_in, &int_out, e);\n\t\t\t\tcontinue;\n\t\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\t\tif (dev->info->iso)\n\t\t\t\t\tendpoint_update(edi, &iso_in, &iso_out, e);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((in && out)  ||  iso_in || iso_out || int_in || int_out)\n\t\t\tgoto found;\n\t}\n\treturn -EINVAL;\n\nfound:\n\tudev = testdev_to_usbdev(dev);\n\tdev->info->alt = alt->desc.bAlternateSetting;\n\tif (alt->desc.bAlternateSetting != 0) {\n\t\ttmp = usb_set_interface(udev,\n\t\t\t\talt->desc.bInterfaceNumber,\n\t\t\t\talt->desc.bAlternateSetting);\n\t\tif (tmp < 0)\n \t\t\treturn tmp;\n \t}\n \n\tif (in) {\n \t\tdev->in_pipe = usb_rcvbulkpipe(udev,\n \t\t\tin->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n \t\tdev->out_pipe = usb_sndbulkpipe(udev,\n \t\t\tout->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n\t}\n \tif (iso_in) {\n \t\tdev->iso_in = &iso_in->desc;\n \t\tdev->in_iso_pipe = usb_rcvisocpipe(udev,\n\t\t\t\tiso_in->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (iso_out) {\n\t\tdev->iso_out = &iso_out->desc;\n\t\tdev->out_iso_pipe = usb_sndisocpipe(udev,\n\t\t\t\tiso_out->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (int_in) {\n\t\tdev->int_in = &int_in->desc;\n\t\tdev->in_int_pipe = usb_rcvintpipe(udev,\n\t\t\t\tint_in->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (int_out) {\n\t\tdev->int_out = &int_out->desc;\n\t\tdev->out_int_pipe = usb_sndintpipe(udev,\n\t\t\t\tint_out->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144075,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)\n{\n\tint\t\t\t\ttmp;\n\tstruct usb_host_interface\t*alt;\n\tstruct usb_host_endpoint\t*in, *out;\n\tstruct usb_host_endpoint\t*iso_in, *iso_out;\n\tstruct usb_host_endpoint\t*int_in, *int_out;\n\tstruct usb_device\t\t*udev;\n\n\tfor (tmp = 0; tmp < intf->num_altsetting; tmp++) {\n\t\tunsigned\tep;\n\n\t\tin = out = NULL;\n\t\tiso_in = iso_out = NULL;\n\t\tint_in = int_out = NULL;\n\t\talt = intf->altsetting + tmp;\n\n\t\tif (override_alt >= 0 &&\n\t\t\t\toverride_alt != alt->desc.bAlternateSetting)\n\t\t\tcontinue;\n\n\t\t/* take the first altsetting with in-bulk + out-bulk;\n\t\t * ignore other endpoints and altsettings.\n\t\t */\n\t\tfor (ep = 0; ep < alt->desc.bNumEndpoints; ep++) {\n\t\t\tstruct usb_host_endpoint\t*e;\n\t\t\tint edi;\n\n\t\t\te = alt->endpoint + ep;\n\t\t\tedi = usb_endpoint_dir_in(&e->desc);\n\n\t\t\tswitch (usb_endpoint_type(&e->desc)) {\n\t\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\t\tendpoint_update(edi, &in, &out, e);\n\t\t\t\tcontinue;\n\t\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t\tif (dev->info->intr)\n\t\t\t\t\tendpoint_update(edi, &int_in, &int_out, e);\n\t\t\t\tcontinue;\n\t\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\t\tif (dev->info->iso)\n\t\t\t\t\tendpoint_update(edi, &iso_in, &iso_out, e);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((in && out)  ||  iso_in || iso_out || int_in || int_out)\n\t\t\tgoto found;\n\t}\n\treturn -EINVAL;\n\nfound:\n\tudev = testdev_to_usbdev(dev);\n\tdev->info->alt = alt->desc.bAlternateSetting;\n\tif (alt->desc.bAlternateSetting != 0) {\n\t\ttmp = usb_set_interface(udev,\n\t\t\t\talt->desc.bInterfaceNumber,\n\t\t\t\talt->desc.bAlternateSetting);\n\t\tif (tmp < 0)\n \t\t\treturn tmp;\n \t}\n \n\tif (in)\n \t\tdev->in_pipe = usb_rcvbulkpipe(udev,\n \t\t\tin->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n\tif (out)\n \t\tdev->out_pipe = usb_sndbulkpipe(udev,\n \t\t\tout->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n\n \tif (iso_in) {\n \t\tdev->iso_in = &iso_in->desc;\n \t\tdev->in_iso_pipe = usb_rcvisocpipe(udev,\n\t\t\t\tiso_in->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (iso_out) {\n\t\tdev->iso_out = &iso_out->desc;\n\t\tdev->out_iso_pipe = usb_sndisocpipe(udev,\n\t\t\t\tiso_out->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (int_in) {\n\t\tdev->int_in = &int_in->desc;\n\t\tdev->in_int_pipe = usb_rcvintpipe(udev,\n\t\t\t\tint_in->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (int_out) {\n\t\tdev->int_out = &int_out->desc;\n\t\tdev->out_int_pipe = usb_sndintpipe(udev,\n\t\t\t\tint_out->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144076,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n    int interlaced = dctx->interlaced;\n    int cur_field = dctx->cur_field;\n\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                interlaced = (state&2)>>1; /* byte following the 5-byte header prefix */\n                cur_field = state&1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) /* EOF considered as end of frame */\n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                 dctx->w = (state >> 32) & 0xFFFF;\n             } else if (dctx->cur_byte == 42) {\n                 int cid = (state >> 32) & 0xFFFFFFFF;\n \n                 if (cid <= 0)\n                     continue;\n \n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (dctx->remaining <= 0) {\n                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (dctx->remaining <= 0)\n                        return dctx->remaining;\n                 }\n                 if (buf_size - i >= dctx->remaining && (!dctx->interlaced || dctx->cur_field)) {\n                     int remaining = dctx->remaining;\n \n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->interlaced = interlaced;\n                    dctx->cur_field = 0;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->interlaced = interlaced;\n            dctx->cur_field = 0;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    dctx->interlaced = interlaced;\n    dctx->cur_field = cur_field;\n    return END_NOT_FOUND;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144101,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n    int interlaced = dctx->interlaced;\n    int cur_field = dctx->cur_field;\n\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                interlaced = (state&2)>>1; /* byte following the 5-byte header prefix */\n                cur_field = state&1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) /* EOF considered as end of frame */\n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                 dctx->w = (state >> 32) & 0xFFFF;\n             } else if (dctx->cur_byte == 42) {\n                 int cid = (state >> 32) & 0xFFFFFFFF;\n                int remaining;\n \n                 if (cid <= 0)\n                     continue;\n \n                remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (remaining <= 0) {\n                    remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (remaining <= 0)\n                        continue;\n                 }\n                dctx->remaining = remaining;\n                 if (buf_size - i >= dctx->remaining && (!dctx->interlaced || dctx->cur_field)) {\n                     int remaining = dctx->remaining;\n \n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->interlaced = interlaced;\n                    dctx->cur_field = 0;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->interlaced = interlaced;\n            dctx->cur_field = 0;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    dctx->interlaced = interlaced;\n    dctx->cur_field = cur_field;\n    return END_NOT_FOUND;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144102,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,\n\t\t\t\t  RBinDexClass *c, int MI, int MA, int paddr, int ins_size,\n\t\t\t\t  int insns_size, char *class_name, int regsz,\n\t\t\t\t  int debug_info_off) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\tconst ut8 *p4 = r_buf_get_at (binfile->buf, debug_info_off, NULL);\n\tconst ut8 *p4_end = p4 + binfile->buf->length - debug_info_off;\n\tut64 line_start;\n\tut64 parameters_size;\n\tut64 param_type_idx;\n\tut16 argReg = regsz - ins_size;\n\tut64 source_file_idx = c->source_file;\n\tRList *params, *debug_positions, *emitted_debug_locals = NULL; \n\tbool keep = true;\n\tif (argReg > regsz) {\n\t\treturn; // this return breaks tests\n\t}\n\tp4 = r_uleb128 (p4, p4_end - p4, &line_start);\n\tp4 = r_uleb128 (p4, p4_end - p4, &parameters_size);\n\tut32 address = 0;\n\tut32 line = line_start;\n\tif (!(debug_positions = r_list_newf ((RListFree)free))) {\n\t\treturn;\t\n\t}\n\tif (!(emitted_debug_locals = r_list_newf ((RListFree)free))) {\n\t\tr_list_free (debug_positions);\n\t\treturn;\n\t}\n\n\tstruct dex_debug_local_t debug_locals[regsz];\n\tmemset (debug_locals, 0, sizeof (struct dex_debug_local_t) * regsz);\n\tif (!(MA & 0x0008)) {\n\t\tdebug_locals[argReg].name = \"this\";\n\t\tdebug_locals[argReg].descriptor = r_str_newf(\"%s;\", class_name);\n\t\tdebug_locals[argReg].startAddress = 0;\n\t\tdebug_locals[argReg].signature = NULL;\n\t\tdebug_locals[argReg].live = true;\n\t\targReg++;\n\t}\n\tif (!(params = dex_method_signature2 (bin, MI))) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\treturn;\n\t}\n\n\tRListIter *iter = r_list_iterator (params);\n\tchar *name;\n\tchar *type;\n\tint reg;\n\n\tr_list_foreach (params, iter, type) {\n\t\tif ((argReg >= regsz) || !type || parameters_size <= 0) {\n\t\t\tr_list_free (debug_positions);\n\t\t\tr_list_free (params);\n\t\t\tr_list_free (emitted_debug_locals);\n\t\t\treturn;\n\t\t}\n\t\tp4 = r_uleb128 (p4, p4_end - p4, &param_type_idx); // read uleb128p1\n\t\tparam_type_idx -= 1;\n\t\tname = getstr (bin, param_type_idx);\n\t\treg = argReg;\n\t\tswitch (type[0]) {\n\t\tcase 'D':\n\t\tcase 'J':\n\t\t\targReg += 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\targReg += 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (name) {\n\t\t\tdebug_locals[reg].name = name;\n\t\t\tdebug_locals[reg].descriptor = type;\n\t\t\tdebug_locals[reg].signature = NULL;\n\t\t\tdebug_locals[reg].startAddress = address;\n\t\t\tdebug_locals[reg].live = true;\n\t\t}\n \t\t--parameters_size;\n \t}\n \n \tut8 opcode = *(p4++) & 0xff;\n \twhile (keep) {\n \t\tswitch (opcode) {\n\t\tcase 0x0: // DBG_END_SEQUENCE\n\t\t\tkeep = false;\n\t\t\tbreak;\n\t\tcase 0x1: // DBG_ADVANCE_PC\n\t\t\t{\n\t\t\tut64 addr_diff;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &addr_diff);\n\t\t\taddress += addr_diff;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x2: // DBG_ADVANCE_LINE\n\t\t\t{\n\t\t\tst64 line_diff = r_sleb128 (&p4, p4_end);\n\t\t\tline += line_diff;\n\t\t\t}\n\t\t\tbreak;\t\n\t\tcase 0x3: // DBG_START_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx); \n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx); \n\t\t\ttype_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = NULL;\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x4: //DBG_START_LOCAL_EXTENDED\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tut64 sig_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx);\n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx);\n\t\t\ttype_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &sig_idx);\n\t\t\tsig_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = getstr (bin, sig_idx);\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x5: // DBG_END_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].live = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x6: // DBG_RESTART_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tif (!debug_locals[register_num].live) {\n\t\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x7: //DBG_SET_PROLOGUE_END\n\t\t\tbreak;\n\t\tcase 0x8: //DBG_SET_PROLOGUE_BEGIN\n\t\t\tbreak;\n\t\tcase 0x9:\n\t\t\t{\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &source_file_idx);\n\t\t\tsource_file_idx--;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\tint adjusted_opcode = opcode - 0x0a;\n\t\t\taddress += (adjusted_opcode / 15);\n\t\t\tline += -4 + (adjusted_opcode % 15);\n\t\t\tstruct dex_debug_position_t *position =\n\t\t\t\tmalloc (sizeof (struct dex_debug_position_t));\n\t\t\tif (!position) {\n\t\t\t\tkeep = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tposition->source_file_idx = source_file_idx;\n\t\t\tposition->address = address;\n\t\t\tposition->line = line;\n\t\t\tr_list_append (debug_positions, position);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\topcode = *(p4++) & 0xff;\n\t}\n\n\tif (!binfile->sdb_addrinfo) {\n\t\tbinfile->sdb_addrinfo = sdb_new0 ();\n\t}\n\n\tchar *fileline;\n\tchar offset[64];\n\tchar *offset_ptr;\n\n\tRListIter *iter1;\n\tstruct dex_debug_position_t *pos;\n\tr_list_foreach (debug_positions, iter1, pos) {\n\t\tfileline = r_str_newf (\"%s|%\"PFMT64d, getstr (bin, pos->source_file_idx), pos->line);\n\t\toffset_ptr = sdb_itoa (pos->address + paddr, offset, 16);\n\t\tsdb_set (binfile->sdb_addrinfo, offset_ptr, fileline, 0);\n\t\tsdb_set (binfile->sdb_addrinfo, fileline, offset_ptr, 0);\n\t}\n\n\tif (!dexdump) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\tr_list_free (params);\n\t\treturn;\n\t}\n\n\tRListIter *iter2;\n\tstruct dex_debug_position_t *position;\n\n\trbin->cb_printf (\"      positions     :\\n\");\n\tr_list_foreach (debug_positions, iter2, position) {\n\t\trbin->cb_printf (\"        0x%04llx line=%llu\\n\",\n\t\t\t\t position->address, position->line);\n\t}\n\n\trbin->cb_printf (\"      locals        :\\n\");\n\n\tRListIter *iter3;\n\tstruct dex_debug_local_t *local;\n\tr_list_foreach (emitted_debug_locals, iter3, local) {\n\t\tif (local->signature) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor,\n\t\t\t\tlocal->signature);\n\t\t} else {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor);\n\t\t}\n\t}\n\n\tfor (reg = 0; reg < regsz; reg++) {\n\t\tif (debug_locals[reg].live) {\n\t\t\tif (debug_locals[reg].signature) {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s \"\n\t\t\t\t\t\"%s\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor,\n\t\t\t\t\tdebug_locals[reg].signature);\n\t\t\t} else {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\"\n\t\t\t\t\t\"\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor);\n\t\t\t}\n\t\t}\n\t}\n\tr_list_free (debug_positions);\n\tr_list_free (emitted_debug_locals);\n\tr_list_free (params);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144111,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,\n\t\t\t\t  RBinDexClass *c, int MI, int MA, int paddr, int ins_size,\n\t\t\t\t  int insns_size, char *class_name, int regsz,\n\t\t\t\t  int debug_info_off) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\tconst ut8 *p4 = r_buf_get_at (binfile->buf, debug_info_off, NULL);\n\tconst ut8 *p4_end = p4 + binfile->buf->length - debug_info_off;\n\tut64 line_start;\n\tut64 parameters_size;\n\tut64 param_type_idx;\n\tut16 argReg = regsz - ins_size;\n\tut64 source_file_idx = c->source_file;\n\tRList *params, *debug_positions, *emitted_debug_locals = NULL; \n\tbool keep = true;\n\tif (argReg > regsz) {\n\t\treturn; // this return breaks tests\n\t}\n\tp4 = r_uleb128 (p4, p4_end - p4, &line_start);\n\tp4 = r_uleb128 (p4, p4_end - p4, &parameters_size);\n\tut32 address = 0;\n\tut32 line = line_start;\n\tif (!(debug_positions = r_list_newf ((RListFree)free))) {\n\t\treturn;\t\n\t}\n\tif (!(emitted_debug_locals = r_list_newf ((RListFree)free))) {\n\t\tr_list_free (debug_positions);\n\t\treturn;\n\t}\n\n\tstruct dex_debug_local_t debug_locals[regsz];\n\tmemset (debug_locals, 0, sizeof (struct dex_debug_local_t) * regsz);\n\tif (!(MA & 0x0008)) {\n\t\tdebug_locals[argReg].name = \"this\";\n\t\tdebug_locals[argReg].descriptor = r_str_newf(\"%s;\", class_name);\n\t\tdebug_locals[argReg].startAddress = 0;\n\t\tdebug_locals[argReg].signature = NULL;\n\t\tdebug_locals[argReg].live = true;\n\t\targReg++;\n\t}\n\tif (!(params = dex_method_signature2 (bin, MI))) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\treturn;\n\t}\n\n\tRListIter *iter = r_list_iterator (params);\n\tchar *name;\n\tchar *type;\n\tint reg;\n\n\tr_list_foreach (params, iter, type) {\n\t\tif ((argReg >= regsz) || !type || parameters_size <= 0) {\n\t\t\tr_list_free (debug_positions);\n\t\t\tr_list_free (params);\n\t\t\tr_list_free (emitted_debug_locals);\n\t\t\treturn;\n\t\t}\n\t\tp4 = r_uleb128 (p4, p4_end - p4, &param_type_idx); // read uleb128p1\n\t\tparam_type_idx -= 1;\n\t\tname = getstr (bin, param_type_idx);\n\t\treg = argReg;\n\t\tswitch (type[0]) {\n\t\tcase 'D':\n\t\tcase 'J':\n\t\t\targReg += 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\targReg += 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (name) {\n\t\t\tdebug_locals[reg].name = name;\n\t\t\tdebug_locals[reg].descriptor = type;\n\t\t\tdebug_locals[reg].signature = NULL;\n\t\t\tdebug_locals[reg].startAddress = address;\n\t\t\tdebug_locals[reg].live = true;\n\t\t}\n \t\t--parameters_size;\n \t}\n \n\tif (p4 <= 0) {\n\t\treturn;\n\t}\n \tut8 opcode = *(p4++) & 0xff;\n \twhile (keep) {\n \t\tswitch (opcode) {\n\t\tcase 0x0: // DBG_END_SEQUENCE\n\t\t\tkeep = false;\n\t\t\tbreak;\n\t\tcase 0x1: // DBG_ADVANCE_PC\n\t\t\t{\n\t\t\tut64 addr_diff;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &addr_diff);\n\t\t\taddress += addr_diff;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x2: // DBG_ADVANCE_LINE\n\t\t\t{\n\t\t\tst64 line_diff = r_sleb128 (&p4, p4_end);\n\t\t\tline += line_diff;\n\t\t\t}\n\t\t\tbreak;\t\n\t\tcase 0x3: // DBG_START_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx); \n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx); \n\t\t\ttype_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = NULL;\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x4: //DBG_START_LOCAL_EXTENDED\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tut64 sig_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx);\n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx);\n\t\t\ttype_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &sig_idx);\n\t\t\tsig_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = getstr (bin, sig_idx);\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x5: // DBG_END_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].live = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x6: // DBG_RESTART_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tif (!debug_locals[register_num].live) {\n\t\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x7: //DBG_SET_PROLOGUE_END\n\t\t\tbreak;\n\t\tcase 0x8: //DBG_SET_PROLOGUE_BEGIN\n\t\t\tbreak;\n\t\tcase 0x9:\n\t\t\t{\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &source_file_idx);\n\t\t\tsource_file_idx--;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\tint adjusted_opcode = opcode - 0x0a;\n\t\t\taddress += (adjusted_opcode / 15);\n\t\t\tline += -4 + (adjusted_opcode % 15);\n\t\t\tstruct dex_debug_position_t *position =\n\t\t\t\tmalloc (sizeof (struct dex_debug_position_t));\n\t\t\tif (!position) {\n\t\t\t\tkeep = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tposition->source_file_idx = source_file_idx;\n\t\t\tposition->address = address;\n\t\t\tposition->line = line;\n\t\t\tr_list_append (debug_positions, position);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\topcode = *(p4++) & 0xff;\n\t}\n\n\tif (!binfile->sdb_addrinfo) {\n\t\tbinfile->sdb_addrinfo = sdb_new0 ();\n\t}\n\n\tchar *fileline;\n\tchar offset[64];\n\tchar *offset_ptr;\n\n\tRListIter *iter1;\n\tstruct dex_debug_position_t *pos;\n\tr_list_foreach (debug_positions, iter1, pos) {\n\t\tfileline = r_str_newf (\"%s|%\"PFMT64d, getstr (bin, pos->source_file_idx), pos->line);\n\t\toffset_ptr = sdb_itoa (pos->address + paddr, offset, 16);\n\t\tsdb_set (binfile->sdb_addrinfo, offset_ptr, fileline, 0);\n\t\tsdb_set (binfile->sdb_addrinfo, fileline, offset_ptr, 0);\n\t}\n\n\tif (!dexdump) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\tr_list_free (params);\n\t\treturn;\n\t}\n\n\tRListIter *iter2;\n\tstruct dex_debug_position_t *position;\n\n\trbin->cb_printf (\"      positions     :\\n\");\n\tr_list_foreach (debug_positions, iter2, position) {\n\t\trbin->cb_printf (\"        0x%04llx line=%llu\\n\",\n\t\t\t\t position->address, position->line);\n\t}\n\n\trbin->cb_printf (\"      locals        :\\n\");\n\n\tRListIter *iter3;\n\tstruct dex_debug_local_t *local;\n\tr_list_foreach (emitted_debug_locals, iter3, local) {\n\t\tif (local->signature) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor,\n\t\t\t\tlocal->signature);\n\t\t} else {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor);\n\t\t}\n\t}\n\n\tfor (reg = 0; reg < regsz; reg++) {\n\t\tif (debug_locals[reg].live) {\n\t\t\tif (debug_locals[reg].signature) {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s \"\n\t\t\t\t\t\"%s\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor,\n\t\t\t\t\tdebug_locals[reg].signature);\n\t\t\t} else {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\"\n\t\t\t\t\t\"\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor);\n\t\t\t}\n\t\t}\n\t}\n\tr_list_free (debug_positions);\n\tr_list_free (emitted_debug_locals);\n\tr_list_free (params);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144112,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int mpeg4video_probe(AVProbeData *probe_packet)\n{\n    uint32_t temp_buffer = -1;\n    int VO = 0, VOL = 0, VOP = 0, VISO = 0, res = 0;\n    int i;\n \n     for (i = 0; i < probe_packet->buf_size; i++) {\n         temp_buffer = (temp_buffer << 8) + probe_packet->buf[i];\n        if ((temp_buffer & 0xffffff00) != 0x100)\n             continue;\n \n         if (temp_buffer == VOP_START_CODE)\n             VOP++;\n         else if (temp_buffer == VISUAL_OBJECT_START_CODE)\n             VISO++;\n        else if (temp_buffer < 0x120)\n             VO++;\n        else if (temp_buffer < 0x130)\n             VOL++;\n         else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) &&\n                  !(0x1B9 < temp_buffer && temp_buffer < 0x1C4))\n            res++;\n    }\n\n    if (VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0)\n        return AVPROBE_SCORE_EXTENSION;\n    return 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144135,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int mpeg4video_probe(AVProbeData *probe_packet)\n{\n    uint32_t temp_buffer = -1;\n    int VO = 0, VOL = 0, VOP = 0, VISO = 0, res = 0;\n    int i;\n \n     for (i = 0; i < probe_packet->buf_size; i++) {\n         temp_buffer = (temp_buffer << 8) + probe_packet->buf[i];\n        if (temp_buffer & 0xfffffe00)\n            continue;\n        if (temp_buffer < 2)\n             continue;\n \n         if (temp_buffer == VOP_START_CODE)\n             VOP++;\n         else if (temp_buffer == VISUAL_OBJECT_START_CODE)\n             VISO++;\n        else if (temp_buffer >= 0x100 && temp_buffer < 0x120)\n             VO++;\n        else if (temp_buffer >= 0x120 && temp_buffer < 0x130)\n             VOL++;\n         else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) &&\n                  !(0x1B9 < temp_buffer && temp_buffer < 0x1C4))\n            res++;\n    }\n\n    if (VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0)\n        return AVPROBE_SCORE_EXTENSION;\n    return 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144136,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " dwarf_elf_object_access_load_section(void* obj_in,\n     Dwarf_Half section_index,\n    Dwarf_Small** section_data,\n    int* error)\n{\n    dwarf_elf_object_access_internals_t*obj =\n        (dwarf_elf_object_access_internals_t*)obj_in;\n    if (section_index == 0) {\n        return DW_DLV_NO_ENTRY;\n    }\n\n    {\n        Elf_Scn *scn = 0;\n        Elf_Data *data = 0;\n\n        scn = elf_getscn(obj->elf, section_index);\n        if (scn == NULL) {\n            *error = DW_DLE_MDE;\n            return DW_DLV_ERROR;\n        }\n\n        /*  When using libelf as a producer, section data may be stored\n            in multiple buffers. In libdwarf however, we only use libelf\n            as a consumer (there is a dwarf producer API, but it doesn't\n            use libelf). Because of this, this single call to elf_getdata\n            will retrieve the entire section in a single contiguous\n            buffer. */\n        data = elf_getdata(scn, NULL);\n        if (data == NULL) {\n             *error = DW_DLE_MDE;\n             return DW_DLV_ERROR;\n         }\n         *section_data = data->d_buf;\n     }\n     return DW_DLV_OK;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144141,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " dwarf_elf_object_access_load_section(void* obj_in,\n     Dwarf_Half section_index,\n    Dwarf_Small** section_data,\n    int* error)\n{\n    dwarf_elf_object_access_internals_t*obj =\n        (dwarf_elf_object_access_internals_t*)obj_in;\n    if (section_index == 0) {\n        return DW_DLV_NO_ENTRY;\n    }\n\n    {\n        Elf_Scn *scn = 0;\n        Elf_Data *data = 0;\n\n        scn = elf_getscn(obj->elf, section_index);\n        if (scn == NULL) {\n            *error = DW_DLE_MDE;\n            return DW_DLV_ERROR;\n        }\n\n        /*  When using libelf as a producer, section data may be stored\n            in multiple buffers. In libdwarf however, we only use libelf\n            as a consumer (there is a dwarf producer API, but it doesn't\n            use libelf). Because of this, this single call to elf_getdata\n            will retrieve the entire section in a single contiguous\n            buffer. */\n        data = elf_getdata(scn, NULL);\n        if (data == NULL) {\n             *error = DW_DLE_MDE;\n             return DW_DLV_ERROR;\n         }\n        if (!data->d_buf) {\n            /*  If NULL it means 'the section has no data'\n                according to libelf documentation.\n                No DWARF-related section should ever have\n                'no data'.  Happens if a section type is\n                SHT_NOBITS and no section libdwarf\n                wants to look at should be SHT_NOBITS. */\n            *error = DW_DLE_MDE;\n            return DW_DLV_ERROR;\n        }\n         *section_data = data->d_buf;\n     }\n     return DW_DLV_OK;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144142,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int rds_cmsg_atomic(struct rds_sock *rs, struct rds_message *rm,\n\t\t    struct cmsghdr *cmsg)\n{\n\tstruct page *page = NULL;\n\tstruct rds_atomic_args *args;\n\tint ret = 0;\n\n\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct rds_atomic_args))\n\t || rm->atomic.op_active)\n\t\treturn -EINVAL;\n\n\targs = CMSG_DATA(cmsg);\n\n\t/* Nonmasked & masked cmsg ops converted to masked hw ops */\n\tswitch (cmsg->cmsg_type) {\n\tcase RDS_CMSG_ATOMIC_FADD:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_FADD;\n\t\trm->atomic.op_m_fadd.add = args->fadd.add;\n\t\trm->atomic.op_m_fadd.nocarry_mask = 0;\n\t\tbreak;\n\tcase RDS_CMSG_MASKED_ATOMIC_FADD:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_FADD;\n\t\trm->atomic.op_m_fadd.add = args->m_fadd.add;\n\t\trm->atomic.op_m_fadd.nocarry_mask = args->m_fadd.nocarry_mask;\n\t\tbreak;\n\tcase RDS_CMSG_ATOMIC_CSWP:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP;\n\t\trm->atomic.op_m_cswp.compare = args->cswp.compare;\n\t\trm->atomic.op_m_cswp.swap = args->cswp.swap;\n\t\trm->atomic.op_m_cswp.compare_mask = ~0;\n\t\trm->atomic.op_m_cswp.swap_mask = ~0;\n\t\tbreak;\n\tcase RDS_CMSG_MASKED_ATOMIC_CSWP:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP;\n\t\trm->atomic.op_m_cswp.compare = args->m_cswp.compare;\n\t\trm->atomic.op_m_cswp.swap = args->m_cswp.swap;\n\t\trm->atomic.op_m_cswp.compare_mask = args->m_cswp.compare_mask;\n\t\trm->atomic.op_m_cswp.swap_mask = args->m_cswp.swap_mask;\n\t\tbreak;\n\tdefault:\n\t\tBUG(); /* should never happen */\n\t}\n\n\trm->atomic.op_notify = !!(args->flags & RDS_RDMA_NOTIFY_ME);\n\trm->atomic.op_silent = !!(args->flags & RDS_RDMA_SILENT);\n\trm->atomic.op_active = 1;\n\trm->atomic.op_recverr = rs->rs_recverr;\n\trm->atomic.op_sg = rds_message_alloc_sgs(rm, 1);\n\tif (!rm->atomic.op_sg) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* verify 8 byte-aligned */\n\tif (args->local_addr & 0x7) {\n\t\tret = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tret = rds_pin_pages(args->local_addr, 1, &page, 1);\n\tif (ret != 1)\n\t\tgoto err;\n\tret = 0;\n\n\tsg_set_page(rm->atomic.op_sg, page, 8, offset_in_page(args->local_addr));\n\n\tif (rm->atomic.op_notify || rm->atomic.op_recverr) {\n\t\t/* We allocate an uninitialized notifier here, because\n\t\t * we don't want to do that in the completion handler. We\n\t\t * would have to use GFP_ATOMIC there, and don't want to deal\n\t\t * with failed allocations.\n\t\t */\n\t\trm->atomic.op_notifier = kmalloc(sizeof(*rm->atomic.op_notifier), GFP_KERNEL);\n\t\tif (!rm->atomic.op_notifier) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\trm->atomic.op_notifier->n_user_token = args->user_token;\n\t\trm->atomic.op_notifier->n_status = RDS_RDMA_SUCCESS;\n\t}\n\n\trm->atomic.op_rkey = rds_rdma_cookie_key(args->cookie);\n\trm->atomic.op_remote_addr = args->remote_addr + rds_rdma_cookie_offset(args->cookie);\n\n\treturn ret;\n err:\n \tif (page)\n \t\tput_page(page);\n \tkfree(rm->atomic.op_notifier);\n \n \treturn ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144161,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int rds_cmsg_atomic(struct rds_sock *rs, struct rds_message *rm,\n\t\t    struct cmsghdr *cmsg)\n{\n\tstruct page *page = NULL;\n\tstruct rds_atomic_args *args;\n\tint ret = 0;\n\n\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct rds_atomic_args))\n\t || rm->atomic.op_active)\n\t\treturn -EINVAL;\n\n\targs = CMSG_DATA(cmsg);\n\n\t/* Nonmasked & masked cmsg ops converted to masked hw ops */\n\tswitch (cmsg->cmsg_type) {\n\tcase RDS_CMSG_ATOMIC_FADD:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_FADD;\n\t\trm->atomic.op_m_fadd.add = args->fadd.add;\n\t\trm->atomic.op_m_fadd.nocarry_mask = 0;\n\t\tbreak;\n\tcase RDS_CMSG_MASKED_ATOMIC_FADD:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_FADD;\n\t\trm->atomic.op_m_fadd.add = args->m_fadd.add;\n\t\trm->atomic.op_m_fadd.nocarry_mask = args->m_fadd.nocarry_mask;\n\t\tbreak;\n\tcase RDS_CMSG_ATOMIC_CSWP:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP;\n\t\trm->atomic.op_m_cswp.compare = args->cswp.compare;\n\t\trm->atomic.op_m_cswp.swap = args->cswp.swap;\n\t\trm->atomic.op_m_cswp.compare_mask = ~0;\n\t\trm->atomic.op_m_cswp.swap_mask = ~0;\n\t\tbreak;\n\tcase RDS_CMSG_MASKED_ATOMIC_CSWP:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP;\n\t\trm->atomic.op_m_cswp.compare = args->m_cswp.compare;\n\t\trm->atomic.op_m_cswp.swap = args->m_cswp.swap;\n\t\trm->atomic.op_m_cswp.compare_mask = args->m_cswp.compare_mask;\n\t\trm->atomic.op_m_cswp.swap_mask = args->m_cswp.swap_mask;\n\t\tbreak;\n\tdefault:\n\t\tBUG(); /* should never happen */\n\t}\n\n\trm->atomic.op_notify = !!(args->flags & RDS_RDMA_NOTIFY_ME);\n\trm->atomic.op_silent = !!(args->flags & RDS_RDMA_SILENT);\n\trm->atomic.op_active = 1;\n\trm->atomic.op_recverr = rs->rs_recverr;\n\trm->atomic.op_sg = rds_message_alloc_sgs(rm, 1);\n\tif (!rm->atomic.op_sg) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* verify 8 byte-aligned */\n\tif (args->local_addr & 0x7) {\n\t\tret = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tret = rds_pin_pages(args->local_addr, 1, &page, 1);\n\tif (ret != 1)\n\t\tgoto err;\n\tret = 0;\n\n\tsg_set_page(rm->atomic.op_sg, page, 8, offset_in_page(args->local_addr));\n\n\tif (rm->atomic.op_notify || rm->atomic.op_recverr) {\n\t\t/* We allocate an uninitialized notifier here, because\n\t\t * we don't want to do that in the completion handler. We\n\t\t * would have to use GFP_ATOMIC there, and don't want to deal\n\t\t * with failed allocations.\n\t\t */\n\t\trm->atomic.op_notifier = kmalloc(sizeof(*rm->atomic.op_notifier), GFP_KERNEL);\n\t\tif (!rm->atomic.op_notifier) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\trm->atomic.op_notifier->n_user_token = args->user_token;\n\t\trm->atomic.op_notifier->n_status = RDS_RDMA_SUCCESS;\n\t}\n\n\trm->atomic.op_rkey = rds_rdma_cookie_key(args->cookie);\n\trm->atomic.op_remote_addr = args->remote_addr + rds_rdma_cookie_offset(args->cookie);\n\n\treturn ret;\n err:\n \tif (page)\n \t\tput_page(page);\n\trm->atomic.op_active = 0;\n \tkfree(rm->atomic.op_notifier);\n \n \treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144162,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n \tu32 device_idx, target_idx;\n \tint rc;\n \n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n \t\treturn -EINVAL;\n \n \tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\n\trc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144179,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n \tu32 device_idx, target_idx;\n \tint rc;\n \n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_TARGET_INDEX])\n \t\treturn -EINVAL;\n \n \tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\n\trc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144180,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) /* EOF considered as end of frame */\n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                 dctx->w = (state >> 32) & 0xFFFF;\n             } else if (dctx->cur_byte == 42) {\n                 int cid = (state >> 32) & 0xFFFFFFFF;\n \n                 if (cid <= 0)\n                     continue;\n \n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (dctx->remaining <= 0) {\n                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (dctx->remaining <= 0)\n                        return dctx->remaining;\n                 }\n                 if (buf_size - i + 47 >= dctx->remaining) {\n                     int remaining = dctx->remaining;\n \n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    return END_NOT_FOUND;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144199,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) /* EOF considered as end of frame */\n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                 dctx->w = (state >> 32) & 0xFFFF;\n             } else if (dctx->cur_byte == 42) {\n                 int cid = (state >> 32) & 0xFFFFFFFF;\n                int remaining;\n \n                 if (cid <= 0)\n                     continue;\n \n                remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (remaining <= 0) {\n                    remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (remaining <= 0)\n                        continue;\n                 }\n                dctx->remaining = remaining;\n                 if (buf_size - i + 47 >= dctx->remaining) {\n                     int remaining = dctx->remaining;\n \n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    return END_NOT_FOUND;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144200,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "VP8XChunk::VP8XChunk(Container* parent)\n  : Chunk(parent, kChunk_VP8X)\n{\n    this->needsRewrite = true;\n    this->size = 10;\n    this->data.resize(this->size);\n     this->data.assign(this->size, 0);\n     XMP_Uns8* bitstream =\n         (XMP_Uns8*)parent->chunks[WEBP_CHUNK_IMAGE][0]->data.data();\n    XMP_Uns32 width = ((bitstream[7] << 8) | bitstream[6]) & 0x3fff;\n    XMP_Uns32 height = ((bitstream[9] << 8) | bitstream[8]) & 0x3fff;\n     this->width(width);\n     this->height(height);\n     parent->vp8x = this;\nVP8XChunk::VP8XChunk(Container* parent, WEBP_MetaHandler* handler)\n  : Chunk(parent, handler)\n{\n    this->size = 10;\n    this->needsRewrite = true;\n    parent->vp8x = this;\n}\n\nXMP_Uns32 VP8XChunk::width()\n{\n    return GetLE24(&this->data[4]) + 1;\n}\nvoid VP8XChunk::width(XMP_Uns32 val)\n{\n    PutLE24(&this->data[4], val > 0 ? val - 1 : 0);\n}\nXMP_Uns32 VP8XChunk::height()\n{\n    return GetLE24(&this->data[7]) + 1;\n}\nvoid VP8XChunk::height(XMP_Uns32 val)\n{\n    PutLE24(&this->data[7], val > 0 ? val - 1 : 0);\n}\nbool VP8XChunk::xmp()\n{\n    XMP_Uns32 flags = GetLE32(&this->data[0]);\n    return (bool)((flags >> XMP_FLAG_BIT) & 1);\n}\nvoid VP8XChunk::xmp(bool hasXMP)\n{\n    XMP_Uns32 flags = GetLE32(&this->data[0]);\n    flags ^= (-hasXMP ^ flags) & (1 << XMP_FLAG_BIT);\n    PutLE32(&this->data[0], flags);\n}\n\nContainer::Container(WEBP_MetaHandler* handler) : Chunk(NULL, handler)\n{\n    this->needsRewrite = false;\n\n    XMP_IO* file = handler->parent->ioRef;\n\n    file->Seek(12, kXMP_SeekFromStart);\n\n    XMP_Int64 size = handler->initialFileSize;\n\n    XMP_Uns32 peek = 0;\n\n    while (file->Offset() < size) {\n        peek = XIO::PeekUns32_LE(file);\n        switch (peek) {\n        case kChunk_XMP_:\n            this->addChunk(new XMPChunk(this, handler));\n            break;\n        case kChunk_VP8X:\n            this->addChunk(new VP8XChunk(this, handler));\n            break;\n        default:\n            this->addChunk(new Chunk(this, handler));\n            break;\n        }\n    }\n\n    if (this->chunks[WEBP_CHUNK_IMAGE].size() == 0) {\n        XMP_Throw(\"File has no image bitstream\", kXMPErr_BadFileFormat);\n    }\n\n    if (this->chunks[WEBP_CHUNK_VP8X].size() == 0) {\n        this->needsRewrite = true;\n        this->addChunk(new VP8XChunk(this));\n    }\n\n    if (this->chunks[WEBP_CHUNK_XMP].size() == 0) {\n        XMPChunk* xmpChunk = new XMPChunk(this);\n        this->addChunk(xmpChunk);\n        handler->xmpChunk = xmpChunk;\n        this->vp8x->xmp(true);\n    }\n}\n\nChunk* Container::getExifChunk()\n{\n    if (this->chunks[WEBP::WEBP_CHUNK_EXIF].size() == 0) {\n        return NULL;\n    }\n    return this->chunks[WEBP::WEBP_CHUNK_EXIF][0];\n}\n\nvoid Container::addChunk(Chunk* chunk)\n{\n    ChunkId idx;\n\n    try {\n        idx = chunkMap.at(chunk->tag);\n    }\n    catch (const std::out_of_range& e) {\n        idx = WEBP_CHUNK_UNKNOWN;\n    }\n    this->chunks[idx].push_back(chunk);\n}\n\nvoid Container::write(WEBP_MetaHandler* handler)\n{\n    XMP_IO* file = handler->parent->ioRef;\n    file->Rewind();\n    XIO::WriteUns32_LE(file, this->tag);\n    XIO::WriteUns32_LE(file, (XMP_Uns32) this->size);\n    XIO::WriteUns32_LE(file, kChunk_WEBP);\n\n    size_t i, j;\n    std::vector<Chunk*> chunkVect;\n    for (i = 0; i < WEBP_CHUNK_NIL; i++) {\n        chunkVect = this->chunks[i];\n        for (j = 0; j < chunkVect.size(); j++) {\n            chunkVect.at(j)->write(handler);\n        }\n    }\n    XMP_Int64 lastOffset = file->Offset();\n    this->size = lastOffset - 8;\n    file->Seek(this->pos + 4, kXMP_SeekFromStart);\n    XIO::WriteUns32_LE(file, (XMP_Uns32) this->size);\n    file->Seek(lastOffset, kXMP_SeekFromStart);\n    if (lastOffset < handler->initialFileSize) {\n        file->Truncate(lastOffset);\n    }\n}\n\nContainer::~Container()\n{\n    Chunk* chunk;\n    size_t i;\n    std::vector<Chunk*> chunkVect;\n    for (i = 0; i < WEBP_CHUNK_NIL; i++) {\n        chunkVect = this->chunks[i];\n        while (!chunkVect.empty()) {\n            chunk = chunkVect.back();\n            delete chunk;\n            chunkVect.pop_back();\n        }\n    }\n}\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144343,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "VP8XChunk::VP8XChunk(Container* parent)\n  : Chunk(parent, kChunk_VP8X)\n{\n    this->needsRewrite = true;\n    this->size = 10;\n    this->data.resize(this->size);\n     this->data.assign(this->size, 0);\n     XMP_Uns8* bitstream =\n         (XMP_Uns8*)parent->chunks[WEBP_CHUNK_IMAGE][0]->data.data();\n    // See bug https://bugs.freedesktop.org/show_bug.cgi?id=105247\n    // bitstream could be NULL.\n    XMP_Uns32 width = bitstream ? ((bitstream[7] << 8) | bitstream[6]) & 0x3fff : 0;\n    XMP_Uns32 height = bitstream ? ((bitstream[9] << 8) | bitstream[8]) & 0x3fff : 0;\n     this->width(width);\n     this->height(height);\n     parent->vp8x = this;\nVP8XChunk::VP8XChunk(Container* parent, WEBP_MetaHandler* handler)\n  : Chunk(parent, handler)\n{\n    this->size = 10;\n    this->needsRewrite = true;\n    parent->vp8x = this;\n}\n\nXMP_Uns32 VP8XChunk::width()\n{\n    return GetLE24(&this->data[4]) + 1;\n}\nvoid VP8XChunk::width(XMP_Uns32 val)\n{\n    PutLE24(&this->data[4], val > 0 ? val - 1 : 0);\n}\nXMP_Uns32 VP8XChunk::height()\n{\n    return GetLE24(&this->data[7]) + 1;\n}\nvoid VP8XChunk::height(XMP_Uns32 val)\n{\n    PutLE24(&this->data[7], val > 0 ? val - 1 : 0);\n}\nbool VP8XChunk::xmp()\n{\n    XMP_Uns32 flags = GetLE32(&this->data[0]);\n    return (bool)((flags >> XMP_FLAG_BIT) & 1);\n}\nvoid VP8XChunk::xmp(bool hasXMP)\n{\n    XMP_Uns32 flags = GetLE32(&this->data[0]);\n    flags ^= (-hasXMP ^ flags) & (1 << XMP_FLAG_BIT);\n    PutLE32(&this->data[0], flags);\n}\n\nContainer::Container(WEBP_MetaHandler* handler) : Chunk(NULL, handler)\n{\n    this->needsRewrite = false;\n\n    XMP_IO* file = handler->parent->ioRef;\n\n    file->Seek(12, kXMP_SeekFromStart);\n\n    XMP_Int64 size = handler->initialFileSize;\n\n    XMP_Uns32 peek = 0;\n\n    while (file->Offset() < size) {\n        peek = XIO::PeekUns32_LE(file);\n        switch (peek) {\n        case kChunk_XMP_:\n            this->addChunk(new XMPChunk(this, handler));\n            break;\n        case kChunk_VP8X:\n            this->addChunk(new VP8XChunk(this, handler));\n            break;\n        default:\n            this->addChunk(new Chunk(this, handler));\n            break;\n        }\n    }\n\n    if (this->chunks[WEBP_CHUNK_IMAGE].size() == 0) {\n        XMP_Throw(\"File has no image bitstream\", kXMPErr_BadFileFormat);\n    }\n\n    if (this->chunks[WEBP_CHUNK_VP8X].size() == 0) {\n        this->needsRewrite = true;\n        this->addChunk(new VP8XChunk(this));\n    }\n\n    if (this->chunks[WEBP_CHUNK_XMP].size() == 0) {\n        XMPChunk* xmpChunk = new XMPChunk(this);\n        this->addChunk(xmpChunk);\n        handler->xmpChunk = xmpChunk;\n        this->vp8x->xmp(true);\n    }\n}\n\nChunk* Container::getExifChunk()\n{\n    if (this->chunks[WEBP::WEBP_CHUNK_EXIF].size() == 0) {\n        return NULL;\n    }\n    return this->chunks[WEBP::WEBP_CHUNK_EXIF][0];\n}\n\nvoid Container::addChunk(Chunk* chunk)\n{\n    ChunkId idx;\n\n    try {\n        idx = chunkMap.at(chunk->tag);\n    }\n    catch (const std::out_of_range& e) {\n        idx = WEBP_CHUNK_UNKNOWN;\n    }\n    this->chunks[idx].push_back(chunk);\n}\n\nvoid Container::write(WEBP_MetaHandler* handler)\n{\n    XMP_IO* file = handler->parent->ioRef;\n    file->Rewind();\n    XIO::WriteUns32_LE(file, this->tag);\n    XIO::WriteUns32_LE(file, (XMP_Uns32) this->size);\n    XIO::WriteUns32_LE(file, kChunk_WEBP);\n\n    size_t i, j;\n    std::vector<Chunk*> chunkVect;\n    for (i = 0; i < WEBP_CHUNK_NIL; i++) {\n        chunkVect = this->chunks[i];\n        for (j = 0; j < chunkVect.size(); j++) {\n            chunkVect.at(j)->write(handler);\n        }\n    }\n    XMP_Int64 lastOffset = file->Offset();\n    this->size = lastOffset - 8;\n    file->Seek(this->pos + 4, kXMP_SeekFromStart);\n    XIO::WriteUns32_LE(file, (XMP_Uns32) this->size);\n    file->Seek(lastOffset, kXMP_SeekFromStart);\n    if (lastOffset < handler->initialFileSize) {\n        file->Truncate(lastOffset);\n    }\n}\n\nContainer::~Container()\n{\n    Chunk* chunk;\n    size_t i;\n    std::vector<Chunk*> chunkVect;\n    for (i = 0; i < WEBP_CHUNK_NIL; i++) {\n        chunkVect = this->chunks[i];\n        while (!chunkVect.empty()) {\n            chunk = chunkVect.back();\n            delete chunk;\n            chunkVect.pop_back();\n        }\n    }\n}\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144344,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "daemon_AuthUserPwd(char *username, char *password, char *errbuf)\n{\n#ifdef _WIN32\n\t/*\n\t * Warning: the user which launches the process must have the\n\t * SE_TCB_NAME right.\n\t * This corresponds to have the \"Act as part of the Operating System\"\n\t * turned on (administrative tools, local security settings, local\n\t * policies, user right assignment)\n\t * However, it seems to me that if you run it as a service, this\n\t * right should be provided by default.\n\t *\n\t * XXX - hopefully, this returns errors such as ERROR_LOGON_FAILURE,\n\t * which merely indicates that the user name or password is\n\t * incorrect, not whether it's the user name or the password\n\t * that's incorrect, so a client that's trying to brute-force\n\t * accounts doesn't know whether it's the user name or the\n\t * password that's incorrect, so it doesn't know whether to\n\t * stop trying to log in with a given user name and move on\n\t * to another user name.\n\t */\n\tHANDLE Token;\n\tif (LogonUser(username, \".\", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"LogonUser() failed\");\n\t\treturn -1;\n\t}\n\n\t// This call should change the current thread to the selected user.\n\t// I didn't test it.\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}\n\n\tCloseHandle(Token);\n\treturn 0;\n\n#else\n\t/*\n\t * See\n\t *\n\t *\thttp://www.unixpapa.com/incnote/passwd.html\n\t *\n\t * We use the Solaris/Linux shadow password authentication if\n\t * we have getspnam(), otherwise we just do traditional\n\t * authentication, which, on some platforms, might work, even\n\t * with shadow passwords, if we're running as root.  Traditional\n\t * authenticaion won't work if we're not running as root, as\n\t * I think these days all UN*Xes either won't return the password\n\t * at all with getpwnam() or will only do so if you're root.\n\t *\n\t * XXX - perhaps what we *should* be using is PAM, if we have\n\t * it.  That might hide all the details of username/password\n\t * authentication, whether it's done with a visible-to-root-\n\t * only password database or some other authentication mechanism,\n\t * behind its API.\n\t */\n\tstruct passwd *user;\n\tchar *user_password;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd *usersp;\n#endif\n\n\t// This call is needed to get the uid\n\tif ((user = getpwnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_GETSPNAM\n\t// This call is needed to get the password; otherwise 'x' is returned\n\tif ((usersp = getspnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\tuser_password = usersp->sp_pwdp;\n#else\n\t/*\n\t * XXX - what about other platforms?\n\t * The unixpapa.com page claims this Just Works on *BSD if you're\n\t * running as root - it's from 2000, so it doesn't indicate whether\n\t * macOS (which didn't come out until 2001, under the name Mac OS\n\t * X) behaves like the *BSDs or not, and might also work on AIX.\n\t * HP-UX does something else.\n\t *\n\t * Again, hopefully PAM hides all that.\n\t */\n\tuser_password = user->pw_passwd;\n#endif\n\n\tif (strcmp(user_password, (char *) crypt(password, user_password)) != 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\n\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}\n\n/*\tif (setgid(user->pw_gid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setgid\");\n\t\treturn -1;\n\t}\n*/\n\treturn 0;\n\n#endif\n\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144511,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "daemon_AuthUserPwd(char *username, char *password, char *errbuf)\n{\n#ifdef _WIN32\n\t/*\n\t * Warning: the user which launches the process must have the\n\t * SE_TCB_NAME right.\n\t * This corresponds to have the \"Act as part of the Operating System\"\n\t * turned on (administrative tools, local security settings, local\n\t * policies, user right assignment)\n\t * However, it seems to me that if you run it as a service, this\n\t * right should be provided by default.\n\t *\n\t * XXX - hopefully, this returns errors such as ERROR_LOGON_FAILURE,\n\t * which merely indicates that the user name or password is\n\t * incorrect, not whether it's the user name or the password\n\t * that's incorrect, so a client that's trying to brute-force\n\t * accounts doesn't know whether it's the user name or the\n\t * password that's incorrect, so it doesn't know whether to\n\t * stop trying to log in with a given user name and move on\n\t * to another user name.\n\t */\n\tHANDLE Token;\n\tif (LogonUser(username, \".\", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"LogonUser() failed\");\n\t\treturn -1;\n\t}\n\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}\n\n\tCloseHandle(Token);\n\treturn 0;\n\n#else\n\t/*\n\t * See\n\t *\n\t *\thttp://www.unixpapa.com/incnote/passwd.html\n\t *\n\t * We use the Solaris/Linux shadow password authentication if\n\t * we have getspnam(), otherwise we just do traditional\n\t * authentication, which, on some platforms, might work, even\n\t * with shadow passwords, if we're running as root.  Traditional\n\t * authenticaion won't work if we're not running as root, as\n\t * I think these days all UN*Xes either won't return the password\n\t * at all with getpwnam() or will only do so if you're root.\n\t *\n\t * XXX - perhaps what we *should* be using is PAM, if we have\n\t * it.  That might hide all the details of username/password\n\t * authentication, whether it's done with a visible-to-root-\n\t * only password database or some other authentication mechanism,\n\t * behind its API.\n\t */\n\tstruct passwd *user;\n\tchar *user_password;\n #ifdef HAVE_GETSPNAM\n \tstruct spwd *usersp;\n #endif\n\tchar *crypt_password;\n \n \tif ((user = getpwnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_GETSPNAM\n\tif ((usersp = getspnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\tuser_password = usersp->sp_pwdp;\n#else\n\t/*\n\t * XXX - what about other platforms?\n\t * The unixpapa.com page claims this Just Works on *BSD if you're\n\t * running as root - it's from 2000, so it doesn't indicate whether\n\t * macOS (which didn't come out until 2001, under the name Mac OS\n\t * X) behaves like the *BSDs or not, and might also work on AIX.\n\t * HP-UX does something else.\n\t *\n\t * Again, hopefully PAM hides all that.\n\t */\n \tuser_password = user->pw_passwd;\n #endif\n \n\tcrypt_password = crypt(password, user_password);\n\tif (crypt_password == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n\t\treturn -1;\n\t}\n\tif (strcmp(user_password, crypt_password) != 0)\n \t{\n \t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n \t\treturn -1;\n\t}\n\n\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}\n\n/*\tif (setgid(user->pw_gid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setgid\");\n\t\treturn -1;\n\t}\n*/\n\treturn 0;\n\n#endif\n\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144512,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " */\nstatic void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t*pce;\n\tzval\t\t\t\tobj;\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp((char *)name, EL_STRING) || !strcmp((char *)name, EL_NUMBER) ||\n\t\t!strcmp((char *)name, EL_BOOLEAN) || !strcmp((char *)name, EL_NULL) ||\n\t  \t!strcmp((char *)name, EL_ARRAY) || !strcmp((char *)name, EL_STRUCT) ||\n\t\t!strcmp((char *)name, EL_RECORDSET) || !strcmp((char *)name, EL_BINARY) ||\n\t\t!strcmp((char *)name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (Z_TYPE(ent1->data) == IS_UNDEF) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t\tefree(ent1);\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp((char *)name, EL_BINARY)) {\n\t\t\tzend_string *new_str = NULL;\n\t\t\t\n\t\t\tif (ZSTR_EMPTY_ALLOC() != Z_STR(ent1->data)) {\n\t\t\t\tnew_str = php_base64_decode(\n\t\t\t\t\t(unsigned char *)Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\t}\n\n\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\tif (new_str) {\n\t\t\t\tZVAL_STR(&ent1->data, new_str);\n\t\t\t} else {\n\t\t\t\tZVAL_EMPTY_STRING(&ent1->data);\n\t\t\t}\n\t\t}\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE(ent1->data) == IS_OBJECT) {\n\t\t\tzval fname, retval;\n\n\t\t\tZVAL_STRING(&fname, \"__wakeup\");\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, &fname, &retval, 0, 0, 0, NULL);\n\n\t\t\tzval_ptr_dtor(&fname);\n\t\t\tzval_ptr_dtor(&retval);\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (Z_ISUNDEF(ent2->data)) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE(ent2->data) == IS_ARRAY || Z_TYPE(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(&ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE(ent1->data) == IS_STRING && Z_STRLEN(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\t\t\t\tzend_string_forget_hash_val(Z_STR(ent1->data));\n\t\t\t\t\t\tif ((pce = zend_hash_find_ptr(EG(class_table), Z_STR(ent1->data))) == NULL) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (pce != PHP_IC_ENTRY && (pce->serialize || pce->unserialize)) {\n\t\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\t\t\t\t\t\t\tZVAL_UNDEF(&ent2->data);\n\t\t\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Class %s can not be unserialized\", Z_STRVAL(ent1->data));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\t\tobject_init_ex(&obj, pce);\n\n\t\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP(obj),\n\t\t\t\t\t\t\t\t\t\t\tZ_ARRVAL(ent2->data),\n\t\t\t\t\t\t\t\t\t\t\tzval_add_ref, 0);\n\n\t\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\t\tphp_store_class_name(&obj, Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\t\tZVAL_COPY_VALUE(&ent2->data, &obj);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE(ent2->data);\n\t\t\t\t\t\tadd_property_zval(&ent2->data, ent1->varname, &ent1->data);\n\t\t\t\t\t\tif Z_REFCOUNTED(ent1->data) Z_DELREF(ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_str_update(target_hash, ent1->varname, strlen(ent1->varname), &ent1->data);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp((char *)name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp((char *)name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144523,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t*pce;\n\tzval\t\t\t\tobj;\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp((char *)name, EL_STRING) || !strcmp((char *)name, EL_NUMBER) ||\n\t\t!strcmp((char *)name, EL_BOOLEAN) || !strcmp((char *)name, EL_NULL) ||\n\t  \t!strcmp((char *)name, EL_ARRAY) || !strcmp((char *)name, EL_STRUCT) ||\n\t\t!strcmp((char *)name, EL_RECORDSET) || !strcmp((char *)name, EL_BINARY) ||\n\t\t!strcmp((char *)name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (Z_TYPE(ent1->data) == IS_UNDEF) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t\tefree(ent1);\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n \n \t\tif (!strcmp((char *)name, EL_BINARY)) {\n \t\t\tzend_string *new_str = NULL;\n\n \t\t\tif (ZSTR_EMPTY_ALLOC() != Z_STR(ent1->data)) {\n \t\t\t\tnew_str = php_base64_decode(\n \t\t\t\t\t(unsigned char *)Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\t}\n\n\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\tif (new_str) {\n\t\t\t\tZVAL_STR(&ent1->data, new_str);\n\t\t\t} else {\n\t\t\t\tZVAL_EMPTY_STRING(&ent1->data);\n\t\t\t}\n\t\t}\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE(ent1->data) == IS_OBJECT) {\n\t\t\tzval fname, retval;\n\n\t\t\tZVAL_STRING(&fname, \"__wakeup\");\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, &fname, &retval, 0, 0, 0, NULL);\n\n\t\t\tzval_ptr_dtor(&fname);\n\t\t\tzval_ptr_dtor(&retval);\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (Z_ISUNDEF(ent2->data)) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE(ent2->data) == IS_ARRAY || Z_TYPE(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(&ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE(ent1->data) == IS_STRING && Z_STRLEN(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\t\t\t\tzend_string_forget_hash_val(Z_STR(ent1->data));\n\t\t\t\t\t\tif ((pce = zend_hash_find_ptr(EG(class_table), Z_STR(ent1->data))) == NULL) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (pce != PHP_IC_ENTRY && (pce->serialize || pce->unserialize)) {\n\t\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\t\t\t\t\t\t\tZVAL_UNDEF(&ent2->data);\n \t\t\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Class %s can not be unserialized\", Z_STRVAL(ent1->data));\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\t\tif (object_init_ex(&obj, pce) != SUCCESS || EG(exception)) {\n\t\t\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\t\t\t\t\t\t\t\tZVAL_UNDEF(&ent2->data);\n\t\t\t\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Class %s can not be instantiated\", Z_STRVAL(ent1->data));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP(obj),\n\t\t\t\t\t\t\t\t\t\t\t\tZ_ARRVAL(ent2->data),\n\t\t\t\t\t\t\t\t\t\t\t\tzval_add_ref, 0);\n\n\t\t\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\t\t\tphp_store_class_name(&obj, Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\t\t\tZVAL_COPY_VALUE(&ent2->data, &obj);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE(ent2->data);\n\t\t\t\t\t\tadd_property_zval(&ent2->data, ent1->varname, &ent1->data);\n\t\t\t\t\t\tif Z_REFCOUNTED(ent1->data) Z_DELREF(ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_str_update(target_hash, ent1->varname, strlen(ent1->varname), &ent1->data);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp((char *)name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp((char *)name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144524,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int attribute_align_arg avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)\n{\n    int ret = 0;\n    int codec_init_ok = 0;\n    AVDictionary *tmp = NULL;\n    const AVPixFmtDescriptor *pixdesc;\n\n    if (avcodec_is_open(avctx))\n        return 0;\n\n    if ((!codec && !avctx->codec)) {\n        av_log(avctx, AV_LOG_ERROR, \"No codec provided to avcodec_open2()\\n\");\n        return AVERROR(EINVAL);\n    }\n    if ((codec && avctx->codec && codec != avctx->codec)) {\n        av_log(avctx, AV_LOG_ERROR, \"This AVCodecContext was allocated for %s, \"\n                                    \"but %s passed to avcodec_open2()\\n\", avctx->codec->name, codec->name);\n        return AVERROR(EINVAL);\n    }\n    if (!codec)\n        codec = avctx->codec;\n\n    if (avctx->extradata_size < 0 || avctx->extradata_size >= FF_MAX_EXTRADATA_SIZE)\n        return AVERROR(EINVAL);\n\n    if (options)\n        av_dict_copy(&tmp, *options, 0);\n\n    ff_lock_avcodec(avctx, codec);\n\n    avctx->internal = av_mallocz(sizeof(*avctx->internal));\n    if (!avctx->internal) {\n        ret = AVERROR(ENOMEM);\n        goto end;\n    }\n\n    avctx->internal->pool = av_mallocz(sizeof(*avctx->internal->pool));\n    if (!avctx->internal->pool) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->to_free = av_frame_alloc();\n    if (!avctx->internal->to_free) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->compat_decode_frame = av_frame_alloc();\n    if (!avctx->internal->compat_decode_frame) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->buffer_frame = av_frame_alloc();\n    if (!avctx->internal->buffer_frame) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->buffer_pkt = av_packet_alloc();\n    if (!avctx->internal->buffer_pkt) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->ds.in_pkt = av_packet_alloc();\n    if (!avctx->internal->ds.in_pkt) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->last_pkt_props = av_packet_alloc();\n    if (!avctx->internal->last_pkt_props) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->skip_samples_multiplier = 1;\n\n    if (codec->priv_data_size > 0) {\n        if (!avctx->priv_data) {\n            avctx->priv_data = av_mallocz(codec->priv_data_size);\n            if (!avctx->priv_data) {\n                ret = AVERROR(ENOMEM);\n                goto end;\n            }\n            if (codec->priv_class) {\n                *(const AVClass **)avctx->priv_data = codec->priv_class;\n                av_opt_set_defaults(avctx->priv_data);\n            }\n        }\n        if (codec->priv_class && (ret = av_opt_set_dict(avctx->priv_data, &tmp)) < 0)\n            goto free_and_end;\n    } else {\n        avctx->priv_data = NULL;\n    }\n    if ((ret = av_opt_set_dict(avctx, &tmp)) < 0)\n        goto free_and_end;\n\n    if (avctx->codec_whitelist && av_match_list(codec->name, avctx->codec_whitelist, ',') <= 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Codec (%s) not on whitelist \\'%s\\'\\n\", codec->name, avctx->codec_whitelist);\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n\n    // only call ff_set_dimensions() for non H.264/VP6F/DXV codecs so as not to overwrite previously setup dimensions\n    if (!(avctx->coded_width && avctx->coded_height && avctx->width && avctx->height &&\n          (avctx->codec_id == AV_CODEC_ID_H264 || avctx->codec_id == AV_CODEC_ID_VP6F || avctx->codec_id == AV_CODEC_ID_DXV))) {\n    if (avctx->coded_width && avctx->coded_height)\n        ret = ff_set_dimensions(avctx, avctx->coded_width, avctx->coded_height);\n    else if (avctx->width && avctx->height)\n        ret = ff_set_dimensions(avctx, avctx->width, avctx->height);\n    if (ret < 0)\n        goto free_and_end;\n    }\n\n    if ((avctx->coded_width || avctx->coded_height || avctx->width || avctx->height)\n        && (  av_image_check_size2(avctx->coded_width, avctx->coded_height, avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx) < 0\n           || av_image_check_size2(avctx->width,       avctx->height,       avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx) < 0)) {\n        av_log(avctx, AV_LOG_WARNING, \"Ignoring invalid width/height values\\n\");\n        ff_set_dimensions(avctx, 0, 0);\n    }\n\n    if (avctx->width > 0 && avctx->height > 0) {\n        if (av_image_check_sar(avctx->width, avctx->height,\n                               avctx->sample_aspect_ratio) < 0) {\n            av_log(avctx, AV_LOG_WARNING, \"ignoring invalid SAR: %u/%u\\n\",\n                   avctx->sample_aspect_ratio.num,\n                   avctx->sample_aspect_ratio.den);\n            avctx->sample_aspect_ratio = (AVRational){ 0, 1 };\n        }\n    }\n\n    /* if the decoder init function was already called previously,\n     * free the already allocated subtitle_header before overwriting it */\n    if (av_codec_is_decoder(codec))\n        av_freep(&avctx->subtitle_header);\n\n    if (avctx->channels > FF_SANE_NB_CHANNELS) {\n        av_log(avctx, AV_LOG_ERROR, \"Too many channels: %d\\n\", avctx->channels);\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n\n    avctx->codec = codec;\n    if ((avctx->codec_type == AVMEDIA_TYPE_UNKNOWN || avctx->codec_type == codec->type) &&\n        avctx->codec_id == AV_CODEC_ID_NONE) {\n        avctx->codec_type = codec->type;\n        avctx->codec_id   = codec->id;\n    }\n    if (avctx->codec_id != codec->id || (avctx->codec_type != codec->type\n                                         && avctx->codec_type != AVMEDIA_TYPE_ATTACHMENT)) {\n        av_log(avctx, AV_LOG_ERROR, \"Codec type or id mismatches\\n\");\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n    avctx->frame_number = 0;\n    avctx->codec_descriptor = avcodec_descriptor_get(avctx->codec_id);\n\n    if ((avctx->codec->capabilities & AV_CODEC_CAP_EXPERIMENTAL) &&\n        avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n        const char *codec_string = av_codec_is_encoder(codec) ? \"encoder\" : \"decoder\";\n        AVCodec *codec2;\n        av_log(avctx, AV_LOG_ERROR,\n               \"The %s '%s' is experimental but experimental codecs are not enabled, \"\n               \"add '-strict %d' if you want to use it.\\n\",\n               codec_string, codec->name, FF_COMPLIANCE_EXPERIMENTAL);\n        codec2 = av_codec_is_encoder(codec) ? avcodec_find_encoder(codec->id) : avcodec_find_decoder(codec->id);\n        if (!(codec2->capabilities & AV_CODEC_CAP_EXPERIMENTAL))\n            av_log(avctx, AV_LOG_ERROR, \"Alternatively use the non experimental %s '%s'.\\n\",\n                codec_string, codec2->name);\n        ret = AVERROR_EXPERIMENTAL;\n        goto free_and_end;\n    }\n\n    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO &&\n        (!avctx->time_base.num || !avctx->time_base.den)) {\n        avctx->time_base.num = 1;\n        avctx->time_base.den = avctx->sample_rate;\n    }\n\n    if (!HAVE_THREADS)\n        av_log(avctx, AV_LOG_WARNING, \"Warning: not compiled with thread support, using thread emulation\\n\");\n\n    if (CONFIG_FRAME_THREAD_ENCODER && av_codec_is_encoder(avctx->codec)) {\n        ff_unlock_avcodec(codec); //we will instantiate a few encoders thus kick the counter to prevent false detection of a problem\n        ret = ff_frame_thread_encoder_init(avctx, options ? *options : NULL);\n        ff_lock_avcodec(avctx, codec);\n        if (ret < 0)\n            goto free_and_end;\n    }\n\n    if (av_codec_is_decoder(avctx->codec)) {\n        ret = ff_decode_bsfs_init(avctx);\n        if (ret < 0)\n            goto free_and_end;\n    }\n\n    if (HAVE_THREADS\n        && !(avctx->internal->frame_thread_encoder && (avctx->active_thread_type&FF_THREAD_FRAME))) {\n        ret = ff_thread_init(avctx);\n        if (ret < 0) {\n            goto free_and_end;\n        }\n    }\n    if (!HAVE_THREADS && !(codec->capabilities & AV_CODEC_CAP_AUTO_THREADS))\n        avctx->thread_count = 1;\n\n    if (avctx->codec->max_lowres < avctx->lowres || avctx->lowres < 0) {\n        av_log(avctx, AV_LOG_WARNING, \"The maximum value for lowres supported by the decoder is %d\\n\",\n               avctx->codec->max_lowres);\n        avctx->lowres = avctx->codec->max_lowres;\n    }\n\n    if (av_codec_is_encoder(avctx->codec)) {\n        int i;\n#if FF_API_CODED_FRAME\nFF_DISABLE_DEPRECATION_WARNINGS\n        avctx->coded_frame = av_frame_alloc();\n        if (!avctx->coded_frame) {\n            ret = AVERROR(ENOMEM);\n            goto free_and_end;\n        }\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n        if (avctx->time_base.num <= 0 || avctx->time_base.den <= 0) {\n            av_log(avctx, AV_LOG_ERROR, \"The encoder timebase is not set.\\n\");\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n\n        if (avctx->codec->sample_fmts) {\n            for (i = 0; avctx->codec->sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {\n                if (avctx->sample_fmt == avctx->codec->sample_fmts[i])\n                    break;\n                if (avctx->channels == 1 &&\n                    av_get_planar_sample_fmt(avctx->sample_fmt) ==\n                    av_get_planar_sample_fmt(avctx->codec->sample_fmts[i])) {\n                    avctx->sample_fmt = avctx->codec->sample_fmts[i];\n                    break;\n                }\n            }\n            if (avctx->codec->sample_fmts[i] == AV_SAMPLE_FMT_NONE) {\n                char buf[128];\n                snprintf(buf, sizeof(buf), \"%d\", avctx->sample_fmt);\n                av_log(avctx, AV_LOG_ERROR, \"Specified sample format %s is invalid or not supported\\n\",\n                       (char *)av_x_if_null(av_get_sample_fmt_name(avctx->sample_fmt), buf));\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (avctx->codec->pix_fmts) {\n            for (i = 0; avctx->codec->pix_fmts[i] != AV_PIX_FMT_NONE; i++)\n                if (avctx->pix_fmt == avctx->codec->pix_fmts[i])\n                    break;\n            if (avctx->codec->pix_fmts[i] == AV_PIX_FMT_NONE\n                && !((avctx->codec_id == AV_CODEC_ID_MJPEG || avctx->codec_id == AV_CODEC_ID_LJPEG)\n                     && avctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL)) {\n                char buf[128];\n                snprintf(buf, sizeof(buf), \"%d\", avctx->pix_fmt);\n                av_log(avctx, AV_LOG_ERROR, \"Specified pixel format %s is invalid or not supported\\n\",\n                       (char *)av_x_if_null(av_get_pix_fmt_name(avctx->pix_fmt), buf));\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n            if (avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ420P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ411P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ422P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ440P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ444P)\n                avctx->color_range = AVCOL_RANGE_JPEG;\n        }\n        if (avctx->codec->supported_samplerates) {\n            for (i = 0; avctx->codec->supported_samplerates[i] != 0; i++)\n                if (avctx->sample_rate == avctx->codec->supported_samplerates[i])\n                    break;\n            if (avctx->codec->supported_samplerates[i] == 0) {\n                av_log(avctx, AV_LOG_ERROR, \"Specified sample rate %d is not supported\\n\",\n                       avctx->sample_rate);\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (avctx->sample_rate < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Specified sample rate %d is not supported\\n\",\n                    avctx->sample_rate);\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if (avctx->codec->channel_layouts) {\n            if (!avctx->channel_layout) {\n                av_log(avctx, AV_LOG_WARNING, \"Channel layout not specified\\n\");\n            } else {\n                for (i = 0; avctx->codec->channel_layouts[i] != 0; i++)\n                    if (avctx->channel_layout == avctx->codec->channel_layouts[i])\n                        break;\n                if (avctx->codec->channel_layouts[i] == 0) {\n                    char buf[512];\n                    av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);\n                    av_log(avctx, AV_LOG_ERROR, \"Specified channel layout '%s' is not supported\\n\", buf);\n                    ret = AVERROR(EINVAL);\n                    goto free_and_end;\n                }\n            }\n        }\n        if (avctx->channel_layout && avctx->channels) {\n            int channels = av_get_channel_layout_nb_channels(avctx->channel_layout);\n            if (channels != avctx->channels) {\n                char buf[512];\n                av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Channel layout '%s' with %d channels does not match number of specified channels %d\\n\",\n                       buf, channels, avctx->channels);\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        } else if (avctx->channel_layout) {\n            avctx->channels = av_get_channel_layout_nb_channels(avctx->channel_layout);\n        }\n        if (avctx->channels < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Specified number of channels %d is not supported\\n\",\n                    avctx->channels);\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if(avctx->codec_type == AVMEDIA_TYPE_VIDEO) {\n            pixdesc = av_pix_fmt_desc_get(avctx->pix_fmt);\n            if (    avctx->bits_per_raw_sample < 0\n                || (avctx->bits_per_raw_sample > 8 && pixdesc->comp[0].depth <= 8)) {\n                av_log(avctx, AV_LOG_WARNING, \"Specified bit depth %d not possible with the specified pixel formats depth %d\\n\",\n                    avctx->bits_per_raw_sample, pixdesc->comp[0].depth);\n                avctx->bits_per_raw_sample = pixdesc->comp[0].depth;\n            }\n            if (avctx->width <= 0 || avctx->height <= 0) {\n                av_log(avctx, AV_LOG_ERROR, \"dimensions not set\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (   (avctx->codec_type == AVMEDIA_TYPE_VIDEO || avctx->codec_type == AVMEDIA_TYPE_AUDIO)\n            && avctx->bit_rate>0 && avctx->bit_rate<1000) {\n            av_log(avctx, AV_LOG_WARNING, \"Bitrate %\"PRId64\" is extremely low, maybe you mean %\"PRId64\"k\\n\", avctx->bit_rate, avctx->bit_rate);\n        }\n\n        if (!avctx->rc_initial_buffer_occupancy)\n            avctx->rc_initial_buffer_occupancy = avctx->rc_buffer_size * 3LL / 4;\n\n        if (avctx->ticks_per_frame && avctx->time_base.num &&\n            avctx->ticks_per_frame > INT_MAX / avctx->time_base.num) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"ticks_per_frame %d too large for the timebase %d/%d.\",\n                   avctx->ticks_per_frame,\n                   avctx->time_base.num,\n                   avctx->time_base.den);\n            goto free_and_end;\n        }\n\n        if (avctx->hw_frames_ctx) {\n            AVHWFramesContext *frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n            if (frames_ctx->format != avctx->pix_fmt) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Mismatching AVCodecContext.pix_fmt and AVHWFramesContext.format\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n            if (avctx->sw_pix_fmt != AV_PIX_FMT_NONE &&\n                avctx->sw_pix_fmt != frames_ctx->sw_format) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Mismatching AVCodecContext.sw_pix_fmt (%s) \"\n                       \"and AVHWFramesContext.sw_format (%s)\\n\",\n                       av_get_pix_fmt_name(avctx->sw_pix_fmt),\n                       av_get_pix_fmt_name(frames_ctx->sw_format));\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n            avctx->sw_pix_fmt = frames_ctx->sw_format;\n        }\n    }\n\n    avctx->pts_correction_num_faulty_pts =\n    avctx->pts_correction_num_faulty_dts = 0;\n    avctx->pts_correction_last_pts =\n    avctx->pts_correction_last_dts = INT64_MIN;\n\n    if (   !CONFIG_GRAY && avctx->flags & AV_CODEC_FLAG_GRAY\n        && avctx->codec_descriptor->type == AVMEDIA_TYPE_VIDEO)\n        av_log(avctx, AV_LOG_WARNING,\n               \"gray decoding requested but not enabled at configuration time\\n\");\n\n    if (   avctx->codec->init && (!(avctx->active_thread_type&FF_THREAD_FRAME)\n        || avctx->internal->frame_thread_encoder)) {\n        ret = avctx->codec->init(avctx);\n        if (ret < 0) {\n            goto free_and_end;\n        }\n        codec_init_ok = 1;\n    }\n\n    ret=0;\n\n    if (av_codec_is_decoder(avctx->codec)) {\n        if (!avctx->bit_rate)\n            avctx->bit_rate = get_bit_rate(avctx);\n        /* validate channel layout from the decoder */\n        if (avctx->channel_layout) {\n            int channels = av_get_channel_layout_nb_channels(avctx->channel_layout);\n            if (!avctx->channels)\n                avctx->channels = channels;\n            else if (channels != avctx->channels) {\n                char buf[512];\n                av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);\n                av_log(avctx, AV_LOG_WARNING,\n                       \"Channel layout '%s' with %d channels does not match specified number of channels %d: \"\n                       \"ignoring specified channel layout\\n\",\n                       buf, channels, avctx->channels);\n                avctx->channel_layout = 0;\n            }\n        }\n        if (avctx->channels && avctx->channels < 0 ||\n            avctx->channels > FF_SANE_NB_CHANNELS) {\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if (avctx->bits_per_coded_sample < 0) {\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if (avctx->sub_charenc) {\n            if (avctx->codec_type != AVMEDIA_TYPE_SUBTITLE) {\n                av_log(avctx, AV_LOG_ERROR, \"Character encoding is only \"\n                       \"supported with subtitles codecs\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            } else if (avctx->codec_descriptor->props & AV_CODEC_PROP_BITMAP_SUB) {\n                av_log(avctx, AV_LOG_WARNING, \"Codec '%s' is bitmap-based, \"\n                       \"subtitles character encoding will be ignored\\n\",\n                       avctx->codec_descriptor->name);\n                avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_DO_NOTHING;\n            } else {\n                /* input character encoding is set for a text based subtitle\n                 * codec at this point */\n                if (avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_AUTOMATIC)\n                    avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_PRE_DECODER;\n\n                if (avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_PRE_DECODER) {\n#if CONFIG_ICONV\n                    iconv_t cd = iconv_open(\"UTF-8\", avctx->sub_charenc);\n                    if (cd == (iconv_t)-1) {\n                        ret = AVERROR(errno);\n                        av_log(avctx, AV_LOG_ERROR, \"Unable to open iconv context \"\n                               \"with input character encoding \\\"%s\\\"\\n\", avctx->sub_charenc);\n                        goto free_and_end;\n                    }\n                    iconv_close(cd);\n#else\n                    av_log(avctx, AV_LOG_ERROR, \"Character encoding subtitles \"\n                           \"conversion needs a libavcodec built with iconv support \"\n                           \"for this codec\\n\");\n                    ret = AVERROR(ENOSYS);\n                    goto free_and_end;\n#endif\n                }\n            }\n        }\n\n#if FF_API_AVCTX_TIMEBASE\n        if (avctx->framerate.num > 0 && avctx->framerate.den > 0)\n            avctx->time_base = av_inv_q(av_mul_q(avctx->framerate, (AVRational){avctx->ticks_per_frame, 1}));\n#endif\n    }\n    if (codec->priv_data_size > 0 && avctx->priv_data && codec->priv_class) {\n        av_assert0(*(const AVClass **)avctx->priv_data == codec->priv_class);\n    }\n\nend:\n    ff_unlock_avcodec(codec);\n    if (options) {\n        av_dict_free(options);\n        *options = tmp;\n    }\n\n    return ret;\nfree_and_end:\n    if (avctx->codec &&\n        (codec_init_ok ||\n         (avctx->codec->caps_internal & FF_CODEC_CAP_INIT_CLEANUP)))\n        avctx->codec->close(avctx);\n\n    if (codec->priv_class && codec->priv_data_size)\n        av_opt_free(avctx->priv_data);\n    av_opt_free(avctx);\n\n#if FF_API_CODED_FRAME\nFF_DISABLE_DEPRECATION_WARNINGS\n    av_frame_free(&avctx->coded_frame);\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n    av_dict_free(&tmp);\n    av_freep(&avctx->priv_data);\n    if (avctx->internal) {\n        av_frame_free(&avctx->internal->to_free);\n        av_frame_free(&avctx->internal->compat_decode_frame);\n        av_frame_free(&avctx->internal->buffer_frame);\n        av_packet_free(&avctx->internal->buffer_pkt);\n        av_packet_free(&avctx->internal->last_pkt_props);\n\n        av_packet_free(&avctx->internal->ds.in_pkt);\n        ff_decode_bsfs_uninit(avctx);\n\n        av_freep(&avctx->internal->pool);\n    }\n    av_freep(&avctx->internal);\n    avctx->codec = NULL;\n    goto end;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144567,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int attribute_align_arg avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)\n{\n    int ret = 0;\n    int codec_init_ok = 0;\n    AVDictionary *tmp = NULL;\n    const AVPixFmtDescriptor *pixdesc;\n\n    if (avcodec_is_open(avctx))\n        return 0;\n\n    if ((!codec && !avctx->codec)) {\n        av_log(avctx, AV_LOG_ERROR, \"No codec provided to avcodec_open2()\\n\");\n        return AVERROR(EINVAL);\n    }\n    if ((codec && avctx->codec && codec != avctx->codec)) {\n        av_log(avctx, AV_LOG_ERROR, \"This AVCodecContext was allocated for %s, \"\n                                    \"but %s passed to avcodec_open2()\\n\", avctx->codec->name, codec->name);\n        return AVERROR(EINVAL);\n    }\n    if (!codec)\n        codec = avctx->codec;\n\n    if (avctx->extradata_size < 0 || avctx->extradata_size >= FF_MAX_EXTRADATA_SIZE)\n        return AVERROR(EINVAL);\n\n    if (options)\n        av_dict_copy(&tmp, *options, 0);\n\n    ff_lock_avcodec(avctx, codec);\n\n    avctx->internal = av_mallocz(sizeof(*avctx->internal));\n    if (!avctx->internal) {\n        ret = AVERROR(ENOMEM);\n        goto end;\n    }\n\n    avctx->internal->pool = av_mallocz(sizeof(*avctx->internal->pool));\n    if (!avctx->internal->pool) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->to_free = av_frame_alloc();\n    if (!avctx->internal->to_free) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->compat_decode_frame = av_frame_alloc();\n    if (!avctx->internal->compat_decode_frame) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->buffer_frame = av_frame_alloc();\n    if (!avctx->internal->buffer_frame) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->buffer_pkt = av_packet_alloc();\n    if (!avctx->internal->buffer_pkt) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->ds.in_pkt = av_packet_alloc();\n    if (!avctx->internal->ds.in_pkt) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->last_pkt_props = av_packet_alloc();\n    if (!avctx->internal->last_pkt_props) {\n        ret = AVERROR(ENOMEM);\n        goto free_and_end;\n    }\n\n    avctx->internal->skip_samples_multiplier = 1;\n\n    if (codec->priv_data_size > 0) {\n        if (!avctx->priv_data) {\n            avctx->priv_data = av_mallocz(codec->priv_data_size);\n            if (!avctx->priv_data) {\n                ret = AVERROR(ENOMEM);\n                goto end;\n            }\n            if (codec->priv_class) {\n                *(const AVClass **)avctx->priv_data = codec->priv_class;\n                av_opt_set_defaults(avctx->priv_data);\n            }\n        }\n        if (codec->priv_class && (ret = av_opt_set_dict(avctx->priv_data, &tmp)) < 0)\n            goto free_and_end;\n    } else {\n        avctx->priv_data = NULL;\n    }\n    if ((ret = av_opt_set_dict(avctx, &tmp)) < 0)\n        goto free_and_end;\n\n    if (avctx->codec_whitelist && av_match_list(codec->name, avctx->codec_whitelist, ',') <= 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Codec (%s) not on whitelist \\'%s\\'\\n\", codec->name, avctx->codec_whitelist);\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n\n    if (!(avctx->coded_width && avctx->coded_height && avctx->width && avctx->height &&\n          (avctx->codec_id == AV_CODEC_ID_H264 || avctx->codec_id == AV_CODEC_ID_VP6F || avctx->codec_id == AV_CODEC_ID_DXV))) {\n    if (avctx->coded_width && avctx->coded_height)\n        ret = ff_set_dimensions(avctx, avctx->coded_width, avctx->coded_height);\n    else if (avctx->width && avctx->height)\n        ret = ff_set_dimensions(avctx, avctx->width, avctx->height);\n    if (ret < 0)\n        goto free_and_end;\n    }\n\n    if ((avctx->coded_width || avctx->coded_height || avctx->width || avctx->height)\n        && (  av_image_check_size2(avctx->coded_width, avctx->coded_height, avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx) < 0\n           || av_image_check_size2(avctx->width,       avctx->height,       avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx) < 0)) {\n        av_log(avctx, AV_LOG_WARNING, \"Ignoring invalid width/height values\\n\");\n        ff_set_dimensions(avctx, 0, 0);\n    }\n\n    if (avctx->width > 0 && avctx->height > 0) {\n        if (av_image_check_sar(avctx->width, avctx->height,\n                               avctx->sample_aspect_ratio) < 0) {\n            av_log(avctx, AV_LOG_WARNING, \"ignoring invalid SAR: %u/%u\\n\",\n                   avctx->sample_aspect_ratio.num,\n                   avctx->sample_aspect_ratio.den);\n            avctx->sample_aspect_ratio = (AVRational){ 0, 1 };\n        }\n    }\n\n    /* if the decoder init function was already called previously,\n     * free the already allocated subtitle_header before overwriting it */\n    if (av_codec_is_decoder(codec))\n        av_freep(&avctx->subtitle_header);\n\n    if (avctx->channels > FF_SANE_NB_CHANNELS) {\n        av_log(avctx, AV_LOG_ERROR, \"Too many channels: %d\\n\", avctx->channels);\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n\n    avctx->codec = codec;\n    if ((avctx->codec_type == AVMEDIA_TYPE_UNKNOWN || avctx->codec_type == codec->type) &&\n        avctx->codec_id == AV_CODEC_ID_NONE) {\n        avctx->codec_type = codec->type;\n        avctx->codec_id   = codec->id;\n    }\n    if (avctx->codec_id != codec->id || (avctx->codec_type != codec->type\n                                         && avctx->codec_type != AVMEDIA_TYPE_ATTACHMENT)) {\n        av_log(avctx, AV_LOG_ERROR, \"Codec type or id mismatches\\n\");\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n    avctx->frame_number = 0;\n    avctx->codec_descriptor = avcodec_descriptor_get(avctx->codec_id);\n\n    if ((avctx->codec->capabilities & AV_CODEC_CAP_EXPERIMENTAL) &&\n        avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n        const char *codec_string = av_codec_is_encoder(codec) ? \"encoder\" : \"decoder\";\n        AVCodec *codec2;\n        av_log(avctx, AV_LOG_ERROR,\n               \"The %s '%s' is experimental but experimental codecs are not enabled, \"\n               \"add '-strict %d' if you want to use it.\\n\",\n               codec_string, codec->name, FF_COMPLIANCE_EXPERIMENTAL);\n        codec2 = av_codec_is_encoder(codec) ? avcodec_find_encoder(codec->id) : avcodec_find_decoder(codec->id);\n        if (!(codec2->capabilities & AV_CODEC_CAP_EXPERIMENTAL))\n            av_log(avctx, AV_LOG_ERROR, \"Alternatively use the non experimental %s '%s'.\\n\",\n                codec_string, codec2->name);\n        ret = AVERROR_EXPERIMENTAL;\n        goto free_and_end;\n    }\n\n    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO &&\n        (!avctx->time_base.num || !avctx->time_base.den)) {\n        avctx->time_base.num = 1;\n        avctx->time_base.den = avctx->sample_rate;\n    }\n\n    if (!HAVE_THREADS)\n        av_log(avctx, AV_LOG_WARNING, \"Warning: not compiled with thread support, using thread emulation\\n\");\n\n    if (CONFIG_FRAME_THREAD_ENCODER && av_codec_is_encoder(avctx->codec)) {\n        ff_unlock_avcodec(codec); //we will instantiate a few encoders thus kick the counter to prevent false detection of a problem\n        ret = ff_frame_thread_encoder_init(avctx, options ? *options : NULL);\n        ff_lock_avcodec(avctx, codec);\n        if (ret < 0)\n            goto free_and_end;\n    }\n\n    if (av_codec_is_decoder(avctx->codec)) {\n        ret = ff_decode_bsfs_init(avctx);\n        if (ret < 0)\n            goto free_and_end;\n    }\n\n    if (HAVE_THREADS\n        && !(avctx->internal->frame_thread_encoder && (avctx->active_thread_type&FF_THREAD_FRAME))) {\n        ret = ff_thread_init(avctx);\n        if (ret < 0) {\n            goto free_and_end;\n        }\n    }\n    if (!HAVE_THREADS && !(codec->capabilities & AV_CODEC_CAP_AUTO_THREADS))\n        avctx->thread_count = 1;\n\n    if (avctx->codec->max_lowres < avctx->lowres || avctx->lowres < 0) {\n        av_log(avctx, AV_LOG_WARNING, \"The maximum value for lowres supported by the decoder is %d\\n\",\n               avctx->codec->max_lowres);\n        avctx->lowres = avctx->codec->max_lowres;\n    }\n\n    if (av_codec_is_encoder(avctx->codec)) {\n        int i;\n#if FF_API_CODED_FRAME\nFF_DISABLE_DEPRECATION_WARNINGS\n        avctx->coded_frame = av_frame_alloc();\n        if (!avctx->coded_frame) {\n            ret = AVERROR(ENOMEM);\n            goto free_and_end;\n        }\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n        if (avctx->time_base.num <= 0 || avctx->time_base.den <= 0) {\n            av_log(avctx, AV_LOG_ERROR, \"The encoder timebase is not set.\\n\");\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n\n        if (avctx->codec->sample_fmts) {\n            for (i = 0; avctx->codec->sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {\n                if (avctx->sample_fmt == avctx->codec->sample_fmts[i])\n                    break;\n                if (avctx->channels == 1 &&\n                    av_get_planar_sample_fmt(avctx->sample_fmt) ==\n                    av_get_planar_sample_fmt(avctx->codec->sample_fmts[i])) {\n                    avctx->sample_fmt = avctx->codec->sample_fmts[i];\n                    break;\n                }\n            }\n            if (avctx->codec->sample_fmts[i] == AV_SAMPLE_FMT_NONE) {\n                char buf[128];\n                snprintf(buf, sizeof(buf), \"%d\", avctx->sample_fmt);\n                av_log(avctx, AV_LOG_ERROR, \"Specified sample format %s is invalid or not supported\\n\",\n                       (char *)av_x_if_null(av_get_sample_fmt_name(avctx->sample_fmt), buf));\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (avctx->codec->pix_fmts) {\n            for (i = 0; avctx->codec->pix_fmts[i] != AV_PIX_FMT_NONE; i++)\n                if (avctx->pix_fmt == avctx->codec->pix_fmts[i])\n                    break;\n            if (avctx->codec->pix_fmts[i] == AV_PIX_FMT_NONE\n                && !((avctx->codec_id == AV_CODEC_ID_MJPEG || avctx->codec_id == AV_CODEC_ID_LJPEG)\n                     && avctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL)) {\n                char buf[128];\n                snprintf(buf, sizeof(buf), \"%d\", avctx->pix_fmt);\n                av_log(avctx, AV_LOG_ERROR, \"Specified pixel format %s is invalid or not supported\\n\",\n                       (char *)av_x_if_null(av_get_pix_fmt_name(avctx->pix_fmt), buf));\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n            if (avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ420P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ411P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ422P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ440P ||\n                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ444P)\n                avctx->color_range = AVCOL_RANGE_JPEG;\n        }\n        if (avctx->codec->supported_samplerates) {\n            for (i = 0; avctx->codec->supported_samplerates[i] != 0; i++)\n                if (avctx->sample_rate == avctx->codec->supported_samplerates[i])\n                    break;\n            if (avctx->codec->supported_samplerates[i] == 0) {\n                av_log(avctx, AV_LOG_ERROR, \"Specified sample rate %d is not supported\\n\",\n                       avctx->sample_rate);\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (avctx->sample_rate < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Specified sample rate %d is not supported\\n\",\n                    avctx->sample_rate);\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if (avctx->codec->channel_layouts) {\n            if (!avctx->channel_layout) {\n                av_log(avctx, AV_LOG_WARNING, \"Channel layout not specified\\n\");\n            } else {\n                for (i = 0; avctx->codec->channel_layouts[i] != 0; i++)\n                    if (avctx->channel_layout == avctx->codec->channel_layouts[i])\n                        break;\n                if (avctx->codec->channel_layouts[i] == 0) {\n                    char buf[512];\n                    av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);\n                    av_log(avctx, AV_LOG_ERROR, \"Specified channel layout '%s' is not supported\\n\", buf);\n                    ret = AVERROR(EINVAL);\n                    goto free_and_end;\n                }\n            }\n        }\n        if (avctx->channel_layout && avctx->channels) {\n            int channels = av_get_channel_layout_nb_channels(avctx->channel_layout);\n            if (channels != avctx->channels) {\n                char buf[512];\n                av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Channel layout '%s' with %d channels does not match number of specified channels %d\\n\",\n                       buf, channels, avctx->channels);\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        } else if (avctx->channel_layout) {\n            avctx->channels = av_get_channel_layout_nb_channels(avctx->channel_layout);\n        }\n        if (avctx->channels < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Specified number of channels %d is not supported\\n\",\n                    avctx->channels);\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if(avctx->codec_type == AVMEDIA_TYPE_VIDEO) {\n            pixdesc = av_pix_fmt_desc_get(avctx->pix_fmt);\n            if (    avctx->bits_per_raw_sample < 0\n                || (avctx->bits_per_raw_sample > 8 && pixdesc->comp[0].depth <= 8)) {\n                av_log(avctx, AV_LOG_WARNING, \"Specified bit depth %d not possible with the specified pixel formats depth %d\\n\",\n                    avctx->bits_per_raw_sample, pixdesc->comp[0].depth);\n                avctx->bits_per_raw_sample = pixdesc->comp[0].depth;\n            }\n            if (avctx->width <= 0 || avctx->height <= 0) {\n                av_log(avctx, AV_LOG_ERROR, \"dimensions not set\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (   (avctx->codec_type == AVMEDIA_TYPE_VIDEO || avctx->codec_type == AVMEDIA_TYPE_AUDIO)\n            && avctx->bit_rate>0 && avctx->bit_rate<1000) {\n            av_log(avctx, AV_LOG_WARNING, \"Bitrate %\"PRId64\" is extremely low, maybe you mean %\"PRId64\"k\\n\", avctx->bit_rate, avctx->bit_rate);\n        }\n\n        if (!avctx->rc_initial_buffer_occupancy)\n            avctx->rc_initial_buffer_occupancy = avctx->rc_buffer_size * 3LL / 4;\n\n        if (avctx->ticks_per_frame && avctx->time_base.num &&\n            avctx->ticks_per_frame > INT_MAX / avctx->time_base.num) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"ticks_per_frame %d too large for the timebase %d/%d.\",\n                   avctx->ticks_per_frame,\n                   avctx->time_base.num,\n                   avctx->time_base.den);\n            goto free_and_end;\n        }\n\n        if (avctx->hw_frames_ctx) {\n            AVHWFramesContext *frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n            if (frames_ctx->format != avctx->pix_fmt) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Mismatching AVCodecContext.pix_fmt and AVHWFramesContext.format\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n            if (avctx->sw_pix_fmt != AV_PIX_FMT_NONE &&\n                avctx->sw_pix_fmt != frames_ctx->sw_format) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Mismatching AVCodecContext.sw_pix_fmt (%s) \"\n                       \"and AVHWFramesContext.sw_format (%s)\\n\",\n                       av_get_pix_fmt_name(avctx->sw_pix_fmt),\n                       av_get_pix_fmt_name(frames_ctx->sw_format));\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n            avctx->sw_pix_fmt = frames_ctx->sw_format;\n        }\n    }\n\n    avctx->pts_correction_num_faulty_pts =\n    avctx->pts_correction_num_faulty_dts = 0;\n    avctx->pts_correction_last_pts =\n    avctx->pts_correction_last_dts = INT64_MIN;\n\n    if (   !CONFIG_GRAY && avctx->flags & AV_CODEC_FLAG_GRAY\n        && avctx->codec_descriptor->type == AVMEDIA_TYPE_VIDEO)\n        av_log(avctx, AV_LOG_WARNING,\n               \"gray decoding requested but not enabled at configuration time\\n\");\n\n    if (   avctx->codec->init && (!(avctx->active_thread_type&FF_THREAD_FRAME)\n        || avctx->internal->frame_thread_encoder)) {\n        ret = avctx->codec->init(avctx);\n        if (ret < 0) {\n            goto free_and_end;\n        }\n        codec_init_ok = 1;\n    }\n\n    ret=0;\n\n    if (av_codec_is_decoder(avctx->codec)) {\n        if (!avctx->bit_rate)\n            avctx->bit_rate = get_bit_rate(avctx);\n        /* validate channel layout from the decoder */\n        if (avctx->channel_layout) {\n            int channels = av_get_channel_layout_nb_channels(avctx->channel_layout);\n            if (!avctx->channels)\n                avctx->channels = channels;\n            else if (channels != avctx->channels) {\n                char buf[512];\n                av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);\n                av_log(avctx, AV_LOG_WARNING,\n                       \"Channel layout '%s' with %d channels does not match specified number of channels %d: \"\n                       \"ignoring specified channel layout\\n\",\n                       buf, channels, avctx->channels);\n                avctx->channel_layout = 0;\n            }\n        }\n        if (avctx->channels && avctx->channels < 0 ||\n            avctx->channels > FF_SANE_NB_CHANNELS) {\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if (avctx->bits_per_coded_sample < 0) {\n            ret = AVERROR(EINVAL);\n            goto free_and_end;\n        }\n        if (avctx->sub_charenc) {\n            if (avctx->codec_type != AVMEDIA_TYPE_SUBTITLE) {\n                av_log(avctx, AV_LOG_ERROR, \"Character encoding is only \"\n                       \"supported with subtitles codecs\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            } else if (avctx->codec_descriptor->props & AV_CODEC_PROP_BITMAP_SUB) {\n                av_log(avctx, AV_LOG_WARNING, \"Codec '%s' is bitmap-based, \"\n                       \"subtitles character encoding will be ignored\\n\",\n                       avctx->codec_descriptor->name);\n                avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_DO_NOTHING;\n            } else {\n                /* input character encoding is set for a text based subtitle\n                 * codec at this point */\n                if (avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_AUTOMATIC)\n                    avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_PRE_DECODER;\n\n                if (avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_PRE_DECODER) {\n#if CONFIG_ICONV\n                    iconv_t cd = iconv_open(\"UTF-8\", avctx->sub_charenc);\n                    if (cd == (iconv_t)-1) {\n                        ret = AVERROR(errno);\n                        av_log(avctx, AV_LOG_ERROR, \"Unable to open iconv context \"\n                               \"with input character encoding \\\"%s\\\"\\n\", avctx->sub_charenc);\n                        goto free_and_end;\n                    }\n                    iconv_close(cd);\n#else\n                    av_log(avctx, AV_LOG_ERROR, \"Character encoding subtitles \"\n                           \"conversion needs a libavcodec built with iconv support \"\n                           \"for this codec\\n\");\n                    ret = AVERROR(ENOSYS);\n                    goto free_and_end;\n#endif\n                }\n            }\n        }\n\n#if FF_API_AVCTX_TIMEBASE\n        if (avctx->framerate.num > 0 && avctx->framerate.den > 0)\n            avctx->time_base = av_inv_q(av_mul_q(avctx->framerate, (AVRational){avctx->ticks_per_frame, 1}));\n#endif\n    }\n    if (codec->priv_data_size > 0 && avctx->priv_data && codec->priv_class) {\n        av_assert0(*(const AVClass **)avctx->priv_data == codec->priv_class);\n    }\n\nend:\n    ff_unlock_avcodec(codec);\n    if (options) {\n        av_dict_free(options);\n        *options = tmp;\n    }\n \n     return ret;\n free_and_end:\n    if (avctx->codec && avctx->codec->close &&\n         (codec_init_ok ||\n          (avctx->codec->caps_internal & FF_CODEC_CAP_INIT_CLEANUP)))\n         avctx->codec->close(avctx);\n\n    if (codec->priv_class && codec->priv_data_size)\n        av_opt_free(avctx->priv_data);\n    av_opt_free(avctx);\n\n#if FF_API_CODED_FRAME\nFF_DISABLE_DEPRECATION_WARNINGS\n    av_frame_free(&avctx->coded_frame);\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n    av_dict_free(&tmp);\n    av_freep(&avctx->priv_data);\n    if (avctx->internal) {\n        av_frame_free(&avctx->internal->to_free);\n        av_frame_free(&avctx->internal->compat_decode_frame);\n        av_frame_free(&avctx->internal->buffer_frame);\n        av_packet_free(&avctx->internal->buffer_pkt);\n        av_packet_free(&avctx->internal->last_pkt_props);\n\n        av_packet_free(&avctx->internal->ds.in_pkt);\n        ff_decode_bsfs_uninit(avctx);\n\n        av_freep(&avctx->internal->pool);\n    }\n    av_freep(&avctx->internal);\n    avctx->codec = NULL;\n    goto end;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144568,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tchar *sep;\n\tlong l, n;\n\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\tfprintf(fd, \"TIFF Directory at offset 0x%I64x (%I64u)\\n\",\n\t\t(unsigned __int64) tif->tif_diroff,\n\t\t(unsigned __int64) tif->tif_diroff);\n#else\n\tfprintf(fd, \"TIFF Directory at offset 0x%llx (%llu)\\n\",\n\t\t(unsigned long long) tif->tif_diroff,\n\t\t(unsigned long long) tif->tif_diroff);\n#endif\n\tif (TIFFFieldSet(tif,FIELD_SUBFILETYPE)) {\n\t\tfprintf(fd, \"  Subfile Type:\");\n\t\tsep = \" \";\n\t\tif (td->td_subfiletype & FILETYPE_REDUCEDIMAGE) {\n\t\t\tfprintf(fd, \"%sreduced-resolution image\", sep);\n\t\t\tsep = \"/\";\n\t\t}\n\t\tif (td->td_subfiletype & FILETYPE_PAGE) {\n\t\t\tfprintf(fd, \"%smulti-page document\", sep);\n\t\t\tsep = \"/\";\n\t\t}\n\t\tif (td->td_subfiletype & FILETYPE_MASK)\n\t\t\tfprintf(fd, \"%stransparency mask\", sep);\n\t\tfprintf(fd, \" (%lu = 0x%lx)\\n\",\n\t\t    (unsigned long) td->td_subfiletype, (long) td->td_subfiletype);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS)) {\n\t\tfprintf(fd, \"  Image Width: %lu Image Length: %lu\",\n\t\t    (unsigned long) td->td_imagewidth, (unsigned long) td->td_imagelength);\n\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDEPTH))\n\t\t\tfprintf(fd, \" Image Depth: %lu\",\n\t\t\t    (unsigned long) td->td_imagedepth);\n\t\tfprintf(fd, \"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS)) {\n\t\tfprintf(fd, \"  Tile Width: %lu Tile Length: %lu\",\n\t\t    (unsigned long) td->td_tilewidth, (unsigned long) td->td_tilelength);\n\t\tif (TIFFFieldSet(tif,FIELD_TILEDEPTH))\n\t\t\tfprintf(fd, \" Tile Depth: %lu\",\n\t\t\t    (unsigned long) td->td_tiledepth);\n\t\tfprintf(fd, \"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_RESOLUTION)) {\n\t\tfprintf(fd, \"  Resolution: %g, %g\",\n\t\t    td->td_xresolution, td->td_yresolution);\n\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT)) {\n\t\t\tswitch (td->td_resolutionunit) {\n\t\t\tcase RESUNIT_NONE:\n\t\t\t\tfprintf(fd, \" (unitless)\");\n\t\t\t\tbreak;\n\t\t\tcase RESUNIT_INCH:\n\t\t\t\tfprintf(fd, \" pixels/inch\");\n\t\t\t\tbreak;\n\t\t\tcase RESUNIT_CENTIMETER:\n\t\t\t\tfprintf(fd, \" pixels/cm\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(fd, \" (unit %u = 0x%x)\",\n\t\t\t\t    td->td_resolutionunit,\n\t\t\t\t    td->td_resolutionunit);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfprintf(fd, \"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_POSITION))\n\t\tfprintf(fd, \"  Position: %g, %g\\n\",\n\t\t    td->td_xposition, td->td_yposition);\n\tif (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\n\t\tfprintf(fd, \"  Bits/Sample: %u\\n\", td->td_bitspersample);\n\tif (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT)) {\n\t\tfprintf(fd, \"  Sample Format: \");\n\t\tswitch (td->td_sampleformat) {\n\t\tcase SAMPLEFORMAT_VOID:\n\t\t\tfprintf(fd, \"void\\n\");\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_INT:\n\t\t\tfprintf(fd, \"signed integer\\n\");\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_UINT:\n\t\t\tfprintf(fd, \"unsigned integer\\n\");\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\tfprintf(fd, \"IEEE floating point\\n\");\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_COMPLEXINT:\n\t\t\tfprintf(fd, \"complex signed integer\\n\");\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_COMPLEXIEEEFP:\n\t\t\tfprintf(fd, \"complex IEEE floating point\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_sampleformat, td->td_sampleformat);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_COMPRESSION)) {\n\t\tconst TIFFCodec* c = TIFFFindCODEC(td->td_compression);\n\t\tfprintf(fd, \"  Compression Scheme: \");\n\t\tif (c)\n\t\t\tfprintf(fd, \"%s\\n\", c->name);\n\t\telse\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_compression, td->td_compression);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_PHOTOMETRIC)) {\n\t\tfprintf(fd, \"  Photometric Interpretation: \");\n\t\tif (td->td_photometric < NPHOTONAMES)\n\t\t\tfprintf(fd, \"%s\\n\", photoNames[td->td_photometric]);\n\t\telse {\n\t\t\tswitch (td->td_photometric) {\n\t\t\tcase PHOTOMETRIC_LOGL:\n\t\t\t\tfprintf(fd, \"CIE Log2(L)\\n\");\n\t\t\t\tbreak;\n\t\t\tcase PHOTOMETRIC_LOGLUV:\n\t\t\t\tfprintf(fd, \"CIE Log2(L) (u',v')\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t\t    td->td_photometric, td->td_photometric);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_EXTRASAMPLES) && td->td_extrasamples) {\n\t\tuint16 i;\n\t\tfprintf(fd, \"  Extra Samples: %u<\", td->td_extrasamples);\n\t\tsep = \"\";\n\t\tfor (i = 0; i < td->td_extrasamples; i++) {\n\t\t\tswitch (td->td_sampleinfo[i]) {\n\t\t\tcase EXTRASAMPLE_UNSPECIFIED:\n\t\t\t\tfprintf(fd, \"%sunspecified\", sep);\n\t\t\t\tbreak;\n\t\t\tcase EXTRASAMPLE_ASSOCALPHA:\n\t\t\t\tfprintf(fd, \"%sassoc-alpha\", sep);\n\t\t\t\tbreak;\n\t\t\tcase EXTRASAMPLE_UNASSALPHA:\n\t\t\t\tfprintf(fd, \"%sunassoc-alpha\", sep);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(fd, \"%s%u (0x%x)\", sep,\n\t\t\t\t    td->td_sampleinfo[i], td->td_sampleinfo[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsep = \", \";\n\t\t}\n\t\tfprintf(fd, \">\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_INKNAMES)) {\n\t\tchar* cp;\n\t\tuint16 i;\n\t\tfprintf(fd, \"  Ink Names: \");\n\t\ti = td->td_samplesperpixel;\n\t\tsep = \"\";\n\t\tfor (cp = td->td_inknames; \n\t\t     i > 0 && cp < td->td_inknames + td->td_inknameslen; \n\t\t     cp = strchr(cp,'\\0')+1, i--) {\n\t\t\tsize_t max_chars = \n\t\t\t\ttd->td_inknameslen - (cp - td->td_inknames);\n\t\t\tfputs(sep, fd);\n\t\t\t_TIFFprintAsciiBounded(fd, cp, max_chars);\n\t\t\tsep = \", \";\n\t\t}\n                fputs(\"\\n\", fd);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_THRESHHOLDING)) {\n\t\tfprintf(fd, \"  Thresholding: \");\n\t\tswitch (td->td_threshholding) {\n\t\tcase THRESHHOLD_BILEVEL:\n\t\t\tfprintf(fd, \"bilevel art scan\\n\");\n\t\t\tbreak;\n\t\tcase THRESHHOLD_HALFTONE:\n\t\t\tfprintf(fd, \"halftone or dithered scan\\n\");\n\t\t\tbreak;\n\t\tcase THRESHHOLD_ERRORDIFFUSE:\n\t\t\tfprintf(fd, \"error diffused\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_threshholding, td->td_threshholding);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_FILLORDER)) {\n\t\tfprintf(fd, \"  FillOrder: \");\n\t\tswitch (td->td_fillorder) {\n\t\tcase FILLORDER_MSB2LSB:\n\t\t\tfprintf(fd, \"msb-to-lsb\\n\");\n\t\t\tbreak;\n\t\tcase FILLORDER_LSB2MSB:\n\t\t\tfprintf(fd, \"lsb-to-msb\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_fillorder, td->td_fillorder);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING))\n        {\n\t\tfprintf(fd, \"  YCbCr Subsampling: %u, %u\\n\",\n\t\t\ttd->td_ycbcrsubsampling[0], td->td_ycbcrsubsampling[1] );\n\t}\n\tif (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING)) {\n\t\tfprintf(fd, \"  YCbCr Positioning: \");\n\t\tswitch (td->td_ycbcrpositioning) {\n\t\tcase YCBCRPOSITION_CENTERED:\n\t\t\tfprintf(fd, \"centered\\n\");\n\t\t\tbreak;\n\t\tcase YCBCRPOSITION_COSITED:\n\t\t\tfprintf(fd, \"cosited\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_ycbcrpositioning, td->td_ycbcrpositioning);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_HALFTONEHINTS))\n\t\tfprintf(fd, \"  Halftone Hints: light %u dark %u\\n\",\n\t\t    td->td_halftonehints[0], td->td_halftonehints[1]);\n\tif (TIFFFieldSet(tif,FIELD_ORIENTATION)) {\n\t\tfprintf(fd, \"  Orientation: \");\n\t\tif (td->td_orientation < NORIENTNAMES)\n\t\t\tfprintf(fd, \"%s\\n\", orientNames[td->td_orientation]);\n\t\telse\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_orientation, td->td_orientation);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\n\t\tfprintf(fd, \"  Samples/Pixel: %u\\n\", td->td_samplesperpixel);\n\tif (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP)) {\n\t\tfprintf(fd, \"  Rows/Strip: \");\n\t\tif (td->td_rowsperstrip == (uint32) -1)\n\t\t\tfprintf(fd, \"(infinite)\\n\");\n\t\telse\n\t\t\tfprintf(fd, \"%lu\\n\", (unsigned long) td->td_rowsperstrip);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE))\n\t\tfprintf(fd, \"  Min Sample Value: %u\\n\", td->td_minsamplevalue);\n\tif (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE))\n\t\tfprintf(fd, \"  Max Sample Value: %u\\n\", td->td_maxsamplevalue);\n\tif (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE)) {\n\t\tint i;\n\t\tint count = (tif->tif_flags & TIFF_PERSAMPLE) ? td->td_samplesperpixel : 1;\n\t\tfprintf(fd, \"  SMin Sample Value:\");\n\t\tfor (i = 0; i < count; ++i)\n\t\t\tfprintf(fd, \" %g\", td->td_sminsamplevalue[i]);\n\t\tfprintf(fd, \"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE)) {\n\t\tint i;\n\t\tint count = (tif->tif_flags & TIFF_PERSAMPLE) ? td->td_samplesperpixel : 1;\n\t\tfprintf(fd, \"  SMax Sample Value:\");\n\t\tfor (i = 0; i < count; ++i)\n\t\t\tfprintf(fd, \" %g\", td->td_smaxsamplevalue[i]);\n\t\tfprintf(fd, \"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_PLANARCONFIG)) {\n\t\tfprintf(fd, \"  Planar Configuration: \");\n\t\tswitch (td->td_planarconfig) {\n\t\tcase PLANARCONFIG_CONTIG:\n\t\t\tfprintf(fd, \"single image plane\\n\");\n\t\t\tbreak;\n\t\tcase PLANARCONFIG_SEPARATE:\n\t\t\tfprintf(fd, \"separate image planes\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_planarconfig, td->td_planarconfig);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_PAGENUMBER))\n\t\tfprintf(fd, \"  Page Number: %u-%u\\n\",\n\t\t    td->td_pagenumber[0], td->td_pagenumber[1]);\n\tif (TIFFFieldSet(tif,FIELD_COLORMAP)) {\n\t\tfprintf(fd, \"  Color Map: \");\n\t\tif (flags & TIFFPRINT_COLORMAP) {\n\t\t\tfprintf(fd, \"\\n\");\n\t\t\tn = 1L<<td->td_bitspersample;\n\t\t\tfor (l = 0; l < n; l++)\n\t\t\t\tfprintf(fd, \"   %5ld: %5u %5u %5u\\n\",\n\t\t\t\t    l,\n\t\t\t\t    td->td_colormap[0][l],\n\t\t\t\t    td->td_colormap[1][l],\n\t\t\t\t    td->td_colormap[2][l]);\n\t\t} else\n\t\t\tfprintf(fd, \"(present)\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_REFBLACKWHITE)) {\n\t\tint i;\n\t\tfprintf(fd, \"  Reference Black/White:\\n\");\n\t\tfor (i = 0; i < 3; i++)\n\t\tfprintf(fd, \"    %2d: %5g %5g\\n\", i,\n\t\t\ttd->td_refblackwhite[2*i+0],\n\t\t\ttd->td_refblackwhite[2*i+1]);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION)) {\n\t\tfprintf(fd, \"  Transfer Function: \");\n\t\tif (flags & TIFFPRINT_CURVES) {\n\t\t\tfprintf(fd, \"\\n\");\n\t\t\tn = 1L<<td->td_bitspersample;\n\t\t\tfor (l = 0; l < n; l++) {\n\t\t\t\tuint16 i;\n\t\t\t\tfprintf(fd, \"    %2ld: %5u\",\n\t\t\t\t    l, td->td_transferfunction[0][l]);\n\t\t\t\tfor (i = 1; i < td->td_samplesperpixel; i++)\n\t\t\t\t\tfprintf(fd, \" %5u\",\n\t\t\t\t\t    td->td_transferfunction[i][l]);\n\t\t\t\tfputc('\\n', fd);\n\t\t\t}\n\t\t} else\n\t\t\tfprintf(fd, \"(present)\\n\");\n\t}\n\tif (TIFFFieldSet(tif, FIELD_SUBIFD) && (td->td_subifd)) {\n\t\tuint16 i;\n\t\tfprintf(fd, \"  SubIFD Offsets:\");\n\t\tfor (i = 0; i < td->td_nsubifd; i++)\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tfprintf(fd, \" %5I64u\",\n\t\t\t\t(unsigned __int64) td->td_subifd[i]);\n#else\n\t\t\tfprintf(fd, \" %5llu\",\n\t\t\t\t(unsigned long long) td->td_subifd[i]);\n#endif\n\t\tfputc('\\n', fd);\n\t}\n\n\t/*\n\t** Custom tag support.\n\t*/\n\t{\n\t\tint  i;\n\t\tshort count;\n\n\t\tcount = (short) TIFFGetTagListCount(tif);\n\t\tfor(i = 0; i < count; i++) {\n\t\t\tuint32 tag = TIFFGetTagListEntry(tif, i);\n\t\t\tconst TIFFField *fip;\n\t\t\tuint32 value_count;\n\t\t\tint mem_alloc = 0;\n\t\t\tvoid *raw_data;\n\n\t\t\tfip = TIFFFieldWithTag(tif, tag);\n\t\t\tif(fip == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tif(fip->field_passcount) {\n\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE2 ) {\n\t\t\t\t\tif(TIFFGetField(tif, tag, &value_count, &raw_data) != 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else if (fip->field_readcount == TIFF_VARIABLE ) {\n\t\t\t\t\tuint16 small_value_count;\n\t\t\t\t\tif(TIFFGetField(tif, tag, &small_value_count, &raw_data) != 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvalue_count = small_value_count;\n\t\t\t\t} else {\n\t\t\t\t\tassert (fip->field_readcount == TIFF_VARIABLE\n\t\t\t\t\t\t|| fip->field_readcount == TIFF_VARIABLE2);\n\t\t\t\t\tcontinue;\n\t\t\t\t} \n\t\t\t} else {\n\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE\n\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE2)\n\t\t\t\t\tvalue_count = 1;\n\t\t\t\telse if (fip->field_readcount == TIFF_SPP)\n\t\t\t\t\tvalue_count = td->td_samplesperpixel;\n\t\t\t\telse\n\t\t\t\t\tvalue_count = fip->field_readcount;\n\t\t\t\tif (fip->field_tag == TIFFTAG_DOTRANGE\n\t\t\t\t    && strcmp(fip->field_name,\"DotRange\") == 0) {\n\t\t\t\t\t/* TODO: This is an evil exception and should not have been\n\t\t\t\t\t   handled this way ... likely best if we move it into\n\t\t\t\t\t   the directory structure with an explicit field in \n\t\t\t\t\t   libtiff 4.1 and assign it a FIELD_ value */\n\t\t\t\t\tstatic uint16 dotrange[2];\n\t\t\t\t\traw_data = dotrange;\n\t\t\t\t\tTIFFGetField(tif, tag, dotrange+0, dotrange+1);\n\t\t\t\t} else if (fip->field_type == TIFF_ASCII\n\t\t\t\t\t   || fip->field_readcount == TIFF_VARIABLE\n\t\t\t\t\t   || fip->field_readcount == TIFF_VARIABLE2\n\t\t\t\t\t   || fip->field_readcount == TIFF_SPP\n\t\t\t\t\t   || value_count > 1) {\n\t\t\t\t\tif(TIFFGetField(tif, tag, &raw_data) != 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\traw_data = _TIFFmalloc(\n\t\t\t\t\t    _TIFFDataSize(fip->field_type)\n\t\t\t\t\t    * value_count);\n\t\t\t\t\tmem_alloc = 1;\n\t\t\t\t\tif(TIFFGetField(tif, tag, raw_data) != 1) {\n\t\t\t\t\t\t_TIFFfree(raw_data);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Catch the tags which needs to be specially handled\n\t\t\t * and pretty print them. If tag not handled in\n\t\t\t * _TIFFPrettyPrintField() fall down and print it as\n\t\t\t * any other tag.\n\t\t\t */\n\t\t\tif (!_TIFFPrettyPrintField(tif, fip, fd, tag, value_count, raw_data))\n\t\t\t\t_TIFFPrintField(fd, fip, value_count, raw_data);\n\n\t\t\tif(mem_alloc)\n\t\t\t\t_TIFFfree(raw_data);\n\t\t}\n\t}\n        \n\tif (tif->tif_tagmethods.printdir)\n\t\t(*tif->tif_tagmethods.printdir)(tif, fd, flags);\n\n        _TIFFFillStriles( tif );\n        \n\tif ((flags & TIFFPRINT_STRIPS) &&\n\t    TIFFFieldSet(tif,FIELD_STRIPOFFSETS)) {\n\t\tuint32 s;\n\n\t\tfprintf(fd, \"  %lu %s:\\n\",\n\t\t    (unsigned long) td->td_nstrips,\n\t\t    isTiled(tif) ? \"Tiles\" : \"Strips\");\n\t\tfor (s = 0; s < td->td_nstrips; s++)\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tfprintf(fd, \"    %3lu: [%8I64u, %8I64u]\\n\",\n\t\t\t    (unsigned long) s,\n\t\t\t    td->td_stripoffset ? (unsigned __int64) td->td_stripoffset[s] : 0,\n\t\t\t    td->td_stripbytecount ? (unsigned __int64) td->td_stripbytecount[s] : 0);\n#else\n\t\t\tfprintf(fd, \"    %3lu: [%8llu, %8llu]\\n\",\n\t\t\t    (unsigned long) s,\n\t\t\t    td->td_stripoffset ? (unsigned long long) td->td_stripoffset[s] : 0,\n\t\t\t    td->td_stripbytecount ? (unsigned long long) td->td_stripbytecount[s] : 0);\n#endif\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144687,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tchar *sep;\n\tlong l, n;\n\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\tfprintf(fd, \"TIFF Directory at offset 0x%I64x (%I64u)\\n\",\n\t\t(unsigned __int64) tif->tif_diroff,\n\t\t(unsigned __int64) tif->tif_diroff);\n#else\n\tfprintf(fd, \"TIFF Directory at offset 0x%llx (%llu)\\n\",\n\t\t(unsigned long long) tif->tif_diroff,\n\t\t(unsigned long long) tif->tif_diroff);\n#endif\n\tif (TIFFFieldSet(tif,FIELD_SUBFILETYPE)) {\n\t\tfprintf(fd, \"  Subfile Type:\");\n\t\tsep = \" \";\n\t\tif (td->td_subfiletype & FILETYPE_REDUCEDIMAGE) {\n\t\t\tfprintf(fd, \"%sreduced-resolution image\", sep);\n\t\t\tsep = \"/\";\n\t\t}\n\t\tif (td->td_subfiletype & FILETYPE_PAGE) {\n\t\t\tfprintf(fd, \"%smulti-page document\", sep);\n\t\t\tsep = \"/\";\n\t\t}\n\t\tif (td->td_subfiletype & FILETYPE_MASK)\n\t\t\tfprintf(fd, \"%stransparency mask\", sep);\n\t\tfprintf(fd, \" (%lu = 0x%lx)\\n\",\n\t\t    (unsigned long) td->td_subfiletype, (long) td->td_subfiletype);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS)) {\n\t\tfprintf(fd, \"  Image Width: %lu Image Length: %lu\",\n\t\t    (unsigned long) td->td_imagewidth, (unsigned long) td->td_imagelength);\n\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDEPTH))\n\t\t\tfprintf(fd, \" Image Depth: %lu\",\n\t\t\t    (unsigned long) td->td_imagedepth);\n\t\tfprintf(fd, \"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS)) {\n\t\tfprintf(fd, \"  Tile Width: %lu Tile Length: %lu\",\n\t\t    (unsigned long) td->td_tilewidth, (unsigned long) td->td_tilelength);\n\t\tif (TIFFFieldSet(tif,FIELD_TILEDEPTH))\n\t\t\tfprintf(fd, \" Tile Depth: %lu\",\n\t\t\t    (unsigned long) td->td_tiledepth);\n\t\tfprintf(fd, \"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_RESOLUTION)) {\n\t\tfprintf(fd, \"  Resolution: %g, %g\",\n\t\t    td->td_xresolution, td->td_yresolution);\n\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT)) {\n\t\t\tswitch (td->td_resolutionunit) {\n\t\t\tcase RESUNIT_NONE:\n\t\t\t\tfprintf(fd, \" (unitless)\");\n\t\t\t\tbreak;\n\t\t\tcase RESUNIT_INCH:\n\t\t\t\tfprintf(fd, \" pixels/inch\");\n\t\t\t\tbreak;\n\t\t\tcase RESUNIT_CENTIMETER:\n\t\t\t\tfprintf(fd, \" pixels/cm\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(fd, \" (unit %u = 0x%x)\",\n\t\t\t\t    td->td_resolutionunit,\n\t\t\t\t    td->td_resolutionunit);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfprintf(fd, \"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_POSITION))\n\t\tfprintf(fd, \"  Position: %g, %g\\n\",\n\t\t    td->td_xposition, td->td_yposition);\n\tif (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\n\t\tfprintf(fd, \"  Bits/Sample: %u\\n\", td->td_bitspersample);\n\tif (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT)) {\n\t\tfprintf(fd, \"  Sample Format: \");\n\t\tswitch (td->td_sampleformat) {\n\t\tcase SAMPLEFORMAT_VOID:\n\t\t\tfprintf(fd, \"void\\n\");\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_INT:\n\t\t\tfprintf(fd, \"signed integer\\n\");\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_UINT:\n\t\t\tfprintf(fd, \"unsigned integer\\n\");\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\tfprintf(fd, \"IEEE floating point\\n\");\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_COMPLEXINT:\n\t\t\tfprintf(fd, \"complex signed integer\\n\");\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_COMPLEXIEEEFP:\n\t\t\tfprintf(fd, \"complex IEEE floating point\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_sampleformat, td->td_sampleformat);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_COMPRESSION)) {\n\t\tconst TIFFCodec* c = TIFFFindCODEC(td->td_compression);\n\t\tfprintf(fd, \"  Compression Scheme: \");\n\t\tif (c)\n\t\t\tfprintf(fd, \"%s\\n\", c->name);\n\t\telse\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_compression, td->td_compression);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_PHOTOMETRIC)) {\n\t\tfprintf(fd, \"  Photometric Interpretation: \");\n\t\tif (td->td_photometric < NPHOTONAMES)\n\t\t\tfprintf(fd, \"%s\\n\", photoNames[td->td_photometric]);\n\t\telse {\n\t\t\tswitch (td->td_photometric) {\n\t\t\tcase PHOTOMETRIC_LOGL:\n\t\t\t\tfprintf(fd, \"CIE Log2(L)\\n\");\n\t\t\t\tbreak;\n\t\t\tcase PHOTOMETRIC_LOGLUV:\n\t\t\t\tfprintf(fd, \"CIE Log2(L) (u',v')\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t\t    td->td_photometric, td->td_photometric);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_EXTRASAMPLES) && td->td_extrasamples) {\n\t\tuint16 i;\n\t\tfprintf(fd, \"  Extra Samples: %u<\", td->td_extrasamples);\n\t\tsep = \"\";\n\t\tfor (i = 0; i < td->td_extrasamples; i++) {\n\t\t\tswitch (td->td_sampleinfo[i]) {\n\t\t\tcase EXTRASAMPLE_UNSPECIFIED:\n\t\t\t\tfprintf(fd, \"%sunspecified\", sep);\n\t\t\t\tbreak;\n\t\t\tcase EXTRASAMPLE_ASSOCALPHA:\n\t\t\t\tfprintf(fd, \"%sassoc-alpha\", sep);\n\t\t\t\tbreak;\n\t\t\tcase EXTRASAMPLE_UNASSALPHA:\n\t\t\t\tfprintf(fd, \"%sunassoc-alpha\", sep);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(fd, \"%s%u (0x%x)\", sep,\n\t\t\t\t    td->td_sampleinfo[i], td->td_sampleinfo[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsep = \", \";\n\t\t}\n\t\tfprintf(fd, \">\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_INKNAMES)) {\n\t\tchar* cp;\n\t\tuint16 i;\n\t\tfprintf(fd, \"  Ink Names: \");\n\t\ti = td->td_samplesperpixel;\n\t\tsep = \"\";\n\t\tfor (cp = td->td_inknames; \n\t\t     i > 0 && cp < td->td_inknames + td->td_inknameslen; \n\t\t     cp = strchr(cp,'\\0')+1, i--) {\n\t\t\tsize_t max_chars = \n\t\t\t\ttd->td_inknameslen - (cp - td->td_inknames);\n\t\t\tfputs(sep, fd);\n\t\t\t_TIFFprintAsciiBounded(fd, cp, max_chars);\n\t\t\tsep = \", \";\n\t\t}\n                fputs(\"\\n\", fd);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_THRESHHOLDING)) {\n\t\tfprintf(fd, \"  Thresholding: \");\n\t\tswitch (td->td_threshholding) {\n\t\tcase THRESHHOLD_BILEVEL:\n\t\t\tfprintf(fd, \"bilevel art scan\\n\");\n\t\t\tbreak;\n\t\tcase THRESHHOLD_HALFTONE:\n\t\t\tfprintf(fd, \"halftone or dithered scan\\n\");\n\t\t\tbreak;\n\t\tcase THRESHHOLD_ERRORDIFFUSE:\n\t\t\tfprintf(fd, \"error diffused\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_threshholding, td->td_threshholding);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_FILLORDER)) {\n\t\tfprintf(fd, \"  FillOrder: \");\n\t\tswitch (td->td_fillorder) {\n\t\tcase FILLORDER_MSB2LSB:\n\t\t\tfprintf(fd, \"msb-to-lsb\\n\");\n\t\t\tbreak;\n\t\tcase FILLORDER_LSB2MSB:\n\t\t\tfprintf(fd, \"lsb-to-msb\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_fillorder, td->td_fillorder);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING))\n        {\n\t\tfprintf(fd, \"  YCbCr Subsampling: %u, %u\\n\",\n\t\t\ttd->td_ycbcrsubsampling[0], td->td_ycbcrsubsampling[1] );\n\t}\n\tif (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING)) {\n\t\tfprintf(fd, \"  YCbCr Positioning: \");\n\t\tswitch (td->td_ycbcrpositioning) {\n\t\tcase YCBCRPOSITION_CENTERED:\n\t\t\tfprintf(fd, \"centered\\n\");\n\t\t\tbreak;\n\t\tcase YCBCRPOSITION_COSITED:\n\t\t\tfprintf(fd, \"cosited\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_ycbcrpositioning, td->td_ycbcrpositioning);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_HALFTONEHINTS))\n\t\tfprintf(fd, \"  Halftone Hints: light %u dark %u\\n\",\n\t\t    td->td_halftonehints[0], td->td_halftonehints[1]);\n\tif (TIFFFieldSet(tif,FIELD_ORIENTATION)) {\n\t\tfprintf(fd, \"  Orientation: \");\n\t\tif (td->td_orientation < NORIENTNAMES)\n\t\t\tfprintf(fd, \"%s\\n\", orientNames[td->td_orientation]);\n\t\telse\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_orientation, td->td_orientation);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\n\t\tfprintf(fd, \"  Samples/Pixel: %u\\n\", td->td_samplesperpixel);\n\tif (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP)) {\n\t\tfprintf(fd, \"  Rows/Strip: \");\n\t\tif (td->td_rowsperstrip == (uint32) -1)\n\t\t\tfprintf(fd, \"(infinite)\\n\");\n\t\telse\n\t\t\tfprintf(fd, \"%lu\\n\", (unsigned long) td->td_rowsperstrip);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE))\n\t\tfprintf(fd, \"  Min Sample Value: %u\\n\", td->td_minsamplevalue);\n\tif (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE))\n\t\tfprintf(fd, \"  Max Sample Value: %u\\n\", td->td_maxsamplevalue);\n\tif (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE)) {\n\t\tint i;\n\t\tint count = (tif->tif_flags & TIFF_PERSAMPLE) ? td->td_samplesperpixel : 1;\n\t\tfprintf(fd, \"  SMin Sample Value:\");\n\t\tfor (i = 0; i < count; ++i)\n\t\t\tfprintf(fd, \" %g\", td->td_sminsamplevalue[i]);\n\t\tfprintf(fd, \"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE)) {\n\t\tint i;\n\t\tint count = (tif->tif_flags & TIFF_PERSAMPLE) ? td->td_samplesperpixel : 1;\n\t\tfprintf(fd, \"  SMax Sample Value:\");\n\t\tfor (i = 0; i < count; ++i)\n\t\t\tfprintf(fd, \" %g\", td->td_smaxsamplevalue[i]);\n\t\tfprintf(fd, \"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_PLANARCONFIG)) {\n\t\tfprintf(fd, \"  Planar Configuration: \");\n\t\tswitch (td->td_planarconfig) {\n\t\tcase PLANARCONFIG_CONTIG:\n\t\t\tfprintf(fd, \"single image plane\\n\");\n\t\t\tbreak;\n\t\tcase PLANARCONFIG_SEPARATE:\n\t\t\tfprintf(fd, \"separate image planes\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_planarconfig, td->td_planarconfig);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_PAGENUMBER))\n\t\tfprintf(fd, \"  Page Number: %u-%u\\n\",\n\t\t    td->td_pagenumber[0], td->td_pagenumber[1]);\n\tif (TIFFFieldSet(tif,FIELD_COLORMAP)) {\n\t\tfprintf(fd, \"  Color Map: \");\n\t\tif (flags & TIFFPRINT_COLORMAP) {\n\t\t\tfprintf(fd, \"\\n\");\n\t\t\tn = 1L<<td->td_bitspersample;\n\t\t\tfor (l = 0; l < n; l++)\n\t\t\t\tfprintf(fd, \"   %5ld: %5u %5u %5u\\n\",\n\t\t\t\t    l,\n\t\t\t\t    td->td_colormap[0][l],\n\t\t\t\t    td->td_colormap[1][l],\n\t\t\t\t    td->td_colormap[2][l]);\n\t\t} else\n\t\t\tfprintf(fd, \"(present)\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_REFBLACKWHITE)) {\n\t\tint i;\n\t\tfprintf(fd, \"  Reference Black/White:\\n\");\n\t\tfor (i = 0; i < 3; i++)\n\t\tfprintf(fd, \"    %2d: %5g %5g\\n\", i,\n\t\t\ttd->td_refblackwhite[2*i+0],\n\t\t\ttd->td_refblackwhite[2*i+1]);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION)) {\n\t\tfprintf(fd, \"  Transfer Function: \");\n\t\tif (flags & TIFFPRINT_CURVES) {\n\t\t\tfprintf(fd, \"\\n\");\n\t\t\tn = 1L<<td->td_bitspersample;\n\t\t\tfor (l = 0; l < n; l++) {\n\t\t\t\tuint16 i;\n\t\t\t\tfprintf(fd, \"    %2ld: %5u\",\n\t\t\t\t    l, td->td_transferfunction[0][l]);\n\t\t\t\tfor (i = 1; i < td->td_samplesperpixel - td->td_extrasamples && i < 3; i++)\n\t\t\t\t\tfprintf(fd, \" %5u\",\n\t\t\t\t\t    td->td_transferfunction[i][l]);\n\t\t\t\tfputc('\\n', fd);\n\t\t\t}\n\t\t} else\n\t\t\tfprintf(fd, \"(present)\\n\");\n\t}\n\tif (TIFFFieldSet(tif, FIELD_SUBIFD) && (td->td_subifd)) {\n\t\tuint16 i;\n\t\tfprintf(fd, \"  SubIFD Offsets:\");\n\t\tfor (i = 0; i < td->td_nsubifd; i++)\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tfprintf(fd, \" %5I64u\",\n\t\t\t\t(unsigned __int64) td->td_subifd[i]);\n#else\n\t\t\tfprintf(fd, \" %5llu\",\n\t\t\t\t(unsigned long long) td->td_subifd[i]);\n#endif\n\t\tfputc('\\n', fd);\n\t}\n\n\t/*\n\t** Custom tag support.\n\t*/\n\t{\n\t\tint  i;\n\t\tshort count;\n\n\t\tcount = (short) TIFFGetTagListCount(tif);\n\t\tfor(i = 0; i < count; i++) {\n\t\t\tuint32 tag = TIFFGetTagListEntry(tif, i);\n\t\t\tconst TIFFField *fip;\n\t\t\tuint32 value_count;\n\t\t\tint mem_alloc = 0;\n\t\t\tvoid *raw_data;\n\n\t\t\tfip = TIFFFieldWithTag(tif, tag);\n\t\t\tif(fip == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tif(fip->field_passcount) {\n\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE2 ) {\n\t\t\t\t\tif(TIFFGetField(tif, tag, &value_count, &raw_data) != 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else if (fip->field_readcount == TIFF_VARIABLE ) {\n\t\t\t\t\tuint16 small_value_count;\n\t\t\t\t\tif(TIFFGetField(tif, tag, &small_value_count, &raw_data) != 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvalue_count = small_value_count;\n\t\t\t\t} else {\n\t\t\t\t\tassert (fip->field_readcount == TIFF_VARIABLE\n\t\t\t\t\t\t|| fip->field_readcount == TIFF_VARIABLE2);\n\t\t\t\t\tcontinue;\n\t\t\t\t} \n\t\t\t} else {\n\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE\n\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE2)\n\t\t\t\t\tvalue_count = 1;\n\t\t\t\telse if (fip->field_readcount == TIFF_SPP)\n\t\t\t\t\tvalue_count = td->td_samplesperpixel;\n\t\t\t\telse\n\t\t\t\t\tvalue_count = fip->field_readcount;\n\t\t\t\tif (fip->field_tag == TIFFTAG_DOTRANGE\n\t\t\t\t    && strcmp(fip->field_name,\"DotRange\") == 0) {\n\t\t\t\t\t/* TODO: This is an evil exception and should not have been\n\t\t\t\t\t   handled this way ... likely best if we move it into\n\t\t\t\t\t   the directory structure with an explicit field in \n\t\t\t\t\t   libtiff 4.1 and assign it a FIELD_ value */\n\t\t\t\t\tstatic uint16 dotrange[2];\n\t\t\t\t\traw_data = dotrange;\n\t\t\t\t\tTIFFGetField(tif, tag, dotrange+0, dotrange+1);\n\t\t\t\t} else if (fip->field_type == TIFF_ASCII\n\t\t\t\t\t   || fip->field_readcount == TIFF_VARIABLE\n\t\t\t\t\t   || fip->field_readcount == TIFF_VARIABLE2\n\t\t\t\t\t   || fip->field_readcount == TIFF_SPP\n\t\t\t\t\t   || value_count > 1) {\n\t\t\t\t\tif(TIFFGetField(tif, tag, &raw_data) != 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\traw_data = _TIFFmalloc(\n\t\t\t\t\t    _TIFFDataSize(fip->field_type)\n\t\t\t\t\t    * value_count);\n\t\t\t\t\tmem_alloc = 1;\n\t\t\t\t\tif(TIFFGetField(tif, tag, raw_data) != 1) {\n\t\t\t\t\t\t_TIFFfree(raw_data);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Catch the tags which needs to be specially handled\n\t\t\t * and pretty print them. If tag not handled in\n\t\t\t * _TIFFPrettyPrintField() fall down and print it as\n\t\t\t * any other tag.\n\t\t\t */\n\t\t\tif (!_TIFFPrettyPrintField(tif, fip, fd, tag, value_count, raw_data))\n\t\t\t\t_TIFFPrintField(fd, fip, value_count, raw_data);\n\n\t\t\tif(mem_alloc)\n\t\t\t\t_TIFFfree(raw_data);\n\t\t}\n\t}\n        \n\tif (tif->tif_tagmethods.printdir)\n\t\t(*tif->tif_tagmethods.printdir)(tif, fd, flags);\n\n        _TIFFFillStriles( tif );\n        \n\tif ((flags & TIFFPRINT_STRIPS) &&\n\t    TIFFFieldSet(tif,FIELD_STRIPOFFSETS)) {\n\t\tuint32 s;\n\n\t\tfprintf(fd, \"  %lu %s:\\n\",\n\t\t    (unsigned long) td->td_nstrips,\n\t\t    isTiled(tif) ? \"Tiles\" : \"Strips\");\n\t\tfor (s = 0; s < td->td_nstrips; s++)\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tfprintf(fd, \"    %3lu: [%8I64u, %8I64u]\\n\",\n\t\t\t    (unsigned long) s,\n\t\t\t    td->td_stripoffset ? (unsigned __int64) td->td_stripoffset[s] : 0,\n\t\t\t    td->td_stripbytecount ? (unsigned __int64) td->td_stripbytecount[s] : 0);\n#else\n\t\t\tfprintf(fd, \"    %3lu: [%8llu, %8llu]\\n\",\n\t\t\t    (unsigned long) s,\n\t\t\t    td->td_stripoffset ? (unsigned long long) td->td_stripoffset[s] : 0,\n\t\t\t    td->td_stripbytecount ? (unsigned long long) td->td_stripbytecount[s] : 0);\n#endif\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144688,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  void Compute(OpKernelContext* context) override {\n    const float min_input = context->input(1).flat<float>()(0);\n    const float max_input = context->input(2).flat<float>()(0);\n    MaxPoolingOp<Device, T>::Compute(context);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144711,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  void Compute(OpKernelContext* context) override {\n    auto min_input_tensor = context->input(1);\n    auto max_input_tensor = context->input(2);\n    OP_REQUIRES(\n        context, min_input_tensor.NumElements() == 1,\n        errors::InvalidArgument(\n            \"min_input must be a scalar float value, got tensor with shape \",\n            min_input_tensor.shape()));\n    OP_REQUIRES(\n        context, max_input_tensor.NumElements() == 1,\n        errors::InvalidArgument(\n            \"max_input must be a scalar float value, got tensor with shape \",\n            max_input_tensor.shape()));\n    const float min_input = context->input(1).flat<float>()(0);\n    const float max_input = context->input(2).flat<float>()(0);\n    MaxPoolingOp<Device, T>::Compute(context);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144712,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "AP4_DataAtom::AP4_DataAtom(AP4_UI32 size, AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_DATA, size)\n{\n    if (size < AP4_ATOM_HEADER_SIZE+8) return;\n\n    AP4_UI32 i;\n    stream.ReadUI32(i); m_DataType = (DataType)i;\n    stream.ReadUI32(i); m_DataLang = (DataLang)i;\n\n    // the stream for the data is a substream of this source\n    AP4_Position data_offset;\n    stream.Tell(data_offset);\n    AP4_Size data_size = size-AP4_ATOM_HEADER_SIZE-8;\n    m_Source = new AP4_SubStream(stream, data_offset, data_size);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144739,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "AP4_DataAtom::AP4_DataAtom(AP4_UI32 size, AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_DATA, size),\n    m_Source(NULL)\n{\n    if (size < AP4_ATOM_HEADER_SIZE+8) return;\n\n    AP4_UI32 i;\n    stream.ReadUI32(i); m_DataType = (DataType)i;\n    stream.ReadUI32(i); m_DataLang = (DataLang)i;\n\n    // the stream for the data is a substream of this source\n    AP4_Position data_offset;\n    stream.Tell(data_offset);\n    AP4_Size data_size = size-AP4_ATOM_HEADER_SIZE-8;\n    m_Source = new AP4_SubStream(stream, data_offset, data_size);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144740,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "AP4_DataAtom::AP4_DataAtom(const AP4_MetaData::Value& value) :\n    AP4_Atom(AP4_ATOM_TYPE_DATA, AP4_ATOM_HEADER_SIZE),\n    m_DataType(DATA_TYPE_BINARY)\n{\n    AP4_MemoryByteStream* memory = new AP4_MemoryByteStream();\n    AP4_Size payload_size = 8;\n    m_Source = memory;\n    \n    switch (value.GetType()) {\n        case AP4_MetaData::Value::TYPE_STRING_UTF_8: {\n            m_DataType = DATA_TYPE_STRING_UTF_8;\n            AP4_String string_value = value.ToString();\n            if (string_value.GetLength()) {\n                memory->Write(string_value.GetChars(), string_value.GetLength());\n            }\n            payload_size += string_value.GetLength();\n            break;\n        }\n         \n        case AP4_MetaData::Value::TYPE_INT_08_BE: {\n            m_DataType = DATA_TYPE_SIGNED_INT_BE;\n            AP4_UI08 int_value = (AP4_UI08)value.ToInteger();\n            memory->Write(&int_value, 1);\n            payload_size += 1;\n            break;\n        }\n            \n        case AP4_MetaData::Value::TYPE_INT_16_BE: {\n            m_DataType = DATA_TYPE_SIGNED_INT_BE;\n            AP4_UI16 int_value = (AP4_UI16)value.ToInteger();\n            memory->Write(&int_value, 2);\n            payload_size += 2;\n            break;\n        }\n\n        case AP4_MetaData::Value::TYPE_INT_32_BE: {\n            m_DataType = DATA_TYPE_SIGNED_INT_BE;\n            AP4_UI32 int_value = (AP4_UI32)value.ToInteger();\n            memory->Write(&int_value, 4);\n            payload_size += 4;\n            break;\n        }\n\n        case AP4_MetaData::Value::TYPE_JPEG:\n            m_DataType = DATA_TYPE_JPEG;\n            // FALLTHROUGH\n        case AP4_MetaData::Value::TYPE_GIF: \n            if (m_DataType == DATA_TYPE_BINARY) m_DataType = DATA_TYPE_GIF;\n            // FALLTHROUGH\n        case AP4_MetaData::Value::TYPE_BINARY: {\n            AP4_DataBuffer buffer;\n            value.ToBytes(buffer);\n            if (buffer.GetDataSize()) {\n                memory->Write(buffer.GetData(), buffer.GetDataSize());\n            }\n            payload_size += buffer.GetDataSize();\n            break;\n        }\n\n        default:\n            break;\n    }\n    \n    const AP4_String& language = value.GetLanguage();\n    if (language == \"en\") {\n        m_DataLang = LANGUAGE_ENGLISH;\n    } else {\n        // default\n        m_DataLang = LANGUAGE_ENGLISH;\n    }\n    \n    m_Size32 += payload_size;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144741,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "AP4_DataAtom::AP4_DataAtom(const AP4_MetaData::Value& value) :\n    AP4_Atom(AP4_ATOM_TYPE_DATA, AP4_ATOM_HEADER_SIZE),\n    m_DataType(DATA_TYPE_BINARY),\n    m_Source(NULL)\n{\n    AP4_MemoryByteStream* memory = new AP4_MemoryByteStream();\n    AP4_Size payload_size = 8;\n    m_Source = memory;\n    \n    switch (value.GetType()) {\n        case AP4_MetaData::Value::TYPE_STRING_UTF_8: {\n            m_DataType = DATA_TYPE_STRING_UTF_8;\n            AP4_String string_value = value.ToString();\n            if (string_value.GetLength()) {\n                memory->Write(string_value.GetChars(), string_value.GetLength());\n            }\n            payload_size += string_value.GetLength();\n            break;\n        }\n         \n        case AP4_MetaData::Value::TYPE_INT_08_BE: {\n            m_DataType = DATA_TYPE_SIGNED_INT_BE;\n            AP4_UI08 int_value = (AP4_UI08)value.ToInteger();\n            memory->Write(&int_value, 1);\n            payload_size += 1;\n            break;\n        }\n            \n        case AP4_MetaData::Value::TYPE_INT_16_BE: {\n            m_DataType = DATA_TYPE_SIGNED_INT_BE;\n            AP4_UI16 int_value = (AP4_UI16)value.ToInteger();\n            memory->Write(&int_value, 2);\n            payload_size += 2;\n            break;\n        }\n\n        case AP4_MetaData::Value::TYPE_INT_32_BE: {\n            m_DataType = DATA_TYPE_SIGNED_INT_BE;\n            AP4_UI32 int_value = (AP4_UI32)value.ToInteger();\n            memory->Write(&int_value, 4);\n            payload_size += 4;\n            break;\n        }\n\n        case AP4_MetaData::Value::TYPE_JPEG:\n            m_DataType = DATA_TYPE_JPEG;\n            // FALLTHROUGH\n        case AP4_MetaData::Value::TYPE_GIF: \n            if (m_DataType == DATA_TYPE_BINARY) m_DataType = DATA_TYPE_GIF;\n            // FALLTHROUGH\n        case AP4_MetaData::Value::TYPE_BINARY: {\n            AP4_DataBuffer buffer;\n            value.ToBytes(buffer);\n            if (buffer.GetDataSize()) {\n                memory->Write(buffer.GetData(), buffer.GetDataSize());\n            }\n            payload_size += buffer.GetDataSize();\n            break;\n        }\n\n        default:\n            break;\n    }\n    \n    const AP4_String& language = value.GetLanguage();\n    if (language == \"en\") {\n        m_DataLang = LANGUAGE_ENGLISH;\n    } else {\n        // default\n        m_DataLang = LANGUAGE_ENGLISH;\n    }\n    \n    m_Size32 += payload_size;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144742,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "AP4_AtomFactory::CreateAtomFromStream(AP4_ByteStream& stream, \n                                      AP4_UI32        type,\n                                      AP4_UI32        size_32,\n                                      AP4_UI64        size_64,\n                                      AP4_Atom*&      atom)\n{\n    bool atom_is_large = (size_32 == 1);\n    bool force_64 = (size_32==1 && ((size_64>>32) == 0));\n    \n    // create the atom\n    if (GetContext() == AP4_ATOM_TYPE_STSD) {\n        // sample entry\n        if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n        switch (type) {\n          case AP4_ATOM_TYPE_MP4A:\n            atom = new AP4_Mp4aSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_MP4V:\n            atom = new AP4_Mp4vSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_MP4S:\n            atom = new AP4_Mp4sSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_ENCA:\n            atom = new AP4_EncaSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_ENCV:\n            atom = new AP4_EncvSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_DRMS:\n            atom = new AP4_DrmsSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_DRMI:\n            atom = new AP4_DrmiSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_AVC1:\n          case AP4_ATOM_TYPE_AVC2:\n          case AP4_ATOM_TYPE_AVC3:\n          case AP4_ATOM_TYPE_AVC4:\n          case AP4_ATOM_TYPE_DVAV:\n          case AP4_ATOM_TYPE_DVA1:\n            atom = new AP4_AvcSampleEntry(type, size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_HEV1:\n          case AP4_ATOM_TYPE_HVC1:\n          case AP4_ATOM_TYPE_DVHE:\n          case AP4_ATOM_TYPE_DVH1:\n            atom = new AP4_HevcSampleEntry(type, size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_ALAC:\n          case AP4_ATOM_TYPE_AC_3:\n          case AP4_ATOM_TYPE_EC_3:\n          case AP4_ATOM_TYPE_DTSC:\n          case AP4_ATOM_TYPE_DTSH:\n          case AP4_ATOM_TYPE_DTSL:\n          case AP4_ATOM_TYPE_DTSE:\n            atom = new AP4_AudioSampleEntry(type, size_32, stream, *this);\n            break;\n            \n          case AP4_ATOM_TYPE_RTP_:\n            atom = new AP4_RtpHintSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_STPP:\n            atom = new AP4_SubtitleSampleEntry(type, size_32, stream, *this);\n            break;\n\n          default: {\n            // try all the external type handlers\n            AP4_List<TypeHandler>::Item* handler_item = m_TypeHandlers.FirstItem();\n            while (handler_item) {\n                TypeHandler* handler = handler_item->GetData();\n                if (AP4_SUCCEEDED(handler->CreateAtom(type, size_32, stream, GetContext(), atom))) {\n                    break;\n                }\n                handler_item = handler_item->GetNext();\n            }\n\n            // no custom handler, create a generic entry\n            if (atom == NULL) {\n                atom = new AP4_UnknownSampleEntry(type, (AP4_UI32)size_64, stream);\n            }\n\n            break;\n          }\n        }\n    } else {\n        // regular atom\n        switch (type) {\n          case AP4_ATOM_TYPE_MOOV:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_MoovAtom::Create(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_MVHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_MvhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_MEHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_MehdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_MFHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_MfhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_TRAK:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TrakAtom::Create(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_TREX:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TrexAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_HDLR:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_HdlrAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_TKHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TkhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_TFHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TfhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_TRUN:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TrunAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_TFRA:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TfraAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_MFRO:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_MfroAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_MDHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_MdhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_STSD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_StsdAtom::Create(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_STSC:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_StscAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_STCO:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_StcoAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_CO64:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_Co64Atom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_STSZ:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_StszAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_STZ2:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_Stz2Atom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_STTS:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SttsAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_CTTS:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_CttsAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_STSS:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_StssAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_IODS:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_IodsAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_ESDS:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_EsdsAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_AVCC:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_AvccAtom::Create(size_32, stream);\n            break;\n            \n          case AP4_ATOM_TYPE_HVCC:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_HvccAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_DVCC:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_DvccAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_HVCE:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_HvccAtom::Create(size_32, stream);\n            atom->SetType(AP4_ATOM_TYPE_HVCE);\n            break;\n\n          case AP4_ATOM_TYPE_AVCE:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_AvccAtom::Create(size_32, stream);\n            atom->SetType(AP4_ATOM_TYPE_AVCE);\n            break;\n\n    #if !defined(AP4_CONFIG_MINI_BUILD)\n          case AP4_ATOM_TYPE_UUID: {\n              AP4_UI08 uuid[16];\n              AP4_Result result = stream.Read(uuid, 16);\n              if (AP4_FAILED(result)) return result;\n              \n              if (AP4_CompareMemory(uuid, AP4_UUID_PIFF_TRACK_ENCRYPTION_ATOM, 16) == 0) {\n                  atom = AP4_PiffTrackEncryptionAtom::Create((AP4_UI32)size_64, stream);\n              } else if (AP4_CompareMemory(uuid, AP4_UUID_PIFF_SAMPLE_ENCRYPTION_ATOM, 16) == 0) {\n                  atom = AP4_PiffSampleEncryptionAtom::Create((AP4_UI32)size_64, stream);\n              } else {\n                  atom = new AP4_UnknownUuidAtom(size_64, uuid, stream);\n              }\n              break;\n          }\n            \n          case AP4_ATOM_TYPE_8ID_:\n            atom = new AP4_NullTerminatedStringAtom(type, size_64, stream);\n            break;\n\n          case AP4_ATOM_TYPE_8BDL:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_8bdlAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_DREF:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_DrefAtom::Create(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_URL:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_UrlAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_ELST:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_ElstAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_VMHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_VmhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SMHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SmhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_NMHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_NmhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_STHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SthdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_HMHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_HmhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_FRMA:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_FrmaAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SCHM:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SchmAtom::Create(size_32, &m_ContextStack, stream);\n            break;\n\n          case AP4_ATOM_TYPE_FTYP:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_FtypAtom::Create(size_32, stream);\n            break;\n                        \n          case AP4_ATOM_TYPE_TIMS:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TimsAtom::Create(size_32, stream);\n            break;\n     \n          case AP4_ATOM_TYPE_SDP_:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SdpAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_IKMS:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_IkmsAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_ISFM:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_IsfmAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_ISLT:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_IsltAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_ODHE:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_OdheAtom::Create(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_OHDR:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_OhdrAtom::Create(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_ODDA:\n            atom = AP4_OddaAtom::Create(size_64, stream);\n            break;\n\n          case AP4_ATOM_TYPE_ODAF:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_OdafAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_GRPI:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_GrpiAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_IPRO:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_IproAtom::Create(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_RTP_:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_RtpAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_TFDT:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TfdtAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_TENC:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TencAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SENC:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SencAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SAIZ:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SaizAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SAIO:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SaioAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_PDIN:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_PdinAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_BLOC:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_BlocAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_AINF:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_AinfAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_PSSH:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_PsshAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SIDX:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SidxAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SBGP:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SbgpAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SGPD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SgpdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_MKID:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            if (GetContext() == AP4_ATOM_TYPE_MARL) {\n                atom = AP4_MkidAtom::Create(size_32, stream);\n            }\n            break;\n\n          case AP4_ATOM_TYPE_DEC3:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            if (GetContext() == AP4_ATOM_TYPE_EC_3 || GetContext() == AP4_ATOM_TYPE_ENCA) {\n                atom = AP4_Dec3Atom::Create(size_32, stream);\n            }\n            break;\n\n          // track ref types\n          case AP4_ATOM_TYPE_HINT:\n          case AP4_ATOM_TYPE_CDSC:\n          case AP4_ATOM_TYPE_SYNC:\n          case AP4_ATOM_TYPE_MPOD:\n          case AP4_ATOM_TYPE_DPND:\n          case AP4_ATOM_TYPE_IPIR:\n          case AP4_ATOM_TYPE_ALIS:\n          case AP4_ATOM_TYPE_CHAP:\n            if (GetContext() == AP4_ATOM_TYPE_TREF) {\n                if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n                atom = AP4_TrefTypeAtom::Create(type, size_32, stream);\n            }\n            break;\n\n    #endif // AP4_CONFIG_MINI_BUILD\n\n          // container atoms\n          case AP4_ATOM_TYPE_MOOF:\n          case AP4_ATOM_TYPE_MVEX:\n          case AP4_ATOM_TYPE_TRAF:\n          case AP4_ATOM_TYPE_TREF:\n          case AP4_ATOM_TYPE_MFRA:\n          case AP4_ATOM_TYPE_HNTI:\n          case AP4_ATOM_TYPE_STBL:\n          case AP4_ATOM_TYPE_MDIA:\n          case AP4_ATOM_TYPE_DINF:\n          case AP4_ATOM_TYPE_MINF:\n          case AP4_ATOM_TYPE_SCHI:\n          case AP4_ATOM_TYPE_SINF:\n          case AP4_ATOM_TYPE_UDTA:\n          case AP4_ATOM_TYPE_ILST:\n          case AP4_ATOM_TYPE_EDTS: \n          case AP4_ATOM_TYPE_MDRI:\n          case AP4_ATOM_TYPE_WAVE:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_ContainerAtom::Create(type, size_64, false, force_64, stream, *this);\n            break;\n\n          // containers, only at the top\n          case AP4_ATOM_TYPE_MARL:\n            if (GetContext() == 0) {\n                atom = AP4_ContainerAtom::Create(type, size_64, false, force_64, stream, *this);\n            }\n            break;\n            \n          // full container atoms\n          case AP4_ATOM_TYPE_META:\n          case AP4_ATOM_TYPE_ODRM:\n          case AP4_ATOM_TYPE_ODKM:\n            atom = AP4_ContainerAtom::Create(type, size_64, true, force_64, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_FREE:\n          case AP4_ATOM_TYPE_WIDE:\n          case AP4_ATOM_TYPE_MDAT:\n            // generic atoms\n            break;\n            \n          default: {\n            // try all the external type handlers\n            AP4_List<TypeHandler>::Item* handler_item = m_TypeHandlers.FirstItem();\n            while (handler_item) {\n                TypeHandler* handler = handler_item->GetData();\n                if (AP4_SUCCEEDED(handler->CreateAtom(type, size_32, stream, GetContext(), atom))) {\n                    break;\n                }\n                handler_item = handler_item->GetNext();\n            }\n\n            break;\n          }\n        }\n    }\n    \n    return AP4_SUCCESS;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144745,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "AP4_AtomFactory::CreateAtomFromStream(AP4_ByteStream& stream, \n                                      AP4_UI32        type,\n                                      AP4_UI32        size_32,\n                                      AP4_UI64        size_64,\n                                      AP4_Atom*&      atom)\n{\n    bool atom_is_large = (size_32 == 1);\n    bool force_64 = (size_32==1 && ((size_64>>32) == 0));\n    \n    // create the atom\n    if (GetContext() == AP4_ATOM_TYPE_STSD) {\n        // sample entry\n        if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n        switch (type) {\n          case AP4_ATOM_TYPE_MP4A:\n            atom = new AP4_Mp4aSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_MP4V:\n            atom = new AP4_Mp4vSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_MP4S:\n            atom = new AP4_Mp4sSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_ENCA:\n            atom = new AP4_EncaSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_ENCV:\n            atom = new AP4_EncvSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_DRMS:\n            atom = new AP4_DrmsSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_DRMI:\n            atom = new AP4_DrmiSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_AVC1:\n          case AP4_ATOM_TYPE_AVC2:\n          case AP4_ATOM_TYPE_AVC3:\n          case AP4_ATOM_TYPE_AVC4:\n          case AP4_ATOM_TYPE_DVAV:\n          case AP4_ATOM_TYPE_DVA1:\n            atom = new AP4_AvcSampleEntry(type, size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_HEV1:\n          case AP4_ATOM_TYPE_HVC1:\n          case AP4_ATOM_TYPE_DVHE:\n          case AP4_ATOM_TYPE_DVH1:\n            atom = new AP4_HevcSampleEntry(type, size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_ALAC:\n          case AP4_ATOM_TYPE_AC_3:\n          case AP4_ATOM_TYPE_EC_3:\n          case AP4_ATOM_TYPE_DTSC:\n          case AP4_ATOM_TYPE_DTSH:\n          case AP4_ATOM_TYPE_DTSL:\n          case AP4_ATOM_TYPE_DTSE:\n            atom = new AP4_AudioSampleEntry(type, size_32, stream, *this);\n            break;\n            \n          case AP4_ATOM_TYPE_RTP_:\n            atom = new AP4_RtpHintSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_STPP:\n            atom = new AP4_SubtitleSampleEntry(type, size_32, stream, *this);\n            break;\n\n          default: {\n            // try all the external type handlers\n            AP4_List<TypeHandler>::Item* handler_item = m_TypeHandlers.FirstItem();\n            while (handler_item) {\n                TypeHandler* handler = handler_item->GetData();\n                if (AP4_SUCCEEDED(handler->CreateAtom(type, size_32, stream, GetContext(), atom))) {\n                    break;\n                }\n                handler_item = handler_item->GetNext();\n            }\n\n            // no custom handler, create a generic entry\n            if (atom == NULL) {\n                atom = new AP4_UnknownSampleEntry(type, (AP4_UI32)size_64, stream);\n            }\n\n            break;\n          }\n        }\n    } else {\n        // regular atom\n        switch (type) {\n          case AP4_ATOM_TYPE_MOOV:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_MoovAtom::Create(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_MVHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_MvhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_MEHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_MehdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_MFHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_MfhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_TRAK:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TrakAtom::Create(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_TREX:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TrexAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_HDLR:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_HdlrAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_TKHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TkhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_TFHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TfhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_TRUN:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TrunAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_TFRA:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TfraAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_MFRO:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_MfroAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_MDHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_MdhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_STSD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_StsdAtom::Create(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_STSC:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_StscAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_STCO:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_StcoAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_CO64:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_Co64Atom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_STSZ:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_StszAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_STZ2:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_Stz2Atom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_STTS:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SttsAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_CTTS:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_CttsAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_STSS:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_StssAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_IODS:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_IodsAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_ESDS:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_EsdsAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_AVCC:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_AvccAtom::Create(size_32, stream);\n            break;\n            \n          case AP4_ATOM_TYPE_HVCC:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_HvccAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_DVCC:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_DvccAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_HVCE:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_HvccAtom::Create(size_32, stream);\n            if (atom) {\n                atom->SetType(AP4_ATOM_TYPE_HVCE);\n            }\n            break;\n\n          case AP4_ATOM_TYPE_AVCE:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_AvccAtom::Create(size_32, stream);\n            if (atom) {\n                atom->SetType(AP4_ATOM_TYPE_AVCE);\n            }\n            break;\n\n    #if !defined(AP4_CONFIG_MINI_BUILD)\n          case AP4_ATOM_TYPE_UUID: {\n              AP4_UI08 uuid[16];\n              AP4_Result result = stream.Read(uuid, 16);\n              if (AP4_FAILED(result)) return result;\n              \n              if (AP4_CompareMemory(uuid, AP4_UUID_PIFF_TRACK_ENCRYPTION_ATOM, 16) == 0) {\n                  atom = AP4_PiffTrackEncryptionAtom::Create((AP4_UI32)size_64, stream);\n              } else if (AP4_CompareMemory(uuid, AP4_UUID_PIFF_SAMPLE_ENCRYPTION_ATOM, 16) == 0) {\n                  atom = AP4_PiffSampleEncryptionAtom::Create((AP4_UI32)size_64, stream);\n              } else {\n                  atom = new AP4_UnknownUuidAtom(size_64, uuid, stream);\n              }\n              break;\n          }\n            \n          case AP4_ATOM_TYPE_8ID_:\n            atom = new AP4_NullTerminatedStringAtom(type, size_64, stream);\n            break;\n\n          case AP4_ATOM_TYPE_8BDL:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_8bdlAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_DREF:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_DrefAtom::Create(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_URL:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_UrlAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_ELST:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_ElstAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_VMHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_VmhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SMHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SmhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_NMHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_NmhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_STHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SthdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_HMHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_HmhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_FRMA:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_FrmaAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SCHM:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SchmAtom::Create(size_32, &m_ContextStack, stream);\n            break;\n\n          case AP4_ATOM_TYPE_FTYP:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_FtypAtom::Create(size_32, stream);\n            break;\n                        \n          case AP4_ATOM_TYPE_TIMS:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TimsAtom::Create(size_32, stream);\n            break;\n     \n          case AP4_ATOM_TYPE_SDP_:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SdpAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_IKMS:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_IkmsAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_ISFM:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_IsfmAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_ISLT:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_IsltAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_ODHE:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_OdheAtom::Create(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_OHDR:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_OhdrAtom::Create(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_ODDA:\n            atom = AP4_OddaAtom::Create(size_64, stream);\n            break;\n\n          case AP4_ATOM_TYPE_ODAF:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_OdafAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_GRPI:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_GrpiAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_IPRO:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_IproAtom::Create(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_RTP_:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_RtpAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_TFDT:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TfdtAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_TENC:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TencAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SENC:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SencAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SAIZ:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SaizAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SAIO:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SaioAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_PDIN:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_PdinAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_BLOC:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_BlocAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_AINF:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_AinfAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_PSSH:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_PsshAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SIDX:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SidxAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SBGP:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SbgpAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SGPD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SgpdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_MKID:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            if (GetContext() == AP4_ATOM_TYPE_MARL) {\n                atom = AP4_MkidAtom::Create(size_32, stream);\n            }\n            break;\n\n          case AP4_ATOM_TYPE_DEC3:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            if (GetContext() == AP4_ATOM_TYPE_EC_3 || GetContext() == AP4_ATOM_TYPE_ENCA) {\n                atom = AP4_Dec3Atom::Create(size_32, stream);\n            }\n            break;\n\n          // track ref types\n          case AP4_ATOM_TYPE_HINT:\n          case AP4_ATOM_TYPE_CDSC:\n          case AP4_ATOM_TYPE_SYNC:\n          case AP4_ATOM_TYPE_MPOD:\n          case AP4_ATOM_TYPE_DPND:\n          case AP4_ATOM_TYPE_IPIR:\n          case AP4_ATOM_TYPE_ALIS:\n          case AP4_ATOM_TYPE_CHAP:\n            if (GetContext() == AP4_ATOM_TYPE_TREF) {\n                if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n                atom = AP4_TrefTypeAtom::Create(type, size_32, stream);\n            }\n            break;\n\n    #endif // AP4_CONFIG_MINI_BUILD\n\n          // container atoms\n          case AP4_ATOM_TYPE_MOOF:\n          case AP4_ATOM_TYPE_MVEX:\n          case AP4_ATOM_TYPE_TRAF:\n          case AP4_ATOM_TYPE_TREF:\n          case AP4_ATOM_TYPE_MFRA:\n          case AP4_ATOM_TYPE_HNTI:\n          case AP4_ATOM_TYPE_STBL:\n          case AP4_ATOM_TYPE_MDIA:\n          case AP4_ATOM_TYPE_DINF:\n          case AP4_ATOM_TYPE_MINF:\n          case AP4_ATOM_TYPE_SCHI:\n          case AP4_ATOM_TYPE_SINF:\n          case AP4_ATOM_TYPE_UDTA:\n          case AP4_ATOM_TYPE_ILST:\n          case AP4_ATOM_TYPE_EDTS: \n          case AP4_ATOM_TYPE_MDRI:\n          case AP4_ATOM_TYPE_WAVE:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_ContainerAtom::Create(type, size_64, false, force_64, stream, *this);\n            break;\n\n          // containers, only at the top\n          case AP4_ATOM_TYPE_MARL:\n            if (GetContext() == 0) {\n                atom = AP4_ContainerAtom::Create(type, size_64, false, force_64, stream, *this);\n            }\n            break;\n            \n          // full container atoms\n          case AP4_ATOM_TYPE_META:\n          case AP4_ATOM_TYPE_ODRM:\n          case AP4_ATOM_TYPE_ODKM:\n            atom = AP4_ContainerAtom::Create(type, size_64, true, force_64, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_FREE:\n          case AP4_ATOM_TYPE_WIDE:\n          case AP4_ATOM_TYPE_MDAT:\n            // generic atoms\n            break;\n            \n          default: {\n            // try all the external type handlers\n            AP4_List<TypeHandler>::Item* handler_item = m_TypeHandlers.FirstItem();\n            while (handler_item) {\n                TypeHandler* handler = handler_item->GetData();\n                if (AP4_SUCCEEDED(handler->CreateAtom(type, size_32, stream, GetContext(), atom))) {\n                    break;\n                }\n                handler_item = handler_item->GetNext();\n            }\n\n            break;\n          }\n        }\n    }\n    \n    return AP4_SUCCESS;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144746,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "AP4_AtomSampleTable::GetSample(AP4_Ordinal index, \n                               AP4_Sample& sample)\n{\n    AP4_Result result;\n\n    // check that we have an stsc atom\n    if (!m_StscAtom) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n    \n    // check that we have a chunk offset table\n    if (m_StcoAtom == NULL && m_Co64Atom == NULL) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n\n    // MP4 uses 1-based indexes internally, so adjust by one\n    index++;\n\n    // find out in which chunk this sample is located\n    AP4_Ordinal chunk, skip, desc;\n    result = m_StscAtom->GetChunkForSample(index, chunk, skip, desc);\n    if (AP4_FAILED(result)) return result;\n    \n    // check that the result is within bounds\n    if (skip > index) return AP4_ERROR_INTERNAL;\n\n    // get the atom offset for this chunk\n    AP4_UI64 offset;\n    if (m_StcoAtom) {\n        AP4_UI32 offset_32;\n        result = m_StcoAtom->GetChunkOffset(chunk, offset_32);\n        offset = offset_32;\n    } else {\n        result = m_Co64Atom->GetChunkOffset(chunk, offset);\n    }\n    if (AP4_FAILED(result)) return result;\n    \n    // compute the additional offset inside the chunk\n    for (unsigned int i = index-skip; i < index; i++) {\n        AP4_Size size = 0;\n        if (m_StszAtom) {\n            result = m_StszAtom->GetSampleSize(i, size); \n        } else if (m_Stz2Atom) {\n            result = m_Stz2Atom->GetSampleSize(i, size); \n        } else {\n            result = AP4_ERROR_INVALID_FORMAT;\n        }\n        if (AP4_FAILED(result)) return result;\n        offset += size;\n    }\n\n    // set the description index\n    sample.SetDescriptionIndex(desc-1); // adjust for 0-based indexes\n\n    // set the dts and cts\n    AP4_UI32 cts_offset = 0;\n    AP4_UI64 dts        = 0;\n    AP4_UI32 duration   = 0;\n    result = m_SttsAtom->GetDts(index, dts, &duration);\n    if (AP4_FAILED(result)) return result;\n    sample.SetDuration(duration);\n    sample.SetDts(dts);\n    if (m_CttsAtom == NULL) {\n        sample.SetCts(dts);\n    } else {\n        result = m_CttsAtom->GetCtsOffset(index, cts_offset); \n\t    if (AP4_FAILED(result)) return result;\n        sample.SetCtsDelta(cts_offset);\n    }     \n\n    // set the size\n    AP4_Size sample_size = 0;\n    if (m_StszAtom) {\n        result = m_StszAtom->GetSampleSize(index, sample_size); \n    } else if (m_Stz2Atom) {\n        result = m_Stz2Atom->GetSampleSize(index, sample_size); \n    } else {\n        result = AP4_ERROR_INVALID_FORMAT;\n    }\n    if (AP4_FAILED(result)) return result;\n    sample.SetSize(sample_size);\n\n    // set the sync flag\n    if (m_StssAtom == NULL) {\n        sample.SetSync(true);\n    } else {\n        sample.SetSync(m_StssAtom->IsSampleSync(index));\n    }\n\n    // set the offset\n    sample.SetOffset(offset);\n\n    // set the data stream\n    sample.SetDataStream(m_SampleStream);\n\n\n    return AP4_SUCCESS;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144773,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "AP4_AtomSampleTable::GetSample(AP4_Ordinal index, \n                               AP4_Sample& sample)\n{\n    AP4_Result result;\n\n    // check that we have an stsc atom\n    if (!m_StscAtom) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n    \n    // check that we have a chunk offset table\n    if (m_StcoAtom == NULL && m_Co64Atom == NULL) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n\n    // MP4 uses 1-based indexes internally, so adjust by one\n    index++;\n\n    // find out in which chunk this sample is located\n    AP4_Ordinal chunk, skip, desc;\n    result = m_StscAtom->GetChunkForSample(index, chunk, skip, desc);\n    if (AP4_FAILED(result)) return result;\n    \n    // check that the result is within bounds\n    if (skip > index) return AP4_ERROR_INTERNAL;\n\n    // get the atom offset for this chunk\n    AP4_UI64 offset;\n    if (m_StcoAtom) {\n        AP4_UI32 offset_32;\n        result = m_StcoAtom->GetChunkOffset(chunk, offset_32);\n        offset = offset_32;\n    } else {\n        result = m_Co64Atom->GetChunkOffset(chunk, offset);\n    }\n    if (AP4_FAILED(result)) return result;\n    \n    // compute the additional offset inside the chunk\n    for (unsigned int i = index-skip; i < index; i++) {\n        AP4_Size size = 0;\n        if (m_StszAtom) {\n            result = m_StszAtom->GetSampleSize(i, size); \n        } else if (m_Stz2Atom) {\n            result = m_Stz2Atom->GetSampleSize(i, size); \n        } else {\n            result = AP4_ERROR_INVALID_FORMAT;\n        }\n        if (AP4_FAILED(result)) return result;\n        offset += size;\n    }\n\n    // set the description index\n    sample.SetDescriptionIndex(desc-1); // adjust for 0-based indexes\n\n    // set the dts and cts\n    AP4_UI32 cts_offset = 0;\n    AP4_UI64 dts        = 0;\n    AP4_UI32 duration   = 0;\n    if (m_SttsAtom) {\n        result = m_SttsAtom->GetDts(index, dts, &duration);\n        if (AP4_FAILED(result)) return result;\n    }\n    sample.SetDuration(duration);\n    sample.SetDts(dts);\n    if (m_CttsAtom == NULL) {\n        sample.SetCts(dts);\n    } else {\n        result = m_CttsAtom->GetCtsOffset(index, cts_offset); \n\t    if (AP4_FAILED(result)) return result;\n        sample.SetCtsDelta(cts_offset);\n    }     \n\n    // set the size\n    AP4_Size sample_size = 0;\n    if (m_StszAtom) {\n        result = m_StszAtom->GetSampleSize(index, sample_size); \n    } else if (m_Stz2Atom) {\n        result = m_Stz2Atom->GetSampleSize(index, sample_size); \n    } else {\n        result = AP4_ERROR_INVALID_FORMAT;\n    }\n    if (AP4_FAILED(result)) return result;\n    sample.SetSize(sample_size);\n\n    // set the sync flag\n    if (m_StssAtom == NULL) {\n        sample.SetSync(true);\n    } else {\n        sample.SetSync(m_StssAtom->IsSampleSync(index));\n    }\n\n    // set the offset\n    sample.SetOffset(offset);\n\n    // set the data stream\n    sample.SetDataStream(m_SampleStream);\n\n\n    return AP4_SUCCESS;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144774,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  std::shared_ptr<Grammar> perform_core(const char *s, size_t n,\n                                        const Rules &rules, std::string &start,\n                                        Log log) {\n    Data data;\n    any dt = &data;\n    auto r = g[\"Grammar\"].parse(s, n, dt);\n\n    if (!r.ret) {\n      if (log) {\n        if (r.message_pos) {\n          auto line = line_info(s, r.message_pos);\n          log(line.first, line.second, r.message);\n        } else {\n          auto line = line_info(s, r.error_pos);\n          log(line.first, line.second, \"syntax error\");\n        }\n      }\n      return nullptr;\n    }\n\n    auto &grammar = *data.grammar;\n\n    // User provided rules\n    for (const auto &x : rules) {\n      auto name = x.first;\n      bool ignore = false;\n      if (!name.empty() && name[0] == '~') {\n        ignore = true;\n        name.erase(0, 1);\n      }\n      if (!name.empty()) {\n        auto &rule = grammar[name];\n        rule <= x.second;\n        rule.name = name;\n        rule.ignoreSemanticValue = ignore;\n      }\n    }\n\n    // Check duplicated definitions\n    bool ret = data.duplicates.empty();\n\n    for (const auto &x : data.duplicates) {\n      if (log) {\n        const auto &name = x.first;\n        auto ptr = x.second;\n        auto line = line_info(s, ptr);\n        log(line.first, line.second, \"'\" + name + \"' is already defined.\");\n      }\n    }\n\n    // Check missing definitions\n    for (auto &x : grammar) {\n      auto &rule = x.second;\n\n      ReferenceChecker vis(*data.grammar, rule.params);\n      rule.accept(vis);\n      for (const auto &y : vis.error_s) {\n        const auto &name = y.first;\n        const auto ptr = y.second;\n        if (log) {\n          auto line = line_info(s, ptr);\n          log(line.first, line.second, vis.error_message[name]);\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Link references\n    for (auto &x : grammar) {\n      auto &rule = x.second;\n      LinkReferences vis(*data.grammar, rule.params);\n      rule.accept(vis);\n    }\n\n    // Check left recursion\n    ret = true;\n\n    for (auto &x : grammar) {\n      const auto &name = x.first;\n      auto &rule = x.second;\n\n      DetectLeftRecursion vis(name);\n      rule.accept(vis);\n      if (vis.error_s) {\n        if (log) {\n          auto line = line_info(s, vis.error_s);\n          log(line.first, line.second, \"'\" + name + \"' is left recursive.\");\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Set root definition\n    auto &start_rule = (*data.grammar)[data.start];\n\n    // Check infinite loop\n    {\n      DetectInfiniteLoop vis(data.start_pos, data.start);\n      start_rule.accept(vis);\n      if (vis.has_error) {\n        if (log) {\n          auto line = line_info(s, vis.error_s);\n          log(line.first, line.second,\n              \"infinite loop is detected in '\" + vis.error_name + \"'.\");\n        }\n        return nullptr;\n      }\n    }\n\n    // Automatic whitespace skipping\n    if (grammar.count(WHITESPACE_DEFINITION_NAME)) {\n      for (auto &x : grammar) {\n        auto &rule = x.second;\n        auto ope = rule.get_core_operator();\n        if (IsLiteralToken::check(*ope)) { rule <= tok(ope); }\n      }\n\n      start_rule.whitespaceOpe =\n          wsp((*data.grammar)[WHITESPACE_DEFINITION_NAME].get_core_operator());\n    }\n\n    // Word expression\n    if (grammar.count(WORD_DEFINITION_NAME)) {\n      start_rule.wordOpe =\n          (*data.grammar)[WORD_DEFINITION_NAME].get_core_operator();\n    }\n\n    // Apply instructions\n    for (const auto &item : data.instructions) {\n      const auto &name = item.first;\n      const auto &instruction = item.second;\n      auto &rule = grammar[name];\n\n      if (instruction.type == \"precedence\") {\n        const auto &info =\n            any_cast<PrecedenceClimbing::BinOpeInfo>(instruction.data);\n\n        if (!apply_precedence_instruction(rule, info, s, log)) {\n          return nullptr;\n        }\n      }\n    }\n\n    // Set root definition\n    start = data.start;\n\n    return data.grammar;\n  }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144836,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  std::shared_ptr<Grammar> perform_core(const char *s, size_t n,\n                                        const Rules &rules, std::string &start,\n                                        Log log) {\n    Data data;\n    any dt = &data;\n    auto r = g[\"Grammar\"].parse(s, n, dt);\n\n    if (!r.ret) {\n      if (log) {\n        if (r.message_pos) {\n          auto line = line_info(s, r.message_pos);\n          log(line.first, line.second, r.message);\n        } else {\n          auto line = line_info(s, r.error_pos);\n          log(line.first, line.second, \"syntax error\");\n        }\n      }\n      return nullptr;\n    }\n\n    auto &grammar = *data.grammar;\n\n    // User provided rules\n    for (const auto &x : rules) {\n      auto name = x.first;\n      bool ignore = false;\n      if (!name.empty() && name[0] == '~') {\n        ignore = true;\n        name.erase(0, 1);\n      }\n      if (!name.empty()) {\n        auto &rule = grammar[name];\n        rule <= x.second;\n        rule.name = name;\n        rule.ignoreSemanticValue = ignore;\n      }\n    }\n\n    // Check duplicated definitions\n    bool ret = data.duplicates.empty();\n\n    for (const auto &x : data.duplicates) {\n      if (log) {\n        const auto &name = x.first;\n        auto ptr = x.second;\n        auto line = line_info(s, ptr);\n        log(line.first, line.second, \"'\" + name + \"' is already defined.\");\n      }\n    }\n\n    // Check if the start rule has ignore operator\n    {\n      auto &rule = grammar[data.start];\n      if (rule.ignoreSemanticValue) {\n        if (log) {\n          auto line = line_info(s, rule.s_);\n          log(line.first, line.second,\n              \"Ignore operator cannot be applied to '\" + rule.name + \"'.\");\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Check missing definitions\n    for (auto &x : grammar) {\n      auto &rule = x.second;\n\n      ReferenceChecker vis(*data.grammar, rule.params);\n      rule.accept(vis);\n      for (const auto &y : vis.error_s) {\n        const auto &name = y.first;\n        const auto ptr = y.second;\n        if (log) {\n          auto line = line_info(s, ptr);\n          log(line.first, line.second, vis.error_message[name]);\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Link references\n    for (auto &x : grammar) {\n      auto &rule = x.second;\n      LinkReferences vis(*data.grammar, rule.params);\n      rule.accept(vis);\n    }\n\n    // Check left recursion\n    ret = true;\n\n    for (auto &x : grammar) {\n      const auto &name = x.first;\n      auto &rule = x.second;\n\n      DetectLeftRecursion vis(name);\n      rule.accept(vis);\n      if (vis.error_s) {\n        if (log) {\n          auto line = line_info(s, vis.error_s);\n          log(line.first, line.second, \"'\" + name + \"' is left recursive.\");\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Set root definition\n    auto &start_rule = (*data.grammar)[data.start];\n\n    // Check infinite loop\n    {\n      DetectInfiniteLoop vis(data.start_pos, data.start);\n      start_rule.accept(vis);\n      if (vis.has_error) {\n        if (log) {\n          auto line = line_info(s, vis.error_s);\n          log(line.first, line.second,\n              \"infinite loop is detected in '\" + vis.error_name + \"'.\");\n        }\n        return nullptr;\n      }\n    }\n\n    // Automatic whitespace skipping\n    if (grammar.count(WHITESPACE_DEFINITION_NAME)) {\n      for (auto &x : grammar) {\n        auto &rule = x.second;\n        auto ope = rule.get_core_operator();\n        if (IsLiteralToken::check(*ope)) { rule <= tok(ope); }\n      }\n\n      start_rule.whitespaceOpe =\n          wsp((*data.grammar)[WHITESPACE_DEFINITION_NAME].get_core_operator());\n    }\n\n    // Word expression\n    if (grammar.count(WORD_DEFINITION_NAME)) {\n      start_rule.wordOpe =\n          (*data.grammar)[WORD_DEFINITION_NAME].get_core_operator();\n    }\n\n    // Apply instructions\n    for (const auto &item : data.instructions) {\n      const auto &name = item.first;\n      const auto &instruction = item.second;\n      auto &rule = grammar[name];\n\n      if (instruction.type == \"precedence\") {\n        const auto &info =\n            any_cast<PrecedenceClimbing::BinOpeInfo>(instruction.data);\n\n        if (!apply_precedence_instruction(rule, info, s, log)) {\n          return nullptr;\n        }\n      }\n    }\n\n    // Set root definition\n    start = data.start;\n\n    return data.grammar;\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144837,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err ilst_item_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 sub_type;\n\tGF_Box *a = NULL;\n\tGF_ListItemBox *ptr = (GF_ListItemBox *)s;\n\t/*iTunes way: there's a data atom containing the data*/\n\tsub_type = gf_bs_peek_bits(bs, 32, 4);\n\tif (sub_type == GF_ISOM_BOX_TYPE_DATA ) {\n\t\te = gf_isom_box_parse(&a, bs);\n\n\t\tif (!e && ptr->size < a->size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d)\\n\", gf_4cc_to_str(ptr->type), ptr->size, a->size, __FILE__, __LINE__ )); \\\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (e) {\n\t\t\tif (a) gf_isom_box_del(a);\n\t\t\treturn e;\n\t\t}\n\n\t\tISOM_DECREASE_SIZE(ptr, a->size);\n\n\t\tif (a && ptr->data) gf_isom_box_del_parent(&ptr->child_boxes, (GF_Box *) ptr->data);\n\n\t\t/* otherwise a->data will always overflow */\n\t\tif (a && a->size > 4 && a->type != GF_ISOM_BOX_TYPE_VOID) {\n\t\t\tptr->data = (GF_DataBox *)a;\n\t\t\tif (!ptr->child_boxes) ptr->child_boxes = gf_list_new();\n\t\t\tgf_list_add(ptr->child_boxes, ptr->data);\n\t\t} else {\n\t\t\tptr->data = NULL;\n\t\t\tgf_isom_box_del(a);\n\t\t}\n\t}\n\t/*QT way*/\n\telse {\n\t\tu64 pos = gf_bs_get_position(bs);\n\t\tu64 prev_size = s->size;\n\t\t/*try parsing as generic box list*/\n\t\te = gf_isom_box_array_read(s, bs, NULL);\n\t\tif (e==GF_OK) return GF_OK;\n\t\t//reset content and retry - this deletes ptr->data !!\n\t\tgf_isom_box_array_del(s->child_boxes);\n\t\ts->child_boxes=NULL;\n\t\tgf_bs_seek(bs, pos);\n\t\ts->size = prev_size;\n\n\t\tptr->data = (GF_DataBox *)gf_isom_box_new_parent(&ptr->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\t\t//nope, check qt-style\n\t\tptr->data->qt_style = GF_TRUE;\n\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t\tptr->data->dataSize = gf_bs_read_u16(bs);\n\t\tgf_bs_read_u16(bs);\n\n\t\tptr->data->data = (char *) gf_malloc(sizeof(char)*(ptr->data->dataSize + 1));\n\t\tgf_bs_read_data(bs, ptr->data->data, ptr->data->dataSize);\n\t\tptr->data->data[ptr->data->dataSize] = 0;\n\t\tISOM_DECREASE_SIZE(ptr, ptr->data->dataSize);\n\t}\n\treturn GF_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144868,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err ilst_item_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 sub_type;\n\tGF_Box *a = NULL;\n\tGF_ListItemBox *ptr = (GF_ListItemBox *)s;\n\t/*iTunes way: there's a data atom containing the data*/\n\tsub_type = gf_bs_peek_bits(bs, 32, 4);\n\tif (sub_type == GF_ISOM_BOX_TYPE_DATA ) {\n\t\te = gf_isom_box_parse(&a, bs);\n\n\t\tif (!e && a && (ptr->size < a->size)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d)\\n\", gf_4cc_to_str(ptr->type), ptr->size, a->size, __FILE__, __LINE__ )); \\\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (e) {\n\t\t\tif (a) gf_isom_box_del(a);\n\t\t\treturn e;\n\t\t}\n\t\tif (!a) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tISOM_DECREASE_SIZE(ptr, a->size);\n\n\t\tif (a && ptr->data) gf_isom_box_del_parent(&ptr->child_boxes, (GF_Box *) ptr->data);\n\n\t\t/* otherwise a->data will always overflow */\n\t\tif (a && a->size > 4 && a->type != GF_ISOM_BOX_TYPE_VOID) {\n\t\t\tptr->data = (GF_DataBox *)a;\n\t\t\tif (!ptr->child_boxes) ptr->child_boxes = gf_list_new();\n\t\t\tgf_list_add(ptr->child_boxes, ptr->data);\n\t\t} else {\n\t\t\tptr->data = NULL;\n\t\t\tgf_isom_box_del(a);\n\t\t}\n\t}\n\t/*QT way*/\n\telse {\n\t\tu64 pos = gf_bs_get_position(bs);\n\t\tu64 prev_size = s->size;\n\t\t/*try parsing as generic box list*/\n\t\te = gf_isom_box_array_read(s, bs, NULL);\n\t\tif (e==GF_OK) return GF_OK;\n\t\t//reset content and retry - this deletes ptr->data !!\n\t\tgf_isom_box_array_del(s->child_boxes);\n\t\ts->child_boxes=NULL;\n\t\tgf_bs_seek(bs, pos);\n\t\ts->size = prev_size;\n\n\t\tptr->data = (GF_DataBox *)gf_isom_box_new_parent(&ptr->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\t\t//nope, check qt-style\n\t\tptr->data->qt_style = GF_TRUE;\n\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t\tptr->data->dataSize = gf_bs_read_u16(bs);\n\t\tgf_bs_read_u16(bs);\n\n\t\tptr->data->data = (char *) gf_malloc(sizeof(char)*(ptr->data->dataSize + 1));\n\t\tgf_bs_read_data(bs, ptr->data->data, ptr->data->dataSize);\n\t\tptr->data->data[ptr->data->dataSize] = 0;\n\t\tISOM_DECREASE_SIZE(ptr, ptr->data->dataSize);\n\t}\n\treturn GF_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144869,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "bool SetOpAttrScalar(TFE_Context* ctx, TFE_Op* op, const char* key,\n                     PyObject* py_value, TF_AttrType type,\n                     tensorflow::gtl::FlatMap<string, int64_t>* attr_list_sizes,\n                     TF_Status* status) {\n  if (type == TF_ATTR_STRING) {\n    tensorflow::StringPiece value;\n    if (!ParseStringValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrString(op, key, value.data(), value.size());\n  } else if (type == TF_ATTR_INT) {\n    int64_t value;\n    if (!ParseInt64Value(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrInt(op, key, value);\n    // attr_list_sizes is set for all int attributes (since at this point we are\n    // not aware if that attribute might be used to calculate the size of an\n    // output list or not).\n    if (attr_list_sizes != nullptr) (*attr_list_sizes)[key] = value;\n  } else if (type == TF_ATTR_FLOAT) {\n    float value;\n    if (!ParseFloatValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrFloat(op, key, value);\n  } else if (type == TF_ATTR_BOOL) {\n    unsigned char value;\n    if (!ParseBoolValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrBool(op, key, value);\n  } else if (type == TF_ATTR_TYPE) {\n    int value;\n    if (!ParseTypeValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrType(op, key, static_cast<TF_DataType>(value));\n  } else if (type == TF_ATTR_SHAPE) {\n    if (py_value == Py_None) {\n      TFE_OpSetAttrShape(op, key, nullptr, -1, status);\n    } else {\n      if (!PySequence_Check(py_value)) {\n        TF_SetStatus(status, TF_INVALID_ARGUMENT,\n                     tensorflow::strings::StrCat(\n                         \"Expecting None or sequence value for attr\", key,\n                         \", got \", py_value->ob_type->tp_name)\n                         .c_str());\n        return false;\n      }\n      const auto num_dims = TensorShapeNumDims(py_value);\n      if (num_dims == -1) {\n        TFE_OpSetAttrShape(op, key, nullptr, -1, status);\n        return true;\n      }\n      std::unique_ptr<int64_t[]> dims(new int64_t[num_dims]);\n      for (int i = 0; i < num_dims; ++i) {\n        tensorflow::Safe_PyObjectPtr inner_py_value(\n            PySequence_ITEM(py_value, i));\n        if (inner_py_value.get() == Py_None) {\n          dims[i] = -1;\n        } else if (!ParseDimensionValue(key, inner_py_value.get(), status,\n                                        &dims[i])) {\n          return false;\n        }\n      }\n      TFE_OpSetAttrShape(op, key, dims.get(), num_dims, status);\n    }\n    if (!status->status.ok()) return false;\n  } else if (type == TF_ATTR_FUNC) {\n    // Allow:\n    // (1) String function name, OR\n    // (2) A Python object with a .name attribute\n    //     (A crude test for being a\n    //     tensorflow.python.framework.function._DefinedFunction)\n    //     (which is what the various \"defun\" or \"Defun\" decorators do).\n    // And in the future also allow an object that can encapsulate\n    // the function name and its attribute values.\n    tensorflow::StringPiece func_name;\n    if (!ParseStringValue(key, py_value, status, &func_name)) {\n      PyObject* name_attr = PyObject_GetAttrString(py_value, \"name\");\n      if (name_attr == nullptr ||\n          !ParseStringValue(key, name_attr, status, &func_name)) {\n        TF_SetStatus(\n            status, TF_INVALID_ARGUMENT,\n            tensorflow::strings::StrCat(\n                \"unable to set function value attribute from a \",\n                py_value->ob_type->tp_name,\n                \" object. If you think this is an error, please file an issue \"\n                \"at https://github.com/tensorflow/tensorflow/issues/new\")\n                .c_str());\n        return false;\n      }\n    }\n    TF_SetStatus(status, TF_OK, \"\");\n    TFE_OpSetAttrFunctionName(op, key, func_name.data(), func_name.size());\n  } else {\n    TF_SetStatus(\n        status, TF_UNIMPLEMENTED,\n        tensorflow::strings::StrCat(\"Attr \", key, \" has unhandled type \", type)\n            .c_str());\n    return false;\n  }\n  return true;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144874,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "bool SetOpAttrScalar(TFE_Context* ctx, TFE_Op* op, const char* key,\n                     PyObject* py_value, TF_AttrType type,\n                     tensorflow::gtl::FlatMap<string, int64_t>* attr_list_sizes,\n                     TF_Status* status) {\n  if (type == TF_ATTR_STRING) {\n    tensorflow::StringPiece value;\n    if (!ParseStringValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrString(op, key, value.data(), value.size());\n  } else if (type == TF_ATTR_INT) {\n    int64_t value;\n    if (!ParseInt64Value(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrInt(op, key, value);\n    // attr_list_sizes is set for all int attributes (since at this point we are\n    // not aware if that attribute might be used to calculate the size of an\n    // output list or not).\n    if (attr_list_sizes != nullptr) (*attr_list_sizes)[key] = value;\n  } else if (type == TF_ATTR_FLOAT) {\n    float value;\n    if (!ParseFloatValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrFloat(op, key, value);\n  } else if (type == TF_ATTR_BOOL) {\n    unsigned char value;\n    if (!ParseBoolValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrBool(op, key, value);\n  } else if (type == TF_ATTR_TYPE) {\n    int value;\n    if (!ParseTypeValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrType(op, key, static_cast<TF_DataType>(value));\n  } else if (type == TF_ATTR_SHAPE) {\n    if (py_value == Py_None) {\n      TFE_OpSetAttrShape(op, key, nullptr, -1, status);\n    } else {\n      if (!PySequence_Check(py_value)) {\n        TF_SetStatus(status, TF_INVALID_ARGUMENT,\n                     tensorflow::strings::StrCat(\n                         \"Expecting None or sequence value for attr\", key,\n                         \", got \", py_value->ob_type->tp_name)\n                         .c_str());\n        return false;\n      }\n      const auto num_dims = TensorShapeNumDims(py_value);\n      if (num_dims == -1) {\n        TFE_OpSetAttrShape(op, key, nullptr, -1, status);\n        return true;\n      }\n      std::unique_ptr<int64_t[]> dims(new int64_t[num_dims]);\n      for (int i = 0; i < num_dims; ++i) {\n        tensorflow::Safe_PyObjectPtr inner_py_value(\n            PySequence_ITEM(py_value, i));\n        // If an error is generated when iterating through object, we can\n        // sometimes get a nullptr.\n        if (inner_py_value.get() == Py_None) {\n          dims[i] = -1;\n        } else if (inner_py_value.get() == nullptr ||\n                   !ParseDimensionValue(key, inner_py_value.get(), status,\n                                        &dims[i])) {\n          return false;\n        }\n      }\n      TFE_OpSetAttrShape(op, key, dims.get(), num_dims, status);\n    }\n    if (!status->status.ok()) return false;\n  } else if (type == TF_ATTR_FUNC) {\n    // Allow:\n    // (1) String function name, OR\n    // (2) A Python object with a .name attribute\n    //     (A crude test for being a\n    //     tensorflow.python.framework.function._DefinedFunction)\n    //     (which is what the various \"defun\" or \"Defun\" decorators do).\n    // And in the future also allow an object that can encapsulate\n    // the function name and its attribute values.\n    tensorflow::StringPiece func_name;\n    if (!ParseStringValue(key, py_value, status, &func_name)) {\n      PyObject* name_attr = PyObject_GetAttrString(py_value, \"name\");\n      if (name_attr == nullptr ||\n          !ParseStringValue(key, name_attr, status, &func_name)) {\n        TF_SetStatus(\n            status, TF_INVALID_ARGUMENT,\n            tensorflow::strings::StrCat(\n                \"unable to set function value attribute from a \",\n                py_value->ob_type->tp_name,\n                \" object. If you think this is an error, please file an issue \"\n                \"at https://github.com/tensorflow/tensorflow/issues/new\")\n                .c_str());\n        return false;\n      }\n    }\n    TF_SetStatus(status, TF_OK, \"\");\n    TFE_OpSetAttrFunctionName(op, key, func_name.data(), func_name.size());\n  } else {\n    TF_SetStatus(\n        status, TF_UNIMPLEMENTED,\n        tensorflow::strings::StrCat(\"Attr \", key, \" has unhandled type \", type)\n            .c_str());\n    return false;\n  }\n  return true;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144875,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  void Compute(OpKernelContext* context) override {\n    // Read ragged_splits inputs.\n    OpInputList ragged_nested_splits_in;\n    OP_REQUIRES_OK(context, context->input_list(\"rt_nested_splits\",\n                                                &ragged_nested_splits_in));\n    const int ragged_nested_splits_len = ragged_nested_splits_in.size();\n    RaggedTensorVariant batched_ragged_input;\n    // Read ragged_values input.\n    batched_ragged_input.set_values(context->input(ragged_nested_splits_len));\n    batched_ragged_input.mutable_nested_splits()->reserve(\n        ragged_nested_splits_len);\n    for (int i = 0; i < ragged_nested_splits_len; i++) {\n      batched_ragged_input.append_splits(ragged_nested_splits_in[i]);\n    }\n\n    if (!batched_input_) {\n      // Encode as a Scalar Variant Tensor.\n      Tensor* encoded_scalar;\n      OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape({}),\n                                                       &encoded_scalar));\n      encoded_scalar->scalar<Variant>()() = std::move(batched_ragged_input);\n      return;\n    }\n\n    // Unbatch the Ragged Tensor and encode the components.\n    std::vector<RaggedTensorVariant> unbatched_ragged_input;\n    OP_REQUIRES_OK(context, UnbatchRaggedZerothDim<VALUE_TYPE, SPLIT_TYPE>(\n                                batched_ragged_input, &unbatched_ragged_input));\n\n    // Bundle the encoded scalar Variant Tensors into a rank-1 Variant Tensor.\n    Tensor* encoded_vector;\n    int output_size = unbatched_ragged_input.size();\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({output_size}),\n                                            &encoded_vector));\n    auto encoded_vector_t = encoded_vector->vec<Variant>();\n    for (int i = 0; i < output_size; i++) {\n      encoded_vector_t(i) = unbatched_ragged_input[i];\n    }\n  }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144880,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  void Compute(OpKernelContext* context) override {\n    // Read inputs.\n    Tensor encoded_variant = context->input(0);\n    Tensor row_splits = context->input(1);\n    auto flat_row_splits = row_splits.flat<SPLIT_TYPE>();\n    TensorShape dense_values_shape;\n    OP_REQUIRES_OK(context,\n                   TensorShapeUtils::MakeShape(context->input(2).vec<int32>(),\n                                               &dense_values_shape));\n\n    const auto& flat_variants = encoded_variant.flat<Variant>();\n\n    // Get a Tensor containing the flat_values for each variant.\n    std::vector<Tensor> values;\n    for (int i = 0; i < flat_variants.size(); ++i) {\n      if (const auto* encoded = flat_variants(i).get<RaggedTensorVariant>()) {\n        values.push_back(encoded->values());\n      } else {\n        // Missing value: this happens if only some of the variant values\n        // generated by ragged_tensor_to_variant impacted the value that we're\n        // calculating the gradient for.  In this case, we will see a\n        // default-constructed variant; so treat it as a zero tensor with the\n        // appropriate shape.\n        const auto value_dtype = DataTypeToEnum<VALUE_TYPE>::v();\n        int piece_size = flat_row_splits(i + 1) - flat_row_splits(i);\n        TensorShape zeros_shape = dense_values_shape;\n        zeros_shape.set_dim(0, piece_size);\n        Tensor zero(value_dtype, zeros_shape);\n        zero.flat<VALUE_TYPE>() =\n            zero.flat<VALUE_TYPE>().constant(VALUE_TYPE());\n        values.push_back(zero);\n      }\n    }\n\n    if (values.size() == 1) {\n      // Just one flat_value tensor: return as-is.\n      context->set_output(0, values[0]);\n    } else {\n      // Multiple flat_values tensors: concatenate them together.\n      using Piece = typename TTypes<VALUE_TYPE, 2>::Matrix;\n      using ConstPiece = typename TTypes<VALUE_TYPE, 2>::ConstMatrix;\n      std::vector<std::unique_ptr<ConstPiece>> pieces;\n      pieces.reserve(values.size());\n      for (const Tensor& t : values) {\n        pieces.emplace_back(\n            new ConstPiece(t.shaped<VALUE_TYPE, 2>({1, t.NumElements()})));\n      }\n      Tensor* out = nullptr;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(0, dense_values_shape, &out));\n      Piece out_flat =\n          out->shaped<VALUE_TYPE, 2>({1, dense_values_shape.num_elements()});\n      ConcatCPU<VALUE_TYPE>(context->device(), pieces, &out_flat);\n    }\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144881,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void LineBitmapRequester::ReconstructRegion(const RectAngle<LONG> &orgregion,const struct RectangleRequest *rr)\n{\n  class ColorTrafo *ctrafo = ColorTrafoOf(false,!rr->rr_bColorTrafo);\n  UBYTE i;\n\n  if (m_bSubsampling && rr->rr_bUpsampling) { \n    for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n      class Component *comp = m_pFrame->ComponentOf(i);\n      UBYTE subx            = comp->SubXOf();\n      UBYTE suby            = comp->SubYOf();\n      class UpsamplerBase *up;  // upsampler\n      LONG bx,by;\n      RectAngle<LONG> blocks;\n      //\n      // Compute the region of blocks\n      assert(subx > 0 && suby > 0);\n      if ((up = m_ppUpsampler[i])) {\n        LONG bwidth           = ((m_ulPixelWidth  + subx - 1) / subx + 7) >> 3;\n        LONG bheight          = ((m_ulPixelHeight + suby - 1) / suby + 7) >> 3;\n        LONG rx               = (subx > 1)?(1):(0);\n        LONG ry               = (suby > 1)?(1):(0);\n        // The +/-1 include additional lines required for subsampling expansion\n        blocks.ra_MinX        = ((orgregion.ra_MinX / subx - rx) >> 3);\n        blocks.ra_MaxX        = ((orgregion.ra_MaxX / subx + rx) >> 3);\n        blocks.ra_MinY        = ((orgregion.ra_MinY / suby - ry) >> 3);\n        blocks.ra_MaxY        = ((orgregion.ra_MaxY / suby + ry) >> 3);\n        // Clip.\n        if (blocks.ra_MinX < 0)        blocks.ra_MinX = 0;\n        if (blocks.ra_MaxX >= bwidth)  blocks.ra_MaxX = bwidth - 1;\n        if (blocks.ra_MinY < 0)        blocks.ra_MinY = 0;\n        if (blocks.ra_MaxY >= bheight) blocks.ra_MaxY = bheight - 1;\n        up->SetBufferedRegion(blocks); // also removes the rectangle of blocks already buffered.\n        //\n        for(by = blocks.ra_MinY;by <= blocks.ra_MaxY;by++) {\n          for(bx = blocks.ra_MinX;bx <= blocks.ra_MaxX;bx++) {\n            LONG dst[64];\n            if (*m_pppImage[i]) {\n              FetchRegion(bx,*m_pppImage[i],dst);\n            } else {\n              memset(dst,0,sizeof(dst));\n            }\n            up->DefineRegion(bx,by,dst);\n          }\n          Next8Lines(i);\n        }\n      }\n    }\n    // Now push blocks into the color transformer from the upsampler.\n    {\n      RectAngle<LONG> r;\n      ULONG minx   = orgregion.ra_MinX >> 3;\n      ULONG maxx   = orgregion.ra_MaxX >> 3;\n      ULONG miny   = orgregion.ra_MinY >> 3;\n      ULONG maxy   = orgregion.ra_MaxY >> 3;\n      ULONG x,y;\n      \n      if (maxy > m_ulMaxMCU)\n        maxy = m_ulMaxMCU;\n\n      for(y = miny,r.ra_MinY = orgregion.ra_MinY;y <= maxy;y++,r.ra_MinY = r.ra_MaxY + 1) {\n        r.ra_MaxY = (r.ra_MinY & -8) + 7;\n        if (r.ra_MaxY > orgregion.ra_MaxY)\n          r.ra_MaxY = orgregion.ra_MaxY;\n        \n        for(x = minx,r.ra_MinX = orgregion.ra_MinX;x <= maxx;x++,r.ra_MinX = r.ra_MaxX + 1) {\n          r.ra_MaxX = (r.ra_MinX & -8) + 7;\n          if (r.ra_MaxX > orgregion.ra_MaxX)\n            r.ra_MaxX = orgregion.ra_MaxX;\n          \n          for(i = 0;i < m_ucCount;i++) {\n            if (i >= rr->rr_usFirstComponent && i <= rr->rr_usLastComponent) {\n              ExtractBitmap(m_ppTempIBM[i],r,i);\n              if (m_ppUpsampler[i]) {\n                // Upsampled case, take from the upsampler, transform\n                // into the color buffer.\n                m_ppUpsampler[i]->UpsampleRegion(r,m_ppCTemp[i]);\n              } else if (*m_pppImage[i]) {\n                FetchRegion(x,*m_pppImage[i],m_ppCTemp[i]);\n              } else {\n                memset(m_ppCTemp[0],0,sizeof(LONG) * 64);\n              }\n            } else {\n              // Not requested, zero the buffer.\n              memset(m_ppCTemp[i],0,sizeof(LONG) * 64);\n            }\n          }\n          ctrafo->YCbCr2RGB(r,m_ppTempIBM,m_ppCTemp,NULL);\n        }\n        //\n        // Advance the quantized rows for the non-subsampled components,\n        // upsampled components have been advanced above.\n        for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n          if (m_ppUpsampler[i] == NULL)\n            Next8Lines(i);\n        }\n      }\n    }\n  } else { // direct case, no upsampling required, residual coding possible.\n    RectAngle<LONG> r;\n    RectAngle<LONG> region = orgregion;\n    SubsampledRegion(region,rr);\n    ULONG minx   = region.ra_MinX >> 3;\n    ULONG maxx   = region.ra_MaxX >> 3;\n    ULONG miny   = region.ra_MinY >> 3;\n    ULONG maxy   = region.ra_MaxY >> 3;\n    ULONG x,y;\n      \n    if (maxy > m_ulMaxMCU)\n      maxy = m_ulMaxMCU;\n\n    for(y = miny,r.ra_MinY = region.ra_MinY;y <= maxy;y++,r.ra_MinY = r.ra_MaxY + 1) {\n      r.ra_MaxY = (r.ra_MinY & -8) + 7;\n      if (r.ra_MaxY > region.ra_MaxY)\n        r.ra_MaxY = region.ra_MaxY;\n        \n      for(x = minx,r.ra_MinX = region.ra_MinX;x <= maxx;x++,r.ra_MinX = r.ra_MaxX + 1) {\n        r.ra_MaxX = (r.ra_MinX & -8) + 7;\n        if (r.ra_MaxX > region.ra_MaxX)\n          r.ra_MaxX = region.ra_MaxX;\n\n        for(i = 0;i < m_ucCount;i++) {      \n          LONG *dst = m_ppCTemp[i];\n          if (i >= rr->rr_usFirstComponent && i <= rr->rr_usLastComponent) {\n            ExtractBitmap(m_ppTempIBM[i],r,i);\n            FetchRegion(x,*m_pppImage[i],dst);\n          } else {\n            memset(dst,0,sizeof(LONG) * 64);\n          }\n        }\n        //\n        // Perform the color transformation now.\n        ctrafo->YCbCr2RGB(r,m_ppTempIBM,m_ppCTemp,NULL);\n      } // of loop over x\n      //\n      // Advance the rows.\n      for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n        Next8Lines(i);\n      }\n    }\n  }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144882,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void LineBitmapRequester::ReconstructRegion(const RectAngle<LONG> &orgregion,const struct RectangleRequest *rr)\n{\n  class ColorTrafo *ctrafo = ColorTrafoOf(false,!rr->rr_bColorTrafo);\n  UBYTE i;\n\n  if (m_bSubsampling && rr->rr_bUpsampling) { \n    for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n      class Component *comp = m_pFrame->ComponentOf(i);\n      UBYTE subx            = comp->SubXOf();\n      UBYTE suby            = comp->SubYOf();\n      class UpsamplerBase *up;  // upsampler\n      LONG bx,by;\n      RectAngle<LONG> blocks;\n      //\n      // Compute the region of blocks\n      assert(subx > 0 && suby > 0);\n      if ((up = m_ppUpsampler[i])) {\n        LONG bwidth           = ((m_ulPixelWidth  + subx - 1) / subx + 7) >> 3;\n        LONG bheight          = ((m_ulPixelHeight + suby - 1) / suby + 7) >> 3;\n        LONG rx               = (subx > 1)?(1):(0);\n        LONG ry               = (suby > 1)?(1):(0);\n        // The +/-1 include additional lines required for subsampling expansion\n        blocks.ra_MinX        = ((orgregion.ra_MinX / subx - rx) >> 3);\n        blocks.ra_MaxX        = ((orgregion.ra_MaxX / subx + rx) >> 3);\n        blocks.ra_MinY        = ((orgregion.ra_MinY / suby - ry) >> 3);\n        blocks.ra_MaxY        = ((orgregion.ra_MaxY / suby + ry) >> 3);\n        // Clip.\n        if (blocks.ra_MinX < 0)        blocks.ra_MinX = 0;\n        if (blocks.ra_MaxX >= bwidth)  blocks.ra_MaxX = bwidth - 1;\n        if (blocks.ra_MinY < 0)        blocks.ra_MinY = 0;\n        if (blocks.ra_MaxY >= bheight) blocks.ra_MaxY = bheight - 1;\n        up->SetBufferedRegion(blocks); // also removes the rectangle of blocks already buffered.\n        //\n        for(by = blocks.ra_MinY;by <= blocks.ra_MaxY;by++) {\n          for(bx = blocks.ra_MinX;bx <= blocks.ra_MaxX;bx++) {\n            LONG dst[64];\n            if (*m_pppImage[i]) {\n              FetchRegion(bx,*m_pppImage[i],dst);\n            } else {\n              memset(dst,0,sizeof(dst));\n            }\n            up->DefineRegion(bx,by,dst);\n          }\n          Next8Lines(i);\n        }\n      }\n    }\n    // Now push blocks into the color transformer from the upsampler.\n    {\n      RectAngle<LONG> r;\n      ULONG minx   = orgregion.ra_MinX >> 3;\n      ULONG maxx   = orgregion.ra_MaxX >> 3;\n      ULONG miny   = orgregion.ra_MinY >> 3;\n      ULONG maxy   = orgregion.ra_MaxY >> 3;\n      ULONG x,y;\n      \n      if (maxy > m_ulMaxMCU)\n        maxy = m_ulMaxMCU;\n\n      for(y = miny,r.ra_MinY = orgregion.ra_MinY;y <= maxy;y++,r.ra_MinY = r.ra_MaxY + 1) {\n        r.ra_MaxY = (r.ra_MinY & -8) + 7;\n        if (r.ra_MaxY > orgregion.ra_MaxY)\n          r.ra_MaxY = orgregion.ra_MaxY;\n        \n        for(x = minx,r.ra_MinX = orgregion.ra_MinX;x <= maxx;x++,r.ra_MinX = r.ra_MaxX + 1) {\n          r.ra_MaxX = (r.ra_MinX & -8) + 7;\n          if (r.ra_MaxX > orgregion.ra_MaxX)\n            r.ra_MaxX = orgregion.ra_MaxX;\n          \n          for(i = 0;i < m_ucCount;i++) {\n            if (i >= rr->rr_usFirstComponent && i <= rr->rr_usLastComponent) {\n              ExtractBitmap(m_ppTempIBM[i],r,i);\n              if (m_ppUpsampler[i]) {\n                // Upsampled case, take from the upsampler, transform\n                // into the color buffer.\n                m_ppUpsampler[i]->UpsampleRegion(r,m_ppCTemp[i]);\n              } else if (*m_pppImage[i]) {\n                FetchRegion(x,*m_pppImage[i],m_ppCTemp[i]);\n              } else {\n                memset(m_ppCTemp[0],0,sizeof(LONG) * 64);\n              }\n            } else {\n              // Not requested, zero the buffer.\n              memset(m_ppCTemp[i],0,sizeof(LONG) * 64);\n            }\n          }\n          ctrafo->YCbCr2RGB(r,m_ppTempIBM,m_ppCTemp,NULL);\n        }\n        //\n        // Advance the quantized rows for the non-subsampled components,\n        // upsampled components have been advanced above.\n        for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n          if (m_ppUpsampler[i] == NULL)\n            Next8Lines(i);\n        }\n      }\n    }\n  } else { // direct case, no upsampling required, residual coding possible.\n    RectAngle<LONG> r;\n    RectAngle<LONG> region = orgregion;\n    SubsampledRegion(region,rr);\n    ULONG minx   = region.ra_MinX >> 3;\n    ULONG maxx   = region.ra_MaxX >> 3;\n    ULONG miny   = region.ra_MinY >> 3;\n    ULONG maxy   = region.ra_MaxY >> 3;\n    ULONG x,y;\n      \n    if (maxy > m_ulMaxMCU)\n      maxy = m_ulMaxMCU;\n\n    for(y = miny,r.ra_MinY = region.ra_MinY;y <= maxy;y++,r.ra_MinY = r.ra_MaxY + 1) {\n      r.ra_MaxY = (r.ra_MinY & -8) + 7;\n      if (r.ra_MaxY > region.ra_MaxY)\n        r.ra_MaxY = region.ra_MaxY;\n        \n      for(x = minx,r.ra_MinX = region.ra_MinX;x <= maxx;x++,r.ra_MinX = r.ra_MaxX + 1) {\n        r.ra_MaxX = (r.ra_MinX & -8) + 7;\n        if (r.ra_MaxX > region.ra_MaxX)\n          r.ra_MaxX = region.ra_MaxX;\n\n        for(i = 0;i < m_ucCount;i++) {      \n          LONG *dst = m_ppCTemp[i];\n          if (i >= rr->rr_usFirstComponent && i <= rr->rr_usLastComponent) {\n            ExtractBitmap(m_ppTempIBM[i],r,i);\n            if (*m_pppImage[i]) {\n              FetchRegion(x,*m_pppImage[i],dst);\n            } else {\n              memset(dst,0,sizeof(LONG) * 64);\n            }\n          } else {\n            memset(dst,0,sizeof(LONG) * 64);\n          }\n        }\n        //\n        // Perform the color transformation now.\n        ctrafo->YCbCr2RGB(r,m_ppTempIBM,m_ppCTemp,NULL);\n      } // of loop over x\n      //\n      // Advance the rows.\n      for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n        Next8Lines(i);\n      }\n    }\n  }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144883,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static GF_Err gf_media_export_filters(GF_MediaExporter *dumper)\n{\n\tchar *args, szSubArgs[1024], szExt[30];\n\tGF_Filter *file_out, *reframer, *remux=NULL, *src_filter;\n\tGF_FilterSession *fsess;\n\tGF_Err e = GF_OK;\n\tu32 codec_id=0;\n\tu32 sample_count=0;\n\tBool skip_write_filter = GF_FALSE;\n\tBool ext_forced = GF_FALSE;\n\tBool use_dynext = GF_FALSE;\n\n\targs = NULL;\n\tstrcpy(szExt, \"\");\n\tif (dumper->trackID && dumper->file) {\n\t\tu32 msubtype = 0;\n\t\tu32 mtype = 0;\n\t\tu32 afmt = 0;\n\t\tGF_PixelFormat pfmt = 0;\n\t\tGF_ESD *esd;\n\t\tconst char *export_ext = dumper->out_name ? gf_file_ext_start(dumper->out_name) : NULL;\n\t\tu32 track_num = gf_isom_get_track_by_id(dumper->file, dumper->trackID);\n\t\tif (!track_num) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] No tracks with ID %d in file\\n\", dumper->trackID));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tesd = gf_media_map_esd(dumper->file, track_num, 0);\n\t\tsample_count = gf_isom_get_sample_count(dumper->file, dumper->trackID);\n\t\tif (esd) {\n\t\t\tif (esd->decoderConfig->objectTypeIndication<GF_CODECID_LAST_MPEG4_MAPPING) {\n\t\t\t\tcodec_id = gf_codecid_from_oti(esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo && (codec_id==GF_CODECID_AAC_MPEG4)) {\n\t\t\t\t\tGF_M4ADecSpecInfo acfg;\n\t\t\t\t\tgf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &acfg);\n\t\t\t\t\tif (acfg.base_object_type == GF_M4A_USAC)\n\t\t\t\t\t\tcodec_id = GF_CODECID_USAC;\n\t\t\t\t}\n#endif\n\t\t\t} else {\n\t\t\t\tcodec_id = esd->decoderConfig->objectTypeIndication;\n\t\t\t}\n\t\t}\n\t\tif (!codec_id) {\n\t\t\tmsubtype = gf_isom_get_media_subtype(dumper->file, track_num, 1);\n\t\t\tcodec_id = gf_codec_id_from_isobmf(msubtype);\n\t\t}\n\t\tmtype = gf_isom_get_media_type(dumper->file, track_num);\n\t\tif (!codec_id) {\n\t\t\tpfmt = gf_pixel_fmt_from_qt_type(msubtype);\n\t\t\tif (pfmt) codec_id = GF_CODECID_RAW;\n\t\t}\n\n\t\tif (!codec_id) {\n\t\t\tstrcpy(szExt, gf_4cc_to_str(msubtype));\n\t\t\text_forced = GF_TRUE;\n\t\t} else if (codec_id==GF_CODECID_RAW) {\n\t\t\tswitch (mtype) {\n\t\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\t\tif (pfmt)\n\t\t\t\t\tstrcpy(szExt, gf_pixel_fmt_sname(pfmt));\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\t\tafmt = gf_audio_fmt_from_isobmf(msubtype);\n\t\t\t\tif (afmt)\n\t\t\t\t\tstrcpy(szExt, gf_audio_fmt_name(afmt));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstrcpy(szExt, gf_4cc_to_str(msubtype));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *sname = gf_codecid_file_ext(codec_id);\n\t\t\tif (export_ext && strstr(sname, export_ext+1)) {\n\t\t\t\tszExt[0]=0;\n\t\t\t} else {\n\t\t\t\tchar *sep;\n\t\t\t\tstrncpy(szExt, sname, 29);\n\t\t\t\tszExt[29]=0;\n\t\t\t\tsep = strchr(szExt, '|');\n\t\t\t\tif (sep) sep[0] = 0;\n\t\t\t}\n\t\t}\n\t\tswitch (mtype) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tskip_write_filter = codec_id ? GF_TRUE : GF_FALSE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tswitch (codec_id) {\n\t\t\tcase GF_CODECID_WEBVTT:\n\t\t\t\tskip_write_filter = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_CODECID_META_TEXT:\n\t\t\tcase GF_CODECID_META_XML:\n\t\t\tcase GF_CODECID_SUBS_TEXT:\n\t\t\tcase GF_CODECID_SUBS_XML:\n\t\t\tcase GF_CODECID_SIMPLE_TEXT:\n\t\t\t\t//use dynamic extension\n\t\t\t\tszExt[0] = 0;\n\t\t\t\tuse_dynext = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t//TODO, move these two to filters one of these days\n\t\tif ((codec_id==GF_CODECID_VORBIS) || (codec_id==GF_CODECID_THEORA) || (codec_id==GF_CODECID_OPUS)) {\n\t\t\tchar *outname = dumper->out_name;\n\t\t\tif (outname && !strcmp(outname, \"std\")) outname=NULL;\n\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\treturn gf_dump_to_ogg(dumper, outname, track_num);\n#else\n\t\t\treturn GF_NOT_SUPPORTED;\n#endif\n\n\t\t}\n\t\tif (codec_id==GF_CODECID_SUBPIC) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\tchar *dsi = NULL;\n\t\t\tu32 dsi_size = 0;\n\t\t\tif (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\tdsi = esd->decoderConfig->decoderSpecificInfo->data;\n\t\t\t\tdsi_size = esd->decoderConfig->decoderSpecificInfo->dataLength;\n\t\t\t}\n\t\t\te = gf_dump_to_vobsub(dumper, dumper->out_name, track_num, dsi, dsi_size);\n#else\n\t\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\treturn e;\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\t} else {\n\t\tconst char *export_ext = dumper->out_name ? gf_file_ext_start(dumper->out_name) : NULL;\n\t\tskip_write_filter = GF_TRUE;\n\t\tif (!export_ext)\n\t\t\tuse_dynext = GF_TRUE;\n\t}\n\n\tfsess = gf_fs_new_defaults(0);\n\tif (!fsess) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Failed to create filter session\\n\"));\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tfile_out = NULL;\n\targs = NULL;\n\n\tif (dumper->flags & GF_EXPORT_REMUX) {\n\t\tfile_out = gf_fs_load_destination(fsess, dumper->out_name, NULL, NULL, &e);\n\t\tif (!file_out) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot open destination %s\\n\", dumper->out_name));\n\t\t\treturn e;\n\t\t}\n\t}\n\t//except in nhml inband file dump, create a sink filter\n\telse if (!dumper->dump_file) {\n\t\tBool no_ext = (dumper->flags & GF_EXPORT_NO_FILE_EXT) ? GF_TRUE : GF_FALSE;\n\t\tchar *ext = gf_file_ext_start(dumper->out_name);\n\t\t//mux args, for now we only dump to file\n\t\te = gf_dynstrcat(&args, \"fout:dst=\", NULL);\n\t\te |= gf_dynstrcat(&args, dumper->out_name, NULL);\n\n\t\tif (dumper->flags & GF_EXPORT_NHNT) {\n\t\t\tstrcpy(szExt, \"nhnt\");\n\t\t\te |= gf_dynstrcat(&args, \":clone\", NULL);\n\t\t\tno_ext = GF_TRUE;\n\t\t\tif (!ext)\n\t\t\t\te |= gf_dynstrcat(&args, \":dynext\", NULL);\n\t\t} else if (dumper->flags & GF_EXPORT_NHML) {\n\t\t\tstrcpy(szExt, \"nhml\");\n\t\t\te |= gf_dynstrcat(&args, \":clone\", NULL);\n\t\t\tno_ext = GF_TRUE;\n\t\t\tif (!ext)\n\t\t\t\te |= gf_dynstrcat(&args, \":dynext\", NULL);\n\t\t}\n\n\t\tif (dumper->flags & GF_EXPORT_RAW_SAMPLES) {\n\t\t\tif (!dumper->sample_num) {\n\n\t\t\t\text = gf_file_ext_start(args);\n\t\t\t\tif (ext) ext[0] = 0;\n\t\t\t\tif (sample_count>=1000) {\n\t\t\t\t\te |= gf_dynstrcat(&args, \"_$num%08d$\", NULL);\n\t\t\t\t} else if (sample_count) {\n\t\t\t\t\te |= gf_dynstrcat(&args, \"_$num%03d$\", NULL);\n\t\t\t\t} else {\n\t\t\t\t\te |= gf_dynstrcat(&args, \"_$num$\", NULL);\n\t\t\t\t}\n\t\t\t\text = gf_file_ext_start(dumper->out_name);\n\t\t\t\tif (ext) e |= gf_dynstrcat(&args, ext, NULL);\n\t\t\t}\n\t\t\te |= gf_dynstrcat(&args, \":dynext\", NULL);\n\t\t} else if (dumper->trackID && strlen(szExt) ) {\n\t\t\tif (!no_ext && !gf_file_ext_start(dumper->out_name)) {\n\t\t\t\tif (args) gf_free(args);\n\t\t\t\targs=NULL;\n\t\t\t\te = gf_dynstrcat(&args, \"fout:dst=\", NULL);\n\t\t\t\te |= gf_dynstrcat(&args, dumper->out_name, NULL);\n\t\t\t\te |= gf_dynstrcat(&args, szExt, \".\");\n\t\t\t} else {\n\t\t\t\te |= gf_dynstrcat(&args, \":ext=\", NULL);\n\t\t\t\te |= gf_dynstrcat(&args, szExt, NULL);\n\t\t\t}\n\t\t} else if ((dumper->trackID || dumper->track_type) && use_dynext) {\n\t\t\te |= gf_dynstrcat(&args, \":dynext\", NULL);\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load arguments for output file dumper\\n\"));\n\t\t\tif (args) gf_free(args);\n\t\t\tgf_fs_del(fsess);\n\t\t\treturn e;\n\t\t}\n\n\t\tfile_out = gf_fs_load_filter(fsess, args, &e);\n\t\tif (!file_out) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tif (args) gf_free(args);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load output file dumper\\n\"));\n\t\t\treturn e;\n\t\t}\n\t}\n\tif (args) gf_free(args);\n\targs = NULL;\n\n\t//raw sample frame, force loading filter generic write in frame mode\n\tif (dumper->flags & GF_EXPORT_RAW_SAMPLES) {\n\t\te = gf_dynstrcat(&args, \"writegen:frame\", NULL);\n\t\tif (dumper->sample_num) {\n\t\t\tsprintf(szSubArgs, \":sstart=%d:send=%d\", dumper->sample_num, dumper->sample_num);\n\t\t\te |= gf_dynstrcat(&args, szSubArgs, NULL);\n\t\t}\n\t\tremux = e ? NULL : gf_fs_load_filter(fsess, args, &e);\n\t\tif (!remux || e) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load stream->file filter\\n\"));\n\t\t\tif (args) gf_free(args);\n\t\t\treturn e ? e : GF_FILTER_NOT_FOUND;\n\t\t}\n\t}\n\telse if (dumper->flags & GF_EXPORT_NHNT) {\n\t\tremux = gf_fs_load_filter(fsess, \"nhntw:exporter\", &e);\n\t\tif (!remux) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load NHNT write filter\\n\"));\n\t\t\treturn e;\n\t\t}\n\t}\n\telse if (dumper->flags & GF_EXPORT_NHML) {\n\t\te = gf_dynstrcat(&args, \"nhmlw:exporter:name=\", NULL);\n\t\te |= gf_dynstrcat(&args, dumper->out_name, NULL);\n\t\tif (dumper->flags & GF_EXPORT_NHML_FULL)\n\t\t\te |= gf_dynstrcat(&args, \":pckp\", NULL);\n\t\tif (dumper->dump_file) {\n\t\t\tsprintf(szSubArgs, \":nhmlonly:filep=%p\", dumper->dump_file);\n\t\t\te |= gf_dynstrcat(&args, szSubArgs, NULL);\n\t\t}\n\t\tremux = e ? NULL : gf_fs_load_filter(fsess, args, &e);\n\t\tif (!remux || e) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tif (args) gf_free(args);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load NHML write filter\\n\"));\n\t\t\treturn e ? e : GF_FILTER_NOT_FOUND;\n\t\t}\n\t} else if (!skip_write_filter) {\n\t\te = gf_dynstrcat(&args, \"writegen:exporter\", NULL);\n\t\t//extension has been forced, override ext at output of writegen\n\t\tif (ext_forced) {\n\t\t\te |= gf_dynstrcat(&args, \":#Extension=\", NULL);\n\t\t\te |= gf_dynstrcat(&args, szExt, NULL);\n\t\t}\n\n\t\tremux = e ? NULL : gf_fs_load_filter(fsess, args, &e);\n\t\tif (!remux) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tif (args) gf_free(args);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load stream->file filter\\n\"));\n\t\t\treturn e;\n\t\t}\n\t}\n\tif (args) gf_free(args);\n\targs = NULL;\n\n\t//force a reframer filter, connected to our input\n\te = gf_dynstrcat(&args, \"reframer:SID=1\", NULL);\n\tif (dumper->trackID) {\n\t\tsprintf(szSubArgs, \"#PID=%d\", dumper->trackID);\n\t\te |= gf_dynstrcat(&args, szSubArgs, NULL);\n\t}\n\te |= gf_dynstrcat(&args, \":exporter\", NULL);\n\tif (dumper->flags & GF_EXPORT_SVC_LAYER)\n\t\te |= gf_dynstrcat(&args, \":extract=layer\", NULL);\n\tif (dumper->flags & GF_EXPORT_WEBVTT_NOMERGE)\n\t\te |= gf_dynstrcat(&args, \":merge\", NULL);\n\n\treframer = gf_fs_load_filter(fsess, args, &e);\n\tif (!reframer || e) {\n\t\tgf_fs_del(fsess);\n\t\tif (args) gf_free(args);\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load reframer filter\\n\"));\n\t\treturn e ? e : GF_FILTER_NOT_FOUND;\n\t}\n\tif (args) gf_free(args);\n\targs = NULL;\n\n\t//we already have the file loaded, directly load the mp4dmx filter with this file\n\tif (dumper->file) {\n\t\t//we want to expose every track\n\t\te = gf_dynstrcat(&args, \"mp4dmx:FID=1:noedit:alltk:allt\", NULL);\n\t\tif (!e) {\n\t\t\tsprintf(szSubArgs, \":mov=%p\", dumper->file);\n\t\t\te = gf_dynstrcat(&args, szSubArgs, NULL);\n\t\t}\n\t\t\n\t\t//we want to expose every track\n\t\tsrc_filter = gf_fs_load_filter(fsess, args, &e);\n\n\t\tgf_free(args);\n\t\targs = NULL;\n\t} else {\n\t\t//we want to expose every track\n\t\tsrc_filter = gf_fs_load_source(fsess, dumper->in_name, \"FID=1:noedit:alltk:allt\", NULL, &e);\n\t}\n\n\tif (!src_filter || e) {\n\t\tgf_fs_del(fsess);\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load filter for input file \\\"%s\\\": %s\\n\", dumper->in_name, gf_error_to_string(e) ));\n\t\treturn e;\n\t}\n\n\tif (dumper->track_type) {\n\t\tconst char *mtype = (dumper->track_type==1) ? \"video\" : \"audio\";\n\t\tif (dumper->trackID) {\n\t\t\tsprintf(szSubArgs, \"%s%d\", mtype, dumper->trackID);\n\t\t} else {\n\t\t\tsprintf(szSubArgs, \"%s\", mtype);\n\t\t}\n\t}\n\telse if (dumper->trackID) {\n\t\tsprintf(szSubArgs, \"PID=%d\", dumper->trackID);\n\t}\n\tif (remux) {\n\t\tgf_filter_set_source(file_out, remux, (dumper->trackID || dumper->track_type) ? szSubArgs : NULL);\n\t\tgf_filter_set_source(remux, reframer, (dumper->trackID || dumper->track_type) ? szSubArgs : NULL);\n\t} else {\n\t\tgf_filter_set_source(file_out, reframer, (dumper->trackID || dumper->track_type) ? szSubArgs : NULL);\n\t}\n\n\te = gf_fs_run(fsess);\n\tif (e>GF_OK) e = GF_OK;\n\tif (!e) e = gf_fs_get_last_connect_error(fsess);\n\tif (!e) e = gf_fs_get_last_process_error(fsess);\n\n\tif (!e) {\n\t\tif (dumper->file)\n\t\t\tgf_fs_print_unused_args(fsess, NULL);\n\t\telse\n\t\t\tgf_fs_print_unused_args(fsess, \"alltk,allt,noedit\");\n\t}\n\tgf_fs_print_non_connected(fsess);\n\tif (dumper->print_stats_graph & 1) gf_fs_print_stats(fsess);\n\tif (dumper->print_stats_graph & 2) gf_fs_print_connections(fsess);\n\tgf_fs_del(fsess);\n\treturn e;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144900,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static GF_Err gf_media_export_filters(GF_MediaExporter *dumper)\n{\n\tchar *args, szSubArgs[1024], szExt[30];\n\tGF_Filter *file_out, *reframer, *remux=NULL, *src_filter;\n\tGF_FilterSession *fsess;\n\tGF_Err e = GF_OK;\n\tu32 codec_id=0;\n\tu32 sample_count=0;\n\tBool skip_write_filter = GF_FALSE;\n\tBool ext_forced = GF_FALSE;\n\tBool use_dynext = GF_FALSE;\n\n\targs = NULL;\n\tstrcpy(szExt, \"\");\n\tif (dumper->trackID && dumper->file) {\n\t\tu32 msubtype = 0;\n\t\tu32 mtype = 0;\n\t\tu32 afmt = 0;\n\t\tGF_PixelFormat pfmt = 0;\n\t\tGF_ESD *esd;\n\t\tconst char *export_ext = dumper->out_name ? gf_file_ext_start(dumper->out_name) : NULL;\n\t\tu32 track_num = gf_isom_get_track_by_id(dumper->file, dumper->trackID);\n\t\tif (!track_num) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] No tracks with ID %d in file\\n\", dumper->trackID));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tesd = gf_media_map_esd(dumper->file, track_num, 0);\n\t\tsample_count = gf_isom_get_sample_count(dumper->file, dumper->trackID);\n\t\tif (esd && esd->decoderConfig) {\n\t\t\tif (esd->decoderConfig->objectTypeIndication<GF_CODECID_LAST_MPEG4_MAPPING) {\n\t\t\t\tcodec_id = gf_codecid_from_oti(esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo && (codec_id==GF_CODECID_AAC_MPEG4)) {\n\t\t\t\t\tGF_M4ADecSpecInfo acfg;\n\t\t\t\t\tgf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &acfg);\n\t\t\t\t\tif (acfg.base_object_type == GF_M4A_USAC)\n\t\t\t\t\t\tcodec_id = GF_CODECID_USAC;\n\t\t\t\t}\n#endif\n\t\t\t} else {\n\t\t\t\tcodec_id = esd->decoderConfig->objectTypeIndication;\n\t\t\t}\n\t\t}\n\t\tif (!codec_id) {\n\t\t\tmsubtype = gf_isom_get_media_subtype(dumper->file, track_num, 1);\n\t\t\tcodec_id = gf_codec_id_from_isobmf(msubtype);\n\t\t}\n\t\tmtype = gf_isom_get_media_type(dumper->file, track_num);\n\t\tif (!codec_id) {\n\t\t\tpfmt = gf_pixel_fmt_from_qt_type(msubtype);\n\t\t\tif (pfmt) codec_id = GF_CODECID_RAW;\n\t\t}\n\n\t\tif (!codec_id) {\n\t\t\tstrcpy(szExt, gf_4cc_to_str(msubtype));\n\t\t\text_forced = GF_TRUE;\n\t\t} else if (codec_id==GF_CODECID_RAW) {\n\t\t\tswitch (mtype) {\n\t\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\t\tif (pfmt)\n\t\t\t\t\tstrcpy(szExt, gf_pixel_fmt_sname(pfmt));\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\t\tafmt = gf_audio_fmt_from_isobmf(msubtype);\n\t\t\t\tif (afmt)\n\t\t\t\t\tstrcpy(szExt, gf_audio_fmt_name(afmt));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstrcpy(szExt, gf_4cc_to_str(msubtype));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *sname = gf_codecid_file_ext(codec_id);\n\t\t\tif (export_ext && strstr(sname, export_ext+1)) {\n\t\t\t\tszExt[0]=0;\n\t\t\t} else {\n\t\t\t\tchar *sep;\n\t\t\t\tstrncpy(szExt, sname, 29);\n\t\t\t\tszExt[29]=0;\n\t\t\t\tsep = strchr(szExt, '|');\n\t\t\t\tif (sep) sep[0] = 0;\n\t\t\t}\n\t\t}\n\t\tswitch (mtype) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tskip_write_filter = codec_id ? GF_TRUE : GF_FALSE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tswitch (codec_id) {\n\t\t\tcase GF_CODECID_WEBVTT:\n\t\t\t\tskip_write_filter = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_CODECID_META_TEXT:\n\t\t\tcase GF_CODECID_META_XML:\n\t\t\tcase GF_CODECID_SUBS_TEXT:\n\t\t\tcase GF_CODECID_SUBS_XML:\n\t\t\tcase GF_CODECID_SIMPLE_TEXT:\n\t\t\t\t//use dynamic extension\n\t\t\t\tszExt[0] = 0;\n\t\t\t\tuse_dynext = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t//TODO, move these two to filters one of these days\n\t\tif ((codec_id==GF_CODECID_VORBIS) || (codec_id==GF_CODECID_THEORA) || (codec_id==GF_CODECID_OPUS)) {\n\t\t\tchar *outname = dumper->out_name;\n\t\t\tif (outname && !strcmp(outname, \"std\")) outname=NULL;\n\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\treturn gf_dump_to_ogg(dumper, outname, track_num);\n#else\n\t\t\treturn GF_NOT_SUPPORTED;\n#endif\n\n\t\t}\n\t\tif (codec_id==GF_CODECID_SUBPIC) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\tchar *dsi = NULL;\n\t\t\tu32 dsi_size = 0;\n\t\t\tif (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\tdsi = esd->decoderConfig->decoderSpecificInfo->data;\n\t\t\t\tdsi_size = esd->decoderConfig->decoderSpecificInfo->dataLength;\n\t\t\t}\n\t\t\te = gf_dump_to_vobsub(dumper, dumper->out_name, track_num, dsi, dsi_size);\n#else\n\t\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\treturn e;\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\t} else {\n\t\tconst char *export_ext = dumper->out_name ? gf_file_ext_start(dumper->out_name) : NULL;\n\t\tskip_write_filter = GF_TRUE;\n\t\tif (!export_ext)\n\t\t\tuse_dynext = GF_TRUE;\n\t}\n\n\tfsess = gf_fs_new_defaults(0);\n\tif (!fsess) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Failed to create filter session\\n\"));\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tfile_out = NULL;\n\targs = NULL;\n\n\tif (dumper->flags & GF_EXPORT_REMUX) {\n\t\tfile_out = gf_fs_load_destination(fsess, dumper->out_name, NULL, NULL, &e);\n\t\tif (!file_out) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot open destination %s\\n\", dumper->out_name));\n\t\t\treturn e;\n\t\t}\n\t}\n\t//except in nhml inband file dump, create a sink filter\n\telse if (!dumper->dump_file) {\n\t\tBool no_ext = (dumper->flags & GF_EXPORT_NO_FILE_EXT) ? GF_TRUE : GF_FALSE;\n\t\tchar *ext = gf_file_ext_start(dumper->out_name);\n\t\t//mux args, for now we only dump to file\n\t\te = gf_dynstrcat(&args, \"fout:dst=\", NULL);\n\t\te |= gf_dynstrcat(&args, dumper->out_name, NULL);\n\n\t\tif (dumper->flags & GF_EXPORT_NHNT) {\n\t\t\tstrcpy(szExt, \"nhnt\");\n\t\t\te |= gf_dynstrcat(&args, \":clone\", NULL);\n\t\t\tno_ext = GF_TRUE;\n\t\t\tif (!ext)\n\t\t\t\te |= gf_dynstrcat(&args, \":dynext\", NULL);\n\t\t} else if (dumper->flags & GF_EXPORT_NHML) {\n\t\t\tstrcpy(szExt, \"nhml\");\n\t\t\te |= gf_dynstrcat(&args, \":clone\", NULL);\n\t\t\tno_ext = GF_TRUE;\n\t\t\tif (!ext)\n\t\t\t\te |= gf_dynstrcat(&args, \":dynext\", NULL);\n\t\t}\n\n\t\tif (dumper->flags & GF_EXPORT_RAW_SAMPLES) {\n\t\t\tif (!dumper->sample_num) {\n\n\t\t\t\text = gf_file_ext_start(args);\n\t\t\t\tif (ext) ext[0] = 0;\n\t\t\t\tif (sample_count>=1000) {\n\t\t\t\t\te |= gf_dynstrcat(&args, \"_$num%08d$\", NULL);\n\t\t\t\t} else if (sample_count) {\n\t\t\t\t\te |= gf_dynstrcat(&args, \"_$num%03d$\", NULL);\n\t\t\t\t} else {\n\t\t\t\t\te |= gf_dynstrcat(&args, \"_$num$\", NULL);\n\t\t\t\t}\n\t\t\t\text = gf_file_ext_start(dumper->out_name);\n\t\t\t\tif (ext) e |= gf_dynstrcat(&args, ext, NULL);\n\t\t\t}\n\t\t\te |= gf_dynstrcat(&args, \":dynext\", NULL);\n\t\t} else if (dumper->trackID && strlen(szExt) ) {\n\t\t\tif (!no_ext && !gf_file_ext_start(dumper->out_name)) {\n\t\t\t\tif (args) gf_free(args);\n\t\t\t\targs=NULL;\n\t\t\t\te = gf_dynstrcat(&args, \"fout:dst=\", NULL);\n\t\t\t\te |= gf_dynstrcat(&args, dumper->out_name, NULL);\n\t\t\t\te |= gf_dynstrcat(&args, szExt, \".\");\n\t\t\t} else {\n\t\t\t\te |= gf_dynstrcat(&args, \":ext=\", NULL);\n\t\t\t\te |= gf_dynstrcat(&args, szExt, NULL);\n\t\t\t}\n\t\t} else if ((dumper->trackID || dumper->track_type) && use_dynext) {\n\t\t\te |= gf_dynstrcat(&args, \":dynext\", NULL);\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load arguments for output file dumper\\n\"));\n\t\t\tif (args) gf_free(args);\n\t\t\tgf_fs_del(fsess);\n\t\t\treturn e;\n\t\t}\n\n\t\tfile_out = gf_fs_load_filter(fsess, args, &e);\n\t\tif (!file_out) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tif (args) gf_free(args);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load output file dumper\\n\"));\n\t\t\treturn e;\n\t\t}\n\t}\n\tif (args) gf_free(args);\n\targs = NULL;\n\n\t//raw sample frame, force loading filter generic write in frame mode\n\tif (dumper->flags & GF_EXPORT_RAW_SAMPLES) {\n\t\te = gf_dynstrcat(&args, \"writegen:frame\", NULL);\n\t\tif (dumper->sample_num) {\n\t\t\tsprintf(szSubArgs, \":sstart=%d:send=%d\", dumper->sample_num, dumper->sample_num);\n\t\t\te |= gf_dynstrcat(&args, szSubArgs, NULL);\n\t\t}\n\t\tremux = e ? NULL : gf_fs_load_filter(fsess, args, &e);\n\t\tif (!remux || e) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load stream->file filter\\n\"));\n\t\t\tif (args) gf_free(args);\n\t\t\treturn e ? e : GF_FILTER_NOT_FOUND;\n\t\t}\n\t}\n\telse if (dumper->flags & GF_EXPORT_NHNT) {\n\t\tremux = gf_fs_load_filter(fsess, \"nhntw:exporter\", &e);\n\t\tif (!remux) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load NHNT write filter\\n\"));\n\t\t\treturn e;\n\t\t}\n\t}\n\telse if (dumper->flags & GF_EXPORT_NHML) {\n\t\te = gf_dynstrcat(&args, \"nhmlw:exporter:name=\", NULL);\n\t\te |= gf_dynstrcat(&args, dumper->out_name, NULL);\n\t\tif (dumper->flags & GF_EXPORT_NHML_FULL)\n\t\t\te |= gf_dynstrcat(&args, \":pckp\", NULL);\n\t\tif (dumper->dump_file) {\n\t\t\tsprintf(szSubArgs, \":nhmlonly:filep=%p\", dumper->dump_file);\n\t\t\te |= gf_dynstrcat(&args, szSubArgs, NULL);\n\t\t}\n\t\tremux = e ? NULL : gf_fs_load_filter(fsess, args, &e);\n\t\tif (!remux || e) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tif (args) gf_free(args);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load NHML write filter\\n\"));\n\t\t\treturn e ? e : GF_FILTER_NOT_FOUND;\n\t\t}\n\t} else if (!skip_write_filter) {\n\t\te = gf_dynstrcat(&args, \"writegen:exporter\", NULL);\n\t\t//extension has been forced, override ext at output of writegen\n\t\tif (ext_forced) {\n\t\t\te |= gf_dynstrcat(&args, \":#Extension=\", NULL);\n\t\t\te |= gf_dynstrcat(&args, szExt, NULL);\n\t\t}\n\n\t\tremux = e ? NULL : gf_fs_load_filter(fsess, args, &e);\n\t\tif (!remux) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tif (args) gf_free(args);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load stream->file filter\\n\"));\n\t\t\treturn e;\n\t\t}\n\t}\n\tif (args) gf_free(args);\n\targs = NULL;\n\n\t//force a reframer filter, connected to our input\n\te = gf_dynstrcat(&args, \"reframer:SID=1\", NULL);\n\tif (dumper->trackID) {\n\t\tsprintf(szSubArgs, \"#PID=%d\", dumper->trackID);\n\t\te |= gf_dynstrcat(&args, szSubArgs, NULL);\n\t}\n\te |= gf_dynstrcat(&args, \":exporter\", NULL);\n\tif (dumper->flags & GF_EXPORT_SVC_LAYER)\n\t\te |= gf_dynstrcat(&args, \":extract=layer\", NULL);\n\tif (dumper->flags & GF_EXPORT_WEBVTT_NOMERGE)\n\t\te |= gf_dynstrcat(&args, \":merge\", NULL);\n\n\treframer = gf_fs_load_filter(fsess, args, &e);\n\tif (!reframer || e) {\n\t\tgf_fs_del(fsess);\n\t\tif (args) gf_free(args);\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load reframer filter\\n\"));\n\t\treturn e ? e : GF_FILTER_NOT_FOUND;\n\t}\n\tif (args) gf_free(args);\n\targs = NULL;\n\n\t//we already have the file loaded, directly load the mp4dmx filter with this file\n\tif (dumper->file) {\n\t\t//we want to expose every track\n\t\te = gf_dynstrcat(&args, \"mp4dmx:FID=1:noedit:alltk:allt\", NULL);\n\t\tif (!e) {\n\t\t\tsprintf(szSubArgs, \":mov=%p\", dumper->file);\n\t\t\te = gf_dynstrcat(&args, szSubArgs, NULL);\n\t\t}\n\t\t\n\t\t//we want to expose every track\n\t\tsrc_filter = gf_fs_load_filter(fsess, args, &e);\n\n\t\tgf_free(args);\n\t\targs = NULL;\n\t} else {\n\t\t//we want to expose every track\n\t\tsrc_filter = gf_fs_load_source(fsess, dumper->in_name, \"FID=1:noedit:alltk:allt\", NULL, &e);\n\t}\n\n\tif (!src_filter || e) {\n\t\tgf_fs_del(fsess);\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load filter for input file \\\"%s\\\": %s\\n\", dumper->in_name, gf_error_to_string(e) ));\n\t\treturn e;\n\t}\n\n\tif (dumper->track_type) {\n\t\tconst char *mtype = (dumper->track_type==1) ? \"video\" : \"audio\";\n\t\tif (dumper->trackID) {\n\t\t\tsprintf(szSubArgs, \"%s%d\", mtype, dumper->trackID);\n\t\t} else {\n\t\t\tsprintf(szSubArgs, \"%s\", mtype);\n\t\t}\n\t}\n\telse if (dumper->trackID) {\n\t\tsprintf(szSubArgs, \"PID=%d\", dumper->trackID);\n\t}\n\tif (remux) {\n\t\tgf_filter_set_source(file_out, remux, (dumper->trackID || dumper->track_type) ? szSubArgs : NULL);\n\t\tgf_filter_set_source(remux, reframer, (dumper->trackID || dumper->track_type) ? szSubArgs : NULL);\n\t} else {\n\t\tgf_filter_set_source(file_out, reframer, (dumper->trackID || dumper->track_type) ? szSubArgs : NULL);\n\t}\n\n\te = gf_fs_run(fsess);\n\tif (e>GF_OK) e = GF_OK;\n\tif (!e) e = gf_fs_get_last_connect_error(fsess);\n\tif (!e) e = gf_fs_get_last_process_error(fsess);\n\n\tif (!e) {\n\t\tif (dumper->file)\n\t\t\tgf_fs_print_unused_args(fsess, NULL);\n\t\telse\n\t\t\tgf_fs_print_unused_args(fsess, \"alltk,allt,noedit\");\n\t}\n\tgf_fs_print_non_connected(fsess);\n\tif (dumper->print_stats_graph & 1) gf_fs_print_stats(fsess);\n\tif (dumper->print_stats_graph & 2) gf_fs_print_connections(fsess);\n\tgf_fs_del(fsess);\n\treturn e;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144901,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int amf_namf_comm_handle_n1_n2_message_transfer(\n        ogs_sbi_stream_t *stream, ogs_sbi_message_t *recvmsg)\n{\n    int status;\n\n    amf_ue_t *amf_ue = NULL;\n    amf_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *n1buf = NULL;\n    ogs_pkbuf_t *n2buf = NULL;\n\n    ogs_pkbuf_t *gmmbuf = NULL;\n    ogs_pkbuf_t *ngapbuf = NULL;\n\n    char *supi = NULL;\n    uint8_t pdu_session_id = OGS_NAS_PDU_SESSION_IDENTITY_UNASSIGNED;\n\n    ogs_sbi_message_t sendmsg;\n    ogs_sbi_response_t *response = NULL;\n\n    OpenAPI_n1_n2_message_transfer_req_data_t *N1N2MessageTransferReqData;\n    OpenAPI_n1_n2_message_transfer_rsp_data_t N1N2MessageTransferRspData;\n    OpenAPI_n1_message_container_t *n1MessageContainer = NULL;\n    OpenAPI_ref_to_binary_data_t *n1MessageContent = NULL;\n    OpenAPI_n2_info_container_t *n2InfoContainer = NULL;\n    OpenAPI_n2_sm_information_t *smInfo = NULL;\n    OpenAPI_n2_info_content_t *n2InfoContent = NULL;\n    OpenAPI_ref_to_binary_data_t *ngapData = NULL;\n\n    ogs_assert(stream);\n    ogs_assert(recvmsg);\n\n    N1N2MessageTransferReqData = recvmsg->N1N2MessageTransferReqData;\n    if (!N1N2MessageTransferReqData) {\n        ogs_error(\"No N1N2MessageTransferReqData\");\n        return OGS_ERROR;\n    }\n\n    if (N1N2MessageTransferReqData->is_pdu_session_id == false) {\n        ogs_error(\"No PDU Session Identity\");\n        return OGS_ERROR;\n    }\n    pdu_session_id = N1N2MessageTransferReqData->pdu_session_id;\n\n    supi = recvmsg->h.resource.component[1];\n    if (!supi) {\n        ogs_error(\"No SUPI\");\n        return OGS_ERROR;\n    }\n\n    amf_ue = amf_ue_find_by_supi(supi);\n    if (!amf_ue) {\n        ogs_error(\"No UE context [%s]\", supi);\n        return OGS_ERROR;\n    }\n\n    sess = amf_sess_find_by_psi(amf_ue, pdu_session_id);\n    if (!sess) {\n        ogs_error(\"[%s] No PDU Session Context [%d]\",\n                amf_ue->supi, pdu_session_id);\n        return OGS_ERROR;\n    }\n\n    n1MessageContainer = N1N2MessageTransferReqData->n1_message_container;\n    if (n1MessageContainer) {\n        n1MessageContent = n1MessageContainer->n1_message_content;\n        if (!n1MessageContent || !n1MessageContent->content_id) {\n            ogs_error(\"No n1MessageContent\");\n            return OGS_ERROR;\n        }\n\n        n1buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, n1MessageContent->content_id);\n        if (!n1buf) {\n            ogs_error(\"[%s] No N1 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n1buf = ogs_pkbuf_copy(n1buf);\n        ogs_assert(n1buf);\n    }\n\n    n2InfoContainer = N1N2MessageTransferReqData->n2_info_container;\n    if (n2InfoContainer) {\n        smInfo = n2InfoContainer->sm_info;\n        if (!smInfo) {\n            ogs_error(\"No smInfo\");\n            return OGS_ERROR;\n        }\n        n2InfoContent = smInfo->n2_info_content;\n        if (!n2InfoContent) {\n            ogs_error(\"No n2InfoContent\");\n            return OGS_ERROR;\n        }\n\n        ngapData = n2InfoContent->ngap_data;\n        if (!ngapData || !ngapData->content_id) {\n            ogs_error(\"No ngapData\");\n            return OGS_ERROR;\n        }\n        n2buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, ngapData->content_id);\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n2buf = ogs_pkbuf_copy(n2buf);\n        ogs_assert(n2buf);\n    }\n\n    memset(&sendmsg, 0, sizeof(sendmsg));\n\n    status = OGS_SBI_HTTP_STATUS_OK;\n\n    memset(&N1N2MessageTransferRspData, 0, sizeof(N1N2MessageTransferRspData));\n    N1N2MessageTransferRspData.cause =\n        OpenAPI_n1_n2_message_transfer_cause_N1_N2_TRANSFER_INITIATED;\n\n    sendmsg.N1N2MessageTransferRspData = &N1N2MessageTransferRspData;\n\n    switch (n2InfoContent->ngap_ie_type) {\n    case OpenAPI_ngap_ie_type_PDU_RES_SETUP_REQ:\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n        }\n\n        if (gmmbuf) {\n            ran_ue_t *ran_ue = NULL;\n\n            /***********************************\n             * 4.3.2 PDU Session Establishment *\n             ***********************************/\n\n            ran_ue = ran_ue_cycle(amf_ue->ran_ue);\n            ogs_assert(ran_ue);\n\n            if (sess->pdu_session_establishment_accept) {\n                ogs_pkbuf_free(sess->pdu_session_establishment_accept);\n                sess->pdu_session_establishment_accept = NULL;\n            }\n\n            if (ran_ue->initial_context_setup_request_sent == true) {\n                ngapbuf = ngap_sess_build_pdu_session_resource_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n            } else {\n                ngapbuf = ngap_sess_build_initial_context_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n\n                ran_ue->initial_context_setup_request_sent = true;\n            }\n\n            if (SESSION_CONTEXT_IN_SMF(sess)) {\n                /*\n                 * [1-CLIENT] /nsmf-pdusession/v1/sm-contexts\n                 * [2-SERVER] /namf-comm/v1/ue-contexts/{supi}/n1-n2-messages\n                 *\n                 * If [2-SERVER] arrives after [1-CLIENT],\n                 * sm-context-ref is created in [1-CLIENT].\n                 * So, the PDU session establishment accpet can be transmitted.\n                 */\n                if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                    ogs_error(\"nas_5gs_send_to_gnb() failed\");\n            } else {\n                sess->pdu_session_establishment_accept = ngapbuf;\n            }\n\n        } else {\n            /*********************************************\n             * 4.2.3.3 Network Triggered Service Request *\n             *********************************************/\n\n            if (CM_IDLE(amf_ue)) {\n                ogs_sbi_server_t *server = NULL;\n                ogs_sbi_header_t header;\n                ogs_sbi_client_t *client = NULL;\n                ogs_sockaddr_t *addr = NULL;\n\n                if (!N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri) {\n                    ogs_error(\"[%s:%d] No n1-n2-failure-notification-uri\",\n                            amf_ue->supi, sess->psi);\n                    return OGS_ERROR;\n                }\n\n                addr = ogs_sbi_getaddr_from_uri(\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n                if (!addr) {\n                    ogs_error(\"[%s:%d] Invalid URI [%s]\",\n                            amf_ue->supi, sess->psi,\n                            N1N2MessageTransferReqData->\n                                n1n2_failure_txf_notif_uri);\n                    return OGS_ERROR;;\n                }\n\n                client = ogs_sbi_client_find(addr);\n                if (!client) {\n                    client = ogs_sbi_client_add(addr);\n                    ogs_assert(client);\n                }\n                OGS_SETUP_SBI_CLIENT(&sess->paging, client);\n\n                ogs_freeaddrinfo(addr);\n\n                status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n                /* Location */\n                server = ogs_sbi_server_from_stream(stream);\n                ogs_assert(server);\n\n                memset(&header, 0, sizeof(header));\n                header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n                header.api.version = (char *)OGS_SBI_API_V1;\n                header.resource.component[0] =\n                    (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n                header.resource.component[1] = amf_ue->supi;\n                header.resource.component[2] =\n                    (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n                header.resource.component[3] = sess->sm_context_ref;\n\n                sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n                /* Store Paging Info */\n                AMF_SESS_STORE_PAGING_INFO(\n                        sess, sendmsg.http.location,\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n\n                /* Store N2 Transfer message */\n                AMF_SESS_STORE_N2_TRANSFER(\n                        sess, pdu_session_resource_setup_request, n2buf);\n\n                ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n            } else if (CM_CONNECTED(amf_ue)) {\n                ogs_assert(OGS_OK ==\n                    ngap_send_pdu_resource_setup_request(sess, n2buf));\n\n            } else {\n\n                ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n                ogs_assert_if_reached();\n\n            }\n\n        }\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_MOD_REQ:\n        if (!n1buf) {\n            ogs_error(\"[%s] No N1 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (CM_IDLE(amf_ue)) {\n            ogs_sbi_server_t *server = NULL;\n            ogs_sbi_header_t header;\n\n            status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n            N1N2MessageTransferRspData.cause =\n                OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n            /* Location */\n            server = ogs_sbi_server_from_stream(stream);\n            ogs_assert(server);\n\n            memset(&header, 0, sizeof(header));\n            header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n            header.api.version = (char *)OGS_SBI_API_V1;\n            header.resource.component[0] =\n                (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n            header.resource.component[1] = amf_ue->supi;\n            header.resource.component[2] =\n                (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n            header.resource.component[3] = sess->sm_context_ref;\n\n            sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n            /* Store Paging Info */\n            AMF_SESS_STORE_PAGING_INFO(\n                    sess, sendmsg.http.location, NULL);\n\n            /* Store 5GSM Message */\n            AMF_SESS_STORE_5GSM_MESSAGE(sess,\n                    OGS_NAS_5GS_PDU_SESSION_MODIFICATION_COMMAND,\n                    n1buf, n2buf);\n\n            ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n\n            ngapbuf = ngap_build_pdu_session_resource_modify_request(\n                    sess, gmmbuf, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\"nas_5gs_send_to_gnb() failed\");\n\n        } else {\n            ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_REL_CMD:\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf)\n            ogs_pkbuf_free(n1buf);\n\n        if (CM_IDLE(amf_ue)) {\n            if (n2buf)\n                ogs_pkbuf_free(n2buf);\n\n            if (N1N2MessageTransferReqData->is_skip_ind == true &&\n                N1N2MessageTransferReqData->skip_ind == true) {\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_N1_MSG_NOT_TRANSFERRED;\n            } else {\n                ogs_fatal(\"[%s] No skipInd\", amf_ue->supi);\n                ogs_assert_if_reached();\n            }\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            ngapbuf = ngap_build_pdu_session_resource_release_command(\n                    sess, NULL, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\"nas_5gs_send_to_gnb() failed\");\n\n        } else {\n            ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n        break;\n\n    default:\n        ogs_error(\"Not implemented ngap_ie_type[%d]\",\n                n2InfoContent->ngap_ie_type);\n        ogs_assert_if_reached();\n    }\n\n    response = ogs_sbi_build_response(&sendmsg, status);\n    ogs_assert(response);\n    ogs_assert(true == ogs_sbi_server_send_response(stream, response));\n\n    if (sendmsg.http.location)\n        ogs_free(sendmsg.http.location);\n\n    return OGS_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144916,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int amf_namf_comm_handle_n1_n2_message_transfer(\n        ogs_sbi_stream_t *stream, ogs_sbi_message_t *recvmsg)\n{\n    int status;\n\n    amf_ue_t *amf_ue = NULL;\n    amf_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *n1buf = NULL;\n    ogs_pkbuf_t *n2buf = NULL;\n\n    ogs_pkbuf_t *gmmbuf = NULL;\n    ogs_pkbuf_t *ngapbuf = NULL;\n\n    char *supi = NULL;\n    uint8_t pdu_session_id = OGS_NAS_PDU_SESSION_IDENTITY_UNASSIGNED;\n\n    ogs_sbi_message_t sendmsg;\n    ogs_sbi_response_t *response = NULL;\n\n    OpenAPI_n1_n2_message_transfer_req_data_t *N1N2MessageTransferReqData;\n    OpenAPI_n1_n2_message_transfer_rsp_data_t N1N2MessageTransferRspData;\n    OpenAPI_n1_message_container_t *n1MessageContainer = NULL;\n    OpenAPI_ref_to_binary_data_t *n1MessageContent = NULL;\n    OpenAPI_n2_info_container_t *n2InfoContainer = NULL;\n    OpenAPI_n2_sm_information_t *smInfo = NULL;\n    OpenAPI_n2_info_content_t *n2InfoContent = NULL;\n    OpenAPI_ref_to_binary_data_t *ngapData = NULL;\n\n    OpenAPI_ngap_ie_type_e ngapIeType = OpenAPI_ngap_ie_type_NULL;\n\n    ogs_assert(stream);\n    ogs_assert(recvmsg);\n\n    N1N2MessageTransferReqData = recvmsg->N1N2MessageTransferReqData;\n    if (!N1N2MessageTransferReqData) {\n        ogs_error(\"No N1N2MessageTransferReqData\");\n        return OGS_ERROR;\n    }\n\n    if (N1N2MessageTransferReqData->is_pdu_session_id == false) {\n        ogs_error(\"No PDU Session Identity\");\n        return OGS_ERROR;\n    }\n    pdu_session_id = N1N2MessageTransferReqData->pdu_session_id;\n\n    supi = recvmsg->h.resource.component[1];\n    if (!supi) {\n        ogs_error(\"No SUPI\");\n        return OGS_ERROR;\n    }\n\n    amf_ue = amf_ue_find_by_supi(supi);\n    if (!amf_ue) {\n        ogs_error(\"No UE context [%s]\", supi);\n        return OGS_ERROR;\n    }\n\n    sess = amf_sess_find_by_psi(amf_ue, pdu_session_id);\n    if (!sess) {\n        ogs_error(\"[%s] No PDU Session Context [%d]\",\n                amf_ue->supi, pdu_session_id);\n        return OGS_ERROR;\n    }\n\n    n1MessageContainer = N1N2MessageTransferReqData->n1_message_container;\n    if (n1MessageContainer) {\n        n1MessageContent = n1MessageContainer->n1_message_content;\n        if (!n1MessageContent || !n1MessageContent->content_id) {\n            ogs_error(\"No n1MessageContent\");\n            return OGS_ERROR;\n        }\n\n        n1buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, n1MessageContent->content_id);\n        if (!n1buf) {\n            ogs_error(\"[%s] No N1 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n1buf = ogs_pkbuf_copy(n1buf);\n        ogs_assert(n1buf);\n    }\n\n    n2InfoContainer = N1N2MessageTransferReqData->n2_info_container;\n    if (n2InfoContainer) {\n        smInfo = n2InfoContainer->sm_info;\n        if (!smInfo) {\n            ogs_error(\"No smInfo\");\n            return OGS_ERROR;\n        }\n\n        n2InfoContent = smInfo->n2_info_content;\n        if (!n2InfoContent) {\n            ogs_error(\"No n2InfoContent\");\n            return OGS_ERROR;\n        }\n\n        ngapIeType = n2InfoContent->ngap_ie_type;\n\n        ngapData = n2InfoContent->ngap_data;\n        if (!ngapData || !ngapData->content_id) {\n            ogs_error(\"No ngapData\");\n            return OGS_ERROR;\n        }\n        n2buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, ngapData->content_id);\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n2buf = ogs_pkbuf_copy(n2buf);\n        ogs_assert(n2buf);\n    }\n\n    memset(&sendmsg, 0, sizeof(sendmsg));\n\n    status = OGS_SBI_HTTP_STATUS_OK;\n\n    memset(&N1N2MessageTransferRspData, 0, sizeof(N1N2MessageTransferRspData));\n    N1N2MessageTransferRspData.cause =\n        OpenAPI_n1_n2_message_transfer_cause_N1_N2_TRANSFER_INITIATED;\n\n    sendmsg.N1N2MessageTransferRspData = &N1N2MessageTransferRspData;\n\n    switch (ngapIeType) {\n    case OpenAPI_ngap_ie_type_PDU_RES_SETUP_REQ:\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n        }\n\n        if (gmmbuf) {\n            ran_ue_t *ran_ue = NULL;\n\n            /***********************************\n             * 4.3.2 PDU Session Establishment *\n             ***********************************/\n\n            ran_ue = ran_ue_cycle(amf_ue->ran_ue);\n            ogs_assert(ran_ue);\n\n            if (sess->pdu_session_establishment_accept) {\n                ogs_pkbuf_free(sess->pdu_session_establishment_accept);\n                sess->pdu_session_establishment_accept = NULL;\n            }\n\n            if (ran_ue->initial_context_setup_request_sent == true) {\n                ngapbuf = ngap_sess_build_pdu_session_resource_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n            } else {\n                ngapbuf = ngap_sess_build_initial_context_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n\n                ran_ue->initial_context_setup_request_sent = true;\n            }\n\n            if (SESSION_CONTEXT_IN_SMF(sess)) {\n                /*\n                 * [1-CLIENT] /nsmf-pdusession/v1/sm-contexts\n                 * [2-SERVER] /namf-comm/v1/ue-contexts/{supi}/n1-n2-messages\n                 *\n                 * If [2-SERVER] arrives after [1-CLIENT],\n                 * sm-context-ref is created in [1-CLIENT].\n                 * So, the PDU session establishment accpet can be transmitted.\n                 */\n                if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                    ogs_error(\"nas_5gs_send_to_gnb() failed\");\n            } else {\n                sess->pdu_session_establishment_accept = ngapbuf;\n            }\n\n        } else {\n            /*********************************************\n             * 4.2.3.3 Network Triggered Service Request *\n             *********************************************/\n\n            if (CM_IDLE(amf_ue)) {\n                ogs_sbi_server_t *server = NULL;\n                ogs_sbi_header_t header;\n                ogs_sbi_client_t *client = NULL;\n                ogs_sockaddr_t *addr = NULL;\n\n                if (!N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri) {\n                    ogs_error(\"[%s:%d] No n1-n2-failure-notification-uri\",\n                            amf_ue->supi, sess->psi);\n                    return OGS_ERROR;\n                }\n\n                addr = ogs_sbi_getaddr_from_uri(\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n                if (!addr) {\n                    ogs_error(\"[%s:%d] Invalid URI [%s]\",\n                            amf_ue->supi, sess->psi,\n                            N1N2MessageTransferReqData->\n                                n1n2_failure_txf_notif_uri);\n                    return OGS_ERROR;;\n                }\n\n                client = ogs_sbi_client_find(addr);\n                if (!client) {\n                    client = ogs_sbi_client_add(addr);\n                    ogs_assert(client);\n                }\n                OGS_SETUP_SBI_CLIENT(&sess->paging, client);\n\n                ogs_freeaddrinfo(addr);\n\n                status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n                /* Location */\n                server = ogs_sbi_server_from_stream(stream);\n                ogs_assert(server);\n\n                memset(&header, 0, sizeof(header));\n                header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n                header.api.version = (char *)OGS_SBI_API_V1;\n                header.resource.component[0] =\n                    (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n                header.resource.component[1] = amf_ue->supi;\n                header.resource.component[2] =\n                    (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n                header.resource.component[3] = sess->sm_context_ref;\n\n                sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n                /* Store Paging Info */\n                AMF_SESS_STORE_PAGING_INFO(\n                        sess, sendmsg.http.location,\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n\n                /* Store N2 Transfer message */\n                AMF_SESS_STORE_N2_TRANSFER(\n                        sess, pdu_session_resource_setup_request, n2buf);\n\n                ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n            } else if (CM_CONNECTED(amf_ue)) {\n                ogs_assert(OGS_OK ==\n                    ngap_send_pdu_resource_setup_request(sess, n2buf));\n\n            } else {\n\n                ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n                ogs_assert_if_reached();\n\n            }\n\n        }\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_MOD_REQ:\n        if (!n1buf) {\n            ogs_error(\"[%s] No N1 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (CM_IDLE(amf_ue)) {\n            ogs_sbi_server_t *server = NULL;\n            ogs_sbi_header_t header;\n\n            status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n            N1N2MessageTransferRspData.cause =\n                OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n            /* Location */\n            server = ogs_sbi_server_from_stream(stream);\n            ogs_assert(server);\n\n            memset(&header, 0, sizeof(header));\n            header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n            header.api.version = (char *)OGS_SBI_API_V1;\n            header.resource.component[0] =\n                (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n            header.resource.component[1] = amf_ue->supi;\n            header.resource.component[2] =\n                (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n            header.resource.component[3] = sess->sm_context_ref;\n\n            sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n            /* Store Paging Info */\n            AMF_SESS_STORE_PAGING_INFO(\n                    sess, sendmsg.http.location, NULL);\n\n            /* Store 5GSM Message */\n            AMF_SESS_STORE_5GSM_MESSAGE(sess,\n                    OGS_NAS_5GS_PDU_SESSION_MODIFICATION_COMMAND,\n                    n1buf, n2buf);\n\n            ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n\n            ngapbuf = ngap_build_pdu_session_resource_modify_request(\n                    sess, gmmbuf, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\"nas_5gs_send_to_gnb() failed\");\n\n        } else {\n            ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_REL_CMD:\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf)\n            ogs_pkbuf_free(n1buf);\n\n        if (CM_IDLE(amf_ue)) {\n            if (n2buf)\n                ogs_pkbuf_free(n2buf);\n\n            if (N1N2MessageTransferReqData->is_skip_ind == true &&\n                N1N2MessageTransferReqData->skip_ind == true) {\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_N1_MSG_NOT_TRANSFERRED;\n            } else {\n                ogs_fatal(\"[%s] No skipInd\", amf_ue->supi);\n                ogs_assert_if_reached();\n            }\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            ngapbuf = ngap_build_pdu_session_resource_release_command(\n                    sess, NULL, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\"nas_5gs_send_to_gnb() failed\");\n\n        } else {\n            ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n        break;\n\n    default:\n        ogs_error(\"Not implemented ngapIeType[%d]\", ngapIeType);\n        ogs_assert_if_reached();\n    }\n\n    response = ogs_sbi_build_response(&sendmsg, status);\n    ogs_assert(response);\n    ogs_assert(true == ogs_sbi_server_send_response(stream, response));\n\n    if (sendmsg.http.location)\n        ogs_free(sendmsg.http.location);\n\n    return OGS_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144917,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err gf_bifs_dec_sf_field(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)\n{\n\tGF_Err e;\n\tGF_Node *new_node;\n\tu32 size, length, w, h, i;\n\tchar *buffer;\n\n\t//blindly call unquantize. return is OK, error or GF_EOS\n\tif (codec->ActiveQP && node) {\n\t\te = gf_bifs_dec_unquant_field(codec, bs, node, field);\n\t\tif (e != GF_EOS) return e;\n\t}\n\t//not quantized, use normal scheme\n\tswitch (field->fieldType) {\n\tcase GF_SG_VRML_SFBOOL:\n\t\t* ((SFBool *) field->far_ptr) = (SFBool) gf_bs_read_int(bs, 1);\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLOR:\n\t\t((SFColor *)field->far_ptr)->red = BD_ReadSFFloat(codec, bs);\n\t\t((SFColor *)field->far_ptr)->green = BD_ReadSFFloat(codec, bs);\n\t\t((SFColor *)field->far_ptr)->blue = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFFLOAT:\n\t\t*((SFFloat *)field->far_ptr) = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFINT32:\n\t\t*((SFInt32 *)field->far_ptr) = (s32) gf_bs_read_int(bs, 32);\n\t\tbreak;\n\tcase GF_SG_VRML_SFTIME:\n\t\t*((SFTime *)field->far_ptr) = gf_bs_read_double(bs);\n\t\tif (node) BD_CheckSFTimeOffset(codec, node, field);\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC2F:\n\t\t((SFVec2f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);\n\t\t((SFVec2f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC3F:\n\t\t((SFVec3f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);\n\t\t((SFVec3f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);\n\t\t((SFVec3f *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFROTATION:\n\t\t((SFRotation *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);\n\t\t((SFRotation *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);\n\t\t((SFRotation *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);\n\t\t((SFRotation *)field->far_ptr)->q = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFSTRING:\n\t\tsize = gf_bs_read_int(bs, 5);\n\t\tlength = gf_bs_read_int(bs, size);\n\t\tif (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tif (node && (node->sgprivate->tag==TAG_MPEG4_CacheTexture) && (field->fieldIndex<=2)) {\n\t\t\tM_CacheTexture *ct = (M_CacheTexture *) node;\n\t\t\tct->data_len = length;\n\t\t\tif (ct->data) gf_free(ct->data);\n\t\t\tct->data = (u8*)gf_malloc(sizeof(char)*length);\n\t\t\tgf_bs_read_data(bs, (char*)ct->data, length);\n\t\t} else if (node && (node->sgprivate->tag==TAG_MPEG4_BitWrapper) ) {\n\t\t\tM_BitWrapper *bw = (M_BitWrapper*) node;\n\t\t\tif (bw->buffer.buffer) gf_free(bw->buffer.buffer);\n\t\t\tbw->buffer_len = length;\n\t\t\tbw->buffer.buffer = (char*)gf_malloc(sizeof(char)*length);\n\t\t\tgf_bs_read_data(bs, (char*)bw->buffer.buffer, length);\n\t\t} else {\n\t\t\tif ( ((SFString *)field->far_ptr)->buffer ) gf_free( ((SFString *)field->far_ptr)->buffer);\n\t\t\t((SFString *)field->far_ptr)->buffer = (char *)gf_malloc(sizeof(char)*(length+1));\n\t\t\tmemset(((SFString *)field->far_ptr)->buffer , 0, length+1);\n\t\t\tfor (i=0; i<length; i++) {\n\t\t\t\t((SFString *)field->far_ptr)->buffer[i] = gf_bs_read_int(bs, 8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_SG_VRML_SFURL:\n\t{\n\t\tSFURL *url = (SFURL *) field->far_ptr;\n\t\tsize = gf_bs_read_int(bs, 1);\n\t\tif (size) {\n\t\t\tif (url->url) gf_free(url->url );\n\t\t\turl->url = NULL;\n\t\t\tlength = gf_bs_read_int(bs, 10);\n\t\t\turl->OD_ID = length;\n\t\t} else {\n\t\t\tif ( url->OD_ID ) url->OD_ID = (u32) -1;\n\t\t\tsize = gf_bs_read_int(bs, 5);\n\t\t\tlength = gf_bs_read_int(bs, size);\n\t\t\tif (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tbuffer = NULL;\n\t\t\tif (length) {\n\t\t\t\tbuffer = (char *)gf_malloc(sizeof(char)*(length+1));\n\t\t\t\tmemset(buffer, 0, length+1);\n\t\t\t\tfor (i=0; i<length; i++) buffer[i] = gf_bs_read_int(bs, 8);\n\t\t\t}\n\t\t\tif (url->url) gf_free( url->url);\n\t\t\t/*if URL is empty set it to NULL*/\n\t\t\tif (buffer && strlen(buffer)) {\n\t\t\t\turl->url = buffer;\n\t\t\t} else {\n\t\t\t\tgf_free(buffer);\n\t\t\t\turl->url = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFIMAGE:\n\t\tif (((SFImage *)field->far_ptr)->pixels) {\n\t\t\tgf_free(((SFImage *)field->far_ptr)->pixels);\n\t\t\t((SFImage *)field->far_ptr)->pixels = NULL;\n\t\t}\n\t\tw = gf_bs_read_int(bs, 12);\n\t\th = gf_bs_read_int(bs, 12);\n\t\tlength = gf_bs_read_int(bs, 2);\n\n\t\tif (length > 3) length = 3;\n\t\tlength += 1;\n\t\tsize = w * h * length;\n\t\tif (gf_bs_available(bs) < size) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t((SFImage *)field->far_ptr)->width = w;\n\t\t((SFImage *)field->far_ptr)->height = h;\n\t\t((SFImage *)field->far_ptr)->numComponents = length;\n\t\t((SFImage *)field->far_ptr)->pixels = (unsigned char *)gf_malloc(sizeof(char)*size);\n\t\t//WARNING: Buffers are NOT ALIGNED IN THE BITSTREAM\n\t\tfor (i=0; i<size; i++) {\n\t\t\t((SFImage *)field->far_ptr)->pixels[i] = gf_bs_read_int(bs, 8);\n\t\t}\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t{\n\t\tSFCommandBuffer *sfcb = (SFCommandBuffer *)field->far_ptr;\n\t\tif (!node) return GF_BAD_PARAM;\n\t\tif (sfcb->buffer) {\n\t\t\tgf_free(sfcb->buffer);\n\t\t\tsfcb->buffer = NULL;\n\t\t}\n\t\twhile (gf_list_count(sfcb->commandList)) {\n\t\t\tGF_Command *com = (GF_Command*)gf_list_get(sfcb->commandList, 0);\n\t\t\tgf_list_rem(sfcb->commandList, 0);\n\t\t\tgf_sg_command_del(com);\n\t\t}\n\n\t\tsize = gf_bs_read_int(bs, 5);\n\t\tlength = gf_bs_read_int(bs, size);\n\t\tif (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tsfcb->bufferSize = length;\n\t\tif (length) {\n\t\t\tsfcb->buffer = (unsigned char *)gf_malloc(sizeof(char)*(length));\n\t\t\t//WARNING Buffers are NOT ALIGNED IN THE BITSTREAM\n\t\t\tfor (i=0; i<length; i++) {\n\t\t\t\tsfcb->buffer[i] = gf_bs_read_int(bs, 8);\n\t\t\t}\n\t\t}\n\t\t//notify the node - this is needed in case an enhencement layer replaces the buffer, in which case\n\t\t//the # ID Bits may change\n\t\tSFCommandBufferChanged(codec, node);\n\n\t\t/*\n\t\t 1 - memory mode, register command buffer for later parsing\n\t\t 2 - InputSensor only works on decompressed commands\n\t\t*/\n\t\tif (codec->dec_memory_mode || (node->sgprivate->tag==TAG_MPEG4_InputSensor)) {\n\t\t\tCommandBufferItem *cbi = (CommandBufferItem *)gf_malloc(sizeof(CommandBufferItem));\n\t\t\tcbi->node = node;\n\t\t\tgf_node_register(cbi->node, NULL);\n\t\t\tcbi->cb = sfcb;\n\t\t\tgf_list_add(codec->command_buffers, cbi);\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFNODE:\n\t\t//if not memory dec mode, unregister previous node\n\t\t//otherwise the field points to the memory command internal field\n\t\tif (!is_mem_com) {\n\t\t\tGF_Node *old_node = *((GF_Node **) field->far_ptr);\n\t\t\tif (old_node != NULL) {\n\t\t\t\tu32 i, count = gf_list_count(codec->command_buffers);\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tCommandBufferItem *cbi = (CommandBufferItem*) gf_list_get(codec->command_buffers, i);\n\t\t\t\t\tif (cbi->node == old_node) {\n\t\t\t\t\t\tgf_list_rem(codec->command_buffers, i);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t\tgf_node_unregister(cbi->node, NULL);\n\t\t\t\t\t\tgf_free(cbi);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_node_unregister(old_node, node);\n\t\t\t\t *((GF_Node **) field->far_ptr) = NULL;\n\t\t\t}\n\t\t}\n\t\t//for nodes the field ptr is a ptr to the field, which is a node ptr ;)\n\t\tnew_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n\t\tif (new_node) {\n\t\t\te = gf_node_register(new_node, is_mem_com ? NULL : node);\n\t\t\tif (e) return e;\n\t\t}\n\t\t//it may happen that new_node is NULL (this is valid for a proto declaration)\n\t\t*((GF_Node **) field->far_ptr) = new_node;\n\t\tbreak;\n\tcase GF_SG_VRML_SFSCRIPT:\n#ifdef GPAC_HAS_QJS\n\t\tcodec->LastError = node ? SFScript_Parse(codec, (SFScript*)field->far_ptr, bs, node) : GF_NON_COMPLIANT_BITSTREAM;\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t\tbreak;\n\tcase GF_SG_VRML_SFATTRREF:\n\t{\n\t\tSFAttrRef *ar = (SFAttrRef *)field->far_ptr;\n\t\tu32 nodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t\tar->node = gf_sg_find_node(codec->current_graph, nodeID);\n\t\tif (!ar->node) {\n\n\t\t} else {\n\t\t\tu32 nbBitsDEF = gf_get_bit_size(gf_node_get_num_fields_in_mode(ar->node, GF_SG_FIELD_CODING_DEF) - 1);\n\t\t\tu32 field_ref = gf_bs_read_int(bs, nbBitsDEF);\n\t\t\tcodec->LastError = gf_bifs_get_field_index(ar->node, field_ref, GF_SG_FIELD_CODING_DEF, &ar->fieldIndex);\n\t\t}\n\t}\n\tbreak;\n\tdefault:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\treturn codec->LastError;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144918,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err gf_bifs_dec_sf_field(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)\n{\n\tGF_Err e;\n\tGF_Node *new_node;\n\tu32 size, length, w, h, i;\n\tchar *buffer;\n\n\t//blindly call unquantize. return is OK, error or GF_EOS\n\tif (codec->ActiveQP && node) {\n\t\te = gf_bifs_dec_unquant_field(codec, bs, node, field);\n\t\tif (e != GF_EOS) return e;\n\t}\n\t//not quantized, use normal scheme\n\tswitch (field->fieldType) {\n\tcase GF_SG_VRML_SFBOOL:\n\t\t* ((SFBool *) field->far_ptr) = (SFBool) gf_bs_read_int(bs, 1);\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLOR:\n\t\t((SFColor *)field->far_ptr)->red = BD_ReadSFFloat(codec, bs);\n\t\t((SFColor *)field->far_ptr)->green = BD_ReadSFFloat(codec, bs);\n\t\t((SFColor *)field->far_ptr)->blue = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFFLOAT:\n\t\t*((SFFloat *)field->far_ptr) = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFINT32:\n\t\t*((SFInt32 *)field->far_ptr) = (s32) gf_bs_read_int(bs, 32);\n\t\tbreak;\n\tcase GF_SG_VRML_SFTIME:\n\t\t*((SFTime *)field->far_ptr) = gf_bs_read_double(bs);\n\t\tif (node) BD_CheckSFTimeOffset(codec, node, field);\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC2F:\n\t\t((SFVec2f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);\n\t\t((SFVec2f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC3F:\n\t\t((SFVec3f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);\n\t\t((SFVec3f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);\n\t\t((SFVec3f *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFROTATION:\n\t\t((SFRotation *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);\n\t\t((SFRotation *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);\n\t\t((SFRotation *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);\n\t\t((SFRotation *)field->far_ptr)->q = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFSTRING:\n\t\tsize = gf_bs_read_int(bs, 5);\n\t\tlength = gf_bs_read_int(bs, size);\n\t\tif (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tif (node && (node->sgprivate->tag==TAG_MPEG4_CacheTexture) && (field->fieldIndex<=2)) {\n\t\t\tM_CacheTexture *ct = (M_CacheTexture *) node;\n\t\t\tct->data_len = length;\n\t\t\tif (ct->data) gf_free(ct->data);\n\t\t\tct->data = (u8*)gf_malloc(sizeof(char)*length);\n\t\t\tgf_bs_read_data(bs, (char*)ct->data, length);\n\t\t} else if (node && (node->sgprivate->tag==TAG_MPEG4_BitWrapper) ) {\n\t\t\tM_BitWrapper *bw = (M_BitWrapper*) node;\n\t\t\tif (bw->buffer.buffer) gf_free(bw->buffer.buffer);\n\t\t\tbw->buffer_len = length;\n\t\t\tbw->buffer.buffer = (char*)gf_malloc(sizeof(char)*length);\n\t\t\tgf_bs_read_data(bs, (char*)bw->buffer.buffer, length);\n\t\t} else {\n\t\t\tif ( ((SFString *)field->far_ptr)->buffer ) gf_free( ((SFString *)field->far_ptr)->buffer);\n\t\t\t((SFString *)field->far_ptr)->buffer = (char *)gf_malloc(sizeof(char)*(length+1));\n\t\t\tmemset(((SFString *)field->far_ptr)->buffer , 0, length+1);\n\t\t\tfor (i=0; i<length; i++) {\n\t\t\t\t((SFString *)field->far_ptr)->buffer[i] = gf_bs_read_int(bs, 8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_SG_VRML_SFURL:\n\t{\n\t\tSFURL *url = (SFURL *) field->far_ptr;\n\t\tsize = gf_bs_read_int(bs, 1);\n\t\tif (size) {\n\t\t\tif (url->url) gf_free(url->url );\n\t\t\turl->url = NULL;\n\t\t\tlength = gf_bs_read_int(bs, 10);\n\t\t\turl->OD_ID = length;\n\t\t} else {\n\t\t\tif ( url->OD_ID ) url->OD_ID = (u32) -1;\n\t\t\tsize = gf_bs_read_int(bs, 5);\n\t\t\tlength = gf_bs_read_int(bs, size);\n\t\t\tif (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tbuffer = NULL;\n\t\t\tif (length) {\n\t\t\t\tbuffer = (char *)gf_malloc(sizeof(char)*(length+1));\n\t\t\t\tmemset(buffer, 0, length+1);\n\t\t\t\tfor (i=0; i<length; i++) buffer[i] = gf_bs_read_int(bs, 8);\n\t\t\t}\n\t\t\tif (url->url) gf_free( url->url);\n\t\t\t/*if URL is empty set it to NULL*/\n\t\t\tif (buffer && strlen(buffer)) {\n\t\t\t\turl->url = buffer;\n\t\t\t} else {\n\t\t\t\tgf_free(buffer);\n\t\t\t\turl->url = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFIMAGE:\n\t\tif (((SFImage *)field->far_ptr)->pixels) {\n\t\t\tgf_free(((SFImage *)field->far_ptr)->pixels);\n\t\t\t((SFImage *)field->far_ptr)->pixels = NULL;\n\t\t}\n\t\tw = gf_bs_read_int(bs, 12);\n\t\th = gf_bs_read_int(bs, 12);\n\t\tlength = gf_bs_read_int(bs, 2);\n\n\t\tif (length > 3) length = 3;\n\t\tlength += 1;\n\t\tsize = w * h * length;\n\t\tif (gf_bs_available(bs) < size) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t((SFImage *)field->far_ptr)->width = w;\n\t\t((SFImage *)field->far_ptr)->height = h;\n\t\t((SFImage *)field->far_ptr)->numComponents = length;\n\t\t((SFImage *)field->far_ptr)->pixels = (unsigned char *)gf_malloc(sizeof(char)*size);\n\t\t//WARNING: Buffers are NOT ALIGNED IN THE BITSTREAM\n\t\tfor (i=0; i<size; i++) {\n\t\t\t((SFImage *)field->far_ptr)->pixels[i] = gf_bs_read_int(bs, 8);\n\t\t}\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t{\n\t\tSFCommandBuffer *sfcb = (SFCommandBuffer *)field->far_ptr;\n\t\tif (!node) return GF_BAD_PARAM;\n\t\tif (sfcb->buffer) {\n\t\t\tgf_free(sfcb->buffer);\n\t\t\tsfcb->buffer = NULL;\n\t\t\tsfcb->bufferSize = 0;\n\t\t}\n\t\twhile (gf_list_count(sfcb->commandList)) {\n\t\t\tGF_Command *com = (GF_Command*)gf_list_get(sfcb->commandList, 0);\n\t\t\tgf_list_rem(sfcb->commandList, 0);\n\t\t\tgf_sg_command_del(com);\n\t\t}\n\n\t\tsize = gf_bs_read_int(bs, 5);\n\t\tlength = gf_bs_read_int(bs, size);\n\t\tif (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tsfcb->bufferSize = length;\n\t\tif (length) {\n\t\t\tsfcb->buffer = (unsigned char *)gf_malloc(sizeof(char)*(length));\n\t\t\t//WARNING Buffers are NOT ALIGNED IN THE BITSTREAM\n\t\t\tfor (i=0; i<length; i++) {\n\t\t\t\tsfcb->buffer[i] = gf_bs_read_int(bs, 8);\n\t\t\t}\n\t\t}\n\t\t//notify the node - this is needed in case an enhencement layer replaces the buffer, in which case\n\t\t//the # ID Bits may change\n\t\tSFCommandBufferChanged(codec, node);\n\n\t\t/*\n\t\t 1 - memory mode, register command buffer for later parsing\n\t\t 2 - InputSensor only works on decompressed commands\n\t\t*/\n\t\tif (codec->dec_memory_mode || (node->sgprivate->tag==TAG_MPEG4_InputSensor)) {\n\t\t\tCommandBufferItem *cbi = (CommandBufferItem *)gf_malloc(sizeof(CommandBufferItem));\n\t\t\tcbi->node = node;\n\t\t\tgf_node_register(cbi->node, NULL);\n\t\t\tcbi->cb = sfcb;\n\t\t\tgf_list_add(codec->command_buffers, cbi);\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFNODE:\n\t\t//if not memory dec mode, unregister previous node\n\t\t//otherwise the field points to the memory command internal field\n\t\tif (!is_mem_com) {\n\t\t\tGF_Node *old_node = *((GF_Node **) field->far_ptr);\n\t\t\tif (old_node != NULL) {\n\t\t\t\tu32 i, count = gf_list_count(codec->command_buffers);\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tCommandBufferItem *cbi = (CommandBufferItem*) gf_list_get(codec->command_buffers, i);\n\t\t\t\t\tif (cbi->node == old_node) {\n\t\t\t\t\t\tgf_list_rem(codec->command_buffers, i);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t\tgf_node_unregister(cbi->node, NULL);\n\t\t\t\t\t\tgf_free(cbi);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_node_unregister(old_node, node);\n\t\t\t\t *((GF_Node **) field->far_ptr) = NULL;\n\t\t\t}\n\t\t}\n\t\t//for nodes the field ptr is a ptr to the field, which is a node ptr ;)\n\t\tnew_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n\t\tif (new_node) {\n\t\t\te = gf_node_register(new_node, is_mem_com ? NULL : node);\n\t\t\tif (e) return e;\n\t\t}\n\t\t//it may happen that new_node is NULL (this is valid for a proto declaration)\n\t\t*((GF_Node **) field->far_ptr) = new_node;\n\t\tbreak;\n\tcase GF_SG_VRML_SFSCRIPT:\n#ifdef GPAC_HAS_QJS\n\t\tcodec->LastError = node ? SFScript_Parse(codec, (SFScript*)field->far_ptr, bs, node) : GF_NON_COMPLIANT_BITSTREAM;\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t\tbreak;\n\tcase GF_SG_VRML_SFATTRREF:\n\t{\n\t\tSFAttrRef *ar = (SFAttrRef *)field->far_ptr;\n\t\tu32 nodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t\tar->node = gf_sg_find_node(codec->current_graph, nodeID);\n\t\tif (!ar->node) {\n\n\t\t} else {\n\t\t\tu32 nbBitsDEF = gf_get_bit_size(gf_node_get_num_fields_in_mode(ar->node, GF_SG_FIELD_CODING_DEF) - 1);\n\t\t\tu32 field_ref = gf_bs_read_int(bs, nbBitsDEF);\n\t\t\tcodec->LastError = gf_bifs_get_field_index(ar->node, field_ref, GF_SG_FIELD_CODING_DEF, &ar->fieldIndex);\n\t\t}\n\t}\n\tbreak;\n\tdefault:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\treturn codec->LastError;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144919,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  Status TrySimplify(NodeDef* consumer, string* simplified_node_name) override {\n    NodeDef* producer;\n    TF_RETURN_IF_ERROR(GetInputNode(consumer->input(0), &producer));\n    const bool producer_is_cast = IsCastLike(*producer);\n    const bool can_optimize =\n        !IsCheckNumerics(*producer) &&\n        ((producer_is_cast && IsValuePreserving(*consumer)) ||\n         (IsValuePreserving(*producer) && IsCastLike(*consumer)));\n    if (!can_optimize || IsControlFlow(*producer) ||\n        IsInPreserveSet(*producer) ||\n        producer->device() != consumer->device()) {\n      return Status::OK();\n    }\n\n    const NodeDef* cast_like_node = producer_is_cast ? producer : consumer;\n    const OpDef* cast_like_op_def = nullptr;\n    TF_RETURN_IF_ERROR(OpRegistry::Global()->LookUpOpDef(cast_like_node->op(),\n                                                         &cast_like_op_def));\n    DataType cast_src_type;\n    TF_RETURN_IF_ERROR(InputTypeForNode(*cast_like_node, *cast_like_op_def, 0,\n                                        &cast_src_type));\n    DataType cast_dst_type;\n    TF_RETURN_IF_ERROR(OutputTypeForNode(*cast_like_node, *cast_like_op_def, 0,\n                                         &cast_dst_type));\n    if (!IsFixedSizeType(cast_src_type) || !IsFixedSizeType(cast_dst_type)) {\n      return Status::OK();\n    } else if (producer_is_cast &&\n               DataTypeSize(cast_dst_type) <= DataTypeSize(cast_src_type)) {\n      return Status::OK();\n    } else if (!producer_is_cast &&\n               DataTypeSize(cast_dst_type) >= DataTypeSize(cast_src_type)) {\n      return Status::OK();\n    }\n\n    // Check that nodes were not already optimized.\n    const string optimized_producer_name = OptimizedNodeName(\n        ParseNodeScopeAndName(producer->name()), DataTypeString(cast_dst_type));\n    const string optimized_consumer_name = OptimizedNodeName(\n        ParseNodeScopeAndName(consumer->name()), DataTypeString(cast_src_type));\n    const bool is_already_optimized =\n        ctx().node_map->NodeExists(optimized_consumer_name) ||\n        ctx().node_map->NodeExists(optimized_producer_name);\n    if (is_already_optimized) {\n      return Status::OK();\n    }\n\n    // Add copies of consumer and producer in reverse order.\n    NodeDef* input;\n    TF_RETURN_IF_ERROR(GetInputNode(producer->input(0), &input));\n    // Create new producer node.\n    NodeDef* new_producer = AddCopyNode(optimized_consumer_name, consumer);\n    new_producer->set_input(0, producer->input(0));\n    ctx().node_map->AddOutput(input->name(), new_producer->name());\n\n    // Create new consumer node.\n    NodeDef* new_consumer = AddCopyNode(optimized_producer_name, producer);\n    new_consumer->set_input(0, new_producer->name());\n\n    NodeDef* new_value_preserving =\n        producer_is_cast ? new_producer : new_consumer;\n    const DataType new_input_type =\n        producer_is_cast ? cast_src_type : cast_dst_type;\n    // Update the input type of the value-preserving node. The input and\n    // output types of the cast-like nodes remain the same.\n    TF_RETURN_IF_ERROR(SetInputType(new_input_type, new_value_preserving));\n    // Make sure there is a kernel registered for the value preserving op\n    // with the new input type.\n    TF_RETURN_IF_ERROR(IsKernelRegisteredForNode(*new_value_preserving));\n    ctx().node_map->AddOutput(new_producer->name(), new_consumer->name());\n\n    AddToOptimizationQueue(new_producer);\n    *simplified_node_name = new_consumer->name();\n\n    return Status::OK();\n  }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144934,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  Status TrySimplify(NodeDef* consumer, string* simplified_node_name) override {\n    NodeDef* producer;\n\n    if (consumer->input_size() < 1) {\n      return errors::FailedPrecondition(\"Node \", simplified_node_name,\n                                        \" lacks inputs\");\n    }\n\n    TF_RETURN_IF_ERROR(GetInputNode(consumer->input(0), &producer));\n    const bool producer_is_cast = IsCastLike(*producer);\n    const bool can_optimize =\n        !IsCheckNumerics(*producer) &&\n        ((producer_is_cast && IsValuePreserving(*consumer)) ||\n         (IsValuePreserving(*producer) && IsCastLike(*consumer)));\n    if (!can_optimize || IsControlFlow(*producer) ||\n        IsInPreserveSet(*producer) ||\n        producer->device() != consumer->device()) {\n      return Status::OK();\n    }\n\n    const NodeDef* cast_like_node = producer_is_cast ? producer : consumer;\n    const OpDef* cast_like_op_def = nullptr;\n    TF_RETURN_IF_ERROR(OpRegistry::Global()->LookUpOpDef(cast_like_node->op(),\n                                                         &cast_like_op_def));\n    DataType cast_src_type;\n    TF_RETURN_IF_ERROR(InputTypeForNode(*cast_like_node, *cast_like_op_def, 0,\n                                        &cast_src_type));\n    DataType cast_dst_type;\n    TF_RETURN_IF_ERROR(OutputTypeForNode(*cast_like_node, *cast_like_op_def, 0,\n                                         &cast_dst_type));\n    if (!IsFixedSizeType(cast_src_type) || !IsFixedSizeType(cast_dst_type)) {\n      return Status::OK();\n    } else if (producer_is_cast &&\n               DataTypeSize(cast_dst_type) <= DataTypeSize(cast_src_type)) {\n      return Status::OK();\n    } else if (!producer_is_cast &&\n               DataTypeSize(cast_dst_type) >= DataTypeSize(cast_src_type)) {\n      return Status::OK();\n    }\n\n    // Check that nodes were not already optimized.\n    const string optimized_producer_name = OptimizedNodeName(\n        ParseNodeScopeAndName(producer->name()), DataTypeString(cast_dst_type));\n    const string optimized_consumer_name = OptimizedNodeName(\n        ParseNodeScopeAndName(consumer->name()), DataTypeString(cast_src_type));\n    const bool is_already_optimized =\n        ctx().node_map->NodeExists(optimized_consumer_name) ||\n        ctx().node_map->NodeExists(optimized_producer_name);\n    if (is_already_optimized) {\n      return Status::OK();\n    }\n\n    // Add copies of consumer and producer in reverse order.\n    NodeDef* input;\n    TF_RETURN_IF_ERROR(GetInputNode(producer->input(0), &input));\n    // Create new producer node.\n    NodeDef* new_producer = AddCopyNode(optimized_consumer_name, consumer);\n    new_producer->set_input(0, producer->input(0));\n    ctx().node_map->AddOutput(input->name(), new_producer->name());\n\n    // Create new consumer node.\n    NodeDef* new_consumer = AddCopyNode(optimized_producer_name, producer);\n    new_consumer->set_input(0, new_producer->name());\n\n    NodeDef* new_value_preserving =\n        producer_is_cast ? new_producer : new_consumer;\n    const DataType new_input_type =\n        producer_is_cast ? cast_src_type : cast_dst_type;\n    // Update the input type of the value-preserving node. The input and\n    // output types of the cast-like nodes remain the same.\n    TF_RETURN_IF_ERROR(SetInputType(new_input_type, new_value_preserving));\n    // Make sure there is a kernel registered for the value preserving op\n    // with the new input type.\n    TF_RETURN_IF_ERROR(IsKernelRegisteredForNode(*new_value_preserving));\n    ctx().node_map->AddOutput(new_producer->name(), new_consumer->name());\n\n    AddToOptimizationQueue(new_producer);\n    *simplified_node_name = new_consumer->name();\n\n    return Status::OK();\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144935,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int directblockRead(struct READER *reader, struct DATAOBJECT *dataobject,\n\t\tstruct FRACTALHEAP *fractalheap) {\n\n\tchar buf[4], *name, *value;\n\tint size, offset_size, length_size, err, len;\n\tuint8_t typeandversion;\n\tuint64_t unknown, heap_header_address, block_offset, block_size, offset,\n\t\t\tlength;\n\tlong store;\n\tstruct DIR *dir;\n\tstruct MYSOFA_ATTRIBUTE *attr;\n\n\tUNUSED(offset);\n\tUNUSED(block_size);\n\tUNUSED(block_offset);\n\n\t/* read signature */\n\tif (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"FHDB\", 4)) {\n\t\tlog(\"cannot read signature of fractal heap indirect block\\n\");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t}\n\tlog(\"%08\" PRIX64 \" %.4s\\n\", (uint64_t )ftell(reader->fhd) - 4, buf);\n\n\tif (fgetc(reader->fhd) != 0) {\n\t\tlog(\"object FHDB must have version 0\\n\");\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t}\n\n\t/* ignore heap_header_address */\n\tif (fseek(reader->fhd, reader->superblock.size_of_offsets, SEEK_CUR) < 0)\n\t\treturn errno;\n\n\tsize = (fractalheap->maximum_heap_size + 7) / 8;\n\tblock_offset = readValue(reader, size);\n\n\tif (fractalheap->flags & 2)\n\t\tif (fseek(reader->fhd, 4, SEEK_CUR))\n\t\t\treturn errno;\n\n\toffset_size = ceilf(log2f(fractalheap->maximum_heap_size) / 8);\n\tif (fractalheap->maximum_direct_block_size < fractalheap->maximum_size)\n\t\tlength_size = ceilf(log2f(fractalheap->maximum_direct_block_size) / 8);\n\telse\n\t\tlength_size = ceilf(log2f(fractalheap->maximum_size) / 8);\n\n\tlog(\" %d %\" PRIu64 \" %d\\n\",size,block_offset,offset_size);\n\n\t/*\n\t * 00003e00  00 46 48 44 42 00 40 02  00 00 00 00 00 00 00 00  |.FHDB.@.........|\n\t 00003e10  00 00 00 83 8d ac f6 >03  00 0c 00 08 00 04 00 00  |................|\n\t 00003e20  43 6f 6e 76 65 6e 74 69  6f 6e 73 00 13 00 00 00  |Conventions.....|\n\t 00003e30  04 00 00 00 02 00 00 00  53 4f 46 41< 03 00 08 00  |........SOFA....|\n\t 00003e40  08 00 04 00 00 56 65 72  73 69 6f 6e 00 13 00 00  |.....Version....|\n\t 00003e50  00 03 00 00 00 02 00 00  00 30 2e 36 03 00 10 00  |.........0.6....|\n\t 00003e60  08 00 04 00 00 53 4f 46  41 43 6f 6e 76 65 6e 74  |.....SOFAConvent|\n\t 00003e70  69 6f 6e 73 00 13 00 00  00 13 00 00 00 02 00 00  |ions............|\n\t 00003e80  00 53 69 6d 70 6c 65 46  72 65 65 46 69 65 6c 64  |.SimpleFreeField|\n\t 00003e90  48 52 49 52 03 00 17 00  08 00 04 00 00 53 4f 46  |HRIR.........SOF|\n\t 00003ea0  41 43 6f 6e 76 65 6e 74  69 6f 6e 73 56 65 72 73  |AConventionsVers|\n\t 00003eb0  69 6f 6e 00 13 00 00 00  03 00 00 00 02 00 00 00  |ion.............|\n\t *\n\t */\n\tdo {\n\t\ttypeandversion = (uint8_t) fgetc(reader->fhd);\n\t\toffset = readValue(reader, offset_size);\n\t\tlength = readValue(reader, length_size);\n\t\tif (offset > 0x10000000 || length > 0x10000000)\n\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\n\t\tlog(\" %d %4\" PRIX64 \" %\" PRIX64 \" %08lX\\n\",typeandversion,offset,length,ftell(reader->fhd));\n\n\t\t/* TODO: for the following part, the specification is incomplete */\n\t\tif (typeandversion == 3) {\n\t\t\t/*\n\t\t\t * this seems to be a name and value pair\n\t\t\t */\n\n\t\t\tif (readValue(reader, 5) != 0x0000040008) {\n\t\t\t\tlog(\"FHDB type 3 unsupported values\");\n\t\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t\t\t}\n\n\t\t\tif (!(name = malloc(length+1)))\n\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\tif (fread(name, 1, length, reader->fhd) != length) {\n\t\t\t\tfree(name);\n\t\t\t\treturn MYSOFA_READ_ERROR;\n\t\t\t}\n\t\t\tname[length]=0;\t\n\n\t\t\tif (readValue(reader, 4) != 0x00000013) {\n\t\t\t\tlog(\"FHDB type 3 unsupported values\");\n\t\t\t\tfree(name);\n\t\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t\t\t}\n\n\t\t\tlen = (int) readValue(reader, 2);\n\t\t\tif (len > 0x1000 || len < 0) {\n\t\t\t\tfree(name);\n\t\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t\t\t}\n\n\t\t\t/* TODO: Get definition of this field */\n\t\t\tunknown = readValue(reader, 6);\n\t\t\tif (unknown == 0x000000020200)\n\t\t\t\tvalue = NULL;\n\t\t\telse if (unknown == 0x000000020000) {\n\t\t\t\tif (!(value = malloc(len + 1))) {\n\t\t\t\t\tfree(name);\n\t\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\t\t}\n\t\t\t\tif (fread(value, 1, len, reader->fhd) != len) {\n\t\t\t\t\tfree(value);\n\t\t\t\t\tfree(name);\n\t\t\t\t\treturn MYSOFA_READ_ERROR;\n\t\t\t\t}\n\t\t\t\tvalue[len] = 0;\n\t\t\t} else if (unknown == 0x20000020000) {\n\t\t\t\tif (!(value = malloc(5))) {\n\t\t\t\t\tfree(name);\n\t\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\t\t}\n\t\t\t\tstrcpy(value, \"\");\n\t\t\t} else {\n\t\t\t\tlog(\"FHDB type 3 unsupported values: %12\" PRIX64 \"\\n\",unknown);\n\t\t\t\tfree(name);\n\t\t\t\t/* TODO:\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT; */\n\t\t\t\treturn MYSOFA_OK;\n\t\t\t} \n\t\t\tlog(\" %s = %s\\n\", name, value);\n\n\t\t\tattr = malloc(sizeof(struct MYSOFA_ATTRIBUTE));\n\t\t\tattr->name = name;\n\t\t\tattr->value = value;\n\t\t\tattr->next = dataobject->attributes;\n\t\t\tdataobject->attributes = attr;\n\n\t\t} else if (typeandversion == 1) {\n\t\t\t/*\n\t\t\t * pointer to another data object\n\t\t\t */\n\t\t\tunknown = readValue(reader, 6);\n\t\t\tif (unknown) {\n\t\t\t\tlog(\"FHDB type 1 unsupported values\\n\");\n\t\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t\t\t}\n\n\t\t\tlen = fgetc(reader->fhd);\n\t\t\tif (len < 0)\n\t\t\t\treturn MYSOFA_READ_ERROR;\n\t\t\tassert(len < 0x100);\n\n\t\t\tif (!(name = malloc(len + 1)))\n\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\tif (fread(name, 1, len, reader->fhd) != len) {\n\t\t\t\tfree(name);\n\t\t\t\treturn MYSOFA_READ_ERROR;\n\t\t\t}\n\t\t\tname[len] = 0;\n\n\t\t\theap_header_address = readValue(reader,\n\t\t\t\t\treader->superblock.size_of_offsets);\n\n\t\t\tlog(\"\\nfractal head type 1 length %4\" PRIX64 \" name %s address %\" PRIX64 \"\\n\", length, name, heap_header_address);\n\n\t\t\tdir = malloc(sizeof(struct DIR));\n\t\t\tif (!dir) {\n\t\t\t\tfree(name);\n\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\t}\n\t\t\tmemset(dir, 0, sizeof(*dir));\n\n\t\t\tdir->next = dataobject->directory;\n\t\t\tdataobject->directory = dir;\n\n\t\t\tstore = ftell(reader->fhd);\n\t\t\tif (fseek(reader->fhd, heap_header_address, SEEK_SET)) {\n\t\t\t\tfree(name);\n\t\t\t\treturn errno;\n\t\t\t}\n\n\t\t\terr = dataobjectRead(reader, &dir->dataobject, name);\n\t\t\tif (err) {\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tif (store < 0) {\n\t\t\t\treturn errno;\n\t\t\t}\n\t\t\tif (fseek(reader->fhd, store, SEEK_SET) < 0)\n\t\t\t\treturn errno;\n\n\t\t} else if (typeandversion != 0) {\n\t\t\t/* TODO is must be avoided somehow */\n\t\t\tlog(\"fractal head unknown type %d\\n\", typeandversion);\n\t\t\t/*\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT; */\n\t\t\treturn MYSOFA_OK;\n\t\t}\n\n\t} while (typeandversion != 0);\n\n\treturn MYSOFA_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144936,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int directblockRead(struct READER *reader, struct DATAOBJECT *dataobject,\n\t\tstruct FRACTALHEAP *fractalheap) {\n\n\tchar buf[4], *name, *value;\n\tint size, offset_size, length_size, err, len;\n\tuint8_t typeandversion;\n\tuint64_t unknown, heap_header_address, block_offset, block_size, offset,\n\t\t\tlength;\n\tlong store;\n\tstruct DIR *dir;\n\tstruct MYSOFA_ATTRIBUTE *attr;\n\n\tUNUSED(offset);\n\tUNUSED(block_size);\n\tUNUSED(block_offset);\n\n\tif(reader->recursive_counter >= 10)\n\t\treturn MYSOFA_INVALID_FORMAT;\n\telse\n\t\treader->recursive_counter++;\n\n\t/* read signature */\n\tif (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"FHDB\", 4)) {\n\t\tlog(\"cannot read signature of fractal heap indirect block\\n\");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t}\n\tlog(\"%08\" PRIX64 \" %.4s stack %d\\n\", (uint64_t )ftell(reader->fhd) - 4, buf, reader->recursive_counter);\n\n\tif (fgetc(reader->fhd) != 0) {\n\t\tlog(\"object FHDB must have version 0\\n\");\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t}\n\n\t/* ignore heap_header_address */\n\tif (fseek(reader->fhd, reader->superblock.size_of_offsets, SEEK_CUR) < 0)\n\t\treturn errno;\n\n\tsize = (fractalheap->maximum_heap_size + 7) / 8;\n\tblock_offset = readValue(reader, size);\n\n\tif (fractalheap->flags & 2)\n\t\tif (fseek(reader->fhd, 4, SEEK_CUR))\n\t\t\treturn errno;\n\n\toffset_size = ceilf(log2f(fractalheap->maximum_heap_size) / 8);\n\tif (fractalheap->maximum_direct_block_size < fractalheap->maximum_size)\n\t\tlength_size = ceilf(log2f(fractalheap->maximum_direct_block_size) / 8);\n\telse\n\t\tlength_size = ceilf(log2f(fractalheap->maximum_size) / 8);\n\n\tlog(\" %d %\" PRIu64 \" %d\\n\",size,block_offset,offset_size);\n\n\t/*\n\t * 00003e00  00 46 48 44 42 00 40 02  00 00 00 00 00 00 00 00  |.FHDB.@.........|\n\t 00003e10  00 00 00 83 8d ac f6 >03  00 0c 00 08 00 04 00 00  |................|\n\t 00003e20  43 6f 6e 76 65 6e 74 69  6f 6e 73 00 13 00 00 00  |Conventions.....|\n\t 00003e30  04 00 00 00 02 00 00 00  53 4f 46 41< 03 00 08 00  |........SOFA....|\n\t 00003e40  08 00 04 00 00 56 65 72  73 69 6f 6e 00 13 00 00  |.....Version....|\n\t 00003e50  00 03 00 00 00 02 00 00  00 30 2e 36 03 00 10 00  |.........0.6....|\n\t 00003e60  08 00 04 00 00 53 4f 46  41 43 6f 6e 76 65 6e 74  |.....SOFAConvent|\n\t 00003e70  69 6f 6e 73 00 13 00 00  00 13 00 00 00 02 00 00  |ions............|\n\t 00003e80  00 53 69 6d 70 6c 65 46  72 65 65 46 69 65 6c 64  |.SimpleFreeField|\n\t 00003e90  48 52 49 52 03 00 17 00  08 00 04 00 00 53 4f 46  |HRIR.........SOF|\n\t 00003ea0  41 43 6f 6e 76 65 6e 74  69 6f 6e 73 56 65 72 73  |AConventionsVers|\n\t 00003eb0  69 6f 6e 00 13 00 00 00  03 00 00 00 02 00 00 00  |ion.............|\n\t *\n\t */\n\tdo {\n\t\ttypeandversion = (uint8_t) fgetc(reader->fhd);\n\t\toffset = readValue(reader, offset_size);\n\t\tlength = readValue(reader, length_size);\n\t\tif (offset > 0x10000000 || length > 0x10000000)\n\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\n\t\tlog(\" %d %4\" PRIX64 \" %\" PRIX64 \" %08lX\\n\",typeandversion,offset,length,ftell(reader->fhd));\n\n\t\t/* TODO: for the following part, the specification is incomplete */\n\t\tif (typeandversion == 3) {\n\t\t\t/*\n\t\t\t * this seems to be a name and value pair\n\t\t\t */\n\n\t\t\tif (readValue(reader, 5) != 0x0000040008) {\n\t\t\t\tlog(\"FHDB type 3 unsupported values\");\n\t\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t\t\t}\n\n\t\t\tif (!(name = malloc(length+1)))\n\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\tif (fread(name, 1, length, reader->fhd) != length) {\n\t\t\t\tfree(name);\n\t\t\t\treturn MYSOFA_READ_ERROR;\n\t\t\t}\n\t\t\tname[length]=0;\t\n\n\t\t\tif (readValue(reader, 4) != 0x00000013) {\n\t\t\t\tlog(\"FHDB type 3 unsupported values\");\n\t\t\t\tfree(name);\n\t\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t\t\t}\n\n\t\t\tlen = (int) readValue(reader, 2);\n\t\t\tif (len > 0x1000 || len < 0) {\n\t\t\t\tfree(name);\n\t\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t\t\t}\n\n\t\t\t/* TODO: Get definition of this field */\n\t\t\tunknown = readValue(reader, 6);\n\t\t\tif (unknown == 0x000000020200)\n\t\t\t\tvalue = NULL;\n\t\t\telse if (unknown == 0x000000020000) {\n\t\t\t\tif (!(value = malloc(len + 1))) {\n\t\t\t\t\tfree(name);\n\t\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\t\t}\n\t\t\t\tif (fread(value, 1, len, reader->fhd) != len) {\n\t\t\t\t\tfree(value);\n\t\t\t\t\tfree(name);\n\t\t\t\t\treturn MYSOFA_READ_ERROR;\n\t\t\t\t}\n\t\t\t\tvalue[len] = 0;\n\t\t\t} else if (unknown == 0x20000020000) {\n\t\t\t\tif (!(value = malloc(5))) {\n\t\t\t\t\tfree(name);\n\t\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\t\t}\n\t\t\t\tstrcpy(value, \"\");\n\t\t\t} else {\n\t\t\t\tlog(\"FHDB type 3 unsupported values: %12\" PRIX64 \"\\n\",unknown);\n\t\t\t\tfree(name);\n\t\t\t\t/* TODO:\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT; */\n\t\t\t\treturn MYSOFA_OK;\n\t\t\t} \n\t\t\tlog(\" %s = %s\\n\", name, value);\n\n\t\t\tattr = malloc(sizeof(struct MYSOFA_ATTRIBUTE));\n\t\t\tattr->name = name;\n\t\t\tattr->value = value;\n\t\t\tattr->next = dataobject->attributes;\n\t\t\tdataobject->attributes = attr;\n\n\t\t} else if (typeandversion == 1) {\n\t\t\t/*\n\t\t\t * pointer to another data object\n\t\t\t */\n\t\t\tunknown = readValue(reader, 6);\n\t\t\tif (unknown) {\n\t\t\t\tlog(\"FHDB type 1 unsupported values\\n\");\n\t\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t\t\t}\n\n\t\t\tlen = fgetc(reader->fhd);\n\t\t\tif (len < 0)\n\t\t\t\treturn MYSOFA_READ_ERROR;\n\t\t\tassert(len < 0x100);\n\n\t\t\tif (!(name = malloc(len + 1)))\n\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\tif (fread(name, 1, len, reader->fhd) != len) {\n\t\t\t\tfree(name);\n\t\t\t\treturn MYSOFA_READ_ERROR;\n\t\t\t}\n\t\t\tname[len] = 0;\n\n\t\t\theap_header_address = readValue(reader,\n\t\t\t\t\treader->superblock.size_of_offsets);\n\n\t\t\tlog(\"\\nfractal head type 1 length %4\" PRIX64 \" name %s address %\" PRIX64 \"\\n\", length, name, heap_header_address);\n\n\t\t\tdir = malloc(sizeof(struct DIR));\n\t\t\tif (!dir) {\n\t\t\t\tfree(name);\n\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\t}\n\t\t\tmemset(dir, 0, sizeof(*dir));\n\n\t\t\tdir->next = dataobject->directory;\n\t\t\tdataobject->directory = dir;\n\n\t\t\tstore = ftell(reader->fhd);\n\t\t\tif (fseek(reader->fhd, heap_header_address, SEEK_SET)) {\n\t\t\t\tfree(name);\n\t\t\t\treturn errno;\n\t\t\t}\n\n\t\t\terr = dataobjectRead(reader, &dir->dataobject, name);\n\t\t\tif (err) {\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tif (store < 0) {\n\t\t\t\treturn errno;\n\t\t\t}\n\t\t\tif (fseek(reader->fhd, store, SEEK_SET) < 0)\n\t\t\t\treturn errno;\n\n\t\t} else if (typeandversion != 0) {\n\t\t\t/* TODO is must be avoided somehow */\n\t\t\tlog(\"fractal head unknown type %d\\n\", typeandversion);\n\t\t\t/*\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT; */\n\t\t\treturn MYSOFA_OK;\n\t\t}\n\n\t} while (typeandversion != 0);\n\n\treader->recursive_counter--;\n\treturn MYSOFA_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144937,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void do_iccprofile_item(deark *c, lctx *d, i64 pos, i64 len)\n{\n\ti64 selector;\n\ti64 data_len;\n\n\tif(len<4) return;\n\tselector = de_getu32be(pos);\n\tdata_len = len-4;\n\tde_dbg(c, \"ICC profile segment, selector=%d, data len=%d\", (int)selector,\n\t\t(int)data_len);\n\n\tif(selector!=1) {\n\t\t// If this is not a Continuation segment, close any current file.\n\t\tdbuf_close(d->iccprofile_file);\n\t\td->iccprofile_file = NULL;\n\t}\n\n\tif(selector==0) { // Beginning segment\n\t\td->iccprofile_file = dbuf_create_output_file(c, \"icc\", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\n\tif(selector==0 || selector==1) {\n\t\t// Beginning and Continuation segments normally have profile data.\n\t\t// End segments (selector==2) are not allowed to include data.\n\t\tdbuf_copy(c->infile, pos+4, data_len, d->iccprofile_file);\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144938,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void do_iccprofile_item(deark *c, lctx *d, i64 pos, i64 len)\n{\n\ti64 selector;\n\ti64 data_len;\n\n\tif(len<4) return;\n\tselector = de_getu32be(pos);\n\tdata_len = len-4;\n\tde_dbg(c, \"ICC profile segment, selector=%d, data len=%d\", (int)selector,\n\t\t(int)data_len);\n\n\tif(selector!=1) {\n\t\t// If this is not a Continuation segment, close any current file.\n\t\tdbuf_close(d->iccprofile_file);\n\t\td->iccprofile_file = NULL;\n\t}\n\n\tif(selector==0) { // Beginning segment\n\t\td->iccprofile_file = dbuf_create_output_file(c, \"icc\", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\n\tif(selector==0 || selector==1) {\n\t\t// Beginning and Continuation segments normally have profile data.\n\t\t// End segments (selector==2) are not allowed to include data.\n\n\t\tif(!d->iccprofile_file) {\n\t\t\tde_warn(c, \"Bad ICC profile segment\");\n\t\t\treturn;\n\t\t}\n\t\tdbuf_copy(c->infile, pos+4, data_len, d->iccprofile_file);\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144939,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& images = context->input(0);\n    const Tensor& boxes = context->input(1);\n    const int64 depth = images.dim_size(3);\n\n    OP_REQUIRES(context, images.dims() == 4,\n                errors::InvalidArgument(\"The rank of the images should be 4\"));\n    OP_REQUIRES(\n        context, boxes.dims() == 3,\n        errors::InvalidArgument(\"The rank of the boxes tensor should be 3\"));\n    OP_REQUIRES(context, images.dim_size(0) == boxes.dim_size(0),\n                errors::InvalidArgument(\"The batch sizes should be the same\"));\n\n    OP_REQUIRES(\n        context, depth == 4 || depth == 1 || depth == 3,\n        errors::InvalidArgument(\"Channel depth should be either 1 (GRY), \"\n                                \"3 (RGB), or 4 (RGBA)\"));\n\n    const int64 batch_size = images.dim_size(0);\n    const int64 height = images.dim_size(1);\n    const int64 width = images.dim_size(2);\n    std::vector<std::vector<float>> color_table;\n    if (context->num_inputs() == 3) {\n      const Tensor& colors_tensor = context->input(2);\n      OP_REQUIRES(context, colors_tensor.shape().dims() == 2,\n                  errors::InvalidArgument(\"colors must be a 2-D matrix\",\n                                          colors_tensor.shape().DebugString()));\n      OP_REQUIRES(context, colors_tensor.shape().dim_size(1) >= depth,\n                  errors::InvalidArgument(\"colors must have equal or more \",\n                                          \"channels than the image provided: \",\n                                          colors_tensor.shape().DebugString()));\n      if (colors_tensor.NumElements() != 0) {\n        color_table.clear();\n\n        auto colors = colors_tensor.matrix<float>();\n        for (int64 i = 0; i < colors.dimension(0); i++) {\n          std::vector<float> color_value(4);\n          for (int64 j = 0; j < 4; j++) {\n            color_value[j] = colors(i, j);\n          }\n          color_table.emplace_back(color_value);\n        }\n      }\n    }\n    if (color_table.empty()) {\n      color_table = DefaultColorTable(depth);\n    }\n    Tensor* output;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n            0, TensorShape({batch_size, height, width, depth}), &output));\n\n    output->tensor<T, 4>() = images.tensor<T, 4>();\n    auto canvas = output->tensor<T, 4>();\n\n    for (int64 b = 0; b < batch_size; ++b) {\n      const int64 num_boxes = boxes.dim_size(1);\n      const auto tboxes = boxes.tensor<T, 3>();\n      for (int64 bb = 0; bb < num_boxes; ++bb) {\n        int64 color_index = bb % color_table.size();\n        const int64 min_box_row =\n            static_cast<float>(tboxes(b, bb, 0)) * (height - 1);\n        const int64 min_box_row_clamp = std::max<int64>(min_box_row, int64{0});\n        const int64 max_box_row =\n            static_cast<float>(tboxes(b, bb, 2)) * (height - 1);\n        const int64 max_box_row_clamp =\n            std::min<int64>(max_box_row, height - 1);\n        const int64 min_box_col =\n            static_cast<float>(tboxes(b, bb, 1)) * (width - 1);\n        const int64 min_box_col_clamp = std::max<int64>(min_box_col, int64{0});\n        const int64 max_box_col =\n            static_cast<float>(tboxes(b, bb, 3)) * (width - 1);\n        const int64 max_box_col_clamp = std::min<int64>(max_box_col, width - 1);\n\n        if (min_box_row > max_box_row || min_box_col > max_box_col) {\n          LOG(WARNING) << \"Bounding box (\" << min_box_row << \",\" << min_box_col\n                       << \",\" << max_box_row << \",\" << max_box_col\n                       << \") is inverted and will not be drawn.\";\n          continue;\n        }\n        if (min_box_row >= height || max_box_row < 0 || min_box_col >= width ||\n            max_box_col < 0) {\n          LOG(WARNING) << \"Bounding box (\" << min_box_row << \",\" << min_box_col\n                       << \",\" << max_box_row << \",\" << max_box_col\n                       << \") is completely outside the image\"\n                       << \" and will not be drawn.\";\n          continue;\n        }\n\n        // At this point, {min,max}_box_{row,col}_clamp are inside the\n        // image.\n        OP_REQUIRES(\n            context, min_box_row_clamp >= 0,\n            errors::InvalidArgument(\"Min box row clamp is less than 0.\"));\n        OP_REQUIRES(\n            context, max_box_row_clamp >= 0,\n            errors::InvalidArgument(\"Max box row clamp is less than 0.\"));\n        OP_REQUIRES(context, min_box_row_clamp <= height,\n                    errors::InvalidArgument(\n                        \"Min box row clamp is greater than height.\"));\n        OP_REQUIRES(context, max_box_row_clamp <= height,\n                    errors::InvalidArgument(\n                        \"Max box row clamp is greater than height.\"));\n\n        OP_REQUIRES(\n            context, min_box_col_clamp >= 0,\n            errors::InvalidArgument(\"Min box col clamp is less than 0.\"));\n        OP_REQUIRES(\n            context, max_box_col_clamp >= 0,\n            errors::InvalidArgument(\"Max box col clamp is less than 0.\"));\n        OP_REQUIRES(context, min_box_col_clamp <= width,\n                    errors::InvalidArgument(\n                        \"Min box col clamp is greater than width.\"));\n        OP_REQUIRES(context, max_box_col_clamp <= width,\n                    errors::InvalidArgument(\n                        \"Max box col clamp is greater than width.\"));\n\n        // At this point, the min_box_row and min_box_col are either\n        // in the image or above/left of it, and max_box_row and\n        // max_box_col are either in the image or below/right or it.\n\n        OP_REQUIRES(\n            context, min_box_row <= height,\n            errors::InvalidArgument(\"Min box row is greater than height.\"));\n        OP_REQUIRES(context, max_box_row >= 0,\n                    errors::InvalidArgument(\"Max box row is less than 0.\"));\n        OP_REQUIRES(\n            context, min_box_col <= width,\n            errors::InvalidArgument(\"Min box col is greater than width.\"));\n        OP_REQUIRES(context, max_box_col >= 0,\n                    errors::InvalidArgument(\"Max box col is less than 0.\"));\n\n        // Draw top line.\n        if (min_box_row >= 0) {\n          for (int64 j = min_box_col_clamp; j <= max_box_col_clamp; ++j)\n            for (int64 c = 0; c < depth; c++) {\n              canvas(b, min_box_row, j, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n        // Draw bottom line.\n        if (max_box_row < height) {\n          for (int64 j = min_box_col_clamp; j <= max_box_col_clamp; ++j)\n            for (int64 c = 0; c < depth; c++) {\n              canvas(b, max_box_row, j, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n        // Draw left line.\n        if (min_box_col >= 0) {\n          for (int64 i = min_box_row_clamp; i <= max_box_row_clamp; ++i)\n            for (int64 c = 0; c < depth; c++) {\n              canvas(b, i, min_box_col, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n        // Draw right line.\n        if (max_box_col < width) {\n          for (int64 i = min_box_row_clamp; i <= max_box_row_clamp; ++i)\n            for (int64 c = 0; c < depth; c++) {\n              canvas(b, i, max_box_col, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n      }\n    }\n  }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144956,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& images = context->input(0);\n    const Tensor& boxes = context->input(1);\n    const int64 depth = images.dim_size(3);\n\n    OP_REQUIRES(context, images.dims() == 4,\n                errors::InvalidArgument(\"The rank of the images should be 4\"));\n    OP_REQUIRES(\n        context, boxes.dims() == 3,\n        errors::InvalidArgument(\"The rank of the boxes tensor should be 3\"));\n    OP_REQUIRES(context, images.dim_size(0) == boxes.dim_size(0),\n                errors::InvalidArgument(\"The batch sizes should be the same\"));\n\n    OP_REQUIRES(\n        context, depth == 4 || depth == 1 || depth == 3,\n        errors::InvalidArgument(\"Channel depth should be either 1 (GRY), \"\n                                \"3 (RGB), or 4 (RGBA)\"));\n\n    OP_REQUIRES(\n        context, boxes.dim_size(2) == 4,\n        errors::InvalidArgument(\n            \"The size of the third dimension of the box must be 4. Received: \",\n            boxes.dim_size(2)));\n\n    const int64 batch_size = images.dim_size(0);\n    const int64 height = images.dim_size(1);\n    const int64 width = images.dim_size(2);\n    std::vector<std::vector<float>> color_table;\n    if (context->num_inputs() == 3) {\n      const Tensor& colors_tensor = context->input(2);\n      OP_REQUIRES(context, colors_tensor.shape().dims() == 2,\n                  errors::InvalidArgument(\"colors must be a 2-D matrix\",\n                                          colors_tensor.shape().DebugString()));\n      OP_REQUIRES(context, colors_tensor.shape().dim_size(1) >= depth,\n                  errors::InvalidArgument(\"colors must have equal or more \",\n                                          \"channels than the image provided: \",\n                                          colors_tensor.shape().DebugString()));\n      if (colors_tensor.NumElements() != 0) {\n        color_table.clear();\n\n        auto colors = colors_tensor.matrix<float>();\n        for (int64 i = 0; i < colors.dimension(0); i++) {\n          std::vector<float> color_value(4);\n          for (int64 j = 0; j < 4; j++) {\n            color_value[j] = colors(i, j);\n          }\n          color_table.emplace_back(color_value);\n        }\n      }\n    }\n    if (color_table.empty()) {\n      color_table = DefaultColorTable(depth);\n    }\n    Tensor* output;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n            0, TensorShape({batch_size, height, width, depth}), &output));\n\n    output->tensor<T, 4>() = images.tensor<T, 4>();\n    auto canvas = output->tensor<T, 4>();\n\n    for (int64 b = 0; b < batch_size; ++b) {\n      const int64 num_boxes = boxes.dim_size(1);\n      const auto tboxes = boxes.tensor<T, 3>();\n      for (int64 bb = 0; bb < num_boxes; ++bb) {\n        int64 color_index = bb % color_table.size();\n        const int64 min_box_row =\n            static_cast<float>(tboxes(b, bb, 0)) * (height - 1);\n        const int64 min_box_row_clamp = std::max<int64>(min_box_row, int64{0});\n        const int64 max_box_row =\n            static_cast<float>(tboxes(b, bb, 2)) * (height - 1);\n        const int64 max_box_row_clamp =\n            std::min<int64>(max_box_row, height - 1);\n        const int64 min_box_col =\n            static_cast<float>(tboxes(b, bb, 1)) * (width - 1);\n        const int64 min_box_col_clamp = std::max<int64>(min_box_col, int64{0});\n        const int64 max_box_col =\n            static_cast<float>(tboxes(b, bb, 3)) * (width - 1);\n        const int64 max_box_col_clamp = std::min<int64>(max_box_col, width - 1);\n\n        if (min_box_row > max_box_row || min_box_col > max_box_col) {\n          LOG(WARNING) << \"Bounding box (\" << min_box_row << \",\" << min_box_col\n                       << \",\" << max_box_row << \",\" << max_box_col\n                       << \") is inverted and will not be drawn.\";\n          continue;\n        }\n        if (min_box_row >= height || max_box_row < 0 || min_box_col >= width ||\n            max_box_col < 0) {\n          LOG(WARNING) << \"Bounding box (\" << min_box_row << \",\" << min_box_col\n                       << \",\" << max_box_row << \",\" << max_box_col\n                       << \") is completely outside the image\"\n                       << \" and will not be drawn.\";\n          continue;\n        }\n\n        // At this point, {min,max}_box_{row,col}_clamp are inside the\n        // image.\n        OP_REQUIRES(\n            context, min_box_row_clamp >= 0,\n            errors::InvalidArgument(\"Min box row clamp is less than 0.\"));\n        OP_REQUIRES(\n            context, max_box_row_clamp >= 0,\n            errors::InvalidArgument(\"Max box row clamp is less than 0.\"));\n        OP_REQUIRES(context, min_box_row_clamp <= height,\n                    errors::InvalidArgument(\n                        \"Min box row clamp is greater than height.\"));\n        OP_REQUIRES(context, max_box_row_clamp <= height,\n                    errors::InvalidArgument(\n                        \"Max box row clamp is greater than height.\"));\n\n        OP_REQUIRES(\n            context, min_box_col_clamp >= 0,\n            errors::InvalidArgument(\"Min box col clamp is less than 0.\"));\n        OP_REQUIRES(\n            context, max_box_col_clamp >= 0,\n            errors::InvalidArgument(\"Max box col clamp is less than 0.\"));\n        OP_REQUIRES(context, min_box_col_clamp <= width,\n                    errors::InvalidArgument(\n                        \"Min box col clamp is greater than width.\"));\n        OP_REQUIRES(context, max_box_col_clamp <= width,\n                    errors::InvalidArgument(\n                        \"Max box col clamp is greater than width.\"));\n\n        // At this point, the min_box_row and min_box_col are either\n        // in the image or above/left of it, and max_box_row and\n        // max_box_col are either in the image or below/right or it.\n\n        OP_REQUIRES(\n            context, min_box_row <= height,\n            errors::InvalidArgument(\"Min box row is greater than height.\"));\n        OP_REQUIRES(context, max_box_row >= 0,\n                    errors::InvalidArgument(\"Max box row is less than 0.\"));\n        OP_REQUIRES(\n            context, min_box_col <= width,\n            errors::InvalidArgument(\"Min box col is greater than width.\"));\n        OP_REQUIRES(context, max_box_col >= 0,\n                    errors::InvalidArgument(\"Max box col is less than 0.\"));\n\n        // Draw top line.\n        if (min_box_row >= 0) {\n          for (int64 j = min_box_col_clamp; j <= max_box_col_clamp; ++j)\n            for (int64 c = 0; c < depth; c++) {\n              canvas(b, min_box_row, j, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n        // Draw bottom line.\n        if (max_box_row < height) {\n          for (int64 j = min_box_col_clamp; j <= max_box_col_clamp; ++j)\n            for (int64 c = 0; c < depth; c++) {\n              canvas(b, max_box_row, j, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n        // Draw left line.\n        if (min_box_col >= 0) {\n          for (int64 i = min_box_row_clamp; i <= max_box_row_clamp; ++i)\n            for (int64 c = 0; c < depth; c++) {\n              canvas(b, i, min_box_col, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n        // Draw right line.\n        if (max_box_col < width) {\n          for (int64 i = min_box_row_clamp; i <= max_box_row_clamp; ++i)\n            for (int64 c = 0; c < depth; c++) {\n              canvas(b, i, max_box_col, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n      }\n    }\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144957,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err HintFile(GF_ISOFile *file, u32 MTUSize, u32 max_ptime, u32 rtp_rate, u32 base_flags, Bool copy_data, Bool interleave, Bool regular_iod, Bool single_group, Bool hint_no_offset)\n{\n\tGF_ESD *esd;\n\tGF_InitialObjectDescriptor *iod;\n\tu32 i, val, res, streamType;\n\tu32 sl_mode, prev_ocr, single_ocr, nb_done, tot_bw, bw, flags, spec_type;\n\tGF_Err e;\n\tchar szPayload[30];\n\tGF_RTPHinter *hinter;\n\tBool copy, has_iod, single_av;\n\tu8 init_payt = BASE_PAYT;\n\tu32 mtype;\n\tGF_SDP_IODProfile iod_mode = GF_SDP_IOD_NONE;\n\tu32 media_group = 0;\n\tu8 media_prio = 0;\n\n\ttot_bw = 0;\n\tprev_ocr = 0;\n\tsingle_ocr = 1;\n\n\thas_iod = 1;\n\tiod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);\n\tif (!iod) has_iod = 0;\n\telse {\n\t\tif (!gf_list_count(iod->ESDescriptors)) has_iod = 0;\n\t\tgf_odf_desc_del((GF_Descriptor *) iod);\n\t}\n\n\tspec_type = gf_isom_guess_specification(file);\n\tsingle_av = single_group ? 1 : gf_isom_is_single_av(file);\n\n\t/*first make sure we use a systems track as base OCR*/\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tres = gf_isom_get_media_type(file, i+1);\n\t\tif ((res==GF_ISOM_MEDIA_SCENE) || (res==GF_ISOM_MEDIA_OD)) {\n\t\t\tif (gf_isom_is_track_in_root_od(file, i+1)) {\n\t\t\t\tgf_isom_set_default_sync_track(file, i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tnb_done = 0;\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tsl_mode = base_flags;\n\t\tcopy = copy_data;\n\t\t/*skip emty tracks (mainly MPEG-4 interaction streams...*/\n\t\tif (!gf_isom_get_sample_count(file, i+1)) continue;\n\t\tif (!gf_isom_is_track_enabled(file, i+1)) {\n\t\t\tM4_LOG(GF_LOG_INFO, (\"Track ID %d disabled - skipping hint\\n\", gf_isom_get_track_id(file, i+1) ));\n\t\t\tcontinue;\n\t\t}\n\n\t\tmtype = gf_isom_get_media_type(file, i+1);\n\t\tswitch (mtype) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tif (single_av) {\n\t\t\t\tmedia_group = 2;\n\t\t\t\tmedia_prio = 2;\n\t\t\t}\n\t\t\tbreak;\n        case GF_ISOM_MEDIA_AUXV:\n            if (single_av) {\n                media_group = 2;\n                media_prio = 3;\n            }\n            break;\n        case GF_ISOM_MEDIA_PICT:\n            if (single_av) {\n                media_group = 2;\n                media_prio = 4;\n            }\n            break;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tif (single_av) {\n\t\t\t\tmedia_group = 2;\n\t\t\t\tmedia_prio = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_HINT:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\t/*no hinting of systems track on isma*/\n\t\t\tif (spec_type==GF_ISOM_BRAND_ISMA) continue;\n\t\t}\n\t\tmtype = gf_isom_get_media_subtype(file, i+1, 1);\n\t\tif ((mtype==GF_ISOM_SUBTYPE_MPEG4) || (mtype==GF_ISOM_SUBTYPE_MPEG4_CRYP) ) mtype = gf_isom_get_mpeg4_subtype(file, i+1, 1);\n\n\t\tif (!single_av) {\n\t\t\t/*one media per group only (we should prompt user for group selection)*/\n\t\t\tmedia_group ++;\n\t\t\tmedia_prio = 1;\n\t\t}\n\n\t\tstreamType = 0;\n\t\tesd = gf_isom_get_esd(file, i+1, 1);\n\t\tif (esd) {\n\t\t\tstreamType = esd->decoderConfig->streamType;\n\t\t\tif (!prev_ocr) {\n\t\t\t\tprev_ocr = esd->OCRESID;\n\t\t\t\tif (!esd->OCRESID) prev_ocr = esd->ESID;\n\t\t\t} else if (esd->OCRESID && prev_ocr != esd->OCRESID) {\n\t\t\t\tsingle_ocr = 0;\n\t\t\t}\n\t\t\t/*OD MUST BE WITHOUT REFERENCES*/\n\t\t\tif (streamType==1) copy = 1;\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\n\t\tif (!regular_iod && gf_isom_is_track_in_root_od(file, i+1)) {\n\t\t\t/*single AU - check if base64 would fit in ESD (consider 33% overhead of base64), otherwise stream*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)==1) {\n\t\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, i+1, 1, &val);\n\t\t\t\tif (streamType) {\n\t\t\t\t\tres = gf_hinter_can_embbed_data(samp->data, samp->dataLength, streamType);\n\t\t\t\t} else {\n\t\t\t\t\t/*not a system track, we shall hint it*/\n\t\t\t\t\tres = 0;\n\t\t\t\t}\n\t\t\t\tif (samp) gf_isom_sample_del(&samp);\n\t\t\t\tif (res) continue;\n\t\t\t}\n\t\t}\n\t\tif (interleave) sl_mode |= GP_RTP_PCK_USE_INTERLEAVING;\n\n\t\thinter = gf_hinter_track_new(file, i+1, MTUSize, max_ptime, rtp_rate, sl_mode, init_payt, copy, media_group, media_prio, &e);\n\n\t\tif (!hinter) {\n\t\t\tif (e) {\n\t\t\t\tM4_LOG(nb_done ? GF_LOG_WARNING : GF_LOG_ERROR, (\"Cannot create hinter (%s)\\n\", gf_error_to_string(e) ));\n\t\t\t\tif (!nb_done) return e;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (hint_no_offset)\n\t\t\tgf_hinter_track_force_no_offsets(hinter);\n\n\t\tbw = gf_hinter_track_get_bandwidth(hinter);\n\t\ttot_bw += bw;\n\t\tflags = gf_hinter_track_get_flags(hinter);\n\n\t\t//set extraction mode for AVC/SVC\n\t\tgf_isom_set_nalu_extract_mode(file, i+1, GF_ISOM_NALU_EXTRACT_LAYER_ONLY);\n\n\t\tgf_hinter_track_get_payload_name(hinter, szPayload);\n\t\tM4_LOG(GF_LOG_INFO, (\"Hinting track ID %d - Type \\\"%s:%s\\\" (%s) - BW %d kbps\\n\", gf_isom_get_track_id(file, i+1), gf_4cc_to_str(mtype), gf_4cc_to_str(mtype), szPayload, bw));\n\t\tif (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) M4_LOG(GF_LOG_INFO, (\"\\tMPEG-4 Systems stream carousel enabled\\n\"));\n\t\te = gf_hinter_track_process(hinter);\n\n\t\tif (!e) e = gf_hinter_track_finalize(hinter, has_iod);\n\t\tgf_hinter_track_del(hinter);\n\n\t\tif (e) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error while hinting (%s)\\n\", gf_error_to_string(e)));\n\t\t\tif (!nb_done) return e;\n\t\t}\n\t\tinit_payt++;\n\t\tnb_done ++;\n\t}\n\n\tif (has_iod) {\n\t\tiod_mode = GF_SDP_IOD_ISMA;\n\t\tif (regular_iod) iod_mode = GF_SDP_IOD_REGULAR;\n\t} else {\n\t\tiod_mode = GF_SDP_IOD_NONE;\n\t}\n\tgf_hinter_finalize(file, iod_mode, tot_bw);\n\n\tif (!single_ocr)\n\t\tM4_LOG(GF_LOG_WARNING, (\"Warning: at least 2 timelines found in the file\\nThis may not be supported by servers/players\\n\\n\"));\n\n\treturn GF_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144992,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err HintFile(GF_ISOFile *file, u32 MTUSize, u32 max_ptime, u32 rtp_rate, u32 base_flags, Bool copy_data, Bool interleave, Bool regular_iod, Bool single_group, Bool hint_no_offset)\n{\n\tGF_ESD *esd;\n\tGF_InitialObjectDescriptor *iod;\n\tu32 i, val, res, streamType;\n\tu32 sl_mode, prev_ocr, single_ocr, nb_done, tot_bw, bw, flags, spec_type;\n\tGF_Err e;\n\tchar szPayload[30];\n\tGF_RTPHinter *hinter;\n\tBool copy, has_iod, single_av;\n\tu8 init_payt = BASE_PAYT;\n\tu32 mtype;\n\tGF_SDP_IODProfile iod_mode = GF_SDP_IOD_NONE;\n\tu32 media_group = 0;\n\tu8 media_prio = 0;\n\n\ttot_bw = 0;\n\tprev_ocr = 0;\n\tsingle_ocr = 1;\n\n\thas_iod = 1;\n\tiod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);\n\tif (!iod) has_iod = 0;\n\telse {\n\t\tif (!gf_list_count(iod->ESDescriptors)) has_iod = 0;\n\t\tgf_odf_desc_del((GF_Descriptor *) iod);\n\t}\n\n\tspec_type = gf_isom_guess_specification(file);\n\tsingle_av = single_group ? 1 : gf_isom_is_single_av(file);\n\n\t/*first make sure we use a systems track as base OCR*/\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tres = gf_isom_get_media_type(file, i+1);\n\t\tif ((res==GF_ISOM_MEDIA_SCENE) || (res==GF_ISOM_MEDIA_OD)) {\n\t\t\tif (gf_isom_is_track_in_root_od(file, i+1)) {\n\t\t\t\tgf_isom_set_default_sync_track(file, i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tnb_done = 0;\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tsl_mode = base_flags;\n\t\tcopy = copy_data;\n\t\t/*skip emty tracks (mainly MPEG-4 interaction streams...*/\n\t\tif (!gf_isom_get_sample_count(file, i+1)) continue;\n\t\tif (!gf_isom_is_track_enabled(file, i+1)) {\n\t\t\tM4_LOG(GF_LOG_INFO, (\"Track ID %d disabled - skipping hint\\n\", gf_isom_get_track_id(file, i+1) ));\n\t\t\tcontinue;\n\t\t}\n\n\t\tmtype = gf_isom_get_media_type(file, i+1);\n\t\tswitch (mtype) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tif (single_av) {\n\t\t\t\tmedia_group = 2;\n\t\t\t\tmedia_prio = 2;\n\t\t\t}\n\t\t\tbreak;\n        case GF_ISOM_MEDIA_AUXV:\n            if (single_av) {\n                media_group = 2;\n                media_prio = 3;\n            }\n            break;\n        case GF_ISOM_MEDIA_PICT:\n            if (single_av) {\n                media_group = 2;\n                media_prio = 4;\n            }\n            break;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tif (single_av) {\n\t\t\t\tmedia_group = 2;\n\t\t\t\tmedia_prio = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_HINT:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\t/*no hinting of systems track on isma*/\n\t\t\tif (spec_type==GF_ISOM_BRAND_ISMA) continue;\n\t\t}\n\t\tmtype = gf_isom_get_media_subtype(file, i+1, 1);\n\t\tif ((mtype==GF_ISOM_SUBTYPE_MPEG4) || (mtype==GF_ISOM_SUBTYPE_MPEG4_CRYP) ) mtype = gf_isom_get_mpeg4_subtype(file, i+1, 1);\n\n\t\tif (!single_av) {\n\t\t\t/*one media per group only (we should prompt user for group selection)*/\n\t\t\tmedia_group ++;\n\t\t\tmedia_prio = 1;\n\t\t}\n\n\t\tstreamType = 0;\n\t\tesd = gf_isom_get_esd(file, i+1, 1);\n\t\tif (esd && esd->decoderConfig) {\n\t\t\tstreamType = esd->decoderConfig->streamType;\n\t\t\tif (!prev_ocr) {\n\t\t\t\tprev_ocr = esd->OCRESID;\n\t\t\t\tif (!esd->OCRESID) prev_ocr = esd->ESID;\n\t\t\t} else if (esd->OCRESID && prev_ocr != esd->OCRESID) {\n\t\t\t\tsingle_ocr = 0;\n\t\t\t}\n\t\t\t/*OD MUST BE WITHOUT REFERENCES*/\n\t\t\tif (streamType==1) copy = 1;\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\n\t\tif (!regular_iod && gf_isom_is_track_in_root_od(file, i+1)) {\n\t\t\t/*single AU - check if base64 would fit in ESD (consider 33% overhead of base64), otherwise stream*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)==1) {\n\t\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, i+1, 1, &val);\n\t\t\t\tif (streamType) {\n\t\t\t\t\tres = gf_hinter_can_embbed_data(samp->data, samp->dataLength, streamType);\n\t\t\t\t} else {\n\t\t\t\t\t/*not a system track, we shall hint it*/\n\t\t\t\t\tres = 0;\n\t\t\t\t}\n\t\t\t\tif (samp) gf_isom_sample_del(&samp);\n\t\t\t\tif (res) continue;\n\t\t\t}\n\t\t}\n\t\tif (interleave) sl_mode |= GP_RTP_PCK_USE_INTERLEAVING;\n\n\t\thinter = gf_hinter_track_new(file, i+1, MTUSize, max_ptime, rtp_rate, sl_mode, init_payt, copy, media_group, media_prio, &e);\n\n\t\tif (!hinter) {\n\t\t\tif (e) {\n\t\t\t\tM4_LOG(nb_done ? GF_LOG_WARNING : GF_LOG_ERROR, (\"Cannot create hinter (%s)\\n\", gf_error_to_string(e) ));\n\t\t\t\tif (!nb_done) return e;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (hint_no_offset)\n\t\t\tgf_hinter_track_force_no_offsets(hinter);\n\n\t\tbw = gf_hinter_track_get_bandwidth(hinter);\n\t\ttot_bw += bw;\n\t\tflags = gf_hinter_track_get_flags(hinter);\n\n\t\t//set extraction mode for AVC/SVC\n\t\tgf_isom_set_nalu_extract_mode(file, i+1, GF_ISOM_NALU_EXTRACT_LAYER_ONLY);\n\n\t\tgf_hinter_track_get_payload_name(hinter, szPayload);\n\t\tM4_LOG(GF_LOG_INFO, (\"Hinting track ID %d - Type \\\"%s:%s\\\" (%s) - BW %d kbps\\n\", gf_isom_get_track_id(file, i+1), gf_4cc_to_str(mtype), gf_4cc_to_str(mtype), szPayload, bw));\n\t\tif (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) M4_LOG(GF_LOG_INFO, (\"\\tMPEG-4 Systems stream carousel enabled\\n\"));\n\t\te = gf_hinter_track_process(hinter);\n\n\t\tif (!e) e = gf_hinter_track_finalize(hinter, has_iod);\n\t\tgf_hinter_track_del(hinter);\n\n\t\tif (e) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error while hinting (%s)\\n\", gf_error_to_string(e)));\n\t\t\tif (!nb_done) return e;\n\t\t}\n\t\tinit_payt++;\n\t\tnb_done ++;\n\t}\n\n\tif (has_iod) {\n\t\tiod_mode = GF_SDP_IOD_ISMA;\n\t\tif (regular_iod) iod_mode = GF_SDP_IOD_REGULAR;\n\t} else {\n\t\tiod_mode = GF_SDP_IOD_NONE;\n\t}\n\tgf_hinter_finalize(file, iod_mode, tot_bw);\n\n\tif (!single_ocr)\n\t\tM4_LOG(GF_LOG_WARNING, (\"Warning: at least 2 timelines found in the file\\nThis may not be supported by servers/players\\n\\n\"));\n\n\treturn GF_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144993,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,\n\t\t\t\t  RBinDexClass *c, int MI, int MA, int paddr, int ins_size,\n\t\t\t\t  int insns_size, char *class_name, int regsz,\n\t\t\t\t  int debug_info_off) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\tconst ut8 *p4 = r_buf_get_at (binfile->buf, debug_info_off, NULL);\n\tconst ut8 *p4_end = p4 + binfile->buf->length - debug_info_off;\n\tut64 line_start;\n\tut64 parameters_size;\n\tut64 param_type_idx;\n\tut16 argReg = regsz - ins_size;\n\tut64 source_file_idx = c->source_file;\n\tRList *params, *debug_positions, *emitted_debug_locals = NULL; \n\tbool keep = true;\n\tif (argReg > regsz) {\n\t\treturn; // this return breaks tests\n\t}\n\tp4 = r_uleb128 (p4, p4_end - p4, &line_start);\n\tp4 = r_uleb128 (p4, p4_end - p4, &parameters_size);\n\t// TODO: check when we should use source_file\n\t// The state machine consists of five registers\n\tut32 address = 0;\n\tut32 line = line_start;\n\tif (!(debug_positions = r_list_newf ((RListFree)free))) {\n\t\treturn;\t\n\t}\n\tif (!(emitted_debug_locals = r_list_newf ((RListFree)free))) {\n\t\tr_list_free (debug_positions);\n\t\treturn;\n\t}\n\n\tstruct dex_debug_local_t debug_locals[regsz];\n\tmemset (debug_locals, 0, sizeof (struct dex_debug_local_t) * regsz);\n\tif (!(MA & 0x0008)) {\n\t\tdebug_locals[argReg].name = \"this\";\n\t\tdebug_locals[argReg].descriptor = r_str_newf(\"%s;\", class_name);\n\t\tdebug_locals[argReg].startAddress = 0;\n\t\tdebug_locals[argReg].signature = NULL;\n\t\tdebug_locals[argReg].live = true;\n\t\targReg++;\n\t}\n\tif (!(params = dex_method_signature2 (bin, MI))) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\treturn;\n\t}\n\n\tRListIter *iter = r_list_iterator (params);\n\tchar *name;\n\tchar *type;\n\tint reg;\n\n\tr_list_foreach (params, iter, type) {\n\t\tif ((argReg >= regsz) || !type || parameters_size <= 0) {\n\t\t\tr_list_free (debug_positions);\n\t\t\tr_list_free (params);\n\t\t\tr_list_free (emitted_debug_locals);\n\t\t\treturn;\n\t\t}\n\t\tp4 = r_uleb128 (p4, p4_end - p4, &param_type_idx); // read uleb128p1\n\t\tparam_type_idx -= 1;\n\t\tname = getstr (bin, param_type_idx);\n\t\treg = argReg;\n\t\tswitch (type[0]) {\n\t\tcase 'D':\n\t\tcase 'J':\n\t\t\targReg += 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\targReg += 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (name) {\n\t\t\tdebug_locals[reg].name = name;\n\t\t\tdebug_locals[reg].descriptor = type;\n\t\t\tdebug_locals[reg].signature = NULL;\n\t\t\tdebug_locals[reg].startAddress = address;\n\t\t\tdebug_locals[reg].live = true;\n\t\t}\n\t\t--parameters_size;\n\t}\n\n\tut8 opcode = *(p4++) & 0xff;\n\twhile (keep) {\n\t\tswitch (opcode) {\n\t\tcase 0x0: // DBG_END_SEQUENCE\n\t\t\tkeep = false;\n\t\t\tbreak;\n\t\tcase 0x1: // DBG_ADVANCE_PC\n\t\t\t{\n\t\t\tut64 addr_diff;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &addr_diff);\n\t\t\taddress += addr_diff;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x2: // DBG_ADVANCE_LINE\n\t\t\t{\n\t\t\tst64 line_diff = r_sleb128 (&p4, p4_end);\n\t\t\tline += line_diff;\n\t\t\t}\n\t\t\tbreak;\t\n\t\tcase 0x3: // DBG_START_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx); \n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx); \n\t\t\ttype_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = NULL;\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t//eprintf(\"DBG_START_LOCAL %x %x %x\\n\", register_num, name_idx, type_idx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x4: //DBG_START_LOCAL_EXTENDED\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tut64 sig_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx);\n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx);\n\t\t\ttype_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &sig_idx);\n\t\t\tsig_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = getstr (bin, sig_idx);\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x5: // DBG_END_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].live = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x6: // DBG_RESTART_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tif (!debug_locals[register_num].live) {\n\t\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x7: //DBG_SET_PROLOGUE_END\n\t\t\tbreak;\n\t\tcase 0x8: //DBG_SET_PROLOGUE_BEGIN\n\t\t\tbreak;\n\t\tcase 0x9:\n\t\t\t{\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &source_file_idx);\n\t\t\tsource_file_idx--;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\tint adjusted_opcode = opcode - 0x0a;\n\t\t\taddress += (adjusted_opcode / 15);\n\t\t\tline += -4 + (adjusted_opcode % 15);\n\t\t\tstruct dex_debug_position_t *position =\n\t\t\t\tmalloc (sizeof (struct dex_debug_position_t));\n\t\t\tif (!position) {\n\t\t\t\tkeep = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tposition->source_file_idx = source_file_idx;\n\t\t\tposition->address = address;\n\t\t\tposition->line = line;\n\t\t\tr_list_append (debug_positions, position);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\topcode = *(p4++) & 0xff;\n\t}\n\n\tif (!binfile->sdb_addrinfo) {\n\t\tbinfile->sdb_addrinfo = sdb_new0 ();\n\t}\n\n\tchar *fileline;\n\tchar offset[64];\n\tchar *offset_ptr;\n\n\tRListIter *iter1;\n\tstruct dex_debug_position_t *pos;\n\tr_list_foreach (debug_positions, iter1, pos) {\n\t\tfileline = r_str_newf (\"%s|%\"PFMT64d, getstr (bin, pos->source_file_idx), pos->line);\n\t\toffset_ptr = sdb_itoa (pos->address + paddr, offset, 16);\n\t\tsdb_set (binfile->sdb_addrinfo, offset_ptr, fileline, 0);\n\t\tsdb_set (binfile->sdb_addrinfo, fileline, offset_ptr, 0);\n\t}\n\n\tif (!dexdump) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\tr_list_free (params);\n\t\treturn;\n\t}\n\n\tRListIter *iter2;\n\tstruct dex_debug_position_t *position;\n\n\trbin->cb_printf (\"      positions     :\\n\");\n\tr_list_foreach (debug_positions, iter2, position) {\n\t\trbin->cb_printf (\"        0x%04llx line=%llu\\n\",\n\t\t\t\t position->address, position->line);\n\t}\n\n\trbin->cb_printf (\"      locals        :\\n\");\n\n\tRListIter *iter3;\n\tstruct dex_debug_local_t *local;\n\tr_list_foreach (emitted_debug_locals, iter3, local) {\n\t\tif (local->signature) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor,\n\t\t\t\tlocal->signature);\n\t\t} else {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor);\n\t\t}\n\t}\n\n\tfor (reg = 0; reg < regsz; reg++) {\n\t\tif (debug_locals[reg].live) {\n\t\t\tif (debug_locals[reg].signature) {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s \"\n\t\t\t\t\t\"%s\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor,\n\t\t\t\t\tdebug_locals[reg].signature);\n\t\t\t} else {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\"\n\t\t\t\t\t\"\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor);\n\t\t\t}\n\t\t}\n\t}\n\tr_list_free (debug_positions);\n\tr_list_free (emitted_debug_locals);\n\tr_list_free (params);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145040,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,\n\t\t\t\t  RBinDexClass *c, int MI, int MA, int paddr, int ins_size,\n\t\t\t\t  int insns_size, char *class_name, int regsz,\n\t\t\t\t  int debug_info_off) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\tconst ut8 *p4 = r_buf_get_at (binfile->buf, debug_info_off, NULL);\n\tconst ut8 *p4_end = p4 + binfile->buf->length - debug_info_off;\n\tut64 line_start;\n\tut64 parameters_size;\n\tut64 param_type_idx;\n\tut16 argReg = regsz - ins_size;\n\tut64 source_file_idx = c->source_file;\n\tRList *params, *debug_positions, *emitted_debug_locals = NULL; \n\tbool keep = true;\n\tif (argReg > regsz) {\n\t\treturn; // this return breaks tests\n\t}\n\tp4 = r_uleb128 (p4, p4_end - p4, &line_start);\n\tp4 = r_uleb128 (p4, p4_end - p4, &parameters_size);\n\t// TODO: check when we should use source_file\n\t// The state machine consists of five registers\n\tut32 address = 0;\n\tut32 line = line_start;\n\tif (!(debug_positions = r_list_newf ((RListFree)free))) {\n\t\treturn;\t\n\t}\n\tif (!(emitted_debug_locals = r_list_newf ((RListFree)free))) {\n\t\tr_list_free (debug_positions);\n\t\treturn;\n\t}\n\n\tstruct dex_debug_local_t debug_locals[regsz];\n\tmemset (debug_locals, 0, sizeof (struct dex_debug_local_t) * regsz);\n\tif (!(MA & 0x0008)) {\n\t\tdebug_locals[argReg].name = \"this\";\n\t\tdebug_locals[argReg].descriptor = r_str_newf(\"%s;\", class_name);\n\t\tdebug_locals[argReg].startAddress = 0;\n\t\tdebug_locals[argReg].signature = NULL;\n\t\tdebug_locals[argReg].live = true;\n\t\targReg++;\n\t}\n\tif (!(params = dex_method_signature2 (bin, MI))) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\treturn;\n\t}\n\n\tRListIter *iter = r_list_iterator (params);\n\tchar *name;\n\tchar *type;\n\tint reg;\n\n\tr_list_foreach (params, iter, type) {\n\t\tif ((argReg >= regsz) || !type || parameters_size <= 0) {\n\t\t\tr_list_free (debug_positions);\n\t\t\tr_list_free (params);\n\t\t\tr_list_free (emitted_debug_locals);\n\t\t\treturn;\n\t\t}\n\t\tp4 = r_uleb128 (p4, p4_end - p4, &param_type_idx); // read uleb128p1\n\t\tparam_type_idx -= 1;\n\t\tname = getstr (bin, param_type_idx);\n\t\treg = argReg;\n\t\tswitch (type[0]) {\n\t\tcase 'D':\n\t\tcase 'J':\n\t\t\targReg += 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\targReg += 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (name) {\n\t\t\tdebug_locals[reg].name = name;\n\t\t\tdebug_locals[reg].descriptor = type;\n\t\t\tdebug_locals[reg].signature = NULL;\n\t\t\tdebug_locals[reg].startAddress = address;\n\t\t\tdebug_locals[reg].live = true;\n\t\t}\n\t\t--parameters_size;\n\t}\n\n\tif (p4 <= 0) {\n\t\treturn;\n\t}\n\tut8 opcode = *(p4++) & 0xff;\n\twhile (keep) {\n\t\tswitch (opcode) {\n\t\tcase 0x0: // DBG_END_SEQUENCE\n\t\t\tkeep = false;\n\t\t\tbreak;\n\t\tcase 0x1: // DBG_ADVANCE_PC\n\t\t\t{\n\t\t\tut64 addr_diff;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &addr_diff);\n\t\t\taddress += addr_diff;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x2: // DBG_ADVANCE_LINE\n\t\t\t{\n\t\t\tst64 line_diff = r_sleb128 (&p4, p4_end);\n\t\t\tline += line_diff;\n\t\t\t}\n\t\t\tbreak;\t\n\t\tcase 0x3: // DBG_START_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx); \n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx); \n\t\t\ttype_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = NULL;\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t//eprintf(\"DBG_START_LOCAL %x %x %x\\n\", register_num, name_idx, type_idx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x4: //DBG_START_LOCAL_EXTENDED\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tut64 sig_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx);\n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx);\n\t\t\ttype_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &sig_idx);\n\t\t\tsig_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = getstr (bin, sig_idx);\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x5: // DBG_END_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].live = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x6: // DBG_RESTART_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tif (!debug_locals[register_num].live) {\n\t\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x7: //DBG_SET_PROLOGUE_END\n\t\t\tbreak;\n\t\tcase 0x8: //DBG_SET_PROLOGUE_BEGIN\n\t\t\tbreak;\n\t\tcase 0x9:\n\t\t\t{\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &source_file_idx);\n\t\t\tsource_file_idx--;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\tint adjusted_opcode = opcode - 0x0a;\n\t\t\taddress += (adjusted_opcode / 15);\n\t\t\tline += -4 + (adjusted_opcode % 15);\n\t\t\tstruct dex_debug_position_t *position =\n\t\t\t\tmalloc (sizeof (struct dex_debug_position_t));\n\t\t\tif (!position) {\n\t\t\t\tkeep = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tposition->source_file_idx = source_file_idx;\n\t\t\tposition->address = address;\n\t\t\tposition->line = line;\n\t\t\tr_list_append (debug_positions, position);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\topcode = *(p4++) & 0xff;\n\t}\n\n\tif (!binfile->sdb_addrinfo) {\n\t\tbinfile->sdb_addrinfo = sdb_new0 ();\n\t}\n\n\tchar *fileline;\n\tchar offset[64];\n\tchar *offset_ptr;\n\n\tRListIter *iter1;\n\tstruct dex_debug_position_t *pos;\n\tr_list_foreach (debug_positions, iter1, pos) {\n\t\tfileline = r_str_newf (\"%s|%\"PFMT64d, getstr (bin, pos->source_file_idx), pos->line);\n\t\toffset_ptr = sdb_itoa (pos->address + paddr, offset, 16);\n\t\tsdb_set (binfile->sdb_addrinfo, offset_ptr, fileline, 0);\n\t\tsdb_set (binfile->sdb_addrinfo, fileline, offset_ptr, 0);\n\t}\n\n\tif (!dexdump) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\tr_list_free (params);\n\t\treturn;\n\t}\n\n\tRListIter *iter2;\n\tstruct dex_debug_position_t *position;\n\n\trbin->cb_printf (\"      positions     :\\n\");\n\tr_list_foreach (debug_positions, iter2, position) {\n\t\trbin->cb_printf (\"        0x%04llx line=%llu\\n\",\n\t\t\t\t position->address, position->line);\n\t}\n\n\trbin->cb_printf (\"      locals        :\\n\");\n\n\tRListIter *iter3;\n\tstruct dex_debug_local_t *local;\n\tr_list_foreach (emitted_debug_locals, iter3, local) {\n\t\tif (local->signature) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor,\n\t\t\t\tlocal->signature);\n\t\t} else {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor);\n\t\t}\n\t}\n\n\tfor (reg = 0; reg < regsz; reg++) {\n\t\tif (debug_locals[reg].live) {\n\t\t\tif (debug_locals[reg].signature) {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s \"\n\t\t\t\t\t\"%s\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor,\n\t\t\t\t\tdebug_locals[reg].signature);\n\t\t\t} else {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\"\n\t\t\t\t\t\"\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor);\n\t\t\t}\n\t\t}\n\t}\n\tr_list_free (debug_positions);\n\tr_list_free (emitted_debug_locals);\n\tr_list_free (params);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145041,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err adts_dmx_process(GF_Filter *filter)\n{\n\tGF_ADTSDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu8 *data, *output;\n\tu8 *start;\n\tu32 pck_size, remain, prev_pck_size;\n\tu64 cts = GF_FILTER_NO_TS;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tadts_dmx_check_dur(filter, ctx);\n\n\tif (ctx->opid && !ctx->is_playing)\n\t\treturn GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (!ctx->adts_buffer_size) {\n\t\t\t\tif (ctx->opid)\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = NULL;\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tprev_pck_size = ctx->adts_buffer_size;\n\tif (pck && !ctx->resume_from) {\n\t\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\t\tif (!pck_size) {\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\tu64 byte_offset = gf_filter_pck_get_byte_offset(pck);\n\t\t\tif (!ctx->adts_buffer_size) {\n\t\t\t\tctx->byte_offset = byte_offset;\n\t\t\t} else if (ctx->byte_offset + ctx->adts_buffer_size != byte_offset) {\n\t\t\t\tctx->byte_offset = GF_FILTER_NO_BO;\n\t\t\t\tif ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->adts_buffer_size) ) {\n\t\t\t\t\tctx->byte_offset = byte_offset - ctx->adts_buffer_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->adts_buffer_size + pck_size > ctx->adts_buffer_alloc) {\n\t\t\tctx->adts_buffer_alloc = ctx->adts_buffer_size + pck_size;\n\t\t\tctx->adts_buffer = gf_realloc(ctx->adts_buffer, ctx->adts_buffer_alloc);\n\t\t}\n\t\tmemcpy(ctx->adts_buffer + ctx->adts_buffer_size, data, pck_size);\n\t\tctx->adts_buffer_size += pck_size;\n\t}\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale && pck) {\n\t\tcts = gf_filter_pck_get_cts(pck);\n\t}\n\n\tif (cts == GF_FILTER_NO_TS) {\n\t\t//avoids updating cts\n\t\tprev_pck_size = 0;\n\t}\n\n\tremain = ctx->adts_buffer_size;\n\tstart = ctx->adts_buffer;\n\n\tif (ctx->resume_from) {\n\t\tstart += ctx->resume_from - 1;\n\t\tremain -= ctx->resume_from - 1;\n\t\tctx->resume_from = 0;\n\t}\n\n\twhile (remain) {\n\t\tu8 *sync;\n\t\tu32 sync_pos, size, offset, bytes_to_drop=0, nb_blocks_per_frame;\n\n\t\tif (!ctx->tag_size && (remain>3)) {\n\n\t\t\t/* Did we read an ID3v2 ? */\n\t\t\tif (start[0] == 'I' && start[1] == 'D' && start[2] == '3') {\n\t\t\t\tif (remain<10)\n\t\t\t\t\treturn GF_OK;\n\n\t\t\t\tctx->tag_size = ((start[9] & 0x7f) + ((start[8] & 0x7f) << 7) + ((start[7] & 0x7f) << 14) + ((start[6] & 0x7f) << 21));\n\n\t\t\t\tbytes_to_drop = 10;\n\t\t\t\tif (ctx->id3_buffer_alloc < ctx->tag_size+10) {\n\t\t\t\t\tctx->id3_buffer = gf_realloc(ctx->id3_buffer, ctx->tag_size+10);\n\t\t\t\t\tctx->id3_buffer_alloc = ctx->tag_size+10;\n\t\t\t\t}\n\t\t\t\tmemcpy(ctx->id3_buffer, start, 10);\n\t\t\t\tctx->id3_buffer_size = 10;\n\t\t\t\tgoto drop_byte;\n\t\t\t}\n\t\t}\n\t\tif (ctx->tag_size) {\n\t\t\tif (ctx->tag_size>remain) {\n\t\t\t\tbytes_to_drop = remain;\n\t\t\t\tctx->tag_size-=remain;\n\t\t\t} else {\n\t\t\t\tbytes_to_drop = ctx->tag_size;\n\t\t\t\tctx->tag_size = 0;\n\t\t\t}\n\t\t\tmemcpy(ctx->id3_buffer + ctx->id3_buffer_size, start, bytes_to_drop);\n\t\t\tctx->id3_buffer_size += bytes_to_drop;\n\n\t\t\tif (!ctx->tag_size && ctx->opid) {\n\t\t\t\tid3dmx_flush(filter, ctx->id3_buffer, ctx->id3_buffer_size, ctx->opid, ctx->expart ? &ctx->vpid : NULL);\n\t\t\t\tctx->id3_buffer_size = 0;\n\t\t\t}\n\t\t\tgoto drop_byte;\n\n\t\t}\n\n\t\tsync = memchr(start, 0xFF, remain);\n\t\tsync_pos = (u32) (sync ? sync - start : remain);\n\n\t\t//couldn't find sync byte in this packet\n\t\tif (remain - sync_pos < 7) {\n\t\t\tbreak;\n\t\t}\n\n\t\t//not sync !\n\t\tif ((sync[1] & 0xF0) != 0xF0) {\n\t\t\tGF_LOG(ctx->nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_PARSER, (\"[ADTSDmx] invalid ADTS sync bytes, resyncing\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t}\n\t\tif (!ctx->bs) {\n\t\t\tctx->bs = gf_bs_new(sync + 1, remain - sync_pos - 1, GF_BITSTREAM_READ);\n\t\t} else {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, sync + 1, remain - sync_pos - 1);\n\t\t}\n\n\t\t//ok parse header\n\t\tgf_bs_read_int(ctx->bs, 4);\n\n\t\tctx->hdr.is_mp2 = (Bool)gf_bs_read_int(ctx->bs, 1);\n\t\t//if (ctx->mpeg4)\n\t\t//we deprecate old MPEG-2 signaling for AAC in ISOBMFF, as it is not well supported anyway and we don't write adif_header as\n\t\t//supposed to be for these types\n\t\tctx->hdr.is_mp2 = 0;\n\n\t\tgf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.no_crc = (Bool)gf_bs_read_int(ctx->bs, 1);\n\n\t\tctx->hdr.profile = 1 + gf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.sr_idx = gf_bs_read_int(ctx->bs, 4);\n\t\tgf_bs_read_int(ctx->bs, 1);\n\t\tctx->hdr.nb_ch = gf_bs_read_int(ctx->bs, 3);\n\n\t\tgf_bs_read_int(ctx->bs, 4);\n\t\tctx->hdr.frame_size = gf_bs_read_int(ctx->bs, 13);\n\t\tgf_bs_read_int(ctx->bs, 11);\n\t\tnb_blocks_per_frame = gf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.hdr_size = 7;\n\n\t\tif (!ctx->hdr.no_crc) {\n\t\t\tu32 skip;\n\t\t\tif (!nb_blocks_per_frame) {\n\t\t\t\tskip = 2;\n\t\t\t} else {\n\t\t\t\tskip = 2 + 2*nb_blocks_per_frame; //and we have 2 bytes per raw_data_block\n\t\t\t}\n\t\t\tctx->hdr.hdr_size += skip;\n\t\t\tgf_bs_skip_bytes(ctx->bs, skip);\n\t\t}\n\n\t\tif (!ctx->hdr.frame_size || !GF_M4ASampleRates[ctx->hdr.sr_idx]) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[ADTSDmx] Invalid ADTS frame header, resyncing\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t}\n\t\tif ((nb_blocks_per_frame>2) || (nb_blocks_per_frame && ctx->hdr.nb_ch)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[ADTSDmx] Unsupported multi-block ADTS frame header - patch welcome\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t} else if (!nb_blocks_per_frame) {\n\t\t\tif (ctx->aacchcfg<0)\n\t\t\t\tctx->hdr.nb_ch = -ctx->aacchcfg;\n\t\t\telse if (!ctx->hdr.nb_ch)\n\t\t\t\tctx->hdr.nb_ch = ctx->aacchcfg;\n\n\t\t\tif (!ctx->hdr.nb_ch) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[ADTSDmx] Missing channel configuration in ADTS frame header, defaulting to stereo - use `--aacchcfg` to force config\\n\"));\n\t\t\t\tctx->hdr.nb_ch = ctx->aacchcfg = 2;\n\t\t\t}\n\t\t}\n\n\t\tif (nb_blocks_per_frame==2) {\n\t\t\tu32 pos = (u32) gf_bs_get_position(ctx->bs);\n\t\t\tgf_m4a_parse_program_config_element(ctx->bs, &ctx->acfg);\n\t\t\tif (!ctx->hdr.no_crc)\n\t\t\t\tgf_bs_skip_bytes(ctx->bs, 2);  //per block CRC\n\n\t\t\tctx->hdr.hdr_size += (u32) gf_bs_get_position(ctx->bs) - pos;\n\t\t}\n\t\t//value 1->6 match channel number, value 7 is 7.1\n\t\tif (ctx->hdr.nb_ch==7)\n\t\t\tctx->hdr.nb_ch = 8;\n\n\n\t\t//ready to send packet\n\t\tif (ctx->hdr.frame_size + 1 < remain) {\n\t\t\tu32 next_frame = ctx->hdr.frame_size;\n\t\t\t//make sure we are sync!\n\t\t\tif ((sync[next_frame] !=0xFF) || ((sync[next_frame+1] & 0xF0) !=0xF0) ) {\n\t\t\t\tGF_LOG(ctx->nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_PARSER, (\"[ADTSDmx] invalid next ADTS frame sync, resyncing\\n\"));\n\t\t\t\tctx->nb_frames = 0;\n\t\t\t\tgoto drop_byte;\n\t\t\t}\n\t\t}\n\t\t//otherwise wait for next frame, unless if end of stream\n\t\telse if (pck) {\n\t\t\tif (ctx->timescale && !prev_pck_size &&  (cts != GF_FILTER_NO_TS) ) {\n\t\t\t\tctx->cts = cts;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tadts_dmx_check_pid(filter, ctx);\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = 1 + ctx->adts_buffer_size - remain;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tctx->nb_frames++;\n\t\tsize = ctx->hdr.frame_size - ctx->hdr.hdr_size;\n\t\toffset = ctx->hdr.hdr_size;\n\t\t//per raw-block CRC\n\t\tif ((nb_blocks_per_frame==2) && !ctx->hdr.no_crc)\n\t\t\tsize -= 2;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_samples_at_seek = (u64) (ctx->start_range * GF_M4ASampleRates[ctx->sr_idx]);\n\t\t\tif (ctx->cts + ctx->dts_inc >= nb_samples_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tbytes_to_drop = ctx->hdr.frame_size;\n\t\tif (ctx->timescale && !prev_pck_size &&  (cts != GF_FILTER_NO_TS) ) {\n\t\t\tctx->cts = cts;\n\t\t\tcts = GF_FILTER_NO_TS;\n\t\t}\n\n\t\tif (!ctx->in_seek) {\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &output);\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\n\t\t\tmemcpy(output, sync + offset, size);\n\n\t\t\tgf_filter_pck_set_dts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_duration(dst_pck, ctx->dts_inc);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\t\t\tgf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);\n\n\t\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset + ctx->hdr.hdr_size);\n\t\t\t}\n\n\t\t\tgf_filter_pck_send(dst_pck);\n\t\t}\n\t\tadts_dmx_update_cts(ctx);\n\n\n\t\t//truncated last frame\n\t\tif (bytes_to_drop>remain) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[ADTSDmx] truncated ADTS frame!\\n\"));\n\t\t\tbytes_to_drop=remain;\n\t\t}\n\ndrop_byte:\n\t\tif (!bytes_to_drop) {\n\t\t\tbytes_to_drop = 1;\n\t\t}\n\t\tstart += bytes_to_drop;\n\t\tremain -= bytes_to_drop;\n\n\t\tif (prev_pck_size) {\n\t\t\tif (prev_pck_size > bytes_to_drop) prev_pck_size -= bytes_to_drop;\n\t\t\telse {\n\t\t\t\tprev_pck_size=0;\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = pck;\n\t\t\t\tif (pck)\n\t\t\t\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\t\t}\n\t\t}\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO)\n\t\t\tctx->byte_offset += bytes_to_drop;\n\t}\n\n\tif (!pck) {\n\t\tctx->adts_buffer_size = 0;\n\t\treturn adts_dmx_process(filter);\n\t} else {\n\t\tif (remain) {\n\t\t\tmemmove(ctx->adts_buffer, start, remain);\n\t\t}\n\t\tctx->adts_buffer_size = remain;\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t}\n\treturn GF_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145074,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err adts_dmx_process(GF_Filter *filter)\n{\n\tGF_ADTSDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu8 *data, *output;\n\tu8 *start;\n\tu32 pck_size, remain, prev_pck_size;\n\tu64 cts = GF_FILTER_NO_TS;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tadts_dmx_check_dur(filter, ctx);\n\n\tif (ctx->opid && !ctx->is_playing)\n\t\treturn GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (!ctx->adts_buffer_size) {\n\t\t\t\tif (ctx->opid)\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = NULL;\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tprev_pck_size = ctx->adts_buffer_size;\n\tif (pck && !ctx->resume_from) {\n\t\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\t\tif (!pck_size) {\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\tu64 byte_offset = gf_filter_pck_get_byte_offset(pck);\n\t\t\tif (!ctx->adts_buffer_size) {\n\t\t\t\tctx->byte_offset = byte_offset;\n\t\t\t} else if (ctx->byte_offset + ctx->adts_buffer_size != byte_offset) {\n\t\t\t\tctx->byte_offset = GF_FILTER_NO_BO;\n\t\t\t\tif ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->adts_buffer_size) ) {\n\t\t\t\t\tctx->byte_offset = byte_offset - ctx->adts_buffer_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->adts_buffer_size + pck_size > ctx->adts_buffer_alloc) {\n\t\t\tctx->adts_buffer_alloc = ctx->adts_buffer_size + pck_size;\n\t\t\tctx->adts_buffer = gf_realloc(ctx->adts_buffer, ctx->adts_buffer_alloc);\n\t\t}\n\t\tmemcpy(ctx->adts_buffer + ctx->adts_buffer_size, data, pck_size);\n\t\tctx->adts_buffer_size += pck_size;\n\t}\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale && pck) {\n\t\tcts = gf_filter_pck_get_cts(pck);\n\t}\n\n\tif (cts == GF_FILTER_NO_TS) {\n\t\t//avoids updating cts\n\t\tprev_pck_size = 0;\n\t}\n\n\tremain = ctx->adts_buffer_size;\n\tstart = ctx->adts_buffer;\n\n\tif (ctx->resume_from) {\n\t\tstart += ctx->resume_from - 1;\n\t\tremain -= ctx->resume_from - 1;\n\t\tctx->resume_from = 0;\n\t}\n\n\twhile (remain) {\n\t\tu8 *sync;\n\t\tu32 sync_pos, size, offset, bytes_to_drop=0, nb_blocks_per_frame;\n\n\t\tif (!ctx->tag_size && (remain>3)) {\n\n\t\t\t/* Did we read an ID3v2 ? */\n\t\t\tif (start[0] == 'I' && start[1] == 'D' && start[2] == '3') {\n\t\t\t\tif (remain<10)\n\t\t\t\t\treturn GF_OK;\n\n\t\t\t\tctx->tag_size = ((start[9] & 0x7f) + ((start[8] & 0x7f) << 7) + ((start[7] & 0x7f) << 14) + ((start[6] & 0x7f) << 21));\n\n\t\t\t\tbytes_to_drop = 10;\n\t\t\t\tif (ctx->id3_buffer_alloc < ctx->tag_size+10) {\n\t\t\t\t\tctx->id3_buffer = gf_realloc(ctx->id3_buffer, ctx->tag_size+10);\n\t\t\t\t\tctx->id3_buffer_alloc = ctx->tag_size+10;\n\t\t\t\t}\n\t\t\t\tmemcpy(ctx->id3_buffer, start, 10);\n\t\t\t\tctx->id3_buffer_size = 10;\n\t\t\t\tgoto drop_byte;\n\t\t\t}\n\t\t}\n\t\tif (ctx->tag_size) {\n\t\t\tif (ctx->tag_size>remain) {\n\t\t\t\tbytes_to_drop = remain;\n\t\t\t\tctx->tag_size-=remain;\n\t\t\t} else {\n\t\t\t\tbytes_to_drop = ctx->tag_size;\n\t\t\t\tctx->tag_size = 0;\n\t\t\t}\n\t\t\tmemcpy(ctx->id3_buffer + ctx->id3_buffer_size, start, bytes_to_drop);\n\t\t\tctx->id3_buffer_size += bytes_to_drop;\n\n\t\t\tif (!ctx->tag_size && ctx->opid) {\n\t\t\t\tid3dmx_flush(filter, ctx->id3_buffer, ctx->id3_buffer_size, ctx->opid, ctx->expart ? &ctx->vpid : NULL);\n\t\t\t\tctx->id3_buffer_size = 0;\n\t\t\t}\n\t\t\tgoto drop_byte;\n\n\t\t}\n\n\t\tsync = memchr(start, 0xFF, remain);\n\t\tsync_pos = (u32) (sync ? sync - start : remain);\n\n\t\t//couldn't find sync byte in this packet\n\t\tif (remain - sync_pos < 7) {\n\t\t\tbreak;\n\t\t}\n\n\t\t//not sync !\n\t\tif ((sync[1] & 0xF0) != 0xF0) {\n\t\t\tGF_LOG(ctx->nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_PARSER, (\"[ADTSDmx] invalid ADTS sync bytes, resyncing\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t}\n\t\tif (!ctx->bs) {\n\t\t\tctx->bs = gf_bs_new(sync + 1, remain - sync_pos - 1, GF_BITSTREAM_READ);\n\t\t} else {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, sync + 1, remain - sync_pos - 1);\n\t\t}\n\n\t\t//ok parse header\n\t\tgf_bs_read_int(ctx->bs, 4);\n\n\t\tctx->hdr.is_mp2 = (Bool)gf_bs_read_int(ctx->bs, 1);\n\t\t//if (ctx->mpeg4)\n\t\t//we deprecate old MPEG-2 signaling for AAC in ISOBMFF, as it is not well supported anyway and we don't write adif_header as\n\t\t//supposed to be for these types\n\t\tctx->hdr.is_mp2 = 0;\n\n\t\tgf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.no_crc = (Bool)gf_bs_read_int(ctx->bs, 1);\n\n\t\tctx->hdr.profile = 1 + gf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.sr_idx = gf_bs_read_int(ctx->bs, 4);\n\t\tgf_bs_read_int(ctx->bs, 1);\n\t\tctx->hdr.nb_ch = gf_bs_read_int(ctx->bs, 3);\n\n\t\tgf_bs_read_int(ctx->bs, 4);\n\t\tctx->hdr.frame_size = gf_bs_read_int(ctx->bs, 13);\n\t\tgf_bs_read_int(ctx->bs, 11);\n\t\tnb_blocks_per_frame = gf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.hdr_size = 7;\n\n\t\tif (!ctx->hdr.no_crc) {\n\t\t\tu32 skip;\n\t\t\tif (!nb_blocks_per_frame) {\n\t\t\t\tskip = 2;\n\t\t\t} else {\n\t\t\t\tskip = 2 + 2*nb_blocks_per_frame; //and we have 2 bytes per raw_data_block\n\t\t\t}\n\t\t\tctx->hdr.hdr_size += skip;\n\t\t\tgf_bs_skip_bytes(ctx->bs, skip);\n\t\t}\n\n\t\tif (!ctx->hdr.frame_size || !GF_M4ASampleRates[ctx->hdr.sr_idx]) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[ADTSDmx] Invalid ADTS frame header, resyncing\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t}\n\t\tif ((nb_blocks_per_frame>2) || (nb_blocks_per_frame && ctx->hdr.nb_ch)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[ADTSDmx] Unsupported multi-block ADTS frame header - patch welcome\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t} else if (!nb_blocks_per_frame) {\n\t\t\tif (ctx->aacchcfg<0)\n\t\t\t\tctx->hdr.nb_ch = -ctx->aacchcfg;\n\t\t\telse if (!ctx->hdr.nb_ch)\n\t\t\t\tctx->hdr.nb_ch = ctx->aacchcfg;\n\n\t\t\tif (!ctx->hdr.nb_ch) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[ADTSDmx] Missing channel configuration in ADTS frame header, defaulting to stereo - use `--aacchcfg` to force config\\n\"));\n\t\t\t\tctx->hdr.nb_ch = ctx->aacchcfg = 2;\n\t\t\t}\n\t\t}\n\n\t\tif (nb_blocks_per_frame==2) {\n\t\t\tu32 pos = (u32) gf_bs_get_position(ctx->bs);\n\t\t\tgf_m4a_parse_program_config_element(ctx->bs, &ctx->acfg);\n\t\t\tif (!ctx->hdr.no_crc)\n\t\t\t\tgf_bs_skip_bytes(ctx->bs, 2);  //per block CRC\n\n\t\t\tctx->hdr.hdr_size += (u32) gf_bs_get_position(ctx->bs) - pos;\n\t\t}\n\t\t//value 1->6 match channel number, value 7 is 7.1\n\t\tif (ctx->hdr.nb_ch==7)\n\t\t\tctx->hdr.nb_ch = 8;\n\n\n\t\t//ready to send packet\n\t\tif (ctx->hdr.frame_size + 1 < remain) {\n\t\t\tu32 next_frame = ctx->hdr.frame_size;\n\t\t\t//make sure we are sync!\n\t\t\tif ((sync[next_frame] !=0xFF) || ((sync[next_frame+1] & 0xF0) !=0xF0) ) {\n\t\t\t\tGF_LOG(ctx->nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_PARSER, (\"[ADTSDmx] invalid next ADTS frame sync, resyncing\\n\"));\n\t\t\t\tctx->nb_frames = 0;\n\t\t\t\tgoto drop_byte;\n\t\t\t}\n\t\t}\n\t\t//otherwise wait for next frame, unless if end of stream\n\t\telse if (pck) {\n\t\t\tif (ctx->timescale && !prev_pck_size &&  (cts != GF_FILTER_NO_TS) ) {\n\t\t\t\tctx->cts = cts;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ctx->hdr.frame_size < ctx->hdr.hdr_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[ADTSDmx] Corrupted ADTS frame header, resyncing\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t}\n\n\t\tadts_dmx_check_pid(filter, ctx);\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = 1 + ctx->adts_buffer_size - remain;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tctx->nb_frames++;\n\t\tsize = ctx->hdr.frame_size - ctx->hdr.hdr_size;\n\t\toffset = ctx->hdr.hdr_size;\n\t\t//per raw-block CRC\n\t\tif ((nb_blocks_per_frame==2) && !ctx->hdr.no_crc)\n\t\t\tsize -= 2;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_samples_at_seek = (u64) (ctx->start_range * GF_M4ASampleRates[ctx->sr_idx]);\n\t\t\tif (ctx->cts + ctx->dts_inc >= nb_samples_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tbytes_to_drop = ctx->hdr.frame_size;\n\t\tif (ctx->timescale && !prev_pck_size &&  (cts != GF_FILTER_NO_TS) ) {\n\t\t\tctx->cts = cts;\n\t\t\tcts = GF_FILTER_NO_TS;\n\t\t}\n\n\t\tif (!ctx->in_seek) {\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &output);\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\n\t\t\tmemcpy(output, sync + offset, size);\n\n\t\t\tgf_filter_pck_set_dts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_duration(dst_pck, ctx->dts_inc);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\t\t\tgf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);\n\n\t\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset + ctx->hdr.hdr_size);\n\t\t\t}\n\n\t\t\tgf_filter_pck_send(dst_pck);\n\t\t}\n\t\tadts_dmx_update_cts(ctx);\n\n\n\t\t//truncated last frame\n\t\tif (bytes_to_drop>remain) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[ADTSDmx] truncated ADTS frame!\\n\"));\n\t\t\tbytes_to_drop=remain;\n\t\t}\n\ndrop_byte:\n\t\tif (!bytes_to_drop) {\n\t\t\tbytes_to_drop = 1;\n\t\t}\n\t\tstart += bytes_to_drop;\n\t\tremain -= bytes_to_drop;\n\n\t\tif (prev_pck_size) {\n\t\t\tif (prev_pck_size > bytes_to_drop) prev_pck_size -= bytes_to_drop;\n\t\t\telse {\n\t\t\t\tprev_pck_size=0;\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = pck;\n\t\t\t\tif (pck)\n\t\t\t\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\t\t}\n\t\t}\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO)\n\t\t\tctx->byte_offset += bytes_to_drop;\n\t}\n\n\tif (!pck) {\n\t\tctx->adts_buffer_size = 0;\n\t\treturn adts_dmx_process(filter);\n\t} else {\n\t\tif (remain) {\n\t\t\tmemmove(ctx->adts_buffer, start, remain);\n\t\t}\n\t\tctx->adts_buffer_size = remain;\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t}\n\treturn GF_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145075,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& diag = context->input(1);\n\n    // MatrixSetDiag and MatrixSetDiagV2 both use this OpKernel. MatrixSetDiag\n    // only has two inputs, so we have to check the number of inputs before\n    // reading additional parameters in MatrixSetDiagV2.\n    int32_t lower_diag_index = 0;\n    int32_t upper_diag_index = 0;\n\n    // MatrixSetDiagV2-specific.\n    if (context->num_inputs() > kNumV1Inputs) {\n      auto& diag_index = context->input(2);\n      OP_REQUIRES(context,\n                  TensorShapeUtils::IsScalar(diag_index.shape()) ||\n                      TensorShapeUtils::IsVector(diag_index.shape()),\n                  errors::InvalidArgument(\n                      \"diag_index must be a scalar or vector, received shape: \",\n                      diag_index.shape().DebugString()));\n      lower_diag_index = diag_index.flat<int32>()(0);\n      upper_diag_index = lower_diag_index;\n      if (TensorShapeUtils::IsVector(diag_index.shape())) {\n        auto diag_index_size = diag_index.dim_size(0);\n        OP_REQUIRES(\n            context, 0 < diag_index_size && diag_index_size <= 2,\n            errors::InvalidArgument(\n                \"diag_index must have only one or two elements, received \",\n                diag_index_size, \" elements.\"));\n        if (diag_index_size > 1) {\n          upper_diag_index = diag_index.flat<int32>()(1);\n        }\n      }\n    }\n\n    const TensorShape& input_shape = input.shape();\n    const TensorShape& diag_shape = diag.shape();\n    const int input_rank = input_shape.dims();\n\n    // Preliminary validation of sizes.\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrixOrHigher(input_shape),\n                errors::InvalidArgument(\n                    \"input must be at least 2-dim, received shape: \",\n                    input.shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVectorOrHigher(diag_shape),\n                errors::InvalidArgument(\n                    \"diagonal must be at least 1-dim, received shape: \",\n                    diag_shape.DebugString()));\n\n    // Make sure lower_diag_index and upper_diag_index is valid.\n    const Eigen::Index num_rows = input_shape.dim_size(input_rank - 2);\n    const Eigen::Index num_cols = input_shape.dim_size(input_rank - 1);\n    OP_REQUIRES(  // Checks lower_diag_index == 0 for when matrix shape = 0.\n        context,\n        (-num_rows < lower_diag_index && lower_diag_index < num_cols) ||\n            lower_diag_index == 0,\n        errors::InvalidArgument(\n            \"lower_diag_index is out of bound: \", lower_diag_index,\n            \" It must be between \", -num_rows, \" and \", num_cols));\n    OP_REQUIRES(context,\n                (-num_rows < upper_diag_index && upper_diag_index < num_cols) ||\n                    upper_diag_index == 0,\n                errors::InvalidArgument(\n                    \"upper_diag_index is out of bound: \", upper_diag_index,\n                    \" It must be between \", -num_rows, \" and \", num_cols));\n    OP_REQUIRES(\n        context, lower_diag_index <= upper_diag_index,\n        errors::InvalidArgument(\n            \"lower_diag_index must not be larger than upper_diag_index: \",\n            lower_diag_index, \" > \", upper_diag_index));\n\n    // Check if diag size is consistent with input.\n    const Eigen::Index num_diags = upper_diag_index - lower_diag_index + 1;\n    OP_REQUIRES(\n        context,\n        lower_diag_index == upper_diag_index ||\n            (diag_shape.dim_size(input_rank - 2) == num_diags),\n        errors::InvalidArgument(\"The number of diagonals provided in `diag` \"\n                                \"is not consistent with `lower_diag_index` and \"\n                                \"`upper_diag_index`\"));\n\n    TensorShape expected_diag_shape = input_shape;\n    expected_diag_shape.RemoveLastDims(2);\n    if (num_diags > 1) expected_diag_shape.AddDim(num_diags);\n    const int32_t max_diag_len =\n        std::min(num_rows + std::min(upper_diag_index, 0),\n                 num_cols - std::max(lower_diag_index, 0));\n    expected_diag_shape.AddDim(max_diag_len);\n    OP_REQUIRES(\n        context, expected_diag_shape == diag_shape,\n        errors::InvalidArgument(\n            \"Either first dimensions of diagonal don't match input.shape[:-2], \"\n            \"or diagonal.shape[:-1] is not equal to the longests diagonal in \"\n            \"range [lower_diag_index:upper_diag_index].\\nInput shape: \",\n            input_shape.DebugString(),\n            \"\\nDiagonal shape: \", diag_shape.DebugString(),\n            \"\\nExpected diagonal shape: \", expected_diag_shape.DebugString()));\n\n    if (input.NumElements() == 0) {\n      // This is a no-op.\n      context->set_output(0, input);\n      return;\n    }\n\n    auto input_reshaped = input.flat_inner_dims<T, 3>();\n    auto diag_reshaped = diag.flat<T>();\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, input_shape, &output));\n    auto output_reshaped = output->flat_inner_dims<T, 3>();\n    functor::MatrixSetDiag<Device, T>::Compute(\n        context, context->eigen_device<Device>(), input_reshaped, diag_reshaped,\n        output_reshaped, lower_diag_index, upper_diag_index, max_diag_len,\n        left_align_superdiagonal_, left_align_subdiagonal_);\n  }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145082,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& diag = context->input(1);\n\n    // MatrixSetDiag and MatrixSetDiagV2 both use this OpKernel. MatrixSetDiag\n    // only has two inputs, so we have to check the number of inputs before\n    // reading additional parameters in MatrixSetDiagV2.\n    int32_t lower_diag_index = 0;\n    int32_t upper_diag_index = 0;\n\n    // MatrixSetDiagV2-specific.\n    if (context->num_inputs() > kNumV1Inputs) {\n      auto& diag_index = context->input(2);\n      OP_REQUIRES(context,\n                  TensorShapeUtils::IsScalar(diag_index.shape()) ||\n                      TensorShapeUtils::IsVector(diag_index.shape()),\n                  errors::InvalidArgument(\n                      \"diag_index must be a scalar or vector, received shape: \",\n                      diag_index.shape().DebugString()));\n      OP_REQUIRES(\n          context, diag_index.NumElements() > 0,\n          errors::InvalidArgument(\"diag_index must have at least one element\"));\n      lower_diag_index = diag_index.flat<int32>()(0);\n      upper_diag_index = lower_diag_index;\n      if (TensorShapeUtils::IsVector(diag_index.shape())) {\n        auto diag_index_size = diag_index.dim_size(0);\n        OP_REQUIRES(\n            context, 0 < diag_index_size && diag_index_size <= 2,\n            errors::InvalidArgument(\n                \"diag_index must have only one or two elements, received \",\n                diag_index_size, \" elements.\"));\n        if (diag_index_size > 1) {\n          upper_diag_index = diag_index.flat<int32>()(1);\n        }\n      }\n    }\n\n    const TensorShape& input_shape = input.shape();\n    const TensorShape& diag_shape = diag.shape();\n    const int input_rank = input_shape.dims();\n\n    // Preliminary validation of sizes.\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrixOrHigher(input_shape),\n                errors::InvalidArgument(\n                    \"input must be at least 2-dim, received shape: \",\n                    input.shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVectorOrHigher(diag_shape),\n                errors::InvalidArgument(\n                    \"diagonal must be at least 1-dim, received shape: \",\n                    diag_shape.DebugString()));\n\n    // Make sure lower_diag_index and upper_diag_index is valid.\n    const Eigen::Index num_rows = input_shape.dim_size(input_rank - 2);\n    const Eigen::Index num_cols = input_shape.dim_size(input_rank - 1);\n    OP_REQUIRES(  // Checks lower_diag_index == 0 for when matrix shape = 0.\n        context,\n        (-num_rows < lower_diag_index && lower_diag_index < num_cols) ||\n            lower_diag_index == 0,\n        errors::InvalidArgument(\n            \"lower_diag_index is out of bound: \", lower_diag_index,\n            \" It must be between \", -num_rows, \" and \", num_cols));\n    OP_REQUIRES(context,\n                (-num_rows < upper_diag_index && upper_diag_index < num_cols) ||\n                    upper_diag_index == 0,\n                errors::InvalidArgument(\n                    \"upper_diag_index is out of bound: \", upper_diag_index,\n                    \" It must be between \", -num_rows, \" and \", num_cols));\n    OP_REQUIRES(\n        context, lower_diag_index <= upper_diag_index,\n        errors::InvalidArgument(\n            \"lower_diag_index must not be larger than upper_diag_index: \",\n            lower_diag_index, \" > \", upper_diag_index));\n\n    // Check if diag size is consistent with input.\n    const Eigen::Index num_diags = upper_diag_index - lower_diag_index + 1;\n    OP_REQUIRES(\n        context,\n        lower_diag_index == upper_diag_index ||\n            (diag_shape.dim_size(input_rank - 2) == num_diags),\n        errors::InvalidArgument(\"The number of diagonals provided in `diag` \"\n                                \"is not consistent with `lower_diag_index` and \"\n                                \"`upper_diag_index`\"));\n\n    TensorShape expected_diag_shape = input_shape;\n    expected_diag_shape.RemoveLastDims(2);\n    if (num_diags > 1) expected_diag_shape.AddDim(num_diags);\n    const int32_t max_diag_len =\n        std::min(num_rows + std::min(upper_diag_index, 0),\n                 num_cols - std::max(lower_diag_index, 0));\n    expected_diag_shape.AddDim(max_diag_len);\n    OP_REQUIRES(\n        context, expected_diag_shape == diag_shape,\n        errors::InvalidArgument(\n            \"Either first dimensions of diagonal don't match input.shape[:-2], \"\n            \"or diagonal.shape[:-1] is not equal to the longests diagonal in \"\n            \"range [lower_diag_index:upper_diag_index].\\nInput shape: \",\n            input_shape.DebugString(),\n            \"\\nDiagonal shape: \", diag_shape.DebugString(),\n            \"\\nExpected diagonal shape: \", expected_diag_shape.DebugString()));\n\n    if (input.NumElements() == 0) {\n      // This is a no-op.\n      context->set_output(0, input);\n      return;\n    }\n\n    auto input_reshaped = input.flat_inner_dims<T, 3>();\n    auto diag_reshaped = diag.flat<T>();\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, input_shape, &output));\n    auto output_reshaped = output->flat_inner_dims<T, 3>();\n    functor::MatrixSetDiag<Device, T>::Compute(\n        context, context->eigen_device<Device>(), input_reshaped, diag_reshaped,\n        output_reshaped, lower_diag_index, upper_diag_index, max_diag_len,\n        left_align_superdiagonal_, left_align_subdiagonal_);\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145083,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void Lua::setParamsTable(lua_State* vm, const char* table_name,\n\t\t\t const char* query) const {\n  char outbuf[FILENAME_MAX];\n  char *where;\n  char *tok;\n\n  char *query_string = query ? strdup(query) : NULL;\n\n  lua_newtable(L);\n\n  if (query_string) {\n    // ntop->getTrace()->traceEvent(TRACE_WARNING, \"[HTTP] %s\", query_string);\n\n    tok = strtok_r(query_string, \"&\", &where);\n\n    while(tok != NULL) {\n      char *_equal;\n\n      if(strncmp(tok, \"csrf\", strlen(\"csrf\")) /* Do not put csrf into the params table */\n\t && (_equal = strchr(tok, '='))) {\n\tchar *decoded_buf;\n        int len;\n\n        _equal[0] = '\\0';\n        _equal = &_equal[1];\n        len = strlen(_equal);\n\n        purifyHTTPParameter(tok), purifyHTTPParameter(_equal);\n\n        // ntop->getTrace()->traceEvent(TRACE_WARNING, \"%s = %s\", tok, _equal);\n\n        if((decoded_buf = (char*)malloc(len+1)) != NULL) {\n\n          Utils::urlDecode(_equal, decoded_buf, len+1);\n\n\t  Utils::purifyHTTPparam(tok, true, false);\n\t  Utils::purifyHTTPparam(decoded_buf, false, false);\n\n\t  /* Now make sure that decoded_buf is not a file path */\n\t  FILE *fd;\n\t  if((decoded_buf[0] == '.')\n\t     && ((fd = fopen(decoded_buf, \"r\"))\n\t\t || (fd = fopen(realpath(decoded_buf, outbuf), \"r\")))) {\n\n\t    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Discarded '%s'='%s' as argument is a valid file path\",\n\t\t\t\t\t tok, decoded_buf);\n\t    decoded_buf[0] = '\\0';\n\t    fclose(fd);\n\t  }\n\n\t  /* ntop->getTrace()->traceEvent(TRACE_WARNING, \"'%s'='%s'\", tok, decoded_buf); */\n\n\t  /* put tok and the decoded buffer in to the table */\n\t  lua_push_str_table_entry(vm, tok, decoded_buf);\n\n          free(decoded_buf);\n        } else\n          ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n      }\n\n      tok = strtok_r(NULL, \"&\", &where);\n    } /* while */\n  }\n\n  if(query_string) free(query_string);\n\n  if(table_name)\n    lua_setglobal(L, table_name);\n  else\n    lua_setglobal(L, (char*)\"_GET\"); /* Default */\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145174,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void Lua::setParamsTable(lua_State* vm, const char* table_name,\n\t\t\t const char* query) const {\n  char outbuf[FILENAME_MAX];\n  char *where;\n  char *tok;\n\n  char *query_string = query ? strdup(query) : NULL;\n\n  lua_newtable(L);\n\n  if (query_string) {\n    // ntop->getTrace()->traceEvent(TRACE_WARNING, \"[HTTP] %s\", query_string);\n\n    tok = strtok_r(query_string, \"&\", &where);\n\n    while(tok != NULL) {\n      char *_equal;\n\n      if(strncmp(tok, \"csrf\", strlen(\"csrf\")) /* Do not put csrf into the params table */\n\t && (_equal = strchr(tok, '='))\n\t && (strlen(_equal) > 1)) {\n\tchar *decoded_buf;\n        int len;\n\n        _equal[0] = '\\0';\n        _equal = &_equal[1];\n        len = strlen(_equal);\n\n        purifyHTTPParameter(tok), purifyHTTPParameter(_equal);\n\n        // ntop->getTrace()->traceEvent(TRACE_WARNING, \"%s = %s\", tok, _equal);\n\n        if((decoded_buf = (char*)malloc(len+1)) != NULL) {\n\n          Utils::urlDecode(_equal, decoded_buf, len+1);\n\n\t  Utils::purifyHTTPparam(tok, true, false);\n\t  Utils::purifyHTTPparam(decoded_buf, false, false);\n\n\t  /* Now make sure that decoded_buf is not a file path */\n\t  FILE *fd;\n\t  if((decoded_buf[0] == '.')\n\t     && ((fd = fopen(decoded_buf, \"r\"))\n\t\t || (fd = fopen(realpath(decoded_buf, outbuf), \"r\")))) {\n\n\t    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Discarded '%s'='%s' as argument is a valid file path\",\n\t\t\t\t\t tok, decoded_buf);\n\t    decoded_buf[0] = '\\0';\n\t    fclose(fd);\n\t  }\n\n\t  /* ntop->getTrace()->traceEvent(TRACE_WARNING, \"'%s'='%s'\", tok, decoded_buf); */\n\n\t  /* put tok and the decoded buffer in to the table */\n\t  lua_push_str_table_entry(vm, tok, decoded_buf);\n\n          free(decoded_buf);\n        } else\n          ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n      }\n\n      tok = strtok_r(NULL, \"&\", &where);\n    } /* while */\n  }\n\n  if(query_string) free(query_string);\n\n  if(table_name)\n    lua_setglobal(L, table_name);\n  else\n    lua_setglobal(L, (char*)\"_GET\"); /* Default */\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145175,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "gs_font_map_glyph_to_unicode(gs_font *font, gs_glyph glyph, int ch, ushort *u, unsigned int length)\n{\n    font_data *pdata = pfont_data(font);\n    const ref *UnicodeDecoding;\n    uchar *unicode_return = (uchar *)u;\n\n    if (r_type(&pdata->GlyphNames2Unicode) == t_dictionary) {\n        int c = gs_font_map_glyph_by_dict(font->memory,\n                                              &pdata->GlyphNames2Unicode, glyph, u, length);\n\n        if (c != 0)\n            return c;\n        if (ch != -1) { /* -1 indicates a CIDFont */\n            /* Its possible that we have a GlyphNames2Unicode dictionary\n             * which contains integers and Unicode values, rather than names\n             * and Unicode values. This happens if the input was PDF, the font\n             * has a ToUnicode Cmap, but no Encoding. In this case we need to\n             * use the character code as an index into the dictionary. Try that\n             * now before we fall back to the UnicodeDecoding.\n             */\n            ref *v, n;\n\n            make_int(&n, ch);\n            if (dict_find(&pdata->GlyphNames2Unicode, &n, &v) > 0) {\n                if (r_has_type(v, t_string)) {\n                    int l = r_size(v);\n\n                    if (l > length)\n                        return l;\n\n                    memcpy(unicode_return, v->value.const_bytes, l * sizeof(short));\n                    return l;\n                }\n                if (r_type(v) == t_integer) {\n                    if (v->value.intval > 65535) {\n                        if (length < 4)\n                            return 4;\n                        unicode_return[0] = v->value.intval >> 24;\n                        unicode_return[1] = (v->value.intval & 0x00FF0000) >> 16;\n                        unicode_return[2] = (v->value.intval & 0x0000FF00) >> 8;\n                        unicode_return[3] = v->value.intval & 0xFF;\n                        return 4;\n                    } else {\n                        if (length < 2)\n                            return 2;\n                        unicode_return[0] = v->value.intval >> 8;\n                        unicode_return[1] = v->value.intval & 0xFF;\n                        return 2;\n                    }\n                }\n            }\n        }\n        /*\n         * Fall through, because test.ps for SF bug #529103 requres\n         * to examine both tables. Due to that the Unicode Decoding resource\n         * can't be a default value for FontInfo.GlyphNames2Unicode .\n         */\n    }\n    if (glyph <= GS_MIN_CID_GLYPH) {\n        UnicodeDecoding = zfont_get_to_unicode_map(font->dir);\n        if (UnicodeDecoding != NULL && r_type(UnicodeDecoding) == t_dictionary)\n            return gs_font_map_glyph_by_dict(font->memory, UnicodeDecoding, glyph, u, length);\n    }\n    return 0; /* No map. */\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145216,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "gs_font_map_glyph_to_unicode(gs_font *font, gs_glyph glyph, int ch, ushort *u, unsigned int length)\n{\n    font_data *pdata = pfont_data(font);\n    const ref *UnicodeDecoding;\n    uchar *unicode_return = (uchar *)u;\n\n    if (r_type(&pdata->GlyphNames2Unicode) == t_dictionary) {\n        int c = gs_font_map_glyph_by_dict(font->memory,\n                                              &pdata->GlyphNames2Unicode, glyph, u, length);\n\n        if (c != 0)\n            return c;\n        if (ch != -1) { /* -1 indicates a CIDFont */\n            /* Its possible that we have a GlyphNames2Unicode dictionary\n             * which contains integers and Unicode values, rather than names\n             * and Unicode values. This happens if the input was PDF, the font\n             * has a ToUnicode Cmap, but no Encoding. In this case we need to\n             * use the character code as an index into the dictionary. Try that\n             * now before we fall back to the UnicodeDecoding.\n             */\n            ref *v, n;\n\n            make_int(&n, ch);\n            if (dict_find(&pdata->GlyphNames2Unicode, &n, &v) > 0) {\n                if (r_has_type(v, t_string)) {\n                    int l = r_size(v);\n\n                    if (l > length)\n                        return l;\n\n                    memcpy(unicode_return, v->value.const_bytes, l * sizeof(short));\n                    return l;\n                }\n                if (r_type(v) == t_integer) {\n                    if (v->value.intval > 65535) {\n                        if (length < 4)\n                            return 4;\n                        unicode_return[0] = v->value.intval >> 24;\n                        unicode_return[1] = (v->value.intval & 0x00FF0000) >> 16;\n                        unicode_return[2] = (v->value.intval & 0x0000FF00) >> 8;\n                        unicode_return[3] = v->value.intval & 0xFF;\n                        return 4;\n                    } else {\n                        if (length < 2)\n                            return 2;\n                        unicode_return[0] = v->value.intval >> 8;\n                        unicode_return[1] = v->value.intval & 0xFF;\n                        return 2;\n                    }\n                }\n            }\n        }\n        /*\n         * Fall through, because test.ps for SF bug #529103 requres\n         * to examine both tables. Due to that the Unicode Decoding resource\n         * can't be a default value for FontInfo.GlyphNames2Unicode .\n         */\n    }\n    if (glyph <= GS_MIN_CID_GLYPH && glyph != GS_NO_GLYPH) {\n        UnicodeDecoding = zfont_get_to_unicode_map(font->dir);\n        if (UnicodeDecoding != NULL && r_type(UnicodeDecoding) == t_dictionary)\n            return gs_font_map_glyph_by_dict(font->memory, UnicodeDecoding, glyph, u, length);\n    }\n    return 0; /* No map. */\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145217,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int line6_init_pcm(struct usb_line6 *line6,\n\t\t   struct line6_pcm_properties *properties)\n{\n\tint i, err;\n\tunsigned ep_read = line6->properties->ep_audio_r;\n\tunsigned ep_write = line6->properties->ep_audio_w;\n\tstruct snd_pcm *pcm;\n\tstruct snd_line6_pcm *line6pcm;\n\n\tif (!(line6->properties->capabilities & LINE6_CAP_PCM))\n\t\treturn 0;\t/* skip PCM initialization and report success */\n\n\terr = snd_line6_new_pcm(line6, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tline6pcm = kzalloc(sizeof(*line6pcm), GFP_KERNEL);\n\tif (!line6pcm)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&line6pcm->state_mutex);\n\tline6pcm->pcm = pcm;\n\tline6pcm->properties = properties;\n\tline6pcm->volume_playback[0] = line6pcm->volume_playback[1] = 255;\n\tline6pcm->volume_monitor = 255;\n\tline6pcm->line6 = line6;\n\n\tline6pcm->max_packet_size_in =\n\t\tusb_maxpacket(line6->usbdev,\n\t\t\tusb_rcvisocpipe(line6->usbdev, ep_read), 0);\n\tline6pcm->max_packet_size_out =\n\t\tusb_maxpacket(line6->usbdev,\n\t\t\tusb_sndisocpipe(line6->usbdev, ep_write), 1);\n\n\tspin_lock_init(&line6pcm->out.lock);\n\tspin_lock_init(&line6pcm->in.lock);\n\tline6pcm->impulse_period = LINE6_IMPULSE_DEFAULT_PERIOD;\n\n\tline6->line6pcm = line6pcm;\n\n\tpcm->private_data = line6pcm;\n\tpcm->private_free = line6_cleanup_pcm;\n\n\terr = line6_create_audio_out_urbs(line6pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = line6_create_audio_in_urbs(line6pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* mixer: */\n\tfor (i = 0; i < ARRAY_SIZE(line6_controls); i++) {\n\t\terr = snd_ctl_add(line6->card,\n\t\t\t\t  snd_ctl_new1(&line6_controls[i], line6pcm));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145218,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int line6_init_pcm(struct usb_line6 *line6,\n\t\t   struct line6_pcm_properties *properties)\n{\n\tint i, err;\n\tunsigned ep_read = line6->properties->ep_audio_r;\n\tunsigned ep_write = line6->properties->ep_audio_w;\n\tstruct snd_pcm *pcm;\n\tstruct snd_line6_pcm *line6pcm;\n\n\tif (!(line6->properties->capabilities & LINE6_CAP_PCM))\n\t\treturn 0;\t/* skip PCM initialization and report success */\n\n\terr = snd_line6_new_pcm(line6, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tline6pcm = kzalloc(sizeof(*line6pcm), GFP_KERNEL);\n\tif (!line6pcm)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&line6pcm->state_mutex);\n\tline6pcm->pcm = pcm;\n\tline6pcm->properties = properties;\n\tline6pcm->volume_playback[0] = line6pcm->volume_playback[1] = 255;\n\tline6pcm->volume_monitor = 255;\n\tline6pcm->line6 = line6;\n\n\tline6pcm->max_packet_size_in =\n\t\tusb_maxpacket(line6->usbdev,\n\t\t\tusb_rcvisocpipe(line6->usbdev, ep_read), 0);\n\tline6pcm->max_packet_size_out =\n\t\tusb_maxpacket(line6->usbdev,\n\t\t\tusb_sndisocpipe(line6->usbdev, ep_write), 1);\n\tif (!line6pcm->max_packet_size_in || !line6pcm->max_packet_size_out) {\n\t\tdev_err(line6pcm->line6->ifcdev,\n\t\t\t\"cannot get proper max packet size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_init(&line6pcm->out.lock);\n\tspin_lock_init(&line6pcm->in.lock);\n\tline6pcm->impulse_period = LINE6_IMPULSE_DEFAULT_PERIOD;\n\n\tline6->line6pcm = line6pcm;\n\n\tpcm->private_data = line6pcm;\n\tpcm->private_free = line6_cleanup_pcm;\n\n\terr = line6_create_audio_out_urbs(line6pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = line6_create_audio_in_urbs(line6pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* mixer: */\n\tfor (i = 0; i < ARRAY_SIZE(line6_controls); i++) {\n\t\terr = snd_ctl_add(line6->card,\n\t\t\t\t  snd_ctl_new1(&line6_controls[i], line6pcm));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145219,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int zr364xx_vidioc_querycap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct zr364xx_camera *cam = video_drvdata(file);\n\n\tstrscpy(cap->driver, DRIVER_DESC, sizeof(cap->driver));\n\tstrscpy(cap->card, cam->udev->product, sizeof(cap->card));\n\tstrscpy(cap->bus_info, dev_name(&cam->udev->dev),\n\t\tsizeof(cap->bus_info));\n\tcap->device_caps = V4L2_CAP_VIDEO_CAPTURE |\n\t\t\t    V4L2_CAP_READWRITE |\n\t\t\t    V4L2_CAP_STREAMING;\n\tcap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145222,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int zr364xx_vidioc_querycap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct zr364xx_camera *cam = video_drvdata(file);\n\n\tstrscpy(cap->driver, DRIVER_DESC, sizeof(cap->driver));\n\tif (cam->udev->product)\n\t\tstrscpy(cap->card, cam->udev->product, sizeof(cap->card));\n\tstrscpy(cap->bus_info, dev_name(&cam->udev->dev),\n\t\tsizeof(cap->bus_info));\n\tcap->device_caps = V4L2_CAP_VIDEO_CAPTURE |\n\t\t\t    V4L2_CAP_READWRITE |\n\t\t\t    V4L2_CAP_STREAMING;\n\tcap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145223,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int sas_get_port_device(struct asd_sas_port *port)\n{\n\tstruct asd_sas_phy *phy;\n\tstruct sas_rphy *rphy;\n\tstruct domain_device *dev;\n\tint rc = -ENODEV;\n\n\tdev = sas_alloc_device();\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&port->phy_list_lock);\n\tif (list_empty(&port->phy_list)) {\n\t\tspin_unlock_irq(&port->phy_list_lock);\n\t\tsas_put_device(dev);\n\t\treturn -ENODEV;\n\t}\n\tphy = container_of(port->phy_list.next, struct asd_sas_phy, port_phy_el);\n\tspin_lock(&phy->frame_rcvd_lock);\n\tmemcpy(dev->frame_rcvd, phy->frame_rcvd, min(sizeof(dev->frame_rcvd),\n\t\t\t\t\t     (size_t)phy->frame_rcvd_size));\n\tspin_unlock(&phy->frame_rcvd_lock);\n\tspin_unlock_irq(&port->phy_list_lock);\n\n\tif (dev->frame_rcvd[0] == 0x34 && port->oob_mode == SATA_OOB_MODE) {\n\t\tstruct dev_to_host_fis *fis =\n\t\t\t(struct dev_to_host_fis *) dev->frame_rcvd;\n\t\tif (fis->interrupt_reason == 1 && fis->lbal == 1 &&\n\t\t    fis->byte_count_low==0x69 && fis->byte_count_high == 0x96\n\t\t    && (fis->device & ~0x10) == 0)\n\t\t\tdev->dev_type = SAS_SATA_PM;\n\t\telse\n\t\t\tdev->dev_type = SAS_SATA_DEV;\n\t\tdev->tproto = SAS_PROTOCOL_SATA;\n\t} else {\n\t\tstruct sas_identify_frame *id =\n\t\t\t(struct sas_identify_frame *) dev->frame_rcvd;\n\t\tdev->dev_type = id->dev_type;\n\t\tdev->iproto = id->initiator_bits;\n\t\tdev->tproto = id->target_bits;\n\t}\n\n\tsas_init_dev(dev);\n\n\tdev->port = port;\n\tswitch (dev->dev_type) {\n\tcase SAS_SATA_DEV:\n\t\trc = sas_ata_init(dev);\n\t\tif (rc) {\n\t\t\trphy = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t/* fall through */\n\tcase SAS_END_DEVICE:\n\t\trphy = sas_end_device_alloc(port->port);\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(port->port,\n\t\t\t\t\t  SAS_EDGE_EXPANDER_DEVICE);\n\t\tbreak;\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(port->port,\n\t\t\t\t\t  SAS_FANOUT_EXPANDER_DEVICE);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"ERROR: Unidentified device type %d\\n\", dev->dev_type);\n\t\trphy = NULL;\n\t\tbreak;\n\t}\n\n\tif (!rphy) {\n\t\tsas_put_device(dev);\n\t\treturn rc;\n\t}\n\n\trphy->identify.phy_identifier = phy->phy->identify.phy_identifier;\n\tmemcpy(dev->sas_addr, port->attached_sas_addr, SAS_ADDR_SIZE);\n\tsas_fill_in_rphy(dev, rphy);\n\tsas_hash_addr(dev->hashed_sas_addr, dev->sas_addr);\n\tport->port_dev = dev;\n\tdev->linkrate = port->linkrate;\n\tdev->min_linkrate = port->linkrate;\n\tdev->max_linkrate = port->linkrate;\n\tdev->pathways = port->num_phys;\n\tmemset(port->disc.fanout_sas_addr, 0, SAS_ADDR_SIZE);\n\tmemset(port->disc.eeds_a, 0, SAS_ADDR_SIZE);\n\tmemset(port->disc.eeds_b, 0, SAS_ADDR_SIZE);\n\tport->disc.max_level = 0;\n\tsas_device_set_phy(dev, port->port);\n\n\tdev->rphy = rphy;\n\tget_device(&dev->rphy->dev);\n\n\tif (dev_is_sata(dev) || dev->dev_type == SAS_END_DEVICE)\n\t\tlist_add_tail(&dev->disco_list_node, &port->disco_list);\n\telse {\n\t\tspin_lock_irq(&port->dev_list_lock);\n\t\tlist_add_tail(&dev->dev_list_node, &port->dev_list);\n\t\tspin_unlock_irq(&port->dev_list_lock);\n\t}\n\n\tspin_lock_irq(&port->phy_list_lock);\n\tlist_for_each_entry(phy, &port->phy_list, port_phy_el)\n\t\tsas_phy_set_target(phy, dev);\n\tspin_unlock_irq(&port->phy_list_lock);\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145242,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int sas_get_port_device(struct asd_sas_port *port)\n{\n\tstruct asd_sas_phy *phy;\n\tstruct sas_rphy *rphy;\n\tstruct domain_device *dev;\n\tint rc = -ENODEV;\n\n\tdev = sas_alloc_device();\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&port->phy_list_lock);\n\tif (list_empty(&port->phy_list)) {\n\t\tspin_unlock_irq(&port->phy_list_lock);\n\t\tsas_put_device(dev);\n\t\treturn -ENODEV;\n\t}\n\tphy = container_of(port->phy_list.next, struct asd_sas_phy, port_phy_el);\n\tspin_lock(&phy->frame_rcvd_lock);\n\tmemcpy(dev->frame_rcvd, phy->frame_rcvd, min(sizeof(dev->frame_rcvd),\n\t\t\t\t\t     (size_t)phy->frame_rcvd_size));\n\tspin_unlock(&phy->frame_rcvd_lock);\n\tspin_unlock_irq(&port->phy_list_lock);\n\n\tif (dev->frame_rcvd[0] == 0x34 && port->oob_mode == SATA_OOB_MODE) {\n\t\tstruct dev_to_host_fis *fis =\n\t\t\t(struct dev_to_host_fis *) dev->frame_rcvd;\n\t\tif (fis->interrupt_reason == 1 && fis->lbal == 1 &&\n\t\t    fis->byte_count_low==0x69 && fis->byte_count_high == 0x96\n\t\t    && (fis->device & ~0x10) == 0)\n\t\t\tdev->dev_type = SAS_SATA_PM;\n\t\telse\n\t\t\tdev->dev_type = SAS_SATA_DEV;\n\t\tdev->tproto = SAS_PROTOCOL_SATA;\n\t} else if (port->oob_mode == SAS_OOB_MODE) {\n\t\tstruct sas_identify_frame *id =\n\t\t\t(struct sas_identify_frame *) dev->frame_rcvd;\n\t\tdev->dev_type = id->dev_type;\n\t\tdev->iproto = id->initiator_bits;\n\t\tdev->tproto = id->target_bits;\n\t} else {\n\t\t/* If the oob mode is OOB_NOT_CONNECTED, the port is\n\t\t * disconnected due to race with PHY down. We cannot\n\t\t * continue to discover this port\n\t\t */\n\t\tsas_put_device(dev);\n\t\tpr_warn(\"Port %016llx is disconnected when discovering\\n\",\n\t\t\tSAS_ADDR(port->attached_sas_addr));\n\t\treturn -ENODEV;\n\t}\n\n\tsas_init_dev(dev);\n\n\tdev->port = port;\n\tswitch (dev->dev_type) {\n\tcase SAS_SATA_DEV:\n\t\trc = sas_ata_init(dev);\n\t\tif (rc) {\n\t\t\trphy = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t/* fall through */\n\tcase SAS_END_DEVICE:\n\t\trphy = sas_end_device_alloc(port->port);\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(port->port,\n\t\t\t\t\t  SAS_EDGE_EXPANDER_DEVICE);\n\t\tbreak;\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(port->port,\n\t\t\t\t\t  SAS_FANOUT_EXPANDER_DEVICE);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"ERROR: Unidentified device type %d\\n\", dev->dev_type);\n\t\trphy = NULL;\n\t\tbreak;\n\t}\n\n\tif (!rphy) {\n\t\tsas_put_device(dev);\n\t\treturn rc;\n\t}\n\n\trphy->identify.phy_identifier = phy->phy->identify.phy_identifier;\n\tmemcpy(dev->sas_addr, port->attached_sas_addr, SAS_ADDR_SIZE);\n\tsas_fill_in_rphy(dev, rphy);\n\tsas_hash_addr(dev->hashed_sas_addr, dev->sas_addr);\n\tport->port_dev = dev;\n\tdev->linkrate = port->linkrate;\n\tdev->min_linkrate = port->linkrate;\n\tdev->max_linkrate = port->linkrate;\n\tdev->pathways = port->num_phys;\n\tmemset(port->disc.fanout_sas_addr, 0, SAS_ADDR_SIZE);\n\tmemset(port->disc.eeds_a, 0, SAS_ADDR_SIZE);\n\tmemset(port->disc.eeds_b, 0, SAS_ADDR_SIZE);\n\tport->disc.max_level = 0;\n\tsas_device_set_phy(dev, port->port);\n\n\tdev->rphy = rphy;\n\tget_device(&dev->rphy->dev);\n\n\tif (dev_is_sata(dev) || dev->dev_type == SAS_END_DEVICE)\n\t\tlist_add_tail(&dev->disco_list_node, &port->disco_list);\n\telse {\n\t\tspin_lock_irq(&port->dev_list_lock);\n\t\tlist_add_tail(&dev->dev_list_node, &port->dev_list);\n\t\tspin_unlock_irq(&port->dev_list_lock);\n\t}\n\n\tspin_lock_irq(&port->phy_list_lock);\n\tlist_for_each_entry(phy, &port->phy_list, port_phy_el)\n\t\tsas_phy_set_target(phy, dev);\n\tspin_unlock_irq(&port->phy_list_lock);\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145243,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int sisusb_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct sisusb_usb_data *sisusb;\n\tint retval = 0, i;\n\n\tdev_info(&dev->dev, \"USB2VGA dongle found at address %d\\n\",\n\t\t\tdev->devnum);\n\n\t/* Allocate memory for our private */\n\tsisusb = kzalloc(sizeof(*sisusb), GFP_KERNEL);\n\tif (!sisusb)\n\t\treturn -ENOMEM;\n\n\tkref_init(&sisusb->kref);\n\n\tmutex_init(&(sisusb->lock));\n\n\t/* Register device */\n\tretval = usb_register_dev(intf, &usb_sisusb_class);\n\tif (retval) {\n\t\tdev_err(&sisusb->sisusb_dev->dev,\n\t\t\t\t\"Failed to get a minor for device %d\\n\",\n\t\t\t\tdev->devnum);\n\t\tretval = -ENODEV;\n\t\tgoto error_1;\n\t}\n\n\tsisusb->sisusb_dev = dev;\n\tsisusb->minor      = intf->minor;\n\tsisusb->vrambase   = SISUSB_PCI_MEMBASE;\n\tsisusb->mmiobase   = SISUSB_PCI_MMIOBASE;\n\tsisusb->mmiosize   = SISUSB_PCI_MMIOSIZE;\n\tsisusb->ioportbase = SISUSB_PCI_IOPORTBASE;\n\t/* Everything else is zero */\n\n\t/* Allocate buffers */\n\tsisusb->ibufsize = SISUSB_IBUF_SIZE;\n\tsisusb->ibuf = kmalloc(SISUSB_IBUF_SIZE, GFP_KERNEL);\n\tif (!sisusb->ibuf) {\n\t\tretval = -ENOMEM;\n\t\tgoto error_2;\n\t}\n\n\tsisusb->numobufs = 0;\n\tsisusb->obufsize = SISUSB_OBUF_SIZE;\n\tfor (i = 0; i < NUMOBUFS; i++) {\n\t\tsisusb->obuf[i] = kmalloc(SISUSB_OBUF_SIZE, GFP_KERNEL);\n\t\tif (!sisusb->obuf[i]) {\n\t\t\tif (i == 0) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto error_3;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tsisusb->numobufs++;\n\t}\n\n\t/* Allocate URBs */\n\tsisusb->sisurbin = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!sisusb->sisurbin) {\n\t\tretval = -ENOMEM;\n\t\tgoto error_3;\n\t}\n\tsisusb->completein = 1;\n\n\tfor (i = 0; i < sisusb->numobufs; i++) {\n\t\tsisusb->sisurbout[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!sisusb->sisurbout[i]) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto error_4;\n\t\t}\n\t\tsisusb->urbout_context[i].sisusb = (void *)sisusb;\n\t\tsisusb->urbout_context[i].urbindex = i;\n\t\tsisusb->urbstatus[i] = 0;\n\t}\n\n\tdev_info(&sisusb->sisusb_dev->dev, \"Allocated %d output buffers\\n\",\n\t\t\tsisusb->numobufs);\n\n#ifdef CONFIG_USB_SISUSBVGA_CON\n\t/* Allocate our SiS_Pr */\n\tsisusb->SiS_Pr = kmalloc(sizeof(struct SiS_Private), GFP_KERNEL);\n\tif (!sisusb->SiS_Pr) {\n\t\tretval = -ENOMEM;\n\t\tgoto error_4;\n\t}\n#endif\n\n\t/* Do remaining init stuff */\n\n\tinit_waitqueue_head(&sisusb->wait_q);\n\n\tusb_set_intfdata(intf, sisusb);\n\n\tusb_get_dev(sisusb->sisusb_dev);\n\n\tsisusb->present = 1;\n\n\tif (dev->speed == USB_SPEED_HIGH || dev->speed >= USB_SPEED_SUPER) {\n\t\tint initscreen = 1;\n#ifdef CONFIG_USB_SISUSBVGA_CON\n\t\tif (sisusb_first_vc > 0 && sisusb_last_vc > 0 &&\n\t\t\t\tsisusb_first_vc <= sisusb_last_vc &&\n\t\t\t\tsisusb_last_vc <= MAX_NR_CONSOLES)\n\t\t\tinitscreen = 0;\n#endif\n\t\tif (sisusb_init_gfxdevice(sisusb, initscreen))\n\t\t\tdev_err(&sisusb->sisusb_dev->dev,\n\t\t\t\t\t\"Failed to early initialize device\\n\");\n\n\t} else\n\t\tdev_info(&sisusb->sisusb_dev->dev,\n\t\t\t\t\"Not attached to USB 2.0 hub, deferring init\\n\");\n\n\tsisusb->ready = 1;\n\n#ifdef SISUSBENDIANTEST\n\tdev_dbg(&sisusb->sisusb_dev->dev, \"*** RWTEST ***\\n\");\n\tsisusb_testreadwrite(sisusb);\n\tdev_dbg(&sisusb->sisusb_dev->dev, \"*** RWTEST END ***\\n\");\n#endif\n\n#ifdef CONFIG_USB_SISUSBVGA_CON\n\tsisusb_console_init(sisusb, sisusb_first_vc, sisusb_last_vc);\n#endif\n\n\treturn 0;\n\nerror_4:\n\tsisusb_free_urbs(sisusb);\nerror_3:\n\tsisusb_free_buffers(sisusb);\nerror_2:\n\tusb_deregister_dev(intf, &usb_sisusb_class);\nerror_1:\n\tkfree(sisusb);\n\treturn retval;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145248,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int sisusb_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct sisusb_usb_data *sisusb;\n\tint retval = 0, i;\n\n\tdev_info(&dev->dev, \"USB2VGA dongle found at address %d\\n\",\n\t\t\tdev->devnum);\n\n\t/* Allocate memory for our private */\n\tsisusb = kzalloc(sizeof(*sisusb), GFP_KERNEL);\n\tif (!sisusb)\n\t\treturn -ENOMEM;\n\n\tkref_init(&sisusb->kref);\n\n\tmutex_init(&(sisusb->lock));\n\n\tsisusb->sisusb_dev = dev;\n\tsisusb->vrambase   = SISUSB_PCI_MEMBASE;\n\tsisusb->mmiobase   = SISUSB_PCI_MMIOBASE;\n\tsisusb->mmiosize   = SISUSB_PCI_MMIOSIZE;\n\tsisusb->ioportbase = SISUSB_PCI_IOPORTBASE;\n\t/* Everything else is zero */\n\n\t/* Register device */\n\tretval = usb_register_dev(intf, &usb_sisusb_class);\n\tif (retval) {\n\t\tdev_err(&sisusb->sisusb_dev->dev,\n\t\t\t\t\"Failed to get a minor for device %d\\n\",\n\t\t\t\tdev->devnum);\n\t\tretval = -ENODEV;\n\t\tgoto error_1;\n\t}\n\n\tsisusb->minor = intf->minor;\n\n\t/* Allocate buffers */\n\tsisusb->ibufsize = SISUSB_IBUF_SIZE;\n\tsisusb->ibuf = kmalloc(SISUSB_IBUF_SIZE, GFP_KERNEL);\n\tif (!sisusb->ibuf) {\n\t\tretval = -ENOMEM;\n\t\tgoto error_2;\n\t}\n\n\tsisusb->numobufs = 0;\n\tsisusb->obufsize = SISUSB_OBUF_SIZE;\n\tfor (i = 0; i < NUMOBUFS; i++) {\n\t\tsisusb->obuf[i] = kmalloc(SISUSB_OBUF_SIZE, GFP_KERNEL);\n\t\tif (!sisusb->obuf[i]) {\n\t\t\tif (i == 0) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto error_3;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tsisusb->numobufs++;\n\t}\n\n\t/* Allocate URBs */\n\tsisusb->sisurbin = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!sisusb->sisurbin) {\n\t\tretval = -ENOMEM;\n\t\tgoto error_3;\n\t}\n\tsisusb->completein = 1;\n\n\tfor (i = 0; i < sisusb->numobufs; i++) {\n\t\tsisusb->sisurbout[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!sisusb->sisurbout[i]) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto error_4;\n\t\t}\n\t\tsisusb->urbout_context[i].sisusb = (void *)sisusb;\n\t\tsisusb->urbout_context[i].urbindex = i;\n\t\tsisusb->urbstatus[i] = 0;\n\t}\n\n\tdev_info(&sisusb->sisusb_dev->dev, \"Allocated %d output buffers\\n\",\n\t\t\tsisusb->numobufs);\n\n#ifdef CONFIG_USB_SISUSBVGA_CON\n\t/* Allocate our SiS_Pr */\n\tsisusb->SiS_Pr = kmalloc(sizeof(struct SiS_Private), GFP_KERNEL);\n\tif (!sisusb->SiS_Pr) {\n\t\tretval = -ENOMEM;\n\t\tgoto error_4;\n\t}\n#endif\n\n\t/* Do remaining init stuff */\n\n\tinit_waitqueue_head(&sisusb->wait_q);\n\n\tusb_set_intfdata(intf, sisusb);\n\n\tusb_get_dev(sisusb->sisusb_dev);\n\n\tsisusb->present = 1;\n\n\tif (dev->speed == USB_SPEED_HIGH || dev->speed >= USB_SPEED_SUPER) {\n\t\tint initscreen = 1;\n#ifdef CONFIG_USB_SISUSBVGA_CON\n\t\tif (sisusb_first_vc > 0 && sisusb_last_vc > 0 &&\n\t\t\t\tsisusb_first_vc <= sisusb_last_vc &&\n\t\t\t\tsisusb_last_vc <= MAX_NR_CONSOLES)\n\t\t\tinitscreen = 0;\n#endif\n\t\tif (sisusb_init_gfxdevice(sisusb, initscreen))\n\t\t\tdev_err(&sisusb->sisusb_dev->dev,\n\t\t\t\t\t\"Failed to early initialize device\\n\");\n\n\t} else\n\t\tdev_info(&sisusb->sisusb_dev->dev,\n\t\t\t\t\"Not attached to USB 2.0 hub, deferring init\\n\");\n\n\tsisusb->ready = 1;\n\n#ifdef SISUSBENDIANTEST\n\tdev_dbg(&sisusb->sisusb_dev->dev, \"*** RWTEST ***\\n\");\n\tsisusb_testreadwrite(sisusb);\n\tdev_dbg(&sisusb->sisusb_dev->dev, \"*** RWTEST END ***\\n\");\n#endif\n\n#ifdef CONFIG_USB_SISUSBVGA_CON\n\tsisusb_console_init(sisusb, sisusb_first_vc, sisusb_last_vc);\n#endif\n\n\treturn 0;\n\nerror_4:\n\tsisusb_free_urbs(sisusb);\nerror_3:\n\tsisusb_free_buffers(sisusb);\nerror_2:\n\tusb_deregister_dev(intf, &usb_sisusb_class);\nerror_1:\n\tkfree(sisusb);\n\treturn retval;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145249,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static apr_status_t modsecurity_request_body_store_memory(modsec_rec *msr,\n    const char *data, apr_size_t length, char **error_msg)\n{\n    *error_msg = NULL;\n\n    /* Would storing this chunk mean going over the limit? */\n    if ((msr->msc_reqbody_spilltodisk)\n        && (msr->msc_reqbody_length + length > (apr_size_t)msr->txcfg->reqbody_inmemory_limit))\n    {\n        msc_data_chunk **chunks;\n        unsigned int disklen = 0;\n        int i;\n\n        msr_log(msr, 4, \"Input filter: Request too large to store in memory, switching to disk.\");\n\n        /* NOTE Must use modsecurity_request_body_store_disk() here\n         *      to prevent data to be sent to the streaming\n         *      processors again.\n         */\n\n        /* Initialise disk storage */\n        msr->msc_reqbody_storage = MSC_REQBODY_DISK;\n        if (modsecurity_request_body_start_init(msr, error_msg) < 0) return -1;\n\n        /* Write the data we keep in memory */\n        chunks = (msc_data_chunk **)msr->msc_reqbody_chunks->elts;\n        for(i = 0; i < msr->msc_reqbody_chunks->nelts; i++) {\n            disklen += chunks[i]->length;\n\n            if (modsecurity_request_body_store_disk(msr, chunks[i]->data, chunks[i]->length, error_msg) < 0) {\n                return -1;\n            }\n\n            free(chunks[i]->data);\n            chunks[i]->data = NULL;\n        }\n\n        /* Clear the memory pool as we no longer need the bits. */\n\n        /* IMP1 But since we only used apr_pool_clear memory might\n         * not be released back to the OS straight away?\n         */\n        msr->msc_reqbody_chunks = NULL;\n        apr_pool_clear(msr->msc_reqbody_mp);\n\n        msr_log(msr, 4, \"Input filter: Wrote %u bytes from memory to disk.\", disklen);\n\n        /* Continue with disk storage from now on */\n        return modsecurity_request_body_store_disk(msr, data, length, error_msg);\n    }\n\n    /* If we're here that means we are not over the\n     * request body in-memory limit yet.\n     */\n    {\n        unsigned long int bucket_offset, bucket_left;\n\n        bucket_offset = 0;\n        bucket_left = length;\n\n        /* Although we store the request body in chunks we don't\n         * want to use the same chunk sizes as the incoming memory\n         * buffers. They are often of very small sizes and that\n         * would make us waste a lot of memory. That's why we\n         * use our own chunks of CHUNK_CAPACITY sizes.\n         */\n\n        /* Loop until we empty this bucket into our chunks. */\n        while(bucket_left > 0) {\n            /* Allocate a new chunk if we have to. */\n            if (msr->msc_reqbody_chunk_current == NULL) {\n                msr->msc_reqbody_chunk_current = (msc_data_chunk *)\n                    apr_pcalloc(msr->msc_reqbody_mp, sizeof(msc_data_chunk));\n                if (msr->msc_reqbody_chunk_current == NULL) {\n                    *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to allocate %lu bytes \"\n                        \"for request body chunk.\", (unsigned long)sizeof(msc_data_chunk));\n                    return -1;\n                }\n\n                msr->msc_reqbody_chunk_current->data = malloc(CHUNK_CAPACITY);\n                if (msr->msc_reqbody_chunk_current->data == NULL) {\n                    *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to allocate %d bytes \"\n                        \"for request body chunk data.\", CHUNK_CAPACITY);\n                    return -1;\n                }\n\n                msr->msc_reqbody_chunk_current->length = 0;\n                msr->msc_reqbody_chunk_current->is_permanent = 1;\n\n                *(const msc_data_chunk **)apr_array_push(msr->msc_reqbody_chunks)\n                    = msr->msc_reqbody_chunk_current;\n            }\n\n            if (bucket_left < (CHUNK_CAPACITY - msr->msc_reqbody_chunk_current->length)) {\n                /* There's enough space in the current chunk. */\n                memcpy(msr->msc_reqbody_chunk_current->data +\n                    msr->msc_reqbody_chunk_current->length, data + bucket_offset, bucket_left);\n                msr->msc_reqbody_chunk_current->length += bucket_left;\n                bucket_left = 0;\n            } else {\n                /* Fill the existing chunk. */\n                unsigned long int copy_length = CHUNK_CAPACITY -\n                    msr->msc_reqbody_chunk_current->length;\n\n                memcpy(msr->msc_reqbody_chunk_current->data +\n                    msr->msc_reqbody_chunk_current->length, data + bucket_offset, copy_length);\n                bucket_offset += copy_length;\n                bucket_left -= copy_length;\n                msr->msc_reqbody_chunk_current->length += copy_length;\n\n                /* We're done with this chunk. Setting the pointer\n                 * to NULL is going to force a new chunk to be allocated\n                 * on the next go.\n                 */\n                msr->msc_reqbody_chunk_current = NULL;\n            }\n        }\n\n        msr->msc_reqbody_length += length;\n    }\n\n    return 1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145268,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static apr_status_t modsecurity_request_body_store_memory(modsec_rec *msr,\n    const char *data, apr_size_t length, char **error_msg)\n{\n    *error_msg = NULL;\n\n    /* Would storing this chunk mean going over the limit? */\n    if ((msr->msc_reqbody_spilltodisk)\n        && (msr->txcfg->reqbody_buffering != REQUEST_BODY_FORCEBUF_ON)\n        && (msr->msc_reqbody_length + length > (apr_size_t)msr->txcfg->reqbody_inmemory_limit))\n    {\n        msc_data_chunk **chunks;\n        unsigned int disklen = 0;\n        int i;\n\n        msr_log(msr, 4, \"Input filter: Request too large to store in memory, switching to disk.\");\n\n        /* NOTE Must use modsecurity_request_body_store_disk() here\n         *      to prevent data to be sent to the streaming\n         *      processors again.\n         */\n\n        /* Initialise disk storage */\n        msr->msc_reqbody_storage = MSC_REQBODY_DISK;\n        if (modsecurity_request_body_start_init(msr, error_msg) < 0) return -1;\n\n        /* Write the data we keep in memory */\n        chunks = (msc_data_chunk **)msr->msc_reqbody_chunks->elts;\n        for(i = 0; i < msr->msc_reqbody_chunks->nelts; i++) {\n            disklen += chunks[i]->length;\n\n            if (modsecurity_request_body_store_disk(msr, chunks[i]->data, chunks[i]->length, error_msg) < 0) {\n                return -1;\n            }\n\n            free(chunks[i]->data);\n            chunks[i]->data = NULL;\n        }\n\n        /* Clear the memory pool as we no longer need the bits. */\n\n        /* IMP1 But since we only used apr_pool_clear memory might\n         * not be released back to the OS straight away?\n         */\n        msr->msc_reqbody_chunks = NULL;\n        apr_pool_clear(msr->msc_reqbody_mp);\n\n        msr_log(msr, 4, \"Input filter: Wrote %u bytes from memory to disk.\", disklen);\n\n        /* Continue with disk storage from now on */\n        return modsecurity_request_body_store_disk(msr, data, length, error_msg);\n    }\n\n    /* If we're here that means we are not over the\n     * request body in-memory limit yet.\n     */\n    {\n        unsigned long int bucket_offset, bucket_left;\n\n        bucket_offset = 0;\n        bucket_left = length;\n\n        /* Although we store the request body in chunks we don't\n         * want to use the same chunk sizes as the incoming memory\n         * buffers. They are often of very small sizes and that\n         * would make us waste a lot of memory. That's why we\n         * use our own chunks of CHUNK_CAPACITY sizes.\n         */\n\n        /* Loop until we empty this bucket into our chunks. */\n        while(bucket_left > 0) {\n            /* Allocate a new chunk if we have to. */\n            if (msr->msc_reqbody_chunk_current == NULL) {\n                msr->msc_reqbody_chunk_current = (msc_data_chunk *)\n                    apr_pcalloc(msr->msc_reqbody_mp, sizeof(msc_data_chunk));\n                if (msr->msc_reqbody_chunk_current == NULL) {\n                    *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to allocate %lu bytes \"\n                        \"for request body chunk.\", (unsigned long)sizeof(msc_data_chunk));\n                    return -1;\n                }\n\n                msr->msc_reqbody_chunk_current->data = malloc(CHUNK_CAPACITY);\n                if (msr->msc_reqbody_chunk_current->data == NULL) {\n                    *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to allocate %d bytes \"\n                        \"for request body chunk data.\", CHUNK_CAPACITY);\n                    return -1;\n                }\n\n                msr->msc_reqbody_chunk_current->length = 0;\n                msr->msc_reqbody_chunk_current->is_permanent = 1;\n\n                *(const msc_data_chunk **)apr_array_push(msr->msc_reqbody_chunks)\n                    = msr->msc_reqbody_chunk_current;\n            }\n\n            if (bucket_left < (CHUNK_CAPACITY - msr->msc_reqbody_chunk_current->length)) {\n                /* There's enough space in the current chunk. */\n                memcpy(msr->msc_reqbody_chunk_current->data +\n                    msr->msc_reqbody_chunk_current->length, data + bucket_offset, bucket_left);\n                msr->msc_reqbody_chunk_current->length += bucket_left;\n                bucket_left = 0;\n            } else {\n                /* Fill the existing chunk. */\n                unsigned long int copy_length = CHUNK_CAPACITY -\n                    msr->msc_reqbody_chunk_current->length;\n\n                memcpy(msr->msc_reqbody_chunk_current->data +\n                    msr->msc_reqbody_chunk_current->length, data + bucket_offset, copy_length);\n                bucket_offset += copy_length;\n                bucket_left -= copy_length;\n                msr->msc_reqbody_chunk_current->length += copy_length;\n\n                /* We're done with this chunk. Setting the pointer\n                 * to NULL is going to force a new chunk to be allocated\n                 * on the next go.\n                 */\n                msr->msc_reqbody_chunk_current = NULL;\n            }\n        }\n\n        msr->msc_reqbody_length += length;\n    }\n\n    return 1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145269,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int RGWPostObj_ObjStore_S3::get_tags()\n{\n  string tags_str;\n  if (part_str(parts, \"tagging\", &tags_str)) {\n    RGWObjTagsXMLParser parser;\n    if (!parser.init()){\n      ldout(s->cct, 0) << \"Couldn't init RGWObjTags XML parser\" << dendl;\n      err_msg = \"Server couldn't process the request\";\n      return -EINVAL; // TODO: This class of errors in rgw code should be a 5XX error\n    }\n    if (!parser.parse(tags_str.c_str(), tags_str.size(), 1)) {\n      ldout(s->cct,0 ) << \"Invalid Tagging XML\" << dendl;\n      err_msg = \"Invalid Tagging XML\";\n      return -EINVAL;\n    }\n\n    RGWObjTagSet_S3 *obj_tags_s3;\n    RGWObjTagging_S3 *tagging;\n\n    tagging = static_cast<RGWObjTagging_S3 *>(parser.find_first(\"Tagging\"));\n    obj_tags_s3 = static_cast<RGWObjTagSet_S3 *>(tagging->find_first(\"TagSet\"));\n    if(!obj_tags_s3){\n      return -ERR_MALFORMED_XML;\n    }\n\n    RGWObjTags obj_tags;\n    int r = obj_tags_s3->rebuild(obj_tags);\n    if (r < 0)\n      return r;\n\n    bufferlist tags_bl;\n    obj_tags.encode(tags_bl);\n    ldout(s->cct, 20) << \"Read \" << obj_tags.count() << \"tags\" << dendl;\n    attrs[RGW_ATTR_TAGS] = tags_bl;\n  }\n\n\n  return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145272,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int RGWPostObj_ObjStore_S3::get_tags()\n{\n  string tags_str;\n  if (part_str(parts, \"tagging\", &tags_str)) {\n    RGWObjTagsXMLParser parser;\n    if (!parser.init()){\n      ldout(s->cct, 0) << \"Couldn't init RGWObjTags XML parser\" << dendl;\n      err_msg = \"Server couldn't process the request\";\n      return -EINVAL; // TODO: This class of errors in rgw code should be a 5XX error\n    }\n    if (!parser.parse(tags_str.c_str(), tags_str.size(), 1)) {\n      ldout(s->cct,0 ) << \"Invalid Tagging XML\" << dendl;\n      err_msg = \"Invalid Tagging XML\";\n      return -EINVAL;\n    }\n\n    RGWObjTagSet_S3 *obj_tags_s3;\n    RGWObjTagging_S3 *tagging;\n\n    tagging = static_cast<RGWObjTagging_S3 *>(parser.find_first(\"Tagging\"));\n    if (!tagging) {\n      return -ERR_MALFORMED_XML;\n    }\n    obj_tags_s3 = static_cast<RGWObjTagSet_S3 *>(tagging->find_first(\"TagSet\"));\n    if(!obj_tags_s3){\n      return -ERR_MALFORMED_XML;\n    }\n\n    RGWObjTags obj_tags;\n    int r = obj_tags_s3->rebuild(obj_tags);\n    if (r < 0)\n      return r;\n\n    bufferlist tags_bl;\n    obj_tags.encode(tags_bl);\n    ldout(s->cct, 20) << \"Read \" << obj_tags.count() << \"tags\" << dendl;\n    attrs[RGW_ATTR_TAGS] = tags_bl;\n  }\n\n\n  return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145273,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void PackLinuxElf64::unpack(OutputFile *fo)\n{\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    upx_uint64_t old_data_off = 0;\n    upx_uint64_t old_data_len = 0;\n    upx_uint64_t old_dtinit = 0;\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);\n        if (e_entry < 0x401180\n        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack(\"p_info corrupted\");\n\n#define MAX_ELF_HDR 1024\n    union {\n        unsigned char buf[MAX_ELF_HDR];\n        //struct { Elf64_Ehdr ehdr; Elf64_Phdr phdr; } e;\n    } u;\n    Elf64_Ehdr *const ehdr = (Elf64_Ehdr *) u.buf;\n    Elf64_Phdr const *phdr = 0;\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > sizeof(u))\n        throwCantUnpack(\"b_info corrupted\");\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len  ||  sizeof(u) < ph.u_len)\n        throwCompressedDataViolation();\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n        // less strict for EM_PPC64 to workaround earlier bug\n    ||  !( ehdr->e_flags==ehdri.e_flags\n        || Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {\n        throwCantUnpack(\"ElfXX_Ehdr corrupted\");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        if (fo) {\n            fo->write(ibuf + ph.u_len, overlay_offset - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te64(&phdr->p_offset);\n                old_data_len = get_te64(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = overlay_offset;\n        total_out = overlay_offset;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te64(&phdr->p_filesz) - overlay_offset;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te64(&phdr->p_filesz);\n                unsigned const offset = get_te64(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD64==get_te32(&phdr->p_type)) {\n            load_va = get_te64(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[6]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));\n    upx_uint64_t hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD64==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te64(&phdr[j].p_offset) +\n                                   get_te64(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {  // the non-first PT_LOAD\n        int n_ptload = 0;\n        unsigned load_off = 0;\n        phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te64(&phdr->p_offset);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n                if (fo) {\n                    fo->seek(get_te64(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n        // Restore DT_INIT.d_val\n        phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (phdr->PT_DYNAMIC==get_te32(&phdr->p_type)) {\n                unsigned const dyn_off = get_te64(&phdr->p_offset);\n                unsigned const dyn_len = get_te64(&phdr->p_filesz);\n                Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +\n                    (dyn_off - load_off));\n                for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                    if (dyn->DT_INIT==get_te32(&dyn->d_tag)) {\n                        if (fo) {\n                            fo->seek(sizeof(upx_uint64_t) + j2 + dyn_off, SEEK_SET);\n                            fo->rewrite(&old_dtinit, sizeof(old_dtinit));\n                            fo->seek(0, SEEK_END);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n#undef MAX_ELF_HDR\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145276,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void PackLinuxElf64::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf64_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack(\"bad e_phoff\");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    upx_uint64_t old_data_off = 0;\n    upx_uint64_t old_data_len = 0;\n    upx_uint64_t old_dtinit = 0;\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);\n        if (e_entry < 0x401180\n        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack(\"p_info corrupted\");\n\n#define MAX_ELF_HDR 1024\n    union {\n        unsigned char buf[MAX_ELF_HDR];\n        //struct { Elf64_Ehdr ehdr; Elf64_Phdr phdr; } e;\n    } u;\n    Elf64_Ehdr *const ehdr = (Elf64_Ehdr *) u.buf;\n    Elf64_Phdr const *phdr = 0;\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > sizeof(u))\n        throwCantUnpack(\"b_info corrupted\");\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len  ||  sizeof(u) < ph.u_len)\n        throwCompressedDataViolation();\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n        // less strict for EM_PPC64 to workaround earlier bug\n    ||  !( ehdr->e_flags==ehdri.e_flags\n        || Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {\n        throwCantUnpack(\"ElfXX_Ehdr corrupted\");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        if (fo) {\n            fo->write(ibuf + ph.u_len, overlay_offset - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te64(&phdr->p_offset);\n                old_data_len = get_te64(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = overlay_offset;\n        total_out = overlay_offset;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te64(&phdr->p_filesz) - overlay_offset;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te64(&phdr->p_filesz);\n                unsigned const offset = get_te64(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD64==get_te32(&phdr->p_type)) {\n            load_va = get_te64(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[6]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));\n    upx_uint64_t hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD64==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te64(&phdr[j].p_offset) +\n                                   get_te64(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {  // the non-first PT_LOAD\n        int n_ptload = 0;\n        unsigned load_off = 0;\n        phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te64(&phdr->p_offset);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n                if (fo) {\n                    fo->seek(get_te64(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n        // Restore DT_INIT.d_val\n        phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (phdr->PT_DYNAMIC==get_te32(&phdr->p_type)) {\n                unsigned const dyn_off = get_te64(&phdr->p_offset);\n                unsigned const dyn_len = get_te64(&phdr->p_filesz);\n                Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +\n                    (dyn_off - load_off));\n                for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                    if (dyn->DT_INIT==get_te32(&dyn->d_tag)) {\n                        if (fo) {\n                            fo->seek(sizeof(upx_uint64_t) + j2 + dyn_off, SEEK_SET);\n                            fo->rewrite(&old_dtinit, sizeof(old_dtinit));\n                            fo->seek(0, SEEK_END);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n#undef MAX_ELF_HDR\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145277,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void PackLinuxElf32::unpack(OutputFile *fo)\n{\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    unsigned old_data_off = 0;\n    unsigned old_data_len = 0;\n    unsigned old_dtinit = 0;\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        if (get_te32(&ehdri.e_entry) < 0x401180\n        &&  Elf32_Ehdr::EM_386 ==get_te16(&ehdri.e_machine)\n        &&  Elf32_Ehdr::ET_EXEC==get_te16(&ehdri.e_type)) {\n            // Beware ET_DYN.e_entry==0x10f0 (or so) does NOT qualify here.\n            /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack(\"p_info corrupted\");\n\n#define MAX_ELF_HDR 512\n    union {\n        unsigned char buf[MAX_ELF_HDR];\n        struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u) == MAX_ELF_HDR)\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *) u.buf;\n    Elf32_Phdr const *phdr = 0;\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > sizeof(u))\n        throwCantUnpack(\"b_info corrupted\");\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Peek at resulting Ehdr and Phdrs for use in controlling unpacking.\n    // Uncompress an extra time, and don't verify or update checksums.\n    if (ibuf.getSize() < ph.c_len  ||  sizeof(u) < ph.u_len)\n        throwCompressedDataViolation();\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n    ||  ehdr->e_flags  !=ehdri.e_flags\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf32_Ehdr::EI_OSABI))\n        throwCantUnpack(\"ElfXX_Ehdr corrupted\");\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        if (fo) {\n            fo->write(ibuf + ph.u_len, overlay_offset - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te32(&phdr->p_offset);\n                old_data_len = get_te32(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = overlay_offset;\n        total_out = overlay_offset;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te32(&phdr->p_filesz) - overlay_offset;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te32(&phdr->p_filesz);\n                unsigned const offset = get_te32(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD32==get_te32(&phdr->p_type)) {\n            load_va = get_te32(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te32(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[4]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n    unsigned hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD32==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te32(&phdr[j].p_offset) +\n                                   get_te32(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {  // the non-first PT_LOAD\n        int n_ptload = 0;\n        unsigned load_off = 0;\n        phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te32(&phdr->p_offset);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n                if (fo) {\n                    fo->seek(get_te32(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n        // Restore DT_INIT.d_val\n        phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (phdr->PT_DYNAMIC==get_te32(&phdr->p_type)) {\n                unsigned const dyn_off = get_te32(&phdr->p_offset);\n                unsigned const dyn_len = get_te32(&phdr->p_filesz);\n                Elf32_Dyn *dyn = (Elf32_Dyn *)((unsigned char *)ibuf +\n                    (dyn_off - load_off));\n                for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                    if (dyn->DT_INIT==get_te32(&dyn->d_tag)) {\n                        if (fo) {\n                            fo->seek(sizeof(unsigned) + j2 + dyn_off, SEEK_SET);\n                            fo->rewrite(&old_dtinit, sizeof(old_dtinit));\n                            fo->seek(0, SEEK_END);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n#undef MAX_ELF_HDR\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145278,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void PackLinuxElf32::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf32_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack(\"bad e_phoff\");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    unsigned old_data_off = 0;\n    unsigned old_data_len = 0;\n    unsigned old_dtinit = 0;\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        if (get_te32(&ehdri.e_entry) < 0x401180\n        &&  Elf32_Ehdr::EM_386 ==get_te16(&ehdri.e_machine)\n        &&  Elf32_Ehdr::ET_EXEC==get_te16(&ehdri.e_type)) {\n            // Beware ET_DYN.e_entry==0x10f0 (or so) does NOT qualify here.\n            /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack(\"p_info corrupted\");\n\n#define MAX_ELF_HDR 512\n    union {\n        unsigned char buf[MAX_ELF_HDR];\n        struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u) == MAX_ELF_HDR)\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *) u.buf;\n    Elf32_Phdr const *phdr = 0;\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > sizeof(u))\n        throwCantUnpack(\"b_info corrupted\");\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Peek at resulting Ehdr and Phdrs for use in controlling unpacking.\n    // Uncompress an extra time, and don't verify or update checksums.\n    if (ibuf.getSize() < ph.c_len  ||  sizeof(u) < ph.u_len)\n        throwCompressedDataViolation();\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n    ||  ehdr->e_flags  !=ehdri.e_flags\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf32_Ehdr::EI_OSABI))\n        throwCantUnpack(\"ElfXX_Ehdr corrupted\");\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        if (fo) {\n            fo->write(ibuf + ph.u_len, overlay_offset - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te32(&phdr->p_offset);\n                old_data_len = get_te32(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = overlay_offset;\n        total_out = overlay_offset;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te32(&phdr->p_filesz) - overlay_offset;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te32(&phdr->p_filesz);\n                unsigned const offset = get_te32(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD32==get_te32(&phdr->p_type)) {\n            load_va = get_te32(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te32(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[4]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n    unsigned hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD32==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te32(&phdr[j].p_offset) +\n                                   get_te32(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {  // the non-first PT_LOAD\n        int n_ptload = 0;\n        unsigned load_off = 0;\n        phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te32(&phdr->p_offset);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n                if (fo) {\n                    fo->seek(get_te32(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n        // Restore DT_INIT.d_val\n        phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (phdr->PT_DYNAMIC==get_te32(&phdr->p_type)) {\n                unsigned const dyn_off = get_te32(&phdr->p_offset);\n                unsigned const dyn_len = get_te32(&phdr->p_filesz);\n                Elf32_Dyn *dyn = (Elf32_Dyn *)((unsigned char *)ibuf +\n                    (dyn_off - load_off));\n                for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                    if (dyn->DT_INIT==get_te32(&dyn->d_tag)) {\n                        if (fo) {\n                            fo->seek(sizeof(unsigned) + j2 + dyn_off, SEEK_SET);\n                            fo->rewrite(&old_dtinit, sizeof(old_dtinit));\n                            fo->seek(0, SEEK_END);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n#undef MAX_ELF_HDR\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145279,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "main (int argc, char **argv)\n{\tSTATE state ;\n\tSF_INFO sfinfo ;\n\tchar pathname [512], ext [32], *cptr ;\n\tint ch, double_split ;\n\n\tif (argc != 2)\n\t{\tif (argc != 1)\n\t\t\tputs (\"\\nError : need a single input file.\\n\") ;\n\t\tusage_exit () ;\n\t\t} ;\n\n\tmemset (&state, 0, sizeof (state)) ;\n\tmemset (&sfinfo, 0, sizeof (sfinfo)) ;\n\n\tif ((state.infile = sf_open (argv [1], SFM_READ, &sfinfo)) == NULL)\n\t{\tprintf (\"\\nError : Not able to open input file '%s'\\n%s\\n\", argv [1], sf_strerror (NULL)) ;\n\t\texit (1) ;\n\t\t} ;\n\n\tif (sfinfo.channels < 2)\n\t{\tprintf (\"\\nError : Input file '%s' only has one channel.\\n\", argv [1]) ;\n\t\texit (1) ;\n\t\t} ;\n\n\tstate.channels = sfinfo.channels ;\n\tsfinfo.channels = 1 ;\n\n\tif (snprintf (pathname, sizeof (pathname), \"%s\", argv [1]) > (int) sizeof (pathname))\n\t{\tprintf (\"\\nError : Length of provided filename '%s' exceeds MAX_PATH (%d).\\n\", argv [1], (int) sizeof (pathname)) ;\n\t\texit (1) ;\n\t\t} ;\n\n\tif ((cptr = strrchr (pathname, '.')) == NULL)\n\t\text [0] = 0 ;\n\telse\n\t{\tsnprintf (ext, sizeof (ext), \"%s\", cptr) ;\n\t\tcptr [0] = 0 ;\n\t\t} ;\n\n\tprintf (\"Input file : %s\\n\", pathname) ;\n\tputs (\"Output files :\") ;\n\n\tfor (ch = 0 ; ch < state.channels ; ch++)\n\t{\tchar filename [520] ;\n\n\t\tsnprintf (filename, sizeof (filename), \"%s_%02d%s\", pathname, ch, ext) ;\n\n\t\tif ((state.outfile [ch] = sf_open (filename, SFM_WRITE, &sfinfo)) == NULL)\n\t\t{\tprintf (\"Not able to open output file '%s'\\n%s\\n\", filename, sf_strerror (NULL)) ;\n\t\t\texit (1) ;\n\t\t\t} ;\n\n\t\tprintf (\"    %s\\n\", filename) ;\n\t\t} ;\n\n\tswitch (sfinfo.format & SF_FORMAT_SUBMASK)\n\t{\tcase SF_FORMAT_FLOAT :\n\t\tcase SF_FORMAT_DOUBLE :\n\t\tcase SF_FORMAT_VORBIS :\n\t\t\tdouble_split = 1 ;\n\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\tdouble_split = 0 ;\n\t\t\tbreak ;\n\t\t} ;\n\n\tif (double_split)\n\t\tdeinterleave_double (&state) ;\n\telse\n\t\tdeinterleave_int (&state) ;\n\n\tsf_close (state.infile) ;\n\tfor (ch = 0 ; ch < MAX_CHANNELS ; ch++)\n\t\tif (state.outfile [ch] != NULL)\n\t\t\tsf_close (state.outfile [ch]) ;\n\n\treturn 0 ;\n} /* main */",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145280,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "main (int argc, char **argv)\n{\tSTATE state ;\n\tSF_INFO sfinfo ;\n\tchar pathname [512], ext [32], *cptr ;\n\tint ch, double_split ;\n\n\tif (argc != 2)\n\t{\tif (argc != 1)\n\t\t\tputs (\"\\nError : need a single input file.\\n\") ;\n\t\tusage_exit () ;\n\t\t} ;\n\n\tmemset (&state, 0, sizeof (state)) ;\n\tmemset (&sfinfo, 0, sizeof (sfinfo)) ;\n\n\tif ((state.infile = sf_open (argv [1], SFM_READ, &sfinfo)) == NULL)\n\t{\tprintf (\"\\nError : Not able to open input file '%s'\\n%s\\n\", argv [1], sf_strerror (NULL)) ;\n\t\texit (1) ;\n\t\t} ;\n\n\tif (sfinfo.channels < 2)\n\t{\tprintf (\"\\nError : Input file '%s' only has one channel.\\n\", argv [1]) ;\n\t\texit (1) ;\n\t\t} ;\n\n\tif (sfinfo.channels > MAX_CHANNELS)\n\t{\tprintf (\"\\nError : Input file '%s' has too many (%d) channels. Limit is %d.\\n\",\n\t\t\targv [1], sfinfo.channels, MAX_CHANNELS) ;\n\t\texit (1) ;\n\t\t} ;\n\n\n\tstate.channels = sfinfo.channels ;\n\tsfinfo.channels = 1 ;\n\n\tif (snprintf (pathname, sizeof (pathname), \"%s\", argv [1]) > (int) sizeof (pathname))\n\t{\tprintf (\"\\nError : Length of provided filename '%s' exceeds MAX_PATH (%d).\\n\", argv [1], (int) sizeof (pathname)) ;\n\t\texit (1) ;\n\t\t} ;\n\n\tif ((cptr = strrchr (pathname, '.')) == NULL)\n\t\text [0] = 0 ;\n\telse\n\t{\tsnprintf (ext, sizeof (ext), \"%s\", cptr) ;\n\t\tcptr [0] = 0 ;\n\t\t} ;\n\n\tprintf (\"Input file : %s\\n\", pathname) ;\n\tputs (\"Output files :\") ;\n\n\tfor (ch = 0 ; ch < state.channels ; ch++)\n\t{\tchar filename [520] ;\n\n\t\tsnprintf (filename, sizeof (filename), \"%s_%02d%s\", pathname, ch, ext) ;\n\n\t\tif ((state.outfile [ch] = sf_open (filename, SFM_WRITE, &sfinfo)) == NULL)\n\t\t{\tprintf (\"Not able to open output file '%s'\\n%s\\n\", filename, sf_strerror (NULL)) ;\n\t\t\texit (1) ;\n\t\t\t} ;\n\n\t\tprintf (\"    %s\\n\", filename) ;\n\t\t} ;\n\n\tswitch (sfinfo.format & SF_FORMAT_SUBMASK)\n\t{\tcase SF_FORMAT_FLOAT :\n\t\tcase SF_FORMAT_DOUBLE :\n\t\tcase SF_FORMAT_VORBIS :\n\t\t\tdouble_split = 1 ;\n\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\tdouble_split = 0 ;\n\t\t\tbreak ;\n\t\t} ;\n\n\tif (double_split)\n\t\tdeinterleave_double (&state) ;\n\telse\n\t\tdeinterleave_int (&state) ;\n\n\tsf_close (state.infile) ;\n\tfor (ch = 0 ; ch < MAX_CHANNELS ; ch++)\n\t\tif (state.outfile [ch] != NULL)\n\t\t\tsf_close (state.outfile [ch]) ;\n\n\treturn 0 ;\n} /* main */",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145281,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "formList_addInput(struct form_list *fl, struct parsed_tag *tag)\n{\n    struct form_item_list *item;\n    char *p;\n    int i;\n\n    /* if not in <form>..</form> environment, just ignore <input> tag */\n    if (fl == NULL)\n\treturn NULL;\n\n    item = New(struct form_item_list);\n    item->type = FORM_UNKNOWN;\n    item->size = -1;\n    item->rows = 0;\n    item->checked = item->init_checked = 0;\n    item->accept = 0;\n    item->name = NULL;\n    item->value = item->init_value = NULL;\n    item->readonly = 0;\n    if (parsedtag_get_value(tag, ATTR_TYPE, &p)) {\n\titem->type = formtype(p);\n\tif (item->size < 0 &&\n\t    (item->type == FORM_INPUT_TEXT ||\n\t     item->type == FORM_INPUT_FILE ||\n\t     item->type == FORM_INPUT_PASSWORD))\n\t    item->size = FORM_I_TEXT_DEFAULT_SIZE;\n    }\n    if (parsedtag_get_value(tag, ATTR_NAME, &p))\n\titem->name = Strnew_charp(p);\n    if (parsedtag_get_value(tag, ATTR_VALUE, &p))\n\titem->value = item->init_value = Strnew_charp(p);\n    item->checked = item->init_checked = parsedtag_exists(tag, ATTR_CHECKED);\n    item->accept = parsedtag_exists(tag, ATTR_ACCEPT);\n    parsedtag_get_value(tag, ATTR_SIZE, &item->size);\n    parsedtag_get_value(tag, ATTR_MAXLENGTH, &item->maxlength);\n    item->readonly = parsedtag_exists(tag, ATTR_READONLY);\n    if (parsedtag_get_value(tag, ATTR_TEXTAREANUMBER, &i)\n\t&& i >= 0 && i < max_textarea)\n\titem->value = item->init_value = textarea_str[i];\n#ifdef MENU_SELECT\n    if (parsedtag_get_value(tag, ATTR_SELECTNUMBER, &i)\n\t&& i >= 0 && i < max_select)\n\titem->select_option = select_option[i].first;\n#endif\t\t\t\t/* MENU_SELECT */\n    if (parsedtag_get_value(tag, ATTR_ROWS, &p))\n\titem->rows = atoi(p);\n    if (item->type == FORM_UNKNOWN) {\n\t/* type attribute is missing. Ignore the tag. */\n\treturn NULL;\n    }\n#ifdef MENU_SELECT\n    if (item->type == FORM_SELECT) {\n\tchooseSelectOption(item, item->select_option);\n\titem->init_selected = item->selected;\n\titem->init_value = item->value;\n\titem->init_label = item->label;\n    }\n#endif\t\t\t\t/* MENU_SELECT */\n    if (item->type == FORM_INPUT_FILE && item->value && item->value->length) {\n\t/* security hole ! */\n\treturn NULL;\n    }\n    item->parent = fl;\n    item->next = NULL;\n    if (fl->item == NULL) {\n\tfl->item = fl->lastitem = item;\n    }\n    else {\n\tfl->lastitem->next = item;\n\tfl->lastitem = item;\n    }\n    if (item->type == FORM_INPUT_HIDDEN)\n\treturn NULL;\n    fl->nitems++;\n    return item;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145297,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int ip_ra_control(struct sock *sk, unsigned char on,\n\t\t  void (*destructor)(struct sock *))\n{\n\tstruct ip_ra_chain *ra, *new_ra;\n\tstruct ip_ra_chain __rcu **rap;\n\tstruct net *net = sock_net(sk);\n\n\tif (sk->sk_type != SOCK_RAW || inet_sk(sk)->inet_num == IPPROTO_RAW)\n\t\treturn -EINVAL;\n\n\tnew_ra = on ? kmalloc(sizeof(*new_ra), GFP_KERNEL) : NULL;\n\n\tmutex_lock(&net->ipv4.ra_mutex);\n\tfor (rap = &net->ipv4.ra_chain;\n\t     (ra = rcu_dereference_protected(*rap,\n\t\t\tlockdep_is_held(&net->ipv4.ra_mutex))) != NULL;\n\t     rap = &ra->next) {\n\t\tif (ra->sk == sk) {\n\t\t\tif (on) {\n\t\t\t\tmutex_unlock(&net->ipv4.ra_mutex);\n\t\t\t\tkfree(new_ra);\n\t\t\t\treturn -EADDRINUSE;\n\t\t\t}\n\t\t\t/* dont let ip_call_ra_chain() use sk again */\n\t\t\tra->sk = NULL;\n\t\t\tRCU_INIT_POINTER(*rap, ra->next);\n\t\t\tmutex_unlock(&net->ipv4.ra_mutex);\n\n\t\t\tif (ra->destructor)\n\t\t\t\tra->destructor(sk);\n\t\t\t/*\n\t\t\t * Delay sock_put(sk) and kfree(ra) after one rcu grace\n\t\t\t * period. This guarantee ip_call_ra_chain() dont need\n\t\t\t * to mess with socket refcounts.\n\t\t\t */\n\t\t\tra->saved_sk = sk;\n\t\t\tcall_rcu(&ra->rcu, ip_ra_destroy_rcu);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!new_ra) {\n\t\tmutex_unlock(&net->ipv4.ra_mutex);\n\t\treturn -ENOBUFS;\n\t}\n\tnew_ra->sk = sk;\n\tnew_ra->destructor = destructor;\n\n\tRCU_INIT_POINTER(new_ra->next, ra);\n\trcu_assign_pointer(*rap, new_ra);\n\tsock_hold(sk);\n\tmutex_unlock(&net->ipv4.ra_mutex);\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145360,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int ip_ra_control(struct sock *sk, unsigned char on,\n\t\t  void (*destructor)(struct sock *))\n{\n\tstruct ip_ra_chain *ra, *new_ra;\n\tstruct ip_ra_chain __rcu **rap;\n\tstruct net *net = sock_net(sk);\n\n\tif (sk->sk_type != SOCK_RAW || inet_sk(sk)->inet_num == IPPROTO_RAW)\n\t\treturn -EINVAL;\n\n\tnew_ra = on ? kmalloc(sizeof(*new_ra), GFP_KERNEL) : NULL;\n\tif (on && !new_ra)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&net->ipv4.ra_mutex);\n\tfor (rap = &net->ipv4.ra_chain;\n\t     (ra = rcu_dereference_protected(*rap,\n\t\t\tlockdep_is_held(&net->ipv4.ra_mutex))) != NULL;\n\t     rap = &ra->next) {\n\t\tif (ra->sk == sk) {\n\t\t\tif (on) {\n\t\t\t\tmutex_unlock(&net->ipv4.ra_mutex);\n\t\t\t\tkfree(new_ra);\n\t\t\t\treturn -EADDRINUSE;\n\t\t\t}\n\t\t\t/* dont let ip_call_ra_chain() use sk again */\n\t\t\tra->sk = NULL;\n\t\t\tRCU_INIT_POINTER(*rap, ra->next);\n\t\t\tmutex_unlock(&net->ipv4.ra_mutex);\n\n\t\t\tif (ra->destructor)\n\t\t\t\tra->destructor(sk);\n\t\t\t/*\n\t\t\t * Delay sock_put(sk) and kfree(ra) after one rcu grace\n\t\t\t * period. This guarantee ip_call_ra_chain() dont need\n\t\t\t * to mess with socket refcounts.\n\t\t\t */\n\t\t\tra->saved_sk = sk;\n\t\t\tcall_rcu(&ra->rcu, ip_ra_destroy_rcu);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!new_ra) {\n\t\tmutex_unlock(&net->ipv4.ra_mutex);\n\t\treturn -ENOBUFS;\n\t}\n\tnew_ra->sk = sk;\n\tnew_ra->destructor = destructor;\n\n\tRCU_INIT_POINTER(new_ra->next, ra);\n\trcu_assign_pointer(*rap, new_ra);\n\tsock_hold(sk);\n\tmutex_unlock(&net->ipv4.ra_mutex);\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145361,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static uint32_t get_cmd(ESPState *s, uint32_t maxlen)\n{\n    uint8_t buf[ESP_CMDFIFO_SZ];\n    uint32_t dmalen, n;\n    int target;\n\n    target = s->wregs[ESP_WBUSID] & BUSID_DID;\n    if (s->dma) {\n        dmalen = MIN(esp_get_tc(s), maxlen);\n        if (dmalen == 0) {\n            return 0;\n        }\n        if (s->dma_memory_read) {\n            s->dma_memory_read(s->dma_opaque, buf, dmalen);\n            fifo8_push_all(&s->cmdfifo, buf, dmalen);\n        } else {\n            if (esp_select(s) < 0) {\n                fifo8_reset(&s->cmdfifo);\n                return -1;\n            }\n            esp_raise_drq(s);\n            fifo8_reset(&s->cmdfifo);\n            return 0;\n        }\n    } else {\n        dmalen = MIN(fifo8_num_used(&s->fifo), maxlen);\n        if (dmalen == 0) {\n            return 0;\n        }\n        n = esp_fifo_pop_buf(&s->fifo, buf, dmalen);\n        if (n >= 3) {\n            buf[0] = buf[2] >> 5;\n        }\n        fifo8_push_all(&s->cmdfifo, buf, n);\n    }\n    trace_esp_get_cmd(dmalen, target);\n\n    if (esp_select(s) < 0) {\n        fifo8_reset(&s->cmdfifo);\n        return -1;\n    }\n    return dmalen;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145458,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static uint32_t get_cmd(ESPState *s, uint32_t maxlen)\n{\n    uint8_t buf[ESP_CMDFIFO_SZ];\n    uint32_t dmalen, n;\n    int target;\n\n    target = s->wregs[ESP_WBUSID] & BUSID_DID;\n    if (s->dma) {\n        dmalen = MIN(esp_get_tc(s), maxlen);\n        if (dmalen == 0) {\n            return 0;\n        }\n        if (s->dma_memory_read) {\n            s->dma_memory_read(s->dma_opaque, buf, dmalen);\n            dmalen = MIN(fifo8_num_free(&s->cmdfifo), dmalen);\n            fifo8_push_all(&s->cmdfifo, buf, dmalen);\n        } else {\n            if (esp_select(s) < 0) {\n                fifo8_reset(&s->cmdfifo);\n                return -1;\n            }\n            esp_raise_drq(s);\n            fifo8_reset(&s->cmdfifo);\n            return 0;\n        }\n    } else {\n        dmalen = MIN(fifo8_num_used(&s->fifo), maxlen);\n        if (dmalen == 0) {\n            return 0;\n        }\n        n = esp_fifo_pop_buf(&s->fifo, buf, dmalen);\n        if (n >= 3) {\n            buf[0] = buf[2] >> 5;\n        }\n        n = MIN(fifo8_num_free(&s->cmdfifo), n);\n        fifo8_push_all(&s->cmdfifo, buf, n);\n    }\n    trace_esp_get_cmd(dmalen, target);\n\n    if (esp_select(s) < 0) {\n        fifo8_reset(&s->cmdfifo);\n        return -1;\n    }\n    return dmalen;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145459,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int stub_send_ret_submit(struct stub_device *sdev)\n{\n\tunsigned long flags;\n\tstruct stub_priv *priv, *tmp;\n\n\tstruct msghdr msg;\n\tsize_t txsize;\n\n\tsize_t total_size = 0;\n\n\twhile ((priv = dequeue_from_priv_tx(sdev)) != NULL) {\n\t\tint ret;\n\t\tstruct urb *urb = priv->urb;\n\t\tstruct usbip_header pdu_header;\n\t\tstruct usbip_iso_packet_descriptor *iso_buffer = NULL;\n\t\tstruct kvec *iov = NULL;\n\t\tint iovnum = 0;\n\n\t\ttxsize = 0;\n\t\tmemset(&pdu_header, 0, sizeof(pdu_header));\n\t\tmemset(&msg, 0, sizeof(msg));\n\n\t\tif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS)\n\t\t\tiovnum = 2 + urb->number_of_packets;\n\t\telse\n\t\t\tiovnum = 2;\n\n\t\tiov = kcalloc(iovnum, sizeof(struct kvec), GFP_KERNEL);\n\n\t\tif (!iov) {\n\t\t\tusbip_event_add(&sdev->ud, SDEV_EVENT_ERROR_MALLOC);\n\t\t\treturn -1;\n\t\t}\n\n\t\tiovnum = 0;\n\n\t\t/* 1. setup usbip_header */\n\t\tsetup_ret_submit_pdu(&pdu_header, urb);\n\t\tusbip_dbg_stub_tx(\"setup txdata seqnum: %d urb: %p\\n\",\n\t\t\t\t  pdu_header.base.seqnum, urb);\n\t\tusbip_header_correct_endian(&pdu_header, 1);\n\n\t\tiov[iovnum].iov_base = &pdu_header;\n\t\tiov[iovnum].iov_len  = sizeof(pdu_header);\n\t\tiovnum++;\n\t\ttxsize += sizeof(pdu_header);\n\n\t\t/* 2. setup transfer buffer */\n\t\tif (usb_pipein(urb->pipe) &&\n\t\t    usb_pipetype(urb->pipe) != PIPE_ISOCHRONOUS &&\n\t\t    urb->actual_length > 0) {\n\t\t\tiov[iovnum].iov_base = urb->transfer_buffer;\n\t\t\tiov[iovnum].iov_len  = urb->actual_length;\n\t\t\tiovnum++;\n\t\t\ttxsize += urb->actual_length;\n\t\t} else if (usb_pipein(urb->pipe) &&\n\t\t\t   usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {\n\t\t\t/*\n\t\t\t * For isochronous packets: actual length is the sum of\n\t\t\t * the actual length of the individual, packets, but as\n\t\t\t * the packet offsets are not changed there will be\n\t\t\t * padding between the packets. To optimally use the\n\t\t\t * bandwidth the padding is not transmitted.\n\t\t\t */\n\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\t\t\tiov[iovnum].iov_base = urb->transfer_buffer +\n\t\t\t\t\turb->iso_frame_desc[i].offset;\n\t\t\t\tiov[iovnum].iov_len =\n\t\t\t\t\turb->iso_frame_desc[i].actual_length;\n\t\t\t\tiovnum++;\n\t\t\t\ttxsize += urb->iso_frame_desc[i].actual_length;\n\t\t\t}\n\n\t\t\tif (txsize != sizeof(pdu_header) + urb->actual_length) {\n\t\t\t\tdev_err(&sdev->udev->dev,\n\t\t\t\t\t\"actual length of urb %d does not match iso packet sizes %zu\\n\",\n\t\t\t\t\turb->actual_length,\n\t\t\t\t\ttxsize-sizeof(pdu_header));\n\t\t\t\tkfree(iov);\n\t\t\t\tusbip_event_add(&sdev->ud,\n\t\t\t\t\t\tSDEV_EVENT_ERROR_TCP);\n\t\t\t   return -1;\n\t\t\t}\n\t\t}\n\n\t\t/* 3. setup iso_packet_descriptor */\n\t\tif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {\n\t\t\tssize_t len = 0;\n\n\t\t\tiso_buffer = usbip_alloc_iso_desc_pdu(urb, &len);\n\t\t\tif (!iso_buffer) {\n\t\t\t\tusbip_event_add(&sdev->ud,\n\t\t\t\t\t\tSDEV_EVENT_ERROR_MALLOC);\n\t\t\t\tkfree(iov);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tiov[iovnum].iov_base = iso_buffer;\n\t\t\tiov[iovnum].iov_len  = len;\n\t\t\ttxsize += len;\n\t\t\tiovnum++;\n\t\t}\n\n\t\tret = kernel_sendmsg(sdev->ud.tcp_socket, &msg,\n\t\t\t\t\t\tiov,  iovnum, txsize);\n\t\tif (ret != txsize) {\n\t\t\tdev_err(&sdev->udev->dev,\n\t\t\t\t\"sendmsg failed!, retval %d for %zd\\n\",\n\t\t\t\tret, txsize);\n\t\t\tkfree(iov);\n\t\t\tkfree(iso_buffer);\n\t\t\tusbip_event_add(&sdev->ud, SDEV_EVENT_ERROR_TCP);\n\t\t\treturn -1;\n\t\t}\n\n\t\tkfree(iov);\n\t\tkfree(iso_buffer);\n\n\t\ttotal_size += txsize;\n\t}\n\n\tspin_lock_irqsave(&sdev->priv_lock, flags);\n\tlist_for_each_entry_safe(priv, tmp, &sdev->priv_free, list) {\n\t\tstub_free_priv_and_urb(priv);\n\t}\n\tspin_unlock_irqrestore(&sdev->priv_lock, flags);\n\n\treturn total_size;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145486,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int stub_send_ret_submit(struct stub_device *sdev)\n{\n\tunsigned long flags;\n\tstruct stub_priv *priv, *tmp;\n\n\tstruct msghdr msg;\n\tsize_t txsize;\n\n\tsize_t total_size = 0;\n\n\twhile ((priv = dequeue_from_priv_tx(sdev)) != NULL) {\n\t\tint ret;\n\t\tstruct urb *urb = priv->urb;\n\t\tstruct usbip_header pdu_header;\n\t\tstruct usbip_iso_packet_descriptor *iso_buffer = NULL;\n\t\tstruct kvec *iov = NULL;\n\t\tint iovnum = 0;\n\n\t\ttxsize = 0;\n\t\tmemset(&pdu_header, 0, sizeof(pdu_header));\n\t\tmemset(&msg, 0, sizeof(msg));\n\n\t\tif (urb->actual_length > 0 && !urb->transfer_buffer) {\n\t\t\tdev_err(&sdev->udev->dev,\n\t\t\t\t\"urb: actual_length %d transfer_buffer null\\n\",\n\t\t\t\turb->actual_length);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS)\n\t\t\tiovnum = 2 + urb->number_of_packets;\n\t\telse\n\t\t\tiovnum = 2;\n\n\t\tiov = kcalloc(iovnum, sizeof(struct kvec), GFP_KERNEL);\n\n\t\tif (!iov) {\n\t\t\tusbip_event_add(&sdev->ud, SDEV_EVENT_ERROR_MALLOC);\n\t\t\treturn -1;\n\t\t}\n\n\t\tiovnum = 0;\n\n\t\t/* 1. setup usbip_header */\n\t\tsetup_ret_submit_pdu(&pdu_header, urb);\n\t\tusbip_dbg_stub_tx(\"setup txdata seqnum: %d urb: %p\\n\",\n\t\t\t\t  pdu_header.base.seqnum, urb);\n\t\tusbip_header_correct_endian(&pdu_header, 1);\n\n\t\tiov[iovnum].iov_base = &pdu_header;\n\t\tiov[iovnum].iov_len  = sizeof(pdu_header);\n\t\tiovnum++;\n\t\ttxsize += sizeof(pdu_header);\n\n\t\t/* 2. setup transfer buffer */\n\t\tif (usb_pipein(urb->pipe) &&\n\t\t    usb_pipetype(urb->pipe) != PIPE_ISOCHRONOUS &&\n\t\t    urb->actual_length > 0) {\n\t\t\tiov[iovnum].iov_base = urb->transfer_buffer;\n\t\t\tiov[iovnum].iov_len  = urb->actual_length;\n\t\t\tiovnum++;\n\t\t\ttxsize += urb->actual_length;\n\t\t} else if (usb_pipein(urb->pipe) &&\n\t\t\t   usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {\n\t\t\t/*\n\t\t\t * For isochronous packets: actual length is the sum of\n\t\t\t * the actual length of the individual, packets, but as\n\t\t\t * the packet offsets are not changed there will be\n\t\t\t * padding between the packets. To optimally use the\n\t\t\t * bandwidth the padding is not transmitted.\n\t\t\t */\n\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\t\t\tiov[iovnum].iov_base = urb->transfer_buffer +\n\t\t\t\t\turb->iso_frame_desc[i].offset;\n\t\t\t\tiov[iovnum].iov_len =\n\t\t\t\t\turb->iso_frame_desc[i].actual_length;\n\t\t\t\tiovnum++;\n\t\t\t\ttxsize += urb->iso_frame_desc[i].actual_length;\n\t\t\t}\n\n\t\t\tif (txsize != sizeof(pdu_header) + urb->actual_length) {\n\t\t\t\tdev_err(&sdev->udev->dev,\n\t\t\t\t\t\"actual length of urb %d does not match iso packet sizes %zu\\n\",\n\t\t\t\t\turb->actual_length,\n\t\t\t\t\ttxsize-sizeof(pdu_header));\n\t\t\t\tkfree(iov);\n\t\t\t\tusbip_event_add(&sdev->ud,\n\t\t\t\t\t\tSDEV_EVENT_ERROR_TCP);\n\t\t\t   return -1;\n\t\t\t}\n\t\t}\n\n\t\t/* 3. setup iso_packet_descriptor */\n\t\tif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {\n\t\t\tssize_t len = 0;\n\n\t\t\tiso_buffer = usbip_alloc_iso_desc_pdu(urb, &len);\n\t\t\tif (!iso_buffer) {\n\t\t\t\tusbip_event_add(&sdev->ud,\n\t\t\t\t\t\tSDEV_EVENT_ERROR_MALLOC);\n\t\t\t\tkfree(iov);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tiov[iovnum].iov_base = iso_buffer;\n\t\t\tiov[iovnum].iov_len  = len;\n\t\t\ttxsize += len;\n\t\t\tiovnum++;\n\t\t}\n\n\t\tret = kernel_sendmsg(sdev->ud.tcp_socket, &msg,\n\t\t\t\t\t\tiov,  iovnum, txsize);\n\t\tif (ret != txsize) {\n\t\t\tdev_err(&sdev->udev->dev,\n\t\t\t\t\"sendmsg failed!, retval %d for %zd\\n\",\n\t\t\t\tret, txsize);\n\t\t\tkfree(iov);\n\t\t\tkfree(iso_buffer);\n\t\t\tusbip_event_add(&sdev->ud, SDEV_EVENT_ERROR_TCP);\n\t\t\treturn -1;\n\t\t}\n\n\t\tkfree(iov);\n\t\tkfree(iso_buffer);\n\n\t\ttotal_size += txsize;\n\t}\n\n\tspin_lock_irqsave(&sdev->priv_lock, flags);\n\tlist_for_each_entry_safe(priv, tmp, &sdev->priv_free, list) {\n\t\tstub_free_priv_and_urb(priv);\n\t}\n\tspin_unlock_irqrestore(&sdev->priv_lock, flags);\n\n\treturn total_size;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145487,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "jbig2_decode_symbol_dict(Jbig2Ctx *ctx,\n                         Jbig2Segment *segment,\n                         const Jbig2SymbolDictParams *params, const byte *data, size_t size, Jbig2ArithCx *GB_stats, Jbig2ArithCx *GR_stats)\n{\n    Jbig2SymbolDict *SDNEWSYMS = NULL;\n    Jbig2SymbolDict *SDEXSYMS = NULL;\n    uint32_t HCHEIGHT;\n    uint32_t NSYMSDECODED;\n    uint32_t SYMWIDTH, TOTWIDTH;\n    uint32_t HCFIRSTSYM;\n    uint32_t *SDNEWSYMWIDTHS = NULL;\n    int SBSYMCODELEN = 0;\n    Jbig2WordStream *ws = NULL;\n    Jbig2HuffmanState *hs = NULL;\n    Jbig2HuffmanTable *SDHUFFRDX = NULL;\n    Jbig2HuffmanTable *SBHUFFRSIZE = NULL;\n    Jbig2ArithState *as = NULL;\n    Jbig2ArithIntCtx *IADH = NULL;\n    Jbig2ArithIntCtx *IADW = NULL;\n    Jbig2ArithIntCtx *IAEX = NULL;\n    Jbig2ArithIntCtx *IAAI = NULL;\n    Jbig2ArithIaidCtx *IAID = NULL;\n    Jbig2ArithIntCtx *IARDX = NULL;\n    Jbig2ArithIntCtx *IARDY = NULL;\n    int code = 0;\n    Jbig2SymbolDict **refagg_dicts = NULL;\n    int n_refagg_dicts = 1;\n\n    Jbig2TextRegionParams *tparams = NULL;\n\n    /* 6.5.5 (3) */\n    HCHEIGHT = 0;\n    NSYMSDECODED = 0;\n\n    ws = jbig2_word_stream_buf_new(ctx, data, size);\n    if (ws == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate ws in jbig2_decode_symbol_dict\");\n        return NULL;\n    }\n\n    as = jbig2_arith_new(ctx, ws);\n    if (as == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate as in jbig2_decode_symbol_dict\");\n        jbig2_word_stream_buf_free(ctx, ws);\n        return NULL;\n    }\n\n    if (!params->SDHUFF) {\n        IADH = jbig2_arith_int_ctx_new(ctx);\n        IADW = jbig2_arith_int_ctx_new(ctx);\n        IAEX = jbig2_arith_int_ctx_new(ctx);\n        IAAI = jbig2_arith_int_ctx_new(ctx);\n        if ((IADH == NULL) || (IADW == NULL) || (IAEX == NULL) || (IAAI == NULL)) {\n            jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate storage for symbol bitmap\");\n            goto cleanup1;\n        }\n        if (params->SDREFAGG) {\n            int64_t tmp = params->SDNUMINSYMS + params->SDNUMNEWSYMS;\n\n            for (SBSYMCODELEN = 0; ((int64_t) 1 << SBSYMCODELEN) < tmp; SBSYMCODELEN++);\n            IAID = jbig2_arith_iaid_ctx_new(ctx, SBSYMCODELEN);\n            IARDX = jbig2_arith_int_ctx_new(ctx);\n            IARDY = jbig2_arith_int_ctx_new(ctx);\n            if ((IAID == NULL) || (IARDX == NULL) || (IARDY == NULL)) {\n                jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate storage for symbol bitmap\");\n                goto cleanup2;\n            }\n        }\n    } else {\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"huffman coded symbol dictionary\");\n        hs = jbig2_huffman_new(ctx, ws);\n        SDHUFFRDX = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);\n        SBHUFFRSIZE = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_A);\n        if ((hs == NULL) || (SDHUFFRDX == NULL) || (SBHUFFRSIZE == NULL)) {\n            jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate storage for symbol bitmap\");\n            goto cleanup2;\n        }\n        if (!params->SDREFAGG) {\n            SDNEWSYMWIDTHS = jbig2_new(ctx, uint32_t, params->SDNUMNEWSYMS);\n            if (SDNEWSYMWIDTHS == NULL) {\n                jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"could not allocate storage for (%u) symbol widths\", params->SDNUMNEWSYMS);\n                goto cleanup2;\n            }\n        }\n    }\n\n    SDNEWSYMS = jbig2_sd_new(ctx, params->SDNUMNEWSYMS);\n    if (SDNEWSYMS == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"could not allocate storage for (%u) new symbols\", params->SDNUMNEWSYMS);\n        goto cleanup2;\n    }\n\n    /* 6.5.5 (4a) */\n    while (NSYMSDECODED < params->SDNUMNEWSYMS) {\n        int32_t HCDH, DW;\n\n        /* 6.5.6 */\n        if (params->SDHUFF) {\n            HCDH = jbig2_huffman_get(hs, params->SDHUFFDH, &code);\n        } else {\n            code = jbig2_arith_int_decode(IADH, as, &HCDH);\n        }\n\n        if (code != 0) {\n            jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"error or OOB decoding height class delta (%d)\\n\", code);\n        }\n\n        if (!params->SDHUFF && jbig2_arith_has_reached_marker(as)) {\n            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"prevent DOS while decoding height classes\");\n            goto cleanup2;\n        }\n\n        /* 6.5.5 (4b) */\n        HCHEIGHT = HCHEIGHT + HCDH;\n        SYMWIDTH = 0;\n        TOTWIDTH = 0;\n        HCFIRSTSYM = NSYMSDECODED;\n\n        if ((int32_t) HCHEIGHT < 0) {\n            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Invalid HCHEIGHT value\");\n            goto cleanup2;\n        }\n#ifdef JBIG2_DEBUG\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"HCHEIGHT = %d\", HCHEIGHT);\n#endif\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"decoding height class %d with %d syms decoded\", HCHEIGHT, NSYMSDECODED);\n\n        for (;;) {\n            /* 6.5.7 */\n            if (params->SDHUFF) {\n                DW = jbig2_huffman_get(hs, params->SDHUFFDW, &code);\n            } else {\n                code = jbig2_arith_int_decode(IADW, as, &DW);\n            }\n            if (code < 0)\n                goto cleanup4;\n\n            /* 6.5.5 (4c.i) */\n            if (code == 1) {\n                jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \" OOB signals end of height class %d\", HCHEIGHT);\n                break;\n            }\n\n            /* check for broken symbol table */\n            if (NSYMSDECODED >= params->SDNUMNEWSYMS) {\n                jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"No OOB signalling end of height class %d\", HCHEIGHT);\n                goto cleanup4;\n            }\n\n            SYMWIDTH = SYMWIDTH + DW;\n            TOTWIDTH = TOTWIDTH + SYMWIDTH;\n            if ((int32_t) SYMWIDTH < 0) {\n                code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Invalid SYMWIDTH value (%d) at symbol %d\", SYMWIDTH, NSYMSDECODED + 1);\n                goto cleanup4;\n            }\n#ifdef JBIG2_DEBUG\n            jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"SYMWIDTH = %d TOTWIDTH = %d\", SYMWIDTH, TOTWIDTH);\n#endif\n            /* 6.5.5 (4c.ii) */\n            if (!params->SDHUFF || params->SDREFAGG) {\n#ifdef JBIG2_DEBUG\n                jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"SDHUFF = %d; SDREFAGG = %d\", params->SDHUFF, params->SDREFAGG);\n#endif\n                /* 6.5.8 */\n                if (!params->SDREFAGG) {\n                    Jbig2GenericRegionParams region_params;\n                    int sdat_bytes;\n                    Jbig2Image *image;\n\n                    /* Table 16 */\n                    region_params.MMR = 0;\n                    region_params.GBTEMPLATE = params->SDTEMPLATE;\n                    region_params.TPGDON = 0;\n                    region_params.USESKIP = 0;\n                    sdat_bytes = params->SDTEMPLATE == 0 ? 8 : 2;\n                    memcpy(region_params.gbat, params->sdat, sdat_bytes);\n\n                    image = jbig2_image_new(ctx, SYMWIDTH, HCHEIGHT);\n                    if (image == NULL) {\n                        code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate image in jbig2_decode_symbol_dict\");\n                        goto cleanup4;\n                    }\n\n                    code = jbig2_decode_generic_region(ctx, segment, &region_params, as, image, GB_stats);\n                    if (code < 0) {\n                        jbig2_image_release(ctx, image);\n                        goto cleanup4;\n                    }\n\n                    SDNEWSYMS->glyphs[NSYMSDECODED] = image;\n                } else {\n                    /* 6.5.8.2 refinement/aggregate symbol */\n                    uint32_t REFAGGNINST;\n\n                    if (params->SDHUFF) {\n                        REFAGGNINST = jbig2_huffman_get(hs, params->SDHUFFAGGINST, &code);\n                    } else {\n                        code = jbig2_arith_int_decode(IAAI, as, (int32_t *) & REFAGGNINST);\n                    }\n                    if (code || (int32_t) REFAGGNINST <= 0) {\n                        code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"invalid number of symbols or OOB in aggregate glyph\");\n                        goto cleanup4;\n                    }\n\n                    jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"aggregate symbol coding (%d instances)\", REFAGGNINST);\n\n                    if (REFAGGNINST > 1) {\n                        Jbig2Image *image;\n                        uint32_t i;\n\n                        if (tparams == NULL) {\n                            /* First time through, we need to initialise the */\n                            /* various tables for Huffman or adaptive encoding */\n                            /* as well as the text region parameters structure */\n                            refagg_dicts = jbig2_new(ctx, Jbig2SymbolDict *, n_refagg_dicts);\n                            if (refagg_dicts == NULL) {\n                                code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory allocating dictionary array\");\n                                goto cleanup4;\n                            }\n                            refagg_dicts[0] = jbig2_sd_new(ctx, params->SDNUMINSYMS + params->SDNUMNEWSYMS);\n                            if (refagg_dicts[0] == NULL) {\n                                code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory allocating symbol dictionary\");\n                                goto cleanup4;\n                            }\n                            for (i = 0; i < params->SDNUMINSYMS; i++) {\n                                refagg_dicts[0]->glyphs[i] = jbig2_image_clone(ctx, params->SDINSYMS->glyphs[i]);\n                            }\n\n                            tparams = jbig2_new(ctx, Jbig2TextRegionParams, 1);\n                            if (tparams == NULL) {\n                                code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory creating text region params\");\n                                goto cleanup4;\n                            }\n                            if (!params->SDHUFF) {\n                                /* Values from Table 17, section 6.5.8.2 (2) */\n                                tparams->IADT = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IAFS = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IADS = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IAIT = jbig2_arith_int_ctx_new(ctx);\n                                /* Table 31 */\n                                for (SBSYMCODELEN = 0; (1 << SBSYMCODELEN) < (int)(params->SDNUMINSYMS + params->SDNUMNEWSYMS); SBSYMCODELEN++);\n                                tparams->IAID = jbig2_arith_iaid_ctx_new(ctx, SBSYMCODELEN);\n                                tparams->IARI = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IARDW = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IARDH = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IARDX = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IARDY = jbig2_arith_int_ctx_new(ctx);\n                            } else {\n                                tparams->SBHUFFFS = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_F);    /* Table B.6 */\n                                tparams->SBHUFFDS = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_H);    /* Table B.8 */\n                                tparams->SBHUFFDT = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_K);    /* Table B.11 */\n                                tparams->SBHUFFRDW = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);   /* Table B.15 */\n                                tparams->SBHUFFRDH = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);   /* Table B.15 */\n                                tparams->SBHUFFRDX = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);   /* Table B.15 */\n                                tparams->SBHUFFRDY = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);   /* Table B.15 */\n                            }\n                            tparams->SBHUFF = params->SDHUFF;\n                            tparams->SBREFINE = 1;\n                            tparams->SBSTRIPS = 1;\n                            tparams->SBDEFPIXEL = 0;\n                            tparams->SBCOMBOP = JBIG2_COMPOSE_OR;\n                            tparams->TRANSPOSED = 0;\n                            tparams->REFCORNER = JBIG2_CORNER_TOPLEFT;\n                            tparams->SBDSOFFSET = 0;\n                            tparams->SBRTEMPLATE = params->SDRTEMPLATE;\n                        }\n                        tparams->SBNUMINSTANCES = REFAGGNINST;\n\n                        image = jbig2_image_new(ctx, SYMWIDTH, HCHEIGHT);\n                        if (image == NULL) {\n                            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory creating symbol image\");\n                            goto cleanup4;\n                        }\n\n                        /* multiple symbols are handled as a text region */\n                        jbig2_decode_text_region(ctx, segment, tparams, (const Jbig2SymbolDict * const *)refagg_dicts,\n                                                 n_refagg_dicts, image, data, size, GR_stats, as, ws);\n\n                        SDNEWSYMS->glyphs[NSYMSDECODED] = image;\n                        refagg_dicts[0]->glyphs[params->SDNUMINSYMS + NSYMSDECODED] = jbig2_image_clone(ctx, SDNEWSYMS->glyphs[NSYMSDECODED]);\n                    } else {\n                        /* 6.5.8.2.2 */\n                        /* bool SBHUFF = params->SDHUFF; */\n                        Jbig2RefinementRegionParams rparams;\n                        Jbig2Image *image;\n                        uint32_t ID;\n                        int32_t RDX, RDY;\n                        int BMSIZE = 0;\n                        uint32_t ninsyms = params->SDNUMINSYMS;\n                        int code1 = 0;\n                        int code2 = 0;\n                        int code3 = 0;\n                        int code4 = 0;\n\n                        /* 6.5.8.2.2 (2, 3, 4, 5) */\n                        if (params->SDHUFF) {\n                            ID = jbig2_huffman_get_bits(hs, SBSYMCODELEN, &code4);\n                            RDX = jbig2_huffman_get(hs, SDHUFFRDX, &code1);\n                            RDY = jbig2_huffman_get(hs, SDHUFFRDX, &code2);\n                            BMSIZE = jbig2_huffman_get(hs, SBHUFFRSIZE, &code3);\n                            jbig2_huffman_skip(hs);\n                        } else {\n                            code1 = jbig2_arith_iaid_decode(IAID, as, (int32_t *) & ID);\n                            code2 = jbig2_arith_int_decode(IARDX, as, &RDX);\n                            code3 = jbig2_arith_int_decode(IARDY, as, &RDY);\n                        }\n\n                        if ((code1 < 0) || (code2 < 0) || (code3 < 0) || (code4 < 0)) {\n                            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to decode data\");\n                            goto cleanup4;\n                        }\n\n                        if (ID >= ninsyms + NSYMSDECODED) {\n                            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"refinement references unknown symbol %d\", ID);\n                            goto cleanup4;\n                        }\n\n                        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number,\n                                    \"symbol is a refinement of id %d with the \" \"refinement applied at (%d,%d)\", ID, RDX, RDY);\n\n                        image = jbig2_image_new(ctx, SYMWIDTH, HCHEIGHT);\n                        if (image == NULL) {\n                            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory creating symbol image\");\n                            goto cleanup4;\n                        }\n\n                        /* Table 18 */\n                        rparams.GRTEMPLATE = params->SDRTEMPLATE;\n                        rparams.reference = (ID < ninsyms) ? params->SDINSYMS->glyphs[ID] : SDNEWSYMS->glyphs[ID - ninsyms];\n                        /* SumatraPDF: fail on missing glyphs */\n                        if (rparams.reference == NULL) {\n                            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"missing glyph %d/%d!\", ID, ninsyms);\n                            jbig2_image_release(ctx, image);\n                            goto cleanup4;\n                        }\n                        rparams.DX = RDX;\n                        rparams.DY = RDY;\n                        rparams.TPGRON = 0;\n                        memcpy(rparams.grat, params->sdrat, 4);\n                        code = jbig2_decode_refinement_region(ctx, segment, &rparams, as, image, GR_stats);\n                        if (code < 0)\n                            goto cleanup4;\n\n                        SDNEWSYMS->glyphs[NSYMSDECODED] = image;\n\n                        /* 6.5.8.2.2 (7) */\n                        if (params->SDHUFF) {\n                            if (BMSIZE == 0)\n                                BMSIZE = image->height * image->stride;\n                            jbig2_huffman_advance(hs, BMSIZE);\n                        }\n                    }\n                }\n\n#ifdef OUTPUT_PBM\n                {\n                    char name[64];\n                    FILE *out;\n\n                    snprintf(name, 64, \"sd.%04d.%04d.pbm\", segment->number, NSYMSDECODED);\n                    out = fopen(name, \"wb\");\n                    jbig2_image_write_pbm(SDNEWSYMS->glyphs[NSYMSDECODED], out);\n                    jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"writing out glyph as '%s' ...\", name);\n                    fclose(out);\n                }\n#endif\n\n            }\n\n            /* 6.5.5 (4c.iii) */\n            if (params->SDHUFF && !params->SDREFAGG) {\n                SDNEWSYMWIDTHS[NSYMSDECODED] = SYMWIDTH;\n            }\n\n            /* 6.5.5 (4c.iv) */\n            NSYMSDECODED = NSYMSDECODED + 1;\n\n            jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"decoded symbol %u of %u (%ux%u)\", NSYMSDECODED, params->SDNUMNEWSYMS, SYMWIDTH, HCHEIGHT);\n\n        }                       /* end height class decode loop */\n\n        /* 6.5.5 (4d) */\n        if (params->SDHUFF && !params->SDREFAGG) {\n            /* 6.5.9 */\n            Jbig2Image *image;\n            uint32_t BMSIZE = jbig2_huffman_get(hs, params->SDHUFFBMSIZE, &code);\n            uint32_t j;\n            int x;\n\n            if (code) {\n                jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"error decoding size of collective bitmap!\");\n                goto cleanup4;\n            }\n\n            /* skip any bits before the next byte boundary */\n            jbig2_huffman_skip(hs);\n\n            image = jbig2_image_new(ctx, TOTWIDTH, HCHEIGHT);\n            if (image == NULL) {\n                jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"could not allocate collective bitmap image!\");\n                goto cleanup4;\n            }\n\n            if (BMSIZE == 0) {\n                /* if BMSIZE == 0 bitmap is uncompressed */\n                const byte *src = data + jbig2_huffman_offset(hs);\n                const int stride = (image->width >> 3) + ((image->width & 7) ? 1 : 0);\n                byte *dst = image->data;\n\n                /* SumatraPDF: prevent read access violation */\n                if ((size - jbig2_huffman_offset(hs) < image->height * stride) || (size < jbig2_huffman_offset(hs))) {\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"not enough data for decoding (%d/%d)\", image->height * stride,\n                                size - jbig2_huffman_offset(hs));\n                    jbig2_image_release(ctx, image);\n                    goto cleanup4;\n                }\n\n                BMSIZE = image->height * stride;\n                jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number,\n                            \"reading %dx%d uncompressed bitmap\" \" for %d symbols (%d bytes)\", image->width, image->height, NSYMSDECODED - HCFIRSTSYM, BMSIZE);\n\n                for (j = 0; j < image->height; j++) {\n                    memcpy(dst, src, stride);\n                    dst += image->stride;\n                    src += stride;\n                }\n            } else {\n                Jbig2GenericRegionParams rparams;\n\n                /* SumatraPDF: prevent read access violation */\n                if (size - jbig2_huffman_offset(hs) < BMSIZE) {\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"not enough data for decoding (%d/%d)\", BMSIZE, size - jbig2_huffman_offset(hs));\n                    jbig2_image_release(ctx, image);\n                    goto cleanup4;\n                }\n\n                jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number,\n                            \"reading %dx%d collective bitmap for %d symbols (%d bytes)\", image->width, image->height, NSYMSDECODED - HCFIRSTSYM, BMSIZE);\n\n                rparams.MMR = 1;\n                code = jbig2_decode_generic_mmr(ctx, segment, &rparams, data + jbig2_huffman_offset(hs), BMSIZE, image);\n                if (code) {\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"error decoding MMR bitmap image!\");\n                    jbig2_image_release(ctx, image);\n                    goto cleanup4;\n                }\n            }\n\n            /* advance past the data we've just read */\n            jbig2_huffman_advance(hs, BMSIZE);\n\n            /* copy the collective bitmap into the symbol dictionary */\n            x = 0;\n            for (j = HCFIRSTSYM; j < NSYMSDECODED; j++) {\n                Jbig2Image *glyph;\n\n                glyph = jbig2_image_new(ctx, SDNEWSYMWIDTHS[j], HCHEIGHT);\n                if (glyph == NULL) {\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to copy the collective bitmap into symbol dictionary\");\n                    jbig2_image_release(ctx, image);\n                    goto cleanup4;\n                }\n                jbig2_image_compose(ctx, glyph, image, -x, 0, JBIG2_COMPOSE_REPLACE);\n                x += SDNEWSYMWIDTHS[j];\n                SDNEWSYMS->glyphs[j] = glyph;\n            }\n            jbig2_image_release(ctx, image);\n        }\n\n    }                           /* end of symbol decode loop */\n\n    /* 6.5.10 */\n    SDEXSYMS = jbig2_sd_new(ctx, params->SDNUMEXSYMS);\n    if (SDEXSYMS == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate symbols exported from symbols dictionary\");\n        goto cleanup4;\n    } else {\n        uint32_t i = 0;\n        uint32_t j = 0;\n        uint32_t k;\n        int exflag = 0;\n        uint32_t limit = params->SDNUMINSYMS + params->SDNUMNEWSYMS;\n        uint32_t exrunlength;\n        int zerolength = 0;\n\n        while (i < limit) {\n            if (params->SDHUFF)\n                exrunlength = jbig2_huffman_get(hs, SBHUFFRSIZE, &code);\n            else\n                code = jbig2_arith_int_decode(IAEX, as, (int32_t *)&exrunlength);\n            /* prevent infinite loop */\n            zerolength = exrunlength > 0 ? 0 : zerolength + 1;\n            if (code || (exrunlength > limit - i) || (zerolength > 4) || (exflag && (exrunlength + j > params->SDNUMEXSYMS))) {\n                if (code)\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to decode exrunlength for exported symbols\");\n                else if (exrunlength <= 0)\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"runlength too small in export symbol table (%d <= 0)\\n\", exrunlength);\n                else\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number,\n                                \"runlength too large in export symbol table (%d > %d - %d)\\n\", exrunlength, params->SDNUMEXSYMS, j);\n                /* skip to the cleanup code and return SDEXSYMS = NULL */\n                jbig2_sd_release(ctx, SDEXSYMS);\n                SDEXSYMS = NULL;\n                break;\n            }\n            for (k = 0; k < exrunlength; k++) {\n                if (exflag) {\n                    SDEXSYMS->glyphs[j++] = (i < params->SDNUMINSYMS) ?\n                                            jbig2_image_clone(ctx, params->SDINSYMS->glyphs[i]) : jbig2_image_clone(ctx, SDNEWSYMS->glyphs[i - params->SDNUMINSYMS]);\n                }\n                i++;\n            }\n            exflag = !exflag;\n        }\n    }\n\ncleanup4:\n    if (tparams != NULL) {\n        if (!params->SDHUFF) {\n            jbig2_arith_int_ctx_free(ctx, tparams->IADT);\n            jbig2_arith_int_ctx_free(ctx, tparams->IAFS);\n            jbig2_arith_int_ctx_free(ctx, tparams->IADS);\n            jbig2_arith_int_ctx_free(ctx, tparams->IAIT);\n            jbig2_arith_iaid_ctx_free(ctx, tparams->IAID);\n            jbig2_arith_int_ctx_free(ctx, tparams->IARI);\n            jbig2_arith_int_ctx_free(ctx, tparams->IARDW);\n            jbig2_arith_int_ctx_free(ctx, tparams->IARDH);\n            jbig2_arith_int_ctx_free(ctx, tparams->IARDX);\n            jbig2_arith_int_ctx_free(ctx, tparams->IARDY);\n        } else {\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFFS);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFDS);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFDT);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFRDX);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFRDY);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFRDW);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFRDH);\n        }\n        jbig2_free(ctx->allocator, tparams);\n    }\n    if (refagg_dicts != NULL) {\n        if (refagg_dicts[0] != NULL)\n            jbig2_sd_release(ctx, refagg_dicts[0]);\n        jbig2_free(ctx->allocator, refagg_dicts);\n    }\n\ncleanup2:\n    jbig2_sd_release(ctx, SDNEWSYMS);\n    if (params->SDHUFF && !params->SDREFAGG) {\n        jbig2_free(ctx->allocator, SDNEWSYMWIDTHS);\n    }\n    jbig2_release_huffman_table(ctx, SDHUFFRDX);\n    jbig2_release_huffman_table(ctx, SBHUFFRSIZE);\n    jbig2_huffman_free(ctx, hs);\n    jbig2_arith_iaid_ctx_free(ctx, IAID);\n    jbig2_arith_int_ctx_free(ctx, IARDX);\n    jbig2_arith_int_ctx_free(ctx, IARDY);\n\ncleanup1:\n    jbig2_word_stream_buf_free(ctx, ws);\n    jbig2_free(ctx->allocator, as);\n    jbig2_arith_int_ctx_free(ctx, IADH);\n    jbig2_arith_int_ctx_free(ctx, IADW);\n    jbig2_arith_int_ctx_free(ctx, IAEX);\n    jbig2_arith_int_ctx_free(ctx, IAAI);\n\n    return SDEXSYMS;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145502,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "jbig2_decode_symbol_dict(Jbig2Ctx *ctx,\n                         Jbig2Segment *segment,\n                         const Jbig2SymbolDictParams *params, const byte *data, size_t size, Jbig2ArithCx *GB_stats, Jbig2ArithCx *GR_stats)\n{\n    Jbig2SymbolDict *SDNEWSYMS = NULL;\n    Jbig2SymbolDict *SDEXSYMS = NULL;\n    uint32_t HCHEIGHT;\n    uint32_t NSYMSDECODED;\n    uint32_t SYMWIDTH, TOTWIDTH;\n    uint32_t HCFIRSTSYM;\n    uint32_t *SDNEWSYMWIDTHS = NULL;\n    int SBSYMCODELEN = 0;\n    Jbig2WordStream *ws = NULL;\n    Jbig2HuffmanState *hs = NULL;\n    Jbig2HuffmanTable *SDHUFFRDX = NULL;\n    Jbig2HuffmanTable *SBHUFFRSIZE = NULL;\n    Jbig2ArithState *as = NULL;\n    Jbig2ArithIntCtx *IADH = NULL;\n    Jbig2ArithIntCtx *IADW = NULL;\n    Jbig2ArithIntCtx *IAEX = NULL;\n    Jbig2ArithIntCtx *IAAI = NULL;\n    Jbig2ArithIaidCtx *IAID = NULL;\n    Jbig2ArithIntCtx *IARDX = NULL;\n    Jbig2ArithIntCtx *IARDY = NULL;\n    int code = 0;\n    Jbig2SymbolDict **refagg_dicts = NULL;\n    int n_refagg_dicts = 1;\n\n    Jbig2TextRegionParams *tparams = NULL;\n\n    /* 6.5.5 (3) */\n    HCHEIGHT = 0;\n    NSYMSDECODED = 0;\n\n    ws = jbig2_word_stream_buf_new(ctx, data, size);\n    if (ws == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate ws in jbig2_decode_symbol_dict\");\n        return NULL;\n    }\n\n    as = jbig2_arith_new(ctx, ws);\n    if (as == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate as in jbig2_decode_symbol_dict\");\n        jbig2_word_stream_buf_free(ctx, ws);\n        return NULL;\n    }\n\n    if (!params->SDHUFF) {\n        IADH = jbig2_arith_int_ctx_new(ctx);\n        IADW = jbig2_arith_int_ctx_new(ctx);\n        IAEX = jbig2_arith_int_ctx_new(ctx);\n        IAAI = jbig2_arith_int_ctx_new(ctx);\n        if ((IADH == NULL) || (IADW == NULL) || (IAEX == NULL) || (IAAI == NULL)) {\n            jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate storage for symbol bitmap\");\n            goto cleanup1;\n        }\n        if (params->SDREFAGG) {\n            int64_t tmp = params->SDNUMINSYMS + params->SDNUMNEWSYMS;\n\n            for (SBSYMCODELEN = 0; ((int64_t) 1 << SBSYMCODELEN) < tmp; SBSYMCODELEN++);\n            IAID = jbig2_arith_iaid_ctx_new(ctx, SBSYMCODELEN);\n            IARDX = jbig2_arith_int_ctx_new(ctx);\n            IARDY = jbig2_arith_int_ctx_new(ctx);\n            if ((IAID == NULL) || (IARDX == NULL) || (IARDY == NULL)) {\n                jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate storage for symbol bitmap\");\n                goto cleanup2;\n            }\n        }\n    } else {\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"huffman coded symbol dictionary\");\n        hs = jbig2_huffman_new(ctx, ws);\n        SDHUFFRDX = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);\n        SBHUFFRSIZE = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_A);\n        if ((hs == NULL) || (SDHUFFRDX == NULL) || (SBHUFFRSIZE == NULL)) {\n            jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate storage for symbol bitmap\");\n            goto cleanup2;\n        }\n        if (!params->SDREFAGG) {\n            SDNEWSYMWIDTHS = jbig2_new(ctx, uint32_t, params->SDNUMNEWSYMS);\n            if (SDNEWSYMWIDTHS == NULL) {\n                jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"could not allocate storage for (%u) symbol widths\", params->SDNUMNEWSYMS);\n                goto cleanup2;\n            }\n        }\n    }\n\n    SDNEWSYMS = jbig2_sd_new(ctx, params->SDNUMNEWSYMS);\n    if (SDNEWSYMS == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"could not allocate storage for (%u) new symbols\", params->SDNUMNEWSYMS);\n        goto cleanup2;\n    }\n\n    /* 6.5.5 (4a) */\n    while (NSYMSDECODED < params->SDNUMNEWSYMS) {\n        int32_t HCDH, DW;\n\n        /* 6.5.6 */\n        if (params->SDHUFF) {\n            HCDH = jbig2_huffman_get(hs, params->SDHUFFDH, &code);\n        } else {\n            code = jbig2_arith_int_decode(IADH, as, &HCDH);\n        }\n\n        if (code != 0) {\n            jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"error or OOB decoding height class delta (%d)\\n\", code);\n        }\n\n        if (!params->SDHUFF && jbig2_arith_has_reached_marker(as)) {\n            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"prevent DOS while decoding height classes\");\n            goto cleanup2;\n        }\n\n        /* 6.5.5 (4b) */\n        HCHEIGHT = HCHEIGHT + HCDH;\n        SYMWIDTH = 0;\n        TOTWIDTH = 0;\n        HCFIRSTSYM = NSYMSDECODED;\n\n        if ((int32_t) HCHEIGHT < 0) {\n            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Invalid HCHEIGHT value\");\n            goto cleanup2;\n        }\n#ifdef JBIG2_DEBUG\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"HCHEIGHT = %d\", HCHEIGHT);\n#endif\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"decoding height class %d with %d syms decoded\", HCHEIGHT, NSYMSDECODED);\n\n        for (;;) {\n            /* 6.5.7 */\n            if (params->SDHUFF) {\n                DW = jbig2_huffman_get(hs, params->SDHUFFDW, &code);\n            } else {\n                code = jbig2_arith_int_decode(IADW, as, &DW);\n            }\n            if (code < 0)\n                goto cleanup4;\n\n            /* 6.5.5 (4c.i) */\n            if (code == 1) {\n                jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \" OOB signals end of height class %d\", HCHEIGHT);\n                break;\n            }\n\n            /* check for broken symbol table */\n            if (NSYMSDECODED >= params->SDNUMNEWSYMS) {\n                jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"No OOB signalling end of height class %d\", HCHEIGHT);\n                goto cleanup4;\n            }\n\n            SYMWIDTH = SYMWIDTH + DW;\n            TOTWIDTH = TOTWIDTH + SYMWIDTH;\n            if ((int32_t) SYMWIDTH < 0) {\n                code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Invalid SYMWIDTH value (%d) at symbol %d\", SYMWIDTH, NSYMSDECODED + 1);\n                goto cleanup4;\n            }\n#ifdef JBIG2_DEBUG\n            jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"SYMWIDTH = %d TOTWIDTH = %d\", SYMWIDTH, TOTWIDTH);\n#endif\n            /* 6.5.5 (4c.ii) */\n            if (!params->SDHUFF || params->SDREFAGG) {\n#ifdef JBIG2_DEBUG\n                jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"SDHUFF = %d; SDREFAGG = %d\", params->SDHUFF, params->SDREFAGG);\n#endif\n                /* 6.5.8 */\n                if (!params->SDREFAGG) {\n                    Jbig2GenericRegionParams region_params;\n                    int sdat_bytes;\n                    Jbig2Image *image;\n\n                    /* Table 16 */\n                    region_params.MMR = 0;\n                    region_params.GBTEMPLATE = params->SDTEMPLATE;\n                    region_params.TPGDON = 0;\n                    region_params.USESKIP = 0;\n                    sdat_bytes = params->SDTEMPLATE == 0 ? 8 : 2;\n                    memcpy(region_params.gbat, params->sdat, sdat_bytes);\n\n                    image = jbig2_image_new(ctx, SYMWIDTH, HCHEIGHT);\n                    if (image == NULL) {\n                        code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate image in jbig2_decode_symbol_dict\");\n                        goto cleanup4;\n                    }\n\n                    code = jbig2_decode_generic_region(ctx, segment, &region_params, as, image, GB_stats);\n                    if (code < 0) {\n                        jbig2_image_release(ctx, image);\n                        goto cleanup4;\n                    }\n\n                    SDNEWSYMS->glyphs[NSYMSDECODED] = image;\n                } else {\n                    /* 6.5.8.2 refinement/aggregate symbol */\n                    uint32_t REFAGGNINST;\n\n                    if (params->SDHUFF) {\n                        REFAGGNINST = jbig2_huffman_get(hs, params->SDHUFFAGGINST, &code);\n                    } else {\n                        code = jbig2_arith_int_decode(IAAI, as, (int32_t *) & REFAGGNINST);\n                    }\n                    if (code || (int32_t) REFAGGNINST <= 0) {\n                        code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"invalid number of symbols or OOB in aggregate glyph\");\n                        goto cleanup4;\n                    }\n\n                    jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"aggregate symbol coding (%d instances)\", REFAGGNINST);\n\n                    if (REFAGGNINST > 1) {\n                        Jbig2Image *image;\n                        uint32_t i;\n\n                        if (tparams == NULL) {\n                            /* First time through, we need to initialise the */\n                            /* various tables for Huffman or adaptive encoding */\n                            /* as well as the text region parameters structure */\n                            refagg_dicts = jbig2_new(ctx, Jbig2SymbolDict *, n_refagg_dicts);\n                            if (refagg_dicts == NULL) {\n                                code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory allocating dictionary array\");\n                                goto cleanup4;\n                            }\n                            refagg_dicts[0] = jbig2_sd_new(ctx, params->SDNUMINSYMS + params->SDNUMNEWSYMS);\n                            if (refagg_dicts[0] == NULL) {\n                                code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory allocating symbol dictionary\");\n                                goto cleanup4;\n                            }\n                            for (i = 0; i < params->SDNUMINSYMS; i++) {\n                                refagg_dicts[0]->glyphs[i] = jbig2_image_clone(ctx, params->SDINSYMS->glyphs[i]);\n                            }\n\n                            tparams = jbig2_new(ctx, Jbig2TextRegionParams, 1);\n                            if (tparams == NULL) {\n                                code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory creating text region params\");\n                                goto cleanup4;\n                            }\n                            if (!params->SDHUFF) {\n                                /* Values from Table 17, section 6.5.8.2 (2) */\n                                tparams->IADT = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IAFS = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IADS = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IAIT = jbig2_arith_int_ctx_new(ctx);\n                                /* Table 31 */\n                                for (SBSYMCODELEN = 0; (1 << SBSYMCODELEN) < (int)(params->SDNUMINSYMS + params->SDNUMNEWSYMS); SBSYMCODELEN++);\n                                tparams->IAID = jbig2_arith_iaid_ctx_new(ctx, SBSYMCODELEN);\n                                tparams->IARI = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IARDW = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IARDH = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IARDX = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IARDY = jbig2_arith_int_ctx_new(ctx);\n                            } else {\n                                tparams->SBHUFFFS = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_F);    /* Table B.6 */\n                                tparams->SBHUFFDS = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_H);    /* Table B.8 */\n                                tparams->SBHUFFDT = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_K);    /* Table B.11 */\n                                tparams->SBHUFFRDW = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);   /* Table B.15 */\n                                tparams->SBHUFFRDH = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);   /* Table B.15 */\n                                tparams->SBHUFFRDX = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);   /* Table B.15 */\n                                tparams->SBHUFFRDY = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);   /* Table B.15 */\n                            }\n                            tparams->SBHUFF = params->SDHUFF;\n                            tparams->SBREFINE = 1;\n                            tparams->SBSTRIPS = 1;\n                            tparams->SBDEFPIXEL = 0;\n                            tparams->SBCOMBOP = JBIG2_COMPOSE_OR;\n                            tparams->TRANSPOSED = 0;\n                            tparams->REFCORNER = JBIG2_CORNER_TOPLEFT;\n                            tparams->SBDSOFFSET = 0;\n                            tparams->SBRTEMPLATE = params->SDRTEMPLATE;\n                        }\n                        tparams->SBNUMINSTANCES = REFAGGNINST;\n\n                        image = jbig2_image_new(ctx, SYMWIDTH, HCHEIGHT);\n                        if (image == NULL) {\n                            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory creating symbol image\");\n                            goto cleanup4;\n                        }\n\n                        /* multiple symbols are handled as a text region */\n                        code = jbig2_decode_text_region(ctx, segment, tparams, (const Jbig2SymbolDict * const *)refagg_dicts,\n                                                 n_refagg_dicts, image, data, size, GR_stats, as, ws);\n                        if (code < 0)\n                            goto cleanup4;\n\n                        SDNEWSYMS->glyphs[NSYMSDECODED] = image;\n                        refagg_dicts[0]->glyphs[params->SDNUMINSYMS + NSYMSDECODED] = jbig2_image_clone(ctx, SDNEWSYMS->glyphs[NSYMSDECODED]);\n                    } else {\n                        /* 6.5.8.2.2 */\n                        /* bool SBHUFF = params->SDHUFF; */\n                        Jbig2RefinementRegionParams rparams;\n                        Jbig2Image *image;\n                        uint32_t ID;\n                        int32_t RDX, RDY;\n                        int BMSIZE = 0;\n                        uint32_t ninsyms = params->SDNUMINSYMS;\n                        int code1 = 0;\n                        int code2 = 0;\n                        int code3 = 0;\n                        int code4 = 0;\n\n                        /* 6.5.8.2.2 (2, 3, 4, 5) */\n                        if (params->SDHUFF) {\n                            ID = jbig2_huffman_get_bits(hs, SBSYMCODELEN, &code4);\n                            RDX = jbig2_huffman_get(hs, SDHUFFRDX, &code1);\n                            RDY = jbig2_huffman_get(hs, SDHUFFRDX, &code2);\n                            BMSIZE = jbig2_huffman_get(hs, SBHUFFRSIZE, &code3);\n                            jbig2_huffman_skip(hs);\n                        } else {\n                            code1 = jbig2_arith_iaid_decode(IAID, as, (int32_t *) & ID);\n                            code2 = jbig2_arith_int_decode(IARDX, as, &RDX);\n                            code3 = jbig2_arith_int_decode(IARDY, as, &RDY);\n                        }\n\n                        if ((code1 < 0) || (code2 < 0) || (code3 < 0) || (code4 < 0)) {\n                            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to decode data\");\n                            goto cleanup4;\n                        }\n\n                        if (ID >= ninsyms + NSYMSDECODED) {\n                            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"refinement references unknown symbol %d\", ID);\n                            goto cleanup4;\n                        }\n\n                        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number,\n                                    \"symbol is a refinement of id %d with the \" \"refinement applied at (%d,%d)\", ID, RDX, RDY);\n\n                        image = jbig2_image_new(ctx, SYMWIDTH, HCHEIGHT);\n                        if (image == NULL) {\n                            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory creating symbol image\");\n                            goto cleanup4;\n                        }\n\n                        /* Table 18 */\n                        rparams.GRTEMPLATE = params->SDRTEMPLATE;\n                        rparams.reference = (ID < ninsyms) ? params->SDINSYMS->glyphs[ID] : SDNEWSYMS->glyphs[ID - ninsyms];\n                        /* SumatraPDF: fail on missing glyphs */\n                        if (rparams.reference == NULL) {\n                            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"missing glyph %d/%d!\", ID, ninsyms);\n                            jbig2_image_release(ctx, image);\n                            goto cleanup4;\n                        }\n                        rparams.DX = RDX;\n                        rparams.DY = RDY;\n                        rparams.TPGRON = 0;\n                        memcpy(rparams.grat, params->sdrat, 4);\n                        code = jbig2_decode_refinement_region(ctx, segment, &rparams, as, image, GR_stats);\n                        if (code < 0)\n                            goto cleanup4;\n\n                        SDNEWSYMS->glyphs[NSYMSDECODED] = image;\n\n                        /* 6.5.8.2.2 (7) */\n                        if (params->SDHUFF) {\n                            if (BMSIZE == 0)\n                                BMSIZE = image->height * image->stride;\n                            jbig2_huffman_advance(hs, BMSIZE);\n                        }\n                    }\n                }\n\n#ifdef OUTPUT_PBM\n                {\n                    char name[64];\n                    FILE *out;\n\n                    snprintf(name, 64, \"sd.%04d.%04d.pbm\", segment->number, NSYMSDECODED);\n                    out = fopen(name, \"wb\");\n                    jbig2_image_write_pbm(SDNEWSYMS->glyphs[NSYMSDECODED], out);\n                    jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"writing out glyph as '%s' ...\", name);\n                    fclose(out);\n                }\n#endif\n\n            }\n\n            /* 6.5.5 (4c.iii) */\n            if (params->SDHUFF && !params->SDREFAGG) {\n                SDNEWSYMWIDTHS[NSYMSDECODED] = SYMWIDTH;\n            }\n\n            /* 6.5.5 (4c.iv) */\n            NSYMSDECODED = NSYMSDECODED + 1;\n\n            jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"decoded symbol %u of %u (%ux%u)\", NSYMSDECODED, params->SDNUMNEWSYMS, SYMWIDTH, HCHEIGHT);\n\n        }                       /* end height class decode loop */\n\n        /* 6.5.5 (4d) */\n        if (params->SDHUFF && !params->SDREFAGG) {\n            /* 6.5.9 */\n            Jbig2Image *image;\n            uint32_t BMSIZE = jbig2_huffman_get(hs, params->SDHUFFBMSIZE, &code);\n            uint32_t j;\n            int x;\n\n            if (code) {\n                jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"error decoding size of collective bitmap!\");\n                goto cleanup4;\n            }\n\n            /* skip any bits before the next byte boundary */\n            jbig2_huffman_skip(hs);\n\n            image = jbig2_image_new(ctx, TOTWIDTH, HCHEIGHT);\n            if (image == NULL) {\n                jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"could not allocate collective bitmap image!\");\n                goto cleanup4;\n            }\n\n            if (BMSIZE == 0) {\n                /* if BMSIZE == 0 bitmap is uncompressed */\n                const byte *src = data + jbig2_huffman_offset(hs);\n                const int stride = (image->width >> 3) + ((image->width & 7) ? 1 : 0);\n                byte *dst = image->data;\n\n                /* SumatraPDF: prevent read access violation */\n                if ((size - jbig2_huffman_offset(hs) < image->height * stride) || (size < jbig2_huffman_offset(hs))) {\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"not enough data for decoding (%d/%d)\", image->height * stride,\n                                size - jbig2_huffman_offset(hs));\n                    jbig2_image_release(ctx, image);\n                    goto cleanup4;\n                }\n\n                BMSIZE = image->height * stride;\n                jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number,\n                            \"reading %dx%d uncompressed bitmap\" \" for %d symbols (%d bytes)\", image->width, image->height, NSYMSDECODED - HCFIRSTSYM, BMSIZE);\n\n                for (j = 0; j < image->height; j++) {\n                    memcpy(dst, src, stride);\n                    dst += image->stride;\n                    src += stride;\n                }\n            } else {\n                Jbig2GenericRegionParams rparams;\n\n                /* SumatraPDF: prevent read access violation */\n                if (size - jbig2_huffman_offset(hs) < BMSIZE) {\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"not enough data for decoding (%d/%d)\", BMSIZE, size - jbig2_huffman_offset(hs));\n                    jbig2_image_release(ctx, image);\n                    goto cleanup4;\n                }\n\n                jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number,\n                            \"reading %dx%d collective bitmap for %d symbols (%d bytes)\", image->width, image->height, NSYMSDECODED - HCFIRSTSYM, BMSIZE);\n\n                rparams.MMR = 1;\n                code = jbig2_decode_generic_mmr(ctx, segment, &rparams, data + jbig2_huffman_offset(hs), BMSIZE, image);\n                if (code) {\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"error decoding MMR bitmap image!\");\n                    jbig2_image_release(ctx, image);\n                    goto cleanup4;\n                }\n            }\n\n            /* advance past the data we've just read */\n            jbig2_huffman_advance(hs, BMSIZE);\n\n            /* copy the collective bitmap into the symbol dictionary */\n            x = 0;\n            for (j = HCFIRSTSYM; j < NSYMSDECODED; j++) {\n                Jbig2Image *glyph;\n\n                glyph = jbig2_image_new(ctx, SDNEWSYMWIDTHS[j], HCHEIGHT);\n                if (glyph == NULL) {\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to copy the collective bitmap into symbol dictionary\");\n                    jbig2_image_release(ctx, image);\n                    goto cleanup4;\n                }\n                jbig2_image_compose(ctx, glyph, image, -x, 0, JBIG2_COMPOSE_REPLACE);\n                x += SDNEWSYMWIDTHS[j];\n                SDNEWSYMS->glyphs[j] = glyph;\n            }\n            jbig2_image_release(ctx, image);\n        }\n\n    }                           /* end of symbol decode loop */\n\n    /* 6.5.10 */\n    SDEXSYMS = jbig2_sd_new(ctx, params->SDNUMEXSYMS);\n    if (SDEXSYMS == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate symbols exported from symbols dictionary\");\n        goto cleanup4;\n    } else {\n        uint32_t i = 0;\n        uint32_t j = 0;\n        uint32_t k;\n        int exflag = 0;\n        uint32_t limit = params->SDNUMINSYMS + params->SDNUMNEWSYMS;\n        uint32_t exrunlength;\n        int zerolength = 0;\n\n        while (i < limit) {\n            if (params->SDHUFF)\n                exrunlength = jbig2_huffman_get(hs, SBHUFFRSIZE, &code);\n            else\n                code = jbig2_arith_int_decode(IAEX, as, (int32_t *)&exrunlength);\n            /* prevent infinite loop */\n            zerolength = exrunlength > 0 ? 0 : zerolength + 1;\n            if (code || (exrunlength > limit - i) || (zerolength > 4) || (exflag && (exrunlength + j > params->SDNUMEXSYMS))) {\n                if (code)\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to decode exrunlength for exported symbols\");\n                else if (exrunlength <= 0)\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"runlength too small in export symbol table (%d <= 0)\\n\", exrunlength);\n                else\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number,\n                                \"runlength too large in export symbol table (%d > %d - %d)\\n\", exrunlength, params->SDNUMEXSYMS, j);\n                /* skip to the cleanup code and return SDEXSYMS = NULL */\n                jbig2_sd_release(ctx, SDEXSYMS);\n                SDEXSYMS = NULL;\n                break;\n            }\n            for (k = 0; k < exrunlength; k++) {\n                if (exflag) {\n                    SDEXSYMS->glyphs[j++] = (i < params->SDNUMINSYMS) ?\n                                            jbig2_image_clone(ctx, params->SDINSYMS->glyphs[i]) : jbig2_image_clone(ctx, SDNEWSYMS->glyphs[i - params->SDNUMINSYMS]);\n                }\n                i++;\n            }\n            exflag = !exflag;\n        }\n    }\n\ncleanup4:\n    if (tparams != NULL) {\n        if (!params->SDHUFF) {\n            jbig2_arith_int_ctx_free(ctx, tparams->IADT);\n            jbig2_arith_int_ctx_free(ctx, tparams->IAFS);\n            jbig2_arith_int_ctx_free(ctx, tparams->IADS);\n            jbig2_arith_int_ctx_free(ctx, tparams->IAIT);\n            jbig2_arith_iaid_ctx_free(ctx, tparams->IAID);\n            jbig2_arith_int_ctx_free(ctx, tparams->IARI);\n            jbig2_arith_int_ctx_free(ctx, tparams->IARDW);\n            jbig2_arith_int_ctx_free(ctx, tparams->IARDH);\n            jbig2_arith_int_ctx_free(ctx, tparams->IARDX);\n            jbig2_arith_int_ctx_free(ctx, tparams->IARDY);\n        } else {\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFFS);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFDS);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFDT);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFRDX);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFRDY);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFRDW);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFRDH);\n        }\n        jbig2_free(ctx->allocator, tparams);\n    }\n    if (refagg_dicts != NULL) {\n        if (refagg_dicts[0] != NULL)\n            jbig2_sd_release(ctx, refagg_dicts[0]);\n        jbig2_free(ctx->allocator, refagg_dicts);\n    }\n\ncleanup2:\n    jbig2_sd_release(ctx, SDNEWSYMS);\n    if (params->SDHUFF && !params->SDREFAGG) {\n        jbig2_free(ctx->allocator, SDNEWSYMWIDTHS);\n    }\n    jbig2_release_huffman_table(ctx, SDHUFFRDX);\n    jbig2_release_huffman_table(ctx, SBHUFFRSIZE);\n    jbig2_huffman_free(ctx, hs);\n    jbig2_arith_iaid_ctx_free(ctx, IAID);\n    jbig2_arith_int_ctx_free(ctx, IARDX);\n    jbig2_arith_int_ctx_free(ctx, IARDY);\n\ncleanup1:\n    jbig2_word_stream_buf_free(ctx, ws);\n    jbig2_free(ctx->allocator, as);\n    jbig2_arith_int_ctx_free(ctx, IADH);\n    jbig2_arith_int_ctx_free(ctx, IADW);\n    jbig2_arith_int_ctx_free(ctx, IAEX);\n    jbig2_arith_int_ctx_free(ctx, IAAI);\n\n    return SDEXSYMS;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145503,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void _cmd_window_show_opt(const char *data, int right)\n{\n\tMAIN_WINDOW_REC *parent;\n\tWINDOW_REC *window;\n\n\tif (*data == '\\0') cmd_return_error(CMDERR_NOT_ENOUGH_PARAMS);\n\n\tif (is_numeric(data, '\\0')) {\n\t\twindow = window_find_refnum(atoi(data));\n\t\tif (window == NULL) {\n\t\t\tprintformat_window(active_win, MSGLEVEL_CLIENTERROR,\n\t\t\t\t\t   TXT_REFNUM_NOT_FOUND, data);\n\t\t}\n\t} else {\n\t\twindow = window_find_item(active_win->active_server, data);\n\t}\n\n\tif (window == NULL || is_window_visible(window))\n\t\treturn;\n\n\tif (WINDOW_GUI(window)->sticky) {\n\t\tif (!settings_get_bool(\"autounstick_windows\")) {\n\t\t\tprintformat_window(active_win, MSGLEVEL_CLIENTERROR,\n\t\t\t\t\t   TXT_CANT_SHOW_STICKY_WINDOWS);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tparent = mainwindow_create(right);\n\tparent->active = window;\n\tgui_window_reparent(window, parent);\n\n\tif (settings_get_bool(\"autostick_split_windows\"))\n\t\tgui_window_set_sticky(window);\n\n\tactive_mainwin = NULL;\n\twindow_set_active(window);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145542,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void _cmd_window_show_opt(const char *data, int right)\n{\n\tMAIN_WINDOW_REC *parent;\n\tWINDOW_REC *window;\n\n\tif (*data == '\\0') cmd_return_error(CMDERR_NOT_ENOUGH_PARAMS);\n\n\tif (is_numeric(data, '\\0')) {\n\t\twindow = window_find_refnum(atoi(data));\n\t\tif (window == NULL) {\n\t\t\tprintformat_window(active_win, MSGLEVEL_CLIENTERROR,\n\t\t\t\t\t   TXT_REFNUM_NOT_FOUND, data);\n\t\t}\n\t} else {\n\t\twindow = window_find_item(active_win->active_server, data);\n\t}\n\n\tif (window == NULL || is_window_visible(window))\n\t\treturn;\n\n\tif (WINDOW_GUI(window)->sticky) {\n\t\tif (!settings_get_bool(\"autounstick_windows\")) {\n\t\t\tprintformat_window(active_win, MSGLEVEL_CLIENTERROR,\n\t\t\t\t\t   TXT_CANT_SHOW_STICKY_WINDOWS);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tparent = mainwindow_create(right);\n\tif (parent == NULL) {\n\t\tprintformat_window(active_win, MSGLEVEL_CLIENTERROR, TXT_WINDOW_TOO_SMALL);\n\t\treturn;\n\t}\n\n\tparent->active = window;\n\tgui_window_reparent(window, parent);\n\n\tif (settings_get_bool(\"autostick_split_windows\"))\n\t\tgui_window_set_sticky(window);\n\n\tactive_mainwin = NULL;\n\twindow_set_active(window);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145543,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int Exiv2::http(Exiv2::Dictionary& request,Exiv2::Dictionary& response,std::string& errors)\n{\n    if ( !request.count(\"verb\")   ) request[\"verb\"   ] = \"GET\";\n    if ( !request.count(\"header\") ) request[\"header\" ] = \"\"   ;\n    if ( !request.count(\"version\")) request[\"version\"] = \"1.0\";\n    if ( !request.count(\"port\")   ) request[\"port\"   ] = \"\"   ;\n\n    std::string file;\n    errors     = \"\";\n    int result = 0;\n\n    ////////////////////////////////////\n    // Windows specific code\n#ifdef WIN32\n    WSADATA wsaData;\n    WSAStartup(MAKEWORD(2,2), &wsaData);\n#endif\n\n    const char* servername = request[\"server\" ].c_str();\n    const char* page       = request[\"page\"   ].c_str();\n    const char* verb       = request[\"verb\"   ].c_str();\n    const char* header     = request[\"header\" ].c_str();\n    const char* version    = request[\"version\"].c_str();\n    const char* port       = request[\"port\"   ].c_str();\n\n    const char* servername_p = servername;\n    const char* port_p       = port      ;\n    std::string url = std::string(\"http://\") + request[\"server\"] + request[\"page\"];\n\n    // parse and change server if using a proxy\n    const char* PROXI  = \"HTTP_PROXY\";\n    const char* proxi  = \"http_proxy\";\n    const char* PROXY  = getenv(PROXI);\n    const char* proxy  = getenv(proxi);\n    bool        bProx  = PROXY || proxy;\n    const char* prox   = bProx ? (proxy?proxy:PROXY):\"\";\n    Exiv2::Uri  Proxy  =  Exiv2::Uri::Parse(prox);\n\n    // find the dictionary of no_proxy servers\n    const char* NO_PROXI = \"NO_PROXY\";\n    const char* no_proxi = \"no_proxy\";\n    const char* NO_PROXY = getenv(NO_PROXI);\n    const char* no_proxy = getenv(no_proxi);\n    bool        bNoProxy = NO_PROXY||no_proxy;\n    std::string no_prox  = std::string(bNoProxy?(no_proxy?no_proxy:NO_PROXY):\"\");\n    Exiv2::Dictionary noProxy= stringToDict(no_prox + \",localhost,127.0.0.1\");\n\n    // if the server is on the no_proxy list ... ignore the proxy!\n    if ( noProxy.count(servername) ) bProx = false;\n\n    if (  bProx ) {\n        servername_p = Proxy.Host.c_str();\n        port_p       = Proxy.Port.c_str();\n        page         = url.c_str();\n        std::string  p(proxy?proxi:PROXI);\n    //  std::cerr << p << '=' << prox << \" page = \" << page << std::endl;\n    }\n    if ( !port  [0] ) port   = \"80\";\n    if ( !port_p[0] ) port_p = \"80\";\n\n    ////////////////////////////////////\n    // open the socket\n    int     sockfd = (int) socket(AF_INET , SOCK_STREAM,IPPROTO_TCP) ;\n    if (    sockfd < 0 ) return error(errors, \"unable to create socket\\n\",NULL,NULL,0) ;\n\n    // connect the socket to the server\n    int     server  = -1 ;\n\n    // fill in the address\n    struct  sockaddr_in serv_addr   ;\n    int                 serv_len = sizeof(serv_addr);\n    memset((char *)&serv_addr,0,serv_len);\n\n    serv_addr.sin_addr.s_addr   = inet_addr(servername_p);\n    serv_addr.sin_family        = AF_INET    ;\n    serv_addr.sin_port          = htons(atoi(port_p));\n\n    // convert unknown servername into IP address\n    // http://publib.boulder.ibm.com/infocenter/iseries/v5r3/index.jsp?topic=/rzab6/rzab6uafinet.htm\n    if (serv_addr.sin_addr.s_addr == (unsigned long)INADDR_NONE)\n    {\n        struct hostent* host = gethostbyname(servername_p);\n        if ( !host )  return error(errors, \"no such host\", servername_p);\n        memcpy(&serv_addr.sin_addr,host->h_addr,sizeof(serv_addr.sin_addr));\n    }\n\n    makeNonBlocking(sockfd) ;\n\n    ////////////////////////////////////\n    // and connect\n    server = connect(sockfd, (const struct sockaddr *) &serv_addr, serv_len) ;\n    if ( server == SOCKET_ERROR && WSAGetLastError() != WSAEWOULDBLOCK )\n        return error(errors,\"error - unable to connect to server = %s port = %s wsa_error = %d\",servername_p,port_p,WSAGetLastError());\n\n    char   buffer[32*1024+1];\n    size_t buff_l= sizeof buffer - 1 ;\n\n    ////////////////////////////////////\n    // format the request\n    int    n  = snprintf(buffer,buff_l,httpTemplate,verb,page,version,servername,header) ;\n    buffer[n] = 0 ;\n    response[\"requestheaders\"]=std::string(buffer,n);\n\n\n    ////////////////////////////////////\n    // send the header (we'll have to wait for the connection by the non-blocking socket)\n    while ( sleep_ >= 0 && send(sockfd,buffer,n,0) == SOCKET_ERROR /* && WSAGetLastError() == WSAENOTCONN */ ) {\n        Sleep(snooze) ;\n        sleep_ -= snooze ;\n    }\n\n    if ( sleep_ < 0 )\n        return error(errors,\"error - timeout connecting to server = %s port = %s wsa_error = %d\",servername,port,WSAGetLastError());\n\n    int    end   = 0         ; // write position in buffer\n    bool   bSearching = true ; // looking for headers in the response\n    int    status= 200       ; // assume happiness\n\n    ////////////////////////////////////\n    // read and process the response\n    int err ;\n    n=forgive(recv(sockfd,buffer,(int)buff_l,0),err) ;\n    while ( n >= 0 && OK(status) ) {\n        if ( n ) {\n            end += n ;\n            buffer[end] = 0 ;\n\n            size_t body = 0         ; // start of body\n            if ( bSearching ) {\n\n                // search for the body\n                for ( size_t b = 0 ; bSearching && b < lengthof(blankLines) ; b++ ) {\n                    if ( strstr(buffer,blankLines[b]) ) {\n                        bSearching = false ;\n                        body   = (int) ( strstr(buffer,blankLines[b]) - buffer ) + strlen(blankLines[b]) ;\n                        status = atoi(strchr(buffer,' ')) ;\n                    }\n                }\n\n                // parse response headers\n                char* h = buffer;\n                char  C = ':' ;\n                char  N = '\\n';\n                int   i = 0   ; // initial byte in buffer\n                while(buffer[i] == N ) i++;\n                h       = strchr(h+i,N)+1;\n                response[\"\"]=std::string(buffer+i).substr(0,h-buffer-2);\n                result = atoi(strchr(buffer,' '));\n                char* c = strchr(h,C);\n                char* first_newline = strchr(h,N);\n                while ( c && first_newline && c < first_newline && h < buffer+body ) {\n                    std::string key(h);\n                    std::string value(c+1);\n                    key   = key.substr(0,c-h);\n                    value = value.substr(0,first_newline-c-1);\n                    response[key]=value;\n                    h = first_newline+1;\n                    c = strchr(h,C);\n                    first_newline = strchr(h,N);\n                }\n            }\n\n            // if the bufffer's full and we're still searching - give up!\n            // this handles the possibility that there are no headers\n            if ( bSearching && buff_l-end < 10 ) {\n                bSearching = false ;\n                body  = 0 ;\n            }\n            if ( !bSearching && OK(status) ) {\n                flushBuffer(buffer,body,end,file);\n            }\n        }\n        n=forgive(recv(sockfd,buffer+end,(int)(buff_l-end),0),err) ;\n        if ( !n ) {\n            Sleep(snooze) ;\n            sleep_ -= snooze ;\n            if ( sleep_ < 0 ) n = FINISH ;\n        }\n    }\n\n    if ( n != FINISH || !OK(status) ) {\n        snprintf(buffer,sizeof buffer,\"wsa_error = %d,n = %d,sleep_ = %d status = %d\"\n                ,   WSAGetLastError()\n                ,   n\n                ,   sleep_\n                ,   status\n                ) ;\n        error(errors,buffer,NULL,NULL,0) ;\n    } else if ( bSearching && OK(status) ) {\n        if ( end ) {\n        //  we finished OK without finding headers, flush the buffer\n            flushBuffer(buffer,0,end,file) ;\n        } else {\n            return error(errors,\"error - no response from server = %s port = %s wsa_error = %d\",servername,port,WSAGetLastError());\n        }\n    }\n\n    ////////////////////////////////////\n    // close sockets\n    closesocket(server) ;\n    closesocket(sockfd) ;\n    response[\"body\"]=file;\n    return result;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145574,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int Exiv2::http(Exiv2::Dictionary& request,Exiv2::Dictionary& response,std::string& errors)\n{\n    if ( !request.count(\"verb\")   ) request[\"verb\"   ] = \"GET\";\n    if ( !request.count(\"header\") ) request[\"header\" ] = \"\"   ;\n    if ( !request.count(\"version\")) request[\"version\"] = \"1.0\";\n    if ( !request.count(\"port\")   ) request[\"port\"   ] = \"\"   ;\n\n    std::string file;\n    errors     = \"\";\n    int result = 0;\n\n    ////////////////////////////////////\n    // Windows specific code\n#ifdef WIN32\n    WSADATA wsaData;\n    WSAStartup(MAKEWORD(2,2), &wsaData);\n#endif\n\n    const char* servername = request[\"server\" ].c_str();\n    const char* page       = request[\"page\"   ].c_str();\n    const char* verb       = request[\"verb\"   ].c_str();\n    const char* header     = request[\"header\" ].c_str();\n    const char* version    = request[\"version\"].c_str();\n    const char* port       = request[\"port\"   ].c_str();\n\n    const char* servername_p = servername;\n    const char* port_p       = port      ;\n    std::string url = std::string(\"http://\") + request[\"server\"] + request[\"page\"];\n\n    // parse and change server if using a proxy\n    const char* PROXI  = \"HTTP_PROXY\";\n    const char* proxi  = \"http_proxy\";\n    const char* PROXY  = getenv(PROXI);\n    const char* proxy  = getenv(proxi);\n    bool        bProx  = PROXY || proxy;\n    const char* prox   = bProx ? (proxy?proxy:PROXY):\"\";\n    Exiv2::Uri  Proxy  =  Exiv2::Uri::Parse(prox);\n\n    // find the dictionary of no_proxy servers\n    const char* NO_PROXI = \"NO_PROXY\";\n    const char* no_proxi = \"no_proxy\";\n    const char* NO_PROXY = getenv(NO_PROXI);\n    const char* no_proxy = getenv(no_proxi);\n    bool        bNoProxy = NO_PROXY||no_proxy;\n    std::string no_prox  = std::string(bNoProxy?(no_proxy?no_proxy:NO_PROXY):\"\");\n    Exiv2::Dictionary noProxy= stringToDict(no_prox + \",localhost,127.0.0.1\");\n\n    // if the server is on the no_proxy list ... ignore the proxy!\n    if ( noProxy.count(servername) ) bProx = false;\n\n    if (  bProx ) {\n        servername_p = Proxy.Host.c_str();\n        port_p       = Proxy.Port.c_str();\n        page         = url.c_str();\n        std::string  p(proxy?proxi:PROXI);\n    //  std::cerr << p << '=' << prox << \" page = \" << page << std::endl;\n    }\n    if ( !port  [0] ) port   = \"80\";\n    if ( !port_p[0] ) port_p = \"80\";\n\n    ////////////////////////////////////\n    // open the socket\n    int     sockfd = (int) socket(AF_INET , SOCK_STREAM,IPPROTO_TCP) ;\n    if (    sockfd < 0 ) return error(errors, \"unable to create socket\\n\",NULL,NULL,0) ;\n\n    // connect the socket to the server\n    int     server  = -1 ;\n\n    // fill in the address\n    struct  sockaddr_in serv_addr   ;\n    int                 serv_len = sizeof(serv_addr);\n    memset((char *)&serv_addr,0,serv_len);\n\n    serv_addr.sin_addr.s_addr   = inet_addr(servername_p);\n    serv_addr.sin_family        = AF_INET    ;\n    serv_addr.sin_port          = htons(atoi(port_p));\n\n    // convert unknown servername into IP address\n    // http://publib.boulder.ibm.com/infocenter/iseries/v5r3/index.jsp?topic=/rzab6/rzab6uafinet.htm\n    if (serv_addr.sin_addr.s_addr == (unsigned long)INADDR_NONE)\n    {\n        struct hostent* host = gethostbyname(servername_p);\n        if ( !host )  return error(errors, \"no such host\", servername_p);\n        memcpy(&serv_addr.sin_addr,host->h_addr,sizeof(serv_addr.sin_addr));\n    }\n\n    makeNonBlocking(sockfd) ;\n\n    ////////////////////////////////////\n    // and connect\n    server = connect(sockfd, (const struct sockaddr *) &serv_addr, serv_len) ;\n    if ( server == SOCKET_ERROR && WSAGetLastError() != WSAEWOULDBLOCK )\n        return error(errors,\"error - unable to connect to server = %s port = %s wsa_error = %d\",servername_p,port_p,WSAGetLastError());\n\n    char   buffer[32*1024+1];\n    size_t buff_l= sizeof buffer - 1 ;\n\n    ////////////////////////////////////\n    // format the request\n    int    n  = snprintf(buffer,buff_l,httpTemplate,verb,page,version,servername,header) ;\n    buffer[n] = 0 ;\n    response[\"requestheaders\"]=std::string(buffer,n);\n\n\n    ////////////////////////////////////\n    // send the header (we'll have to wait for the connection by the non-blocking socket)\n    while ( sleep_ >= 0 && send(sockfd,buffer,n,0) == SOCKET_ERROR /* && WSAGetLastError() == WSAENOTCONN */ ) {\n        Sleep(snooze) ;\n        sleep_ -= snooze ;\n    }\n\n    if ( sleep_ < 0 )\n        return error(errors,\"error - timeout connecting to server = %s port = %s wsa_error = %d\",servername,port,WSAGetLastError());\n\n    int    end   = 0         ; // write position in buffer\n    bool   bSearching = true ; // looking for headers in the response\n    int    status= 200       ; // assume happiness\n\n    ////////////////////////////////////\n    // read and process the response\n    int err ;\n    n=forgive(recv(sockfd,buffer,(int)buff_l,0),err) ;\n    while ( n >= 0 && OK(status) ) {\n        if ( n ) {\n            end += n ;\n            buffer[end] = 0 ;\n\n            size_t body = 0         ; // start of body\n            if ( bSearching ) {\n\n                // search for the body\n                for ( size_t b = 0 ; bSearching && b < lengthof(blankLines) ; b++ ) {\n                    const char* blankLinePos = strstr(buffer,blankLines[b]);\n                    if ( blankLinePos ) {\n                        bSearching = false ;\n                        body   = blankLinePos - buffer + strlen(blankLines[b]);\n                        const char* firstSpace = strchr(buffer,' ');\n                        if (firstSpace) {\n                            status = atoi(firstSpace);\n                        }\n                    }\n                }\n\n                // parse response headers\n                char* h = buffer;\n                char  C = ':' ;\n                char  N = '\\n';\n                int   i = 0   ; // initial byte in buffer\n                while(buffer[i] == N ) i++;\n                h = strchr(h+i,N);\n                if (!h) {\n                    status = 0;\n                    break;\n                }\n                h++;\n                response[\"\"]=std::string(buffer+i).substr(0,h-buffer-2);\n                const char* firstSpace = strchr(buffer,' ');\n                if ( !firstSpace ) {\n                    status = 0;\n                    break;\n                }\n                result = atoi(firstSpace);\n                char* c = strchr(h,C);\n                char* first_newline = strchr(h,N);\n                while ( c && first_newline && c < first_newline && h < buffer+body ) {\n                    std::string key(h);\n                    std::string value(c+1);\n                    key   = key.substr(0,c-h);\n                    value = value.substr(0,first_newline-c-1);\n                    response[key]=value;\n                    h = first_newline+1;\n                    c = strchr(h,C);\n                    first_newline = strchr(h,N);\n                }\n            }\n\n            // if the bufffer's full and we're still searching - give up!\n            // this handles the possibility that there are no headers\n            if ( bSearching && buff_l-end < 10 ) {\n                bSearching = false ;\n                body  = 0 ;\n            }\n            if ( !bSearching && OK(status) ) {\n                flushBuffer(buffer,body,end,file);\n            }\n        }\n        n=forgive(recv(sockfd,buffer+end,(int)(buff_l-end),0),err) ;\n        if ( !n ) {\n            Sleep(snooze) ;\n            sleep_ -= snooze ;\n            if ( sleep_ < 0 ) n = FINISH ;\n        }\n    }\n\n    if ( n != FINISH || !OK(status) ) {\n        snprintf(buffer,sizeof buffer,\"wsa_error = %d,n = %d,sleep_ = %d status = %d\"\n                ,   WSAGetLastError()\n                ,   n\n                ,   sleep_\n                ,   status\n                ) ;\n        error(errors,buffer,NULL,NULL,0) ;\n    } else if ( bSearching && OK(status) ) {\n        if ( end ) {\n        //  we finished OK without finding headers, flush the buffer\n            flushBuffer(buffer,0,end,file) ;\n        } else {\n            return error(errors,\"error - no response from server = %s port = %s wsa_error = %d\",servername,port,WSAGetLastError());\n        }\n    }\n\n    ////////////////////////////////////\n    // close sockets\n    closesocket(server) ;\n    closesocket(sockfd) ;\n    response[\"body\"]=file;\n    return result;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145575,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int CLASS parse_tiff_ifd(int base)\n{\n  unsigned entries, tag, type, len, plen = 16, save;\n  int ifd, use_cm = 0, cfa, i, j, c, ima_len = 0;\n  char *cbuf, *cp;\n  uchar cfa_pat[16], cfa_pc[] = {0, 1, 2, 3}, tab[256];\n  double fm[3][4], cc[4][4], cm[4][3], cam_xyz[4][3], num;\n  double ab[] = {1, 1, 1, 1}, asn[] = {0, 0, 0, 0}, xyz[] = {1, 1, 1};\n  unsigned sony_curve[] = {0, 0, 0, 0, 0, 4095};\n  unsigned *buf, sony_offset = 0, sony_length = 0, sony_key = 0;\n  struct jhead jh;\n  int pana_raw = 0;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *sfp;\n#endif\n\n  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n    return 1;\n  ifd = tiff_nifds++;\n  for (j = 0; j < 4; j++)\n    for (i = 0; i < 4; i++)\n      cc[j][i] = i == j;\n  entries = get2();\n  if (entries > 512)\n    return 1;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n#endif\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && len + savepos > fsize * 2)\n      continue; // skip tag pointing out of 2xfile\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data, tag | (pana_raw ? 0x30000 : 0), type, len, order, ifp);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strncasecmp(make, \"SONY\", 4) ||\n        (!strncasecmp(make, \"Hasselblad\", 10) &&\n         (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) || !strncasecmp(model, \"HV\", 2))))\n    {\n      switch (tag)\n      {\n      case 0x7300: // SR2 black level\n        for (int i = 0; i < 4 && i < len; i++)\n          cblack[i] = get2();\n        break;\n      case 0x7480:\n      case 0x7820:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n        break;\n      case 0x7481:\n      case 0x7821:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1];\n        break;\n      case 0x7482:\n      case 0x7822:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n        break;\n      case 0x7483:\n      case 0x7823:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1];\n        break;\n      case 0x7484:\n      case 0x7824:\n        imgdata.color.WBCT_Coeffs[0][0] = 4500;\n        FORC3 imgdata.color.WBCT_Coeffs[0][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[0][4] = imgdata.color.WBCT_Coeffs[0][2];\n        break;\n      case 0x7486:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n        break;\n      case 0x7825:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n        break;\n      case 0x7826:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1];\n        break;\n      case 0x7827:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1];\n        break;\n      case 0x7828:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1];\n        break;\n      case 0x7829:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1];\n        break;\n      case 0x782a:\n        imgdata.color.WBCT_Coeffs[1][0] = 8500;\n        FORC3 imgdata.color.WBCT_Coeffs[1][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[1][4] = imgdata.color.WBCT_Coeffs[1][2];\n        break;\n      case 0x782b:\n        imgdata.color.WBCT_Coeffs[2][0] = 6000;\n        FORC3 imgdata.color.WBCT_Coeffs[2][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[2][4] = imgdata.color.WBCT_Coeffs[2][2];\n        break;\n      case 0x782c:\n        imgdata.color.WBCT_Coeffs[3][0] = 3200;\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][c] = imgdata.color.WBCT_Coeffs[3][c + 1] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][3] = imgdata.color.WBCT_Coeffs[3][4] =\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][1];\n        break;\n      case 0x782d:\n        imgdata.color.WBCT_Coeffs[4][0] = 2500;\n        FORC3 imgdata.color.WBCT_Coeffs[4][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[4][4] = imgdata.color.WBCT_Coeffs[4][2];\n        break;\n      case 0x787f:\n        FORC3 imgdata.color.linear_max[c] = get2();\n        imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n        break;\n      }\n    }\n#endif\n\n    switch (tag)\n    {\n    case 1:\n      if (len == 4)\n        pana_raw = get4();\n      break;\n    case 5:\n      width = get2();\n      break;\n    case 6:\n      height = get2();\n      break;\n    case 7:\n      width += get2();\n      break;\n    case 9:\n      if ((i = get2()))\n        filters = i;\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw && len == 1 && type == 3)\n        pana_black[3] += i;\n#endif\n      break;\n    case 8:\n    case 10:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw && len == 1 && type == 3)\n        pana_black[3] += get2();\n#endif\n      break;\n    case 14:\n    case 15:\n    case 16:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw)\n      {\n        imgdata.color.linear_max[tag - 14] = get2();\n        if (tag == 15)\n          imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n      }\n#endif\n      break;\n    case 17:\n    case 18:\n      if (type == 3 && len == 1)\n        cam_mul[(tag - 17) * 2] = get2() / 256.0;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 19:\n      if (pana_raw)\n      {\n        ushort nWB, cnt, tWB;\n        nWB = get2();\n        if (nWB > 0x100)\n          break;\n        for (cnt = 0; cnt < nWB; cnt++)\n        {\n          tWB = get2();\n          if (tWB < 0x100)\n          {\n            imgdata.color.WB_Coeffs[tWB][0] = get2();\n            imgdata.color.WB_Coeffs[tWB][2] = get2();\n            imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = 0x100;\n          }\n          else\n            get4();\n        }\n      }\n      break;\n#endif\n    case 23:\n      if (type == 3)\n        iso_speed = get2();\n      break;\n    case 28:\n    case 29:\n    case 30:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw && len == 1 && type == 3)\n      {\n        pana_black[tag - 28] = get2();\n      }\n      else\n#endif\n      {\n        cblack[tag - 28] = get2();\n        cblack[3] = cblack[1];\n      }\n      break;\n    case 36:\n    case 37:\n    case 38:\n      cam_mul[tag - 36] = get2();\n      break;\n    case 39:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw)\n      {\n        ushort nWB, cnt, tWB;\n        nWB = get2();\n        if (nWB > 0x100)\n          break;\n        for (cnt = 0; cnt < nWB; cnt++)\n        {\n          tWB = get2();\n          if (tWB < 0x100)\n          {\n            imgdata.color.WB_Coeffs[tWB][0] = get2();\n            imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = get2();\n            imgdata.color.WB_Coeffs[tWB][2] = get2();\n          }\n          else\n            fseek(ifp, 6, SEEK_CUR);\n        }\n      }\n      break;\n#endif\n      if (len < 50 || cam_mul[0])\n        break;\n      fseek(ifp, 12, SEEK_CUR);\n      FORC3 cam_mul[c] = get2();\n      break;\n    case 46:\n      if (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n        break;\n      thumb_offset = ftell(ifp) - 2;\n      thumb_length = len;\n      break;\n    case 61440: /* Fuji HS10 table */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 2:\n    case 256:\n    case 61441: /* ImageWidth */\n      tiff_ifd[ifd].t_width = getint(type);\n      break;\n    case 3:\n    case 257:\n    case 61442: /* ImageHeight */\n      tiff_ifd[ifd].t_height = getint(type);\n      break;\n    case 258: /* BitsPerSample */\n    case 61443:\n      tiff_ifd[ifd].samples = len & 7;\n      tiff_ifd[ifd].bps = getint(type);\n      if (tiff_bps < tiff_ifd[ifd].bps)\n        tiff_bps = tiff_ifd[ifd].bps;\n      break;\n    case 61446:\n      raw_height = 0;\n      if (tiff_ifd[ifd].bps > 12)\n        break;\n      load_raw = &CLASS packed_load_raw;\n      load_flags = get4() ? 24 : 80;\n      break;\n    case 259: /* Compression */\n      tiff_ifd[ifd].comp = getint(type);\n      break;\n    case 262: /* PhotometricInterpretation */\n      tiff_ifd[ifd].phint = get2();\n      break;\n    case 270: /* ImageDescription */\n      fread(desc, 512, 1, ifp);\n      break;\n    case 271: /* Make */\n      fgets(make, 64, ifp);\n      break;\n    case 272: /* Model */\n      fgets(model, 64, ifp);\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 278:\n      tiff_ifd[ifd].rows_per_strip = getint(type);\n      break;\n#endif\n    case 280: /* Panasonic RW2 offset */\n      if (type != 4)\n        break;\n      load_raw = &CLASS panasonic_load_raw;\n      load_flags = 0x2008;\n    case 273: /* StripOffset */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (len > 1 && len < 16384)\n      {\n        off_t sav = ftell(ifp);\n        tiff_ifd[ifd].strip_offsets = (int *)calloc(len, sizeof(int));\n        tiff_ifd[ifd].strip_offsets_count = len;\n        for (int i = 0; i < len; i++)\n          tiff_ifd[ifd].strip_offsets[i] = get4() + base;\n        fseek(ifp, sav, SEEK_SET); // restore position\n      }\n/* fallback */\n#endif\n    case 513: /* JpegIFOffset */\n    case 61447:\n      tiff_ifd[ifd].offset = get4() + base;\n      if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0)\n      {\n        fseek(ifp, tiff_ifd[ifd].offset, SEEK_SET);\n        if (ljpeg_start(&jh, 1))\n        {\n          tiff_ifd[ifd].comp = 6;\n          tiff_ifd[ifd].t_width = jh.wide;\n          tiff_ifd[ifd].t_height = jh.high;\n          tiff_ifd[ifd].bps = jh.bits;\n          tiff_ifd[ifd].samples = jh.clrs;\n          if (!(jh.sraw || (jh.clrs & 1)))\n            tiff_ifd[ifd].t_width *= jh.clrs;\n          if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)\n          {\n            tiff_ifd[ifd].t_width /= 2;\n            tiff_ifd[ifd].t_height *= 2;\n          }\n          i = order;\n          parse_tiff(tiff_ifd[ifd].offset + 12);\n          order = i;\n        }\n      }\n      break;\n    case 274: /* Orientation */\n      tiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7] - '0';\n      break;\n    case 277: /* SamplesPerPixel */\n      tiff_ifd[ifd].samples = getint(type) & 7;\n      break;\n    case 279: /* StripByteCounts */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (len > 1 && len < 16384)\n      {\n        off_t sav = ftell(ifp);\n        tiff_ifd[ifd].strip_byte_counts = (int *)calloc(len, sizeof(int));\n        tiff_ifd[ifd].strip_byte_counts_count = len;\n        for (int i = 0; i < len; i++)\n          tiff_ifd[ifd].strip_byte_counts[i] = get4();\n        fseek(ifp, sav, SEEK_SET); // restore position\n      }\n/* fallback */\n#endif\n    case 514:\n    case 61448:\n      tiff_ifd[ifd].bytes = get4();\n      break;\n    case 61454:\n      FORC3 cam_mul[(4 - c) % 3] = getint(type);\n      break;\n    case 305:\n    case 11: /* Software */\n      fgets(software, 64, ifp);\n      if (!strncmp(software, \"Adobe\", 5) || !strncmp(software, \"dcraw\", 5) || !strncmp(software, \"UFRaw\", 5) ||\n          !strncmp(software, \"Bibble\", 6) || !strcmp(software, \"Digital Photo Professional\"))\n        is_raw = 0;\n      break;\n    case 306: /* DateTime */\n      get_timestamp(0);\n      break;\n    case 315: /* Artist */\n      fread(artist, 64, 1, ifp);\n      break;\n    case 317:\n      tiff_ifd[ifd].predictor = getint(type);\n      break;\n    case 322: /* TileWidth */\n      tiff_ifd[ifd].t_tile_width = getint(type);\n      break;\n    case 323: /* TileLength */\n      tiff_ifd[ifd].t_tile_length = getint(type);\n      break;\n    case 324: /* TileOffsets */\n      tiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();\n      if (len == 1)\n        tiff_ifd[ifd].t_tile_width = tiff_ifd[ifd].t_tile_length = 0;\n      if (len == 4)\n      {\n        load_raw = &CLASS sinar_4shot_load_raw;\n        is_raw = 5;\n      }\n      break;\n    case 325:\n      tiff_ifd[ifd].bytes = len > 1 ? ftell(ifp) : get4();\n      break;\n    case 330: /* SubIFDs */\n      if (!strcmp(model, \"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872)\n      {\n        load_raw = &CLASS sony_arw_load_raw;\n        data_offset = get4() + base;\n        ifd++;\n        break;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (!strncmp(make, \"Hasselblad\", 10) && libraw_internal_data.unpacker_data.hasselblad_parser_flag)\n      {\n        fseek(ifp, ftell(ifp) + 4, SEEK_SET);\n        fseek(ifp, get4() + base, SEEK_SET);\n        parse_tiff_ifd(base);\n        break;\n      }\n#endif\n      if (len > 1000)\n        len = 1000; /* 1000 SubIFDs is enough */\n      while (len--)\n      {\n        i = ftell(ifp);\n        fseek(ifp, get4() + base, SEEK_SET);\n        if (parse_tiff_ifd(base))\n          break;\n        fseek(ifp, i + 4, SEEK_SET);\n      }\n      break;\n    case 339:\n      tiff_ifd[ifd].sample_format = getint(type);\n      break;\n    case 400:\n      strcpy(make, \"Sarnoff\");\n      maximum = 0xfff;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 700:\n      if ((type == 1 || type == 2 || type == 6 || type == 7) && len > 1 && len < 5100000)\n      {\n        xmpdata = (char *)malloc(xmplen = len + 1);\n        fread(xmpdata, len, 1, ifp);\n        xmpdata[len] = 0;\n      }\n      break;\n#endif\n    case 28688:\n      FORC4 sony_curve[c + 1] = get2() >> 2 & 0xfff;\n      for (i = 0; i < 5; i++)\n        for (j = sony_curve[i] + 1; j <= sony_curve[i + 1]; j++)\n          curve[j] = curve[j - 1] + (1 << i);\n      break;\n    case 29184:\n      sony_offset = get4();\n      break;\n    case 29185:\n      sony_length = get4();\n      break;\n    case 29217:\n      sony_key = get4();\n      break;\n    case 29264:\n      parse_minolta(ftell(ifp));\n      raw_width = 0;\n      break;\n    case 29443:\n      FORC4 cam_mul[c ^ (c < 2)] = get2();\n      break;\n    case 29459:\n      FORC4 cam_mul[c] = get2();\n      i = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;\n      SWAP(cam_mul[i], cam_mul[i + 1])\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 30720: // Sony matrix, Sony_SR2SubIFD_0x7800\n      for (i = 0; i < 3; i++)\n      {\n        float num = 0.0;\n        for (c = 0; c < 3; c++)\n        {\n          imgdata.color.ccm[i][c] = (float)((short)get2());\n          num += imgdata.color.ccm[i][c];\n        }\n        if (num > 0.01)\n          FORC3 imgdata.color.ccm[i][c] = imgdata.color.ccm[i][c] / num;\n      }\n      break;\n#endif\n    case 29456: // Sony black level, Sony_SR2SubIFD_0x7310, no more needs to be divided by 4\n      FORC4 cblack[c ^ c >> 1] = get2();\n      i = cblack[3];\n      FORC3 if (i > cblack[c]) i = cblack[c];\n      FORC4 cblack[c] -= i;\n      black = i;\n\n#ifdef DCRAW_VERBOSE\n      if (verbose)\n        fprintf(stderr, _(\"...Sony black: %u cblack: %u %u %u %u\\n\"), black, cblack[0], cblack[1], cblack[2],\n                cblack[3]);\n#endif\n      break;\n    case 33405: /* Model2 */\n      fgets(model2, 64, ifp);\n      break;\n    case 33421: /* CFARepeatPatternDim */\n      if (get2() == 6 && get2() == 6)\n        filters = 9;\n      break;\n    case 33422: /* CFAPattern */\n      if (filters == 9)\n      {\n        FORC(36)((char *)xtrans)[c] = fgetc(ifp) & 3;\n        break;\n      }\n    case 64777: /* Kodak P-series */\n      if (len == 36)\n      {\n        filters = 9;\n        colors = 3;\n        FORC(36) xtrans[0][c] = fgetc(ifp) & 3;\n      }\n      else if (len > 0)\n      {\n        if ((plen = len) > 16)\n          plen = 16;\n        fread(cfa_pat, 1, plen, ifp);\n        for (colors = cfa = i = 0; i < plen && colors < 4; i++)\n        {\n          colors += !(cfa & (1 << cfa_pat[i]));\n          cfa |= 1 << cfa_pat[i];\n        }\n        if (cfa == 070)\n          memcpy(cfa_pc, \"\\003\\004\\005\", 3); /* CMY */\n        if (cfa == 072)\n          memcpy(cfa_pc, \"\\005\\003\\004\\001\", 4); /* GMCY */\n        goto guess_cfa_pc;\n      }\n      break;\n    case 33424:\n    case 65024:\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_kodak_ifd(base);\n      break;\n    case 33434: /* ExposureTime */\n      tiff_ifd[ifd].t_shutter = shutter = getreal(type);\n      break;\n    case 33437: /* FNumber */\n      aperture = getreal(type);\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    // IB start\n    case 0xa405: // FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431: // BodySerialNumber\n    case 0xc62f:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435: // LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa433: // LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434: // LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = powf64(2.0f, (getreal(type) / 2.0f));\n      break;\n// IB end\n#endif\n    case 34306: /* Leaf white balance */\n      FORC4 cam_mul[c ^ 1] = 4096.0 / get2();\n      break;\n    case 34307: /* Leaf CatchLight color matrix */\n      fread(software, 1, 7, ifp);\n      if (strncmp(software, \"MATRIX\", 6))\n        break;\n      colors = 4;\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        FORC4 fscanf(ifp, \"%f\", &rgb_cam[i][c ^ 1]);\n        if (!use_camera_wb)\n          continue;\n        num = 0;\n        FORC4 num += rgb_cam[i][c];\n        FORC4 rgb_cam[i][c] /= MAX(1, num);\n      }\n      break;\n    case 34310: /* Leaf metadata */\n      parse_mos(ftell(ifp));\n    case 34303:\n      strcpy(make, \"Leaf\");\n      break;\n    case 34665: /* EXIF tag */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_exif(base);\n      break;\n    case 34853: /* GPSInfo tag */\n    {\n      unsigned pos;\n      fseek(ifp, pos = (get4() + base), SEEK_SET);\n      parse_gps(base);\n#ifdef LIBRAW_LIBRARY_BUILD\n      fseek(ifp, pos, SEEK_SET);\n      parse_gps_libraw(base);\n#endif\n    }\n    break;\n    case 34675: /* InterColorProfile */\n    case 50831: /* AsShotICCProfile */\n      profile_offset = ftell(ifp);\n      profile_length = len;\n      break;\n    case 37122: /* CompressedBitsPerPixel */\n      kodak_cbpp = get4();\n      break;\n    case 37386: /* FocalLength */\n      focal_len = getreal(type);\n      break;\n    case 37393: /* ImageNumber */\n      shot_order = getint(type);\n      break;\n    case 37400: /* old Kodak KDC tag */\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        getreal(type);\n        FORC3 rgb_cam[i][c] = getreal(type);\n      }\n      break;\n    case 40976:\n      strip_offset = get4();\n      switch (tiff_ifd[ifd].comp)\n      {\n      case 32770:\n        load_raw = &CLASS samsung_load_raw;\n        break;\n      case 32772:\n        load_raw = &CLASS samsung2_load_raw;\n        break;\n      case 32773:\n        load_raw = &CLASS samsung3_load_raw;\n        break;\n      }\n      break;\n    case 46275: /* Imacon tags */\n      strcpy(make, \"Imacon\");\n      data_offset = ftell(ifp);\n      ima_len = len;\n      break;\n    case 46279:\n      if (!ima_len)\n        break;\n      fseek(ifp, 38, SEEK_CUR);\n    case 46274:\n      fseek(ifp, 40, SEEK_CUR);\n      raw_width = get4();\n      raw_height = get4();\n      left_margin = get4() & 7;\n      width = raw_width - left_margin - (get4() & 7);\n      top_margin = get4() & 7;\n      height = raw_height - top_margin - (get4() & 7);\n      if (raw_width == 7262 && ima_len == 234317952)\n      {\n        height = 5412;\n        width = 7216;\n        left_margin = 7;\n        filters = 0;\n      }\n      else if (raw_width == 7262)\n      {\n        height = 5444;\n        width = 7244;\n        left_margin = 7;\n      }\n      fseek(ifp, 52, SEEK_CUR);\n      FORC3 cam_mul[c] = getreal(11);\n      fseek(ifp, 114, SEEK_CUR);\n      flip = (get2() >> 7) * 90;\n      if (width * height * 6 == ima_len)\n      {\n        if (flip % 180 == 90)\n          SWAP(width, height);\n        raw_width = width;\n        raw_height = height;\n        left_margin = top_margin = filters = flip = 0;\n      }\n      sprintf(model, \"Ixpress %d-Mp\", height * width / 1000000);\n      load_raw = &CLASS imacon_full_load_raw;\n      if (filters)\n      {\n        if (left_margin & 1)\n          filters = 0x61616161;\n        load_raw = &CLASS unpacked_load_raw;\n      }\n      maximum = 0xffff;\n      break;\n    case 50454: /* Sinar tag */\n    case 50455:\n      if (len > 2560000 || !(cbuf = (char *)malloc(len)))\n        break;\n#ifndef LIBRAW_LIBRARY_BUILD\n      fread(cbuf, 1, len, ifp);\n#else\n      if (fread(cbuf, 1, len, ifp) != len)\n        throw LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle\n#endif\n      cbuf[len - 1] = 0;\n      for (cp = cbuf - 1; cp && cp < cbuf + len; cp = strchr(cp, '\\n'))\n        if (!strncmp(++cp, \"Neutral \", 8))\n          sscanf(cp + 8, \"%f %f %f\", cam_mul, cam_mul + 1, cam_mul + 2);\n      free(cbuf);\n      break;\n    case 50458:\n      if (!make[0])\n        strcpy(make, \"Hasselblad\");\n      break;\n    case 50459: /* Hasselblad tag */\n#ifdef LIBRAW_LIBRARY_BUILD\n      libraw_internal_data.unpacker_data.hasselblad_parser_flag = 1;\n#endif\n      i = order;\n      j = ftell(ifp);\n      c = tiff_nifds;\n      order = get2();\n      fseek(ifp, j + (get2(), get4()), SEEK_SET);\n      parse_tiff_ifd(j);\n      maximum = 0xffff;\n      tiff_nifds = c;\n      order = i;\n      break;\n    case 50706: /* DNGVersion */\n      FORC4 dng_version = (dng_version << 8) + fgetc(ifp);\n      if (!make[0])\n        strcpy(make, \"DNG\");\n      is_raw = 1;\n      break;\n    case 50708: /* UniqueCameraModel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      stmread(imgdata.color.UniqueCameraModel, len, ifp);\n      imgdata.color.UniqueCameraModel[sizeof(imgdata.color.UniqueCameraModel) - 1] = 0;\n#endif\n      if (model[0])\n        break;\n#ifndef LIBRAW_LIBRARY_BUILD\n      fgets(make, 64, ifp);\n#else\n      strncpy(make, imgdata.color.UniqueCameraModel, MIN(len, sizeof(imgdata.color.UniqueCameraModel)));\n#endif\n      if ((cp = strchr(make, ' ')))\n      {\n        strcpy(model, cp + 1);\n        *cp = 0;\n      }\n      break;\n    case 50710: /* CFAPlaneColor */\n      if (filters == 9)\n        break;\n      if (len > 4)\n        len = 4;\n      colors = len;\n      fread(cfa_pc, 1, colors, ifp);\n    guess_cfa_pc:\n      FORCC tab[cfa_pc[c]] = c;\n      cdesc[c] = 0;\n      for (i = 16; i--;)\n        filters = filters << 2 | tab[cfa_pat[i % plen]];\n      filters -= !filters;\n      break;\n    case 50711: /* CFALayout */\n      if (get2() == 2)\n        fuji_width = 1;\n      break;\n    case 291:\n    case 50712: /* LinearizationTable */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].lineartable_offset = ftell(ifp);\n      tiff_ifd[ifd].lineartable_len = len;\n#endif\n      linear_table(len);\n      break;\n    case 50713: /* BlackLevelRepeatDim */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_cblack[4] =\n#endif\n          cblack[4] = get2();\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_cblack[5] =\n#endif\n          cblack[5] = get2();\n      if (cblack[4] * cblack[5] > (sizeof(cblack) / sizeof(cblack[0]) - 6))\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.dng_cblack[4] = tiff_ifd[ifd].dng_levels.dng_cblack[5] =\n#endif\n            cblack[4] = cblack[5] = 1;\n      break;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0xf00c:\n    {\n      unsigned fwb[4];\n      FORC4 fwb[c] = get4();\n      if (fwb[3] < 0x100)\n      {\n        imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n        imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n        imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n        if ((fwb[3] == 17) && libraw_internal_data.unpacker_data.lenRAFData > 3 &&\n            libraw_internal_data.unpacker_data.lenRAFData < 10240000)\n        {\n          long long f_save = ftell(ifp);\n          int fj, found = 0;\n          ushort *rafdata = (ushort *)malloc(sizeof(ushort) * libraw_internal_data.unpacker_data.lenRAFData);\n          fseek(ifp, libraw_internal_data.unpacker_data.posRAFData, SEEK_SET);\n          fread(rafdata, sizeof(ushort), libraw_internal_data.unpacker_data.lenRAFData, ifp);\n          fseek(ifp, f_save, SEEK_SET);\n          for (int fi = 0; fi < (libraw_internal_data.unpacker_data.lenRAFData - 3); fi++)\n          {\n            if ((fwb[0] == rafdata[fi]) && (fwb[1] == rafdata[fi + 1]) && (fwb[2] == rafdata[fi + 2]))\n            {\n              if (rafdata[fi - 15] != fwb[0])\n                continue;\n              fi = fi - 15;\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][3] =\n                  rafdata[fi];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = rafdata[fi + 1];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = rafdata[fi + 2];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =\n                  rafdata[fi + 3];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = rafdata[fi + 4];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = rafdata[fi + 5];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =\n                  rafdata[fi + 6];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = rafdata[fi + 7];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = rafdata[fi + 8];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] =\n                  rafdata[fi + 9];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][0] = rafdata[fi + 10];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][2] = rafdata[fi + 11];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =\n                  rafdata[fi + 12];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = rafdata[fi + 13];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = rafdata[fi + 14];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =\n                  rafdata[fi + 15];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = rafdata[fi + 16];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = rafdata[fi + 17];\n\n              fi += 111;\n              for (fj = fi; fj < (fi + 15); fj += 3)\n                if (rafdata[fj] != rafdata[fi])\n                {\n                  found = 1;\n                  break;\n                }\n              if (found)\n              {\n                int FujiCCT_K[31] = {2500, 2550, 2650, 2700, 2800, 2850, 2950, 3000, 3100, 3200, 3300,\n                                     3400, 3600, 3700, 3800, 4000, 4200, 4300, 4500, 4800, 5000, 5300,\n                                     5600, 5900, 6300, 6700, 7100, 7700, 8300, 9100, 10000};\n                fj = fj - 93;\n                for (int iCCT = 0; iCCT < 31; iCCT++)\n                {\n                  imgdata.color.WBCT_Coeffs[iCCT][0] = FujiCCT_K[iCCT];\n                  imgdata.color.WBCT_Coeffs[iCCT][1] = rafdata[iCCT * 3 + 1 + fj];\n                  imgdata.color.WBCT_Coeffs[iCCT][2] = imgdata.color.WBCT_Coeffs[iCCT][4] = rafdata[iCCT * 3 + fj];\n                  imgdata.color.WBCT_Coeffs[iCCT][3] = rafdata[iCCT * 3 + 2 + fj];\n                }\n              }\n              free(rafdata);\n              break;\n            }\n          }\n        }\n      }\n      FORC4 fwb[c] = get4();\n      if (fwb[3] < 0x100)\n      {\n        imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n        imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n        imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n      }\n    }\n    break;\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50709:\n      stmread(imgdata.color.LocalizedCameraModel, len, ifp);\n      break;\n#endif\n\n    case 61450:\n      cblack[4] = cblack[5] = MIN(sqrt((double)len), 64);\n    case 50714: /* BlackLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tiff_ifd[ifd].samples > 1 && tiff_ifd[ifd].samples == len) // LinearDNG, per-channel black\n      {\n        for (i = 0; i < colors && i < 4 && i < len; i++)\n          tiff_ifd[ifd].dng_levels.dng_cblack[i] = cblack[i] = getreal(type) + 0.5;\n\n        tiff_ifd[ifd].dng_levels.dng_black = black = 0;\n      }\n      else\n#endif\n          if ((cblack[4] * cblack[5] < 2) && len == 1)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.dng_black =\n#endif\n            black = getreal(type);\n      }\n      else if (cblack[4] * cblack[5] <= len)\n      {\n        FORC(cblack[4] * cblack[5])\n        cblack[6 + c] = getreal(type);\n        black = 0;\n        FORC4\n        cblack[c] = 0;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (tag == 50714)\n        {\n          FORC(cblack[4] * cblack[5])\n          tiff_ifd[ifd].dng_levels.dng_cblack[6 + c] = cblack[6 + c];\n          tiff_ifd[ifd].dng_levels.dng_black = 0;\n          FORC4\n          tiff_ifd[ifd].dng_levels.dng_cblack[c] = 0;\n        }\n#endif\n      }\n      break;\n    case 50715: /* BlackLevelDeltaH */\n    case 50716: /* BlackLevelDeltaV */\n      for (num = i = 0; i < len && i < 65536; i++)\n        num += getreal(type);\n      black += num / len + 0.5;\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_black += num / len + 0.5;\n#endif\n      break;\n    case 50717: /* WhiteLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_whitelevel[0] =\n#endif\n          maximum = getint(type);\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tiff_ifd[ifd].samples > 1) // Linear DNG case\n        for (i = 1; i < colors && i < 4 && i < len; i++)\n          tiff_ifd[ifd].dng_levels.dng_whitelevel[i] = getint(type);\n#endif\n      break;\n    case 50718: /* DefaultScale */\n      pixel_aspect = getreal(type);\n      pixel_aspect /= getreal(type);\n      if (pixel_aspect > 0.995 && pixel_aspect < 1.005)\n        pixel_aspect = 1.0;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50778:\n      tiff_ifd[ifd].dng_color[0].illuminant = get2();\n      break;\n    case 50779:\n      tiff_ifd[ifd].dng_color[1].illuminant = get2();\n      break;\n#endif\n    case 50721: /* ColorMatrix1 */\n    case 50722: /* ColorMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      i = tag == 50721 ? 0 : 1;\n#endif\n      FORCC for (j = 0; j < 3; j++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_color[i].colormatrix[c][j] =\n#endif\n            cm[c][j] = getreal(type);\n      }\n      use_cm = 1;\n      break;\n\n    case 0xc714: /* ForwardMatrix1 */\n    case 0xc715: /* ForwardMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      i = tag == 0xc714 ? 0 : 1;\n#endif\n      for (j = 0; j < 3; j++)\n        FORCC\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          tiff_ifd[ifd].dng_color[i].forwardmatrix[j][c] =\n#endif\n              fm[j][c] = getreal(type);\n        }\n      break;\n\n    case 50723: /* CameraCalibration1 */\n    case 50724: /* CameraCalibration2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      j = tag == 50723 ? 0 : 1;\n#endif\n      for (i = 0; i < colors; i++)\n        FORCC\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          tiff_ifd[ifd].dng_color[j].calibration[i][c] =\n#endif\n              cc[i][c] = getreal(type);\n        }\n      break;\n    case 50727: /* AnalogBalance */\n      FORCC\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.analogbalance[c] =\n#endif\n            ab[c] = getreal(type);\n      }\n      break;\n    case 50728: /* AsShotNeutral */\n      FORCC asn[c] = getreal(type);\n      break;\n    case 50729: /* AsShotWhiteXY */\n      xyz[0] = getreal(type);\n      xyz[1] = getreal(type);\n      xyz[2] = 1 - xyz[0] - xyz[1];\n      FORC3 xyz[c] /= d65_white[c];\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50730: /* DNG: Baseline Exposure */\n      baseline_exposure = getreal(type);\n      break;\n#endif\n    // IB start\n    case 50740: /* tag 0xc634 : DNG Adobe, DNG Pentax, Sony SR2, DNG Private */\n#ifdef LIBRAW_LIBRARY_BUILD\n    {\n      char mbuf[64];\n      unsigned short makernote_found = 0;\n      INT64 curr_pos, start_pos = ftell(ifp);\n      unsigned MakN_order, m_sorder = order;\n      unsigned MakN_length;\n      unsigned pos_in_original_raw;\n      fread(mbuf, 1, 6, ifp);\n\n      if (!strcmp(mbuf, \"Adobe\"))\n      {\n        order = 0x4d4d; // Adobe header is always in \"MM\" / big endian\n        curr_pos = start_pos + 6;\n        while (curr_pos + 8 - start_pos <= len)\n        {\n          fread(mbuf, 1, 4, ifp);\n          curr_pos += 8;\n          if (!strncmp(mbuf, \"MakN\", 4))\n          {\n            makernote_found = 1;\n            MakN_length = get4();\n            MakN_order = get2();\n            pos_in_original_raw = get4();\n            order = MakN_order;\n            parse_makernote_0xc634(curr_pos + 6 - pos_in_original_raw, 0, AdobeDNG);\n            break;\n          }\n        }\n      }\n      else\n      {\n        fread(mbuf + 6, 1, 2, ifp);\n        if (!strcmp(mbuf, \"PENTAX \") || !strcmp(mbuf, \"SAMSUNG\"))\n        {\n          makernote_found = 1;\n          fseek(ifp, start_pos, SEEK_SET);\n          parse_makernote_0xc634(base, 0, CameraDNG);\n        }\n      }\n\n      fseek(ifp, start_pos, SEEK_SET);\n      order = m_sorder;\n    }\n// IB end\n#endif\n      if (dng_version)\n        break;\n      parse_minolta(j = get4() + base);\n      fseek(ifp, j, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 50752:\n      read_shorts(cr2_slice, 3);\n      break;\n    case 50829: /* ActiveArea */\n      top_margin = getint(type);\n      left_margin = getint(type);\n      height = getint(type) - top_margin;\n      width = getint(type) - left_margin;\n      break;\n    case 50830: /* MaskedAreas */\n      for (i = 0; i < len && i < 32; i++)\n        ((int *)mask)[i] = getint(type);\n      black = 0;\n      break;\n    case 51009: /* OpcodeList2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].opcode2_offset =\n#endif\n          meta_offset = ftell(ifp);\n      break;\n    case 64772: /* Kodak P-series */\n      if (len < 13)\n        break;\n      fseek(ifp, 16, SEEK_CUR);\n      data_offset = get4();\n      fseek(ifp, 28, SEEK_CUR);\n      data_offset += get4();\n      load_raw = &CLASS packed_load_raw;\n      break;\n    case 65026:\n      if (type == 2)\n        fgets(model2, 64, ifp);\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n  if (sony_length && sony_length < 10240000 && (buf = (unsigned *)malloc(sony_length)))\n  {\n    fseek(ifp, sony_offset, SEEK_SET);\n    fread(buf, sony_length, 1, ifp);\n    sony_decrypt(buf, sony_length / 4, 1, sony_key);\n#ifndef LIBRAW_LIBRARY_BUILD\n    sfp = ifp;\n    if ((ifp = tmpfile()))\n    {\n      fwrite(buf, sony_length, 1, ifp);\n      fseek(ifp, 0, SEEK_SET);\n      parse_tiff_ifd(-sony_offset);\n      fclose(ifp);\n    }\n    ifp = sfp;\n#else\n    if (!ifp->tempbuffer_open(buf, sony_length))\n    {\n      parse_tiff_ifd(-sony_offset);\n      ifp->tempbuffer_close();\n    }\n#endif\n    free(buf);\n  }\n  for (i = 0; i < colors; i++)\n    FORCC cc[i][c] *= ab[i];\n  if (use_cm)\n  {\n    FORCC for (i = 0; i < 3; i++) for (cam_xyz[c][i] = j = 0; j < colors; j++) cam_xyz[c][i] +=\n        cc[c][j] * cm[j][i] * xyz[i];\n    cam_xyz_coeff(cmatrix, cam_xyz);\n  }\n  if (asn[0])\n  {\n    cam_mul[3] = 0;\n    FORCC cam_mul[c] = 1 / asn[c];\n  }\n  if (!use_cm)\n    FORCC pre_mul[c] /= cc[c][c];\n  return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145658,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int CLASS parse_tiff_ifd(int base)\n{\n  unsigned entries, tag, type, len, plen = 16, save;\n  int ifd, use_cm = 0, cfa, i, j, c, ima_len = 0;\n  char *cbuf, *cp;\n  uchar cfa_pat[16], cfa_pc[] = {0, 1, 2, 3}, tab[256];\n  double fm[3][4], cc[4][4], cm[4][3], cam_xyz[4][3], num;\n  double ab[] = {1, 1, 1, 1}, asn[] = {0, 0, 0, 0}, xyz[] = {1, 1, 1};\n  unsigned sony_curve[] = {0, 0, 0, 0, 0, 4095};\n  unsigned *buf, sony_offset = 0, sony_length = 0, sony_key = 0;\n  struct jhead jh;\n  int pana_raw = 0;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *sfp;\n#endif\n\n  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n    return 1;\n  ifd = tiff_nifds++;\n  for (j = 0; j < 4; j++)\n    for (i = 0; i < 4; i++)\n      cc[j][i] = i == j;\n  entries = get2();\n  if (entries > 512)\n    return 1;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n#endif\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && len + savepos > fsize * 2)\n      continue; // skip tag pointing out of 2xfile\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data, tag | (pana_raw ? 0x30000 : 0), type, len, order, ifp);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strncasecmp(make, \"SONY\", 4) ||\n        (!strncasecmp(make, \"Hasselblad\", 10) &&\n         (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) || !strncasecmp(model, \"HV\", 2))))\n    {\n      switch (tag)\n      {\n      case 0x7300: // SR2 black level\n        for (int i = 0; i < 4 && i < len; i++)\n          cblack[i] = get2();\n        break;\n      case 0x7480:\n      case 0x7820:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n        break;\n      case 0x7481:\n      case 0x7821:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1];\n        break;\n      case 0x7482:\n      case 0x7822:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n        break;\n      case 0x7483:\n      case 0x7823:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1];\n        break;\n      case 0x7484:\n      case 0x7824:\n        imgdata.color.WBCT_Coeffs[0][0] = 4500;\n        FORC3 imgdata.color.WBCT_Coeffs[0][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[0][4] = imgdata.color.WBCT_Coeffs[0][2];\n        break;\n      case 0x7486:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n        break;\n      case 0x7825:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n        break;\n      case 0x7826:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1];\n        break;\n      case 0x7827:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1];\n        break;\n      case 0x7828:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1];\n        break;\n      case 0x7829:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1];\n        break;\n      case 0x782a:\n        imgdata.color.WBCT_Coeffs[1][0] = 8500;\n        FORC3 imgdata.color.WBCT_Coeffs[1][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[1][4] = imgdata.color.WBCT_Coeffs[1][2];\n        break;\n      case 0x782b:\n        imgdata.color.WBCT_Coeffs[2][0] = 6000;\n        FORC3 imgdata.color.WBCT_Coeffs[2][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[2][4] = imgdata.color.WBCT_Coeffs[2][2];\n        break;\n      case 0x782c:\n        imgdata.color.WBCT_Coeffs[3][0] = 3200;\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][c] = imgdata.color.WBCT_Coeffs[3][c + 1] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][3] = imgdata.color.WBCT_Coeffs[3][4] =\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][1];\n        break;\n      case 0x782d:\n        imgdata.color.WBCT_Coeffs[4][0] = 2500;\n        FORC3 imgdata.color.WBCT_Coeffs[4][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[4][4] = imgdata.color.WBCT_Coeffs[4][2];\n        break;\n      case 0x787f:\n        FORC3 imgdata.color.linear_max[c] = get2();\n        imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n        break;\n      }\n    }\n#endif\n\n    switch (tag)\n    {\n    case 1:\n      if (len == 4)\n        pana_raw = get4();\n      break;\n    case 5:\n      width = get2();\n      break;\n    case 6:\n      height = get2();\n      break;\n    case 7:\n      width += get2();\n      break;\n    case 9:\n      if ((i = get2()))\n        filters = i;\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw && len == 1 && type == 3)\n        pana_black[3] += i;\n#endif\n      break;\n    case 8:\n    case 10:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw && len == 1 && type == 3)\n        pana_black[3] += get2();\n#endif\n      break;\n    case 14:\n    case 15:\n    case 16:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw)\n      {\n        imgdata.color.linear_max[tag - 14] = get2();\n        if (tag == 15)\n          imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n      }\n#endif\n      break;\n    case 17:\n    case 18:\n      if (type == 3 && len == 1)\n        cam_mul[(tag - 17) * 2] = get2() / 256.0;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 19:\n      if (pana_raw)\n      {\n        ushort nWB, cnt, tWB;\n        nWB = get2();\n        if (nWB > 0x100)\n          break;\n        for (cnt = 0; cnt < nWB; cnt++)\n        {\n          tWB = get2();\n          if (tWB < 0x100)\n          {\n            imgdata.color.WB_Coeffs[tWB][0] = get2();\n            imgdata.color.WB_Coeffs[tWB][2] = get2();\n            imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = 0x100;\n          }\n          else\n            get4();\n        }\n      }\n      break;\n#endif\n    case 23:\n      if (type == 3)\n        iso_speed = get2();\n      break;\n    case 28:\n    case 29:\n    case 30:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw && len == 1 && type == 3)\n      {\n        pana_black[tag - 28] = get2();\n      }\n      else\n#endif\n      {\n        cblack[tag - 28] = get2();\n        cblack[3] = cblack[1];\n      }\n      break;\n    case 36:\n    case 37:\n    case 38:\n      cam_mul[tag - 36] = get2();\n      break;\n    case 39:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw)\n      {\n        ushort nWB, cnt, tWB;\n        nWB = get2();\n        if (nWB > 0x100)\n          break;\n        for (cnt = 0; cnt < nWB; cnt++)\n        {\n          tWB = get2();\n          if (tWB < 0x100)\n          {\n            imgdata.color.WB_Coeffs[tWB][0] = get2();\n            imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = get2();\n            imgdata.color.WB_Coeffs[tWB][2] = get2();\n          }\n          else\n            fseek(ifp, 6, SEEK_CUR);\n        }\n      }\n      break;\n#endif\n      if (len < 50 || cam_mul[0])\n        break;\n      fseek(ifp, 12, SEEK_CUR);\n      FORC3 cam_mul[c] = get2();\n      break;\n    case 46:\n      if (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n        break;\n      thumb_offset = ftell(ifp) - 2;\n      thumb_length = len;\n      break;\n    case 61440: /* Fuji HS10 table */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 2:\n    case 256:\n    case 61441: /* ImageWidth */\n      tiff_ifd[ifd].t_width = getint(type);\n      break;\n    case 3:\n    case 257:\n    case 61442: /* ImageHeight */\n      tiff_ifd[ifd].t_height = getint(type);\n      break;\n    case 258: /* BitsPerSample */\n    case 61443:\n      tiff_ifd[ifd].samples = len & 7;\n      tiff_ifd[ifd].bps = getint(type);\n      if (tiff_bps < tiff_ifd[ifd].bps)\n        tiff_bps = tiff_ifd[ifd].bps;\n      break;\n    case 61446:\n      raw_height = 0;\n      if (tiff_ifd[ifd].bps > 12)\n        break;\n      load_raw = &CLASS packed_load_raw;\n      load_flags = get4() ? 24 : 80;\n      break;\n    case 259: /* Compression */\n      tiff_ifd[ifd].comp = getint(type);\n      break;\n    case 262: /* PhotometricInterpretation */\n      tiff_ifd[ifd].phint = get2();\n      break;\n    case 270: /* ImageDescription */\n      fread(desc, 512, 1, ifp);\n      break;\n    case 271: /* Make */\n      fgets(make, 64, ifp);\n      break;\n    case 272: /* Model */\n      fgets(model, 64, ifp);\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 278:\n      tiff_ifd[ifd].rows_per_strip = getint(type);\n      break;\n#endif\n    case 280: /* Panasonic RW2 offset */\n      if (type != 4)\n        break;\n      load_raw = &CLASS panasonic_load_raw;\n      load_flags = 0x2008;\n    case 273: /* StripOffset */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (len > 1 && len < 16384)\n      {\n        off_t sav = ftell(ifp);\n        tiff_ifd[ifd].strip_offsets = (int *)calloc(len, sizeof(int));\n        tiff_ifd[ifd].strip_offsets_count = len;\n        for (int i = 0; i < len; i++)\n          tiff_ifd[ifd].strip_offsets[i] = get4() + base;\n        fseek(ifp, sav, SEEK_SET); // restore position\n      }\n/* fallback */\n#endif\n    case 513: /* JpegIFOffset */\n    case 61447:\n      tiff_ifd[ifd].offset = get4() + base;\n      if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0)\n      {\n        fseek(ifp, tiff_ifd[ifd].offset, SEEK_SET);\n        if (ljpeg_start(&jh, 1))\n        {\n          tiff_ifd[ifd].comp = 6;\n          tiff_ifd[ifd].t_width = jh.wide;\n          tiff_ifd[ifd].t_height = jh.high;\n          tiff_ifd[ifd].bps = jh.bits;\n          tiff_ifd[ifd].samples = jh.clrs;\n          if (!(jh.sraw || (jh.clrs & 1)))\n            tiff_ifd[ifd].t_width *= jh.clrs;\n          if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)\n          {\n            tiff_ifd[ifd].t_width /= 2;\n            tiff_ifd[ifd].t_height *= 2;\n          }\n          i = order;\n          parse_tiff(tiff_ifd[ifd].offset + 12);\n          order = i;\n        }\n      }\n      break;\n    case 274: /* Orientation */\n      tiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7] - '0';\n      break;\n    case 277: /* SamplesPerPixel */\n      tiff_ifd[ifd].samples = getint(type) & 7;\n      break;\n    case 279: /* StripByteCounts */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (len > 1 && len < 16384)\n      {\n        off_t sav = ftell(ifp);\n        tiff_ifd[ifd].strip_byte_counts = (int *)calloc(len, sizeof(int));\n        tiff_ifd[ifd].strip_byte_counts_count = len;\n        for (int i = 0; i < len; i++)\n          tiff_ifd[ifd].strip_byte_counts[i] = get4();\n        fseek(ifp, sav, SEEK_SET); // restore position\n      }\n/* fallback */\n#endif\n    case 514:\n    case 61448:\n      tiff_ifd[ifd].bytes = get4();\n      break;\n    case 61454:\n      FORC3 cam_mul[(4 - c) % 3] = getint(type);\n      break;\n    case 305:\n    case 11: /* Software */\n      fgets(software, 64, ifp);\n      if (!strncmp(software, \"Adobe\", 5) || !strncmp(software, \"dcraw\", 5) || !strncmp(software, \"UFRaw\", 5) ||\n          !strncmp(software, \"Bibble\", 6) || !strcmp(software, \"Digital Photo Professional\"))\n        is_raw = 0;\n      break;\n    case 306: /* DateTime */\n      get_timestamp(0);\n      break;\n    case 315: /* Artist */\n      fread(artist, 64, 1, ifp);\n      break;\n    case 317:\n      tiff_ifd[ifd].predictor = getint(type);\n      break;\n    case 322: /* TileWidth */\n      tiff_ifd[ifd].t_tile_width = getint(type);\n      break;\n    case 323: /* TileLength */\n      tiff_ifd[ifd].t_tile_length = getint(type);\n      break;\n    case 324: /* TileOffsets */\n      tiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();\n      if (len == 1)\n        tiff_ifd[ifd].t_tile_width = tiff_ifd[ifd].t_tile_length = 0;\n      if (len == 4)\n      {\n        load_raw = &CLASS sinar_4shot_load_raw;\n        is_raw = 5;\n      }\n      break;\n    case 325:\n      tiff_ifd[ifd].bytes = len > 1 ? ftell(ifp) : get4();\n      break;\n    case 330: /* SubIFDs */\n      if (!strcmp(model, \"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872)\n      {\n        load_raw = &CLASS sony_arw_load_raw;\n        data_offset = get4() + base;\n        ifd++;\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif (ifd >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif    \n        break;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (!strncmp(make, \"Hasselblad\", 10) && libraw_internal_data.unpacker_data.hasselblad_parser_flag)\n      {\n        fseek(ifp, ftell(ifp) + 4, SEEK_SET);\n        fseek(ifp, get4() + base, SEEK_SET);\n        parse_tiff_ifd(base);\n        break;\n      }\n#endif\n      if (len > 1000)\n        len = 1000; /* 1000 SubIFDs is enough */\n      while (len--)\n      {\n        i = ftell(ifp);\n        fseek(ifp, get4() + base, SEEK_SET);\n        if (parse_tiff_ifd(base))\n          break;\n        fseek(ifp, i + 4, SEEK_SET);\n      }\n      break;\n    case 339:\n      tiff_ifd[ifd].sample_format = getint(type);\n      break;\n    case 400:\n      strcpy(make, \"Sarnoff\");\n      maximum = 0xfff;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 700:\n      if ((type == 1 || type == 2 || type == 6 || type == 7) && len > 1 && len < 5100000)\n      {\n        xmpdata = (char *)malloc(xmplen = len + 1);\n        fread(xmpdata, len, 1, ifp);\n        xmpdata[len] = 0;\n      }\n      break;\n#endif\n    case 28688:\n      FORC4 sony_curve[c + 1] = get2() >> 2 & 0xfff;\n      for (i = 0; i < 5; i++)\n        for (j = sony_curve[i] + 1; j <= sony_curve[i + 1]; j++)\n          curve[j] = curve[j - 1] + (1 << i);\n      break;\n    case 29184:\n      sony_offset = get4();\n      break;\n    case 29185:\n      sony_length = get4();\n      break;\n    case 29217:\n      sony_key = get4();\n      break;\n    case 29264:\n      parse_minolta(ftell(ifp));\n      raw_width = 0;\n      break;\n    case 29443:\n      FORC4 cam_mul[c ^ (c < 2)] = get2();\n      break;\n    case 29459:\n      FORC4 cam_mul[c] = get2();\n      i = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;\n      SWAP(cam_mul[i], cam_mul[i + 1])\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 30720: // Sony matrix, Sony_SR2SubIFD_0x7800\n      for (i = 0; i < 3; i++)\n      {\n        float num = 0.0;\n        for (c = 0; c < 3; c++)\n        {\n          imgdata.color.ccm[i][c] = (float)((short)get2());\n          num += imgdata.color.ccm[i][c];\n        }\n        if (num > 0.01)\n          FORC3 imgdata.color.ccm[i][c] = imgdata.color.ccm[i][c] / num;\n      }\n      break;\n#endif\n    case 29456: // Sony black level, Sony_SR2SubIFD_0x7310, no more needs to be divided by 4\n      FORC4 cblack[c ^ c >> 1] = get2();\n      i = cblack[3];\n      FORC3 if (i > cblack[c]) i = cblack[c];\n      FORC4 cblack[c] -= i;\n      black = i;\n\n#ifdef DCRAW_VERBOSE\n      if (verbose)\n        fprintf(stderr, _(\"...Sony black: %u cblack: %u %u %u %u\\n\"), black, cblack[0], cblack[1], cblack[2],\n                cblack[3]);\n#endif\n      break;\n    case 33405: /* Model2 */\n      fgets(model2, 64, ifp);\n      break;\n    case 33421: /* CFARepeatPatternDim */\n      if (get2() == 6 && get2() == 6)\n        filters = 9;\n      break;\n    case 33422: /* CFAPattern */\n      if (filters == 9)\n      {\n        FORC(36)((char *)xtrans)[c] = fgetc(ifp) & 3;\n        break;\n      }\n    case 64777: /* Kodak P-series */\n      if (len == 36)\n      {\n        filters = 9;\n        colors = 3;\n        FORC(36) xtrans[0][c] = fgetc(ifp) & 3;\n      }\n      else if (len > 0)\n      {\n        if ((plen = len) > 16)\n          plen = 16;\n        fread(cfa_pat, 1, plen, ifp);\n        for (colors = cfa = i = 0; i < plen && colors < 4; i++)\n        {\n          colors += !(cfa & (1 << cfa_pat[i]));\n          cfa |= 1 << cfa_pat[i];\n        }\n        if (cfa == 070)\n          memcpy(cfa_pc, \"\\003\\004\\005\", 3); /* CMY */\n        if (cfa == 072)\n          memcpy(cfa_pc, \"\\005\\003\\004\\001\", 4); /* GMCY */\n        goto guess_cfa_pc;\n      }\n      break;\n    case 33424:\n    case 65024:\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_kodak_ifd(base);\n      break;\n    case 33434: /* ExposureTime */\n      tiff_ifd[ifd].t_shutter = shutter = getreal(type);\n      break;\n    case 33437: /* FNumber */\n      aperture = getreal(type);\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    // IB start\n    case 0xa405: // FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431: // BodySerialNumber\n    case 0xc62f:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435: // LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa433: // LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434: // LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = powf64(2.0f, (getreal(type) / 2.0f));\n      break;\n// IB end\n#endif\n    case 34306: /* Leaf white balance */\n      FORC4 cam_mul[c ^ 1] = 4096.0 / get2();\n      break;\n    case 34307: /* Leaf CatchLight color matrix */\n      fread(software, 1, 7, ifp);\n      if (strncmp(software, \"MATRIX\", 6))\n        break;\n      colors = 4;\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        FORC4 fscanf(ifp, \"%f\", &rgb_cam[i][c ^ 1]);\n        if (!use_camera_wb)\n          continue;\n        num = 0;\n        FORC4 num += rgb_cam[i][c];\n        FORC4 rgb_cam[i][c] /= MAX(1, num);\n      }\n      break;\n    case 34310: /* Leaf metadata */\n      parse_mos(ftell(ifp));\n    case 34303:\n      strcpy(make, \"Leaf\");\n      break;\n    case 34665: /* EXIF tag */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_exif(base);\n      break;\n    case 34853: /* GPSInfo tag */\n    {\n      unsigned pos;\n      fseek(ifp, pos = (get4() + base), SEEK_SET);\n      parse_gps(base);\n#ifdef LIBRAW_LIBRARY_BUILD\n      fseek(ifp, pos, SEEK_SET);\n      parse_gps_libraw(base);\n#endif\n    }\n    break;\n    case 34675: /* InterColorProfile */\n    case 50831: /* AsShotICCProfile */\n      profile_offset = ftell(ifp);\n      profile_length = len;\n      break;\n    case 37122: /* CompressedBitsPerPixel */\n      kodak_cbpp = get4();\n      break;\n    case 37386: /* FocalLength */\n      focal_len = getreal(type);\n      break;\n    case 37393: /* ImageNumber */\n      shot_order = getint(type);\n      break;\n    case 37400: /* old Kodak KDC tag */\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        getreal(type);\n        FORC3 rgb_cam[i][c] = getreal(type);\n      }\n      break;\n    case 40976:\n      strip_offset = get4();\n      switch (tiff_ifd[ifd].comp)\n      {\n      case 32770:\n        load_raw = &CLASS samsung_load_raw;\n        break;\n      case 32772:\n        load_raw = &CLASS samsung2_load_raw;\n        break;\n      case 32773:\n        load_raw = &CLASS samsung3_load_raw;\n        break;\n      }\n      break;\n    case 46275: /* Imacon tags */\n      strcpy(make, \"Imacon\");\n      data_offset = ftell(ifp);\n      ima_len = len;\n      break;\n    case 46279:\n      if (!ima_len)\n        break;\n      fseek(ifp, 38, SEEK_CUR);\n    case 46274:\n      fseek(ifp, 40, SEEK_CUR);\n      raw_width = get4();\n      raw_height = get4();\n      left_margin = get4() & 7;\n      width = raw_width - left_margin - (get4() & 7);\n      top_margin = get4() & 7;\n      height = raw_height - top_margin - (get4() & 7);\n      if (raw_width == 7262 && ima_len == 234317952)\n      {\n        height = 5412;\n        width = 7216;\n        left_margin = 7;\n        filters = 0;\n      }\n      else if (raw_width == 7262)\n      {\n        height = 5444;\n        width = 7244;\n        left_margin = 7;\n      }\n      fseek(ifp, 52, SEEK_CUR);\n      FORC3 cam_mul[c] = getreal(11);\n      fseek(ifp, 114, SEEK_CUR);\n      flip = (get2() >> 7) * 90;\n      if (width * height * 6 == ima_len)\n      {\n        if (flip % 180 == 90)\n          SWAP(width, height);\n        raw_width = width;\n        raw_height = height;\n        left_margin = top_margin = filters = flip = 0;\n      }\n      sprintf(model, \"Ixpress %d-Mp\", height * width / 1000000);\n      load_raw = &CLASS imacon_full_load_raw;\n      if (filters)\n      {\n        if (left_margin & 1)\n          filters = 0x61616161;\n        load_raw = &CLASS unpacked_load_raw;\n      }\n      maximum = 0xffff;\n      break;\n    case 50454: /* Sinar tag */\n    case 50455:\n      if (len < 1 || len > 2560000 || !(cbuf = (char *)malloc(len)))\n        break;\n#ifndef LIBRAW_LIBRARY_BUILD\n      fread(cbuf, 1, len, ifp);\n#else\n      if (fread(cbuf, 1, len, ifp) != len)\n        throw LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle\n#endif\n      cbuf[len - 1] = 0;\n      for (cp = cbuf - 1; cp && cp < cbuf + len; cp = strchr(cp, '\\n'))\n        if (!strncmp(++cp, \"Neutral \", 8))\n          sscanf(cp + 8, \"%f %f %f\", cam_mul, cam_mul + 1, cam_mul + 2);\n      free(cbuf);\n      break;\n    case 50458:\n      if (!make[0])\n        strcpy(make, \"Hasselblad\");\n      break;\n    case 50459: /* Hasselblad tag */\n#ifdef LIBRAW_LIBRARY_BUILD\n      libraw_internal_data.unpacker_data.hasselblad_parser_flag = 1;\n#endif\n      i = order;\n      j = ftell(ifp);\n      c = tiff_nifds;\n      order = get2();\n      fseek(ifp, j + (get2(), get4()), SEEK_SET);\n      parse_tiff_ifd(j);\n      maximum = 0xffff;\n      tiff_nifds = c;\n      order = i;\n      break;\n    case 50706: /* DNGVersion */\n      FORC4 dng_version = (dng_version << 8) + fgetc(ifp);\n      if (!make[0])\n        strcpy(make, \"DNG\");\n      is_raw = 1;\n      break;\n    case 50708: /* UniqueCameraModel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      stmread(imgdata.color.UniqueCameraModel, len, ifp);\n      imgdata.color.UniqueCameraModel[sizeof(imgdata.color.UniqueCameraModel) - 1] = 0;\n#endif\n      if (model[0])\n        break;\n#ifndef LIBRAW_LIBRARY_BUILD\n      fgets(make, 64, ifp);\n#else\n      strncpy(make, imgdata.color.UniqueCameraModel, MIN(len, sizeof(imgdata.color.UniqueCameraModel)));\n#endif\n      if ((cp = strchr(make, ' ')))\n      {\n        strcpy(model, cp + 1);\n        *cp = 0;\n      }\n      break;\n    case 50710: /* CFAPlaneColor */\n      if (filters == 9)\n        break;\n      if (len > 4)\n        len = 4;\n      colors = len;\n      fread(cfa_pc, 1, colors, ifp);\n    guess_cfa_pc:\n      FORCC tab[cfa_pc[c]] = c;\n      cdesc[c] = 0;\n      for (i = 16; i--;)\n        filters = filters << 2 | tab[cfa_pat[i % plen]];\n      filters -= !filters;\n      break;\n    case 50711: /* CFALayout */\n      if (get2() == 2)\n        fuji_width = 1;\n      break;\n    case 291:\n    case 50712: /* LinearizationTable */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].lineartable_offset = ftell(ifp);\n      tiff_ifd[ifd].lineartable_len = len;\n#endif\n      linear_table(len);\n      break;\n    case 50713: /* BlackLevelRepeatDim */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_cblack[4] =\n#endif\n          cblack[4] = get2();\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_cblack[5] =\n#endif\n          cblack[5] = get2();\n      if (cblack[4] * cblack[5] > (sizeof(cblack) / sizeof(cblack[0]) - 6))\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.dng_cblack[4] = tiff_ifd[ifd].dng_levels.dng_cblack[5] =\n#endif\n            cblack[4] = cblack[5] = 1;\n      break;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0xf00c:\n    {\n      unsigned fwb[4];\n      FORC4 fwb[c] = get4();\n      if (fwb[3] < 0x100)\n      {\n        imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n        imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n        imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n        if ((fwb[3] == 17) && libraw_internal_data.unpacker_data.lenRAFData > 3 &&\n            libraw_internal_data.unpacker_data.lenRAFData < 10240000)\n        {\n          long long f_save = ftell(ifp);\n          int fj, found = 0;\n          ushort *rafdata = (ushort *)malloc(sizeof(ushort) * libraw_internal_data.unpacker_data.lenRAFData);\n          fseek(ifp, libraw_internal_data.unpacker_data.posRAFData, SEEK_SET);\n          fread(rafdata, sizeof(ushort), libraw_internal_data.unpacker_data.lenRAFData, ifp);\n          fseek(ifp, f_save, SEEK_SET);\n          for (int fi = 0; fi < (libraw_internal_data.unpacker_data.lenRAFData - 3); fi++)\n          {\n            if ((fwb[0] == rafdata[fi]) && (fwb[1] == rafdata[fi + 1]) && (fwb[2] == rafdata[fi + 2]))\n            {\n              if (rafdata[fi - 15] != fwb[0])\n                continue;\n              fi = fi - 15;\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][3] =\n                  rafdata[fi];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = rafdata[fi + 1];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = rafdata[fi + 2];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =\n                  rafdata[fi + 3];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = rafdata[fi + 4];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = rafdata[fi + 5];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =\n                  rafdata[fi + 6];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = rafdata[fi + 7];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = rafdata[fi + 8];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] =\n                  rafdata[fi + 9];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][0] = rafdata[fi + 10];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][2] = rafdata[fi + 11];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =\n                  rafdata[fi + 12];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = rafdata[fi + 13];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = rafdata[fi + 14];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =\n                  rafdata[fi + 15];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = rafdata[fi + 16];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = rafdata[fi + 17];\n\n              fi += 111;\n              for (fj = fi; fj < (fi + 15); fj += 3)\n                if (rafdata[fj] != rafdata[fi])\n                {\n                  found = 1;\n                  break;\n                }\n              if (found)\n              {\n                int FujiCCT_K[31] = {2500, 2550, 2650, 2700, 2800, 2850, 2950, 3000, 3100, 3200, 3300,\n                                     3400, 3600, 3700, 3800, 4000, 4200, 4300, 4500, 4800, 5000, 5300,\n                                     5600, 5900, 6300, 6700, 7100, 7700, 8300, 9100, 10000};\n                fj = fj - 93;\n                for (int iCCT = 0; iCCT < 31; iCCT++)\n                {\n                  imgdata.color.WBCT_Coeffs[iCCT][0] = FujiCCT_K[iCCT];\n                  imgdata.color.WBCT_Coeffs[iCCT][1] = rafdata[iCCT * 3 + 1 + fj];\n                  imgdata.color.WBCT_Coeffs[iCCT][2] = imgdata.color.WBCT_Coeffs[iCCT][4] = rafdata[iCCT * 3 + fj];\n                  imgdata.color.WBCT_Coeffs[iCCT][3] = rafdata[iCCT * 3 + 2 + fj];\n                }\n              }\n              free(rafdata);\n              break;\n            }\n          }\n        }\n      }\n      FORC4 fwb[c] = get4();\n      if (fwb[3] < 0x100)\n      {\n        imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n        imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n        imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n      }\n    }\n    break;\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50709:\n      stmread(imgdata.color.LocalizedCameraModel, len, ifp);\n      break;\n#endif\n\n    case 61450:\n      cblack[4] = cblack[5] = MIN(sqrt((double)len), 64);\n    case 50714: /* BlackLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tiff_ifd[ifd].samples > 1 && tiff_ifd[ifd].samples == len) // LinearDNG, per-channel black\n      {\n        for (i = 0; i < colors && i < 4 && i < len; i++)\n          tiff_ifd[ifd].dng_levels.dng_cblack[i] = cblack[i] = getreal(type) + 0.5;\n\n        tiff_ifd[ifd].dng_levels.dng_black = black = 0;\n      }\n      else\n#endif\n          if ((cblack[4] * cblack[5] < 2) && len == 1)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.dng_black =\n#endif\n            black = getreal(type);\n      }\n      else if (cblack[4] * cblack[5] <= len)\n      {\n        FORC(cblack[4] * cblack[5])\n        cblack[6 + c] = getreal(type);\n        black = 0;\n        FORC4\n        cblack[c] = 0;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (tag == 50714)\n        {\n          FORC(cblack[4] * cblack[5])\n          tiff_ifd[ifd].dng_levels.dng_cblack[6 + c] = cblack[6 + c];\n          tiff_ifd[ifd].dng_levels.dng_black = 0;\n          FORC4\n          tiff_ifd[ifd].dng_levels.dng_cblack[c] = 0;\n        }\n#endif\n      }\n      break;\n    case 50715: /* BlackLevelDeltaH */\n    case 50716: /* BlackLevelDeltaV */\n      for (num = i = 0; i < len && i < 65536; i++)\n        num += getreal(type);\n      black += num / len + 0.5;\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_black += num / len + 0.5;\n#endif\n      break;\n    case 50717: /* WhiteLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_whitelevel[0] =\n#endif\n          maximum = getint(type);\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tiff_ifd[ifd].samples > 1) // Linear DNG case\n        for (i = 1; i < colors && i < 4 && i < len; i++)\n          tiff_ifd[ifd].dng_levels.dng_whitelevel[i] = getint(type);\n#endif\n      break;\n    case 50718: /* DefaultScale */\n      pixel_aspect = getreal(type);\n      pixel_aspect /= getreal(type);\n      if (pixel_aspect > 0.995 && pixel_aspect < 1.005)\n        pixel_aspect = 1.0;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50778:\n      tiff_ifd[ifd].dng_color[0].illuminant = get2();\n      break;\n    case 50779:\n      tiff_ifd[ifd].dng_color[1].illuminant = get2();\n      break;\n#endif\n    case 50721: /* ColorMatrix1 */\n    case 50722: /* ColorMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      i = tag == 50721 ? 0 : 1;\n#endif\n      FORCC for (j = 0; j < 3; j++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_color[i].colormatrix[c][j] =\n#endif\n            cm[c][j] = getreal(type);\n      }\n      use_cm = 1;\n      break;\n\n    case 0xc714: /* ForwardMatrix1 */\n    case 0xc715: /* ForwardMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      i = tag == 0xc714 ? 0 : 1;\n#endif\n      for (j = 0; j < 3; j++)\n        FORCC\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          tiff_ifd[ifd].dng_color[i].forwardmatrix[j][c] =\n#endif\n              fm[j][c] = getreal(type);\n        }\n      break;\n\n    case 50723: /* CameraCalibration1 */\n    case 50724: /* CameraCalibration2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      j = tag == 50723 ? 0 : 1;\n#endif\n      for (i = 0; i < colors; i++)\n        FORCC\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          tiff_ifd[ifd].dng_color[j].calibration[i][c] =\n#endif\n              cc[i][c] = getreal(type);\n        }\n      break;\n    case 50727: /* AnalogBalance */\n      FORCC\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.analogbalance[c] =\n#endif\n            ab[c] = getreal(type);\n      }\n      break;\n    case 50728: /* AsShotNeutral */\n      FORCC asn[c] = getreal(type);\n      break;\n    case 50729: /* AsShotWhiteXY */\n      xyz[0] = getreal(type);\n      xyz[1] = getreal(type);\n      xyz[2] = 1 - xyz[0] - xyz[1];\n      FORC3 xyz[c] /= d65_white[c];\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50730: /* DNG: Baseline Exposure */\n      baseline_exposure = getreal(type);\n      break;\n#endif\n    // IB start\n    case 50740: /* tag 0xc634 : DNG Adobe, DNG Pentax, Sony SR2, DNG Private */\n#ifdef LIBRAW_LIBRARY_BUILD\n    {\n      char mbuf[64];\n      unsigned short makernote_found = 0;\n      INT64 curr_pos, start_pos = ftell(ifp);\n      unsigned MakN_order, m_sorder = order;\n      unsigned MakN_length;\n      unsigned pos_in_original_raw;\n      fread(mbuf, 1, 6, ifp);\n\n      if (!strcmp(mbuf, \"Adobe\"))\n      {\n        order = 0x4d4d; // Adobe header is always in \"MM\" / big endian\n        curr_pos = start_pos + 6;\n        while (curr_pos + 8 - start_pos <= len)\n        {\n          fread(mbuf, 1, 4, ifp);\n          curr_pos += 8;\n          if (!strncmp(mbuf, \"MakN\", 4))\n          {\n            makernote_found = 1;\n            MakN_length = get4();\n            MakN_order = get2();\n            pos_in_original_raw = get4();\n            order = MakN_order;\n            parse_makernote_0xc634(curr_pos + 6 - pos_in_original_raw, 0, AdobeDNG);\n            break;\n          }\n        }\n      }\n      else\n      {\n        fread(mbuf + 6, 1, 2, ifp);\n        if (!strcmp(mbuf, \"PENTAX \") || !strcmp(mbuf, \"SAMSUNG\"))\n        {\n          makernote_found = 1;\n          fseek(ifp, start_pos, SEEK_SET);\n          parse_makernote_0xc634(base, 0, CameraDNG);\n        }\n      }\n\n      fseek(ifp, start_pos, SEEK_SET);\n      order = m_sorder;\n    }\n// IB end\n#endif\n      if (dng_version)\n        break;\n      parse_minolta(j = get4() + base);\n      fseek(ifp, j, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 50752:\n      read_shorts(cr2_slice, 3);\n      break;\n    case 50829: /* ActiveArea */\n      top_margin = getint(type);\n      left_margin = getint(type);\n      height = getint(type) - top_margin;\n      width = getint(type) - left_margin;\n      break;\n    case 50830: /* MaskedAreas */\n      for (i = 0; i < len && i < 32; i++)\n        ((int *)mask)[i] = getint(type);\n      black = 0;\n      break;\n    case 51009: /* OpcodeList2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].opcode2_offset =\n#endif\n          meta_offset = ftell(ifp);\n      break;\n    case 64772: /* Kodak P-series */\n      if (len < 13)\n        break;\n      fseek(ifp, 16, SEEK_CUR);\n      data_offset = get4();\n      fseek(ifp, 28, SEEK_CUR);\n      data_offset += get4();\n      load_raw = &CLASS packed_load_raw;\n      break;\n    case 65026:\n      if (type == 2)\n        fgets(model2, 64, ifp);\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n  if (sony_length && sony_length < 10240000 && (buf = (unsigned *)malloc(sony_length)))\n  {\n    fseek(ifp, sony_offset, SEEK_SET);\n    fread(buf, sony_length, 1, ifp);\n    sony_decrypt(buf, sony_length / 4, 1, sony_key);\n#ifndef LIBRAW_LIBRARY_BUILD\n    sfp = ifp;\n    if ((ifp = tmpfile()))\n    {\n      fwrite(buf, sony_length, 1, ifp);\n      fseek(ifp, 0, SEEK_SET);\n      parse_tiff_ifd(-sony_offset);\n      fclose(ifp);\n    }\n    ifp = sfp;\n#else\n    if (!ifp->tempbuffer_open(buf, sony_length))\n    {\n      parse_tiff_ifd(-sony_offset);\n      ifp->tempbuffer_close();\n    }\n#endif\n    free(buf);\n  }\n  for (i = 0; i < colors; i++)\n    FORCC cc[i][c] *= ab[i];\n  if (use_cm)\n  {\n    FORCC for (i = 0; i < 3; i++) for (cam_xyz[c][i] = j = 0; j < colors; j++) cam_xyz[c][i] +=\n        cc[c][j] * cm[j][i] * xyz[i];\n    cam_xyz_coeff(cmatrix, cam_xyz);\n  }\n  if (asn[0])\n  {\n    cam_mul[3] = 0;\n    FORCC cam_mul[c] = 1 / asn[c];\n  }\n  if (!use_cm)\n    FORCC pre_mul[c] /= cc[c][c];\n  return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145659,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *bin, ut64 limit_start, ut64 limit_end, ut32 event_mask, RFixupCallback callback, void * context) {\n\tint i = 0;\n\tfor (; i < bin->nsegs && i < bin->segs_count; i++) {\n\t\tif (!bin->chained_starts[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tint page_size = bin->chained_starts[i]->page_size;\n\t\tif (page_size < 1) {\n\t\t\tpage_size = 4096;\n\t\t}\n\t\tut64 start = bin->segs[i].fileoff;\n\t\tut64 end = start + bin->segs[i].filesize;\n\t\tif (end >= limit_start && start <= limit_end) {\n\t\t\tut64 page_idx = (R_MAX (start, limit_start) - start) / page_size;\n\t\t\tut64 page_end_idx = (R_MIN (limit_end, end) - start) / page_size;\n\t\t\tfor (; page_idx <= page_end_idx; page_idx++) {\n\t\t\t\tif (page_idx >= bin->chained_starts[i]->page_count) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut16 page_start = bin->chained_starts[i]->page_start[page_idx];\n\t\t\t\tif (page_start == DYLD_CHAINED_PTR_START_NONE) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tut64 cursor = start + page_idx * page_size + page_start;\n\t\t\t\twhile (cursor < limit_end && cursor < end) {\n\t\t\t\t\tut8 tmp[8];\n\t\t\t\t\tbool previous_rebasing = bin->rebasing_buffer;\n\t\t\t\t\tbin->rebasing_buffer = true;\n\t\t\t\t\tif (r_buf_read_at (bin->b, cursor, tmp, 8) != 8) {\n\t\t\t\t\t\tbin->rebasing_buffer = previous_rebasing;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbin->rebasing_buffer = previous_rebasing;\n\t\t\t\t\tut64 raw_ptr = r_read_le64 (tmp);\n\t\t\t\t\tut64 ptr_value = raw_ptr;\n\t\t\t\t\tut64 delta, stride, addend;\n\t\t\t\t\tut16 pointer_format = bin->chained_starts[i]->pointer_format;\n\t\t\t\t\tRFixupEvent event = R_FIXUP_EVENT_NONE;\n\t\t\t\t\tut8 key = 0, addr_div = 0;\n\t\t\t\t\tut16 diversity = 0;\n\t\t\t\t\tut32 ordinal = UT32_MAX;\n\t\t\t\t\tswitch (pointer_format) {\n\t\t\t\t\tcase DYLD_CHAINED_PTR_ARM64E:\n\t\t\t\t\t\t{\n\t\t\t\t\t\tstride = 8;\n\t\t\t\t\t\tbool is_auth = IS_PTR_AUTH (raw_ptr);\n\t\t\t\t\t\tbool is_bind = IS_PTR_BIND (raw_ptr);\n\t\t\t\t\t\tif (is_auth && is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND_AUTH;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t} else if (!is_auth && is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\taddend = p->addend;\n\t\t\t\t\t\t} else if (is_auth && !is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE_AUTH;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = p->target + bin->baddr;\n\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = ((ut64)p->high8 << 56) | p->target;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DYLD_CHAINED_PTR_ARM64E_USERLAND24:\n\t\t\t\t\t\t{\n\t\t\t\t\t\tstride = 8;\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind24 *bind =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind24 *) &raw_ptr;\n\t\t\t\t\t\tif (bind->bind) {\n\t\t\t\t\t\t\tdelta = bind->next;\n\t\t\t\t\t\t\tif (bind->auth) {\n\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind24 *p =\n\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind24 *) &raw_ptr;\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND_AUTH;\n\t\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND;\n\t\t\t\t\t\t\t\tordinal = bind->ordinal;\n\t\t\t\t\t\t\t\taddend = bind->addend;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (bind->auth) {\n\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE_AUTH;\n\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\tptr_value = p->target + bin->baddr;\n\t\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE;\n\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\tptr_value = bin->baddr + (((ut64)p->high8 << 56) | p->target);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DYLD_CHAINED_PTR_64:\n\t\t\t\t\tcase DYLD_CHAINED_PTR_64_OFFSET:\n\t\t\t\t\t\t{\n\t\t\t\t\t\tstride = 4;\n\t\t\t\t\t\tstruct dyld_chained_ptr_64_bind *bind =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_64_bind *) &raw_ptr;\n\t\t\t\t\t\tif (bind->bind) {\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND;\n\t\t\t\t\t\t\tdelta = bind->next;\n\t\t\t\t\t\t\tordinal = bind->ordinal;\n\t\t\t\t\t\t\taddend = bind->addend;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_64_rebase *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_64_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = ((ut64)p->high8 << 56) | p->target;\n\t\t\t\t\t\t\tif (pointer_format == DYLD_CHAINED_PTR_64_OFFSET) {\n\t\t\t\t\t\t\t\tptr_value += bin->baddr;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\teprintf (\"Unsupported chained pointer format %d\\n\", pointer_format);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (cursor >= limit_start && cursor <= limit_end - 8 && (event & event_mask) != 0) {\n\t\t\t\t\t\tbool carry_on;\n\t\t\t\t\t\tswitch (event) {\n\t\t\t\t\t\tcase R_FIXUP_EVENT_BIND: {\n\t\t\t\t\t\t\tRFixupBindEventDetails event_details;\n\n\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\tevent_details.ordinal = ordinal;\n\t\t\t\t\t\t\tevent_details.addend = addend;\n\n\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase R_FIXUP_EVENT_BIND_AUTH: {\n\t\t\t\t\t\t\tRFixupBindAuthEventDetails event_details;\n\n\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\tevent_details.ordinal = ordinal;\n\t\t\t\t\t\t\tevent_details.key = key;\n\t\t\t\t\t\t\tevent_details.addr_div = addr_div;\n\t\t\t\t\t\t\tevent_details.diversity = diversity;\n\n\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase R_FIXUP_EVENT_REBASE: {\n\t\t\t\t\t\t\tRFixupRebaseEventDetails event_details;\n\n\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\tevent_details.ptr_value = ptr_value;\n\n\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase R_FIXUP_EVENT_REBASE_AUTH: {\n\t\t\t\t\t\t\tRFixupRebaseAuthEventDetails event_details;\n\n\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\tevent_details.ptr_value = ptr_value;\n\t\t\t\t\t\t\tevent_details.key = key;\n\t\t\t\t\t\t\tevent_details.addr_div = addr_div;\n\t\t\t\t\t\t\tevent_details.diversity = diversity;\n\n\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\teprintf (\"Unexpected event while iterating chained fixups\\n\");\n\t\t\t\t\t\t\tcarry_on = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!carry_on) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcursor += delta * stride;\n\t\t\t\t\tif (!delta) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145672,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *bin, ut64 limit_start, ut64 limit_end, ut32 event_mask, RFixupCallback callback, void * context) {\n\tint i = 0;\n\tfor (; i < bin->nsegs && i < bin->segs_count; i++) {\n\t\tif (!bin->chained_starts[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tint page_size = bin->chained_starts[i]->page_size;\n\t\tif (page_size < 1) {\n\t\t\tpage_size = 4096;\n\t\t}\n\t\tut64 start = bin->segs[i].fileoff;\n\t\tut64 end = start + bin->segs[i].filesize;\n\t\tif (end >= limit_start && start <= limit_end) {\n\t\t\tut64 page_idx = (R_MAX (start, limit_start) - start) / page_size;\n\t\t\tut64 page_end_idx = (R_MIN (limit_end, end) - start) / page_size;\n\t\t\tfor (; page_idx <= page_end_idx; page_idx++) {\n\t\t\t\tif (page_idx >= bin->chained_starts[i]->page_count) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!bin->chained_starts[i]->page_start) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut16 page_start = bin->chained_starts[i]->page_start[page_idx];\n\t\t\t\tif (page_start == DYLD_CHAINED_PTR_START_NONE) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tut64 cursor = start + page_idx * page_size + page_start;\n\t\t\t\twhile (cursor < limit_end && cursor < end) {\n\t\t\t\t\tut8 tmp[8];\n\t\t\t\t\tbool previous_rebasing = bin->rebasing_buffer;\n\t\t\t\t\tbin->rebasing_buffer = true;\n\t\t\t\t\tif (r_buf_read_at (bin->b, cursor, tmp, 8) != 8) {\n\t\t\t\t\t\tbin->rebasing_buffer = previous_rebasing;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbin->rebasing_buffer = previous_rebasing;\n\t\t\t\t\tut64 raw_ptr = r_read_le64 (tmp);\n\t\t\t\t\tut64 ptr_value = raw_ptr;\n\t\t\t\t\tut64 delta, stride, addend;\n\t\t\t\t\tut16 pointer_format = bin->chained_starts[i]->pointer_format;\n\t\t\t\t\tRFixupEvent event = R_FIXUP_EVENT_NONE;\n\t\t\t\t\tut8 key = 0, addr_div = 0;\n\t\t\t\t\tut16 diversity = 0;\n\t\t\t\t\tut32 ordinal = UT32_MAX;\n\t\t\t\t\tswitch (pointer_format) {\n\t\t\t\t\tcase DYLD_CHAINED_PTR_ARM64E:\n\t\t\t\t\t\t{\n\t\t\t\t\t\tstride = 8;\n\t\t\t\t\t\tbool is_auth = IS_PTR_AUTH (raw_ptr);\n\t\t\t\t\t\tbool is_bind = IS_PTR_BIND (raw_ptr);\n\t\t\t\t\t\tif (is_auth && is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND_AUTH;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t} else if (!is_auth && is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\taddend = p->addend;\n\t\t\t\t\t\t} else if (is_auth && !is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE_AUTH;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = p->target + bin->baddr;\n\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = ((ut64)p->high8 << 56) | p->target;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DYLD_CHAINED_PTR_ARM64E_USERLAND24:\n\t\t\t\t\t\t{\n\t\t\t\t\t\tstride = 8;\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind24 *bind =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind24 *) &raw_ptr;\n\t\t\t\t\t\tif (bind->bind) {\n\t\t\t\t\t\t\tdelta = bind->next;\n\t\t\t\t\t\t\tif (bind->auth) {\n\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind24 *p =\n\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind24 *) &raw_ptr;\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND_AUTH;\n\t\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND;\n\t\t\t\t\t\t\t\tordinal = bind->ordinal;\n\t\t\t\t\t\t\t\taddend = bind->addend;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (bind->auth) {\n\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE_AUTH;\n\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\tptr_value = p->target + bin->baddr;\n\t\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE;\n\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\tptr_value = bin->baddr + (((ut64)p->high8 << 56) | p->target);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DYLD_CHAINED_PTR_64:\n\t\t\t\t\tcase DYLD_CHAINED_PTR_64_OFFSET:\n\t\t\t\t\t\t{\n\t\t\t\t\t\tstride = 4;\n\t\t\t\t\t\tstruct dyld_chained_ptr_64_bind *bind =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_64_bind *) &raw_ptr;\n\t\t\t\t\t\tif (bind->bind) {\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND;\n\t\t\t\t\t\t\tdelta = bind->next;\n\t\t\t\t\t\t\tordinal = bind->ordinal;\n\t\t\t\t\t\t\taddend = bind->addend;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_64_rebase *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_64_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = ((ut64)p->high8 << 56) | p->target;\n\t\t\t\t\t\t\tif (pointer_format == DYLD_CHAINED_PTR_64_OFFSET) {\n\t\t\t\t\t\t\t\tptr_value += bin->baddr;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\teprintf (\"Unsupported chained pointer format %d\\n\", pointer_format);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (cursor >= limit_start && cursor <= limit_end - 8 && (event & event_mask) != 0) {\n\t\t\t\t\t\tbool carry_on;\n\t\t\t\t\t\tswitch (event) {\n\t\t\t\t\t\tcase R_FIXUP_EVENT_BIND: {\n\t\t\t\t\t\t\tRFixupBindEventDetails event_details;\n\n\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\tevent_details.ordinal = ordinal;\n\t\t\t\t\t\t\tevent_details.addend = addend;\n\n\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase R_FIXUP_EVENT_BIND_AUTH: {\n\t\t\t\t\t\t\tRFixupBindAuthEventDetails event_details;\n\n\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\tevent_details.ordinal = ordinal;\n\t\t\t\t\t\t\tevent_details.key = key;\n\t\t\t\t\t\t\tevent_details.addr_div = addr_div;\n\t\t\t\t\t\t\tevent_details.diversity = diversity;\n\n\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase R_FIXUP_EVENT_REBASE: {\n\t\t\t\t\t\t\tRFixupRebaseEventDetails event_details;\n\n\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\tevent_details.ptr_value = ptr_value;\n\n\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase R_FIXUP_EVENT_REBASE_AUTH: {\n\t\t\t\t\t\t\tRFixupRebaseAuthEventDetails event_details;\n\n\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\tevent_details.ptr_value = ptr_value;\n\t\t\t\t\t\t\tevent_details.key = key;\n\t\t\t\t\t\t\tevent_details.addr_div = addr_div;\n\t\t\t\t\t\t\tevent_details.diversity = diversity;\n\n\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\teprintf (\"Unexpected event while iterating chained fixups\\n\");\n\t\t\t\t\t\t\tcarry_on = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!carry_on) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcursor += delta * stride;\n\t\t\t\t\tif (!delta) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145673,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "Controller::constructHeaderForSessionProtocol(Request *req, char * restrict buffer,\n\tunsigned int &size, const SessionProtocolWorkingState &state, string delta_monotonic)\n{\n\tchar *pos = buffer;\n\tconst char *end = buffer + size;\n\n\tpos += sizeof(boost::uint32_t);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REQUEST_URI\"));\n\tpos = appendData(pos, end, req->path.start->data, req->path.size);\n\tpos = appendData(pos, end, \"\", 1);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"PATH_INFO\"));\n\tpos = appendData(pos, end, state.path.data(), state.path.size());\n\tpos = appendData(pos, end, \"\", 1);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SCRIPT_NAME\"));\n\tif (state.hasBaseURI) {\n\t\tpos = appendData(pos, end, req->options.baseURI);\n\t\tpos = appendData(pos, end, \"\", 1);\n\t} else {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"\"));\n\t}\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"QUERY_STRING\"));\n\tpos = appendData(pos, end, state.queryString.data(), state.queryString.size());\n\tpos = appendData(pos, end, \"\", 1);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REQUEST_METHOD\"));\n\tpos = appendData(pos, end, state.methodStr);\n\tpos = appendData(pos, end, \"\", 1);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SERVER_NAME\"));\n\tpos = appendData(pos, end, state.serverName);\n\tpos = appendData(pos, end, \"\", 1);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SERVER_PORT\"));\n\tpos = appendData(pos, end, state.serverPort);\n\tpos = appendData(pos, end, \"\", 1);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SERVER_SOFTWARE\"));\n\tpos = appendData(pos, end, serverSoftware);\n\tpos = appendData(pos, end, \"\", 1);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SERVER_PROTOCOL\"));\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"HTTP/1.1\"));\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REMOTE_ADDR\"));\n\tif (state.remoteAddr != NULL) {\n\t\tpos = appendData(pos, end, state.remoteAddr);\n\t\tpos = appendData(pos, end, \"\", 1);\n\t} else {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"127.0.0.1\"));\n\t}\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REMOTE_PORT\"));\n\tif (state.remotePort != NULL) {\n\t\tpos = appendData(pos, end, state.remotePort);\n\t\tpos = appendData(pos, end, \"\", 1);\n\t} else {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"0\"));\n\t}\n\n\tif (state.remoteUser != NULL) {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REMOTE_USER\"));\n\t\tpos = appendData(pos, end, state.remoteUser);\n\t\tpos = appendData(pos, end, \"\", 1);\n\t}\n\n\tif (state.contentType != NULL) {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"CONTENT_TYPE\"));\n\t\tpos = appendData(pos, end, state.contentType);\n\t\tpos = appendData(pos, end, \"\", 1);\n\t}\n\n\tif (state.contentLength != NULL) {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"CONTENT_LENGTH\"));\n\t\tpos = appendData(pos, end, state.contentLength);\n\t\tpos = appendData(pos, end, \"\", 1);\n\t}\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"PASSENGER_CONNECT_PASSWORD\"));\n\tpos = appendData(pos, end, req->session->getApiKey().toStaticString());\n\tpos = appendData(pos, end, \"\", 1);\n\n\tif (req->https) {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"HTTPS\"));\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"on\"));\n\t}\n\n\tif (req->options.analytics) {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"PASSENGER_TXN_ID\"));\n\t\tpos = appendData(pos, end, req->options.transaction->getTxnId());\n\t\tpos = appendData(pos, end, \"\", 1);\n\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"PASSENGER_DELTA_MONOTONIC\"));\n\t\tpos = appendData(pos, end, delta_monotonic);\n\t\tpos = appendData(pos, end, \"\", 1);\n\t}\n\n\tif (req->upgraded()) {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"HTTP_CONNECTION\"));\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"upgrade\"));\n\t}\n\n\tServerKit::HeaderTable::Iterator it(req->headers);\n\twhile (*it != NULL) {\n\t\tif ((it->header->hash == HTTP_CONTENT_LENGTH.hash()\n\t\t\t|| it->header->hash == HTTP_CONTENT_TYPE.hash()\n\t\t\t|| it->header->hash == HTTP_CONNECTION.hash())\n\t\t && (psg_lstr_cmp(&it->header->key, P_STATIC_STRING(\"content-type\"))\n\t\t\t|| psg_lstr_cmp(&it->header->key, P_STATIC_STRING(\"content-length\"))\n\t\t\t|| psg_lstr_cmp(&it->header->key, P_STATIC_STRING(\"connection\"))))\n\t\t{\n\t\t\tit.next();\n\t\t\tcontinue;\n\t\t}\n\n\t\tpos = appendData(pos, end, P_STATIC_STRING(\"HTTP_\"));\n\t\tconst LString::Part *part = it->header->key.start;\n\t\twhile (part != NULL) {\n\t\t\tchar *start = pos;\n\t\t\tpos = appendData(pos, end, part->data, part->size);\n\t\t\thttpHeaderToScgiUpperCase((unsigned char *) start, pos - start);\n\t\t\tpart = part->next;\n\t\t}\n\t\tpos = appendData(pos, end, \"\", 1);\n\n\t\tpart = it->header->val.start;\n\t\twhile (part != NULL) {\n\t\t\tpos = appendData(pos, end, part->data, part->size);\n\t\t\tpart = part->next;\n\t\t}\n\t\tpos = appendData(pos, end, \"\", 1);\n\n\t\tit.next();\n\t}\n\n\tif (state.environmentVariablesData != NULL) {\n\t\tpos = appendData(pos, end, state.environmentVariablesData, state.environmentVariablesSize);\n\t}\n\n\tUint32Message::generate(buffer, pos - buffer - sizeof(boost::uint32_t));\n\n\tsize = pos - buffer;\n\treturn pos < end;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145692,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "Controller::constructHeaderForSessionProtocol(Request *req, char * restrict buffer,\n\tunsigned int &size, const SessionProtocolWorkingState &state, string delta_monotonic)\n{\n\tchar *pos = buffer;\n\tconst char *end = buffer + size;\n\n\tpos += sizeof(boost::uint32_t);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REQUEST_URI\"));\n\tpos = appendData(pos, end, req->path.start->data, req->path.size);\n\tpos = appendData(pos, end, \"\", 1);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"PATH_INFO\"));\n\tpos = appendData(pos, end, state.path.data(), state.path.size());\n\tpos = appendData(pos, end, \"\", 1);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SCRIPT_NAME\"));\n\tif (state.hasBaseURI) {\n\t\tpos = appendData(pos, end, req->options.baseURI);\n\t\tpos = appendData(pos, end, \"\", 1);\n\t} else {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"\"));\n\t}\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"QUERY_STRING\"));\n\tpos = appendData(pos, end, state.queryString.data(), state.queryString.size());\n\tpos = appendData(pos, end, \"\", 1);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REQUEST_METHOD\"));\n\tpos = appendData(pos, end, state.methodStr);\n\tpos = appendData(pos, end, \"\", 1);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SERVER_NAME\"));\n\tpos = appendData(pos, end, state.serverName);\n\tpos = appendData(pos, end, \"\", 1);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SERVER_PORT\"));\n\tpos = appendData(pos, end, state.serverPort);\n\tpos = appendData(pos, end, \"\", 1);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SERVER_SOFTWARE\"));\n\tpos = appendData(pos, end, serverSoftware);\n\tpos = appendData(pos, end, \"\", 1);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SERVER_PROTOCOL\"));\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"HTTP/1.1\"));\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REMOTE_ADDR\"));\n\tif (state.remoteAddr != NULL) {\n\t\tpos = appendData(pos, end, state.remoteAddr);\n\t\tpos = appendData(pos, end, \"\", 1);\n\t} else {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"127.0.0.1\"));\n\t}\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REMOTE_PORT\"));\n\tif (state.remotePort != NULL) {\n\t\tpos = appendData(pos, end, state.remotePort);\n\t\tpos = appendData(pos, end, \"\", 1);\n\t} else {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"0\"));\n\t}\n\n\tif (state.remoteUser != NULL) {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REMOTE_USER\"));\n\t\tpos = appendData(pos, end, state.remoteUser);\n\t\tpos = appendData(pos, end, \"\", 1);\n\t}\n\n\tif (state.contentType != NULL) {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"CONTENT_TYPE\"));\n\t\tpos = appendData(pos, end, state.contentType);\n\t\tpos = appendData(pos, end, \"\", 1);\n\t}\n\n\tif (state.contentLength != NULL) {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"CONTENT_LENGTH\"));\n\t\tpos = appendData(pos, end, state.contentLength);\n\t\tpos = appendData(pos, end, \"\", 1);\n\t}\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"PASSENGER_CONNECT_PASSWORD\"));\n\tpos = appendData(pos, end, req->session->getApiKey().toStaticString());\n\tpos = appendData(pos, end, \"\", 1);\n\n\tif (req->https) {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"HTTPS\"));\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"on\"));\n\t}\n\n\tif (req->options.analytics) {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"PASSENGER_TXN_ID\"));\n\t\tpos = appendData(pos, end, req->options.transaction->getTxnId());\n\t\tpos = appendData(pos, end, \"\", 1);\n\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"PASSENGER_DELTA_MONOTONIC\"));\n\t\tpos = appendData(pos, end, delta_monotonic);\n\t\tpos = appendData(pos, end, \"\", 1);\n\t}\n\n\tif (req->upgraded()) {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"HTTP_CONNECTION\"));\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"upgrade\"));\n\t}\n\n\tServerKit::HeaderTable::Iterator it(req->headers);\n\twhile (*it != NULL) {\n\t\t// This header-skipping is not accounted for in determineHeaderSizeForSessionProtocol(), but\n\t\t// since we are only reducing the size it just wastes some mem bytes.\n\t\tif ((\n\t\t\t\t(it->header->hash == HTTP_CONTENT_LENGTH.hash()\n\t\t\t\t\t\t|| it->header->hash == HTTP_CONTENT_TYPE.hash()\n\t\t\t\t\t\t|| it->header->hash == HTTP_CONNECTION.hash()\n\t\t\t\t) && (psg_lstr_cmp(&it->header->key, P_STATIC_STRING(\"content-type\"))\n\t\t\t\t\t\t|| psg_lstr_cmp(&it->header->key, P_STATIC_STRING(\"content-length\"))\n\t\t\t\t\t\t|| psg_lstr_cmp(&it->header->key, P_STATIC_STRING(\"connection\"))\n\t\t\t\t)\n\t\t\t) || containsNonAlphaNumDash(it->header->key)\n\t\t   )\n\t\t{\n\t\t\tit.next();\n\t\t\tcontinue;\n\t\t}\n\n\t\tpos = appendData(pos, end, P_STATIC_STRING(\"HTTP_\"));\n\t\tconst LString::Part *part = it->header->key.start;\n\t\twhile (part != NULL) {\n\t\t\tchar *start = pos;\n\t\t\tpos = appendData(pos, end, part->data, part->size);\n\t\t\thttpHeaderToScgiUpperCase((unsigned char *) start, pos - start);\n\t\t\tpart = part->next;\n\t\t}\n\t\tpos = appendData(pos, end, \"\", 1);\n\n\t\tpart = it->header->val.start;\n\t\twhile (part != NULL) {\n\t\t\tpos = appendData(pos, end, part->data, part->size);\n\t\t\tpart = part->next;\n\t\t}\n\t\tpos = appendData(pos, end, \"\", 1);\n\n\t\tit.next();\n\t}\n\n\tif (state.environmentVariablesData != NULL) {\n\t\tpos = appendData(pos, end, state.environmentVariablesData, state.environmentVariablesSize);\n\t}\n\n\tUint32Message::generate(buffer, pos - buffer - sizeof(boost::uint32_t));\n\n\tsize = pos - buffer;\n\treturn pos < end;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145693,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  Statement_Ptr Expand::operator()(Declaration_Ptr d)\n  {\n    Block_Obj ab = d->block();\n    String_Obj old_p = d->property();\n    Expression_Obj prop = old_p->perform(&eval);\n    String_Obj new_p = Cast<String>(prop);\n    // we might get a color back\n    if (!new_p) {\n      std::string str(prop->to_string(ctx.c_options));\n      new_p = SASS_MEMORY_NEW(String_Constant, old_p->pstate(), str);\n    }\n    Expression_Obj value = d->value()->perform(&eval);\n    Block_Obj bb = ab ? operator()(ab) : NULL;\n    if (!bb) {\n      if (!value || (value->is_invisible() && !d->is_important())) return 0;\n    }\n    Declaration_Ptr decl = SASS_MEMORY_NEW(Declaration,\n                                        d->pstate(),\n                                        new_p,\n                                        value,\n                                        d->is_important(),\n                                        d->is_custom_property(),\n                                        bb);\n    decl->tabs(d->tabs());\n    return decl;\n  }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145704,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  Statement_Ptr Expand::operator()(Declaration_Ptr d)\n  {\n    Block_Obj ab = d->block();\n    String_Obj old_p = d->property();\n    Expression_Obj prop = old_p->perform(&eval);\n    String_Obj new_p = Cast<String>(prop);\n    // we might get a color back\n    if (!new_p) {\n      std::string str(prop->to_string(ctx.c_options));\n      new_p = SASS_MEMORY_NEW(String_Constant, old_p->pstate(), str);\n    }\n    Expression_Obj value = d->value();\n    if (value) value = value->perform(&eval);\n    Block_Obj bb = ab ? operator()(ab) : NULL;\n    if (!bb) {\n      if (!value || (value->is_invisible() && !d->is_important())) return 0;\n    }\n    Declaration_Ptr decl = SASS_MEMORY_NEW(Declaration,\n                                        d->pstate(),\n                                        new_p,\n                                        value,\n                                        d->is_important(),\n                                        d->is_custom_property(),\n                                        bb);\n    decl->tabs(d->tabs());\n    return decl;\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145705,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int Exiv2::http(Exiv2::Dictionary& request, Exiv2::Dictionary& response, std::string& errors)\n{\n    if (!request.count(\"verb\"))\n        request[\"verb\"] = \"GET\";\n    if (!request.count(\"header\"))\n        request[\"header\"] = \"\";\n    if (!request.count(\"version\"))\n        request[\"version\"] = \"1.0\";\n    if (!request.count(\"port\"))\n        request[\"port\"] = \"\";\n\n    std::string file;\n    errors = \"\";\n    int result = 0;\n\n    ////////////////////////////////////\n    // Windows specific code\n#ifdef WIN32\n    WSADATA wsaData;\n    WSAStartup(MAKEWORD(2, 2), &wsaData);\n#endif\n\n    const char* servername = request[\"server\"].c_str();\n    const char* page = request[\"page\"].c_str();\n    const char* verb = request[\"verb\"].c_str();\n    const char* header = request[\"header\"].c_str();\n    const char* version = request[\"version\"].c_str();\n    const char* port = request[\"port\"].c_str();\n\n    const char* servername_p = servername;\n    const char* port_p = port;\n    std::string url = std::string(\"http://\") + request[\"server\"] + request[\"page\"];\n\n    // parse and change server if using a proxy\n    const char* PROXI = \"HTTP_PROXY\";\n    const char* proxi = \"http_proxy\";\n    const char* PROXY = getenv(PROXI);\n    const char* proxy = getenv(proxi);\n    bool bProx = PROXY || proxy;\n    const char* prox = bProx ? (proxy ? proxy : PROXY) : \"\";\n    Exiv2::Uri Proxy = Exiv2::Uri::Parse(prox);\n\n    // find the dictionary of no_proxy servers\n    const char* NO_PROXI = \"NO_PROXY\";\n    const char* no_proxi = \"no_proxy\";\n    const char* NO_PROXY = getenv(NO_PROXI);\n    const char* no_proxy = getenv(no_proxi);\n    bool bNoProxy = NO_PROXY || no_proxy;\n    std::string no_prox = std::string(bNoProxy ? (no_proxy ? no_proxy : NO_PROXY) : \"\");\n    Exiv2::Dictionary noProxy = stringToDict(no_prox + \",localhost,127.0.0.1\");\n\n    // if the server is on the no_proxy list ... ignore the proxy!\n    if (noProxy.count(servername))\n        bProx = false;\n\n    if (bProx) {\n        servername_p = Proxy.Host.c_str();\n        port_p = Proxy.Port.c_str();\n        page = url.c_str();\n        std::string p(proxy ? proxi : PROXI);\n        //  std::cerr << p << '=' << prox << \" page = \" << page << std::endl;\n    }\n    if (!port[0])\n        port = \"80\";\n    if (!port_p[0])\n        port_p = \"80\";\n\n    ////////////////////////////////////\n    // open the socket\n    int sockfd = (int)socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n    if (sockfd < 0)\n        return error(errors, \"unable to create socket\\n\", nullptr, nullptr, 0);\n\n    // fill in the address\n    struct sockaddr_in serv_addr;\n    int serv_len = sizeof(serv_addr);\n    memset((char*)&serv_addr, 0, serv_len);\n\n    serv_addr.sin_addr.s_addr = inet_addr(servername_p);\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(atoi(port_p));\n\n    // convert unknown servername into IP address\n    // http://publib.boulder.ibm.com/infocenter/iseries/v5r3/index.jsp?topic=/rzab6/rzab6uafinet.htm\n    if (serv_addr.sin_addr.s_addr == (unsigned long)INADDR_NONE) {\n        struct hostent* host = gethostbyname(servername_p);\n        if (!host) {\n            closesocket(sockfd);\n            return error(errors, \"no such host\", servername_p);\n        }\n        memcpy(&serv_addr.sin_addr, host->h_addr, sizeof(serv_addr.sin_addr));\n    }\n\n    makeNonBlocking(sockfd);\n\n    ////////////////////////////////////\n    // connect the socket to the server\n    auto server = connect(sockfd, (const struct sockaddr*)&serv_addr, serv_len);\n    if (server == SOCKET_ERROR && WSAGetLastError() != WSAEWOULDBLOCK) {\n        auto errorCode = WSAGetLastError();\n        closesocket(sockfd);\n        return error(errors, \"error - unable to connect to server = %s port = %s wsa_error = %d\", servername_p, port_p,\n                     errorCode);\n    }\n\n    char buffer[32 * 1024 + 1];\n    size_t buff_l = sizeof buffer - 1;\n\n    ////////////////////////////////////\n    // format the request\n    int n = snprintf(buffer, buff_l, httpTemplate, verb, page, version, servername, header);\n    buffer[n] = 0;\n    response[\"requestheaders\"] = std::string(buffer, n);\n\n    ////////////////////////////////////\n    // send the header (we'll have to wait for the connection by the non-blocking socket)\n    while (sleep_ >= 0 && send(sockfd, buffer, n, 0) == SOCKET_ERROR /* && WSAGetLastError() == WSAENOTCONN */) {\n        Sleep(snooze);\n        sleep_ -= snooze;\n    }\n\n    if (sleep_ < 0) {\n        auto errorCode = WSAGetLastError();\n        closesocket(server);\n        closesocket(sockfd);\n        return error(errors, \"error - timeout connecting to server = %s port = %s wsa_error = %d\", servername, port,\n                     errorCode);\n    }\n\n    int end = 0;             // write position in buffer\n    bool bSearching = true;  // looking for headers in the response\n    int status = 200;        // assume happiness\n\n    ////////////////////////////////////\n    // read and process the response\n    int err;\n    n = forgive(recv(sockfd, buffer, (int)buff_l, 0), err);\n    while (n >= 0 && OK(status)) {\n        if (n) {\n            end += n;\n            buffer[end] = 0;\n\n            size_t body = 0;  // start of body\n            if (bSearching) {\n                // search for the body\n                for (size_t b = 0; bSearching && b < lengthof(blankLines); b++) {\n                    if (strstr(buffer, blankLines[b])) {\n                        bSearching = false;\n                        body = (int)(strstr(buffer, blankLines[b]) - buffer) + strlen(blankLines[b]);\n                        status = atoi(strchr(buffer, ' '));\n                    }\n                }\n\n                // parse response headers\n                char* h = buffer;\n                char C = ':';\n                char N = '\\n';\n                int i = 0;  // initial byte in buffer\n                while (buffer[i] == N)\n                    i++;\n                h = strchr(h + i, N) + 1;\n                response[\"\"] = std::string(buffer + i).substr(0, h - buffer - 2);\n                result = atoi(strchr(buffer, ' '));\n                char* c = strchr(h, C);\n                char* first_newline = strchr(h, N);\n                while (c && first_newline && c < first_newline && h < buffer + body) {\n                    std::string key(h);\n                    std::string value(c + 1);\n                    key = key.substr(0, c - h);\n                    value = value.substr(0, first_newline - c - 1);\n                    response[key] = value;\n                    h = first_newline + 1;\n                    c = strchr(h, C);\n                    first_newline = strchr(h, N);\n                }\n            }\n\n            // if the buffer's full and we're still searching - give up!\n            // this handles the possibility that there are no headers\n            if (bSearching && buff_l - end < 10) {\n                bSearching = false;\n                body = 0;\n            }\n            if (!bSearching && OK(status)) {\n                flushBuffer(buffer, body, end, file);\n            }\n        }\n        n = forgive(recv(sockfd, buffer + end, (int)(buff_l - end), 0), err);\n        if (!n) {\n            Sleep(snooze);\n            sleep_ -= snooze;\n            if (sleep_ < 0)\n                n = FINISH;\n        }\n    }\n\n    if (n != FINISH || !OK(status)) {\n        snprintf(buffer, sizeof buffer, \"wsa_error = %d,n = %d,sleep_ = %d status = %d\", WSAGetLastError(), n, sleep_,\n                 status);\n        error(errors, buffer, nullptr, nullptr, 0);\n    } else if (bSearching && OK(status)) {\n        if (end) {\n            //  we finished OK without finding headers, flush the buffer\n            flushBuffer(buffer, 0, end, file);\n        } else {\n            auto errorCode = WSAGetLastError();\n            closesocket(server);\n            closesocket(sockfd);\n            return error(errors, \"error - no response from server = %s port = %s wsa_error = %d\", servername, port,\n                         errorCode);\n        }\n    }\n\n    ////////////////////////////////////\n    // close sockets\n    closesocket(server);\n    closesocket(sockfd);\n    response[\"body\"] = file;\n    return result;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145730,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int Exiv2::http(Exiv2::Dictionary& request, Exiv2::Dictionary& response, std::string& errors)\n{\n    if (!request.count(\"verb\"))\n        request[\"verb\"] = \"GET\";\n    if (!request.count(\"header\"))\n        request[\"header\"] = \"\";\n    if (!request.count(\"version\"))\n        request[\"version\"] = \"1.0\";\n    if (!request.count(\"port\"))\n        request[\"port\"] = \"\";\n\n    std::string file;\n    errors = \"\";\n    int result = 0;\n\n////////////////////////////////////\n// Windows specific code\n#ifdef WIN32\n    WSADATA wsaData;\n    WSAStartup(MAKEWORD(2, 2), &wsaData);\n#endif\n\n    const char* servername = request[\"server\"].c_str();\n    const char* page = request[\"page\"].c_str();\n    const char* verb = request[\"verb\"].c_str();\n    const char* header = request[\"header\"].c_str();\n    const char* version = request[\"version\"].c_str();\n    const char* port = request[\"port\"].c_str();\n\n    const char* servername_p = servername;\n    const char* port_p = port;\n    std::string url = std::string(\"http://\") + request[\"server\"] + request[\"page\"];\n\n    // parse and change server if using a proxy\n    const char* PROXI = \"HTTP_PROXY\";\n    const char* proxi = \"http_proxy\";\n    const char* PROXY = getenv(PROXI);\n    const char* proxy = getenv(proxi);\n    bool bProx = PROXY || proxy;\n    const char* prox = bProx ? (proxy ? proxy : PROXY) : \"\";\n    Exiv2::Uri Proxy = Exiv2::Uri::Parse(prox);\n\n    // find the dictionary of no_proxy servers\n    const char* NO_PROXI = \"NO_PROXY\";\n    const char* no_proxi = \"no_proxy\";\n    const char* NO_PROXY = getenv(NO_PROXI);\n    const char* no_proxy = getenv(no_proxi);\n    bool bNoProxy = NO_PROXY || no_proxy;\n    std::string no_prox = std::string(bNoProxy ? (no_proxy ? no_proxy : NO_PROXY) : \"\");\n    Exiv2::Dictionary noProxy = stringToDict(no_prox + \",localhost,127.0.0.1\");\n\n    // if the server is on the no_proxy list ... ignore the proxy!\n    if (noProxy.count(servername))\n        bProx = false;\n\n    if (bProx) {\n        servername_p = Proxy.Host.c_str();\n        port_p = Proxy.Port.c_str();\n        page = url.c_str();\n        std::string p(proxy ? proxi : PROXI);\n        //  std::cerr << p << '=' << prox << \" page = \" << page << std::endl;\n    }\n    if (!port[0])\n        port = \"80\";\n    if (!port_p[0])\n        port_p = \"80\";\n\n    ////////////////////////////////////\n    // open the socket\n    int sockfd = (int)socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n    if (sockfd < 0)\n        return error(errors, \"unable to create socket\\n\", nullptr, nullptr, 0);\n\n    // fill in the address\n    struct sockaddr_in serv_addr;\n    int serv_len = sizeof(serv_addr);\n    memset((char*)&serv_addr, 0, serv_len);\n\n    serv_addr.sin_addr.s_addr = inet_addr(servername_p);\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(atoi(port_p));\n\n    // convert unknown servername into IP address\n    // http://publib.boulder.ibm.com/infocenter/iseries/v5r3/index.jsp?topic=/rzab6/rzab6uafinet.htm\n    if (serv_addr.sin_addr.s_addr == (unsigned long)INADDR_NONE) {\n        struct hostent* host = gethostbyname(servername_p);\n        if (!host) {\n            closesocket(sockfd);\n            return error(errors, \"no such host\", servername_p);\n        }\n        memcpy(&serv_addr.sin_addr, host->h_addr, sizeof(serv_addr.sin_addr));\n    }\n\n    makeNonBlocking(sockfd);\n\n    ////////////////////////////////////\n    // connect the socket to the server\n    auto server = connect(sockfd, (const struct sockaddr*)&serv_addr, serv_len);\n    if (server == SOCKET_ERROR && WSAGetLastError() != WSAEWOULDBLOCK) {\n        auto errorCode = WSAGetLastError();\n        closesocket(sockfd);\n        return error(errors, \"error - unable to connect to server = %s port = %s wsa_error = %d\", servername_p, port_p,\n                     errorCode);\n    }\n\n    char buffer[32 * 1024 + 1];\n    size_t buff_l = sizeof buffer - 1;\n\n    ////////////////////////////////////\n    // format the request\n    int n = snprintf(buffer, buff_l, httpTemplate, verb, page, version, servername, header);\n    buffer[n] = 0;\n    response[\"requestheaders\"] = std::string(buffer, n);\n\n    ////////////////////////////////////\n    // send the header (we'll have to wait for the connection by the non-blocking socket)\n    while (sleep_ >= 0 && send(sockfd, buffer, n, 0) == SOCKET_ERROR /* && WSAGetLastError() == WSAENOTCONN */) {\n        Sleep(snooze);\n        sleep_ -= snooze;\n    }\n\n    if (sleep_ < 0) {\n        auto errorCode = WSAGetLastError();\n        closesocket(server);\n        closesocket(sockfd);\n        return error(errors, \"error - timeout connecting to server = %s port = %s wsa_error = %d\", servername, port,\n                     errorCode);\n    }\n\n    int end = 0;             // write position in buffer\n    bool bSearching = true;  // looking for headers in the response\n    int status = 200;        // assume happiness\n\n    ////////////////////////////////////\n    // read and process the response\n    int err;\n    n = forgive(recv(sockfd, buffer, (int)buff_l, 0), err);\n    while (n >= 0 && OK(status)) {\n        if (n) {\n            end += n;\n            buffer[end] = 0;\n\n            size_t body = 0;  // start of body\n            if (bSearching) {\n                // search for the body\n                for (size_t b = 0; bSearching && b < lengthof(blankLines); b++) {\n                    const char* blankLinePos = strstr(buffer, blankLines[b]);\n                    if (blankLinePos) {\n                        bSearching = false;\n                        body = blankLinePos - buffer + strlen(blankLines[b]);\n                        const char* firstSpace = strchr(buffer, ' ');\n                        if (firstSpace) {\n                            status = atoi(firstSpace);\n                        }\n                    }\n                }\n\n                // parse response headers\n                char* h = buffer;\n                char C = ':';\n                char N = '\\n';\n                int i = 0;  // initial byte in buffer\n                while (buffer[i] == N)\n                    i++;\n                h = strchr(h + i, N);\n                if (!h) {\n                    status = 0;\n                    break;\n                }\n                h++;\n                response[\"\"] = std::string(buffer + i).substr(0, h - buffer - 2);\n                const char* firstSpace = strchr(buffer, ' ');\n                if (!firstSpace) {\n                    status = 0;\n                    break;\n                }\n                result = atoi(firstSpace);\n                char* c = strchr(h, C);\n                char* first_newline = strchr(h, N);\n                while (c && first_newline && c < first_newline && h < buffer + body) {\n                    std::string key(h);\n                    std::string value(c + 1);\n                    key = key.substr(0, c - h);\n                    value = value.substr(0, first_newline - c - 1);\n                    response[key] = value;\n                    h = first_newline + 1;\n                    c = strchr(h, C);\n                    first_newline = strchr(h, N);\n                }\n            }\n\n            // if the buffer's full and we're still searching - give up!\n            // this handles the possibility that there are no headers\n            if (bSearching && buff_l - end < 10) {\n                bSearching = false;\n                body = 0;\n            }\n            if (!bSearching && OK(status)) {\n                flushBuffer(buffer, body, end, file);\n            }\n        }\n        n = forgive(recv(sockfd, buffer + end, (int)(buff_l - end), 0), err);\n        if (!n) {\n            Sleep(snooze);\n            sleep_ -= snooze;\n            if (sleep_ < 0)\n                n = FINISH;\n        }\n    }\n\n    if (n != FINISH || !OK(status)) {\n        snprintf(buffer, sizeof buffer, \"wsa_error = %d,n = %d,sleep_ = %d status = %d\", WSAGetLastError(), n, sleep_,\n                 status);\n        error(errors, buffer, nullptr, nullptr, 0);\n    } else if (bSearching && OK(status)) {\n        if (end) {\n            //  we finished OK without finding headers, flush the buffer\n            flushBuffer(buffer, 0, end, file);\n        } else {\n            auto errorCode = WSAGetLastError();\n            closesocket(server);\n            closesocket(sockfd);\n            return error(errors, \"error - no response from server = %s port = %s wsa_error = %d\", servername, port,\n                         errorCode);\n        }\n    }\n\n    ////////////////////////////////////\n    // close sockets\n    closesocket(server);\n    closesocket(sockfd);\n    response[\"body\"] = file;\n    return result;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145731,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "process_tgs_req(krb5_kdc_req *request, krb5_data *pkt,\n                const krb5_fulladdr *from, kdc_realm_t *kdc_active_realm,\n                krb5_data **response)\n{\n    krb5_keyblock * subkey = 0;\n    krb5_keyblock *header_key = NULL;\n    krb5_keyblock *stkt_server_key = NULL;\n    krb5_keyblock *subject_key;\n    krb5_db_entry *server = NULL;\n    krb5_db_entry *stkt_server = NULL;\n    krb5_db_entry *subject_server;\n    krb5_kdc_rep reply;\n    krb5_enc_kdc_rep_part reply_encpart;\n    krb5_ticket ticket_reply, *header_ticket = 0;\n    const krb5_ticket *stkt = NULL;\n    krb5_enc_tkt_part enc_tkt_reply;\n    int newtransited = 0;\n    krb5_error_code retval = 0;\n    krb5_keyblock server_keyblock, *encrypting_key;\n    krb5_timestamp kdc_time, authtime = 0;\n    krb5_keyblock session_key, local_tgt_key;\n    krb5_keyblock *reply_key = NULL;\n    krb5_principal cprinc = NULL, sprinc = NULL, altcprinc = NULL;\n    krb5_const_principal authdata_client;\n    krb5_principal stkt_authdata_client = NULL;\n    krb5_last_req_entry *nolrarray[2], nolrentry;\n    int errcode;\n    const char        *status = 0;\n    krb5_enc_tkt_part *header_enc_tkt = NULL; /* TGT */\n    krb5_enc_tkt_part *subject_tkt = NULL; /* TGT or evidence ticket */\n    krb5_db_entry *client = NULL, *header_server = NULL;\n    krb5_db_entry *local_tgt, *local_tgt_storage = NULL;\n    krb5_pa_s4u_x509_user *s4u_x509_user = NULL; /* protocol transition request */\n    krb5_authdata **kdc_issued_auth_data = NULL; /* auth data issued by KDC */\n    unsigned int c_flags = 0, s_flags = 0;       /* client/server KDB flags */\n    krb5_boolean is_referral, is_crossrealm;\n    const char *emsg = NULL;\n    krb5_kvno ticket_kvno = 0;\n    struct kdc_request_state *state = NULL;\n    krb5_pa_data *pa_tgs_req; /*points into request*/\n    krb5_data scratch;\n    krb5_pa_data **e_data = NULL;\n    krb5_audit_state *au_state = NULL;\n    krb5_data **auth_indicators = NULL;\n    void *ad_info = NULL, *stkt_ad_info = NULL;\n\n    memset(&reply, 0, sizeof(reply));\n    memset(&reply_encpart, 0, sizeof(reply_encpart));\n    memset(&ticket_reply, 0, sizeof(ticket_reply));\n    memset(&enc_tkt_reply, 0, sizeof(enc_tkt_reply));\n    memset(&server_keyblock, 0, sizeof(server_keyblock));\n    memset(&local_tgt_key, 0, sizeof(local_tgt_key));\n    session_key.contents = NULL;\n\n    /* Save pointer to client-requested service principal, in case of\n     * errors before a successful call to search_sprinc(). */\n    sprinc = request->server;\n\n    if (request->msg_type != KRB5_TGS_REQ) {\n        krb5_free_kdc_req(kdc_context, request);\n        return KRB5_BADMSGTYPE;\n    }\n\n    errcode = kdc_make_rstate(kdc_active_realm, &state);\n    if (errcode != 0)\n        goto cleanup;\n\n    /* Initialize audit state. */\n    errcode = kau_init_kdc_req(kdc_context, request, from, &au_state);\n    if (errcode)\n        goto cleanup;\n\n    /* Seed the audit trail with the request ID and basic information. */\n    kau_tgs_req(kdc_context, TRUE, au_state);\n\n    errcode = kdc_process_tgs_req(kdc_active_realm,\n                                  request, from, pkt, &header_ticket,\n                                  &header_server, &header_key, &subkey,\n                                  &pa_tgs_req);\n    if (header_ticket && header_ticket->enc_part2)\n        cprinc = header_ticket->enc_part2->client;\n\n    if (errcode) {\n        status = \"PROCESS_TGS\";\n        goto cleanup;\n    }\n\n    if (!header_ticket) {\n        errcode = KRB5_NO_TKT_SUPPLIED;        /* XXX? */\n        goto cleanup;\n    }\n    errcode = kau_make_tkt_id(kdc_context, header_ticket,\n                              &au_state->tkt_in_id);\n    if (errcode)\n        goto cleanup;\n\n    scratch.length = pa_tgs_req->length;\n    scratch.data = (char *) pa_tgs_req->contents;\n    errcode = kdc_find_fast(&request, &scratch, subkey,\n                            header_ticket->enc_part2->session, state, NULL);\n    /* Reset sprinc because kdc_find_fast() can replace request. */\n    sprinc = request->server;\n    if (errcode !=0) {\n        status = \"FIND_FAST\";\n        goto cleanup;\n    }\n\n    errcode = get_local_tgt(kdc_context, &sprinc->realm, header_server,\n                            &local_tgt, &local_tgt_storage, &local_tgt_key);\n    if (errcode) {\n        status = \"GET_LOCAL_TGT\";\n        goto cleanup;\n    }\n\n    /* Ignore (for now) the request modification due to FAST processing. */\n    au_state->request = request;\n\n    /*\n     * Pointer to the encrypted part of the header ticket, which may be\n     * replaced to point to the encrypted part of the evidence ticket\n     * if constrained delegation is used. This simplifies the number of\n     * special cases for constrained delegation.\n     */\n    header_enc_tkt = header_ticket->enc_part2;\n\n    /*\n     * We've already dealt with the AP_REQ authentication, so we can\n     * use header_ticket freely.  The encrypted part (if any) has been\n     * decrypted with the session key.\n     */\n\n    au_state->stage = SRVC_PRINC;\n\n    /* XXX make sure server here has the proper realm...taken from AP_REQ\n       header? */\n\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE)) {\n        setflag(c_flags, KRB5_KDB_FLAG_CANONICALIZE);\n        setflag(s_flags, KRB5_KDB_FLAG_CANONICALIZE);\n    }\n\n    errcode = search_sprinc(kdc_active_realm, request, s_flags, &server,\n                            &status);\n    if (errcode != 0)\n        goto cleanup;\n    sprinc = server->princ;\n\n    /* If we got a cross-realm TGS which is not the requested server, we are\n     * issuing a referral (or alternate TGT, which we treat similarly). */\n    is_referral = is_cross_tgs_principal(server->princ) &&\n        !krb5_principal_compare(kdc_context, request->server, server->princ);\n\n    au_state->stage = VALIDATE_POL;\n\n    if ((errcode = krb5_timeofday(kdc_context, &kdc_time)))\n        goto cleanup;\n\n    is_crossrealm = !data_eq(header_server->princ->realm, sprinc->realm);\n    if (is_crossrealm)\n        setflag(c_flags, KRB5_KDB_FLAG_CROSS_REALM);\n    if (is_referral)\n        setflag(c_flags, KRB5_KDB_FLAG_ISSUING_REFERRAL);\n\n    /* Check for protocol transition */\n    errcode = kdc_process_s4u2self_req(kdc_active_realm, request, server,\n                                       subkey, header_enc_tkt->session,\n                                       &s4u_x509_user, &client, &status);\n    if (s4u_x509_user != NULL || errcode != 0) {\n        if (s4u_x509_user != NULL)\n            au_state->s4u2self_user = s4u_x509_user->user_id.user;\n        au_state->status = status;\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        au_state->s4u2self_user = NULL;\n    }\n\n    /* For user-to-user and S4U2Proxy requests, decrypt the second ticket. */\n    errcode = decrypt_2ndtkt(kdc_active_realm, request, c_flags,\n                             &stkt, &stkt_server, &stkt_server_key, &status);\n    if (errcode)\n        goto cleanup;\n\n    retval = validate_tgs_request(kdc_active_realm, request, server,\n                                  header_ticket, stkt, stkt_server, kdc_time,\n                                  s4u_x509_user, client, is_crossrealm,\n                                  is_referral, &status, &e_data);\n    if (retval) {\n        if (retval == KDC_ERR_POLICY || retval == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        errcode = retval + ERROR_TABLE_BASE_krb5;\n        goto cleanup;\n    }\n\n    if (errcode)\n        goto cleanup;\n\n    if (s4u_x509_user != NULL && client == NULL) {\n        /*\n         * For an S4U2Self referral request (the requesting service is\n         * following a referral back to its own realm), the authdata in the\n         * header ticket should be for the requested client.\n         */\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n        authdata_client = s4u_x509_user->user_id.user;\n    } else {\n        /* Otherwise (including for initial S4U2Self requests), the authdata\n         * should be for the header ticket client. */\n        authdata_client = header_enc_tkt->client;\n    }\n    errcode = krb5_db_get_authdata_info(kdc_context, c_flags,\n                                        header_enc_tkt->authorization_data,\n                                        authdata_client, request->server,\n                                        header_key, &local_tgt_key, local_tgt,\n                                        header_enc_tkt->times.authtime,\n                                        &ad_info, NULL);\n    if (errcode && errcode != KRB5_PLUGIN_OP_NOTSUPP)\n        goto cleanup;\n\n    /* Flag all S4U2Self requests now that we have checked the authdata. */\n    if (s4u_x509_user != NULL)\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n\n    if (isflagset(request->kdc_options, KDC_OPT_CNAME_IN_ADDL_TKT)) {\n        /* Do constrained delegation protocol and authorization checks. */\n        setflag(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION);\n\n        errcode = kdc_process_s4u2proxy_req(kdc_active_realm, c_flags, request,\n                                            stkt->enc_part2, local_tgt,\n                                            &local_tgt_key, stkt_server,\n                                            stkt_server_key,\n                                            header_ticket->enc_part2->client,\n                                            server, request->server, ad_info,\n                                            &stkt_ad_info,\n                                            &stkt_authdata_client,\n                                            &status);\n        if (errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        else if (errcode)\n            au_state->violation = LOCAL_POLICY;\n        au_state->status = status;\n        retval = kau_make_tkt_id(kdc_context, stkt, &au_state->evid_tkt_id);\n        if (retval) {\n            errcode = retval;\n            goto cleanup;\n        }\n        kau_s4u2proxy(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n\n        assert(krb5_is_tgs_principal(header_ticket->server));\n\n        /* Use the parsed authdata from the second ticket during authdata\n         * handling. */\n        krb5_db_free_authdata_info(kdc_context, ad_info);\n        ad_info = stkt_ad_info;\n        stkt_ad_info = NULL;\n    }\n\n    au_state->stage = ISSUE_TKT;\n\n    errcode = gen_session_key(kdc_active_realm, request, server, &session_key,\n                              &status);\n    if (errcode)\n        goto cleanup;\n\n    /*\n     * subject_tkt will refer to the evidence ticket (for constrained\n     * delegation) or the TGT. The distinction from header_enc_tkt is\n     * necessary because the TGS signature only protects some fields:\n     * the others could be forged by a malicious server.\n     */\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        subject_tkt = stkt->enc_part2;\n        subject_server = stkt_server;\n        subject_key = stkt_server_key;\n    } else {\n        subject_tkt = header_enc_tkt;\n        subject_server = header_server;\n        subject_key = header_key;\n    }\n    authtime = subject_tkt->times.authtime;\n\n    /* Extract and check auth indicators from the subject ticket, except for\n     * S4U2Self requests (where the client didn't authenticate). */\n    if (s4u_x509_user == NULL) {\n        errcode = get_auth_indicators(kdc_context, subject_tkt, local_tgt,\n                                      &local_tgt_key, &auth_indicators);\n        if (errcode) {\n            status = \"GET_AUTH_INDICATORS\";\n            goto cleanup;\n        }\n\n        errcode = check_indicators(kdc_context, server, auth_indicators);\n        if (errcode) {\n            status = \"HIGHER_AUTHENTICATION_REQUIRED\";\n            goto cleanup;\n        }\n    }\n\n    if (is_referral)\n        ticket_reply.server = server->princ;\n    else\n        ticket_reply.server = request->server; /* XXX careful for realm... */\n\n    enc_tkt_reply.flags = get_ticket_flags(request->kdc_options, client,\n                                           server, header_enc_tkt);\n    enc_tkt_reply.times.starttime = 0;\n\n    /* OK_TO_AUTH_AS_DELEGATE must be set on the service requesting S4U2Self\n     * for forwardable tickets to be issued. */\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        !is_referral &&\n        !isflagset(server->attributes, KRB5_KDB_OK_TO_AUTH_AS_DELEGATE))\n        clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n\n    /* don't use new addresses unless forwarded, see below */\n\n    enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n    /* noaddrarray[0] = 0; */\n    reply_encpart.caddrs = 0;/* optional...don't put it in */\n    reply_encpart.enc_padata = NULL;\n\n    /*\n     * It should be noted that local policy may affect the\n     * processing of any of these flags.  For example, some\n     * realms may refuse to issue renewable tickets\n     */\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDED) ||\n        isflagset(request->kdc_options, KDC_OPT_PROXY)) {\n\n        /* include new addresses in ticket & reply */\n\n        enc_tkt_reply.caddrs = request->addresses;\n        reply_encpart.caddrs = request->addresses;\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_POSTDATED))\n        enc_tkt_reply.times.starttime = request->from;\n    else\n        enc_tkt_reply.times.starttime = kdc_time;\n\n    if (isflagset(request->kdc_options, KDC_OPT_VALIDATE)) {\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n        clear(enc_tkt_reply.flags, TKT_FLG_INVALID);\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_RENEW)) {\n        krb5_timestamp old_starttime;\n        krb5_deltat old_life;\n\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n\n        old_starttime = enc_tkt_reply.times.starttime ?\n            enc_tkt_reply.times.starttime : enc_tkt_reply.times.authtime;\n        old_life = ts_delta(enc_tkt_reply.times.endtime, old_starttime);\n\n        enc_tkt_reply.times.starttime = kdc_time;\n        enc_tkt_reply.times.endtime =\n            ts_min(header_ticket->enc_part2->times.renew_till,\n                   ts_incr(kdc_time, old_life));\n    } else {\n        /* not a renew request */\n        enc_tkt_reply.times.starttime = kdc_time;\n\n        kdc_get_ticket_endtime(kdc_active_realm, enc_tkt_reply.times.starttime,\n                               header_enc_tkt->times.endtime, request->till,\n                               client, server, &enc_tkt_reply.times.endtime);\n    }\n\n    kdc_get_ticket_renewtime(kdc_active_realm, request, header_enc_tkt, client,\n                             server, &enc_tkt_reply);\n\n    errcode = check_kdcpolicy_tgs(kdc_context, request, server, header_ticket,\n                                  auth_indicators, kdc_time,\n                                  &enc_tkt_reply.times, &status);\n    if (errcode)\n        goto cleanup;\n\n    /*\n     * Set authtime to be the same as header or evidence ticket's\n     */\n    enc_tkt_reply.times.authtime = authtime;\n\n    /* starttime is optional, and treated as authtime if not present.\n       so we can nuke it if it matches */\n    if (enc_tkt_reply.times.starttime == enc_tkt_reply.times.authtime)\n        enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n        altcprinc = s4u_x509_user->user_id.user;\n    } else if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /* kdc_process_s4u2proxy_req() only allows cross-realm requests if\n         * stkt_authdata_client is set. */\n        altcprinc = is_crossrealm ? stkt_authdata_client : subject_tkt->client;\n    } else {\n        altcprinc = NULL;\n    }\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        encrypting_key = stkt->enc_part2->session;\n    } else {\n        errcode = get_first_current_key(kdc_context, server, &server_keyblock);\n        if (errcode) {\n            status = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n        encrypting_key = &server_keyblock;\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /*\n         * Don't allow authorization data to be disabled if constrained\n         * delegation is requested. We don't want to deny the server\n         * the ability to validate that delegation was used.\n         */\n        clear(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED);\n    }\n    if (isflagset(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED) == 0) {\n        /* If we are not doing protocol transition, try to look up the subject\n         * principal so that KDB modules can add additional authdata. */\n        if (!isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n            /* Generate authorization data so we can include it in ticket */\n            setflag(c_flags, KRB5_KDB_FLAG_INCLUDE_PAC);\n            /* Map principals from foreign (possibly non-AD) realms */\n            setflag(c_flags, KRB5_KDB_FLAG_MAP_PRINCIPALS);\n\n            assert(client == NULL); /* should not have been set already */\n\n            errcode = krb5_db_get_principal(kdc_context, subject_tkt->client,\n                                            c_flags, &client);\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAGS_S4U) && !is_referral)\n        enc_tkt_reply.client = altcprinc;\n    else\n        enc_tkt_reply.client = header_enc_tkt->client;\n\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n    enc_tkt_reply.transited.tr_contents = empty_string; /* equivalent of \"\" */\n\n    /*\n     * Only add the realm of the presented tgt to the transited list if\n     * it is different than the server realm (cross-realm) and it is different\n     * than the realm of the client (since the realm of the client is already\n     * implicitly part of the transited list and should not be explicitly\n     * listed).\n     */\n    if (!is_crossrealm ||\n        krb5_realm_compare(kdc_context, header_ticket->server,\n                           enc_tkt_reply.client)) {\n        /* tgt issued by local realm or issued by realm of client */\n        enc_tkt_reply.transited = header_enc_tkt->transited;\n    } else {\n        /* tgt issued by some other realm and not the realm of the client */\n        /* assemble new transited field into allocated storage */\n        if (header_enc_tkt->transited.tr_type !=\n            KRB5_DOMAIN_X500_COMPRESS) {\n            status = \"VALIDATE_TRANSIT_TYPE\";\n            errcode = KRB5KDC_ERR_TRTYPE_NOSUPP;\n            goto cleanup;\n        }\n        memset(&enc_tkt_reply.transited, 0, sizeof(enc_tkt_reply.transited));\n        enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n        if ((errcode =\n             add_to_transited(&header_enc_tkt->transited.tr_contents,\n                              &enc_tkt_reply.transited.tr_contents,\n                              header_ticket->server,\n                              enc_tkt_reply.client,\n                              request->server))) {\n            status = \"ADD_TO_TRANSITED_LIST\";\n            goto cleanup;\n        }\n        newtransited = 1;\n    }\n    if (!isflagset (request->kdc_options, KDC_OPT_DISABLE_TRANSITED_CHECK)) {\n        errcode = kdc_check_transited_list (kdc_active_realm,\n                                            &enc_tkt_reply.transited.tr_contents,\n                                            krb5_princ_realm (kdc_context, header_enc_tkt->client),\n                                            krb5_princ_realm (kdc_context, request->server));\n        if (errcode == 0) {\n            setflag (enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED);\n        } else {\n            log_tgs_badtrans(kdc_context, cprinc, sprinc,\n                             &enc_tkt_reply.transited.tr_contents, errcode);\n        }\n    } else\n        krb5_klog_syslog(LOG_INFO, _(\"not checking transit path\"));\n    if (kdc_active_realm->realm_reject_bad_transit &&\n        !isflagset(enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED)) {\n        errcode = KRB5KDC_ERR_POLICY;\n        status = \"BAD_TRANSIT\";\n        au_state->violation = LOCAL_POLICY;\n        goto cleanup;\n    }\n\n    errcode = handle_authdata(kdc_context, c_flags, client, server,\n                              subject_server, local_tgt, &local_tgt_key,\n                              subkey != NULL ? subkey :\n                              header_ticket->enc_part2->session,\n                              encrypting_key, subject_key, pkt, request,\n                              altcprinc, ad_info, subject_tkt,\n                              &auth_indicators, &enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ : handle_authdata (%d)\"),\n                         errcode);\n        status = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    /* If we are doing user-to-user authentication, encrypt the ticket using\n     * the session key of the second ticket. */\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        ticket_kvno = 0;\n        ticket_reply.enc_part.enctype = stkt->enc_part2->session->enctype;\n        kau_u2u(kdc_context, TRUE, au_state);\n    } else {\n        ticket_kvno = current_kvno(server);\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, encrypting_key,\n                                    &ticket_reply);\n    if (errcode)\n        goto cleanup;\n    ticket_reply.enc_part.kvno = ticket_kvno;\n    /* Start assembling the response */\n    au_state->stage = ENCR_REP;\n    reply.msg_type = KRB5_TGS_REP;\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        krb5int_find_pa_data(kdc_context, request->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        errcode = kdc_make_s4u2self_rep(kdc_context,\n                                        subkey,\n                                        header_ticket->enc_part2->session,\n                                        s4u_x509_user,\n                                        &reply,\n                                        &reply_encpart);\n        if (errcode)\n            au_state->status = status;\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n    }\n\n    reply.client = enc_tkt_reply.client;\n    reply.enc_part.kvno = 0;/* We are using the session key */\n    reply.ticket = &ticket_reply;\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = request->nonce;\n\n    /* copy the time fields */\n    reply_encpart.times = enc_tkt_reply.times;\n\n    nolrentry.lr_type = KRB5_LRQ_NONE;\n    nolrentry.value = 0;\n    nolrentry.magic = 0;\n    nolrarray[0] = &nolrentry;\n    nolrarray[1] = 0;\n    reply_encpart.last_req = nolrarray;        /* not available for TGS reqs */\n    reply_encpart.key_exp = 0;/* ditto */\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    /* use the session key in the ticket, unless there's a subsession key\n       in the AP_REQ */\n    reply.enc_part.enctype = subkey ? subkey->enctype :\n        header_ticket->enc_part2->session->enctype;\n    errcode  = kdc_fast_response_handle_padata(state, request, &reply,\n                                               subkey ? subkey->enctype : header_ticket->enc_part2->session->enctype);\n    if (errcode)\n        goto cleanup;\n    errcode =kdc_fast_handle_reply_key(state,\n                                       subkey?subkey:header_ticket->enc_part2->session, &reply_key);\n    if (errcode)\n        goto cleanup;\n    errcode = return_enc_padata(kdc_context, pkt, request,\n                                reply_key, server, &reply_encpart,\n                                is_referral &&\n                                isflagset(s_flags,\n                                          KRB5_KDB_FLAG_CANONICALIZE));\n    if (errcode) {\n        status = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    errcode = kau_make_tkt_id(kdc_context, &ticket_reply, &au_state->tkt_out_id);\n    if (errcode)\n        goto cleanup;\n\n    if (kdc_fast_hide_client(state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_TGS_REP, &reply_encpart,\n                                  subkey ? 1 : 0,\n                                  reply_key,\n                                  &reply, response);\n    if (!errcode)\n        status = \"ISSUE\";\n\n    memset(ticket_reply.enc_part.ciphertext.data, 0,\n           ticket_reply.enc_part.ciphertext.length);\n    free(ticket_reply.enc_part.ciphertext.data);\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(reply.enc_part.ciphertext.data, 0,\n           reply.enc_part.ciphertext.length);\n    free(reply.enc_part.ciphertext.data);\n\ncleanup:\n    if (status == NULL)\n        status = \"UNKNOWN_REASON\";\n    krb5_free_keyblock_contents(kdc_context, &server_keyblock);\n    if (reply_key)\n        krb5_free_keyblock(kdc_context, reply_key);\n    if (stkt_server_key)\n        krb5_free_keyblock(kdc_context, stkt_server_key);\n    if (errcode)\n        emsg = krb5_get_error_message (kdc_context, errcode);\n\n    if (au_state != NULL) {\n        au_state->status = status;\n        if (!errcode)\n            au_state->reply = &reply;\n        kau_tgs_req(kdc_context, errcode ? FALSE : TRUE, au_state);\n        kau_free_kdc_req(au_state);\n    }\n\n    log_tgs_req(kdc_context, from, request, &reply, cprinc,\n                sprinc, altcprinc, authtime,\n                c_flags, status, errcode, emsg);\n    if (errcode) {\n        krb5_free_error_message (kdc_context, emsg);\n        emsg = NULL;\n    }\n\n    if (errcode && state != NULL) {\n        int got_err = 0;\n        if (status == 0) {\n            status = krb5_get_error_message (kdc_context, errcode);\n            got_err = 1;\n        }\n        errcode -= ERROR_TABLE_BASE_krb5;\n        if (errcode < 0 || errcode > KRB_ERR_MAX)\n            errcode = KRB_ERR_GENERIC;\n\n        retval = prepare_error_tgs(state, request, header_ticket, errcode,\n                                   (server != NULL) ? server->princ : NULL,\n                                   response, status, e_data);\n        if (got_err) {\n            krb5_free_error_message (kdc_context, status);\n            status = 0;\n        }\n    }\n\n    if (header_ticket != NULL)\n        krb5_free_ticket(kdc_context, header_ticket);\n    if (request != NULL)\n        krb5_free_kdc_req(kdc_context, request);\n    if (state)\n        kdc_free_rstate(state);\n    krb5_db_free_principal(kdc_context, server);\n    krb5_db_free_principal(kdc_context, stkt_server);\n    krb5_db_free_principal(kdc_context, header_server);\n    krb5_db_free_principal(kdc_context, client);\n    krb5_db_free_principal(kdc_context, local_tgt_storage);\n    if (local_tgt_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &local_tgt_key);\n    if (session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &session_key);\n    if (newtransited)\n        free(enc_tkt_reply.transited.tr_contents.data);\n    if (s4u_x509_user != NULL)\n        krb5_free_pa_s4u_x509_user(kdc_context, s4u_x509_user);\n    if (kdc_issued_auth_data != NULL)\n        krb5_free_authdata(kdc_context, kdc_issued_auth_data);\n    if (subkey != NULL)\n        krb5_free_keyblock(kdc_context, subkey);\n    if (header_key != NULL)\n        krb5_free_keyblock(kdc_context, header_key);\n    if (reply.padata)\n        krb5_free_pa_data(kdc_context, reply.padata);\n    if (reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, reply_encpart.enc_padata);\n    if (enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context, enc_tkt_reply.authorization_data);\n    krb5_free_pa_data(kdc_context, e_data);\n    k5_free_data_ptr_list(auth_indicators);\n    krb5_db_free_authdata_info(kdc_context, ad_info);\n    krb5_db_free_authdata_info(kdc_context, stkt_ad_info);\n    krb5_free_principal(kdc_context, stkt_authdata_client);\n\n    return retval;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145780,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "process_tgs_req(krb5_kdc_req *request, krb5_data *pkt,\n                const krb5_fulladdr *from, kdc_realm_t *kdc_active_realm,\n                krb5_data **response)\n{\n    krb5_keyblock * subkey = 0;\n    krb5_keyblock *header_key = NULL;\n    krb5_keyblock *stkt_server_key = NULL;\n    krb5_keyblock *subject_key;\n    krb5_db_entry *server = NULL;\n    krb5_db_entry *stkt_server = NULL;\n    krb5_db_entry *subject_server;\n    krb5_kdc_rep reply;\n    krb5_enc_kdc_rep_part reply_encpart;\n    krb5_ticket ticket_reply, *header_ticket = 0;\n    const krb5_ticket *stkt = NULL;\n    krb5_enc_tkt_part enc_tkt_reply;\n    int newtransited = 0;\n    krb5_error_code retval = 0;\n    krb5_keyblock server_keyblock, *encrypting_key;\n    krb5_timestamp kdc_time, authtime = 0;\n    krb5_keyblock session_key, local_tgt_key;\n    krb5_keyblock *reply_key = NULL;\n    krb5_principal cprinc = NULL, sprinc = NULL, altcprinc = NULL;\n    krb5_const_principal authdata_client;\n    krb5_principal stkt_authdata_client = NULL;\n    krb5_last_req_entry *nolrarray[2], nolrentry;\n    int errcode;\n    const char        *status = 0;\n    krb5_enc_tkt_part *header_enc_tkt = NULL; /* TGT */\n    krb5_enc_tkt_part *subject_tkt = NULL; /* TGT or evidence ticket */\n    krb5_db_entry *client = NULL, *header_server = NULL;\n    krb5_db_entry *local_tgt, *local_tgt_storage = NULL;\n    krb5_pa_s4u_x509_user *s4u_x509_user = NULL; /* protocol transition request */\n    krb5_authdata **kdc_issued_auth_data = NULL; /* auth data issued by KDC */\n    unsigned int c_flags = 0, s_flags = 0;       /* client/server KDB flags */\n    krb5_boolean is_referral, is_crossrealm;\n    const char *emsg = NULL;\n    krb5_kvno ticket_kvno = 0;\n    struct kdc_request_state *state = NULL;\n    krb5_pa_data *pa_tgs_req; /*points into request*/\n    krb5_data scratch;\n    krb5_pa_data **e_data = NULL;\n    krb5_audit_state *au_state = NULL;\n    krb5_data **auth_indicators = NULL;\n    void *ad_info = NULL, *stkt_ad_info = NULL;\n\n    memset(&reply, 0, sizeof(reply));\n    memset(&reply_encpart, 0, sizeof(reply_encpart));\n    memset(&ticket_reply, 0, sizeof(ticket_reply));\n    memset(&enc_tkt_reply, 0, sizeof(enc_tkt_reply));\n    memset(&server_keyblock, 0, sizeof(server_keyblock));\n    memset(&local_tgt_key, 0, sizeof(local_tgt_key));\n    session_key.contents = NULL;\n\n    /* Save pointer to client-requested service principal, in case of\n     * errors before a successful call to search_sprinc(). */\n    sprinc = request->server;\n\n    if (request->msg_type != KRB5_TGS_REQ) {\n        krb5_free_kdc_req(kdc_context, request);\n        return KRB5_BADMSGTYPE;\n    }\n\n    errcode = kdc_make_rstate(kdc_active_realm, &state);\n    if (errcode != 0)\n        goto cleanup;\n\n    /* Initialize audit state. */\n    errcode = kau_init_kdc_req(kdc_context, request, from, &au_state);\n    if (errcode)\n        goto cleanup;\n\n    /* Seed the audit trail with the request ID and basic information. */\n    kau_tgs_req(kdc_context, TRUE, au_state);\n\n    errcode = kdc_process_tgs_req(kdc_active_realm,\n                                  request, from, pkt, &header_ticket,\n                                  &header_server, &header_key, &subkey,\n                                  &pa_tgs_req);\n    if (header_ticket && header_ticket->enc_part2)\n        cprinc = header_ticket->enc_part2->client;\n\n    if (errcode) {\n        status = \"PROCESS_TGS\";\n        goto cleanup;\n    }\n\n    if (!header_ticket) {\n        errcode = KRB5_NO_TKT_SUPPLIED;        /* XXX? */\n        goto cleanup;\n    }\n    errcode = kau_make_tkt_id(kdc_context, header_ticket,\n                              &au_state->tkt_in_id);\n    if (errcode)\n        goto cleanup;\n\n    scratch.length = pa_tgs_req->length;\n    scratch.data = (char *) pa_tgs_req->contents;\n    errcode = kdc_find_fast(&request, &scratch, subkey,\n                            header_ticket->enc_part2->session, state, NULL);\n    /* Reset sprinc because kdc_find_fast() can replace request. */\n    sprinc = request->server;\n    if (errcode !=0) {\n        status = \"FIND_FAST\";\n        goto cleanup;\n    }\n    if (sprinc == NULL) {\n        status = \"NULL_SERVER\";\n        errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto cleanup;\n    }\n\n    errcode = get_local_tgt(kdc_context, &sprinc->realm, header_server,\n                            &local_tgt, &local_tgt_storage, &local_tgt_key);\n    if (errcode) {\n        status = \"GET_LOCAL_TGT\";\n        goto cleanup;\n    }\n\n    /* Ignore (for now) the request modification due to FAST processing. */\n    au_state->request = request;\n\n    /*\n     * Pointer to the encrypted part of the header ticket, which may be\n     * replaced to point to the encrypted part of the evidence ticket\n     * if constrained delegation is used. This simplifies the number of\n     * special cases for constrained delegation.\n     */\n    header_enc_tkt = header_ticket->enc_part2;\n\n    /*\n     * We've already dealt with the AP_REQ authentication, so we can\n     * use header_ticket freely.  The encrypted part (if any) has been\n     * decrypted with the session key.\n     */\n\n    au_state->stage = SRVC_PRINC;\n\n    /* XXX make sure server here has the proper realm...taken from AP_REQ\n       header? */\n\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE)) {\n        setflag(c_flags, KRB5_KDB_FLAG_CANONICALIZE);\n        setflag(s_flags, KRB5_KDB_FLAG_CANONICALIZE);\n    }\n\n    errcode = search_sprinc(kdc_active_realm, request, s_flags, &server,\n                            &status);\n    if (errcode != 0)\n        goto cleanup;\n    sprinc = server->princ;\n\n    /* If we got a cross-realm TGS which is not the requested server, we are\n     * issuing a referral (or alternate TGT, which we treat similarly). */\n    is_referral = is_cross_tgs_principal(server->princ) &&\n        !krb5_principal_compare(kdc_context, request->server, server->princ);\n\n    au_state->stage = VALIDATE_POL;\n\n    if ((errcode = krb5_timeofday(kdc_context, &kdc_time)))\n        goto cleanup;\n\n    is_crossrealm = !data_eq(header_server->princ->realm, sprinc->realm);\n    if (is_crossrealm)\n        setflag(c_flags, KRB5_KDB_FLAG_CROSS_REALM);\n    if (is_referral)\n        setflag(c_flags, KRB5_KDB_FLAG_ISSUING_REFERRAL);\n\n    /* Check for protocol transition */\n    errcode = kdc_process_s4u2self_req(kdc_active_realm, request, server,\n                                       subkey, header_enc_tkt->session,\n                                       &s4u_x509_user, &client, &status);\n    if (s4u_x509_user != NULL || errcode != 0) {\n        if (s4u_x509_user != NULL)\n            au_state->s4u2self_user = s4u_x509_user->user_id.user;\n        au_state->status = status;\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        au_state->s4u2self_user = NULL;\n    }\n\n    /* For user-to-user and S4U2Proxy requests, decrypt the second ticket. */\n    errcode = decrypt_2ndtkt(kdc_active_realm, request, c_flags,\n                             &stkt, &stkt_server, &stkt_server_key, &status);\n    if (errcode)\n        goto cleanup;\n\n    retval = validate_tgs_request(kdc_active_realm, request, server,\n                                  header_ticket, stkt, stkt_server, kdc_time,\n                                  s4u_x509_user, client, is_crossrealm,\n                                  is_referral, &status, &e_data);\n    if (retval) {\n        if (retval == KDC_ERR_POLICY || retval == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        errcode = retval + ERROR_TABLE_BASE_krb5;\n        goto cleanup;\n    }\n\n    if (errcode)\n        goto cleanup;\n\n    if (s4u_x509_user != NULL && client == NULL) {\n        /*\n         * For an S4U2Self referral request (the requesting service is\n         * following a referral back to its own realm), the authdata in the\n         * header ticket should be for the requested client.\n         */\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n        authdata_client = s4u_x509_user->user_id.user;\n    } else {\n        /* Otherwise (including for initial S4U2Self requests), the authdata\n         * should be for the header ticket client. */\n        authdata_client = header_enc_tkt->client;\n    }\n    errcode = krb5_db_get_authdata_info(kdc_context, c_flags,\n                                        header_enc_tkt->authorization_data,\n                                        authdata_client, request->server,\n                                        header_key, &local_tgt_key, local_tgt,\n                                        header_enc_tkt->times.authtime,\n                                        &ad_info, NULL);\n    if (errcode && errcode != KRB5_PLUGIN_OP_NOTSUPP)\n        goto cleanup;\n\n    /* Flag all S4U2Self requests now that we have checked the authdata. */\n    if (s4u_x509_user != NULL)\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n\n    if (isflagset(request->kdc_options, KDC_OPT_CNAME_IN_ADDL_TKT)) {\n        /* Do constrained delegation protocol and authorization checks. */\n        setflag(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION);\n\n        errcode = kdc_process_s4u2proxy_req(kdc_active_realm, c_flags, request,\n                                            stkt->enc_part2, local_tgt,\n                                            &local_tgt_key, stkt_server,\n                                            stkt_server_key,\n                                            header_ticket->enc_part2->client,\n                                            server, request->server, ad_info,\n                                            &stkt_ad_info,\n                                            &stkt_authdata_client,\n                                            &status);\n        if (errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        else if (errcode)\n            au_state->violation = LOCAL_POLICY;\n        au_state->status = status;\n        retval = kau_make_tkt_id(kdc_context, stkt, &au_state->evid_tkt_id);\n        if (retval) {\n            errcode = retval;\n            goto cleanup;\n        }\n        kau_s4u2proxy(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n\n        assert(krb5_is_tgs_principal(header_ticket->server));\n\n        /* Use the parsed authdata from the second ticket during authdata\n         * handling. */\n        krb5_db_free_authdata_info(kdc_context, ad_info);\n        ad_info = stkt_ad_info;\n        stkt_ad_info = NULL;\n    }\n\n    au_state->stage = ISSUE_TKT;\n\n    errcode = gen_session_key(kdc_active_realm, request, server, &session_key,\n                              &status);\n    if (errcode)\n        goto cleanup;\n\n    /*\n     * subject_tkt will refer to the evidence ticket (for constrained\n     * delegation) or the TGT. The distinction from header_enc_tkt is\n     * necessary because the TGS signature only protects some fields:\n     * the others could be forged by a malicious server.\n     */\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        subject_tkt = stkt->enc_part2;\n        subject_server = stkt_server;\n        subject_key = stkt_server_key;\n    } else {\n        subject_tkt = header_enc_tkt;\n        subject_server = header_server;\n        subject_key = header_key;\n    }\n    authtime = subject_tkt->times.authtime;\n\n    /* Extract and check auth indicators from the subject ticket, except for\n     * S4U2Self requests (where the client didn't authenticate). */\n    if (s4u_x509_user == NULL) {\n        errcode = get_auth_indicators(kdc_context, subject_tkt, local_tgt,\n                                      &local_tgt_key, &auth_indicators);\n        if (errcode) {\n            status = \"GET_AUTH_INDICATORS\";\n            goto cleanup;\n        }\n\n        errcode = check_indicators(kdc_context, server, auth_indicators);\n        if (errcode) {\n            status = \"HIGHER_AUTHENTICATION_REQUIRED\";\n            goto cleanup;\n        }\n    }\n\n    if (is_referral)\n        ticket_reply.server = server->princ;\n    else\n        ticket_reply.server = request->server; /* XXX careful for realm... */\n\n    enc_tkt_reply.flags = get_ticket_flags(request->kdc_options, client,\n                                           server, header_enc_tkt);\n    enc_tkt_reply.times.starttime = 0;\n\n    /* OK_TO_AUTH_AS_DELEGATE must be set on the service requesting S4U2Self\n     * for forwardable tickets to be issued. */\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        !is_referral &&\n        !isflagset(server->attributes, KRB5_KDB_OK_TO_AUTH_AS_DELEGATE))\n        clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n\n    /* don't use new addresses unless forwarded, see below */\n\n    enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n    /* noaddrarray[0] = 0; */\n    reply_encpart.caddrs = 0;/* optional...don't put it in */\n    reply_encpart.enc_padata = NULL;\n\n    /*\n     * It should be noted that local policy may affect the\n     * processing of any of these flags.  For example, some\n     * realms may refuse to issue renewable tickets\n     */\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDED) ||\n        isflagset(request->kdc_options, KDC_OPT_PROXY)) {\n\n        /* include new addresses in ticket & reply */\n\n        enc_tkt_reply.caddrs = request->addresses;\n        reply_encpart.caddrs = request->addresses;\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_POSTDATED))\n        enc_tkt_reply.times.starttime = request->from;\n    else\n        enc_tkt_reply.times.starttime = kdc_time;\n\n    if (isflagset(request->kdc_options, KDC_OPT_VALIDATE)) {\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n        clear(enc_tkt_reply.flags, TKT_FLG_INVALID);\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_RENEW)) {\n        krb5_timestamp old_starttime;\n        krb5_deltat old_life;\n\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n\n        old_starttime = enc_tkt_reply.times.starttime ?\n            enc_tkt_reply.times.starttime : enc_tkt_reply.times.authtime;\n        old_life = ts_delta(enc_tkt_reply.times.endtime, old_starttime);\n\n        enc_tkt_reply.times.starttime = kdc_time;\n        enc_tkt_reply.times.endtime =\n            ts_min(header_ticket->enc_part2->times.renew_till,\n                   ts_incr(kdc_time, old_life));\n    } else {\n        /* not a renew request */\n        enc_tkt_reply.times.starttime = kdc_time;\n\n        kdc_get_ticket_endtime(kdc_active_realm, enc_tkt_reply.times.starttime,\n                               header_enc_tkt->times.endtime, request->till,\n                               client, server, &enc_tkt_reply.times.endtime);\n    }\n\n    kdc_get_ticket_renewtime(kdc_active_realm, request, header_enc_tkt, client,\n                             server, &enc_tkt_reply);\n\n    errcode = check_kdcpolicy_tgs(kdc_context, request, server, header_ticket,\n                                  auth_indicators, kdc_time,\n                                  &enc_tkt_reply.times, &status);\n    if (errcode)\n        goto cleanup;\n\n    /*\n     * Set authtime to be the same as header or evidence ticket's\n     */\n    enc_tkt_reply.times.authtime = authtime;\n\n    /* starttime is optional, and treated as authtime if not present.\n       so we can nuke it if it matches */\n    if (enc_tkt_reply.times.starttime == enc_tkt_reply.times.authtime)\n        enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n        altcprinc = s4u_x509_user->user_id.user;\n    } else if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /* kdc_process_s4u2proxy_req() only allows cross-realm requests if\n         * stkt_authdata_client is set. */\n        altcprinc = is_crossrealm ? stkt_authdata_client : subject_tkt->client;\n    } else {\n        altcprinc = NULL;\n    }\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        encrypting_key = stkt->enc_part2->session;\n    } else {\n        errcode = get_first_current_key(kdc_context, server, &server_keyblock);\n        if (errcode) {\n            status = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n        encrypting_key = &server_keyblock;\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /*\n         * Don't allow authorization data to be disabled if constrained\n         * delegation is requested. We don't want to deny the server\n         * the ability to validate that delegation was used.\n         */\n        clear(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED);\n    }\n    if (isflagset(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED) == 0) {\n        /* If we are not doing protocol transition, try to look up the subject\n         * principal so that KDB modules can add additional authdata. */\n        if (!isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n            /* Generate authorization data so we can include it in ticket */\n            setflag(c_flags, KRB5_KDB_FLAG_INCLUDE_PAC);\n            /* Map principals from foreign (possibly non-AD) realms */\n            setflag(c_flags, KRB5_KDB_FLAG_MAP_PRINCIPALS);\n\n            assert(client == NULL); /* should not have been set already */\n\n            errcode = krb5_db_get_principal(kdc_context, subject_tkt->client,\n                                            c_flags, &client);\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAGS_S4U) && !is_referral)\n        enc_tkt_reply.client = altcprinc;\n    else\n        enc_tkt_reply.client = header_enc_tkt->client;\n\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n    enc_tkt_reply.transited.tr_contents = empty_string; /* equivalent of \"\" */\n\n    /*\n     * Only add the realm of the presented tgt to the transited list if\n     * it is different than the server realm (cross-realm) and it is different\n     * than the realm of the client (since the realm of the client is already\n     * implicitly part of the transited list and should not be explicitly\n     * listed).\n     */\n    if (!is_crossrealm ||\n        krb5_realm_compare(kdc_context, header_ticket->server,\n                           enc_tkt_reply.client)) {\n        /* tgt issued by local realm or issued by realm of client */\n        enc_tkt_reply.transited = header_enc_tkt->transited;\n    } else {\n        /* tgt issued by some other realm and not the realm of the client */\n        /* assemble new transited field into allocated storage */\n        if (header_enc_tkt->transited.tr_type !=\n            KRB5_DOMAIN_X500_COMPRESS) {\n            status = \"VALIDATE_TRANSIT_TYPE\";\n            errcode = KRB5KDC_ERR_TRTYPE_NOSUPP;\n            goto cleanup;\n        }\n        memset(&enc_tkt_reply.transited, 0, sizeof(enc_tkt_reply.transited));\n        enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n        if ((errcode =\n             add_to_transited(&header_enc_tkt->transited.tr_contents,\n                              &enc_tkt_reply.transited.tr_contents,\n                              header_ticket->server,\n                              enc_tkt_reply.client,\n                              request->server))) {\n            status = \"ADD_TO_TRANSITED_LIST\";\n            goto cleanup;\n        }\n        newtransited = 1;\n    }\n    if (!isflagset (request->kdc_options, KDC_OPT_DISABLE_TRANSITED_CHECK)) {\n        errcode = kdc_check_transited_list (kdc_active_realm,\n                                            &enc_tkt_reply.transited.tr_contents,\n                                            krb5_princ_realm (kdc_context, header_enc_tkt->client),\n                                            krb5_princ_realm (kdc_context, request->server));\n        if (errcode == 0) {\n            setflag (enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED);\n        } else {\n            log_tgs_badtrans(kdc_context, cprinc, sprinc,\n                             &enc_tkt_reply.transited.tr_contents, errcode);\n        }\n    } else\n        krb5_klog_syslog(LOG_INFO, _(\"not checking transit path\"));\n    if (kdc_active_realm->realm_reject_bad_transit &&\n        !isflagset(enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED)) {\n        errcode = KRB5KDC_ERR_POLICY;\n        status = \"BAD_TRANSIT\";\n        au_state->violation = LOCAL_POLICY;\n        goto cleanup;\n    }\n\n    errcode = handle_authdata(kdc_context, c_flags, client, server,\n                              subject_server, local_tgt, &local_tgt_key,\n                              subkey != NULL ? subkey :\n                              header_ticket->enc_part2->session,\n                              encrypting_key, subject_key, pkt, request,\n                              altcprinc, ad_info, subject_tkt,\n                              &auth_indicators, &enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ : handle_authdata (%d)\"),\n                         errcode);\n        status = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    /* If we are doing user-to-user authentication, encrypt the ticket using\n     * the session key of the second ticket. */\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        ticket_kvno = 0;\n        ticket_reply.enc_part.enctype = stkt->enc_part2->session->enctype;\n        kau_u2u(kdc_context, TRUE, au_state);\n    } else {\n        ticket_kvno = current_kvno(server);\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, encrypting_key,\n                                    &ticket_reply);\n    if (errcode)\n        goto cleanup;\n    ticket_reply.enc_part.kvno = ticket_kvno;\n    /* Start assembling the response */\n    au_state->stage = ENCR_REP;\n    reply.msg_type = KRB5_TGS_REP;\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        krb5int_find_pa_data(kdc_context, request->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        errcode = kdc_make_s4u2self_rep(kdc_context,\n                                        subkey,\n                                        header_ticket->enc_part2->session,\n                                        s4u_x509_user,\n                                        &reply,\n                                        &reply_encpart);\n        if (errcode)\n            au_state->status = status;\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n    }\n\n    reply.client = enc_tkt_reply.client;\n    reply.enc_part.kvno = 0;/* We are using the session key */\n    reply.ticket = &ticket_reply;\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = request->nonce;\n\n    /* copy the time fields */\n    reply_encpart.times = enc_tkt_reply.times;\n\n    nolrentry.lr_type = KRB5_LRQ_NONE;\n    nolrentry.value = 0;\n    nolrentry.magic = 0;\n    nolrarray[0] = &nolrentry;\n    nolrarray[1] = 0;\n    reply_encpart.last_req = nolrarray;        /* not available for TGS reqs */\n    reply_encpart.key_exp = 0;/* ditto */\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    /* use the session key in the ticket, unless there's a subsession key\n       in the AP_REQ */\n    reply.enc_part.enctype = subkey ? subkey->enctype :\n        header_ticket->enc_part2->session->enctype;\n    errcode  = kdc_fast_response_handle_padata(state, request, &reply,\n                                               subkey ? subkey->enctype : header_ticket->enc_part2->session->enctype);\n    if (errcode)\n        goto cleanup;\n    errcode =kdc_fast_handle_reply_key(state,\n                                       subkey?subkey:header_ticket->enc_part2->session, &reply_key);\n    if (errcode)\n        goto cleanup;\n    errcode = return_enc_padata(kdc_context, pkt, request,\n                                reply_key, server, &reply_encpart,\n                                is_referral &&\n                                isflagset(s_flags,\n                                          KRB5_KDB_FLAG_CANONICALIZE));\n    if (errcode) {\n        status = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    errcode = kau_make_tkt_id(kdc_context, &ticket_reply, &au_state->tkt_out_id);\n    if (errcode)\n        goto cleanup;\n\n    if (kdc_fast_hide_client(state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_TGS_REP, &reply_encpart,\n                                  subkey ? 1 : 0,\n                                  reply_key,\n                                  &reply, response);\n    if (!errcode)\n        status = \"ISSUE\";\n\n    memset(ticket_reply.enc_part.ciphertext.data, 0,\n           ticket_reply.enc_part.ciphertext.length);\n    free(ticket_reply.enc_part.ciphertext.data);\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(reply.enc_part.ciphertext.data, 0,\n           reply.enc_part.ciphertext.length);\n    free(reply.enc_part.ciphertext.data);\n\ncleanup:\n    if (status == NULL)\n        status = \"UNKNOWN_REASON\";\n    krb5_free_keyblock_contents(kdc_context, &server_keyblock);\n    if (reply_key)\n        krb5_free_keyblock(kdc_context, reply_key);\n    if (stkt_server_key)\n        krb5_free_keyblock(kdc_context, stkt_server_key);\n    if (errcode)\n        emsg = krb5_get_error_message (kdc_context, errcode);\n\n    if (au_state != NULL) {\n        au_state->status = status;\n        if (!errcode)\n            au_state->reply = &reply;\n        kau_tgs_req(kdc_context, errcode ? FALSE : TRUE, au_state);\n        kau_free_kdc_req(au_state);\n    }\n\n    log_tgs_req(kdc_context, from, request, &reply, cprinc,\n                sprinc, altcprinc, authtime,\n                c_flags, status, errcode, emsg);\n    if (errcode) {\n        krb5_free_error_message (kdc_context, emsg);\n        emsg = NULL;\n    }\n\n    if (errcode && state != NULL) {\n        int got_err = 0;\n        if (status == 0) {\n            status = krb5_get_error_message (kdc_context, errcode);\n            got_err = 1;\n        }\n        errcode -= ERROR_TABLE_BASE_krb5;\n        if (errcode < 0 || errcode > KRB_ERR_MAX)\n            errcode = KRB_ERR_GENERIC;\n\n        retval = prepare_error_tgs(state, request, header_ticket, errcode,\n                                   (server != NULL) ? server->princ : NULL,\n                                   response, status, e_data);\n        if (got_err) {\n            krb5_free_error_message (kdc_context, status);\n            status = 0;\n        }\n    }\n\n    if (header_ticket != NULL)\n        krb5_free_ticket(kdc_context, header_ticket);\n    if (request != NULL)\n        krb5_free_kdc_req(kdc_context, request);\n    if (state)\n        kdc_free_rstate(state);\n    krb5_db_free_principal(kdc_context, server);\n    krb5_db_free_principal(kdc_context, stkt_server);\n    krb5_db_free_principal(kdc_context, header_server);\n    krb5_db_free_principal(kdc_context, client);\n    krb5_db_free_principal(kdc_context, local_tgt_storage);\n    if (local_tgt_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &local_tgt_key);\n    if (session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &session_key);\n    if (newtransited)\n        free(enc_tkt_reply.transited.tr_contents.data);\n    if (s4u_x509_user != NULL)\n        krb5_free_pa_s4u_x509_user(kdc_context, s4u_x509_user);\n    if (kdc_issued_auth_data != NULL)\n        krb5_free_authdata(kdc_context, kdc_issued_auth_data);\n    if (subkey != NULL)\n        krb5_free_keyblock(kdc_context, subkey);\n    if (header_key != NULL)\n        krb5_free_keyblock(kdc_context, header_key);\n    if (reply.padata)\n        krb5_free_pa_data(kdc_context, reply.padata);\n    if (reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, reply_encpart.enc_padata);\n    if (enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context, enc_tkt_reply.authorization_data);\n    krb5_free_pa_data(kdc_context, e_data);\n    k5_free_data_ptr_list(auth_indicators);\n    krb5_db_free_authdata_info(kdc_context, ad_info);\n    krb5_db_free_authdata_info(kdc_context, stkt_ad_info);\n    krb5_free_principal(kdc_context, stkt_authdata_client);\n\n    return retval;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145781,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target){\n  Vdbe *v = pParse->pVdbe;  /* The VM under construction */\n  int op;                   /* The opcode being coded */\n  int inReg = target;       /* Results stored in register inReg */\n  int regFree1 = 0;         /* If non-zero free this temporary register */\n  int regFree2 = 0;         /* If non-zero free this temporary register */\n  int r1, r2;               /* Various register numbers */\n  Expr tempX;               /* Temporary expression node */\n  int p5 = 0;\n\n  assert( target>0 && target<=pParse->nMem );\n  if( v==0 ){\n    assert( pParse->db->mallocFailed );\n    return 0;\n  }\n\nexpr_code_doover:\n  if( pExpr==0 ){\n    op = TK_NULL;\n  }else{\n    op = pExpr->op;\n  }\n  switch( op ){\n    case TK_AGG_COLUMN: {\n      AggInfo *pAggInfo = pExpr->pAggInfo;\n      struct AggInfo_col *pCol = &pAggInfo->aCol[pExpr->iAgg];\n      if( !pAggInfo->directMode ){\n        assert( pCol->iMem>0 );\n        return pCol->iMem;\n      }else if( pAggInfo->useSortingIdx ){\n        sqlite3VdbeAddOp3(v, OP_Column, pAggInfo->sortingIdxPTab,\n                              pCol->iSorterColumn, target);\n        return target;\n      }\n      /* Otherwise, fall thru into the TK_COLUMN case */\n    }\n    case TK_COLUMN: {\n      int iTab = pExpr->iTable;\n      if( ExprHasProperty(pExpr, EP_FixedCol) ){\n        /* This COLUMN expression is really a constant due to WHERE clause\n        ** constraints, and that constant is coded by the pExpr->pLeft\n        ** expresssion.  However, make sure the constant has the correct\n        ** datatype by applying the Affinity of the table column to the\n        ** constant.\n        */\n        int iReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft,target);\n        int aff = sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);\n        if( aff>SQLITE_AFF_BLOB ){\n          static const char zAff[] = \"B\\000C\\000D\\000E\";\n          assert( SQLITE_AFF_BLOB=='A' );\n          assert( SQLITE_AFF_TEXT=='B' );\n          if( iReg!=target ){\n            sqlite3VdbeAddOp2(v, OP_SCopy, iReg, target);\n            iReg = target;\n          }\n          sqlite3VdbeAddOp4(v, OP_Affinity, iReg, 1, 0,\n                            &zAff[(aff-'B')*2], P4_STATIC);\n        }\n        return iReg;\n      }\n      if( iTab<0 ){\n        if( pParse->iSelfTab<0 ){\n          /* Other columns in the same row for CHECK constraints or\n          ** generated columns or for inserting into partial index.\n          ** The row is unpacked into registers beginning at\n          ** 0-(pParse->iSelfTab).  The rowid (if any) is in a register\n          ** immediately prior to the first column.\n          */\n          Column *pCol;\n          Table *pTab = pExpr->y.pTab;\n          int iSrc;\n          int iCol = pExpr->iColumn;\n          assert( pTab!=0 );\n          assert( iCol>=XN_ROWID );\n          assert( iCol<pExpr->y.pTab->nCol );\n          if( iCol<0 ){\n            return -1-pParse->iSelfTab;\n          }\n          pCol = pTab->aCol + iCol;\n          testcase( iCol!=sqlite3TableColumnToStorage(pTab,iCol) );\n          iSrc = sqlite3TableColumnToStorage(pTab, iCol) - pParse->iSelfTab;\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n          if( pCol->colFlags & COLFLAG_GENERATED ){\n            if( pCol->colFlags & COLFLAG_BUSY ){\n              sqlite3ErrorMsg(pParse, \"generated column loop on \\\"%s\\\"\",\n                              pCol->zName);\n              return 0;\n            }\n            pCol->colFlags |= COLFLAG_BUSY;\n            if( pCol->colFlags & COLFLAG_NOTAVAIL ){\n              sqlite3ExprCodeGeneratedColumn(pParse, pCol, iSrc);\n            }\n            pCol->colFlags &= ~(COLFLAG_BUSY|COLFLAG_NOTAVAIL);\n            return iSrc;\n          }else\n#endif /* SQLITE_OMIT_GENERATED_COLUMNS */\n          if( pCol->affinity==SQLITE_AFF_REAL ){\n            sqlite3VdbeAddOp2(v, OP_SCopy, iSrc, target);\n            sqlite3VdbeAddOp1(v, OP_RealAffinity, target);\n            return target;\n          }else{\n            return iSrc;\n          }\n        }else{\n          /* Coding an expression that is part of an index where column names\n          ** in the index refer to the table to which the index belongs */\n          iTab = pParse->iSelfTab - 1;\n        }\n      }\n      return sqlite3ExprCodeGetColumn(pParse, pExpr->y.pTab,\n                               pExpr->iColumn, iTab, target,\n                               pExpr->op2);\n    }\n    case TK_INTEGER: {\n      codeInteger(pParse, pExpr, 0, target);\n      return target;\n    }\n    case TK_TRUEFALSE: {\n      sqlite3VdbeAddOp2(v, OP_Integer, sqlite3ExprTruthValue(pExpr), target);\n      return target;\n    }\n#ifndef SQLITE_OMIT_FLOATING_POINT\n    case TK_FLOAT: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      codeReal(v, pExpr->u.zToken, 0, target);\n      return target;\n    }\n#endif\n    case TK_STRING: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      sqlite3VdbeLoadString(v, target, pExpr->u.zToken);\n      return target;\n    }\n    case TK_NULL: {\n      sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n      return target;\n    }\n#ifndef SQLITE_OMIT_BLOB_LITERAL\n    case TK_BLOB: {\n      int n;\n      const char *z;\n      char *zBlob;\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      assert( pExpr->u.zToken[0]=='x' || pExpr->u.zToken[0]=='X' );\n      assert( pExpr->u.zToken[1]=='\\'' );\n      z = &pExpr->u.zToken[2];\n      n = sqlite3Strlen30(z) - 1;\n      assert( z[n]=='\\'' );\n      zBlob = sqlite3HexToBlob(sqlite3VdbeDb(v), z, n);\n      sqlite3VdbeAddOp4(v, OP_Blob, n/2, target, 0, zBlob, P4_DYNAMIC);\n      return target;\n    }\n#endif\n    case TK_VARIABLE: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      assert( pExpr->u.zToken!=0 );\n      assert( pExpr->u.zToken[0]!=0 );\n      sqlite3VdbeAddOp2(v, OP_Variable, pExpr->iColumn, target);\n      if( pExpr->u.zToken[1]!=0 ){\n        const char *z = sqlite3VListNumToName(pParse->pVList, pExpr->iColumn);\n        assert( pExpr->u.zToken[0]=='?' || strcmp(pExpr->u.zToken, z)==0 );\n        pParse->pVList[0] = 0; /* Indicate VList may no longer be enlarged */\n        sqlite3VdbeAppendP4(v, (char*)z, P4_STATIC);\n      }\n      return target;\n    }\n    case TK_REGISTER: {\n      return pExpr->iTable;\n    }\n#ifndef SQLITE_OMIT_CAST\n    case TK_CAST: {\n      /* Expressions of the form:   CAST(pLeft AS token) */\n      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n      if( inReg!=target ){\n        sqlite3VdbeAddOp2(v, OP_SCopy, inReg, target);\n        inReg = target;\n      }\n      sqlite3VdbeAddOp2(v, OP_Cast, target,\n                        sqlite3AffinityType(pExpr->u.zToken, 0));\n      return inReg;\n    }\n#endif /* SQLITE_OMIT_CAST */\n    case TK_IS:\n    case TK_ISNOT:\n      op = (op==TK_IS) ? TK_EQ : TK_NE;\n      p5 = SQLITE_NULLEQ;\n      /* fall-through */\n    case TK_LT:\n    case TK_LE:\n    case TK_GT:\n    case TK_GE:\n    case TK_NE:\n    case TK_EQ: {\n      Expr *pLeft = pExpr->pLeft;\n      if( sqlite3ExprIsVector(pLeft) ){\n        codeVectorCompare(pParse, pExpr, target, op, p5);\n      }else{\n        r1 = sqlite3ExprCodeTemp(pParse, pLeft, &regFree1);\n        r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n        codeCompare(pParse, pLeft, pExpr->pRight, op,\n            r1, r2, inReg, SQLITE_STOREP2 | p5,\n            ExprHasProperty(pExpr,EP_Commuted));\n        assert(TK_LT==OP_Lt); testcase(op==OP_Lt); VdbeCoverageIf(v,op==OP_Lt);\n        assert(TK_LE==OP_Le); testcase(op==OP_Le); VdbeCoverageIf(v,op==OP_Le);\n        assert(TK_GT==OP_Gt); testcase(op==OP_Gt); VdbeCoverageIf(v,op==OP_Gt);\n        assert(TK_GE==OP_Ge); testcase(op==OP_Ge); VdbeCoverageIf(v,op==OP_Ge);\n        assert(TK_EQ==OP_Eq); testcase(op==OP_Eq); VdbeCoverageIf(v,op==OP_Eq);\n        assert(TK_NE==OP_Ne); testcase(op==OP_Ne); VdbeCoverageIf(v,op==OP_Ne);\n        testcase( regFree1==0 );\n        testcase( regFree2==0 );\n      }\n      break;\n    }\n    case TK_AND:\n    case TK_OR:\n    case TK_PLUS:\n    case TK_STAR:\n    case TK_MINUS:\n    case TK_REM:\n    case TK_BITAND:\n    case TK_BITOR:\n    case TK_SLASH:\n    case TK_LSHIFT:\n    case TK_RSHIFT: \n    case TK_CONCAT: {\n      assert( TK_AND==OP_And );            testcase( op==TK_AND );\n      assert( TK_OR==OP_Or );              testcase( op==TK_OR );\n      assert( TK_PLUS==OP_Add );           testcase( op==TK_PLUS );\n      assert( TK_MINUS==OP_Subtract );     testcase( op==TK_MINUS );\n      assert( TK_REM==OP_Remainder );      testcase( op==TK_REM );\n      assert( TK_BITAND==OP_BitAnd );      testcase( op==TK_BITAND );\n      assert( TK_BITOR==OP_BitOr );        testcase( op==TK_BITOR );\n      assert( TK_SLASH==OP_Divide );       testcase( op==TK_SLASH );\n      assert( TK_LSHIFT==OP_ShiftLeft );   testcase( op==TK_LSHIFT );\n      assert( TK_RSHIFT==OP_ShiftRight );  testcase( op==TK_RSHIFT );\n      assert( TK_CONCAT==OP_Concat );      testcase( op==TK_CONCAT );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n      sqlite3VdbeAddOp3(v, op, r2, r1, target);\n      testcase( regFree1==0 );\n      testcase( regFree2==0 );\n      break;\n    }\n    case TK_UMINUS: {\n      Expr *pLeft = pExpr->pLeft;\n      assert( pLeft );\n      if( pLeft->op==TK_INTEGER ){\n        codeInteger(pParse, pLeft, 1, target);\n        return target;\n#ifndef SQLITE_OMIT_FLOATING_POINT\n      }else if( pLeft->op==TK_FLOAT ){\n        assert( !ExprHasProperty(pExpr, EP_IntValue) );\n        codeReal(v, pLeft->u.zToken, 1, target);\n        return target;\n#endif\n      }else{\n        tempX.op = TK_INTEGER;\n        tempX.flags = EP_IntValue|EP_TokenOnly;\n        tempX.u.iValue = 0;\n        r1 = sqlite3ExprCodeTemp(pParse, &tempX, &regFree1);\n        r2 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree2);\n        sqlite3VdbeAddOp3(v, OP_Subtract, r2, r1, target);\n        testcase( regFree2==0 );\n      }\n      break;\n    }\n    case TK_BITNOT:\n    case TK_NOT: {\n      assert( TK_BITNOT==OP_BitNot );   testcase( op==TK_BITNOT );\n      assert( TK_NOT==OP_Not );         testcase( op==TK_NOT );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      testcase( regFree1==0 );\n      sqlite3VdbeAddOp2(v, op, r1, inReg);\n      break;\n    }\n    case TK_TRUTH: {\n      int isTrue;    /* IS TRUE or IS NOT TRUE */\n      int bNormal;   /* IS TRUE or IS FALSE */\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      testcase( regFree1==0 );\n      isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n      bNormal = pExpr->op2==TK_IS;\n      testcase( isTrue && bNormal);\n      testcase( !isTrue && bNormal);\n      sqlite3VdbeAddOp4Int(v, OP_IsTrue, r1, inReg, !isTrue, isTrue ^ bNormal);\n      break;\n    }\n    case TK_ISNULL:\n    case TK_NOTNULL: {\n      int addr;\n      assert( TK_ISNULL==OP_IsNull );   testcase( op==TK_ISNULL );\n      assert( TK_NOTNULL==OP_NotNull ); testcase( op==TK_NOTNULL );\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, target);\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      testcase( regFree1==0 );\n      addr = sqlite3VdbeAddOp1(v, op, r1);\n      VdbeCoverageIf(v, op==TK_ISNULL);\n      VdbeCoverageIf(v, op==TK_NOTNULL);\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, target);\n      sqlite3VdbeJumpHere(v, addr);\n      break;\n    }\n    case TK_AGG_FUNCTION: {\n      AggInfo *pInfo = pExpr->pAggInfo;\n      if( pInfo==0 ){\n        assert( !ExprHasProperty(pExpr, EP_IntValue) );\n        sqlite3ErrorMsg(pParse, \"misuse of aggregate: %s()\", pExpr->u.zToken);\n      }else{\n        return pInfo->aFunc[pExpr->iAgg].iMem;\n      }\n      break;\n    }\n    case TK_FUNCTION: {\n      ExprList *pFarg;       /* List of function arguments */\n      int nFarg;             /* Number of function arguments */\n      FuncDef *pDef;         /* The function definition object */\n      const char *zId;       /* The function name */\n      u32 constMask = 0;     /* Mask of function arguments that are constant */\n      int i;                 /* Loop counter */\n      sqlite3 *db = pParse->db;  /* The database connection */\n      u8 enc = ENC(db);      /* The text encoding used by this database */\n      CollSeq *pColl = 0;    /* A collating sequence */\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n      if( ExprHasProperty(pExpr, EP_WinFunc) ){\n        return pExpr->y.pWin->regResult;\n      }\n#endif\n\n      if( ConstFactorOk(pParse) && sqlite3ExprIsConstantNotJoin(pExpr) ){\n        /* SQL functions can be expensive. So try to move constant functions\n        ** out of the inner loop, even if that means an extra OP_Copy. */\n        return sqlite3ExprCodeAtInit(pParse, pExpr, -1);\n      }\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n      if( ExprHasProperty(pExpr, EP_TokenOnly) ){\n        pFarg = 0;\n      }else{\n        pFarg = pExpr->x.pList;\n      }\n      nFarg = pFarg ? pFarg->nExpr : 0;\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      zId = pExpr->u.zToken;\n      pDef = sqlite3FindFunction(db, zId, nFarg, enc, 0);\n#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION\n      if( pDef==0 && pParse->explain ){\n        pDef = sqlite3FindFunction(db, \"unknown\", nFarg, enc, 0);\n      }\n#endif\n      if( pDef==0 || pDef->xFinalize!=0 ){\n        sqlite3ErrorMsg(pParse, \"unknown function: %s()\", zId);\n        break;\n      }\n\n      /* Attempt a direct implementation of the built-in COALESCE() and\n      ** IFNULL() functions.  This avoids unnecessary evaluation of\n      ** arguments past the first non-NULL argument.\n      */\n      if( pDef->funcFlags & SQLITE_FUNC_COALESCE ){\n        int endCoalesce = sqlite3VdbeMakeLabel(pParse);\n        assert( nFarg>=2 );\n        sqlite3ExprCode(pParse, pFarg->a[0].pExpr, target);\n        for(i=1; i<nFarg; i++){\n          sqlite3VdbeAddOp2(v, OP_NotNull, target, endCoalesce);\n          VdbeCoverage(v);\n          sqlite3ExprCode(pParse, pFarg->a[i].pExpr, target);\n        }\n        sqlite3VdbeResolveLabel(v, endCoalesce);\n        break;\n      }\n\n      /* The UNLIKELY() function is a no-op.  The result is the value\n      ** of the first argument.\n      */\n      if( pDef->funcFlags & SQLITE_FUNC_UNLIKELY ){\n        assert( nFarg>=1 );\n        return sqlite3ExprCodeTarget(pParse, pFarg->a[0].pExpr, target);\n      }\n\n#ifdef SQLITE_DEBUG\n      /* The AFFINITY() function evaluates to a string that describes\n      ** the type affinity of the argument.  This is used for testing of\n      ** the SQLite type logic.\n      */\n      if( pDef->funcFlags & SQLITE_FUNC_AFFINITY ){\n        const char *azAff[] = { \"blob\", \"text\", \"numeric\", \"integer\", \"real\" };\n        char aff;\n        assert( nFarg==1 );\n        aff = sqlite3ExprAffinity(pFarg->a[0].pExpr);\n        sqlite3VdbeLoadString(v, target, \n                (aff<=SQLITE_AFF_NONE) ? \"none\" : azAff[aff-SQLITE_AFF_BLOB]);\n        return target;\n      }\n#endif\n\n      for(i=0; i<nFarg; i++){\n        if( i<32 && sqlite3ExprIsConstant(pFarg->a[i].pExpr) ){\n          testcase( i==31 );\n          constMask |= MASKBIT32(i);\n        }\n        if( (pDef->funcFlags & SQLITE_FUNC_NEEDCOLL)!=0 && !pColl ){\n          pColl = sqlite3ExprCollSeq(pParse, pFarg->a[i].pExpr);\n        }\n      }\n      if( pFarg ){\n        if( constMask ){\n          r1 = pParse->nMem+1;\n          pParse->nMem += nFarg;\n        }else{\n          r1 = sqlite3GetTempRange(pParse, nFarg);\n        }\n\n        /* For length() and typeof() functions with a column argument,\n        ** set the P5 parameter to the OP_Column opcode to OPFLAG_LENGTHARG\n        ** or OPFLAG_TYPEOFARG respectively, to avoid unnecessary data\n        ** loading.\n        */\n        if( (pDef->funcFlags & (SQLITE_FUNC_LENGTH|SQLITE_FUNC_TYPEOF))!=0 ){\n          u8 exprOp;\n          assert( nFarg==1 );\n          assert( pFarg->a[0].pExpr!=0 );\n          exprOp = pFarg->a[0].pExpr->op;\n          if( exprOp==TK_COLUMN || exprOp==TK_AGG_COLUMN ){\n            assert( SQLITE_FUNC_LENGTH==OPFLAG_LENGTHARG );\n            assert( SQLITE_FUNC_TYPEOF==OPFLAG_TYPEOFARG );\n            testcase( pDef->funcFlags & OPFLAG_LENGTHARG );\n            pFarg->a[0].pExpr->op2 = \n                  pDef->funcFlags & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG);\n          }\n        }\n\n        sqlite3ExprCodeExprList(pParse, pFarg, r1, 0,\n                                SQLITE_ECEL_DUP|SQLITE_ECEL_FACTOR);\n      }else{\n        r1 = 0;\n      }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n      /* Possibly overload the function if the first argument is\n      ** a virtual table column.\n      **\n      ** For infix functions (LIKE, GLOB, REGEXP, and MATCH) use the\n      ** second argument, not the first, as the argument to test to\n      ** see if it is a column in a virtual table.  This is done because\n      ** the left operand of infix functions (the operand we want to\n      ** control overloading) ends up as the second argument to the\n      ** function.  The expression \"A glob B\" is equivalent to \n      ** \"glob(B,A).  We want to use the A in \"A glob B\" to test\n      ** for function overloading.  But we use the B term in \"glob(B,A)\".\n      */\n      if( nFarg>=2 && ExprHasProperty(pExpr, EP_InfixFunc) ){\n        pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[1].pExpr);\n      }else if( nFarg>0 ){\n        pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[0].pExpr);\n      }\n#endif\n      if( pDef->funcFlags & SQLITE_FUNC_NEEDCOLL ){\n        if( !pColl ) pColl = db->pDfltColl; \n        sqlite3VdbeAddOp4(v, OP_CollSeq, 0, 0, 0, (char *)pColl, P4_COLLSEQ);\n      }\n#ifdef SQLITE_ENABLE_OFFSET_SQL_FUNC\n      if( pDef->funcFlags & SQLITE_FUNC_OFFSET ){\n        Expr *pArg = pFarg->a[0].pExpr;\n        if( pArg->op==TK_COLUMN ){\n          sqlite3VdbeAddOp3(v, OP_Offset, pArg->iTable, pArg->iColumn, target);\n        }else{\n          sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n        }\n      }else\n#endif\n      {\n        sqlite3VdbeAddFunctionCall(pParse, constMask, r1, target, nFarg,\n                                   pDef, pExpr->op2);\n      }\n      if( nFarg && constMask==0 ){\n        sqlite3ReleaseTempRange(pParse, r1, nFarg);\n      }\n      return target;\n    }\n#ifndef SQLITE_OMIT_SUBQUERY\n    case TK_EXISTS:\n    case TK_SELECT: {\n      int nCol;\n      testcase( op==TK_EXISTS );\n      testcase( op==TK_SELECT );\n      if( op==TK_SELECT && (nCol = pExpr->x.pSelect->pEList->nExpr)!=1 ){\n        sqlite3SubselectError(pParse, nCol, 1);\n      }else{\n        return sqlite3CodeSubselect(pParse, pExpr);\n      }\n      break;\n    }\n    case TK_SELECT_COLUMN: {\n      int n;\n      if( pExpr->pLeft->iTable==0 ){\n        pExpr->pLeft->iTable = sqlite3CodeSubselect(pParse, pExpr->pLeft);\n      }\n      assert( pExpr->iTable==0 || pExpr->pLeft->op==TK_SELECT );\n      if( pExpr->iTable!=0\n       && pExpr->iTable!=(n = sqlite3ExprVectorSize(pExpr->pLeft))\n      ){\n        sqlite3ErrorMsg(pParse, \"%d columns assigned %d values\",\n                                pExpr->iTable, n);\n      }\n      return pExpr->pLeft->iTable + pExpr->iColumn;\n    }\n    case TK_IN: {\n      int destIfFalse = sqlite3VdbeMakeLabel(pParse);\n      int destIfNull = sqlite3VdbeMakeLabel(pParse);\n      sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n      sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, target);\n      sqlite3VdbeResolveLabel(v, destIfFalse);\n      sqlite3VdbeAddOp2(v, OP_AddImm, target, 0);\n      sqlite3VdbeResolveLabel(v, destIfNull);\n      return target;\n    }\n#endif /* SQLITE_OMIT_SUBQUERY */\n\n\n    /*\n    **    x BETWEEN y AND z\n    **\n    ** This is equivalent to\n    **\n    **    x>=y AND x<=z\n    **\n    ** X is stored in pExpr->pLeft.\n    ** Y is stored in pExpr->pList->a[0].pExpr.\n    ** Z is stored in pExpr->pList->a[1].pExpr.\n    */\n    case TK_BETWEEN: {\n      exprCodeBetween(pParse, pExpr, target, 0, 0);\n      return target;\n    }\n    case TK_SPAN:\n    case TK_COLLATE: \n    case TK_UPLUS: {\n      pExpr = pExpr->pLeft;\n      goto expr_code_doover; /* 2018-04-28: Prevent deep recursion. OSSFuzz. */\n    }\n\n    case TK_TRIGGER: {\n      /* If the opcode is TK_TRIGGER, then the expression is a reference\n      ** to a column in the new.* or old.* pseudo-tables available to\n      ** trigger programs. In this case Expr.iTable is set to 1 for the\n      ** new.* pseudo-table, or 0 for the old.* pseudo-table. Expr.iColumn\n      ** is set to the column of the pseudo-table to read, or to -1 to\n      ** read the rowid field.\n      **\n      ** The expression is implemented using an OP_Param opcode. The p1\n      ** parameter is set to 0 for an old.rowid reference, or to (i+1)\n      ** to reference another column of the old.* pseudo-table, where \n      ** i is the index of the column. For a new.rowid reference, p1 is\n      ** set to (n+1), where n is the number of columns in each pseudo-table.\n      ** For a reference to any other column in the new.* pseudo-table, p1\n      ** is set to (n+2+i), where n and i are as defined previously. For\n      ** example, if the table on which triggers are being fired is\n      ** declared as:\n      **\n      **   CREATE TABLE t1(a, b);\n      **\n      ** Then p1 is interpreted as follows:\n      **\n      **   p1==0   ->    old.rowid     p1==3   ->    new.rowid\n      **   p1==1   ->    old.a         p1==4   ->    new.a\n      **   p1==2   ->    old.b         p1==5   ->    new.b       \n      */\n      Table *pTab = pExpr->y.pTab;\n      int iCol = pExpr->iColumn;\n      int p1 = pExpr->iTable * (pTab->nCol+1) + 1 \n                     + (iCol>=0 ? sqlite3TableColumnToStorage(pTab, iCol) : -1);\n\n      assert( pExpr->iTable==0 || pExpr->iTable==1 );\n      assert( iCol>=-1 && iCol<pTab->nCol );\n      assert( pTab->iPKey<0 || iCol!=pTab->iPKey );\n      assert( p1>=0 && p1<(pTab->nCol*2+2) );\n\n      sqlite3VdbeAddOp2(v, OP_Param, p1, target);\n      VdbeComment((v, \"r[%d]=%s.%s\", target,\n        (pExpr->iTable ? \"new\" : \"old\"),\n        (pExpr->iColumn<0 ? \"rowid\" : pExpr->y.pTab->aCol[iCol].zName)\n      ));\n\n#ifndef SQLITE_OMIT_FLOATING_POINT\n      /* If the column has REAL affinity, it may currently be stored as an\n      ** integer. Use OP_RealAffinity to make sure it is really real.\n      **\n      ** EVIDENCE-OF: R-60985-57662 SQLite will convert the value back to\n      ** floating point when extracting it from the record.  */\n      if( iCol>=0 && pTab->aCol[iCol].affinity==SQLITE_AFF_REAL ){\n        sqlite3VdbeAddOp1(v, OP_RealAffinity, target);\n      }\n#endif\n      break;\n    }\n\n    case TK_VECTOR: {\n      sqlite3ErrorMsg(pParse, \"row value misused\");\n      break;\n    }\n\n    /* TK_IF_NULL_ROW Expr nodes are inserted ahead of expressions\n    ** that derive from the right-hand table of a LEFT JOIN.  The\n    ** Expr.iTable value is the table number for the right-hand table.\n    ** The expression is only evaluated if that table is not currently\n    ** on a LEFT JOIN NULL row.\n    */\n    case TK_IF_NULL_ROW: {\n      int addrINR;\n      u8 okConstFactor = pParse->okConstFactor;\n      addrINR = sqlite3VdbeAddOp1(v, OP_IfNullRow, pExpr->iTable);\n      /* Temporarily disable factoring of constant expressions, since\n      ** even though expressions may appear to be constant, they are not\n      ** really constant because they originate from the right-hand side\n      ** of a LEFT JOIN. */\n      pParse->okConstFactor = 0;\n      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n      pParse->okConstFactor = okConstFactor;\n      sqlite3VdbeJumpHere(v, addrINR);\n      sqlite3VdbeChangeP3(v, addrINR, inReg);\n      break;\n    }\n\n    /*\n    ** Form A:\n    **   CASE x WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END\n    **\n    ** Form B:\n    **   CASE WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END\n    **\n    ** Form A is can be transformed into the equivalent form B as follows:\n    **   CASE WHEN x=e1 THEN r1 WHEN x=e2 THEN r2 ...\n    **        WHEN x=eN THEN rN ELSE y END\n    **\n    ** X (if it exists) is in pExpr->pLeft.\n    ** Y is in the last element of pExpr->x.pList if pExpr->x.pList->nExpr is\n    ** odd.  The Y is also optional.  If the number of elements in x.pList\n    ** is even, then Y is omitted and the \"otherwise\" result is NULL.\n    ** Ei is in pExpr->pList->a[i*2] and Ri is pExpr->pList->a[i*2+1].\n    **\n    ** The result of the expression is the Ri for the first matching Ei,\n    ** or if there is no matching Ei, the ELSE term Y, or if there is\n    ** no ELSE term, NULL.\n    */\n    default: assert( op==TK_CASE ); {\n      int endLabel;                     /* GOTO label for end of CASE stmt */\n      int nextCase;                     /* GOTO label for next WHEN clause */\n      int nExpr;                        /* 2x number of WHEN terms */\n      int i;                            /* Loop counter */\n      ExprList *pEList;                 /* List of WHEN terms */\n      struct ExprList_item *aListelem;  /* Array of WHEN terms */\n      Expr opCompare;                   /* The X==Ei expression */\n      Expr *pX;                         /* The X expression */\n      Expr *pTest = 0;                  /* X==Ei (form A) or just Ei (form B) */\n      Expr *pDel = 0;\n      sqlite3 *db = pParse->db;\n\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) && pExpr->x.pList );\n      assert(pExpr->x.pList->nExpr > 0);\n      pEList = pExpr->x.pList;\n      aListelem = pEList->a;\n      nExpr = pEList->nExpr;\n      endLabel = sqlite3VdbeMakeLabel(pParse);\n      if( (pX = pExpr->pLeft)!=0 ){\n        pDel = sqlite3ExprDup(db, pX, 0);\n        if( db->mallocFailed ){\n          sqlite3ExprDelete(db, pDel);\n          break;\n        }\n        testcase( pX->op==TK_COLUMN );\n        exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));\n        testcase( regFree1==0 );\n        memset(&opCompare, 0, sizeof(opCompare));\n        opCompare.op = TK_EQ;\n        opCompare.pLeft = pDel;\n        pTest = &opCompare;\n        /* Ticket b351d95f9cd5ef17e9d9dbae18f5ca8611190001:\n        ** The value in regFree1 might get SCopy-ed into the file result.\n        ** So make sure that the regFree1 register is not reused for other\n        ** purposes and possibly overwritten.  */\n        regFree1 = 0;\n      }\n      for(i=0; i<nExpr-1; i=i+2){\n        if( pX ){\n          assert( pTest!=0 );\n          opCompare.pRight = aListelem[i].pExpr;\n        }else{\n          pTest = aListelem[i].pExpr;\n        }\n        nextCase = sqlite3VdbeMakeLabel(pParse);\n        testcase( pTest->op==TK_COLUMN );\n        sqlite3ExprIfFalse(pParse, pTest, nextCase, SQLITE_JUMPIFNULL);\n        testcase( aListelem[i+1].pExpr->op==TK_COLUMN );\n        sqlite3ExprCode(pParse, aListelem[i+1].pExpr, target);\n        sqlite3VdbeGoto(v, endLabel);\n        sqlite3VdbeResolveLabel(v, nextCase);\n      }\n      if( (nExpr&1)!=0 ){\n        sqlite3ExprCode(pParse, pEList->a[nExpr-1].pExpr, target);\n      }else{\n        sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n      }\n      sqlite3ExprDelete(db, pDel);\n      sqlite3VdbeResolveLabel(v, endLabel);\n      break;\n    }\n#ifndef SQLITE_OMIT_TRIGGER\n    case TK_RAISE: {\n      assert( pExpr->affExpr==OE_Rollback \n           || pExpr->affExpr==OE_Abort\n           || pExpr->affExpr==OE_Fail\n           || pExpr->affExpr==OE_Ignore\n      );\n      if( !pParse->pTriggerTab ){\n        sqlite3ErrorMsg(pParse,\n                       \"RAISE() may only be used within a trigger-program\");\n        return 0;\n      }\n      if( pExpr->affExpr==OE_Abort ){\n        sqlite3MayAbort(pParse);\n      }\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      if( pExpr->affExpr==OE_Ignore ){\n        sqlite3VdbeAddOp4(\n            v, OP_Halt, SQLITE_OK, OE_Ignore, 0, pExpr->u.zToken,0);\n        VdbeCoverage(v);\n      }else{\n        sqlite3HaltConstraint(pParse, SQLITE_CONSTRAINT_TRIGGER,\n                              pExpr->affExpr, pExpr->u.zToken, 0, 0);\n      }\n\n      break;\n    }\n#endif\n  }\n  sqlite3ReleaseTempReg(pParse, regFree1);\n  sqlite3ReleaseTempReg(pParse, regFree2);\n  return inReg;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145794,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target){\n  Vdbe *v = pParse->pVdbe;  /* The VM under construction */\n  int op;                   /* The opcode being coded */\n  int inReg = target;       /* Results stored in register inReg */\n  int regFree1 = 0;         /* If non-zero free this temporary register */\n  int regFree2 = 0;         /* If non-zero free this temporary register */\n  int r1, r2;               /* Various register numbers */\n  Expr tempX;               /* Temporary expression node */\n  int p5 = 0;\n\n  assert( target>0 && target<=pParse->nMem );\n  if( v==0 ){\n    assert( pParse->db->mallocFailed );\n    return 0;\n  }\n\nexpr_code_doover:\n  if( pExpr==0 ){\n    op = TK_NULL;\n  }else{\n    op = pExpr->op;\n  }\n  switch( op ){\n    case TK_AGG_COLUMN: {\n      AggInfo *pAggInfo = pExpr->pAggInfo;\n      struct AggInfo_col *pCol = &pAggInfo->aCol[pExpr->iAgg];\n      if( !pAggInfo->directMode ){\n        assert( pCol->iMem>0 );\n        return pCol->iMem;\n      }else if( pAggInfo->useSortingIdx ){\n        sqlite3VdbeAddOp3(v, OP_Column, pAggInfo->sortingIdxPTab,\n                              pCol->iSorterColumn, target);\n        return target;\n      }\n      /* Otherwise, fall thru into the TK_COLUMN case */\n    }\n    case TK_COLUMN: {\n      int iTab = pExpr->iTable;\n      if( ExprHasProperty(pExpr, EP_FixedCol) ){\n        /* This COLUMN expression is really a constant due to WHERE clause\n        ** constraints, and that constant is coded by the pExpr->pLeft\n        ** expresssion.  However, make sure the constant has the correct\n        ** datatype by applying the Affinity of the table column to the\n        ** constant.\n        */\n        int iReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft,target);\n        int aff;\n        if( pExpr->y.pTab ){\n          aff = sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);\n        }else{\n          aff = pExpr->affExpr;\n        }\n        if( aff>SQLITE_AFF_BLOB ){\n          static const char zAff[] = \"B\\000C\\000D\\000E\";\n          assert( SQLITE_AFF_BLOB=='A' );\n          assert( SQLITE_AFF_TEXT=='B' );\n          if( iReg!=target ){\n            sqlite3VdbeAddOp2(v, OP_SCopy, iReg, target);\n            iReg = target;\n          }\n          sqlite3VdbeAddOp4(v, OP_Affinity, iReg, 1, 0,\n                            &zAff[(aff-'B')*2], P4_STATIC);\n        }\n        return iReg;\n      }\n      if( iTab<0 ){\n        if( pParse->iSelfTab<0 ){\n          /* Other columns in the same row for CHECK constraints or\n          ** generated columns or for inserting into partial index.\n          ** The row is unpacked into registers beginning at\n          ** 0-(pParse->iSelfTab).  The rowid (if any) is in a register\n          ** immediately prior to the first column.\n          */\n          Column *pCol;\n          Table *pTab = pExpr->y.pTab;\n          int iSrc;\n          int iCol = pExpr->iColumn;\n          assert( pTab!=0 );\n          assert( iCol>=XN_ROWID );\n          assert( iCol<pExpr->y.pTab->nCol );\n          if( iCol<0 ){\n            return -1-pParse->iSelfTab;\n          }\n          pCol = pTab->aCol + iCol;\n          testcase( iCol!=sqlite3TableColumnToStorage(pTab,iCol) );\n          iSrc = sqlite3TableColumnToStorage(pTab, iCol) - pParse->iSelfTab;\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n          if( pCol->colFlags & COLFLAG_GENERATED ){\n            if( pCol->colFlags & COLFLAG_BUSY ){\n              sqlite3ErrorMsg(pParse, \"generated column loop on \\\"%s\\\"\",\n                              pCol->zName);\n              return 0;\n            }\n            pCol->colFlags |= COLFLAG_BUSY;\n            if( pCol->colFlags & COLFLAG_NOTAVAIL ){\n              sqlite3ExprCodeGeneratedColumn(pParse, pCol, iSrc);\n            }\n            pCol->colFlags &= ~(COLFLAG_BUSY|COLFLAG_NOTAVAIL);\n            return iSrc;\n          }else\n#endif /* SQLITE_OMIT_GENERATED_COLUMNS */\n          if( pCol->affinity==SQLITE_AFF_REAL ){\n            sqlite3VdbeAddOp2(v, OP_SCopy, iSrc, target);\n            sqlite3VdbeAddOp1(v, OP_RealAffinity, target);\n            return target;\n          }else{\n            return iSrc;\n          }\n        }else{\n          /* Coding an expression that is part of an index where column names\n          ** in the index refer to the table to which the index belongs */\n          iTab = pParse->iSelfTab - 1;\n        }\n      }\n      return sqlite3ExprCodeGetColumn(pParse, pExpr->y.pTab,\n                               pExpr->iColumn, iTab, target,\n                               pExpr->op2);\n    }\n    case TK_INTEGER: {\n      codeInteger(pParse, pExpr, 0, target);\n      return target;\n    }\n    case TK_TRUEFALSE: {\n      sqlite3VdbeAddOp2(v, OP_Integer, sqlite3ExprTruthValue(pExpr), target);\n      return target;\n    }\n#ifndef SQLITE_OMIT_FLOATING_POINT\n    case TK_FLOAT: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      codeReal(v, pExpr->u.zToken, 0, target);\n      return target;\n    }\n#endif\n    case TK_STRING: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      sqlite3VdbeLoadString(v, target, pExpr->u.zToken);\n      return target;\n    }\n    case TK_NULL: {\n      sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n      return target;\n    }\n#ifndef SQLITE_OMIT_BLOB_LITERAL\n    case TK_BLOB: {\n      int n;\n      const char *z;\n      char *zBlob;\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      assert( pExpr->u.zToken[0]=='x' || pExpr->u.zToken[0]=='X' );\n      assert( pExpr->u.zToken[1]=='\\'' );\n      z = &pExpr->u.zToken[2];\n      n = sqlite3Strlen30(z) - 1;\n      assert( z[n]=='\\'' );\n      zBlob = sqlite3HexToBlob(sqlite3VdbeDb(v), z, n);\n      sqlite3VdbeAddOp4(v, OP_Blob, n/2, target, 0, zBlob, P4_DYNAMIC);\n      return target;\n    }\n#endif\n    case TK_VARIABLE: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      assert( pExpr->u.zToken!=0 );\n      assert( pExpr->u.zToken[0]!=0 );\n      sqlite3VdbeAddOp2(v, OP_Variable, pExpr->iColumn, target);\n      if( pExpr->u.zToken[1]!=0 ){\n        const char *z = sqlite3VListNumToName(pParse->pVList, pExpr->iColumn);\n        assert( pExpr->u.zToken[0]=='?' || strcmp(pExpr->u.zToken, z)==0 );\n        pParse->pVList[0] = 0; /* Indicate VList may no longer be enlarged */\n        sqlite3VdbeAppendP4(v, (char*)z, P4_STATIC);\n      }\n      return target;\n    }\n    case TK_REGISTER: {\n      return pExpr->iTable;\n    }\n#ifndef SQLITE_OMIT_CAST\n    case TK_CAST: {\n      /* Expressions of the form:   CAST(pLeft AS token) */\n      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n      if( inReg!=target ){\n        sqlite3VdbeAddOp2(v, OP_SCopy, inReg, target);\n        inReg = target;\n      }\n      sqlite3VdbeAddOp2(v, OP_Cast, target,\n                        sqlite3AffinityType(pExpr->u.zToken, 0));\n      return inReg;\n    }\n#endif /* SQLITE_OMIT_CAST */\n    case TK_IS:\n    case TK_ISNOT:\n      op = (op==TK_IS) ? TK_EQ : TK_NE;\n      p5 = SQLITE_NULLEQ;\n      /* fall-through */\n    case TK_LT:\n    case TK_LE:\n    case TK_GT:\n    case TK_GE:\n    case TK_NE:\n    case TK_EQ: {\n      Expr *pLeft = pExpr->pLeft;\n      if( sqlite3ExprIsVector(pLeft) ){\n        codeVectorCompare(pParse, pExpr, target, op, p5);\n      }else{\n        r1 = sqlite3ExprCodeTemp(pParse, pLeft, &regFree1);\n        r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n        codeCompare(pParse, pLeft, pExpr->pRight, op,\n            r1, r2, inReg, SQLITE_STOREP2 | p5,\n            ExprHasProperty(pExpr,EP_Commuted));\n        assert(TK_LT==OP_Lt); testcase(op==OP_Lt); VdbeCoverageIf(v,op==OP_Lt);\n        assert(TK_LE==OP_Le); testcase(op==OP_Le); VdbeCoverageIf(v,op==OP_Le);\n        assert(TK_GT==OP_Gt); testcase(op==OP_Gt); VdbeCoverageIf(v,op==OP_Gt);\n        assert(TK_GE==OP_Ge); testcase(op==OP_Ge); VdbeCoverageIf(v,op==OP_Ge);\n        assert(TK_EQ==OP_Eq); testcase(op==OP_Eq); VdbeCoverageIf(v,op==OP_Eq);\n        assert(TK_NE==OP_Ne); testcase(op==OP_Ne); VdbeCoverageIf(v,op==OP_Ne);\n        testcase( regFree1==0 );\n        testcase( regFree2==0 );\n      }\n      break;\n    }\n    case TK_AND:\n    case TK_OR:\n    case TK_PLUS:\n    case TK_STAR:\n    case TK_MINUS:\n    case TK_REM:\n    case TK_BITAND:\n    case TK_BITOR:\n    case TK_SLASH:\n    case TK_LSHIFT:\n    case TK_RSHIFT: \n    case TK_CONCAT: {\n      assert( TK_AND==OP_And );            testcase( op==TK_AND );\n      assert( TK_OR==OP_Or );              testcase( op==TK_OR );\n      assert( TK_PLUS==OP_Add );           testcase( op==TK_PLUS );\n      assert( TK_MINUS==OP_Subtract );     testcase( op==TK_MINUS );\n      assert( TK_REM==OP_Remainder );      testcase( op==TK_REM );\n      assert( TK_BITAND==OP_BitAnd );      testcase( op==TK_BITAND );\n      assert( TK_BITOR==OP_BitOr );        testcase( op==TK_BITOR );\n      assert( TK_SLASH==OP_Divide );       testcase( op==TK_SLASH );\n      assert( TK_LSHIFT==OP_ShiftLeft );   testcase( op==TK_LSHIFT );\n      assert( TK_RSHIFT==OP_ShiftRight );  testcase( op==TK_RSHIFT );\n      assert( TK_CONCAT==OP_Concat );      testcase( op==TK_CONCAT );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n      sqlite3VdbeAddOp3(v, op, r2, r1, target);\n      testcase( regFree1==0 );\n      testcase( regFree2==0 );\n      break;\n    }\n    case TK_UMINUS: {\n      Expr *pLeft = pExpr->pLeft;\n      assert( pLeft );\n      if( pLeft->op==TK_INTEGER ){\n        codeInteger(pParse, pLeft, 1, target);\n        return target;\n#ifndef SQLITE_OMIT_FLOATING_POINT\n      }else if( pLeft->op==TK_FLOAT ){\n        assert( !ExprHasProperty(pExpr, EP_IntValue) );\n        codeReal(v, pLeft->u.zToken, 1, target);\n        return target;\n#endif\n      }else{\n        tempX.op = TK_INTEGER;\n        tempX.flags = EP_IntValue|EP_TokenOnly;\n        tempX.u.iValue = 0;\n        r1 = sqlite3ExprCodeTemp(pParse, &tempX, &regFree1);\n        r2 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree2);\n        sqlite3VdbeAddOp3(v, OP_Subtract, r2, r1, target);\n        testcase( regFree2==0 );\n      }\n      break;\n    }\n    case TK_BITNOT:\n    case TK_NOT: {\n      assert( TK_BITNOT==OP_BitNot );   testcase( op==TK_BITNOT );\n      assert( TK_NOT==OP_Not );         testcase( op==TK_NOT );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      testcase( regFree1==0 );\n      sqlite3VdbeAddOp2(v, op, r1, inReg);\n      break;\n    }\n    case TK_TRUTH: {\n      int isTrue;    /* IS TRUE or IS NOT TRUE */\n      int bNormal;   /* IS TRUE or IS FALSE */\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      testcase( regFree1==0 );\n      isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n      bNormal = pExpr->op2==TK_IS;\n      testcase( isTrue && bNormal);\n      testcase( !isTrue && bNormal);\n      sqlite3VdbeAddOp4Int(v, OP_IsTrue, r1, inReg, !isTrue, isTrue ^ bNormal);\n      break;\n    }\n    case TK_ISNULL:\n    case TK_NOTNULL: {\n      int addr;\n      assert( TK_ISNULL==OP_IsNull );   testcase( op==TK_ISNULL );\n      assert( TK_NOTNULL==OP_NotNull ); testcase( op==TK_NOTNULL );\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, target);\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      testcase( regFree1==0 );\n      addr = sqlite3VdbeAddOp1(v, op, r1);\n      VdbeCoverageIf(v, op==TK_ISNULL);\n      VdbeCoverageIf(v, op==TK_NOTNULL);\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, target);\n      sqlite3VdbeJumpHere(v, addr);\n      break;\n    }\n    case TK_AGG_FUNCTION: {\n      AggInfo *pInfo = pExpr->pAggInfo;\n      if( pInfo==0 ){\n        assert( !ExprHasProperty(pExpr, EP_IntValue) );\n        sqlite3ErrorMsg(pParse, \"misuse of aggregate: %s()\", pExpr->u.zToken);\n      }else{\n        return pInfo->aFunc[pExpr->iAgg].iMem;\n      }\n      break;\n    }\n    case TK_FUNCTION: {\n      ExprList *pFarg;       /* List of function arguments */\n      int nFarg;             /* Number of function arguments */\n      FuncDef *pDef;         /* The function definition object */\n      const char *zId;       /* The function name */\n      u32 constMask = 0;     /* Mask of function arguments that are constant */\n      int i;                 /* Loop counter */\n      sqlite3 *db = pParse->db;  /* The database connection */\n      u8 enc = ENC(db);      /* The text encoding used by this database */\n      CollSeq *pColl = 0;    /* A collating sequence */\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n      if( ExprHasProperty(pExpr, EP_WinFunc) ){\n        return pExpr->y.pWin->regResult;\n      }\n#endif\n\n      if( ConstFactorOk(pParse) && sqlite3ExprIsConstantNotJoin(pExpr) ){\n        /* SQL functions can be expensive. So try to move constant functions\n        ** out of the inner loop, even if that means an extra OP_Copy. */\n        return sqlite3ExprCodeAtInit(pParse, pExpr, -1);\n      }\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n      if( ExprHasProperty(pExpr, EP_TokenOnly) ){\n        pFarg = 0;\n      }else{\n        pFarg = pExpr->x.pList;\n      }\n      nFarg = pFarg ? pFarg->nExpr : 0;\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      zId = pExpr->u.zToken;\n      pDef = sqlite3FindFunction(db, zId, nFarg, enc, 0);\n#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION\n      if( pDef==0 && pParse->explain ){\n        pDef = sqlite3FindFunction(db, \"unknown\", nFarg, enc, 0);\n      }\n#endif\n      if( pDef==0 || pDef->xFinalize!=0 ){\n        sqlite3ErrorMsg(pParse, \"unknown function: %s()\", zId);\n        break;\n      }\n\n      /* Attempt a direct implementation of the built-in COALESCE() and\n      ** IFNULL() functions.  This avoids unnecessary evaluation of\n      ** arguments past the first non-NULL argument.\n      */\n      if( pDef->funcFlags & SQLITE_FUNC_COALESCE ){\n        int endCoalesce = sqlite3VdbeMakeLabel(pParse);\n        assert( nFarg>=2 );\n        sqlite3ExprCode(pParse, pFarg->a[0].pExpr, target);\n        for(i=1; i<nFarg; i++){\n          sqlite3VdbeAddOp2(v, OP_NotNull, target, endCoalesce);\n          VdbeCoverage(v);\n          sqlite3ExprCode(pParse, pFarg->a[i].pExpr, target);\n        }\n        sqlite3VdbeResolveLabel(v, endCoalesce);\n        break;\n      }\n\n      /* The UNLIKELY() function is a no-op.  The result is the value\n      ** of the first argument.\n      */\n      if( pDef->funcFlags & SQLITE_FUNC_UNLIKELY ){\n        assert( nFarg>=1 );\n        return sqlite3ExprCodeTarget(pParse, pFarg->a[0].pExpr, target);\n      }\n\n#ifdef SQLITE_DEBUG\n      /* The AFFINITY() function evaluates to a string that describes\n      ** the type affinity of the argument.  This is used for testing of\n      ** the SQLite type logic.\n      */\n      if( pDef->funcFlags & SQLITE_FUNC_AFFINITY ){\n        const char *azAff[] = { \"blob\", \"text\", \"numeric\", \"integer\", \"real\" };\n        char aff;\n        assert( nFarg==1 );\n        aff = sqlite3ExprAffinity(pFarg->a[0].pExpr);\n        sqlite3VdbeLoadString(v, target, \n                (aff<=SQLITE_AFF_NONE) ? \"none\" : azAff[aff-SQLITE_AFF_BLOB]);\n        return target;\n      }\n#endif\n\n      for(i=0; i<nFarg; i++){\n        if( i<32 && sqlite3ExprIsConstant(pFarg->a[i].pExpr) ){\n          testcase( i==31 );\n          constMask |= MASKBIT32(i);\n        }\n        if( (pDef->funcFlags & SQLITE_FUNC_NEEDCOLL)!=0 && !pColl ){\n          pColl = sqlite3ExprCollSeq(pParse, pFarg->a[i].pExpr);\n        }\n      }\n      if( pFarg ){\n        if( constMask ){\n          r1 = pParse->nMem+1;\n          pParse->nMem += nFarg;\n        }else{\n          r1 = sqlite3GetTempRange(pParse, nFarg);\n        }\n\n        /* For length() and typeof() functions with a column argument,\n        ** set the P5 parameter to the OP_Column opcode to OPFLAG_LENGTHARG\n        ** or OPFLAG_TYPEOFARG respectively, to avoid unnecessary data\n        ** loading.\n        */\n        if( (pDef->funcFlags & (SQLITE_FUNC_LENGTH|SQLITE_FUNC_TYPEOF))!=0 ){\n          u8 exprOp;\n          assert( nFarg==1 );\n          assert( pFarg->a[0].pExpr!=0 );\n          exprOp = pFarg->a[0].pExpr->op;\n          if( exprOp==TK_COLUMN || exprOp==TK_AGG_COLUMN ){\n            assert( SQLITE_FUNC_LENGTH==OPFLAG_LENGTHARG );\n            assert( SQLITE_FUNC_TYPEOF==OPFLAG_TYPEOFARG );\n            testcase( pDef->funcFlags & OPFLAG_LENGTHARG );\n            pFarg->a[0].pExpr->op2 = \n                  pDef->funcFlags & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG);\n          }\n        }\n\n        sqlite3ExprCodeExprList(pParse, pFarg, r1, 0,\n                                SQLITE_ECEL_DUP|SQLITE_ECEL_FACTOR);\n      }else{\n        r1 = 0;\n      }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n      /* Possibly overload the function if the first argument is\n      ** a virtual table column.\n      **\n      ** For infix functions (LIKE, GLOB, REGEXP, and MATCH) use the\n      ** second argument, not the first, as the argument to test to\n      ** see if it is a column in a virtual table.  This is done because\n      ** the left operand of infix functions (the operand we want to\n      ** control overloading) ends up as the second argument to the\n      ** function.  The expression \"A glob B\" is equivalent to \n      ** \"glob(B,A).  We want to use the A in \"A glob B\" to test\n      ** for function overloading.  But we use the B term in \"glob(B,A)\".\n      */\n      if( nFarg>=2 && ExprHasProperty(pExpr, EP_InfixFunc) ){\n        pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[1].pExpr);\n      }else if( nFarg>0 ){\n        pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[0].pExpr);\n      }\n#endif\n      if( pDef->funcFlags & SQLITE_FUNC_NEEDCOLL ){\n        if( !pColl ) pColl = db->pDfltColl; \n        sqlite3VdbeAddOp4(v, OP_CollSeq, 0, 0, 0, (char *)pColl, P4_COLLSEQ);\n      }\n#ifdef SQLITE_ENABLE_OFFSET_SQL_FUNC\n      if( pDef->funcFlags & SQLITE_FUNC_OFFSET ){\n        Expr *pArg = pFarg->a[0].pExpr;\n        if( pArg->op==TK_COLUMN ){\n          sqlite3VdbeAddOp3(v, OP_Offset, pArg->iTable, pArg->iColumn, target);\n        }else{\n          sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n        }\n      }else\n#endif\n      {\n        sqlite3VdbeAddFunctionCall(pParse, constMask, r1, target, nFarg,\n                                   pDef, pExpr->op2);\n      }\n      if( nFarg && constMask==0 ){\n        sqlite3ReleaseTempRange(pParse, r1, nFarg);\n      }\n      return target;\n    }\n#ifndef SQLITE_OMIT_SUBQUERY\n    case TK_EXISTS:\n    case TK_SELECT: {\n      int nCol;\n      testcase( op==TK_EXISTS );\n      testcase( op==TK_SELECT );\n      if( op==TK_SELECT && (nCol = pExpr->x.pSelect->pEList->nExpr)!=1 ){\n        sqlite3SubselectError(pParse, nCol, 1);\n      }else{\n        return sqlite3CodeSubselect(pParse, pExpr);\n      }\n      break;\n    }\n    case TK_SELECT_COLUMN: {\n      int n;\n      if( pExpr->pLeft->iTable==0 ){\n        pExpr->pLeft->iTable = sqlite3CodeSubselect(pParse, pExpr->pLeft);\n      }\n      assert( pExpr->iTable==0 || pExpr->pLeft->op==TK_SELECT );\n      if( pExpr->iTable!=0\n       && pExpr->iTable!=(n = sqlite3ExprVectorSize(pExpr->pLeft))\n      ){\n        sqlite3ErrorMsg(pParse, \"%d columns assigned %d values\",\n                                pExpr->iTable, n);\n      }\n      return pExpr->pLeft->iTable + pExpr->iColumn;\n    }\n    case TK_IN: {\n      int destIfFalse = sqlite3VdbeMakeLabel(pParse);\n      int destIfNull = sqlite3VdbeMakeLabel(pParse);\n      sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n      sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, target);\n      sqlite3VdbeResolveLabel(v, destIfFalse);\n      sqlite3VdbeAddOp2(v, OP_AddImm, target, 0);\n      sqlite3VdbeResolveLabel(v, destIfNull);\n      return target;\n    }\n#endif /* SQLITE_OMIT_SUBQUERY */\n\n\n    /*\n    **    x BETWEEN y AND z\n    **\n    ** This is equivalent to\n    **\n    **    x>=y AND x<=z\n    **\n    ** X is stored in pExpr->pLeft.\n    ** Y is stored in pExpr->pList->a[0].pExpr.\n    ** Z is stored in pExpr->pList->a[1].pExpr.\n    */\n    case TK_BETWEEN: {\n      exprCodeBetween(pParse, pExpr, target, 0, 0);\n      return target;\n    }\n    case TK_SPAN:\n    case TK_COLLATE: \n    case TK_UPLUS: {\n      pExpr = pExpr->pLeft;\n      goto expr_code_doover; /* 2018-04-28: Prevent deep recursion. OSSFuzz. */\n    }\n\n    case TK_TRIGGER: {\n      /* If the opcode is TK_TRIGGER, then the expression is a reference\n      ** to a column in the new.* or old.* pseudo-tables available to\n      ** trigger programs. In this case Expr.iTable is set to 1 for the\n      ** new.* pseudo-table, or 0 for the old.* pseudo-table. Expr.iColumn\n      ** is set to the column of the pseudo-table to read, or to -1 to\n      ** read the rowid field.\n      **\n      ** The expression is implemented using an OP_Param opcode. The p1\n      ** parameter is set to 0 for an old.rowid reference, or to (i+1)\n      ** to reference another column of the old.* pseudo-table, where \n      ** i is the index of the column. For a new.rowid reference, p1 is\n      ** set to (n+1), where n is the number of columns in each pseudo-table.\n      ** For a reference to any other column in the new.* pseudo-table, p1\n      ** is set to (n+2+i), where n and i are as defined previously. For\n      ** example, if the table on which triggers are being fired is\n      ** declared as:\n      **\n      **   CREATE TABLE t1(a, b);\n      **\n      ** Then p1 is interpreted as follows:\n      **\n      **   p1==0   ->    old.rowid     p1==3   ->    new.rowid\n      **   p1==1   ->    old.a         p1==4   ->    new.a\n      **   p1==2   ->    old.b         p1==5   ->    new.b       \n      */\n      Table *pTab = pExpr->y.pTab;\n      int iCol = pExpr->iColumn;\n      int p1 = pExpr->iTable * (pTab->nCol+1) + 1 \n                     + (iCol>=0 ? sqlite3TableColumnToStorage(pTab, iCol) : -1);\n\n      assert( pExpr->iTable==0 || pExpr->iTable==1 );\n      assert( iCol>=-1 && iCol<pTab->nCol );\n      assert( pTab->iPKey<0 || iCol!=pTab->iPKey );\n      assert( p1>=0 && p1<(pTab->nCol*2+2) );\n\n      sqlite3VdbeAddOp2(v, OP_Param, p1, target);\n      VdbeComment((v, \"r[%d]=%s.%s\", target,\n        (pExpr->iTable ? \"new\" : \"old\"),\n        (pExpr->iColumn<0 ? \"rowid\" : pExpr->y.pTab->aCol[iCol].zName)\n      ));\n\n#ifndef SQLITE_OMIT_FLOATING_POINT\n      /* If the column has REAL affinity, it may currently be stored as an\n      ** integer. Use OP_RealAffinity to make sure it is really real.\n      **\n      ** EVIDENCE-OF: R-60985-57662 SQLite will convert the value back to\n      ** floating point when extracting it from the record.  */\n      if( iCol>=0 && pTab->aCol[iCol].affinity==SQLITE_AFF_REAL ){\n        sqlite3VdbeAddOp1(v, OP_RealAffinity, target);\n      }\n#endif\n      break;\n    }\n\n    case TK_VECTOR: {\n      sqlite3ErrorMsg(pParse, \"row value misused\");\n      break;\n    }\n\n    /* TK_IF_NULL_ROW Expr nodes are inserted ahead of expressions\n    ** that derive from the right-hand table of a LEFT JOIN.  The\n    ** Expr.iTable value is the table number for the right-hand table.\n    ** The expression is only evaluated if that table is not currently\n    ** on a LEFT JOIN NULL row.\n    */\n    case TK_IF_NULL_ROW: {\n      int addrINR;\n      u8 okConstFactor = pParse->okConstFactor;\n      addrINR = sqlite3VdbeAddOp1(v, OP_IfNullRow, pExpr->iTable);\n      /* Temporarily disable factoring of constant expressions, since\n      ** even though expressions may appear to be constant, they are not\n      ** really constant because they originate from the right-hand side\n      ** of a LEFT JOIN. */\n      pParse->okConstFactor = 0;\n      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n      pParse->okConstFactor = okConstFactor;\n      sqlite3VdbeJumpHere(v, addrINR);\n      sqlite3VdbeChangeP3(v, addrINR, inReg);\n      break;\n    }\n\n    /*\n    ** Form A:\n    **   CASE x WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END\n    **\n    ** Form B:\n    **   CASE WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END\n    **\n    ** Form A is can be transformed into the equivalent form B as follows:\n    **   CASE WHEN x=e1 THEN r1 WHEN x=e2 THEN r2 ...\n    **        WHEN x=eN THEN rN ELSE y END\n    **\n    ** X (if it exists) is in pExpr->pLeft.\n    ** Y is in the last element of pExpr->x.pList if pExpr->x.pList->nExpr is\n    ** odd.  The Y is also optional.  If the number of elements in x.pList\n    ** is even, then Y is omitted and the \"otherwise\" result is NULL.\n    ** Ei is in pExpr->pList->a[i*2] and Ri is pExpr->pList->a[i*2+1].\n    **\n    ** The result of the expression is the Ri for the first matching Ei,\n    ** or if there is no matching Ei, the ELSE term Y, or if there is\n    ** no ELSE term, NULL.\n    */\n    default: assert( op==TK_CASE ); {\n      int endLabel;                     /* GOTO label for end of CASE stmt */\n      int nextCase;                     /* GOTO label for next WHEN clause */\n      int nExpr;                        /* 2x number of WHEN terms */\n      int i;                            /* Loop counter */\n      ExprList *pEList;                 /* List of WHEN terms */\n      struct ExprList_item *aListelem;  /* Array of WHEN terms */\n      Expr opCompare;                   /* The X==Ei expression */\n      Expr *pX;                         /* The X expression */\n      Expr *pTest = 0;                  /* X==Ei (form A) or just Ei (form B) */\n      Expr *pDel = 0;\n      sqlite3 *db = pParse->db;\n\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) && pExpr->x.pList );\n      assert(pExpr->x.pList->nExpr > 0);\n      pEList = pExpr->x.pList;\n      aListelem = pEList->a;\n      nExpr = pEList->nExpr;\n      endLabel = sqlite3VdbeMakeLabel(pParse);\n      if( (pX = pExpr->pLeft)!=0 ){\n        pDel = sqlite3ExprDup(db, pX, 0);\n        if( db->mallocFailed ){\n          sqlite3ExprDelete(db, pDel);\n          break;\n        }\n        testcase( pX->op==TK_COLUMN );\n        exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));\n        testcase( regFree1==0 );\n        memset(&opCompare, 0, sizeof(opCompare));\n        opCompare.op = TK_EQ;\n        opCompare.pLeft = pDel;\n        pTest = &opCompare;\n        /* Ticket b351d95f9cd5ef17e9d9dbae18f5ca8611190001:\n        ** The value in regFree1 might get SCopy-ed into the file result.\n        ** So make sure that the regFree1 register is not reused for other\n        ** purposes and possibly overwritten.  */\n        regFree1 = 0;\n      }\n      for(i=0; i<nExpr-1; i=i+2){\n        if( pX ){\n          assert( pTest!=0 );\n          opCompare.pRight = aListelem[i].pExpr;\n        }else{\n          pTest = aListelem[i].pExpr;\n        }\n        nextCase = sqlite3VdbeMakeLabel(pParse);\n        testcase( pTest->op==TK_COLUMN );\n        sqlite3ExprIfFalse(pParse, pTest, nextCase, SQLITE_JUMPIFNULL);\n        testcase( aListelem[i+1].pExpr->op==TK_COLUMN );\n        sqlite3ExprCode(pParse, aListelem[i+1].pExpr, target);\n        sqlite3VdbeGoto(v, endLabel);\n        sqlite3VdbeResolveLabel(v, nextCase);\n      }\n      if( (nExpr&1)!=0 ){\n        sqlite3ExprCode(pParse, pEList->a[nExpr-1].pExpr, target);\n      }else{\n        sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n      }\n      sqlite3ExprDelete(db, pDel);\n      sqlite3VdbeResolveLabel(v, endLabel);\n      break;\n    }\n#ifndef SQLITE_OMIT_TRIGGER\n    case TK_RAISE: {\n      assert( pExpr->affExpr==OE_Rollback \n           || pExpr->affExpr==OE_Abort\n           || pExpr->affExpr==OE_Fail\n           || pExpr->affExpr==OE_Ignore\n      );\n      if( !pParse->pTriggerTab ){\n        sqlite3ErrorMsg(pParse,\n                       \"RAISE() may only be used within a trigger-program\");\n        return 0;\n      }\n      if( pExpr->affExpr==OE_Abort ){\n        sqlite3MayAbort(pParse);\n      }\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      if( pExpr->affExpr==OE_Ignore ){\n        sqlite3VdbeAddOp4(\n            v, OP_Halt, SQLITE_OK, OE_Ignore, 0, pExpr->u.zToken,0);\n        VdbeCoverage(v);\n      }else{\n        sqlite3HaltConstraint(pParse, SQLITE_CONSTRAINT_TRIGGER,\n                              pExpr->affExpr, pExpr->u.zToken, 0, 0);\n      }\n\n      break;\n    }\n#endif\n  }\n  sqlite3ReleaseTempReg(pParse, regFree1);\n  sqlite3ReleaseTempReg(pParse, regFree2);\n  return inReg;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145795,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "do_refill(struct table *tbl, int row, int col, int maxlimit)\n{\n    TextList *orgdata;\n    TextListItem *l;\n    struct readbuffer obuf;\n    struct html_feed_environ h_env;\n    struct environment envs[MAX_ENV_LEVEL];\n    int colspan, icell;\n\n    if (tbl->tabdata[row] == NULL || tbl->tabdata[row][col] == NULL)\n\treturn;\n    orgdata = (TextList *)tbl->tabdata[row][col];\n    tbl->tabdata[row][col] = newGeneralList();\n\n    init_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL,\n\t      (TextLineList *)tbl->tabdata[row][col],\n\t      get_spec_cell_width(tbl, row, col), 0);\n    obuf.flag |= RB_INTABLE;\n    if (h_env.limit > maxlimit)\n\th_env.limit = maxlimit;\n    if (tbl->border_mode != BORDER_NONE && tbl->vcellpadding > 0)\n\tdo_blankline(&h_env, &obuf, 0, 0, h_env.limit);\n    for (l = orgdata->first; l != NULL; l = l->next) {\n\tif (TAG_IS(l->ptr, \"<table_alt\", 10)) {\n\t    int id = -1;\n\t    char *p = l->ptr;\n\t    struct parsed_tag *tag;\n\t    if ((tag = parse_tag(&p, TRUE)) != NULL)\n\t\tparsedtag_get_value(tag, ATTR_TID, &id);\n\t    if (id >= 0 && id < tbl->ntable) {\n\t\tint alignment;\n\t\tTextLineListItem *ti;\n\t\tstruct table *t = tbl->tables[id].ptr;\n\t\tint limit = tbl->tables[id].indent + t->total_width;\n\t\ttbl->tables[id].ptr = NULL;\n\t\tsave_fonteffect(&h_env, h_env.obuf);\n\t\tflushline(&h_env, &obuf, 0, 2, h_env.limit);\n\t\tif (t->vspace > 0 && !(obuf.flag & RB_IGNORE_P))\n\t\t    do_blankline(&h_env, &obuf, 0, 0, h_env.limit);\n\t\tif (RB_GET_ALIGN(h_env.obuf) == RB_CENTER)\n\t\t    alignment = ALIGN_CENTER;\n\t\telse if (RB_GET_ALIGN(h_env.obuf) == RB_RIGHT)\n\t\t    alignment = ALIGN_RIGHT;\n\t\telse\n\t\t    alignment = ALIGN_LEFT;\n\n\t\tif (alignment != ALIGN_LEFT) {\n\t\t    for (ti = tbl->tables[id].buf->first;\n\t\t\t ti != NULL; ti = ti->next)\n\t\t\talign(ti->ptr, h_env.limit, alignment);\n\t\t}\n\t\tappendTextLineList(h_env.buf, tbl->tables[id].buf);\n\t\tif (h_env.maxlimit < limit)\n\t\t    h_env.maxlimit = limit;\n\t\trestore_fonteffect(&h_env, h_env.obuf);\n\t\tobuf.flag &= ~RB_IGNORE_P;\n\t\th_env.blank_lines = 0;\n\t\tif (t->vspace > 0) {\n\t\t    do_blankline(&h_env, &obuf, 0, 0, h_env.limit);\n\t\t    obuf.flag |= RB_IGNORE_P;\n\t\t}\n\t    }\n\t}\n\telse\n\t    HTMLlineproc1(l->ptr, &h_env);\n    }\n    if (obuf.status != R_ST_NORMAL) {\n\tobuf.status = R_ST_EOL;\n\tHTMLlineproc1(\"\\n\", &h_env);\n    }\n    completeHTMLstream(&h_env, &obuf);\n    flushline(&h_env, &obuf, 0, 2, h_env.limit);\n    if (tbl->border_mode == BORDER_NONE) {\n\tint rowspan = table_rowspan(tbl, row, col);\n\tif (row + rowspan <= tbl->maxrow) {\n\t    if (tbl->vcellpadding > 0 && !(obuf.flag & RB_IGNORE_P))\n\t\tdo_blankline(&h_env, &obuf, 0, 0, h_env.limit);\n\t}\n\telse {\n\t    if (tbl->vspace > 0)\n\t\tpurgeline(&h_env);\n\t}\n    }\n    else {\n\tif (tbl->vcellpadding > 0) {\n\t    if (!(obuf.flag & RB_IGNORE_P))\n\t\tdo_blankline(&h_env, &obuf, 0, 0, h_env.limit);\n\t}\n\telse\n\t    purgeline(&h_env);\n    }\n    if ((colspan = table_colspan(tbl, row, col)) > 1) {\n\tstruct table_cell *cell = &tbl->cell;\n\tint k;\n\tk = bsearch_2short(colspan, cell->colspan, col, cell->col, MAXCOL,\n\t\t\t   cell->index, cell->maxcell + 1);\n\ticell = cell->index[k];\n\tif (cell->minimum_width[icell] < h_env.maxlimit)\n\t    cell->minimum_width[icell] = h_env.maxlimit;\n    }\n    else {\n\tif (tbl->minimum_width[col] < h_env.maxlimit)\n\t    tbl->minimum_width[col] = h_env.maxlimit;\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145798,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "MultiPartInputFile::initialize()\n{\n    readMagicNumberAndVersionField(*_data->is, _data->version);\n    \n    bool multipart = isMultiPart(_data->version);\n    bool tiled = isTiled(_data->version);\n\n    //\n    // Multipart files don't have and shouldn't have the tiled bit set.\n    //\n\n    if (tiled && multipart)\n        throw IEX_NAMESPACE::InputExc (\"Multipart files cannot have the tiled bit set\");\n\n    \n    int pos = 0;\n    while (true)\n    {\n        Header header;\n        header.readFrom(*_data->is, _data->version);\n\n        //\n        // If we read nothing then we stop reading.\n        //\n\n        if (header.readsNothing())\n        {\n            pos++;\n            break;\n        }\n\n        _data->_headers.push_back(header);\n        \n        if(multipart == false)\n          break;\n    }\n\n    //\n    // Perform usual check on headers.\n    //\n\n    for (size_t i = 0; i < _data->_headers.size(); i++)\n    {\n        //\n        // Silently invent a type if the file is a single part regular image.\n        //\n\n        if( _data->_headers[i].hasType() == false )\n        {\n            if(multipart)\n\n                throw IEX_NAMESPACE::ArgExc (\"Every header in a multipart file should have a type\");\n          \n            _data->_headers[i].setType(tiled ? TILEDIMAGE : SCANLINEIMAGE);\n        }\n        else\n        {\n            \n            //\n            // Silently fix the header type if it's wrong\n            // (happens when a regular Image file written by EXR_2.0 is rewritten by an older library,\n            //  so doesn't effect deep image types)\n            //\n\n            if(!multipart && !isNonImage(_data->version))\n            {\n                _data->_headers[i].setType(tiled ? TILEDIMAGE : SCANLINEIMAGE);\n            }\n        }\n         \n\n        \n        if( _data->_headers[i].hasName() == false )\n        {\n            if(multipart)\n                throw IEX_NAMESPACE::ArgExc (\"Every header in a multipart file should have a name\");\n        }\n        \n        if (isTiled(_data->_headers[i].type()))\n            _data->_headers[i].sanityCheck(true, multipart);\n        else\n            _data->_headers[i].sanityCheck(false, multipart);\n    }\n\n    //\n    // Check name uniqueness.\n    //\n\n    if (multipart)\n    {\n        set<string> names;\n        for (size_t i = 0; i < _data->_headers.size(); i++)\n        {\n        \n            if (names.find(_data->_headers[i].name()) != names.end())\n            {\n                throw IEX_NAMESPACE::InputExc (\"Header name \" + _data->_headers[i].name() +\n                                   \" is not a unique name.\");\n            }\n            names.insert(_data->_headers[i].name());\n        }\n    }\n    \n    //\n    // Check shared attributes compliance.\n    //\n\n    if (multipart && strictSharedAttribute)\n    {\n        for (size_t i = 1; i < _data->_headers.size(); i++)\n        {\n            vector <string> attrs;\n            if (_data->checkSharedAttributesValues (_data->_headers[0], _data->_headers[i], attrs))\n            {\n                string attrNames;\n                for (size_t j=0; j<attrs.size(); j++)\n                    attrNames += \" \" + attrs[j];\n                throw IEX_NAMESPACE::InputExc (\"Header name \" + _data->_headers[i].name() +\n                                     \" has non-conforming shared attributes: \"+\n                                     attrNames);\n            }\n        }\n    }\n\n    //\n    // Create InputParts and read chunk offset tables.\n    //\n        \n    for (size_t i = 0; i < _data->_headers.size(); i++)\n        _data->parts.push_back(\n                new InputPartData(_data, _data->_headers[i], i, _data->numThreads, _data->version));\n\n    _data->readChunkOffsetTables(_data->reconstructChunkOffsetTable);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145856,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "MultiPartInputFile::initialize()\n{\n    readMagicNumberAndVersionField(*_data->is, _data->version);\n    \n    bool multipart = isMultiPart(_data->version);\n    bool tiled = isTiled(_data->version);\n\n    //\n    // Multipart files don't have and shouldn't have the tiled bit set.\n    //\n\n    if (tiled && multipart)\n        throw IEX_NAMESPACE::InputExc (\"Multipart files cannot have the tiled bit set\");\n\n    \n    int pos = 0;\n    while (true)\n    {\n        Header header;\n        header.readFrom(*_data->is, _data->version);\n\n        //\n        // If we read nothing then we stop reading.\n        //\n\n        if (header.readsNothing())\n        {\n            pos++;\n            break;\n        }\n\n        _data->_headers.push_back(header);\n        \n        if(multipart == false)\n          break;\n    }\n\n    //\n    // Perform usual check on headers.\n    //\n\n    if ( _data->_headers.size() == 0)\n    {\n        throw IEX_NAMESPACE::ArgExc (\"Files must contain at least one header\");\n    }\n\n    for (size_t i = 0; i < _data->_headers.size(); i++)\n    {\n        //\n        // Silently invent a type if the file is a single part regular image.\n        //\n\n        if( _data->_headers[i].hasType() == false )\n        {\n            if(multipart)\n\n                throw IEX_NAMESPACE::ArgExc (\"Every header in a multipart file should have a type\");\n          \n            _data->_headers[i].setType(tiled ? TILEDIMAGE : SCANLINEIMAGE);\n        }\n        else\n        {\n            \n            //\n            // Silently fix the header type if it's wrong\n            // (happens when a regular Image file written by EXR_2.0 is rewritten by an older library,\n            //  so doesn't effect deep image types)\n            //\n\n            if(!multipart && !isNonImage(_data->version))\n            {\n                _data->_headers[i].setType(tiled ? TILEDIMAGE : SCANLINEIMAGE);\n            }\n        }\n         \n\n        \n        if( _data->_headers[i].hasName() == false )\n        {\n            if(multipart)\n                throw IEX_NAMESPACE::ArgExc (\"Every header in a multipart file should have a name\");\n        }\n        \n        if (isTiled(_data->_headers[i].type()))\n            _data->_headers[i].sanityCheck(true, multipart);\n        else\n            _data->_headers[i].sanityCheck(false, multipart);\n    }\n\n    //\n    // Check name uniqueness.\n    //\n\n    if (multipart)\n    {\n        set<string> names;\n        for (size_t i = 0; i < _data->_headers.size(); i++)\n        {\n        \n            if (names.find(_data->_headers[i].name()) != names.end())\n            {\n                throw IEX_NAMESPACE::InputExc (\"Header name \" + _data->_headers[i].name() +\n                                   \" is not a unique name.\");\n            }\n            names.insert(_data->_headers[i].name());\n        }\n    }\n    \n    //\n    // Check shared attributes compliance.\n    //\n\n    if (multipart && strictSharedAttribute)\n    {\n        for (size_t i = 1; i < _data->_headers.size(); i++)\n        {\n            vector <string> attrs;\n            if (_data->checkSharedAttributesValues (_data->_headers[0], _data->_headers[i], attrs))\n            {\n                string attrNames;\n                for (size_t j=0; j<attrs.size(); j++)\n                    attrNames += \" \" + attrs[j];\n                throw IEX_NAMESPACE::InputExc (\"Header name \" + _data->_headers[i].name() +\n                                     \" has non-conforming shared attributes: \"+\n                                     attrNames);\n            }\n        }\n    }\n\n    //\n    // Create InputParts and read chunk offset tables.\n    //\n        \n    for (size_t i = 0; i < _data->_headers.size(); i++)\n        _data->parts.push_back(\n                new InputPartData(_data, _data->_headers[i], i, _data->numThreads, _data->version));\n\n    _data->readChunkOffsetTables(_data->reconstructChunkOffsetTable);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145857,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn;\n\n\tbitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);\n\n\tif (irqchip_split(vcpu->kvm))\n\t\tkvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);\n\telse {\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tkvm_x86_ops->sync_pir_to_irr(vcpu);\n\t\tkvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);\n\t}\n\n\tif (is_guest_mode(vcpu))\n\t\tvcpu->arch.load_eoi_exitmap_pending = true;\n\telse\n\t\tkvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145860,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn;\n\n\tbitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);\n\n\tif (irqchip_split(vcpu->kvm))\n\t\tkvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);\n\telse {\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tkvm_x86_ops->sync_pir_to_irr(vcpu);\n\t\tif (ioapic_in_kernel(vcpu->kvm))\n\t\t\tkvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);\n\t}\n\n\tif (is_guest_mode(vcpu))\n\t\tvcpu->arch.load_eoi_exitmap_pending = true;\n\telse\n\t\tkvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145861,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "shiftAnchorPosition(AnchorList *al, HmarkerList *hl, int line, int pos,\n\t\t    int shift)\n{\n    Anchor *a;\n    size_t b, e, s = 0;\n    int cmp;\n\n    if (al == NULL || al->nanchor == 0)\n\treturn;\n\n    s = al->nanchor / 2;\n    for (b = 0, e = al->nanchor - 1; b <= e; s = (b + e + 1) / 2) {\n\ta = &al->anchors[s];\n\tcmp = onAnchor(a, line, pos);\n\tif (cmp == 0)\n\t    break;\n\telse if (cmp > 0)\n\t    b = s + 1;\n\telse if (s == 0)\n\t    break;\n\telse\n\t    e = s - 1;\n    }\n    for (; s < al->nanchor; s++) {\n\ta = &al->anchors[s];\n\tif (a->start.line > line)\n\t    break;\n\tif (a->start.pos > pos) {\n\t    a->start.pos += shift;\n\t    if (hl->marks[a->hseq].line == line)\n\t\thl->marks[a->hseq].pos = a->start.pos;\n\t}\n\tif (a->end.pos >= pos)\n\t    a->end.pos += shift;\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145882,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "shiftAnchorPosition(AnchorList *al, HmarkerList *hl, int line, int pos,\n\t\t    int shift)\n{\n    Anchor *a;\n    size_t b, e, s = 0;\n    int cmp;\n\n    if (al == NULL || al->nanchor == 0)\n\treturn;\n\n    s = al->nanchor / 2;\n    for (b = 0, e = al->nanchor - 1; b <= e; s = (b + e + 1) / 2) {\n\ta = &al->anchors[s];\n\tcmp = onAnchor(a, line, pos);\n\tif (cmp == 0)\n\t    break;\n\telse if (cmp > 0)\n\t    b = s + 1;\n\telse if (s == 0)\n\t    break;\n\telse\n\t    e = s - 1;\n    }\n    for (; s < al->nanchor; s++) {\n\ta = &al->anchors[s];\n\tif (a->start.line > line)\n\t    break;\n\tif (a->start.pos > pos) {\n\t    a->start.pos += shift;\n\t    if (hl && hl->marks && hl->marks[a->hseq].line == line)\n\t\thl->marks[a->hseq].pos = a->start.pos;\n\t}\n\tif (a->end.pos >= pos)\n\t    a->end.pos += shift;\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145883,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "PHP_FUNCTION(ldap_get_entries)\n{\n\tzval *link, *result;\n\tLDAPMessage *ldap_result, *ldap_result_entry;\n\tzval *tmp1, *tmp2;\n\tldap_linkdata *ld;\n\tLDAP *ldap;\n\tint num_entries, num_attrib, num_values, i;\n\tBerElement *ber;\n\tchar *attribute;\n\tsize_t attr_len;\n\tstruct berval **ldap_value;\n\tchar *dn;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rr\", &link, &result) != SUCCESS) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(ld, ldap_linkdata *, &link, -1, \"ldap link\", le_link);\n\tZEND_FETCH_RESOURCE(ldap_result, LDAPMessage *, &result, -1, \"ldap result\", le_result);\n\n\tldap = ld->link;\n\tnum_entries = ldap_count_entries(ldap, ldap_result);\n\n\tarray_init(return_value);\n\tadd_assoc_long(return_value, \"count\", num_entries);\n\n\tif (num_entries == 0) {\n\t\treturn;\n\t}\n\n\tldap_result_entry = ldap_first_entry(ldap, ldap_result);\n\tif (ldap_result_entry == NULL) {\n\t\tzval_dtor(return_value);\n\t\tRETURN_FALSE;\n\t}\n\n\tnum_entries = 0;\n\twhile (ldap_result_entry != NULL) {\n\t\tMAKE_STD_ZVAL(tmp1);\n\t\tarray_init(tmp1);\n\n\t\tnum_attrib = 0;\n\t\tattribute = ldap_first_attribute(ldap, ldap_result_entry, &ber);\n\n\t\twhile (attribute != NULL) {\n\t\t\tldap_value = ldap_get_values_len(ldap, ldap_result_entry, attribute);\n\t\t\tnum_values = ldap_count_values_len(ldap_value);\n\n\t\t\tMAKE_STD_ZVAL(tmp2);\n\t\t\tarray_init(tmp2);\n\t\t\tadd_assoc_long(tmp2, \"count\", num_values);\n\t\t\tfor (i = 0; i < num_values; i++) {\n\t\t\t\tadd_index_stringl(tmp2, i, ldap_value[i]->bv_val, ldap_value[i]->bv_len, 1);\n\t\t\t}\n\t\t\tldap_value_free_len(ldap_value);\n\n\t\t\tattr_len = strlen(attribute);\n\t\t\tzend_hash_update(Z_ARRVAL_P(tmp1), php_strtolower(attribute, attr_len), attr_len+1, (void *) &tmp2, sizeof(zval *), NULL);\n\t\t\tadd_index_string(tmp1, num_attrib, attribute, 1);\n\n\t\t\tnum_attrib++;\n#if (LDAP_API_VERSION > 2000) || HAVE_NSLDAP || HAVE_ORALDAP || WINDOWS\n\t\t\tldap_memfree(attribute);\n#endif\n\t\t\tattribute = ldap_next_attribute(ldap, ldap_result_entry, ber);\n\t\t}\n#if (LDAP_API_VERSION > 2000) || HAVE_NSLDAP || HAVE_ORALDAP || WINDOWS\n\t\tif (ber != NULL) {\n\t\t\tber_free(ber, 0);\n\t\t}\n#endif\n\n\t\tadd_assoc_long(tmp1, \"count\", num_attrib);\n\t\tdn = ldap_get_dn(ldap, ldap_result_entry);\n\t\tadd_assoc_string(tmp1, \"dn\", dn, 1);\n#if (LDAP_API_VERSION > 2000) || HAVE_NSLDAP || HAVE_ORALDAP || WINDOWS\n\t\tldap_memfree(dn);\n#else\n\t\tfree(dn);\n#endif\n\n\t\tzend_hash_index_update(Z_ARRVAL_P(return_value), num_entries, (void *) &tmp1, sizeof(zval *), NULL);\n\n\t\tnum_entries++;\n\t\tldap_result_entry = ldap_next_entry(ldap, ldap_result_entry);\n\t}\n\n\tadd_assoc_long(return_value, \"count\", num_entries);\n\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145978,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "PHP_FUNCTION(ldap_get_entries)\n{\n\tzval *link, *result;\n\tLDAPMessage *ldap_result, *ldap_result_entry;\n\tzval *tmp1, *tmp2;\n\tldap_linkdata *ld;\n\tLDAP *ldap;\n\tint num_entries, num_attrib, num_values, i;\n\tBerElement *ber;\n\tchar *attribute;\n\tsize_t attr_len;\n\tstruct berval **ldap_value;\n\tchar *dn;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rr\", &link, &result) != SUCCESS) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(ld, ldap_linkdata *, &link, -1, \"ldap link\", le_link);\n\tZEND_FETCH_RESOURCE(ldap_result, LDAPMessage *, &result, -1, \"ldap result\", le_result);\n\n\tldap = ld->link;\n\tnum_entries = ldap_count_entries(ldap, ldap_result);\n\n\tarray_init(return_value);\n\tadd_assoc_long(return_value, \"count\", num_entries);\n\n\tif (num_entries == 0) {\n\t\treturn;\n\t}\n\n\tldap_result_entry = ldap_first_entry(ldap, ldap_result);\n\tif (ldap_result_entry == NULL) {\n\t\tzval_dtor(return_value);\n\t\tRETURN_FALSE;\n\t}\n\n\tnum_entries = 0;\n\twhile (ldap_result_entry != NULL) {\n\t\tMAKE_STD_ZVAL(tmp1);\n\t\tarray_init(tmp1);\n\n\t\tnum_attrib = 0;\n\t\tattribute = ldap_first_attribute(ldap, ldap_result_entry, &ber);\n\n\t\twhile (attribute != NULL) {\n\t\t\tldap_value = ldap_get_values_len(ldap, ldap_result_entry, attribute);\n\t\t\tnum_values = ldap_count_values_len(ldap_value);\n\n\t\t\tMAKE_STD_ZVAL(tmp2);\n\t\t\tarray_init(tmp2);\n\t\t\tadd_assoc_long(tmp2, \"count\", num_values);\n\t\t\tfor (i = 0; i < num_values; i++) {\n\t\t\t\tadd_index_stringl(tmp2, i, ldap_value[i]->bv_val, ldap_value[i]->bv_len, 1);\n\t\t\t}\n\t\t\tldap_value_free_len(ldap_value);\n\n\t\t\tattr_len = strlen(attribute);\n\t\t\tzend_hash_update(Z_ARRVAL_P(tmp1), php_strtolower(attribute, attr_len), attr_len+1, (void *) &tmp2, sizeof(zval *), NULL);\n\t\t\tadd_index_string(tmp1, num_attrib, attribute, 1);\n\n\t\t\tnum_attrib++;\n#if (LDAP_API_VERSION > 2000) || HAVE_NSLDAP || HAVE_ORALDAP || WINDOWS\n\t\t\tldap_memfree(attribute);\n#endif\n\t\t\tattribute = ldap_next_attribute(ldap, ldap_result_entry, ber);\n\t\t}\n#if (LDAP_API_VERSION > 2000) || HAVE_NSLDAP || HAVE_ORALDAP || WINDOWS\n\t\tif (ber != NULL) {\n\t\t\tber_free(ber, 0);\n\t\t}\n#endif\n\n\t\tadd_assoc_long(tmp1, \"count\", num_attrib);\n\t\tdn = ldap_get_dn(ldap, ldap_result_entry);\n\t\tif (dn) {\n\t\t\tadd_assoc_string(tmp1, \"dn\", dn, 1);\n\t\t} else {\n\t\t\tadd_assoc_null(tmp1, \"dn\");\n\t\t}\n#if (LDAP_API_VERSION > 2000) || HAVE_NSLDAP || HAVE_ORALDAP || WINDOWS\n\t\tldap_memfree(dn);\n#else\n\t\tfree(dn);\n#endif\n\n\t\tzend_hash_index_update(Z_ARRVAL_P(return_value), num_entries, (void *) &tmp1, sizeof(zval *), NULL);\n\n\t\tnum_entries++;\n\t\tldap_result_entry = ldap_next_entry(ldap, ldap_result_entry);\n\t}\n\n\tadd_assoc_long(return_value, \"count\", num_entries);\n\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145979,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int main(int argc, char *argv[]) {\n  GooString *fileName;\n  UnicodeMap *uMap;\n  GooString *ownerPW, *userPW;\n  PDFDoc *doc;\n  char uBuf[8];\n  char path[1024];\n  char *p;\n  bool ok;\n  int exitCode;\n  GooList *embeddedFiles = nullptr;\n  int nFiles, nPages, n, i, j;\n  FileSpec *fileSpec;\n  Page *page;\n  Annots *annots;\n  Annot *annot;\n  const GooString *s1;\n  Unicode u;\n  bool isUnicode;\n\n  Win32Console win32Console(&argc, &argv);\n  exitCode = 99;\n\n  // parse args\n  ok = parseArgs(argDesc, &argc, argv);\n  if ((doList ? 1 : 0) +\n      ((saveNum != 0) ? 1 : 0) +\n      (saveAll ? 1 : 0) != 1) {\n    ok = false;\n  }\n  if (!ok || argc != 2 || printVersion || printHelp) {\n    fprintf(stderr, \"pdfdetach version %s\\n\", PACKAGE_VERSION);\n    fprintf(stderr, \"%s\\n\", popplerCopyright);\n    fprintf(stderr, \"%s\\n\", xpdfCopyright);\n    if (!printVersion) {\n      printUsage(\"pdfdetach\", \"<PDF-file>\", argDesc);\n    }\n    goto err0;\n  }\n  fileName = new GooString(argv[1]);\n\n  // read config file\n  globalParams = new GlobalParams();\n  if (textEncName[0]) {\n    globalParams->setTextEncoding(textEncName);\n  }\n\n  // get mapping to output encoding\n  if (!(uMap = globalParams->getTextEncoding())) {\n    error(errConfig, -1, \"Couldn't get text encoding\");\n    delete fileName;\n    goto err1;\n  }\n\n  // open PDF file\n  if (ownerPassword[0] != '\\001') {\n    ownerPW = new GooString(ownerPassword);\n  } else {\n    ownerPW = nullptr;\n  }\n  if (userPassword[0] != '\\001') {\n    userPW = new GooString(userPassword);\n  } else {\n    userPW = nullptr;\n  }\n\n  doc = PDFDocFactory().createPDFDoc(*fileName, ownerPW, userPW);\n\n  if (userPW) {\n    delete userPW;\n  }\n  if (ownerPW) {\n    delete ownerPW;\n  }\n  if (!doc->isOk()) {\n    exitCode = 1;\n    goto err2;\n  }\n\n  embeddedFiles = new GooList();\n  for (i = 0; i < doc->getCatalog()->numEmbeddedFiles(); ++i)\n    embeddedFiles->push_back(doc->getCatalog()->embeddedFile(i));\n\n  nPages = doc->getCatalog()->getNumPages();\n  for (i = 0; i < nPages; ++i) {\n    page = doc->getCatalog()->getPage(i + 1);\n    if (!page)\n      continue;\n    annots = page->getAnnots();\n    if (!annots)\n      break;\n\n    for (j = 0; j < annots->getNumAnnots(); ++j) {\n      annot = annots->getAnnot(j);\n      if (annot->getType() != Annot::typeFileAttachment)\n        continue;\n      embeddedFiles->push_back(new FileSpec(static_cast<AnnotFileAttachment *>(annot)->getFile()));\n    }\n  }\n\n  nFiles = embeddedFiles->getLength();\n\n  // list embedded files\n  if (doList) {\n    printf(\"%d embedded files\\n\", nFiles);\n    for (i = 0; i < nFiles; ++i) {\n      fileSpec = static_cast<FileSpec *>(embeddedFiles->get(i));\n      printf(\"%d: \", i+1);\n      s1 = fileSpec->getFileName();\n      if ((s1->getChar(0) & 0xff) == 0xfe && (s1->getChar(1) & 0xff) == 0xff) {\n        isUnicode = true;\n        j = 2;\n      } else {\n        isUnicode = false;\n        j = 0;\n      }\n      while (j < fileSpec->getFileName()->getLength()) {\n        if (isUnicode) {\n          u = ((s1->getChar(j) & 0xff) << 8) | (s1->getChar(j+1) & 0xff);\n          j += 2;\n        } else {\n          u = pdfDocEncoding[s1->getChar(j) & 0xff];\n          ++j;\n        }\n        n = uMap->mapUnicode(u, uBuf, sizeof(uBuf));\n        fwrite(uBuf, 1, n, stdout);\n      }\n      fputc('\\n', stdout);\n    }\n\n  // save all embedded files\n  } else if (saveAll) {\n    for (i = 0; i < nFiles; ++i) {\n      fileSpec = static_cast<FileSpec *>(embeddedFiles->get(i));\n      if (savePath[0]) {\n\tn = strlen(savePath);\n\tif (n > (int)sizeof(path) - 2) {\n\t  n = sizeof(path) - 2;\n\t}\n\tmemcpy(path, savePath, n);\n\tpath[n] = '/';\n\tp = path + n + 1;\n      } else {\n\tp = path;\n      }\n      s1 = fileSpec->getFileName();\n      if ((s1->getChar(0) & 0xff) == 0xfe && (s1->getChar(1) & 0xff) == 0xff) {\n        isUnicode = true;\n        j = 2;\n      } else {\n        isUnicode = false;\n        j = 0;\n      }\n      while (j < fileSpec->getFileName()->getLength()) {\n        if (isUnicode) {\n          u = ((s1->getChar(j) & 0xff) << 8) | (s1->getChar(j+1) & 0xff);\n          j += 2;\n        } else {\n          u = pdfDocEncoding[s1->getChar(j) & 0xff];\n          ++j;\n        }\n        n = uMap->mapUnicode(u, uBuf, sizeof(uBuf));\n        if (p + n >= path + sizeof(path))\n          break;\n        memcpy(p, uBuf, n);\n        p += n;\n      }\n      *p = '\\0';\n\n      auto *embFile = fileSpec->getEmbeddedFile();\n      if (!embFile || !embFile->isOk()) {\n\texitCode = 3;\n\tgoto err2;\n      }\n      if (!embFile->save(path)) {\n\terror(errIO, -1, \"Error saving embedded file as '{0:s}'\", p);\n\texitCode = 2;\n\tgoto err2;\n      }\n    }\n\n  // save an embedded file\n  } else {\n    if (saveNum < 1 || saveNum > nFiles) {\n      error(errCommandLine, -1, \"Invalid file number\");\n      goto err2;\n    }\n\n    fileSpec = static_cast<FileSpec *>(embeddedFiles->get(saveNum - 1));\n    if (savePath[0]) {\n      p = savePath;\n    } else {\n      p = path;\n      s1 = fileSpec->getFileName();\n      if ((s1->getChar(0) & 0xff) == 0xfe && (s1->getChar(1) & 0xff) == 0xff) {\n        isUnicode = true;\n        j = 2;\n      } else {\n        isUnicode = false;\n        j = 0;\n      }\n      while (j < fileSpec->getFileName()->getLength()) {\n        if (isUnicode) {\n          u = ((s1->getChar(j) & 0xff) << 8) | (s1->getChar(j+1) & 0xff);\n          j += 2;\n        } else {\n          u = pdfDocEncoding[s1->getChar(j) & 0xff];\n          ++j;\n        }\n        n = uMap->mapUnicode(u, uBuf, sizeof(uBuf));\n        if (p + n >= path + sizeof(path))\n          break;\n        memcpy(p, uBuf, n);\n        p += n;\n      }\n      *p = '\\0';\n      p = path;\n    }\n\n    auto *embFile = fileSpec->getEmbeddedFile();\n    if (!embFile || !embFile->isOk()) {\n      exitCode = 3;\n      goto err2;\n    }\n    if (!embFile->save(p)) {\n      error(errIO, -1, \"Error saving embedded file as '{0:s}'\", p);\n      exitCode = 2;\n      goto err2;\n    }\n  }\n\n  exitCode = 0;\n\n  // clean up\n err2:\n  if (embeddedFiles)\n    deleteGooList<FileSpec>(embeddedFiles);\n  uMap->decRefCnt();\n  delete doc;\n err1:\n  delete globalParams;\n err0:\n\n  return exitCode;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145986,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int main(int argc, char *argv[]) {\n  GooString *fileName;\n  UnicodeMap *uMap;\n  GooString *ownerPW, *userPW;\n  PDFDoc *doc;\n  char uBuf[8];\n  char path[1024];\n  char *p;\n  bool ok;\n  int exitCode;\n  GooList *embeddedFiles = nullptr;\n  int nFiles, nPages, n, i, j;\n  FileSpec *fileSpec;\n  Page *page;\n  Annots *annots;\n  Annot *annot;\n  const GooString *s1;\n  Unicode u;\n  bool isUnicode;\n\n  Win32Console win32Console(&argc, &argv);\n  exitCode = 99;\n\n  // parse args\n  ok = parseArgs(argDesc, &argc, argv);\n  if ((doList ? 1 : 0) +\n      ((saveNum != 0) ? 1 : 0) +\n      (saveAll ? 1 : 0) != 1) {\n    ok = false;\n  }\n  if (!ok || argc != 2 || printVersion || printHelp) {\n    fprintf(stderr, \"pdfdetach version %s\\n\", PACKAGE_VERSION);\n    fprintf(stderr, \"%s\\n\", popplerCopyright);\n    fprintf(stderr, \"%s\\n\", xpdfCopyright);\n    if (!printVersion) {\n      printUsage(\"pdfdetach\", \"<PDF-file>\", argDesc);\n    }\n    goto err0;\n  }\n  fileName = new GooString(argv[1]);\n\n  // read config file\n  globalParams = new GlobalParams();\n  if (textEncName[0]) {\n    globalParams->setTextEncoding(textEncName);\n  }\n\n  // get mapping to output encoding\n  if (!(uMap = globalParams->getTextEncoding())) {\n    error(errConfig, -1, \"Couldn't get text encoding\");\n    delete fileName;\n    goto err1;\n  }\n\n  // open PDF file\n  if (ownerPassword[0] != '\\001') {\n    ownerPW = new GooString(ownerPassword);\n  } else {\n    ownerPW = nullptr;\n  }\n  if (userPassword[0] != '\\001') {\n    userPW = new GooString(userPassword);\n  } else {\n    userPW = nullptr;\n  }\n\n  doc = PDFDocFactory().createPDFDoc(*fileName, ownerPW, userPW);\n\n  if (userPW) {\n    delete userPW;\n  }\n  if (ownerPW) {\n    delete ownerPW;\n  }\n  if (!doc->isOk()) {\n    exitCode = 1;\n    goto err2;\n  }\n\n  embeddedFiles = new GooList();\n  for (i = 0; i < doc->getCatalog()->numEmbeddedFiles(); ++i)\n    embeddedFiles->push_back(doc->getCatalog()->embeddedFile(i));\n\n  nPages = doc->getCatalog()->getNumPages();\n  for (i = 0; i < nPages; ++i) {\n    page = doc->getCatalog()->getPage(i + 1);\n    if (!page)\n      continue;\n    annots = page->getAnnots();\n    if (!annots)\n      break;\n\n    for (j = 0; j < annots->getNumAnnots(); ++j) {\n      annot = annots->getAnnot(j);\n      if (annot->getType() != Annot::typeFileAttachment)\n        continue;\n      embeddedFiles->push_back(new FileSpec(static_cast<AnnotFileAttachment *>(annot)->getFile()));\n    }\n  }\n\n  nFiles = embeddedFiles->getLength();\n\n  // list embedded files\n  if (doList) {\n    printf(\"%d embedded files\\n\", nFiles);\n    for (i = 0; i < nFiles; ++i) {\n      fileSpec = static_cast<FileSpec *>(embeddedFiles->get(i));\n      printf(\"%d: \", i+1);\n      s1 = fileSpec->getFileName();\n      if (!s1) {\n\texitCode = 3;\n\tgoto err2;\n      }\n      if (s1->hasUnicodeMarker()) {\n        isUnicode = true;\n        j = 2;\n      } else {\n        isUnicode = false;\n        j = 0;\n      }\n      while (j < s1->getLength()) {\n        if (isUnicode) {\n          u = ((s1->getChar(j) & 0xff) << 8) | (s1->getChar(j+1) & 0xff);\n          j += 2;\n        } else {\n          u = pdfDocEncoding[s1->getChar(j) & 0xff];\n          ++j;\n        }\n        n = uMap->mapUnicode(u, uBuf, sizeof(uBuf));\n        fwrite(uBuf, 1, n, stdout);\n      }\n      fputc('\\n', stdout);\n    }\n\n  // save all embedded files\n  } else if (saveAll) {\n    for (i = 0; i < nFiles; ++i) {\n      fileSpec = static_cast<FileSpec *>(embeddedFiles->get(i));\n      if (savePath[0]) {\n\tn = strlen(savePath);\n\tif (n > (int)sizeof(path) - 2) {\n\t  n = sizeof(path) - 2;\n\t}\n\tmemcpy(path, savePath, n);\n\tpath[n] = '/';\n\tp = path + n + 1;\n      } else {\n\tp = path;\n      }\n      s1 = fileSpec->getFileName();\n      if (!s1) {\n\texitCode = 3;\n\tgoto err2;\n      }\n      if (s1->hasUnicodeMarker()) {\n        isUnicode = true;\n        j = 2;\n      } else {\n        isUnicode = false;\n        j = 0;\n      }\n      while (j < s1->getLength()) {\n        if (isUnicode) {\n          u = ((s1->getChar(j) & 0xff) << 8) | (s1->getChar(j+1) & 0xff);\n          j += 2;\n        } else {\n          u = pdfDocEncoding[s1->getChar(j) & 0xff];\n          ++j;\n        }\n        n = uMap->mapUnicode(u, uBuf, sizeof(uBuf));\n        if (p + n >= path + sizeof(path))\n          break;\n        memcpy(p, uBuf, n);\n        p += n;\n      }\n      *p = '\\0';\n\n      auto *embFile = fileSpec->getEmbeddedFile();\n      if (!embFile || !embFile->isOk()) {\n\texitCode = 3;\n\tgoto err2;\n      }\n      if (!embFile->save(path)) {\n\terror(errIO, -1, \"Error saving embedded file as '{0:s}'\", p);\n\texitCode = 2;\n\tgoto err2;\n      }\n    }\n\n  // save an embedded file\n  } else {\n    if (saveNum < 1 || saveNum > nFiles) {\n      error(errCommandLine, -1, \"Invalid file number\");\n      goto err2;\n    }\n\n    fileSpec = static_cast<FileSpec *>(embeddedFiles->get(saveNum - 1));\n    if (savePath[0]) {\n      p = savePath;\n    } else {\n      p = path;\n      s1 = fileSpec->getFileName();\n      if (!s1) {\n\texitCode = 3;\n\tgoto err2;\n      }\n      if (s1->hasUnicodeMarker()) {\n        isUnicode = true;\n        j = 2;\n      } else {\n        isUnicode = false;\n        j = 0;\n      }\n      while (j < s1->getLength()) {\n        if (isUnicode) {\n          u = ((s1->getChar(j) & 0xff) << 8) | (s1->getChar(j+1) & 0xff);\n          j += 2;\n        } else {\n          u = pdfDocEncoding[s1->getChar(j) & 0xff];\n          ++j;\n        }\n        n = uMap->mapUnicode(u, uBuf, sizeof(uBuf));\n        if (p + n >= path + sizeof(path))\n          break;\n        memcpy(p, uBuf, n);\n        p += n;\n      }\n      *p = '\\0';\n      p = path;\n    }\n\n    auto *embFile = fileSpec->getEmbeddedFile();\n    if (!embFile || !embFile->isOk()) {\n      exitCode = 3;\n      goto err2;\n    }\n    if (!embFile->save(p)) {\n      error(errIO, -1, \"Error saving embedded file as '{0:s}'\", p);\n      exitCode = 2;\n      goto err2;\n    }\n  }\n\n  exitCode = 0;\n\n  // clean up\n err2:\n  if (embeddedFiles)\n    deleteGooList<FileSpec>(embeddedFiles);\n  uMap->decRefCnt();\n  delete doc;\n err1:\n  delete globalParams;\n err0:\n\n  return exitCode;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145987,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int pb0100_start(struct sd *sd)\n{\n\tint err, packet_size, max_packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tstruct cam *cam = &sd->gspca_dev.cam;\n\tu32 mode = cam->cam_mode[sd->gspca_dev.curr_mode].priv;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt)\n\t\treturn -ENODEV;\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\n\t/* If we don't have enough bandwidth use a lower framerate */\n\tmax_packet_size = sd->sensor->max_packet_size[sd->gspca_dev.curr_mode];\n\tif (packet_size < max_packet_size)\n\t\tstv06xx_write_sensor(sd, PB_ROWSPEED, BIT(4)|BIT(3)|BIT(1));\n\telse\n\t\tstv06xx_write_sensor(sd, PB_ROWSPEED, BIT(5)|BIT(3)|BIT(1));\n\n\t/* Setup sensor window */\n\tif (mode & PB0100_CROP_TO_VGA) {\n\t\tstv06xx_write_sensor(sd, PB_RSTART, 30);\n\t\tstv06xx_write_sensor(sd, PB_CSTART, 20);\n\t\tstv06xx_write_sensor(sd, PB_RWSIZE, 240 - 1);\n\t\tstv06xx_write_sensor(sd, PB_CWSIZE, 320 - 1);\n\t} else {\n\t\tstv06xx_write_sensor(sd, PB_RSTART, 8);\n\t\tstv06xx_write_sensor(sd, PB_CSTART, 4);\n\t\tstv06xx_write_sensor(sd, PB_RWSIZE, 288 - 1);\n\t\tstv06xx_write_sensor(sd, PB_CWSIZE, 352 - 1);\n\t}\n\n\tif (mode & PB0100_SUBSAMPLE) {\n\t\tstv06xx_write_bridge(sd, STV_Y_CTRL, 0x02); /* Wrong, FIXME */\n\t\tstv06xx_write_bridge(sd, STV_X_CTRL, 0x06);\n\n\t\tstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x10);\n\t} else {\n\t\tstv06xx_write_bridge(sd, STV_Y_CTRL, 0x01);\n\t\tstv06xx_write_bridge(sd, STV_X_CTRL, 0x0a);\n\t\t/* larger -> slower */\n\t\tstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x20);\n\t}\n\n\terr = stv06xx_write_sensor(sd, PB_CONTROL, BIT(5)|BIT(3)|BIT(1));\n\tgspca_dbg(gspca_dev, D_STREAM, \"Started stream, status: %d\\n\", err);\n\n\treturn (err < 0) ? err : 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146030,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int pb0100_start(struct sd *sd)\n{\n\tint err, packet_size, max_packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tstruct cam *cam = &sd->gspca_dev.cam;\n\tu32 mode = cam->cam_mode[sd->gspca_dev.curr_mode].priv;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt)\n\t\treturn -ENODEV;\n\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\n\t/* If we don't have enough bandwidth use a lower framerate */\n\tmax_packet_size = sd->sensor->max_packet_size[sd->gspca_dev.curr_mode];\n\tif (packet_size < max_packet_size)\n\t\tstv06xx_write_sensor(sd, PB_ROWSPEED, BIT(4)|BIT(3)|BIT(1));\n\telse\n\t\tstv06xx_write_sensor(sd, PB_ROWSPEED, BIT(5)|BIT(3)|BIT(1));\n\n\t/* Setup sensor window */\n\tif (mode & PB0100_CROP_TO_VGA) {\n\t\tstv06xx_write_sensor(sd, PB_RSTART, 30);\n\t\tstv06xx_write_sensor(sd, PB_CSTART, 20);\n\t\tstv06xx_write_sensor(sd, PB_RWSIZE, 240 - 1);\n\t\tstv06xx_write_sensor(sd, PB_CWSIZE, 320 - 1);\n\t} else {\n\t\tstv06xx_write_sensor(sd, PB_RSTART, 8);\n\t\tstv06xx_write_sensor(sd, PB_CSTART, 4);\n\t\tstv06xx_write_sensor(sd, PB_RWSIZE, 288 - 1);\n\t\tstv06xx_write_sensor(sd, PB_CWSIZE, 352 - 1);\n\t}\n\n\tif (mode & PB0100_SUBSAMPLE) {\n\t\tstv06xx_write_bridge(sd, STV_Y_CTRL, 0x02); /* Wrong, FIXME */\n\t\tstv06xx_write_bridge(sd, STV_X_CTRL, 0x06);\n\n\t\tstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x10);\n\t} else {\n\t\tstv06xx_write_bridge(sd, STV_Y_CTRL, 0x01);\n\t\tstv06xx_write_bridge(sd, STV_X_CTRL, 0x0a);\n\t\t/* larger -> slower */\n\t\tstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x20);\n\t}\n\n\terr = stv06xx_write_sensor(sd, PB_CONTROL, BIT(5)|BIT(3)|BIT(1));\n\tgspca_dbg(gspca_dev, D_STREAM, \"Started stream, status: %d\\n\", err);\n\n\treturn (err < 0) ? err : 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146031,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\n\tif (--header->nreg)\n\t\treturn;\n\n\tif (parent)\n\t\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146092,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\n\tif (--header->nreg)\n\t\treturn;\n\n\tif (parent) {\n\t\tput_links(header);\n\t\tstart_unregistering(header);\n\t}\n\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146093,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "main(int argc, char* argv[])\n{\n\tuint32 rowsperstrip = (uint32) -1;\n\tTIFF *in, *out;\n\tuint32 w, h;\n\tuint16 samplesperpixel;\n\tuint16 bitspersample;\n\tuint16 config;\n\tuint16 photometric;\n\tuint16* red;\n\tuint16* green;\n\tuint16* blue;\n\ttsize_t rowsize;\n\tregister uint32 row;\n\tregister tsample_t s;\n\tunsigned char *inbuf, *outbuf;\n\tchar thing[1024];\n\tint c;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char *optarg;\n#endif\n        \n        in = (TIFF *) NULL;\n        out = (TIFF *) NULL;\n        inbuf = (unsigned char *) NULL;\n        outbuf = (unsigned char *) NULL;\n\n\twhile ((c = getopt(argc, argv, \"c:r:R:G:B:\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'c':\t\t/* compression scheme */\n\t\t\tif (!processCompressOptions(optarg))\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'r':\t\t/* rows/strip */\n\t\t\trowsperstrip = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tRED = PCT(atoi(optarg));\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tGREEN = PCT(atoi(optarg));\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tBLUE = PCT(atoi(optarg));\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage();\n\t\t\t/*NOTREACHED*/\n\t\t}\n\tif (argc - optind < 2)\n\t\tusage();\n\tin = TIFFOpen(argv[optind], \"r\");\n\tif (in == NULL)\n\t\treturn (-1);\n\tphotometric = 0;\n\tTIFFGetField(in, TIFFTAG_PHOTOMETRIC, &photometric);\n\tif (photometric != PHOTOMETRIC_RGB && photometric != PHOTOMETRIC_PALETTE ) {\n\t\tfprintf(stderr,\n\t    \"%s: Bad photometric; can only handle RGB and Palette images.\\n\",\n\t\t    argv[optind]);\n                goto tiff2bw_error;\n\t}\n\tTIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\tif (samplesperpixel != 1 && samplesperpixel != 3) {\n\t\tfprintf(stderr, \"%s: Bad samples/pixel %u.\\n\",\n\t\t    argv[optind], samplesperpixel);\n                goto tiff2bw_error;\n\t}\n\tif( photometric == PHOTOMETRIC_RGB && samplesperpixel != 3) {\n\t\tfprintf(stderr, \"%s: Bad samples/pixel %u for PHOTOMETRIC_RGB.\\n\",\n\t\t    argv[optind], samplesperpixel);\n                goto tiff2bw_error;\n\t}\n\tTIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\tif (bitspersample != 8) {\n\t\tfprintf(stderr,\n\t\t    \" %s: Sorry, only handle 8-bit samples.\\n\", argv[optind]);\n                goto tiff2bw_error;\n\t}\n\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w);\n\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &h);\n\tTIFFGetField(in, TIFFTAG_PLANARCONFIG, &config);\n\n\tout = TIFFOpen(argv[optind+1], \"w\");\n\tif (out == NULL)\n\t{\n                goto tiff2bw_error;\n\t}\n\tTIFFSetField(out, TIFFTAG_IMAGEWIDTH, w);\n\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, h);\n\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8);\n\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 1);\n\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tcpTags(in, out);\n\tif (compression != (uint16) -1) {\n\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n\t\tswitch (compression) {\n\t\tcase COMPRESSION_JPEG:\n\t\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n\t\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n\t\t\tbreak;\n\t\tcase COMPRESSION_LZW:\n\t\tcase COMPRESSION_DEFLATE:\n\t\t\tif (predictor != 0)\n\t\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\t\t\tbreak;\n\t\t}\n\t}\n\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\tsnprintf(thing, sizeof(thing), \"B&W version of %s\", argv[optind]);\n\tTIFFSetField(out, TIFFTAG_IMAGEDESCRIPTION, thing);\n\tTIFFSetField(out, TIFFTAG_SOFTWARE, \"tiff2bw\");\n\toutbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(out));\n\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP,\n\t    TIFFDefaultStripSize(out, rowsperstrip));\n\n#define\tpack(a,b)\t((a)<<8 | (b))\n\tswitch (pack(photometric, config)) {\n\tcase pack(PHOTOMETRIC_PALETTE, PLANARCONFIG_CONTIG):\n\tcase pack(PHOTOMETRIC_PALETTE, PLANARCONFIG_SEPARATE):\n\t\tTIFFGetField(in, TIFFTAG_COLORMAP, &red, &green, &blue);\n\t\t/*\n\t\t * Convert 16-bit colormap to 8-bit (unless it looks\n\t\t * like an old-style 8-bit colormap).\n\t\t */\n\t\tif (checkcmap(in, 1<<bitspersample, red, green, blue) == 16) {\n\t\t\tint i;\n#define\tCVT(x)\t\t(((x) * 255L) / ((1L<<16)-1))\n\t\t\tfor (i = (1<<bitspersample)-1; i >= 0; i--) {\n\t\t\t\tred[i] = CVT(red[i]);\n\t\t\t\tgreen[i] = CVT(green[i]);\n\t\t\t\tblue[i] = CVT(blue[i]);\n\t\t\t}\n#undef CVT\n\t\t}\n\t\tinbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\n\t\tfor (row = 0; row < h; row++) {\n\t\t\tif (TIFFReadScanline(in, inbuf, row, 0) < 0)\n\t\t\t\tbreak;\n\t\t\tcompresspalette(outbuf, inbuf, w, red, green, blue);\n\t\t\tif (TIFFWriteScanline(out, outbuf, row, 0) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase pack(PHOTOMETRIC_RGB, PLANARCONFIG_CONTIG):\n\t\tinbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\n\t\tfor (row = 0; row < h; row++) {\n\t\t\tif (TIFFReadScanline(in, inbuf, row, 0) < 0)\n\t\t\t\tbreak;\n\t\t\tcompresscontig(outbuf, inbuf, w);\n\t\t\tif (TIFFWriteScanline(out, outbuf, row, 0) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase pack(PHOTOMETRIC_RGB, PLANARCONFIG_SEPARATE):\n\t\trowsize = TIFFScanlineSize(in);\n\t\tinbuf = (unsigned char *)_TIFFmalloc(3*rowsize);\n\t\tfor (row = 0; row < h; row++) {\n\t\t\tfor (s = 0; s < 3; s++)\n\t\t\t\tif (TIFFReadScanline(in,\n\t\t\t\t    inbuf+s*rowsize, row, s) < 0)\n                                        goto tiff2bw_error;\n\t\t\tcompresssep(outbuf,\n\t\t\t    inbuf, inbuf+rowsize, inbuf+2*rowsize, w);\n\t\t\tif (TIFFWriteScanline(out, outbuf, row, 0) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n#undef pack\n        if (inbuf)\n                _TIFFfree(inbuf);\n        if (outbuf)\n                _TIFFfree(outbuf);\n        TIFFClose(in);\n\tTIFFClose(out);\n\treturn (0);\n\n tiff2bw_error:\n        if (inbuf)\n                _TIFFfree(inbuf);\n        if (outbuf)\n                _TIFFfree(outbuf);\n        if (out)\n                TIFFClose(out);\n        if (in)\n                TIFFClose(in);\n        return (-1);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146094,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "main(int argc, char* argv[])\n{\n\tuint32 rowsperstrip = (uint32) -1;\n\tTIFF *in, *out;\n\tuint32 w, h;\n\tuint16 samplesperpixel;\n\tuint16 bitspersample;\n\tuint16 config;\n\tuint16 photometric;\n\tuint16* red;\n\tuint16* green;\n\tuint16* blue;\n\ttsize_t rowsize;\n\tregister uint32 row;\n\tregister tsample_t s;\n\tunsigned char *inbuf, *outbuf;\n\tchar thing[1024];\n\tint c;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char *optarg;\n#endif\n        \n        in = (TIFF *) NULL;\n        out = (TIFF *) NULL;\n        inbuf = (unsigned char *) NULL;\n        outbuf = (unsigned char *) NULL;\n\n\twhile ((c = getopt(argc, argv, \"c:r:R:G:B:\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'c':\t\t/* compression scheme */\n\t\t\tif (!processCompressOptions(optarg))\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'r':\t\t/* rows/strip */\n\t\t\trowsperstrip = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tRED = PCT(atoi(optarg));\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tGREEN = PCT(atoi(optarg));\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tBLUE = PCT(atoi(optarg));\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage();\n\t\t\t/*NOTREACHED*/\n\t\t}\n\tif (argc - optind < 2)\n\t\tusage();\n\tin = TIFFOpen(argv[optind], \"r\");\n\tif (in == NULL)\n\t\treturn (-1);\n\tphotometric = 0;\n\tTIFFGetField(in, TIFFTAG_PHOTOMETRIC, &photometric);\n\tif (photometric != PHOTOMETRIC_RGB && photometric != PHOTOMETRIC_PALETTE ) {\n\t\tfprintf(stderr,\n\t    \"%s: Bad photometric; can only handle RGB and Palette images.\\n\",\n\t\t    argv[optind]);\n                goto tiff2bw_error;\n\t}\n\tTIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\tif (samplesperpixel != 1 && samplesperpixel != 3) {\n\t\tfprintf(stderr, \"%s: Bad samples/pixel %u.\\n\",\n\t\t    argv[optind], samplesperpixel);\n                goto tiff2bw_error;\n\t}\n\tif( photometric == PHOTOMETRIC_RGB && samplesperpixel != 3) {\n\t\tfprintf(stderr, \"%s: Bad samples/pixel %u for PHOTOMETRIC_RGB.\\n\",\n\t\t    argv[optind], samplesperpixel);\n                goto tiff2bw_error;\n\t}\n\tTIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\tif (bitspersample != 8) {\n\t\tfprintf(stderr,\n\t\t    \" %s: Sorry, only handle 8-bit samples.\\n\", argv[optind]);\n                goto tiff2bw_error;\n\t}\n\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w);\n\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &h);\n\tTIFFGetField(in, TIFFTAG_PLANARCONFIG, &config);\n\n\tout = TIFFOpen(argv[optind+1], \"w\");\n\tif (out == NULL)\n\t{\n                goto tiff2bw_error;\n\t}\n\tTIFFSetField(out, TIFFTAG_IMAGEWIDTH, w);\n\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, h);\n\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8);\n\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 1);\n\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tcpTags(in, out);\n\tif (compression != (uint16) -1) {\n\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n\t\tswitch (compression) {\n\t\tcase COMPRESSION_JPEG:\n\t\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n\t\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n\t\t\tbreak;\n\t\tcase COMPRESSION_LZW:\n\t\tcase COMPRESSION_DEFLATE:\n\t\t\tif (predictor != 0)\n\t\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\t\t\tbreak;\n\t\t}\n\t}\n\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\tsnprintf(thing, sizeof(thing), \"B&W version of %s\", argv[optind]);\n\tTIFFSetField(out, TIFFTAG_IMAGEDESCRIPTION, thing);\n\tTIFFSetField(out, TIFFTAG_SOFTWARE, \"tiff2bw\");\n\toutbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(out));\n        if( !outbuf )\n        {\n            fprintf(stderr, \"Out of memory\\n\");\n            goto tiff2bw_error;\n        }\n\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP,\n\t    TIFFDefaultStripSize(out, rowsperstrip));\n\n#define\tpack(a,b)\t((a)<<8 | (b))\n\tswitch (pack(photometric, config)) {\n\tcase pack(PHOTOMETRIC_PALETTE, PLANARCONFIG_CONTIG):\n\tcase pack(PHOTOMETRIC_PALETTE, PLANARCONFIG_SEPARATE):\n\t\tTIFFGetField(in, TIFFTAG_COLORMAP, &red, &green, &blue);\n\t\t/*\n\t\t * Convert 16-bit colormap to 8-bit (unless it looks\n\t\t * like an old-style 8-bit colormap).\n\t\t */\n\t\tif (checkcmap(in, 1<<bitspersample, red, green, blue) == 16) {\n\t\t\tint i;\n#define\tCVT(x)\t\t(((x) * 255L) / ((1L<<16)-1))\n\t\t\tfor (i = (1<<bitspersample)-1; i >= 0; i--) {\n\t\t\t\tred[i] = CVT(red[i]);\n\t\t\t\tgreen[i] = CVT(green[i]);\n\t\t\t\tblue[i] = CVT(blue[i]);\n\t\t\t}\n#undef CVT\n\t\t}\n\t\tinbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\n                if( !inbuf )\n                {\n                    fprintf(stderr, \"Out of memory\\n\");\n                    goto tiff2bw_error;\n                }\n\t\tfor (row = 0; row < h; row++) {\n\t\t\tif (TIFFReadScanline(in, inbuf, row, 0) < 0)\n\t\t\t\tbreak;\n\t\t\tcompresspalette(outbuf, inbuf, w, red, green, blue);\n\t\t\tif (TIFFWriteScanline(out, outbuf, row, 0) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase pack(PHOTOMETRIC_RGB, PLANARCONFIG_CONTIG):\n\t\tinbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\n                if( !inbuf )\n                {\n                    fprintf(stderr, \"Out of memory\\n\");\n                    goto tiff2bw_error;\n                }\n\t\tfor (row = 0; row < h; row++) {\n\t\t\tif (TIFFReadScanline(in, inbuf, row, 0) < 0)\n\t\t\t\tbreak;\n\t\t\tcompresscontig(outbuf, inbuf, w);\n\t\t\tif (TIFFWriteScanline(out, outbuf, row, 0) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase pack(PHOTOMETRIC_RGB, PLANARCONFIG_SEPARATE):\n        {\n                tmsize_t inbufsize;\n\t\trowsize = TIFFScanlineSize(in);\n                inbufsize = TIFFSafeMultiply(tmsize_t, 3, rowsize);\n\t\tinbuf = (unsigned char *)_TIFFmalloc(inbufsize);\n                if( !inbuf )\n                {\n                    fprintf(stderr, \"Out of memory\\n\");\n                    goto tiff2bw_error;\n                }\n\t\tfor (row = 0; row < h; row++) {\n\t\t\tfor (s = 0; s < 3; s++)\n\t\t\t\tif (TIFFReadScanline(in,\n\t\t\t\t    inbuf+s*rowsize, row, s) < 0)\n                                        goto tiff2bw_error;\n\t\t\tcompresssep(outbuf,\n\t\t\t    inbuf, inbuf+rowsize, inbuf+2*rowsize, w);\n\t\t\tif (TIFFWriteScanline(out, outbuf, row, 0) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n        }\n\t}\n#undef pack\n        if (inbuf)\n                _TIFFfree(inbuf);\n        if (outbuf)\n                _TIFFfree(outbuf);\n        TIFFClose(in);\n\tTIFFClose(out);\n\treturn (0);\n\n tiff2bw_error:\n        if (inbuf)\n                _TIFFfree(inbuf);\n        if (outbuf)\n                _TIFFfree(outbuf);\n        if (out)\n                TIFFClose(out);\n        if (in)\n                TIFFClose(in);\n        return (-1);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146095,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void LoadOpenCLDevices(MagickCLEnv clEnv)\n{\n  cl_context_properties\n    properties[3];\n\n  cl_device_id\n    *devices;\n\n  cl_int\n    status;\n\n  cl_platform_id\n    *platforms;\n\n  cl_uint\n    i,\n    j,\n    next,\n    number_devices,\n    number_platforms;\n\n  size_t\n    length;\n\n  number_platforms=0;\n  if (openCL_library->clGetPlatformIDs(0,NULL,&number_platforms) != CL_SUCCESS)\n    return;\n  if (number_platforms == 0)\n    return;\n  platforms=(cl_platform_id *) AcquireMagickMemory(number_platforms*\n    sizeof(cl_platform_id));\n  if (platforms == (cl_platform_id *) NULL)\n    return;\n  if (openCL_library->clGetPlatformIDs(number_platforms,platforms,NULL) != CL_SUCCESS)\n    {\n       platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n       return;\n    }\n  for (i = 0; i < number_platforms; i++)\n  {\n    number_devices=GetOpenCLDeviceCount(clEnv,platforms[i]);\n    if (number_devices == 0)\n      platforms[i]=(cl_platform_id) NULL;\n    else\n      clEnv->number_devices+=number_devices;\n  }\n  if (clEnv->number_devices == 0)\n    {\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      return;\n    }\n  clEnv->devices=(MagickCLDevice *) AcquireQuantumMemory(clEnv->number_devices,\n    sizeof(MagickCLDevice));\n  if (clEnv->devices == (MagickCLDevice *) NULL)\n    {\n      RelinquishMagickCLDevices(clEnv);\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      return;\n    }\n  (void) ResetMagickMemory(clEnv->devices,0,clEnv->number_devices*\n    sizeof(MagickCLDevice));\n  devices=(cl_device_id *) AcquireQuantumMemory(clEnv->number_devices,\n    sizeof(cl_device_id));\n  if (devices == (cl_device_id *) NULL)\n    {\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      RelinquishMagickCLDevices(clEnv);\n      return;\n    }\n  clEnv->number_contexts=(size_t) number_platforms;\n  clEnv->contexts=(cl_context *) AcquireQuantumMemory(clEnv->number_contexts,\n    sizeof(cl_context));\n  if (clEnv->contexts == (cl_context *) NULL)\n    {\n      devices=(cl_device_id *) RelinquishMagickMemory(devices);\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      RelinquishMagickCLDevices(clEnv);\n      return;\n    }\n  next=0;\n  for (i = 0; i < number_platforms; i++)\n  {\n    if (platforms[i] == (cl_platform_id) NULL)\n      continue;\n\n    status=clEnv->library->clGetDeviceIDs(platforms[i],CL_DEVICE_TYPE_CPU | \n      CL_DEVICE_TYPE_GPU,(cl_uint) clEnv->number_devices,devices,&number_devices);\n    if (status != CL_SUCCESS)\n      continue;\n\n    properties[0]=CL_CONTEXT_PLATFORM;\n    properties[1]=(cl_context_properties) platforms[i];\n    properties[2]=0;\n    clEnv->contexts[i]=openCL_library->clCreateContext(properties,number_devices,\n      devices,NULL,NULL,&status);\n    if (status != CL_SUCCESS)\n      continue;\n\n    for (j = 0; j < number_devices; j++,next++)\n    {\n      MagickCLDevice\n        device;\n\n      device=AcquireMagickCLDevice();\n      if (device == (MagickCLDevice) NULL)\n        break;\n\n      device->context=clEnv->contexts[i];\n      device->deviceID=devices[j];\n\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_NAME,0,NULL,\n        &length);\n      device->platform_name=AcquireQuantumMemory(length,\n        sizeof(*device->platform_name));\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_NAME,length,\n        device->platform_name,NULL);\n\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_VENDOR,0,NULL,\n        &length);\n      device->vendor_name=AcquireQuantumMemory(length,\n        sizeof(*device->vendor_name));\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_VENDOR,length,\n        device->vendor_name,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_NAME,0,NULL,\n        &length);\n      device->name=AcquireQuantumMemory(length,sizeof(*device->name));\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_NAME,length,\n        device->name,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DRIVER_VERSION,0,NULL,\n        &length);\n      device->version=AcquireQuantumMemory(length,sizeof(*device->version));\n      openCL_library->clGetDeviceInfo(devices[j],CL_DRIVER_VERSION,length,\n        device->version,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_MAX_CLOCK_FREQUENCY,\n        sizeof(cl_uint),&device->max_clock_frequency,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_MAX_COMPUTE_UNITS,\n        sizeof(cl_uint),&device->max_compute_units,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_TYPE,\n        sizeof(cl_device_type),&device->type,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_LOCAL_MEM_SIZE,\n        sizeof(cl_ulong),&device->local_memory_size,NULL);\n\n      clEnv->devices[next]=device;\n    }\n  }\n  if (next != clEnv->number_devices)\n    RelinquishMagickCLDevices(clEnv);\n  platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n  devices=(cl_device_id *) RelinquishMagickMemory(devices);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146100,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void LoadOpenCLDevices(MagickCLEnv clEnv)\n{\n  cl_context_properties\n    properties[3];\n\n  cl_device_id\n    *devices;\n\n  cl_int\n    status;\n\n  cl_platform_id\n    *platforms;\n\n  cl_uint\n    i,\n    j,\n    next,\n    number_devices,\n    number_platforms;\n\n  size_t\n    length;\n\n  number_platforms=0;\n  if (openCL_library->clGetPlatformIDs(0,NULL,&number_platforms) != CL_SUCCESS)\n    return;\n  if (number_platforms == 0)\n    return;\n  platforms=(cl_platform_id *) AcquireMagickMemory(number_platforms*\n    sizeof(cl_platform_id));\n  if (platforms == (cl_platform_id *) NULL)\n    return;\n  if (openCL_library->clGetPlatformIDs(number_platforms,platforms,NULL) != CL_SUCCESS)\n    {\n       platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n       return;\n    }\n  for (i = 0; i < number_platforms; i++)\n  {\n    number_devices=GetOpenCLDeviceCount(clEnv,platforms[i]);\n    if (number_devices == 0)\n      platforms[i]=(cl_platform_id) NULL;\n    else\n      clEnv->number_devices+=number_devices;\n  }\n  if (clEnv->number_devices == 0)\n    {\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      return;\n    }\n  clEnv->devices=(MagickCLDevice *) AcquireQuantumMemory(clEnv->number_devices,\n    sizeof(MagickCLDevice));\n  if (clEnv->devices == (MagickCLDevice *) NULL)\n    {\n      RelinquishMagickCLDevices(clEnv);\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      return;\n    }\n  (void) ResetMagickMemory(clEnv->devices,0,clEnv->number_devices*\n    sizeof(MagickCLDevice));\n  devices=(cl_device_id *) AcquireQuantumMemory(clEnv->number_devices,\n    sizeof(cl_device_id));\n  if (devices == (cl_device_id *) NULL)\n    {\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      RelinquishMagickCLDevices(clEnv);\n      return;\n    }\n  clEnv->number_contexts=(size_t) number_platforms;\n  clEnv->contexts=(cl_context *) AcquireQuantumMemory(clEnv->number_contexts,\n    sizeof(cl_context));\n  if (clEnv->contexts == (cl_context *) NULL)\n    {\n      devices=(cl_device_id *) RelinquishMagickMemory(devices);\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      RelinquishMagickCLDevices(clEnv);\n      return;\n    }\n  next=0;\n  for (i = 0; i < number_platforms; i++)\n  {\n    if (platforms[i] == (cl_platform_id) NULL)\n      continue;\n\n    status=clEnv->library->clGetDeviceIDs(platforms[i],CL_DEVICE_TYPE_CPU | \n      CL_DEVICE_TYPE_GPU,(cl_uint) clEnv->number_devices,devices,&number_devices);\n    if (status != CL_SUCCESS)\n      continue;\n\n    properties[0]=CL_CONTEXT_PLATFORM;\n    properties[1]=(cl_context_properties) platforms[i];\n    properties[2]=0;\n    clEnv->contexts[i]=openCL_library->clCreateContext(properties,number_devices,\n      devices,NULL,NULL,&status);\n    if (status != CL_SUCCESS)\n      continue;\n\n    for (j = 0; j < number_devices; j++,next++)\n    {\n      MagickCLDevice\n        device;\n\n      device=AcquireMagickCLDevice();\n      if (device == (MagickCLDevice) NULL)\n        break;\n\n      device->context=clEnv->contexts[i];\n      device->deviceID=devices[j];\n\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_NAME,0,NULL,\n        &length);\n      device->platform_name=AcquireCriticalMemory(length*\n        sizeof(*device->platform_name));\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_NAME,length,\n        device->platform_name,NULL);\n\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_VENDOR,0,NULL,\n        &length);\n      device->vendor_name=AcquireQuantumMemory(length,\n        sizeof(*device->vendor_name));\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_VENDOR,length,\n        device->vendor_name,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_NAME,0,NULL,\n        &length);\n      device->name=AcquireQuantumMemory(length,sizeof(*device->name));\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_NAME,length,\n        device->name,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DRIVER_VERSION,0,NULL,\n        &length);\n      device->version=AcquireQuantumMemory(length,sizeof(*device->version));\n      openCL_library->clGetDeviceInfo(devices[j],CL_DRIVER_VERSION,length,\n        device->version,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_MAX_CLOCK_FREQUENCY,\n        sizeof(cl_uint),&device->max_clock_frequency,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_MAX_COMPUTE_UNITS,\n        sizeof(cl_uint),&device->max_compute_units,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_TYPE,\n        sizeof(cl_device_type),&device->type,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_LOCAL_MEM_SIZE,\n        sizeof(cl_ulong),&device->local_memory_size,NULL);\n\n      clEnv->devices[next]=device;\n    }\n  }\n  if (next != clEnv->number_devices)\n    RelinquishMagickCLDevices(clEnv);\n  platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n  devices=(cl_device_id *) RelinquishMagickMemory(devices);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146101,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tint i;\n\tbool ret;\n\n\t*r = -1;\n\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dst, &bitmap);\n\tif (ret) {\n\t\t*r = 0;\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dst[i])\n\t\t\t\tcontinue;\n\t\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146108,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tint i;\n\tbool ret;\n\n\t*r = -1;\n\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\tif (KVM_BUG_ON(!src, kvm)) {\n\t\t\t*r = 0;\n\t\t\treturn true;\n\t\t}\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dst, &bitmap);\n\tif (ret) {\n\t\t*r = 0;\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dst[i])\n\t\t\t\tcontinue;\n\t\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146109,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "_parse_pat (GstMpegtsSection * section)\n{\n  GPtrArray *pat;\n  guint16 i = 0, nb_programs;\n  GstMpegtsPatProgram *program;\n  guint8 *data, *end;\n\n  /* Skip already parsed data */\n  data = section->data + 8;\n\n  /* stop at the CRC */\n  end = section->data + section->section_length;\n\n  /* Initialize program list */\n  nb_programs = (end - 4 - data) / 4;\n  pat =\n      g_ptr_array_new_full (nb_programs,\n      (GDestroyNotify) _mpegts_pat_program_free);\n\n  while (data < end - 4) {\n    program = g_slice_new0 (GstMpegtsPatProgram);\n    program->program_number = GST_READ_UINT16_BE (data);\n    data += 2;\n\n    program->network_or_program_map_PID = GST_READ_UINT16_BE (data) & 0x1FFF;\n    data += 2;\n\n    g_ptr_array_index (pat, i) = program;\n\n    i++;\n  }\n  pat->len = nb_programs;\n\n  if (data != end - 4) {\n    GST_ERROR (\"at the end of PAT data != end - 4\");\n    g_ptr_array_unref (pat);\n\n    return NULL;\n  }\n\n  return (gpointer) pat;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146118,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "_parse_pat (GstMpegtsSection * section)\n{\n  GPtrArray *pat;\n  guint16 i, nb_programs;\n  GstMpegtsPatProgram *program;\n  guint8 *data, *end;\n\n  /* Skip already parsed data */\n  data = section->data + 8;\n\n  /* stop at the CRC */\n  end = section->data + section->section_length;\n\n  /* Initialize program list */\n  nb_programs = (end - 4 - data) / 4;\n  pat =\n      g_ptr_array_new_full (nb_programs,\n      (GDestroyNotify) _mpegts_pat_program_free);\n\n  GST_LOG (\"nb_programs %u\", nb_programs);\n\n  for (i = 0; i < nb_programs; i++) {\n    program = g_slice_new0 (GstMpegtsPatProgram);\n    program->program_number = GST_READ_UINT16_BE (data);\n    data += 2;\n\n    program->network_or_program_map_PID = GST_READ_UINT16_BE (data) & 0x1FFF;\n    data += 2;\n\n    g_ptr_array_index (pat, i) = program;\n  }\n  pat->len = nb_programs;\n\n  if (data != end - 4) {\n    GST_ERROR (\"at the end of PAT data != end - 4\");\n    g_ptr_array_unref (pat);\n\n    return NULL;\n  }\n\n  return (gpointer) pat;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146119,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "    bool parse( char* ptr )\n    {\n        ptr = skipSpaces( ptr );\n        if ( !ptr || !*ptr )\n            return false;\n\n        FileNode root_collection(fs->getFS(), 0, 0);\n\n        if( *ptr == '{' )\n        {\n            FileNode root_node = fs->addNode(root_collection, std::string(), FileNode::MAP);\n            parseMap( ptr, root_node );\n        }\n        else if ( *ptr == '[' )\n        {\n            FileNode root_node = fs->addNode(root_collection, std::string(), FileNode::SEQ);\n            parseSeq( ptr, root_node );\n        }\n        else\n        {\n            CV_PARSE_ERROR_CPP( \"left-brace of top level is missing\" );\n        }\n\n        if( !ptr || !*ptr )\n            CV_PARSE_ERROR_CPP( \"Unexpected End-Of-File\" );\n        return true;\n    }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146130,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "    bool parse( char* ptr )\n    {\n        if (!ptr)\n            CV_PARSE_ERROR_CPP(\"Invalid input\");\n\n        ptr = skipSpaces( ptr );\n        if ( !ptr || !*ptr )\n            return false;\n\n        FileNode root_collection(fs->getFS(), 0, 0);\n\n        if( *ptr == '{' )\n        {\n            FileNode root_node = fs->addNode(root_collection, std::string(), FileNode::MAP);\n            parseMap( ptr, root_node );\n        }\n        else if ( *ptr == '[' )\n        {\n            FileNode root_node = fs->addNode(root_collection, std::string(), FileNode::SEQ);\n            parseSeq( ptr, root_node );\n        }\n        else\n        {\n            CV_PARSE_ERROR_CPP( \"left-brace of top level is missing\" );\n        }\n\n        if( !ptr || !*ptr )\n            CV_PARSE_ERROR_CPP( \"Unexpected End-Of-File\" );\n        return true;\n    }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146131,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "    bool parse(char* ptr)\n    {\n        CV_Assert( fs != 0 );\n\n        std::string key, key2, type_name;\n        int tag_type = 0;\n        bool ok = false;\n\n        // CV_XML_INSIDE_TAG is used to prohibit leading comments\n        ptr = skipSpaces( ptr, CV_XML_INSIDE_TAG );\n\n        if( memcmp( ptr, \"<?xml\", 5 ) != 0 )  // FIXIT ptr[1..] - out of bounds read without check\n            CV_PARSE_ERROR_CPP( \"Valid XML should start with \\'<?xml ...?>\\'\" );\n\n        ptr = parseTag( ptr, key, type_name, tag_type );\n        FileNode root_collection(fs->getFS(), 0, 0);\n\n        while( ptr && *ptr != '\\0' )\n        {\n            ptr = skipSpaces( ptr, 0 );\n\n            if( *ptr != '\\0' )\n            {\n                ptr = parseTag( ptr, key, type_name, tag_type );\n                if( tag_type != CV_XML_OPENING_TAG || key != \"opencv_storage\" )\n                    CV_PARSE_ERROR_CPP( \"<opencv_storage> tag is missing\" );\n                FileNode root = fs->addNode(root_collection, std::string(), FileNode::MAP, 0);\n                ptr = parseValue( ptr, root );\n                ptr = parseTag( ptr, key2, type_name, tag_type );\n                if( tag_type != CV_XML_CLOSING_TAG || key != key2 )\n                    CV_PARSE_ERROR_CPP( \"</opencv_storage> tag is missing\" );\n                ptr = skipSpaces( ptr, 0 );\n                ok = true;\n            }\n        }\n        CV_Assert( fs->eof() );\n        return ok;\n    }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146132,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "    bool parse(char* ptr)\n    {\n        CV_Assert( fs != 0 );\n\n        std::string key, key2, type_name;\n        int tag_type = 0;\n        bool ok = false;\n\n        // CV_XML_INSIDE_TAG is used to prohibit leading comments\n        ptr = skipSpaces( ptr, CV_XML_INSIDE_TAG );\n        if (!ptr)\n            CV_PARSE_ERROR_CPP(\"Invalid input\");\n\n        if( memcmp( ptr, \"<?xml\", 5 ) != 0 )  // FIXIT ptr[1..] - out of bounds read without check\n            CV_PARSE_ERROR_CPP( \"Valid XML should start with \\'<?xml ...?>\\'\" );\n\n        ptr = parseTag( ptr, key, type_name, tag_type );\n        FileNode root_collection(fs->getFS(), 0, 0);\n\n        while( ptr && *ptr != '\\0' )\n        {\n            ptr = skipSpaces( ptr, 0 );\n            if (!ptr)\n                CV_PARSE_ERROR_CPP(\"Invalid input\");\n\n            if( *ptr != '\\0' )\n            {\n                ptr = parseTag( ptr, key, type_name, tag_type );\n                if( tag_type != CV_XML_OPENING_TAG || key != \"opencv_storage\" )\n                    CV_PARSE_ERROR_CPP( \"<opencv_storage> tag is missing\" );\n                FileNode root = fs->addNode(root_collection, std::string(), FileNode::MAP, 0);\n                ptr = parseValue( ptr, root );\n                ptr = parseTag( ptr, key2, type_name, tag_type );\n                if( tag_type != CV_XML_CLOSING_TAG || key != key2 )\n                    CV_PARSE_ERROR_CPP( \"</opencv_storage> tag is missing\" );\n                ptr = skipSpaces( ptr, 0 );\n                ok = true;\n            }\n        }\n        CV_Assert( fs->eof() );\n        return ok;\n    }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146133,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "    bool parse( char* ptr )\n    {\n        bool first = true;\n        bool ok = true;\n        FileNode root_collection(fs->getFS(), 0, 0);\n\n        for(;;)\n        {\n            // 0. skip leading comments and directives  and ...\n            // 1. reach the first item\n            for(;;)\n            {\n                ptr = skipSpaces( ptr, 0, INT_MAX );\n                if( !ptr || *ptr == '\\0' )\n                {\n                    ok = !first;\n                    break;\n                }\n\n                if( *ptr == '%' )\n                {\n                    if( memcmp( ptr, \"%YAML\", 5 ) == 0 &&\n                        memcmp( ptr, \"%YAML:1.\", 8 ) != 0 &&\n                        memcmp( ptr, \"%YAML 1.\", 8 ) != 0)\n                        CV_PARSE_ERROR_CPP( \"Unsupported YAML version (it must be 1.x)\" );\n                    *ptr = '\\0';\n                }\n                else if( *ptr == '-' )\n                {\n                    if( memcmp(ptr, \"---\", 3) == 0 )\n                    {\n                        ptr += 3;\n                        break;\n                    }\n                    else if( first )\n                        break;\n                }\n                else if( cv_isalnum(*ptr) || *ptr=='_')\n                {\n                    if( !first )\n                        CV_PARSE_ERROR_CPP( \"The YAML streams must start with '---', except the first one\" );\n                    break;\n                }\n                else if( fs->eof() )\n                    break;\n                else\n                    CV_PARSE_ERROR_CPP( \"Invalid or unsupported syntax\" );\n            }\n\n            if( ptr )\n                ptr = skipSpaces( ptr, 0, INT_MAX );\n            if( !ptr || !ptr[0] )\n                break;\n            if( memcmp( ptr, \"...\", 3 ) != 0 )\n            {\n                // 2. parse the collection\n                FileNode root_node = fs->addNode(root_collection, std::string(), FileNode::NONE);\n\n                ptr = parseValue( ptr, root_node, 0, false );\n                if( !root_node.isMap() && !root_node.isSeq() )\n                    CV_PARSE_ERROR_CPP( \"Only collections as YAML streams are supported by this parser\" );\n\n                // 3. parse until the end of file or next collection\n                ptr = skipSpaces( ptr, 0, INT_MAX );\n                if( !ptr )\n                    break;\n            }\n\n            if( fs->eof() )\n                break;\n            ptr += 3;\n            first = false;\n        }\n\n        return ok;\n    }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146134,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "    bool parse( char* ptr )\n    {\n        if (!ptr)\n            CV_PARSE_ERROR_CPP(\"Invalid input\");\n\n        bool first = true;\n        bool ok = true;\n        FileNode root_collection(fs->getFS(), 0, 0);\n\n        for(;;)\n        {\n            // 0. skip leading comments and directives  and ...\n            // 1. reach the first item\n            for(;;)\n            {\n                ptr = skipSpaces( ptr, 0, INT_MAX );\n                if( !ptr || *ptr == '\\0' )\n                {\n                    ok = !first;\n                    break;\n                }\n\n                if( *ptr == '%' )\n                {\n                    if( memcmp( ptr, \"%YAML\", 5 ) == 0 &&\n                        memcmp( ptr, \"%YAML:1.\", 8 ) != 0 &&\n                        memcmp( ptr, \"%YAML 1.\", 8 ) != 0)\n                        CV_PARSE_ERROR_CPP( \"Unsupported YAML version (it must be 1.x)\" );\n                    *ptr = '\\0';\n                }\n                else if( *ptr == '-' )\n                {\n                    if( memcmp(ptr, \"---\", 3) == 0 )\n                    {\n                        ptr += 3;\n                        break;\n                    }\n                    else if( first )\n                        break;\n                }\n                else if( cv_isalnum(*ptr) || *ptr=='_')\n                {\n                    if( !first )\n                        CV_PARSE_ERROR_CPP( \"The YAML streams must start with '---', except the first one\" );\n                    break;\n                }\n                else if( fs->eof() )\n                    break;\n                else\n                    CV_PARSE_ERROR_CPP( \"Invalid or unsupported syntax\" );\n            }\n\n            if( ptr )\n                ptr = skipSpaces( ptr, 0, INT_MAX );\n            if( !ptr || !ptr[0] )\n                break;\n            if( memcmp( ptr, \"...\", 3 ) != 0 )\n            {\n                // 2. parse the collection\n                FileNode root_node = fs->addNode(root_collection, std::string(), FileNode::NONE);\n\n                ptr = parseValue( ptr, root_node, 0, false );\n                if( !root_node.isMap() && !root_node.isSeq() )\n                    CV_PARSE_ERROR_CPP( \"Only collections as YAML streams are supported by this parser\" );\n\n                // 3. parse until the end of file or next collection\n                ptr = skipSpaces( ptr, 0, INT_MAX );\n                if( !ptr )\n                    break;\n            }\n\n            if( fs->eof() )\n                break;\n            ptr += 3;\n            first = false;\n        }\n\n        return ok;\n    }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146135,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "_poppler_attachment_new (FileSpec *emb_file)\n{\n  PopplerAttachment *attachment;\n  PopplerAttachmentPrivate *priv;\n  EmbFile *embFile;\n\n  g_assert (emb_file != nullptr);\n\n  attachment = (PopplerAttachment *) g_object_new (POPPLER_TYPE_ATTACHMENT, nullptr);\n  priv = POPPLER_ATTACHMENT_GET_PRIVATE (attachment);\n\n  if (emb_file->getFileName ())\n    attachment->name = _poppler_goo_string_to_utf8 (emb_file->getFileName ());\n  if (emb_file->getDescription ())\n    attachment->description = _poppler_goo_string_to_utf8 (emb_file->getDescription ());\n\n  embFile = emb_file->getEmbeddedFile();\n  attachment->size = embFile->size ();\n\n  if (embFile->createDate ())\n    _poppler_convert_pdf_date_to_gtime (embFile->createDate (), (time_t *)&attachment->ctime);\n  if (embFile->modDate ())\n    _poppler_convert_pdf_date_to_gtime (embFile->modDate (), (time_t *)&attachment->mtime);\n\n  if (embFile->checksum () && embFile->checksum ()->getLength () > 0)\n    attachment->checksum = g_string_new_len (embFile->checksum ()->getCString (),\n                                             embFile->checksum ()->getLength ());\n  priv->obj_stream = embFile->streamObject()->copy();\n\n  return attachment;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146172,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "_poppler_attachment_new (FileSpec *emb_file)\n{\n  PopplerAttachment *attachment;\n  PopplerAttachmentPrivate *priv;\n  EmbFile *embFile;\n\n  g_assert (emb_file != nullptr);\n\n  attachment = (PopplerAttachment *) g_object_new (POPPLER_TYPE_ATTACHMENT, nullptr);\n  priv = POPPLER_ATTACHMENT_GET_PRIVATE (attachment);\n\n  if (emb_file->getFileName ())\n    attachment->name = _poppler_goo_string_to_utf8 (emb_file->getFileName ());\n  if (emb_file->getDescription ())\n    attachment->description = _poppler_goo_string_to_utf8 (emb_file->getDescription ());\n\n  embFile = emb_file->getEmbeddedFile();\n  if (embFile != NULL && embFile->streamObject()->isStream())\n    {\n      attachment->size = embFile->size ();\n\n      if (embFile->createDate ())\n        _poppler_convert_pdf_date_to_gtime (embFile->createDate (), (time_t *)&attachment->ctime);\n      if (embFile->modDate ())\n        _poppler_convert_pdf_date_to_gtime (embFile->modDate (), (time_t *)&attachment->mtime);\n\n      if (embFile->checksum () && embFile->checksum ()->getLength () > 0)\n        attachment->checksum = g_string_new_len (embFile->checksum ()->getCString (),\n                                                 embFile->checksum ()->getLength ());\n      priv->obj_stream = embFile->streamObject()->copy();\n    }\n  else\n    {\n      g_warning (\"Missing stream object for embedded file\");\n      g_clear_object (&attachment);\n    }\n\n  return attachment;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146173,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "asn1_read_value_type (asn1_node root, const char *name, void *ivalue,\n\t\t      int *len, unsigned int *etype)\n{\n  asn1_node node, p, p2;\n  int len2, len3, result;\n  int value_size = *len;\n  unsigned char *value = ivalue;\n  unsigned type;\n\n  node = asn1_find_node (root, name);\n  if (node == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  type = type_field (node->type);\n\n  if ((type != ASN1_ETYPE_NULL) &&\n      (type != ASN1_ETYPE_CHOICE) &&\n      !(node->type & CONST_DEFAULT) && !(node->type & CONST_ASSIGN) &&\n      (node->value == NULL))\n    return ASN1_VALUE_NOT_FOUND;\n\n  if (etype)\n    *etype = type;\n  switch (type)\n    {\n    case ASN1_ETYPE_NULL:\n      PUT_STR_VALUE (value, value_size, \"NULL\");\n      break;\n    case ASN1_ETYPE_BOOLEAN:\n      if ((node->type & CONST_DEFAULT) && (node->value == NULL))\n\t{\n\t  p = node->down;\n\t  while (type_field (p->type) != ASN1_ETYPE_DEFAULT)\n\t    p = p->right;\n\t  if (p->type & CONST_TRUE)\n\t    {\n\t      PUT_STR_VALUE (value, value_size, \"TRUE\");\n\t    }\n\t  else\n\t    {\n\t      PUT_STR_VALUE (value, value_size, \"FALSE\");\n\t    }\n\t}\n      else if (node->value[0] == 'T')\n\t{\n\t  PUT_STR_VALUE (value, value_size, \"TRUE\");\n\t}\n      else\n\t{\n\t  PUT_STR_VALUE (value, value_size, \"FALSE\");\n\t}\n      break;\n    case ASN1_ETYPE_INTEGER:\n    case ASN1_ETYPE_ENUMERATED:\n      if ((node->type & CONST_DEFAULT) && (node->value == NULL))\n\t{\n\t  p = node->down;\n\t  while (type_field (p->type) != ASN1_ETYPE_DEFAULT)\n\t    p = p->right;\n\t  if ((isdigit (p->value[0])) || (p->value[0] == '-')\n\t      || (p->value[0] == '+'))\n\t    {\n\t      result = _asn1_convert_integer\n\t\t  (p->value, value, value_size, len);\n              if (result != ASN1_SUCCESS)\n\t\treturn result;\n\t    }\n\t  else\n\t    {\t\t\t/* is an identifier like v1 */\n\t      p2 = node->down;\n\t      while (p2)\n\t\t{\n\t\t  if (type_field (p2->type) == ASN1_ETYPE_CONSTANT)\n\t\t    {\n\t\t      if (!_asn1_strcmp (p2->name, p->value))\n\t\t\t{\n\t\t\t  result = _asn1_convert_integer\n\t\t\t      (p2->value, value, value_size,\n\t\t\t       len);\n\t\t\t  if (result != ASN1_SUCCESS)\n\t\t\t    return result;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  p2 = p2->right;\n\t\t}\n\t    }\n\t}\n      else\n\t{\n\t  len2 = -1;\n\t  result = asn1_get_octet_der\n\t      (node->value, node->value_len, &len2, value, value_size,\n\t       len);\n          if (result != ASN1_SUCCESS)\n\t    return result;\n\t}\n      break;\n    case ASN1_ETYPE_OBJECT_ID:\n      if (node->type & CONST_ASSIGN)\n\t{\n\t  if (value)\n\t  \tvalue[0] = 0;\n\t  p = node->down;\n\t  while (p)\n\t    {\n\t      if (type_field (p->type) == ASN1_ETYPE_CONSTANT)\n\t\t{\n\t\t  ADD_STR_VALUE (value, value_size, p->value);\n\t\t  if (p->right)\n\t\t    {\n\t\t      ADD_STR_VALUE (value, value_size, \".\");\n\t\t    }\n\t\t}\n\t      p = p->right;\n\t    }\n\t  *len = _asn1_strlen (value) + 1;\n\t}\n      else if ((node->type & CONST_DEFAULT) && (node->value == NULL))\n\t{\n\t  p = node->down;\n\t  while (type_field (p->type) != ASN1_ETYPE_DEFAULT)\n\t    p = p->right;\n\t  PUT_STR_VALUE (value, value_size, p->value);\n\t}\n      else\n\t{\n\t  PUT_STR_VALUE (value, value_size, node->value);\n\t}\n      break;\n    case ASN1_ETYPE_GENERALIZED_TIME:\n    case ASN1_ETYPE_UTC_TIME:\n      PUT_AS_STR_VALUE (value, value_size, node->value, node->value_len);\n      break;\n    case ASN1_ETYPE_OCTET_STRING:\n    case ASN1_ETYPE_GENERALSTRING:\n    case ASN1_ETYPE_NUMERIC_STRING:\n    case ASN1_ETYPE_IA5_STRING:\n    case ASN1_ETYPE_TELETEX_STRING:\n    case ASN1_ETYPE_PRINTABLE_STRING:\n    case ASN1_ETYPE_UNIVERSAL_STRING:\n    case ASN1_ETYPE_BMP_STRING:\n    case ASN1_ETYPE_UTF8_STRING:\n    case ASN1_ETYPE_VISIBLE_STRING:\n      len2 = -1;\n      result = asn1_get_octet_der\n\t  (node->value, node->value_len, &len2, value, value_size,\n\t   len);\n      if (result != ASN1_SUCCESS)\n\treturn result;\n      break;\n    case ASN1_ETYPE_BIT_STRING:\n      len2 = -1;\n      result = asn1_get_bit_der\n\t  (node->value, node->value_len, &len2, value, value_size,\n\t   len);\n      if (result != ASN1_SUCCESS)\n\treturn result;\n      break;\n    case ASN1_ETYPE_CHOICE:\n      PUT_STR_VALUE (value, value_size, node->down->name);\n      break;\n    case ASN1_ETYPE_ANY:\n      len3 = -1;\n      len2 = asn1_get_length_der (node->value, node->value_len, &len3);\n      if (len2 < 0)\n\treturn ASN1_DER_ERROR;\n      PUT_VALUE (value, value_size, node->value + len3, len2);\n      break;\n    default:\n      return ASN1_ELEMENT_NOT_FOUND;\n      break;\n    }\n  return ASN1_SUCCESS;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146188,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "asn1_read_value_type (asn1_node root, const char *name, void *ivalue,\n\t\t      int *len, unsigned int *etype)\n{\n  asn1_node node, p, p2;\n  int len2, len3, result;\n  int value_size = *len;\n  unsigned char *value = ivalue;\n  unsigned type;\n\n  node = asn1_find_node (root, name);\n  if (node == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  type = type_field (node->type);\n\n  if ((type != ASN1_ETYPE_NULL) &&\n      (type != ASN1_ETYPE_CHOICE) &&\n      !(node->type & CONST_DEFAULT) && !(node->type & CONST_ASSIGN) &&\n      (node->value == NULL))\n    return ASN1_VALUE_NOT_FOUND;\n\n  if (etype)\n    *etype = type;\n  switch (type)\n    {\n    case ASN1_ETYPE_NULL:\n      PUT_STR_VALUE (value, value_size, \"NULL\");\n      break;\n    case ASN1_ETYPE_BOOLEAN:\n      if ((node->type & CONST_DEFAULT) && (node->value == NULL))\n\t{\n\t  p = node->down;\n\t  while (type_field (p->type) != ASN1_ETYPE_DEFAULT)\n\t    p = p->right;\n\t  if (p->type & CONST_TRUE)\n\t    {\n\t      PUT_STR_VALUE (value, value_size, \"TRUE\");\n\t    }\n\t  else\n\t    {\n\t      PUT_STR_VALUE (value, value_size, \"FALSE\");\n\t    }\n\t}\n      else if (node->value[0] == 'T')\n\t{\n\t  PUT_STR_VALUE (value, value_size, \"TRUE\");\n\t}\n      else\n\t{\n\t  PUT_STR_VALUE (value, value_size, \"FALSE\");\n\t}\n      break;\n    case ASN1_ETYPE_INTEGER:\n    case ASN1_ETYPE_ENUMERATED:\n      if ((node->type & CONST_DEFAULT) && (node->value == NULL))\n\t{\n\t  p = node->down;\n\t  while (type_field (p->type) != ASN1_ETYPE_DEFAULT)\n\t    p = p->right;\n\t  if ((isdigit (p->value[0])) || (p->value[0] == '-')\n\t      || (p->value[0] == '+'))\n\t    {\n\t      result = _asn1_convert_integer\n\t\t  (p->value, value, value_size, len);\n              if (result != ASN1_SUCCESS)\n\t\treturn result;\n\t    }\n\t  else\n\t    {\t\t\t/* is an identifier like v1 */\n\t      p2 = node->down;\n\t      while (p2)\n\t\t{\n\t\t  if (type_field (p2->type) == ASN1_ETYPE_CONSTANT)\n\t\t    {\n\t\t      if (!_asn1_strcmp (p2->name, p->value))\n\t\t\t{\n\t\t\t  result = _asn1_convert_integer\n\t\t\t      (p2->value, value, value_size,\n\t\t\t       len);\n\t\t\t  if (result != ASN1_SUCCESS)\n\t\t\t    return result;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  p2 = p2->right;\n\t\t}\n\t    }\n\t}\n      else\n\t{\n\t  len2 = -1;\n\t  result = asn1_get_octet_der\n\t      (node->value, node->value_len, &len2, value, value_size,\n\t       len);\n          if (result != ASN1_SUCCESS)\n\t    return result;\n\t}\n      break;\n    case ASN1_ETYPE_OBJECT_ID:\n      if (node->type & CONST_ASSIGN)\n\t{\n\t  *len = 0;\n\t  if (value)\n\t  \tvalue[0] = 0;\n\t  p = node->down;\n\t  while (p)\n\t    {\n\t      if (type_field (p->type) == ASN1_ETYPE_CONSTANT)\n\t\t{\n\t\t  ADD_STR_VALUE (value, value_size, p->value);\n\t\t  if (p->right)\n\t\t    {\n\t\t      ADD_STR_VALUE (value, value_size, \".\");\n\t\t    }\n\t\t}\n\t      p = p->right;\n\t    }\n\t  (*len)++;\n\t}\n      else if ((node->type & CONST_DEFAULT) && (node->value == NULL))\n\t{\n\t  p = node->down;\n\t  while (type_field (p->type) != ASN1_ETYPE_DEFAULT)\n\t    p = p->right;\n\t  PUT_STR_VALUE (value, value_size, p->value);\n\t}\n      else\n\t{\n\t  PUT_STR_VALUE (value, value_size, node->value);\n\t}\n      break;\n    case ASN1_ETYPE_GENERALIZED_TIME:\n    case ASN1_ETYPE_UTC_TIME:\n      PUT_AS_STR_VALUE (value, value_size, node->value, node->value_len);\n      break;\n    case ASN1_ETYPE_OCTET_STRING:\n    case ASN1_ETYPE_GENERALSTRING:\n    case ASN1_ETYPE_NUMERIC_STRING:\n    case ASN1_ETYPE_IA5_STRING:\n    case ASN1_ETYPE_TELETEX_STRING:\n    case ASN1_ETYPE_PRINTABLE_STRING:\n    case ASN1_ETYPE_UNIVERSAL_STRING:\n    case ASN1_ETYPE_BMP_STRING:\n    case ASN1_ETYPE_UTF8_STRING:\n    case ASN1_ETYPE_VISIBLE_STRING:\n      len2 = -1;\n      result = asn1_get_octet_der\n\t  (node->value, node->value_len, &len2, value, value_size,\n\t   len);\n      if (result != ASN1_SUCCESS)\n\treturn result;\n      break;\n    case ASN1_ETYPE_BIT_STRING:\n      len2 = -1;\n      result = asn1_get_bit_der\n\t  (node->value, node->value_len, &len2, value, value_size,\n\t   len);\n      if (result != ASN1_SUCCESS)\n\treturn result;\n      break;\n    case ASN1_ETYPE_CHOICE:\n      PUT_STR_VALUE (value, value_size, node->down->name);\n      break;\n    case ASN1_ETYPE_ANY:\n      len3 = -1;\n      len2 = asn1_get_length_der (node->value, node->value_len, &len3);\n      if (len2 < 0)\n\treturn ASN1_DER_ERROR;\n      PUT_VALUE (value, value_size, node->value + len3, len2);\n      break;\n    default:\n      return ASN1_ELEMENT_NOT_FOUND;\n      break;\n    }\n  return ASN1_SUCCESS;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146189,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "struct nfc_llcp_sdp_tlv *nfc_llcp_build_sdreq_tlv(u8 tid, char *uri,\n\t\t\t\t\t\t  size_t uri_len)\n{\n\tstruct nfc_llcp_sdp_tlv *sdreq;\n\n\tpr_debug(\"uri: %s, len: %zu\\n\", uri, uri_len);\n\n\t/* sdreq->tlv_len is u8, takes uri_len, + 3 for header, + 1 for NULL */\n\tif (WARN_ON_ONCE(uri_len > U8_MAX - 4))\n\t\treturn NULL;\n\n\tsdreq = kzalloc(sizeof(struct nfc_llcp_sdp_tlv), GFP_KERNEL);\n\tif (sdreq == NULL)\n\t\treturn NULL;\n\n\tsdreq->tlv_len = uri_len + 3;\n\n\tif (uri[uri_len - 1] == 0)\n\t\tsdreq->tlv_len--;\n\n\tsdreq->tlv = kzalloc(sdreq->tlv_len + 1, GFP_KERNEL);\n\tif (sdreq->tlv == NULL) {\n\t\tkfree(sdreq);\n\t\treturn NULL;\n\t}\n\n\tsdreq->tlv[0] = LLCP_TLV_SDREQ;\n\tsdreq->tlv[1] = sdreq->tlv_len - 2;\n\tsdreq->tlv[2] = tid;\n\n\tsdreq->tid = tid;\n\tsdreq->uri = sdreq->tlv + 3;\n\tmemcpy(sdreq->uri, uri, uri_len);\n\n\tsdreq->time = jiffies;\n\n\tINIT_HLIST_NODE(&sdreq->node);\n\n\treturn sdreq;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146211,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "    ExifData::const_iterator isoSpeed(const ExifData& ed)\n    {\n        static const char* keys[] = {\n            \"Exif.Photo.ISOSpeedRatings\",\n            \"Exif.Image.ISOSpeedRatings\",\n            \"Exif.CanonSi.ISOSpeed\",\n            \"Exif.CanonCs.ISOSpeed\",\n            \"Exif.Nikon1.ISOSpeed\",\n            \"Exif.Nikon2.ISOSpeed\",\n            \"Exif.Nikon3.ISOSpeed\",\n            \"Exif.NikonIi.ISO\",\n            \"Exif.NikonIi.ISO2\",\n            \"Exif.MinoltaCsNew.ISOSetting\",\n            \"Exif.MinoltaCsOld.ISOSetting\",\n            \"Exif.MinoltaCs5D.ISOSpeed\",\n            \"Exif.MinoltaCs7D.ISOSpeed\",\n            \"Exif.Sony1Cs.ISOSetting\",\n            \"Exif.Sony2Cs.ISOSetting\",\n            \"Exif.Sony1Cs2.ISOSetting\",\n            \"Exif.Sony2Cs2.ISOSetting\",\n            \"Exif.Sony1MltCsA100.ISOSetting\",\n            \"Exif.Pentax.ISO\",\n            \"Exif.PentaxDng.ISO\",\n            \"Exif.Olympus.ISOSpeed\",\n            \"Exif.Samsung2.ISO\",\n            \"Exif.Casio.ISO\",\n            \"Exif.Casio2.ISO\",\n            \"Exif.Casio2.ISOSpeed\"\n        };\n\n        struct SensKeyNameList {\n            int count;\n            const char* keys[3];\n        };\n\n        // covers Exif.Phot.SensitivityType values 1-7. Note that SOS, REI and\n        // ISO do differ in their meaning. Values coming first in a list (and\n        // existing as a tag) are picked up first and used as the \"ISO\" value.\n        static const SensKeyNameList sensitivityKey[] = {\n            { 1, { \"Exif.Photo.StandardOutputSensitivity\" }},\n            { 1, { \"Exif.Photo.RecommendedExposureIndex\" }},\n            { 1, { \"Exif.Photo.ISOSpeed\" }},\n            { 2, { \"Exif.Photo.RecommendedExposureIndex\", \"Exif.Photo.StandardOutputSensitivity\" }},\n            { 2, { \"Exif.Photo.ISOSpeed\", \"Exif.Photo.StandardOutputSensitivity\" }},\n            { 2, { \"Exif.Photo.ISOSpeed\", \"Exif.Photo.RecommendedExposureIndex\" }},\n            { 3, { \"Exif.Photo.ISOSpeed\", \"Exif.Photo.RecommendedExposureIndex\", \"Exif.Photo.StandardOutputSensitivity\" }}\n        };\n\n        static const char* sensitivityType[] = {\n            \"Exif.Photo.SensitivityType\"\n        };\n\n        // Find the first ISO value which is not \"0\"\n        const int cnt = EXV_COUNTOF(keys);\n        ExifData::const_iterator md = ed.end();\n        long iso_val = -1;\n        for (int idx = 0; idx < cnt; ) {\n            md = findMetadatum(ed, keys + idx, cnt - idx);\n            if (md == ed.end()) break;\n            std::ostringstream os;\n            md->write(os, &ed);\n            bool ok = false;\n            iso_val = parseLong(os.str(), ok);\n            if (ok && iso_val > 0) break;\n            while (strcmp(keys[idx++], md->key().c_str()) != 0 && idx < cnt) {}\n            md = ed.end();\n        }\n\n        // there is either a possible ISO \"overflow\" or no legacy\n        // ISO tag at all. Check for SensitivityType tag and the referenced\n        // ISO value (see EXIF 2.3 Annex G)\n        long iso_tmp_val = -1;\n        while (iso_tmp_val == -1 && (iso_val == 65535 || md == ed.end())) {\n            ExifData::const_iterator md_st = findMetadatum(ed, sensitivityType, 1);\n            // no SensitivityType? exit with existing data\n            if (md_st == ed.end())\n                break;\n            // otherwise pick up actual value and grab value accordingly\n            std::ostringstream os;\n            md_st->write(os, &ed);\n            bool ok = false;\n            long st_val = parseLong(os.str(), ok);\n            // SensivityType out of range or cannot be parsed properly\n            if (!ok || st_val < 1 || st_val > 7)\n                break;\n            // pick up list of ISO tags, and check for at least one of\n            // them available.\n            const SensKeyNameList *sensKeys = &sensitivityKey[st_val - 1];\n            md_st = ed.end();\n            for (int idx = 0; idx < sensKeys->count; md_st = ed.end()) {\n                md_st = findMetadatum(ed, const_cast<const char**>(sensKeys->keys), sensKeys->count);\n                if (md_st == ed.end())\n                    break;\n                std::ostringstream os_iso;\n                md_st->write(os_iso, &ed);\n                ok = false;\n                iso_tmp_val = parseLong(os_iso.str(), ok);\n                // something wrong with the value\n                if (ok || iso_tmp_val > 0) {\n                    md = md_st;\n                    break;\n                }\n                while (strcmp(sensKeys->keys[idx++], md_st->key().c_str()) != 0 && idx < cnt) {}\n            }\n            break;\n        }\n\n        return md;\n    }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146252,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "    ExifData::const_iterator isoSpeed(const ExifData& ed)\n    {\n        static const char* keys[] = {\n            \"Exif.Photo.ISOSpeedRatings\",\n            \"Exif.Image.ISOSpeedRatings\",\n            \"Exif.CanonSi.ISOSpeed\",\n            \"Exif.CanonCs.ISOSpeed\",\n            \"Exif.Nikon1.ISOSpeed\",\n            \"Exif.Nikon2.ISOSpeed\",\n            \"Exif.Nikon3.ISOSpeed\",\n            \"Exif.NikonIi.ISO\",\n            \"Exif.NikonIi.ISO2\",\n            \"Exif.MinoltaCsNew.ISOSetting\",\n            \"Exif.MinoltaCsOld.ISOSetting\",\n            \"Exif.MinoltaCs5D.ISOSpeed\",\n            \"Exif.MinoltaCs7D.ISOSpeed\",\n            \"Exif.Sony1Cs.ISOSetting\",\n            \"Exif.Sony2Cs.ISOSetting\",\n            \"Exif.Sony1Cs2.ISOSetting\",\n            \"Exif.Sony2Cs2.ISOSetting\",\n            \"Exif.Sony1MltCsA100.ISOSetting\",\n            \"Exif.Pentax.ISO\",\n            \"Exif.PentaxDng.ISO\",\n            \"Exif.Olympus.ISOSpeed\",\n            \"Exif.Samsung2.ISO\",\n            \"Exif.Casio.ISO\",\n            \"Exif.Casio2.ISO\",\n            \"Exif.Casio2.ISOSpeed\"\n        };\n\n        struct SensKeyNameList {\n            int count;\n            const char* keys[3];\n        };\n\n        // covers Exif.Phot.SensitivityType values 1-7. Note that SOS, REI and\n        // ISO do differ in their meaning. Values coming first in a list (and\n        // existing as a tag) are picked up first and used as the \"ISO\" value.\n        static const SensKeyNameList sensitivityKey[] = {\n            { 1, { \"Exif.Photo.StandardOutputSensitivity\" }},\n            { 1, { \"Exif.Photo.RecommendedExposureIndex\" }},\n            { 1, { \"Exif.Photo.ISOSpeed\" }},\n            { 2, { \"Exif.Photo.RecommendedExposureIndex\", \"Exif.Photo.StandardOutputSensitivity\" }},\n            { 2, { \"Exif.Photo.ISOSpeed\", \"Exif.Photo.StandardOutputSensitivity\" }},\n            { 2, { \"Exif.Photo.ISOSpeed\", \"Exif.Photo.RecommendedExposureIndex\" }},\n            { 3, { \"Exif.Photo.ISOSpeed\", \"Exif.Photo.RecommendedExposureIndex\", \"Exif.Photo.StandardOutputSensitivity\" }}\n        };\n\n        static const char* sensitivityType[] = {\n            \"Exif.Photo.SensitivityType\"\n        };\n\n        // Find the first ISO value which is not \"0\"\n        const int cnt = EXV_COUNTOF(keys);\n        ExifData::const_iterator md = ed.end();\n        long iso_val = -1;\n        for (int idx = 0; idx < cnt; ) {\n            md = findMetadatum(ed, keys + idx, cnt - idx);\n            if (md == ed.end()) break;\n            std::ostringstream os;\n            md->write(os, &ed);\n            bool ok = false;\n            iso_val = parseLong(os.str(), ok);\n            if (ok && iso_val > 0) break;\n            while (strcmp(keys[idx++], md->key().c_str()) != 0 && idx < cnt) {}\n            md = ed.end();\n        }\n\n        // there is either a possible ISO \"overflow\" or no legacy\n        // ISO tag at all. Check for SensitivityType tag and the referenced\n        // ISO value (see EXIF 2.3 Annex G)\n        long iso_tmp_val = -1;\n        while (iso_tmp_val == -1 && (iso_val == 65535 || md == ed.end())) {\n            ExifData::const_iterator md_st = findMetadatum(ed, sensitivityType, 1);\n            // no SensitivityType? exit with existing data\n            if (md_st == ed.end())\n                break;\n            // otherwise pick up actual value and grab value accordingly\n            std::ostringstream os;\n            md_st->write(os, &ed);\n            bool ok = false;\n            const long st_val = parseLong(os.str(), ok);\n            // SensivityType out of range or cannot be parsed properly\n            if (!ok || st_val < 1 || st_val > 7)\n                break;\n            // pick up list of ISO tags, and check for at least one of\n            // them available.\n            const SensKeyNameList *sensKeys = &sensitivityKey[st_val - 1];\n            md_st = ed.end();\n            for (int idx = 0; idx < sensKeys->count; md_st = ed.end()) {\n                md_st = findMetadatum(ed, const_cast<const char**>(sensKeys->keys), sensKeys->count);\n                if (md_st == ed.end())\n                    break;\n                std::ostringstream os_iso;\n                md_st->write(os_iso, &ed);\n                ok = false;\n                iso_tmp_val = parseLong(os_iso.str(), ok);\n                // something wrong with the value\n                if (ok || iso_tmp_val > 0) {\n                    md = md_st;\n                    break;\n                }\n                while (strcmp(sensKeys->keys[idx++], md_st->key().c_str()) != 0 && idx < sensKeys->count) {}\n            }\n            break;\n        }\n\n        return md;\n    }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146253,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "slap_modrdn2mods(\n\tOperation\t*op,\n\tSlapReply\t*rs )\n{\n\tint\t\ta_cnt, d_cnt;\n\tLDAPRDN\t\told_rdn = NULL;\n\tLDAPRDN\t\tnew_rdn = NULL;\n\n\tassert( !BER_BVISEMPTY( &op->oq_modrdn.rs_newrdn ) );\n\n\t/* if requestDN is empty, silently reset deleteOldRDN */\n\tif ( BER_BVISEMPTY( &op->o_req_dn ) ) op->orr_deleteoldrdn = 0;\n\n\tif ( ldap_bv2rdn_x( &op->oq_modrdn.rs_newrdn, &new_rdn,\n\t\t(char **)&rs->sr_text, LDAP_DN_FORMAT_LDAP, op->o_tmpmemctx ) ) {\n\t\tDebug( LDAP_DEBUG_TRACE,\n\t\t\t\"%s slap_modrdn2mods: can't figure out \"\n\t\t\t\"type(s)/value(s) of newrdn\\n\",\n\t\t\top->o_log_prefix );\n\t\trs->sr_err = LDAP_INVALID_DN_SYNTAX;\n\t\trs->sr_text = \"unknown type(s)/value(s) used in RDN\";\n\t\tgoto done;\n\t}\n\n\tif ( op->oq_modrdn.rs_deleteoldrdn ) {\n\t\tif ( ldap_bv2rdn_x( &op->o_req_dn, &old_rdn,\n\t\t\t(char **)&rs->sr_text, LDAP_DN_FORMAT_LDAP, op->o_tmpmemctx ) ) {\n\t\t\tDebug( LDAP_DEBUG_TRACE,\n\t\t\t\t\"%s slap_modrdn2mods: can't figure out \"\n\t\t\t\t\"type(s)/value(s) of oldrdn\\n\",\n\t\t\t\top->o_log_prefix );\n\t\t\trs->sr_err = LDAP_OTHER;\n\t\t\trs->sr_text = \"cannot parse RDN from old DN\";\n\t\t\tgoto done;\n\t\t}\n\t}\n\trs->sr_text = NULL;\n\n\t/* Add new attribute values to the entry */\n\tfor ( a_cnt = 0; new_rdn[a_cnt]; a_cnt++ ) {\n\t\tAttributeDescription\t*desc = NULL;\n\t\tModifications \t\t*mod_tmp;\n\n\t\trs->sr_err = slap_bv2ad( &new_rdn[a_cnt]->la_attr, &desc, &rs->sr_text );\n\n\t\tif ( rs->sr_err != LDAP_SUCCESS ) {\n\t\t\tDebug( LDAP_DEBUG_TRACE,\n\t\t\t\t\"%s slap_modrdn2mods: %s: %s (new)\\n\",\n\t\t\t\top->o_log_prefix,\n\t\t\t\trs->sr_text,\n\t\t\t\tnew_rdn[ a_cnt ]->la_attr.bv_val );\n\t\t\tgoto done;\t\t\n\t\t}\n\n\t\tif ( !desc->ad_type->sat_equality ) {\n\t\t\tDebug( LDAP_DEBUG_TRACE,\n\t\t\t\t\"%s slap_modrdn2mods: %s: %s (new)\\n\",\n\t\t\t\top->o_log_prefix,\n\t\t\t\trs->sr_text,\n\t\t\t\tnew_rdn[ a_cnt ]->la_attr.bv_val );\n\t\t\trs->sr_text = \"naming attribute has no equality matching rule\";\n\t\t\trs->sr_err = LDAP_NAMING_VIOLATION;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Apply modification */\n\t\tmod_tmp = ( Modifications * )ch_malloc( sizeof( Modifications ) );\n\t\tmod_tmp->sml_desc = desc;\n\t\tBER_BVZERO( &mod_tmp->sml_type );\n\t\tmod_tmp->sml_numvals = 1;\n\t\tmod_tmp->sml_values = ( BerVarray )ch_malloc( 2 * sizeof( struct berval ) );\n\t\tber_dupbv( &mod_tmp->sml_values[0], &new_rdn[a_cnt]->la_value );\n\t\tmod_tmp->sml_values[1].bv_val = NULL;\n\t\tif( desc->ad_type->sat_equality->smr_normalize) {\n\t\t\tmod_tmp->sml_nvalues = ( BerVarray )ch_malloc( 2 * sizeof( struct berval ) );\n\t\t\trs->sr_err = desc->ad_type->sat_equality->smr_normalize(\n\t\t\t\tSLAP_MR_EQUALITY|SLAP_MR_VALUE_OF_ASSERTION_SYNTAX,\n\t\t\t\tdesc->ad_type->sat_syntax,\n\t\t\t\tdesc->ad_type->sat_equality,\n\t\t\t\t&mod_tmp->sml_values[0],\n\t\t\t\t&mod_tmp->sml_nvalues[0], NULL );\n\t\t\tif (rs->sr_err != LDAP_SUCCESS) {\n\t\t\t\tch_free(mod_tmp->sml_nvalues);\n\t\t\t\tch_free(mod_tmp->sml_values[0].bv_val);\n\t\t\t\tch_free(mod_tmp->sml_values);\n\t\t\t\tch_free(mod_tmp);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tmod_tmp->sml_nvalues[1].bv_val = NULL;\n\t\t} else {\n\t\t\tmod_tmp->sml_nvalues = NULL;\n\t\t}\n\t\tmod_tmp->sml_op = SLAP_MOD_SOFTADD;\n\t\tmod_tmp->sml_flags = 0;\n\t\tmod_tmp->sml_next = op->orr_modlist;\n\t\top->orr_modlist = mod_tmp;\n\t}\n\n\t/* Remove old rdn value if required */\n\tif ( op->orr_deleteoldrdn ) {\n\t\tfor ( d_cnt = 0; old_rdn[d_cnt]; d_cnt++ ) {\n\t\t\tAttributeDescription\t*desc = NULL;\n\t\t\tModifications \t\t*mod_tmp;\n\n\t\t\trs->sr_err = slap_bv2ad( &old_rdn[d_cnt]->la_attr, &desc, &rs->sr_text );\n\t\t\tif ( rs->sr_err != LDAP_SUCCESS ) {\n\t\t\t\tDebug( LDAP_DEBUG_TRACE,\n\t\t\t\t\t\"%s slap_modrdn2mods: %s: %s (old)\\n\",\n\t\t\t\t\top->o_log_prefix,\n\t\t\t\t\trs->sr_text, \n\t\t\t\t\told_rdn[d_cnt]->la_attr.bv_val );\n\t\t\t\tgoto done;\t\t\n\t\t\t}\n\t\t\tif ( !desc->ad_type->sat_equality ) {\n\t\t\t\tDebug( LDAP_DEBUG_TRACE,\n\t\t\t\t\t\"%s slap_modrdn2mods: %s: %s (old)\\n\",\n\t\t\t\t\top->o_log_prefix,\n\t\t\t\t\trs->sr_text,\n\t\t\t\t\told_rdn[ d_cnt ]->la_attr.bv_val );\n\t\t\t\trs->sr_text = \"naming attribute has no equality matching rule\";\n\t\t\t\trs->sr_err = LDAP_NAMING_VIOLATION;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* Apply modification */\n\t\t\tmod_tmp = ( Modifications * )ch_malloc( sizeof( Modifications ) );\n\t\t\tmod_tmp->sml_desc = desc;\n\t\t\tBER_BVZERO( &mod_tmp->sml_type );\n\t\t\tmod_tmp->sml_numvals = 1;\n\t\t\tmod_tmp->sml_values = ( BerVarray )ch_malloc( 2 * sizeof( struct berval ) );\n\t\t\tber_dupbv( &mod_tmp->sml_values[0], &old_rdn[d_cnt]->la_value );\n\t\t\tmod_tmp->sml_values[1].bv_val = NULL;\n\t\t\tif( desc->ad_type->sat_equality->smr_normalize) {\n\t\t\t\tmod_tmp->sml_nvalues = ( BerVarray )ch_malloc( 2 * sizeof( struct berval ) );\n\t\t\t\t(void) (*desc->ad_type->sat_equality->smr_normalize)(\n\t\t\t\t\tSLAP_MR_EQUALITY|SLAP_MR_VALUE_OF_ASSERTION_SYNTAX,\n\t\t\t\t\tdesc->ad_type->sat_syntax,\n\t\t\t\t\tdesc->ad_type->sat_equality,\n\t\t\t\t\t&mod_tmp->sml_values[0],\n\t\t\t\t\t&mod_tmp->sml_nvalues[0], NULL );\n\t\t\t\tmod_tmp->sml_nvalues[1].bv_val = NULL;\n\t\t\t} else {\n\t\t\t\tmod_tmp->sml_nvalues = NULL;\n\t\t\t}\n\t\t\tmod_tmp->sml_op = LDAP_MOD_DELETE;\n\t\t\tmod_tmp->sml_flags = 0;\n\t\t\tmod_tmp->sml_next = op->orr_modlist;\n\t\t\top->orr_modlist = mod_tmp;\n\t\t}\n\t}\n\t\ndone:\n\n\t/* LDAP v2 supporting correct attribute handling. */\n\tif ( rs->sr_err != LDAP_SUCCESS && op->orr_modlist != NULL ) {\n\t\tModifications *tmp;\n\n\t\tfor ( ; op->orr_modlist != NULL; op->orr_modlist = tmp ) {\n\t\t\ttmp = op->orr_modlist->sml_next;\n\t\t\tch_free( op->orr_modlist );\n\t\t}\n\t}\n\n\tif ( new_rdn != NULL ) {\n\t\tldap_rdnfree_x( new_rdn, op->o_tmpmemctx );\n\t}\n\tif ( old_rdn != NULL ) {\n\t\tldap_rdnfree_x( old_rdn, op->o_tmpmemctx );\n\t}\n\n\treturn rs->sr_err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146256,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "slap_modrdn2mods(\n\tOperation\t*op,\n\tSlapReply\t*rs )\n{\n\tint\t\ta_cnt, d_cnt;\n\tLDAPRDN\t\told_rdn = NULL;\n\tLDAPRDN\t\tnew_rdn = NULL;\n\n\tassert( !BER_BVISEMPTY( &op->oq_modrdn.rs_newrdn ) );\n\n\t/* if requestDN is empty, silently reset deleteOldRDN */\n\tif ( BER_BVISEMPTY( &op->o_req_dn ) ) op->orr_deleteoldrdn = 0;\n\n\tif ( ldap_bv2rdn_x( &op->oq_modrdn.rs_newrdn, &new_rdn,\n\t\t(char **)&rs->sr_text, LDAP_DN_FORMAT_LDAP, op->o_tmpmemctx ) ) {\n\t\tDebug( LDAP_DEBUG_TRACE,\n\t\t\t\"%s slap_modrdn2mods: can't figure out \"\n\t\t\t\"type(s)/value(s) of newrdn\\n\",\n\t\t\top->o_log_prefix );\n\t\trs->sr_err = LDAP_INVALID_DN_SYNTAX;\n\t\trs->sr_text = \"unknown type(s)/value(s) used in RDN\";\n\t\tgoto done;\n\t}\n\n\tif ( op->oq_modrdn.rs_deleteoldrdn ) {\n\t\tif ( ldap_bv2rdn_x( &op->o_req_dn, &old_rdn,\n\t\t\t(char **)&rs->sr_text, LDAP_DN_FORMAT_LDAP, op->o_tmpmemctx ) ) {\n\t\t\tDebug( LDAP_DEBUG_TRACE,\n\t\t\t\t\"%s slap_modrdn2mods: can't figure out \"\n\t\t\t\t\"type(s)/value(s) of oldrdn\\n\",\n\t\t\t\top->o_log_prefix );\n\t\t\trs->sr_err = LDAP_OTHER;\n\t\t\trs->sr_text = \"cannot parse RDN from old DN\";\n\t\t\tgoto done;\n\t\t}\n\t}\n\trs->sr_text = NULL;\n\n\t/* Add new attribute values to the entry */\n\tfor ( a_cnt = 0; new_rdn[a_cnt]; a_cnt++ ) {\n\t\tAttributeDescription\t*desc = NULL;\n\t\tModifications \t\t*mod_tmp;\n\n\t\trs->sr_err = slap_bv2ad( &new_rdn[a_cnt]->la_attr, &desc, &rs->sr_text );\n\n\t\tif ( rs->sr_err != LDAP_SUCCESS ) {\n\t\t\tDebug( LDAP_DEBUG_TRACE,\n\t\t\t\t\"%s slap_modrdn2mods: %s: %s (new)\\n\",\n\t\t\t\top->o_log_prefix,\n\t\t\t\trs->sr_text,\n\t\t\t\tnew_rdn[ a_cnt ]->la_attr.bv_val );\n\t\t\tgoto done;\t\t\n\t\t}\n\n\t\tif ( !desc->ad_type->sat_equality ) {\n\t\t\tDebug( LDAP_DEBUG_TRACE,\n\t\t\t\t\"%s slap_modrdn2mods: %s: %s (new)\\n\",\n\t\t\t\top->o_log_prefix,\n\t\t\t\trs->sr_text,\n\t\t\t\tnew_rdn[ a_cnt ]->la_attr.bv_val );\n\t\t\trs->sr_text = \"naming attribute has no equality matching rule\";\n\t\t\trs->sr_err = LDAP_NAMING_VIOLATION;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Apply modification */\n\t\tmod_tmp = ( Modifications * )ch_malloc( sizeof( Modifications ) );\n\t\tmod_tmp->sml_desc = desc;\n\t\tBER_BVZERO( &mod_tmp->sml_type );\n\t\tmod_tmp->sml_numvals = 1;\n\t\tmod_tmp->sml_values = ( BerVarray )ch_malloc( 2 * sizeof( struct berval ) );\n\t\tber_dupbv( &mod_tmp->sml_values[0], &new_rdn[a_cnt]->la_value );\n\t\tmod_tmp->sml_values[1].bv_val = NULL;\n\t\tif( desc->ad_type->sat_equality->smr_normalize) {\n\t\t\tmod_tmp->sml_nvalues = ( BerVarray )ch_malloc( 2 * sizeof( struct berval ) );\n\t\t\trs->sr_err = desc->ad_type->sat_equality->smr_normalize(\n\t\t\t\tSLAP_MR_EQUALITY|SLAP_MR_VALUE_OF_ASSERTION_SYNTAX,\n\t\t\t\tdesc->ad_type->sat_syntax,\n\t\t\t\tdesc->ad_type->sat_equality,\n\t\t\t\t&mod_tmp->sml_values[0],\n\t\t\t\t&mod_tmp->sml_nvalues[0], NULL );\n\t\t\tif (rs->sr_err != LDAP_SUCCESS) {\n\t\t\t\tch_free(mod_tmp->sml_nvalues);\n\t\t\t\tch_free(mod_tmp->sml_values[0].bv_val);\n\t\t\t\tch_free(mod_tmp->sml_values);\n\t\t\t\tch_free(mod_tmp);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tmod_tmp->sml_nvalues[1].bv_val = NULL;\n\t\t} else {\n\t\t\tmod_tmp->sml_nvalues = NULL;\n\t\t}\n\t\tmod_tmp->sml_op = SLAP_MOD_SOFTADD;\n\t\tmod_tmp->sml_flags = 0;\n\t\tmod_tmp->sml_next = op->orr_modlist;\n\t\top->orr_modlist = mod_tmp;\n\t}\n\n\t/* Remove old rdn value if required */\n\tif ( op->orr_deleteoldrdn ) {\n\t\tfor ( d_cnt = 0; old_rdn[d_cnt]; d_cnt++ ) {\n\t\t\tAttributeDescription\t*desc = NULL;\n\t\t\tModifications \t\t*mod_tmp;\n\n\t\t\trs->sr_err = slap_bv2ad( &old_rdn[d_cnt]->la_attr, &desc, &rs->sr_text );\n\t\t\tif ( rs->sr_err != LDAP_SUCCESS ) {\n\t\t\t\tDebug( LDAP_DEBUG_TRACE,\n\t\t\t\t\t\"%s slap_modrdn2mods: %s: %s (old)\\n\",\n\t\t\t\t\top->o_log_prefix,\n\t\t\t\t\trs->sr_text, \n\t\t\t\t\told_rdn[d_cnt]->la_attr.bv_val );\n\t\t\t\tgoto done;\t\t\n\t\t\t}\n\n\t\t\t/* Apply modification */\n\t\t\tmod_tmp = ( Modifications * )ch_malloc( sizeof( Modifications ) );\n\t\t\tmod_tmp->sml_desc = desc;\n\t\t\tBER_BVZERO( &mod_tmp->sml_type );\n\t\t\tmod_tmp->sml_numvals = 1;\n\t\t\tmod_tmp->sml_values = ( BerVarray )ch_malloc( 2 * sizeof( struct berval ) );\n\t\t\tber_dupbv( &mod_tmp->sml_values[0], &old_rdn[d_cnt]->la_value );\n\t\t\tmod_tmp->sml_values[1].bv_val = NULL;\n\t\t\tif( desc->ad_type->sat_equality && desc->ad_type->sat_equality->smr_normalize) {\n\t\t\t\tmod_tmp->sml_nvalues = ( BerVarray )ch_malloc( 2 * sizeof( struct berval ) );\n\t\t\t\t(void) (*desc->ad_type->sat_equality->smr_normalize)(\n\t\t\t\t\tSLAP_MR_EQUALITY|SLAP_MR_VALUE_OF_ASSERTION_SYNTAX,\n\t\t\t\t\tdesc->ad_type->sat_syntax,\n\t\t\t\t\tdesc->ad_type->sat_equality,\n\t\t\t\t\t&mod_tmp->sml_values[0],\n\t\t\t\t\t&mod_tmp->sml_nvalues[0], NULL );\n\t\t\t\tmod_tmp->sml_nvalues[1].bv_val = NULL;\n\t\t\t} else {\n\t\t\t\tmod_tmp->sml_nvalues = NULL;\n\t\t\t}\n\t\t\tmod_tmp->sml_op = LDAP_MOD_DELETE;\n\t\t\tmod_tmp->sml_flags = 0;\n\t\t\tmod_tmp->sml_next = op->orr_modlist;\n\t\t\top->orr_modlist = mod_tmp;\n\t\t}\n\t}\n\t\ndone:\n\n\t/* LDAP v2 supporting correct attribute handling. */\n\tif ( rs->sr_err != LDAP_SUCCESS && op->orr_modlist != NULL ) {\n\t\tModifications *tmp;\n\n\t\tfor ( ; op->orr_modlist != NULL; op->orr_modlist = tmp ) {\n\t\t\ttmp = op->orr_modlist->sml_next;\n\t\t\tch_free( op->orr_modlist );\n\t\t}\n\t}\n\n\tif ( new_rdn != NULL ) {\n\t\tldap_rdnfree_x( new_rdn, op->o_tmpmemctx );\n\t}\n\tif ( old_rdn != NULL ) {\n\t\tldap_rdnfree_x( old_rdn, op->o_tmpmemctx );\n\t}\n\n\treturn rs->sr_err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146257,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int snd_usb_pipe_sanity_check(struct usb_device *dev, unsigned int pipe)\n{\n\tstatic const int pipetypes[4] = {\n\t\tPIPE_CONTROL, PIPE_ISOCHRONOUS, PIPE_BULK, PIPE_INTERRUPT\n\t};\n\tstruct usb_host_endpoint *ep;\n\n\tep = usb_pipe_endpoint(dev, pipe);\n\tif (usb_pipetype(pipe) != pipetypes[usb_endpoint_type(&ep->desc)])\n\t\treturn -EINVAL;\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146264,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int snd_usb_pipe_sanity_check(struct usb_device *dev, unsigned int pipe)\n{\n\tstatic const int pipetypes[4] = {\n\t\tPIPE_CONTROL, PIPE_ISOCHRONOUS, PIPE_BULK, PIPE_INTERRUPT\n\t};\n\tstruct usb_host_endpoint *ep;\n\n\tep = usb_pipe_endpoint(dev, pipe);\n\tif (!ep || usb_pipetype(pipe) != pipetypes[usb_endpoint_type(&ep->desc)])\n\t\treturn -EINVAL;\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146265,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int smsusb_init_device(struct usb_interface *intf, int board_id)\n{\n\tstruct smsdevice_params_t params;\n\tstruct smsusb_device_t *dev;\n\tvoid *mdev;\n\tint i, rc;\n\n\t/* create device object */\n\tdev = kzalloc(sizeof(struct smsusb_device_t), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tmemset(&params, 0, sizeof(params));\n\tusb_set_intfdata(intf, dev);\n\tdev->udev = interface_to_usbdev(intf);\n\tdev->state = SMSUSB_DISCONNECTED;\n\n\tparams.device_type = sms_get_board(board_id)->type;\n\n\tswitch (params.device_type) {\n\tcase SMS_STELLAR:\n\t\tdev->buffer_size = USB1_BUFFER_SIZE;\n\n\t\tparams.setmode_handler = smsusb1_setmode;\n\t\tparams.detectmode_handler = smsusb1_detectmode;\n\t\tbreak;\n\tcase SMS_UNKNOWN_TYPE:\n\t\tpr_err(\"Unspecified sms device type!\\n\");\n\t\t/* fall-thru */\n\tdefault:\n\t\tdev->buffer_size = USB2_BUFFER_SIZE;\n\t\tdev->response_alignment =\n\t\t    le16_to_cpu(dev->udev->ep_in[1]->desc.wMaxPacketSize) -\n\t\t    sizeof(struct sms_msg_hdr);\n\n\t\tparams.flags |= SMS_DEVICE_FAMILY2;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++) {\n\t\tif (intf->cur_altsetting->endpoint[i].desc. bEndpointAddress & USB_DIR_IN)\n\t\t\tdev->in_ep = intf->cur_altsetting->endpoint[i].desc.bEndpointAddress;\n\t\telse\n\t\t\tdev->out_ep = intf->cur_altsetting->endpoint[i].desc.bEndpointAddress;\n\t}\n\n\tpr_debug(\"in_ep = %02x, out_ep = %02x\\n\",\n\t\tdev->in_ep, dev->out_ep);\n\n\tparams.device = &dev->udev->dev;\n\tparams.usb_device = dev->udev;\n\tparams.buffer_size = dev->buffer_size;\n\tparams.num_buffers = MAX_BUFFERS;\n\tparams.sendrequest_handler = smsusb_sendrequest;\n\tparams.context = dev;\n\tusb_make_path(dev->udev, params.devpath, sizeof(params.devpath));\n\n\tmdev = siano_media_device_register(dev, board_id);\n\n\t/* register in smscore */\n\trc = smscore_register_device(&params, &dev->coredev, 0, mdev);\n\tif (rc < 0) {\n\t\tpr_err(\"smscore_register_device(...) failed, rc %d\\n\", rc);\n\t\tsmsusb_term_device(intf);\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\t\tmedia_device_unregister(mdev);\n#endif\n\t\tkfree(mdev);\n\t\treturn rc;\n\t}\n\n\tsmscore_set_board_id(dev->coredev, board_id);\n\n\tdev->coredev->is_usb_device = true;\n\n\t/* initialize urbs */\n\tfor (i = 0; i < MAX_URBS; i++) {\n\t\tdev->surbs[i].dev = dev;\n\t\tusb_init_urb(&dev->surbs[i].urb);\n\t}\n\n\tpr_debug(\"smsusb_start_streaming(...).\\n\");\n\trc = smsusb_start_streaming(dev);\n\tif (rc < 0) {\n\t\tpr_err(\"smsusb_start_streaming(...) failed\\n\");\n\t\tsmsusb_term_device(intf);\n\t\treturn rc;\n\t}\n\n\tdev->state = SMSUSB_ACTIVE;\n\n\trc = smscore_start_device(dev->coredev);\n\tif (rc < 0) {\n\t\tpr_err(\"smscore_start_device(...) failed\\n\");\n\t\tsmsusb_term_device(intf);\n\t\treturn rc;\n\t}\n\n\tpr_debug(\"device 0x%p created\\n\", dev);\n\n\treturn rc;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146266,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int smsusb_init_device(struct usb_interface *intf, int board_id)\n{\n\tstruct smsdevice_params_t params;\n\tstruct smsusb_device_t *dev;\n\tvoid *mdev;\n\tint i, rc;\n\tint in_maxp;\n\n\t/* create device object */\n\tdev = kzalloc(sizeof(struct smsusb_device_t), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tmemset(&params, 0, sizeof(params));\n\tusb_set_intfdata(intf, dev);\n\tdev->udev = interface_to_usbdev(intf);\n\tdev->state = SMSUSB_DISCONNECTED;\n\n\tfor (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++) {\n\t\tstruct usb_endpoint_descriptor *desc =\n\t\t\t\t&intf->cur_altsetting->endpoint[i].desc;\n\n\t\tif (desc->bEndpointAddress & USB_DIR_IN) {\n\t\t\tdev->in_ep = desc->bEndpointAddress;\n\t\t\tin_maxp = usb_endpoint_maxp(desc);\n\t\t} else {\n\t\t\tdev->out_ep = desc->bEndpointAddress;\n\t\t}\n\t}\n\n\tpr_debug(\"in_ep = %02x, out_ep = %02x\\n\", dev->in_ep, dev->out_ep);\n\tif (!dev->in_ep || !dev->out_ep) {\t/* Missing endpoints? */\n\t\tsmsusb_term_device(intf);\n\t\treturn -ENODEV;\n\t}\n\n\tparams.device_type = sms_get_board(board_id)->type;\n\n\tswitch (params.device_type) {\n\tcase SMS_STELLAR:\n\t\tdev->buffer_size = USB1_BUFFER_SIZE;\n\n\t\tparams.setmode_handler = smsusb1_setmode;\n\t\tparams.detectmode_handler = smsusb1_detectmode;\n\t\tbreak;\n\tcase SMS_UNKNOWN_TYPE:\n\t\tpr_err(\"Unspecified sms device type!\\n\");\n\t\t/* fall-thru */\n\tdefault:\n\t\tdev->buffer_size = USB2_BUFFER_SIZE;\n\t\tdev->response_alignment = in_maxp - sizeof(struct sms_msg_hdr);\n\n\t\tparams.flags |= SMS_DEVICE_FAMILY2;\n\t\tbreak;\n\t}\n\n\tparams.device = &dev->udev->dev;\n\tparams.usb_device = dev->udev;\n\tparams.buffer_size = dev->buffer_size;\n\tparams.num_buffers = MAX_BUFFERS;\n\tparams.sendrequest_handler = smsusb_sendrequest;\n\tparams.context = dev;\n\tusb_make_path(dev->udev, params.devpath, sizeof(params.devpath));\n\n\tmdev = siano_media_device_register(dev, board_id);\n\n\t/* register in smscore */\n\trc = smscore_register_device(&params, &dev->coredev, 0, mdev);\n\tif (rc < 0) {\n\t\tpr_err(\"smscore_register_device(...) failed, rc %d\\n\", rc);\n\t\tsmsusb_term_device(intf);\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\t\tmedia_device_unregister(mdev);\n#endif\n\t\tkfree(mdev);\n\t\treturn rc;\n\t}\n\n\tsmscore_set_board_id(dev->coredev, board_id);\n\n\tdev->coredev->is_usb_device = true;\n\n\t/* initialize urbs */\n\tfor (i = 0; i < MAX_URBS; i++) {\n\t\tdev->surbs[i].dev = dev;\n\t\tusb_init_urb(&dev->surbs[i].urb);\n\t}\n\n\tpr_debug(\"smsusb_start_streaming(...).\\n\");\n\trc = smsusb_start_streaming(dev);\n\tif (rc < 0) {\n\t\tpr_err(\"smsusb_start_streaming(...) failed\\n\");\n\t\tsmsusb_term_device(intf);\n\t\treturn rc;\n\t}\n\n\tdev->state = SMSUSB_ACTIVE;\n\n\trc = smscore_start_device(dev->coredev);\n\tif (rc < 0) {\n\t\tpr_err(\"smscore_start_device(...) failed\\n\");\n\t\tsmsusb_term_device(intf);\n\t\treturn rc;\n\t}\n\n\tpr_debug(\"device 0x%p created\\n\", dev);\n\n\treturn rc;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146267,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int __init atalk_init(void)\n{\n\tint rc;\n\n\trc = proto_register(&ddp_proto, 0);\n\tif (rc)\n\t\tgoto out;\n\n\trc = sock_register(&atalk_family_ops);\n\tif (rc)\n\t\tgoto out_proto;\n\n\tddp_dl = register_snap_client(ddp_snap_id, atalk_rcv);\n\tif (!ddp_dl)\n\t\tprintk(atalk_err_snap);\n\n\tdev_add_pack(&ltalk_packet_type);\n\tdev_add_pack(&ppptalk_packet_type);\n\n\trc = register_netdevice_notifier(&ddp_notifier);\n\tif (rc)\n\t\tgoto out_sock;\n\n\taarp_proto_init();\n\trc = atalk_proc_init();\n\tif (rc)\n\t\tgoto out_aarp;\n\n\trc = atalk_register_sysctl();\n\tif (rc)\n\t\tgoto out_proc;\nout:\n\treturn rc;\nout_proc:\n\tatalk_proc_exit();\nout_aarp:\n\taarp_cleanup_module();\n\tunregister_netdevice_notifier(&ddp_notifier);\nout_sock:\n\tdev_remove_pack(&ppptalk_packet_type);\n\tdev_remove_pack(&ltalk_packet_type);\n\tunregister_snap_client(ddp_dl);\n\tsock_unregister(PF_APPLETALK);\nout_proto:\n\tproto_unregister(&ddp_proto);\n\tgoto out;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146312,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int __init atalk_init(void)\n{\n\tint rc;\n\n\trc = proto_register(&ddp_proto, 0);\n\tif (rc)\n\t\tgoto out;\n\n\trc = sock_register(&atalk_family_ops);\n\tif (rc)\n\t\tgoto out_proto;\n\n\tddp_dl = register_snap_client(ddp_snap_id, atalk_rcv);\n\tif (!ddp_dl) {\n\t\tpr_crit(\"Unable to register DDP with SNAP.\\n\");\n\t\tgoto out_sock;\n\t}\n\n\tdev_add_pack(&ltalk_packet_type);\n\tdev_add_pack(&ppptalk_packet_type);\n\n\trc = register_netdevice_notifier(&ddp_notifier);\n\tif (rc)\n\t\tgoto out_snap;\n\n\trc = aarp_proto_init();\n\tif (rc)\n\t\tgoto out_dev;\n\n\trc = atalk_proc_init();\n\tif (rc)\n\t\tgoto out_aarp;\n\n\trc = atalk_register_sysctl();\n\tif (rc)\n\t\tgoto out_proc;\nout:\n\treturn rc;\nout_proc:\n\tatalk_proc_exit();\nout_aarp:\n\taarp_cleanup_module();\nout_dev:\n\tunregister_netdevice_notifier(&ddp_notifier);\nout_snap:\n\tdev_remove_pack(&ppptalk_packet_type);\n\tdev_remove_pack(&ltalk_packet_type);\n\tunregister_snap_client(ddp_dl);\nout_sock:\n\tsock_unregister(PF_APPLETALK);\nout_proto:\n\tproto_unregister(&ddp_proto);\n\tgoto out;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146313,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void __init aarp_proto_init(void)\n{\n\taarp_dl = register_snap_client(aarp_snap_id, aarp_rcv);\n\tif (!aarp_dl)\n\t\tprintk(KERN_CRIT \"Unable to register AARP with SNAP.\\n\");\n\ttimer_setup(&aarp_timer, aarp_expire_timeout, 0);\n\taarp_timer.expires  = jiffies + sysctl_aarp_expiry_time;\n\tadd_timer(&aarp_timer);\n\tregister_netdevice_notifier(&aarp_notifier);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146314,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int __init aarp_proto_init(void)\n{\n\tint rc;\n\n\taarp_dl = register_snap_client(aarp_snap_id, aarp_rcv);\n\tif (!aarp_dl) {\n\t\tprintk(KERN_CRIT \"Unable to register AARP with SNAP.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\ttimer_setup(&aarp_timer, aarp_expire_timeout, 0);\n\taarp_timer.expires  = jiffies + sysctl_aarp_expiry_time;\n\tadd_timer(&aarp_timer);\n\trc = register_netdevice_notifier(&aarp_notifier);\n\tif (rc) {\n\t\tdel_timer_sync(&aarp_timer);\n\t\tunregister_snap_client(aarp_dl);\n\t}\n\treturn rc;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146315,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "setup_server_realm(struct server_handle *handle, krb5_principal sprinc)\n{\n    kdc_realm_t         *newrealm;\n    kdc_realm_t **kdc_realmlist = handle->kdc_realmlist;\n    int kdc_numrealms = handle->kdc_numrealms;\n\n    if (kdc_numrealms > 1) {\n        if (!(newrealm = find_realm_data(handle, sprinc->realm.data,\n                                         (krb5_ui_4) sprinc->realm.length)))\n            return NULL;\n        else\n            return newrealm;\n    }\n    else\n        return kdc_realmlist[0];\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146344,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "setup_server_realm(struct server_handle *handle, krb5_principal sprinc)\n{\n    kdc_realm_t         *newrealm;\n    kdc_realm_t **kdc_realmlist = handle->kdc_realmlist;\n    int kdc_numrealms = handle->kdc_numrealms;\n\n    if (sprinc == NULL)\n        return NULL;\n\n    if (kdc_numrealms > 1) {\n        if (!(newrealm = find_realm_data(handle, sprinc->realm.data,\n                                         (krb5_ui_4) sprinc->realm.length)))\n            return NULL;\n        else\n            return newrealm;\n    }\n    else\n        return kdc_realmlist[0];\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146345,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "fetch_token(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r, num;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  OnigSyntaxType* syn = env->syntax;\n  UChar* prev;\n  UChar* p = *src;\n  PFETCH_READY;\n\n start:\n  if (PEND) {\n    tok->type = TK_EOT;\n    return tok->type;\n  }\n\n  tok->type  = TK_STRING;\n  tok->base  = 0;\n  tok->backp = p;\n\n  PFETCH(c);\n  if (IS_MC_ESC_CODE(c, syn)) {\n    if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n    tok->backp = p;\n    PFETCH(c);\n\n    tok->u.c = c;\n    tok->escaped = 1;\n    switch (c) {\n    case '*':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '+':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_PLUS_ONE_INF)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 1;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '?':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_QMARK_ZERO_ONE)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = 1;\n    greedy_check:\n      if (!PEND && PPEEK_IS('?') &&\n          IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_NON_GREEDY)) {\n        PFETCH(c);\n        tok->u.repeat.greedy     = 0;\n        tok->u.repeat.possessive = 0;\n      }\n      else {\n      possessive_check:\n        if (!PEND && PPEEK_IS('+') &&\n            ((IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT) &&\n              tok->type != TK_INTERVAL)  ||\n             (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL) &&\n              tok->type == TK_INTERVAL))) {\n          PFETCH(c);\n          tok->u.repeat.greedy     = 1;\n          tok->u.repeat.possessive = 1;\n        }\n        else {\n          tok->u.repeat.greedy     = 1;\n          tok->u.repeat.possessive = 0;\n        }\n      }\n      break;\n\n    case '{':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_BRACE_INTERVAL)) break;\n      r = fetch_range_quantifier(&p, end, tok, env);\n      if (r < 0) return r;  /* error */\n      if (r == 0) goto greedy_check;\n      else if (r == 2) { /* {n} */\n        if (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))\n          goto possessive_check;\n\n        goto greedy_check;\n      }\n      /* r == 1 : normal char */\n      break;\n\n    case '|':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_VBAR_ALT)) break;\n      tok->type = TK_ALT;\n      break;\n\n    case '(':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_OPEN;\n      break;\n\n    case ')':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_CLOSE;\n      break;\n\n    case 'w':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'W':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'b':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCHOR_WORD_BOUNDARY;\n      break;\n\n    case 'B':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCHOR_NO_WORD_BOUNDARY;\n      break;\n\n    case 'y':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP2_ESC_X_Y_GRAPHEME_CLUSTER)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCHOR_EXTENDED_GRAPHEME_CLUSTER_BOUNDARY;\n      break;\n\n    case 'Y':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP2_ESC_X_Y_GRAPHEME_CLUSTER)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCHOR_NO_EXTENDED_GRAPHEME_CLUSTER_BOUNDARY;\n      break;\n\n#ifdef USE_WORD_BEGIN_END\n    case '<':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCHOR_WORD_BEGIN;\n      break;\n\n    case '>':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCHOR_WORD_END;\n      break;\n#endif\n\n    case 's':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'S':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'd':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'D':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'h':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'H':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'K':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_K_KEEP)) break;\n      tok->type = TK_KEEP;\n      break;\n\n    case 'R':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_R_GENERAL_NEWLINE)) break;\n      tok->type = TK_GENERAL_NEWLINE;\n      break;\n\n    case 'N':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_N_O_SUPER_DOT)) break;\n      tok->type = TK_NO_NEWLINE;\n      break;\n\n    case 'O':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_N_O_SUPER_DOT)) break;\n      tok->type = TK_TRUE_ANYCHAR;\n      break;\n\n    case 'X':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_X_Y_GRAPHEME_CLUSTER)) break;\n      tok->type = TK_EXTENDED_GRAPHEME_CLUSTER;\n      break;\n\n    case 'A':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n    begin_buf:\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCHOR_BEGIN_BUF;\n      break;\n\n    case 'Z':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCHOR_SEMI_END_BUF;\n      break;\n\n    case 'z':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n    end_buf:\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCHOR_END_BUF;\n      break;\n\n    case 'G':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCHOR_BEGIN_POSITION;\n      break;\n\n    case '`':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;\n      goto begin_buf;\n      break;\n\n    case '\\'':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;\n      goto end_buf;\n      break;\n\n    case 'o':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_O_BRACE_OCTAL)) {\n        PINC;\n        num = scan_unsigned_octal_number(&p, end, 11, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n        if (!PEND) {\n          if (IS_CODE_DIGIT_ASCII(enc, PPEEK))\n            return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n        }\n\n        if ((p > prev + enclen(enc, prev)) && !PEND && PPEEK_IS('}')) {\n          PINC;\n          tok->type   = TK_CODE_POINT;\n          tok->u.code = (OnigCodePoint )num;\n        }\n        else {\n          /* can't read nothing or invalid format */\n          p = prev;\n        }\n      }\n      break;\n\n    case 'x':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {\n        PINC;\n        num = scan_unsigned_hexadecimal_number(&p, end, 0, 8, enc);\n        if (num < 0) {\n          if (num == ONIGERR_TOO_BIG_NUMBER)\n            return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n          else\n            return num;\n        }\n        if (!PEND) {\n          if (IS_CODE_XDIGIT_ASCII(enc, PPEEK))\n            return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n        }\n\n        if ((p > prev + enclen(enc, prev)) && !PEND && PPEEK_IS('}')) {\n          PINC;\n          tok->type   = TK_CODE_POINT;\n          tok->u.code = (OnigCodePoint )num;\n        }\n        else {\n          /* can't read nothing or invalid format */\n          p = prev;\n        }\n      }\n      else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {\n        num = scan_unsigned_hexadecimal_number(&p, end, 0, 2, enc);\n        if (num < 0) return num;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 16;\n        tok->u.c  = num;\n      }\n      break;\n\n    case 'u':\n      if (PEND) break;\n\n      prev = p;\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {\n        num = scan_unsigned_hexadecimal_number(&p, end, 4, 4, enc);\n        if (num < 0) return num;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type   = TK_CODE_POINT;\n        tok->base   = 16;\n        tok->u.code = (OnigCodePoint )num;\n      }\n      break;\n\n    case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n      PUNFETCH;\n      prev = p;\n      num = onig_scan_unsigned_number(&p, end, enc);\n      if (num < 0 || num > ONIG_MAX_BACKREF_NUM) {\n        goto skip_backref;\n      }\n\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_DECIMAL_BACKREF) && \n          (num <= env->num_mem || num <= 9)) { /* This spec. from GNU regex */\n        if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n          if (num > env->num_mem || IS_NULL(SCANENV_MEMENV(env)[num].node))\n            return ONIGERR_INVALID_BACKREF;\n        }\n\n        tok->type = TK_BACKREF;\n        tok->u.backref.num     = 1;\n        tok->u.backref.ref1    = num;\n        tok->u.backref.by_name = 0;\n#ifdef USE_BACKREF_WITH_LEVEL\n        tok->u.backref.exist_level = 0;\n#endif\n        break;\n      }\n\n    skip_backref:\n      if (c == '8' || c == '9') {\n        /* normal char */\n        p = prev; PINC;\n        break;\n      }\n\n      p = prev;\n      /* fall through */\n    case '0':\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {\n        prev = p;\n        num = scan_unsigned_octal_number(&p, end, (c == '0' ? 2:3), enc);\n        if (num < 0 || num >= 256) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 8;\n        tok->u.c  = num;\n      }\n      else if (c != '0') {\n        PINC;\n      }\n      break;\n\n    case 'k':\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_K_NAMED_BACKREF)) {\n        PFETCH(c);\n        if (c == '<' || c == '\\'') {\n          UChar* name_end;\n          int* backs;\n          int back_num;\n          enum REF_NUM num_type;\n\n          prev = p;\n\n#ifdef USE_BACKREF_WITH_LEVEL\n          name_end = NULL_UCHARP; /* no need. escape gcc warning. */\n          r = fetch_name_with_level((OnigCodePoint )c, &p, end, &name_end,\n                                 env, &back_num, &tok->u.backref.level, &num_type);\n          if (r == 1) tok->u.backref.exist_level = 1;\n          else        tok->u.backref.exist_level = 0;\n#else\n          r = fetch_name(c, &p, end, &name_end, env, &back_num, &num_type, 1);\n#endif\n          if (r < 0) return r;\n\n          if (num_type != IS_NOT_NUM) {\n            if (num_type == IS_REL_NUM) {\n              back_num = backref_rel_to_abs(back_num, env);\n            }\n            if (back_num <= 0)\n              return ONIGERR_INVALID_BACKREF;\n\n            if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n              if (back_num > env->num_mem ||\n                  IS_NULL(SCANENV_MEMENV(env)[back_num].node))\n                return ONIGERR_INVALID_BACKREF;\n            }\n            tok->type = TK_BACKREF;\n            tok->u.backref.by_name = 0;\n            tok->u.backref.num  = 1;\n            tok->u.backref.ref1 = back_num;\n          }\n          else {\n            num = onig_name_to_group_numbers(env->reg, prev, name_end, &backs);\n            if (num <= 0) {\n              onig_scan_env_set_error_string(env,\n                        ONIGERR_UNDEFINED_NAME_REFERENCE, prev, name_end);\n              return ONIGERR_UNDEFINED_NAME_REFERENCE;\n            }\n            if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n              int i;\n              for (i = 0; i < num; i++) {\n                if (backs[i] > env->num_mem ||\n                    IS_NULL(SCANENV_MEMENV(env)[backs[i]].node))\n                  return ONIGERR_INVALID_BACKREF;\n              }\n            }\n\n            tok->type = TK_BACKREF;\n            tok->u.backref.by_name = 1;\n            if (num == 1) {\n              tok->u.backref.num  = 1;\n              tok->u.backref.ref1 = backs[0];\n            }\n            else {\n              tok->u.backref.num  = num;\n              tok->u.backref.refs = backs;\n            }\n          }\n        }\n        else\n          PUNFETCH;\n      }\n      break;\n\n#ifdef USE_CALL\n    case 'g':\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_G_SUBEXP_CALL)) {\n        PFETCH(c);\n        if (c == '<' || c == '\\'') {\n          int gnum;\n          UChar* name_end;\n          enum REF_NUM num_type;\n\n          prev = p;\n          r = fetch_name((OnigCodePoint )c, &p, end, &name_end, env,\n                         &gnum, &num_type, 1);\n          if (r < 0) return r;\n\n          if (num_type != IS_NOT_NUM) {\n            if (num_type == IS_REL_NUM) {\n              gnum = backref_rel_to_abs(gnum, env);\n              if (gnum < 0)\n                return ONIGERR_UNDEFINED_GROUP_REFERENCE;\n            }\n            tok->u.call.by_number = 1;\n            tok->u.call.gnum      = gnum;\n          }\n          else {\n            tok->u.call.by_number = 0;\n            tok->u.call.gnum      = 0;\n          }\n\n          tok->type = TK_CALL;\n          tok->u.call.name     = prev;\n          tok->u.call.name_end = name_end;\n        }\n        else\n          PUNFETCH;\n      }\n      break;\n#endif\n\n    case 'Q':\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE)) {\n        tok->type = TK_QUOTE_OPEN;\n      }\n      break;\n\n    case 'p':\n    case 'P':\n      if (!PEND && PPEEK_IS('{') &&\n          IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {\n        PINC;\n        tok->type = TK_CHAR_PROPERTY;\n        tok->u.prop.not = (c == 'P' ? 1 : 0);\n\n        if (!PEND &&\n            IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {\n          PFETCH(c);\n          if (c == '^') {\n            tok->u.prop.not = (tok->u.prop.not == 0 ? 1 : 0);\n          }\n          else\n            PUNFETCH;\n        }\n      }\n      break;\n\n    default:\n      {\n        OnigCodePoint c2;\n\n        PUNFETCH;\n        num = fetch_escaped_value(&p, end, env, &c2);\n        if (num < 0) return num;\n        /* set_raw: */\n        if (tok->u.c != c2) {\n          tok->type = TK_CODE_POINT;\n          tok->u.code = c2;\n        }\n        else { /* string */\n          p = tok->backp + enclen(enc, tok->backp);\n        }\n      }\n      break;\n    }\n  }\n  else {\n    tok->u.c = c;\n    tok->escaped = 0;\n\n#ifdef USE_VARIABLE_META_CHARS\n    if ((c != ONIG_INEFFECTIVE_META_CHAR) &&\n        IS_SYNTAX_OP(syn, ONIG_SYN_OP_VARIABLE_META_CHARACTERS)) {\n      if (c == MC_ANYCHAR(syn))\n        goto any_char;\n      else if (c == MC_ANYTIME(syn))\n        goto anytime;\n      else if (c == MC_ZERO_OR_ONE_TIME(syn))\n        goto zero_or_one_time;\n      else if (c == MC_ONE_OR_MORE_TIME(syn))\n        goto one_or_more_time;\n      else if (c == MC_ANYCHAR_ANYTIME(syn)) {\n        tok->type = TK_ANYCHAR_ANYTIME;\n        goto out;\n      }\n    }\n#endif\n\n    switch (c) {\n    case '.':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_DOT_ANYCHAR)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    any_char:\n#endif\n      tok->type = TK_ANYCHAR;\n      break;\n\n    case '*':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ASTERISK_ZERO_INF)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    anytime:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '+':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_PLUS_ONE_INF)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    one_or_more_time:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 1;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '?':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_ZERO_ONE)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    zero_or_one_time:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = 1;\n      goto greedy_check;\n      break;\n\n    case '{':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACE_INTERVAL)) break;\n      r = fetch_range_quantifier(&p, end, tok, env);\n      if (r < 0) return r;  /* error */\n      if (r == 0) goto greedy_check;\n      else if (r == 2) { /* {n} */\n        if (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))\n          goto possessive_check;\n\n        goto greedy_check;\n      }\n      /* r == 1 : normal char */\n      break;\n\n    case '|':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_VBAR_ALT)) break;\n      tok->type = TK_ALT;\n      break;\n\n    case '(':\n      if (!PEND && PPEEK_IS('?') &&\n          IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_QMARK_GROUP_EFFECT)) {\n        PINC;\n        if (! PEND) {\n          c = PPEEK;\n          if (c == '#') {\n            PFETCH(c);\n            while (1) {\n              if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n              PFETCH(c);\n              if (c == MC_ESC(syn)) {\n                if (! PEND) PFETCH(c);\n              }\n              else {\n                if (c == ')') break;\n              }\n            }\n            goto start;\n          }\n          else if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_QMARK_PERL_SUBEXP_CALL)) {\n            int gnum;\n            UChar* name;\n            UChar* name_end;\n            enum REF_NUM num_type;\n\n            switch (c) {\n            case '&':\n              {\n                PINC;\n                name = p;\n                r = fetch_name((OnigCodePoint )'(', &p, end, &name_end, env, &gnum,\n                               &num_type, 0);\n                if (r < 0) return r;\n\n                tok->type = TK_CALL;\n                tok->u.call.by_number = 0;\n                tok->u.call.gnum      = 0;\n                tok->u.call.name      = name;\n                tok->u.call.name_end  = name_end;\n              }\n              break;\n\n            case 'R':\n              tok->type = TK_CALL;\n              tok->u.call.by_number = 1;\n              tok->u.call.gnum      = 0;\n              tok->u.call.name      = p;\n              PINC;\n              if (! PPEEK_IS(')')) return ONIGERR_INVALID_GROUP_NAME;\n              tok->u.call.name_end  = p;\n              break;\n\n            case '-':\n            case '+':\n              goto lparen_qmark_num;\n              break;\n            default:\n              if (! ONIGENC_IS_CODE_DIGIT(enc, c)) goto lparen_qmark_end;\n\n            lparen_qmark_num:\n              {\n                name = p;\n                r = fetch_name((OnigCodePoint )'(', &p, end, &name_end, env,\n                               &gnum, &num_type, 1);\n                if (r < 0) return r;\n\n                if (num_type == IS_NOT_NUM) {\n                  return ONIGERR_INVALID_GROUP_NAME;\n                }\n                else {\n                  if (num_type == IS_REL_NUM) {\n                    gnum = backref_rel_to_abs(gnum, env);\n                    if (gnum < 0)\n                      return ONIGERR_UNDEFINED_GROUP_REFERENCE;\n                  }\n                  tok->u.call.by_number = 1;\n                  tok->u.call.gnum      = gnum;\n                }\n\n                tok->type = TK_CALL;\n                tok->u.call.name     = name;\n                tok->u.call.name_end = name_end;\n              }\n              break;\n            }\n          }\n        }\n      lparen_qmark_end:\n        PUNFETCH;\n      }\n\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_OPEN;\n      break;\n\n    case ')':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_CLOSE;\n      break;\n\n    case '^':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = (IS_SINGLELINE(env->options)\n                        ? ANCHOR_BEGIN_BUF : ANCHOR_BEGIN_LINE);\n      break;\n\n    case '$':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = (IS_SINGLELINE(env->options)\n                        ? ANCHOR_SEMI_END_BUF : ANCHOR_END_LINE);\n      break;\n\n    case '[':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACKET_CC)) break;\n      tok->type = TK_CC_OPEN;\n      break;\n\n    case ']':\n      if (*src > env->pattern)   /* /].../ is allowed. */\n        CLOSE_BRACKET_WITHOUT_ESC_WARN(env, (UChar* )\"]\");\n      break;\n\n    case '#':\n      if (IS_EXTEND(env->options)) {\n        while (!PEND) {\n          PFETCH(c);\n          if (ONIGENC_IS_CODE_NEWLINE(enc, c))\n            break;\n        }\n        goto start;\n        break;\n      }\n      break;\n\n    case ' ': case '\\t': case '\\n': case '\\r': case '\\f':\n      if (IS_EXTEND(env->options))\n        goto start;\n      break;\n\n    default:\n      /* string */\n      break;\n    }\n  }\n\n#ifdef USE_VARIABLE_META_CHARS\n out:\n#endif\n  *src = p;\n  return tok->type;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146358,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "fetch_token(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r, num;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  OnigSyntaxType* syn = env->syntax;\n  UChar* prev;\n  UChar* p = *src;\n  PFETCH_READY;\n\n start:\n  if (PEND) {\n    tok->type = TK_EOT;\n    return tok->type;\n  }\n\n  tok->type  = TK_STRING;\n  tok->base  = 0;\n  tok->backp = p;\n\n  PFETCH(c);\n  if (IS_MC_ESC_CODE(c, syn)) {\n    if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n    tok->backp = p;\n    PFETCH(c);\n\n    tok->u.c = c;\n    tok->escaped = 1;\n    switch (c) {\n    case '*':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '+':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_PLUS_ONE_INF)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 1;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '?':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_QMARK_ZERO_ONE)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = 1;\n    greedy_check:\n      if (!PEND && PPEEK_IS('?') &&\n          IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_NON_GREEDY)) {\n        PFETCH(c);\n        tok->u.repeat.greedy     = 0;\n        tok->u.repeat.possessive = 0;\n      }\n      else {\n      possessive_check:\n        if (!PEND && PPEEK_IS('+') &&\n            ((IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT) &&\n              tok->type != TK_INTERVAL)  ||\n             (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL) &&\n              tok->type == TK_INTERVAL))) {\n          PFETCH(c);\n          tok->u.repeat.greedy     = 1;\n          tok->u.repeat.possessive = 1;\n        }\n        else {\n          tok->u.repeat.greedy     = 1;\n          tok->u.repeat.possessive = 0;\n        }\n      }\n      break;\n\n    case '{':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_BRACE_INTERVAL)) break;\n      r = fetch_range_quantifier(&p, end, tok, env);\n      if (r < 0) return r;  /* error */\n      if (r == 0) goto greedy_check;\n      else if (r == 2) { /* {n} */\n        if (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))\n          goto possessive_check;\n\n        goto greedy_check;\n      }\n      /* r == 1 : normal char */\n      break;\n\n    case '|':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_VBAR_ALT)) break;\n      tok->type = TK_ALT;\n      break;\n\n    case '(':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_OPEN;\n      break;\n\n    case ')':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_CLOSE;\n      break;\n\n    case 'w':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'W':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'b':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCHOR_WORD_BOUNDARY;\n      break;\n\n    case 'B':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCHOR_NO_WORD_BOUNDARY;\n      break;\n\n    case 'y':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP2_ESC_X_Y_GRAPHEME_CLUSTER)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCHOR_EXTENDED_GRAPHEME_CLUSTER_BOUNDARY;\n      break;\n\n    case 'Y':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP2_ESC_X_Y_GRAPHEME_CLUSTER)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCHOR_NO_EXTENDED_GRAPHEME_CLUSTER_BOUNDARY;\n      break;\n\n#ifdef USE_WORD_BEGIN_END\n    case '<':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCHOR_WORD_BEGIN;\n      break;\n\n    case '>':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCHOR_WORD_END;\n      break;\n#endif\n\n    case 's':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'S':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'd':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'D':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'h':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'H':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'K':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_K_KEEP)) break;\n      tok->type = TK_KEEP;\n      break;\n\n    case 'R':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_R_GENERAL_NEWLINE)) break;\n      tok->type = TK_GENERAL_NEWLINE;\n      break;\n\n    case 'N':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_N_O_SUPER_DOT)) break;\n      tok->type = TK_NO_NEWLINE;\n      break;\n\n    case 'O':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_N_O_SUPER_DOT)) break;\n      tok->type = TK_TRUE_ANYCHAR;\n      break;\n\n    case 'X':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_X_Y_GRAPHEME_CLUSTER)) break;\n      tok->type = TK_EXTENDED_GRAPHEME_CLUSTER;\n      break;\n\n    case 'A':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n    begin_buf:\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCHOR_BEGIN_BUF;\n      break;\n\n    case 'Z':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCHOR_SEMI_END_BUF;\n      break;\n\n    case 'z':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n    end_buf:\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCHOR_END_BUF;\n      break;\n\n    case 'G':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCHOR_BEGIN_POSITION;\n      break;\n\n    case '`':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;\n      goto begin_buf;\n      break;\n\n    case '\\'':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;\n      goto end_buf;\n      break;\n\n    case 'o':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_O_BRACE_OCTAL)) {\n        PINC;\n        num = scan_unsigned_octal_number(&p, end, 11, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n        if (!PEND) {\n          if (IS_CODE_DIGIT_ASCII(enc, PPEEK))\n            return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n        }\n\n        if ((p > prev + enclen(enc, prev)) && !PEND && PPEEK_IS('}')) {\n          PINC;\n          tok->type   = TK_CODE_POINT;\n          tok->u.code = (OnigCodePoint )num;\n        }\n        else {\n          /* can't read nothing or invalid format */\n          p = prev;\n        }\n      }\n      break;\n\n    case 'x':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {\n        PINC;\n        num = scan_unsigned_hexadecimal_number(&p, end, 0, 8, enc);\n        if (num < 0) {\n          if (num == ONIGERR_TOO_BIG_NUMBER)\n            return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n          else\n            return num;\n        }\n        if (!PEND) {\n          if (IS_CODE_XDIGIT_ASCII(enc, PPEEK))\n            return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n        }\n\n        if ((p > prev + enclen(enc, prev)) && !PEND && PPEEK_IS('}')) {\n          PINC;\n          tok->type   = TK_CODE_POINT;\n          tok->u.code = (OnigCodePoint )num;\n        }\n        else {\n          /* can't read nothing or invalid format */\n          p = prev;\n        }\n      }\n      else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {\n        num = scan_unsigned_hexadecimal_number(&p, end, 0, 2, enc);\n        if (num < 0) return num;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 16;\n        tok->u.c  = num;\n      }\n      break;\n\n    case 'u':\n      if (PEND) break;\n\n      prev = p;\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {\n        num = scan_unsigned_hexadecimal_number(&p, end, 4, 4, enc);\n        if (num < 0) return num;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type   = TK_CODE_POINT;\n        tok->base   = 16;\n        tok->u.code = (OnigCodePoint )num;\n      }\n      break;\n\n    case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n      PUNFETCH;\n      prev = p;\n      num = onig_scan_unsigned_number(&p, end, enc);\n      if (num < 0 || num > ONIG_MAX_BACKREF_NUM) {\n        goto skip_backref;\n      }\n\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_DECIMAL_BACKREF) && \n          (num <= env->num_mem || num <= 9)) { /* This spec. from GNU regex */\n        if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n          if (num > env->num_mem || IS_NULL(SCANENV_MEMENV(env)[num].node))\n            return ONIGERR_INVALID_BACKREF;\n        }\n\n        tok->type = TK_BACKREF;\n        tok->u.backref.num     = 1;\n        tok->u.backref.ref1    = num;\n        tok->u.backref.by_name = 0;\n#ifdef USE_BACKREF_WITH_LEVEL\n        tok->u.backref.exist_level = 0;\n#endif\n        break;\n      }\n\n    skip_backref:\n      if (c == '8' || c == '9') {\n        /* normal char */\n        p = prev; PINC;\n        break;\n      }\n\n      p = prev;\n      /* fall through */\n    case '0':\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {\n        prev = p;\n        num = scan_unsigned_octal_number(&p, end, (c == '0' ? 2:3), enc);\n        if (num < 0 || num >= 256) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 8;\n        tok->u.c  = num;\n      }\n      else if (c != '0') {\n        PINC;\n      }\n      break;\n\n    case 'k':\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_K_NAMED_BACKREF)) {\n        PFETCH(c);\n        if (c == '<' || c == '\\'') {\n          UChar* name_end;\n          int* backs;\n          int back_num;\n          enum REF_NUM num_type;\n\n          prev = p;\n\n#ifdef USE_BACKREF_WITH_LEVEL\n          name_end = NULL_UCHARP; /* no need. escape gcc warning. */\n          r = fetch_name_with_level((OnigCodePoint )c, &p, end, &name_end,\n                                 env, &back_num, &tok->u.backref.level, &num_type);\n          if (r == 1) tok->u.backref.exist_level = 1;\n          else        tok->u.backref.exist_level = 0;\n#else\n          r = fetch_name(c, &p, end, &name_end, env, &back_num, &num_type, 1);\n#endif\n          if (r < 0) return r;\n\n          if (num_type != IS_NOT_NUM) {\n            if (num_type == IS_REL_NUM) {\n              back_num = backref_rel_to_abs(back_num, env);\n            }\n            if (back_num <= 0)\n              return ONIGERR_INVALID_BACKREF;\n\n            if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n              if (back_num > env->num_mem ||\n                  IS_NULL(SCANENV_MEMENV(env)[back_num].node))\n                return ONIGERR_INVALID_BACKREF;\n            }\n            tok->type = TK_BACKREF;\n            tok->u.backref.by_name = 0;\n            tok->u.backref.num  = 1;\n            tok->u.backref.ref1 = back_num;\n          }\n          else {\n            num = onig_name_to_group_numbers(env->reg, prev, name_end, &backs);\n            if (num <= 0) {\n              onig_scan_env_set_error_string(env,\n                        ONIGERR_UNDEFINED_NAME_REFERENCE, prev, name_end);\n              return ONIGERR_UNDEFINED_NAME_REFERENCE;\n            }\n            if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n              int i;\n              for (i = 0; i < num; i++) {\n                if (backs[i] > env->num_mem ||\n                    IS_NULL(SCANENV_MEMENV(env)[backs[i]].node))\n                  return ONIGERR_INVALID_BACKREF;\n              }\n            }\n\n            tok->type = TK_BACKREF;\n            tok->u.backref.by_name = 1;\n            if (num == 1) {\n              tok->u.backref.num  = 1;\n              tok->u.backref.ref1 = backs[0];\n            }\n            else {\n              tok->u.backref.num  = num;\n              tok->u.backref.refs = backs;\n            }\n          }\n        }\n        else\n          PUNFETCH;\n      }\n      break;\n\n#ifdef USE_CALL\n    case 'g':\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_G_SUBEXP_CALL)) {\n        PFETCH(c);\n        if (c == '<' || c == '\\'') {\n          int gnum;\n          UChar* name_end;\n          enum REF_NUM num_type;\n\n          prev = p;\n          r = fetch_name((OnigCodePoint )c, &p, end, &name_end, env,\n                         &gnum, &num_type, 1);\n          if (r < 0) return r;\n\n          if (num_type != IS_NOT_NUM) {\n            if (num_type == IS_REL_NUM) {\n              gnum = backref_rel_to_abs(gnum, env);\n              if (gnum < 0) {\n                onig_scan_env_set_error_string(env, ONIGERR_UNDEFINED_NAME_REFERENCE,\n                                               prev, name_end);\n                return ONIGERR_UNDEFINED_GROUP_REFERENCE;\n              }\n            }\n            tok->u.call.by_number = 1;\n            tok->u.call.gnum      = gnum;\n          }\n          else {\n            tok->u.call.by_number = 0;\n            tok->u.call.gnum      = 0;\n          }\n\n          tok->type = TK_CALL;\n          tok->u.call.name     = prev;\n          tok->u.call.name_end = name_end;\n        }\n        else\n          PUNFETCH;\n      }\n      break;\n#endif\n\n    case 'Q':\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE)) {\n        tok->type = TK_QUOTE_OPEN;\n      }\n      break;\n\n    case 'p':\n    case 'P':\n      if (!PEND && PPEEK_IS('{') &&\n          IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {\n        PINC;\n        tok->type = TK_CHAR_PROPERTY;\n        tok->u.prop.not = (c == 'P' ? 1 : 0);\n\n        if (!PEND &&\n            IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {\n          PFETCH(c);\n          if (c == '^') {\n            tok->u.prop.not = (tok->u.prop.not == 0 ? 1 : 0);\n          }\n          else\n            PUNFETCH;\n        }\n      }\n      break;\n\n    default:\n      {\n        OnigCodePoint c2;\n\n        PUNFETCH;\n        num = fetch_escaped_value(&p, end, env, &c2);\n        if (num < 0) return num;\n        /* set_raw: */\n        if (tok->u.c != c2) {\n          tok->type = TK_CODE_POINT;\n          tok->u.code = c2;\n        }\n        else { /* string */\n          p = tok->backp + enclen(enc, tok->backp);\n        }\n      }\n      break;\n    }\n  }\n  else {\n    tok->u.c = c;\n    tok->escaped = 0;\n\n#ifdef USE_VARIABLE_META_CHARS\n    if ((c != ONIG_INEFFECTIVE_META_CHAR) &&\n        IS_SYNTAX_OP(syn, ONIG_SYN_OP_VARIABLE_META_CHARACTERS)) {\n      if (c == MC_ANYCHAR(syn))\n        goto any_char;\n      else if (c == MC_ANYTIME(syn))\n        goto anytime;\n      else if (c == MC_ZERO_OR_ONE_TIME(syn))\n        goto zero_or_one_time;\n      else if (c == MC_ONE_OR_MORE_TIME(syn))\n        goto one_or_more_time;\n      else if (c == MC_ANYCHAR_ANYTIME(syn)) {\n        tok->type = TK_ANYCHAR_ANYTIME;\n        goto out;\n      }\n    }\n#endif\n\n    switch (c) {\n    case '.':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_DOT_ANYCHAR)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    any_char:\n#endif\n      tok->type = TK_ANYCHAR;\n      break;\n\n    case '*':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ASTERISK_ZERO_INF)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    anytime:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '+':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_PLUS_ONE_INF)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    one_or_more_time:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 1;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '?':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_ZERO_ONE)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    zero_or_one_time:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = 1;\n      goto greedy_check;\n      break;\n\n    case '{':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACE_INTERVAL)) break;\n      r = fetch_range_quantifier(&p, end, tok, env);\n      if (r < 0) return r;  /* error */\n      if (r == 0) goto greedy_check;\n      else if (r == 2) { /* {n} */\n        if (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))\n          goto possessive_check;\n\n        goto greedy_check;\n      }\n      /* r == 1 : normal char */\n      break;\n\n    case '|':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_VBAR_ALT)) break;\n      tok->type = TK_ALT;\n      break;\n\n    case '(':\n      if (!PEND && PPEEK_IS('?') &&\n          IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_QMARK_GROUP_EFFECT)) {\n        PINC;\n        if (! PEND) {\n          c = PPEEK;\n          if (c == '#') {\n            PFETCH(c);\n            while (1) {\n              if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n              PFETCH(c);\n              if (c == MC_ESC(syn)) {\n                if (! PEND) PFETCH(c);\n              }\n              else {\n                if (c == ')') break;\n              }\n            }\n            goto start;\n          }\n          else if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_QMARK_PERL_SUBEXP_CALL)) {\n            int gnum;\n            UChar* name;\n            UChar* name_end;\n            enum REF_NUM num_type;\n\n            switch (c) {\n            case '&':\n              {\n                PINC;\n                name = p;\n                r = fetch_name((OnigCodePoint )'(', &p, end, &name_end, env, &gnum,\n                               &num_type, 0);\n                if (r < 0) return r;\n\n                tok->type = TK_CALL;\n                tok->u.call.by_number = 0;\n                tok->u.call.gnum      = 0;\n                tok->u.call.name      = name;\n                tok->u.call.name_end  = name_end;\n              }\n              break;\n\n            case 'R':\n              tok->type = TK_CALL;\n              tok->u.call.by_number = 1;\n              tok->u.call.gnum      = 0;\n              tok->u.call.name      = p;\n              PINC;\n              if (! PPEEK_IS(')')) return ONIGERR_INVALID_GROUP_NAME;\n              tok->u.call.name_end  = p;\n              break;\n\n            case '-':\n            case '+':\n              goto lparen_qmark_num;\n              break;\n            default:\n              if (! ONIGENC_IS_CODE_DIGIT(enc, c)) goto lparen_qmark_end;\n\n            lparen_qmark_num:\n              {\n                name = p;\n                r = fetch_name((OnigCodePoint )'(', &p, end, &name_end, env,\n                               &gnum, &num_type, 1);\n                if (r < 0) return r;\n\n                if (num_type == IS_NOT_NUM) {\n                  return ONIGERR_INVALID_GROUP_NAME;\n                }\n                else {\n                  if (num_type == IS_REL_NUM) {\n                    gnum = backref_rel_to_abs(gnum, env);\n                    if (gnum < 0) {\n                      onig_scan_env_set_error_string(env,\n                             ONIGERR_UNDEFINED_NAME_REFERENCE, name, name_end);\n                      return ONIGERR_UNDEFINED_GROUP_REFERENCE;\n                    }\n                  }\n                  tok->u.call.by_number = 1;\n                  tok->u.call.gnum      = gnum;\n                }\n\n                tok->type = TK_CALL;\n                tok->u.call.name     = name;\n                tok->u.call.name_end = name_end;\n              }\n              break;\n            }\n          }\n        }\n      lparen_qmark_end:\n        PUNFETCH;\n      }\n\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_OPEN;\n      break;\n\n    case ')':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_CLOSE;\n      break;\n\n    case '^':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = (IS_SINGLELINE(env->options)\n                        ? ANCHOR_BEGIN_BUF : ANCHOR_BEGIN_LINE);\n      break;\n\n    case '$':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = (IS_SINGLELINE(env->options)\n                        ? ANCHOR_SEMI_END_BUF : ANCHOR_END_LINE);\n      break;\n\n    case '[':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACKET_CC)) break;\n      tok->type = TK_CC_OPEN;\n      break;\n\n    case ']':\n      if (*src > env->pattern)   /* /].../ is allowed. */\n        CLOSE_BRACKET_WITHOUT_ESC_WARN(env, (UChar* )\"]\");\n      break;\n\n    case '#':\n      if (IS_EXTEND(env->options)) {\n        while (!PEND) {\n          PFETCH(c);\n          if (ONIGENC_IS_CODE_NEWLINE(enc, c))\n            break;\n        }\n        goto start;\n        break;\n      }\n      break;\n\n    case ' ': case '\\t': case '\\n': case '\\r': case '\\f':\n      if (IS_EXTEND(env->options))\n        goto start;\n      break;\n\n    default:\n      /* string */\n      break;\n    }\n  }\n\n#ifdef USE_VARIABLE_META_CHARS\n out:\n#endif\n  *src = p;\n  return tok->type;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146359,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "imapx_connect_to_server (CamelIMAPXServer *is,\n                         GCancellable *cancellable,\n                         GError **error)\n{\n\tCamelNetworkSettings *network_settings;\n\tCamelNetworkSecurityMethod method;\n\tCamelIMAPXStore *store;\n\tCamelSettings *settings;\n\tGIOStream *connection = NULL;\n\tGIOStream *tls_stream;\n\tGSocket *socket;\n\tguint len;\n\tguchar *token;\n\tgint tok;\n\tCamelIMAPXCommand *ic;\n\tgchar *shell_command = NULL;\n\tgboolean use_shell_command;\n\tgboolean success = TRUE;\n\tgchar *host;\n\n\tstore = camel_imapx_server_ref_store (is);\n\n\tsettings = camel_service_ref_settings (CAMEL_SERVICE (store));\n\n\tnetwork_settings = CAMEL_NETWORK_SETTINGS (settings);\n\thost = camel_network_settings_dup_host (network_settings);\n\tmethod = camel_network_settings_get_security_method (network_settings);\n\n\tuse_shell_command = camel_imapx_settings_get_use_shell_command (\n\t\tCAMEL_IMAPX_SETTINGS (settings));\n\n\tif (use_shell_command)\n\t\tshell_command = camel_imapx_settings_dup_shell_command (\n\t\t\tCAMEL_IMAPX_SETTINGS (settings));\n\n\tg_object_unref (settings);\n\n\tif (shell_command != NULL) {\n\t\tsuccess = connect_to_server_process (is, shell_command, error);\n\n\t\tg_free (shell_command);\n\n\t\tif (success)\n\t\t\tgoto connected;\n\t\telse\n\t\t\tgoto exit;\n\t}\n\n\tconnection = camel_network_service_connect_sync (\n\t\tCAMEL_NETWORK_SERVICE (store), cancellable, error);\n\n\tif (connection != NULL) {\n\t\tGInputStream *input_stream;\n\t\tGOutputStream *output_stream;\n\t\tGError *local_error = NULL;\n\n\t\t/* Disable the Nagle algorithm with TCP_NODELAY, since IMAP\n\t\t * commands should be issued immediately even we've not yet\n\t\t * received a response to a previous command. */\n\t\tsocket = g_socket_connection_get_socket (\n\t\t\tG_SOCKET_CONNECTION (connection));\n\t\tg_socket_set_option (\n\t\t\tsocket, IPPROTO_TCP, TCP_NODELAY, 1, &local_error);\n\t\tif (local_error != NULL) {\n\t\t\t/* Failure to set the socket option is non-fatal. */\n\t\t\tg_warning (\"%s: %s\", G_STRFUNC, local_error->message);\n\t\t\tg_clear_error (&local_error);\n\t\t}\n\n\t\tg_mutex_lock (&is->priv->stream_lock);\n\t\tg_warn_if_fail (is->priv->connection == NULL);\n\t\tis->priv->connection = g_object_ref (connection);\n\t\tg_mutex_unlock (&is->priv->stream_lock);\n\n\t\tinput_stream = g_io_stream_get_input_stream (connection);\n\t\toutput_stream = g_io_stream_get_output_stream (connection);\n\n\t\timapx_server_set_streams (is, input_stream, output_stream);\n\n\t\t/* Hang on to the connection reference in case we need to\n\t\t * issue STARTTLS below. */\n\t} else {\n\t\tsuccess = FALSE;\n\t\tgoto exit;\n\t}\n\nconnected:\n\twhile (1) {\n\t\tGInputStream *input_stream;\n\n\t\tinput_stream = camel_imapx_server_ref_input_stream (is);\n\n\t\ttoken = NULL;\n\t\ttok = camel_imapx_input_stream_token (\n\t\t\tCAMEL_IMAPX_INPUT_STREAM (input_stream),\n\t\t\t&token, &len, cancellable, error);\n\n\t\tif (tok < 0) {\n\t\t\tsuccess = FALSE;\n\n\t\t} else if (tok == '*') {\n\t\t\tsuccess = imapx_untagged (\n\t\t\t\tis, input_stream, cancellable, error);\n\n\t\t\tif (success) {\n\t\t\t\tg_object_unref (input_stream);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else {\n\t\t\tcamel_imapx_input_stream_ungettoken (\n\t\t\t\tCAMEL_IMAPX_INPUT_STREAM (input_stream),\n\t\t\t\ttok, token, len);\n\n\t\t\tsuccess = camel_imapx_input_stream_text (\n\t\t\t\tCAMEL_IMAPX_INPUT_STREAM (input_stream),\n\t\t\t\t&token, cancellable, error);\n\n\t\t\tg_free (token);\n\t\t}\n\n\t\tg_object_unref (input_stream);\n\n\t\tif (!success)\n\t\t\tgoto exit;\n\t}\n\n\tg_mutex_lock (&is->priv->stream_lock);\n\n\tif (!is->priv->cinfo) {\n\t\tg_mutex_unlock (&is->priv->stream_lock);\n\n\t\tic = camel_imapx_command_new (is, CAMEL_IMAPX_JOB_CAPABILITY, \"CAPABILITY\");\n\n\t\tsuccess = camel_imapx_server_process_command_sync (is, ic, _(\"Failed to get capabilities\"), cancellable, error);\n\n\t\tcamel_imapx_command_unref (ic);\n\n\t\tif (!success)\n\t\t\tgoto exit;\n\t} else {\n\t\tg_mutex_unlock (&is->priv->stream_lock);\n\t}\n\n\tif (method == CAMEL_NETWORK_SECURITY_METHOD_STARTTLS_ON_STANDARD_PORT) {\n\n\t\tg_mutex_lock (&is->priv->stream_lock);\n\n\t\tif (CAMEL_IMAPX_LACK_CAPABILITY (is->priv->cinfo, STARTTLS)) {\n\t\t\tg_mutex_unlock (&is->priv->stream_lock);\n\t\t\tg_set_error (\n\t\t\t\terror, CAMEL_ERROR,\n\t\t\t\tCAMEL_ERROR_GENERIC,\n\t\t\t\t_(\"Failed to connect to IMAP server %s in secure mode: %s\"),\n\t\t\t\thost, _(\"STARTTLS not supported\"));\n\t\t\tsuccess = FALSE;\n\t\t\tgoto exit;\n\t\t} else {\n\t\t\tg_mutex_unlock (&is->priv->stream_lock);\n\t\t}\n\n\t\tic = camel_imapx_command_new (is, CAMEL_IMAPX_JOB_STARTTLS, \"STARTTLS\");\n\n\t\tsuccess = camel_imapx_server_process_command_sync (is, ic, _(\"Failed to issue STARTTLS\"), cancellable, error);\n\n\t\tif (success) {\n\t\t\tg_mutex_lock (&is->priv->stream_lock);\n\n\t\t\t/* See if we got new capabilities\n\t\t\t * in the STARTTLS response. */\n\t\t\timapx_free_capability (is->priv->cinfo);\n\t\t\tis->priv->cinfo = NULL;\n\t\t\tif (ic->status->condition == IMAPX_CAPABILITY) {\n\t\t\t\tis->priv->cinfo = ic->status->u.cinfo;\n\t\t\t\tic->status->u.cinfo = NULL;\n\t\t\t\tc (is->priv->tagprefix, \"got capability flags %08x\\n\", is->priv->cinfo ? is->priv->cinfo->capa : 0xFFFFFFFF);\n\t\t\t\timapx_server_stash_command_arguments (is);\n\t\t\t}\n\n\t\t\tg_mutex_unlock (&is->priv->stream_lock);\n\t\t}\n\n\t\tcamel_imapx_command_unref (ic);\n\n\t\tif (!success)\n\t\t\tgoto exit;\n\n\t\ttls_stream = camel_network_service_starttls (\n\t\t\tCAMEL_NETWORK_SERVICE (store), connection, error);\n\n\t\tif (tls_stream != NULL) {\n\t\t\tGInputStream *input_stream;\n\t\t\tGOutputStream *output_stream;\n\n\t\t\tg_mutex_lock (&is->priv->stream_lock);\n\t\t\tg_object_unref (is->priv->connection);\n\t\t\tis->priv->connection = g_object_ref (tls_stream);\n\t\t\tg_mutex_unlock (&is->priv->stream_lock);\n\n\t\t\tinput_stream =\n\t\t\t\tg_io_stream_get_input_stream (tls_stream);\n\t\t\toutput_stream =\n\t\t\t\tg_io_stream_get_output_stream (tls_stream);\n\n\t\t\timapx_server_set_streams (\n\t\t\t\tis, input_stream, output_stream);\n\n\t\t\tg_object_unref (tls_stream);\n\t\t} else {\n\t\t\tg_prefix_error (\n\t\t\t\terror,\n\t\t\t\t_(\"Failed to connect to IMAP server %s in secure mode: \"),\n\t\t\t\thost);\n\t\t\tsuccess = FALSE;\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/* Get new capabilities if they weren't already given */\n\t\tg_mutex_lock (&is->priv->stream_lock);\n\t\tif (is->priv->cinfo == NULL) {\n\t\t\tg_mutex_unlock (&is->priv->stream_lock);\n\t\t\tic = camel_imapx_command_new (is, CAMEL_IMAPX_JOB_CAPABILITY, \"CAPABILITY\");\n\t\t\tsuccess = camel_imapx_server_process_command_sync (is, ic, _(\"Failed to get capabilities\"), cancellable, error);\n\t\t\tcamel_imapx_command_unref (ic);\n\n\t\t\tif (!success)\n\t\t\t\tgoto exit;\n\t\t} else {\n\t\t\tg_mutex_unlock (&is->priv->stream_lock);\n\t\t}\n\t}\n\nexit:\n\tif (!success) {\n\t\tg_mutex_lock (&is->priv->stream_lock);\n\n\t\tg_clear_object (&is->priv->input_stream);\n\t\tg_clear_object (&is->priv->output_stream);\n\t\tg_clear_object (&is->priv->connection);\n\t\tg_clear_object (&is->priv->subprocess);\n\n\t\tif (is->priv->cinfo != NULL) {\n\t\t\timapx_free_capability (is->priv->cinfo);\n\t\t\tis->priv->cinfo = NULL;\n\t\t}\n\n\t\tg_mutex_unlock (&is->priv->stream_lock);\n\t}\n\n\tg_free (host);\n\n\tg_clear_object (&connection);\n\tg_clear_object (&store);\n\n\treturn success;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146376,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "imapx_connect_to_server (CamelIMAPXServer *is,\n                         GCancellable *cancellable,\n                         GError **error)\n{\n\tCamelNetworkSettings *network_settings;\n\tCamelNetworkSecurityMethod method;\n\tCamelIMAPXStore *store;\n\tCamelSettings *settings;\n\tGIOStream *connection = NULL;\n\tGIOStream *tls_stream;\n\tGSocket *socket;\n\tguint len;\n\tguchar *token;\n\tgint tok;\n\tCamelIMAPXCommand *ic;\n\tgchar *shell_command = NULL;\n\tgboolean use_shell_command;\n\tgboolean success = TRUE;\n\tgchar *host;\n\n\tstore = camel_imapx_server_ref_store (is);\n\n\tsettings = camel_service_ref_settings (CAMEL_SERVICE (store));\n\n\tnetwork_settings = CAMEL_NETWORK_SETTINGS (settings);\n\thost = camel_network_settings_dup_host (network_settings);\n\tmethod = camel_network_settings_get_security_method (network_settings);\n\n\tuse_shell_command = camel_imapx_settings_get_use_shell_command (\n\t\tCAMEL_IMAPX_SETTINGS (settings));\n\n\tif (use_shell_command)\n\t\tshell_command = camel_imapx_settings_dup_shell_command (\n\t\t\tCAMEL_IMAPX_SETTINGS (settings));\n\n\tg_object_unref (settings);\n\n\tif (shell_command != NULL) {\n\t\tsuccess = connect_to_server_process (is, shell_command, error);\n\n\t\tg_free (shell_command);\n\n\t\tif (success)\n\t\t\tgoto connected;\n\t\telse\n\t\t\tgoto exit;\n\t}\n\n\tconnection = camel_network_service_connect_sync (\n\t\tCAMEL_NETWORK_SERVICE (store), cancellable, error);\n\n\tif (connection != NULL) {\n\t\tGInputStream *input_stream;\n\t\tGOutputStream *output_stream;\n\t\tGError *local_error = NULL;\n\n\t\t/* Disable the Nagle algorithm with TCP_NODELAY, since IMAP\n\t\t * commands should be issued immediately even we've not yet\n\t\t * received a response to a previous command. */\n\t\tsocket = g_socket_connection_get_socket (\n\t\t\tG_SOCKET_CONNECTION (connection));\n\t\tg_socket_set_option (\n\t\t\tsocket, IPPROTO_TCP, TCP_NODELAY, 1, &local_error);\n\t\tif (local_error != NULL) {\n\t\t\t/* Failure to set the socket option is non-fatal. */\n\t\t\tg_warning (\"%s: %s\", G_STRFUNC, local_error->message);\n\t\t\tg_clear_error (&local_error);\n\t\t}\n\n\t\tg_mutex_lock (&is->priv->stream_lock);\n\t\tg_warn_if_fail (is->priv->connection == NULL);\n\t\tis->priv->connection = g_object_ref (connection);\n\t\tg_mutex_unlock (&is->priv->stream_lock);\n\n\t\tinput_stream = g_io_stream_get_input_stream (connection);\n\t\toutput_stream = g_io_stream_get_output_stream (connection);\n\n\t\timapx_server_set_streams (is, input_stream, output_stream);\n\n\t\t/* Hang on to the connection reference in case we need to\n\t\t * issue STARTTLS below. */\n\t} else {\n\t\tsuccess = FALSE;\n\t\tgoto exit;\n\t}\n\nconnected:\n\twhile (1) {\n\t\tGInputStream *input_stream;\n\n\t\tinput_stream = camel_imapx_server_ref_input_stream (is);\n\n\t\ttoken = NULL;\n\t\ttok = camel_imapx_input_stream_token (\n\t\t\tCAMEL_IMAPX_INPUT_STREAM (input_stream),\n\t\t\t&token, &len, cancellable, error);\n\n\t\tif (tok < 0) {\n\t\t\tsuccess = FALSE;\n\n\t\t} else if (tok == '*') {\n\t\t\tsuccess = imapx_untagged (\n\t\t\t\tis, input_stream, cancellable, error);\n\n\t\t\tif (success) {\n\t\t\t\tg_object_unref (input_stream);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else {\n\t\t\tcamel_imapx_input_stream_ungettoken (\n\t\t\t\tCAMEL_IMAPX_INPUT_STREAM (input_stream),\n\t\t\t\ttok, token, len);\n\n\t\t\tsuccess = camel_imapx_input_stream_text (\n\t\t\t\tCAMEL_IMAPX_INPUT_STREAM (input_stream),\n\t\t\t\t&token, cancellable, error);\n\n\t\t\tg_free (token);\n\t\t}\n\n\t\tg_object_unref (input_stream);\n\n\t\tif (!success)\n\t\t\tgoto exit;\n\t}\n\n\tg_mutex_lock (&is->priv->stream_lock);\n\n\tif (!is->priv->cinfo) {\n\t\tg_mutex_unlock (&is->priv->stream_lock);\n\n\t\tic = camel_imapx_command_new (is, CAMEL_IMAPX_JOB_CAPABILITY, \"CAPABILITY\");\n\n\t\tsuccess = camel_imapx_server_process_command_sync (is, ic, _(\"Failed to get capabilities\"), cancellable, error);\n\n\t\tcamel_imapx_command_unref (ic);\n\n\t\tif (!success)\n\t\t\tgoto exit;\n\t} else {\n\t\tg_mutex_unlock (&is->priv->stream_lock);\n\t}\n\n\tif (method == CAMEL_NETWORK_SECURITY_METHOD_STARTTLS_ON_STANDARD_PORT) {\n\n\t\tg_mutex_lock (&is->priv->stream_lock);\n\n\t\tif (CAMEL_IMAPX_LACK_CAPABILITY (is->priv->cinfo, STARTTLS)) {\n\t\t\tg_mutex_unlock (&is->priv->stream_lock);\n\t\t\tg_set_error (\n\t\t\t\terror, CAMEL_ERROR,\n\t\t\t\tCAMEL_ERROR_GENERIC,\n\t\t\t\t_(\"Failed to connect to IMAP server %s in secure mode: %s\"),\n\t\t\t\thost, _(\"STARTTLS not supported\"));\n\t\t\tsuccess = FALSE;\n\t\t\tgoto exit;\n\t\t} else {\n\t\t\tg_mutex_unlock (&is->priv->stream_lock);\n\t\t}\n\n\t\tic = camel_imapx_command_new (is, CAMEL_IMAPX_JOB_STARTTLS, \"STARTTLS\");\n\n\t\tsuccess = camel_imapx_server_process_command_sync (is, ic, _(\"Failed to issue STARTTLS\"), cancellable, error);\n\n\t\tif (success) {\n\t\t\tg_mutex_lock (&is->priv->stream_lock);\n\n\t\t\t/* See if we got new capabilities\n\t\t\t * in the STARTTLS response. */\n\t\t\tif (is->priv->cinfo)\n\t\t\t\timapx_free_capability (is->priv->cinfo);\n\t\t\tis->priv->cinfo = NULL;\n\t\t\tif (ic->status->condition == IMAPX_CAPABILITY) {\n\t\t\t\tis->priv->cinfo = ic->status->u.cinfo;\n\t\t\t\tic->status->u.cinfo = NULL;\n\t\t\t\tc (is->priv->tagprefix, \"got capability flags %08x\\n\", is->priv->cinfo ? is->priv->cinfo->capa : 0xFFFFFFFF);\n\t\t\t\timapx_server_stash_command_arguments (is);\n\t\t\t}\n\n\t\t\tg_mutex_unlock (&is->priv->stream_lock);\n\t\t}\n\n\t\tcamel_imapx_command_unref (ic);\n\n\t\tif (!success)\n\t\t\tgoto exit;\n\n\t\ttls_stream = camel_network_service_starttls (\n\t\t\tCAMEL_NETWORK_SERVICE (store), connection, error);\n\n\t\tif (tls_stream != NULL) {\n\t\t\tGInputStream *input_stream;\n\t\t\tGOutputStream *output_stream;\n\n\t\t\tg_mutex_lock (&is->priv->stream_lock);\n\t\t\tg_object_unref (is->priv->connection);\n\t\t\tis->priv->connection = g_object_ref (tls_stream);\n\t\t\tg_mutex_unlock (&is->priv->stream_lock);\n\n\t\t\tinput_stream =\n\t\t\t\tg_io_stream_get_input_stream (tls_stream);\n\t\t\toutput_stream =\n\t\t\t\tg_io_stream_get_output_stream (tls_stream);\n\n\t\t\timapx_server_set_streams (\n\t\t\t\tis, input_stream, output_stream);\n\n\t\t\tg_object_unref (tls_stream);\n\t\t} else {\n\t\t\tg_prefix_error (\n\t\t\t\terror,\n\t\t\t\t_(\"Failed to connect to IMAP server %s in secure mode: \"),\n\t\t\t\thost);\n\t\t\tsuccess = FALSE;\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/* Get new capabilities if they weren't already given */\n\t\tg_mutex_lock (&is->priv->stream_lock);\n\t\tif (is->priv->cinfo == NULL) {\n\t\t\tg_mutex_unlock (&is->priv->stream_lock);\n\t\t\tic = camel_imapx_command_new (is, CAMEL_IMAPX_JOB_CAPABILITY, \"CAPABILITY\");\n\t\t\tsuccess = camel_imapx_server_process_command_sync (is, ic, _(\"Failed to get capabilities\"), cancellable, error);\n\t\t\tcamel_imapx_command_unref (ic);\n\n\t\t\tif (!success)\n\t\t\t\tgoto exit;\n\t\t} else {\n\t\t\tg_mutex_unlock (&is->priv->stream_lock);\n\t\t}\n\t}\n\nexit:\n\tif (!success) {\n\t\tg_mutex_lock (&is->priv->stream_lock);\n\n\t\tg_clear_object (&is->priv->input_stream);\n\t\tg_clear_object (&is->priv->output_stream);\n\t\tg_clear_object (&is->priv->connection);\n\t\tg_clear_object (&is->priv->subprocess);\n\n\t\tif (is->priv->cinfo != NULL) {\n\t\t\timapx_free_capability (is->priv->cinfo);\n\t\t\tis->priv->cinfo = NULL;\n\t\t}\n\n\t\tg_mutex_unlock (&is->priv->stream_lock);\n\t}\n\n\tg_free (host);\n\n\tg_clear_object (&connection);\n\tg_clear_object (&store);\n\n\treturn success;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146377,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "pdf14_pop_transparency_group(gs_gstate *pgs, pdf14_ctx *ctx,\n    const pdf14_nonseparable_blending_procs_t * pblend_procs,\n    int tos_num_color_comp, cmm_profile_t *curr_icc_profile, gx_device *dev)\n{\n    pdf14_buf *tos = ctx->stack;\n    pdf14_buf *nos = tos->saved;\n    pdf14_mask_t *mask_stack = tos->mask_stack;\n    pdf14_buf *maskbuf;\n    int x0, x1, y0, y1;\n    byte *new_data_buf = NULL;\n    int num_noncolor_planes, new_num_planes;\n    int num_cols, num_rows, nos_num_color_comp;\n    bool icc_match;\n    gsicc_rendering_param_t rendering_params;\n    gsicc_link_t *icc_link;\n    gsicc_bufferdesc_t input_buff_desc;\n    gsicc_bufferdesc_t output_buff_desc;\n    pdf14_device *pdev = (pdf14_device *)dev;\n    bool overprint = pdev->overprint;\n    gx_color_index drawn_comps = pdev->drawn_comps;\n    bool nonicc_conversion = true;\n\n    nos_num_color_comp = nos->parent_color_info_procs->num_components - nos->num_spots;\n    tos_num_color_comp = tos_num_color_comp - tos->num_spots;\n\n#ifdef DEBUG\n    pdf14_debug_mask_stack_state(ctx);\n#endif\n    if (mask_stack == NULL) {\n        maskbuf = NULL;\n    } else {\n        maskbuf = mask_stack->rc_mask->mask_buf;\n    }\n    if (nos == NULL)\n        return_error(gs_error_rangecheck);\n    /* Sanitise the dirty rectangles, in case some of the drawing routines\n     * have made them overly large. */\n    rect_intersect(tos->dirty, tos->rect);\n    rect_intersect(nos->dirty, nos->rect);\n    /* dirty = the marked bbox. rect = the entire bounds of the buffer. */\n    /* Everything marked on tos that fits onto nos needs to be merged down. */\n    y0 = max(tos->dirty.p.y, nos->rect.p.y);\n    y1 = min(tos->dirty.q.y, nos->rect.q.y);\n    x0 = max(tos->dirty.p.x, nos->rect.p.x);\n    x1 = min(tos->dirty.q.x, nos->rect.q.x);\n    if (ctx->mask_stack) {\n        /* This can occur when we have a situation where we are ending out of\n           a group that has internal to it a soft mask and another group.\n           The soft mask left over from the previous trans group pop is put\n           into ctx->masbuf, since it is still active if another trans group\n           push occurs to use it.  If one does not occur, but instead we find\n           ourselves popping from a parent group, then this softmask is no\n           longer needed.  We will rc_decrement and set it to NULL. */\n        rc_decrement(ctx->mask_stack->rc_mask, \"pdf14_pop_transparency_group\");\n        if (ctx->mask_stack->rc_mask == NULL ){\n            gs_free_object(ctx->memory, ctx->mask_stack, \"pdf14_pop_transparency_group\");\n        }\n        ctx->mask_stack = NULL;\n    }\n    ctx->mask_stack = mask_stack;  /* Restore the mask saved by pdf14_push_transparency_group. */\n    tos->mask_stack = NULL;        /* Clean the pointer sinse the mask ownership is now passed to ctx. */\n    if (tos->idle)\n        goto exit;\n    if (maskbuf != NULL && maskbuf->data == NULL && maskbuf->alpha == 255)\n        goto exit;\n\n#if RAW_DUMP\n    /* Dump the current buffer to see what we have. */\n    dump_raw_buffer(ctx->stack->rect.q.y-ctx->stack->rect.p.y,\n                ctx->stack->rowstride, ctx->stack->n_planes,\n                ctx->stack->planestride, ctx->stack->rowstride,\n                \"aaTrans_Group_Pop\",ctx->stack->data);\n#endif\n/* Note currently if a pattern space has transparency, the ICC profile is not used\n   for blending purposes.  Instead we rely upon the gray, rgb, or cmyk parent space.\n   This is partially due to the fact that pdf14_pop_transparency_group and\n   pdf14_push_transparnecy_group have no real ICC interaction and those are the\n   operations called in the tile transparency code.  Instead we may want to\n   look at pdf14_begin_transparency_group and pdf14_end_transparency group which\n   is where all the ICC information is handled.  We will return to look at that later */\n    if (nos->parent_color_info_procs->icc_profile != NULL) {\n        icc_match = (nos->parent_color_info_procs->icc_profile->hashcode !=\n                        curr_icc_profile->hashcode);\n    } else {\n        /* Let the other tests make the decision if we need to transform */\n        icc_match = false;\n    }\n    /* If the color spaces are different and we actually did do a swap of\n       the procs for color */\n    if ((nos->parent_color_info_procs->parent_color_mapping_procs != NULL &&\n        nos_num_color_comp != tos_num_color_comp) || icc_match) {\n        if (x0 < x1 && y0 < y1) {\n            /* The NOS blending color space is different than that of the\n               TOS.  It is necessary to transform the TOS buffer data to the\n               color space of the NOS prior to doing the pdf14_compose_group\n               operation.  */\n            num_noncolor_planes = tos->n_planes - tos_num_color_comp;\n            new_num_planes = num_noncolor_planes + nos_num_color_comp;\n\n            /* See if we are doing ICC based conversion */\n            if (nos->parent_color_info_procs->icc_profile != NULL &&\n                curr_icc_profile != NULL) {\n                /* Use the ICC color management for buffer color conversion */\n                /* Define the rendering intents */\n                rendering_params.black_point_comp = gsBLACKPTCOMP_ON;\n                rendering_params.graphics_type_tag = GS_IMAGE_TAG;\n                rendering_params.override_icc = false;\n                rendering_params.preserve_black = gsBKPRESNOTSPECIFIED;\n                rendering_params.rendering_intent = gsPERCEPTUAL;\n                rendering_params.cmm = gsCMM_DEFAULT;\n                /* Request the ICC link for the transform that we will need to use */\n                /* Note that if pgs is NULL we assume the same color space.  This\n                   is due to a call to pop the group from fill_mask when filling\n                   with a mask with transparency.  In that case, the parent\n                   and the child will have the same color space anyway */\n                icc_link = gsicc_get_link_profile(pgs, dev, curr_icc_profile,\n                                    nos->parent_color_info_procs->icc_profile,\n                                    &rendering_params, pgs->memory, false);\n                if (icc_link != NULL) {\n                    /* if problem with link we will do non-ICC approach */\n                    nonicc_conversion = false;\n                    /* If the link is the identity, then we don't need to do\n                       any color conversions */\n                    if ( !(icc_link->is_identity) ) {\n                        /* Before we do any allocations check if we can get away with\n                           reusing the existing buffer if it is the same size ( if it is\n                           smaller go ahead and allocate).  We could reuse it in this\n                           case too.  We need to do a bit of testing to determine what\n                           would be best.  */\n                        /* FIXME: RJW: Could we get away with just color converting\n                         * the area that's actually active (i.e. dirty, not rect)?\n                         */\n                        if(nos_num_color_comp != tos_num_color_comp) {\n                            /* Different size.  We will need to allocate */\n                            new_data_buf = gs_alloc_bytes(ctx->memory,\n                                                tos->planestride * new_num_planes,\n                                                    \"pdf14_pop_transparency_group\");\n                            if (new_data_buf == NULL)\n                                return_error(gs_error_VMerror);\n                            /* Copy over the noncolor planes. */\n                            memcpy(new_data_buf + tos->planestride * nos_num_color_comp,\n                                   tos->data + tos->planestride * tos_num_color_comp,\n                                   tos->planestride * num_noncolor_planes);\n                        } else {\n                            /* In place color conversion! */\n                            new_data_buf = tos->data;\n                        }\n                        /* Set up the buffer descriptors. Note that pdf14 always has\n                           the alpha channels at the back end (last planes).\n                           We will just handle that here and let the CMM know\n                           nothing about it */\n                        num_rows = tos->rect.q.y - tos->rect.p.y;\n                        num_cols = tos->rect.q.x - tos->rect.p.x;\n                        gsicc_init_buffer(&input_buff_desc, tos_num_color_comp, 1,\n                                          false, false, true,\n                                          tos->planestride, tos->rowstride,\n                                          num_rows, num_cols);\n                        gsicc_init_buffer(&output_buff_desc, nos_num_color_comp,\n                                          1, false, false, true, tos->planestride,\n                                          tos->rowstride, num_rows, num_cols);\n                        /* Transform the data. Since the pdf14 device should be\n                           using RGB, CMYK or Gray buffers, this transform\n                           does not need to worry about the cmap procs of\n                           the target device.  Those are handled when we do\n                           the pdf14 put image operation */\n                        (icc_link->procs.map_buffer)(dev, icc_link, &input_buff_desc,\n                                                     &output_buff_desc, tos->data,\n                                                     new_data_buf);\n                    }\n                    /* Release the link */\n                    gsicc_release_link(icc_link);\n                    /* free the old object if the color spaces were different sizes */\n                    if(!(icc_link->is_identity) &&\n                        nos_num_color_comp != tos_num_color_comp) {\n                        gs_free_object(ctx->memory, tos->data,\n                            \"pdf14_pop_transparency_group\");\n                        tos->data = new_data_buf;\n                    }\n                }\n            }\n            if (nonicc_conversion) {\n                /* Non ICC based transform */\n                new_data_buf = gs_alloc_bytes(ctx->memory,\n                                    tos->planestride * new_num_planes,\n                                    \"pdf14_pop_transparency_group\");\n                if (new_data_buf == NULL)\n                    return_error(gs_error_VMerror);\n                gs_transform_color_buffer_generic(tos->data, tos->rowstride,\n                            tos->planestride, tos_num_color_comp, tos->rect,\n                            new_data_buf, nos_num_color_comp, num_noncolor_planes);\n                /* Free the old object */\n                gs_free_object(ctx->memory, tos->data,\n                                \"pdf14_pop_transparency_group\");\n                 tos->data = new_data_buf;\n            }\n             /* Adjust the plane and channel size now */\n             tos->n_chan = nos->n_chan;\n             tos->n_planes = nos->n_planes;\n#if RAW_DUMP\n            /* Dump the current buffer to see what we have. */\n            dump_raw_buffer(ctx->stack->rect.q.y-ctx->stack->rect.p.y,\n                            ctx->stack->rowstride, ctx->stack->n_chan,\n                            ctx->stack->planestride, ctx->stack->rowstride,\n                            \"aCMTrans_Group_ColorConv\",ctx->stack->data);\n#endif\n             /* compose. never do overprint in this case */\n            pdf14_compose_group(tos, nos, maskbuf, x0, x1, y0, y1, nos->n_chan,\n                 nos->parent_color_info_procs->isadditive,\n                 nos->parent_color_info_procs->parent_blending_procs,\n                 false, drawn_comps, ctx->memory, dev);\n        }\n    } else {\n        /* Group color spaces are the same.  No color conversions needed */\n        if (x0 < x1 && y0 < y1)\n            pdf14_compose_group(tos, nos, maskbuf, x0, x1, y0, y1, nos->n_chan,\n                                ctx->additive, pblend_procs, overprint,\n                                drawn_comps, ctx->memory, dev);\n    }\nexit:\n    ctx->stack = nos;\n    /* We want to detect the cases where we have luminosity soft masks embedded\n       within one another.  The \"alpha\" channel really needs to be merged into\n       the luminosity channel in this case.  This will occur during the mask pop */\n    if (ctx->smask_depth > 0 && maskbuf != NULL) {\n        /* Set the trigger so that we will blend if not alpha. Since\n           we have softmasks embedded in softmasks */\n        ctx->smask_blend = true;\n    }\n    if_debug1m('v', ctx->memory, \"[v]pop buf, idle=%d\\n\", tos->idle);\n    pdf14_buf_free(tos, ctx->memory);\n    return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146388,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "pdf14_pop_transparency_group(gs_gstate *pgs, pdf14_ctx *ctx,\n    const pdf14_nonseparable_blending_procs_t * pblend_procs,\n    int tos_num_color_comp, cmm_profile_t *curr_icc_profile, gx_device *dev)\n{\n    pdf14_buf *tos = ctx->stack;\n    pdf14_buf *nos = tos->saved;\n    pdf14_mask_t *mask_stack = tos->mask_stack;\n    pdf14_buf *maskbuf;\n    int x0, x1, y0, y1;\n    byte *new_data_buf = NULL;\n    int num_noncolor_planes, new_num_planes;\n    int num_cols, num_rows, nos_num_color_comp;\n    bool icc_match;\n    gsicc_rendering_param_t rendering_params;\n    gsicc_link_t *icc_link;\n    gsicc_bufferdesc_t input_buff_desc;\n    gsicc_bufferdesc_t output_buff_desc;\n    pdf14_device *pdev = (pdf14_device *)dev;\n    bool overprint = pdev->overprint;\n    gx_color_index drawn_comps = pdev->drawn_comps;\n    bool nonicc_conversion = true;\n\n    if (nos == NULL)\n        return_error(gs_error_unknownerror);  /* Unmatched group pop */\n\n    nos_num_color_comp = nos->parent_color_info_procs->num_components - nos->num_spots;\n    tos_num_color_comp = tos_num_color_comp - tos->num_spots;\n\n#ifdef DEBUG\n    pdf14_debug_mask_stack_state(ctx);\n#endif\n    if (mask_stack == NULL) {\n        maskbuf = NULL;\n    } else {\n        maskbuf = mask_stack->rc_mask->mask_buf;\n    }\n    if (nos == NULL)\n        return_error(gs_error_rangecheck);\n    /* Sanitise the dirty rectangles, in case some of the drawing routines\n     * have made them overly large. */\n    rect_intersect(tos->dirty, tos->rect);\n    rect_intersect(nos->dirty, nos->rect);\n    /* dirty = the marked bbox. rect = the entire bounds of the buffer. */\n    /* Everything marked on tos that fits onto nos needs to be merged down. */\n    y0 = max(tos->dirty.p.y, nos->rect.p.y);\n    y1 = min(tos->dirty.q.y, nos->rect.q.y);\n    x0 = max(tos->dirty.p.x, nos->rect.p.x);\n    x1 = min(tos->dirty.q.x, nos->rect.q.x);\n    if (ctx->mask_stack) {\n        /* This can occur when we have a situation where we are ending out of\n           a group that has internal to it a soft mask and another group.\n           The soft mask left over from the previous trans group pop is put\n           into ctx->masbuf, since it is still active if another trans group\n           push occurs to use it.  If one does not occur, but instead we find\n           ourselves popping from a parent group, then this softmask is no\n           longer needed.  We will rc_decrement and set it to NULL. */\n        rc_decrement(ctx->mask_stack->rc_mask, \"pdf14_pop_transparency_group\");\n        if (ctx->mask_stack->rc_mask == NULL ){\n            gs_free_object(ctx->memory, ctx->mask_stack, \"pdf14_pop_transparency_group\");\n        }\n        ctx->mask_stack = NULL;\n    }\n    ctx->mask_stack = mask_stack;  /* Restore the mask saved by pdf14_push_transparency_group. */\n    tos->mask_stack = NULL;        /* Clean the pointer sinse the mask ownership is now passed to ctx. */\n    if (tos->idle)\n        goto exit;\n    if (maskbuf != NULL && maskbuf->data == NULL && maskbuf->alpha == 255)\n        goto exit;\n\n#if RAW_DUMP\n    /* Dump the current buffer to see what we have. */\n    dump_raw_buffer(ctx->stack->rect.q.y-ctx->stack->rect.p.y,\n                ctx->stack->rowstride, ctx->stack->n_planes,\n                ctx->stack->planestride, ctx->stack->rowstride,\n                \"aaTrans_Group_Pop\",ctx->stack->data);\n#endif\n/* Note currently if a pattern space has transparency, the ICC profile is not used\n   for blending purposes.  Instead we rely upon the gray, rgb, or cmyk parent space.\n   This is partially due to the fact that pdf14_pop_transparency_group and\n   pdf14_push_transparnecy_group have no real ICC interaction and those are the\n   operations called in the tile transparency code.  Instead we may want to\n   look at pdf14_begin_transparency_group and pdf14_end_transparency group which\n   is where all the ICC information is handled.  We will return to look at that later */\n    if (nos->parent_color_info_procs->icc_profile != NULL) {\n        icc_match = (nos->parent_color_info_procs->icc_profile->hashcode !=\n                        curr_icc_profile->hashcode);\n    } else {\n        /* Let the other tests make the decision if we need to transform */\n        icc_match = false;\n    }\n    /* If the color spaces are different and we actually did do a swap of\n       the procs for color */\n    if ((nos->parent_color_info_procs->parent_color_mapping_procs != NULL &&\n        nos_num_color_comp != tos_num_color_comp) || icc_match) {\n        if (x0 < x1 && y0 < y1) {\n            /* The NOS blending color space is different than that of the\n               TOS.  It is necessary to transform the TOS buffer data to the\n               color space of the NOS prior to doing the pdf14_compose_group\n               operation.  */\n            num_noncolor_planes = tos->n_planes - tos_num_color_comp;\n            new_num_planes = num_noncolor_planes + nos_num_color_comp;\n\n            /* See if we are doing ICC based conversion */\n            if (nos->parent_color_info_procs->icc_profile != NULL &&\n                curr_icc_profile != NULL) {\n                /* Use the ICC color management for buffer color conversion */\n                /* Define the rendering intents */\n                rendering_params.black_point_comp = gsBLACKPTCOMP_ON;\n                rendering_params.graphics_type_tag = GS_IMAGE_TAG;\n                rendering_params.override_icc = false;\n                rendering_params.preserve_black = gsBKPRESNOTSPECIFIED;\n                rendering_params.rendering_intent = gsPERCEPTUAL;\n                rendering_params.cmm = gsCMM_DEFAULT;\n                /* Request the ICC link for the transform that we will need to use */\n                /* Note that if pgs is NULL we assume the same color space.  This\n                   is due to a call to pop the group from fill_mask when filling\n                   with a mask with transparency.  In that case, the parent\n                   and the child will have the same color space anyway */\n                icc_link = gsicc_get_link_profile(pgs, dev, curr_icc_profile,\n                                    nos->parent_color_info_procs->icc_profile,\n                                    &rendering_params, pgs->memory, false);\n                if (icc_link != NULL) {\n                    /* if problem with link we will do non-ICC approach */\n                    nonicc_conversion = false;\n                    /* If the link is the identity, then we don't need to do\n                       any color conversions */\n                    if ( !(icc_link->is_identity) ) {\n                        /* Before we do any allocations check if we can get away with\n                           reusing the existing buffer if it is the same size ( if it is\n                           smaller go ahead and allocate).  We could reuse it in this\n                           case too.  We need to do a bit of testing to determine what\n                           would be best.  */\n                        /* FIXME: RJW: Could we get away with just color converting\n                         * the area that's actually active (i.e. dirty, not rect)?\n                         */\n                        if(nos_num_color_comp != tos_num_color_comp) {\n                            /* Different size.  We will need to allocate */\n                            new_data_buf = gs_alloc_bytes(ctx->memory,\n                                                tos->planestride * new_num_planes,\n                                                    \"pdf14_pop_transparency_group\");\n                            if (new_data_buf == NULL)\n                                return_error(gs_error_VMerror);\n                            /* Copy over the noncolor planes. */\n                            memcpy(new_data_buf + tos->planestride * nos_num_color_comp,\n                                   tos->data + tos->planestride * tos_num_color_comp,\n                                   tos->planestride * num_noncolor_planes);\n                        } else {\n                            /* In place color conversion! */\n                            new_data_buf = tos->data;\n                        }\n                        /* Set up the buffer descriptors. Note that pdf14 always has\n                           the alpha channels at the back end (last planes).\n                           We will just handle that here and let the CMM know\n                           nothing about it */\n                        num_rows = tos->rect.q.y - tos->rect.p.y;\n                        num_cols = tos->rect.q.x - tos->rect.p.x;\n                        gsicc_init_buffer(&input_buff_desc, tos_num_color_comp, 1,\n                                          false, false, true,\n                                          tos->planestride, tos->rowstride,\n                                          num_rows, num_cols);\n                        gsicc_init_buffer(&output_buff_desc, nos_num_color_comp,\n                                          1, false, false, true, tos->planestride,\n                                          tos->rowstride, num_rows, num_cols);\n                        /* Transform the data. Since the pdf14 device should be\n                           using RGB, CMYK or Gray buffers, this transform\n                           does not need to worry about the cmap procs of\n                           the target device.  Those are handled when we do\n                           the pdf14 put image operation */\n                        (icc_link->procs.map_buffer)(dev, icc_link, &input_buff_desc,\n                                                     &output_buff_desc, tos->data,\n                                                     new_data_buf);\n                    }\n                    /* Release the link */\n                    gsicc_release_link(icc_link);\n                    /* free the old object if the color spaces were different sizes */\n                    if(!(icc_link->is_identity) &&\n                        nos_num_color_comp != tos_num_color_comp) {\n                        gs_free_object(ctx->memory, tos->data,\n                            \"pdf14_pop_transparency_group\");\n                        tos->data = new_data_buf;\n                    }\n                }\n            }\n            if (nonicc_conversion) {\n                /* Non ICC based transform */\n                new_data_buf = gs_alloc_bytes(ctx->memory,\n                                    tos->planestride * new_num_planes,\n                                    \"pdf14_pop_transparency_group\");\n                if (new_data_buf == NULL)\n                    return_error(gs_error_VMerror);\n                gs_transform_color_buffer_generic(tos->data, tos->rowstride,\n                            tos->planestride, tos_num_color_comp, tos->rect,\n                            new_data_buf, nos_num_color_comp, num_noncolor_planes);\n                /* Free the old object */\n                gs_free_object(ctx->memory, tos->data,\n                                \"pdf14_pop_transparency_group\");\n                 tos->data = new_data_buf;\n            }\n             /* Adjust the plane and channel size now */\n             tos->n_chan = nos->n_chan;\n             tos->n_planes = nos->n_planes;\n#if RAW_DUMP\n            /* Dump the current buffer to see what we have. */\n            dump_raw_buffer(ctx->stack->rect.q.y-ctx->stack->rect.p.y,\n                            ctx->stack->rowstride, ctx->stack->n_chan,\n                            ctx->stack->planestride, ctx->stack->rowstride,\n                            \"aCMTrans_Group_ColorConv\",ctx->stack->data);\n#endif\n             /* compose. never do overprint in this case */\n            pdf14_compose_group(tos, nos, maskbuf, x0, x1, y0, y1, nos->n_chan,\n                 nos->parent_color_info_procs->isadditive,\n                 nos->parent_color_info_procs->parent_blending_procs,\n                 false, drawn_comps, ctx->memory, dev);\n        }\n    } else {\n        /* Group color spaces are the same.  No color conversions needed */\n        if (x0 < x1 && y0 < y1)\n            pdf14_compose_group(tos, nos, maskbuf, x0, x1, y0, y1, nos->n_chan,\n                                ctx->additive, pblend_procs, overprint,\n                                drawn_comps, ctx->memory, dev);\n    }\nexit:\n    ctx->stack = nos;\n    /* We want to detect the cases where we have luminosity soft masks embedded\n       within one another.  The \"alpha\" channel really needs to be merged into\n       the luminosity channel in this case.  This will occur during the mask pop */\n    if (ctx->smask_depth > 0 && maskbuf != NULL) {\n        /* Set the trigger so that we will blend if not alpha. Since\n           we have softmasks embedded in softmasks */\n        ctx->smask_blend = true;\n    }\n    if_debug1m('v', ctx->memory, \"[v]pop buf, idle=%d\\n\", tos->idle);\n    pdf14_buf_free(tos, ctx->memory);\n    return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146389,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int wrap_nettle_hash_fast(gnutls_digest_algorithm_t algo,\n\t\t\t\t const void *text, size_t text_size,\n\t\t\t\t void *digest)\n{\n\tstruct nettle_hash_ctx ctx;\n\tint ret;\n\n\tret = _ctx_init(algo, &ctx);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\n\tctx.update(&ctx, text_size, text);\n\tctx.digest(&ctx, ctx.length, digest);\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146478,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int wrap_nettle_hash_fast(gnutls_digest_algorithm_t algo,\n\t\t\t\t const void *text, size_t text_size,\n\t\t\t\t void *digest)\n{\n\tstruct nettle_hash_ctx ctx;\n\tint ret;\n\n\tret = _ctx_init(algo, &ctx);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\n\tif (text_size > 0) {\n\t\tctx.update(&ctx, text_size, text);\n\t}\n\tctx.digest(&ctx, ctx.length, digest);\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146479,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "AuthenticodeVerify (\r\n  IN  CONST UINT8  *AuthData,\r\n  IN  UINTN        DataSize,\r\n  IN  CONST UINT8  *TrustedCert,\r\n  IN  UINTN        CertSize,\r\n  IN  CONST UINT8  *ImageHash,\r\n  IN  UINTN        HashSize\r\n  )\r\n{\r\n  BOOLEAN      Status;\r\n  PKCS7        *Pkcs7;\r\n  CONST UINT8  *Temp;\r\n  CONST UINT8  *OrigAuthData;\r\n  UINT8        *SpcIndirectDataContent;\r\n  UINT8        Asn1Byte;\r\n  UINTN        ContentSize;\r\n  CONST UINT8  *SpcIndirectDataOid;\r\n\r\n  //\r\n  // Check input parameters.\r\n  //\r\n  if ((AuthData == NULL) || (TrustedCert == NULL) || (ImageHash == NULL)) {\r\n    return FALSE;\r\n  }\r\n\r\n  if ((DataSize > INT_MAX) || (CertSize > INT_MAX) || (HashSize > INT_MAX)) {\r\n    return FALSE;\r\n  }\r\n\r\n  Status       = FALSE;\r\n  Pkcs7        = NULL;\r\n  OrigAuthData = AuthData;\r\n\r\n  //\r\n  // Retrieve & Parse PKCS#7 Data (DER encoding) from Authenticode Signature\r\n  //\r\n  Temp  = AuthData;\r\n  Pkcs7 = d2i_PKCS7 (NULL, &Temp, (int)DataSize);\r\n  if (Pkcs7 == NULL) {\r\n    goto _Exit;\r\n  }\r\n\r\n  //\r\n  // Check if it's PKCS#7 Signed Data (for Authenticode Scenario)\r\n  //\r\n  if (!PKCS7_type_is_signed (Pkcs7)) {\r\n    goto _Exit;\r\n  }\r\n\r\n  //\r\n  // NOTE: OpenSSL PKCS7 Decoder didn't work for Authenticode-format signed data due to\r\n  //       some authenticode-specific structure. Use opaque ASN.1 string to retrieve\r\n  //       PKCS#7 ContentInfo here.\r\n  //\r\n  SpcIndirectDataOid = OBJ_get0_data(Pkcs7->d.sign->contents->type);\r\n  if (OBJ_length(Pkcs7->d.sign->contents->type) != sizeof(mSpcIndirectOidValue) ||\r\n      CompareMem (\r\n        SpcIndirectDataOid,\r\n        mSpcIndirectOidValue,\r\n        sizeof (mSpcIndirectOidValue)\r\n        ) != 0) {\r\n    //\r\n    // Un-matched SPC_INDIRECT_DATA_OBJID.\r\n    //\r\n    goto _Exit;\r\n  }\r\n\r\n\r\n  SpcIndirectDataContent = (UINT8 *)(Pkcs7->d.sign->contents->d.other->value.asn1_string->data);\r\n\r\n  //\r\n  // Retrieve the SEQUENCE data size from ASN.1-encoded SpcIndirectDataContent.\r\n  //\r\n  Asn1Byte = *(SpcIndirectDataContent + 1);\r\n\r\n  if ((Asn1Byte & 0x80) == 0) {\r\n    //\r\n    // Short Form of Length Encoding (Length < 128)\r\n    //\r\n    ContentSize = (UINTN) (Asn1Byte & 0x7F);\r\n    //\r\n    // Skip the SEQUENCE Tag;\r\n    //\r\n    SpcIndirectDataContent += 2;\r\n\r\n  } else if ((Asn1Byte & 0x81) == 0x81) {\r\n    //\r\n    // Long Form of Length Encoding (128 <= Length < 255, Single Octet)\r\n    //\r\n    ContentSize = (UINTN) (*(UINT8 *)(SpcIndirectDataContent + 2));\r\n    //\r\n    // Skip the SEQUENCE Tag;\r\n    //\r\n    SpcIndirectDataContent += 3;\r\n\r\n  } else if ((Asn1Byte & 0x82) == 0x82) {\r\n    //\r\n    // Long Form of Length Encoding (Length > 255, Two Octet)\r\n    //\r\n    ContentSize = (UINTN) (*(UINT8 *)(SpcIndirectDataContent + 2));\r\n    ContentSize = (ContentSize << 8) + (UINTN)(*(UINT8 *)(SpcIndirectDataContent + 3));\r\n    //\r\n    // Skip the SEQUENCE Tag;\r\n    //\r\n    SpcIndirectDataContent += 4;\r\n\r\n  } else {\r\n    goto _Exit;\r\n  }\r\n\r\n  //\r\n  // Compare the original file hash value to the digest retrieve from SpcIndirectDataContent\r\n  // defined in Authenticode\r\n  // NOTE: Need to double-check HashLength here!\r\n  //\r\n  if (CompareMem (SpcIndirectDataContent + ContentSize - HashSize, ImageHash, HashSize) != 0) {\r\n    //\r\n    // Un-matched PE/COFF Hash Value\r\n    //\r\n    goto _Exit;\r\n  }\r\n\r\n  //\r\n  // Verifies the PKCS#7 Signed Data in PE/COFF Authenticode Signature\r\n  //\r\n  Status = (BOOLEAN) Pkcs7Verify (OrigAuthData, DataSize, TrustedCert, CertSize, SpcIndirectDataContent, ContentSize);\r\n\r\n_Exit:\r\n  //\r\n  // Release Resources\r\n  //\r\n  PKCS7_free (Pkcs7);\r\n\r\n  return Status;\r\n}\r",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146500,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "AuthenticodeVerify (\r\n  IN  CONST UINT8  *AuthData,\r\n  IN  UINTN        DataSize,\r\n  IN  CONST UINT8  *TrustedCert,\r\n  IN  UINTN        CertSize,\r\n  IN  CONST UINT8  *ImageHash,\r\n  IN  UINTN        HashSize\r\n  )\r\n{\r\n  BOOLEAN      Status;\r\n  PKCS7        *Pkcs7;\r\n  CONST UINT8  *Temp;\r\n  CONST UINT8  *OrigAuthData;\r\n  UINT8        *SpcIndirectDataContent;\r\n  UINT8        Asn1Byte;\r\n  UINTN        ContentSize;\r\n  CONST UINT8  *SpcIndirectDataOid;\r\n\r\n  //\r\n  // Check input parameters.\r\n  //\r\n  if ((AuthData == NULL) || (TrustedCert == NULL) || (ImageHash == NULL)) {\r\n    return FALSE;\r\n  }\r\n\r\n  if ((DataSize > INT_MAX) || (CertSize > INT_MAX) || (HashSize > INT_MAX)) {\r\n    return FALSE;\r\n  }\r\n\r\n  Status       = FALSE;\r\n  Pkcs7        = NULL;\r\n  OrigAuthData = AuthData;\r\n\r\n  //\r\n  // Retrieve & Parse PKCS#7 Data (DER encoding) from Authenticode Signature\r\n  //\r\n  Temp  = AuthData;\r\n  Pkcs7 = d2i_PKCS7 (NULL, &Temp, (int)DataSize);\r\n  if (Pkcs7 == NULL) {\r\n    goto _Exit;\r\n  }\r\n\r\n  //\r\n  // Check if it's PKCS#7 Signed Data (for Authenticode Scenario)\r\n  //\r\n  if (!PKCS7_type_is_signed (Pkcs7) || PKCS7_get_detached (Pkcs7)) {\r\n    goto _Exit;\r\n  }\r\n\r\n  //\r\n  // NOTE: OpenSSL PKCS7 Decoder didn't work for Authenticode-format signed data due to\r\n  //       some authenticode-specific structure. Use opaque ASN.1 string to retrieve\r\n  //       PKCS#7 ContentInfo here.\r\n  //\r\n  SpcIndirectDataOid = OBJ_get0_data(Pkcs7->d.sign->contents->type);\r\n  if (OBJ_length(Pkcs7->d.sign->contents->type) != sizeof(mSpcIndirectOidValue) ||\r\n      CompareMem (\r\n        SpcIndirectDataOid,\r\n        mSpcIndirectOidValue,\r\n        sizeof (mSpcIndirectOidValue)\r\n        ) != 0) {\r\n    //\r\n    // Un-matched SPC_INDIRECT_DATA_OBJID.\r\n    //\r\n    goto _Exit;\r\n  }\r\n\r\n\r\n  SpcIndirectDataContent = (UINT8 *)(Pkcs7->d.sign->contents->d.other->value.asn1_string->data);\r\n\r\n  //\r\n  // Retrieve the SEQUENCE data size from ASN.1-encoded SpcIndirectDataContent.\r\n  //\r\n  Asn1Byte = *(SpcIndirectDataContent + 1);\r\n\r\n  if ((Asn1Byte & 0x80) == 0) {\r\n    //\r\n    // Short Form of Length Encoding (Length < 128)\r\n    //\r\n    ContentSize = (UINTN) (Asn1Byte & 0x7F);\r\n    //\r\n    // Skip the SEQUENCE Tag;\r\n    //\r\n    SpcIndirectDataContent += 2;\r\n\r\n  } else if ((Asn1Byte & 0x81) == 0x81) {\r\n    //\r\n    // Long Form of Length Encoding (128 <= Length < 255, Single Octet)\r\n    //\r\n    ContentSize = (UINTN) (*(UINT8 *)(SpcIndirectDataContent + 2));\r\n    //\r\n    // Skip the SEQUENCE Tag;\r\n    //\r\n    SpcIndirectDataContent += 3;\r\n\r\n  } else if ((Asn1Byte & 0x82) == 0x82) {\r\n    //\r\n    // Long Form of Length Encoding (Length > 255, Two Octet)\r\n    //\r\n    ContentSize = (UINTN) (*(UINT8 *)(SpcIndirectDataContent + 2));\r\n    ContentSize = (ContentSize << 8) + (UINTN)(*(UINT8 *)(SpcIndirectDataContent + 3));\r\n    //\r\n    // Skip the SEQUENCE Tag;\r\n    //\r\n    SpcIndirectDataContent += 4;\r\n\r\n  } else {\r\n    goto _Exit;\r\n  }\r\n\r\n  //\r\n  // Compare the original file hash value to the digest retrieve from SpcIndirectDataContent\r\n  // defined in Authenticode\r\n  // NOTE: Need to double-check HashLength here!\r\n  //\r\n  if (CompareMem (SpcIndirectDataContent + ContentSize - HashSize, ImageHash, HashSize) != 0) {\r\n    //\r\n    // Un-matched PE/COFF Hash Value\r\n    //\r\n    goto _Exit;\r\n  }\r\n\r\n  //\r\n  // Verifies the PKCS#7 Signed Data in PE/COFF Authenticode Signature\r\n  //\r\n  Status = (BOOLEAN) Pkcs7Verify (OrigAuthData, DataSize, TrustedCert, CertSize, SpcIndirectDataContent, ContentSize);\r\n\r\n_Exit:\r\n  //\r\n  // Release Resources\r\n  //\r\n  PKCS7_free (Pkcs7);\r\n\r\n  return Status;\r\n}\r",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146501,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " */\nstatic int\nxmlXPathCompOpEval(xmlXPathParserContextPtr ctxt, xmlXPathStepOpPtr op)\n{\n    int total = 0;\n    int equal, ret;\n    xmlXPathCompExprPtr comp;\n    xmlXPathObjectPtr arg1, arg2;\n\n    CHECK_ERROR0;\n    comp = ctxt->comp;\n    switch (op->op) {\n        case XPATH_OP_END:\n            return (0);\n        case XPATH_OP_AND:\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            xmlXPathBooleanFunction(ctxt, 1);\n            if ((ctxt->value == NULL) || (ctxt->value->boolval == 0))\n                return (total);\n            arg2 = valuePop(ctxt);\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    if (ctxt->error) {\n\t\txmlXPathFreeObject(arg2);\n\t\treturn(0);\n\t    }\n            xmlXPathBooleanFunction(ctxt, 1);\n            arg1 = valuePop(ctxt);\n            arg1->boolval &= arg2->boolval;\n            valuePush(ctxt, arg1);\n\t    xmlXPathReleaseObject(ctxt->context, arg2);\n            return (total);\n        case XPATH_OP_OR:\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            xmlXPathBooleanFunction(ctxt, 1);\n            if ((ctxt->value == NULL) || (ctxt->value->boolval == 1))\n                return (total);\n            arg2 = valuePop(ctxt);\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    if (ctxt->error) {\n\t\txmlXPathFreeObject(arg2);\n\t\treturn(0);\n\t    }\n            xmlXPathBooleanFunction(ctxt, 1);\n            arg1 = valuePop(ctxt);\n            arg1->boolval |= arg2->boolval;\n            valuePush(ctxt, arg1);\n\t    xmlXPathReleaseObject(ctxt->context, arg2);\n            return (total);\n        case XPATH_OP_EQUAL:\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n\t    if (op->value)\n\t\tequal = xmlXPathEqualValues(ctxt);\n\t    else\n\t\tequal = xmlXPathNotEqualValues(ctxt);\n\t    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, equal));\n            return (total);\n        case XPATH_OP_CMP:\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n            ret = xmlXPathCompareValues(ctxt, op->value, op->value2);\n\t    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, ret));\n            return (total);\n        case XPATH_OP_PLUS:\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            if (op->ch2 != -1) {\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    }\n\t    CHECK_ERROR0;\n            if (op->value == 0)\n                xmlXPathSubValues(ctxt);\n            else if (op->value == 1)\n                xmlXPathAddValues(ctxt);\n            else if (op->value == 2)\n                xmlXPathValueFlipSign(ctxt);\n            else if (op->value == 3) {\n                CAST_TO_NUMBER;\n                CHECK_TYPE0(XPATH_NUMBER);\n            }\n            return (total);\n        case XPATH_OP_MULT:\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n            if (op->value == 0)\n                xmlXPathMultValues(ctxt);\n            else if (op->value == 1)\n                xmlXPathDivValues(ctxt);\n            else if (op->value == 2)\n                xmlXPathModValues(ctxt);\n            return (total);\n        case XPATH_OP_UNION:\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n\n            arg2 = valuePop(ctxt);\n            arg1 = valuePop(ctxt);\n            if ((arg1 == NULL) || (arg1->type != XPATH_NODESET) ||\n                (arg2 == NULL) || (arg2->type != XPATH_NODESET)) {\n\t        xmlXPathReleaseObject(ctxt->context, arg1);\n\t        xmlXPathReleaseObject(ctxt->context, arg2);\n                XP_ERROR0(XPATH_INVALID_TYPE);\n            }\n\n\t    if ((arg1->nodesetval == NULL) ||\n\t\t((arg2->nodesetval != NULL) &&\n\t\t (arg2->nodesetval->nodeNr != 0)))\n\t    {\n\t\targ1->nodesetval = xmlXPathNodeSetMerge(arg1->nodesetval,\n\t\t\t\t\t\t\targ2->nodesetval);\n\t    }\n\n            valuePush(ctxt, arg1);\n\t    xmlXPathReleaseObject(ctxt->context, arg2);\n            return (total);\n        case XPATH_OP_ROOT:\n            xmlXPathRoot(ctxt);\n            return (total);\n        case XPATH_OP_NODE:\n            if (op->ch1 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            if (op->ch2 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n\t    valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,\n\t\tctxt->context->node));\n            return (total);\n        case XPATH_OP_COLLECT:{\n                if (op->ch1 == -1)\n                    return (total);\n\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t\tCHECK_ERROR0;\n\n                total += xmlXPathNodeCollectAndTest(ctxt, op, NULL, NULL, 0);\n                return (total);\n            }\n        case XPATH_OP_VALUE:\n            valuePush(ctxt,\n                      xmlXPathCacheObjectCopy(ctxt->context,\n\t\t\t(xmlXPathObjectPtr) op->value4));\n            return (total);\n        case XPATH_OP_VARIABLE:{\n\t\txmlXPathObjectPtr val;\n\n                if (op->ch1 != -1)\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n                if (op->value5 == NULL) {\n\t\t    val = xmlXPathVariableLookup(ctxt->context, op->value4);\n\t\t    if (val == NULL)\n\t\t\tXP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);\n                    valuePush(ctxt, val);\n\t\t} else {\n                    const xmlChar *URI;\n\n                    URI = xmlXPathNsLookup(ctxt->context, op->value5);\n                    if (URI == NULL) {\n                        xmlGenericError(xmlGenericErrorContext,\n            \"xmlXPathCompOpEval: variable %s bound to undefined prefix %s\\n\",\n                                    (char *) op->value4, (char *)op->value5);\n                        ctxt->error = XPATH_UNDEF_PREFIX_ERROR;\n                        return (total);\n                    }\n\t\t    val = xmlXPathVariableLookupNS(ctxt->context,\n                                                       op->value4, URI);\n\t\t    if (val == NULL)\n\t\t\tXP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);\n                    valuePush(ctxt, val);\n                }\n                return (total);\n            }\n        case XPATH_OP_FUNCTION:{\n                xmlXPathFunction func;\n                const xmlChar *oldFunc, *oldFuncURI;\n\t\tint i;\n                int frame;\n\n                frame = xmlXPathSetFrame(ctxt);\n                if (op->ch1 != -1) {\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n                    if (ctxt->error != XPATH_EXPRESSION_OK) {\n                        xmlXPathPopFrame(ctxt, frame);\n                        return (total);\n                    }\n                }\n\t\tif (ctxt->valueNr < ctxt->valueFrame + op->value) {\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"xmlXPathCompOpEval: parameter error\\n\");\n\t\t    ctxt->error = XPATH_INVALID_OPERAND;\n                    xmlXPathPopFrame(ctxt, frame);\n\t\t    return (total);\n\t\t}\n\t\tfor (i = 0; i < op->value; i++) {\n\t\t    if (ctxt->valueTab[(ctxt->valueNr - 1) - i] == NULL) {\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"xmlXPathCompOpEval: parameter error\\n\");\n\t\t\tctxt->error = XPATH_INVALID_OPERAND;\n                        xmlXPathPopFrame(ctxt, frame);\n\t\t\treturn (total);\n\t\t    }\n                }\n                if (op->cache != NULL)\n                    func = op->cache;\n                else {\n                    const xmlChar *URI = NULL;\n\n                    if (op->value5 == NULL)\n                        func =\n                            xmlXPathFunctionLookup(ctxt->context,\n                                                   op->value4);\n                    else {\n                        URI = xmlXPathNsLookup(ctxt->context, op->value5);\n                        if (URI == NULL) {\n                            xmlGenericError(xmlGenericErrorContext,\n            \"xmlXPathCompOpEval: function %s bound to undefined prefix %s\\n\",\n                                    (char *)op->value4, (char *)op->value5);\n                            xmlXPathPopFrame(ctxt, frame);\n                            ctxt->error = XPATH_UNDEF_PREFIX_ERROR;\n                            return (total);\n                        }\n                        func = xmlXPathFunctionLookupNS(ctxt->context,\n                                                        op->value4, URI);\n                    }\n                    if (func == NULL) {\n                        xmlGenericError(xmlGenericErrorContext,\n                                \"xmlXPathCompOpEval: function %s not found\\n\",\n                                        (char *)op->value4);\n                        XP_ERROR0(XPATH_UNKNOWN_FUNC_ERROR);\n                    }\n                    op->cache = func;\n                    op->cacheURI = (void *) URI;\n                }\n                oldFunc = ctxt->context->function;\n                oldFuncURI = ctxt->context->functionURI;\n                ctxt->context->function = op->value4;\n                ctxt->context->functionURI = op->cacheURI;\n                func(ctxt, op->value);\n                ctxt->context->function = oldFunc;\n                ctxt->context->functionURI = oldFuncURI;\n                xmlXPathPopFrame(ctxt, frame);\n                return (total);\n            }\n        case XPATH_OP_ARG:\n            if (op->ch1 != -1) {\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t        CHECK_ERROR0;\n            }\n            if (op->ch2 != -1) {\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t        CHECK_ERROR0;\n\t    }\n            return (total);\n        case XPATH_OP_PREDICATE:\n        case XPATH_OP_FILTER:{\n                xmlXPathObjectPtr res;\n                xmlXPathObjectPtr obj, tmp;\n                xmlNodeSetPtr newset = NULL;\n                xmlNodeSetPtr oldset;\n                xmlNodePtr oldnode;\n\t\txmlDocPtr oldDoc;\n                int oldcs, oldpp;\n                int i;\n\n                /*\n                 * Optimization for ()[1] selection i.e. the first elem\n                 */\n                if ((op->ch1 != -1) && (op->ch2 != -1) &&\n#ifdef XP_OPTIMIZED_FILTER_FIRST\n\t\t    /*\n\t\t    * FILTER TODO: Can we assume that the inner processing\n\t\t    *  will result in an ordered list if we have an\n\t\t    *  XPATH_OP_FILTER?\n\t\t    *  What about an additional field or flag on\n\t\t    *  xmlXPathObject like @sorted ? This way we wouln'd need\n\t\t    *  to assume anything, so it would be more robust and\n\t\t    *  easier to optimize.\n\t\t    */\n                    ((comp->steps[op->ch1].op == XPATH_OP_SORT) || /* 18 */\n\t\t     (comp->steps[op->ch1].op == XPATH_OP_FILTER)) && /* 17 */\n#else\n\t\t    (comp->steps[op->ch1].op == XPATH_OP_SORT) &&\n#endif\n                    (comp->steps[op->ch2].op == XPATH_OP_VALUE)) { /* 12 */\n                    xmlXPathObjectPtr val;\n\n                    val = comp->steps[op->ch2].value4;\n                    if ((val != NULL) && (val->type == XPATH_NUMBER) &&\n                        (val->floatval == 1.0)) {\n                        xmlNodePtr first = NULL;\n\n                        total +=\n                            xmlXPathCompOpEvalFirst(ctxt,\n                                                    &comp->steps[op->ch1],\n                                                    &first);\n\t\t\tCHECK_ERROR0;\n                        /*\n                         * The nodeset should be in document order,\n                         * Keep only the first value\n                         */\n                        if ((ctxt->value != NULL) &&\n                            (ctxt->value->type == XPATH_NODESET) &&\n                            (ctxt->value->nodesetval != NULL) &&\n                            (ctxt->value->nodesetval->nodeNr > 1))\n                            xmlXPathNodeSetClearFromPos(ctxt->value->nodesetval,\n                                                        1, 1);\n                        return (total);\n                    }\n                }\n                /*\n                 * Optimization for ()[last()] selection i.e. the last elem\n                 */\n                if ((op->ch1 != -1) && (op->ch2 != -1) &&\n                    (comp->steps[op->ch1].op == XPATH_OP_SORT) &&\n                    (comp->steps[op->ch2].op == XPATH_OP_SORT)) {\n                    int f = comp->steps[op->ch2].ch1;\n\n                    if ((f != -1) &&\n                        (comp->steps[f].op == XPATH_OP_FUNCTION) &&\n                        (comp->steps[f].value5 == NULL) &&\n                        (comp->steps[f].value == 0) &&\n                        (comp->steps[f].value4 != NULL) &&\n                        (xmlStrEqual\n                         (comp->steps[f].value4, BAD_CAST \"last\"))) {\n                        xmlNodePtr last = NULL;\n\n                        total +=\n                            xmlXPathCompOpEvalLast(ctxt,\n                                                   &comp->steps[op->ch1],\n                                                   &last);\n\t\t\tCHECK_ERROR0;\n                        /*\n                         * The nodeset should be in document order,\n                         * Keep only the last value\n                         */\n                        if ((ctxt->value != NULL) &&\n                            (ctxt->value->type == XPATH_NODESET) &&\n                            (ctxt->value->nodesetval != NULL) &&\n                            (ctxt->value->nodesetval->nodeTab != NULL) &&\n                            (ctxt->value->nodesetval->nodeNr > 1))\n                            xmlXPathNodeSetKeepLast(ctxt->value->nodesetval);\n                        return (total);\n                    }\n                }\n\t\t/*\n\t\t* Process inner predicates first.\n\t\t* Example \"index[parent::book][1]\":\n\t\t* ...\n\t\t*   PREDICATE   <-- we are here \"[1]\"\n\t\t*     PREDICATE <-- process \"[parent::book]\" first\n\t\t*       SORT\n\t\t*         COLLECT  'parent' 'name' 'node' book\n\t\t*           NODE\n\t\t*     ELEM Object is a number : 1\n\t\t*/\n                if (op->ch1 != -1)\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t\tCHECK_ERROR0;\n                if (op->ch2 == -1)\n                    return (total);\n                if (ctxt->value == NULL)\n                    return (total);\n\n#ifdef LIBXML_XPTR_ENABLED\n                /*\n                 * Hum are we filtering the result of an XPointer expression\n                 */\n                if (ctxt->value->type == XPATH_LOCATIONSET) {\n                    xmlLocationSetPtr newlocset = NULL;\n                    xmlLocationSetPtr oldlocset;\n\n                    /*\n                     * Extract the old locset, and then evaluate the result of the\n                     * expression for all the element in the locset. use it to grow\n                     * up a new locset.\n                     */\n                    CHECK_TYPE0(XPATH_LOCATIONSET);\n\n                    if ((ctxt->value->user == NULL) ||\n                        (((xmlLocationSetPtr) ctxt->value->user)->locNr == 0))\n                        return (total);\n\n                    obj = valuePop(ctxt);\n                    oldlocset = obj->user;\n                    oldnode = ctxt->context->node;\n                    oldcs = ctxt->context->contextSize;\n                    oldpp = ctxt->context->proximityPosition;\n\n                    newlocset = xmlXPtrLocationSetCreate(NULL);\n\n                    for (i = 0; i < oldlocset->locNr; i++) {\n                        /*\n                         * Run the evaluation with a node list made of a\n                         * single item in the nodelocset.\n                         */\n                        ctxt->context->node = oldlocset->locTab[i]->user;\n                        ctxt->context->contextSize = oldlocset->locNr;\n                        ctxt->context->proximityPosition = i + 1;\n\t\t\ttmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t    ctxt->context->node);\n                        valuePush(ctxt, tmp);\n\n                        if (op->ch2 != -1)\n                            total +=\n                                xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\tif (ctxt->error != XPATH_EXPRESSION_OK) {\n                            xmlXPtrFreeLocationSet(newlocset);\n                            goto filter_xptr_error;\n\t\t\t}\n\n                        /*\n                         * The result of the evaluation need to be tested to\n                         * decided whether the filter succeeded or not\n                         */\n                        res = valuePop(ctxt);\n                        if (xmlXPathEvaluatePredicateResult(ctxt, res)) {\n                            xmlXPtrLocationSetAdd(newlocset,\n                                                  xmlXPathObjectCopy\n                                                  (oldlocset->locTab[i]));\n                        }\n\n                        /*\n                         * Cleanup\n                         */\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        if (ctxt->value == tmp) {\n                            res = valuePop(ctxt);\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n                        }\n                    }\n\n                    /*\n                     * The result is used as the new evaluation locset.\n                     */\n                    valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));\nfilter_xptr_error:\n\t\t    xmlXPathReleaseObject(ctxt->context, obj);\n                    ctxt->context->node = oldnode;\n                    ctxt->context->contextSize = oldcs;\n                    ctxt->context->proximityPosition = oldpp;\n                    return (total);\n                }\n#endif /* LIBXML_XPTR_ENABLED */\n\n                /*\n                 * Extract the old set, and then evaluate the result of the\n                 * expression for all the element in the set. use it to grow\n                 * up a new set.\n                 */\n                CHECK_TYPE0(XPATH_NODESET);\n\n                if ((ctxt->value->nodesetval != NULL) &&\n                    (ctxt->value->nodesetval->nodeNr != 0)) {\n                    obj = valuePop(ctxt);\n                    oldset = obj->nodesetval;\n                    oldnode = ctxt->context->node;\n                    oldDoc = ctxt->context->doc;\n                    oldcs = ctxt->context->contextSize;\n                    oldpp = ctxt->context->proximityPosition;\n\t\t    tmp = NULL;\n                    /*\n                     * Initialize the new set.\n\t\t     * Also set the xpath document in case things like\n\t\t     * key() evaluation are attempted on the predicate\n                     */\n                    newset = xmlXPathNodeSetCreate(NULL);\n\t\t    /*\n\t\t    * SPEC XPath 1.0:\n\t\t    *  \"For each node in the node-set to be filtered, the\n\t\t    *  PredicateExpr is evaluated with that node as the\n\t\t    *  context node, with the number of nodes in the\n\t\t    *  node-set as the context size, and with the proximity\n\t\t    *  position of the node in the node-set with respect to\n\t\t    *  the axis as the context position;\"\n\t\t    * @oldset is the node-set\" to be filtered.\n\t\t    *\n\t\t    * SPEC XPath 1.0:\n\t\t    *  \"only predicates change the context position and\n\t\t    *  context size (see [2.4 Predicates]).\"\n\t\t    * Example:\n\t\t    *   node-set  context pos\n\t\t    *    nA         1\n\t\t    *    nB         2\n\t\t    *    nC         3\n\t\t    *   After applying predicate [position() > 1] :\n\t\t    *   node-set  context pos\n\t\t    *    nB         1\n\t\t    *    nC         2\n\t\t    *\n\t\t    * removed the first node in the node-set, then\n\t\t    * the context position of the\n\t\t    */\n                    for (i = 0; i < oldset->nodeNr; i++) {\n                        /*\n                         * Run the evaluation with a node list made of\n                         * a single item in the nodeset.\n                         */\n                        ctxt->context->node = oldset->nodeTab[i];\n\t\t\tif ((oldset->nodeTab[i]->type != XML_NAMESPACE_DECL) &&\n\t\t\t    (oldset->nodeTab[i]->doc != NULL))\n\t\t            ctxt->context->doc = oldset->nodeTab[i]->doc;\n\t\t\tif (tmp == NULL) {\n\t\t\t    tmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t\tctxt->context->node);\n\t\t\t} else {\n\t\t\t    if (xmlXPathNodeSetAddUnique(tmp->nodesetval,\n\t\t\t\t               ctxt->context->node) < 0) {\n\t\t\t\tctxt->error = XPATH_MEMORY_ERROR;\n\t\t\t    }\n\t\t\t}\n                        valuePush(ctxt, tmp);\n                        ctxt->context->contextSize = oldset->nodeNr;\n                        ctxt->context->proximityPosition = i + 1;\n\t\t\t/*\n\t\t\t* Evaluate the predicate against the context node.\n\t\t\t* Can/should we optimize position() predicates\n\t\t\t* here (e.g. \"[1]\")?\n\t\t\t*/\n                        if (op->ch2 != -1)\n                            total +=\n                                xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\tif (ctxt->error != XPATH_EXPRESSION_OK) {\n\t\t\t    xmlXPathFreeNodeSet(newset);\n                            goto filter_error;\n\t\t\t}\n\n                        /*\n                         * The result of the evaluation needs to be tested to\n                         * decide whether the filter succeeded or not\n                         */\n\t\t\t/*\n\t\t\t* OPTIMIZE TODO: Can we use\n\t\t\t* xmlXPathNodeSetAdd*Unique()* instead?\n\t\t\t*/\n                        res = valuePop(ctxt);\n                        if (xmlXPathEvaluatePredicateResult(ctxt, res)) {\n                            if (xmlXPathNodeSetAdd(newset, oldset->nodeTab[i])\n\t\t\t        < 0)\n\t\t\t\tctxt->error = XPATH_MEMORY_ERROR;\n                        }\n\n                        /*\n                         * Cleanup\n                         */\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        if (ctxt->value == tmp) {\n                            valuePop(ctxt);\n\t\t\t    xmlXPathNodeSetClear(tmp->nodesetval, 1);\n\t\t\t    /*\n\t\t\t    * Don't free the temporary nodeset\n\t\t\t    * in order to avoid massive recreation inside this\n\t\t\t    * loop.\n\t\t\t    */\n                        } else\n\t\t\t    tmp = NULL;\n                    }\n\t\t    if (tmp != NULL)\n\t\t\txmlXPathReleaseObject(ctxt->context, tmp);\n                    /*\n                     * The result is used as the new evaluation set.\n                     */\n\t\t    valuePush(ctxt,\n\t\t\txmlXPathCacheWrapNodeSet(ctxt->context, newset));\nfilter_error:\n\t\t    xmlXPathReleaseObject(ctxt->context, obj);\n\t\t    ctxt->context->node = oldnode;\n\t\t    ctxt->context->doc = oldDoc;\n                    ctxt->context->contextSize = oldcs;\n                    ctxt->context->proximityPosition = oldpp;\n                }\n                return (total);\n            }\n        case XPATH_OP_SORT:\n            if (op->ch1 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            if ((ctxt->value != NULL) &&\n                (ctxt->value->type == XPATH_NODESET) &&\n                (ctxt->value->nodesetval != NULL) &&\n\t\t(ctxt->value->nodesetval->nodeNr > 1))\n\t    {\n                xmlXPathNodeSetSort(ctxt->value->nodesetval);\n\t    }\n            return (total);\n#ifdef LIBXML_XPTR_ENABLED\n        case XPATH_OP_RANGETO:{\n                xmlXPathObjectPtr range;\n                xmlXPathObjectPtr res, obj;\n                xmlXPathObjectPtr tmp;\n                xmlLocationSetPtr newlocset = NULL;\n\t\t    xmlLocationSetPtr oldlocset;\n                xmlNodeSetPtr oldset;\n                xmlNodePtr oldnode = ctxt->context->node;\n                int oldcs = ctxt->context->contextSize;\n                int oldpp = ctxt->context->proximityPosition;\n                int i, j;\n\n                if (op->ch1 != -1) {\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n                    CHECK_ERROR0;\n                }\n                if (ctxt->value == NULL) {\n                    XP_ERROR0(XPATH_INVALID_OPERAND);\n                }\n                if (op->ch2 == -1)\n                    return (total);\n\n                if (ctxt->value->type == XPATH_LOCATIONSET) {\n                    /*\n                     * Extract the old locset, and then evaluate the result of the\n                     * expression for all the element in the locset. use it to grow\n                     * up a new locset.\n                     */\n                    CHECK_TYPE0(XPATH_LOCATIONSET);\n\n                    if ((ctxt->value->user == NULL) ||\n                        (((xmlLocationSetPtr) ctxt->value->user)->locNr == 0))\n                        return (total);\n\n                    obj = valuePop(ctxt);\n                    oldlocset = obj->user;\n\n                    newlocset = xmlXPtrLocationSetCreate(NULL);\n\n                    for (i = 0; i < oldlocset->locNr; i++) {\n                        /*\n                         * Run the evaluation with a node list made of a\n                         * single item in the nodelocset.\n                         */\n                        ctxt->context->node = oldlocset->locTab[i]->user;\n                        ctxt->context->contextSize = oldlocset->locNr;\n                        ctxt->context->proximityPosition = i + 1;\n\t\t\ttmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t    ctxt->context->node);\n                        valuePush(ctxt, tmp);\n\n                        if (op->ch2 != -1)\n                            total +=\n                                xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\tif (ctxt->error != XPATH_EXPRESSION_OK) {\n                            xmlXPtrFreeLocationSet(newlocset);\n                            goto rangeto_error;\n\t\t\t}\n\n                        res = valuePop(ctxt);\n\t\t\tif (res->type == XPATH_LOCATIONSET) {\n\t\t\t    xmlLocationSetPtr rloc =\n\t\t\t        (xmlLocationSetPtr)res->user;\n\t\t\t    for (j=0; j<rloc->locNr; j++) {\n\t\t\t        range = xmlXPtrNewRange(\n\t\t\t\t  oldlocset->locTab[i]->user,\n\t\t\t\t  oldlocset->locTab[i]->index,\n\t\t\t\t  rloc->locTab[j]->user2,\n\t\t\t\t  rloc->locTab[j]->index2);\n\t\t\t\tif (range != NULL) {\n\t\t\t\t    xmlXPtrLocationSetAdd(newlocset, range);\n\t\t\t\t}\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    range = xmlXPtrNewRangeNodeObject(\n\t\t\t\t(xmlNodePtr)oldlocset->locTab[i]->user, res);\n                            if (range != NULL) {\n                                xmlXPtrLocationSetAdd(newlocset,range);\n\t\t\t    }\n                        }\n\n                        /*\n                         * Cleanup\n                         */\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        if (ctxt->value == tmp) {\n                            res = valuePop(ctxt);\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n                        }\n                    }\n\t\t} else {\t/* Not a location set */\n                    CHECK_TYPE0(XPATH_NODESET);\n                    obj = valuePop(ctxt);\n                    oldset = obj->nodesetval;\n\n                    newlocset = xmlXPtrLocationSetCreate(NULL);\n\n                    if (oldset != NULL) {\n                        for (i = 0; i < oldset->nodeNr; i++) {\n                            /*\n                             * Run the evaluation with a node list made of a single item\n                             * in the nodeset.\n                             */\n                            ctxt->context->node = oldset->nodeTab[i];\n\t\t\t    /*\n\t\t\t    * OPTIMIZE TODO: Avoid recreation for every iteration.\n\t\t\t    */\n\t\t\t    tmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t\tctxt->context->node);\n                            valuePush(ctxt, tmp);\n\n                            if (op->ch2 != -1)\n                                total +=\n                                    xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\t    if (ctxt->error != XPATH_EXPRESSION_OK) {\n                                xmlXPtrFreeLocationSet(newlocset);\n                                goto rangeto_error;\n\t\t\t    }\n\n                            res = valuePop(ctxt);\n                            range =\n                                xmlXPtrNewRangeNodeObject(oldset->nodeTab[i],\n                                                      res);\n                            if (range != NULL) {\n                                xmlXPtrLocationSetAdd(newlocset, range);\n                            }\n\n                            /*\n                             * Cleanup\n                             */\n                            if (res != NULL) {\n\t\t\t\txmlXPathReleaseObject(ctxt->context, res);\n\t\t\t    }\n                            if (ctxt->value == tmp) {\n                                res = valuePop(ctxt);\n\t\t\t\txmlXPathReleaseObject(ctxt->context, res);\n                            }\n                        }\n                    }\n                }\n\n                /*\n                 * The result is used as the new evaluation set.\n                 */\n                valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));\nrangeto_error:\n\t\txmlXPathReleaseObject(ctxt->context, obj);\n                ctxt->context->node = oldnode;\n                ctxt->context->contextSize = oldcs;\n                ctxt->context->proximityPosition = oldpp;\n                return (total);\n            }\n#endif /* LIBXML_XPTR_ENABLED */\n    }\n    xmlGenericError(xmlGenericErrorContext,\n                    \"XPath: unknown precompiled operation %d\\n\", op->op);\n    ctxt->error = XPATH_INVALID_OPERAND;",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146504,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " */\nstatic int\nxmlXPathCompOpEval(xmlXPathParserContextPtr ctxt, xmlXPathStepOpPtr op)\n{\n    int total = 0;\n    int equal, ret;\n    xmlXPathCompExprPtr comp;\n    xmlXPathObjectPtr arg1, arg2;\n\n    CHECK_ERROR0;\n    comp = ctxt->comp;\n    switch (op->op) {\n        case XPATH_OP_END:\n            return (0);\n        case XPATH_OP_AND:\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            xmlXPathBooleanFunction(ctxt, 1);\n            if ((ctxt->value == NULL) || (ctxt->value->boolval == 0))\n                return (total);\n            arg2 = valuePop(ctxt);\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    if (ctxt->error) {\n\t\txmlXPathFreeObject(arg2);\n\t\treturn(0);\n\t    }\n            xmlXPathBooleanFunction(ctxt, 1);\n            if (ctxt->value != NULL)\n                ctxt->value->boolval &= arg2->boolval;\n\t    xmlXPathReleaseObject(ctxt->context, arg2);\n            return (total);\n        case XPATH_OP_OR:\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            xmlXPathBooleanFunction(ctxt, 1);\n            if ((ctxt->value == NULL) || (ctxt->value->boolval == 1))\n                return (total);\n            arg2 = valuePop(ctxt);\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    if (ctxt->error) {\n\t\txmlXPathFreeObject(arg2);\n\t\treturn(0);\n\t    }\n            xmlXPathBooleanFunction(ctxt, 1);\n            if (ctxt->value != NULL)\n                ctxt->value->boolval |= arg2->boolval;\n\t    xmlXPathReleaseObject(ctxt->context, arg2);\n            return (total);\n        case XPATH_OP_EQUAL:\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n\t    if (op->value)\n\t\tequal = xmlXPathEqualValues(ctxt);\n\t    else\n\t\tequal = xmlXPathNotEqualValues(ctxt);\n\t    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, equal));\n            return (total);\n        case XPATH_OP_CMP:\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n            ret = xmlXPathCompareValues(ctxt, op->value, op->value2);\n\t    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, ret));\n            return (total);\n        case XPATH_OP_PLUS:\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            if (op->ch2 != -1) {\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    }\n\t    CHECK_ERROR0;\n            if (op->value == 0)\n                xmlXPathSubValues(ctxt);\n            else if (op->value == 1)\n                xmlXPathAddValues(ctxt);\n            else if (op->value == 2)\n                xmlXPathValueFlipSign(ctxt);\n            else if (op->value == 3) {\n                CAST_TO_NUMBER;\n                CHECK_TYPE0(XPATH_NUMBER);\n            }\n            return (total);\n        case XPATH_OP_MULT:\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n            if (op->value == 0)\n                xmlXPathMultValues(ctxt);\n            else if (op->value == 1)\n                xmlXPathDivValues(ctxt);\n            else if (op->value == 2)\n                xmlXPathModValues(ctxt);\n            return (total);\n        case XPATH_OP_UNION:\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n\n            arg2 = valuePop(ctxt);\n            arg1 = valuePop(ctxt);\n            if ((arg1 == NULL) || (arg1->type != XPATH_NODESET) ||\n                (arg2 == NULL) || (arg2->type != XPATH_NODESET)) {\n\t        xmlXPathReleaseObject(ctxt->context, arg1);\n\t        xmlXPathReleaseObject(ctxt->context, arg2);\n                XP_ERROR0(XPATH_INVALID_TYPE);\n            }\n\n\t    if ((arg1->nodesetval == NULL) ||\n\t\t((arg2->nodesetval != NULL) &&\n\t\t (arg2->nodesetval->nodeNr != 0)))\n\t    {\n\t\targ1->nodesetval = xmlXPathNodeSetMerge(arg1->nodesetval,\n\t\t\t\t\t\t\targ2->nodesetval);\n\t    }\n\n            valuePush(ctxt, arg1);\n\t    xmlXPathReleaseObject(ctxt->context, arg2);\n            return (total);\n        case XPATH_OP_ROOT:\n            xmlXPathRoot(ctxt);\n            return (total);\n        case XPATH_OP_NODE:\n            if (op->ch1 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            if (op->ch2 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n\t    valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,\n\t\tctxt->context->node));\n            return (total);\n        case XPATH_OP_COLLECT:{\n                if (op->ch1 == -1)\n                    return (total);\n\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t\tCHECK_ERROR0;\n\n                total += xmlXPathNodeCollectAndTest(ctxt, op, NULL, NULL, 0);\n                return (total);\n            }\n        case XPATH_OP_VALUE:\n            valuePush(ctxt,\n                      xmlXPathCacheObjectCopy(ctxt->context,\n\t\t\t(xmlXPathObjectPtr) op->value4));\n            return (total);\n        case XPATH_OP_VARIABLE:{\n\t\txmlXPathObjectPtr val;\n\n                if (op->ch1 != -1)\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n                if (op->value5 == NULL) {\n\t\t    val = xmlXPathVariableLookup(ctxt->context, op->value4);\n\t\t    if (val == NULL)\n\t\t\tXP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);\n                    valuePush(ctxt, val);\n\t\t} else {\n                    const xmlChar *URI;\n\n                    URI = xmlXPathNsLookup(ctxt->context, op->value5);\n                    if (URI == NULL) {\n                        xmlGenericError(xmlGenericErrorContext,\n            \"xmlXPathCompOpEval: variable %s bound to undefined prefix %s\\n\",\n                                    (char *) op->value4, (char *)op->value5);\n                        ctxt->error = XPATH_UNDEF_PREFIX_ERROR;\n                        return (total);\n                    }\n\t\t    val = xmlXPathVariableLookupNS(ctxt->context,\n                                                       op->value4, URI);\n\t\t    if (val == NULL)\n\t\t\tXP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);\n                    valuePush(ctxt, val);\n                }\n                return (total);\n            }\n        case XPATH_OP_FUNCTION:{\n                xmlXPathFunction func;\n                const xmlChar *oldFunc, *oldFuncURI;\n\t\tint i;\n                int frame;\n\n                frame = xmlXPathSetFrame(ctxt);\n                if (op->ch1 != -1) {\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n                    if (ctxt->error != XPATH_EXPRESSION_OK) {\n                        xmlXPathPopFrame(ctxt, frame);\n                        return (total);\n                    }\n                }\n\t\tif (ctxt->valueNr < ctxt->valueFrame + op->value) {\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"xmlXPathCompOpEval: parameter error\\n\");\n\t\t    ctxt->error = XPATH_INVALID_OPERAND;\n                    xmlXPathPopFrame(ctxt, frame);\n\t\t    return (total);\n\t\t}\n\t\tfor (i = 0; i < op->value; i++) {\n\t\t    if (ctxt->valueTab[(ctxt->valueNr - 1) - i] == NULL) {\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"xmlXPathCompOpEval: parameter error\\n\");\n\t\t\tctxt->error = XPATH_INVALID_OPERAND;\n                        xmlXPathPopFrame(ctxt, frame);\n\t\t\treturn (total);\n\t\t    }\n                }\n                if (op->cache != NULL)\n                    func = op->cache;\n                else {\n                    const xmlChar *URI = NULL;\n\n                    if (op->value5 == NULL)\n                        func =\n                            xmlXPathFunctionLookup(ctxt->context,\n                                                   op->value4);\n                    else {\n                        URI = xmlXPathNsLookup(ctxt->context, op->value5);\n                        if (URI == NULL) {\n                            xmlGenericError(xmlGenericErrorContext,\n            \"xmlXPathCompOpEval: function %s bound to undefined prefix %s\\n\",\n                                    (char *)op->value4, (char *)op->value5);\n                            xmlXPathPopFrame(ctxt, frame);\n                            ctxt->error = XPATH_UNDEF_PREFIX_ERROR;\n                            return (total);\n                        }\n                        func = xmlXPathFunctionLookupNS(ctxt->context,\n                                                        op->value4, URI);\n                    }\n                    if (func == NULL) {\n                        xmlGenericError(xmlGenericErrorContext,\n                                \"xmlXPathCompOpEval: function %s not found\\n\",\n                                        (char *)op->value4);\n                        XP_ERROR0(XPATH_UNKNOWN_FUNC_ERROR);\n                    }\n                    op->cache = func;\n                    op->cacheURI = (void *) URI;\n                }\n                oldFunc = ctxt->context->function;\n                oldFuncURI = ctxt->context->functionURI;\n                ctxt->context->function = op->value4;\n                ctxt->context->functionURI = op->cacheURI;\n                func(ctxt, op->value);\n                ctxt->context->function = oldFunc;\n                ctxt->context->functionURI = oldFuncURI;\n                xmlXPathPopFrame(ctxt, frame);\n                return (total);\n            }\n        case XPATH_OP_ARG:\n            if (op->ch1 != -1) {\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t        CHECK_ERROR0;\n            }\n            if (op->ch2 != -1) {\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t        CHECK_ERROR0;\n\t    }\n            return (total);\n        case XPATH_OP_PREDICATE:\n        case XPATH_OP_FILTER:{\n                xmlXPathObjectPtr res;\n                xmlXPathObjectPtr obj, tmp;\n                xmlNodeSetPtr newset = NULL;\n                xmlNodeSetPtr oldset;\n                xmlNodePtr oldnode;\n\t\txmlDocPtr oldDoc;\n                int oldcs, oldpp;\n                int i;\n\n                /*\n                 * Optimization for ()[1] selection i.e. the first elem\n                 */\n                if ((op->ch1 != -1) && (op->ch2 != -1) &&\n#ifdef XP_OPTIMIZED_FILTER_FIRST\n\t\t    /*\n\t\t    * FILTER TODO: Can we assume that the inner processing\n\t\t    *  will result in an ordered list if we have an\n\t\t    *  XPATH_OP_FILTER?\n\t\t    *  What about an additional field or flag on\n\t\t    *  xmlXPathObject like @sorted ? This way we wouln'd need\n\t\t    *  to assume anything, so it would be more robust and\n\t\t    *  easier to optimize.\n\t\t    */\n                    ((comp->steps[op->ch1].op == XPATH_OP_SORT) || /* 18 */\n\t\t     (comp->steps[op->ch1].op == XPATH_OP_FILTER)) && /* 17 */\n#else\n\t\t    (comp->steps[op->ch1].op == XPATH_OP_SORT) &&\n#endif\n                    (comp->steps[op->ch2].op == XPATH_OP_VALUE)) { /* 12 */\n                    xmlXPathObjectPtr val;\n\n                    val = comp->steps[op->ch2].value4;\n                    if ((val != NULL) && (val->type == XPATH_NUMBER) &&\n                        (val->floatval == 1.0)) {\n                        xmlNodePtr first = NULL;\n\n                        total +=\n                            xmlXPathCompOpEvalFirst(ctxt,\n                                                    &comp->steps[op->ch1],\n                                                    &first);\n\t\t\tCHECK_ERROR0;\n                        /*\n                         * The nodeset should be in document order,\n                         * Keep only the first value\n                         */\n                        if ((ctxt->value != NULL) &&\n                            (ctxt->value->type == XPATH_NODESET) &&\n                            (ctxt->value->nodesetval != NULL) &&\n                            (ctxt->value->nodesetval->nodeNr > 1))\n                            xmlXPathNodeSetClearFromPos(ctxt->value->nodesetval,\n                                                        1, 1);\n                        return (total);\n                    }\n                }\n                /*\n                 * Optimization for ()[last()] selection i.e. the last elem\n                 */\n                if ((op->ch1 != -1) && (op->ch2 != -1) &&\n                    (comp->steps[op->ch1].op == XPATH_OP_SORT) &&\n                    (comp->steps[op->ch2].op == XPATH_OP_SORT)) {\n                    int f = comp->steps[op->ch2].ch1;\n\n                    if ((f != -1) &&\n                        (comp->steps[f].op == XPATH_OP_FUNCTION) &&\n                        (comp->steps[f].value5 == NULL) &&\n                        (comp->steps[f].value == 0) &&\n                        (comp->steps[f].value4 != NULL) &&\n                        (xmlStrEqual\n                         (comp->steps[f].value4, BAD_CAST \"last\"))) {\n                        xmlNodePtr last = NULL;\n\n                        total +=\n                            xmlXPathCompOpEvalLast(ctxt,\n                                                   &comp->steps[op->ch1],\n                                                   &last);\n\t\t\tCHECK_ERROR0;\n                        /*\n                         * The nodeset should be in document order,\n                         * Keep only the last value\n                         */\n                        if ((ctxt->value != NULL) &&\n                            (ctxt->value->type == XPATH_NODESET) &&\n                            (ctxt->value->nodesetval != NULL) &&\n                            (ctxt->value->nodesetval->nodeTab != NULL) &&\n                            (ctxt->value->nodesetval->nodeNr > 1))\n                            xmlXPathNodeSetKeepLast(ctxt->value->nodesetval);\n                        return (total);\n                    }\n                }\n\t\t/*\n\t\t* Process inner predicates first.\n\t\t* Example \"index[parent::book][1]\":\n\t\t* ...\n\t\t*   PREDICATE   <-- we are here \"[1]\"\n\t\t*     PREDICATE <-- process \"[parent::book]\" first\n\t\t*       SORT\n\t\t*         COLLECT  'parent' 'name' 'node' book\n\t\t*           NODE\n\t\t*     ELEM Object is a number : 1\n\t\t*/\n                if (op->ch1 != -1)\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t\tCHECK_ERROR0;\n                if (op->ch2 == -1)\n                    return (total);\n                if (ctxt->value == NULL)\n                    return (total);\n\n#ifdef LIBXML_XPTR_ENABLED\n                /*\n                 * Hum are we filtering the result of an XPointer expression\n                 */\n                if (ctxt->value->type == XPATH_LOCATIONSET) {\n                    xmlLocationSetPtr newlocset = NULL;\n                    xmlLocationSetPtr oldlocset;\n\n                    /*\n                     * Extract the old locset, and then evaluate the result of the\n                     * expression for all the element in the locset. use it to grow\n                     * up a new locset.\n                     */\n                    CHECK_TYPE0(XPATH_LOCATIONSET);\n\n                    if ((ctxt->value->user == NULL) ||\n                        (((xmlLocationSetPtr) ctxt->value->user)->locNr == 0))\n                        return (total);\n\n                    obj = valuePop(ctxt);\n                    oldlocset = obj->user;\n                    oldnode = ctxt->context->node;\n                    oldcs = ctxt->context->contextSize;\n                    oldpp = ctxt->context->proximityPosition;\n\n                    newlocset = xmlXPtrLocationSetCreate(NULL);\n\n                    for (i = 0; i < oldlocset->locNr; i++) {\n                        /*\n                         * Run the evaluation with a node list made of a\n                         * single item in the nodelocset.\n                         */\n                        ctxt->context->node = oldlocset->locTab[i]->user;\n                        ctxt->context->contextSize = oldlocset->locNr;\n                        ctxt->context->proximityPosition = i + 1;\n\t\t\ttmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t    ctxt->context->node);\n                        valuePush(ctxt, tmp);\n\n                        if (op->ch2 != -1)\n                            total +=\n                                xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\tif (ctxt->error != XPATH_EXPRESSION_OK) {\n                            xmlXPtrFreeLocationSet(newlocset);\n                            goto filter_xptr_error;\n\t\t\t}\n\n                        /*\n                         * The result of the evaluation need to be tested to\n                         * decided whether the filter succeeded or not\n                         */\n                        res = valuePop(ctxt);\n                        if (xmlXPathEvaluatePredicateResult(ctxt, res)) {\n                            xmlXPtrLocationSetAdd(newlocset,\n                                                  xmlXPathObjectCopy\n                                                  (oldlocset->locTab[i]));\n                        }\n\n                        /*\n                         * Cleanup\n                         */\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        if (ctxt->value == tmp) {\n                            res = valuePop(ctxt);\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n                        }\n                    }\n\n                    /*\n                     * The result is used as the new evaluation locset.\n                     */\n                    valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));\nfilter_xptr_error:\n\t\t    xmlXPathReleaseObject(ctxt->context, obj);\n                    ctxt->context->node = oldnode;\n                    ctxt->context->contextSize = oldcs;\n                    ctxt->context->proximityPosition = oldpp;\n                    return (total);\n                }\n#endif /* LIBXML_XPTR_ENABLED */\n\n                /*\n                 * Extract the old set, and then evaluate the result of the\n                 * expression for all the element in the set. use it to grow\n                 * up a new set.\n                 */\n                CHECK_TYPE0(XPATH_NODESET);\n\n                if ((ctxt->value->nodesetval != NULL) &&\n                    (ctxt->value->nodesetval->nodeNr != 0)) {\n                    obj = valuePop(ctxt);\n                    oldset = obj->nodesetval;\n                    oldnode = ctxt->context->node;\n                    oldDoc = ctxt->context->doc;\n                    oldcs = ctxt->context->contextSize;\n                    oldpp = ctxt->context->proximityPosition;\n\t\t    tmp = NULL;\n                    /*\n                     * Initialize the new set.\n\t\t     * Also set the xpath document in case things like\n\t\t     * key() evaluation are attempted on the predicate\n                     */\n                    newset = xmlXPathNodeSetCreate(NULL);\n\t\t    /*\n\t\t    * SPEC XPath 1.0:\n\t\t    *  \"For each node in the node-set to be filtered, the\n\t\t    *  PredicateExpr is evaluated with that node as the\n\t\t    *  context node, with the number of nodes in the\n\t\t    *  node-set as the context size, and with the proximity\n\t\t    *  position of the node in the node-set with respect to\n\t\t    *  the axis as the context position;\"\n\t\t    * @oldset is the node-set\" to be filtered.\n\t\t    *\n\t\t    * SPEC XPath 1.0:\n\t\t    *  \"only predicates change the context position and\n\t\t    *  context size (see [2.4 Predicates]).\"\n\t\t    * Example:\n\t\t    *   node-set  context pos\n\t\t    *    nA         1\n\t\t    *    nB         2\n\t\t    *    nC         3\n\t\t    *   After applying predicate [position() > 1] :\n\t\t    *   node-set  context pos\n\t\t    *    nB         1\n\t\t    *    nC         2\n\t\t    *\n\t\t    * removed the first node in the node-set, then\n\t\t    * the context position of the\n\t\t    */\n                    for (i = 0; i < oldset->nodeNr; i++) {\n                        /*\n                         * Run the evaluation with a node list made of\n                         * a single item in the nodeset.\n                         */\n                        ctxt->context->node = oldset->nodeTab[i];\n\t\t\tif ((oldset->nodeTab[i]->type != XML_NAMESPACE_DECL) &&\n\t\t\t    (oldset->nodeTab[i]->doc != NULL))\n\t\t            ctxt->context->doc = oldset->nodeTab[i]->doc;\n\t\t\tif (tmp == NULL) {\n\t\t\t    tmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t\tctxt->context->node);\n\t\t\t} else {\n\t\t\t    if (xmlXPathNodeSetAddUnique(tmp->nodesetval,\n\t\t\t\t               ctxt->context->node) < 0) {\n\t\t\t\tctxt->error = XPATH_MEMORY_ERROR;\n\t\t\t    }\n\t\t\t}\n                        valuePush(ctxt, tmp);\n                        ctxt->context->contextSize = oldset->nodeNr;\n                        ctxt->context->proximityPosition = i + 1;\n\t\t\t/*\n\t\t\t* Evaluate the predicate against the context node.\n\t\t\t* Can/should we optimize position() predicates\n\t\t\t* here (e.g. \"[1]\")?\n\t\t\t*/\n                        if (op->ch2 != -1)\n                            total +=\n                                xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\tif (ctxt->error != XPATH_EXPRESSION_OK) {\n\t\t\t    xmlXPathFreeNodeSet(newset);\n                            goto filter_error;\n\t\t\t}\n\n                        /*\n                         * The result of the evaluation needs to be tested to\n                         * decide whether the filter succeeded or not\n                         */\n\t\t\t/*\n\t\t\t* OPTIMIZE TODO: Can we use\n\t\t\t* xmlXPathNodeSetAdd*Unique()* instead?\n\t\t\t*/\n                        res = valuePop(ctxt);\n                        if (xmlXPathEvaluatePredicateResult(ctxt, res)) {\n                            if (xmlXPathNodeSetAdd(newset, oldset->nodeTab[i])\n\t\t\t        < 0)\n\t\t\t\tctxt->error = XPATH_MEMORY_ERROR;\n                        }\n\n                        /*\n                         * Cleanup\n                         */\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        if (ctxt->value == tmp) {\n                            valuePop(ctxt);\n\t\t\t    xmlXPathNodeSetClear(tmp->nodesetval, 1);\n\t\t\t    /*\n\t\t\t    * Don't free the temporary nodeset\n\t\t\t    * in order to avoid massive recreation inside this\n\t\t\t    * loop.\n\t\t\t    */\n                        } else\n\t\t\t    tmp = NULL;\n                    }\n\t\t    if (tmp != NULL)\n\t\t\txmlXPathReleaseObject(ctxt->context, tmp);\n                    /*\n                     * The result is used as the new evaluation set.\n                     */\n\t\t    valuePush(ctxt,\n\t\t\txmlXPathCacheWrapNodeSet(ctxt->context, newset));\nfilter_error:\n\t\t    xmlXPathReleaseObject(ctxt->context, obj);\n\t\t    ctxt->context->node = oldnode;\n\t\t    ctxt->context->doc = oldDoc;\n                    ctxt->context->contextSize = oldcs;\n                    ctxt->context->proximityPosition = oldpp;\n                }\n                return (total);\n            }\n        case XPATH_OP_SORT:\n            if (op->ch1 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            if ((ctxt->value != NULL) &&\n                (ctxt->value->type == XPATH_NODESET) &&\n                (ctxt->value->nodesetval != NULL) &&\n\t\t(ctxt->value->nodesetval->nodeNr > 1))\n\t    {\n                xmlXPathNodeSetSort(ctxt->value->nodesetval);\n\t    }\n            return (total);\n#ifdef LIBXML_XPTR_ENABLED\n        case XPATH_OP_RANGETO:{\n                xmlXPathObjectPtr range;\n                xmlXPathObjectPtr res, obj;\n                xmlXPathObjectPtr tmp;\n                xmlLocationSetPtr newlocset = NULL;\n\t\t    xmlLocationSetPtr oldlocset;\n                xmlNodeSetPtr oldset;\n                xmlNodePtr oldnode = ctxt->context->node;\n                int oldcs = ctxt->context->contextSize;\n                int oldpp = ctxt->context->proximityPosition;\n                int i, j;\n\n                if (op->ch1 != -1) {\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n                    CHECK_ERROR0;\n                }\n                if (ctxt->value == NULL) {\n                    XP_ERROR0(XPATH_INVALID_OPERAND);\n                }\n                if (op->ch2 == -1)\n                    return (total);\n\n                if (ctxt->value->type == XPATH_LOCATIONSET) {\n                    /*\n                     * Extract the old locset, and then evaluate the result of the\n                     * expression for all the element in the locset. use it to grow\n                     * up a new locset.\n                     */\n                    CHECK_TYPE0(XPATH_LOCATIONSET);\n\n                    if ((ctxt->value->user == NULL) ||\n                        (((xmlLocationSetPtr) ctxt->value->user)->locNr == 0))\n                        return (total);\n\n                    obj = valuePop(ctxt);\n                    oldlocset = obj->user;\n\n                    newlocset = xmlXPtrLocationSetCreate(NULL);\n\n                    for (i = 0; i < oldlocset->locNr; i++) {\n                        /*\n                         * Run the evaluation with a node list made of a\n                         * single item in the nodelocset.\n                         */\n                        ctxt->context->node = oldlocset->locTab[i]->user;\n                        ctxt->context->contextSize = oldlocset->locNr;\n                        ctxt->context->proximityPosition = i + 1;\n\t\t\ttmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t    ctxt->context->node);\n                        valuePush(ctxt, tmp);\n\n                        if (op->ch2 != -1)\n                            total +=\n                                xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\tif (ctxt->error != XPATH_EXPRESSION_OK) {\n                            xmlXPtrFreeLocationSet(newlocset);\n                            goto rangeto_error;\n\t\t\t}\n\n                        res = valuePop(ctxt);\n\t\t\tif (res->type == XPATH_LOCATIONSET) {\n\t\t\t    xmlLocationSetPtr rloc =\n\t\t\t        (xmlLocationSetPtr)res->user;\n\t\t\t    for (j=0; j<rloc->locNr; j++) {\n\t\t\t        range = xmlXPtrNewRange(\n\t\t\t\t  oldlocset->locTab[i]->user,\n\t\t\t\t  oldlocset->locTab[i]->index,\n\t\t\t\t  rloc->locTab[j]->user2,\n\t\t\t\t  rloc->locTab[j]->index2);\n\t\t\t\tif (range != NULL) {\n\t\t\t\t    xmlXPtrLocationSetAdd(newlocset, range);\n\t\t\t\t}\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    range = xmlXPtrNewRangeNodeObject(\n\t\t\t\t(xmlNodePtr)oldlocset->locTab[i]->user, res);\n                            if (range != NULL) {\n                                xmlXPtrLocationSetAdd(newlocset,range);\n\t\t\t    }\n                        }\n\n                        /*\n                         * Cleanup\n                         */\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        if (ctxt->value == tmp) {\n                            res = valuePop(ctxt);\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n                        }\n                    }\n\t\t} else {\t/* Not a location set */\n                    CHECK_TYPE0(XPATH_NODESET);\n                    obj = valuePop(ctxt);\n                    oldset = obj->nodesetval;\n\n                    newlocset = xmlXPtrLocationSetCreate(NULL);\n\n                    if (oldset != NULL) {\n                        for (i = 0; i < oldset->nodeNr; i++) {\n                            /*\n                             * Run the evaluation with a node list made of a single item\n                             * in the nodeset.\n                             */\n                            ctxt->context->node = oldset->nodeTab[i];\n\t\t\t    /*\n\t\t\t    * OPTIMIZE TODO: Avoid recreation for every iteration.\n\t\t\t    */\n\t\t\t    tmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t\tctxt->context->node);\n                            valuePush(ctxt, tmp);\n\n                            if (op->ch2 != -1)\n                                total +=\n                                    xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\t    if (ctxt->error != XPATH_EXPRESSION_OK) {\n                                xmlXPtrFreeLocationSet(newlocset);\n                                goto rangeto_error;\n\t\t\t    }\n\n                            res = valuePop(ctxt);\n                            range =\n                                xmlXPtrNewRangeNodeObject(oldset->nodeTab[i],\n                                                      res);\n                            if (range != NULL) {\n                                xmlXPtrLocationSetAdd(newlocset, range);\n                            }\n\n                            /*\n                             * Cleanup\n                             */\n                            if (res != NULL) {\n\t\t\t\txmlXPathReleaseObject(ctxt->context, res);\n\t\t\t    }\n                            if (ctxt->value == tmp) {\n                                res = valuePop(ctxt);\n\t\t\t\txmlXPathReleaseObject(ctxt->context, res);\n                            }\n                        }\n                    }\n                }\n\n                /*\n                 * The result is used as the new evaluation set.\n                 */\n                valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));\nrangeto_error:\n\t\txmlXPathReleaseObject(ctxt->context, obj);\n                ctxt->context->node = oldnode;\n                ctxt->context->contextSize = oldcs;\n                ctxt->context->proximityPosition = oldpp;\n                return (total);\n            }\n#endif /* LIBXML_XPTR_ENABLED */\n    }\n    xmlGenericError(xmlGenericErrorContext,\n                    \"XPath: unknown precompiled operation %d\\n\", op->op);\n    ctxt->error = XPATH_INVALID_OPERAND;",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146505,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  void Inspect::operator()(Complex_Selector_Ptr c)\n  {\n    Compound_Selector_Obj      head = c->head();\n    Complex_Selector_Obj            tail = c->tail();\n    Complex_Selector::Combinator comb = c->combinator();\n\n    if (comb == Complex_Selector::ANCESTOR_OF && (!head || head->empty())) {\n      if (tail) tail->perform(this);\n      return;\n    }\n\n    if (c->has_line_feed()) {\n      if (!(c->has_parent_ref())) {\n        append_optional_linefeed();\n        append_indentation();\n      }\n    }\n\n    if (head && head->length() != 0) head->perform(this);\n    bool is_empty = !head || head->length() == 0 || head->is_empty_reference();\n    bool is_tail = head && !head->is_empty_reference() && tail;\n    if (output_style() == COMPRESSED && comb != Complex_Selector::ANCESTOR_OF) scheduled_space = 0;\n\n    switch (comb) {\n      case Complex_Selector::ANCESTOR_OF:\n        if (is_tail) append_mandatory_space();\n      break;\n      case Complex_Selector::PARENT_OF:\n        append_optional_space();\n        append_string(\">\");\n        append_optional_space();\n      break;\n      case Complex_Selector::ADJACENT_TO:\n        append_optional_space();\n        append_string(\"+\");\n        append_optional_space();\n      break;\n      case Complex_Selector::REFERENCE:\n        append_mandatory_space();\n        append_string(\"/\");\n        c->reference()->perform(this);\n        append_string(\"/\");\n        append_mandatory_space();\n      break;\n      case Complex_Selector::PRECEDES:\n        if (is_empty) append_optional_space();\n        else append_mandatory_space();\n        append_string(\"~\");\n        if (tail) append_mandatory_space();\n        else append_optional_space();\n      break;\n      default: break;\n    }\n    if (tail && comb != Complex_Selector::ANCESTOR_OF) {\n      if (c->has_line_break()) append_optional_linefeed();\n    }\n    if (tail) tail->perform(this);\n    if (!tail && c->has_line_break()) {\n      if (output_style() == COMPACT) {\n        append_mandatory_space();\n      }\n    }\n  }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146566,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  void Inspect::operator()(Complex_Selector_Ptr c)\n  {\n    Compound_Selector_Obj      head = c->head();\n    Complex_Selector_Obj            tail = c->tail();\n    Complex_Selector::Combinator comb = c->combinator();\n\n    if (comb == Complex_Selector::ANCESTOR_OF && (!head || head->empty())) {\n      if (tail) tail->perform(this);\n      return;\n    }\n\n    if (c->has_line_feed()) {\n      if (!(c->has_parent_ref())) {\n        append_optional_linefeed();\n        append_indentation();\n      }\n    }\n\n    if (head && head->length() != 0) head->perform(this);\n    bool is_empty = !head || head->length() == 0 || head->is_empty_reference();\n    bool is_tail = head && !head->is_empty_reference() && tail;\n    if (output_style() == COMPRESSED && comb != Complex_Selector::ANCESTOR_OF) scheduled_space = 0;\n\n    switch (comb) {\n      case Complex_Selector::ANCESTOR_OF:\n        if (is_tail) append_mandatory_space();\n      break;\n      case Complex_Selector::PARENT_OF:\n        append_optional_space();\n        append_string(\">\");\n        append_optional_space();\n      break;\n      case Complex_Selector::ADJACENT_TO:\n        append_optional_space();\n        append_string(\"+\");\n        append_optional_space();\n      break;\n      case Complex_Selector::REFERENCE:\n        append_mandatory_space();\n        append_string(\"/\");\n        if (c->reference()) c->reference()->perform(this);\n        append_string(\"/\");\n        append_mandatory_space();\n      break;\n      case Complex_Selector::PRECEDES:\n        if (is_empty) append_optional_space();\n        else append_mandatory_space();\n        append_string(\"~\");\n        if (tail) append_mandatory_space();\n        else append_optional_space();\n      break;\n      default: break;\n    }\n    if (tail && comb != Complex_Selector::ANCESTOR_OF) {\n      if (c->has_line_break()) append_optional_linefeed();\n    }\n    if (tail) tail->perform(this);\n    if (!tail && c->has_line_break()) {\n      if (output_style() == COMPACT) {\n        append_mandatory_space();\n      }\n    }\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146567,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "php_stream *php_stream_url_wrap_http_ex(php_stream_wrapper *wrapper,\n\t\tconst char *path, const char *mode, int options, zend_string **opened_path,\n\t\tphp_stream_context *context, int redirect_max, int flags STREAMS_DC) /* {{{ */\n{\n\tphp_stream *stream = NULL;\n\tphp_url *resource = NULL;\n\tint use_ssl;\n\tint use_proxy = 0;\n\tchar *scratch = NULL;\n\tzend_string *tmp = NULL;\n\tchar *ua_str = NULL;\n\tzval *ua_zval = NULL, *tmpzval = NULL, ssl_proxy_peer_name;\n\tsize_t scratch_len = 0;\n\tchar location[HTTP_HEADER_BLOCK_SIZE];\n\tzval response_header;\n\tint reqok = 0;\n\tchar *http_header_line = NULL;\n\tchar tmp_line[128];\n\tsize_t chunk_size = 0, file_size = 0;\n\tint eol_detect = 0;\n\tchar *transport_string;\n\tzend_string *errstr = NULL;\n\tsize_t transport_len;\n\tint have_header = 0;\n\tzend_bool request_fulluri = 0, ignore_errors = 0;\n\tchar *protocol_version = NULL;\n\tint protocol_version_len = 3; /* Default: \"1.0\" */\n\tstruct timeval timeout;\n\tchar *user_headers = NULL;\n\tint header_init = ((flags & HTTP_WRAPPER_HEADER_INIT) != 0);\n\tint redirected = ((flags & HTTP_WRAPPER_REDIRECTED) != 0);\n\tzend_bool follow_location = 1;\n\tphp_stream_filter *transfer_encoding = NULL;\n\tint response_code;\n\tzend_array *symbol_table;\n\n\tZVAL_UNDEF(&response_header);\n\ttmp_line[0] = '\\0';\n\n\tif (redirect_max < 1) {\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"Redirection limit reached, aborting\");\n\t\treturn NULL;\n\t}\n\n\tresource = php_url_parse(path);\n\tif (resource == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (strncasecmp(resource->scheme, \"http\", sizeof(\"http\")) && strncasecmp(resource->scheme, \"https\", sizeof(\"https\"))) {\n\t\tif (!context ||\n\t\t\t(tmpzval = php_stream_context_get_option(context, wrapper->wops->label, \"proxy\")) == NULL ||\n\t\t\tZ_TYPE_P(tmpzval) != IS_STRING ||\n\t\t\tZ_STRLEN_P(tmpzval) <= 0) {\n\t\t\tphp_url_free(resource);\n\t\t\treturn php_stream_open_wrapper_ex(path, mode, REPORT_ERRORS, NULL, context);\n\t\t}\n\t\t/* Called from a non-http wrapper with http proxying requested (i.e. ftp) */\n\t\trequest_fulluri = 1;\n\t\tuse_ssl = 0;\n\t\tuse_proxy = 1;\n\n\t\ttransport_len = Z_STRLEN_P(tmpzval);\n\t\ttransport_string = estrndup(Z_STRVAL_P(tmpzval), Z_STRLEN_P(tmpzval));\n\t} else {\n\t\t/* Normal http request (possibly with proxy) */\n\n\t\tif (strpbrk(mode, \"awx+\")) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options, \"HTTP wrapper does not support writeable connections\");\n\t\t\tphp_url_free(resource);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tuse_ssl = resource->scheme && (strlen(resource->scheme) > 4) && resource->scheme[4] == 's';\n\t\t/* choose default ports */\n\t\tif (use_ssl && resource->port == 0)\n\t\t\tresource->port = 443;\n\t\telse if (resource->port == 0)\n\t\t\tresource->port = 80;\n\n\t\tif (context &&\n\t\t\t(tmpzval = php_stream_context_get_option(context, wrapper->wops->label, \"proxy\")) != NULL &&\n\t\t\tZ_TYPE_P(tmpzval) == IS_STRING &&\n\t\t\tZ_STRLEN_P(tmpzval) > 0) {\n\t\t\tuse_proxy = 1;\n\t\t\ttransport_len = Z_STRLEN_P(tmpzval);\n\t\t\ttransport_string = estrndup(Z_STRVAL_P(tmpzval), Z_STRLEN_P(tmpzval));\n\t\t} else {\n\t\t\ttransport_len = spprintf(&transport_string, 0, \"%s://%s:%d\", use_ssl ? \"ssl\" : \"tcp\", resource->host, resource->port);\n\t\t}\n\t}\n\n\tif (context && (tmpzval = php_stream_context_get_option(context, wrapper->wops->label, \"timeout\")) != NULL) {\n\t\tdouble d = zval_get_double(tmpzval);\n#ifndef PHP_WIN32\n\t\ttimeout.tv_sec = (time_t) d;\n\t\ttimeout.tv_usec = (size_t) ((d - timeout.tv_sec) * 1000000);\n#else\n\t\ttimeout.tv_sec = (long) d;\n\t\ttimeout.tv_usec = (long) ((d - timeout.tv_sec) * 1000000);\n#endif\n\t} else {\n#ifndef PHP_WIN32\n\t\ttimeout.tv_sec = FG(default_socket_timeout);\n#else\n\t\ttimeout.tv_sec = (long)FG(default_socket_timeout);\n#endif\n\t\ttimeout.tv_usec = 0;\n\t}\n\n\tstream = php_stream_xport_create(transport_string, transport_len, options,\n\t\t\tSTREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT,\n\t\t\tNULL, &timeout, context, &errstr, NULL);\n\n\tif (stream) {\n\t\tphp_stream_set_option(stream, PHP_STREAM_OPTION_READ_TIMEOUT, 0, &timeout);\n\t}\n\n\tif (errstr) {\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"%s\", ZSTR_VAL(errstr));\n\t\tzend_string_release(errstr);\n\t\terrstr = NULL;\n\t}\n\n\tefree(transport_string);\n\n\tif (stream && use_proxy && use_ssl) {\n\t\tsmart_str header = {0};\n\n\t\t/* Set peer_name or name verification will try to use the proxy server name */\n\t\tif (!context || (tmpzval = php_stream_context_get_option(context, \"ssl\", \"peer_name\")) == NULL) {\n\t\t\tZVAL_STRING(&ssl_proxy_peer_name, resource->host);\n\t\t\tphp_stream_context_set_option(PHP_STREAM_CONTEXT(stream), \"ssl\", \"peer_name\", &ssl_proxy_peer_name);\n\t\t\tzval_ptr_dtor(&ssl_proxy_peer_name);\n\t\t}\n\n\t\tsmart_str_appendl(&header, \"CONNECT \", sizeof(\"CONNECT \")-1);\n\t\tsmart_str_appends(&header, resource->host);\n\t\tsmart_str_appendc(&header, ':');\n\t\tsmart_str_append_unsigned(&header, resource->port);\n\t\tsmart_str_appendl(&header, \" HTTP/1.0\\r\\n\", sizeof(\" HTTP/1.0\\r\\n\")-1);\n\n\t    /* check if we have Proxy-Authorization header */\n\t\tif (context && (tmpzval = php_stream_context_get_option(context, \"http\", \"header\")) != NULL) {\n\t\t\tchar *s, *p;\n\n\t\t\tif (Z_TYPE_P(tmpzval) == IS_ARRAY) {\n\t\t\t\tzval *tmpheader = NULL;\n\n\t\t\t\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(tmpzval), tmpheader) {\n\t\t\t\t\tif (Z_TYPE_P(tmpheader) == IS_STRING) {\n\t\t\t\t\t\ts = Z_STRVAL_P(tmpheader);\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\twhile (*s == ' ' || *s == '\\t') s++;\n\t\t\t\t\t\t\tp = s;\n\t\t\t\t\t\t\twhile (*p != 0 && *p != ':' && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\tif (*p == ':') {\n\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t\tif (p - s == sizeof(\"Proxy-Authorization:\") - 1 &&\n\t\t\t\t\t\t\t\t    zend_binary_strcasecmp(s, sizeof(\"Proxy-Authorization:\") - 1,\n\t\t\t\t\t\t\t\t        \"Proxy-Authorization:\", sizeof(\"Proxy-Authorization:\") - 1) == 0) {\n\t\t\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\t\t\tsmart_str_appendl(&header, s, p - s);\n\t\t\t\t\t\t\t\t\tsmart_str_appendl(&header, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\t\t\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts = p;\n\t\t\t\t\t\t\twhile (*s == '\\r' || *s == '\\n') s++;\n\t\t\t\t\t\t} while (*s != 0);\n\t\t\t\t\t}\n\t\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t\t} else if (Z_TYPE_P(tmpzval) == IS_STRING && Z_STRLEN_P(tmpzval)) {\n\t\t\t\ts = Z_STRVAL_P(tmpzval);\n\t\t\t\tdo {\n\t\t\t\t\twhile (*s == ' ' || *s == '\\t') s++;\n\t\t\t\t\tp = s;\n\t\t\t\t\twhile (*p != 0 && *p != ':' && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\tif (*p == ':') {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tif (p - s == sizeof(\"Proxy-Authorization:\") - 1 &&\n\t\t\t\t\t\t    zend_binary_strcasecmp(s, sizeof(\"Proxy-Authorization:\") - 1,\n\t\t\t\t\t\t        \"Proxy-Authorization:\", sizeof(\"Proxy-Authorization:\") - 1) == 0) {\n\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\tsmart_str_appendl(&header, s, p - s);\n\t\t\t\t\t\t\tsmart_str_appendl(&header, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ts = p;\n\t\t\t\t\twhile (*s == '\\r' || *s == '\\n') s++;\n\t\t\t\t} while (*s != 0);\n\t\t\t}\n\t\t}\nfinish:\n\t\tsmart_str_appendl(&header, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\n\t\tif (php_stream_write(stream, ZSTR_VAL(header.s), ZSTR_LEN(header.s)) != ZSTR_LEN(header.s)) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options, \"Cannot connect to HTTPS server through proxy\");\n\t\t\tphp_stream_close(stream);\n\t\t\tstream = NULL;\n\t\t}\n \t \tsmart_str_free(&header);\n\n \t \tif (stream) {\n \t \t\tchar header_line[HTTP_HEADER_BLOCK_SIZE];\n\n\t\t\t/* get response header */\n\t\t\twhile (php_stream_gets(stream, header_line, HTTP_HEADER_BLOCK_SIZE-1) != NULL) {\n\t\t\t\tif (header_line[0] == '\\n' ||\n\t\t\t\t    header_line[0] == '\\r' ||\n\t\t\t\t    header_line[0] == '\\0') {\n\t\t\t\t  break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* enable SSL transport layer */\n\t\tif (stream) {\n\t\t\tif (php_stream_xport_crypto_setup(stream, STREAM_CRYPTO_METHOD_SSLv23_CLIENT, NULL) < 0 ||\n\t\t\t    php_stream_xport_crypto_enable(stream, 1) < 0) {\n\t\t\t\tphp_stream_wrapper_log_error(wrapper, options, \"Cannot connect to HTTPS server through proxy\");\n\t\t\t\tphp_stream_close(stream);\n\t\t\t\tstream = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (stream == NULL)\n\t\tgoto out;\n\n\t/* avoid buffering issues while reading header */\n\tif (options & STREAM_WILL_CAST)\n\t\tchunk_size = php_stream_set_chunk_size(stream, 1);\n\n\t/* avoid problems with auto-detecting when reading the headers -> the headers\n\t * are always in canonical \\r\\n format */\n\teol_detect = stream->flags & (PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC);\n\tstream->flags &= ~(PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC);\n\n\tphp_stream_context_set(stream, context);\n\n\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_CONNECT, NULL, 0);\n\n\tif (header_init && context && (tmpzval = php_stream_context_get_option(context, \"http\", \"max_redirects\")) != NULL) {\n\t\tredirect_max = (int)zval_get_long(tmpzval);\n\t}\n\n\tif (context && (tmpzval = php_stream_context_get_option(context, \"http\", \"method\")) != NULL) {\n\t\tif (Z_TYPE_P(tmpzval) == IS_STRING && Z_STRLEN_P(tmpzval) > 0) {\n\t\t\t/* As per the RFC, automatically redirected requests MUST NOT use other methods than\n\t\t\t * GET and HEAD unless it can be confirmed by the user */\n\t\t\tif (!redirected\n\t\t\t\t|| (Z_STRLEN_P(tmpzval) == 3 && memcmp(\"GET\", Z_STRVAL_P(tmpzval), 3) == 0)\n\t\t\t\t|| (Z_STRLEN_P(tmpzval) == 4 && memcmp(\"HEAD\",Z_STRVAL_P(tmpzval), 4) == 0)\n\t\t\t) {\n\t\t\t\tscratch_len = strlen(path) + 29 + Z_STRLEN_P(tmpzval);\n\t\t\t\tscratch = emalloc(scratch_len);\n\t\t\t\tstrlcpy(scratch, Z_STRVAL_P(tmpzval), Z_STRLEN_P(tmpzval) + 1);\n\t\t\t\tstrncat(scratch, \" \", 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (context && (tmpzval = php_stream_context_get_option(context, \"http\", \"protocol_version\")) != NULL) {\n\t\tprotocol_version_len = (int)spprintf(&protocol_version, 0, \"%.1F\", zval_get_double(tmpzval));\n\t}\n\n\tif (!scratch) {\n\t\tscratch_len = strlen(path) + 29 + protocol_version_len;\n\t\tscratch = emalloc(scratch_len);\n\t\tstrncpy(scratch, \"GET \", scratch_len);\n\t}\n\n\t/* Should we send the entire path in the request line, default to no. */\n\tif (!request_fulluri && context &&\n\t\t(tmpzval = php_stream_context_get_option(context, \"http\", \"request_fulluri\")) != NULL) {\n\t\trequest_fulluri = zend_is_true(tmpzval);\n\t}\n\n\tif (request_fulluri) {\n\t\t/* Ask for everything */\n\t\tstrcat(scratch, path);\n\t} else {\n\t\t/* Send the traditional /path/to/file?query_string */\n\n\t\t/* file */\n\t\tif (resource->path && *resource->path) {\n\t\t\tstrlcat(scratch, resource->path, scratch_len);\n\t\t} else {\n\t\t\tstrlcat(scratch, \"/\", scratch_len);\n\t\t}\n\n\t\t/* query string */\n\t\tif (resource->query) {\n\t\t\tstrlcat(scratch, \"?\", scratch_len);\n\t\t\tstrlcat(scratch, resource->query, scratch_len);\n\t\t}\n\t}\n\n\t/* protocol version we are speaking */\n\tif (protocol_version) {\n\t\tstrlcat(scratch, \" HTTP/\", scratch_len);\n\t\tstrlcat(scratch, protocol_version, scratch_len);\n\t\tstrlcat(scratch, \"\\r\\n\", scratch_len);\n\t} else {\n\t\tstrlcat(scratch, \" HTTP/1.0\\r\\n\", scratch_len);\n\t}\n\n\t/* send it */\n\tphp_stream_write(stream, scratch, strlen(scratch));\n\n\tif (context && (tmpzval = php_stream_context_get_option(context, \"http\", \"header\")) != NULL) {\n\t\ttmp = NULL;\n\n\t\tif (Z_TYPE_P(tmpzval) == IS_ARRAY) {\n\t\t\tzval *tmpheader = NULL;\n\t\t\tsmart_str tmpstr = {0};\n\n\t\t\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(tmpzval), tmpheader) {\n\t\t\t\tif (Z_TYPE_P(tmpheader) == IS_STRING) {\n\t\t\t\t\tsmart_str_append(&tmpstr, Z_STR_P(tmpheader));\n\t\t\t\t\tsmart_str_appendl(&tmpstr, \"\\r\\n\", sizeof(\"\\r\\n\") - 1);\n\t\t\t\t}\n\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t\tsmart_str_0(&tmpstr);\n\t\t\t/* Remove newlines and spaces from start and end. there's at least one extra \\r\\n at the end that needs to go. */\n\t\t\tif (tmpstr.s) {\n\t\t\t\ttmp = php_trim(tmpstr.s, NULL, 0, 3);\n\t\t\t\tsmart_str_free(&tmpstr);\n\t\t\t}\n\t\t} else if (Z_TYPE_P(tmpzval) == IS_STRING && Z_STRLEN_P(tmpzval)) {\n\t\t\t/* Remove newlines and spaces from start and end php_trim will estrndup() */\n\t\t\ttmp = php_trim(Z_STR_P(tmpzval), NULL, 0, 3);\n\t\t}\n\t\tif (tmp && ZSTR_LEN(tmp)) {\n\t\t\tchar *s;\n\t\t\tchar *t;\n\n\t\t\tuser_headers = estrndup(ZSTR_VAL(tmp), ZSTR_LEN(tmp));\n\n\t\t\tif (ZSTR_IS_INTERNED(tmp)) {\n\t\t\t\ttmp = zend_string_init(ZSTR_VAL(tmp), ZSTR_LEN(tmp), 0);\n\t\t\t} else if (GC_REFCOUNT(tmp) > 1) {\n\t\t\t\tGC_REFCOUNT(tmp)--;\n\t\t\t\ttmp = zend_string_init(ZSTR_VAL(tmp), ZSTR_LEN(tmp), 0);\n\t\t\t}\n\n\t\t\t/* Make lowercase for easy comparison against 'standard' headers */\n\t\t\tphp_strtolower(ZSTR_VAL(tmp), ZSTR_LEN(tmp));\n\t\t\tt = ZSTR_VAL(tmp);\n\n\t\t\tif (!header_init) {\n\t\t\t\t/* strip POST headers on redirect */\n\t\t\t\tstrip_header(user_headers, t, \"content-length:\");\n\t\t\t\tstrip_header(user_headers, t, \"content-type:\");\n\t\t\t}\n\n\t\t\tif ((s = strstr(t, \"user-agent:\")) &&\n\t\t\t    (s == t || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_USER_AGENT;\n\t\t\t}\n\t\t\tif ((s = strstr(t, \"host:\")) &&\n\t\t\t    (s == t || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_HOST;\n\t\t\t}\n\t\t\tif ((s = strstr(t, \"from:\")) &&\n\t\t\t    (s == t || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_FROM;\n\t\t\t\t}\n\t\t\tif ((s = strstr(t, \"authorization:\")) &&\n\t\t\t    (s == t || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_AUTH;\n\t\t\t}\n\t\t\tif ((s = strstr(t, \"content-length:\")) &&\n\t\t\t    (s == t || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_CONTENT_LENGTH;\n\t\t\t}\n\t\t\tif ((s = strstr(t, \"content-type:\")) &&\n\t\t\t    (s == t || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_TYPE;\n\t\t\t}\n\t\t\tif ((s = strstr(t, \"connection:\")) &&\n\t\t\t    (s == t || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_CONNECTION;\n\t\t\t}\n\t\t\t/* remove Proxy-Authorization header */\n\t\t\tif (use_proxy && use_ssl && (s = strstr(t, \"proxy-authorization:\")) &&\n\t\t\t    (s == t || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\tchar *p = s + sizeof(\"proxy-authorization:\") - 1;\n\n\t\t\t\twhile (s > t && (*(s-1) == ' ' || *(s-1) == '\\t')) s--;\n\t\t\t\twhile (*p != 0 && *p != '\\r' && *p != '\\n') p++;\n\t\t\t\twhile (*p == '\\r' || *p == '\\n') p++;\n\t\t\t\tif (*p == 0) {\n\t\t\t\t\tif (s == t) {\n\t\t\t\t\t\tefree(user_headers);\n\t\t\t\t\t\tuser_headers = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\twhile (s > t && (*(s-1) == '\\r' || *(s-1) == '\\n')) s--;\n\t\t\t\t\t\tuser_headers[s - t] = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmemmove(user_headers + (s - t), user_headers + (p - t), strlen(p) + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tif (tmp) {\n\t\t\tzend_string_release(tmp);\n\t\t}\n\t}\n\n\t/* auth header if it was specified */\n\tif (((have_header & HTTP_HEADER_AUTH) == 0) && resource->user) {\n\t\tzend_string *stmp;\n\t\t/* decode the strings first */\n\t\tphp_url_decode(resource->user, strlen(resource->user));\n\n\t\t/* scratch is large enough, since it was made large enough for the whole URL */\n\t\tstrcpy(scratch, resource->user);\n\t\tstrcat(scratch, \":\");\n\n\t\t/* Note: password is optional! */\n\t\tif (resource->pass) {\n\t\t\tphp_url_decode(resource->pass, strlen(resource->pass));\n\t\t\tstrcat(scratch, resource->pass);\n\t\t}\n\n\t\tstmp = php_base64_encode((unsigned char*)scratch, strlen(scratch));\n\n\t\tif (snprintf(scratch, scratch_len, \"Authorization: Basic %s\\r\\n\", ZSTR_VAL(stmp)) > 0) {\n\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t\t\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_AUTH_REQUIRED, NULL, 0);\n\t\t}\n\n\t\tzend_string_free(stmp);\n\t}\n\n\t/* if the user has configured who they are, send a From: line */\n\tif (((have_header & HTTP_HEADER_FROM) == 0) && FG(from_address)) {\n\t\tif (snprintf(scratch, scratch_len, \"From: %s\\r\\n\", FG(from_address)) > 0)\n\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t}\n\n\t/* Send Host: header so name-based virtual hosts work */\n\tif ((have_header & HTTP_HEADER_HOST) == 0) {\n\t\tif ((use_ssl && resource->port != 443 && resource->port != 0) ||\n\t\t\t(!use_ssl && resource->port != 80 && resource->port != 0)) {\n\t\t\tif (snprintf(scratch, scratch_len, \"Host: %s:%i\\r\\n\", resource->host, resource->port) > 0)\n\t\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t\t} else {\n\t\t\tif (snprintf(scratch, scratch_len, \"Host: %s\\r\\n\", resource->host) > 0) {\n\t\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Send a Connection: close header to avoid hanging when the server\n\t * interprets the RFC literally and establishes a keep-alive connection,\n\t * unless the user specifically requests something else by specifying a\n\t * Connection header in the context options. Send that header even for\n\t * HTTP/1.0 to avoid issues when the server respond with a HTTP/1.1\n\t * keep-alive response, which is the preferred response type. */\n\tif ((have_header & HTTP_HEADER_CONNECTION) == 0) {\n\t\tphp_stream_write_string(stream, \"Connection: close\\r\\n\");\n\t}\n\n\tif (context &&\n\t    (ua_zval = php_stream_context_get_option(context, \"http\", \"user_agent\")) != NULL &&\n\t\tZ_TYPE_P(ua_zval) == IS_STRING) {\n\t\tua_str = Z_STRVAL_P(ua_zval);\n\t} else if (FG(user_agent)) {\n\t\tua_str = FG(user_agent);\n\t}\n\n\tif (((have_header & HTTP_HEADER_USER_AGENT) == 0) && ua_str) {\n#define _UA_HEADER \"User-Agent: %s\\r\\n\"\n\t\tchar *ua;\n\t\tsize_t ua_len;\n\n\t\tua_len = sizeof(_UA_HEADER) + strlen(ua_str);\n\n\t\t/* ensure the header is only sent if user_agent is not blank */\n\t\tif (ua_len > sizeof(_UA_HEADER)) {\n\t\t\tua = emalloc(ua_len + 1);\n\t\t\tif ((ua_len = slprintf(ua, ua_len, _UA_HEADER, ua_str)) > 0) {\n\t\t\t\tua[ua_len] = 0;\n\t\t\t\tphp_stream_write(stream, ua, ua_len);\n\t\t\t} else {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Cannot construct User-agent header\");\n\t\t\t}\n\t\t\tefree(ua);\n\t\t}\n\t}\n\n\tif (user_headers) {\n\t\t/* A bit weird, but some servers require that Content-Length be sent prior to Content-Type for POST\n\t\t * see bug #44603 for details. Since Content-Type maybe part of user's headers we need to do this check first.\n\t\t */\n\t\tif (\n\t\t\t\theader_init &&\n\t\t\t\tcontext &&\n\t\t\t\t!(have_header & HTTP_HEADER_CONTENT_LENGTH) &&\n\t\t\t\t(tmpzval = php_stream_context_get_option(context, \"http\", \"content\")) != NULL &&\n\t\t\t\tZ_TYPE_P(tmpzval) == IS_STRING && Z_STRLEN_P(tmpzval) > 0\n\t\t) {\n\t\t\tscratch_len = slprintf(scratch, scratch_len, \"Content-Length: %d\\r\\n\", Z_STRLEN_P(tmpzval));\n\t\t\tphp_stream_write(stream, scratch, scratch_len);\n\t\t\thave_header |= HTTP_HEADER_CONTENT_LENGTH;\n\t\t}\n\n\t\tphp_stream_write(stream, user_headers, strlen(user_headers));\n\t\tphp_stream_write(stream, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\tefree(user_headers);\n\t}\n\n\t/* Request content, such as for POST requests */\n\tif (header_init && context &&\n\t\t(tmpzval = php_stream_context_get_option(context, \"http\", \"content\")) != NULL &&\n\t\tZ_TYPE_P(tmpzval) == IS_STRING && Z_STRLEN_P(tmpzval) > 0) {\n\t\tif (!(have_header & HTTP_HEADER_CONTENT_LENGTH)) {\n\t\t\tscratch_len = slprintf(scratch, scratch_len, \"Content-Length: %d\\r\\n\", Z_STRLEN_P(tmpzval));\n\t\t\tphp_stream_write(stream, scratch, scratch_len);\n\t\t}\n\t\tif (!(have_header & HTTP_HEADER_TYPE)) {\n\t\t\tphp_stream_write(stream, \"Content-Type: application/x-www-form-urlencoded\\r\\n\",\n\t\t\t\tsizeof(\"Content-Type: application/x-www-form-urlencoded\\r\\n\") - 1);\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Content-type not specified assuming application/x-www-form-urlencoded\");\n\t\t}\n\t\tphp_stream_write(stream, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\tphp_stream_write(stream, Z_STRVAL_P(tmpzval), Z_STRLEN_P(tmpzval));\n\t} else {\n\t\tphp_stream_write(stream, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t}\n\n\tlocation[0] = '\\0';\n\n\tsymbol_table = zend_rebuild_symbol_table();\n\n\tif (header_init) {\n\t\tzval ztmp;\n\t\tarray_init(&ztmp);\n\t\tzend_set_local_var_str(\"http_response_header\", sizeof(\"http_response_header\")-1, &ztmp, 0);\n\t}\n\n\t{\n\t\tzval *response_header_ptr = zend_hash_str_find_ind(symbol_table, \"http_response_header\", sizeof(\"http_response_header\")-1);\n\t\tif (!response_header_ptr || Z_TYPE_P(response_header_ptr) != IS_ARRAY) {\n\t\t\tZVAL_UNDEF(&response_header);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tZVAL_COPY(&response_header, response_header_ptr);\n\t\t}\n\t}\n\n\tif (!php_stream_eof(stream)) {\n\t\tsize_t tmp_line_len;\n\t\t/* get response header */\n\n\t\tif (php_stream_get_line(stream, tmp_line, sizeof(tmp_line) - 1, &tmp_line_len) != NULL) {\n\t\t\tzval http_response;\n\n\t\t\tif (tmp_line_len > 9) {\n\t\t\t\tresponse_code = atoi(tmp_line + 9);\n\t\t\t} else {\n\t\t\t\tresponse_code = 0;\n\t\t\t}\n\t\t\tif (context && NULL != (tmpzval = php_stream_context_get_option(context, \"http\", \"ignore_errors\"))) {\n\t\t\t\tignore_errors = zend_is_true(tmpzval);\n\t\t\t}\n\t\t\t/* when we request only the header, don't fail even on error codes */\n\t\t\tif ((options & STREAM_ONLY_GET_HEADERS) || ignore_errors) {\n\t\t\t\treqok = 1;\n\t\t\t}\n\n\t\t\t/* status codes of 1xx are \"informational\", and will be followed by a real response\n\t\t\t * e.g \"100 Continue\". RFC 7231 states that unexpected 1xx status MUST be parsed,\n\t\t\t * and MAY be ignored. As such, we need to skip ahead to the \"real\" status*/\n\t\t\tif (response_code >= 100 && response_code < 200) {\n\t\t\t\t/* consume lines until we find a line starting 'HTTP/1' */\n\t\t\t\twhile (\n\t\t\t\t\t!php_stream_eof(stream)\n\t\t\t\t\t&& php_stream_get_line(stream, tmp_line, sizeof(tmp_line) - 1, &tmp_line_len) != NULL\n\t\t\t\t\t&& ( tmp_line_len < sizeof(\"HTTP/1\") - 1 || strncasecmp(tmp_line, \"HTTP/1\", sizeof(\"HTTP/1\") - 1) )\n\t\t\t\t);\n\n\t\t\t\tif (tmp_line_len > 9) {\n\t\t\t\t\tresponse_code = atoi(tmp_line + 9);\n\t\t\t\t} else {\n\t\t\t\t\tresponse_code = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* all status codes in the 2xx range are defined by the specification as successful;\n\t\t\t * all status codes in the 3xx range are for redirection, and so also should never\n\t\t\t * fail */\n\t\t\tif (response_code >= 200 && response_code < 400) {\n\t\t\t\treqok = 1;\n\t\t\t} else {\n\t\t\t\tswitch(response_code) {\n\t\t\t\t\tcase 403:\n\t\t\t\t\t\tphp_stream_notify_error(context, PHP_STREAM_NOTIFY_AUTH_RESULT,\n\t\t\t\t\t\t\t\ttmp_line, response_code);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* safety net in the event tmp_line == NULL */\n\t\t\t\t\t\tif (!tmp_line_len) {\n\t\t\t\t\t\t\ttmp_line[0] = '\\0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tphp_stream_notify_error(context, PHP_STREAM_NOTIFY_FAILURE,\n\t\t\t\t\t\t\t\ttmp_line, response_code);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tmp_line[tmp_line_len - 1] == '\\n') {\n\t\t\t\t--tmp_line_len;\n\t\t\t\tif (tmp_line[tmp_line_len - 1] == '\\r') {\n\t\t\t\t\t--tmp_line_len;\n\t\t\t\t}\n\t\t\t}\n\t\t\tZVAL_STRINGL(&http_response, tmp_line, tmp_line_len);\n\t\t\tzend_hash_next_index_insert(Z_ARRVAL(response_header), &http_response);\n\t\t}\n\t} else {\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"HTTP request failed, unexpected end of socket!\");\n\t\tgoto out;\n\t}\n\n\t/* read past HTTP headers */\n\n\thttp_header_line = emalloc(HTTP_HEADER_BLOCK_SIZE);\n\n\twhile (!php_stream_eof(stream)) {\n\t\tsize_t http_header_line_length;\n\t\t\n\t\tif (php_stream_get_line(stream, http_header_line, HTTP_HEADER_BLOCK_SIZE, &http_header_line_length) && *http_header_line != '\\n' && *http_header_line != '\\r') {\n\t\t\tchar *e = http_header_line + http_header_line_length - 1;\n\t\t\tchar *http_header_value;\n\t\t\tif (*e != '\\n') {\n\t\t\t\tdo { /* partial header */\n\t\t\t\t\tif (php_stream_get_line(stream, http_header_line, HTTP_HEADER_BLOCK_SIZE, &http_header_line_length) == NULL) {\n\t\t\t\t\t\tphp_stream_wrapper_log_error(wrapper, options, \"Failed to read HTTP headers\");\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\te = http_header_line + http_header_line_length - 1;\n\t\t\t\t} while (*e != '\\n');\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (e >= http_header_line && (*e == '\\n' || *e == '\\r')) {\n\t\t\t\te--;\n\t\t\t}\n\n\t\t\t/* The primary definition of an HTTP header in RFC 7230 states:\n\t\t\t * > Each header field consists of a case-insensitive field name followed\n\t\t\t * > by a colon (\":\"), optional leading whitespace, the field value, and\n\t\t\t * > optional trailing whitespace. */\n\n\t\t\t/* Strip trailing whitespace */\n\t\t\twhile (e >= http_header_line && (*e == ' ' || *e == '\\t')) {\n\t\t\t\te--;\n\t\t\t}\n\n\t\t\t/* Terminate header line */\n\t\t\te++;\n\t\t\t*e = '\\0';\n\t\t\thttp_header_line_length = e - http_header_line;\n\n\t\t\thttp_header_value = memchr(http_header_line, ':', http_header_line_length);\n\t\t\tif (http_header_value) {\n\t\t\t\thttp_header_value++; /* Skip ':' */\n\n\t\t\t\t/* Strip leading whitespace */\n\t\t\t\twhile (http_header_value < e\n\t\t\t\t\t\t&& (*http_header_value == ' ' || *http_header_value == '\\t')) {\n\t\t\t\t\thttp_header_value++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!strncasecmp(http_header_line, \"Location:\", sizeof(\"Location:\")-1)) {\n\t\t\t\tif (context && (tmpzval = php_stream_context_get_option(context, \"http\", \"follow_location\")) != NULL) {\n\t\t\t\t\tfollow_location = zval_is_true(tmpzval);\n\t\t\t\t} else if (!((response_code >= 300 && response_code < 304)\n\t\t\t\t\t\t|| 307 == response_code || 308 == response_code)) {\n\t\t\t\t\t/* we shouldn't redirect automatically\n\t\t\t\t\tif follow_location isn't set and response_code not in (300, 301, 302, 303 and 307)\n\t\t\t\t\tsee http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.1\n\t\t\t\t\tRFC 7238 defines 308: http://tools.ietf.org/html/rfc7238 */\n\t\t\t\t\tfollow_location = 0;\n\t\t\t\t}\n\t\t\t\tstrlcpy(location, http_header_value, sizeof(location));\n\t\t\t} else if (!strncasecmp(http_header_line, \"Content-Type:\", sizeof(\"Content-Type:\")-1)) {\n\t\t\t\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_MIME_TYPE_IS, http_header_value, 0);\n\t\t\t} else if (!strncasecmp(http_header_line, \"Content-Length:\", sizeof(\"Content-Length\")-1)) {\n\t\t\t\tfile_size = atoi(http_header_value);\n\t\t\t\tphp_stream_notify_file_size(context, file_size, http_header_line, 0);\n\t\t\t} else if (\n\t\t\t\t!strncasecmp(http_header_line, \"Transfer-Encoding:\", sizeof(\"Transfer-Encoding\")-1)\n\t\t\t\t&& !strncasecmp(http_header_value, \"Chunked\", sizeof(\"Chunked\")-1)\n\t\t\t) {\n\n\t\t\t\t/* create filter to decode response body */\n\t\t\t\tif (!(options & STREAM_ONLY_GET_HEADERS)) {\n\t\t\t\t\tzend_long decode = 1;\n\n\t\t\t\t\tif (context && (tmpzval = php_stream_context_get_option(context, \"http\", \"auto_decode\")) != NULL) {\n\t\t\t\t\t\tdecode = zend_is_true(tmpzval);\n\t\t\t\t\t}\n\t\t\t\t\tif (decode) {\n\t\t\t\t\t\ttransfer_encoding = php_stream_filter_create(\"dechunk\", NULL, php_stream_is_persistent(stream));\n\t\t\t\t\t\tif (transfer_encoding) {\n\t\t\t\t\t\t\t/* don't store transfer-encodeing header */\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tzval http_header;\n\t\t\t\tZVAL_STRINGL(&http_header, http_header_line, http_header_line_length);\n\t\t\t\tzend_hash_next_index_insert(Z_ARRVAL(response_header), &http_header);\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!reqok || (location[0] != '\\0' && follow_location)) {\n\t\tif (!follow_location || (((options & STREAM_ONLY_GET_HEADERS) || ignore_errors) && redirect_max <= 1)) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (location[0] != '\\0')\n\t\t\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_REDIRECTED, location, 0);\n\n\t\tphp_stream_close(stream);\n\t\tstream = NULL;\n\n\t\tif (location[0] != '\\0') {\n\n\t\t\tchar new_path[HTTP_HEADER_BLOCK_SIZE];\n\t\t\tchar loc_path[HTTP_HEADER_BLOCK_SIZE];\n\n\t\t\t*new_path='\\0';\n\t\t\tif (strlen(location)<8 || (strncasecmp(location, \"http://\", sizeof(\"http://\")-1) &&\n\t\t\t\t\t\t\tstrncasecmp(location, \"https://\", sizeof(\"https://\")-1) &&\n\t\t\t\t\t\t\tstrncasecmp(location, \"ftp://\", sizeof(\"ftp://\")-1) &&\n\t\t\t\t\t\t\tstrncasecmp(location, \"ftps://\", sizeof(\"ftps://\")-1)))\n\t\t\t{\n\t\t\t\tif (*location != '/') {\n\t\t\t\t\tif (*(location+1) != '\\0' && resource->path) {\n\t\t\t\t\t\tchar *s = strrchr(resource->path, '/');\n\t\t\t\t\t\tif (!s) {\n\t\t\t\t\t\t\ts = resource->path;\n\t\t\t\t\t\t\tif (!s[0]) {\n\t\t\t\t\t\t\t\tefree(s);\n\t\t\t\t\t\t\t\ts = resource->path = estrdup(\"/\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t*s = '/';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts[1] = '\\0';\n\t\t\t\t\t\tif (resource->path && *(resource->path) == '/' && *(resource->path + 1) == '\\0') {\n\t\t\t\t\t\t\tsnprintf(loc_path, sizeof(loc_path) - 1, \"%s%s\", resource->path, location);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsnprintf(loc_path, sizeof(loc_path) - 1, \"%s/%s\", resource->path, location);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsnprintf(loc_path, sizeof(loc_path) - 1, \"/%s\", location);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstrlcpy(loc_path, location, sizeof(loc_path));\n\t\t\t\t}\n\t\t\t\tif ((use_ssl && resource->port != 443) || (!use_ssl && resource->port != 80)) {\n\t\t\t\t\tsnprintf(new_path, sizeof(new_path) - 1, \"%s://%s:%d%s\", resource->scheme, resource->host, resource->port, loc_path);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(new_path, sizeof(new_path) - 1, \"%s://%s%s\", resource->scheme, resource->host, loc_path);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstrlcpy(new_path, location, sizeof(new_path));\n\t\t\t}\n\n\t\t\tphp_url_free(resource);\n\t\t\t/* check for invalid redirection URLs */\n\t\t\tif ((resource = php_url_parse(new_path)) == NULL) {\n\t\t\t\tphp_stream_wrapper_log_error(wrapper, options, \"Invalid redirect URL! %s\", new_path);\n\t\t\t\tgoto out;\n\t\t\t}\n\n#define CHECK_FOR_CNTRL_CHARS(val) { \\\n\tif (val) { \\\n\t\tunsigned char *s, *e; \\\n\t\tsize_t l; \\\n\t\tl = php_url_decode(val, strlen(val)); \\\n\t\ts = (unsigned char*)val; e = s + l; \\\n\t\twhile (s < e) { \\\n\t\t\tif (iscntrl(*s)) { \\\n\t\t\t\tphp_stream_wrapper_log_error(wrapper, options, \"Invalid redirect URL! %s\", new_path); \\\n\t\t\t\tgoto out; \\\n\t\t\t} \\\n\t\t\ts++; \\\n\t\t} \\\n\t} \\\n}\n\t\t\t/* check for control characters in login, password & path */\n\t\t\tif (strncasecmp(new_path, \"http://\", sizeof(\"http://\") - 1) || strncasecmp(new_path, \"https://\", sizeof(\"https://\") - 1)) {\n\t\t\t\tCHECK_FOR_CNTRL_CHARS(resource->user)\n\t\t\t\tCHECK_FOR_CNTRL_CHARS(resource->pass)\n\t\t\t\tCHECK_FOR_CNTRL_CHARS(resource->path)\n\t\t\t}\n\t\t\tstream = php_stream_url_wrap_http_ex(wrapper, new_path, mode, options, opened_path, context, --redirect_max, HTTP_WRAPPER_REDIRECTED STREAMS_CC);\n\t\t} else {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options, \"HTTP request failed! %s\", tmp_line);\n\t\t}\n\t}\nout:\n\tif (protocol_version) {\n\t\tefree(protocol_version);\n\t}\n\n\tif (http_header_line) {\n\t\tefree(http_header_line);\n\t}\n\n\tif (scratch) {\n\t\tefree(scratch);\n\t}\n\n\tif (resource) {\n\t\tphp_url_free(resource);\n\t}\n\n\tif (stream) {\n\t\tif (header_init) {\n\t\t\tZVAL_COPY(&stream->wrapperdata, &response_header);\n\t\t}\n\t\tphp_stream_notify_progress_init(context, 0, file_size);\n\n\t\t/* Restore original chunk size now that we're done with headers */\n\t\tif (options & STREAM_WILL_CAST)\n\t\t\tphp_stream_set_chunk_size(stream, (int)chunk_size);\n\n\t\t/* restore the users auto-detect-line-endings setting */\n\t\tstream->flags |= eol_detect;\n\n\t\t/* as far as streams are concerned, we are now at the start of\n\t\t * the stream */\n\t\tstream->position = 0;\n\n\t\t/* restore mode */\n\t\tstrlcpy(stream->mode, mode, sizeof(stream->mode));\n\n\t\tif (transfer_encoding) {\n\t\t\tphp_stream_filter_append(&stream->readfilters, transfer_encoding);\n\t\t}\n\t} else {\n\t\tif (transfer_encoding) {\n\t\t\tphp_stream_filter_free(transfer_encoding);\n\t\t}\n\t}\n\n\tzval_ptr_dtor(&response_header);\n\n\treturn stream;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146764,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "php_stream *php_stream_url_wrap_http_ex(php_stream_wrapper *wrapper,\n\t\tconst char *path, const char *mode, int options, zend_string **opened_path,\n\t\tphp_stream_context *context, int redirect_max, int flags STREAMS_DC) /* {{{ */\n{\n\tphp_stream *stream = NULL;\n\tphp_url *resource = NULL;\n\tint use_ssl;\n\tint use_proxy = 0;\n\tchar *scratch = NULL;\n\tzend_string *tmp = NULL;\n\tchar *ua_str = NULL;\n\tzval *ua_zval = NULL, *tmpzval = NULL, ssl_proxy_peer_name;\n\tsize_t scratch_len = 0;\n\tchar location[HTTP_HEADER_BLOCK_SIZE];\n\tzval response_header;\n\tint reqok = 0;\n\tchar *http_header_line = NULL;\n\tchar tmp_line[128];\n\tsize_t chunk_size = 0, file_size = 0;\n\tint eol_detect = 0;\n\tchar *transport_string;\n\tzend_string *errstr = NULL;\n\tsize_t transport_len;\n\tint have_header = 0;\n\tzend_bool request_fulluri = 0, ignore_errors = 0;\n\tchar *protocol_version = NULL;\n\tint protocol_version_len = 3; /* Default: \"1.0\" */\n\tstruct timeval timeout;\n\tchar *user_headers = NULL;\n\tint header_init = ((flags & HTTP_WRAPPER_HEADER_INIT) != 0);\n\tint redirected = ((flags & HTTP_WRAPPER_REDIRECTED) != 0);\n\tzend_bool follow_location = 1;\n\tphp_stream_filter *transfer_encoding = NULL;\n\tint response_code;\n\tzend_array *symbol_table;\n\n\tZVAL_UNDEF(&response_header);\n\ttmp_line[0] = '\\0';\n\n\tif (redirect_max < 1) {\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"Redirection limit reached, aborting\");\n\t\treturn NULL;\n\t}\n\n\tresource = php_url_parse(path);\n\tif (resource == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (strncasecmp(resource->scheme, \"http\", sizeof(\"http\")) && strncasecmp(resource->scheme, \"https\", sizeof(\"https\"))) {\n\t\tif (!context ||\n\t\t\t(tmpzval = php_stream_context_get_option(context, wrapper->wops->label, \"proxy\")) == NULL ||\n\t\t\tZ_TYPE_P(tmpzval) != IS_STRING ||\n\t\t\tZ_STRLEN_P(tmpzval) <= 0) {\n\t\t\tphp_url_free(resource);\n\t\t\treturn php_stream_open_wrapper_ex(path, mode, REPORT_ERRORS, NULL, context);\n\t\t}\n\t\t/* Called from a non-http wrapper with http proxying requested (i.e. ftp) */\n\t\trequest_fulluri = 1;\n\t\tuse_ssl = 0;\n\t\tuse_proxy = 1;\n\n\t\ttransport_len = Z_STRLEN_P(tmpzval);\n\t\ttransport_string = estrndup(Z_STRVAL_P(tmpzval), Z_STRLEN_P(tmpzval));\n\t} else {\n\t\t/* Normal http request (possibly with proxy) */\n\n\t\tif (strpbrk(mode, \"awx+\")) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options, \"HTTP wrapper does not support writeable connections\");\n\t\t\tphp_url_free(resource);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tuse_ssl = resource->scheme && (strlen(resource->scheme) > 4) && resource->scheme[4] == 's';\n\t\t/* choose default ports */\n\t\tif (use_ssl && resource->port == 0)\n\t\t\tresource->port = 443;\n\t\telse if (resource->port == 0)\n\t\t\tresource->port = 80;\n\n\t\tif (context &&\n\t\t\t(tmpzval = php_stream_context_get_option(context, wrapper->wops->label, \"proxy\")) != NULL &&\n\t\t\tZ_TYPE_P(tmpzval) == IS_STRING &&\n\t\t\tZ_STRLEN_P(tmpzval) > 0) {\n\t\t\tuse_proxy = 1;\n\t\t\ttransport_len = Z_STRLEN_P(tmpzval);\n\t\t\ttransport_string = estrndup(Z_STRVAL_P(tmpzval), Z_STRLEN_P(tmpzval));\n\t\t} else {\n\t\t\ttransport_len = spprintf(&transport_string, 0, \"%s://%s:%d\", use_ssl ? \"ssl\" : \"tcp\", resource->host, resource->port);\n\t\t}\n\t}\n\n\tif (context && (tmpzval = php_stream_context_get_option(context, wrapper->wops->label, \"timeout\")) != NULL) {\n\t\tdouble d = zval_get_double(tmpzval);\n#ifndef PHP_WIN32\n\t\ttimeout.tv_sec = (time_t) d;\n\t\ttimeout.tv_usec = (size_t) ((d - timeout.tv_sec) * 1000000);\n#else\n\t\ttimeout.tv_sec = (long) d;\n\t\ttimeout.tv_usec = (long) ((d - timeout.tv_sec) * 1000000);\n#endif\n\t} else {\n#ifndef PHP_WIN32\n\t\ttimeout.tv_sec = FG(default_socket_timeout);\n#else\n\t\ttimeout.tv_sec = (long)FG(default_socket_timeout);\n#endif\n\t\ttimeout.tv_usec = 0;\n\t}\n\n\tstream = php_stream_xport_create(transport_string, transport_len, options,\n\t\t\tSTREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT,\n\t\t\tNULL, &timeout, context, &errstr, NULL);\n\n\tif (stream) {\n\t\tphp_stream_set_option(stream, PHP_STREAM_OPTION_READ_TIMEOUT, 0, &timeout);\n\t}\n\n\tif (errstr) {\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"%s\", ZSTR_VAL(errstr));\n\t\tzend_string_release(errstr);\n\t\terrstr = NULL;\n\t}\n\n\tefree(transport_string);\n\n\tif (stream && use_proxy && use_ssl) {\n\t\tsmart_str header = {0};\n\n\t\t/* Set peer_name or name verification will try to use the proxy server name */\n\t\tif (!context || (tmpzval = php_stream_context_get_option(context, \"ssl\", \"peer_name\")) == NULL) {\n\t\t\tZVAL_STRING(&ssl_proxy_peer_name, resource->host);\n\t\t\tphp_stream_context_set_option(PHP_STREAM_CONTEXT(stream), \"ssl\", \"peer_name\", &ssl_proxy_peer_name);\n\t\t\tzval_ptr_dtor(&ssl_proxy_peer_name);\n\t\t}\n\n\t\tsmart_str_appendl(&header, \"CONNECT \", sizeof(\"CONNECT \")-1);\n\t\tsmart_str_appends(&header, resource->host);\n\t\tsmart_str_appendc(&header, ':');\n\t\tsmart_str_append_unsigned(&header, resource->port);\n\t\tsmart_str_appendl(&header, \" HTTP/1.0\\r\\n\", sizeof(\" HTTP/1.0\\r\\n\")-1);\n\n\t    /* check if we have Proxy-Authorization header */\n\t\tif (context && (tmpzval = php_stream_context_get_option(context, \"http\", \"header\")) != NULL) {\n\t\t\tchar *s, *p;\n\n\t\t\tif (Z_TYPE_P(tmpzval) == IS_ARRAY) {\n\t\t\t\tzval *tmpheader = NULL;\n\n\t\t\t\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(tmpzval), tmpheader) {\n\t\t\t\t\tif (Z_TYPE_P(tmpheader) == IS_STRING) {\n\t\t\t\t\t\ts = Z_STRVAL_P(tmpheader);\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\twhile (*s == ' ' || *s == '\\t') s++;\n\t\t\t\t\t\t\tp = s;\n\t\t\t\t\t\t\twhile (*p != 0 && *p != ':' && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\tif (*p == ':') {\n\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t\tif (p - s == sizeof(\"Proxy-Authorization:\") - 1 &&\n\t\t\t\t\t\t\t\t    zend_binary_strcasecmp(s, sizeof(\"Proxy-Authorization:\") - 1,\n\t\t\t\t\t\t\t\t        \"Proxy-Authorization:\", sizeof(\"Proxy-Authorization:\") - 1) == 0) {\n\t\t\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\t\t\tsmart_str_appendl(&header, s, p - s);\n\t\t\t\t\t\t\t\t\tsmart_str_appendl(&header, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\t\t\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts = p;\n\t\t\t\t\t\t\twhile (*s == '\\r' || *s == '\\n') s++;\n\t\t\t\t\t\t} while (*s != 0);\n\t\t\t\t\t}\n\t\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t\t} else if (Z_TYPE_P(tmpzval) == IS_STRING && Z_STRLEN_P(tmpzval)) {\n\t\t\t\ts = Z_STRVAL_P(tmpzval);\n\t\t\t\tdo {\n\t\t\t\t\twhile (*s == ' ' || *s == '\\t') s++;\n\t\t\t\t\tp = s;\n\t\t\t\t\twhile (*p != 0 && *p != ':' && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\tif (*p == ':') {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tif (p - s == sizeof(\"Proxy-Authorization:\") - 1 &&\n\t\t\t\t\t\t    zend_binary_strcasecmp(s, sizeof(\"Proxy-Authorization:\") - 1,\n\t\t\t\t\t\t        \"Proxy-Authorization:\", sizeof(\"Proxy-Authorization:\") - 1) == 0) {\n\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\tsmart_str_appendl(&header, s, p - s);\n\t\t\t\t\t\t\tsmart_str_appendl(&header, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ts = p;\n\t\t\t\t\twhile (*s == '\\r' || *s == '\\n') s++;\n\t\t\t\t} while (*s != 0);\n\t\t\t}\n\t\t}\nfinish:\n\t\tsmart_str_appendl(&header, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\n\t\tif (php_stream_write(stream, ZSTR_VAL(header.s), ZSTR_LEN(header.s)) != ZSTR_LEN(header.s)) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options, \"Cannot connect to HTTPS server through proxy\");\n\t\t\tphp_stream_close(stream);\n\t\t\tstream = NULL;\n\t\t}\n \t \tsmart_str_free(&header);\n\n \t \tif (stream) {\n \t \t\tchar header_line[HTTP_HEADER_BLOCK_SIZE];\n\n\t\t\t/* get response header */\n\t\t\twhile (php_stream_gets(stream, header_line, HTTP_HEADER_BLOCK_SIZE-1) != NULL) {\n\t\t\t\tif (header_line[0] == '\\n' ||\n\t\t\t\t    header_line[0] == '\\r' ||\n\t\t\t\t    header_line[0] == '\\0') {\n\t\t\t\t  break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* enable SSL transport layer */\n\t\tif (stream) {\n\t\t\tif (php_stream_xport_crypto_setup(stream, STREAM_CRYPTO_METHOD_SSLv23_CLIENT, NULL) < 0 ||\n\t\t\t    php_stream_xport_crypto_enable(stream, 1) < 0) {\n\t\t\t\tphp_stream_wrapper_log_error(wrapper, options, \"Cannot connect to HTTPS server through proxy\");\n\t\t\t\tphp_stream_close(stream);\n\t\t\t\tstream = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (stream == NULL)\n\t\tgoto out;\n\n\t/* avoid buffering issues while reading header */\n\tif (options & STREAM_WILL_CAST)\n\t\tchunk_size = php_stream_set_chunk_size(stream, 1);\n\n\t/* avoid problems with auto-detecting when reading the headers -> the headers\n\t * are always in canonical \\r\\n format */\n\teol_detect = stream->flags & (PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC);\n\tstream->flags &= ~(PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC);\n\n\tphp_stream_context_set(stream, context);\n\n\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_CONNECT, NULL, 0);\n\n\tif (header_init && context && (tmpzval = php_stream_context_get_option(context, \"http\", \"max_redirects\")) != NULL) {\n\t\tredirect_max = (int)zval_get_long(tmpzval);\n\t}\n\n\tif (context && (tmpzval = php_stream_context_get_option(context, \"http\", \"method\")) != NULL) {\n\t\tif (Z_TYPE_P(tmpzval) == IS_STRING && Z_STRLEN_P(tmpzval) > 0) {\n\t\t\t/* As per the RFC, automatically redirected requests MUST NOT use other methods than\n\t\t\t * GET and HEAD unless it can be confirmed by the user */\n\t\t\tif (!redirected\n\t\t\t\t|| (Z_STRLEN_P(tmpzval) == 3 && memcmp(\"GET\", Z_STRVAL_P(tmpzval), 3) == 0)\n\t\t\t\t|| (Z_STRLEN_P(tmpzval) == 4 && memcmp(\"HEAD\",Z_STRVAL_P(tmpzval), 4) == 0)\n\t\t\t) {\n\t\t\t\tscratch_len = strlen(path) + 29 + Z_STRLEN_P(tmpzval);\n\t\t\t\tscratch = emalloc(scratch_len);\n\t\t\t\tstrlcpy(scratch, Z_STRVAL_P(tmpzval), Z_STRLEN_P(tmpzval) + 1);\n\t\t\t\tstrncat(scratch, \" \", 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (context && (tmpzval = php_stream_context_get_option(context, \"http\", \"protocol_version\")) != NULL) {\n\t\tprotocol_version_len = (int)spprintf(&protocol_version, 0, \"%.1F\", zval_get_double(tmpzval));\n\t}\n\n\tif (!scratch) {\n\t\tscratch_len = strlen(path) + 29 + protocol_version_len;\n\t\tscratch = emalloc(scratch_len);\n\t\tstrncpy(scratch, \"GET \", scratch_len);\n\t}\n\n\t/* Should we send the entire path in the request line, default to no. */\n\tif (!request_fulluri && context &&\n\t\t(tmpzval = php_stream_context_get_option(context, \"http\", \"request_fulluri\")) != NULL) {\n\t\trequest_fulluri = zend_is_true(tmpzval);\n\t}\n\n\tif (request_fulluri) {\n\t\t/* Ask for everything */\n\t\tstrcat(scratch, path);\n\t} else {\n\t\t/* Send the traditional /path/to/file?query_string */\n\n\t\t/* file */\n\t\tif (resource->path && *resource->path) {\n\t\t\tstrlcat(scratch, resource->path, scratch_len);\n\t\t} else {\n\t\t\tstrlcat(scratch, \"/\", scratch_len);\n\t\t}\n\n\t\t/* query string */\n\t\tif (resource->query) {\n\t\t\tstrlcat(scratch, \"?\", scratch_len);\n\t\t\tstrlcat(scratch, resource->query, scratch_len);\n\t\t}\n\t}\n\n\t/* protocol version we are speaking */\n\tif (protocol_version) {\n\t\tstrlcat(scratch, \" HTTP/\", scratch_len);\n\t\tstrlcat(scratch, protocol_version, scratch_len);\n\t\tstrlcat(scratch, \"\\r\\n\", scratch_len);\n\t} else {\n\t\tstrlcat(scratch, \" HTTP/1.0\\r\\n\", scratch_len);\n\t}\n\n\t/* send it */\n\tphp_stream_write(stream, scratch, strlen(scratch));\n\n\tif (context && (tmpzval = php_stream_context_get_option(context, \"http\", \"header\")) != NULL) {\n\t\ttmp = NULL;\n\n\t\tif (Z_TYPE_P(tmpzval) == IS_ARRAY) {\n\t\t\tzval *tmpheader = NULL;\n\t\t\tsmart_str tmpstr = {0};\n\n\t\t\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(tmpzval), tmpheader) {\n\t\t\t\tif (Z_TYPE_P(tmpheader) == IS_STRING) {\n\t\t\t\t\tsmart_str_append(&tmpstr, Z_STR_P(tmpheader));\n\t\t\t\t\tsmart_str_appendl(&tmpstr, \"\\r\\n\", sizeof(\"\\r\\n\") - 1);\n\t\t\t\t}\n\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t\tsmart_str_0(&tmpstr);\n\t\t\t/* Remove newlines and spaces from start and end. there's at least one extra \\r\\n at the end that needs to go. */\n\t\t\tif (tmpstr.s) {\n\t\t\t\ttmp = php_trim(tmpstr.s, NULL, 0, 3);\n\t\t\t\tsmart_str_free(&tmpstr);\n\t\t\t}\n\t\t} else if (Z_TYPE_P(tmpzval) == IS_STRING && Z_STRLEN_P(tmpzval)) {\n\t\t\t/* Remove newlines and spaces from start and end php_trim will estrndup() */\n\t\t\ttmp = php_trim(Z_STR_P(tmpzval), NULL, 0, 3);\n\t\t}\n\t\tif (tmp && ZSTR_LEN(tmp)) {\n\t\t\tchar *s;\n\t\t\tchar *t;\n\n\t\t\tuser_headers = estrndup(ZSTR_VAL(tmp), ZSTR_LEN(tmp));\n\n\t\t\tif (ZSTR_IS_INTERNED(tmp)) {\n\t\t\t\ttmp = zend_string_init(ZSTR_VAL(tmp), ZSTR_LEN(tmp), 0);\n\t\t\t} else if (GC_REFCOUNT(tmp) > 1) {\n\t\t\t\tGC_REFCOUNT(tmp)--;\n\t\t\t\ttmp = zend_string_init(ZSTR_VAL(tmp), ZSTR_LEN(tmp), 0);\n\t\t\t}\n\n\t\t\t/* Make lowercase for easy comparison against 'standard' headers */\n\t\t\tphp_strtolower(ZSTR_VAL(tmp), ZSTR_LEN(tmp));\n\t\t\tt = ZSTR_VAL(tmp);\n\n\t\t\tif (!header_init) {\n\t\t\t\t/* strip POST headers on redirect */\n\t\t\t\tstrip_header(user_headers, t, \"content-length:\");\n\t\t\t\tstrip_header(user_headers, t, \"content-type:\");\n\t\t\t}\n\n\t\t\tif ((s = strstr(t, \"user-agent:\")) &&\n\t\t\t    (s == t || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_USER_AGENT;\n\t\t\t}\n\t\t\tif ((s = strstr(t, \"host:\")) &&\n\t\t\t    (s == t || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_HOST;\n\t\t\t}\n\t\t\tif ((s = strstr(t, \"from:\")) &&\n\t\t\t    (s == t || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_FROM;\n\t\t\t\t}\n\t\t\tif ((s = strstr(t, \"authorization:\")) &&\n\t\t\t    (s == t || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_AUTH;\n\t\t\t}\n\t\t\tif ((s = strstr(t, \"content-length:\")) &&\n\t\t\t    (s == t || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_CONTENT_LENGTH;\n\t\t\t}\n\t\t\tif ((s = strstr(t, \"content-type:\")) &&\n\t\t\t    (s == t || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_TYPE;\n\t\t\t}\n\t\t\tif ((s = strstr(t, \"connection:\")) &&\n\t\t\t    (s == t || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_CONNECTION;\n\t\t\t}\n\t\t\t/* remove Proxy-Authorization header */\n\t\t\tif (use_proxy && use_ssl && (s = strstr(t, \"proxy-authorization:\")) &&\n\t\t\t    (s == t || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\tchar *p = s + sizeof(\"proxy-authorization:\") - 1;\n\n\t\t\t\twhile (s > t && (*(s-1) == ' ' || *(s-1) == '\\t')) s--;\n\t\t\t\twhile (*p != 0 && *p != '\\r' && *p != '\\n') p++;\n\t\t\t\twhile (*p == '\\r' || *p == '\\n') p++;\n\t\t\t\tif (*p == 0) {\n\t\t\t\t\tif (s == t) {\n\t\t\t\t\t\tefree(user_headers);\n\t\t\t\t\t\tuser_headers = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\twhile (s > t && (*(s-1) == '\\r' || *(s-1) == '\\n')) s--;\n\t\t\t\t\t\tuser_headers[s - t] = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmemmove(user_headers + (s - t), user_headers + (p - t), strlen(p) + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tif (tmp) {\n\t\t\tzend_string_release(tmp);\n\t\t}\n\t}\n\n\t/* auth header if it was specified */\n\tif (((have_header & HTTP_HEADER_AUTH) == 0) && resource->user) {\n\t\tzend_string *stmp;\n\t\t/* decode the strings first */\n\t\tphp_url_decode(resource->user, strlen(resource->user));\n\n\t\t/* scratch is large enough, since it was made large enough for the whole URL */\n\t\tstrcpy(scratch, resource->user);\n\t\tstrcat(scratch, \":\");\n\n\t\t/* Note: password is optional! */\n\t\tif (resource->pass) {\n\t\t\tphp_url_decode(resource->pass, strlen(resource->pass));\n\t\t\tstrcat(scratch, resource->pass);\n\t\t}\n\n\t\tstmp = php_base64_encode((unsigned char*)scratch, strlen(scratch));\n\n\t\tif (snprintf(scratch, scratch_len, \"Authorization: Basic %s\\r\\n\", ZSTR_VAL(stmp)) > 0) {\n\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t\t\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_AUTH_REQUIRED, NULL, 0);\n\t\t}\n\n\t\tzend_string_free(stmp);\n\t}\n\n\t/* if the user has configured who they are, send a From: line */\n\tif (((have_header & HTTP_HEADER_FROM) == 0) && FG(from_address)) {\n\t\tif (snprintf(scratch, scratch_len, \"From: %s\\r\\n\", FG(from_address)) > 0)\n\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t}\n\n\t/* Send Host: header so name-based virtual hosts work */\n\tif ((have_header & HTTP_HEADER_HOST) == 0) {\n\t\tif ((use_ssl && resource->port != 443 && resource->port != 0) ||\n\t\t\t(!use_ssl && resource->port != 80 && resource->port != 0)) {\n\t\t\tif (snprintf(scratch, scratch_len, \"Host: %s:%i\\r\\n\", resource->host, resource->port) > 0)\n\t\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t\t} else {\n\t\t\tif (snprintf(scratch, scratch_len, \"Host: %s\\r\\n\", resource->host) > 0) {\n\t\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Send a Connection: close header to avoid hanging when the server\n\t * interprets the RFC literally and establishes a keep-alive connection,\n\t * unless the user specifically requests something else by specifying a\n\t * Connection header in the context options. Send that header even for\n\t * HTTP/1.0 to avoid issues when the server respond with a HTTP/1.1\n\t * keep-alive response, which is the preferred response type. */\n\tif ((have_header & HTTP_HEADER_CONNECTION) == 0) {\n\t\tphp_stream_write_string(stream, \"Connection: close\\r\\n\");\n\t}\n\n\tif (context &&\n\t    (ua_zval = php_stream_context_get_option(context, \"http\", \"user_agent\")) != NULL &&\n\t\tZ_TYPE_P(ua_zval) == IS_STRING) {\n\t\tua_str = Z_STRVAL_P(ua_zval);\n\t} else if (FG(user_agent)) {\n\t\tua_str = FG(user_agent);\n\t}\n\n\tif (((have_header & HTTP_HEADER_USER_AGENT) == 0) && ua_str) {\n#define _UA_HEADER \"User-Agent: %s\\r\\n\"\n\t\tchar *ua;\n\t\tsize_t ua_len;\n\n\t\tua_len = sizeof(_UA_HEADER) + strlen(ua_str);\n\n\t\t/* ensure the header is only sent if user_agent is not blank */\n\t\tif (ua_len > sizeof(_UA_HEADER)) {\n\t\t\tua = emalloc(ua_len + 1);\n\t\t\tif ((ua_len = slprintf(ua, ua_len, _UA_HEADER, ua_str)) > 0) {\n\t\t\t\tua[ua_len] = 0;\n\t\t\t\tphp_stream_write(stream, ua, ua_len);\n\t\t\t} else {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Cannot construct User-agent header\");\n\t\t\t}\n\t\t\tefree(ua);\n\t\t}\n\t}\n\n\tif (user_headers) {\n\t\t/* A bit weird, but some servers require that Content-Length be sent prior to Content-Type for POST\n\t\t * see bug #44603 for details. Since Content-Type maybe part of user's headers we need to do this check first.\n\t\t */\n\t\tif (\n\t\t\t\theader_init &&\n\t\t\t\tcontext &&\n\t\t\t\t!(have_header & HTTP_HEADER_CONTENT_LENGTH) &&\n\t\t\t\t(tmpzval = php_stream_context_get_option(context, \"http\", \"content\")) != NULL &&\n\t\t\t\tZ_TYPE_P(tmpzval) == IS_STRING && Z_STRLEN_P(tmpzval) > 0\n\t\t) {\n\t\t\tscratch_len = slprintf(scratch, scratch_len, \"Content-Length: %d\\r\\n\", Z_STRLEN_P(tmpzval));\n\t\t\tphp_stream_write(stream, scratch, scratch_len);\n\t\t\thave_header |= HTTP_HEADER_CONTENT_LENGTH;\n\t\t}\n\n\t\tphp_stream_write(stream, user_headers, strlen(user_headers));\n\t\tphp_stream_write(stream, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\tefree(user_headers);\n\t}\n\n\t/* Request content, such as for POST requests */\n\tif (header_init && context &&\n\t\t(tmpzval = php_stream_context_get_option(context, \"http\", \"content\")) != NULL &&\n\t\tZ_TYPE_P(tmpzval) == IS_STRING && Z_STRLEN_P(tmpzval) > 0) {\n\t\tif (!(have_header & HTTP_HEADER_CONTENT_LENGTH)) {\n\t\t\tscratch_len = slprintf(scratch, scratch_len, \"Content-Length: %d\\r\\n\", Z_STRLEN_P(tmpzval));\n\t\t\tphp_stream_write(stream, scratch, scratch_len);\n\t\t}\n\t\tif (!(have_header & HTTP_HEADER_TYPE)) {\n\t\t\tphp_stream_write(stream, \"Content-Type: application/x-www-form-urlencoded\\r\\n\",\n\t\t\t\tsizeof(\"Content-Type: application/x-www-form-urlencoded\\r\\n\") - 1);\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Content-type not specified assuming application/x-www-form-urlencoded\");\n\t\t}\n\t\tphp_stream_write(stream, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\tphp_stream_write(stream, Z_STRVAL_P(tmpzval), Z_STRLEN_P(tmpzval));\n\t} else {\n\t\tphp_stream_write(stream, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t}\n\n\tlocation[0] = '\\0';\n\n\tsymbol_table = zend_rebuild_symbol_table();\n\n\tif (header_init) {\n\t\tzval ztmp;\n\t\tarray_init(&ztmp);\n\t\tzend_set_local_var_str(\"http_response_header\", sizeof(\"http_response_header\")-1, &ztmp, 0);\n\t}\n\n\t{\n\t\tzval *response_header_ptr = zend_hash_str_find_ind(symbol_table, \"http_response_header\", sizeof(\"http_response_header\")-1);\n\t\tif (!response_header_ptr || Z_TYPE_P(response_header_ptr) != IS_ARRAY) {\n\t\t\tZVAL_UNDEF(&response_header);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tZVAL_COPY(&response_header, response_header_ptr);\n\t\t}\n\t}\n\n\tif (!php_stream_eof(stream)) {\n\t\tsize_t tmp_line_len;\n\t\t/* get response header */\n\n\t\tif (php_stream_get_line(stream, tmp_line, sizeof(tmp_line) - 1, &tmp_line_len) != NULL) {\n\t\t\tzval http_response;\n\n\t\t\tif (tmp_line_len > 9) {\n\t\t\t\tresponse_code = atoi(tmp_line + 9);\n\t\t\t} else {\n\t\t\t\tresponse_code = 0;\n\t\t\t}\n\t\t\tif (context && NULL != (tmpzval = php_stream_context_get_option(context, \"http\", \"ignore_errors\"))) {\n\t\t\t\tignore_errors = zend_is_true(tmpzval);\n\t\t\t}\n\t\t\t/* when we request only the header, don't fail even on error codes */\n\t\t\tif ((options & STREAM_ONLY_GET_HEADERS) || ignore_errors) {\n\t\t\t\treqok = 1;\n\t\t\t}\n\n\t\t\t/* status codes of 1xx are \"informational\", and will be followed by a real response\n\t\t\t * e.g \"100 Continue\". RFC 7231 states that unexpected 1xx status MUST be parsed,\n\t\t\t * and MAY be ignored. As such, we need to skip ahead to the \"real\" status*/\n\t\t\tif (response_code >= 100 && response_code < 200) {\n\t\t\t\t/* consume lines until we find a line starting 'HTTP/1' */\n\t\t\t\twhile (\n\t\t\t\t\t!php_stream_eof(stream)\n\t\t\t\t\t&& php_stream_get_line(stream, tmp_line, sizeof(tmp_line) - 1, &tmp_line_len) != NULL\n\t\t\t\t\t&& ( tmp_line_len < sizeof(\"HTTP/1\") - 1 || strncasecmp(tmp_line, \"HTTP/1\", sizeof(\"HTTP/1\") - 1) )\n\t\t\t\t);\n\n\t\t\t\tif (tmp_line_len > 9) {\n\t\t\t\t\tresponse_code = atoi(tmp_line + 9);\n\t\t\t\t} else {\n\t\t\t\t\tresponse_code = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* all status codes in the 2xx range are defined by the specification as successful;\n\t\t\t * all status codes in the 3xx range are for redirection, and so also should never\n\t\t\t * fail */\n\t\t\tif (response_code >= 200 && response_code < 400) {\n\t\t\t\treqok = 1;\n\t\t\t} else {\n\t\t\t\tswitch(response_code) {\n\t\t\t\t\tcase 403:\n\t\t\t\t\t\tphp_stream_notify_error(context, PHP_STREAM_NOTIFY_AUTH_RESULT,\n\t\t\t\t\t\t\t\ttmp_line, response_code);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* safety net in the event tmp_line == NULL */\n\t\t\t\t\t\tif (!tmp_line_len) {\n\t\t\t\t\t\t\ttmp_line[0] = '\\0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tphp_stream_notify_error(context, PHP_STREAM_NOTIFY_FAILURE,\n\t\t\t\t\t\t\t\ttmp_line, response_code);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tmp_line[tmp_line_len - 1] == '\\n') {\n\t\t\t\t--tmp_line_len;\n\t\t\t\tif (tmp_line[tmp_line_len - 1] == '\\r') {\n\t\t\t\t\t--tmp_line_len;\n\t\t\t\t}\n\t\t\t}\n\t\t\tZVAL_STRINGL(&http_response, tmp_line, tmp_line_len);\n\t\t\tzend_hash_next_index_insert(Z_ARRVAL(response_header), &http_response);\n\t\t}\n\t} else {\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"HTTP request failed, unexpected end of socket!\");\n\t\tgoto out;\n\t}\n\n\t/* read past HTTP headers */\n\n\thttp_header_line = emalloc(HTTP_HEADER_BLOCK_SIZE);\n\n\twhile (!php_stream_eof(stream)) {\n\t\tsize_t http_header_line_length;\n\t\t\n\t\tif (php_stream_get_line(stream, http_header_line, HTTP_HEADER_BLOCK_SIZE, &http_header_line_length) && *http_header_line != '\\n' && *http_header_line != '\\r') {\n\t\t\tchar *e = http_header_line + http_header_line_length - 1;\n\t\t\tchar *http_header_value;\n\t\t\tif (*e != '\\n') {\n\t\t\t\tdo { /* partial header */\n\t\t\t\t\tif (php_stream_get_line(stream, http_header_line, HTTP_HEADER_BLOCK_SIZE, &http_header_line_length) == NULL) {\n\t\t\t\t\t\tphp_stream_wrapper_log_error(wrapper, options, \"Failed to read HTTP headers\");\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\te = http_header_line + http_header_line_length - 1;\n\t\t\t\t} while (*e != '\\n');\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (e >= http_header_line && (*e == '\\n' || *e == '\\r')) {\n\t\t\t\te--;\n\t\t\t}\n\n\t\t\t/* The primary definition of an HTTP header in RFC 7230 states:\n\t\t\t * > Each header field consists of a case-insensitive field name followed\n\t\t\t * > by a colon (\":\"), optional leading whitespace, the field value, and\n\t\t\t * > optional trailing whitespace. */\n\n\t\t\t/* Strip trailing whitespace */\n\t\t\twhile (e >= http_header_line && (*e == ' ' || *e == '\\t')) {\n\t\t\t\te--;\n\t\t\t}\n\n\t\t\t/* Terminate header line */\n\t\t\te++;\n\t\t\t*e = '\\0';\n\t\t\thttp_header_line_length = e - http_header_line;\n\n\t\t\thttp_header_value = memchr(http_header_line, ':', http_header_line_length);\n\t\t\tif (http_header_value) {\n\t\t\t\thttp_header_value++; /* Skip ':' */\n\n\t\t\t\t/* Strip leading whitespace */\n\t\t\t\twhile (http_header_value < e\n\t\t\t\t\t\t&& (*http_header_value == ' ' || *http_header_value == '\\t')) {\n\t\t\t\t\thttp_header_value++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* There is no colon. Set the value to the end of the header line, which is\n\t\t\t\t * effectively an empty string. */\n\t\t\t\thttp_header_value = e;\n\t\t\t}\n\n\t\t\tif (!strncasecmp(http_header_line, \"Location:\", sizeof(\"Location:\")-1)) {\n\t\t\t\tif (context && (tmpzval = php_stream_context_get_option(context, \"http\", \"follow_location\")) != NULL) {\n\t\t\t\t\tfollow_location = zval_is_true(tmpzval);\n\t\t\t\t} else if (!((response_code >= 300 && response_code < 304)\n\t\t\t\t\t\t|| 307 == response_code || 308 == response_code)) {\n\t\t\t\t\t/* we shouldn't redirect automatically\n\t\t\t\t\tif follow_location isn't set and response_code not in (300, 301, 302, 303 and 307)\n\t\t\t\t\tsee http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.1\n\t\t\t\t\tRFC 7238 defines 308: http://tools.ietf.org/html/rfc7238 */\n\t\t\t\t\tfollow_location = 0;\n\t\t\t\t}\n\t\t\t\tstrlcpy(location, http_header_value, sizeof(location));\n\t\t\t} else if (!strncasecmp(http_header_line, \"Content-Type:\", sizeof(\"Content-Type:\")-1)) {\n\t\t\t\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_MIME_TYPE_IS, http_header_value, 0);\n\t\t\t} else if (!strncasecmp(http_header_line, \"Content-Length:\", sizeof(\"Content-Length:\")-1)) {\n\t\t\t\tfile_size = atoi(http_header_value);\n\t\t\t\tphp_stream_notify_file_size(context, file_size, http_header_line, 0);\n\t\t\t} else if (\n\t\t\t\t!strncasecmp(http_header_line, \"Transfer-Encoding:\", sizeof(\"Transfer-Encoding:\")-1)\n\t\t\t\t&& !strncasecmp(http_header_value, \"Chunked\", sizeof(\"Chunked\")-1)\n\t\t\t) {\n\n\t\t\t\t/* create filter to decode response body */\n\t\t\t\tif (!(options & STREAM_ONLY_GET_HEADERS)) {\n\t\t\t\t\tzend_long decode = 1;\n\n\t\t\t\t\tif (context && (tmpzval = php_stream_context_get_option(context, \"http\", \"auto_decode\")) != NULL) {\n\t\t\t\t\t\tdecode = zend_is_true(tmpzval);\n\t\t\t\t\t}\n\t\t\t\t\tif (decode) {\n\t\t\t\t\t\ttransfer_encoding = php_stream_filter_create(\"dechunk\", NULL, php_stream_is_persistent(stream));\n\t\t\t\t\t\tif (transfer_encoding) {\n\t\t\t\t\t\t\t/* don't store transfer-encodeing header */\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tzval http_header;\n\t\t\t\tZVAL_STRINGL(&http_header, http_header_line, http_header_line_length);\n\t\t\t\tzend_hash_next_index_insert(Z_ARRVAL(response_header), &http_header);\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!reqok || (location[0] != '\\0' && follow_location)) {\n\t\tif (!follow_location || (((options & STREAM_ONLY_GET_HEADERS) || ignore_errors) && redirect_max <= 1)) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (location[0] != '\\0')\n\t\t\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_REDIRECTED, location, 0);\n\n\t\tphp_stream_close(stream);\n\t\tstream = NULL;\n\n\t\tif (location[0] != '\\0') {\n\n\t\t\tchar new_path[HTTP_HEADER_BLOCK_SIZE];\n\t\t\tchar loc_path[HTTP_HEADER_BLOCK_SIZE];\n\n\t\t\t*new_path='\\0';\n\t\t\tif (strlen(location)<8 || (strncasecmp(location, \"http://\", sizeof(\"http://\")-1) &&\n\t\t\t\t\t\t\tstrncasecmp(location, \"https://\", sizeof(\"https://\")-1) &&\n\t\t\t\t\t\t\tstrncasecmp(location, \"ftp://\", sizeof(\"ftp://\")-1) &&\n\t\t\t\t\t\t\tstrncasecmp(location, \"ftps://\", sizeof(\"ftps://\")-1)))\n\t\t\t{\n\t\t\t\tif (*location != '/') {\n\t\t\t\t\tif (*(location+1) != '\\0' && resource->path) {\n\t\t\t\t\t\tchar *s = strrchr(resource->path, '/');\n\t\t\t\t\t\tif (!s) {\n\t\t\t\t\t\t\ts = resource->path;\n\t\t\t\t\t\t\tif (!s[0]) {\n\t\t\t\t\t\t\t\tefree(s);\n\t\t\t\t\t\t\t\ts = resource->path = estrdup(\"/\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t*s = '/';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts[1] = '\\0';\n\t\t\t\t\t\tif (resource->path && *(resource->path) == '/' && *(resource->path + 1) == '\\0') {\n\t\t\t\t\t\t\tsnprintf(loc_path, sizeof(loc_path) - 1, \"%s%s\", resource->path, location);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsnprintf(loc_path, sizeof(loc_path) - 1, \"%s/%s\", resource->path, location);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsnprintf(loc_path, sizeof(loc_path) - 1, \"/%s\", location);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstrlcpy(loc_path, location, sizeof(loc_path));\n\t\t\t\t}\n\t\t\t\tif ((use_ssl && resource->port != 443) || (!use_ssl && resource->port != 80)) {\n\t\t\t\t\tsnprintf(new_path, sizeof(new_path) - 1, \"%s://%s:%d%s\", resource->scheme, resource->host, resource->port, loc_path);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(new_path, sizeof(new_path) - 1, \"%s://%s%s\", resource->scheme, resource->host, loc_path);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstrlcpy(new_path, location, sizeof(new_path));\n\t\t\t}\n\n\t\t\tphp_url_free(resource);\n\t\t\t/* check for invalid redirection URLs */\n\t\t\tif ((resource = php_url_parse(new_path)) == NULL) {\n\t\t\t\tphp_stream_wrapper_log_error(wrapper, options, \"Invalid redirect URL! %s\", new_path);\n\t\t\t\tgoto out;\n\t\t\t}\n\n#define CHECK_FOR_CNTRL_CHARS(val) { \\\n\tif (val) { \\\n\t\tunsigned char *s, *e; \\\n\t\tsize_t l; \\\n\t\tl = php_url_decode(val, strlen(val)); \\\n\t\ts = (unsigned char*)val; e = s + l; \\\n\t\twhile (s < e) { \\\n\t\t\tif (iscntrl(*s)) { \\\n\t\t\t\tphp_stream_wrapper_log_error(wrapper, options, \"Invalid redirect URL! %s\", new_path); \\\n\t\t\t\tgoto out; \\\n\t\t\t} \\\n\t\t\ts++; \\\n\t\t} \\\n\t} \\\n}\n\t\t\t/* check for control characters in login, password & path */\n\t\t\tif (strncasecmp(new_path, \"http://\", sizeof(\"http://\") - 1) || strncasecmp(new_path, \"https://\", sizeof(\"https://\") - 1)) {\n\t\t\t\tCHECK_FOR_CNTRL_CHARS(resource->user)\n\t\t\t\tCHECK_FOR_CNTRL_CHARS(resource->pass)\n\t\t\t\tCHECK_FOR_CNTRL_CHARS(resource->path)\n\t\t\t}\n\t\t\tstream = php_stream_url_wrap_http_ex(wrapper, new_path, mode, options, opened_path, context, --redirect_max, HTTP_WRAPPER_REDIRECTED STREAMS_CC);\n\t\t} else {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options, \"HTTP request failed! %s\", tmp_line);\n\t\t}\n\t}\nout:\n\tif (protocol_version) {\n\t\tefree(protocol_version);\n\t}\n\n\tif (http_header_line) {\n\t\tefree(http_header_line);\n\t}\n\n\tif (scratch) {\n\t\tefree(scratch);\n\t}\n\n\tif (resource) {\n\t\tphp_url_free(resource);\n\t}\n\n\tif (stream) {\n\t\tif (header_init) {\n\t\t\tZVAL_COPY(&stream->wrapperdata, &response_header);\n\t\t}\n\t\tphp_stream_notify_progress_init(context, 0, file_size);\n\n\t\t/* Restore original chunk size now that we're done with headers */\n\t\tif (options & STREAM_WILL_CAST)\n\t\t\tphp_stream_set_chunk_size(stream, (int)chunk_size);\n\n\t\t/* restore the users auto-detect-line-endings setting */\n\t\tstream->flags |= eol_detect;\n\n\t\t/* as far as streams are concerned, we are now at the start of\n\t\t * the stream */\n\t\tstream->position = 0;\n\n\t\t/* restore mode */\n\t\tstrlcpy(stream->mode, mode, sizeof(stream->mode));\n\n\t\tif (transfer_encoding) {\n\t\t\tphp_stream_filter_append(&stream->readfilters, transfer_encoding);\n\t\t}\n\t} else {\n\t\tif (transfer_encoding) {\n\t\t\tphp_stream_filter_free(transfer_encoding);\n\t\t}\n\t}\n\n\tzval_ptr_dtor(&response_header);\n\n\treturn stream;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146765,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void exit_mmap(struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tunsigned long nr_accounted = 0;\n\n\t/* mm's last user has gone, and its about to be pulled down */\n\tmmu_notifier_release(mm);\n\n\tif (mm->locked_vm) {\n\t\tvma = mm->mmap;\n\t\twhile (vma) {\n\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\tmunlock_vma_pages_all(vma);\n\t\t\tvma = vma->vm_next;\n\t\t}\n\t}\n\n\tarch_exit_mmap(mm);\n\n\tvma = mm->mmap;\n\tif (!vma)\t/* Can happen if dup_mmap() received an OOM */\n\t\treturn;\n\n\tlru_add_drain();\n\tflush_cache_mm(mm);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\t/* update_hiwater_rss(mm) here? but nobody should be looking */\n\t/* Use -1 here to ensure all VMAs in the mm are unmapped */\n\tunmap_vmas(&tlb, vma, 0, -1);\n\n\tif (unlikely(mm_is_oom_victim(mm))) {\n\t\t/*\n\t\t * Wait for oom_reap_task() to stop working on this\n\t\t * mm. Because MMF_OOM_SKIP is already set before\n\t\t * calling down_read(), oom_reap_task() will not run\n\t\t * on this \"mm\" post up_write().\n\t\t *\n\t\t * mm_is_oom_victim() cannot be set from under us\n\t\t * either because victim->mm is already set to NULL\n\t\t * under task_lock before calling mmput and oom_mm is\n\t\t * set not NULL by the OOM killer only if victim->mm\n\t\t * is found not NULL while holding the task_lock.\n\t\t */\n\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\t\tdown_write(&mm->mmap_sem);\n\t\tup_write(&mm->mmap_sem);\n\t}\n\tfree_pgtables(&tlb, vma, FIRST_USER_ADDRESS, USER_PGTABLES_CEILING);\n\ttlb_finish_mmu(&tlb, 0, -1);\n\n\t/*\n\t * Walk the list again, actually closing and freeing it,\n\t * with preemption enabled, without holding any MM locks.\n\t */\n\twhile (vma) {\n\t\tif (vma->vm_flags & VM_ACCOUNT)\n\t\t\tnr_accounted += vma_pages(vma);\n\t\tvma = remove_vma(vma);\n\t}\n\tvm_unacct_memory(nr_accounted);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146768,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void exit_mmap(struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tunsigned long nr_accounted = 0;\n\n\t/* mm's last user has gone, and its about to be pulled down */\n\tmmu_notifier_release(mm);\n\n\tif (unlikely(mm_is_oom_victim(mm))) {\n\t\t/*\n\t\t * Manually reap the mm to free as much memory as possible.\n\t\t * Then, as the oom reaper does, set MMF_OOM_SKIP to disregard\n\t\t * this mm from further consideration.  Taking mm->mmap_sem for\n\t\t * write after setting MMF_OOM_SKIP will guarantee that the oom\n\t\t * reaper will not run on this mm again after mmap_sem is\n\t\t * dropped.\n\t\t *\n\t\t * Nothing can be holding mm->mmap_sem here and the above call\n\t\t * to mmu_notifier_release(mm) ensures mmu notifier callbacks in\n\t\t * __oom_reap_task_mm() will not block.\n\t\t *\n\t\t * This needs to be done before calling munlock_vma_pages_all(),\n\t\t * which clears VM_LOCKED, otherwise the oom reaper cannot\n\t\t * reliably test it.\n\t\t */\n\t\tmutex_lock(&oom_lock);\n\t\t__oom_reap_task_mm(mm);\n\t\tmutex_unlock(&oom_lock);\n\n\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\t\tdown_write(&mm->mmap_sem);\n\t\tup_write(&mm->mmap_sem);\n\t}\n\n\tif (mm->locked_vm) {\n\t\tvma = mm->mmap;\n\t\twhile (vma) {\n\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\tmunlock_vma_pages_all(vma);\n\t\t\tvma = vma->vm_next;\n\t\t}\n\t}\n\n\tarch_exit_mmap(mm);\n\n\tvma = mm->mmap;\n\tif (!vma)\t/* Can happen if dup_mmap() received an OOM */\n\t\treturn;\n\n\tlru_add_drain();\n\tflush_cache_mm(mm);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\t/* update_hiwater_rss(mm) here? but nobody should be looking */\n\t/* Use -1 here to ensure all VMAs in the mm are unmapped */\n\tunmap_vmas(&tlb, vma, 0, -1);\n\tfree_pgtables(&tlb, vma, FIRST_USER_ADDRESS, USER_PGTABLES_CEILING);\n\ttlb_finish_mmu(&tlb, 0, -1);\n\n\t/*\n\t * Walk the list again, actually closing and freeing it,\n\t * with preemption enabled, without holding any MM locks.\n\t */\n\twhile (vma) {\n\t\tif (vma->vm_flags & VM_ACCOUNT)\n\t\t\tnr_accounted += vma_pages(vma);\n\t\tvma = remove_vma(vma);\n\t}\n\tvm_unacct_memory(nr_accounted);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146769,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int dccp_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tconst struct dccp_sock *dp = dccp_sk(sk);\n\tconst int flags = msg->msg_flags;\n\tconst int noblock = flags & MSG_DONTWAIT;\n\tstruct sk_buff *skb;\n\tint rc, size;\n\tlong timeo;\n\n\ttrace_dccp_probe(sk, len);\n\n\tif (len > dp->dccps_mss_cache)\n\t\treturn -EMSGSIZE;\n\n\tlock_sock(sk);\n\n\tif (dccp_qpolicy_full(sk)) {\n\t\trc = -EAGAIN;\n\t\tgoto out_release;\n\t}\n\n\ttimeo = sock_sndtimeo(sk, noblock);\n\n\t/*\n\t * We have to use sk_stream_wait_connect here to set sk_write_pending,\n\t * so that the trick in dccp_rcv_request_sent_state_process.\n\t */\n\t/* Wait for a connection to finish. */\n\tif ((1 << sk->sk_state) & ~(DCCPF_OPEN | DCCPF_PARTOPEN))\n\t\tif ((rc = sk_stream_wait_connect(sk, &timeo)) != 0)\n\t\t\tgoto out_release;\n\n\tsize = sk->sk_prot->max_header + len;\n\trelease_sock(sk);\n\tskb = sock_alloc_send_skb(sk, size, noblock, &rc);\n\tlock_sock(sk);\n\tif (skb == NULL)\n\t\tgoto out_release;\n\n\tskb_reserve(skb, sk->sk_prot->max_header);\n\trc = memcpy_from_msg(skb_put(skb, len), msg, len);\n\tif (rc != 0)\n\t\tgoto out_discard;\n\n\trc = dccp_msghdr_parse(msg, skb);\n\tif (rc != 0)\n\t\tgoto out_discard;\n\n\tdccp_qpolicy_push(sk, skb);\n\t/*\n\t * The xmit_timer is set if the TX CCID is rate-based and will expire\n\t * when congestion control permits to release further packets into the\n\t * network. Window-based CCIDs do not use this timer.\n\t */\n\tif (!timer_pending(&dp->dccps_xmit_timer))\n\t\tdccp_write_xmit(sk);\nout_release:\n\trelease_sock(sk);\n\treturn rc ? : len;\nout_discard:\n\tkfree_skb(skb);\n\tgoto out_release;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146770,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int dccp_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tconst struct dccp_sock *dp = dccp_sk(sk);\n\tconst int flags = msg->msg_flags;\n\tconst int noblock = flags & MSG_DONTWAIT;\n\tstruct sk_buff *skb;\n\tint rc, size;\n\tlong timeo;\n\n\ttrace_dccp_probe(sk, len);\n\n\tif (len > dp->dccps_mss_cache)\n\t\treturn -EMSGSIZE;\n\n\tlock_sock(sk);\n\n\tif (dccp_qpolicy_full(sk)) {\n\t\trc = -EAGAIN;\n\t\tgoto out_release;\n\t}\n\n\ttimeo = sock_sndtimeo(sk, noblock);\n\n\t/*\n\t * We have to use sk_stream_wait_connect here to set sk_write_pending,\n\t * so that the trick in dccp_rcv_request_sent_state_process.\n\t */\n\t/* Wait for a connection to finish. */\n\tif ((1 << sk->sk_state) & ~(DCCPF_OPEN | DCCPF_PARTOPEN))\n\t\tif ((rc = sk_stream_wait_connect(sk, &timeo)) != 0)\n\t\t\tgoto out_release;\n\n\tsize = sk->sk_prot->max_header + len;\n\trelease_sock(sk);\n\tskb = sock_alloc_send_skb(sk, size, noblock, &rc);\n\tlock_sock(sk);\n\tif (skb == NULL)\n\t\tgoto out_release;\n\n\tif (sk->sk_state == DCCP_CLOSED) {\n\t\trc = -ENOTCONN;\n\t\tgoto out_discard;\n\t}\n\n\tskb_reserve(skb, sk->sk_prot->max_header);\n\trc = memcpy_from_msg(skb_put(skb, len), msg, len);\n\tif (rc != 0)\n\t\tgoto out_discard;\n\n\trc = dccp_msghdr_parse(msg, skb);\n\tif (rc != 0)\n\t\tgoto out_discard;\n\n\tdccp_qpolicy_push(sk, skb);\n\t/*\n\t * The xmit_timer is set if the TX CCID is rate-based and will expire\n\t * when congestion control permits to release further packets into the\n\t * network. Window-based CCIDs do not use this timer.\n\t */\n\tif (!timer_pending(&dp->dccps_xmit_timer))\n\t\tdccp_write_xmit(sk);\nout_release:\n\trelease_sock(sk);\n\treturn rc ? : len;\nout_discard:\n\tkfree_skb(skb);\n\tgoto out_release;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146771,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void coroutine_fn mirror_wait_on_conflicts(MirrorOp *self,\n                                                  MirrorBlockJob *s,\n                                                  uint64_t offset,\n                                                  uint64_t bytes)\n{\n    uint64_t self_start_chunk = offset / s->granularity;\n    uint64_t self_end_chunk = DIV_ROUND_UP(offset + bytes, s->granularity);\n    uint64_t self_nb_chunks = self_end_chunk - self_start_chunk;\n\n    while (find_next_bit(s->in_flight_bitmap, self_end_chunk,\n                         self_start_chunk) < self_end_chunk &&\n           s->ret >= 0)\n    {\n        MirrorOp *op;\n\n        QTAILQ_FOREACH(op, &s->ops_in_flight, next) {\n            uint64_t op_start_chunk = op->offset / s->granularity;\n            uint64_t op_nb_chunks = DIV_ROUND_UP(op->offset + op->bytes,\n                                                 s->granularity) -\n                                    op_start_chunk;\n\n            if (op == self) {\n                continue;\n            }\n\n            if (ranges_overlap(self_start_chunk, self_nb_chunks,\n                               op_start_chunk, op_nb_chunks))\n            {\n                /*\n                 * If the operation is already (indirectly) waiting for us, or\n                 * will wait for us as soon as it wakes up, then just go on\n                 * (instead of producing a deadlock in the former case).\n                 */\n                if (op->waiting_for_op) {\n                    continue;\n                }\n\n                self->waiting_for_op = op;\n                qemu_co_queue_wait(&op->waiting_requests, NULL);\n                self->waiting_for_op = NULL;\n                break;\n            }\n        }\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146794,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void coroutine_fn mirror_wait_on_conflicts(MirrorOp *self,\n                                                  MirrorBlockJob *s,\n                                                  uint64_t offset,\n                                                  uint64_t bytes)\n{\n    uint64_t self_start_chunk = offset / s->granularity;\n    uint64_t self_end_chunk = DIV_ROUND_UP(offset + bytes, s->granularity);\n    uint64_t self_nb_chunks = self_end_chunk - self_start_chunk;\n\n    while (find_next_bit(s->in_flight_bitmap, self_end_chunk,\n                         self_start_chunk) < self_end_chunk &&\n           s->ret >= 0)\n    {\n        MirrorOp *op;\n\n        QTAILQ_FOREACH(op, &s->ops_in_flight, next) {\n            uint64_t op_start_chunk = op->offset / s->granularity;\n            uint64_t op_nb_chunks = DIV_ROUND_UP(op->offset + op->bytes,\n                                                 s->granularity) -\n                                    op_start_chunk;\n\n            if (op == self) {\n                continue;\n            }\n\n            if (ranges_overlap(self_start_chunk, self_nb_chunks,\n                               op_start_chunk, op_nb_chunks))\n            {\n                if (self) {\n                    /*\n                     * If the operation is already (indirectly) waiting for us,\n                     * or will wait for us as soon as it wakes up, then just go\n                     * on (instead of producing a deadlock in the former case).\n                     */\n                    if (op->waiting_for_op) {\n                        continue;\n                    }\n\n                    self->waiting_for_op = op;\n                }\n\n                qemu_co_queue_wait(&op->waiting_requests, NULL);\n\n                if (self) {\n                    self->waiting_for_op = NULL;\n                }\n\n                break;\n            }\n        }\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146795,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "f_assert_fails(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*cmd;\n    garray_T\tga;\n    int\t\tsave_trylevel = trylevel;\n    int\t\tcalled_emsg_before = called_emsg;\n    char\t*wrong_arg_msg = NULL;\n    char_u\t*tofree = NULL;\n\n    if (check_for_string_or_number_arg(argvars, 0) == FAIL\n\t    || check_for_opt_string_or_list_arg(argvars, 1) == FAIL\n\t    || (argvars[1].v_type != VAR_UNKNOWN\n\t\t&& (argvars[2].v_type != VAR_UNKNOWN\n\t\t    && (check_for_opt_number_arg(argvars, 3) == FAIL\n\t\t\t|| (argvars[3].v_type != VAR_UNKNOWN\n\t\t\t    && check_for_opt_string_arg(argvars, 4) == FAIL)))))\n\treturn;\n\n    cmd = tv_get_string_chk(&argvars[0]);\n\n    // trylevel must be zero for a \":throw\" command to be considered failed\n    trylevel = 0;\n    suppress_errthrow = TRUE;\n    in_assert_fails = TRUE;\n\n    do_cmdline_cmd(cmd);\n    if (called_emsg == called_emsg_before)\n    {\n\tprepare_assert_error(&ga);\n\tga_concat(&ga, (char_u *)\"command did not fail: \");\n\tassert_append_cmd_or_arg(&ga, argvars, cmd);\n\tassert_error(&ga);\n\tga_clear(&ga);\n\trettv->vval.v_number = 1;\n    }\n    else if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tchar_u\tbuf[NUMBUFLEN];\n\tchar_u\t*expected;\n\tchar_u\t*expected_str = NULL;\n\tint\terror_found = FALSE;\n\tint\terror_found_index = 1;\n\tchar_u\t*actual = emsg_assert_fails_msg == NULL ? (char_u *)\"[unknown]\"\n\t\t\t\t\t\t       : emsg_assert_fails_msg;\n\n\tif (argvars[1].v_type == VAR_STRING)\n\t{\n\t    expected = tv_get_string_buf_chk(&argvars[1], buf);\n\t    error_found = expected == NULL\n\t\t\t   || strstr((char *)actual, (char *)expected) == NULL;\n\t}\n\telse if (argvars[1].v_type == VAR_LIST)\n\t{\n\t    list_T\t*list = argvars[1].vval.v_list;\n\t    typval_T\t*tv;\n\n\t    if (list == NULL || list->lv_len < 1 || list->lv_len > 2)\n\t    {\n\t\twrong_arg_msg = e_assert_fails_second_arg;\n\t\tgoto theend;\n\t    }\n\t    CHECK_LIST_MATERIALIZE(list);\n\t    tv = &list->lv_first->li_tv;\n\t    expected = tv_get_string_buf_chk(tv, buf);\n\t    if (!pattern_match(expected, actual, FALSE))\n\t    {\n\t\terror_found = TRUE;\n\t\texpected_str = expected;\n\t    }\n\t    else if (list->lv_len == 2)\n\t    {\n\t\t// make a copy, an error in pattern_match() may free it\n\t\ttofree = actual = vim_strsave(get_vim_var_str(VV_ERRMSG));\n\t\tif (actual != NULL)\n\t\t{\n\t\t    tv = &list->lv_u.mat.lv_last->li_tv;\n\t\t    expected = tv_get_string_buf_chk(tv, buf);\n\t\t    if (!pattern_match(expected, actual, FALSE))\n\t\t    {\n\t\t\terror_found = TRUE;\n\t\t\texpected_str = expected;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    wrong_arg_msg = e_assert_fails_second_arg;\n\t    goto theend;\n\t}\n\n\tif (!error_found && argvars[2].v_type != VAR_UNKNOWN\n\t\t&& argvars[3].v_type != VAR_UNKNOWN)\n\t{\n\t    if (argvars[3].v_type != VAR_NUMBER)\n\t    {\n\t\twrong_arg_msg = e_assert_fails_fourth_argument;\n\t\tgoto theend;\n\t    }\n\t    else if (argvars[3].vval.v_number >= 0\n\t\t\t && argvars[3].vval.v_number != emsg_assert_fails_lnum)\n\t    {\n\t\terror_found = TRUE;\n\t\terror_found_index = 3;\n\t    }\n\t    if (!error_found && argvars[4].v_type != VAR_UNKNOWN)\n\t    {\n\t\tif (argvars[4].v_type != VAR_STRING)\n\t\t{\n\t\t    wrong_arg_msg = e_assert_fails_fifth_argument;\n\t\t    goto theend;\n\t\t}\n\t\telse if (argvars[4].vval.v_string != NULL\n\t\t    && !pattern_match(argvars[4].vval.v_string,\n\t\t\t\t\t     emsg_assert_fails_context, FALSE))\n\t\t{\n\t\t    error_found = TRUE;\n\t\t    error_found_index = 4;\n\t\t}\n\t    }\n\t}\n\n\tif (error_found)\n\t{\n\t    typval_T actual_tv;\n\n\t    prepare_assert_error(&ga);\n\t    if (error_found_index == 3)\n\t    {\n\t\tactual_tv.v_type = VAR_NUMBER;\n\t\tactual_tv.vval.v_number = emsg_assert_fails_lnum;\n\t    }\n\t    else if (error_found_index == 4)\n\t    {\n\t\tactual_tv.v_type = VAR_STRING;\n\t\tactual_tv.vval.v_string = emsg_assert_fails_context;\n\t    }\n\t    else\n\t    {\n\t\tactual_tv.v_type = VAR_STRING;\n\t\tactual_tv.vval.v_string = actual;\n\t    }\n\t    fill_assert_error(&ga, &argvars[2], expected_str,\n\t\t\t&argvars[error_found_index], &actual_tv, ASSERT_OTHER);\n\t    ga_concat(&ga, (char_u *)\": \");\n\t    assert_append_cmd_or_arg(&ga, argvars, cmd);\n\t    assert_error(&ga);\n\t    ga_clear(&ga);\n\t    rettv->vval.v_number = 1;\n\t}\n    }\n\ntheend:\n    trylevel = save_trylevel;\n    suppress_errthrow = FALSE;\n    in_assert_fails = FALSE;\n    did_emsg = FALSE;\n    got_int = FALSE;\n    msg_col = 0;\n    need_wait_return = FALSE;\n    emsg_on_display = FALSE;\n    msg_scrolled = 0;\n    lines_left = Rows;\n    VIM_CLEAR(emsg_assert_fails_msg);\n    vim_free(tofree);\n    set_vim_var_string(VV_ERRMSG, NULL, 0);\n    if (wrong_arg_msg != NULL)\n\temsg(_(wrong_arg_msg));\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146804,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "f_assert_fails(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*cmd;\n    garray_T\tga;\n    int\t\tsave_trylevel = trylevel;\n    int\t\tcalled_emsg_before = called_emsg;\n    char\t*wrong_arg_msg = NULL;\n    char_u\t*tofree = NULL;\n\n    if (check_for_string_or_number_arg(argvars, 0) == FAIL\n\t    || check_for_opt_string_or_list_arg(argvars, 1) == FAIL\n\t    || (argvars[1].v_type != VAR_UNKNOWN\n\t\t&& (argvars[2].v_type != VAR_UNKNOWN\n\t\t    && (check_for_opt_number_arg(argvars, 3) == FAIL\n\t\t\t|| (argvars[3].v_type != VAR_UNKNOWN\n\t\t\t    && check_for_opt_string_arg(argvars, 4) == FAIL)))))\n\treturn;\n\n    cmd = tv_get_string_chk(&argvars[0]);\n\n    // trylevel must be zero for a \":throw\" command to be considered failed\n    trylevel = 0;\n    suppress_errthrow = TRUE;\n    in_assert_fails = TRUE;\n\n    do_cmdline_cmd(cmd);\n\n    // reset here for any errors reported below\n    trylevel = save_trylevel;\n    suppress_errthrow = FALSE;\n\n    if (called_emsg == called_emsg_before)\n    {\n\tprepare_assert_error(&ga);\n\tga_concat(&ga, (char_u *)\"command did not fail: \");\n\tassert_append_cmd_or_arg(&ga, argvars, cmd);\n\tassert_error(&ga);\n\tga_clear(&ga);\n\trettv->vval.v_number = 1;\n    }\n    else if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tchar_u\tbuf[NUMBUFLEN];\n\tchar_u\t*expected;\n\tchar_u\t*expected_str = NULL;\n\tint\terror_found = FALSE;\n\tint\terror_found_index = 1;\n\tchar_u\t*actual = emsg_assert_fails_msg == NULL ? (char_u *)\"[unknown]\"\n\t\t\t\t\t\t       : emsg_assert_fails_msg;\n\n\tif (argvars[1].v_type == VAR_STRING)\n\t{\n\t    expected = tv_get_string_buf_chk(&argvars[1], buf);\n\t    error_found = expected == NULL\n\t\t\t   || strstr((char *)actual, (char *)expected) == NULL;\n\t}\n\telse if (argvars[1].v_type == VAR_LIST)\n\t{\n\t    list_T\t*list = argvars[1].vval.v_list;\n\t    typval_T\t*tv;\n\n\t    if (list == NULL || list->lv_len < 1 || list->lv_len > 2)\n\t    {\n\t\twrong_arg_msg = e_assert_fails_second_arg;\n\t\tgoto theend;\n\t    }\n\t    CHECK_LIST_MATERIALIZE(list);\n\t    tv = &list->lv_first->li_tv;\n\t    expected = tv_get_string_buf_chk(tv, buf);\n\t    if (expected == NULL)\n\t\tgoto theend;\n\t    if (!pattern_match(expected, actual, FALSE))\n\t    {\n\t\terror_found = TRUE;\n\t\texpected_str = expected;\n\t    }\n\t    else if (list->lv_len == 2)\n\t    {\n\t\t// make a copy, an error in pattern_match() may free it\n\t\ttofree = actual = vim_strsave(get_vim_var_str(VV_ERRMSG));\n\t\tif (actual != NULL)\n\t\t{\n\t\t    tv = &list->lv_u.mat.lv_last->li_tv;\n\t\t    expected = tv_get_string_buf_chk(tv, buf);\n\t\t    if (expected == NULL)\n\t\t\tgoto theend;\n\t\t    if (!pattern_match(expected, actual, FALSE))\n\t\t    {\n\t\t\terror_found = TRUE;\n\t\t\texpected_str = expected;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    wrong_arg_msg = e_assert_fails_second_arg;\n\t    goto theend;\n\t}\n\n\tif (!error_found && argvars[2].v_type != VAR_UNKNOWN\n\t\t&& argvars[3].v_type != VAR_UNKNOWN)\n\t{\n\t    if (argvars[3].v_type != VAR_NUMBER)\n\t    {\n\t\twrong_arg_msg = e_assert_fails_fourth_argument;\n\t\tgoto theend;\n\t    }\n\t    else if (argvars[3].vval.v_number >= 0\n\t\t\t && argvars[3].vval.v_number != emsg_assert_fails_lnum)\n\t    {\n\t\terror_found = TRUE;\n\t\terror_found_index = 3;\n\t    }\n\t    if (!error_found && argvars[4].v_type != VAR_UNKNOWN)\n\t    {\n\t\tif (argvars[4].v_type != VAR_STRING)\n\t\t{\n\t\t    wrong_arg_msg = e_assert_fails_fifth_argument;\n\t\t    goto theend;\n\t\t}\n\t\telse if (argvars[4].vval.v_string != NULL\n\t\t    && !pattern_match(argvars[4].vval.v_string,\n\t\t\t\t\t     emsg_assert_fails_context, FALSE))\n\t\t{\n\t\t    error_found = TRUE;\n\t\t    error_found_index = 4;\n\t\t}\n\t    }\n\t}\n\n\tif (error_found)\n\t{\n\t    typval_T actual_tv;\n\n\t    prepare_assert_error(&ga);\n\t    if (error_found_index == 3)\n\t    {\n\t\tactual_tv.v_type = VAR_NUMBER;\n\t\tactual_tv.vval.v_number = emsg_assert_fails_lnum;\n\t    }\n\t    else if (error_found_index == 4)\n\t    {\n\t\tactual_tv.v_type = VAR_STRING;\n\t\tactual_tv.vval.v_string = emsg_assert_fails_context;\n\t    }\n\t    else\n\t    {\n\t\tactual_tv.v_type = VAR_STRING;\n\t\tactual_tv.vval.v_string = actual;\n\t    }\n\t    fill_assert_error(&ga, &argvars[2], expected_str,\n\t\t\t&argvars[error_found_index], &actual_tv, ASSERT_OTHER);\n\t    ga_concat(&ga, (char_u *)\": \");\n\t    assert_append_cmd_or_arg(&ga, argvars, cmd);\n\t    assert_error(&ga);\n\t    ga_clear(&ga);\n\t    rettv->vval.v_number = 1;\n\t}\n    }\n\ntheend:\n    trylevel = save_trylevel;\n    suppress_errthrow = FALSE;\n    in_assert_fails = FALSE;\n    did_emsg = FALSE;\n    got_int = FALSE;\n    msg_col = 0;\n    need_wait_return = FALSE;\n    emsg_on_display = FALSE;\n    msg_scrolled = 0;\n    lines_left = Rows;\n    VIM_CLEAR(emsg_assert_fails_msg);\n    vim_free(tofree);\n    set_vim_var_string(VV_ERRMSG, NULL, 0);\n    if (wrong_arg_msg != NULL)\n\temsg(_(wrong_arg_msg));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146805,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static FITS_HDU_LIST *fits_decode_header (FITS_RECORD_LIST *hdr,\n                        long hdr_offset, long dat_offset)\n\n{FITS_HDU_LIST *hdulist;\n FITS_DATA *fdat;\n char errmsg[80], key[9];\n int k, bpp, random_groups;\n long mul_axis, data_size, bitpix_supported;\n\n#define FITS_DECODE_CARD(mhdr,mkey,mfdat,mtyp) \\\n {strcpy (key, mkey); \\\n  mfdat = fits_decode_card (fits_search_card (mhdr, mkey), mtyp); \\\n  if (mfdat == NULL) goto err_missing; }\n\n#define FITS_TRY_CARD(mhdr,mhdu,mkey,mvar,mtyp,unionvar) \\\n {FITS_DATA *mfdat = fits_decode_card (fits_search_card (mhdr,mkey), mtyp); \\\n  mhdu->used.mvar = (mfdat != NULL); \\\n  if (mhdu->used.mvar) mhdu->mvar = mfdat->unionvar; }\n\n hdulist = fits_new_hdulist ();\n if (hdulist == NULL)\n   FITS_RETURN (\"fits_decode_header: Not enough memory\", NULL);\n\n /* Initialize the header data */\n hdulist->header_offset = hdr_offset;\n hdulist->data_offset = dat_offset;\n\n hdulist->used.simple = (strncmp (hdr->data, \"SIMPLE  \", 8) == 0);\n hdulist->used.xtension = (strncmp (hdr->data, \"XTENSION\", 8) == 0);\n if (hdulist->used.xtension)\n {\n   fdat = fits_decode_card (fits_search_card (hdr, \"XTENSION\"), typ_fstring);\n   strcpy (hdulist->xtension, fdat->fstring);\n }\n\n FITS_DECODE_CARD (hdr, \"NAXIS\", fdat, typ_flong);\n hdulist->naxis = fdat->flong;\n\n FITS_DECODE_CARD (hdr, \"BITPIX\", fdat, typ_flong);\n bpp = hdulist->bitpix = (int)fdat->flong;\n if (   (bpp != 8) && (bpp != 16) && (bpp != 32)\n     && (bpp != -32) && (bpp != -64))\n {\n   strcpy (errmsg, \"fits_decode_header: Invalid BITPIX-value\");\n   goto err_return;\n }\n if (bpp < 0) bpp = -bpp;\n bpp /= 8;\n hdulist->bpp = bpp;\n\n FITS_TRY_CARD (hdr, hdulist, \"GCOUNT\", gcount, typ_flong, flong);\n FITS_TRY_CARD (hdr, hdulist, \"PCOUNT\", pcount, typ_flong, flong);\n\n FITS_TRY_CARD (hdr, hdulist, \"GROUPS\", groups, typ_fbool, fbool);\n random_groups = hdulist->used.groups && hdulist->groups;\n\n FITS_TRY_CARD (hdr, hdulist, \"EXTEND\", extend, typ_fbool, fbool);\n\n if (hdulist->used.xtension)  /* Extension requires GCOUNT and PCOUNT */\n {\n   if ((!hdulist->used.gcount) || (!hdulist->used.pcount))\n   {\n     strcpy (errmsg, \"fits_decode_header: Missing GCOUNT/PCOUNT for XTENSION\");\n     goto err_return;\n   }\n }\n\n mul_axis = 1;\n\n /* Find all NAXISx-cards */\n for (k = 1; k <= FITS_MAX_AXIS; k++)\n {char naxisn[9];\n\n   sprintf (naxisn, \"NAXIS%-3d\", k);\n   fdat = fits_decode_card (fits_search_card (hdr, naxisn), typ_flong);\n   if (fdat == NULL)\n   {\n     k--;   /* Save the last NAXISk read */\n     break;\n   }\n   hdulist->naxisn[k-1] = (int)fdat->flong;\n   if (hdulist->naxisn[k-1] < 0)\n   {\n     strcpy (errmsg, \"fits_decode_header: Negative value in NAXISn\");\n     goto err_return;\n   }\n   if ((k == 1) && (random_groups))\n   {\n     if (hdulist->naxisn[0] != 0)\n     {\n       strcpy (errmsg, \"fits_decode_header: Random groups with NAXIS1 != 0\");\n       goto err_return;\n     }\n   }\n   else\n     mul_axis *= hdulist->naxisn[k-1];\n }\n\n if ((hdulist->naxis > 0) && (k < hdulist->naxis))\n {\n   strcpy (errmsg, \"fits_decode_card: Not enough NAXISn-cards\");\n   goto err_return;\n }\n\n /* If we have only one dimension, just set the second to size one. */\n /* So we dont have to check for naxis < 2 in some places. */\n if (hdulist->naxis < 2)\n   hdulist->naxisn[1] = 1;\n if (hdulist->naxis < 1)\n {\n   mul_axis = 0;\n   hdulist->naxisn[0] = 1;\n }\n\n if (hdulist->used.xtension)\n   data_size = bpp*hdulist->gcount*(hdulist->pcount + mul_axis);\n else\n   data_size = bpp*mul_axis;\n hdulist->udata_size = data_size;  /* Used data size without padding */\n\n /* Datasize must be a multiple of the FITS logical record size */\n data_size = (data_size + FITS_RECORD_SIZE - 1) / FITS_RECORD_SIZE;\n data_size *= FITS_RECORD_SIZE;\n hdulist->data_size = data_size;\n\n\n FITS_TRY_CARD (hdr, hdulist, \"BLANK\", blank, typ_flong, flong);\n\n FITS_TRY_CARD (hdr, hdulist, \"DATAMIN\", datamin, typ_fdouble, fdouble);\n FITS_TRY_CARD (hdr, hdulist, \"DATAMAX\", datamax, typ_fdouble, fdouble);\n\n FITS_TRY_CARD (hdr, hdulist, \"BZERO\", bzero, typ_fdouble, fdouble);\n FITS_TRY_CARD (hdr, hdulist, \"BSCALE\", bscale, typ_fdouble, fdouble);\n\n /* Evaluate number of interpretable images for this HDU */\n hdulist->numpic = 0;\n\n /* We must support this format */\n bitpix_supported =    (hdulist->bitpix > 0)\n                    || (   (hdulist->bitpix == -64)\n                        && (fits_ieee64_intel || fits_ieee64_motorola))\n                    || (   (hdulist->bitpix == -32)\n                        && (   fits_ieee32_intel || fits_ieee32_motorola\n                            || fits_ieee64_intel || fits_ieee64_motorola));\n\n if (bitpix_supported)\n {\n   if (hdulist->used.simple)\n   {\n     if (hdulist->naxis > 0)\n     {\n       hdulist->numpic = 1;\n       for (k = 3; k <= hdulist->naxis; k++)\n         hdulist->numpic *= hdulist->naxisn[k-1];\n     }\n   }\n   else if (   hdulist->used.xtension\n            && (strncmp (hdulist->xtension, \"IMAGE\", 5) == 0))\n   {\n     if (hdulist->naxis > 0)\n     {\n       hdulist->numpic = 1;\n       for (k = 3; k <= hdulist->naxis; k++)\n         hdulist->numpic *= hdulist->naxisn[k-1];\n     }\n   }\n }\n else\n {char msg[160];\n   sprintf (msg, \"fits_decode_header: IEEE floating point format required for\\\n BITPIX=%d\\nis not supported on this machine\", hdulist->bitpix);\n   fits_set_error (msg);\n }\n\n hdulist->header_record_list = hdr;  /* Add header records to the list */\n return (hdulist);\n\nerr_missing:\n sprintf (errmsg, \"fits_decode_header: missing/invalid %s card\", key);\n\nerr_return:\n fits_delete_hdulist (hdulist);\n fits_set_error (errmsg);\n return (NULL);\n\n#undef FITS_DECODE_CARD\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146834,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static FITS_HDU_LIST *fits_decode_header (FITS_RECORD_LIST *hdr,\n                        long hdr_offset, long dat_offset)\n\n{FITS_HDU_LIST *hdulist;\n FITS_DATA *fdat;\n char errmsg[80], key[9];\n int k, bpp, random_groups;\n long mul_axis, data_size, bitpix_supported;\n\n#define FITS_DECODE_CARD(mhdr,mkey,mfdat,mtyp) \\\n {strcpy (key, mkey); \\\n  mfdat = fits_decode_card (fits_search_card (mhdr, mkey), mtyp); \\\n  if (mfdat == NULL) goto err_missing; }\n\n#define FITS_TRY_CARD(mhdr,mhdu,mkey,mvar,mtyp,unionvar) \\\n {FITS_DATA *mfdat = fits_decode_card (fits_search_card (mhdr,mkey), mtyp); \\\n  mhdu->used.mvar = (mfdat != NULL); \\\n  if (mhdu->used.mvar) mhdu->mvar = mfdat->unionvar; }\n\n hdulist = fits_new_hdulist ();\n if (hdulist == NULL)\n   FITS_RETURN (\"fits_decode_header: Not enough memory\", NULL);\n\n /* Initialize the header data */\n hdulist->header_offset = hdr_offset;\n hdulist->data_offset = dat_offset;\n\n hdulist->used.simple = (strncmp (hdr->data, \"SIMPLE  \", 8) == 0);\n hdulist->used.xtension = (strncmp (hdr->data, \"XTENSION\", 8) == 0);\n if (hdulist->used.xtension)\n   {\n     fdat = fits_decode_card (fits_search_card (hdr, \"XTENSION\"), typ_fstring);\n     if (fdat != NULL)\n       {\n         strcpy (hdulist->xtension, fdat->fstring);\n       }\n     else\n       {\n         strcpy (errmsg, \"No valid XTENSION header found.\");\n         goto err_return;\n       }\n   }\n\n FITS_DECODE_CARD (hdr, \"NAXIS\", fdat, typ_flong);\n hdulist->naxis = fdat->flong;\n\n FITS_DECODE_CARD (hdr, \"BITPIX\", fdat, typ_flong);\n bpp = hdulist->bitpix = (int)fdat->flong;\n if (   (bpp != 8) && (bpp != 16) && (bpp != 32)\n     && (bpp != -32) && (bpp != -64))\n {\n   strcpy (errmsg, \"fits_decode_header: Invalid BITPIX-value\");\n   goto err_return;\n }\n if (bpp < 0) bpp = -bpp;\n bpp /= 8;\n hdulist->bpp = bpp;\n\n FITS_TRY_CARD (hdr, hdulist, \"GCOUNT\", gcount, typ_flong, flong);\n FITS_TRY_CARD (hdr, hdulist, \"PCOUNT\", pcount, typ_flong, flong);\n\n FITS_TRY_CARD (hdr, hdulist, \"GROUPS\", groups, typ_fbool, fbool);\n random_groups = hdulist->used.groups && hdulist->groups;\n\n FITS_TRY_CARD (hdr, hdulist, \"EXTEND\", extend, typ_fbool, fbool);\n\n if (hdulist->used.xtension)  /* Extension requires GCOUNT and PCOUNT */\n {\n   if ((!hdulist->used.gcount) || (!hdulist->used.pcount))\n   {\n     strcpy (errmsg, \"fits_decode_header: Missing GCOUNT/PCOUNT for XTENSION\");\n     goto err_return;\n   }\n }\n\n mul_axis = 1;\n\n /* Find all NAXISx-cards */\n for (k = 1; k <= FITS_MAX_AXIS; k++)\n {char naxisn[9];\n\n   sprintf (naxisn, \"NAXIS%-3d\", k);\n   fdat = fits_decode_card (fits_search_card (hdr, naxisn), typ_flong);\n   if (fdat == NULL)\n   {\n     k--;   /* Save the last NAXISk read */\n     break;\n   }\n   hdulist->naxisn[k-1] = (int)fdat->flong;\n   if (hdulist->naxisn[k-1] < 0)\n   {\n     strcpy (errmsg, \"fits_decode_header: Negative value in NAXISn\");\n     goto err_return;\n   }\n   if ((k == 1) && (random_groups))\n   {\n     if (hdulist->naxisn[0] != 0)\n     {\n       strcpy (errmsg, \"fits_decode_header: Random groups with NAXIS1 != 0\");\n       goto err_return;\n     }\n   }\n   else\n     mul_axis *= hdulist->naxisn[k-1];\n }\n\n if ((hdulist->naxis > 0) && (k < hdulist->naxis))\n {\n   strcpy (errmsg, \"fits_decode_card: Not enough NAXISn-cards\");\n   goto err_return;\n }\n\n /* If we have only one dimension, just set the second to size one. */\n /* So we dont have to check for naxis < 2 in some places. */\n if (hdulist->naxis < 2)\n   hdulist->naxisn[1] = 1;\n if (hdulist->naxis < 1)\n {\n   mul_axis = 0;\n   hdulist->naxisn[0] = 1;\n }\n\n if (hdulist->used.xtension)\n   data_size = bpp*hdulist->gcount*(hdulist->pcount + mul_axis);\n else\n   data_size = bpp*mul_axis;\n hdulist->udata_size = data_size;  /* Used data size without padding */\n\n /* Datasize must be a multiple of the FITS logical record size */\n data_size = (data_size + FITS_RECORD_SIZE - 1) / FITS_RECORD_SIZE;\n data_size *= FITS_RECORD_SIZE;\n hdulist->data_size = data_size;\n\n\n FITS_TRY_CARD (hdr, hdulist, \"BLANK\", blank, typ_flong, flong);\n\n FITS_TRY_CARD (hdr, hdulist, \"DATAMIN\", datamin, typ_fdouble, fdouble);\n FITS_TRY_CARD (hdr, hdulist, \"DATAMAX\", datamax, typ_fdouble, fdouble);\n\n FITS_TRY_CARD (hdr, hdulist, \"BZERO\", bzero, typ_fdouble, fdouble);\n FITS_TRY_CARD (hdr, hdulist, \"BSCALE\", bscale, typ_fdouble, fdouble);\n\n /* Evaluate number of interpretable images for this HDU */\n hdulist->numpic = 0;\n\n /* We must support this format */\n bitpix_supported =    (hdulist->bitpix > 0)\n                    || (   (hdulist->bitpix == -64)\n                        && (fits_ieee64_intel || fits_ieee64_motorola))\n                    || (   (hdulist->bitpix == -32)\n                        && (   fits_ieee32_intel || fits_ieee32_motorola\n                            || fits_ieee64_intel || fits_ieee64_motorola));\n\n if (bitpix_supported)\n {\n   if (hdulist->used.simple)\n   {\n     if (hdulist->naxis > 0)\n     {\n       hdulist->numpic = 1;\n       for (k = 3; k <= hdulist->naxis; k++)\n         hdulist->numpic *= hdulist->naxisn[k-1];\n     }\n   }\n   else if (   hdulist->used.xtension\n            && (strncmp (hdulist->xtension, \"IMAGE\", 5) == 0))\n   {\n     if (hdulist->naxis > 0)\n     {\n       hdulist->numpic = 1;\n       for (k = 3; k <= hdulist->naxis; k++)\n         hdulist->numpic *= hdulist->naxisn[k-1];\n     }\n   }\n }\n else\n {char msg[160];\n   sprintf (msg, \"fits_decode_header: IEEE floating point format required for\\\n BITPIX=%d\\nis not supported on this machine\", hdulist->bitpix);\n   fits_set_error (msg);\n }\n\n hdulist->header_record_list = hdr;  /* Add header records to the list */\n return (hdulist);\n\nerr_missing:\n sprintf (errmsg, \"fits_decode_header: missing/invalid %s card\", key);\n\nerr_return:\n fits_delete_hdulist (hdulist);\n fits_set_error (errmsg);\n return (NULL);\n\n#undef FITS_DECODE_CARD\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146835,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "ec_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n          krb5_enc_tkt_part *enc_tkt_reply, krb5_pa_data *data,\n          krb5_kdcpreauth_callbacks cb, krb5_kdcpreauth_rock rock,\n          krb5_kdcpreauth_moddata moddata,\n          krb5_kdcpreauth_verify_respond_fn respond, void *arg)\n{\n    krb5_error_code retval = 0;\n    krb5_enc_data *enc = NULL;\n    krb5_data scratch, plain;\n    krb5_keyblock *armor_key = cb->fast_armor(context, rock);\n    krb5_pa_enc_ts *ts = NULL;\n    krb5_keyblock *client_keys = NULL;\n    krb5_keyblock *challenge_key = NULL;\n    krb5_keyblock *kdc_challenge_key;\n    krb5_kdcpreauth_modreq modreq = NULL;\n    int i = 0;\n    char *ai = NULL, *realmstr = NULL;\n    krb5_data realm = request->server->realm;\n\n    plain.data = NULL;\n\n    if (armor_key == NULL) {\n        retval = ENOENT;\n        k5_setmsg(context, ENOENT,\n                  _(\"Encrypted Challenge used outside of FAST tunnel\"));\n    }\n    scratch.data = (char *) data->contents;\n    scratch.length = data->length;\n    if (retval == 0)\n        retval = decode_krb5_enc_data(&scratch, &enc);\n    if (retval == 0) {\n        plain.data =  malloc(enc->ciphertext.length);\n        plain.length = enc->ciphertext.length;\n        if (plain.data == NULL)\n            retval = ENOMEM;\n    }\n\n    /* Check for a configured FAST ec auth indicator. */\n    realmstr = k5memdup0(realm.data, realm.length, &retval);\n    if (realmstr != NULL)\n        retval = profile_get_string(context->profile, KRB5_CONF_REALMS,\n                                    realmstr,\n                                    KRB5_CONF_ENCRYPTED_CHALLENGE_INDICATOR,\n                                    NULL, &ai);\n\n    if (retval == 0)\n        retval = cb->client_keys(context, rock, &client_keys);\n    if (retval == 0) {\n        for (i = 0; client_keys[i].enctype&& (retval == 0); i++ ) {\n            retval = krb5_c_fx_cf2_simple(context,\n                                          armor_key, \"clientchallengearmor\",\n                                          &client_keys[i], \"challengelongterm\",\n                                          &challenge_key);\n            if (retval == 0)\n                retval  = krb5_c_decrypt(context, challenge_key,\n                                         KRB5_KEYUSAGE_ENC_CHALLENGE_CLIENT,\n                                         NULL, enc, &plain);\n            if (challenge_key)\n                krb5_free_keyblock(context, challenge_key);\n            challenge_key = NULL;\n            if (retval == 0)\n                break;\n            /*We failed to decrypt. Try next key*/\n            retval = 0;\n        }\n        if (client_keys[i].enctype == 0) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            k5_setmsg(context, retval,\n                      _(\"Incorrect password in encrypted challenge\"));\n        }\n    }\n    if (retval == 0)\n        retval = decode_krb5_pa_enc_ts(&plain, &ts);\n    if (retval == 0)\n        retval = krb5_check_clockskew(context, ts->patimestamp);\n    if (retval == 0) {\n        enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n        /*\n         * If this fails, we won't generate a reply to the client.  That may\n         * cause the client to fail, but at this point the KDC has considered\n         * this a success, so the return value is ignored.\n         */\n        if (krb5_c_fx_cf2_simple(context, armor_key, \"kdcchallengearmor\",\n                                 &client_keys[i], \"challengelongterm\",\n                                 &kdc_challenge_key) == 0) {\n            modreq = (krb5_kdcpreauth_modreq)kdc_challenge_key;\n            if (ai != NULL)\n                cb->add_auth_indicator(context, rock, ai);\n        }\n    }\n    cb->free_keys(context, rock, client_keys);\n    if (plain.data)\n        free(plain.data);\n    if (enc)\n        krb5_free_enc_data(context, enc);\n    if (ts)\n        krb5_free_pa_enc_ts(context, ts);\n    free(realmstr);\n    free(ai);\n\n    (*respond)(arg, retval, modreq, NULL, NULL);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146858,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "ec_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n          krb5_enc_tkt_part *enc_tkt_reply, krb5_pa_data *data,\n          krb5_kdcpreauth_callbacks cb, krb5_kdcpreauth_rock rock,\n          krb5_kdcpreauth_moddata moddata,\n          krb5_kdcpreauth_verify_respond_fn respond, void *arg)\n{\n    krb5_error_code retval = 0;\n    krb5_enc_data *enc = NULL;\n    krb5_data scratch, plain;\n    krb5_keyblock *armor_key = cb->fast_armor(context, rock);\n    krb5_pa_enc_ts *ts = NULL;\n    krb5_keyblock *client_keys = NULL;\n    krb5_keyblock *challenge_key = NULL;\n    krb5_keyblock *kdc_challenge_key;\n    krb5_kdcpreauth_modreq modreq = NULL;\n    int i = 0;\n    char *ai = NULL, *realmstr = NULL;\n    krb5_data realm = request->server->realm;\n\n    plain.data = NULL;\n\n    if (armor_key == NULL) {\n        retval = ENOENT;\n        k5_setmsg(context, ENOENT,\n                  _(\"Encrypted Challenge used outside of FAST tunnel\"));\n    }\n    scratch.data = (char *) data->contents;\n    scratch.length = data->length;\n    if (retval == 0)\n        retval = decode_krb5_enc_data(&scratch, &enc);\n    if (retval == 0) {\n        plain.data =  malloc(enc->ciphertext.length);\n        plain.length = enc->ciphertext.length;\n        if (plain.data == NULL)\n            retval = ENOMEM;\n    }\n\n    /* Check for a configured FAST ec auth indicator. */\n    if (retval == 0)\n        realmstr = k5memdup0(realm.data, realm.length, &retval);\n    if (realmstr != NULL)\n        retval = profile_get_string(context->profile, KRB5_CONF_REALMS,\n                                    realmstr,\n                                    KRB5_CONF_ENCRYPTED_CHALLENGE_INDICATOR,\n                                    NULL, &ai);\n\n    if (retval == 0)\n        retval = cb->client_keys(context, rock, &client_keys);\n    if (retval == 0) {\n        for (i = 0; client_keys[i].enctype&& (retval == 0); i++ ) {\n            retval = krb5_c_fx_cf2_simple(context,\n                                          armor_key, \"clientchallengearmor\",\n                                          &client_keys[i], \"challengelongterm\",\n                                          &challenge_key);\n            if (retval == 0)\n                retval  = krb5_c_decrypt(context, challenge_key,\n                                         KRB5_KEYUSAGE_ENC_CHALLENGE_CLIENT,\n                                         NULL, enc, &plain);\n            if (challenge_key)\n                krb5_free_keyblock(context, challenge_key);\n            challenge_key = NULL;\n            if (retval == 0)\n                break;\n            /*We failed to decrypt. Try next key*/\n            retval = 0;\n        }\n        if (client_keys[i].enctype == 0) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            k5_setmsg(context, retval,\n                      _(\"Incorrect password in encrypted challenge\"));\n        }\n    }\n    if (retval == 0)\n        retval = decode_krb5_pa_enc_ts(&plain, &ts);\n    if (retval == 0)\n        retval = krb5_check_clockskew(context, ts->patimestamp);\n    if (retval == 0) {\n        enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n        /*\n         * If this fails, we won't generate a reply to the client.  That may\n         * cause the client to fail, but at this point the KDC has considered\n         * this a success, so the return value is ignored.\n         */\n        if (krb5_c_fx_cf2_simple(context, armor_key, \"kdcchallengearmor\",\n                                 &client_keys[i], \"challengelongterm\",\n                                 &kdc_challenge_key) == 0) {\n            modreq = (krb5_kdcpreauth_modreq)kdc_challenge_key;\n            if (ai != NULL)\n                cb->add_auth_indicator(context, rock, ai);\n        }\n    }\n    cb->free_keys(context, rock, client_keys);\n    if (plain.data)\n        free(plain.data);\n    if (enc)\n        krb5_free_enc_data(context, enc);\n    if (ts)\n        krb5_free_pa_enc_ts(context, ts);\n    free(realmstr);\n    free(ai);\n\n    (*respond)(arg, retval, modreq, NULL, NULL);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146859,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int ssh_buffer_add_data(struct ssh_buffer_struct *buffer, const void *data, uint32_t len)\n{\n    buffer_verify(buffer);\n\n    if (data == NULL) {\n        return -1;\n    }\n\n    if (buffer->used + len < len) {\n        return -1;\n    }\n\n    if (buffer->allocated < (buffer->used + len)) {\n        if (buffer->pos > 0) {\n            buffer_shift(buffer);\n        }\n        if (realloc_buffer(buffer, buffer->used + len) < 0) {\n            return -1;\n        }\n    }\n\n    memcpy(buffer->data + buffer->used, data, len);\n    buffer->used += len;\n    buffer_verify(buffer);\n    return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146870,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int ssh_buffer_add_data(struct ssh_buffer_struct *buffer, const void *data, uint32_t len)\n{\n    if (buffer == NULL) {\n        return -1;\n    }\n\n    buffer_verify(buffer);\n\n    if (data == NULL) {\n        return -1;\n    }\n\n    if (buffer->used + len < len) {\n        return -1;\n    }\n\n    if (buffer->allocated < (buffer->used + len)) {\n        if (buffer->pos > 0) {\n            buffer_shift(buffer);\n        }\n        if (realloc_buffer(buffer, buffer->used + len) < 0) {\n            return -1;\n        }\n    }\n\n    memcpy(buffer->data + buffer->used, data, len);\n    buffer->used += len;\n    buffer_verify(buffer);\n    return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146871,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "jas_image_t *jp2_decode(jas_stream_t *in, const char *optstr)\n{\n\tjp2_box_t *box;\n\tint found;\n\tjas_image_t *image;\n\tjp2_dec_t *dec;\n\tbool samedtype;\n\tint dtype;\n\tunsigned int i;\n\tjp2_cmap_t *cmapd;\n\tjp2_pclr_t *pclrd;\n\tjp2_cdef_t *cdefd;\n\tunsigned int channo;\n\tint newcmptno;\n\tint_fast32_t *lutents;\n#if 0\n\tjp2_cdefchan_t *cdefent;\n\tint cmptno;\n#endif\n\tjp2_cmapent_t *cmapent;\n\tjas_icchdr_t icchdr;\n\tjas_iccprof_t *iccprof;\n\n\tdec = 0;\n\tbox = 0;\n\timage = 0;\n\n\tJAS_DBGLOG(100, (\"jp2_decode(%p, \\\"%s\\\")\\n\", in, optstr));\n\n\tif (!(dec = jp2_dec_create())) {\n\t\tgoto error;\n\t}\n\n\t/* Get the first box.  This should be a JP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tjas_eprintf(\"error: cannot get box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_JP) {\n\t\tjas_eprintf(\"error: expecting signature box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->data.jp.magic != JP2_JP_MAGIC) {\n\t\tjas_eprintf(\"incorrect magic number\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get the second box.  This should be a FTYP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_FTYP) {\n\t\tjas_eprintf(\"expecting file type box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get more boxes... */\n\tfound = 0;\n\twhile ((box = jp2_box_get(in))) {\n\t\tif (jas_getdbglevel() >= 1) {\n\t\t\tjas_eprintf(\"got box type %s\\n\", box->info->name);\n\t\t}\n\t\tswitch (box->type) {\n\t\tcase JP2_BOX_JP2C:\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\tcase JP2_BOX_IHDR:\n\t\t\tif (!dec->ihdr) {\n\t\t\t\tdec->ihdr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_BPCC:\n\t\t\tif (!dec->bpcc) {\n\t\t\t\tdec->bpcc = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CDEF:\n\t\t\tif (!dec->cdef) {\n\t\t\t\tdec->cdef = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_PCLR:\n\t\t\tif (!dec->pclr) {\n\t\t\t\tdec->pclr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CMAP:\n\t\t\tif (!dec->cmap) {\n\t\t\t\tdec->cmap = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_COLR:\n\t\t\tif (!dec->colr) {\n\t\t\t\tdec->colr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (box) {\n\t\t\tjp2_box_destroy(box);\n\t\t\tbox = 0;\n\t\t}\n\t\tif (found) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tjas_eprintf(\"error: no code stream found\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!(dec->image = jpc_decode(in, optstr))) {\n\t\tjas_eprintf(\"error: cannot decode code stream\\n\");\n\t\tgoto error;\n\t}\n\n\t/* An IHDR box must be present. */\n\tif (!dec->ihdr) {\n\t\tjas_eprintf(\"error: missing IHDR box\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Does the number of components indicated in the IHDR box match\n\t  the value specified in the code stream? */\n\tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(jas_uint,\n\t  jas_image_numcmpts(dec->image))) {\n\t\tjas_eprintf(\"error: number of components mismatch (IHDR)\\n\");\n\t\tgoto error;\n\t}\n\n\t/* At least one component must be present. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Determine if all components have the same data type. */\n\tsamedtype = true;\n\tdtype = jas_image_cmptdtype(dec->image, 0);\n\tfor (i = 1; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tif (jas_image_cmptdtype(dec->image, i) != dtype) {\n\t\t\tsamedtype = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Is the component data type indicated in the IHDR box consistent\n\t  with the data in the code stream? */\n\tif ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||\n\t  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {\n\t\tjas_eprintf(\"error: component data type mismatch (IHDR)\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Is the compression type supported? */\n\tif (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {\n\t\tjas_eprintf(\"error: unsupported compression type\\n\");\n\t\tgoto error;\n\t}\n\n\tif (dec->bpcc) {\n\t\t/* Is the number of components indicated in the BPCC box\n\t\t  consistent with the code stream data? */\n\t\tif (dec->bpcc->data.bpcc.numcmpts !=\n\t\t  JAS_CAST(jas_uint, jas_image_numcmpts(dec->image))) {\n\t\t\tjas_eprintf(\"error: number of components mismatch (BPCC)\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\t/* Is the component data type information indicated in the BPCC\n\t\t  box consistent with the code stream data? */\n\t\tif (!samedtype) {\n\t\t\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\t\t\t  ++i) {\n\t\t\t\tif (jas_image_cmptdtype(dec->image, i) !=\n\t\t\t\t  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {\n\t\t\t\t\tjas_eprintf(\"error: component data type mismatch (BPCC)\\n\");\n\t\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tjas_eprintf(\"warning: superfluous BPCC box\\n\");\n\t\t}\n\t}\n\n\t/* A COLR box must be present. */\n\tif (!dec->colr) {\n\t\tjas_eprintf(\"error: no COLR box\\n\");\n\t\tgoto error;\n\t}\n\n\tswitch (dec->colr->data.colr.method) {\n\tcase JP2_COLR_ENUM:\n\t\tjas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\ticcprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,\n\t\t  dec->colr->data.colr.iccplen);\n\t\tif (!iccprof) {\n\t\t\tjas_eprintf(\"error: failed to parse ICC profile\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_iccprof_gethdr(iccprof, &icchdr);\n\t\tjas_eprintf(\"ICC Profile CS %08x\\n\", icchdr.colorspc);\n\t\tjas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));\n\t\tdec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);\n\t\tif (!dec->image->cmprof_) {\n\t\t\tjas_iccprof_destroy(iccprof);\n\t\t\tgoto error;\n\t\t}\n\t\tjas_iccprof_destroy(iccprof);\n\t\tbreak;\n\t}\n\n\t/* If a CMAP box is present, a PCLR box must also be present. */\n\tif (dec->cmap && !dec->pclr) {\n\t\tjas_eprintf(\"warning: missing PCLR box or superfluous CMAP box\\n\");\n\t\tjp2_box_destroy(dec->cmap);\n\t\tdec->cmap = 0;\n\t}\n\n\t/* If a CMAP box is not present, a PCLR box must not be present. */\n\tif (!dec->cmap && dec->pclr) {\n\t\tjas_eprintf(\"warning: missing CMAP box or superfluous PCLR box\\n\");\n\t\tjp2_box_destroy(dec->pclr);\n\t\tdec->pclr = 0;\n\t}\n\n\t/* Determine the number of channels (which is essentially the number\n\t  of components after any palette mappings have been applied). */\n\tdec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :\n\t  JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\n\t/* Perform a basic sanity check on the CMAP box if present. */\n\tif (dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the component number reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(jas_uint,\n\t\t\t  jas_image_numcmpts(dec->image))) {\n\t\t\t\tjas_eprintf(\"error: invalid component number in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/* Is the LUT index reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].pcol >=\n\t\t\t  dec->pclr->data.pclr.numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid CMAP LUT index\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Allocate space for the channel-number to component-number LUT. */\n\tif (!(dec->chantocmptlut = jas_alloc2(dec->numchans,\n\t  sizeof(uint_fast16_t)))) {\n\t\tjas_eprintf(\"error: no memory\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tdec->chantocmptlut[i] = i;\n\t\t}\n\t} else {\n\t\tcmapd = &dec->cmap->data.cmap;\n\t\tpclrd = &dec->pclr->data.pclr;\n\t\tcdefd = &dec->cdef->data.cdef;\n\t\tfor (channo = 0; channo < cmapd->numchans; ++channo) {\n\t\t\tcmapent = &cmapd->ents[channo];\n\t\t\tif (cmapent->map == JP2_CMAP_DIRECT) {\n\t\t\t\tdec->chantocmptlut[channo] = channo;\n\t\t\t} else if (cmapent->map == JP2_CMAP_PALETTE) {\n\t\t\t\tif (!pclrd->numlutents) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tlutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));\n\t\t\t\tif (!lutents) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < pclrd->numlutents; ++i) {\n\t\t\t\t\tlutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];\n\t\t\t\t}\n\t\t\t\tnewcmptno = jas_image_numcmpts(dec->image);\n\t\t\t\tjas_image_depalettize(dec->image, cmapent->cmptno,\n\t\t\t\t  pclrd->numlutents, lutents,\n\t\t\t\t  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);\n\t\t\t\tdec->chantocmptlut[channo] = newcmptno;\n\t\t\t\tjas_free(lutents);\n#if 0\n\t\t\t\tif (dec->cdef) {\n\t\t\t\t\tcdefent = jp2_cdef_lookup(cdefd, channo);\n\t\t\t\t\tif (!cdefent) {\n\t\t\t\t\t\tabort();\n\t\t\t\t\t}\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));\n\t\t\t\t} else {\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));\n\t\t\t\t}\n#else\n\t\t\t\t/* suppress -Wunused-but-set-variable */\n\t\t\t\t(void)cdefd;\n#endif\n\t\t\t} else {\n\t\t\t\tjas_eprintf(\"error: invalid MTYP in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Ensure that the number of channels being used by the decoder\n\t  matches the number of image components. */\n\tif (dec->numchans != jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: mismatch in number of components (%d != %d)\\n\",\n\t\t  dec->numchans, jas_image_numcmpts(dec->image));\n\t\tgoto error;\n\t}\n\n\t/* Mark all components as being of unknown type. */\n\n\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tjas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);\n\t}\n\n\t/* Determine the type of each component. */\n\tif (dec->cdef) {\n\t\tfor (i = 0; i < dec->cdef->data.cdef.numchans; ++i) {\n\t\t\tuint_fast16_t channo = dec->cdef->data.cdef.ents[i].channo;\n\t\t\t/* Is the channel number reasonable? */\n\t\t\tif (channo >= dec->numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid channel number in CDEF box (%d)\\n\",\n\t\t\t\t  channo);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tunsigned compno = dec->chantocmptlut[channo];\n\t\t\tif (compno >= jas_image_numcmpts(dec->image)) {\n\t\t\t\tjas_eprintf(\n\t\t\t\t  \"error: invalid component reference in CDEF box (%d)\\n\",\n\t\t\t\t  compno);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_setcmpttype(dec->image, compno,\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image),\n\t\t\t  dec->cdef->data.cdef.ents[i].type,\n\t\t\t  dec->cdef->data.cdef.ents[i].assoc));\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tjas_image_setcmpttype(dec->image, dec->chantocmptlut[i],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));\n\t\t}\n\t}\n\n\t/* Delete any components that are not of interest. */\n\tfor (i = jas_image_numcmpts(dec->image); i > 0; --i) {\n\t\tif (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {\n\t\t\tjas_image_delcmpt(dec->image, i - 1);\n\t\t}\n\t}\n\n\t/* Ensure that some components survived. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n#if 0\njas_eprintf(\"no of components is %d\\n\", jas_image_numcmpts(dec->image));\n#endif\n\n\t/* Prevent the image from being destroyed later. */\n\timage = dec->image;\n\tdec->image = 0;\n\n\tjp2_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (dec) {\n\t\tjp2_dec_destroy(dec);\n\t}\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146894,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "jas_image_t *jp2_decode(jas_stream_t *in, const char *optstr)\n{\n\tjp2_box_t *box;\n\tint found;\n\tjas_image_t *image;\n\tjp2_dec_t *dec;\n\tbool samedtype;\n\tint dtype;\n\tunsigned int i;\n\tjp2_cmap_t *cmapd;\n\tjp2_pclr_t *pclrd;\n\tjp2_cdef_t *cdefd;\n\tunsigned int channo;\n\tint newcmptno;\n\tint_fast32_t *lutents;\n#if 0\n\tjp2_cdefchan_t *cdefent;\n\tint cmptno;\n#endif\n\tjp2_cmapent_t *cmapent;\n\tjas_icchdr_t icchdr;\n\tjas_iccprof_t *iccprof;\n\n\tdec = 0;\n\tbox = 0;\n\timage = 0;\n\n\tJAS_DBGLOG(100, (\"jp2_decode(%p, \\\"%s\\\")\\n\", in, optstr));\n\n\tif (!(dec = jp2_dec_create())) {\n\t\tgoto error;\n\t}\n\n\t/* Get the first box.  This should be a JP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tjas_eprintf(\"error: cannot get box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_JP) {\n\t\tjas_eprintf(\"error: expecting signature box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->data.jp.magic != JP2_JP_MAGIC) {\n\t\tjas_eprintf(\"incorrect magic number\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get the second box.  This should be a FTYP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_FTYP) {\n\t\tjas_eprintf(\"expecting file type box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get more boxes... */\n\tfound = 0;\n\twhile ((box = jp2_box_get(in))) {\n\t\tif (jas_getdbglevel() >= 1) {\n\t\t\tjas_eprintf(\"got box type %s\\n\", box->info->name);\n\t\t}\n\t\tswitch (box->type) {\n\t\tcase JP2_BOX_JP2C:\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\tcase JP2_BOX_IHDR:\n\t\t\tif (!dec->ihdr) {\n\t\t\t\tdec->ihdr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_BPCC:\n\t\t\tif (!dec->bpcc) {\n\t\t\t\tdec->bpcc = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CDEF:\n\t\t\tif (!dec->cdef) {\n\t\t\t\tdec->cdef = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_PCLR:\n\t\t\tif (!dec->pclr) {\n\t\t\t\tdec->pclr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CMAP:\n\t\t\tif (!dec->cmap) {\n\t\t\t\tdec->cmap = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_COLR:\n\t\t\tif (!dec->colr) {\n\t\t\t\tdec->colr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (box) {\n\t\t\tjp2_box_destroy(box);\n\t\t\tbox = 0;\n\t\t}\n\t\tif (found) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tjas_eprintf(\"error: no code stream found\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!(dec->image = jpc_decode(in, optstr))) {\n\t\tjas_eprintf(\"error: cannot decode code stream\\n\");\n\t\tgoto error;\n\t}\n\n\t/* An IHDR box must be present. */\n\tif (!dec->ihdr) {\n\t\tjas_eprintf(\"error: missing IHDR box\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Does the number of components indicated in the IHDR box match\n\t  the value specified in the code stream? */\n\tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(jas_uint,\n\t  jas_image_numcmpts(dec->image))) {\n\t\tjas_eprintf(\"error: number of components mismatch (IHDR)\\n\");\n\t\tgoto error;\n\t}\n\n\t/* At least one component must be present. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Determine if all components have the same data type. */\n\tsamedtype = true;\n\tdtype = jas_image_cmptdtype(dec->image, 0);\n\tfor (i = 1; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tif (jas_image_cmptdtype(dec->image, i) != dtype) {\n\t\t\tsamedtype = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Is the component data type indicated in the IHDR box consistent\n\t  with the data in the code stream? */\n\tif ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||\n\t  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {\n\t\tjas_eprintf(\"error: component data type mismatch (IHDR)\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Is the compression type supported? */\n\tif (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {\n\t\tjas_eprintf(\"error: unsupported compression type\\n\");\n\t\tgoto error;\n\t}\n\n\tif (dec->bpcc) {\n\t\t/* Is the number of components indicated in the BPCC box\n\t\t  consistent with the code stream data? */\n\t\tif (dec->bpcc->data.bpcc.numcmpts !=\n\t\t  JAS_CAST(jas_uint, jas_image_numcmpts(dec->image))) {\n\t\t\tjas_eprintf(\"error: number of components mismatch (BPCC)\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\t/* Is the component data type information indicated in the BPCC\n\t\t  box consistent with the code stream data? */\n\t\tif (!samedtype) {\n\t\t\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\t\t\t  ++i) {\n\t\t\t\tif (jas_image_cmptdtype(dec->image, i) !=\n\t\t\t\t  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {\n\t\t\t\t\tjas_eprintf(\"error: component data type mismatch (BPCC)\\n\");\n\t\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tjas_eprintf(\"warning: superfluous BPCC box\\n\");\n\t\t}\n\t}\n\n\t/* A COLR box must be present. */\n\tif (!dec->colr) {\n\t\tjas_eprintf(\"error: no COLR box\\n\");\n\t\tgoto error;\n\t}\n\n\tswitch (dec->colr->data.colr.method) {\n\tcase JP2_COLR_ENUM:\n\t\tjas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\ticcprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,\n\t\t  dec->colr->data.colr.iccplen);\n\t\tif (!iccprof) {\n\t\t\tjas_eprintf(\"error: failed to parse ICC profile\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_iccprof_gethdr(iccprof, &icchdr);\n\t\tjas_eprintf(\"ICC Profile CS %08x\\n\", icchdr.colorspc);\n\t\tjas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));\n\t\tdec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);\n\t\tif (!dec->image->cmprof_) {\n\t\t\tjas_iccprof_destroy(iccprof);\n\t\t\tgoto error;\n\t\t}\n\t\tjas_iccprof_destroy(iccprof);\n\t\tbreak;\n\t}\n\n\t/* If a CMAP box is present, a PCLR box must also be present. */\n\tif (dec->cmap && !dec->pclr) {\n\t\tjas_eprintf(\"warning: missing PCLR box or superfluous CMAP box\\n\");\n\t\tjp2_box_destroy(dec->cmap);\n\t\tdec->cmap = 0;\n\t}\n\n\t/* If a CMAP box is not present, a PCLR box must not be present. */\n\tif (!dec->cmap && dec->pclr) {\n\t\tjas_eprintf(\"warning: missing CMAP box or superfluous PCLR box\\n\");\n\t\tjp2_box_destroy(dec->pclr);\n\t\tdec->pclr = 0;\n\t}\n\n\t/* Determine the number of channels (which is essentially the number\n\t  of components after any palette mappings have been applied). */\n\tdec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :\n\t  JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\n\t/* Perform a basic sanity check on the CMAP box if present. */\n\tif (dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the component number reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(jas_uint,\n\t\t\t  jas_image_numcmpts(dec->image))) {\n\t\t\t\tjas_eprintf(\"error: invalid component number in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/* Is the LUT index reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].pcol >=\n\t\t\t  dec->pclr->data.pclr.numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid CMAP LUT index\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Allocate space for the channel-number to component-number LUT. */\n\tif (!(dec->chantocmptlut = jas_alloc2(dec->numchans,\n\t  sizeof(uint_fast16_t)))) {\n\t\tjas_eprintf(\"error: no memory\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tdec->chantocmptlut[i] = i;\n\t\t}\n\t} else {\n\t\tcmapd = &dec->cmap->data.cmap;\n\t\tpclrd = &dec->pclr->data.pclr;\n\t\tcdefd = &dec->cdef->data.cdef;\n\t\tfor (channo = 0; channo < cmapd->numchans; ++channo) {\n\t\t\tcmapent = &cmapd->ents[channo];\n\t\t\tif (cmapent->map == JP2_CMAP_DIRECT) {\n\t\t\t\tdec->chantocmptlut[channo] = channo;\n\t\t\t} else if (cmapent->map == JP2_CMAP_PALETTE) {\n\t\t\t\tif (!pclrd->numlutents) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tlutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));\n\t\t\t\tif (!lutents) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < pclrd->numlutents; ++i) {\n\t\t\t\t\tlutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];\n\t\t\t\t}\n\t\t\t\tnewcmptno = jas_image_numcmpts(dec->image);\n\t\t\t\tjas_image_depalettize(dec->image, cmapent->cmptno,\n\t\t\t\t  pclrd->numlutents, lutents,\n\t\t\t\t  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);\n\t\t\t\tdec->chantocmptlut[channo] = newcmptno;\n\t\t\t\tjas_free(lutents);\n#if 0\n\t\t\t\tif (dec->cdef) {\n\t\t\t\t\tcdefent = jp2_cdef_lookup(cdefd, channo);\n\t\t\t\t\tif (!cdefent) {\n\t\t\t\t\t\tabort();\n\t\t\t\t\t}\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));\n\t\t\t\t} else {\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));\n\t\t\t\t}\n#else\n\t\t\t\t/* suppress -Wunused-but-set-variable */\n\t\t\t\t(void)cdefd;\n#endif\n\t\t\t} else {\n\t\t\t\tjas_eprintf(\"error: invalid MTYP in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Ensure that the number of channels being used by the decoder\n\t  matches the number of image components. */\n\tif (dec->numchans != jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: mismatch in number of components (%d != %d)\\n\",\n\t\t  dec->numchans, jas_image_numcmpts(dec->image));\n\t\tgoto error;\n\t}\n\n\t/* Mark all components as being of unknown type. */\n\n\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tjas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);\n\t}\n\n\t/* Determine the type of each component. */\n\tif (dec->cdef) {\n\t\tfor (i = 0; i < dec->cdef->data.cdef.numchans; ++i) {\n\t\t\tuint_fast16_t channo = dec->cdef->data.cdef.ents[i].channo;\n\t\t\t/* Is the channel number reasonable? */\n\t\t\tif (channo >= dec->numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid channel number in CDEF box (%d)\\n\",\n\t\t\t\t  channo);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tunsigned compno = dec->chantocmptlut[channo];\n\t\t\tif (compno >= jas_image_numcmpts(dec->image)) {\n\t\t\t\tjas_eprintf(\n\t\t\t\t  \"error: invalid component reference in CDEF box (%d)\\n\",\n\t\t\t\t  compno);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_setcmpttype(dec->image, compno,\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image),\n\t\t\t  dec->cdef->data.cdef.ents[i].type,\n\t\t\t  dec->cdef->data.cdef.ents[i].assoc));\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tunsigned compno = dec->chantocmptlut[i];\n\t\t\tif (compno >= jas_image_numcmpts(dec->image)) {\n\t\t\t\tjas_eprintf(\n\t\t\t\t  \"error: invalid component reference (%d)\\n\", compno);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_setcmpttype(dec->image, compno,\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));\n\t\t}\n\t}\n\n\t/* Delete any components that are not of interest. */\n\tfor (i = jas_image_numcmpts(dec->image); i > 0; --i) {\n\t\tif (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {\n\t\t\tjas_image_delcmpt(dec->image, i - 1);\n\t\t}\n\t}\n\n\t/* Ensure that some components survived. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n#if 0\njas_eprintf(\"no of components is %d\\n\", jas_image_numcmpts(dec->image));\n#endif\n\n\t/* Prevent the image from being destroyed later. */\n\timage = dec->image;\n\tdec->image = 0;\n\n\tjp2_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (dec) {\n\t\tjp2_dec_destroy(dec);\n\t}\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146895,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "   Send an email message */\nPHP_FUNCTION(imap_mail)\n{\n\tchar *to=NULL, *message=NULL, *headers=NULL, *subject=NULL, *cc=NULL, *bcc=NULL, *rpath=NULL;\n\tint to_len, message_len, headers_len, subject_len, cc_len, bcc_len, rpath_len, argc = ZEND_NUM_ARGS();\n\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"sss|ssss\", &to, &to_len, &subject, &subject_len, &message, &message_len,\n\t\t&headers, &headers_len, &cc, &cc_len, &bcc, &bcc_len, &rpath, &rpath_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\t/* To: */\n\tif (!to_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No to field in mail command\");\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Subject: */\n\tif (!subject_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No subject field in mail command\");\n\t\tRETURN_FALSE;\n\t}\n\n\t/* message body */\n\tif (!message_len) {\n\t\t/* this is not really an error, so it is allowed. */\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No message string in mail command\");\n\t\tmessage = NULL;\n\t}\n\n\tif (_php_imap_mail(to, subject, message, headers, cc, bcc, rpath TSRMLS_CC)) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146938,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "   Send an email message */\nPHP_FUNCTION(imap_mail)\n{\n\tchar *to=NULL, *message=NULL, *headers=NULL, *subject=NULL, *cc=NULL, *bcc=NULL, *rpath=NULL;\n\tint to_len, message_len, headers_len, subject_len, cc_len, bcc_len, rpath_len, argc = ZEND_NUM_ARGS();\n\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"sss|ssss\", &to, &to_len, &subject, &subject_len, &message, &message_len,\n\t\t&headers, &headers_len, &cc, &cc_len, &bcc, &bcc_len, &rpath, &rpath_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\t/* To: */\n\tif (!to_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No to field in mail command\");\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Subject: */\n\tif (!subject_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No subject field in mail command\");\n\t\tRETURN_FALSE;\n\t}\n\n\t/* message body */\n\tif (!message_len) {\n\t\t/* this is not really an error, so it is allowed. */\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No message string in mail command\");\n\t}\n\n\tif (_php_imap_mail(to, subject, message, headers, cc, bcc, rpath TSRMLS_CC)) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146939,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int php_session_rfc1867_callback(unsigned int event, void *event_data, void **extra) /* {{{ */\n{\n\tphp_session_rfc1867_progress *progress;\n\tint retval = SUCCESS;\n\n\tif (php_session_rfc1867_orig_callback) {\n\t\tretval = php_session_rfc1867_orig_callback(event, event_data, extra);\n\t}\n\tif (!PS(rfc1867_enabled)) {\n\t\treturn retval;\n\t}\n\n\tprogress = PS(rfc1867_progress);\n\n\tswitch(event) {\n\t\tcase MULTIPART_EVENT_START: {\n\t\t\tmultipart_event_start *data = (multipart_event_start *) event_data;\n\t\t\tprogress = ecalloc(1, sizeof(php_session_rfc1867_progress));\n\t\t\tprogress->content_length = data->content_length;\n\t\t\tprogress->sname_len  = strlen(PS(session_name));\n\t\t\tPS(rfc1867_progress) = progress;\n\t\t}\n\t\tbreak;\n\t\tcase MULTIPART_EVENT_FORMDATA: {\n\t\t\tmultipart_event_formdata *data = (multipart_event_formdata *) event_data;\n\t\t\tsize_t value_len;\n\n\t\t\tif (Z_TYPE(progress->sid) && progress->key.s) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* orig callback may have modified *data->newlength */\n\t\t\tif (data->newlength) {\n\t\t\t\tvalue_len = *data->newlength;\n\t\t\t} else {\n\t\t\t\tvalue_len = data->length;\n\t\t\t}\n\n\t\t\tif (data->name && data->value && value_len) {\n\t\t\t\tsize_t name_len = strlen(data->name);\n\n\t\t\t\tif (name_len == progress->sname_len && memcmp(data->name, PS(session_name), name_len) == 0) {\n\t\t\t\t\tzval_dtor(&progress->sid);\n\t\t\t\t\tZVAL_STRINGL(&progress->sid, (*data->value), value_len);\n\t\t\t\t} else if (name_len == strlen(PS(rfc1867_name)) && memcmp(data->name, PS(rfc1867_name), name_len + 1) == 0) {\n\t\t\t\t\tsmart_str_free(&progress->key);\n\t\t\t\t\tsmart_str_appends(&progress->key, PS(rfc1867_prefix));\n\t\t\t\t\tsmart_str_appendl(&progress->key, *data->value, value_len);\n\t\t\t\t\tsmart_str_0(&progress->key);\n\n\t\t\t\t\tprogress->apply_trans_sid = APPLY_TRANS_SID;\n\t\t\t\t\tphp_session_rfc1867_early_find_sid(progress);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase MULTIPART_EVENT_FILE_START: {\n\t\t\tmultipart_event_file_start *data = (multipart_event_file_start *) event_data;\n\n\t\t\t/* Do nothing when $_POST[\"PHP_SESSION_UPLOAD_PROGRESS\"] is not set\n\t\t\t * or when we have no session id */\n\t\t\tif (!Z_TYPE(progress->sid) || !progress->key.s) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* First FILE_START event, initializing data */\n\t\t\tif (Z_ISUNDEF(progress->data)) {\n\n\t\t\t\tif (PS(rfc1867_freq) >= 0) {\n\t\t\t\t\tprogress->update_step = PS(rfc1867_freq);\n\t\t\t\t} else if (PS(rfc1867_freq) < 0) { /* % of total size */\n\t\t\t\t\tprogress->update_step = progress->content_length * -PS(rfc1867_freq) / 100;\n\t\t\t\t}\n\t\t\t\tprogress->next_update = 0;\n\t\t\t\tprogress->next_update_time = 0.0;\n\n\t\t\t\tarray_init(&progress->data);\n\t\t\t\tarray_init(&progress->files);\n\n\t\t\t\tadd_assoc_long_ex(&progress->data, \"start_time\", sizeof(\"start_time\") - 1, (zend_long)sapi_get_request_time());\n\t\t\t\tadd_assoc_long_ex(&progress->data, \"content_length\",  sizeof(\"content_length\") - 1, progress->content_length);\n\t\t\t\tadd_assoc_long_ex(&progress->data, \"bytes_processed\", sizeof(\"bytes_processed\") - 1, data->post_bytes_processed);\n\t\t\t\tadd_assoc_bool_ex(&progress->data, \"done\", sizeof(\"done\") - 1, 0);\n\t\t\t\tadd_assoc_zval_ex(&progress->data, \"files\", sizeof(\"files\") - 1, &progress->files);\n\n\t\t\t\tprogress->post_bytes_processed = zend_hash_str_find(Z_ARRVAL(progress->data), \"bytes_processed\", sizeof(\"bytes_processed\") - 1);\n\n\t\t\t\tphp_rinit_session(0);\n\t\t\t\tPS(id) = zend_string_init(Z_STRVAL(progress->sid), Z_STRLEN(progress->sid), 0);\n\t\t\t\tif (progress->apply_trans_sid) {\n\t\t\t\t\t/* Enable trans sid by modifying flags */\n\t\t\t\t\tPS(use_trans_sid) = 1;\n\t\t\t\t\tPS(use_only_cookies) = 0;\n\t\t\t\t}\n\t\t\t\tPS(send_cookie) = 0;\n\t\t\t}\n\n\t\t\tarray_init(&progress->current_file);\n\n\t\t\t/* Each uploaded file has its own array. Trying to make it close to $_FILES entries. */\n\t\t\tadd_assoc_string_ex(&progress->current_file, \"field_name\", sizeof(\"field_name\") - 1, data->name);\n\t\t\tadd_assoc_string_ex(&progress->current_file, \"name\", sizeof(\"name\") - 1, *data->filename);\n\t\t\tadd_assoc_null_ex(&progress->current_file, \"tmp_name\", sizeof(\"tmp_name\") - 1);\n\t\t\tadd_assoc_long_ex(&progress->current_file, \"error\", sizeof(\"error\") - 1, 0);\n\n\t\t\tadd_assoc_bool_ex(&progress->current_file, \"done\", sizeof(\"done\") - 1, 0);\n\t\t\tadd_assoc_long_ex(&progress->current_file, \"start_time\", sizeof(\"start_time\") - 1, (zend_long)time(NULL));\n\t\t\tadd_assoc_long_ex(&progress->current_file, \"bytes_processed\", sizeof(\"bytes_processed\") - 1, 0);\n\n\t\t\tadd_next_index_zval(&progress->files, &progress->current_file);\n\n\t\t\tprogress->current_file_bytes_processed = zend_hash_str_find(Z_ARRVAL(progress->current_file), \"bytes_processed\", sizeof(\"bytes_processed\") - 1);\n\n\t\t\tZ_LVAL_P(progress->current_file_bytes_processed) =  data->post_bytes_processed;\n\t\t\tphp_session_rfc1867_update(progress, 0);\n\t\t}\n\t\tbreak;\n\t\tcase MULTIPART_EVENT_FILE_DATA: {\n\t\t\tmultipart_event_file_data *data = (multipart_event_file_data *) event_data;\n\n\t\t\tif (!Z_TYPE(progress->sid) || !progress->key.s) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tZ_LVAL_P(progress->current_file_bytes_processed) = data->offset + data->length;\n\t\t\tZ_LVAL_P(progress->post_bytes_processed) = data->post_bytes_processed;\n\n\t\t\tphp_session_rfc1867_update(progress, 0);\n\t\t}\n\t\tbreak;\n\t\tcase MULTIPART_EVENT_FILE_END: {\n\t\t\tmultipart_event_file_end *data = (multipart_event_file_end *) event_data;\n\n\t\t\tif (!Z_TYPE(progress->sid) || !progress->key.s) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (data->temp_filename) {\n\t\t\t\tadd_assoc_string_ex(&progress->current_file, \"tmp_name\",  sizeof(\"tmp_name\") - 1, data->temp_filename);\n\t\t\t}\n\n\t\t\tadd_assoc_long_ex(&progress->current_file, \"error\", sizeof(\"error\") - 1, data->cancel_upload);\n\t\t\tadd_assoc_bool_ex(&progress->current_file, \"done\", sizeof(\"done\") - 1,  1);\n\n\t\t\tZ_LVAL_P(progress->post_bytes_processed) = data->post_bytes_processed;\n\n\t\t\tphp_session_rfc1867_update(progress, 0);\n\t\t}\n\t\tbreak;\n\t\tcase MULTIPART_EVENT_END: {\n\t\t\tmultipart_event_end *data = (multipart_event_end *) event_data;\n\n\t\t\tif (Z_TYPE(progress->sid) && progress->key.s) {\n\t\t\t\tif (PS(rfc1867_cleanup)) {\n\t\t\t\t\tphp_session_rfc1867_cleanup(progress);\n\t\t\t\t} else {\n\t\t\t\t\tSEPARATE_ARRAY(&progress->data);\n\t\t\t\t\tadd_assoc_bool_ex(&progress->data, \"done\", sizeof(\"done\") - 1, 1);\n\t\t\t\t\tZ_LVAL_P(progress->post_bytes_processed) = data->post_bytes_processed;\n\t\t\t\t\tphp_session_rfc1867_update(progress, 1);\n\t\t\t\t}\n\t\t\t\tphp_rshutdown_session_globals();\n\t\t\t}\n\n\t\t\tif (!Z_ISUNDEF(progress->data)) {\n\t\t\t\tzval_ptr_dtor(&progress->data);\n\t\t\t}\n\t\t\tzval_ptr_dtor(&progress->sid);\n\t\t\tsmart_str_free(&progress->key);\n\t\t\tefree(progress);\n\t\t\tprogress = NULL;\n\t\t\tPS(rfc1867_progress) = NULL;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (progress && progress->cancel_upload) {\n\t\treturn FAILURE;\n\t}\n\treturn retval;\n\n} /* }}} */",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146974,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int php_session_rfc1867_callback(unsigned int event, void *event_data, void **extra) /* {{{ */\n{\n\tphp_session_rfc1867_progress *progress;\n\tint retval = SUCCESS;\n\n\tif (php_session_rfc1867_orig_callback) {\n\t\tretval = php_session_rfc1867_orig_callback(event, event_data, extra);\n\t}\n\tif (!PS(rfc1867_enabled)) {\n\t\treturn retval;\n\t}\n\n\tprogress = PS(rfc1867_progress);\n\n\tswitch(event) {\n\t\tcase MULTIPART_EVENT_START: {\n\t\t\tmultipart_event_start *data = (multipart_event_start *) event_data;\n\t\t\tprogress = ecalloc(1, sizeof(php_session_rfc1867_progress));\n\t\t\tprogress->content_length = data->content_length;\n\t\t\tprogress->sname_len  = strlen(PS(session_name));\n\t\t\tPS(rfc1867_progress) = progress;\n\t\t}\n\t\tbreak;\n\t\tcase MULTIPART_EVENT_FORMDATA: {\n\t\t\tmultipart_event_formdata *data = (multipart_event_formdata *) event_data;\n\t\t\tsize_t value_len;\n\n\t\t\tif (Z_TYPE(progress->sid) && progress->key.s) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* orig callback may have modified *data->newlength */\n\t\t\tif (data->newlength) {\n\t\t\t\tvalue_len = *data->newlength;\n\t\t\t} else {\n\t\t\t\tvalue_len = data->length;\n\t\t\t}\n\n\t\t\tif (data->name && data->value && value_len) {\n\t\t\t\tsize_t name_len = strlen(data->name);\n\n\t\t\t\tif (name_len == progress->sname_len && memcmp(data->name, PS(session_name), name_len) == 0) {\n\t\t\t\t\tzval_dtor(&progress->sid);\n\t\t\t\t\tZVAL_STRINGL(&progress->sid, (*data->value), value_len);\n\t\t\t\t} else if (name_len == strlen(PS(rfc1867_name)) && memcmp(data->name, PS(rfc1867_name), name_len + 1) == 0) {\n\t\t\t\t\tsmart_str_free(&progress->key);\n\t\t\t\t\tsmart_str_appends(&progress->key, PS(rfc1867_prefix));\n\t\t\t\t\tsmart_str_appendl(&progress->key, *data->value, value_len);\n\t\t\t\t\tsmart_str_0(&progress->key);\n\n\t\t\t\t\tprogress->apply_trans_sid = APPLY_TRANS_SID;\n\t\t\t\t\tphp_session_rfc1867_early_find_sid(progress);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase MULTIPART_EVENT_FILE_START: {\n\t\t\tmultipart_event_file_start *data = (multipart_event_file_start *) event_data;\n\n\t\t\t/* Do nothing when $_POST[\"PHP_SESSION_UPLOAD_PROGRESS\"] is not set\n\t\t\t * or when we have no session id */\n\t\t\tif (!Z_TYPE(progress->sid) || !progress->key.s) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* First FILE_START event, initializing data */\n\t\t\tif (Z_ISUNDEF(progress->data)) {\n\n\t\t\t\tif (PS(rfc1867_freq) >= 0) {\n\t\t\t\t\tprogress->update_step = PS(rfc1867_freq);\n\t\t\t\t} else if (PS(rfc1867_freq) < 0) { /* % of total size */\n\t\t\t\t\tprogress->update_step = progress->content_length * -PS(rfc1867_freq) / 100;\n\t\t\t\t}\n\t\t\t\tprogress->next_update = 0;\n\t\t\t\tprogress->next_update_time = 0.0;\n\n\t\t\t\tarray_init(&progress->data);\n\t\t\t\tarray_init(&progress->files);\n\n\t\t\t\tadd_assoc_long_ex(&progress->data, \"start_time\", sizeof(\"start_time\") - 1, (zend_long)sapi_get_request_time());\n\t\t\t\tadd_assoc_long_ex(&progress->data, \"content_length\",  sizeof(\"content_length\") - 1, progress->content_length);\n\t\t\t\tadd_assoc_long_ex(&progress->data, \"bytes_processed\", sizeof(\"bytes_processed\") - 1, data->post_bytes_processed);\n\t\t\t\tadd_assoc_bool_ex(&progress->data, \"done\", sizeof(\"done\") - 1, 0);\n\t\t\t\tadd_assoc_zval_ex(&progress->data, \"files\", sizeof(\"files\") - 1, &progress->files);\n\n\t\t\t\tprogress->post_bytes_processed = zend_hash_str_find(Z_ARRVAL(progress->data), \"bytes_processed\", sizeof(\"bytes_processed\") - 1);\n\n\t\t\t\tphp_rinit_session(0);\n\t\t\t\tPS(id) = zend_string_init(Z_STRVAL(progress->sid), Z_STRLEN(progress->sid), 0);\n\t\t\t\tif (progress->apply_trans_sid) {\n\t\t\t\t\t/* Enable trans sid by modifying flags */\n\t\t\t\t\tPS(use_trans_sid) = 1;\n\t\t\t\t\tPS(use_only_cookies) = 0;\n\t\t\t\t}\n\t\t\t\tPS(send_cookie) = 0;\n\t\t\t}\n\n\t\t\tarray_init(&progress->current_file);\n\n\t\t\t/* Each uploaded file has its own array. Trying to make it close to $_FILES entries. */\n\t\t\tadd_assoc_string_ex(&progress->current_file, \"field_name\", sizeof(\"field_name\") - 1, data->name);\n\t\t\tadd_assoc_string_ex(&progress->current_file, \"name\", sizeof(\"name\") - 1, *data->filename);\n\t\t\tadd_assoc_null_ex(&progress->current_file, \"tmp_name\", sizeof(\"tmp_name\") - 1);\n\t\t\tadd_assoc_long_ex(&progress->current_file, \"error\", sizeof(\"error\") - 1, 0);\n\n\t\t\tadd_assoc_bool_ex(&progress->current_file, \"done\", sizeof(\"done\") - 1, 0);\n\t\t\tadd_assoc_long_ex(&progress->current_file, \"start_time\", sizeof(\"start_time\") - 1, (zend_long)time(NULL));\n\t\t\tadd_assoc_long_ex(&progress->current_file, \"bytes_processed\", sizeof(\"bytes_processed\") - 1, 0);\n\n\t\t\tadd_next_index_zval(&progress->files, &progress->current_file);\n\n\t\t\tprogress->current_file_bytes_processed = zend_hash_str_find(Z_ARRVAL(progress->current_file), \"bytes_processed\", sizeof(\"bytes_processed\") - 1);\n\n\t\t\tZ_LVAL_P(progress->current_file_bytes_processed) =  data->post_bytes_processed;\n\t\t\tphp_session_rfc1867_update(progress, 0);\n\t\t}\n\t\tbreak;\n\t\tcase MULTIPART_EVENT_FILE_DATA: {\n\t\t\tmultipart_event_file_data *data = (multipart_event_file_data *) event_data;\n\n\t\t\tif (!Z_TYPE(progress->sid) || !progress->key.s) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tZ_LVAL_P(progress->current_file_bytes_processed) = data->offset + data->length;\n\t\t\tZ_LVAL_P(progress->post_bytes_processed) = data->post_bytes_processed;\n\n\t\t\tphp_session_rfc1867_update(progress, 0);\n\t\t}\n\t\tbreak;\n\t\tcase MULTIPART_EVENT_FILE_END: {\n\t\t\tmultipart_event_file_end *data = (multipart_event_file_end *) event_data;\n\n\t\t\tif (!Z_TYPE(progress->sid) || !progress->key.s) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (data->temp_filename) {\n\t\t\t\tadd_assoc_string_ex(&progress->current_file, \"tmp_name\",  sizeof(\"tmp_name\") - 1, data->temp_filename);\n\t\t\t}\n\n\t\t\tadd_assoc_long_ex(&progress->current_file, \"error\", sizeof(\"error\") - 1, data->cancel_upload);\n\t\t\tadd_assoc_bool_ex(&progress->current_file, \"done\", sizeof(\"done\") - 1,  1);\n\n\t\t\tZ_LVAL_P(progress->post_bytes_processed) = data->post_bytes_processed;\n\n\t\t\tphp_session_rfc1867_update(progress, 0);\n\t\t}\n\t\tbreak;\n\t\tcase MULTIPART_EVENT_END: {\n\t\t\tmultipart_event_end *data = (multipart_event_end *) event_data;\n\n\t\t\tif (Z_TYPE(progress->sid) && progress->key.s) {\n\t\t\t\tif (PS(rfc1867_cleanup)) {\n\t\t\t\t\tphp_session_rfc1867_cleanup(progress);\n\t\t\t\t} else {\n\t\t\t\t\tif (!Z_ISUNDEF(progress->data)) {\n\t\t\t\t\t\tSEPARATE_ARRAY(&progress->data);\n\t\t\t\t\t\tadd_assoc_bool_ex(&progress->data, \"done\", sizeof(\"done\") - 1, 1);\n\t\t\t\t\t\tZ_LVAL_P(progress->post_bytes_processed) = data->post_bytes_processed;\n\t\t\t\t\t\tphp_session_rfc1867_update(progress, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tphp_rshutdown_session_globals();\n\t\t\t}\n\n\t\t\tif (!Z_ISUNDEF(progress->data)) {\n\t\t\t\tzval_ptr_dtor(&progress->data);\n\t\t\t}\n\t\t\tzval_ptr_dtor(&progress->sid);\n\t\t\tsmart_str_free(&progress->key);\n\t\t\tefree(progress);\n\t\t\tprogress = NULL;\n\t\t\tPS(rfc1867_progress) = NULL;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (progress && progress->cancel_upload) {\n\t\treturn FAILURE;\n\t}\n\treturn retval;\n\n} /* }}} */",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146975,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static Image *ReadPANGOImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  cairo_font_options_t\n    *font_options;\n\n  cairo_surface_t\n    *surface;\n\n  char\n    *caption,\n    *property;\n\n  cairo_t\n    *cairo_image;\n\n  const char\n    *option;\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *pixel_info;\n\n  PangoAlignment\n    align;\n\n  PangoContext\n    *context;\n\n  PangoFontDescription\n    *description;\n\n  PangoFontMap\n    *fontmap;\n\n  PangoGravity\n    gravity;\n\n  PangoLayout\n    *layout;\n\n  PangoRectangle\n    extent;\n\n  PixelPacket\n    fill_color;\n\n  RectangleInfo\n    page;\n\n  register unsigned char\n    *p;\n\n  size_t\n    stride;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Initialize Image structure.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info);\n  (void) ResetImagePage(image,\"0x0+0+0\");\n  if ((image->columns != 0) && (image->rows != 0))\n    (void) SetImageBackgroundColor(image);\n  /*\n    Format caption.\n  */\n  option=GetImageOption(image_info,\"filename\");\n  if (option == (const char *) NULL)\n    property=InterpretImageProperties(image_info,image,image_info->filename);\n  else\n    if (LocaleNCompare(option,\"pango:\",6) == 0)\n      property=InterpretImageProperties(image_info,image,option+6);\n    else\n      property=InterpretImageProperties(image_info,image,option);\n  (void) SetImageProperty(image,\"caption\",property);\n  property=DestroyString(property);\n  caption=ConstantString(GetImageProperty(image,\"caption\"));\n  /*\n    Get context.\n  */\n  fontmap=pango_cairo_font_map_new();\n  pango_cairo_font_map_set_resolution(PANGO_CAIRO_FONT_MAP(fontmap),\n    image->x_resolution == 0.0 ? DefaultPANGODensity : image->x_resolution);\n  font_options=cairo_font_options_create();\n  option=GetImageOption(image_info,\"pango:hinting\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"none\") != 0)\n        cairo_font_options_set_hint_style(font_options,CAIRO_HINT_STYLE_NONE);\n      if (LocaleCompare(option,\"full\") != 0)\n        cairo_font_options_set_hint_style(font_options,CAIRO_HINT_STYLE_FULL);\n    }\n  context=pango_font_map_create_context(fontmap);\n  pango_cairo_context_set_font_options(context,font_options);\n  cairo_font_options_destroy(font_options);\n  option=GetImageOption(image_info,\"pango:language\");\n  if (option != (const char *) NULL)\n    pango_context_set_language(context,pango_language_from_string(option));\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  pango_context_set_base_dir(context,draw_info->direction ==\n    RightToLeftDirection ? PANGO_DIRECTION_RTL : PANGO_DIRECTION_LTR);\n  switch (draw_info->gravity)\n  {\n    case NorthGravity:\n    {\n      gravity=PANGO_GRAVITY_NORTH;\n      break;\n    }\n    case NorthWestGravity:\n    case WestGravity:\n    case SouthWestGravity:\n    {\n      gravity=PANGO_GRAVITY_WEST;\n      break;\n    }\n    case NorthEastGravity:\n    case EastGravity:\n    case SouthEastGravity:\n    {\n      gravity=PANGO_GRAVITY_EAST;\n      break;\n    }\n    case SouthGravity:\n    {\n      gravity=PANGO_GRAVITY_SOUTH;\n      break;\n    }\n    default:\n    {\n      gravity=PANGO_GRAVITY_AUTO;\n      break;\n    }\n  }\n  pango_context_set_base_gravity(context,gravity);\n  option=GetImageOption(image_info,\"pango:gravity-hint\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"line\") == 0)\n        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_LINE);\n      if (LocaleCompare(option,\"natural\") == 0)\n        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_NATURAL);\n      if (LocaleCompare(option,\"strong\") == 0)\n        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_STRONG);\n    }\n  /*\n    Configure layout.\n  */\n  layout=pango_layout_new(context);\n  option=GetImageOption(image_info,\"pango:auto-dir\");\n  if (option != (const char *) NULL)\n    pango_layout_set_auto_dir(layout,1);\n  option=GetImageOption(image_info,\"pango:ellipsize\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"end\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_END);\n      if (LocaleCompare(option,\"middle\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_MIDDLE);\n      if (LocaleCompare(option,\"none\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_NONE);\n      if (LocaleCompare(option,\"start\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_START);\n    }\n  option=GetImageOption(image_info,\"pango:justify\");\n  if ((option != (const char *) NULL) && (IsMagickTrue(option) != MagickFalse))\n    pango_layout_set_justify(layout,1);\n  option=GetImageOption(image_info,\"pango:single-paragraph\");\n  if ((option != (const char *) NULL) && (IsMagickTrue(option) != MagickFalse))\n    pango_layout_set_single_paragraph_mode(layout,1);\n  option=GetImageOption(image_info,\"pango:wrap\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"char\") == 0)\n        pango_layout_set_wrap(layout,PANGO_WRAP_CHAR);\n      if (LocaleCompare(option,\"word\") == 0)\n        pango_layout_set_wrap(layout,PANGO_WRAP_WORD);\n      if (LocaleCompare(option,\"word-char\") == 0)\n        pango_layout_set_wrap(layout,PANGO_WRAP_WORD_CHAR);\n    }\n  option=GetImageOption(image_info,\"pango:indent\");\n  if (option != (const char *) NULL)\n    pango_layout_set_indent(layout,(int) ((StringToLong(option)*\n      (image->x_resolution == 0.0 ? DefaultPANGODensity : image->x_resolution)*\n      PANGO_SCALE+DefaultPANGODensity/2)/DefaultPANGODensity+0.5));\n  switch (draw_info->align)\n  {\n    case CenterAlign: align=PANGO_ALIGN_CENTER; break;\n    case RightAlign: align=PANGO_ALIGN_RIGHT; break;\n    case LeftAlign: align=PANGO_ALIGN_LEFT; break;\n    default:\n    {\n      if (draw_info->gravity == CenterGravity)\n        {\n          align=PANGO_ALIGN_CENTER;\n          break;\n        }\n      align=PANGO_ALIGN_LEFT;\n      break;\n    }\n  }\n  if ((align != PANGO_ALIGN_CENTER) &&\n      (draw_info->direction == RightToLeftDirection))\n    align=(PangoAlignment) (PANGO_ALIGN_LEFT+PANGO_ALIGN_RIGHT-align);\n  option=GetImageOption(image_info,\"pango:align\");\n  if (option != (const char *) NULL) \n    {\n      if (LocaleCompare(option,\"center\") == 0)\n        align=PANGO_ALIGN_CENTER;\n      if (LocaleCompare(option,\"left\") == 0)\n        align=PANGO_ALIGN_LEFT;\n      if (LocaleCompare(option,\"right\") == 0)\n        align=PANGO_ALIGN_RIGHT;\n    }\n  pango_layout_set_alignment(layout,align);\n  if (draw_info->font == (char *) NULL)\n    description=pango_font_description_new();\n  else\n    description=pango_font_description_from_string(draw_info->font);\n  pango_font_description_set_size(description,(int) (PANGO_SCALE*\n    draw_info->pointsize+0.5));\n  pango_layout_set_font_description(layout,description);\n  pango_font_description_free(description);\n  option=GetImageOption(image_info,\"pango:markup\");\n  if ((option != (const char *) NULL) && (IsMagickTrue(option) == MagickFalse))\n    pango_layout_set_text(layout,caption,-1);\n  else\n    {\n      GError\n        *error;\n\n      error=(GError *) NULL;\n      if (pango_parse_markup(caption,-1,0,NULL,NULL,NULL,&error) == 0)\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          error->message,\"`%s'\",image_info->filename);\n      pango_layout_set_markup(layout,caption,-1);\n    }\n  pango_layout_context_changed(layout);\n  page.x=0;\n  page.y=0;\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  if (image->columns == 0)\n    {\n      pango_layout_get_extents(layout,NULL,&extent);\n      image->columns=(extent.x+extent.width+PANGO_SCALE/2)/PANGO_SCALE+2*page.x;\n    }\n  else\n    {\n      image->columns-=2*page.x;\n      pango_layout_set_width(layout,(int) ((PANGO_SCALE*image->columns*\n        (image->x_resolution == 0.0 ? DefaultPANGODensity :\n        image->x_resolution)+DefaultPANGODensity/2)/DefaultPANGODensity+0.5));\n    }\n  if (image->rows == 0)\n    {\n      pango_layout_get_extents(layout,NULL,&extent);\n      image->rows=(extent.y+extent.height+PANGO_SCALE/2)/PANGO_SCALE+2*page.y;\n    }\n  else\n    {\n      image->rows-=2*page.y;\n      pango_layout_set_height(layout,(int) ((PANGO_SCALE*image->rows*\n        (image->y_resolution == 0.0 ? DefaultPANGODensity :\n        image->y_resolution)+DefaultPANGODensity/2)/DefaultPANGODensity+0.5));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  /*\n    Render markup.\n  */\n  stride=(size_t) cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32,(int)\n    image->columns);\n  pixel_info=AcquireVirtualMemory(image->rows,stride*sizeof(*pixels));\n  if (pixel_info == (MemoryInfo *) NULL)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      caption=DestroyString(caption);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n  surface=cairo_image_surface_create_for_data(pixels,CAIRO_FORMAT_ARGB32,\n    (int) image->columns,(int) image->rows,(int) stride);\n  cairo_image=cairo_create(surface);\n  cairo_set_operator(cairo_image,CAIRO_OPERATOR_CLEAR);\n  cairo_paint(cairo_image);\n  cairo_set_operator(cairo_image,CAIRO_OPERATOR_OVER);\n  cairo_translate(cairo_image,page.x,page.y);\n  cairo_set_source_rgba(cairo_image,QuantumScale*draw_info->fill.red,\n    QuantumScale*draw_info->fill.green,QuantumScale*draw_info->fill.blue,\n    QuantumScale*(QuantumRange-draw_info->fill.opacity));\n  pango_cairo_show_layout(cairo_image,layout);\n  cairo_destroy(cairo_image);\n  cairo_surface_destroy(surface);\n  g_object_unref(layout);\n  g_object_unref(fontmap);\n  /*\n    Convert surface to image.\n  */\n  (void) SetImageBackgroundColor(image);\n  p=pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *q;\n\n    register ssize_t\n      x;\n\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      fill_color.blue=ScaleCharToQuantum(*p++);\n      fill_color.green=ScaleCharToQuantum(*p++);\n      fill_color.red=ScaleCharToQuantum(*p++);\n      fill_color.opacity=QuantumRange-ScaleCharToQuantum(*p++);\n      /*\n        Disassociate alpha.\n      */\n      gamma=1.0-QuantumScale*fill_color.opacity;\n      gamma=PerceptibleReciprocal(gamma);\n      fill_color.blue*=gamma;\n      fill_color.green*=gamma;\n      fill_color.red*=gamma;\n      MagickCompositeOver(&fill_color,fill_color.opacity,q,(MagickRealType)\n        q->opacity,q);\n      q++;\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n        image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  /*\n    Relinquish resources.\n  */\n  pixel_info=RelinquishVirtualMemory(pixel_info);\n  draw_info=DestroyDrawInfo(draw_info);\n  caption=DestroyString(caption);\n  return(GetFirstImageInList(image));\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147014,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static Image *ReadPANGOImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  cairo_font_options_t\n    *font_options;\n\n  cairo_surface_t\n    *surface;\n\n  char\n    *caption,\n    *property;\n\n  cairo_t\n    *cairo_image;\n\n  const char\n    *option;\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *pixel_info;\n\n  PangoAlignment\n    align;\n\n  PangoContext\n    *context;\n\n  PangoFontDescription\n    *description;\n\n  PangoFontMap\n    *fontmap;\n\n  PangoGravity\n    gravity;\n\n  PangoLayout\n    *layout;\n\n  PangoRectangle\n    extent;\n\n  PixelPacket\n    fill_color;\n\n  RectangleInfo\n    page;\n\n  register unsigned char\n    *p;\n\n  size_t\n    stride;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Initialize Image structure.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info);\n  (void) ResetImagePage(image,\"0x0+0+0\");\n  if ((image->columns != 0) && (image->rows != 0))\n    (void) SetImageBackgroundColor(image);\n  /*\n    Format caption.\n  */\n  option=GetImageOption(image_info,\"filename\");\n  if (option == (const char *) NULL)\n    property=InterpretImageProperties(image_info,image,image_info->filename);\n  else\n    if (LocaleNCompare(option,\"pango:\",6) == 0)\n      property=InterpretImageProperties(image_info,image,option+6);\n    else\n      property=InterpretImageProperties(image_info,image,option);\n  if (property != (char *) NULL)\n    {\n      (void) SetImageProperty(image,\"caption\",property);\n      property=DestroyString(property);\n    }\n  caption=ConstantString(GetImageProperty(image,\"caption\"));\n  /*\n    Get context.\n  */\n  fontmap=pango_cairo_font_map_new();\n  pango_cairo_font_map_set_resolution(PANGO_CAIRO_FONT_MAP(fontmap),\n    image->x_resolution == 0.0 ? DefaultPANGODensity : image->x_resolution);\n  font_options=cairo_font_options_create();\n  option=GetImageOption(image_info,\"pango:hinting\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"none\") != 0)\n        cairo_font_options_set_hint_style(font_options,CAIRO_HINT_STYLE_NONE);\n      if (LocaleCompare(option,\"full\") != 0)\n        cairo_font_options_set_hint_style(font_options,CAIRO_HINT_STYLE_FULL);\n    }\n  context=pango_font_map_create_context(fontmap);\n  pango_cairo_context_set_font_options(context,font_options);\n  cairo_font_options_destroy(font_options);\n  option=GetImageOption(image_info,\"pango:language\");\n  if (option != (const char *) NULL)\n    pango_context_set_language(context,pango_language_from_string(option));\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  pango_context_set_base_dir(context,draw_info->direction ==\n    RightToLeftDirection ? PANGO_DIRECTION_RTL : PANGO_DIRECTION_LTR);\n  switch (draw_info->gravity)\n  {\n    case NorthGravity:\n    {\n      gravity=PANGO_GRAVITY_NORTH;\n      break;\n    }\n    case NorthWestGravity:\n    case WestGravity:\n    case SouthWestGravity:\n    {\n      gravity=PANGO_GRAVITY_WEST;\n      break;\n    }\n    case NorthEastGravity:\n    case EastGravity:\n    case SouthEastGravity:\n    {\n      gravity=PANGO_GRAVITY_EAST;\n      break;\n    }\n    case SouthGravity:\n    {\n      gravity=PANGO_GRAVITY_SOUTH;\n      break;\n    }\n    default:\n    {\n      gravity=PANGO_GRAVITY_AUTO;\n      break;\n    }\n  }\n  pango_context_set_base_gravity(context,gravity);\n  option=GetImageOption(image_info,\"pango:gravity-hint\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"line\") == 0)\n        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_LINE);\n      if (LocaleCompare(option,\"natural\") == 0)\n        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_NATURAL);\n      if (LocaleCompare(option,\"strong\") == 0)\n        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_STRONG);\n    }\n  /*\n    Configure layout.\n  */\n  layout=pango_layout_new(context);\n  option=GetImageOption(image_info,\"pango:auto-dir\");\n  if (option != (const char *) NULL)\n    pango_layout_set_auto_dir(layout,1);\n  option=GetImageOption(image_info,\"pango:ellipsize\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"end\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_END);\n      if (LocaleCompare(option,\"middle\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_MIDDLE);\n      if (LocaleCompare(option,\"none\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_NONE);\n      if (LocaleCompare(option,\"start\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_START);\n    }\n  option=GetImageOption(image_info,\"pango:justify\");\n  if ((option != (const char *) NULL) && (IsMagickTrue(option) != MagickFalse))\n    pango_layout_set_justify(layout,1);\n  option=GetImageOption(image_info,\"pango:single-paragraph\");\n  if ((option != (const char *) NULL) && (IsMagickTrue(option) != MagickFalse))\n    pango_layout_set_single_paragraph_mode(layout,1);\n  option=GetImageOption(image_info,\"pango:wrap\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"char\") == 0)\n        pango_layout_set_wrap(layout,PANGO_WRAP_CHAR);\n      if (LocaleCompare(option,\"word\") == 0)\n        pango_layout_set_wrap(layout,PANGO_WRAP_WORD);\n      if (LocaleCompare(option,\"word-char\") == 0)\n        pango_layout_set_wrap(layout,PANGO_WRAP_WORD_CHAR);\n    }\n  option=GetImageOption(image_info,\"pango:indent\");\n  if (option != (const char *) NULL)\n    pango_layout_set_indent(layout,(int) ((StringToLong(option)*\n      (image->x_resolution == 0.0 ? DefaultPANGODensity : image->x_resolution)*\n      PANGO_SCALE+DefaultPANGODensity/2)/DefaultPANGODensity+0.5));\n  switch (draw_info->align)\n  {\n    case CenterAlign: align=PANGO_ALIGN_CENTER; break;\n    case RightAlign: align=PANGO_ALIGN_RIGHT; break;\n    case LeftAlign: align=PANGO_ALIGN_LEFT; break;\n    default:\n    {\n      if (draw_info->gravity == CenterGravity)\n        {\n          align=PANGO_ALIGN_CENTER;\n          break;\n        }\n      align=PANGO_ALIGN_LEFT;\n      break;\n    }\n  }\n  if ((align != PANGO_ALIGN_CENTER) &&\n      (draw_info->direction == RightToLeftDirection))\n    align=(PangoAlignment) (PANGO_ALIGN_LEFT+PANGO_ALIGN_RIGHT-align);\n  option=GetImageOption(image_info,\"pango:align\");\n  if (option != (const char *) NULL) \n    {\n      if (LocaleCompare(option,\"center\") == 0)\n        align=PANGO_ALIGN_CENTER;\n      if (LocaleCompare(option,\"left\") == 0)\n        align=PANGO_ALIGN_LEFT;\n      if (LocaleCompare(option,\"right\") == 0)\n        align=PANGO_ALIGN_RIGHT;\n    }\n  pango_layout_set_alignment(layout,align);\n  if (draw_info->font == (char *) NULL)\n    description=pango_font_description_new();\n  else\n    description=pango_font_description_from_string(draw_info->font);\n  pango_font_description_set_size(description,(int) (PANGO_SCALE*\n    draw_info->pointsize+0.5));\n  pango_layout_set_font_description(layout,description);\n  pango_font_description_free(description);\n  option=GetImageOption(image_info,\"pango:markup\");\n  if ((option != (const char *) NULL) && (IsMagickTrue(option) == MagickFalse))\n    pango_layout_set_text(layout,caption,-1);\n  else\n    {\n      GError\n        *error;\n\n      error=(GError *) NULL;\n      if (pango_parse_markup(caption,-1,0,NULL,NULL,NULL,&error) == 0)\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          error->message,\"`%s'\",image_info->filename);\n      pango_layout_set_markup(layout,caption,-1);\n    }\n  pango_layout_context_changed(layout);\n  page.x=0;\n  page.y=0;\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  if (image->columns == 0)\n    {\n      pango_layout_get_extents(layout,NULL,&extent);\n      image->columns=(extent.x+extent.width+PANGO_SCALE/2)/PANGO_SCALE+2*page.x;\n    }\n  else\n    {\n      image->columns-=2*page.x;\n      pango_layout_set_width(layout,(int) ((PANGO_SCALE*image->columns*\n        (image->x_resolution == 0.0 ? DefaultPANGODensity :\n        image->x_resolution)+DefaultPANGODensity/2)/DefaultPANGODensity+0.5));\n    }\n  if (image->rows == 0)\n    {\n      pango_layout_get_extents(layout,NULL,&extent);\n      image->rows=(extent.y+extent.height+PANGO_SCALE/2)/PANGO_SCALE+2*page.y;\n    }\n  else\n    {\n      image->rows-=2*page.y;\n      pango_layout_set_height(layout,(int) ((PANGO_SCALE*image->rows*\n        (image->y_resolution == 0.0 ? DefaultPANGODensity :\n        image->y_resolution)+DefaultPANGODensity/2)/DefaultPANGODensity+0.5));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  /*\n    Render markup.\n  */\n  stride=(size_t) cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32,(int)\n    image->columns);\n  pixel_info=AcquireVirtualMemory(image->rows,stride*sizeof(*pixels));\n  if (pixel_info == (MemoryInfo *) NULL)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      caption=DestroyString(caption);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n  surface=cairo_image_surface_create_for_data(pixels,CAIRO_FORMAT_ARGB32,\n    (int) image->columns,(int) image->rows,(int) stride);\n  cairo_image=cairo_create(surface);\n  cairo_set_operator(cairo_image,CAIRO_OPERATOR_CLEAR);\n  cairo_paint(cairo_image);\n  cairo_set_operator(cairo_image,CAIRO_OPERATOR_OVER);\n  cairo_translate(cairo_image,page.x,page.y);\n  cairo_set_source_rgba(cairo_image,QuantumScale*draw_info->fill.red,\n    QuantumScale*draw_info->fill.green,QuantumScale*draw_info->fill.blue,\n    QuantumScale*(QuantumRange-draw_info->fill.opacity));\n  pango_cairo_show_layout(cairo_image,layout);\n  cairo_destroy(cairo_image);\n  cairo_surface_destroy(surface);\n  g_object_unref(layout);\n  g_object_unref(fontmap);\n  /*\n    Convert surface to image.\n  */\n  (void) SetImageBackgroundColor(image);\n  p=pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *q;\n\n    register ssize_t\n      x;\n\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      fill_color.blue=ScaleCharToQuantum(*p++);\n      fill_color.green=ScaleCharToQuantum(*p++);\n      fill_color.red=ScaleCharToQuantum(*p++);\n      fill_color.opacity=QuantumRange-ScaleCharToQuantum(*p++);\n      /*\n        Disassociate alpha.\n      */\n      gamma=1.0-QuantumScale*fill_color.opacity;\n      gamma=PerceptibleReciprocal(gamma);\n      fill_color.blue*=gamma;\n      fill_color.green*=gamma;\n      fill_color.red*=gamma;\n      MagickCompositeOver(&fill_color,fill_color.opacity,q,(MagickRealType)\n        q->opacity,q);\n      q++;\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n        image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  /*\n    Relinquish resources.\n  */\n  pixel_info=RelinquishVirtualMemory(pixel_info);\n  draw_info=DestroyDrawInfo(draw_info);\n  caption=DestroyString(caption);\n  return(GetFirstImageInList(image));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147015,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static Image *ReadVIDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ClientName  \"montage\"\n\n  char\n    **filelist,\n    *label,\n    **list;\n\n  Image\n    *image,\n    *images,\n    *montage_image,\n    *next_image,\n    *thumbnail_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    number_files;\n\n  MagickBooleanType\n    status;\n\n  MontageInfo\n    *montage_info;\n\n  RectangleInfo\n    geometry;\n\n  register ssize_t\n    i;\n\n  /*\n    Expand the filename.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info);\n  list=(char **) AcquireMagickMemory(sizeof(*filelist));\n  if (list == (char **) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  list[0]=ConstantString(image_info->filename);\n  filelist=list;\n  number_files=1;\n  status=ExpandFilenames(&number_files,&filelist);\n  list[0]=DestroyString(list[0]);\n  list=(char **) RelinquishMagickMemory(list);\n  if ((status == MagickFalse) || (number_files == 0))\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  image=DestroyImage(image);\n  /*\n    Read each image and convert them to a tile.\n  */\n  images=NewImageList();\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  if (read_info->size == (char *) NULL)\n    (void) CloneString(&read_info->size,DefaultTileGeometry);\n  for (i=0; i < (ssize_t) number_files; i++)\n  {\n    if (image_info->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"name: %s\",\n        filelist[i]);\n    (void) CopyMagickString(read_info->filename,filelist[i],MaxTextExtent);\n    filelist[i]=DestroyString(filelist[i]);\n    *read_info->magick='\\0';\n    next_image=ReadImage(read_info,exception);\n    CatchException(exception);\n    if (next_image == (Image *) NULL)\n      break;\n    label=InterpretImageProperties(image_info,next_image,DefaultTileLabel);\n    (void) SetImageProperty(next_image,\"label\",label);\n    label=DestroyString(label);\n    if (image_info->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"geometry: %.20gx%.20g\",(double) next_image->columns,(double)\n        next_image->rows);\n    SetGeometry(next_image,&geometry);\n    (void) ParseMetaGeometry(read_info->size,&geometry.x,&geometry.y,\n      &geometry.width,&geometry.height);\n    thumbnail_image=ThumbnailImage(next_image,geometry.width,geometry.height,\n      exception);\n    if (thumbnail_image != (Image *) NULL)\n      {\n        next_image=DestroyImage(next_image);\n        next_image=thumbnail_image;\n      }\n    if (image_info->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"thumbnail geometry: %.20gx%.20g\",(double) next_image->columns,(double)\n        next_image->rows);\n    AppendImageToList(&images,next_image);\n    status=SetImageProgress(images,LoadImagesTag,i,number_files);\n    if (status == MagickFalse)\n      break;\n  }\n  read_info=DestroyImageInfo(read_info);\n  filelist=(char **) RelinquishMagickMemory(filelist);\n  if (images == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\n      \"ImageFileDoesNotContainAnyImageData\");\n  /*\n    Create the visual image directory.\n  */\n  montage_info=CloneMontageInfo(image_info,(MontageInfo *) NULL);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"creating montage\");\n  montage_image=MontageImageList(image_info,montage_info,\n    GetFirstImageInList(images),exception);\n  montage_info=DestroyMontageInfo(montage_info);\n  images=DestroyImageList(images);\n  return(montage_image);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147016,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static Image *ReadVIDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ClientName  \"montage\"\n\n  char\n    **filelist,\n    *label,\n    **list;\n\n  Image\n    *image,\n    *images,\n    *montage_image,\n    *next_image,\n    *thumbnail_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    number_files;\n\n  MagickBooleanType\n    status;\n\n  MontageInfo\n    *montage_info;\n\n  RectangleInfo\n    geometry;\n\n  register ssize_t\n    i;\n\n  /*\n    Expand the filename.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info);\n  list=(char **) AcquireMagickMemory(sizeof(*filelist));\n  if (list == (char **) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  list[0]=ConstantString(image_info->filename);\n  filelist=list;\n  number_files=1;\n  status=ExpandFilenames(&number_files,&filelist);\n  list[0]=DestroyString(list[0]);\n  list=(char **) RelinquishMagickMemory(list);\n  if ((status == MagickFalse) || (number_files == 0))\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  image=DestroyImage(image);\n  /*\n    Read each image and convert them to a tile.\n  */\n  images=NewImageList();\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  if (read_info->size == (char *) NULL)\n    (void) CloneString(&read_info->size,DefaultTileGeometry);\n  for (i=0; i < (ssize_t) number_files; i++)\n  {\n    if (image_info->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"name: %s\",\n        filelist[i]);\n    (void) CopyMagickString(read_info->filename,filelist[i],MaxTextExtent);\n    filelist[i]=DestroyString(filelist[i]);\n    *read_info->magick='\\0';\n    next_image=ReadImage(read_info,exception);\n    CatchException(exception);\n    if (next_image == (Image *) NULL)\n      break;\n    label=InterpretImageProperties(image_info,next_image,DefaultTileLabel);\n    if (label != (char *) NULL)\n      {\n        (void) SetImageProperty(next_image,\"label\",label);\n        label=DestroyString(label);\n      }\n    if (image_info->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"geometry: %.20gx%.20g\",(double) next_image->columns,(double)\n        next_image->rows);\n    SetGeometry(next_image,&geometry);\n    (void) ParseMetaGeometry(read_info->size,&geometry.x,&geometry.y,\n      &geometry.width,&geometry.height);\n    thumbnail_image=ThumbnailImage(next_image,geometry.width,geometry.height,\n      exception);\n    if (thumbnail_image != (Image *) NULL)\n      {\n        next_image=DestroyImage(next_image);\n        next_image=thumbnail_image;\n      }\n    if (image_info->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"thumbnail geometry: %.20gx%.20g\",(double) next_image->columns,(double)\n        next_image->rows);\n    AppendImageToList(&images,next_image);\n    status=SetImageProgress(images,LoadImagesTag,i,number_files);\n    if (status == MagickFalse)\n      break;\n  }\n  read_info=DestroyImageInfo(read_info);\n  filelist=(char **) RelinquishMagickMemory(filelist);\n  if (images == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\n      \"ImageFileDoesNotContainAnyImageData\");\n  /*\n    Create the visual image directory.\n  */\n  montage_info=CloneMontageInfo(image_info,(MontageInfo *) NULL);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"creating montage\");\n  montage_image=MontageImageList(image_info,montage_info,\n    GetFirstImageInList(images),exception);\n  montage_info=DestroyMontageInfo(montage_info);\n  images=DestroyImageList(images);\n  return(montage_image);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147017,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int get_vdev_port_node_info(struct mdesc_handle *md, u64 node,\n\t\t\t\t   union md_node_info *node_info)\n{\n\tconst u64 *parent_cfg_hdlp;\n\tconst char *name;\n\tconst u64 *idp;\n\n\t/*\n\t * Virtual device nodes are distinguished by:\n\t * 1. \"id\" property\n\t * 2. \"name\" property\n\t * 3. parent node \"cfg-handle\" property\n\t */\n\tidp = mdesc_get_property(md, node, \"id\", NULL);\n\tname = mdesc_get_property(md, node, \"name\", NULL);\n\tparent_cfg_hdlp = parent_cfg_handle(md, node);\n\n\tif (!idp || !name || !parent_cfg_hdlp)\n\t\treturn -1;\n\n\tnode_info->vdev_port.id = *idp;\n\tnode_info->vdev_port.name = kstrdup_const(name, GFP_KERNEL);\n\tnode_info->vdev_port.parent_cfg_hdl = *parent_cfg_hdlp;\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147024,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int get_vdev_port_node_info(struct mdesc_handle *md, u64 node,\n\t\t\t\t   union md_node_info *node_info)\n{\n\tconst u64 *parent_cfg_hdlp;\n\tconst char *name;\n\tconst u64 *idp;\n\n\t/*\n\t * Virtual device nodes are distinguished by:\n\t * 1. \"id\" property\n\t * 2. \"name\" property\n\t * 3. parent node \"cfg-handle\" property\n\t */\n\tidp = mdesc_get_property(md, node, \"id\", NULL);\n\tname = mdesc_get_property(md, node, \"name\", NULL);\n\tparent_cfg_hdlp = parent_cfg_handle(md, node);\n\n\tif (!idp || !name || !parent_cfg_hdlp)\n\t\treturn -1;\n\n\tnode_info->vdev_port.id = *idp;\n\tnode_info->vdev_port.name = kstrdup_const(name, GFP_KERNEL);\n\tif (!node_info->vdev_port.name)\n\t\treturn -1;\n\tnode_info->vdev_port.parent_cfg_hdl = *parent_cfg_hdlp;\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147025,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "WandExport double *DrawGetStrokeDashArray(const DrawingWand *wand,\n  size_t *number_elements)\n{\n  double\n    *dasharray;\n\n  register const double\n    *p;\n\n  register double\n    *q;\n\n  register ssize_t\n    i;\n\n  size_t\n    n;\n\n  assert(wand != (const DrawingWand *) NULL);\n  assert(wand->signature == MagickWandSignature);\n  if (wand->debug != MagickFalse)\n    (void) LogMagickEvent(WandEvent,GetMagickModule(),\"%s\",wand->name);\n  assert(number_elements != (size_t *) NULL);\n  n=0;\n  p=CurrentContext->dash_pattern;\n  if (p != (const double *) NULL)\n    while (fabs(*p++) >= MagickEpsilon)\n      n++;\n  *number_elements=n;\n  dasharray=(double *) NULL;\n  if (n != 0)\n    {\n      dasharray=(double *) AcquireQuantumMemory((size_t) n+1UL,\n        sizeof(*dasharray));\n      p=CurrentContext->dash_pattern;\n      q=dasharray;\n      for (i=0; i < (ssize_t) n; i++)\n        *q++=(*p++);\n      *q=0.0;\n    }\n  return(dasharray);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147036,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "WandExport double *DrawGetStrokeDashArray(const DrawingWand *wand,\n  size_t *number_elements)\n{\n  double\n    *dasharray;\n\n  register const double\n    *p;\n\n  register double\n    *q;\n\n  register ssize_t\n    i;\n\n  size_t\n    n;\n\n  assert(wand != (const DrawingWand *) NULL);\n  assert(wand->signature == MagickWandSignature);\n  if (wand->debug != MagickFalse)\n    (void) LogMagickEvent(WandEvent,GetMagickModule(),\"%s\",wand->name);\n  assert(number_elements != (size_t *) NULL);\n  n=0;\n  p=CurrentContext->dash_pattern;\n  if (p != (const double *) NULL)\n    while (fabs(*p++) >= MagickEpsilon)\n      n++;\n  *number_elements=n;\n  dasharray=(double *) NULL;\n  if (n != 0)\n    {\n      dasharray=(double *) AcquireQuantumMemory((size_t) n+1UL,\n        sizeof(*dasharray));\n      if (dasharray != (double *) NULL)\n        {\n          p=CurrentContext->dash_pattern;\n          q=dasharray;\n          for (i=0; i < (ssize_t) n; i++)\n            *q++=(*p++);\n          *q=0.0;\n        }\n    }\n  return(dasharray);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147037,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "fetch_token(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r, num;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  const OnigSyntaxType* syn = env->syntax;\n  UChar* prev;\n  UChar* p = *src;\n  PFETCH_READY;\n\n start:\n  if (PEND) {\n    tok->type = TK_EOT;\n    return tok->type;\n  }\n\n  tok->type  = TK_STRING;\n  tok->base  = 0;\n  tok->backp = p;\n\n  PFETCH(c);\n  if (IS_MC_ESC_CODE(c, syn)) {\n    if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n    tok->backp = p;\n    PFETCH(c);\n\n    tok->u.c = c;\n    tok->escaped = 1;\n    switch (c) {\n    case '*':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '+':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_PLUS_ONE_INF)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 1;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '?':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_QMARK_ZERO_ONE)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = 1;\n    greedy_check:\n      if (!PEND && PPEEK_IS('?') &&\n\t  IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_NON_GREEDY)) {\n\tPFETCH(c);\n\ttok->u.repeat.greedy     = 0;\n\ttok->u.repeat.possessive = 0;\n      }\n      else {\n      possessive_check:\n\tif (!PEND && PPEEK_IS('+') &&\n\t    ((IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT) &&\n\t      tok->type != TK_INTERVAL)  ||\n\t     (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL) &&\n\t      tok->type == TK_INTERVAL))) {\n\t  PFETCH(c);\n\t  tok->u.repeat.greedy     = 1;\n\t  tok->u.repeat.possessive = 1;\n\t}\n\telse {\n\t  tok->u.repeat.greedy     = 1;\n\t  tok->u.repeat.possessive = 0;\n\t}\n      }\n      break;\n\n    case '{':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_BRACE_INTERVAL)) break;\n      r = fetch_range_quantifier(&p, end, tok, env);\n      if (r < 0) return r;  /* error */\n      if (r == 0) goto greedy_check;\n      else if (r == 2) { /* {n} */\n\tif (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))\n\t  goto possessive_check;\n\n\tgoto greedy_check;\n      }\n      /* r == 1 : normal char */\n      break;\n\n    case '|':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_VBAR_ALT)) break;\n      tok->type = TK_ALT;\n      break;\n\n    case '(':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_OPEN;\n      break;\n\n    case ')':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_CLOSE;\n      break;\n\n    case 'w':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'W':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'b':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_WORD_BOUND;\n      tok->u.anchor.ascii_range = IS_ASCII_RANGE(env->option)\n\t\t&& ! IS_WORD_BOUND_ALL_RANGE(env->option);\n      break;\n\n    case 'B':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_NOT_WORD_BOUND;\n      tok->u.anchor.ascii_range = IS_ASCII_RANGE(env->option)\n\t\t&& ! IS_WORD_BOUND_ALL_RANGE(env->option);\n      break;\n\n#ifdef USE_WORD_BEGIN_END\n    case '<':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_WORD_BEGIN;\n      tok->u.anchor.ascii_range = IS_ASCII_RANGE(env->option);\n      break;\n\n    case '>':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_WORD_END;\n      tok->u.anchor.ascii_range = IS_ASCII_RANGE(env->option);\n      break;\n#endif\n\n    case 's':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'S':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'd':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'D':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'h':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'H':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'A':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n    begin_buf:\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_BEGIN_BUF;\n      break;\n\n    case 'Z':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_SEMI_END_BUF;\n      break;\n\n    case 'z':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n    end_buf:\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_END_BUF;\n      break;\n\n    case 'G':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_BEGIN_POSITION;\n      break;\n\n    case '`':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;\n      goto begin_buf;\n      break;\n\n    case '\\'':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;\n      goto end_buf;\n      break;\n\n    case 'x':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {\n\tPINC;\n\tnum = scan_unsigned_hexadecimal_number(&p, end, 0, 8, enc);\n\tif (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n\tif (!PEND) {\n\t  if (ONIGENC_IS_CODE_XDIGIT(enc, PPEEK))\n\t    return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n\t}\n\n\tif ((p > prev + enclen(enc, prev, end)) && !PEND && PPEEK_IS('}')) {\n\t  PINC;\n\t  tok->type   = TK_CODE_POINT;\n\t  tok->u.code = (OnigCodePoint )num;\n\t}\n\telse {\n\t  /* can't read nothing or invalid format */\n\t  p = prev;\n\t}\n      }\n      else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {\n\tnum = scan_unsigned_hexadecimal_number(&p, end, 0, 2, enc);\n\tif (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n\tif (p == prev) {  /* can't read nothing. */\n\t  num = 0; /* but, it's not error */\n\t}\n\ttok->type = TK_RAW_BYTE;\n\ttok->base = 16;\n\ttok->u.c  = num;\n      }\n      break;\n\n    case 'u':\n      if (PEND) break;\n\n      prev = p;\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {\n\tnum = scan_unsigned_hexadecimal_number(&p, end, 4, 4, enc);\n\tif (num < -1) return ONIGERR_TOO_SHORT_DIGITS;\n\telse if (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n\tif (p == prev) {  /* can't read nothing. */\n\t  num = 0; /* but, it's not error */\n\t}\n\ttok->type   = TK_CODE_POINT;\n\ttok->base   = 16;\n\ttok->u.code = (OnigCodePoint )num;\n      }\n      break;\n\n    case 'o':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_O_BRACE_OCTAL)) {\n\tPINC;\n\tnum = scan_unsigned_octal_number(&p, end, 11, enc);\n\tif (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n\tif (!PEND) {\n\t  OnigCodePoint c = PPEEK;\n\t  if (ONIGENC_IS_CODE_DIGIT(enc, c) && c < '8')\n\t    return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n\t}\n\n\tif ((p > prev + enclen(enc, prev, end)) && !PEND && PPEEK_IS('}')) {\n\t  PINC;\n\t  tok->type   = TK_CODE_POINT;\n\t  tok->u.code = (OnigCodePoint )num;\n\t}\n\telse {\n\t  /* can't read nothing or invalid format */\n\t  p = prev;\n\t}\n      }\n      break;\n\n    case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n      PUNFETCH;\n      prev = p;\n      num = onig_scan_unsigned_number(&p, end, enc);\n      if (num < 0 || num > ONIG_MAX_BACKREF_NUM) {\n\tgoto skip_backref;\n      }\n\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_DECIMAL_BACKREF) &&\n\t  (num <= env->num_mem || num <= 9)) { /* This spec. from GNU regex */\n\tif (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n\t  if (num > env->num_mem || IS_NULL(SCANENV_MEM_NODES(env)[num]))\n\t    return ONIGERR_INVALID_BACKREF;\n\t}\n\n\ttok->type = TK_BACKREF;\n\ttok->u.backref.num     = 1;\n\ttok->u.backref.ref1    = num;\n\ttok->u.backref.by_name = 0;\n#ifdef USE_BACKREF_WITH_LEVEL\n\ttok->u.backref.exist_level = 0;\n#endif\n\tbreak;\n      }\n\n    skip_backref:\n      if (c == '8' || c == '9') {\n\t/* normal char */\n\tp = prev; PINC;\n\tbreak;\n      }\n\n      p = prev;\n      /* fall through */\n    case '0':\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {\n\tprev = p;\n\tnum = scan_unsigned_octal_number(&p, end, (c == '0' ? 2:3), enc);\n\tif (num < 0 || 0xff < num) return ONIGERR_TOO_BIG_NUMBER;\n\tif (p == prev) {  /* can't read nothing. */\n\t  num = 0; /* but, it's not error */\n\t}\n\ttok->type = TK_RAW_BYTE;\n\ttok->base = 8;\n\ttok->u.c  = num;\n      }\n      else if (c != '0') {\n\tPINC;\n      }\n      break;\n\n#ifdef USE_NAMED_GROUP\n    case 'k':\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_K_NAMED_BACKREF)) {\n\tPFETCH(c);\n\tif (c == '<' || c == '\\'') {\n\t  r = fetch_named_backref_token(c, tok, &p, end, env);\n\t  if (r < 0) return r;\n\t}\n\telse {\n\t  PUNFETCH;\n\t  onig_syntax_warn(env, \"invalid back reference\");\n\t}\n      }\n      break;\n#endif\n\n#if defined(USE_SUBEXP_CALL) || defined(USE_NAMED_GROUP)\n    case 'g':\n# ifdef USE_NAMED_GROUP\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_G_BRACE_BACKREF)) {\n\tPFETCH(c);\n\tif (c == '{') {\n\t  r = fetch_named_backref_token(c, tok, &p, end, env);\n\t  if (r < 0) return r;\n\t}\n\telse\n\t  PUNFETCH;\n      }\n# endif\n# ifdef USE_SUBEXP_CALL\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_G_SUBEXP_CALL)) {\n\tPFETCH(c);\n\tif (c == '<' || c == '\\'') {\n\t  int gnum = -1, rel = 0;\n\t  UChar* name_end;\n\t  OnigCodePoint cnext;\n\n\t  cnext = PPEEK;\n\t  if (cnext == '0') {\n\t    PINC;\n\t    if (PPEEK_IS(get_name_end_code_point(c))) {  /* \\g<0>, \\g'0' */\n\t      PINC;\n\t      name_end = p;\n\t      gnum = 0;\n\t    }\n\t  }\n\t  else if (cnext == '+') {\n\t    PINC;\n\t    rel = 1;\n\t  }\n\t  prev = p;\n\t  if (gnum < 0) {\n\t    r = fetch_name((OnigCodePoint )c, &p, end, &name_end, env, &gnum, 1);\n\t    if (r < 0) return r;\n\t  }\n\n\t  tok->type = TK_CALL;\n\t  tok->u.call.name     = prev;\n\t  tok->u.call.name_end = name_end;\n\t  tok->u.call.gnum     = gnum;\n\t  tok->u.call.rel      = rel;\n\t}\n\telse {\n\t  onig_syntax_warn(env, \"invalid subexp call\");\n\t  PUNFETCH;\n\t}\n      }\n# endif\n      break;\n#endif\n\n    case 'Q':\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE)) {\n\ttok->type = TK_QUOTE_OPEN;\n      }\n      break;\n\n    case 'p':\n    case 'P':\n      if (PPEEK_IS('{') &&\n\t  IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {\n\tPINC;\n\ttok->type = TK_CHAR_PROPERTY;\n\ttok->u.prop.not = (c == 'P' ? 1 : 0);\n\n\tif (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {\n\t  PFETCH(c);\n\t  if (c == '^') {\n\t    tok->u.prop.not = (tok->u.prop.not == 0 ? 1 : 0);\n\t  }\n\t  else\n\t    PUNFETCH;\n\t}\n      }\n      else {\n\tonig_syntax_warn(env, \"invalid Unicode Property \\\\%c\", c);\n      }\n      break;\n\n    case 'R':\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_R_LINEBREAK)) {\n\ttok->type = TK_LINEBREAK;\n      }\n      break;\n\n    case 'X':\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_X_EXTENDED_GRAPHEME_CLUSTER)) {\n\ttok->type = TK_EXTENDED_GRAPHEME_CLUSTER;\n      }\n      break;\n\n    case 'K':\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_K_KEEP)) {\n\ttok->type = TK_KEEP;\n      }\n      break;\n\n    default:\n      {\n\tOnigCodePoint c2;\n\n\tPUNFETCH;\n\tnum = fetch_escaped_value(&p, end, env, &c2);\n\tif (num < 0) return num;\n\t/* set_raw: */\n\tif ((OnigCodePoint )tok->u.c != c2) {\n\t  tok->type = TK_CODE_POINT;\n\t  tok->u.code = (OnigCodePoint )c2;\n\t}\n\telse { /* string */\n\t  p = tok->backp + enclen(enc, tok->backp, end);\n\t}\n      }\n      break;\n    }\n  }\n  else {\n    tok->u.c = c;\n    tok->escaped = 0;\n\n#ifdef USE_VARIABLE_META_CHARS\n    if ((c != ONIG_INEFFECTIVE_META_CHAR) &&\n\tIS_SYNTAX_OP(syn, ONIG_SYN_OP_VARIABLE_META_CHARACTERS)) {\n      if (c == MC_ANYCHAR(syn))\n\tgoto any_char;\n      else if (c == MC_ANYTIME(syn))\n\tgoto anytime;\n      else if (c == MC_ZERO_OR_ONE_TIME(syn))\n\tgoto zero_or_one_time;\n      else if (c == MC_ONE_OR_MORE_TIME(syn))\n\tgoto one_or_more_time;\n      else if (c == MC_ANYCHAR_ANYTIME(syn)) {\n\ttok->type = TK_ANYCHAR_ANYTIME;\n\tgoto out;\n      }\n    }\n#endif\n\n    switch (c) {\n    case '.':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_DOT_ANYCHAR)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    any_char:\n#endif\n      tok->type = TK_ANYCHAR;\n      break;\n\n    case '*':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ASTERISK_ZERO_INF)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    anytime:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '+':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_PLUS_ONE_INF)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    one_or_more_time:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 1;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '?':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_ZERO_ONE)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    zero_or_one_time:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = 1;\n      goto greedy_check;\n      break;\n\n    case '{':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACE_INTERVAL)) break;\n      r = fetch_range_quantifier(&p, end, tok, env);\n      if (r < 0) return r;  /* error */\n      if (r == 0) goto greedy_check;\n      else if (r == 2) { /* {n} */\n\tif (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))\n\t  goto possessive_check;\n\n\tgoto greedy_check;\n      }\n      /* r == 1 : normal char */\n      break;\n\n    case '|':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_VBAR_ALT)) break;\n      tok->type = TK_ALT;\n      break;\n\n    case '(':\n      if (PPEEK_IS('?') &&\n\t  IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_QMARK_GROUP_EFFECT)) {\n\tPINC;\n\tif (PPEEK_IS('#')) {\n\t  PFETCH(c);\n\t  while (1) {\n\t    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n\t    PFETCH(c);\n\t    if (c == MC_ESC(syn)) {\n\t      if (!PEND) PFETCH(c);\n\t    }\n\t    else {\n\t      if (c == ')') break;\n\t    }\n\t  }\n\t  goto start;\n\t}\n#ifdef USE_PERL_SUBEXP_CALL\n\t/* (?&name), (?n), (?R), (?0), (?+n), (?-n) */\n\tc = PPEEK;\n\tif ((c == '&' || c == 'R' || ONIGENC_IS_CODE_DIGIT(enc, c)) &&\n\t    IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_SUBEXP_CALL)) {\n\t  /* (?&name), (?n), (?R), (?0) */\n\t  int gnum;\n\t  UChar *name;\n\t  UChar *name_end;\n\n\t  if (c == 'R' || c == '0') {\n\t    PINC;   /* skip 'R' / '0' */\n\t    if (!PPEEK_IS(')')) return ONIGERR_INVALID_GROUP_NAME;\n\t    PINC;   /* skip ')' */\n\t    name_end = name = p;\n\t    gnum = 0;\n\t  }\n\t  else {\n\t    int numref = 1;\n\t    if (c == '&') {     /* (?&name) */\n\t      PINC;\n\t      numref = 0;       /* don't allow number name */\n\t    }\n\t    name = p;\n\t    r = fetch_name((OnigCodePoint )'(', &p, end, &name_end, env, &gnum, numref);\n\t    if (r < 0) return r;\n\t  }\n\n\t  tok->type = TK_CALL;\n\t  tok->u.call.name     = name;\n\t  tok->u.call.name_end = name_end;\n\t  tok->u.call.gnum     = gnum;\n\t  tok->u.call.rel      = 0;\n\t  break;\n\t}\n\telse if ((c == '-' || c == '+') &&\n\t    IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_SUBEXP_CALL)) {\n\t  /* (?+n), (?-n) */\n\t  int gnum;\n\t  UChar *name;\n\t  UChar *name_end;\n\t  OnigCodePoint cnext;\n\t  PFETCH_READY;\n\n\t  PINC;     /* skip '-' / '+' */\n\t  cnext = PPEEK;\n\t  if (ONIGENC_IS_CODE_DIGIT(enc, cnext)) {\n\t    if (c == '-') PUNFETCH;\n\t    name = p;\n\t    r = fetch_name((OnigCodePoint )'(', &p, end, &name_end, env, &gnum, 1);\n\t    if (r < 0) return r;\n\n\t    tok->type = TK_CALL;\n\t    tok->u.call.name     = name;\n\t    tok->u.call.name_end = name_end;\n\t    tok->u.call.gnum     = gnum;\n\t    tok->u.call.rel      = 1;\n\t    break;\n\t  }\n\t}\n#endif /* USE_PERL_SUBEXP_CALL */\n#ifdef USE_CAPITAL_P_NAMED_GROUP\n\tif (PPEEK_IS('P') &&\n\t    IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_CAPITAL_P_NAMED_GROUP)) {\n\t  int gnum;\n\t  UChar *name;\n\t  UChar *name_end;\n\t  PFETCH_READY;\n\n\t  PINC;     /* skip 'P' */\n\t  if (PEND) return ONIGERR_UNDEFINED_GROUP_OPTION;\n\t  PFETCH(c);\n\t  if (c == '=') {       /* (?P=name): backref */\n\t    r = fetch_named_backref_token((OnigCodePoint )'(', tok, &p, end, env);\n\t    if (r < 0) return r;\n\t    break;\n\t  }\n\t  else if (c == '>') {  /* (?P>name): subexp call */\n\t    name = p;\n\t    r = fetch_name((OnigCodePoint )'(', &p, end, &name_end, env, &gnum, 0);\n\t    if (r < 0) return r;\n\n\t    tok->type = TK_CALL;\n\t    tok->u.call.name     = name;\n\t    tok->u.call.name_end = name_end;\n\t    tok->u.call.gnum     = gnum;\n\t    tok->u.call.rel      = 0;\n\t    break;\n\t  }\n\t}\n#endif /* USE_CAPITAL_P_NAMED_GROUP */\n\tPUNFETCH;\n      }\n\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_OPEN;\n      break;\n\n    case ')':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_CLOSE;\n      break;\n\n    case '^':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = (IS_SINGLELINE(env->option)\n\t\t\t       ? ANCHOR_BEGIN_BUF : ANCHOR_BEGIN_LINE);\n      break;\n\n    case '$':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = (IS_SINGLELINE(env->option)\n\t\t\t       ? ANCHOR_SEMI_END_BUF : ANCHOR_END_LINE);\n      break;\n\n    case '[':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACKET_CC)) break;\n      tok->type = TK_CC_OPEN;\n      break;\n\n    case ']':\n      if (*src > env->pattern)   /* /].../ is allowed. */\n\tCLOSE_BRACKET_WITHOUT_ESC_WARN(env, (UChar* )\"]\");\n      break;\n\n    case '#':\n      if (IS_EXTEND(env->option)) {\n\twhile (!PEND) {\n\t  PFETCH(c);\n\t  if (ONIGENC_IS_CODE_NEWLINE(enc, c))\n\t    break;\n\t}\n\tgoto start;\n\tbreak;\n      }\n      break;\n\n    case ' ': case '\\t': case '\\n': case '\\r': case '\\f':\n      if (IS_EXTEND(env->option))\n\tgoto start;\n      break;\n\n    default:\n      /* string */\n      break;\n    }\n  }\n\n#ifdef USE_VARIABLE_META_CHARS\n out:\n#endif\n  *src = p;\n  return tok->type;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147052,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "fetch_token(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r, num;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  const OnigSyntaxType* syn = env->syntax;\n  UChar* prev;\n  UChar* p = *src;\n  PFETCH_READY;\n\n start:\n  if (PEND) {\n    tok->type = TK_EOT;\n    return tok->type;\n  }\n\n  tok->type  = TK_STRING;\n  tok->base  = 0;\n  tok->backp = p;\n\n  PFETCH(c);\n  if (IS_MC_ESC_CODE(c, syn)) {\n    if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n    tok->backp = p;\n    PFETCH(c);\n\n    tok->u.c = c;\n    tok->escaped = 1;\n    switch (c) {\n    case '*':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '+':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_PLUS_ONE_INF)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 1;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '?':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_QMARK_ZERO_ONE)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = 1;\n    greedy_check:\n      if (!PEND && PPEEK_IS('?') &&\n\t  IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_NON_GREEDY)) {\n\tPFETCH(c);\n\ttok->u.repeat.greedy     = 0;\n\ttok->u.repeat.possessive = 0;\n      }\n      else {\n      possessive_check:\n\tif (!PEND && PPEEK_IS('+') &&\n\t    ((IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT) &&\n\t      tok->type != TK_INTERVAL)  ||\n\t     (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL) &&\n\t      tok->type == TK_INTERVAL))) {\n\t  PFETCH(c);\n\t  tok->u.repeat.greedy     = 1;\n\t  tok->u.repeat.possessive = 1;\n\t}\n\telse {\n\t  tok->u.repeat.greedy     = 1;\n\t  tok->u.repeat.possessive = 0;\n\t}\n      }\n      break;\n\n    case '{':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_BRACE_INTERVAL)) break;\n      r = fetch_range_quantifier(&p, end, tok, env);\n      if (r < 0) return r;  /* error */\n      if (r == 0) goto greedy_check;\n      else if (r == 2) { /* {n} */\n\tif (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))\n\t  goto possessive_check;\n\n\tgoto greedy_check;\n      }\n      /* r == 1 : normal char */\n      break;\n\n    case '|':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_VBAR_ALT)) break;\n      tok->type = TK_ALT;\n      break;\n\n    case '(':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_OPEN;\n      break;\n\n    case ')':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_CLOSE;\n      break;\n\n    case 'w':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'W':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'b':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_WORD_BOUND;\n      tok->u.anchor.ascii_range = IS_ASCII_RANGE(env->option)\n\t\t&& ! IS_WORD_BOUND_ALL_RANGE(env->option);\n      break;\n\n    case 'B':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_NOT_WORD_BOUND;\n      tok->u.anchor.ascii_range = IS_ASCII_RANGE(env->option)\n\t\t&& ! IS_WORD_BOUND_ALL_RANGE(env->option);\n      break;\n\n#ifdef USE_WORD_BEGIN_END\n    case '<':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_WORD_BEGIN;\n      tok->u.anchor.ascii_range = IS_ASCII_RANGE(env->option);\n      break;\n\n    case '>':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_WORD_END;\n      tok->u.anchor.ascii_range = IS_ASCII_RANGE(env->option);\n      break;\n#endif\n\n    case 's':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'S':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'd':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'D':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'h':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'H':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'A':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n    begin_buf:\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_BEGIN_BUF;\n      break;\n\n    case 'Z':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_SEMI_END_BUF;\n      break;\n\n    case 'z':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n    end_buf:\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_END_BUF;\n      break;\n\n    case 'G':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_BEGIN_POSITION;\n      break;\n\n    case '`':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;\n      goto begin_buf;\n      break;\n\n    case '\\'':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;\n      goto end_buf;\n      break;\n\n    case 'x':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {\n\tPINC;\n\tnum = scan_unsigned_hexadecimal_number(&p, end, 0, 8, enc);\n\tif (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n\tif (!PEND) {\n\t  if (ONIGENC_IS_CODE_XDIGIT(enc, PPEEK))\n\t    return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n\t}\n\n\tif ((p > prev + enclen(enc, prev, end)) && !PEND && PPEEK_IS('}')) {\n\t  PINC;\n\t  tok->type   = TK_CODE_POINT;\n\t  tok->u.code = (OnigCodePoint )num;\n\t}\n\telse {\n\t  /* can't read nothing or invalid format */\n\t  p = prev;\n\t}\n      }\n      else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {\n\tnum = scan_unsigned_hexadecimal_number(&p, end, 0, 2, enc);\n\tif (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n\tif (p == prev) {  /* can't read nothing. */\n\t  num = 0; /* but, it's not error */\n\t}\n\ttok->type = TK_RAW_BYTE;\n\ttok->base = 16;\n\ttok->u.c  = num;\n      }\n      break;\n\n    case 'u':\n      if (PEND) break;\n\n      prev = p;\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {\n\tnum = scan_unsigned_hexadecimal_number(&p, end, 4, 4, enc);\n\tif (num < -1) return ONIGERR_TOO_SHORT_DIGITS;\n\telse if (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n\tif (p == prev) {  /* can't read nothing. */\n\t  num = 0; /* but, it's not error */\n\t}\n\ttok->type   = TK_CODE_POINT;\n\ttok->base   = 16;\n\ttok->u.code = (OnigCodePoint )num;\n      }\n      break;\n\n    case 'o':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_O_BRACE_OCTAL)) {\n\tPINC;\n\tnum = scan_unsigned_octal_number(&p, end, 11, enc);\n\tif (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n\tif (!PEND) {\n\t  OnigCodePoint c = PPEEK;\n\t  if (ONIGENC_IS_CODE_DIGIT(enc, c) && c < '8')\n\t    return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n\t}\n\n\tif ((p > prev + enclen(enc, prev, end)) && !PEND && PPEEK_IS('}')) {\n\t  PINC;\n\t  tok->type   = TK_CODE_POINT;\n\t  tok->u.code = (OnigCodePoint )num;\n\t}\n\telse {\n\t  /* can't read nothing or invalid format */\n\t  p = prev;\n\t}\n      }\n      break;\n\n    case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n      PUNFETCH;\n      prev = p;\n      num = onig_scan_unsigned_number(&p, end, enc);\n      if (num < 0 || num > ONIG_MAX_BACKREF_NUM) {\n\tgoto skip_backref;\n      }\n\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_DECIMAL_BACKREF) &&\n\t  (num <= env->num_mem || num <= 9)) { /* This spec. from GNU regex */\n\tif (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n\t  if (num > env->num_mem || IS_NULL(SCANENV_MEM_NODES(env)[num]))\n\t    return ONIGERR_INVALID_BACKREF;\n\t}\n\n\ttok->type = TK_BACKREF;\n\ttok->u.backref.num     = 1;\n\ttok->u.backref.ref1    = num;\n\ttok->u.backref.by_name = 0;\n#ifdef USE_BACKREF_WITH_LEVEL\n\ttok->u.backref.exist_level = 0;\n#endif\n\tbreak;\n      }\n\n    skip_backref:\n      if (c == '8' || c == '9') {\n\t/* normal char */\n\tp = prev; PINC;\n\tbreak;\n      }\n\n      p = prev;\n      /* fall through */\n    case '0':\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {\n\tprev = p;\n\tnum = scan_unsigned_octal_number(&p, end, (c == '0' ? 2:3), enc);\n\tif (num < 0 || 0xff < num) return ONIGERR_TOO_BIG_NUMBER;\n\tif (p == prev) {  /* can't read nothing. */\n\t  num = 0; /* but, it's not error */\n\t}\n\ttok->type = TK_RAW_BYTE;\n\ttok->base = 8;\n\ttok->u.c  = num;\n      }\n      else if (c != '0') {\n\tPINC;\n      }\n      break;\n\n#ifdef USE_NAMED_GROUP\n    case 'k':\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_K_NAMED_BACKREF)) {\n\tPFETCH(c);\n\tif (c == '<' || c == '\\'') {\n\t  r = fetch_named_backref_token(c, tok, &p, end, env);\n\t  if (r < 0) return r;\n\t}\n\telse {\n\t  PUNFETCH;\n\t  onig_syntax_warn(env, \"invalid back reference\");\n\t}\n      }\n      break;\n#endif\n\n#if defined(USE_SUBEXP_CALL) || defined(USE_NAMED_GROUP)\n    case 'g':\n# ifdef USE_NAMED_GROUP\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_G_BRACE_BACKREF)) {\n\tPFETCH(c);\n\tif (c == '{') {\n\t  r = fetch_named_backref_token(c, tok, &p, end, env);\n\t  if (r < 0) return r;\n\t}\n\telse\n\t  PUNFETCH;\n      }\n# endif\n# ifdef USE_SUBEXP_CALL\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_G_SUBEXP_CALL)) {\n\tPFETCH(c);\n\tif (c == '<' || c == '\\'') {\n\t  int gnum = -1, rel = 0;\n\t  UChar* name_end;\n\t  OnigCodePoint cnext;\n\n\t  cnext = PPEEK;\n\t  if (cnext == '0') {\n\t    PINC;\n\t    if (PPEEK_IS(get_name_end_code_point(c))) {  /* \\g<0>, \\g'0' */\n\t      PINC;\n\t      name_end = p;\n\t      gnum = 0;\n\t    }\n\t  }\n\t  else if (cnext == '+') {\n\t    PINC;\n\t    rel = 1;\n\t  }\n\t  prev = p;\n\t  if (gnum < 0) {\n\t    r = fetch_name((OnigCodePoint )c, &p, end, &name_end, env, &gnum, 1);\n\t    if (r < 0) return r;\n\t  }\n\n\t  tok->type = TK_CALL;\n\t  tok->u.call.name     = prev;\n\t  tok->u.call.name_end = name_end;\n\t  tok->u.call.gnum     = gnum;\n\t  tok->u.call.rel      = rel;\n\t}\n\telse {\n\t  onig_syntax_warn(env, \"invalid subexp call\");\n\t  PUNFETCH;\n\t}\n      }\n# endif\n      break;\n#endif\n\n    case 'Q':\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE)) {\n\ttok->type = TK_QUOTE_OPEN;\n      }\n      break;\n\n    case 'p':\n    case 'P':\n      if (PPEEK_IS('{') &&\n\t  IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {\n\tPINC;\n\ttok->type = TK_CHAR_PROPERTY;\n\ttok->u.prop.not = (c == 'P' ? 1 : 0);\n\n\tif (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {\n\t  PFETCH(c);\n\t  if (c == '^') {\n\t    tok->u.prop.not = (tok->u.prop.not == 0 ? 1 : 0);\n\t  }\n\t  else\n\t    PUNFETCH;\n\t}\n      }\n      else {\n\tonig_syntax_warn(env, \"invalid Unicode Property \\\\%c\", c);\n      }\n      break;\n\n    case 'R':\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_R_LINEBREAK)) {\n\ttok->type = TK_LINEBREAK;\n      }\n      break;\n\n    case 'X':\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_X_EXTENDED_GRAPHEME_CLUSTER)) {\n\ttok->type = TK_EXTENDED_GRAPHEME_CLUSTER;\n      }\n      break;\n\n    case 'K':\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_K_KEEP)) {\n\ttok->type = TK_KEEP;\n      }\n      break;\n\n    default:\n      {\n\tOnigCodePoint c2;\n\n\tPUNFETCH;\n\tnum = fetch_escaped_value(&p, end, env, &c2);\n\tif (num < 0) return num;\n\t/* set_raw: */\n\tif ((OnigCodePoint )tok->u.c != c2) {\n\t  tok->type = TK_CODE_POINT;\n\t  tok->u.code = (OnigCodePoint )c2;\n\t}\n\telse { /* string */\n\t  p = tok->backp + enclen(enc, tok->backp, end);\n\t}\n      }\n      break;\n    }\n  }\n  else {\n    tok->u.c = c;\n    tok->escaped = 0;\n\n#ifdef USE_VARIABLE_META_CHARS\n    if ((c != ONIG_INEFFECTIVE_META_CHAR) &&\n\tIS_SYNTAX_OP(syn, ONIG_SYN_OP_VARIABLE_META_CHARACTERS)) {\n      if (c == MC_ANYCHAR(syn))\n\tgoto any_char;\n      else if (c == MC_ANYTIME(syn))\n\tgoto anytime;\n      else if (c == MC_ZERO_OR_ONE_TIME(syn))\n\tgoto zero_or_one_time;\n      else if (c == MC_ONE_OR_MORE_TIME(syn))\n\tgoto one_or_more_time;\n      else if (c == MC_ANYCHAR_ANYTIME(syn)) {\n\ttok->type = TK_ANYCHAR_ANYTIME;\n\tgoto out;\n      }\n    }\n#endif\n\n    switch (c) {\n    case '.':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_DOT_ANYCHAR)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    any_char:\n#endif\n      tok->type = TK_ANYCHAR;\n      break;\n\n    case '*':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ASTERISK_ZERO_INF)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    anytime:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '+':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_PLUS_ONE_INF)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    one_or_more_time:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 1;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '?':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_ZERO_ONE)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    zero_or_one_time:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = 1;\n      goto greedy_check;\n      break;\n\n    case '{':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACE_INTERVAL)) break;\n      r = fetch_range_quantifier(&p, end, tok, env);\n      if (r < 0) return r;  /* error */\n      if (r == 0) goto greedy_check;\n      else if (r == 2) { /* {n} */\n\tif (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))\n\t  goto possessive_check;\n\n\tgoto greedy_check;\n      }\n      /* r == 1 : normal char */\n      break;\n\n    case '|':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_VBAR_ALT)) break;\n      tok->type = TK_ALT;\n      break;\n\n    case '(':\n      if (PPEEK_IS('?') &&\n\t  IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_QMARK_GROUP_EFFECT)) {\n\tPINC;\n\tif (PPEEK_IS('#')) {\n\t  PFETCH(c);\n\t  while (1) {\n\t    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n\t    PFETCH(c);\n\t    if (c == MC_ESC(syn)) {\n\t      if (!PEND) PFETCH(c);\n\t    }\n\t    else {\n\t      if (c == ')') break;\n\t    }\n\t  }\n\t  goto start;\n\t}\n#ifdef USE_PERL_SUBEXP_CALL\n\t/* (?&name), (?n), (?R), (?0), (?+n), (?-n) */\n\tc = PPEEK;\n\tif ((c == '&' || c == 'R' || ONIGENC_IS_CODE_DIGIT(enc, c)) &&\n\t    IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_SUBEXP_CALL)) {\n\t  /* (?&name), (?n), (?R), (?0) */\n\t  int gnum;\n\t  UChar *name;\n\t  UChar *name_end;\n\n\t  if (c == 'R' || c == '0') {\n\t    PINC;   /* skip 'R' / '0' */\n\t    if (!PPEEK_IS(')')) {\n\t      r = ONIGERR_INVALID_GROUP_NAME;\n\t      onig_scan_env_set_error_string(env, r, p - 1, p + 1);\n\t      return r;\n\t    }\n\t    PINC;   /* skip ')' */\n\t    name_end = name = p;\n\t    gnum = 0;\n\t  }\n\t  else {\n\t    int numref = 1;\n\t    if (c == '&') {     /* (?&name) */\n\t      PINC;\n\t      numref = 0;       /* don't allow number name */\n\t    }\n\t    name = p;\n\t    r = fetch_name((OnigCodePoint )'(', &p, end, &name_end, env, &gnum, numref);\n\t    if (r < 0) return r;\n\t  }\n\n\t  tok->type = TK_CALL;\n\t  tok->u.call.name     = name;\n\t  tok->u.call.name_end = name_end;\n\t  tok->u.call.gnum     = gnum;\n\t  tok->u.call.rel      = 0;\n\t  break;\n\t}\n\telse if ((c == '-' || c == '+') &&\n\t    IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_SUBEXP_CALL)) {\n\t  /* (?+n), (?-n) */\n\t  int gnum;\n\t  UChar *name;\n\t  UChar *name_end;\n\t  OnigCodePoint cnext;\n\t  PFETCH_READY;\n\n\t  PINC;     /* skip '-' / '+' */\n\t  cnext = PPEEK;\n\t  if (ONIGENC_IS_CODE_DIGIT(enc, cnext)) {\n\t    if (c == '-') PUNFETCH;\n\t    name = p;\n\t    r = fetch_name((OnigCodePoint )'(', &p, end, &name_end, env, &gnum, 1);\n\t    if (r < 0) return r;\n\n\t    tok->type = TK_CALL;\n\t    tok->u.call.name     = name;\n\t    tok->u.call.name_end = name_end;\n\t    tok->u.call.gnum     = gnum;\n\t    tok->u.call.rel      = 1;\n\t    break;\n\t  }\n\t}\n#endif /* USE_PERL_SUBEXP_CALL */\n#ifdef USE_CAPITAL_P_NAMED_GROUP\n\tif (PPEEK_IS('P') &&\n\t    IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_CAPITAL_P_NAMED_GROUP)) {\n\t  int gnum;\n\t  UChar *name;\n\t  UChar *name_end;\n\t  PFETCH_READY;\n\n\t  PINC;     /* skip 'P' */\n\t  if (PEND) return ONIGERR_UNDEFINED_GROUP_OPTION;\n\t  PFETCH(c);\n\t  if (c == '=') {       /* (?P=name): backref */\n\t    r = fetch_named_backref_token((OnigCodePoint )'(', tok, &p, end, env);\n\t    if (r < 0) return r;\n\t    break;\n\t  }\n\t  else if (c == '>') {  /* (?P>name): subexp call */\n\t    name = p;\n\t    r = fetch_name((OnigCodePoint )'(', &p, end, &name_end, env, &gnum, 0);\n\t    if (r < 0) return r;\n\n\t    tok->type = TK_CALL;\n\t    tok->u.call.name     = name;\n\t    tok->u.call.name_end = name_end;\n\t    tok->u.call.gnum     = gnum;\n\t    tok->u.call.rel      = 0;\n\t    break;\n\t  }\n\t}\n#endif /* USE_CAPITAL_P_NAMED_GROUP */\n\tPUNFETCH;\n      }\n\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_OPEN;\n      break;\n\n    case ')':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_CLOSE;\n      break;\n\n    case '^':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = (IS_SINGLELINE(env->option)\n\t\t\t       ? ANCHOR_BEGIN_BUF : ANCHOR_BEGIN_LINE);\n      break;\n\n    case '$':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = (IS_SINGLELINE(env->option)\n\t\t\t       ? ANCHOR_SEMI_END_BUF : ANCHOR_END_LINE);\n      break;\n\n    case '[':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACKET_CC)) break;\n      tok->type = TK_CC_OPEN;\n      break;\n\n    case ']':\n      if (*src > env->pattern)   /* /].../ is allowed. */\n\tCLOSE_BRACKET_WITHOUT_ESC_WARN(env, (UChar* )\"]\");\n      break;\n\n    case '#':\n      if (IS_EXTEND(env->option)) {\n\twhile (!PEND) {\n\t  PFETCH(c);\n\t  if (ONIGENC_IS_CODE_NEWLINE(enc, c))\n\t    break;\n\t}\n\tgoto start;\n\tbreak;\n      }\n      break;\n\n    case ' ': case '\\t': case '\\n': case '\\r': case '\\f':\n      if (IS_EXTEND(env->option))\n\tgoto start;\n      break;\n\n    default:\n      /* string */\n      break;\n    }\n  }\n\n#ifdef USE_VARIABLE_META_CHARS\n out:\n#endif\n  *src = p;\n  return tok->type;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147053,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "MagickExport const char *GetMagickProperty(ImageInfo *image_info,\n  Image *image,const char *property,ExceptionInfo *exception)\n{\n  char\n    value[MagickPathExtent];\n\n  const char\n    *string;\n\n  assert(property[0] != '\\0');\n  assert(image != (Image *) NULL || image_info != (ImageInfo *) NULL );\n  if (property[1] == '\\0')  /* single letter property request */\n    return(GetMagickPropertyLetter(image_info,image,*property,exception));\n  if ((image != (Image *) NULL) && (image->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  else\n    if ((image_info != (ImageInfo *) NULL) &&\n        (image_info->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\"no-images\");\n  *value='\\0';           /* formated string */\n  string=(char *) NULL;  /* constant string reference */\n  switch (*property)\n  {\n    case 'b':\n    {\n      if (LocaleCompare(\"basename\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,BasePath,value);\n          if (*value == '\\0')\n            string=\"\";\n          break;\n        }\n      if (LocaleCompare(\"bit-depth\",property) == 0)\n        {\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            GetImageDepth(image,exception));\n          break;\n        }\n      break;\n    }\n    case 'c':\n    {\n      if (LocaleCompare(\"channels\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          /* FUTURE: return actual image channels */\n          (void) FormatLocaleString(value,MagickPathExtent,\"%s\",\n            CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)\n            image->colorspace));\n          LocaleLower(value);\n          if( image->alpha_trait != UndefinedPixelTrait )\n            (void) ConcatenateMagickString(value,\"a\",MagickPathExtent);\n          break;\n        }\n      if (LocaleCompare(\"colorspace\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)\n            image->colorspace);\n          break;\n        }\n      if (LocaleCompare(\"compose\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickComposeOptions,(ssize_t)\n            image->compose);\n          break;\n        }\n      if (LocaleCompare(\"compression\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickCompressOptions,(ssize_t)\n            image->compression);\n          break;\n        }\n      if (LocaleCompare(\"copyright\",property) == 0)\n        {\n          (void) CopyMagickString(value,GetMagickCopyright(),MagickPathExtent);\n          break;\n        }\n      break;\n    }\n    case 'd':\n    {\n      if (LocaleCompare(\"depth\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            image->depth);\n          break;\n        }\n      if (LocaleCompare(\"directory\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,HeadPath,value);\n          if (*value == '\\0')\n            string=\"\";\n          break;\n        }\n      break;\n    }\n    case 'e':\n    {\n      if (LocaleCompare(\"entropy\",property) == 0)\n        {\n          double\n            entropy;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageEntropy(image,&entropy,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),entropy);\n          break;\n        }\n      if (LocaleCompare(\"extension\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,ExtensionPath,value);\n          if (*value == '\\0')\n            string=\"\";\n          break;\n        }\n      break;\n    }\n    case 'g':\n    {\n      if (LocaleCompare(\"gamma\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),image->gamma);\n          break;\n        }\n      break;\n    }\n    case 'h':\n    {\n      if (LocaleCompare(\"height\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n            image->magick_rows != 0 ? (double) image->magick_rows : 256.0);\n          break;\n        }\n      break;\n    }\n    case 'i':\n    {\n      if (LocaleCompare(\"input\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image->filename;\n          break;\n        }\n      if (LocaleCompare(\"interlace\",property) == 0)\n        {\n          string=CommandOptionToMnemonic(MagickInterlaceOptions,(ssize_t)\n            image->interlace);\n          break;\n        }\n      break;\n    }\n    case 'k':\n    {\n      if (LocaleCompare(\"kurtosis\",property) == 0)\n        {\n          double\n            kurtosis,\n            skewness;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),kurtosis);\n          break;\n        }\n      break;\n    }\n    case 'm':\n    {\n      if (LocaleCompare(\"magick\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image->magick;\n          break;\n        }\n      if ((LocaleCompare(\"maxima\",property) == 0) ||\n          (LocaleCompare(\"max\",property) == 0))\n        {\n          double\n            maximum,\n            minimum;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageRange(image,&minimum,&maximum,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),maximum);\n          break;\n        }\n      if (LocaleCompare(\"mean\",property) == 0)\n        {\n          double\n            mean,\n            standard_deviation;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageMean(image,&mean,&standard_deviation,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),mean);\n          break;\n        }\n      if ((LocaleCompare(\"minima\",property) == 0) ||\n          (LocaleCompare(\"min\",property) == 0))\n        {\n          double\n            maximum,\n            minimum;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageRange(image,&minimum,&maximum,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),minimum);\n          break;\n        }\n      break;\n    }\n    case 'o':\n    {\n      if (LocaleCompare(\"opaque\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickBooleanOptions,(ssize_t)\n            IsImageOpaque(image,exception));\n          break;\n        }\n      if (LocaleCompare(\"orientation\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickOrientationOptions,(ssize_t)\n            image->orientation);\n          break;\n        }\n      if (LocaleCompare(\"output\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) CopyMagickString(value,image_info->filename,MagickPathExtent);\n          break;\n        }\n      break;\n    }\n    case 'p':\n    {\n      if (LocaleCompare(\"page\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20gx%.20g\",\n            (double) image->page.width,(double) image->page.height);\n          break;\n        }\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n      if (LocaleCompare(\"profile:icc\",property) == 0 ||\n          LocaleCompare(\"profile:icm\",property) == 0)\n        {\n#if !defined(LCMS_VERSION) || (LCMS_VERSION < 2000)\n#define cmsUInt32Number  DWORD\n#endif\n\n          const StringInfo\n            *profile;\n\n          cmsHPROFILE\n            icc_profile;\n\n          profile=GetImageProfile(image,property+8);\n          if (profile == (StringInfo *) NULL)\n            break;\n          icc_profile=cmsOpenProfileFromMem(GetStringInfoDatum(profile),\n            (cmsUInt32Number) GetStringInfoLength(profile));\n          if (icc_profile != (cmsHPROFILE *) NULL)\n            {\n#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)\n              string=cmsTakeProductName(icc_profile);\n#else\n              (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoDescription,\n                \"en\",\"US\",value,MagickPathExtent);\n#endif\n              (void) cmsCloseProfile(icc_profile);\n            }\n      }\n#endif\n      if (LocaleCompare(\"profiles\",property) == 0)\n        {\n          const char\n            *name;\n\n          ResetImageProfileIterator(image);\n          name=GetNextImageProfile(image);\n          if (name != (char *) NULL)\n            {\n              (void) CopyMagickString(value,name,MagickPathExtent);\n              name=GetNextImageProfile(image);\n              while (name != (char *) NULL)\n              {\n                ConcatenateMagickString(value,\",\",MagickPathExtent);\n                ConcatenateMagickString(value,name,MagickPathExtent);\n                name=GetNextImageProfile(image);\n              }\n            }\n          break;\n        }\n      break;\n    }\n    case 'q':\n    {\n      if (LocaleCompare(\"quality\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            image->quality);\n          break;\n        }\n      break;\n    }\n    case 'r':\n    {\n      if (LocaleCompare(\"resolution.x\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",\n            image->resolution.x);\n          break;\n        }\n      if (LocaleCompare(\"resolution.y\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",\n            image->resolution.y);\n          break;\n        }\n      break;\n    }\n    case 's':\n    {\n      if (LocaleCompare(\"scene\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          if (image_info->number_scenes != 0)\n            (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n              image_info->scene);\n          else {\n            WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n            (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n              image->scene);\n          }\n          break;\n        }\n      if (LocaleCompare(\"scenes\",property) == 0)\n        {\n          /* FUTURE: equivelent to %n? */\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            GetImageListLength(image));\n          break;\n        }\n      if (LocaleCompare(\"size\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatMagickSize(GetBlobSize(image),MagickFalse,\"B\",\n            MagickPathExtent,value);\n          break;\n        }\n      if (LocaleCompare(\"skewness\",property) == 0)\n        {\n          double\n            kurtosis,\n            skewness;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),skewness);\n          break;\n        }\n      if (LocaleCompare(\"standard-deviation\",property) == 0)\n        {\n          double\n            mean,\n            standard_deviation;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageMean(image,&mean,&standard_deviation,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),standard_deviation);\n          break;\n        }\n      break;\n    }\n    case 't':\n    {\n      if (LocaleCompare(\"type\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickTypeOptions,(ssize_t)\n            IdentifyImageType(image,exception));\n          break;\n        }\n       break;\n    }\n    case 'u':\n    {\n      if (LocaleCompare(\"unique\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image_info->unique;\n          break;\n        }\n      if (LocaleCompare(\"units\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickResolutionOptions,(ssize_t)\n            image->units);\n          break;\n        }\n      break;\n    }\n    case 'v':\n    {\n      if (LocaleCompare(\"version\",property) == 0)\n        {\n          string=GetMagickVersion((size_t *) NULL);\n          break;\n        }\n      break;\n    }\n    case 'w':\n    {\n      if (LocaleCompare(\"width\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            (image->magick_columns != 0 ? image->magick_columns : 256));\n          break;\n        }\n      break;\n    }\n  }\n  if (string != (char *) NULL)\n    return(string);\n  if (*value != '\\0')\n    {\n      /*\n        Create a cloned copy of result, that will get cleaned up, eventually.\n      */\n      if (image != (Image *) NULL)\n        {\n          (void) SetImageArtifact(image,\"get-property\",value);\n          return(GetImageArtifact(image,\"get-property\"));\n        }\n      else\n        {\n          (void) SetImageOption(image_info,\"get-property\",value);\n          return(GetImageOption(image_info,\"get-property\"));\n        }\n    }\n  return((char *) NULL);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147054,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "MagickExport const char *GetMagickProperty(ImageInfo *image_info,\n  Image *image,const char *property,ExceptionInfo *exception)\n{\n  char\n    value[MagickPathExtent];\n\n  const char\n    *string;\n\n  assert(property[0] != '\\0');\n  assert(image != (Image *) NULL || image_info != (ImageInfo *) NULL );\n  if (property[1] == '\\0')  /* single letter property request */\n    return(GetMagickPropertyLetter(image_info,image,*property,exception));\n  if ((image != (Image *) NULL) && (image->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  else\n    if ((image_info != (ImageInfo *) NULL) &&\n        (image_info->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\"no-images\");\n  *value='\\0';           /* formated string */\n  string=(char *) NULL;  /* constant string reference */\n  switch (*property)\n  {\n    case 'b':\n    {\n      if (LocaleCompare(\"basename\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,BasePath,value);\n          if (*value == '\\0')\n            string=\"\";\n          break;\n        }\n      if (LocaleCompare(\"bit-depth\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            GetImageDepth(image,exception));\n          break;\n        }\n      break;\n    }\n    case 'c':\n    {\n      if (LocaleCompare(\"channels\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          /* FUTURE: return actual image channels */\n          (void) FormatLocaleString(value,MagickPathExtent,\"%s\",\n            CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)\n            image->colorspace));\n          LocaleLower(value);\n          if( image->alpha_trait != UndefinedPixelTrait )\n            (void) ConcatenateMagickString(value,\"a\",MagickPathExtent);\n          break;\n        }\n      if (LocaleCompare(\"colorspace\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)\n            image->colorspace);\n          break;\n        }\n      if (LocaleCompare(\"compose\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickComposeOptions,(ssize_t)\n            image->compose);\n          break;\n        }\n      if (LocaleCompare(\"compression\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickCompressOptions,(ssize_t)\n            image->compression);\n          break;\n        }\n      if (LocaleCompare(\"copyright\",property) == 0)\n        {\n          (void) CopyMagickString(value,GetMagickCopyright(),MagickPathExtent);\n          break;\n        }\n      break;\n    }\n    case 'd':\n    {\n      if (LocaleCompare(\"depth\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            image->depth);\n          break;\n        }\n      if (LocaleCompare(\"directory\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,HeadPath,value);\n          if (*value == '\\0')\n            string=\"\";\n          break;\n        }\n      break;\n    }\n    case 'e':\n    {\n      if (LocaleCompare(\"entropy\",property) == 0)\n        {\n          double\n            entropy;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageEntropy(image,&entropy,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),entropy);\n          break;\n        }\n      if (LocaleCompare(\"extension\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,ExtensionPath,value);\n          if (*value == '\\0')\n            string=\"\";\n          break;\n        }\n      break;\n    }\n    case 'g':\n    {\n      if (LocaleCompare(\"gamma\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),image->gamma);\n          break;\n        }\n      break;\n    }\n    case 'h':\n    {\n      if (LocaleCompare(\"height\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n            image->magick_rows != 0 ? (double) image->magick_rows : 256.0);\n          break;\n        }\n      break;\n    }\n    case 'i':\n    {\n      if (LocaleCompare(\"input\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image->filename;\n          break;\n        }\n      if (LocaleCompare(\"interlace\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickInterlaceOptions,(ssize_t)\n            image->interlace);\n          break;\n        }\n      break;\n    }\n    case 'k':\n    {\n      if (LocaleCompare(\"kurtosis\",property) == 0)\n        {\n          double\n            kurtosis,\n            skewness;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),kurtosis);\n          break;\n        }\n      break;\n    }\n    case 'm':\n    {\n      if (LocaleCompare(\"magick\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image->magick;\n          break;\n        }\n      if ((LocaleCompare(\"maxima\",property) == 0) ||\n          (LocaleCompare(\"max\",property) == 0))\n        {\n          double\n            maximum,\n            minimum;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageRange(image,&minimum,&maximum,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),maximum);\n          break;\n        }\n      if (LocaleCompare(\"mean\",property) == 0)\n        {\n          double\n            mean,\n            standard_deviation;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageMean(image,&mean,&standard_deviation,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),mean);\n          break;\n        }\n      if ((LocaleCompare(\"minima\",property) == 0) ||\n          (LocaleCompare(\"min\",property) == 0))\n        {\n          double\n            maximum,\n            minimum;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageRange(image,&minimum,&maximum,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),minimum);\n          break;\n        }\n      break;\n    }\n    case 'o':\n    {\n      if (LocaleCompare(\"opaque\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickBooleanOptions,(ssize_t)\n            IsImageOpaque(image,exception));\n          break;\n        }\n      if (LocaleCompare(\"orientation\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickOrientationOptions,(ssize_t)\n            image->orientation);\n          break;\n        }\n      if (LocaleCompare(\"output\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) CopyMagickString(value,image_info->filename,MagickPathExtent);\n          break;\n        }\n      break;\n    }\n    case 'p':\n    {\n      if (LocaleCompare(\"page\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20gx%.20g\",\n            (double) image->page.width,(double) image->page.height);\n          break;\n        }\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n      if (LocaleCompare(\"profile:icc\",property) == 0 ||\n          LocaleCompare(\"profile:icm\",property) == 0)\n        {\n#if !defined(LCMS_VERSION) || (LCMS_VERSION < 2000)\n#define cmsUInt32Number  DWORD\n#endif\n\n          const StringInfo\n            *profile;\n\n          cmsHPROFILE\n            icc_profile;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          profile=GetImageProfile(image,property+8);\n          if (profile == (StringInfo *) NULL)\n            break;\n          icc_profile=cmsOpenProfileFromMem(GetStringInfoDatum(profile),\n            (cmsUInt32Number) GetStringInfoLength(profile));\n          if (icc_profile != (cmsHPROFILE *) NULL)\n            {\n#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)\n              string=cmsTakeProductName(icc_profile);\n#else\n              (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoDescription,\n                \"en\",\"US\",value,MagickPathExtent);\n#endif\n              (void) cmsCloseProfile(icc_profile);\n            }\n      }\n#endif\n      if (LocaleCompare(\"profiles\",property) == 0)\n        {\n          const char\n            *name;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          ResetImageProfileIterator(image);\n          name=GetNextImageProfile(image);\n          if (name != (char *) NULL)\n            {\n              (void) CopyMagickString(value,name,MagickPathExtent);\n              name=GetNextImageProfile(image);\n              while (name != (char *) NULL)\n              {\n                ConcatenateMagickString(value,\",\",MagickPathExtent);\n                ConcatenateMagickString(value,name,MagickPathExtent);\n                name=GetNextImageProfile(image);\n              }\n            }\n          break;\n        }\n      break;\n    }\n    case 'q':\n    {\n      if (LocaleCompare(\"quality\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            image->quality);\n          break;\n        }\n      break;\n    }\n    case 'r':\n    {\n      if (LocaleCompare(\"resolution.x\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",\n            image->resolution.x);\n          break;\n        }\n      if (LocaleCompare(\"resolution.y\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",\n            image->resolution.y);\n          break;\n        }\n      break;\n    }\n    case 's':\n    {\n      if (LocaleCompare(\"scene\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          if (image_info->number_scenes != 0)\n            (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n              image_info->scene);\n          else {\n            WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n            (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n              image->scene);\n          }\n          break;\n        }\n      if (LocaleCompare(\"scenes\",property) == 0)\n        {\n          /* FUTURE: equivelent to %n? */\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            GetImageListLength(image));\n          break;\n        }\n      if (LocaleCompare(\"size\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatMagickSize(GetBlobSize(image),MagickFalse,\"B\",\n            MagickPathExtent,value);\n          break;\n        }\n      if (LocaleCompare(\"skewness\",property) == 0)\n        {\n          double\n            kurtosis,\n            skewness;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),skewness);\n          break;\n        }\n      if (LocaleCompare(\"standard-deviation\",property) == 0)\n        {\n          double\n            mean,\n            standard_deviation;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageMean(image,&mean,&standard_deviation,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),standard_deviation);\n          break;\n        }\n      break;\n    }\n    case 't':\n    {\n      if (LocaleCompare(\"type\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickTypeOptions,(ssize_t)\n            IdentifyImageType(image,exception));\n          break;\n        }\n       break;\n    }\n    case 'u':\n    {\n      if (LocaleCompare(\"unique\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image_info->unique;\n          break;\n        }\n      if (LocaleCompare(\"units\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickResolutionOptions,(ssize_t)\n            image->units);\n          break;\n        }\n      break;\n    }\n    case 'v':\n    {\n      if (LocaleCompare(\"version\",property) == 0)\n        {\n          string=GetMagickVersion((size_t *) NULL);\n          break;\n        }\n      break;\n    }\n    case 'w':\n    {\n      if (LocaleCompare(\"width\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            (image->magick_columns != 0 ? image->magick_columns : 256));\n          break;\n        }\n      break;\n    }\n  }\n  if (string != (char *) NULL)\n    return(string);\n  if (*value != '\\0')\n    {\n      /*\n        Create a cloned copy of result, that will get cleaned up, eventually.\n      */\n      if (image != (Image *) NULL)\n        {\n          (void) SetImageArtifact(image,\"get-property\",value);\n          return(GetImageArtifact(image,\"get-property\"));\n        }\n      else\n        {\n          (void) SetImageOption(image_info,\"get-property\",value);\n          return(GetImageOption(image_info,\"get-property\"));\n        }\n    }\n  return((char *) NULL);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147055,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "g_markup_parse_context_end_parse (GMarkupParseContext  *context,\n                                  GError              **error)\n{\n  g_return_val_if_fail (context != NULL, FALSE);\n  g_return_val_if_fail (!context->parsing, FALSE);\n  g_return_val_if_fail (context->state != STATE_ERROR, FALSE);\n\n  if (context->partial_chunk != NULL)\n    {\n      g_string_free (context->partial_chunk, TRUE);\n      context->partial_chunk = NULL;\n    }\n\n  if (context->document_empty)\n    {\n      set_error_literal (context, error, G_MARKUP_ERROR_EMPTY,\n                         _(\"Document was empty or contained only whitespace\"));\n      return FALSE;\n    }\n\n  context->parsing = TRUE;\n\n  switch (context->state)\n    {\n    case STATE_START:\n      /* Nothing to do */\n      break;\n\n    case STATE_AFTER_OPEN_ANGLE:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\"Document ended unexpectedly just after an open angle bracket \u201c<\u201d\"));\n      break;\n\n    case STATE_AFTER_CLOSE_ANGLE:\n      if (context->tag_stack != NULL)\n        {\n          /* Error message the same as for INSIDE_TEXT */\n          set_error (context, error, G_MARKUP_ERROR_PARSE,\n                     _(\"Document ended unexpectedly with elements still open \u2014 \"\n                       \"\u201c%s\u201d was the last element opened\"),\n                     current_element (context));\n        }\n      break;\n\n    case STATE_AFTER_ELISION_SLASH:\n      set_error (context, error, G_MARKUP_ERROR_PARSE,\n                 _(\"Document ended unexpectedly, expected to see a close angle \"\n                   \"bracket ending the tag <%s/>\"), current_element (context));\n      break;\n\n    case STATE_INSIDE_OPEN_TAG_NAME:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\"Document ended unexpectedly inside an element name\"));\n      break;\n\n    case STATE_INSIDE_ATTRIBUTE_NAME:\n    case STATE_AFTER_ATTRIBUTE_NAME:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\"Document ended unexpectedly inside an attribute name\"));\n      break;\n\n    case STATE_BETWEEN_ATTRIBUTES:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\"Document ended unexpectedly inside an element-opening \"\n                           \"tag.\"));\n      break;\n\n    case STATE_AFTER_ATTRIBUTE_EQUALS_SIGN:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\"Document ended unexpectedly after the equals sign \"\n                           \"following an attribute name; no attribute value\"));\n      break;\n\n    case STATE_INSIDE_ATTRIBUTE_VALUE_SQ:\n    case STATE_INSIDE_ATTRIBUTE_VALUE_DQ:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\"Document ended unexpectedly while inside an attribute \"\n                           \"value\"));\n      break;\n\n    case STATE_INSIDE_TEXT:\n      g_assert (context->tag_stack != NULL);\n      set_error (context, error, G_MARKUP_ERROR_PARSE,\n                 _(\"Document ended unexpectedly with elements still open \u2014 \"\n                   \"\u201c%s\u201d was the last element opened\"),\n                 current_element (context));\n      break;\n\n    case STATE_AFTER_CLOSE_TAG_SLASH:\n    case STATE_INSIDE_CLOSE_TAG_NAME:\n    case STATE_AFTER_CLOSE_TAG_NAME:\n      set_error (context, error, G_MARKUP_ERROR_PARSE,\n                 _(\"Document ended unexpectedly inside the close tag for \"\n                   \"element \u201c%s\u201d\"), current_element (context));\n      break;\n\n    case STATE_INSIDE_PASSTHROUGH:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\"Document ended unexpectedly inside a comment or \"\n                           \"processing instruction\"));\n      break;\n\n    case STATE_ERROR:\n    default:\n      g_assert_not_reached ();\n      break;\n    }\n\n  context->parsing = FALSE;\n\n  return context->state != STATE_ERROR;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147062,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "g_markup_parse_context_end_parse (GMarkupParseContext  *context,\n                                  GError              **error)\n{\n  g_return_val_if_fail (context != NULL, FALSE);\n  g_return_val_if_fail (!context->parsing, FALSE);\n  g_return_val_if_fail (context->state != STATE_ERROR, FALSE);\n\n  if (context->partial_chunk != NULL)\n    {\n      g_string_free (context->partial_chunk, TRUE);\n      context->partial_chunk = NULL;\n    }\n\n  if (context->document_empty)\n    {\n      set_error_literal (context, error, G_MARKUP_ERROR_EMPTY,\n                         _(\"Document was empty or contained only whitespace\"));\n      return FALSE;\n    }\n\n  context->parsing = TRUE;\n\n  switch (context->state)\n    {\n    case STATE_START:\n      /* Nothing to do */\n      break;\n\n    case STATE_AFTER_OPEN_ANGLE:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\"Document ended unexpectedly just after an open angle bracket \u201c<\u201d\"));\n      break;\n\n    case STATE_AFTER_CLOSE_ANGLE:\n      if (context->tag_stack != NULL)\n        {\n          /* Error message the same as for INSIDE_TEXT */\n          set_error (context, error, G_MARKUP_ERROR_PARSE,\n                     _(\"Document ended unexpectedly with elements still open \u2014 \"\n                       \"\u201c%s\u201d was the last element opened\"),\n                     current_element (context));\n        }\n      break;\n\n    case STATE_AFTER_ELISION_SLASH:\n      set_error (context, error, G_MARKUP_ERROR_PARSE,\n                 _(\"Document ended unexpectedly, expected to see a close angle \"\n                   \"bracket ending the tag <%s/>\"), current_element (context));\n      break;\n\n    case STATE_INSIDE_OPEN_TAG_NAME:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\"Document ended unexpectedly inside an element name\"));\n      break;\n\n    case STATE_INSIDE_ATTRIBUTE_NAME:\n    case STATE_AFTER_ATTRIBUTE_NAME:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\"Document ended unexpectedly inside an attribute name\"));\n      break;\n\n    case STATE_BETWEEN_ATTRIBUTES:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\"Document ended unexpectedly inside an element-opening \"\n                           \"tag.\"));\n      break;\n\n    case STATE_AFTER_ATTRIBUTE_EQUALS_SIGN:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\"Document ended unexpectedly after the equals sign \"\n                           \"following an attribute name; no attribute value\"));\n      break;\n\n    case STATE_INSIDE_ATTRIBUTE_VALUE_SQ:\n    case STATE_INSIDE_ATTRIBUTE_VALUE_DQ:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\"Document ended unexpectedly while inside an attribute \"\n                           \"value\"));\n      break;\n\n    case STATE_INSIDE_TEXT:\n      g_assert (context->tag_stack != NULL);\n      set_error (context, error, G_MARKUP_ERROR_PARSE,\n                 _(\"Document ended unexpectedly with elements still open \u2014 \"\n                   \"\u201c%s\u201d was the last element opened\"),\n                 current_element (context));\n      break;\n\n    case STATE_AFTER_CLOSE_TAG_SLASH:\n    case STATE_INSIDE_CLOSE_TAG_NAME:\n    case STATE_AFTER_CLOSE_TAG_NAME:\n      if (context->tag_stack != NULL)\n        set_error (context, error, G_MARKUP_ERROR_PARSE,\n                   _(\"Document ended unexpectedly inside the close tag for \"\n                     \"element \u201c%s\u201d\"), current_element (context));\n      else\n        set_error (context, error, G_MARKUP_ERROR_PARSE,\n                   _(\"Document ended unexpectedly inside the close tag for an \"\n                     \"unopened element\"));\n      break;\n\n    case STATE_INSIDE_PASSTHROUGH:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\"Document ended unexpectedly inside a comment or \"\n                           \"processing instruction\"));\n      break;\n\n    case STATE_ERROR:\n    default:\n      g_assert_not_reached ();\n      break;\n    }\n\n  context->parsing = FALSE;\n\n  return context->state != STATE_ERROR;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147063,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void JBIG2Stream::readTextRegionSeg(unsigned int segNum, bool imm, bool lossless, unsigned int length, unsigned int *refSegs, unsigned int nRefSegs)\n{\n    std::unique_ptr<JBIG2Bitmap> bitmap;\n    JBIG2HuffmanTable runLengthTab[36];\n    JBIG2HuffmanTable *symCodeTab = nullptr;\n    const JBIG2HuffmanTable *huffFSTable, *huffDSTable, *huffDTTable;\n    const JBIG2HuffmanTable *huffRDWTable, *huffRDHTable;\n    const JBIG2HuffmanTable *huffRDXTable, *huffRDYTable, *huffRSizeTable;\n    JBIG2Segment *seg;\n    std::vector<JBIG2Segment *> codeTables;\n    JBIG2SymbolDict *symbolDict;\n    JBIG2Bitmap **syms;\n    unsigned int w, h, x, y, segInfoFlags, extCombOp;\n    unsigned int flags, huff, refine, logStrips, refCorner, transposed;\n    unsigned int combOp, defPixel, templ;\n    int sOffset;\n    unsigned int huffFlags, huffFS, huffDS, huffDT;\n    unsigned int huffRDW, huffRDH, huffRDX, huffRDY, huffRSize;\n    unsigned int numInstances, numSyms, symCodeLen;\n    int atx[2], aty[2];\n    unsigned int i, k, kk;\n    int j = 0;\n\n    // region segment info field\n    if (!readULong(&w) || !readULong(&h) || !readULong(&x) || !readULong(&y) || !readUByte(&segInfoFlags)) {\n        goto eofError;\n    }\n    extCombOp = segInfoFlags & 7;\n\n    // rest of the text region header\n    if (!readUWord(&flags)) {\n        goto eofError;\n    }\n    huff = flags & 1;\n    refine = (flags >> 1) & 1;\n    logStrips = (flags >> 2) & 3;\n    refCorner = (flags >> 4) & 3;\n    transposed = (flags >> 6) & 1;\n    combOp = (flags >> 7) & 3;\n    defPixel = (flags >> 9) & 1;\n    sOffset = (flags >> 10) & 0x1f;\n    if (sOffset & 0x10) {\n        sOffset |= -1 - 0x0f;\n    }\n    templ = (flags >> 15) & 1;\n    huffFS = huffDS = huffDT = 0; // make gcc happy\n    huffRDW = huffRDH = huffRDX = huffRDY = huffRSize = 0; // make gcc happy\n    if (huff) {\n        if (!readUWord(&huffFlags)) {\n            goto eofError;\n        }\n        huffFS = huffFlags & 3;\n        huffDS = (huffFlags >> 2) & 3;\n        huffDT = (huffFlags >> 4) & 3;\n        huffRDW = (huffFlags >> 6) & 3;\n        huffRDH = (huffFlags >> 8) & 3;\n        huffRDX = (huffFlags >> 10) & 3;\n        huffRDY = (huffFlags >> 12) & 3;\n        huffRSize = (huffFlags >> 14) & 1;\n    }\n    if (refine && templ == 0) {\n        if (!readByte(&atx[0]) || !readByte(&aty[0]) || !readByte(&atx[1]) || !readByte(&aty[1])) {\n            goto eofError;\n        }\n    }\n    if (!readULong(&numInstances)) {\n        goto eofError;\n    }\n\n    // get symbol dictionaries and tables\n    numSyms = 0;\n    for (i = 0; i < nRefSegs; ++i) {\n        if ((seg = findSegment(refSegs[i]))) {\n            if (seg->getType() == jbig2SegSymbolDict) {\n                numSyms += ((JBIG2SymbolDict *)seg)->getSize();\n            } else if (seg->getType() == jbig2SegCodeTable) {\n                codeTables.push_back(seg);\n            }\n        } else {\n            error(errSyntaxError, curStr->getPos(), \"Invalid segment reference in JBIG2 text region\");\n            return;\n        }\n    }\n    i = numSyms;\n    if (i <= 1) {\n        symCodeLen = huff ? 1 : 0;\n    } else {\n        --i;\n        symCodeLen = 0;\n        // i = floor((numSyms-1) / 2^symCodeLen)\n        while (i > 0) {\n            ++symCodeLen;\n            i >>= 1;\n        }\n    }\n\n    // get the symbol bitmaps\n    syms = (JBIG2Bitmap **)gmallocn_checkoverflow(numSyms, sizeof(JBIG2Bitmap *));\n    if (numSyms > 0 && !syms) {\n        return;\n    }\n    kk = 0;\n    for (i = 0; i < nRefSegs; ++i) {\n        if ((seg = findSegment(refSegs[i]))) {\n            if (seg->getType() == jbig2SegSymbolDict) {\n                symbolDict = (JBIG2SymbolDict *)seg;\n                for (k = 0; k < symbolDict->getSize(); ++k) {\n                    syms[kk++] = symbolDict->getBitmap(k);\n                }\n            }\n        }\n    }\n\n    // get the Huffman tables\n    huffFSTable = huffDSTable = huffDTTable = nullptr; // make gcc happy\n    huffRDWTable = huffRDHTable = nullptr; // make gcc happy\n    huffRDXTable = huffRDYTable = huffRSizeTable = nullptr; // make gcc happy\n    i = 0;\n    if (huff) {\n        if (huffFS == 0) {\n            huffFSTable = huffTableF;\n        } else if (huffFS == 1) {\n            huffFSTable = huffTableG;\n        } else {\n            if (i >= codeTables.size()) {\n                goto codeTableError;\n            }\n            huffFSTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable();\n        }\n        if (huffDS == 0) {\n            huffDSTable = huffTableH;\n        } else if (huffDS == 1) {\n            huffDSTable = huffTableI;\n        } else if (huffDS == 2) {\n            huffDSTable = huffTableJ;\n        } else {\n            if (i >= codeTables.size()) {\n                goto codeTableError;\n            }\n            huffDSTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable();\n        }\n        if (huffDT == 0) {\n            huffDTTable = huffTableK;\n        } else if (huffDT == 1) {\n            huffDTTable = huffTableL;\n        } else if (huffDT == 2) {\n            huffDTTable = huffTableM;\n        } else {\n            if (i >= codeTables.size()) {\n                goto codeTableError;\n            }\n            huffDTTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable();\n        }\n        if (huffRDW == 0) {\n            huffRDWTable = huffTableN;\n        } else if (huffRDW == 1) {\n            huffRDWTable = huffTableO;\n        } else {\n            if (i >= codeTables.size()) {\n                goto codeTableError;\n            }\n            huffRDWTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable();\n        }\n        if (huffRDH == 0) {\n            huffRDHTable = huffTableN;\n        } else if (huffRDH == 1) {\n            huffRDHTable = huffTableO;\n        } else {\n            if (i >= codeTables.size()) {\n                goto codeTableError;\n            }\n            huffRDHTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable();\n        }\n        if (huffRDX == 0) {\n            huffRDXTable = huffTableN;\n        } else if (huffRDX == 1) {\n            huffRDXTable = huffTableO;\n        } else {\n            if (i >= codeTables.size()) {\n                goto codeTableError;\n            }\n            huffRDXTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable();\n        }\n        if (huffRDY == 0) {\n            huffRDYTable = huffTableN;\n        } else if (huffRDY == 1) {\n            huffRDYTable = huffTableO;\n        } else {\n            if (i >= codeTables.size()) {\n                goto codeTableError;\n            }\n            huffRDYTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable();\n        }\n        if (huffRSize == 0) {\n            huffRSizeTable = huffTableA;\n        } else {\n            if (i >= codeTables.size()) {\n                goto codeTableError;\n            }\n            huffRSizeTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable();\n        }\n    }\n\n    // symbol ID Huffman decoding table\n    if (huff) {\n        huffDecoder->reset();\n        for (i = 0; i < 32; ++i) {\n            runLengthTab[i].val = i;\n            runLengthTab[i].prefixLen = huffDecoder->readBits(4);\n            runLengthTab[i].rangeLen = 0;\n        }\n        runLengthTab[32].val = 0x103;\n        runLengthTab[32].prefixLen = huffDecoder->readBits(4);\n        runLengthTab[32].rangeLen = 2;\n        runLengthTab[33].val = 0x203;\n        runLengthTab[33].prefixLen = huffDecoder->readBits(4);\n        runLengthTab[33].rangeLen = 3;\n        runLengthTab[34].val = 0x20b;\n        runLengthTab[34].prefixLen = huffDecoder->readBits(4);\n        runLengthTab[34].rangeLen = 7;\n        runLengthTab[35].prefixLen = 0;\n        runLengthTab[35].rangeLen = jbig2HuffmanEOT;\n        if (!JBIG2HuffmanDecoder::buildTable(runLengthTab, 35)) {\n            huff = false;\n        }\n    }\n\n    if (huff) {\n        symCodeTab = (JBIG2HuffmanTable *)gmallocn_checkoverflow(numSyms + 1, sizeof(JBIG2HuffmanTable));\n        if (!symCodeTab) {\n            gfree(syms);\n            return;\n        }\n        for (i = 0; i < numSyms; ++i) {\n            symCodeTab[i].val = i;\n            symCodeTab[i].rangeLen = 0;\n        }\n        i = 0;\n        while (i < numSyms) {\n            huffDecoder->decodeInt(&j, runLengthTab);\n            if (j > 0x200) {\n                for (j -= 0x200; j && i < numSyms; --j) {\n                    symCodeTab[i++].prefixLen = 0;\n                }\n            } else if (j > 0x100) {\n                if (unlikely(i == 0)) {\n                    symCodeTab[i].prefixLen = 0;\n                    ++i;\n                }\n                for (j -= 0x100; j && i < numSyms; --j) {\n                    symCodeTab[i].prefixLen = symCodeTab[i - 1].prefixLen;\n                    ++i;\n                }\n            } else {\n                symCodeTab[i++].prefixLen = j;\n            }\n        }\n        symCodeTab[numSyms].prefixLen = 0;\n        symCodeTab[numSyms].rangeLen = jbig2HuffmanEOT;\n        if (!JBIG2HuffmanDecoder::buildTable(symCodeTab, numSyms)) {\n            huff = false;\n            gfree(symCodeTab);\n            symCodeTab = nullptr;\n        }\n        huffDecoder->reset();\n\n        // set up the arithmetic decoder\n    }\n\n    if (!huff) {\n        if (!resetIntStats(symCodeLen)) {\n            gfree(syms);\n            return;\n        }\n        arithDecoder->start();\n    }\n    if (refine) {\n        resetRefinementStats(templ, nullptr);\n    }\n\n    bitmap = readTextRegion(huff, refine, w, h, numInstances, logStrips, numSyms, symCodeTab, symCodeLen, syms, defPixel, combOp, transposed, refCorner, sOffset, huffFSTable, huffDSTable, huffDTTable, huffRDWTable, huffRDHTable,\n                            huffRDXTable, huffRDYTable, huffRSizeTable, templ, atx, aty);\n\n    gfree(syms);\n\n    if (bitmap) {\n        // combine the region bitmap into the page bitmap\n        if (imm) {\n            if (pageH == 0xffffffff && y + h > curPageH) {\n                pageBitmap->expand(y + h, pageDefPixel);\n            }\n            if (pageBitmap->isOk()) {\n                pageBitmap->combine(bitmap.get(), x, y, extCombOp);\n            }\n\n            // store the region bitmap\n        } else {\n            bitmap->setSegNum(segNum);\n            segments.push_back(std::move(bitmap));\n        }\n    }\n\n    // clean up the Huffman decoder\n    if (huff) {\n        gfree(symCodeTab);\n    }\n\n    return;\n\ncodeTableError:\n    error(errSyntaxError, curStr->getPos(), \"Missing code table in JBIG2 text region\");\n    gfree(syms);\n    return;\n\neofError:\n    error(errSyntaxError, curStr->getPos(), \"Unexpected EOF in JBIG2 stream\");\n    return;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147078,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void JBIG2Stream::readTextRegionSeg(unsigned int segNum, bool imm, bool lossless, unsigned int length, unsigned int *refSegs, unsigned int nRefSegs)\n{\n    std::unique_ptr<JBIG2Bitmap> bitmap;\n    JBIG2HuffmanTable runLengthTab[36];\n    JBIG2HuffmanTable *symCodeTab = nullptr;\n    const JBIG2HuffmanTable *huffFSTable, *huffDSTable, *huffDTTable;\n    const JBIG2HuffmanTable *huffRDWTable, *huffRDHTable;\n    const JBIG2HuffmanTable *huffRDXTable, *huffRDYTable, *huffRSizeTable;\n    JBIG2Segment *seg;\n    std::vector<JBIG2Segment *> codeTables;\n    JBIG2SymbolDict *symbolDict;\n    JBIG2Bitmap **syms;\n    unsigned int w, h, x, y, segInfoFlags, extCombOp;\n    unsigned int flags, huff, refine, logStrips, refCorner, transposed;\n    unsigned int combOp, defPixel, templ;\n    int sOffset;\n    unsigned int huffFlags, huffFS, huffDS, huffDT;\n    unsigned int huffRDW, huffRDH, huffRDX, huffRDY, huffRSize;\n    unsigned int numInstances, numSyms, symCodeLen;\n    int atx[2], aty[2];\n    unsigned int i, k, kk;\n    int j = 0;\n\n    // region segment info field\n    if (!readULong(&w) || !readULong(&h) || !readULong(&x) || !readULong(&y) || !readUByte(&segInfoFlags)) {\n        goto eofError;\n    }\n    extCombOp = segInfoFlags & 7;\n\n    // rest of the text region header\n    if (!readUWord(&flags)) {\n        goto eofError;\n    }\n    huff = flags & 1;\n    refine = (flags >> 1) & 1;\n    logStrips = (flags >> 2) & 3;\n    refCorner = (flags >> 4) & 3;\n    transposed = (flags >> 6) & 1;\n    combOp = (flags >> 7) & 3;\n    defPixel = (flags >> 9) & 1;\n    sOffset = (flags >> 10) & 0x1f;\n    if (sOffset & 0x10) {\n        sOffset |= -1 - 0x0f;\n    }\n    templ = (flags >> 15) & 1;\n    huffFS = huffDS = huffDT = 0; // make gcc happy\n    huffRDW = huffRDH = huffRDX = huffRDY = huffRSize = 0; // make gcc happy\n    if (huff) {\n        if (!readUWord(&huffFlags)) {\n            goto eofError;\n        }\n        huffFS = huffFlags & 3;\n        huffDS = (huffFlags >> 2) & 3;\n        huffDT = (huffFlags >> 4) & 3;\n        huffRDW = (huffFlags >> 6) & 3;\n        huffRDH = (huffFlags >> 8) & 3;\n        huffRDX = (huffFlags >> 10) & 3;\n        huffRDY = (huffFlags >> 12) & 3;\n        huffRSize = (huffFlags >> 14) & 1;\n    }\n    if (refine && templ == 0) {\n        if (!readByte(&atx[0]) || !readByte(&aty[0]) || !readByte(&atx[1]) || !readByte(&aty[1])) {\n            goto eofError;\n        }\n    }\n    if (!readULong(&numInstances)) {\n        goto eofError;\n    }\n\n    // get symbol dictionaries and tables\n    numSyms = 0;\n    for (i = 0; i < nRefSegs; ++i) {\n        if ((seg = findSegment(refSegs[i]))) {\n            if (seg->getType() == jbig2SegSymbolDict) {\n                const unsigned int segSize = ((JBIG2SymbolDict *)seg)->getSize();\n                if (unlikely(checkedAdd(numSyms, segSize, &numSyms))) {\n                    error(errSyntaxError, getPos(), \"Too many symbols in JBIG2 text region\");\n                    return;\n                }\n            } else if (seg->getType() == jbig2SegCodeTable) {\n                codeTables.push_back(seg);\n            }\n        } else {\n            error(errSyntaxError, curStr->getPos(), \"Invalid segment reference in JBIG2 text region\");\n            return;\n        }\n    }\n    i = numSyms;\n    if (i <= 1) {\n        symCodeLen = huff ? 1 : 0;\n    } else {\n        --i;\n        symCodeLen = 0;\n        // i = floor((numSyms-1) / 2^symCodeLen)\n        while (i > 0) {\n            ++symCodeLen;\n            i >>= 1;\n        }\n    }\n\n    // get the symbol bitmaps\n    syms = (JBIG2Bitmap **)gmallocn_checkoverflow(numSyms, sizeof(JBIG2Bitmap *));\n    if (numSyms > 0 && !syms) {\n        return;\n    }\n    kk = 0;\n    for (i = 0; i < nRefSegs; ++i) {\n        if ((seg = findSegment(refSegs[i]))) {\n            if (seg->getType() == jbig2SegSymbolDict) {\n                symbolDict = (JBIG2SymbolDict *)seg;\n                for (k = 0; k < symbolDict->getSize(); ++k) {\n                    syms[kk++] = symbolDict->getBitmap(k);\n                }\n            }\n        }\n    }\n\n    // get the Huffman tables\n    huffFSTable = huffDSTable = huffDTTable = nullptr; // make gcc happy\n    huffRDWTable = huffRDHTable = nullptr; // make gcc happy\n    huffRDXTable = huffRDYTable = huffRSizeTable = nullptr; // make gcc happy\n    i = 0;\n    if (huff) {\n        if (huffFS == 0) {\n            huffFSTable = huffTableF;\n        } else if (huffFS == 1) {\n            huffFSTable = huffTableG;\n        } else {\n            if (i >= codeTables.size()) {\n                goto codeTableError;\n            }\n            huffFSTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable();\n        }\n        if (huffDS == 0) {\n            huffDSTable = huffTableH;\n        } else if (huffDS == 1) {\n            huffDSTable = huffTableI;\n        } else if (huffDS == 2) {\n            huffDSTable = huffTableJ;\n        } else {\n            if (i >= codeTables.size()) {\n                goto codeTableError;\n            }\n            huffDSTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable();\n        }\n        if (huffDT == 0) {\n            huffDTTable = huffTableK;\n        } else if (huffDT == 1) {\n            huffDTTable = huffTableL;\n        } else if (huffDT == 2) {\n            huffDTTable = huffTableM;\n        } else {\n            if (i >= codeTables.size()) {\n                goto codeTableError;\n            }\n            huffDTTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable();\n        }\n        if (huffRDW == 0) {\n            huffRDWTable = huffTableN;\n        } else if (huffRDW == 1) {\n            huffRDWTable = huffTableO;\n        } else {\n            if (i >= codeTables.size()) {\n                goto codeTableError;\n            }\n            huffRDWTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable();\n        }\n        if (huffRDH == 0) {\n            huffRDHTable = huffTableN;\n        } else if (huffRDH == 1) {\n            huffRDHTable = huffTableO;\n        } else {\n            if (i >= codeTables.size()) {\n                goto codeTableError;\n            }\n            huffRDHTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable();\n        }\n        if (huffRDX == 0) {\n            huffRDXTable = huffTableN;\n        } else if (huffRDX == 1) {\n            huffRDXTable = huffTableO;\n        } else {\n            if (i >= codeTables.size()) {\n                goto codeTableError;\n            }\n            huffRDXTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable();\n        }\n        if (huffRDY == 0) {\n            huffRDYTable = huffTableN;\n        } else if (huffRDY == 1) {\n            huffRDYTable = huffTableO;\n        } else {\n            if (i >= codeTables.size()) {\n                goto codeTableError;\n            }\n            huffRDYTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable();\n        }\n        if (huffRSize == 0) {\n            huffRSizeTable = huffTableA;\n        } else {\n            if (i >= codeTables.size()) {\n                goto codeTableError;\n            }\n            huffRSizeTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable();\n        }\n    }\n\n    // symbol ID Huffman decoding table\n    if (huff) {\n        huffDecoder->reset();\n        for (i = 0; i < 32; ++i) {\n            runLengthTab[i].val = i;\n            runLengthTab[i].prefixLen = huffDecoder->readBits(4);\n            runLengthTab[i].rangeLen = 0;\n        }\n        runLengthTab[32].val = 0x103;\n        runLengthTab[32].prefixLen = huffDecoder->readBits(4);\n        runLengthTab[32].rangeLen = 2;\n        runLengthTab[33].val = 0x203;\n        runLengthTab[33].prefixLen = huffDecoder->readBits(4);\n        runLengthTab[33].rangeLen = 3;\n        runLengthTab[34].val = 0x20b;\n        runLengthTab[34].prefixLen = huffDecoder->readBits(4);\n        runLengthTab[34].rangeLen = 7;\n        runLengthTab[35].prefixLen = 0;\n        runLengthTab[35].rangeLen = jbig2HuffmanEOT;\n        if (!JBIG2HuffmanDecoder::buildTable(runLengthTab, 35)) {\n            huff = false;\n        }\n    }\n\n    if (huff) {\n        symCodeTab = (JBIG2HuffmanTable *)gmallocn_checkoverflow(numSyms + 1, sizeof(JBIG2HuffmanTable));\n        if (!symCodeTab) {\n            gfree(syms);\n            return;\n        }\n        for (i = 0; i < numSyms; ++i) {\n            symCodeTab[i].val = i;\n            symCodeTab[i].rangeLen = 0;\n        }\n        i = 0;\n        while (i < numSyms) {\n            huffDecoder->decodeInt(&j, runLengthTab);\n            if (j > 0x200) {\n                for (j -= 0x200; j && i < numSyms; --j) {\n                    symCodeTab[i++].prefixLen = 0;\n                }\n            } else if (j > 0x100) {\n                if (unlikely(i == 0)) {\n                    symCodeTab[i].prefixLen = 0;\n                    ++i;\n                }\n                for (j -= 0x100; j && i < numSyms; --j) {\n                    symCodeTab[i].prefixLen = symCodeTab[i - 1].prefixLen;\n                    ++i;\n                }\n            } else {\n                symCodeTab[i++].prefixLen = j;\n            }\n        }\n        symCodeTab[numSyms].prefixLen = 0;\n        symCodeTab[numSyms].rangeLen = jbig2HuffmanEOT;\n        if (!JBIG2HuffmanDecoder::buildTable(symCodeTab, numSyms)) {\n            huff = false;\n            gfree(symCodeTab);\n            symCodeTab = nullptr;\n        }\n        huffDecoder->reset();\n\n        // set up the arithmetic decoder\n    }\n\n    if (!huff) {\n        if (!resetIntStats(symCodeLen)) {\n            gfree(syms);\n            return;\n        }\n        arithDecoder->start();\n    }\n    if (refine) {\n        resetRefinementStats(templ, nullptr);\n    }\n\n    bitmap = readTextRegion(huff, refine, w, h, numInstances, logStrips, numSyms, symCodeTab, symCodeLen, syms, defPixel, combOp, transposed, refCorner, sOffset, huffFSTable, huffDSTable, huffDTTable, huffRDWTable, huffRDHTable,\n                            huffRDXTable, huffRDYTable, huffRSizeTable, templ, atx, aty);\n\n    gfree(syms);\n\n    if (bitmap) {\n        // combine the region bitmap into the page bitmap\n        if (imm) {\n            if (pageH == 0xffffffff && y + h > curPageH) {\n                pageBitmap->expand(y + h, pageDefPixel);\n            }\n            if (pageBitmap->isOk()) {\n                pageBitmap->combine(bitmap.get(), x, y, extCombOp);\n            }\n\n            // store the region bitmap\n        } else {\n            bitmap->setSegNum(segNum);\n            segments.push_back(std::move(bitmap));\n        }\n    }\n\n    // clean up the Huffman decoder\n    if (huff) {\n        gfree(symCodeTab);\n    }\n\n    return;\n\ncodeTableError:\n    error(errSyntaxError, curStr->getPos(), \"Missing code table in JBIG2 text region\");\n    gfree(syms);\n    return;\n\neofError:\n    error(errSyntaxError, curStr->getPos(), \"Unexpected EOF in JBIG2 stream\");\n    return;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147079,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "DwaCompressor::uncompress\n    (const char *inPtr,\n     int inSize,\n     IMATH_NAMESPACE::Box2i range,\n     const char *&outPtr)\n{\n    int minX = range.min.x;\n    int maxX = std::min (range.max.x, _max[0]);\n    int minY = range.min.y;\n    int maxY = std::min (range.max.y, _max[1]);\n\n    Int64 iSize = static_cast<Int64>( inSize );\n    Int64 headerSize = NUM_SIZES_SINGLE*sizeof(Int64);\n    if (iSize < headerSize) \n    {\n        throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                            \"(truncated header).\");\n    }\n\n    // \n    // Flip the counters from XDR to NATIVE\n    //\n\n    for (int i = 0; i < NUM_SIZES_SINGLE; ++i)\n    {\n        Int64      *dst =  (((Int64 *)inPtr) + i);\n        const char *src = (char *)(((Int64 *)inPtr) + i);\n\n        Xdr::read<CharPtrIO> (src, *dst);\n    }\n\n    //\n    // Unwind all the counter info\n    //\n\n    const Int64 *inPtr64 = (const Int64*) inPtr;\n\n    Int64 version                  = *(inPtr64 + VERSION);\n    Int64 unknownUncompressedSize  = *(inPtr64 + UNKNOWN_UNCOMPRESSED_SIZE);\n    Int64 unknownCompressedSize    = *(inPtr64 + UNKNOWN_COMPRESSED_SIZE);\n    Int64 acCompressedSize         = *(inPtr64 + AC_COMPRESSED_SIZE);\n    Int64 dcCompressedSize         = *(inPtr64 + DC_COMPRESSED_SIZE);\n    Int64 rleCompressedSize        = *(inPtr64 + RLE_COMPRESSED_SIZE);\n    Int64 rleUncompressedSize      = *(inPtr64 + RLE_UNCOMPRESSED_SIZE);\n    Int64 rleRawSize               = *(inPtr64 + RLE_RAW_SIZE);\n \n    Int64 totalAcUncompressedCount = *(inPtr64 + AC_UNCOMPRESSED_COUNT); \n    Int64 totalDcUncompressedCount = *(inPtr64 + DC_UNCOMPRESSED_COUNT); \n\n    Int64 acCompression            = *(inPtr64 + AC_COMPRESSION); \n\n    Int64 compressedSize           = unknownCompressedSize + \n                                     acCompressedSize +\n                                     dcCompressedSize +\n                                     rleCompressedSize;\n\n    const char *dataPtr            = inPtr + NUM_SIZES_SINGLE * sizeof(Int64);\n\n    /* Both the sum and individual sizes are checked in case of overflow. */\n    if (iSize < (headerSize + compressedSize) ||\n        iSize < unknownCompressedSize ||\n        iSize < acCompressedSize ||\n        iSize < dcCompressedSize ||\n        iSize < rleCompressedSize)\n    {\n        throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                            \"(truncated file).\");\n    }\n\n    if ((SInt64)unknownUncompressedSize < 0  ||\n        (SInt64)unknownCompressedSize < 0    ||\n        (SInt64)acCompressedSize < 0         ||\n        (SInt64)dcCompressedSize < 0         ||\n        (SInt64)rleCompressedSize < 0        ||\n        (SInt64)rleUncompressedSize < 0      ||\n        (SInt64)rleRawSize < 0               ||\n        (SInt64)totalAcUncompressedCount < 0 ||\n        (SInt64)totalDcUncompressedCount < 0)\n    {\n        throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                            \" (corrupt header).\");\n    }\n\n    if (version < 2) \n        initializeLegacyChannelRules();\n    else\n    {\n        unsigned short ruleSize = 0;\n        Xdr::read<CharPtrIO>(dataPtr, ruleSize);\n\n        if (ruleSize < Xdr::size<unsigned short>() ) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt header file).\");\n\n        headerSize += ruleSize;\n        if (iSize < headerSize + compressedSize)\n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (truncated file).\");\n\n        _channelRules.clear();\n        ruleSize -= Xdr::size<unsigned short> ();\n        while (ruleSize > 0) \n        {\n            Classifier rule(dataPtr, ruleSize);\n            \n            _channelRules.push_back(rule);\n            ruleSize -= rule.size();\n        }\n    }\n\n\n    size_t outBufferSize = 0;\n    initializeBuffers(outBufferSize);\n\n    //\n    // Allocate _outBuffer, if we haven't done so already\n    //\n\n    if (static_cast<size_t>(_maxScanLineSize * numScanLines()) > _outBufferSize) \n    {\n        _outBufferSize = static_cast<size_t>(_maxScanLineSize * numScanLines());\n        if (_outBuffer != 0)\n            delete[] _outBuffer;\n        _outBuffer = new char[_maxScanLineSize * numScanLines()];\n    }\n\n\n    char *outBufferEnd = _outBuffer;\n\n       \n    //\n    // Find the start of the RLE packed AC components and\n    // the DC components for each channel. This will be handy   \n    // if you want to decode the channels in parallel later on.\n    //\n\n    char *packedAcBufferEnd = 0; \n\n    if (_packedAcBuffer)\n        packedAcBufferEnd = _packedAcBuffer;\n\n    char *packedDcBufferEnd = 0;\n\n    if (_packedDcBuffer)\n        packedDcBufferEnd = _packedDcBuffer;\n\n    //\n    // UNKNOWN data is packed first, followed by the \n    // Huffman-compressed AC, then the DC values, \n    // and then the zlib compressed RLE data.\n    //\n    \n    const char *compressedUnknownBuf = dataPtr;\n\n    const char *compressedAcBuf      = compressedUnknownBuf + \n                                  static_cast<ptrdiff_t>(unknownCompressedSize);\n    const char *compressedDcBuf      = compressedAcBuf +\n                                  static_cast<ptrdiff_t>(acCompressedSize);\n    const char *compressedRleBuf     = compressedDcBuf + \n                                  static_cast<ptrdiff_t>(dcCompressedSize);\n\n    // \n    // Sanity check that the version is something we expect. Right now, \n    // we can decode version 0, 1, and 2. v1 adds 'end of block' symbols\n    // to the AC RLE. v2 adds channel classification rules at the \n    // start of the data block.\n    //\n\n    if (version > 2)\n        throw IEX_NAMESPACE::InputExc (\"Invalid version of compressed data block\");    \n\n    setupChannelData(minX, minY, maxX, maxY);\n\n    // \n    // Uncompress the UNKNOWN data into _planarUncBuffer[UNKNOWN]\n    //\n\n    if (unknownCompressedSize > 0)\n    {\n        if (unknownUncompressedSize > _planarUncBufferSize[UNKNOWN]) \n        {\n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \"(corrupt header).\");\n        }\n\n        uLongf outSize = (uLongf)unknownUncompressedSize;\n\n        if (Z_OK != ::uncompress\n                        ((Bytef *)_planarUncBuffer[UNKNOWN],\n                         &outSize,\n                         (Bytef *)compressedUnknownBuf,\n                         (uLong)unknownCompressedSize))\n        {\n            throw IEX_NAMESPACE::BaseExc(\"Error uncompressing UNKNOWN data.\");\n        }\n    }\n\n    // \n    // Uncompress the AC data into _packedAcBuffer\n    //\n\n    if (acCompressedSize > 0)\n    {\n        if (totalAcUncompressedCount*sizeof(unsigned short) > _packedAcBufferSize)\n        {\n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \"(corrupt header).\");\n        }\n\n        //\n        // Don't trust the user to get it right, look in the file.\n        //\n\n        switch (acCompression)\n        {\n          case STATIC_HUFFMAN:\n\n            hufUncompress\n                (compressedAcBuf, \n                 (int)acCompressedSize, \n                 (unsigned short *)_packedAcBuffer, \n                 (int)totalAcUncompressedCount); \n\n            break;\n\n          case DEFLATE:\n            {\n                uLongf destLen =\n                    (int)(totalAcUncompressedCount) * sizeof (unsigned short);\n\n                if (Z_OK != ::uncompress\n                                ((Bytef *)_packedAcBuffer,\n                                 &destLen,\n                                 (Bytef *)compressedAcBuf,\n                                 (uLong)acCompressedSize))\n                {\n                    throw IEX_NAMESPACE::InputExc (\"Data decompression (zlib) failed.\");\n                }\n\n                if (totalAcUncompressedCount * sizeof (unsigned short) !=\n                                destLen)\n                {\n                    throw IEX_NAMESPACE::InputExc (\"AC data corrupt.\");     \n                }\n            }\n            break;\n\n          default:\n\n            throw IEX_NAMESPACE::NoImplExc (\"Unknown AC Compression\");\n            break;\n        }\n    }\n\n    //\n    // Uncompress the DC data into _packedDcBuffer\n    //\n\n    if (dcCompressedSize > 0)\n    {\n        if (totalDcUncompressedCount*sizeof(unsigned short) > _packedDcBufferSize)\n        {\n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \"(corrupt header).\");\n        }\n\n        if (static_cast<Int64>(_zip->uncompress\n                    (compressedDcBuf, (int)dcCompressedSize, _packedDcBuffer))\n            != totalDcUncompressedCount * sizeof (unsigned short))\n        {\n            throw IEX_NAMESPACE::BaseExc(\"DC data corrupt.\");\n        }\n    }\n\n    //\n    // Uncompress the RLE data into _rleBuffer, then unRLE the results\n    // into _planarUncBuffer[RLE]\n    //\n\n    if (rleRawSize > 0)\n    {\n        if (rleUncompressedSize > _rleBufferSize ||\n            rleRawSize > _planarUncBufferSize[RLE])\n        {\n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \"(corrupt header).\");\n        }\n \n        uLongf dstLen = (uLongf)rleUncompressedSize;\n\n        if (Z_OK != ::uncompress\n                        ((Bytef *)_rleBuffer,\n                         &dstLen,\n                         (Bytef *)compressedRleBuf,\n                         (uLong)rleCompressedSize))\n        {\n            throw IEX_NAMESPACE::BaseExc(\"Error uncompressing RLE data.\");\n        }\n\n        if (dstLen != rleUncompressedSize)\n            throw IEX_NAMESPACE::BaseExc(\"RLE data corrupted\");\n\n        if (static_cast<Int64>(rleUncompress\n                ((int)rleUncompressedSize, \n                 (int)rleRawSize,\n                 (signed char *)_rleBuffer,\n                 _planarUncBuffer[RLE])) != rleRawSize)\n        {        \n            throw IEX_NAMESPACE::BaseExc(\"RLE data corrupted\");\n        }\n    }\n\n    //\n    // Determine the start of each row in the output buffer\n    //\n\n    std::vector<bool> decodedChannels (_channelData.size());\n    std::vector< std::vector<char *> > rowPtrs (_channelData.size());\n\n    for (unsigned int chan = 0; chan < _channelData.size(); ++chan)\n        decodedChannels[chan] = false;\n\n    outBufferEnd = _outBuffer;\n\n    for (int y = minY; y <= maxY; ++y)\n    {\n        for (unsigned int chan = 0; chan < _channelData.size(); ++chan)\n        {\n            ChannelData *cd = &_channelData[chan];\n\n            if (IMATH_NAMESPACE::modp (y, cd->ySampling) != 0)\n                continue;\n\n            rowPtrs[chan].push_back (outBufferEnd);\n            outBufferEnd += cd->width * OPENEXR_IMF_NAMESPACE::pixelTypeSize (cd->type);\n        }\n    }\n\n    //\n    // Setup to decode each block of 3 channels that need to\n    // be handled together\n    //\n\n    for (unsigned int csc = 0; csc < _cscSets.size(); ++csc)\n    {\n        int rChan = _cscSets[csc].idx[0];    \n        int gChan = _cscSets[csc].idx[1];    \n        int bChan = _cscSets[csc].idx[2];    \n\n\n        LossyDctDecoderCsc decoder\n            (rowPtrs[rChan],\n             rowPtrs[gChan],\n             rowPtrs[bChan],\n             packedAcBufferEnd,\n             packedDcBufferEnd,\n             dwaCompressorToLinear,\n             _channelData[rChan].width,\n             _channelData[rChan].height,\n             _channelData[rChan].type,\n             _channelData[gChan].type,\n             _channelData[bChan].type);\n\n        decoder.execute();\n\n        packedAcBufferEnd +=\n            decoder.numAcValuesEncoded() * sizeof (unsigned short);\n\n        packedDcBufferEnd +=\n            decoder.numDcValuesEncoded() * sizeof (unsigned short);\n\n        decodedChannels[rChan] = true;\n        decodedChannels[gChan] = true;\n        decodedChannels[bChan] = true;\n    }\n\n    //\n    // Setup to handle the remaining channels by themselves\n    //\n\n    for (unsigned int chan = 0; chan < _channelData.size(); ++chan)\n    {\n        if (decodedChannels[chan])\n            continue;\n\n        ChannelData *cd = &_channelData[chan];\n        int pixelSize = OPENEXR_IMF_NAMESPACE::pixelTypeSize (cd->type);\n\n        switch (cd->compression)\n        {\n          case LOSSY_DCT:\n\n            //\n            // Setup a single-channel lossy DCT decoder pointing\n            // at the output buffer\n            //\n\n            {\n                const unsigned short *linearLut = 0;\n\n                if (!cd->pLinear)\n                    linearLut = dwaCompressorToLinear;\n\n                LossyDctDecoder decoder\n                    (rowPtrs[chan],\n                     packedAcBufferEnd,\n                     packedDcBufferEnd,\n                     linearLut,\n                     cd->width,\n                     cd->height,\n                     cd->type);\n\n                decoder.execute();   \n\n                packedAcBufferEnd += \n                    decoder.numAcValuesEncoded() * sizeof (unsigned short);\n\n                packedDcBufferEnd += \n                    decoder.numDcValuesEncoded() * sizeof (unsigned short);\n            }\n\n            break;\n\n          case RLE:\n\n            //\n            // For the RLE case, the data has been un-RLE'd into\n            // planarUncRleEnd[], but is still split out by bytes.\n            // We need to rearrange the bytes back into the correct\n            // order in the output buffer;\n            //\n\n            {\n                int row = 0;\n\n                for (int y = minY; y <= maxY; ++y)\n                {\n                    if (IMATH_NAMESPACE::modp (y, cd->ySampling) != 0)\n                        continue;\n\n                    char *dst = rowPtrs[chan][row];\n\n                    if (pixelSize == 2)\n                    {\n                        interleaveByte2 (dst, \n                                         cd->planarUncRleEnd[0],\n                                         cd->planarUncRleEnd[1],\n                                         cd->width);\n                                            \n                        cd->planarUncRleEnd[0] += cd->width;\n                        cd->planarUncRleEnd[1] += cd->width;\n                    }\n                    else\n                    {\n                        for (int x = 0; x < cd->width; ++x)\n                        {\n                            for (int byte = 0; byte < pixelSize; ++byte)\n                            {\n                               *dst++ = *cd->planarUncRleEnd[byte]++;\n                            }\n                        }\n                    }\n\n                    row++;\n                }\n            }\n\n            break;\n\n          case UNKNOWN:\n\n            //\n            // In the UNKNOWN case, data is already in planarUncBufferEnd\n            // and just needs to copied over to the output buffer\n            //\n\n            {\n                int row             = 0;\n                int dstScanlineSize = cd->width * OPENEXR_IMF_NAMESPACE::pixelTypeSize (cd->type);\n\n                for (int y = minY; y <= maxY; ++y)\n                {\n                    if (IMATH_NAMESPACE::modp (y, cd->ySampling) != 0)\n                        continue;\n\n                    //\n                    // sanity check for buffer data lying within range\n                    //\n                    if ((cd->planarUncBufferEnd + static_cast<size_t>(dstScanlineSize))  > (_planarUncBuffer[UNKNOWN] + _planarUncBufferSize[UNKNOWN]) )\n                    {\n                        throw Iex::InputExc(\"DWA data corrupt\");\n                    }\n\n                    memcpy (rowPtrs[chan][row],\n                            cd->planarUncBufferEnd,\n                            dstScanlineSize);\n\n                    cd->planarUncBufferEnd += dstScanlineSize;\n                    row++;\n                }\n            }\n\n            break;\n\n          default:\n\n            throw IEX_NAMESPACE::NoImplExc (\"Unhandled compression scheme case\");\n            break;\n        }\n\n        decodedChannels[chan] = true;\n    }\n\n    //\n    // Return a ptr to _outBuffer\n    //\n\n    outPtr = _outBuffer;\n    return (int)(outBufferEnd - _outBuffer);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147110,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "DwaCompressor::uncompress\n    (const char *inPtr,\n     int inSize,\n     IMATH_NAMESPACE::Box2i range,\n     const char *&outPtr)\n{\n    int minX = range.min.x;\n    int maxX = std::min (range.max.x, _max[0]);\n    int minY = range.min.y;\n    int maxY = std::min (range.max.y, _max[1]);\n\n    Int64 iSize = static_cast<Int64>( inSize );\n    Int64 headerSize = NUM_SIZES_SINGLE*sizeof(Int64);\n    if (iSize < headerSize) \n    {\n        throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                            \"(truncated header).\");\n    }\n\n    // \n    // Flip the counters from XDR to NATIVE\n    //\n\n    for (int i = 0; i < NUM_SIZES_SINGLE; ++i)\n    {\n        Int64      *dst =  (((Int64 *)inPtr) + i);\n        const char *src = (char *)(((Int64 *)inPtr) + i);\n\n        Xdr::read<CharPtrIO> (src, *dst);\n    }\n\n    //\n    // Unwind all the counter info\n    //\n\n    const Int64 *inPtr64 = (const Int64*) inPtr;\n\n    Int64 version                  = *(inPtr64 + VERSION);\n    Int64 unknownUncompressedSize  = *(inPtr64 + UNKNOWN_UNCOMPRESSED_SIZE);\n    Int64 unknownCompressedSize    = *(inPtr64 + UNKNOWN_COMPRESSED_SIZE);\n    Int64 acCompressedSize         = *(inPtr64 + AC_COMPRESSED_SIZE);\n    Int64 dcCompressedSize         = *(inPtr64 + DC_COMPRESSED_SIZE);\n    Int64 rleCompressedSize        = *(inPtr64 + RLE_COMPRESSED_SIZE);\n    Int64 rleUncompressedSize      = *(inPtr64 + RLE_UNCOMPRESSED_SIZE);\n    Int64 rleRawSize               = *(inPtr64 + RLE_RAW_SIZE);\n \n    Int64 totalAcUncompressedCount = *(inPtr64 + AC_UNCOMPRESSED_COUNT); \n    Int64 totalDcUncompressedCount = *(inPtr64 + DC_UNCOMPRESSED_COUNT); \n\n    Int64 acCompression            = *(inPtr64 + AC_COMPRESSION); \n\n    Int64 compressedSize           = unknownCompressedSize + \n                                     acCompressedSize +\n                                     dcCompressedSize +\n                                     rleCompressedSize;\n\n    const char *dataPtr            = inPtr + NUM_SIZES_SINGLE * sizeof(Int64);\n\n    /* Both the sum and individual sizes are checked in case of overflow. */\n    if (iSize < (headerSize + compressedSize) ||\n        iSize < unknownCompressedSize ||\n        iSize < acCompressedSize ||\n        iSize < dcCompressedSize ||\n        iSize < rleCompressedSize)\n    {\n        throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                            \"(truncated file).\");\n    }\n\n    if ((SInt64)unknownUncompressedSize < 0  ||\n        (SInt64)unknownCompressedSize < 0    ||\n        (SInt64)acCompressedSize < 0         ||\n        (SInt64)dcCompressedSize < 0         ||\n        (SInt64)rleCompressedSize < 0        ||\n        (SInt64)rleUncompressedSize < 0      ||\n        (SInt64)rleRawSize < 0               ||\n        (SInt64)totalAcUncompressedCount < 0 ||\n        (SInt64)totalDcUncompressedCount < 0)\n    {\n        throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                            \" (corrupt header).\");\n    }\n\n    if (version < 2) \n        initializeLegacyChannelRules();\n    else\n    {\n        unsigned short ruleSize = 0;\n        Xdr::read<CharPtrIO>(dataPtr, ruleSize);\n\n        if (ruleSize < Xdr::size<unsigned short>() ) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt header file).\");\n\n        headerSize += ruleSize;\n        if (iSize < headerSize + compressedSize)\n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (truncated file).\");\n\n        _channelRules.clear();\n        ruleSize -= Xdr::size<unsigned short> ();\n        while (ruleSize > 0) \n        {\n            Classifier rule(dataPtr, ruleSize);\n            \n            _channelRules.push_back(rule);\n            ruleSize -= rule.size();\n        }\n    }\n\n\n    size_t outBufferSize = 0;\n    initializeBuffers(outBufferSize);\n\n    //\n    // Allocate _outBuffer, if we haven't done so already\n    //\n\n    if (static_cast<size_t>(_maxScanLineSize * numScanLines()) > _outBufferSize) \n    {\n        _outBufferSize = static_cast<size_t>(_maxScanLineSize * numScanLines());\n        if (_outBuffer != 0)\n            delete[] _outBuffer;\n        _outBuffer = new char[_maxScanLineSize * numScanLines()];\n    }\n\n\n    char *outBufferEnd = _outBuffer;\n\n       \n    //\n    // Find the start of the RLE packed AC components and\n    // the DC components for each channel. This will be handy   \n    // if you want to decode the channels in parallel later on.\n    //\n\n    char *packedAcBufferEnd = 0; \n\n    if (_packedAcBuffer)\n        packedAcBufferEnd = _packedAcBuffer;\n\n    char *packedDcBufferEnd = 0;\n\n    if (_packedDcBuffer)\n        packedDcBufferEnd = _packedDcBuffer;\n\n    //\n    // UNKNOWN data is packed first, followed by the \n    // Huffman-compressed AC, then the DC values, \n    // and then the zlib compressed RLE data.\n    //\n    \n    const char *compressedUnknownBuf = dataPtr;\n\n    const char *compressedAcBuf      = compressedUnknownBuf + \n                                  static_cast<ptrdiff_t>(unknownCompressedSize);\n    const char *compressedDcBuf      = compressedAcBuf +\n                                  static_cast<ptrdiff_t>(acCompressedSize);\n    const char *compressedRleBuf     = compressedDcBuf + \n                                  static_cast<ptrdiff_t>(dcCompressedSize);\n\n    // \n    // Sanity check that the version is something we expect. Right now, \n    // we can decode version 0, 1, and 2. v1 adds 'end of block' symbols\n    // to the AC RLE. v2 adds channel classification rules at the \n    // start of the data block.\n    //\n\n    if (version > 2)\n        throw IEX_NAMESPACE::InputExc (\"Invalid version of compressed data block\");    \n\n    setupChannelData(minX, minY, maxX, maxY);\n\n    // \n    // Uncompress the UNKNOWN data into _planarUncBuffer[UNKNOWN]\n    //\n\n    if (unknownCompressedSize > 0)\n    {\n        if (unknownUncompressedSize > _planarUncBufferSize[UNKNOWN]) \n        {\n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \"(corrupt header).\");\n        }\n\n        uLongf outSize = (uLongf)unknownUncompressedSize;\n\n        if (Z_OK != ::uncompress\n                        ((Bytef *)_planarUncBuffer[UNKNOWN],\n                         &outSize,\n                         (Bytef *)compressedUnknownBuf,\n                         (uLong)unknownCompressedSize))\n        {\n            throw IEX_NAMESPACE::BaseExc(\"Error uncompressing UNKNOWN data.\");\n        }\n    }\n\n    // \n    // Uncompress the AC data into _packedAcBuffer\n    //\n\n    if (acCompressedSize > 0)\n    {\n        if ( !_packedAcBuffer || totalAcUncompressedCount*sizeof(unsigned short) > _packedAcBufferSize)\n        {\n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \"(corrupt header).\");\n        }\n\n        //\n        // Don't trust the user to get it right, look in the file.\n        //\n\n        switch (acCompression)\n        {\n          case STATIC_HUFFMAN:\n\n            hufUncompress\n                (compressedAcBuf, \n                 (int)acCompressedSize, \n                 (unsigned short *)_packedAcBuffer, \n                 (int)totalAcUncompressedCount); \n\n            break;\n\n          case DEFLATE:\n            {\n                uLongf destLen =\n                    (int)(totalAcUncompressedCount) * sizeof (unsigned short);\n\n                if (Z_OK != ::uncompress\n                                ((Bytef *)_packedAcBuffer,\n                                 &destLen,\n                                 (Bytef *)compressedAcBuf,\n                                 (uLong)acCompressedSize))\n                {\n                    throw IEX_NAMESPACE::InputExc (\"Data decompression (zlib) failed.\");\n                }\n\n                if (totalAcUncompressedCount * sizeof (unsigned short) !=\n                                destLen)\n                {\n                    throw IEX_NAMESPACE::InputExc (\"AC data corrupt.\");     \n                }\n            }\n            break;\n\n          default:\n\n            throw IEX_NAMESPACE::NoImplExc (\"Unknown AC Compression\");\n            break;\n        }\n    }\n\n    //\n    // Uncompress the DC data into _packedDcBuffer\n    //\n\n    if (dcCompressedSize > 0)\n    {\n        if (totalDcUncompressedCount*sizeof(unsigned short) > _packedDcBufferSize)\n        {\n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \"(corrupt header).\");\n        }\n\n        if (static_cast<Int64>(_zip->uncompress\n                    (compressedDcBuf, (int)dcCompressedSize, _packedDcBuffer))\n            != totalDcUncompressedCount * sizeof (unsigned short))\n        {\n            throw IEX_NAMESPACE::BaseExc(\"DC data corrupt.\");\n        }\n    }\n\n    //\n    // Uncompress the RLE data into _rleBuffer, then unRLE the results\n    // into _planarUncBuffer[RLE]\n    //\n\n    if (rleRawSize > 0)\n    {\n        if (rleUncompressedSize > _rleBufferSize ||\n            rleRawSize > _planarUncBufferSize[RLE])\n        {\n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \"(corrupt header).\");\n        }\n \n        uLongf dstLen = (uLongf)rleUncompressedSize;\n\n        if (Z_OK != ::uncompress\n                        ((Bytef *)_rleBuffer,\n                         &dstLen,\n                         (Bytef *)compressedRleBuf,\n                         (uLong)rleCompressedSize))\n        {\n            throw IEX_NAMESPACE::BaseExc(\"Error uncompressing RLE data.\");\n        }\n\n        if (dstLen != rleUncompressedSize)\n            throw IEX_NAMESPACE::BaseExc(\"RLE data corrupted\");\n\n        if (static_cast<Int64>(rleUncompress\n                ((int)rleUncompressedSize, \n                 (int)rleRawSize,\n                 (signed char *)_rleBuffer,\n                 _planarUncBuffer[RLE])) != rleRawSize)\n        {        \n            throw IEX_NAMESPACE::BaseExc(\"RLE data corrupted\");\n        }\n    }\n\n    //\n    // Determine the start of each row in the output buffer\n    //\n\n    std::vector<bool> decodedChannels (_channelData.size());\n    std::vector< std::vector<char *> > rowPtrs (_channelData.size());\n\n    for (unsigned int chan = 0; chan < _channelData.size(); ++chan)\n        decodedChannels[chan] = false;\n\n    outBufferEnd = _outBuffer;\n\n    for (int y = minY; y <= maxY; ++y)\n    {\n        for (unsigned int chan = 0; chan < _channelData.size(); ++chan)\n        {\n            ChannelData *cd = &_channelData[chan];\n\n            if (IMATH_NAMESPACE::modp (y, cd->ySampling) != 0)\n                continue;\n\n            rowPtrs[chan].push_back (outBufferEnd);\n            outBufferEnd += cd->width * OPENEXR_IMF_NAMESPACE::pixelTypeSize (cd->type);\n        }\n    }\n\n    //\n    // Setup to decode each block of 3 channels that need to\n    // be handled together\n    //\n\n    for (unsigned int csc = 0; csc < _cscSets.size(); ++csc)\n    {\n        int rChan = _cscSets[csc].idx[0];    \n        int gChan = _cscSets[csc].idx[1];    \n        int bChan = _cscSets[csc].idx[2];    \n\n\n        LossyDctDecoderCsc decoder\n            (rowPtrs[rChan],\n             rowPtrs[gChan],\n             rowPtrs[bChan],\n             packedAcBufferEnd,\n             packedDcBufferEnd,\n             dwaCompressorToLinear,\n             _channelData[rChan].width,\n             _channelData[rChan].height,\n             _channelData[rChan].type,\n             _channelData[gChan].type,\n             _channelData[bChan].type);\n\n        decoder.execute();\n\n        packedAcBufferEnd +=\n            decoder.numAcValuesEncoded() * sizeof (unsigned short);\n\n        packedDcBufferEnd +=\n            decoder.numDcValuesEncoded() * sizeof (unsigned short);\n\n        decodedChannels[rChan] = true;\n        decodedChannels[gChan] = true;\n        decodedChannels[bChan] = true;\n    }\n\n    //\n    // Setup to handle the remaining channels by themselves\n    //\n\n    for (unsigned int chan = 0; chan < _channelData.size(); ++chan)\n    {\n        if (decodedChannels[chan])\n            continue;\n\n        ChannelData *cd = &_channelData[chan];\n        int pixelSize = OPENEXR_IMF_NAMESPACE::pixelTypeSize (cd->type);\n\n        switch (cd->compression)\n        {\n          case LOSSY_DCT:\n\n            //\n            // Setup a single-channel lossy DCT decoder pointing\n            // at the output buffer\n            //\n\n            {\n                const unsigned short *linearLut = 0;\n\n                if (!cd->pLinear)\n                    linearLut = dwaCompressorToLinear;\n\n                LossyDctDecoder decoder\n                    (rowPtrs[chan],\n                     packedAcBufferEnd,\n                     packedDcBufferEnd,\n                     linearLut,\n                     cd->width,\n                     cd->height,\n                     cd->type);\n\n                decoder.execute();   \n\n                packedAcBufferEnd += \n                    decoder.numAcValuesEncoded() * sizeof (unsigned short);\n\n                packedDcBufferEnd += \n                    decoder.numDcValuesEncoded() * sizeof (unsigned short);\n            }\n\n            break;\n\n          case RLE:\n\n            //\n            // For the RLE case, the data has been un-RLE'd into\n            // planarUncRleEnd[], but is still split out by bytes.\n            // We need to rearrange the bytes back into the correct\n            // order in the output buffer;\n            //\n\n            {\n                int row = 0;\n\n                for (int y = minY; y <= maxY; ++y)\n                {\n                    if (IMATH_NAMESPACE::modp (y, cd->ySampling) != 0)\n                        continue;\n\n                    char *dst = rowPtrs[chan][row];\n\n                    if (pixelSize == 2)\n                    {\n                        interleaveByte2 (dst, \n                                         cd->planarUncRleEnd[0],\n                                         cd->planarUncRleEnd[1],\n                                         cd->width);\n                                            \n                        cd->planarUncRleEnd[0] += cd->width;\n                        cd->planarUncRleEnd[1] += cd->width;\n                    }\n                    else\n                    {\n                        for (int x = 0; x < cd->width; ++x)\n                        {\n                            for (int byte = 0; byte < pixelSize; ++byte)\n                            {\n                               *dst++ = *cd->planarUncRleEnd[byte]++;\n                            }\n                        }\n                    }\n\n                    row++;\n                }\n            }\n\n            break;\n\n          case UNKNOWN:\n\n            //\n            // In the UNKNOWN case, data is already in planarUncBufferEnd\n            // and just needs to copied over to the output buffer\n            //\n\n            {\n                int row             = 0;\n                int dstScanlineSize = cd->width * OPENEXR_IMF_NAMESPACE::pixelTypeSize (cd->type);\n\n                for (int y = minY; y <= maxY; ++y)\n                {\n                    if (IMATH_NAMESPACE::modp (y, cd->ySampling) != 0)\n                        continue;\n\n                    //\n                    // sanity check for buffer data lying within range\n                    //\n                    if ((cd->planarUncBufferEnd + static_cast<size_t>(dstScanlineSize))  > (_planarUncBuffer[UNKNOWN] + _planarUncBufferSize[UNKNOWN]) )\n                    {\n                        throw Iex::InputExc(\"DWA data corrupt\");\n                    }\n\n                    memcpy (rowPtrs[chan][row],\n                            cd->planarUncBufferEnd,\n                            dstScanlineSize);\n\n                    cd->planarUncBufferEnd += dstScanlineSize;\n                    row++;\n                }\n            }\n\n            break;\n\n          default:\n\n            throw IEX_NAMESPACE::NoImplExc (\"Unhandled compression scheme case\");\n            break;\n        }\n\n        decodedChannels[chan] = true;\n    }\n\n    //\n    // Return a ptr to _outBuffer\n    //\n\n    outPtr = _outBuffer;\n    return (int)(outBufferEnd - _outBuffer);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147111,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void kvm_mmu_invpcid_gva(struct kvm_vcpu *vcpu, gva_t gva, unsigned long pcid)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tbool tlb_flush = false;\n\tuint i;\n\n\tif (pcid == kvm_get_active_pcid(vcpu)) {\n\t\tmmu->invlpg(vcpu, gva, mmu->root.hpa);\n\t\ttlb_flush = true;\n\t}\n\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++) {\n\t\tif (VALID_PAGE(mmu->prev_roots[i].hpa) &&\n\t\t    pcid == kvm_get_pcid(vcpu, mmu->prev_roots[i].pgd)) {\n\t\t\tmmu->invlpg(vcpu, gva, mmu->prev_roots[i].hpa);\n\t\t\ttlb_flush = true;\n\t\t}\n\t}\n\n\tif (tlb_flush)\n\t\tstatic_call(kvm_x86_flush_tlb_gva)(vcpu, gva);\n\n\t++vcpu->stat.invlpg;\n\n\t/*\n\t * Mappings not reachable via the current cr3 or the prev_roots will be\n\t * synced when switching to that cr3, so nothing needs to be done here\n\t * for them.\n\t */\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147122,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void kvm_mmu_invpcid_gva(struct kvm_vcpu *vcpu, gva_t gva, unsigned long pcid)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tbool tlb_flush = false;\n\tuint i;\n\n\tif (pcid == kvm_get_active_pcid(vcpu)) {\n\t\tif (mmu->invlpg)\n\t\t\tmmu->invlpg(vcpu, gva, mmu->root.hpa);\n\t\ttlb_flush = true;\n\t}\n\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++) {\n\t\tif (VALID_PAGE(mmu->prev_roots[i].hpa) &&\n\t\t    pcid == kvm_get_pcid(vcpu, mmu->prev_roots[i].pgd)) {\n\t\t\tif (mmu->invlpg)\n\t\t\t\tmmu->invlpg(vcpu, gva, mmu->prev_roots[i].hpa);\n\t\t\ttlb_flush = true;\n\t\t}\n\t}\n\n\tif (tlb_flush)\n\t\tstatic_call(kvm_x86_flush_tlb_gva)(vcpu, gva);\n\n\t++vcpu->stat.invlpg;\n\n\t/*\n\t * Mappings not reachable via the current cr3 or the prev_roots will be\n\t * synced when switching to that cr3, so nothing needs to be done here\n\t * for them.\n\t */\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147123,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "AP_DECLARE(void) ap_increment_counts(ap_sb_handle_t *sb, request_rec *r)\n{\n    worker_score *ws;\n    apr_off_t bytes;\n\n    if (!sb)\n        return;\n\n    ws = &ap_scoreboard_image->servers[sb->child_num][sb->thread_num];\n    if (pfn_ap_logio_get_last_bytes != NULL) {\n        bytes = pfn_ap_logio_get_last_bytes(r->connection);\n    }\n    else if (r->method_number == M_GET && r->method[0] == 'H') {\n        bytes = 0;\n    }\n    else {\n        bytes = r->bytes_sent;\n    }\n\n#ifdef HAVE_TIMES\n    times(&ws->times);\n#endif\n    ws->access_count++;\n    ws->my_access_count++;\n    ws->conn_count++;\n    ws->bytes_served += bytes;\n    ws->my_bytes_served += bytes;\n    ws->conn_bytes += bytes;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147126,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "AP_DECLARE(void) ap_increment_counts(ap_sb_handle_t *sb, request_rec *r)\n{\n    worker_score *ws;\n    apr_off_t bytes;\n\n    if (!sb)\n        return;\n\n    ws = &ap_scoreboard_image->servers[sb->child_num][sb->thread_num];\n    if (pfn_ap_logio_get_last_bytes != NULL) {\n        bytes = pfn_ap_logio_get_last_bytes(r->connection);\n    }\n    else if (r->method_number == M_GET && r->method && r->method[0] == 'H') {\n        bytes = 0;\n    }\n    else {\n        bytes = r->bytes_sent;\n    }\n\n#ifdef HAVE_TIMES\n    times(&ws->times);\n#endif\n    ws->access_count++;\n    ws->my_access_count++;\n    ws->conn_count++;\n    ws->bytes_served += bytes;\n    ws->my_bytes_served += bytes;\n    ws->conn_bytes += bytes;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147127,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int rds_iw_laddr_check(__be32 addr)\n{\n\tint ret;\n\tstruct rdma_cm_id *cm_id;\n\tstruct sockaddr_in sin;\n\n\t/* Create a CMA ID and try to bind it. This catches both\n\t * IB and iWARP capable NICs.\n\t */\n\tcm_id = rdma_create_id(NULL, NULL, RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(cm_id))\n\t\treturn PTR_ERR(cm_id);\n\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_family = AF_INET;\n\tsin.sin_addr.s_addr = addr;\n\n\t/* rdma_bind_addr will only succeed for IB & iWARP devices */\n\tret = rdma_bind_addr(cm_id, (struct sockaddr *)&sin);\n\t/* due to this, we will claim to support IB devices unless we\n\t   check node_type. */\n\tif (ret || cm_id->device->node_type != RDMA_NODE_RNIC)\n\t\tret = -EADDRNOTAVAIL;\n\n\trdsdebug(\"addr %pI4 ret %d node type %d\\n\",\n\t\t&addr, ret,\n\t\tcm_id->device ? cm_id->device->node_type : -1);\n\n\trdma_destroy_id(cm_id);\n\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147130,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int rds_iw_laddr_check(__be32 addr)\n{\n\tint ret;\n\tstruct rdma_cm_id *cm_id;\n\tstruct sockaddr_in sin;\n\n\t/* Create a CMA ID and try to bind it. This catches both\n\t * IB and iWARP capable NICs.\n\t */\n\tcm_id = rdma_create_id(NULL, NULL, RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(cm_id))\n\t\treturn PTR_ERR(cm_id);\n\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_family = AF_INET;\n\tsin.sin_addr.s_addr = addr;\n\n\t/* rdma_bind_addr will only succeed for IB & iWARP devices */\n\tret = rdma_bind_addr(cm_id, (struct sockaddr *)&sin);\n\t/* due to this, we will claim to support IB devices unless we\n\t   check node_type. */\n\tif (ret || !cm_id->device ||\n\t    cm_id->device->node_type != RDMA_NODE_RNIC)\n\t\tret = -EADDRNOTAVAIL;\n\n\trdsdebug(\"addr %pI4 ret %d node type %d\\n\",\n\t\t&addr, ret,\n\t\tcm_id->device ? cm_id->device->node_type : -1);\n\n\trdma_destroy_id(cm_id);\n\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147131,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147138,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page_file_mapping(page));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147139,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int ldb_lock_backend_callback(struct ldb_request *req,\n\t\t\t\t     struct ldb_reply *ares)\n{\n\tstruct ldb_db_lock_context *lock_context;\n\tint ret;\n\n\tlock_context = talloc_get_type(req->context,\n\t\t\t\t       struct ldb_db_lock_context);\n\n\tif (!ares) {\n\t\treturn ldb_module_done(lock_context->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\tif (ares->error != LDB_SUCCESS || ares->type == LDB_REPLY_DONE) {\n\t\tret = ldb_module_done(lock_context->req, ares->controls,\n\t\t\t\t      ares->response, ares->error);\n\t\t/*\n\t\t * If this is a LDB_REPLY_DONE or an error, unlock the\n\t\t * DB by calling the destructor on this context\n\t\t */\n\t\ttalloc_free(lock_context);\n\t\treturn ret;\n\t}\n\n\t/* Otherwise pass on the callback */\n\tswitch (ares->type) {\n\tcase LDB_REPLY_ENTRY:\n\t\treturn ldb_module_send_entry(lock_context->req, ares->message,\n\t\t\t\t\t     ares->controls);\n\n\tcase LDB_REPLY_REFERRAL:\n\t\treturn ldb_module_send_referral(lock_context->req,\n\t\t\t\t\t\tares->referral);\n\tdefault:\n\t\t/* Can't happen */\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147186,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int ldb_lock_backend_callback(struct ldb_request *req,\n\t\t\t\t     struct ldb_reply *ares)\n{\n\tstruct ldb_db_lock_context *lock_context;\n\tint ret;\n\n\tif (req->context == NULL) {\n\t\t/*\n\t\t * The usual way to get here is to ignore the return codes\n\t\t * and continuing processing after an error.\n\t\t */\n\t\tabort();\n\t}\n\tlock_context = talloc_get_type(req->context,\n\t\t\t\t       struct ldb_db_lock_context);\n\n\tif (!ares) {\n\t\treturn ldb_module_done(lock_context->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\tif (ares->error != LDB_SUCCESS || ares->type == LDB_REPLY_DONE) {\n\t\tret = ldb_module_done(lock_context->req, ares->controls,\n\t\t\t\t      ares->response, ares->error);\n\t\t/*\n\t\t * If this is a LDB_REPLY_DONE or an error, unlock the\n\t\t * DB by calling the destructor on this context\n\t\t */\n\t\tTALLOC_FREE(req->context);\n\t\treturn ret;\n\t}\n\n\t/* Otherwise pass on the callback */\n\tswitch (ares->type) {\n\tcase LDB_REPLY_ENTRY:\n\t\treturn ldb_module_send_entry(lock_context->req, ares->message,\n\t\t\t\t\t     ares->controls);\n\n\tcase LDB_REPLY_REFERRAL:\n\t\treturn ldb_module_send_referral(lock_context->req,\n\t\t\t\t\t\tares->referral);\n\tdefault:\n\t\t/* Can't happen */\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147187,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "png_free_data(png_const_structrp png_ptr, png_inforp info_ptr, png_uint_32 mask,\n    int num)\n{\n   png_debug(1, \"in png_free_data\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n#ifdef PNG_TEXT_SUPPORTED\n   /* Free text item num or (if num == -1) all text items */\n   if (info_ptr->text != NULL &&\n       ((mask & PNG_FREE_TEXT) & info_ptr->free_me) != 0)\n   {\n      if (num != -1)\n      {\n         png_free(png_ptr, info_ptr->text[num].key);\n         info_ptr->text[num].key = NULL;\n      }\n\n      else\n      {\n         int i;\n\n         for (i = 0; i < info_ptr->num_text; i++)\n            png_free(png_ptr, info_ptr->text[i].key);\n\n         png_free(png_ptr, info_ptr->text);\n         info_ptr->text = NULL;\n         info_ptr->num_text = 0;\n      }\n   }\n#endif\n\n#ifdef PNG_tRNS_SUPPORTED\n   /* Free any tRNS entry */\n   if (((mask & PNG_FREE_TRNS) & info_ptr->free_me) != 0)\n   {\n      info_ptr->valid &= ~PNG_INFO_tRNS;\n      png_free(png_ptr, info_ptr->trans_alpha);\n      info_ptr->trans_alpha = NULL;\n      info_ptr->num_trans = 0;\n   }\n#endif\n\n#ifdef PNG_sCAL_SUPPORTED\n   /* Free any sCAL entry */\n   if (((mask & PNG_FREE_SCAL) & info_ptr->free_me) != 0)\n   {\n      png_free(png_ptr, info_ptr->scal_s_width);\n      png_free(png_ptr, info_ptr->scal_s_height);\n      info_ptr->scal_s_width = NULL;\n      info_ptr->scal_s_height = NULL;\n      info_ptr->valid &= ~PNG_INFO_sCAL;\n   }\n#endif\n\n#ifdef PNG_pCAL_SUPPORTED\n   /* Free any pCAL entry */\n   if (((mask & PNG_FREE_PCAL) & info_ptr->free_me) != 0)\n   {\n      png_free(png_ptr, info_ptr->pcal_purpose);\n      png_free(png_ptr, info_ptr->pcal_units);\n      info_ptr->pcal_purpose = NULL;\n      info_ptr->pcal_units = NULL;\n\n      if (info_ptr->pcal_params != NULL)\n         {\n            int i;\n\n            for (i = 0; i < info_ptr->pcal_nparams; i++)\n               png_free(png_ptr, info_ptr->pcal_params[i]);\n\n            png_free(png_ptr, info_ptr->pcal_params);\n            info_ptr->pcal_params = NULL;\n         }\n      info_ptr->valid &= ~PNG_INFO_pCAL;\n   }\n#endif\n\n#ifdef PNG_iCCP_SUPPORTED\n   /* Free any profile entry */\n   if (((mask & PNG_FREE_ICCP) & info_ptr->free_me) != 0)\n   {\n      png_free(png_ptr, info_ptr->iccp_name);\n      png_free(png_ptr, info_ptr->iccp_profile);\n      info_ptr->iccp_name = NULL;\n      info_ptr->iccp_profile = NULL;\n      info_ptr->valid &= ~PNG_INFO_iCCP;\n   }\n#endif\n\n#ifdef PNG_sPLT_SUPPORTED\n   /* Free a given sPLT entry, or (if num == -1) all sPLT entries */\n   if (info_ptr->splt_palettes != NULL &&\n       ((mask & PNG_FREE_SPLT) & info_ptr->free_me) != 0)\n   {\n      if (num != -1)\n      {\n         png_free(png_ptr, info_ptr->splt_palettes[num].name);\n         png_free(png_ptr, info_ptr->splt_palettes[num].entries);\n         info_ptr->splt_palettes[num].name = NULL;\n         info_ptr->splt_palettes[num].entries = NULL;\n      }\n\n      else\n      {\n         int i;\n\n         for (i = 0; i < info_ptr->splt_palettes_num; i++)\n         {\n            png_free(png_ptr, info_ptr->splt_palettes[i].name);\n            png_free(png_ptr, info_ptr->splt_palettes[i].entries);\n         }\n\n         png_free(png_ptr, info_ptr->splt_palettes);\n         info_ptr->splt_palettes = NULL;\n         info_ptr->splt_palettes_num = 0;\n         info_ptr->valid &= ~PNG_INFO_sPLT;\n      }\n   }\n#endif\n\n#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED\n   if (info_ptr->unknown_chunks != NULL &&\n       ((mask & PNG_FREE_UNKN) & info_ptr->free_me) != 0)\n   {\n      if (num != -1)\n      {\n          png_free(png_ptr, info_ptr->unknown_chunks[num].data);\n          info_ptr->unknown_chunks[num].data = NULL;\n      }\n\n      else\n      {\n         int i;\n\n         for (i = 0; i < info_ptr->unknown_chunks_num; i++)\n            png_free(png_ptr, info_ptr->unknown_chunks[i].data);\n\n         png_free(png_ptr, info_ptr->unknown_chunks);\n         info_ptr->unknown_chunks = NULL;\n         info_ptr->unknown_chunks_num = 0;\n      }\n   }\n#endif\n\n#ifdef PNG_hIST_SUPPORTED\n   /* Free any hIST entry */\n   if (((mask & PNG_FREE_HIST) & info_ptr->free_me) != 0)\n   {\n      png_free(png_ptr, info_ptr->hist);\n      info_ptr->hist = NULL;\n      info_ptr->valid &= ~PNG_INFO_hIST;\n   }\n#endif\n\n   /* Free any PLTE entry that was internally allocated */\n   if (((mask & PNG_FREE_PLTE) & info_ptr->free_me) != 0)\n   {\n      png_free(png_ptr, info_ptr->palette);\n      info_ptr->palette = NULL;\n      info_ptr->valid &= ~PNG_INFO_PLTE;\n      info_ptr->num_palette = 0;\n   }\n\n#ifdef PNG_INFO_IMAGE_SUPPORTED\n   /* Free any image bits attached to the info structure */\n   if (((mask & PNG_FREE_ROWS) & info_ptr->free_me) != 0)\n   {\n      if (info_ptr->row_pointers != NULL)\n      {\n         png_uint_32 row;\n         for (row = 0; row < info_ptr->height; row++)\n            png_free(png_ptr, info_ptr->row_pointers[row]);\n\n         png_free(png_ptr, info_ptr->row_pointers);\n         info_ptr->row_pointers = NULL;\n      }\n      info_ptr->valid &= ~PNG_INFO_IDAT;\n   }\n#endif\n\n   if (num != -1)\n      mask &= ~PNG_FREE_MUL;\n\n   info_ptr->free_me &= ~mask;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147222,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "png_free_data(png_const_structrp png_ptr, png_inforp info_ptr, png_uint_32 mask,\n    int num)\n{\n   png_debug(1, \"in png_free_data\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n#ifdef PNG_TEXT_SUPPORTED\n   /* Free text item num or (if num == -1) all text items */\n   if (info_ptr->text != NULL &&\n       ((mask & PNG_FREE_TEXT) & info_ptr->free_me) != 0)\n   {\n      if (num != -1)\n      {\n         png_free(png_ptr, info_ptr->text[num].key);\n         info_ptr->text[num].key = NULL;\n      }\n\n      else\n      {\n         int i;\n\n         for (i = 0; i < info_ptr->num_text; i++)\n            png_free(png_ptr, info_ptr->text[i].key);\n\n         png_free(png_ptr, info_ptr->text);\n         info_ptr->text = NULL;\n         info_ptr->num_text = 0;\n         info_ptr->max_text = 0;\n      }\n   }\n#endif\n\n#ifdef PNG_tRNS_SUPPORTED\n   /* Free any tRNS entry */\n   if (((mask & PNG_FREE_TRNS) & info_ptr->free_me) != 0)\n   {\n      info_ptr->valid &= ~PNG_INFO_tRNS;\n      png_free(png_ptr, info_ptr->trans_alpha);\n      info_ptr->trans_alpha = NULL;\n      info_ptr->num_trans = 0;\n   }\n#endif\n\n#ifdef PNG_sCAL_SUPPORTED\n   /* Free any sCAL entry */\n   if (((mask & PNG_FREE_SCAL) & info_ptr->free_me) != 0)\n   {\n      png_free(png_ptr, info_ptr->scal_s_width);\n      png_free(png_ptr, info_ptr->scal_s_height);\n      info_ptr->scal_s_width = NULL;\n      info_ptr->scal_s_height = NULL;\n      info_ptr->valid &= ~PNG_INFO_sCAL;\n   }\n#endif\n\n#ifdef PNG_pCAL_SUPPORTED\n   /* Free any pCAL entry */\n   if (((mask & PNG_FREE_PCAL) & info_ptr->free_me) != 0)\n   {\n      png_free(png_ptr, info_ptr->pcal_purpose);\n      png_free(png_ptr, info_ptr->pcal_units);\n      info_ptr->pcal_purpose = NULL;\n      info_ptr->pcal_units = NULL;\n\n      if (info_ptr->pcal_params != NULL)\n         {\n            int i;\n\n            for (i = 0; i < info_ptr->pcal_nparams; i++)\n               png_free(png_ptr, info_ptr->pcal_params[i]);\n\n            png_free(png_ptr, info_ptr->pcal_params);\n            info_ptr->pcal_params = NULL;\n         }\n      info_ptr->valid &= ~PNG_INFO_pCAL;\n   }\n#endif\n\n#ifdef PNG_iCCP_SUPPORTED\n   /* Free any profile entry */\n   if (((mask & PNG_FREE_ICCP) & info_ptr->free_me) != 0)\n   {\n      png_free(png_ptr, info_ptr->iccp_name);\n      png_free(png_ptr, info_ptr->iccp_profile);\n      info_ptr->iccp_name = NULL;\n      info_ptr->iccp_profile = NULL;\n      info_ptr->valid &= ~PNG_INFO_iCCP;\n   }\n#endif\n\n#ifdef PNG_sPLT_SUPPORTED\n   /* Free a given sPLT entry, or (if num == -1) all sPLT entries */\n   if (info_ptr->splt_palettes != NULL &&\n       ((mask & PNG_FREE_SPLT) & info_ptr->free_me) != 0)\n   {\n      if (num != -1)\n      {\n         png_free(png_ptr, info_ptr->splt_palettes[num].name);\n         png_free(png_ptr, info_ptr->splt_palettes[num].entries);\n         info_ptr->splt_palettes[num].name = NULL;\n         info_ptr->splt_palettes[num].entries = NULL;\n      }\n\n      else\n      {\n         int i;\n\n         for (i = 0; i < info_ptr->splt_palettes_num; i++)\n         {\n            png_free(png_ptr, info_ptr->splt_palettes[i].name);\n            png_free(png_ptr, info_ptr->splt_palettes[i].entries);\n         }\n\n         png_free(png_ptr, info_ptr->splt_palettes);\n         info_ptr->splt_palettes = NULL;\n         info_ptr->splt_palettes_num = 0;\n         info_ptr->valid &= ~PNG_INFO_sPLT;\n      }\n   }\n#endif\n\n#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED\n   if (info_ptr->unknown_chunks != NULL &&\n       ((mask & PNG_FREE_UNKN) & info_ptr->free_me) != 0)\n   {\n      if (num != -1)\n      {\n          png_free(png_ptr, info_ptr->unknown_chunks[num].data);\n          info_ptr->unknown_chunks[num].data = NULL;\n      }\n\n      else\n      {\n         int i;\n\n         for (i = 0; i < info_ptr->unknown_chunks_num; i++)\n            png_free(png_ptr, info_ptr->unknown_chunks[i].data);\n\n         png_free(png_ptr, info_ptr->unknown_chunks);\n         info_ptr->unknown_chunks = NULL;\n         info_ptr->unknown_chunks_num = 0;\n      }\n   }\n#endif\n\n#ifdef PNG_hIST_SUPPORTED\n   /* Free any hIST entry */\n   if (((mask & PNG_FREE_HIST) & info_ptr->free_me) != 0)\n   {\n      png_free(png_ptr, info_ptr->hist);\n      info_ptr->hist = NULL;\n      info_ptr->valid &= ~PNG_INFO_hIST;\n   }\n#endif\n\n   /* Free any PLTE entry that was internally allocated */\n   if (((mask & PNG_FREE_PLTE) & info_ptr->free_me) != 0)\n   {\n      png_free(png_ptr, info_ptr->palette);\n      info_ptr->palette = NULL;\n      info_ptr->valid &= ~PNG_INFO_PLTE;\n      info_ptr->num_palette = 0;\n   }\n\n#ifdef PNG_INFO_IMAGE_SUPPORTED\n   /* Free any image bits attached to the info structure */\n   if (((mask & PNG_FREE_ROWS) & info_ptr->free_me) != 0)\n   {\n      if (info_ptr->row_pointers != NULL)\n      {\n         png_uint_32 row;\n         for (row = 0; row < info_ptr->height; row++)\n            png_free(png_ptr, info_ptr->row_pointers[row]);\n\n         png_free(png_ptr, info_ptr->row_pointers);\n         info_ptr->row_pointers = NULL;\n      }\n      info_ptr->valid &= ~PNG_INFO_IDAT;\n   }\n#endif\n\n   if (num != -1)\n      mask &= ~PNG_FREE_MUL;\n\n   info_ptr->free_me &= ~mask;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147223,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "onig_compile(regex_t* reg, const UChar* pattern, const UChar* pattern_end,\n             OnigErrorInfo* einfo)\n{\n#define COMPILE_INIT_SIZE  20\n\n  int r, init_size;\n  Node*  root;\n  ScanEnv  scan_env;\n#ifdef USE_CALL\n  UnsetAddrList  uslist;\n#endif\n\n  root = 0;\n  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n\n#ifdef ONIG_DEBUG\n  print_enc_string(stderr, reg->enc, pattern, pattern_end);\n#endif\n\n  if (reg->alloc == 0) {\n    init_size = (int )(pattern_end - pattern) * 2;\n    if (init_size <= 0) init_size = COMPILE_INIT_SIZE;\n    r = BB_INIT(reg, init_size);\n    if (r != 0) goto end;\n  }\n  else\n    reg->used = 0;\n\n  reg->num_mem            = 0;\n  reg->num_repeat         = 0;\n  reg->num_null_check     = 0;\n  reg->repeat_range_alloc = 0;\n  reg->repeat_range       = (OnigRepeatRange* )NULL;\n\n  r = onig_parse_tree(&root, pattern, pattern_end, reg, &scan_env);\n  if (r != 0) goto err;\n\n  /* mixed use named group and no-named group */\n  if (scan_env.num_named > 0 &&\n      IS_SYNTAX_BV(scan_env.syntax, ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP) &&\n      ! ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_CAPTURE_GROUP)) {\n    if (scan_env.num_named != scan_env.num_mem)\n      r = disable_noname_group_capture(&root, reg, &scan_env);\n    else\n      r = numbered_ref_check(root);\n\n    if (r != 0) goto err;\n  }\n\n  r = check_backrefs(root, &scan_env);\n  if (r != 0) goto err;\n\n#ifdef USE_CALL\n  if (scan_env.num_call > 0) {\n    r = unset_addr_list_init(&uslist, scan_env.num_call);\n    if (r != 0) goto err;\n    scan_env.unset_addr_list = &uslist;\n    r = setup_call(root, &scan_env, 0);\n    if (r != 0) goto err_unset;\n    r = setup_call2(root);\n    if (r != 0) goto err_unset;\n    r = recursive_call_check_trav(root, &scan_env, 0);\n    if (r  < 0) goto err_unset;\n    r = infinite_recursive_call_check_trav(root, &scan_env);\n    if (r != 0) goto err_unset;\n\n    setup_called_state(root, 0);\n  }\n\n  reg->num_call = scan_env.num_call;\n#endif\n\n  r = setup_tree(root, reg, 0, &scan_env);\n  if (r != 0) goto err_unset;\n\n#ifdef ONIG_DEBUG_PARSE\n  print_tree(stderr, root);\n#endif\n\n  reg->capture_history  = scan_env.capture_history;\n  reg->bt_mem_start     = scan_env.bt_mem_start;\n  reg->bt_mem_start    |= reg->capture_history;\n  if (IS_FIND_CONDITION(reg->options))\n    MEM_STATUS_ON_ALL(reg->bt_mem_end);\n  else {\n    reg->bt_mem_end  = scan_env.bt_mem_end;\n    reg->bt_mem_end |= reg->capture_history;\n  }\n  reg->bt_mem_start |= reg->bt_mem_end;\n\n  clear_optimize_info(reg);\n#ifndef ONIG_DONT_OPTIMIZE\n  r = set_optimize_info_from_tree(root, reg, &scan_env);\n  if (r != 0) goto err_unset;\n#endif\n\n  if (IS_NOT_NULL(scan_env.mem_env_dynamic)) {\n    xfree(scan_env.mem_env_dynamic);\n    scan_env.mem_env_dynamic = (MemEnv* )NULL;\n  }\n\n  r = compile_tree(root, reg, &scan_env);\n  if (r == 0) {\n    if (scan_env.keep_num > 0) {\n      r = add_opcode(reg, OP_UPDATE_VAR);\n      if (r != 0) goto err;\n      r = add_update_var_type(reg, UPDATE_VAR_KEEP_FROM_STACK_LAST);\n      if (r != 0) goto err;\n      r = add_mem_num(reg, 0 /* not used */);\n      if (r != 0) goto err;\n    }\n\n    r = add_opcode(reg, OP_END);\n#ifdef USE_CALL\n    if (scan_env.num_call > 0) {\n      r = fix_unset_addr_list(&uslist, reg);\n      unset_addr_list_end(&uslist);\n      if (r != 0) goto err;\n    }\n#endif\n\n    if ((reg->num_repeat != 0) || (reg->bt_mem_end != 0)\n#ifdef USE_CALLOUT\n        || (IS_NOT_NULL(REG_EXTP(reg)) && REG_EXTP(reg)->callout_num != 0)\n#endif\n        )\n      reg->stack_pop_level = STACK_POP_LEVEL_ALL;\n    else {\n      if (reg->bt_mem_start != 0)\n        reg->stack_pop_level = STACK_POP_LEVEL_MEM_START;\n      else\n        reg->stack_pop_level = STACK_POP_LEVEL_FREE;\n    }\n  }\n#ifdef USE_CALL\n  else if (scan_env.num_call > 0) {\n    unset_addr_list_end(&uslist);\n  }\n#endif\n  onig_node_free(root);\n\n#ifdef ONIG_DEBUG_COMPILE\n  onig_print_names(stderr, reg);\n  onig_print_compiled_byte_code_list(stderr, reg);\n#endif\n\n end:\n  return r;\n\n err_unset:\n#ifdef USE_CALL\n  if (scan_env.num_call > 0) {\n    unset_addr_list_end(&uslist);\n  }\n#endif\n err:\n  if (IS_NOT_NULL(scan_env.error)) {\n    if (IS_NOT_NULL(einfo)) {\n      einfo->enc     = scan_env.enc;\n      einfo->par     = scan_env.error;\n      einfo->par_end = scan_env.error_end;\n    }\n  }\n\n  onig_node_free(root);\n  if (IS_NOT_NULL(scan_env.mem_env_dynamic))\n      xfree(scan_env.mem_env_dynamic);\n  return r;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147242,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "onig_compile(regex_t* reg, const UChar* pattern, const UChar* pattern_end,\n             OnigErrorInfo* einfo)\n{\n#define COMPILE_INIT_SIZE  20\n\n  int r, init_size;\n  Node*  root;\n  ScanEnv  scan_env;\n#ifdef USE_CALL\n  UnsetAddrList  uslist;\n#endif\n\n  root = 0;\n  if (IS_NOT_NULL(einfo)) {\n    einfo->enc = reg->enc;\n    einfo->par = (UChar* )NULL;\n  }\n\n#ifdef ONIG_DEBUG\n  print_enc_string(stderr, reg->enc, pattern, pattern_end);\n#endif\n\n  if (reg->alloc == 0) {\n    init_size = (int )(pattern_end - pattern) * 2;\n    if (init_size <= 0) init_size = COMPILE_INIT_SIZE;\n    r = BB_INIT(reg, init_size);\n    if (r != 0) goto end;\n  }\n  else\n    reg->used = 0;\n\n  reg->num_mem            = 0;\n  reg->num_repeat         = 0;\n  reg->num_null_check     = 0;\n  reg->repeat_range_alloc = 0;\n  reg->repeat_range       = (OnigRepeatRange* )NULL;\n\n  r = onig_parse_tree(&root, pattern, pattern_end, reg, &scan_env);\n  if (r != 0) goto err;\n\n  /* mixed use named group and no-named group */\n  if (scan_env.num_named > 0 &&\n      IS_SYNTAX_BV(scan_env.syntax, ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP) &&\n      ! ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_CAPTURE_GROUP)) {\n    if (scan_env.num_named != scan_env.num_mem)\n      r = disable_noname_group_capture(&root, reg, &scan_env);\n    else\n      r = numbered_ref_check(root);\n\n    if (r != 0) goto err;\n  }\n\n  r = check_backrefs(root, &scan_env);\n  if (r != 0) goto err;\n\n#ifdef USE_CALL\n  if (scan_env.num_call > 0) {\n    r = unset_addr_list_init(&uslist, scan_env.num_call);\n    if (r != 0) goto err;\n    scan_env.unset_addr_list = &uslist;\n    r = setup_call(root, &scan_env, 0);\n    if (r != 0) goto err_unset;\n    r = setup_call2(root);\n    if (r != 0) goto err_unset;\n    r = recursive_call_check_trav(root, &scan_env, 0);\n    if (r  < 0) goto err_unset;\n    r = infinite_recursive_call_check_trav(root, &scan_env);\n    if (r != 0) goto err_unset;\n\n    setup_called_state(root, 0);\n  }\n\n  reg->num_call = scan_env.num_call;\n#endif\n\n  r = setup_tree(root, reg, 0, &scan_env);\n  if (r != 0) goto err_unset;\n\n#ifdef ONIG_DEBUG_PARSE\n  print_tree(stderr, root);\n#endif\n\n  reg->capture_history  = scan_env.capture_history;\n  reg->bt_mem_start     = scan_env.bt_mem_start;\n  reg->bt_mem_start    |= reg->capture_history;\n  if (IS_FIND_CONDITION(reg->options))\n    MEM_STATUS_ON_ALL(reg->bt_mem_end);\n  else {\n    reg->bt_mem_end  = scan_env.bt_mem_end;\n    reg->bt_mem_end |= reg->capture_history;\n  }\n  reg->bt_mem_start |= reg->bt_mem_end;\n\n  clear_optimize_info(reg);\n#ifndef ONIG_DONT_OPTIMIZE\n  r = set_optimize_info_from_tree(root, reg, &scan_env);\n  if (r != 0) goto err_unset;\n#endif\n\n  if (IS_NOT_NULL(scan_env.mem_env_dynamic)) {\n    xfree(scan_env.mem_env_dynamic);\n    scan_env.mem_env_dynamic = (MemEnv* )NULL;\n  }\n\n  r = compile_tree(root, reg, &scan_env);\n  if (r == 0) {\n    if (scan_env.keep_num > 0) {\n      r = add_opcode(reg, OP_UPDATE_VAR);\n      if (r != 0) goto err;\n      r = add_update_var_type(reg, UPDATE_VAR_KEEP_FROM_STACK_LAST);\n      if (r != 0) goto err;\n      r = add_mem_num(reg, 0 /* not used */);\n      if (r != 0) goto err;\n    }\n\n    r = add_opcode(reg, OP_END);\n#ifdef USE_CALL\n    if (scan_env.num_call > 0) {\n      r = fix_unset_addr_list(&uslist, reg);\n      unset_addr_list_end(&uslist);\n      if (r != 0) goto err;\n    }\n#endif\n\n    if ((reg->num_repeat != 0) || (reg->bt_mem_end != 0)\n#ifdef USE_CALLOUT\n        || (IS_NOT_NULL(REG_EXTP(reg)) && REG_EXTP(reg)->callout_num != 0)\n#endif\n        )\n      reg->stack_pop_level = STACK_POP_LEVEL_ALL;\n    else {\n      if (reg->bt_mem_start != 0)\n        reg->stack_pop_level = STACK_POP_LEVEL_MEM_START;\n      else\n        reg->stack_pop_level = STACK_POP_LEVEL_FREE;\n    }\n  }\n#ifdef USE_CALL\n  else if (scan_env.num_call > 0) {\n    unset_addr_list_end(&uslist);\n  }\n#endif\n  onig_node_free(root);\n\n#ifdef ONIG_DEBUG_COMPILE\n  onig_print_names(stderr, reg);\n  onig_print_compiled_byte_code_list(stderr, reg);\n#endif\n\n end:\n  return r;\n\n err_unset:\n#ifdef USE_CALL\n  if (scan_env.num_call > 0) {\n    unset_addr_list_end(&uslist);\n  }\n#endif\n err:\n  if (IS_NOT_NULL(scan_env.error)) {\n    if (IS_NOT_NULL(einfo)) {\n      einfo->par     = scan_env.error;\n      einfo->par_end = scan_env.error_end;\n    }\n  }\n\n  onig_node_free(root);\n  if (IS_NOT_NULL(scan_env.mem_env_dynamic))\n      xfree(scan_env.mem_env_dynamic);\n  return r;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147243,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int jp2_encode(jas_image_t *image, jas_stream_t *out, const char *optstr)\n{\n\tjp2_box_t *box;\n\tjp2_ftyp_t *ftyp;\n\tjp2_ihdr_t *ihdr;\n\tjas_stream_t *tmpstream;\n\tint allcmptssame;\n\tjp2_bpcc_t *bpcc;\n\tlong len;\n\tuint_fast16_t cmptno;\n\tjp2_colr_t *colr;\n\tchar buf[4096];\n\tuint_fast32_t overhead;\n\tjp2_cdefchan_t *cdefchanent;\n\tjp2_cdef_t *cdef;\n\tint i;\n\tuint_fast32_t typeasoc;\n\tjas_iccprof_t *iccprof;\n\tjas_stream_t *iccstream;\n\tint pos;\n\tint needcdef;\n\tint prec;\n\tint sgnd;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tallcmptssame = 1;\n\tsgnd = jas_image_cmptsgnd(image, 0);\n\tprec = jas_image_cmptprec(image, 0);\n\tfor (i = 1; i < jas_image_numcmpts(image); ++i) {\n\t\tif (jas_image_cmptsgnd(image, i) != sgnd ||\n\t\t  jas_image_cmptprec(image, i) != prec) {\n\t\t\tallcmptssame = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Output the signature box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP))) {\n\t\tgoto error;\n\t}\n\tbox->data.jp.magic = JP2_JP_MAGIC;\n\tif (jp2_box_put(box, out)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Output the file type box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_FTYP))) {\n\t\tgoto error;\n\t}\n\tftyp = &box->data.ftyp;\n\tftyp->majver = JP2_FTYP_MAJVER;\n\tftyp->minver = JP2_FTYP_MINVER;\n\tftyp->numcompatcodes = 1;\n\tftyp->compatcodes[0] = JP2_FTYP_COMPATCODE;\n\tif (jp2_box_put(box, out)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/*\n\t * Generate the data portion of the JP2 header box.\n\t * We cannot simply output the header for this box\n\t * since we do not yet know the correct value for the length\n\t * field.\n\t */\n\n\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\tgoto error;\n\t}\n\n\t/* Generate image header box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_IHDR))) {\n\t\tgoto error;\n\t}\n\tihdr = &box->data.ihdr;\n\tihdr->width = jas_image_width(image);\n\tihdr->height = jas_image_height(image);\n\tihdr->numcmpts = jas_image_numcmpts(image);\n\tihdr->bpc = allcmptssame ? JP2_SPTOBPC(jas_image_cmptsgnd(image, 0),\n\t  jas_image_cmptprec(image, 0)) : JP2_IHDR_BPCNULL;\n\tihdr->comptype = JP2_IHDR_COMPTYPE;\n\tihdr->csunk = 0;\n\tihdr->ipr = 0;\n\tif (jp2_box_put(box, tmpstream)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Generate bits per component box. */\n\n\tif (!allcmptssame) {\n\t\tif (!(box = jp2_box_create(JP2_BOX_BPCC))) {\n\t\t\tgoto error;\n\t\t}\n\t\tbpcc = &box->data.bpcc;\n\t\tbpcc->numcmpts = jas_image_numcmpts(image);\n\t\tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts,\n\t\t  sizeof(uint_fast8_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (cmptno = 0; cmptno < bpcc->numcmpts; ++cmptno) {\n\t\t\tbpcc->bpcs[cmptno] = JP2_SPTOBPC(jas_image_cmptsgnd(image,\n\t\t\t  cmptno), jas_image_cmptprec(image, cmptno));\n\t\t}\n\t\tif (jp2_box_put(box, tmpstream)) {\n\t\t\tgoto error;\n\t\t}\n\t\tjp2_box_destroy(box);\n\t\tbox = 0;\n\t}\n\n\t/* Generate color specification box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_COLR))) {\n\t\tgoto error;\n\t}\n\tcolr = &box->data.colr;\n\tswitch (jas_image_clrspc(image)) {\n\tcase JAS_CLRSPC_SRGB:\n\tcase JAS_CLRSPC_SYCBCR:\n\tcase JAS_CLRSPC_SGRAY:\n\t\tcolr->method = JP2_COLR_ENUM;\n\t\tcolr->csid = clrspctojp2(jas_image_clrspc(image));\n\t\tcolr->pri = JP2_COLR_PRI;\n\t\tcolr->approx = 0;\n\t\tbreak;\n\tdefault:\n\t\tcolr->method = JP2_COLR_ICC;\n\t\tcolr->pri = JP2_COLR_PRI;\n\t\tcolr->approx = 0;\n\t\ticcprof = jas_iccprof_createfromcmprof(jas_image_cmprof(image));\n\t\tassert(iccprof);\n\t\ticcstream = jas_stream_memopen(0, 0);\n\t\tassert(iccstream);\n\t\tif (jas_iccprof_save(iccprof, iccstream))\n\t\t\tabort();\n\t\tif ((pos = jas_stream_tell(iccstream)) < 0)\n\t\t\tabort();\n\t\tcolr->iccplen = pos;\n\t\tcolr->iccp = jas_malloc(pos);\n\t\tassert(colr->iccp);\n\t\tjas_stream_rewind(iccstream);\n\t\tif (jas_stream_read(iccstream, colr->iccp, colr->iccplen) != colr->iccplen)\n\t\t\tabort();\n\t\tjas_stream_close(iccstream);\n\t\tjas_iccprof_destroy(iccprof);\n\t\tbreak;\n\t}\n\tif (jp2_box_put(box, tmpstream)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\tneedcdef = 1;\n\tswitch (jas_clrspc_fam(jas_image_clrspc(image))) {\n\tcase JAS_CLRSPC_FAM_RGB:\n\t\tif (jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R) &&\n\t\t  jas_image_cmpttype(image, 1) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G) &&\n\t\t  jas_image_cmpttype(image, 2) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tcase JAS_CLRSPC_FAM_YCBCR:\n\t\tif (jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_Y) &&\n\t\t  jas_image_cmpttype(image, 1) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CB) &&\n\t\t  jas_image_cmpttype(image, 2) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CR))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tcase JAS_CLRSPC_FAM_GRAY:\n\t\tif (jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_IMAGE_CT_GRAY_Y))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\n\tif (needcdef) {\n\t\tif (!(box = jp2_box_create(JP2_BOX_CDEF))) {\n\t\t\tgoto error;\n\t\t}\n\t\tcdef = &box->data.cdef;\n\t\tcdef->numchans = jas_image_numcmpts(image);\n\t\tcdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t));\n\t\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\t\tcdefchanent = &cdef->ents[i];\n\t\t\tcdefchanent->channo = i;\n\t\t\ttypeasoc = jp2_gettypeasoc(jas_image_clrspc(image), jas_image_cmpttype(image, i));\n\t\t\tcdefchanent->type = typeasoc >> 16;\n\t\t\tcdefchanent->assoc = typeasoc & 0x7fff;\n\t\t}\n\t\tif (jp2_box_put(box, tmpstream)) {\n\t\t\tgoto error;\n\t\t}\n\t\tjp2_box_destroy(box);\n\t\tbox = 0;\n\t}\n\n\t/* Determine the total length of the JP2 header box. */\n\n\tlen = jas_stream_tell(tmpstream);\n\tjas_stream_rewind(tmpstream);\n\n\t/*\n\t * Output the JP2 header box and all of the boxes which it contains.\n\t */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP2H))) {\n\t\tgoto error;\n\t}\n\tbox->len = len + JP2_BOX_HDRLEN(false);\n\tif (jp2_box_put(box, out)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\tif (jas_stream_copy(out, tmpstream, len)) {\n\t\tgoto error;\n\t}\n\n\tjas_stream_close(tmpstream);\n\ttmpstream = 0;\n\n\t/*\n\t * Output the contiguous code stream box.\n\t */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP2C))) {\n\t\tgoto error;\n\t}\n\tbox->len = 0;\n\tif (jp2_box_put(box, out)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Output the JPEG-2000 code stream. */\n\n\toverhead = jas_stream_getrwcount(out);\n\tsprintf(buf, \"%s\\n_jp2overhead=%lu\\n\", (optstr ? optstr : \"\"),\n\t  (unsigned long) overhead);\n\n\tif (jpc_encode(image, out, buf)) {\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147270,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int jp2_encode(jas_image_t *image, jas_stream_t *out, const char *optstr)\n{\n\tjp2_box_t *box;\n\tjp2_ftyp_t *ftyp;\n\tjp2_ihdr_t *ihdr;\n\tjas_stream_t *tmpstream;\n\tint allcmptssame;\n\tjp2_bpcc_t *bpcc;\n\tlong len;\n\tuint_fast16_t cmptno;\n\tjp2_colr_t *colr;\n\tchar buf[4096];\n\tuint_fast32_t overhead;\n\tjp2_cdefchan_t *cdefchanent;\n\tjp2_cdef_t *cdef;\n\tint i;\n\tuint_fast32_t typeasoc;\n\tjas_iccprof_t *iccprof;\n\tjas_stream_t *iccstream;\n\tint pos;\n\tint needcdef;\n\tint prec;\n\tint sgnd;\n\n\tbox = 0;\n\ttmpstream = 0;\n\ticcstream = 0;\n\ticcprof = 0;\n\n\tallcmptssame = 1;\n\tsgnd = jas_image_cmptsgnd(image, 0);\n\tprec = jas_image_cmptprec(image, 0);\n\tfor (i = 1; i < jas_image_numcmpts(image); ++i) {\n\t\tif (jas_image_cmptsgnd(image, i) != sgnd ||\n\t\t  jas_image_cmptprec(image, i) != prec) {\n\t\t\tallcmptssame = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Output the signature box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP))) {\n\t\tgoto error;\n\t}\n\tbox->data.jp.magic = JP2_JP_MAGIC;\n\tif (jp2_box_put(box, out)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Output the file type box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_FTYP))) {\n\t\tgoto error;\n\t}\n\tftyp = &box->data.ftyp;\n\tftyp->majver = JP2_FTYP_MAJVER;\n\tftyp->minver = JP2_FTYP_MINVER;\n\tftyp->numcompatcodes = 1;\n\tftyp->compatcodes[0] = JP2_FTYP_COMPATCODE;\n\tif (jp2_box_put(box, out)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/*\n\t * Generate the data portion of the JP2 header box.\n\t * We cannot simply output the header for this box\n\t * since we do not yet know the correct value for the length\n\t * field.\n\t */\n\n\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\tgoto error;\n\t}\n\n\t/* Generate image header box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_IHDR))) {\n\t\tgoto error;\n\t}\n\tihdr = &box->data.ihdr;\n\tihdr->width = jas_image_width(image);\n\tihdr->height = jas_image_height(image);\n\tihdr->numcmpts = jas_image_numcmpts(image);\n\tihdr->bpc = allcmptssame ? JP2_SPTOBPC(jas_image_cmptsgnd(image, 0),\n\t  jas_image_cmptprec(image, 0)) : JP2_IHDR_BPCNULL;\n\tihdr->comptype = JP2_IHDR_COMPTYPE;\n\tihdr->csunk = 0;\n\tihdr->ipr = 0;\n\tif (jp2_box_put(box, tmpstream)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Generate bits per component box. */\n\n\tif (!allcmptssame) {\n\t\tif (!(box = jp2_box_create(JP2_BOX_BPCC))) {\n\t\t\tgoto error;\n\t\t}\n\t\tbpcc = &box->data.bpcc;\n\t\tbpcc->numcmpts = jas_image_numcmpts(image);\n\t\tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts,\n\t\t  sizeof(uint_fast8_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (cmptno = 0; cmptno < bpcc->numcmpts; ++cmptno) {\n\t\t\tbpcc->bpcs[cmptno] = JP2_SPTOBPC(jas_image_cmptsgnd(image,\n\t\t\t  cmptno), jas_image_cmptprec(image, cmptno));\n\t\t}\n\t\tif (jp2_box_put(box, tmpstream)) {\n\t\t\tgoto error;\n\t\t}\n\t\tjp2_box_destroy(box);\n\t\tbox = 0;\n\t}\n\n\t/* Generate color specification box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_COLR))) {\n\t\tgoto error;\n\t}\n\tcolr = &box->data.colr;\n\tswitch (jas_image_clrspc(image)) {\n\tcase JAS_CLRSPC_SRGB:\n\tcase JAS_CLRSPC_SYCBCR:\n\tcase JAS_CLRSPC_SGRAY:\n\t\tcolr->method = JP2_COLR_ENUM;\n\t\tcolr->csid = clrspctojp2(jas_image_clrspc(image));\n\t\tcolr->pri = JP2_COLR_PRI;\n\t\tcolr->approx = 0;\n\t\tbreak;\n\tdefault:\n\t\tcolr->method = JP2_COLR_ICC;\n\t\tcolr->pri = JP2_COLR_PRI;\n\t\tcolr->approx = 0;\n\t\t/* Ensure that cmprof_ is not null. */\n\t\tif (!jas_image_cmprof(image)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(iccprof = jas_iccprof_createfromcmprof(\n\t\t  jas_image_cmprof(image)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(iccstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_iccprof_save(iccprof, iccstream)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif ((pos = jas_stream_tell(iccstream)) < 0) {\n\t\t\tgoto error;\n\t\t}\n\t\tcolr->iccplen = pos;\n\t\tif (!(colr->iccp = jas_malloc(pos))) {\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_rewind(iccstream);\n\t\tif (jas_stream_read(iccstream, colr->iccp, colr->iccplen) !=\n\t\t  colr->iccplen) {\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(iccstream);\n\t\ticcstream = 0;\n\t\tjas_iccprof_destroy(iccprof);\n\t\ticcprof = 0;\n\t\tbreak;\n\t}\n\tif (jp2_box_put(box, tmpstream)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\tneedcdef = 1;\n\tswitch (jas_clrspc_fam(jas_image_clrspc(image))) {\n\tcase JAS_CLRSPC_FAM_RGB:\n\t\tif (jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R) &&\n\t\t  jas_image_cmpttype(image, 1) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G) &&\n\t\t  jas_image_cmpttype(image, 2) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tcase JAS_CLRSPC_FAM_YCBCR:\n\t\tif (jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_Y) &&\n\t\t  jas_image_cmpttype(image, 1) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CB) &&\n\t\t  jas_image_cmpttype(image, 2) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CR))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tcase JAS_CLRSPC_FAM_GRAY:\n\t\tif (jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_IMAGE_CT_GRAY_Y))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\n\tif (needcdef) {\n\t\tif (!(box = jp2_box_create(JP2_BOX_CDEF))) {\n\t\t\tgoto error;\n\t\t}\n\t\tcdef = &box->data.cdef;\n\t\tcdef->numchans = jas_image_numcmpts(image);\n\t\tcdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t));\n\t\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\t\tcdefchanent = &cdef->ents[i];\n\t\t\tcdefchanent->channo = i;\n\t\t\ttypeasoc = jp2_gettypeasoc(jas_image_clrspc(image), jas_image_cmpttype(image, i));\n\t\t\tcdefchanent->type = typeasoc >> 16;\n\t\t\tcdefchanent->assoc = typeasoc & 0x7fff;\n\t\t}\n\t\tif (jp2_box_put(box, tmpstream)) {\n\t\t\tgoto error;\n\t\t}\n\t\tjp2_box_destroy(box);\n\t\tbox = 0;\n\t}\n\n\t/* Determine the total length of the JP2 header box. */\n\n\tlen = jas_stream_tell(tmpstream);\n\tjas_stream_rewind(tmpstream);\n\n\t/*\n\t * Output the JP2 header box and all of the boxes which it contains.\n\t */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP2H))) {\n\t\tgoto error;\n\t}\n\tbox->len = len + JP2_BOX_HDRLEN(false);\n\tif (jp2_box_put(box, out)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\tif (jas_stream_copy(out, tmpstream, len)) {\n\t\tgoto error;\n\t}\n\n\tjas_stream_close(tmpstream);\n\ttmpstream = 0;\n\n\t/*\n\t * Output the contiguous code stream box.\n\t */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP2C))) {\n\t\tgoto error;\n\t}\n\tbox->len = 0;\n\tif (jp2_box_put(box, out)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Output the JPEG-2000 code stream. */\n\n\toverhead = jas_stream_getrwcount(out);\n\tsprintf(buf, \"%s\\n_jp2overhead=%lu\\n\", (optstr ? optstr : \"\"),\n\t  (unsigned long) overhead);\n\n\tif (jpc_encode(image, out, buf)) {\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (iccprof) {\n\t\tjas_iccprof_destroy(iccprof);\n\t}\n\tif (iccstream) {\n\t\tjas_stream_close(iccstream);\n\t}\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147271,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static inline void CheckEventLogging()\n{\n  /*\n    Are we logging events?\n  */\n  if (IsLinkedListEmpty(log_cache) != MagickFalse)\n    event_logging=MagickFalse;\n  else\n    {\n      LogInfo\n        *p;\n\n      ResetLinkedListIterator(log_cache);\n      p=(LogInfo *) GetNextValueInLinkedList(log_cache);\n      event_logging=p->event_mask != NoEvents ? MagickTrue: MagickFalse;\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147290,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static inline void CheckEventLogging()\n{\n  /*\n    Are we logging events?\n  */\n  if (IsLinkedListEmpty(log_cache) != MagickFalse)\n    event_logging=MagickFalse;\n  else\n    {\n      LogInfo\n        *p;\n\n      ResetLinkedListIterator(log_cache);\n      p=(LogInfo *) GetNextValueInLinkedList(log_cache);\n      event_logging=(p != (LogInfo *) NULL) && (p->event_mask != NoEvents) ?\n        MagickTrue: MagickFalse;\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147291,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void interface_release_resource(QXLInstance *sin,\n                                       QXLReleaseInfoExt ext)\n{\n    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);\n    QXLReleaseRing *ring;\n    uint64_t *item, id;\n\n    if (ext.group_id == MEMSLOT_GROUP_HOST) {\n        /* host group -> vga mode update request */\n        QXLCommandExt *cmdext = (void *)(intptr_t)(ext.info->id);\n        SimpleSpiceUpdate *update;\n        g_assert(cmdext->cmd.type == QXL_CMD_DRAW);\n        update = container_of(cmdext, SimpleSpiceUpdate, ext);\n        qemu_spice_destroy_update(&qxl->ssd, update);\n        return;\n    }\n\n    /*\n     * ext->info points into guest-visible memory\n     * pci bar 0, $command.release_info\n     */\n    ring = &qxl->ram->release_ring;\n    SPICE_RING_PROD_ITEM(qxl, ring, item);\n    if (!item) {\n        return;\n    }\n    if (*item == 0) {\n        /* stick head into the ring */\n        id = ext.info->id;\n        ext.info->next = 0;\n        qxl_ram_set_dirty(qxl, &ext.info->next);\n        *item = id;\n        qxl_ring_set_dirty(qxl);\n    } else {\n        /* append item to the list */\n        qxl->last_release->next = ext.info->id;\n        qxl_ram_set_dirty(qxl, &qxl->last_release->next);\n        ext.info->next = 0;\n        qxl_ram_set_dirty(qxl, &ext.info->next);\n    }\n    qxl->last_release = ext.info;\n    qxl->num_free_res++;\n    trace_qxl_ring_res_put(qxl->id, qxl->num_free_res);\n    qxl_push_free_res(qxl, 0);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147298,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void interface_release_resource(QXLInstance *sin,\n                                       QXLReleaseInfoExt ext)\n{\n    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);\n    QXLReleaseRing *ring;\n    uint64_t *item, id;\n\n    if (!ext.info) {\n        return;\n    }\n    if (ext.group_id == MEMSLOT_GROUP_HOST) {\n        /* host group -> vga mode update request */\n        QXLCommandExt *cmdext = (void *)(intptr_t)(ext.info->id);\n        SimpleSpiceUpdate *update;\n        g_assert(cmdext->cmd.type == QXL_CMD_DRAW);\n        update = container_of(cmdext, SimpleSpiceUpdate, ext);\n        qemu_spice_destroy_update(&qxl->ssd, update);\n        return;\n    }\n\n    /*\n     * ext->info points into guest-visible memory\n     * pci bar 0, $command.release_info\n     */\n    ring = &qxl->ram->release_ring;\n    SPICE_RING_PROD_ITEM(qxl, ring, item);\n    if (!item) {\n        return;\n    }\n    if (*item == 0) {\n        /* stick head into the ring */\n        id = ext.info->id;\n        ext.info->next = 0;\n        qxl_ram_set_dirty(qxl, &ext.info->next);\n        *item = id;\n        qxl_ring_set_dirty(qxl);\n    } else {\n        /* append item to the list */\n        qxl->last_release->next = ext.info->id;\n        qxl_ram_set_dirty(qxl, &qxl->last_release->next);\n        ext.info->next = 0;\n        qxl_ram_set_dirty(qxl, &ext.info->next);\n    }\n    qxl->last_release = ext.info;\n    qxl->num_free_res++;\n    trace_qxl_ring_res_put(qxl->id, qxl->num_free_res);\n    qxl_push_free_res(qxl, 0);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147299,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static Image *ReadPANGOImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  cairo_font_options_t\n    *font_options;\n\n  cairo_surface_t\n    *surface;\n\n  char\n    *caption,\n    *property;\n\n  cairo_t\n    *cairo_image;\n\n  const char\n    *option;\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *pixel_info;\n\n  PangoAlignment\n    align;\n\n  PangoContext\n    *context;\n\n  PangoFontDescription\n    *description;\n\n  PangoFontMap\n    *fontmap;\n\n  PangoGravity\n    gravity;\n\n  PangoLayout\n    *layout;\n\n  PangoRectangle\n    extent;\n\n  PixelInfo\n    fill_color;\n\n  RectangleInfo\n    page;\n\n  register unsigned char\n    *p;\n\n  size_t\n    stride;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Initialize Image structure.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  (void) ResetImagePage(image,\"0x0+0+0\");\n  if ((image->columns != 0) && (image->rows != 0))\n    (void) SetImageBackgroundColor(image,exception);\n  /*\n    Format caption.\n  */\n  option=GetImageOption(image_info,\"filename\");\n  if (option == (const char *) NULL)\n    property=InterpretImageProperties((ImageInfo *) image_info,image,\n      image_info->filename,exception);\n  else\n    if (LocaleNCompare(option,\"pango:\",6) == 0)\n      property=InterpretImageProperties((ImageInfo *) image_info,image,option+6,\n        exception);\n    else\n      property=InterpretImageProperties((ImageInfo *) image_info,image,option,\n        exception);\n  (void) SetImageProperty(image,\"caption\",property,exception);\n  property=DestroyString(property);\n  caption=ConstantString(GetImageProperty(image,\"caption\",exception));\n  /*\n    Get context.\n  */\n  fontmap=pango_cairo_font_map_new();\n  pango_cairo_font_map_set_resolution(PANGO_CAIRO_FONT_MAP(fontmap),\n    image->resolution.x == 0.0 ? DefaultSVGDensity : image->resolution.x);\n  font_options=cairo_font_options_create();\n  option=GetImageOption(image_info,\"pango:hinting\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"none\") != 0)\n        cairo_font_options_set_hint_style(font_options,CAIRO_HINT_STYLE_NONE);\n      if (LocaleCompare(option,\"full\") != 0)\n        cairo_font_options_set_hint_style(font_options,CAIRO_HINT_STYLE_FULL);\n    }\n  context=pango_font_map_create_context(fontmap);\n  pango_cairo_context_set_font_options(context,font_options);\n  cairo_font_options_destroy(font_options);\n  option=GetImageOption(image_info,\"pango:language\");\n  if (option != (const char *) NULL)\n    pango_context_set_language(context,pango_language_from_string(option));\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  pango_context_set_base_dir(context,draw_info->direction ==\n    RightToLeftDirection ? PANGO_DIRECTION_RTL : PANGO_DIRECTION_LTR);\n  switch (draw_info->gravity)\n  {\n    case NorthGravity:\n    {\n      gravity=PANGO_GRAVITY_NORTH;\n      break;\n    }\n    case NorthWestGravity:\n    case WestGravity:\n    case SouthWestGravity:\n    {\n      gravity=PANGO_GRAVITY_WEST;\n      break;\n    }\n    case NorthEastGravity:\n    case EastGravity:\n    case SouthEastGravity:\n    {\n      gravity=PANGO_GRAVITY_EAST;\n      break;\n    }\n    case SouthGravity:\n    {\n      gravity=PANGO_GRAVITY_SOUTH;\n      break;\n    }\n    default:\n    {\n      gravity=PANGO_GRAVITY_AUTO;\n      break;\n    }\n  }\n  pango_context_set_base_gravity(context,gravity);\n  option=GetImageOption(image_info,\"pango:gravity-hint\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"line\") == 0)\n        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_LINE);\n      if (LocaleCompare(option,\"natural\") == 0)\n        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_NATURAL);\n      if (LocaleCompare(option,\"strong\") == 0)\n        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_STRONG);\n    }\n  /*\n    Configure layout.\n  */\n  layout=pango_layout_new(context);\n  option=GetImageOption(image_info,\"pango:auto-dir\");\n  if (option != (const char *) NULL)\n    pango_layout_set_auto_dir(layout,1);\n  option=GetImageOption(image_info,\"pango:ellipsize\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"end\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_END);\n      if (LocaleCompare(option,\"middle\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_MIDDLE);\n      if (LocaleCompare(option,\"none\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_NONE);\n      if (LocaleCompare(option,\"start\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_START);\n    }\n  option=GetImageOption(image_info,\"pango:justify\");\n  if (IsStringTrue(option) != MagickFalse)\n    pango_layout_set_justify(layout,1);\n  option=GetImageOption(image_info,\"pango:single-paragraph\");\n  if (IsStringTrue(option) != MagickFalse)\n    pango_layout_set_single_paragraph_mode(layout,1);\n  option=GetImageOption(image_info,\"pango:wrap\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"char\") == 0)\n        pango_layout_set_wrap(layout,PANGO_WRAP_CHAR);\n      if (LocaleCompare(option,\"word\") == 0)\n        pango_layout_set_wrap(layout,PANGO_WRAP_WORD);\n      if (LocaleCompare(option,\"word-char\") == 0)\n        pango_layout_set_wrap(layout,PANGO_WRAP_WORD_CHAR);\n    }\n  option=GetImageOption(image_info,\"pango:indent\");\n  if (option != (const char *) NULL)\n    pango_layout_set_indent(layout,(int) ((StringToLong(option)*\n      (image->resolution.x == 0.0 ? DefaultSVGDensity : image->resolution.x)*\n      PANGO_SCALE+DefaultSVGDensity/2)/DefaultSVGDensity+0.5));\n  switch (draw_info->align)\n  {\n    case CenterAlign: align=PANGO_ALIGN_CENTER; break;\n    case RightAlign: align=PANGO_ALIGN_RIGHT; break;\n    case LeftAlign: align=PANGO_ALIGN_LEFT; break;\n    default:\n    {\n      if (draw_info->gravity == CenterGravity)\n        {\n          align=PANGO_ALIGN_CENTER;\n          break;\n        }\n      align=PANGO_ALIGN_LEFT;\n      break;\n    }\n  }\n  if ((align != PANGO_ALIGN_CENTER) &&\n      (draw_info->direction == RightToLeftDirection))\n    align=(PangoAlignment) (PANGO_ALIGN_LEFT+PANGO_ALIGN_RIGHT-align);\n  option=GetImageOption(image_info,\"pango:align\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"center\") == 0)\n        align=PANGO_ALIGN_CENTER;\n      if (LocaleCompare(option,\"left\") == 0)\n        align=PANGO_ALIGN_LEFT;\n      if (LocaleCompare(option,\"right\") == 0)\n        align=PANGO_ALIGN_RIGHT;\n    }\n  pango_layout_set_alignment(layout,align);\n  if (draw_info->font == (char *) NULL)\n    description=pango_font_description_new();\n  else\n    description=pango_font_description_from_string(draw_info->font);\n  pango_font_description_set_size(description,(int) (PANGO_SCALE*\n    draw_info->pointsize+0.5));\n  pango_layout_set_font_description(layout,description);\n  pango_font_description_free(description);\n  option=GetImageOption(image_info,\"pango:markup\");\n  if ((option != (const char *) NULL) && (IsStringTrue(option) == MagickFalse))\n    pango_layout_set_text(layout,caption,-1);\n  else\n    {\n      GError\n        *error;\n\n      error=(GError *) NULL;\n      if (pango_parse_markup(caption,-1,0,NULL,NULL,NULL,&error) == 0)\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          error->message,\"`%s'\",image_info->filename);\n      pango_layout_set_markup(layout,caption,-1);\n    }\n  pango_layout_context_changed(layout);\n  page.x=0;\n  page.y=0;\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  if (image->columns == 0)\n    {\n      pango_layout_get_extents(layout,NULL,&extent);\n      image->columns=(extent.x+extent.width+PANGO_SCALE/2)/PANGO_SCALE+2*page.x;\n    }\n  else\n    {\n      image->columns-=2*page.x;\n      pango_layout_set_width(layout,(int) ((PANGO_SCALE*image->columns*\n        (image->resolution.x == 0.0 ? DefaultSVGDensity : image->resolution.x)+\n        DefaultSVGDensity/2)/DefaultSVGDensity+0.5));\n    }\n  if (image->rows == 0)\n    {\n      pango_layout_get_extents(layout,NULL,&extent);\n      image->rows=(extent.y+extent.height+PANGO_SCALE/2)/PANGO_SCALE+2*page.y;\n    }\n  else\n    {\n      image->rows-=2*page.y;\n      pango_layout_set_height(layout,(int) ((PANGO_SCALE*image->rows*\n        (image->resolution.y == 0.0 ? DefaultSVGDensity : image->resolution.y)+\n        DefaultSVGDensity/2)/DefaultSVGDensity+0.5));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Render markup.\n  */\n  stride=(size_t) cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32,\n    (int) image->columns);\n  pixel_info=AcquireVirtualMemory(image->rows,stride*sizeof(*pixels));\n  if (pixel_info == (MemoryInfo *) NULL)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      caption=DestroyString(caption);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n  surface=cairo_image_surface_create_for_data(pixels,CAIRO_FORMAT_ARGB32,\n    (int) image->columns,(int) image->rows,(int) stride);\n  cairo_image=cairo_create(surface);\n  cairo_set_operator(cairo_image,CAIRO_OPERATOR_CLEAR);\n  cairo_paint(cairo_image);\n  cairo_set_operator(cairo_image,CAIRO_OPERATOR_OVER);\n  cairo_translate(cairo_image,page.x,page.y);\n  cairo_set_source_rgba(cairo_image,QuantumScale*draw_info->fill.red,\n    QuantumScale*draw_info->fill.green,QuantumScale*draw_info->fill.blue,\n    QuantumScale*draw_info->fill.alpha);\n  pango_cairo_show_layout(cairo_image,layout);\n  cairo_destroy(cairo_image);\n  cairo_surface_destroy(surface);\n  g_object_unref(layout);\n  g_object_unref(fontmap);\n  /*\n    Convert surface to image.\n  */\n  (void) SetImageBackgroundColor(image,exception);\n  p=pixels;\n  GetPixelInfo(image,&fill_color);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *q;\n\n    register ssize_t\n      x;\n\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      fill_color.blue=(double) ScaleCharToQuantum(*p++);\n      fill_color.green=(double) ScaleCharToQuantum(*p++);\n      fill_color.red=(double) ScaleCharToQuantum(*p++);\n      fill_color.alpha=(double) ScaleCharToQuantum(*p++);\n      /*\n        Disassociate alpha.\n      */\n      gamma=QuantumScale*fill_color.alpha;\n      gamma=PerceptibleReciprocal(gamma);\n      fill_color.blue*=gamma;\n      fill_color.green*=gamma;\n      fill_color.red*=gamma;\n      CompositePixelOver(image,&fill_color,fill_color.alpha,q,(double)\n        GetPixelAlpha(image,q),q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n        image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  /*\n    Relinquish resources.\n  */\n  pixel_info=RelinquishVirtualMemory(pixel_info);\n  draw_info=DestroyDrawInfo(draw_info);\n  caption=DestroyString(caption);\n  return(GetFirstImageInList(image));\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147318,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static Image *ReadPANGOImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  cairo_font_options_t\n    *font_options;\n\n  cairo_surface_t\n    *surface;\n\n  char\n    *caption,\n    *property;\n\n  cairo_t\n    *cairo_image;\n\n  const char\n    *option;\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *pixel_info;\n\n  PangoAlignment\n    align;\n\n  PangoContext\n    *context;\n\n  PangoFontDescription\n    *description;\n\n  PangoFontMap\n    *fontmap;\n\n  PangoGravity\n    gravity;\n\n  PangoLayout\n    *layout;\n\n  PangoRectangle\n    extent;\n\n  PixelInfo\n    fill_color;\n\n  RectangleInfo\n    page;\n\n  register unsigned char\n    *p;\n\n  size_t\n    stride;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Initialize Image structure.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  (void) ResetImagePage(image,\"0x0+0+0\");\n  if ((image->columns != 0) && (image->rows != 0))\n    (void) SetImageBackgroundColor(image,exception);\n  /*\n    Format caption.\n  */\n  option=GetImageOption(image_info,\"filename\");\n  if (option == (const char *) NULL)\n    property=InterpretImageProperties((ImageInfo *) image_info,image,\n      image_info->filename,exception);\n  else\n    if (LocaleNCompare(option,\"pango:\",6) == 0)\n      property=InterpretImageProperties((ImageInfo *) image_info,image,option+6,\n        exception);\n    else\n      property=InterpretImageProperties((ImageInfo *) image_info,image,option,\n        exception);\n  if (property != (char *) NULL)\n    {\n      (void) SetImageProperty(image,\"caption\",property,exception);\n      property=DestroyString(property);\n    }\n  caption=ConstantString(GetImageProperty(image,\"caption\",exception));\n  /*\n    Get context.\n  */\n  fontmap=pango_cairo_font_map_new();\n  pango_cairo_font_map_set_resolution(PANGO_CAIRO_FONT_MAP(fontmap),\n    image->resolution.x == 0.0 ? DefaultSVGDensity : image->resolution.x);\n  font_options=cairo_font_options_create();\n  option=GetImageOption(image_info,\"pango:hinting\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"none\") != 0)\n        cairo_font_options_set_hint_style(font_options,CAIRO_HINT_STYLE_NONE);\n      if (LocaleCompare(option,\"full\") != 0)\n        cairo_font_options_set_hint_style(font_options,CAIRO_HINT_STYLE_FULL);\n    }\n  context=pango_font_map_create_context(fontmap);\n  pango_cairo_context_set_font_options(context,font_options);\n  cairo_font_options_destroy(font_options);\n  option=GetImageOption(image_info,\"pango:language\");\n  if (option != (const char *) NULL)\n    pango_context_set_language(context,pango_language_from_string(option));\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  pango_context_set_base_dir(context,draw_info->direction ==\n    RightToLeftDirection ? PANGO_DIRECTION_RTL : PANGO_DIRECTION_LTR);\n  switch (draw_info->gravity)\n  {\n    case NorthGravity:\n    {\n      gravity=PANGO_GRAVITY_NORTH;\n      break;\n    }\n    case NorthWestGravity:\n    case WestGravity:\n    case SouthWestGravity:\n    {\n      gravity=PANGO_GRAVITY_WEST;\n      break;\n    }\n    case NorthEastGravity:\n    case EastGravity:\n    case SouthEastGravity:\n    {\n      gravity=PANGO_GRAVITY_EAST;\n      break;\n    }\n    case SouthGravity:\n    {\n      gravity=PANGO_GRAVITY_SOUTH;\n      break;\n    }\n    default:\n    {\n      gravity=PANGO_GRAVITY_AUTO;\n      break;\n    }\n  }\n  pango_context_set_base_gravity(context,gravity);\n  option=GetImageOption(image_info,\"pango:gravity-hint\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"line\") == 0)\n        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_LINE);\n      if (LocaleCompare(option,\"natural\") == 0)\n        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_NATURAL);\n      if (LocaleCompare(option,\"strong\") == 0)\n        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_STRONG);\n    }\n  /*\n    Configure layout.\n  */\n  layout=pango_layout_new(context);\n  option=GetImageOption(image_info,\"pango:auto-dir\");\n  if (option != (const char *) NULL)\n    pango_layout_set_auto_dir(layout,1);\n  option=GetImageOption(image_info,\"pango:ellipsize\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"end\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_END);\n      if (LocaleCompare(option,\"middle\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_MIDDLE);\n      if (LocaleCompare(option,\"none\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_NONE);\n      if (LocaleCompare(option,\"start\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_START);\n    }\n  option=GetImageOption(image_info,\"pango:justify\");\n  if (IsStringTrue(option) != MagickFalse)\n    pango_layout_set_justify(layout,1);\n  option=GetImageOption(image_info,\"pango:single-paragraph\");\n  if (IsStringTrue(option) != MagickFalse)\n    pango_layout_set_single_paragraph_mode(layout,1);\n  option=GetImageOption(image_info,\"pango:wrap\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"char\") == 0)\n        pango_layout_set_wrap(layout,PANGO_WRAP_CHAR);\n      if (LocaleCompare(option,\"word\") == 0)\n        pango_layout_set_wrap(layout,PANGO_WRAP_WORD);\n      if (LocaleCompare(option,\"word-char\") == 0)\n        pango_layout_set_wrap(layout,PANGO_WRAP_WORD_CHAR);\n    }\n  option=GetImageOption(image_info,\"pango:indent\");\n  if (option != (const char *) NULL)\n    pango_layout_set_indent(layout,(int) ((StringToLong(option)*\n      (image->resolution.x == 0.0 ? DefaultSVGDensity : image->resolution.x)*\n      PANGO_SCALE+DefaultSVGDensity/2)/DefaultSVGDensity+0.5));\n  switch (draw_info->align)\n  {\n    case CenterAlign: align=PANGO_ALIGN_CENTER; break;\n    case RightAlign: align=PANGO_ALIGN_RIGHT; break;\n    case LeftAlign: align=PANGO_ALIGN_LEFT; break;\n    default:\n    {\n      if (draw_info->gravity == CenterGravity)\n        {\n          align=PANGO_ALIGN_CENTER;\n          break;\n        }\n      align=PANGO_ALIGN_LEFT;\n      break;\n    }\n  }\n  if ((align != PANGO_ALIGN_CENTER) &&\n      (draw_info->direction == RightToLeftDirection))\n    align=(PangoAlignment) (PANGO_ALIGN_LEFT+PANGO_ALIGN_RIGHT-align);\n  option=GetImageOption(image_info,\"pango:align\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"center\") == 0)\n        align=PANGO_ALIGN_CENTER;\n      if (LocaleCompare(option,\"left\") == 0)\n        align=PANGO_ALIGN_LEFT;\n      if (LocaleCompare(option,\"right\") == 0)\n        align=PANGO_ALIGN_RIGHT;\n    }\n  pango_layout_set_alignment(layout,align);\n  if (draw_info->font == (char *) NULL)\n    description=pango_font_description_new();\n  else\n    description=pango_font_description_from_string(draw_info->font);\n  pango_font_description_set_size(description,(int) (PANGO_SCALE*\n    draw_info->pointsize+0.5));\n  pango_layout_set_font_description(layout,description);\n  pango_font_description_free(description);\n  option=GetImageOption(image_info,\"pango:markup\");\n  if ((option != (const char *) NULL) && (IsStringTrue(option) == MagickFalse))\n    pango_layout_set_text(layout,caption,-1);\n  else\n    {\n      GError\n        *error;\n\n      error=(GError *) NULL;\n      if (pango_parse_markup(caption,-1,0,NULL,NULL,NULL,&error) == 0)\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          error->message,\"`%s'\",image_info->filename);\n      pango_layout_set_markup(layout,caption,-1);\n    }\n  pango_layout_context_changed(layout);\n  page.x=0;\n  page.y=0;\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  if (image->columns == 0)\n    {\n      pango_layout_get_extents(layout,NULL,&extent);\n      image->columns=(extent.x+extent.width+PANGO_SCALE/2)/PANGO_SCALE+2*page.x;\n    }\n  else\n    {\n      image->columns-=2*page.x;\n      pango_layout_set_width(layout,(int) ((PANGO_SCALE*image->columns*\n        (image->resolution.x == 0.0 ? DefaultSVGDensity : image->resolution.x)+\n        DefaultSVGDensity/2)/DefaultSVGDensity+0.5));\n    }\n  if (image->rows == 0)\n    {\n      pango_layout_get_extents(layout,NULL,&extent);\n      image->rows=(extent.y+extent.height+PANGO_SCALE/2)/PANGO_SCALE+2*page.y;\n    }\n  else\n    {\n      image->rows-=2*page.y;\n      pango_layout_set_height(layout,(int) ((PANGO_SCALE*image->rows*\n        (image->resolution.y == 0.0 ? DefaultSVGDensity : image->resolution.y)+\n        DefaultSVGDensity/2)/DefaultSVGDensity+0.5));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Render markup.\n  */\n  stride=(size_t) cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32,\n    (int) image->columns);\n  pixel_info=AcquireVirtualMemory(image->rows,stride*sizeof(*pixels));\n  if (pixel_info == (MemoryInfo *) NULL)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      caption=DestroyString(caption);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n  surface=cairo_image_surface_create_for_data(pixels,CAIRO_FORMAT_ARGB32,\n    (int) image->columns,(int) image->rows,(int) stride);\n  cairo_image=cairo_create(surface);\n  cairo_set_operator(cairo_image,CAIRO_OPERATOR_CLEAR);\n  cairo_paint(cairo_image);\n  cairo_set_operator(cairo_image,CAIRO_OPERATOR_OVER);\n  cairo_translate(cairo_image,page.x,page.y);\n  cairo_set_source_rgba(cairo_image,QuantumScale*draw_info->fill.red,\n    QuantumScale*draw_info->fill.green,QuantumScale*draw_info->fill.blue,\n    QuantumScale*draw_info->fill.alpha);\n  pango_cairo_show_layout(cairo_image,layout);\n  cairo_destroy(cairo_image);\n  cairo_surface_destroy(surface);\n  g_object_unref(layout);\n  g_object_unref(fontmap);\n  /*\n    Convert surface to image.\n  */\n  (void) SetImageBackgroundColor(image,exception);\n  p=pixels;\n  GetPixelInfo(image,&fill_color);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *q;\n\n    register ssize_t\n      x;\n\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      fill_color.blue=(double) ScaleCharToQuantum(*p++);\n      fill_color.green=(double) ScaleCharToQuantum(*p++);\n      fill_color.red=(double) ScaleCharToQuantum(*p++);\n      fill_color.alpha=(double) ScaleCharToQuantum(*p++);\n      /*\n        Disassociate alpha.\n      */\n      gamma=QuantumScale*fill_color.alpha;\n      gamma=PerceptibleReciprocal(gamma);\n      fill_color.blue*=gamma;\n      fill_color.green*=gamma;\n      fill_color.red*=gamma;\n      CompositePixelOver(image,&fill_color,fill_color.alpha,q,(double)\n        GetPixelAlpha(image,q),q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n        image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  /*\n    Relinquish resources.\n  */\n  pixel_info=RelinquishVirtualMemory(pixel_info);\n  draw_info=DestroyDrawInfo(draw_info);\n  caption=DestroyString(caption);\n  return(GetFirstImageInList(image));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147319,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static Image *ReadVIDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ClientName  \"montage\"\n\n  char\n    **filelist,\n    *label,\n    **list;\n\n  Image\n    *image,\n    *images,\n    *montage_image,\n    *next_image,\n    *thumbnail_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    number_files;\n\n  MagickBooleanType\n    status;\n\n  MontageInfo\n    *montage_info;\n\n  RectangleInfo\n    geometry;\n\n  register ssize_t\n    i;\n\n  /*\n    Expand the filename.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  list=(char **) AcquireMagickMemory(sizeof(*filelist));\n  if (list == (char **) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  list[0]=ConstantString(image_info->filename);\n  filelist=list;\n  number_files=1;\n  status=ExpandFilenames(&number_files,&filelist);\n  list[0]=DestroyString(list[0]);\n  list=(char **) RelinquishMagickMemory(list);\n  if ((status == MagickFalse) || (number_files == 0))\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  image=DestroyImage(image);\n  /*\n    Read each image and convert them to a tile.\n  */\n  images=NewImageList();\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  if (read_info->size == (char *) NULL)\n    (void) CloneString(&read_info->size,DefaultTileGeometry);\n  for (i=0; i < (ssize_t) number_files; i++)\n  {\n    if (image_info->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"name: %s\",\n        filelist[i]);\n    (void) CopyMagickString(read_info->filename,filelist[i],MagickPathExtent);\n    filelist[i]=DestroyString(filelist[i]);\n    *read_info->magick='\\0';\n    next_image=ReadImage(read_info,exception);\n    CatchException(exception);\n    if (next_image == (Image *) NULL)\n      break;\n    label=InterpretImageProperties((ImageInfo *) image_info,next_image,\n      DefaultTileLabel,exception);\n    (void) SetImageProperty(next_image,\"label\",label,exception);\n    label=DestroyString(label);\n    if (image_info->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"geometry: %.20gx%.20g\",(double) next_image->columns,(double)\n        next_image->rows);\n    SetGeometry(next_image,&geometry);\n    (void) ParseMetaGeometry(read_info->size,&geometry.x,&geometry.y,\n      &geometry.width,&geometry.height);\n    thumbnail_image=ThumbnailImage(next_image,geometry.width,geometry.height,\n      exception);\n    if (thumbnail_image != (Image *) NULL)\n      {\n        next_image=DestroyImage(next_image);\n        next_image=thumbnail_image;\n      }\n    if (image_info->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"thumbnail geometry: %.20gx%.20g\",(double) next_image->columns,(double)\n        next_image->rows);\n    AppendImageToList(&images,next_image);\n    status=SetImageProgress(images,LoadImagesTag,i,number_files);\n    if (status == MagickFalse)\n      break;\n  }\n  read_info=DestroyImageInfo(read_info);\n  filelist=(char **) RelinquishMagickMemory(filelist);\n  if (images == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\n      \"ImageFileDoesNotContainAnyImageData\");\n  /*\n    Create the visual image directory.\n  */\n  montage_info=CloneMontageInfo(image_info,(MontageInfo *) NULL);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"creating montage\");\n  montage_image=MontageImageList(image_info,montage_info,\n    GetFirstImageInList(images),exception);\n  montage_info=DestroyMontageInfo(montage_info);\n  images=DestroyImageList(images);\n  return(montage_image);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147320,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static Image *ReadVIDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ClientName  \"montage\"\n\n  char\n    **filelist,\n    *label,\n    **list;\n\n  Image\n    *image,\n    *images,\n    *montage_image,\n    *next_image,\n    *thumbnail_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    number_files;\n\n  MagickBooleanType\n    status;\n\n  MontageInfo\n    *montage_info;\n\n  RectangleInfo\n    geometry;\n\n  register ssize_t\n    i;\n\n  /*\n    Expand the filename.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  list=(char **) AcquireMagickMemory(sizeof(*filelist));\n  if (list == (char **) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  list[0]=ConstantString(image_info->filename);\n  filelist=list;\n  number_files=1;\n  status=ExpandFilenames(&number_files,&filelist);\n  list[0]=DestroyString(list[0]);\n  list=(char **) RelinquishMagickMemory(list);\n  if ((status == MagickFalse) || (number_files == 0))\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  image=DestroyImage(image);\n  /*\n    Read each image and convert them to a tile.\n  */\n  images=NewImageList();\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  if (read_info->size == (char *) NULL)\n    (void) CloneString(&read_info->size,DefaultTileGeometry);\n  for (i=0; i < (ssize_t) number_files; i++)\n  {\n    if (image_info->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"name: %s\",\n        filelist[i]);\n    (void) CopyMagickString(read_info->filename,filelist[i],MagickPathExtent);\n    filelist[i]=DestroyString(filelist[i]);\n    *read_info->magick='\\0';\n    next_image=ReadImage(read_info,exception);\n    CatchException(exception);\n    if (next_image == (Image *) NULL)\n      break;\n    label=InterpretImageProperties((ImageInfo *) image_info,next_image,\n      DefaultTileLabel,exception);\n    if (label != (char *) NULL)\n      {\n        (void) SetImageProperty(next_image,\"label\",label,exception);\n        label=DestroyString(label);\n      }\n    if (image_info->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"geometry: %.20gx%.20g\",(double) next_image->columns,(double)\n        next_image->rows);\n    SetGeometry(next_image,&geometry);\n    (void) ParseMetaGeometry(read_info->size,&geometry.x,&geometry.y,\n      &geometry.width,&geometry.height);\n    thumbnail_image=ThumbnailImage(next_image,geometry.width,geometry.height,\n      exception);\n    if (thumbnail_image != (Image *) NULL)\n      {\n        next_image=DestroyImage(next_image);\n        next_image=thumbnail_image;\n      }\n    if (image_info->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"thumbnail geometry: %.20gx%.20g\",(double) next_image->columns,(double)\n        next_image->rows);\n    AppendImageToList(&images,next_image);\n    status=SetImageProgress(images,LoadImagesTag,i,number_files);\n    if (status == MagickFalse)\n      break;\n  }\n  read_info=DestroyImageInfo(read_info);\n  filelist=(char **) RelinquishMagickMemory(filelist);\n  if (images == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\n      \"ImageFileDoesNotContainAnyImageData\");\n  /*\n    Create the visual image directory.\n  */\n  montage_info=CloneMontageInfo(image_info,(MontageInfo *) NULL);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"creating montage\");\n  montage_image=MontageImageList(image_info,montage_info,\n    GetFirstImageInList(images),exception);\n  montage_info=DestroyMontageInfo(montage_info);\n  images=DestroyImageList(images);\n  return(montage_image);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147321,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static struct clk ** __init sunxi_divs_clk_setup(struct device_node *node,\n\t\t\t\t\t\t const struct divs_data *data)\n{\n\tstruct clk_onecell_data *clk_data;\n\tconst char *parent;\n\tconst char *clk_name;\n\tstruct clk **clks, *pclk;\n\tstruct clk_hw *gate_hw, *rate_hw;\n\tconst struct clk_ops *rate_ops;\n\tstruct clk_gate *gate = NULL;\n\tstruct clk_fixed_factor *fix_factor;\n\tstruct clk_divider *divider;\n\tstruct factors_data factors = *data->factors;\n\tchar *derived_name = NULL;\n\tvoid __iomem *reg;\n\tint ndivs = SUNXI_DIVS_MAX_QTY, i = 0;\n\tint flags, clkflags;\n\n\t/* if number of children known, use it */\n\tif (data->ndivs)\n\t\tndivs = data->ndivs;\n\n\t/* Try to find a name for base factor clock */\n\tfor (i = 0; i < ndivs; i++) {\n\t\tif (data->div[i].self) {\n\t\t\tof_property_read_string_index(node, \"clock-output-names\",\n\t\t\t\t\t\t      i, &factors.name);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* If we don't have a .self clk use the first output-name up to '_' */\n\tif (factors.name == NULL) {\n\t\tchar *endp;\n\n\t\tof_property_read_string_index(node, \"clock-output-names\",\n\t\t\t\t\t\t      0, &clk_name);\n\t\tendp = strchr(clk_name, '_');\n\t\tif (endp) {\n\t\t\tderived_name = kstrndup(clk_name, endp - clk_name,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tfactors.name = derived_name;\n\t\t} else {\n\t\t\tfactors.name = clk_name;\n\t\t}\n\t}\n\n\t/* Set up factor clock that we will be dividing */\n\tpclk = sunxi_factors_clk_setup(node, &factors);\n\tif (!pclk)\n\t\treturn NULL;\n\n\tparent = __clk_get_name(pclk);\n\tkfree(derived_name);\n\n\treg = of_iomap(node, 0);\n\tif (!reg) {\n\t\tpr_err(\"Could not map registers for divs-clk: %pOF\\n\", node);\n\t\treturn NULL;\n\t}\n\n\tclk_data = kmalloc(sizeof(struct clk_onecell_data), GFP_KERNEL);\n\tif (!clk_data)\n\t\tgoto out_unmap;\n\n\tclks = kcalloc(ndivs, sizeof(*clks), GFP_KERNEL);\n\tif (!clks)\n\t\tgoto free_clkdata;\n\n\tclk_data->clks = clks;\n\n\t/* It's not a good idea to have automatic reparenting changing\n\t * our RAM clock! */\n\tclkflags = !strcmp(\"pll5\", parent) ? 0 : CLK_SET_RATE_PARENT;\n\n\tfor (i = 0; i < ndivs; i++) {\n\t\tif (of_property_read_string_index(node, \"clock-output-names\",\n\t\t\t\t\t\t  i, &clk_name) != 0)\n\t\t\tbreak;\n\n\t\t/* If this is the base factor clock, only update clks */\n\t\tif (data->div[i].self) {\n\t\t\tclk_data->clks[i] = pclk;\n\t\t\tcontinue;\n\t\t}\n\n\t\tgate_hw = NULL;\n\t\trate_hw = NULL;\n\t\trate_ops = NULL;\n\n\t\t/* If this leaf clock can be gated, create a gate */\n\t\tif (data->div[i].gate) {\n\t\t\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\t\t\tif (!gate)\n\t\t\t\tgoto free_clks;\n\n\t\t\tgate->reg = reg;\n\t\t\tgate->bit_idx = data->div[i].gate;\n\t\t\tgate->lock = &clk_lock;\n\n\t\t\tgate_hw = &gate->hw;\n\t\t}\n\n\t\t/* Leaves can be fixed or configurable divisors */\n\t\tif (data->div[i].fixed) {\n\t\t\tfix_factor = kzalloc(sizeof(*fix_factor), GFP_KERNEL);\n\t\t\tif (!fix_factor)\n\t\t\t\tgoto free_gate;\n\n\t\t\tfix_factor->mult = 1;\n\t\t\tfix_factor->div = data->div[i].fixed;\n\n\t\t\trate_hw = &fix_factor->hw;\n\t\t\trate_ops = &clk_fixed_factor_ops;\n\t\t} else {\n\t\t\tdivider = kzalloc(sizeof(*divider), GFP_KERNEL);\n\t\t\tif (!divider)\n\t\t\t\tgoto free_gate;\n\n\t\t\tflags = data->div[i].pow ? CLK_DIVIDER_POWER_OF_TWO : 0;\n\n\t\t\tdivider->reg = reg;\n\t\t\tdivider->shift = data->div[i].shift;\n\t\t\tdivider->width = SUNXI_DIVISOR_WIDTH;\n\t\t\tdivider->flags = flags;\n\t\t\tdivider->lock = &clk_lock;\n\t\t\tdivider->table = data->div[i].table;\n\n\t\t\trate_hw = &divider->hw;\n\t\t\trate_ops = &clk_divider_ops;\n\t\t}\n\n\t\t/* Wrap the (potential) gate and the divisor on a composite\n\t\t * clock to unify them */\n\t\tclks[i] = clk_register_composite(NULL, clk_name, &parent, 1,\n\t\t\t\t\t\t NULL, NULL,\n\t\t\t\t\t\t rate_hw, rate_ops,\n\t\t\t\t\t\t gate_hw, &clk_gate_ops,\n\t\t\t\t\t\t clkflags |\n\t\t\t\t\t\t data->div[i].critical ?\n\t\t\t\t\t\t\tCLK_IS_CRITICAL : 0);\n\n\t\tWARN_ON(IS_ERR(clk_data->clks[i]));\n\t}\n\n\t/* Adjust to the real max */\n\tclk_data->clk_num = i;\n\n\tif (of_clk_add_provider(node, of_clk_src_onecell_get, clk_data)) {\n\t\tpr_err(\"%s: failed to add clock provider for %s\\n\",\n\t\t       __func__, clk_name);\n\t\tgoto free_gate;\n\t}\n\n\treturn clks;\nfree_gate:\n\tkfree(gate);\nfree_clks:\n\tkfree(clks);\nfree_clkdata:\n\tkfree(clk_data);\nout_unmap:\n\tiounmap(reg);\n\treturn NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147460,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static struct clk ** __init sunxi_divs_clk_setup(struct device_node *node,\n\t\t\t\t\t\t const struct divs_data *data)\n{\n\tstruct clk_onecell_data *clk_data;\n\tconst char *parent;\n\tconst char *clk_name;\n\tstruct clk **clks, *pclk;\n\tstruct clk_hw *gate_hw, *rate_hw;\n\tconst struct clk_ops *rate_ops;\n\tstruct clk_gate *gate = NULL;\n\tstruct clk_fixed_factor *fix_factor;\n\tstruct clk_divider *divider;\n\tstruct factors_data factors = *data->factors;\n\tchar *derived_name = NULL;\n\tvoid __iomem *reg;\n\tint ndivs = SUNXI_DIVS_MAX_QTY, i = 0;\n\tint flags, clkflags;\n\n\t/* if number of children known, use it */\n\tif (data->ndivs)\n\t\tndivs = data->ndivs;\n\n\t/* Try to find a name for base factor clock */\n\tfor (i = 0; i < ndivs; i++) {\n\t\tif (data->div[i].self) {\n\t\t\tof_property_read_string_index(node, \"clock-output-names\",\n\t\t\t\t\t\t      i, &factors.name);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* If we don't have a .self clk use the first output-name up to '_' */\n\tif (factors.name == NULL) {\n\t\tchar *endp;\n\n\t\tof_property_read_string_index(node, \"clock-output-names\",\n\t\t\t\t\t\t      0, &clk_name);\n\t\tendp = strchr(clk_name, '_');\n\t\tif (endp) {\n\t\t\tderived_name = kstrndup(clk_name, endp - clk_name,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!derived_name)\n\t\t\t\treturn NULL;\n\t\t\tfactors.name = derived_name;\n\t\t} else {\n\t\t\tfactors.name = clk_name;\n\t\t}\n\t}\n\n\t/* Set up factor clock that we will be dividing */\n\tpclk = sunxi_factors_clk_setup(node, &factors);\n\tif (!pclk)\n\t\treturn NULL;\n\n\tparent = __clk_get_name(pclk);\n\tkfree(derived_name);\n\n\treg = of_iomap(node, 0);\n\tif (!reg) {\n\t\tpr_err(\"Could not map registers for divs-clk: %pOF\\n\", node);\n\t\treturn NULL;\n\t}\n\n\tclk_data = kmalloc(sizeof(struct clk_onecell_data), GFP_KERNEL);\n\tif (!clk_data)\n\t\tgoto out_unmap;\n\n\tclks = kcalloc(ndivs, sizeof(*clks), GFP_KERNEL);\n\tif (!clks)\n\t\tgoto free_clkdata;\n\n\tclk_data->clks = clks;\n\n\t/* It's not a good idea to have automatic reparenting changing\n\t * our RAM clock! */\n\tclkflags = !strcmp(\"pll5\", parent) ? 0 : CLK_SET_RATE_PARENT;\n\n\tfor (i = 0; i < ndivs; i++) {\n\t\tif (of_property_read_string_index(node, \"clock-output-names\",\n\t\t\t\t\t\t  i, &clk_name) != 0)\n\t\t\tbreak;\n\n\t\t/* If this is the base factor clock, only update clks */\n\t\tif (data->div[i].self) {\n\t\t\tclk_data->clks[i] = pclk;\n\t\t\tcontinue;\n\t\t}\n\n\t\tgate_hw = NULL;\n\t\trate_hw = NULL;\n\t\trate_ops = NULL;\n\n\t\t/* If this leaf clock can be gated, create a gate */\n\t\tif (data->div[i].gate) {\n\t\t\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\t\t\tif (!gate)\n\t\t\t\tgoto free_clks;\n\n\t\t\tgate->reg = reg;\n\t\t\tgate->bit_idx = data->div[i].gate;\n\t\t\tgate->lock = &clk_lock;\n\n\t\t\tgate_hw = &gate->hw;\n\t\t}\n\n\t\t/* Leaves can be fixed or configurable divisors */\n\t\tif (data->div[i].fixed) {\n\t\t\tfix_factor = kzalloc(sizeof(*fix_factor), GFP_KERNEL);\n\t\t\tif (!fix_factor)\n\t\t\t\tgoto free_gate;\n\n\t\t\tfix_factor->mult = 1;\n\t\t\tfix_factor->div = data->div[i].fixed;\n\n\t\t\trate_hw = &fix_factor->hw;\n\t\t\trate_ops = &clk_fixed_factor_ops;\n\t\t} else {\n\t\t\tdivider = kzalloc(sizeof(*divider), GFP_KERNEL);\n\t\t\tif (!divider)\n\t\t\t\tgoto free_gate;\n\n\t\t\tflags = data->div[i].pow ? CLK_DIVIDER_POWER_OF_TWO : 0;\n\n\t\t\tdivider->reg = reg;\n\t\t\tdivider->shift = data->div[i].shift;\n\t\t\tdivider->width = SUNXI_DIVISOR_WIDTH;\n\t\t\tdivider->flags = flags;\n\t\t\tdivider->lock = &clk_lock;\n\t\t\tdivider->table = data->div[i].table;\n\n\t\t\trate_hw = &divider->hw;\n\t\t\trate_ops = &clk_divider_ops;\n\t\t}\n\n\t\t/* Wrap the (potential) gate and the divisor on a composite\n\t\t * clock to unify them */\n\t\tclks[i] = clk_register_composite(NULL, clk_name, &parent, 1,\n\t\t\t\t\t\t NULL, NULL,\n\t\t\t\t\t\t rate_hw, rate_ops,\n\t\t\t\t\t\t gate_hw, &clk_gate_ops,\n\t\t\t\t\t\t clkflags |\n\t\t\t\t\t\t data->div[i].critical ?\n\t\t\t\t\t\t\tCLK_IS_CRITICAL : 0);\n\n\t\tWARN_ON(IS_ERR(clk_data->clks[i]));\n\t}\n\n\t/* Adjust to the real max */\n\tclk_data->clk_num = i;\n\n\tif (of_clk_add_provider(node, of_clk_src_onecell_get, clk_data)) {\n\t\tpr_err(\"%s: failed to add clock provider for %s\\n\",\n\t\t       __func__, clk_name);\n\t\tgoto free_gate;\n\t}\n\n\treturn clks;\nfree_gate:\n\tkfree(gate);\nfree_clks:\n\tkfree(clks);\nfree_clkdata:\n\tkfree(clk_data);\nout_unmap:\n\tiounmap(reg);\n\treturn NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147461,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void tw5864_handle_frame(struct tw5864_h264_frame *frame)\n{\n#define SKIP_VLCBUF_BYTES 3\n\tstruct tw5864_input *input = frame->input;\n\tstruct tw5864_dev *dev = input->root;\n\tstruct tw5864_buf *vb;\n\tstruct vb2_v4l2_buffer *v4l2_buf;\n\tint frame_len = frame->vlc_len - SKIP_VLCBUF_BYTES;\n\tu8 *dst = input->buf_cur_ptr;\n\tu8 tail_mask, vlc_mask = 0;\n\tint i;\n\tu8 vlc_first_byte = ((u8 *)(frame->vlc.addr + SKIP_VLCBUF_BYTES))[0];\n\tunsigned long flags;\n\tint zero_run;\n\tu8 *src;\n\tu8 *src_end;\n\n#ifdef DEBUG\n\tif (frame->checksum !=\n\t    tw5864_vlc_checksum((u32 *)frame->vlc.addr, frame_len))\n\t\tdev_err(&dev->pci->dev,\n\t\t\t\"Checksum of encoded frame doesn't match!\\n\");\n#endif\n\n\tspin_lock_irqsave(&input->slock, flags);\n\tvb = input->vb;\n\tinput->vb = NULL;\n\tspin_unlock_irqrestore(&input->slock, flags);\n\n\tv4l2_buf = to_vb2_v4l2_buffer(&vb->vb.vb2_buf);\n\n\tif (!vb) { /* Gone because of disabling */\n\t\tdev_dbg(&dev->pci->dev, \"vb is empty, dropping frame\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Check for space.\n\t * Mind the overhead of startcode emulation prevention.\n\t */\n\tif (input->buf_cur_space_left < frame_len * 5 / 4) {\n\t\tdev_err_once(&dev->pci->dev,\n\t\t\t     \"Left space in vb2 buffer, %d bytes, is less than considered safely enough to put frame of length %d. Dropping this frame.\\n\",\n\t\t\t     input->buf_cur_space_left, frame_len);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 8 - input->tail_nb_bits; i++)\n\t\tvlc_mask |= 1 << i;\n\ttail_mask = (~vlc_mask) & 0xff;\n\n\tdst[0] = (input->tail & tail_mask) | (vlc_first_byte & vlc_mask);\n\tframe_len--;\n\tdst++;\n\n\t/* H.264 startcode emulation prevention */\n\tsrc = frame->vlc.addr + SKIP_VLCBUF_BYTES + 1;\n\tsrc_end = src + frame_len;\n\tzero_run = 0;\n\tfor (; src < src_end; src++) {\n\t\tif (zero_run < 2) {\n\t\t\tif (*src == 0)\n\t\t\t\t++zero_run;\n\t\t\telse\n\t\t\t\tzero_run = 0;\n\t\t} else {\n\t\t\tif ((*src & ~0x03) == 0)\n\t\t\t\t*dst++ = 0x03;\n\t\t\tzero_run = *src == 0;\n\t\t}\n\t\t*dst++ = *src;\n\t}\n\n\tvb2_set_plane_payload(&vb->vb.vb2_buf, 0,\n\t\t\t      dst - (u8 *)vb2_plane_vaddr(&vb->vb.vb2_buf, 0));\n\n\tvb->vb.vb2_buf.timestamp = frame->timestamp;\n\tv4l2_buf->field = V4L2_FIELD_INTERLACED;\n\tv4l2_buf->sequence = frame->seqno;\n\n\t/* Check for motion flags */\n\tif (frame->gop_seqno /* P-frame */ &&\n\t    tw5864_is_motion_triggered(frame)) {\n\t\tstruct v4l2_event ev = {\n\t\t\t.type = V4L2_EVENT_MOTION_DET,\n\t\t\t.u.motion_det = {\n\t\t\t\t.flags = V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ,\n\t\t\t\t.frame_sequence = v4l2_buf->sequence,\n\t\t\t},\n\t\t};\n\n\t\tv4l2_event_queue(&input->vdev, &ev);\n\t}\n\n\tvb2_buffer_done(&vb->vb.vb2_buf, VB2_BUF_STATE_DONE);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147478,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void tw5864_handle_frame(struct tw5864_h264_frame *frame)\n{\n#define SKIP_VLCBUF_BYTES 3\n\tstruct tw5864_input *input = frame->input;\n\tstruct tw5864_dev *dev = input->root;\n\tstruct tw5864_buf *vb;\n\tstruct vb2_v4l2_buffer *v4l2_buf;\n\tint frame_len = frame->vlc_len - SKIP_VLCBUF_BYTES;\n\tu8 *dst = input->buf_cur_ptr;\n\tu8 tail_mask, vlc_mask = 0;\n\tint i;\n\tu8 vlc_first_byte = ((u8 *)(frame->vlc.addr + SKIP_VLCBUF_BYTES))[0];\n\tunsigned long flags;\n\tint zero_run;\n\tu8 *src;\n\tu8 *src_end;\n\n#ifdef DEBUG\n\tif (frame->checksum !=\n\t    tw5864_vlc_checksum((u32 *)frame->vlc.addr, frame_len))\n\t\tdev_err(&dev->pci->dev,\n\t\t\t\"Checksum of encoded frame doesn't match!\\n\");\n#endif\n\n\tspin_lock_irqsave(&input->slock, flags);\n\tvb = input->vb;\n\tinput->vb = NULL;\n\tspin_unlock_irqrestore(&input->slock, flags);\n\n\tif (!vb) { /* Gone because of disabling */\n\t\tdev_dbg(&dev->pci->dev, \"vb is empty, dropping frame\\n\");\n\t\treturn;\n\t}\n\n\tv4l2_buf = to_vb2_v4l2_buffer(&vb->vb.vb2_buf);\n\n\t/*\n\t * Check for space.\n\t * Mind the overhead of startcode emulation prevention.\n\t */\n\tif (input->buf_cur_space_left < frame_len * 5 / 4) {\n\t\tdev_err_once(&dev->pci->dev,\n\t\t\t     \"Left space in vb2 buffer, %d bytes, is less than considered safely enough to put frame of length %d. Dropping this frame.\\n\",\n\t\t\t     input->buf_cur_space_left, frame_len);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 8 - input->tail_nb_bits; i++)\n\t\tvlc_mask |= 1 << i;\n\ttail_mask = (~vlc_mask) & 0xff;\n\n\tdst[0] = (input->tail & tail_mask) | (vlc_first_byte & vlc_mask);\n\tframe_len--;\n\tdst++;\n\n\t/* H.264 startcode emulation prevention */\n\tsrc = frame->vlc.addr + SKIP_VLCBUF_BYTES + 1;\n\tsrc_end = src + frame_len;\n\tzero_run = 0;\n\tfor (; src < src_end; src++) {\n\t\tif (zero_run < 2) {\n\t\t\tif (*src == 0)\n\t\t\t\t++zero_run;\n\t\t\telse\n\t\t\t\tzero_run = 0;\n\t\t} else {\n\t\t\tif ((*src & ~0x03) == 0)\n\t\t\t\t*dst++ = 0x03;\n\t\t\tzero_run = *src == 0;\n\t\t}\n\t\t*dst++ = *src;\n\t}\n\n\tvb2_set_plane_payload(&vb->vb.vb2_buf, 0,\n\t\t\t      dst - (u8 *)vb2_plane_vaddr(&vb->vb.vb2_buf, 0));\n\n\tvb->vb.vb2_buf.timestamp = frame->timestamp;\n\tv4l2_buf->field = V4L2_FIELD_INTERLACED;\n\tv4l2_buf->sequence = frame->seqno;\n\n\t/* Check for motion flags */\n\tif (frame->gop_seqno /* P-frame */ &&\n\t    tw5864_is_motion_triggered(frame)) {\n\t\tstruct v4l2_event ev = {\n\t\t\t.type = V4L2_EVENT_MOTION_DET,\n\t\t\t.u.motion_det = {\n\t\t\t\t.flags = V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ,\n\t\t\t\t.frame_sequence = v4l2_buf->sequence,\n\t\t\t},\n\t\t};\n\n\t\tv4l2_event_queue(&input->vdev, &ev);\n\t}\n\n\tvb2_buffer_done(&vb->vb.vb2_buf, VB2_BUF_STATE_DONE);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147479,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tint mmu_reset_needed = 0;\n\tint i, pending_vec, max_bits;\n\tstruct descriptor_table dt;\n\n\tvcpu_load(vcpu);\n\n\tdt.limit = sregs->idt.limit;\n\tdt.base = sregs->idt.base;\n\tkvm_x86_ops->set_idt(vcpu, &dt);\n\tdt.limit = sregs->gdt.limit;\n\tdt.base = sregs->gdt.base;\n\tkvm_x86_ops->set_gdt(vcpu, &dt);\n\n\tvcpu->arch.cr2 = sregs->cr2;\n\tmmu_reset_needed |= vcpu->arch.cr3 != sregs->cr3;\n\tvcpu->arch.cr3 = sregs->cr3;\n\n\tkvm_set_cr8(vcpu, sregs->cr8);\n\n\tmmu_reset_needed |= vcpu->arch.shadow_efer != sregs->efer;\n\tkvm_x86_ops->set_efer(vcpu, sregs->efer);\n\tkvm_set_apic_base(vcpu, sregs->apic_base);\n\n\tkvm_x86_ops->decache_cr4_guest_bits(vcpu);\n\n\tmmu_reset_needed |= vcpu->arch.cr0 != sregs->cr0;\n\tkvm_x86_ops->set_cr0(vcpu, sregs->cr0);\n\tvcpu->arch.cr0 = sregs->cr0;\n\n\tmmu_reset_needed |= vcpu->arch.cr4 != sregs->cr4;\n\tkvm_x86_ops->set_cr4(vcpu, sregs->cr4);\n\tif (!is_long_mode(vcpu) && is_pae(vcpu))\n\t\tload_pdptrs(vcpu, vcpu->arch.cr3);\n\n\tif (mmu_reset_needed)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif (!irqchip_in_kernel(vcpu->kvm)) {\n\t\tmemcpy(vcpu->arch.irq_pending, sregs->interrupt_bitmap,\n\t\t       sizeof vcpu->arch.irq_pending);\n\t\tvcpu->arch.irq_summary = 0;\n\t\tfor (i = 0; i < ARRAY_SIZE(vcpu->arch.irq_pending); ++i)\n\t\t\tif (vcpu->arch.irq_pending[i])\n\t\t\t\t__set_bit(i, &vcpu->arch.irq_summary);\n\t} else {\n\t\tmax_bits = (sizeof sregs->interrupt_bitmap) << 3;\n\t\tpending_vec = find_first_bit(\n\t\t\t(const unsigned long *)sregs->interrupt_bitmap,\n\t\t\tmax_bits);\n\t\t/* Only pending external irq is handled here */\n\t\tif (pending_vec < max_bits) {\n\t\t\tkvm_x86_ops->set_irq(vcpu, pending_vec);\n\t\t\tpr_debug(\"Set back pending irq %d\\n\",\n\t\t\t\t pending_vec);\n\t\t}\n\t\tkvm_pic_clear_isr_ack(vcpu->kvm);\n\t}\n\n\tkvm_set_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_set_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_set_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_set_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_set_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_set_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_set_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_set_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\t/* Older userspace won't unhalt the vcpu on reset. */\n\tif (vcpu->vcpu_id == 0 && kvm_rip_read(vcpu) == 0xfff0 &&\n\t    sregs->cs.selector == 0xf000 && sregs->cs.base == 0xffff0000 &&\n\t    !(vcpu->arch.cr0 & X86_CR0_PE))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\n\tvcpu_put(vcpu);\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147542,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tint mmu_reset_needed = 0;\n\tint i, pending_vec, max_bits;\n\tstruct descriptor_table dt;\n\n\tvcpu_load(vcpu);\n\n\tdt.limit = sregs->idt.limit;\n\tdt.base = sregs->idt.base;\n\tkvm_x86_ops->set_idt(vcpu, &dt);\n\tdt.limit = sregs->gdt.limit;\n\tdt.base = sregs->gdt.base;\n\tkvm_x86_ops->set_gdt(vcpu, &dt);\n\n\tvcpu->arch.cr2 = sregs->cr2;\n\tmmu_reset_needed |= vcpu->arch.cr3 != sregs->cr3;\n\n\tdown_read(&vcpu->kvm->slots_lock);\n\tif (gfn_to_memslot(vcpu->kvm, sregs->cr3 >> PAGE_SHIFT))\n\t\tvcpu->arch.cr3 = sregs->cr3;\n\telse\n\t\tset_bit(KVM_REQ_TRIPLE_FAULT, &vcpu->requests);\n\tup_read(&vcpu->kvm->slots_lock);\n\n\tkvm_set_cr8(vcpu, sregs->cr8);\n\n\tmmu_reset_needed |= vcpu->arch.shadow_efer != sregs->efer;\n\tkvm_x86_ops->set_efer(vcpu, sregs->efer);\n\tkvm_set_apic_base(vcpu, sregs->apic_base);\n\n\tkvm_x86_ops->decache_cr4_guest_bits(vcpu);\n\n\tmmu_reset_needed |= vcpu->arch.cr0 != sregs->cr0;\n\tkvm_x86_ops->set_cr0(vcpu, sregs->cr0);\n\tvcpu->arch.cr0 = sregs->cr0;\n\n\tmmu_reset_needed |= vcpu->arch.cr4 != sregs->cr4;\n\tkvm_x86_ops->set_cr4(vcpu, sregs->cr4);\n\tif (!is_long_mode(vcpu) && is_pae(vcpu))\n\t\tload_pdptrs(vcpu, vcpu->arch.cr3);\n\n\tif (mmu_reset_needed)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif (!irqchip_in_kernel(vcpu->kvm)) {\n\t\tmemcpy(vcpu->arch.irq_pending, sregs->interrupt_bitmap,\n\t\t       sizeof vcpu->arch.irq_pending);\n\t\tvcpu->arch.irq_summary = 0;\n\t\tfor (i = 0; i < ARRAY_SIZE(vcpu->arch.irq_pending); ++i)\n\t\t\tif (vcpu->arch.irq_pending[i])\n\t\t\t\t__set_bit(i, &vcpu->arch.irq_summary);\n\t} else {\n\t\tmax_bits = (sizeof sregs->interrupt_bitmap) << 3;\n\t\tpending_vec = find_first_bit(\n\t\t\t(const unsigned long *)sregs->interrupt_bitmap,\n\t\t\tmax_bits);\n\t\t/* Only pending external irq is handled here */\n\t\tif (pending_vec < max_bits) {\n\t\t\tkvm_x86_ops->set_irq(vcpu, pending_vec);\n\t\t\tpr_debug(\"Set back pending irq %d\\n\",\n\t\t\t\t pending_vec);\n\t\t}\n\t\tkvm_pic_clear_isr_ack(vcpu->kvm);\n\t}\n\n\tkvm_set_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_set_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_set_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_set_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_set_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_set_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_set_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_set_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\t/* Older userspace won't unhalt the vcpu on reset. */\n\tif (vcpu->vcpu_id == 0 && kvm_rip_read(vcpu) == 0xfff0 &&\n\t    sregs->cs.selector == 0xf000 && sregs->cs.base == 0xffff0000 &&\n\t    !(vcpu->arch.cr0 & X86_CR0_PE))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\n\tvcpu_put(vcpu);\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147543,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int udp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\tsize_t len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct udp_sock *up = udp_sk(sk);\n\tint ulen = len;\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = NULL;\n\tint free = 0;\n\tint connected = 0;\n\t__be32 daddr, faddr, saddr;\n\t__be16 dport;\n\tu8  tos;\n\tint err;\n\tint corkreq = up->corkflag || msg->msg_flags&MSG_MORE;\n\n\tif (len > 0xFFFF)\n\t\treturn -EMSGSIZE;\n\n\t/* \n\t *\tCheck the flags.\n\t */\n\n\tif (msg->msg_flags&MSG_OOB)\t/* Mirror BSD error message compatibility */\n\t\treturn -EOPNOTSUPP;\n\n\tipc.opt = NULL;\n\n\tif (up->pending) {\n\t\t/*\n\t\t * There are pending frames.\n\t \t * The socket lock must be held while it's corked.\n\t\t */\n\t\tlock_sock(sk);\n\t\tif (likely(up->pending)) {\n\t\t\tif (unlikely(up->pending != AF_INET)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n \t\t\tgoto do_append_data;\n\t\t}\n\t\trelease_sock(sk);\n\t}\n\tulen += sizeof(struct udphdr);\n\n\t/*\n\t *\tGet and verify the address. \n\t */\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_in * usin = (struct sockaddr_in*)msg->msg_name;\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\treturn -EINVAL;\n\t\tif (usin->sin_family != AF_INET) {\n\t\t\tif (usin->sin_family != AF_UNSPEC)\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\tdport = usin->sin_port;\n\t\tif (dport == 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdaddr = inet->daddr;\n\t\tdport = inet->dport;\n\t\t/* Open fast path for connected socket.\n\t\t   Route will not be used, if at least one option is set.\n\t\t */\n\t\tconnected = 1;\n  \t}\n\tipc.addr = inet->saddr;\n\n\tipc.oif = sk->sk_bound_dev_if;\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(msg, &ipc);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (ipc.opt)\n\t\t\tfree = 1;\n\t\tconnected = 0;\n\t}\n\tif (!ipc.opt)\n\t\tipc.opt = inet->opt;\n\n\tsaddr = ipc.addr;\n\tipc.addr = faddr = daddr;\n\n\tif (ipc.opt && ipc.opt->srr) {\n\t\tif (!daddr)\n\t\t\treturn -EINVAL;\n\t\tfaddr = ipc.opt->faddr;\n\t\tconnected = 0;\n\t}\n\ttos = RT_TOS(inet->tos);\n\tif (sock_flag(sk, SOCK_LOCALROUTE) ||\n\t    (msg->msg_flags & MSG_DONTROUTE) || \n\t    (ipc.opt && ipc.opt->is_strictroute)) {\n\t\ttos |= RTO_ONLINK;\n\t\tconnected = 0;\n\t}\n\n\tif (MULTICAST(daddr)) {\n\t\tif (!ipc.oif)\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t\tconnected = 0;\n\t}\n\n\tif (connected)\n\t\trt = (struct rtable*)sk_dst_check(sk, 0);\n\n\tif (rt == NULL) {\n\t\tstruct flowi fl = { .oif = ipc.oif,\n\t\t\t\t    .nl_u = { .ip4_u =\n\t\t\t\t\t      { .daddr = faddr,\n\t\t\t\t\t\t.saddr = saddr,\n\t\t\t\t\t\t.tos = tos } },\n\t\t\t\t    .proto = IPPROTO_UDP,\n\t\t\t\t    .uli_u = { .ports =\n\t\t\t\t\t       { .sport = inet->sport,\n\t\t\t\t\t\t .dport = dport } } };\n\t\tsecurity_sk_classify_flow(sk, &fl);\n\t\terr = ip_route_output_flow(&rt, &fl, sk, !(msg->msg_flags&MSG_DONTWAIT));\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = -EACCES;\n\t\tif ((rt->rt_flags & RTCF_BROADCAST) &&\n\t\t    !sock_flag(sk, SOCK_BROADCAST))\n\t\t\tgoto out;\n\t\tif (connected)\n\t\t\tsk_dst_set(sk, dst_clone(&rt->u.dst));\n\t}\n\n\tif (msg->msg_flags&MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tsaddr = rt->rt_src;\n\tif (!ipc.addr)\n\t\tdaddr = ipc.addr = rt->rt_dst;\n\n\tlock_sock(sk);\n\tif (unlikely(up->pending)) {\n\t\t/* The socket is already corked while preparing it. */\n\t\t/* ... which is an evident application bug. --ANK */\n\t\trelease_sock(sk);\n\n\t\tLIMIT_NETDEBUG(KERN_DEBUG \"udp cork app bug 2\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\t/*\n\t *\tNow cork the socket to pend data.\n\t */\n\tinet->cork.fl.fl4_dst = daddr;\n\tinet->cork.fl.fl_ip_dport = dport;\n\tinet->cork.fl.fl4_src = saddr;\n\tinet->cork.fl.fl_ip_sport = inet->sport;\n\tup->pending = AF_INET;\n\ndo_append_data:\n\tup->len += ulen;\n\terr = ip_append_data(sk, ip_generic_getfrag, msg->msg_iov, ulen, \n\t\t\tsizeof(struct udphdr), &ipc, rt, \n\t\t\tcorkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags);\n\tif (err)\n\t\tudp_flush_pending_frames(sk);\n\telse if (!corkreq)\n\t\terr = udp_push_pending_frames(sk, up);\n\trelease_sock(sk);\n\nout:\n\tip_rt_put(rt);\n\tif (free)\n\t\tkfree(ipc.opt);\n\tif (!err) {\n\t\tUDP_INC_STATS_USER(UDP_MIB_OUTDATAGRAMS);\n\t\treturn len;\n\t}\n\t/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise\n\t * we don't have a good statistic (IpOutDiscards but it can be too many\n\t * things).  We could add another new stat but at least for now that\n\t * seems like overkill.\n\t */\n\tif (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {\n\t\tUDP_INC_STATS_USER(UDP_MIB_SNDBUFERRORS);\n\t}\n\treturn err;\n\ndo_confirm:\n\tdst_confirm(&rt->u.dst);\n\tif (!(msg->msg_flags&MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto out;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147550,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int udp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\tsize_t len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct udp_sock *up = udp_sk(sk);\n\tint ulen = len;\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = NULL;\n\tint free = 0;\n\tint connected = 0;\n\t__be32 daddr, faddr, saddr;\n\t__be16 dport;\n\tu8  tos;\n\tint err;\n\tint corkreq = up->corkflag || msg->msg_flags&MSG_MORE;\n\n\tif (len > 0xFFFF)\n\t\treturn -EMSGSIZE;\n\n\t/* \n\t *\tCheck the flags.\n\t */\n\n\tif (msg->msg_flags&MSG_OOB)\t/* Mirror BSD error message compatibility */\n\t\treturn -EOPNOTSUPP;\n\n\tipc.opt = NULL;\n\n\tif (up->pending) {\n\t\t/*\n\t\t * There are pending frames.\n\t \t * The socket lock must be held while it's corked.\n\t\t */\n\t\tlock_sock(sk);\n\t\tif (likely(up->pending)) {\n\t\t\tif (unlikely(up->pending != AF_INET)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n \t\t\tgoto do_append_data;\n\t\t}\n\t\trelease_sock(sk);\n\t}\n\tulen += sizeof(struct udphdr);\n\n\t/*\n\t *\tGet and verify the address. \n\t */\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_in * usin = (struct sockaddr_in*)msg->msg_name;\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\treturn -EINVAL;\n\t\tif (usin->sin_family != AF_INET) {\n\t\t\tif (usin->sin_family != AF_UNSPEC)\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\tdport = usin->sin_port;\n\t\tif (dport == 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdaddr = inet->daddr;\n\t\tdport = inet->dport;\n\t\t/* Open fast path for connected socket.\n\t\t   Route will not be used, if at least one option is set.\n\t\t */\n\t\tconnected = 1;\n  \t}\n\tipc.addr = inet->saddr;\n\n\tipc.oif = sk->sk_bound_dev_if;\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(msg, &ipc);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (ipc.opt)\n\t\t\tfree = 1;\n\t\tconnected = 0;\n\t}\n\tif (!ipc.opt)\n\t\tipc.opt = inet->opt;\n\n\tsaddr = ipc.addr;\n\tipc.addr = faddr = daddr;\n\n\tif (ipc.opt && ipc.opt->srr) {\n\t\tif (!daddr)\n\t\t\treturn -EINVAL;\n\t\tfaddr = ipc.opt->faddr;\n\t\tconnected = 0;\n\t}\n\ttos = RT_TOS(inet->tos);\n\tif (sock_flag(sk, SOCK_LOCALROUTE) ||\n\t    (msg->msg_flags & MSG_DONTROUTE) || \n\t    (ipc.opt && ipc.opt->is_strictroute)) {\n\t\ttos |= RTO_ONLINK;\n\t\tconnected = 0;\n\t}\n\n\tif (MULTICAST(daddr)) {\n\t\tif (!ipc.oif)\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t\tconnected = 0;\n\t}\n\n\tif (connected)\n\t\trt = (struct rtable*)sk_dst_check(sk, 0);\n\n\tif (rt == NULL) {\n\t\tstruct flowi fl = { .oif = ipc.oif,\n\t\t\t\t    .nl_u = { .ip4_u =\n\t\t\t\t\t      { .daddr = faddr,\n\t\t\t\t\t\t.saddr = saddr,\n\t\t\t\t\t\t.tos = tos } },\n\t\t\t\t    .proto = IPPROTO_UDP,\n\t\t\t\t    .uli_u = { .ports =\n\t\t\t\t\t       { .sport = inet->sport,\n\t\t\t\t\t\t .dport = dport } } };\n\t\tsecurity_sk_classify_flow(sk, &fl);\n\t\terr = ip_route_output_flow(&rt, &fl, sk, !(msg->msg_flags&MSG_DONTWAIT));\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = -EACCES;\n\t\tif ((rt->rt_flags & RTCF_BROADCAST) &&\n\t\t    !sock_flag(sk, SOCK_BROADCAST))\n\t\t\tgoto out;\n\t\tif (connected)\n\t\t\tsk_dst_set(sk, dst_clone(&rt->u.dst));\n\t}\n\n\tif (msg->msg_flags&MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tsaddr = rt->rt_src;\n\tif (!ipc.addr)\n\t\tdaddr = ipc.addr = rt->rt_dst;\n\n\tlock_sock(sk);\n\tif (unlikely(up->pending)) {\n\t\t/* The socket is already corked while preparing it. */\n\t\t/* ... which is an evident application bug. --ANK */\n\t\trelease_sock(sk);\n\n\t\tLIMIT_NETDEBUG(KERN_DEBUG \"udp cork app bug 2\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\t/*\n\t *\tNow cork the socket to pend data.\n\t */\n\tinet->cork.fl.fl4_dst = daddr;\n\tinet->cork.fl.fl_ip_dport = dport;\n\tinet->cork.fl.fl4_src = saddr;\n\tinet->cork.fl.fl_ip_sport = inet->sport;\n\tup->pending = AF_INET;\n\ndo_append_data:\n\tup->len += ulen;\n\terr = ip_append_data(sk, ip_generic_getfrag, msg->msg_iov, ulen, \n\t\t\tsizeof(struct udphdr), &ipc, rt, \n\t\t\tcorkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags);\n\tif (err)\n\t\tudp_flush_pending_frames(sk);\n\telse if (!corkreq)\n\t\terr = udp_push_pending_frames(sk, up);\n\telse if (unlikely(skb_queue_empty(&sk->sk_write_queue)))\n\t\tup->pending = 0;\n\trelease_sock(sk);\n\nout:\n\tip_rt_put(rt);\n\tif (free)\n\t\tkfree(ipc.opt);\n\tif (!err) {\n\t\tUDP_INC_STATS_USER(UDP_MIB_OUTDATAGRAMS);\n\t\treturn len;\n\t}\n\t/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise\n\t * we don't have a good statistic (IpOutDiscards but it can be too many\n\t * things).  We could add another new stat but at least for now that\n\t * seems like overkill.\n\t */\n\tif (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {\n\t\tUDP_INC_STATS_USER(UDP_MIB_SNDBUFERRORS);\n\t}\n\treturn err;\n\ndo_confirm:\n\tdst_confirm(&rt->u.dst);\n\tif (!(msg->msg_flags&MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto out;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147551,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static struct kmem_cache *ccid_kmem_cache_create(int obj_size, char *slab_name_fmt, const char *fmt,...)\n{\n\tstruct kmem_cache *slab;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(slab_name_fmt, sizeof(slab_name_fmt), fmt, args);\n\tva_end(args);\n\n\tslab = kmem_cache_create(slab_name_fmt, sizeof(struct ccid) + obj_size, 0,\n\t\t\t\t SLAB_HWCACHE_ALIGN, NULL);\n\treturn slab;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147616,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static struct kmem_cache *ccid_kmem_cache_create(int obj_size, char *slab_name_fmt, const char *fmt,...)\n{\n\tstruct kmem_cache *slab;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(slab_name_fmt, CCID_SLAB_NAME_LENGTH, fmt, args);\n\tva_end(args);\n\n\tslab = kmem_cache_create(slab_name_fmt, sizeof(struct ccid) + obj_size, 0,\n\t\t\t\t SLAB_HWCACHE_ALIGN, NULL);\n\treturn slab;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147617,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void aes_ctr_cleanup(struct ssh_cipher_struct *cipher){\n    explicit_bzero(cipher->aes_key, sizeof(*cipher->aes_key));\n    SAFE_FREE(cipher->aes_key);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147690,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void aes_ctr_cleanup(struct ssh_cipher_struct *cipher){\n    if (cipher != NULL) {\n        if (cipher->aes_key != NULL) {\n            explicit_bzero(cipher->aes_key, sizeof(*cipher->aes_key));\n        }\n        SAFE_FREE(cipher->aes_key);\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147691,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int tls1_check_sig_alg(SSL *s, X509 *x, int default_nid)\n{\n    int sig_nid, use_pc_sigalgs = 0;\n    size_t i;\n    const SIGALG_LOOKUP *sigalg;\n    size_t sigalgslen;\n    if (default_nid == -1)\n        return 1;\n    sig_nid = X509_get_signature_nid(x);\n    if (default_nid)\n        return sig_nid == default_nid ? 1 : 0;\n\n    if (SSL_IS_TLS13(s) && s->s3.tmp.peer_cert_sigalgs != NULL) {\n        /*\n         * If we're in TLSv1.3 then we only get here if we're checking the\n         * chain. If the peer has specified peer_cert_sigalgs then we use them\n         * otherwise we default to normal sigalgs.\n         */\n        sigalgslen = s->s3.tmp.peer_cert_sigalgslen;\n        use_pc_sigalgs = 1;\n    } else {\n        sigalgslen = s->shared_sigalgslen;\n    }\n    for (i = 0; i < sigalgslen; i++) {\n        sigalg = use_pc_sigalgs\n                 ? tls1_lookup_sigalg(s->s3.tmp.peer_cert_sigalgs[i])\n                 : s->shared_sigalgs[i];\n        if (sig_nid == sigalg->sigandhash)\n            return 1;\n    }\n    return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147764,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int tls1_check_sig_alg(SSL *s, X509 *x, int default_nid)\n{\n    int sig_nid, use_pc_sigalgs = 0;\n    size_t i;\n    const SIGALG_LOOKUP *sigalg;\n    size_t sigalgslen;\n    if (default_nid == -1)\n        return 1;\n    sig_nid = X509_get_signature_nid(x);\n    if (default_nid)\n        return sig_nid == default_nid ? 1 : 0;\n\n    if (SSL_IS_TLS13(s) && s->s3.tmp.peer_cert_sigalgs != NULL) {\n        /*\n         * If we're in TLSv1.3 then we only get here if we're checking the\n         * chain. If the peer has specified peer_cert_sigalgs then we use them\n         * otherwise we default to normal sigalgs.\n         */\n        sigalgslen = s->s3.tmp.peer_cert_sigalgslen;\n        use_pc_sigalgs = 1;\n    } else {\n        sigalgslen = s->shared_sigalgslen;\n    }\n    for (i = 0; i < sigalgslen; i++) {\n        sigalg = use_pc_sigalgs\n                 ? tls1_lookup_sigalg(s->s3.tmp.peer_cert_sigalgs[i])\n                 : s->shared_sigalgs[i];\n        if (sigalg != NULL && sig_nid == sigalg->sigandhash)\n            return 1;\n    }\n    return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147765,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int ASN1_item_ex_i2d(const ASN1_VALUE **pval, unsigned char **out,\n                     const ASN1_ITEM *it, int tag, int aclass)\n{\n    const ASN1_TEMPLATE *tt = NULL;\n    int i, seqcontlen, seqlen, ndef = 1;\n    const ASN1_EXTERN_FUNCS *ef;\n    const ASN1_AUX *aux = it->funcs;\n    ASN1_aux_const_cb *asn1_cb = NULL;\n\n    if ((it->itype != ASN1_ITYPE_PRIMITIVE) && *pval == NULL)\n        return 0;\n\n    if (aux != NULL) {\n        asn1_cb = ((aux->flags & ASN1_AFLG_CONST_CB) != 0) ? aux->asn1_const_cb\n            : (ASN1_aux_const_cb *)aux->asn1_cb; /* backward compatibility */\n    }\n\n    switch (it->itype) {\n\n    case ASN1_ITYPE_PRIMITIVE:\n        if (it->templates)\n            return asn1_template_ex_i2d(pval, out, it->templates,\n                                        tag, aclass);\n        return asn1_i2d_ex_primitive(pval, out, it, tag, aclass);\n\n    case ASN1_ITYPE_MSTRING:\n        return asn1_i2d_ex_primitive(pval, out, it, -1, aclass);\n\n    case ASN1_ITYPE_CHOICE:\n        if (asn1_cb && !asn1_cb(ASN1_OP_I2D_PRE, pval, it, NULL))\n            return 0;\n        i = asn1_get_choice_selector_const(pval, it);\n        if ((i >= 0) && (i < it->tcount)) {\n            const ASN1_VALUE **pchval;\n            const ASN1_TEMPLATE *chtt;\n            chtt = it->templates + i;\n            pchval = asn1_get_const_field_ptr(pval, chtt);\n            return asn1_template_ex_i2d(pchval, out, chtt, -1, aclass);\n        }\n        /* Fixme: error condition if selector out of range */\n        if (asn1_cb && !asn1_cb(ASN1_OP_I2D_POST, pval, it, NULL))\n            return 0;\n        break;\n\n    case ASN1_ITYPE_EXTERN:\n        /* If new style i2d it does all the work */\n        ef = it->funcs;\n        return ef->asn1_ex_i2d(pval, out, it, tag, aclass);\n\n    case ASN1_ITYPE_NDEF_SEQUENCE:\n        /* Use indefinite length constructed if requested */\n        if (aclass & ASN1_TFLG_NDEF)\n            ndef = 2;\n        /* fall through */\n\n    case ASN1_ITYPE_SEQUENCE:\n        i = asn1_enc_restore(&seqcontlen, out, pval, it);\n        /* An error occurred */\n        if (i < 0)\n            return 0;\n        /* We have a valid cached encoding... */\n        if (i > 0)\n            return seqcontlen;\n        /* Otherwise carry on */\n        seqcontlen = 0;\n        /* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */\n        if (tag == -1) {\n            tag = V_ASN1_SEQUENCE;\n            /* Retain any other flags in aclass */\n            aclass = (aclass & ~ASN1_TFLG_TAG_CLASS)\n                | V_ASN1_UNIVERSAL;\n        }\n        if (asn1_cb && !asn1_cb(ASN1_OP_I2D_PRE, pval, it, NULL))\n            return 0;\n        /* First work out sequence content length */\n        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {\n            const ASN1_TEMPLATE *seqtt;\n            const ASN1_VALUE **pseqval;\n            int tmplen;\n            seqtt = asn1_do_adb(*pval, tt, 1);\n            if (!seqtt)\n                return 0;\n            pseqval = asn1_get_const_field_ptr(pval, seqtt);\n            tmplen = asn1_template_ex_i2d(pseqval, NULL, seqtt, -1, aclass);\n            if (tmplen == -1 || (tmplen > INT_MAX - seqcontlen))\n                return -1;\n            seqcontlen += tmplen;\n        }\n\n        seqlen = ASN1_object_size(ndef, seqcontlen, tag);\n        if (!out || seqlen == -1)\n            return seqlen;\n        /* Output SEQUENCE header */\n        ASN1_put_object(out, ndef, seqcontlen, tag, aclass);\n        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {\n            const ASN1_TEMPLATE *seqtt;\n            const ASN1_VALUE **pseqval;\n            seqtt = asn1_do_adb(*pval, tt, 1);\n            if (!seqtt)\n                return 0;\n            pseqval = asn1_get_const_field_ptr(pval, seqtt);\n            /* FIXME: check for errors in enhanced version */\n            asn1_template_ex_i2d(pseqval, out, seqtt, -1, aclass);\n        }\n        if (ndef == 2)\n            ASN1_put_eoc(out);\n        if (asn1_cb && !asn1_cb(ASN1_OP_I2D_POST, pval, it, NULL))\n            return 0;\n        return seqlen;\n\n    default:\n        return 0;\n\n    }\n    return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147766,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int ASN1_item_ex_i2d(const ASN1_VALUE **pval, unsigned char **out,\n                     const ASN1_ITEM *it, int tag, int aclass)\n{\n    const ASN1_TEMPLATE *tt = NULL;\n    int i, seqcontlen, seqlen, ndef = 1;\n    const ASN1_EXTERN_FUNCS *ef;\n    const ASN1_AUX *aux = it->funcs;\n    ASN1_aux_const_cb *asn1_cb = NULL;\n\n    if ((it->itype != ASN1_ITYPE_PRIMITIVE) && *pval == NULL)\n        return 0;\n\n    if (aux != NULL) {\n        asn1_cb = ((aux->flags & ASN1_AFLG_CONST_CB) != 0) ? aux->asn1_const_cb\n            : (ASN1_aux_const_cb *)aux->asn1_cb; /* backward compatibility */\n    }\n\n    switch (it->itype) {\n\n    case ASN1_ITYPE_PRIMITIVE:\n        if (it->templates)\n            return asn1_template_ex_i2d(pval, out, it->templates,\n                                        tag, aclass);\n        return asn1_i2d_ex_primitive(pval, out, it, tag, aclass);\n\n    case ASN1_ITYPE_MSTRING:\n        /*\n         * It never makes sense for multi-strings to have implicit tagging, so\n         * if tag != -1, then this looks like an error in the template.\n         */\n        if (tag != -1) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_BAD_TEMPLATE);\n            return -1;\n        }\n        return asn1_i2d_ex_primitive(pval, out, it, -1, aclass);\n\n    case ASN1_ITYPE_CHOICE:\n        /*\n         * It never makes sense for CHOICE types to have implicit tagging, so\n         * if tag != -1, then this looks like an error in the template.\n         */\n        if (tag != -1) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_BAD_TEMPLATE);\n            return -1;\n        }\n        if (asn1_cb && !asn1_cb(ASN1_OP_I2D_PRE, pval, it, NULL))\n            return 0;\n        i = asn1_get_choice_selector_const(pval, it);\n        if ((i >= 0) && (i < it->tcount)) {\n            const ASN1_VALUE **pchval;\n            const ASN1_TEMPLATE *chtt;\n            chtt = it->templates + i;\n            pchval = asn1_get_const_field_ptr(pval, chtt);\n            return asn1_template_ex_i2d(pchval, out, chtt, -1, aclass);\n        }\n        /* Fixme: error condition if selector out of range */\n        if (asn1_cb && !asn1_cb(ASN1_OP_I2D_POST, pval, it, NULL))\n            return 0;\n        break;\n\n    case ASN1_ITYPE_EXTERN:\n        /* If new style i2d it does all the work */\n        ef = it->funcs;\n        return ef->asn1_ex_i2d(pval, out, it, tag, aclass);\n\n    case ASN1_ITYPE_NDEF_SEQUENCE:\n        /* Use indefinite length constructed if requested */\n        if (aclass & ASN1_TFLG_NDEF)\n            ndef = 2;\n        /* fall through */\n\n    case ASN1_ITYPE_SEQUENCE:\n        i = asn1_enc_restore(&seqcontlen, out, pval, it);\n        /* An error occurred */\n        if (i < 0)\n            return 0;\n        /* We have a valid cached encoding... */\n        if (i > 0)\n            return seqcontlen;\n        /* Otherwise carry on */\n        seqcontlen = 0;\n        /* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */\n        if (tag == -1) {\n            tag = V_ASN1_SEQUENCE;\n            /* Retain any other flags in aclass */\n            aclass = (aclass & ~ASN1_TFLG_TAG_CLASS)\n                | V_ASN1_UNIVERSAL;\n        }\n        if (asn1_cb && !asn1_cb(ASN1_OP_I2D_PRE, pval, it, NULL))\n            return 0;\n        /* First work out sequence content length */\n        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {\n            const ASN1_TEMPLATE *seqtt;\n            const ASN1_VALUE **pseqval;\n            int tmplen;\n            seqtt = asn1_do_adb(*pval, tt, 1);\n            if (!seqtt)\n                return 0;\n            pseqval = asn1_get_const_field_ptr(pval, seqtt);\n            tmplen = asn1_template_ex_i2d(pseqval, NULL, seqtt, -1, aclass);\n            if (tmplen == -1 || (tmplen > INT_MAX - seqcontlen))\n                return -1;\n            seqcontlen += tmplen;\n        }\n\n        seqlen = ASN1_object_size(ndef, seqcontlen, tag);\n        if (!out || seqlen == -1)\n            return seqlen;\n        /* Output SEQUENCE header */\n        ASN1_put_object(out, ndef, seqcontlen, tag, aclass);\n        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {\n            const ASN1_TEMPLATE *seqtt;\n            const ASN1_VALUE **pseqval;\n            seqtt = asn1_do_adb(*pval, tt, 1);\n            if (!seqtt)\n                return 0;\n            pseqval = asn1_get_const_field_ptr(pval, seqtt);\n            /* FIXME: check for errors in enhanced version */\n            asn1_template_ex_i2d(pseqval, out, seqtt, -1, aclass);\n        }\n        if (ndef == 2)\n            ASN1_put_eoc(out);\n        if (asn1_cb && !asn1_cb(ASN1_OP_I2D_POST, pval, it, NULL))\n            return 0;\n        return seqlen;\n\n    default:\n        return 0;\n\n    }\n    return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147767,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,\n                               long len, const ASN1_ITEM *it,\n                               int tag, int aclass, char opt, ASN1_TLC *ctx,\n                               int depth)\n{\n    const ASN1_TEMPLATE *tt, *errtt = NULL;\n    const ASN1_EXTERN_FUNCS *ef;\n    const ASN1_AUX *aux = it->funcs;\n    ASN1_aux_cb *asn1_cb;\n    const unsigned char *p = NULL, *q;\n    unsigned char oclass;\n    char seq_eoc, seq_nolen, cst, isopt;\n    long tmplen;\n    int i;\n    int otag;\n    int ret = 0;\n    ASN1_VALUE **pchptr;\n\n    if (pval == NULL)\n        return 0;\n    if (aux && aux->asn1_cb)\n        asn1_cb = aux->asn1_cb;\n    else\n        asn1_cb = 0;\n\n    if (++depth > ASN1_MAX_CONSTRUCTED_NEST) {\n        ERR_raise(ERR_LIB_ASN1, ASN1_R_NESTED_TOO_DEEP);\n        goto err;\n    }\n\n    switch (it->itype) {\n    case ASN1_ITYPE_PRIMITIVE:\n        if (it->templates) {\n            /*\n             * tagging or OPTIONAL is currently illegal on an item template\n             * because the flags can't get passed down. In practice this\n             * isn't a problem: we include the relevant flags from the item\n             * template in the template itself.\n             */\n            if ((tag != -1) || opt) {\n                ERR_raise(ERR_LIB_ASN1,\n                          ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);\n                goto err;\n            }\n            return asn1_template_ex_d2i(pval, in, len,\n                                        it->templates, opt, ctx, depth);\n        }\n        return asn1_d2i_ex_primitive(pval, in, len, it,\n                                     tag, aclass, opt, ctx);\n\n    case ASN1_ITYPE_MSTRING:\n        p = *in;\n        /* Just read in tag and class */\n        ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, NULL,\n                              &p, len, -1, 0, 1, ctx);\n        if (!ret) {\n            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n\n        /* Must be UNIVERSAL class */\n        if (oclass != V_ASN1_UNIVERSAL) {\n            /* If OPTIONAL, assume this is OK */\n            if (opt)\n                return -1;\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_MSTRING_NOT_UNIVERSAL);\n            goto err;\n        }\n        /* Check tag matches bit map */\n        if (!(ASN1_tag2bit(otag) & it->utype)) {\n            /* If OPTIONAL, assume this is OK */\n            if (opt)\n                return -1;\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_MSTRING_WRONG_TAG);\n            goto err;\n        }\n        return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0, ctx);\n\n    case ASN1_ITYPE_EXTERN:\n        /* Use new style d2i */\n        ef = it->funcs;\n        return ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, ctx);\n\n    case ASN1_ITYPE_CHOICE:\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))\n            goto auxerr;\n        if (*pval) {\n            /* Free up and zero CHOICE value if initialised */\n            i = asn1_get_choice_selector(pval, it);\n            if ((i >= 0) && (i < it->tcount)) {\n                tt = it->templates + i;\n                pchptr = asn1_get_field_ptr(pval, tt);\n                asn1_template_free(pchptr, tt);\n                asn1_set_choice_selector(pval, -1, it);\n            }\n        } else if (!ASN1_item_ex_new(pval, it)) {\n            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n        /* CHOICE type, try each possibility in turn */\n        p = *in;\n        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {\n            pchptr = asn1_get_field_ptr(pval, tt);\n            /*\n             * We mark field as OPTIONAL so its absence can be recognised.\n             */\n            ret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, ctx, depth);\n            /* If field not present, try the next one */\n            if (ret == -1)\n                continue;\n            /* If positive return, read OK, break loop */\n            if (ret > 0)\n                break;\n            /*\n             * Must be an ASN1 parsing error.\n             * Free up any partial choice value\n             */\n            asn1_template_free(pchptr, tt);\n            errtt = tt;\n            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n\n        /* Did we fall off the end without reading anything? */\n        if (i == it->tcount) {\n            /* If OPTIONAL, this is OK */\n            if (opt) {\n                /* Free and zero it */\n                ASN1_item_ex_free(pval, it);\n                return -1;\n            }\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_NO_MATCHING_CHOICE_TYPE);\n            goto err;\n        }\n\n        asn1_set_choice_selector(pval, i, it);\n\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))\n            goto auxerr;\n        *in = p;\n        return 1;\n\n    case ASN1_ITYPE_NDEF_SEQUENCE:\n    case ASN1_ITYPE_SEQUENCE:\n        p = *in;\n        tmplen = len;\n\n        /* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */\n        if (tag == -1) {\n            tag = V_ASN1_SEQUENCE;\n            aclass = V_ASN1_UNIVERSAL;\n        }\n        /* Get SEQUENCE length and update len, p */\n        ret = asn1_check_tlen(&len, NULL, NULL, &seq_eoc, &cst,\n                              &p, len, tag, aclass, opt, ctx);\n        if (!ret) {\n            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        } else if (ret == -1)\n            return -1;\n        if (aux && (aux->flags & ASN1_AFLG_BROKEN)) {\n            len = tmplen - (p - *in);\n            seq_nolen = 1;\n        }\n        /* If indefinite we don't do a length check */\n        else\n            seq_nolen = seq_eoc;\n        if (!cst) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);\n            goto err;\n        }\n\n        if (*pval == NULL && !ASN1_item_ex_new(pval, it)) {\n            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))\n            goto auxerr;\n\n        /* Free up and zero any ADB found */\n        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {\n            if (tt->flags & ASN1_TFLG_ADB_MASK) {\n                const ASN1_TEMPLATE *seqtt;\n                ASN1_VALUE **pseqval;\n                seqtt = asn1_do_adb(*pval, tt, 0);\n                if (seqtt == NULL)\n                    continue;\n                pseqval = asn1_get_field_ptr(pval, seqtt);\n                asn1_template_free(pseqval, seqtt);\n            }\n        }\n\n        /* Get each field entry */\n        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {\n            const ASN1_TEMPLATE *seqtt;\n            ASN1_VALUE **pseqval;\n            seqtt = asn1_do_adb(*pval, tt, 1);\n            if (seqtt == NULL)\n                goto err;\n            pseqval = asn1_get_field_ptr(pval, seqtt);\n            /* Have we ran out of data? */\n            if (!len)\n                break;\n            q = p;\n            if (asn1_check_eoc(&p, len)) {\n                if (!seq_eoc) {\n                    ERR_raise(ERR_LIB_ASN1, ASN1_R_UNEXPECTED_EOC);\n                    goto err;\n                }\n                len -= p - q;\n                seq_eoc = 0;\n                break;\n            }\n            /*\n             * This determines the OPTIONAL flag value. The field cannot be\n             * omitted if it is the last of a SEQUENCE and there is still\n             * data to be read. This isn't strictly necessary but it\n             * increases efficiency in some cases.\n             */\n            if (i == (it->tcount - 1))\n                isopt = 0;\n            else\n                isopt = (char)(seqtt->flags & ASN1_TFLG_OPTIONAL);\n            /*\n             * attempt to read in field, allowing each to be OPTIONAL\n             */\n\n            ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, ctx,\n                                       depth);\n            if (!ret) {\n                errtt = seqtt;\n                goto err;\n            } else if (ret == -1) {\n                /*\n                 * OPTIONAL component absent. Free and zero the field.\n                 */\n                asn1_template_free(pseqval, seqtt);\n                continue;\n            }\n            /* Update length */\n            len -= p - q;\n        }\n\n        /* Check for EOC if expecting one */\n        if (seq_eoc && !asn1_check_eoc(&p, len)) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_MISSING_EOC);\n            goto err;\n        }\n        /* Check all data read */\n        if (!seq_nolen && len) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_SEQUENCE_LENGTH_MISMATCH);\n            goto err;\n        }\n\n        /*\n         * If we get here we've got no more data in the SEQUENCE, however we\n         * may not have read all fields so check all remaining are OPTIONAL\n         * and clear any that are.\n         */\n        for (; i < it->tcount; tt++, i++) {\n            const ASN1_TEMPLATE *seqtt;\n            seqtt = asn1_do_adb(*pval, tt, 1);\n            if (seqtt == NULL)\n                goto err;\n            if (seqtt->flags & ASN1_TFLG_OPTIONAL) {\n                ASN1_VALUE **pseqval;\n                pseqval = asn1_get_field_ptr(pval, seqtt);\n                asn1_template_free(pseqval, seqtt);\n            } else {\n                errtt = seqtt;\n                ERR_raise(ERR_LIB_ASN1, ASN1_R_FIELD_MISSING);\n                goto err;\n            }\n        }\n        /* Save encoding */\n        if (!asn1_enc_save(pval, *in, p - *in, it))\n            goto auxerr;\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))\n            goto auxerr;\n        *in = p;\n        return 1;\n\n    default:\n        return 0;\n    }\n auxerr:\n    ERR_raise(ERR_LIB_ASN1, ASN1_R_AUX_ERROR);\n err:\n    if (errtt)\n        ERR_add_error_data(4, \"Field=\", errtt->field_name,\n                           \", Type=\", it->sname);\n    else\n        ERR_add_error_data(2, \"Type=\", it->sname);\n    return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147768,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,\n                               long len, const ASN1_ITEM *it,\n                               int tag, int aclass, char opt, ASN1_TLC *ctx,\n                               int depth)\n{\n    const ASN1_TEMPLATE *tt, *errtt = NULL;\n    const ASN1_EXTERN_FUNCS *ef;\n    const ASN1_AUX *aux = it->funcs;\n    ASN1_aux_cb *asn1_cb;\n    const unsigned char *p = NULL, *q;\n    unsigned char oclass;\n    char seq_eoc, seq_nolen, cst, isopt;\n    long tmplen;\n    int i;\n    int otag;\n    int ret = 0;\n    ASN1_VALUE **pchptr;\n\n    if (pval == NULL)\n        return 0;\n    if (aux && aux->asn1_cb)\n        asn1_cb = aux->asn1_cb;\n    else\n        asn1_cb = 0;\n\n    if (++depth > ASN1_MAX_CONSTRUCTED_NEST) {\n        ERR_raise(ERR_LIB_ASN1, ASN1_R_NESTED_TOO_DEEP);\n        goto err;\n    }\n\n    switch (it->itype) {\n    case ASN1_ITYPE_PRIMITIVE:\n        if (it->templates) {\n            /*\n             * tagging or OPTIONAL is currently illegal on an item template\n             * because the flags can't get passed down. In practice this\n             * isn't a problem: we include the relevant flags from the item\n             * template in the template itself.\n             */\n            if ((tag != -1) || opt) {\n                ERR_raise(ERR_LIB_ASN1,\n                          ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);\n                goto err;\n            }\n            return asn1_template_ex_d2i(pval, in, len,\n                                        it->templates, opt, ctx, depth);\n        }\n        return asn1_d2i_ex_primitive(pval, in, len, it,\n                                     tag, aclass, opt, ctx);\n\n    case ASN1_ITYPE_MSTRING:\n        /*\n         * It never makes sense for multi-strings to have implicit tagging, so\n         * if tag != -1, then this looks like an error in the template.\n         */\n        if (tag != -1) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_BAD_TEMPLATE);\n            goto err;\n        }\n\n        p = *in;\n        /* Just read in tag and class */\n        ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, NULL,\n                              &p, len, -1, 0, 1, ctx);\n        if (!ret) {\n            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n\n        /* Must be UNIVERSAL class */\n        if (oclass != V_ASN1_UNIVERSAL) {\n            /* If OPTIONAL, assume this is OK */\n            if (opt)\n                return -1;\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_MSTRING_NOT_UNIVERSAL);\n            goto err;\n        }\n\n        /* Check tag matches bit map */\n        if (!(ASN1_tag2bit(otag) & it->utype)) {\n            /* If OPTIONAL, assume this is OK */\n            if (opt)\n                return -1;\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_MSTRING_WRONG_TAG);\n            goto err;\n        }\n        return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0, ctx);\n\n    case ASN1_ITYPE_EXTERN:\n        /* Use new style d2i */\n        ef = it->funcs;\n        return ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, ctx);\n\n    case ASN1_ITYPE_CHOICE:\n        /*\n         * It never makes sense for CHOICE types to have implicit tagging, so\n         * if tag != -1, then this looks like an error in the template.\n         */\n        if (tag != -1) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_BAD_TEMPLATE);\n            goto err;\n        }\n\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))\n            goto auxerr;\n        if (*pval) {\n            /* Free up and zero CHOICE value if initialised */\n            i = asn1_get_choice_selector(pval, it);\n            if ((i >= 0) && (i < it->tcount)) {\n                tt = it->templates + i;\n                pchptr = asn1_get_field_ptr(pval, tt);\n                asn1_template_free(pchptr, tt);\n                asn1_set_choice_selector(pval, -1, it);\n            }\n        } else if (!ASN1_item_ex_new(pval, it)) {\n            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n        /* CHOICE type, try each possibility in turn */\n        p = *in;\n        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {\n            pchptr = asn1_get_field_ptr(pval, tt);\n            /*\n             * We mark field as OPTIONAL so its absence can be recognised.\n             */\n            ret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, ctx, depth);\n            /* If field not present, try the next one */\n            if (ret == -1)\n                continue;\n            /* If positive return, read OK, break loop */\n            if (ret > 0)\n                break;\n            /*\n             * Must be an ASN1 parsing error.\n             * Free up any partial choice value\n             */\n            asn1_template_free(pchptr, tt);\n            errtt = tt;\n            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n\n        /* Did we fall off the end without reading anything? */\n        if (i == it->tcount) {\n            /* If OPTIONAL, this is OK */\n            if (opt) {\n                /* Free and zero it */\n                ASN1_item_ex_free(pval, it);\n                return -1;\n            }\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_NO_MATCHING_CHOICE_TYPE);\n            goto err;\n        }\n\n        asn1_set_choice_selector(pval, i, it);\n\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))\n            goto auxerr;\n        *in = p;\n        return 1;\n\n    case ASN1_ITYPE_NDEF_SEQUENCE:\n    case ASN1_ITYPE_SEQUENCE:\n        p = *in;\n        tmplen = len;\n\n        /* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */\n        if (tag == -1) {\n            tag = V_ASN1_SEQUENCE;\n            aclass = V_ASN1_UNIVERSAL;\n        }\n        /* Get SEQUENCE length and update len, p */\n        ret = asn1_check_tlen(&len, NULL, NULL, &seq_eoc, &cst,\n                              &p, len, tag, aclass, opt, ctx);\n        if (!ret) {\n            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        } else if (ret == -1)\n            return -1;\n        if (aux && (aux->flags & ASN1_AFLG_BROKEN)) {\n            len = tmplen - (p - *in);\n            seq_nolen = 1;\n        }\n        /* If indefinite we don't do a length check */\n        else\n            seq_nolen = seq_eoc;\n        if (!cst) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);\n            goto err;\n        }\n\n        if (*pval == NULL && !ASN1_item_ex_new(pval, it)) {\n            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))\n            goto auxerr;\n\n        /* Free up and zero any ADB found */\n        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {\n            if (tt->flags & ASN1_TFLG_ADB_MASK) {\n                const ASN1_TEMPLATE *seqtt;\n                ASN1_VALUE **pseqval;\n                seqtt = asn1_do_adb(*pval, tt, 0);\n                if (seqtt == NULL)\n                    continue;\n                pseqval = asn1_get_field_ptr(pval, seqtt);\n                asn1_template_free(pseqval, seqtt);\n            }\n        }\n\n        /* Get each field entry */\n        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {\n            const ASN1_TEMPLATE *seqtt;\n            ASN1_VALUE **pseqval;\n            seqtt = asn1_do_adb(*pval, tt, 1);\n            if (seqtt == NULL)\n                goto err;\n            pseqval = asn1_get_field_ptr(pval, seqtt);\n            /* Have we ran out of data? */\n            if (!len)\n                break;\n            q = p;\n            if (asn1_check_eoc(&p, len)) {\n                if (!seq_eoc) {\n                    ERR_raise(ERR_LIB_ASN1, ASN1_R_UNEXPECTED_EOC);\n                    goto err;\n                }\n                len -= p - q;\n                seq_eoc = 0;\n                break;\n            }\n            /*\n             * This determines the OPTIONAL flag value. The field cannot be\n             * omitted if it is the last of a SEQUENCE and there is still\n             * data to be read. This isn't strictly necessary but it\n             * increases efficiency in some cases.\n             */\n            if (i == (it->tcount - 1))\n                isopt = 0;\n            else\n                isopt = (char)(seqtt->flags & ASN1_TFLG_OPTIONAL);\n            /*\n             * attempt to read in field, allowing each to be OPTIONAL\n             */\n\n            ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, ctx,\n                                       depth);\n            if (!ret) {\n                errtt = seqtt;\n                goto err;\n            } else if (ret == -1) {\n                /*\n                 * OPTIONAL component absent. Free and zero the field.\n                 */\n                asn1_template_free(pseqval, seqtt);\n                continue;\n            }\n            /* Update length */\n            len -= p - q;\n        }\n\n        /* Check for EOC if expecting one */\n        if (seq_eoc && !asn1_check_eoc(&p, len)) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_MISSING_EOC);\n            goto err;\n        }\n        /* Check all data read */\n        if (!seq_nolen && len) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_SEQUENCE_LENGTH_MISMATCH);\n            goto err;\n        }\n\n        /*\n         * If we get here we've got no more data in the SEQUENCE, however we\n         * may not have read all fields so check all remaining are OPTIONAL\n         * and clear any that are.\n         */\n        for (; i < it->tcount; tt++, i++) {\n            const ASN1_TEMPLATE *seqtt;\n            seqtt = asn1_do_adb(*pval, tt, 1);\n            if (seqtt == NULL)\n                goto err;\n            if (seqtt->flags & ASN1_TFLG_OPTIONAL) {\n                ASN1_VALUE **pseqval;\n                pseqval = asn1_get_field_ptr(pval, seqtt);\n                asn1_template_free(pseqval, seqtt);\n            } else {\n                errtt = seqtt;\n                ERR_raise(ERR_LIB_ASN1, ASN1_R_FIELD_MISSING);\n                goto err;\n            }\n        }\n        /* Save encoding */\n        if (!asn1_enc_save(pval, *in, p - *in, it))\n            goto auxerr;\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))\n            goto auxerr;\n        *in = p;\n        return 1;\n\n    default:\n        return 0;\n    }\n auxerr:\n    ERR_raise(ERR_LIB_ASN1, ASN1_R_AUX_ERROR);\n err:\n    if (errtt)\n        ERR_add_error_data(4, \"Field=\", errtt->field_name,\n                           \", Type=\", it->sname);\n    else\n        ERR_add_error_data(2, \"Type=\", it->sname);\n    return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147769,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int GENERAL_NAME_cmp(GENERAL_NAME *a, GENERAL_NAME *b)\n{\n    int result = -1;\n\n    if (!a || !b || a->type != b->type)\n        return -1;\n    switch (a->type) {\n    case GEN_X400:\n    case GEN_EDIPARTY:\n        result = ASN1_TYPE_cmp(a->d.other, b->d.other);\n        break;\n\n    case GEN_OTHERNAME:\n        result = OTHERNAME_cmp(a->d.otherName, b->d.otherName);\n        break;\n\n    case GEN_EMAIL:\n    case GEN_DNS:\n    case GEN_URI:\n        result = ASN1_STRING_cmp(a->d.ia5, b->d.ia5);\n        break;\n\n    case GEN_DIRNAME:\n        result = X509_NAME_cmp(a->d.dirn, b->d.dirn);\n        break;\n\n    case GEN_IPADD:\n        result = ASN1_OCTET_STRING_cmp(a->d.ip, b->d.ip);\n        break;\n\n    case GEN_RID:\n        result = OBJ_cmp(a->d.rid, b->d.rid);\n        break;\n    }\n    return result;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147770,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int GENERAL_NAME_cmp(GENERAL_NAME *a, GENERAL_NAME *b)\n{\n    int result = -1;\n\n    if (!a || !b || a->type != b->type)\n        return -1;\n    switch (a->type) {\n    case GEN_X400:\n        result = ASN1_TYPE_cmp(a->d.x400Address, b->d.x400Address);\n        break;\n\n    case GEN_EDIPARTY:\n        result = edipartyname_cmp(a->d.ediPartyName, b->d.ediPartyName);\n        break;\n\n    case GEN_OTHERNAME:\n        result = OTHERNAME_cmp(a->d.otherName, b->d.otherName);\n        break;\n\n    case GEN_EMAIL:\n    case GEN_DNS:\n    case GEN_URI:\n        result = ASN1_STRING_cmp(a->d.ia5, b->d.ia5);\n        break;\n\n    case GEN_DIRNAME:\n        result = X509_NAME_cmp(a->d.dirn, b->d.dirn);\n        break;\n\n    case GEN_IPADD:\n        result = ASN1_OCTET_STRING_cmp(a->d.ip, b->d.ip);\n        break;\n\n    case GEN_RID:\n        result = OBJ_cmp(a->d.rid, b->d.rid);\n        break;\n    }\n    return result;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147771,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "unsigned long X509_issuer_and_serial_hash(X509 *a)\n{\n    unsigned long ret = 0;\n    EVP_MD_CTX *ctx = EVP_MD_CTX_new();\n    unsigned char md[16];\n    char *f;\n\n    if (ctx == NULL)\n        goto err;\n    f = X509_NAME_oneline(a->cert_info.issuer, NULL, 0);\n    if (!EVP_DigestInit_ex(ctx, EVP_md5(), NULL))\n        goto err;\n    if (!EVP_DigestUpdate(ctx, (unsigned char *)f, strlen(f)))\n        goto err;\n    OPENSSL_free(f);\n    if (!EVP_DigestUpdate\n        (ctx, (unsigned char *)a->cert_info.serialNumber.data,\n         (unsigned long)a->cert_info.serialNumber.length))\n        goto err;\n    if (!EVP_DigestFinal_ex(ctx, &(md[0]), NULL))\n        goto err;\n    ret = (((unsigned long)md[0]) | ((unsigned long)md[1] << 8L) |\n           ((unsigned long)md[2] << 16L) | ((unsigned long)md[3] << 24L)\n        ) & 0xffffffffL;\n err:\n    EVP_MD_CTX_free(ctx);\n    return ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147792,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "unsigned long X509_issuer_and_serial_hash(X509 *a)\n{\n    unsigned long ret = 0;\n    EVP_MD_CTX *ctx = EVP_MD_CTX_new();\n    unsigned char md[16];\n    char *f;\n\n    if (ctx == NULL)\n        goto err;\n    f = X509_NAME_oneline(a->cert_info.issuer, NULL, 0);\n    if (f == NULL)\n        goto err;\n    if (!EVP_DigestInit_ex(ctx, EVP_md5(), NULL))\n        goto err;\n    if (!EVP_DigestUpdate(ctx, (unsigned char *)f, strlen(f)))\n        goto err;\n    OPENSSL_free(f);\n    if (!EVP_DigestUpdate\n        (ctx, (unsigned char *)a->cert_info.serialNumber.data,\n         (unsigned long)a->cert_info.serialNumber.length))\n        goto err;\n    if (!EVP_DigestFinal_ex(ctx, &(md[0]), NULL))\n        goto err;\n    ret = (((unsigned long)md[0]) | ((unsigned long)md[1] << 8L) |\n           ((unsigned long)md[2] << 16L) | ((unsigned long)md[3] << 24L)\n        ) & 0xffffffffL;\n err:\n    EVP_MD_CTX_free(ctx);\n    return ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147793,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int FuzzerTestOneInput(const uint8_t *buf, size_t len)\n{\n    const unsigned char *p = buf;\n    unsigned char *der = NULL;\n\n    X509 *x509 = d2i_X509(NULL, &p, len);\n    if (x509 != NULL) {\n        BIO *bio = BIO_new(BIO_s_null());\n        /* This will load and print the public key as well as extensions */\n        X509_print(bio, x509);\n        BIO_free(bio);\n\n        i2d_X509(x509, &der);\n        OPENSSL_free(der);\n\n        X509_free(x509);\n    }\n    ERR_clear_error();\n    return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147794,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int FuzzerTestOneInput(const uint8_t *buf, size_t len)\n{\n    const unsigned char *p = buf;\n    unsigned char *der = NULL;\n\n    X509 *x509 = d2i_X509(NULL, &p, len);\n    if (x509 != NULL) {\n        BIO *bio = BIO_new(BIO_s_null());\n        /* This will load and print the public key as well as extensions */\n        X509_print(bio, x509);\n        BIO_free(bio);\n\n        X509_issuer_and_serial_hash(x509);\n\n        i2d_X509(x509, &der);\n        OPENSSL_free(der);\n\n        X509_free(x509);\n    }\n    ERR_clear_error();\n    return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147795,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int init_sig_algs(SSL *s, unsigned int context)\n{\n    /* Clear any signature algorithms extension received */\n    OPENSSL_free(s->s3->tmp.peer_sigalgs);\n    s->s3->tmp.peer_sigalgs = NULL;\n\n    return 1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147798,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int init_sig_algs_cert(SSL *s, unsigned int context)\n{\n    /* Clear any signature algorithms extension received */\n    OPENSSL_free(s->s3->tmp.peer_cert_sigalgs);\n    s->s3->tmp.peer_cert_sigalgs = NULL;\n\n    return 1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147799,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int run(const CommandLineOptions& options)\n{\n\tIR::Module irModule;\n\n\t// Load the module.\n\tif(!loadModule(options.filename, irModule)) { return EXIT_FAILURE; }\n\tif(options.onlyCheck) { return EXIT_SUCCESS; }\n\n\t// Compile the module.\n\tRuntime::Module* module = nullptr;\n\tif(!options.precompiled) { module = Runtime::compileModule(irModule); }\n\telse\n\t{\n\t\tconst UserSection* precompiledObjectSection = nullptr;\n\t\tfor(const UserSection& userSection : irModule.userSections)\n\t\t{\n\t\t\tif(userSection.name == \"wavm.precompiled_object\")\n\t\t\t{\n\t\t\t\tprecompiledObjectSection = &userSection;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!precompiledObjectSection)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Input file did not contain 'wavm.precompiled_object' section\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmodule = Runtime::loadPrecompiledModule(irModule, precompiledObjectSection->data);\n\t\t}\n\t}\n\n\t// Link the module with the intrinsic modules.\n\tCompartment* compartment = Runtime::createCompartment();\n\tContext* context = Runtime::createContext(compartment);\n\tRootResolver rootResolver(compartment);\n\n\tEmscripten::Instance* emscriptenInstance = nullptr;\n\tif(options.enableEmscripten)\n\t{\n\t\temscriptenInstance = Emscripten::instantiate(compartment, irModule);\n\t\tif(emscriptenInstance)\n\t\t{\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"env\", emscriptenInstance->env);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"asm2wasm\", emscriptenInstance->asm2wasm);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"global\", emscriptenInstance->global);\n\t\t}\n\t}\n\n\tif(options.enableThreadTest)\n\t{\n\t\tModuleInstance* threadTestInstance = ThreadTest::instantiate(compartment);\n\t\trootResolver.moduleNameToInstanceMap.set(\"threadTest\", threadTestInstance);\n\t}\n\n\tLinkResult linkResult = linkModule(irModule, rootResolver);\n\tif(!linkResult.success)\n\t{\n\t\tLog::printf(Log::error, \"Failed to link module:\\n\");\n\t\tfor(auto& missingImport : linkResult.missingImports)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\"Missing import: module=\\\"%s\\\" export=\\\"%s\\\" type=\\\"%s\\\"\\n\",\n\t\t\t\t\t\tmissingImport.moduleName.c_str(),\n\t\t\t\t\t\tmissingImport.exportName.c_str(),\n\t\t\t\t\t\tasString(missingImport.type).c_str());\n\t\t}\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t// Instantiate the module.\n\tModuleInstance* moduleInstance = instantiateModule(\n\t\tcompartment, module, std::move(linkResult.resolvedImports), options.filename);\n\tif(!moduleInstance) { return EXIT_FAILURE; }\n\n\t// Call the module start function, if it has one.\n\tFunctionInstance* startFunction = getStartFunction(moduleInstance);\n\tif(startFunction) { invokeFunctionChecked(context, startFunction, {}); }\n\n\tif(options.enableEmscripten)\n\t{\n\t\t// Call the Emscripten global initalizers.\n\t\tEmscripten::initializeGlobals(context, irModule, moduleInstance);\n\t}\n\n\t// Look up the function export to call.\n\tFunctionInstance* functionInstance;\n\tif(!options.functionName)\n\t{\n\t\tfunctionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \"main\"));\n\t\tif(!functionInstance)\n\t\t{ functionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \"_main\")); }\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Module does not export main function\\n\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfunctionInstance\n\t\t\t= asFunctionNullable(getInstanceExport(moduleInstance, options.functionName));\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Module does not export '%s'\\n\", options.functionName);\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\tFunctionType functionType = getFunctionType(functionInstance);\n\n\t// Set up the arguments for the invoke.\n\tstd::vector<Value> invokeArgs;\n\tif(!options.functionName)\n\t{\n\t\tif(functionType.params().size() == 2)\n\t\t{\n\t\t\tMemoryInstance* defaultMemory = Runtime::getDefaultMemory(moduleInstance);\n\t\t\tif(!defaultMemory)\n\t\t\t{\n\t\t\t\tLog::printf(\n\t\t\t\t\tLog::error,\n\t\t\t\t\t\"Module does not declare a default memory object to put arguments in.\\n\");\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\n\t\t\tstd::vector<const char*> argStrings;\n\t\t\targStrings.push_back(options.filename);\n\t\t\tchar** args = options.args;\n\t\t\twhile(*args) { argStrings.push_back(*args++); };\n\n\t\t\tEmscripten::injectCommandArgs(emscriptenInstance, argStrings, invokeArgs);\n\t\t}\n\t\telse if(functionType.params().size() > 0)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\"WebAssembly function requires %\" PRIu64\n\t\t\t\t\t\t\" argument(s), but only 0 or 2 can be passed!\",\n\t\t\t\t\t\tfunctionType.params().size());\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(U32 i = 0; options.args[i]; ++i)\n\t\t{\n\t\t\tValue value;\n\t\t\tswitch(functionType.params()[i])\n\t\t\t{\n\t\t\tcase ValueType::i32: value = (U32)atoi(options.args[i]); break;\n\t\t\tcase ValueType::i64: value = (U64)atol(options.args[i]); break;\n\t\t\tcase ValueType::f32: value = (F32)atof(options.args[i]); break;\n\t\t\tcase ValueType::f64: value = atof(options.args[i]); break;\n\t\t\tcase ValueType::v128:\n\t\t\tcase ValueType::anyref:\n\t\t\tcase ValueType::anyfunc:\n\t\t\t\tErrors::fatalf(\"Cannot parse command-line argument for %s function parameter\",\n\t\t\t\t\t\t\t   asString(functionType.params()[i]));\n\t\t\tdefault: Errors::unreachable();\n\t\t\t}\n\t\t\tinvokeArgs.push_back(value);\n\t\t}\n\t}\n\n\t// Invoke the function.\n\tTiming::Timer executionTimer;\n\tIR::ValueTuple functionResults = invokeFunctionChecked(context, functionInstance, invokeArgs);\n\tTiming::logTimer(\"Invoked function\", executionTimer);\n\n\tif(options.functionName)\n\t{\n\t\tLog::printf(Log::debug,\n\t\t\t\t\t\"%s returned: %s\\n\",\n\t\t\t\t\toptions.functionName,\n\t\t\t\t\tasString(functionResults).c_str());\n\t\treturn EXIT_SUCCESS;\n\t}\n\telse if(functionResults.size() == 1 && functionResults[0].type == ValueType::i32)\n\t{\n\t\treturn functionResults[0].i32;\n\t}\n\telse\n\t{\n\t\treturn EXIT_SUCCESS;\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147860,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int run(const CommandLineOptions& options)\n{\n\tIR::Module irModule;\n\n\t// Load the module.\n\tif(!loadModule(options.filename, irModule)) { return EXIT_FAILURE; }\n\tif(options.onlyCheck) { return EXIT_SUCCESS; }\n\n\t// Compile the module.\n\tRuntime::Module* module = nullptr;\n\tif(!options.precompiled) { module = Runtime::compileModule(irModule); }\n\telse\n\t{\n\t\tconst UserSection* precompiledObjectSection = nullptr;\n\t\tfor(const UserSection& userSection : irModule.userSections)\n\t\t{\n\t\t\tif(userSection.name == \"wavm.precompiled_object\")\n\t\t\t{\n\t\t\t\tprecompiledObjectSection = &userSection;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!precompiledObjectSection)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Input file did not contain 'wavm.precompiled_object' section\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmodule = Runtime::loadPrecompiledModule(irModule, precompiledObjectSection->data);\n\t\t}\n\t}\n\n\t// Link the module with the intrinsic modules.\n\tCompartment* compartment = Runtime::createCompartment();\n\tContext* context = Runtime::createContext(compartment);\n\tRootResolver rootResolver(compartment);\n\n\tEmscripten::Instance* emscriptenInstance = nullptr;\n\tif(options.enableEmscripten)\n\t{\n\t\temscriptenInstance = Emscripten::instantiate(compartment, irModule);\n\t\tif(emscriptenInstance)\n\t\t{\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"env\", emscriptenInstance->env);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"asm2wasm\", emscriptenInstance->asm2wasm);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"global\", emscriptenInstance->global);\n\t\t}\n\t}\n\n\tif(options.enableThreadTest)\n\t{\n\t\tModuleInstance* threadTestInstance = ThreadTest::instantiate(compartment);\n\t\trootResolver.moduleNameToInstanceMap.set(\"threadTest\", threadTestInstance);\n\t}\n\n\tLinkResult linkResult = linkModule(irModule, rootResolver);\n\tif(!linkResult.success)\n\t{\n\t\tLog::printf(Log::error, \"Failed to link module:\\n\");\n\t\tfor(auto& missingImport : linkResult.missingImports)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\"Missing import: module=\\\"%s\\\" export=\\\"%s\\\" type=\\\"%s\\\"\\n\",\n\t\t\t\t\t\tmissingImport.moduleName.c_str(),\n\t\t\t\t\t\tmissingImport.exportName.c_str(),\n\t\t\t\t\t\tasString(missingImport.type).c_str());\n\t\t}\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t// Instantiate the module.\n\tModuleInstance* moduleInstance = instantiateModule(\n\t\tcompartment, module, std::move(linkResult.resolvedImports), options.filename);\n\tif(!moduleInstance) { return EXIT_FAILURE; }\n\n\t// Call the module start function, if it has one.\n\tFunctionInstance* startFunction = getStartFunction(moduleInstance);\n\tif(startFunction) { invokeFunctionChecked(context, startFunction, {}); }\n\n\tif(options.enableEmscripten)\n\t{\n\t\t// Call the Emscripten global initalizers.\n\t\tEmscripten::initializeGlobals(context, irModule, moduleInstance);\n\t}\n\n\t// Look up the function export to call.\n\tFunctionInstance* functionInstance;\n\tif(!options.functionName)\n\t{\n\t\tfunctionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \"main\"));\n\t\tif(!functionInstance)\n\t\t{ functionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \"_main\")); }\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Module does not export main function\\n\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfunctionInstance\n\t\t\t= asFunctionNullable(getInstanceExport(moduleInstance, options.functionName));\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Module does not export '%s'\\n\", options.functionName);\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\tFunctionType functionType = getFunctionType(functionInstance);\n\n\t// Set up the arguments for the invoke.\n\tstd::vector<Value> invokeArgs;\n\tif(!options.functionName)\n\t{\n\t\tif(functionType.params().size() == 2)\n\t\t{\n\t\t\tif(!emscriptenInstance)\n\t\t\t{\n\t\t\t\tLog::printf(\n\t\t\t\t\tLog::error,\n\t\t\t\t\t\"Module does not declare a default memory object to put arguments in.\\n\");\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::vector<const char*> argStrings;\n\t\t\t\targStrings.push_back(options.filename);\n\t\t\t\tchar** args = options.args;\n\t\t\t\twhile(*args) { argStrings.push_back(*args++); };\n\n\t\t\t\twavmAssert(emscriptenInstance);\n\t\t\t\tEmscripten::injectCommandArgs(emscriptenInstance, argStrings, invokeArgs);\n\t\t\t}\n\t\t}\n\t\telse if(functionType.params().size() > 0)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\"WebAssembly function requires %\" PRIu64\n\t\t\t\t\t\t\" argument(s), but only 0 or 2 can be passed!\",\n\t\t\t\t\t\tfunctionType.params().size());\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(U32 i = 0; options.args[i]; ++i)\n\t\t{\n\t\t\tValue value;\n\t\t\tswitch(functionType.params()[i])\n\t\t\t{\n\t\t\tcase ValueType::i32: value = (U32)atoi(options.args[i]); break;\n\t\t\tcase ValueType::i64: value = (U64)atol(options.args[i]); break;\n\t\t\tcase ValueType::f32: value = (F32)atof(options.args[i]); break;\n\t\t\tcase ValueType::f64: value = atof(options.args[i]); break;\n\t\t\tcase ValueType::v128:\n\t\t\tcase ValueType::anyref:\n\t\t\tcase ValueType::anyfunc:\n\t\t\t\tErrors::fatalf(\"Cannot parse command-line argument for %s function parameter\",\n\t\t\t\t\t\t\t   asString(functionType.params()[i]));\n\t\t\tdefault: Errors::unreachable();\n\t\t\t}\n\t\t\tinvokeArgs.push_back(value);\n\t\t}\n\t}\n\n\t// Invoke the function.\n\tTiming::Timer executionTimer;\n\tIR::ValueTuple functionResults = invokeFunctionChecked(context, functionInstance, invokeArgs);\n\tTiming::logTimer(\"Invoked function\", executionTimer);\n\n\tif(options.functionName)\n\t{\n\t\tLog::printf(Log::debug,\n\t\t\t\t\t\"%s returned: %s\\n\",\n\t\t\t\t\toptions.functionName,\n\t\t\t\t\tasString(functionResults).c_str());\n\t\treturn EXIT_SUCCESS;\n\t}\n\telse if(functionResults.size() == 1 && functionResults[0].type == ValueType::i32)\n\t{\n\t\treturn functionResults[0].i32;\n\t}\n\telse\n\t{\n\t\treturn EXIT_SUCCESS;\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147861,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void sqlcipher_exportFunc(sqlite3_context *context, int argc, sqlite3_value **argv) {\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  const char* targetDb, *sourceDb; \n  int targetDb_idx = 0;\n  u64 saved_flags = db->flags;        /* Saved value of the db->flags */\n  u32 saved_mDbFlags = db->mDbFlags;        /* Saved value of the db->mDbFlags */\n  int saved_nChange = db->nChange;      /* Saved value of db->nChange */\n  int saved_nTotalChange = db->nTotalChange; /* Saved value of db->nTotalChange */\n  u8 saved_mTrace = db->mTrace;        /* Saved value of db->mTrace */\n  int rc = SQLITE_OK;     /* Return code from service routines */\n  char *zSql = NULL;         /* SQL statements */\n  char *pzErrMsg = NULL;\n\n  if(argc != 1 && argc != 2) {\n    rc = SQLITE_ERROR;\n    pzErrMsg = sqlite3_mprintf(\"invalid number of arguments (%d) passed to sqlcipher_export\", argc);\n    goto end_of_export;\n  }\n\n  targetDb = (const char*) sqlite3_value_text(argv[0]);\n  sourceDb = (argc == 2) ? (char *) sqlite3_value_text(argv[1]) : \"main\";\n\n  /* if the name of the target is not main, but the index returned is zero \n     there is a mismatch and we should not proceed */\n  targetDb_idx =  sqlcipher_find_db_index(db, targetDb);\n  if(targetDb_idx == 0 && sqlite3StrICmp(\"main\", targetDb) != 0) {\n    rc = SQLITE_ERROR;\n    pzErrMsg = sqlite3_mprintf(\"unknown database %s\", targetDb);\n    goto end_of_export;\n  }\n  db->init.iDb = targetDb_idx;\n\n  db->flags |= SQLITE_WriteSchema | SQLITE_IgnoreChecks; \n  db->mDbFlags |= DBFLAG_PreferBuiltin | DBFLAG_Vacuum;\n  db->flags &= ~(u64)(SQLITE_ForeignKeys | SQLITE_ReverseOrder | SQLITE_Defensive | SQLITE_CountRows); \n  db->mTrace = 0;\n\n  /* Query the schema of the main database. Create a mirror schema\n  ** in the temporary database.\n  */\n  zSql = sqlite3_mprintf(\n    \"SELECT sql \"\n    \"  FROM %s.sqlite_master WHERE type='table' AND name!='sqlite_sequence'\"\n    \"   AND rootpage>0\"\n  , sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  zSql = sqlite3_mprintf(\n    \"SELECT sql \"\n    \"  FROM %s.sqlite_master WHERE sql LIKE 'CREATE INDEX %%' \"\n  , sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  zSql = sqlite3_mprintf(\n    \"SELECT sql \"\n    \"  FROM %s.sqlite_master WHERE sql LIKE 'CREATE UNIQUE INDEX %%'\"\n  , sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  /* Loop through the tables in the main database. For each, do\n  ** an \"INSERT INTO rekey_db.xxx SELECT * FROM main.xxx;\" to copy\n  ** the contents to the temporary database.\n  */\n  zSql = sqlite3_mprintf(\n    \"SELECT 'INSERT INTO %s.' || quote(name) \"\n    \"|| ' SELECT * FROM %s.' || quote(name) || ';'\"\n    \"FROM %s.sqlite_master \"\n    \"WHERE type = 'table' AND name!='sqlite_sequence' \"\n    \"  AND rootpage>0\"\n  , targetDb, sourceDb, sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  /* Copy over the contents of the sequence table\n  */\n  zSql = sqlite3_mprintf(\n    \"SELECT 'INSERT INTO %s.' || quote(name) \"\n    \"|| ' SELECT * FROM %s.' || quote(name) || ';' \"\n    \"FROM %s.sqlite_master WHERE name=='sqlite_sequence';\"\n  , targetDb, sourceDb, targetDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  /* Copy the triggers, views, and virtual tables from the main database\n  ** over to the temporary database.  None of these objects has any\n  ** associated storage, so all we have to do is copy their entries\n  ** from the SQLITE_MASTER table.\n  */\n  zSql = sqlite3_mprintf(\n    \"INSERT INTO %s.sqlite_master \"\n    \"  SELECT type, name, tbl_name, rootpage, sql\"\n    \"    FROM %s.sqlite_master\"\n    \"   WHERE type='view' OR type='trigger'\"\n    \"      OR (type='table' AND rootpage=0)\"\n  , targetDb, sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  zSql = NULL;\nend_of_export:\n  db->init.iDb = 0;\n  db->flags = saved_flags;\n  db->mDbFlags = saved_mDbFlags;\n  db->nChange = saved_nChange;\n  db->nTotalChange = saved_nTotalChange;\n  db->mTrace = saved_mTrace;\n\n  if(zSql) sqlite3_free(zSql);\n\n  if(rc) {\n    if(pzErrMsg != NULL) {\n      sqlite3_result_error(context, pzErrMsg, -1);\n      sqlite3DbFree(db, pzErrMsg);\n    } else {\n      sqlite3_result_error(context, sqlite3ErrStr(rc), -1);\n    }\n  }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147878,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void sqlcipher_exportFunc(sqlite3_context *context, int argc, sqlite3_value **argv) {\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  const char* targetDb, *sourceDb; \n  int targetDb_idx = 0;\n  u64 saved_flags = db->flags;        /* Saved value of the db->flags */\n  u32 saved_mDbFlags = db->mDbFlags;        /* Saved value of the db->mDbFlags */\n  int saved_nChange = db->nChange;      /* Saved value of db->nChange */\n  int saved_nTotalChange = db->nTotalChange; /* Saved value of db->nTotalChange */\n  u8 saved_mTrace = db->mTrace;        /* Saved value of db->mTrace */\n  int rc = SQLITE_OK;     /* Return code from service routines */\n  char *zSql = NULL;         /* SQL statements */\n  char *pzErrMsg = NULL;\n\n  if(argc != 1 && argc != 2) {\n    rc = SQLITE_ERROR;\n    pzErrMsg = sqlite3_mprintf(\"invalid number of arguments (%d) passed to sqlcipher_export\", argc);\n    goto end_of_export;\n  }\n\n  if(sqlite3_value_type(argv[0]) == SQLITE_NULL) {\n    rc = SQLITE_ERROR;\n    pzErrMsg = sqlite3_mprintf(\"target database can't be NULL\");\n    goto end_of_export;\n  }\n\n  targetDb = (const char*) sqlite3_value_text(argv[0]); \n  sourceDb = \"main\";\n\n  if(argc == 2) {\n    if(sqlite3_value_type(argv[1]) == SQLITE_NULL) {\n      rc = SQLITE_ERROR;\n      pzErrMsg = sqlite3_mprintf(\"target database can't be NULL\");\n      goto end_of_export;\n    }\n    sourceDb = (char *) sqlite3_value_text(argv[1]);\n  }\n\n\n  /* if the name of the target is not main, but the index returned is zero \n     there is a mismatch and we should not proceed */\n  targetDb_idx =  sqlcipher_find_db_index(db, targetDb);\n  if(targetDb_idx == 0 && targetDb != NULL && sqlite3StrICmp(\"main\", targetDb) != 0) {\n    rc = SQLITE_ERROR;\n    pzErrMsg = sqlite3_mprintf(\"unknown database %s\", targetDb);\n    goto end_of_export;\n  }\n  db->init.iDb = targetDb_idx;\n\n  db->flags |= SQLITE_WriteSchema | SQLITE_IgnoreChecks; \n  db->mDbFlags |= DBFLAG_PreferBuiltin | DBFLAG_Vacuum;\n  db->flags &= ~(u64)(SQLITE_ForeignKeys | SQLITE_ReverseOrder | SQLITE_Defensive | SQLITE_CountRows); \n  db->mTrace = 0;\n\n  /* Query the schema of the main database. Create a mirror schema\n  ** in the temporary database.\n  */\n  zSql = sqlite3_mprintf(\n    \"SELECT sql \"\n    \"  FROM %s.sqlite_master WHERE type='table' AND name!='sqlite_sequence'\"\n    \"   AND rootpage>0\"\n  , sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  zSql = sqlite3_mprintf(\n    \"SELECT sql \"\n    \"  FROM %s.sqlite_master WHERE sql LIKE 'CREATE INDEX %%' \"\n  , sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  zSql = sqlite3_mprintf(\n    \"SELECT sql \"\n    \"  FROM %s.sqlite_master WHERE sql LIKE 'CREATE UNIQUE INDEX %%'\"\n  , sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  /* Loop through the tables in the main database. For each, do\n  ** an \"INSERT INTO rekey_db.xxx SELECT * FROM main.xxx;\" to copy\n  ** the contents to the temporary database.\n  */\n  zSql = sqlite3_mprintf(\n    \"SELECT 'INSERT INTO %s.' || quote(name) \"\n    \"|| ' SELECT * FROM %s.' || quote(name) || ';'\"\n    \"FROM %s.sqlite_master \"\n    \"WHERE type = 'table' AND name!='sqlite_sequence' \"\n    \"  AND rootpage>0\"\n  , targetDb, sourceDb, sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  /* Copy over the contents of the sequence table\n  */\n  zSql = sqlite3_mprintf(\n    \"SELECT 'INSERT INTO %s.' || quote(name) \"\n    \"|| ' SELECT * FROM %s.' || quote(name) || ';' \"\n    \"FROM %s.sqlite_master WHERE name=='sqlite_sequence';\"\n  , targetDb, sourceDb, targetDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  /* Copy the triggers, views, and virtual tables from the main database\n  ** over to the temporary database.  None of these objects has any\n  ** associated storage, so all we have to do is copy their entries\n  ** from the SQLITE_MASTER table.\n  */\n  zSql = sqlite3_mprintf(\n    \"INSERT INTO %s.sqlite_master \"\n    \"  SELECT type, name, tbl_name, rootpage, sql\"\n    \"    FROM %s.sqlite_master\"\n    \"   WHERE type='view' OR type='trigger'\"\n    \"      OR (type='table' AND rootpage=0)\"\n  , targetDb, sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  zSql = NULL;\nend_of_export:\n  db->init.iDb = 0;\n  db->flags = saved_flags;\n  db->mDbFlags = saved_mDbFlags;\n  db->nChange = saved_nChange;\n  db->nTotalChange = saved_nTotalChange;\n  db->mTrace = saved_mTrace;\n\n  if(zSql) sqlite3_free(zSql);\n\n  if(rc) {\n    if(pzErrMsg != NULL) {\n      sqlite3_result_error(context, pzErrMsg, -1);\n      sqlite3DbFree(db, pzErrMsg);\n    } else {\n      sqlite3_result_error(context, sqlite3ErrStr(rc), -1);\n    }\n  }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147879,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box)\n{\n\tu32 type, uuid_type, hdr_size;\n\tu64 size, start, payload_start, end;\n\tchar uuid[16];\n\tGF_Err e;\n\tGF_Box *newBox;\n\tBool skip_logs = gf_bs_get_cookie(bs) ? GF_TRUE : GF_FALSE;\n\tBool is_special = GF_TRUE;\n\n\tif ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;\n\t*outBox = NULL;\n\tif (gf_bs_available(bs) < 8) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tstart = gf_bs_get_position(bs);\n\n\tuuid_type = 0;\n\tsize = (u64) gf_bs_read_u32(bs);\n\thdr_size = 4;\n\t/*fix for some boxes found in some old hinted files*/\n\tif ((size >= 2) && (size <= 4)) {\n\t\tsize = 4;\n\t\ttype = GF_ISOM_BOX_TYPE_VOID;\n\t} else {\n\t\ttype = gf_bs_read_u32(bs);\n\t\thdr_size += 4;\n\t\t/*no size means till end of file - EXCEPT FOR some old QuickTime boxes...*/\n\t\tif (type == GF_ISOM_BOX_TYPE_TOTL)\n\t\t\tsize = 12;\n\t\tif (!size) {\n\t\t\tif (is_root_box) {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\\n\", gf_4cc_to_str(type), type));\n\t\t\t\t}\n\t\t\t\tsize = gf_bs_available(bs) + 8;\n\t\t\t} else {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s (0x%08X) at position \"LLU\" has size 0 but is not at root/file level, skipping\\n\", gf_4cc_to_str(type), type, start));\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n//\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t}\n\t}\n\t/*handle uuid*/\n\tmemset(uuid, 0, 16);\n\tif (type == GF_ISOM_BOX_TYPE_UUID ) {\n\t\tif (gf_bs_available(bs) < 16) {\n\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t}\n\t\tgf_bs_read_data(bs, uuid, 16);\n\t\thdr_size += 16;\n\t\tuuid_type = gf_isom_solve_uuid_box(uuid);\n\t}\n\n\t//handle large box\n\tif (size == 1) {\n\t\tif (gf_bs_available(bs) < 8) {\n\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t}\n\t\tsize = gf_bs_read_u64(bs);\n\t\thdr_size += 8;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(type), LLD_CAST size, LLD_CAST start));\n\n\tif ( size < hdr_size ) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box size \"LLD\" less than box header size %d\\n\", LLD_CAST size, hdr_size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//some special boxes (references and track groups) are handled by a single generic box with an associated ref/group type\n\tif (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_TrackGroupTypeBox*)newBox)->group_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;\n\t} else {\n\t\t//OK, create the box based on the type\n\t\tis_special = GF_FALSE;\n\t\tnewBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t}\n\n\t//OK, init and read this box\n\tif (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {\n\t\tmemcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);\n\t\t((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;\n\t}\n\n\tif (!newBox->type) newBox->type = type;\n\tpayload_start = gf_bs_get_position(bs);\n\nretry_unknown_box:\n\n\tend = gf_bs_available(bs);\n\tif (size - hdr_size > end ) {\n\t\tnewBox->size = size - hdr_size - end;\n\t\t*outBox = newBox;\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tnewBox->size = size - hdr_size;\n\n\tif (newBox->size) {\n\t\te = gf_isom_full_box_read(newBox, bs);\n\t\tif (!e) e = gf_isom_box_read(newBox, bs);\n\t\tnewBox->size = size;\n\t\tend = gf_bs_get_position(bs);\n\t} else {\n\t\tnewBox->size = size;\n\t\t//empty box\n\t\te = GF_OK;\n\t\tend = gf_bs_get_position(bs);\n\t}\n\n\tif (e && (e != GF_ISOM_INCOMPLETE_FILE)) {\n\t\tgf_isom_box_del(newBox);\n\t\t*outBox = NULL;\n\n\t\tif (parent_type==GF_ISOM_BOX_TYPE_STSD) {\n\t\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\t\t((GF_UnknownBox *)newBox)->original_4cc = type;\n\t\t\tnewBox->size = size;\n\t\t\tgf_bs_seek(bs, payload_start);\n\t\t\tgoto retry_unknown_box;\n\t\t}\n\t\tif (!skip_logs) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box \\\"%s\\\" (start \"LLU\") failed (%s) - skipping\\n\", gf_4cc_to_str(type), start, gf_error_to_string(e)));\n\t\t}\n\t\t//we don't try to reparse known boxes that have been failing (too dangerous)\n\t\treturn e;\n\t}\n\n\tif (end-start > size) {\n\t\tif (!skip_logs) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" size \"LLU\" (start \"LLU\") invalid (read \"LLU\")\\n\", gf_4cc_to_str(type), LLU_CAST size, start, LLU_CAST (end-start) ));\n\t\t}\n\t\t/*let's still try to load the file since no error was notified*/\n\t\tgf_bs_seek(bs, start+size);\n\t} else if (end-start < size) {\n\t\tu32 to_skip = (u32) (size-(end-start));\n\t\tif (!skip_logs) {\n\t\t\tif ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" (start \"LLU\") has %u extra bytes\\n\", gf_4cc_to_str(type), start, to_skip));\n\t\t\t}\n\t\t}\n\t\tgf_bs_skip_bytes(bs, to_skip);\n\t}\n\t*outBox = newBox;\n\n\treturn e;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147902,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box)\n{\n\tu32 type, uuid_type, hdr_size;\n\tu64 size, start, payload_start, end;\n\tchar uuid[16];\n\tGF_Err e;\n\tGF_Box *newBox;\n\tBool skip_logs = gf_bs_get_cookie(bs) ? GF_TRUE : GF_FALSE;\n\tBool is_special = GF_TRUE;\n\n\tif ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;\n\t*outBox = NULL;\n\tif (gf_bs_available(bs) < 8) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tstart = gf_bs_get_position(bs);\n\n\tuuid_type = 0;\n\tsize = (u64) gf_bs_read_u32(bs);\n\thdr_size = 4;\n\t/*fix for some boxes found in some old hinted files*/\n\tif ((size >= 2) && (size <= 4)) {\n\t\tsize = 4;\n\t\ttype = GF_ISOM_BOX_TYPE_VOID;\n\t} else {\n\t\ttype = gf_bs_read_u32(bs);\n\t\thdr_size += 4;\n\t\t/*no size means till end of file - EXCEPT FOR some old QuickTime boxes...*/\n\t\tif (type == GF_ISOM_BOX_TYPE_TOTL)\n\t\t\tsize = 12;\n\t\tif (!size) {\n\t\t\tif (is_root_box) {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\\n\", gf_4cc_to_str(type), type));\n\t\t\t\t}\n\t\t\t\tsize = gf_bs_available(bs) + 8;\n\t\t\t} else {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s (0x%08X) at position \"LLU\" has size 0 but is not at root/file level, skipping\\n\", gf_4cc_to_str(type), type, start));\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n//\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t}\n\t}\n\t/*handle uuid*/\n\tmemset(uuid, 0, 16);\n\tif (type == GF_ISOM_BOX_TYPE_UUID ) {\n\t\tif (gf_bs_available(bs) < 16) {\n\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t}\n\t\tgf_bs_read_data(bs, uuid, 16);\n\t\thdr_size += 16;\n\t\tuuid_type = gf_isom_solve_uuid_box(uuid);\n\t}\n\n\t//handle large box\n\tif (size == 1) {\n\t\tif (gf_bs_available(bs) < 8) {\n\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t}\n\t\tsize = gf_bs_read_u64(bs);\n\t\thdr_size += 8;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(type), LLD_CAST size, LLD_CAST start));\n\n\tif ( size < hdr_size ) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box size \"LLD\" less than box header size %d\\n\", LLD_CAST size, hdr_size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//some special boxes (references and track groups) are handled by a single generic box with an associated ref/group type\n\tif (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_TrackGroupTypeBox*)newBox)->group_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;\n\t} else {\n\t\t//OK, create the box based on the type\n\t\tis_special = GF_FALSE;\n\t\tnewBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t}\n\n\t//OK, init and read this box\n\tif (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {\n\t\tmemcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);\n\t\t((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;\n\t}\n\n\tif (!newBox->type) newBox->type = type;\n\tpayload_start = gf_bs_get_position(bs);\n\nretry_unknown_box:\n\n\tend = gf_bs_available(bs);\n\tif (size - hdr_size > end ) {\n\t\tnewBox->size = size - hdr_size - end;\n\t\t*outBox = newBox;\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tnewBox->size = size - hdr_size;\n\n\t//parse even if size is 0 - this makes sure that we perform box parsing (usually in box->read)\n\te = gf_isom_full_box_read(newBox, bs);\n\tif (!e) e = gf_isom_box_read(newBox, bs);\n\tnewBox->size = size;\n\tend = gf_bs_get_position(bs);\n\n\tif (e && (e != GF_ISOM_INCOMPLETE_FILE)) {\n\t\tgf_isom_box_del(newBox);\n\t\t*outBox = NULL;\n\n\t\tif (parent_type==GF_ISOM_BOX_TYPE_STSD) {\n\t\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\t\t((GF_UnknownBox *)newBox)->original_4cc = type;\n\t\t\tnewBox->size = size;\n\t\t\tgf_bs_seek(bs, payload_start);\n\t\t\tgoto retry_unknown_box;\n\t\t}\n\t\tif (!skip_logs) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box \\\"%s\\\" (start \"LLU\") failed (%s) - skipping\\n\", gf_4cc_to_str(type), start, gf_error_to_string(e)));\n\t\t}\n\t\t//we don't try to reparse known boxes that have been failing (too dangerous)\n\t\treturn e;\n\t}\n\n\tif (end-start > size) {\n\t\tif (!skip_logs) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" size \"LLU\" (start \"LLU\") invalid (read \"LLU\")\\n\", gf_4cc_to_str(type), LLU_CAST size, start, LLU_CAST (end-start) ));\n\t\t}\n\t\t/*let's still try to load the file since no error was notified*/\n\t\tgf_bs_seek(bs, start+size);\n\t} else if (end-start < size) {\n\t\tu32 to_skip = (u32) (size-(end-start));\n\t\tif (!skip_logs) {\n\t\t\tif ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" (start \"LLU\") has %u extra bytes\\n\", gf_4cc_to_str(type), start, to_skip));\n\t\t\t}\n\t\t}\n\t\tgf_bs_skip_bytes(bs, to_skip);\n\t}\n\t*outBox = newBox;\n\n\treturn e;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147903,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tBool zfound=GF_FALSE;\n\tGF_Err e;\n\n\tISOM_DECREASE_SIZE(ptr, 25)\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize =(u32)ptr->size;\n\ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n\tif (!tmp_str) return GF_OUT_OF_MEM;\n\tmemset(tmp_str, 0, sizeof(char)*tmp_strsize);\n\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tif (i) {\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\tzfound = GF_FALSE;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j]) {\n\t\t\t\tzfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tif (!zfound)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tzfound = GF_FALSE;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j]) {\n\t\t\t\tzfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\n\t\tif (!zfound)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\tzfound = GF_FALSE;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tif (i) {\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\tzfound = GF_FALSE;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tif (i) {\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->segment_run_table_entries, asrt);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->fragment_run_table_entries, afrt);\n\t}\n\n\tgf_free(tmp_str);\n\n\treturn GF_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147920,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tBool zfound=GF_FALSE;\n\tGF_Err e = GF_OK;\n\n\tISOM_DECREASE_SIZE(ptr, 25)\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize =(u32)ptr->size;\n\ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n\tif (!tmp_str) return GF_OUT_OF_MEM;\n\tmemset(tmp_str, 0, sizeof(char)*tmp_strsize);\n\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\tif (i) {\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\tzfound = GF_FALSE;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j]) {\n\t\t\t\tzfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tif (!zfound) {\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\tif (ptr->server_entry_count != gf_list_count(ptr->server_entry_table)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tzfound = GF_FALSE;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j]) {\n\t\t\t\tzfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\n\t\tif (!zfound) {\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\tif (ptr->quality_entry_count != gf_list_count(ptr->quality_entry_table)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\tzfound = GF_FALSE;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tif (i) {\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\tzfound = GF_FALSE;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tif (i) {\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgoto exit;\n\t\t}\n\t\tgf_list_add(ptr->segment_run_table_entries, asrt);\n\t}\n\tif (ptr->segment_run_table_count != gf_list_count(ptr->segment_run_table_entries)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgoto exit;\n\t\t}\n\t\tgf_list_add(ptr->fragment_run_table_entries, afrt);\n\t}\n\tif (ptr->fragment_run_table_count != gf_list_count(ptr->fragment_run_table_entries)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\nexit:\n\tgf_free(tmp_str);\n\treturn e;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147921,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "bool CClient::OnTextMessage(CTextMessage& Message) {\n    CString sTargets = Message.GetTarget();\n\n    VCString vTargets;\n    sTargets.Split(\",\", vTargets, false);\n\n    for (CString& sTarget : vTargets) {\n        Message.SetTarget(sTarget);\n        if (m_pNetwork) {\n            // May be nullptr.\n            Message.SetChan(m_pNetwork->FindChan(sTarget));\n        }\n\n        if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {\n            if (sTarget.Equals(\"status\")) {\n                CString sMsg = Message.GetText();\n                UserCommand(sMsg);\n            } else {\n                CALLMOD(sTarget, this, m_pUser, m_pNetwork,\n                        OnModCommand(Message.GetText()));\n            }\n            continue;\n        }\n\n        bool bContinue = false;\n        NETWORKMODULECALL(OnUserTextMessage(Message), m_pUser, m_pNetwork, this,\n                          &bContinue);\n        if (bContinue) continue;\n\n        if (!GetIRCSock()) {\n            // Some lagmeters do a PRIVMSG to their own nick, ignore those.\n            if (!sTarget.Equals(m_sNick))\n                PutStatus(\n                    t_f(\"Your message to {1} got lost, you are not connected \"\n                        \"to IRC!\")(Message.GetTarget()));\n            continue;\n        }\n\n        if (m_pNetwork) {\n            AddBuffer(Message);\n            EchoMessage(Message);\n            PutIRC(Message.ToString(CMessage::ExcludePrefix |\n                                    CMessage::ExcludeTags));\n        }\n    }\n\n    return true;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147926,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "bool CClient::OnTextMessage(CTextMessage& Message) {\n    CString sTargets = Message.GetTarget();\n\n    VCString vTargets;\n    sTargets.Split(\",\", vTargets, false);\n\n    for (CString& sTarget : vTargets) {\n        Message.SetTarget(sTarget);\n        if (m_pNetwork) {\n            // May be nullptr.\n            Message.SetChan(m_pNetwork->FindChan(sTarget));\n        }\n\n        if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {\n            EchoMessage(Message);\n\n            if (sTarget.Equals(\"status\")) {\n                CString sMsg = Message.GetText();\n                UserCommand(sMsg);\n            } else {\n                CALLMOD(sTarget, this, m_pUser, m_pNetwork,\n                        OnModCommand(Message.GetText()));\n            }\n            continue;\n        }\n\n        bool bContinue = false;\n        NETWORKMODULECALL(OnUserTextMessage(Message), m_pUser, m_pNetwork, this,\n                          &bContinue);\n        if (bContinue) continue;\n\n        if (!GetIRCSock()) {\n            // Some lagmeters do a PRIVMSG to their own nick, ignore those.\n            if (!sTarget.Equals(m_sNick))\n                PutStatus(\n                    t_f(\"Your message to {1} got lost, you are not connected \"\n                        \"to IRC!\")(Message.GetTarget()));\n            continue;\n        }\n\n        if (m_pNetwork) {\n            AddBuffer(Message);\n            EchoMessage(Message);\n            PutIRC(Message.ToString(CMessage::ExcludePrefix |\n                                    CMessage::ExcludeTags));\n        }\n    }\n\n    return true;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147927,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "Status PyArrayDescr_to_TF_DataType(PyArray_Descr* descr,\n                                   TF_DataType* out_tf_datatype) {\n  PyObject* key;\n  PyObject* value;\n  Py_ssize_t pos = 0;\n  if (PyDict_Next(descr->fields, &pos, &key, &value)) {\n    // In Python 3, the keys of numpy custom struct types are unicode, unlike\n    // Python 2, where the keys are bytes.\n    const char* key_string =\n        PyBytes_Check(key) ? PyBytes_AsString(key)\n                           : PyBytes_AsString(PyUnicode_AsASCIIString(key));\n    if (!key_string) {\n      return errors::Internal(\"Corrupt numpy type descriptor\");\n    }\n    tensorflow::string key = key_string;\n    // The typenames here should match the field names in the custom struct\n    // types constructed in test_util.py.\n    // TODO(mrry,keveman): Investigate Numpy type registration to replace this\n    // hard-coding of names.\n    if (key == \"quint8\") {\n      *out_tf_datatype = TF_QUINT8;\n    } else if (key == \"qint8\") {\n      *out_tf_datatype = TF_QINT8;\n    } else if (key == \"qint16\") {\n      *out_tf_datatype = TF_QINT16;\n    } else if (key == \"quint16\") {\n      *out_tf_datatype = TF_QUINT16;\n    } else if (key == \"qint32\") {\n      *out_tf_datatype = TF_QINT32;\n    } else if (key == \"resource\") {\n      *out_tf_datatype = TF_RESOURCE;\n    } else {\n      return errors::Internal(\"Unsupported numpy data type\");\n    }\n    return Status::OK();\n  }\n  return errors::Internal(\"Unsupported numpy data type\");\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147936,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "Status PyArrayDescr_to_TF_DataType(PyArray_Descr* descr,\n                                   TF_DataType* out_tf_datatype) {\n  PyObject* key;\n  PyObject* value;\n  Py_ssize_t pos = 0;\n\n  // Return an error if the fields attribute is null.\n  // Occurs with an improper conversion attempt to resource.\n  if (descr->fields == nullptr) {\n    return errors::Internal(\"Unexpected numpy data type\");\n  }\n\n  if (PyDict_Next(descr->fields, &pos, &key, &value)) {\n    // In Python 3, the keys of numpy custom struct types are unicode, unlike\n    // Python 2, where the keys are bytes.\n    const char* key_string =\n        PyBytes_Check(key) ? PyBytes_AsString(key)\n                           : PyBytes_AsString(PyUnicode_AsASCIIString(key));\n    if (!key_string) {\n      return errors::Internal(\"Corrupt numpy type descriptor\");\n    }\n    tensorflow::string key = key_string;\n    // The typenames here should match the field names in the custom struct\n    // types constructed in test_util.py.\n    // TODO(mrry,keveman): Investigate Numpy type registration to replace this\n    // hard-coding of names.\n    if (key == \"quint8\") {\n      *out_tf_datatype = TF_QUINT8;\n    } else if (key == \"qint8\") {\n      *out_tf_datatype = TF_QINT8;\n    } else if (key == \"qint16\") {\n      *out_tf_datatype = TF_QINT16;\n    } else if (key == \"quint16\") {\n      *out_tf_datatype = TF_QUINT16;\n    } else if (key == \"qint32\") {\n      *out_tf_datatype = TF_QINT32;\n    } else if (key == \"resource\") {\n      *out_tf_datatype = TF_RESOURCE;\n    } else {\n      return errors::Internal(\"Unsupported numpy data type\");\n    }\n    return Status::OK();\n  }\n  return errors::Internal(\"Unsupported numpy data type\");\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147937,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "vq_endchains(struct virtio_vq_info *vq, int used_all_avail)\n{\n\tstruct virtio_base *base;\n\tuint16_t event_idx, new_idx, old_idx;\n\tint intr;\n\n\t/*\n\t * Interrupt generation: if we're using EVENT_IDX,\n\t * interrupt if we've crossed the event threshold.\n\t * Otherwise interrupt is generated if we added \"used\" entries,\n\t * but suppressed by VRING_AVAIL_F_NO_INTERRUPT.\n\t *\n\t * In any case, though, if NOTIFY_ON_EMPTY is set and the\n\t * entire avail was processed, we need to interrupt always.\n\t */\n\n\tatomic_thread_fence();\n\n\tbase = vq->base;\n\told_idx = vq->save_used;\n\tvq->save_used = new_idx = vq->used->idx;\n\tif (used_all_avail &&\n\t    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))\n\t\tintr = 1;\n\telse if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\t\tevent_idx = VQ_USED_EVENT_IDX(vq);\n\t\t/*\n\t\t * This calculation is per docs and the kernel\n\t\t * (see src/sys/dev/virtio/virtio_ring.h).\n\t\t */\n\t\tintr = (uint16_t)(new_idx - event_idx - 1) <\n\t\t\t(uint16_t)(new_idx - old_idx);\n\t} else {\n\t\tintr = new_idx != old_idx &&\n\t\t    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);\n\t}\n\tif (intr)\n\t\tvq_interrupt(base, vq);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147938,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "vq_endchains(struct virtio_vq_info *vq, int used_all_avail)\n{\n\tstruct virtio_base *base;\n\tuint16_t event_idx, new_idx, old_idx;\n\tint intr;\n\n\tif (!vq || !vq->used)\n\t\treturn;\n\n\t/*\n\t * Interrupt generation: if we're using EVENT_IDX,\n\t * interrupt if we've crossed the event threshold.\n\t * Otherwise interrupt is generated if we added \"used\" entries,\n\t * but suppressed by VRING_AVAIL_F_NO_INTERRUPT.\n\t *\n\t * In any case, though, if NOTIFY_ON_EMPTY is set and the\n\t * entire avail was processed, we need to interrupt always.\n\t */\n\n\tatomic_thread_fence();\n\n\tbase = vq->base;\n\told_idx = vq->save_used;\n\tvq->save_used = new_idx = vq->used->idx;\n\tif (used_all_avail &&\n\t    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))\n\t\tintr = 1;\n\telse if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\t\tevent_idx = VQ_USED_EVENT_IDX(vq);\n\t\t/*\n\t\t * This calculation is per docs and the kernel\n\t\t * (see src/sys/dev/virtio/virtio_ring.h).\n\t\t */\n\t\tintr = (uint16_t)(new_idx - event_idx - 1) <\n\t\t\t(uint16_t)(new_idx - old_idx);\n\t} else {\n\t\tintr = new_idx != old_idx &&\n\t\t    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);\n\t}\n\tif (intr)\n\t\tvq_interrupt(base, vq);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147939,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "codegen(codegen_scope *s, node *tree, int val)\n{\n  int nt;\n  int rlev = s->rlev;\n\n  if (!tree) {\n    if (val) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    return;\n  }\n\n  s->rlev++;\n  if (s->rlev > MRB_CODEGEN_LEVEL_MAX) {\n    codegen_error(s, \"too complex expression\");\n  }\n  if (s->irep && s->filename_index != tree->filename_index) {\n    mrb_sym fname = mrb_parser_get_filename(s->parser, s->filename_index);\n    const char *filename = mrb_sym_name_len(s->mrb, fname, NULL);\n\n    mrb_debug_info_append_file(s->mrb, s->irep->debug_info,\n                               filename, s->lines, s->debug_start_pos, s->pc);\n    s->debug_start_pos = s->pc;\n    s->filename_index = tree->filename_index;\n    s->filename_sym = mrb_parser_get_filename(s->parser, tree->filename_index);\n  }\n\n  nt = nint(tree->car);\n  s->lineno = tree->lineno;\n  tree = tree->cdr;\n  switch (nt) {\n  case NODE_BEGIN:\n    if (val && !tree) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    while (tree) {\n      codegen(s, tree->car, tree->cdr ? NOVAL : val);\n      tree = tree->cdr;\n    }\n    break;\n\n  case NODE_RESCUE:\n    {\n      int noexc;\n      uint32_t exend, pos1, pos2, tmp;\n      struct loopinfo *lp;\n      int catch_entry, begin, end;\n\n      if (tree->car == NULL) goto exit;\n      lp = loop_push(s, LOOP_BEGIN);\n      lp->pc0 = new_label(s);\n      catch_entry = catch_handler_new(s);\n      begin = s->pc;\n      codegen(s, tree->car, VAL);\n      pop();\n      lp->type = LOOP_RESCUE;\n      end = s->pc;\n      noexc = genjmp_0(s, OP_JMP);\n      catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);\n      tree = tree->cdr;\n      exend = JMPLINK_START;\n      pos1 = JMPLINK_START;\n      if (tree->car) {\n        node *n2 = tree->car;\n        int exc = cursp();\n\n        genop_1(s, OP_EXCEPT, exc);\n        push();\n        while (n2) {\n          node *n3 = n2->car;\n          node *n4 = n3->car;\n\n          dispatch(s, pos1);\n          pos2 = JMPLINK_START;\n          do {\n            if (n4 && n4->car && nint(n4->car->car) == NODE_SPLAT) {\n              codegen(s, n4->car, VAL);\n              gen_move(s, cursp(), exc, 0);\n              push_n(2); pop_n(2); /* space for one arg and a block */\n              pop();\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);\n            }\n            else {\n              if (n4) {\n                codegen(s, n4->car, VAL);\n              }\n              else {\n                genop_2(s, OP_GETCONST, cursp(), new_sym(s, MRB_SYM_2(s->mrb, StandardError)));\n                push();\n              }\n              pop();\n              genop_2(s, OP_RESCUE, exc, cursp());\n            }\n            tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, val);\n            pos2 = tmp;\n            if (n4) {\n              n4 = n4->cdr;\n            }\n          } while (n4);\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch_linked(s, pos2);\n\n          pop();\n          if (n3->cdr->car) {\n            gen_assignment(s, n3->cdr->car, NULL, exc, NOVAL);\n          }\n          if (n3->cdr->cdr->car) {\n            codegen(s, n3->cdr->cdr->car, val);\n            if (val) pop();\n          }\n          tmp = genjmp(s, OP_JMP, exend);\n          exend = tmp;\n          n2 = n2->cdr;\n          push();\n        }\n        if (pos1 != JMPLINK_START) {\n          dispatch(s, pos1);\n          genop_1(s, OP_RAISEIF, exc);\n        }\n      }\n      pop();\n      tree = tree->cdr;\n      dispatch(s, noexc);\n      if (tree->car) {\n        codegen(s, tree->car, val);\n      }\n      else if (val) {\n        push();\n      }\n      dispatch_linked(s, exend);\n      loop_pop(s, NOVAL);\n    }\n    break;\n\n  case NODE_ENSURE:\n    if (!tree->cdr || !tree->cdr->cdr ||\n        (nint(tree->cdr->cdr->car) == NODE_BEGIN &&\n         tree->cdr->cdr->cdr)) {\n      int catch_entry, begin, end, target;\n      int idx;\n\n      catch_entry = catch_handler_new(s);\n      begin = s->pc;\n      codegen(s, tree->car, val);\n      end = target = s->pc;\n      push();\n      idx = cursp();\n      genop_1(s, OP_EXCEPT, idx);\n      push();\n      codegen(s, tree->cdr->cdr, NOVAL);\n      pop();\n      genop_1(s, OP_RAISEIF, idx);\n      pop();\n      catch_handler_set(s, catch_entry, MRB_CATCH_ENSURE, begin, end, target);\n    }\n    else {                      /* empty ensure ignored */\n      codegen(s, tree->car, val);\n    }\n    break;\n\n  case NODE_LAMBDA:\n    if (val) {\n      int idx = lambda_body(s, tree, 1);\n\n      genop_2(s, OP_LAMBDA, cursp(), idx);\n      push();\n    }\n    break;\n\n  case NODE_BLOCK:\n    if (val) {\n      int idx = lambda_body(s, tree, 1);\n\n      genop_2(s, OP_BLOCK, cursp(), idx);\n      push();\n    }\n    break;\n\n  case NODE_IF:\n    {\n      uint32_t pos1, pos2;\n      mrb_bool nil_p = FALSE;\n      node *elsepart = tree->cdr->cdr->car;\n\n      if (!tree->car) {\n        codegen(s, elsepart, val);\n        goto exit;\n      }\n      if (true_always(tree->car)) {\n        codegen(s, tree->cdr->car, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, elsepart, val);\n        goto exit;\n      }\n      if (nint(tree->car->car) == NODE_CALL) {\n        node *n = tree->car->cdr;\n        mrb_sym mid = nsym(n->cdr->car);\n        mrb_sym sym_nil_p = MRB_SYM_Q_2(s->mrb, nil);\n        if (mid == sym_nil_p && n->cdr->cdr->car == NULL) {\n          nil_p = TRUE;\n          codegen(s, n->car, VAL);\n        }\n      }\n      if (!nil_p) {\n        codegen(s, tree->car, VAL);\n      }\n      pop();\n      if (val || tree->cdr->car) {\n        if (nil_p) {\n          pos2 = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch(s, pos2);\n        }\n        else {\n          pos1 = genjmp2_0(s, OP_JMPNOT, cursp(), val);\n        }\n        codegen(s, tree->cdr->car, val);\n        if (val) pop();\n        if (elsepart || val) {\n          pos2 = genjmp_0(s, OP_JMP);\n          dispatch(s, pos1);\n          codegen(s, elsepart, val);\n          dispatch(s, pos2);\n        }\n        else {\n          dispatch(s, pos1);\n        }\n      }\n      else {                    /* empty then-part */\n        if (elsepart) {\n          if (nil_p) {\n            pos1 = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n          }\n          else {\n            pos1 = genjmp2_0(s, OP_JMPIF, cursp(), val);\n          }\n          codegen(s, elsepart, val);\n          dispatch(s, pos1);\n        }\n        else if (val && !nil_p) {\n          genop_1(s, OP_LOADNIL, cursp());\n          push();\n        }\n      }\n    }\n    break;\n\n  case NODE_AND:\n    {\n      uint32_t pos;\n\n      if (true_always(tree->car)) {\n        codegen(s, tree->cdr, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, tree->car, val);\n        goto exit;\n      }\n      codegen(s, tree->car, VAL);\n      pop();\n      pos = genjmp2_0(s, OP_JMPNOT, cursp(), val);\n      codegen(s, tree->cdr, val);\n      dispatch(s, pos);\n    }\n    break;\n\n  case NODE_OR:\n    {\n      uint32_t pos;\n\n      if (true_always(tree->car)) {\n        codegen(s, tree->car, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, tree->cdr, val);\n        goto exit;\n      }\n      codegen(s, tree->car, VAL);\n      pop();\n      pos = genjmp2_0(s, OP_JMPIF, cursp(), val);\n      codegen(s, tree->cdr, val);\n      dispatch(s, pos);\n    }\n    break;\n\n  case NODE_WHILE:\n  case NODE_UNTIL:\n    {\n      if (true_always(tree->car)) {\n        if (nt == NODE_UNTIL) {\n          if (val) {\n            genop_1(s, OP_LOADNIL, cursp());\n            push();\n          }\n          goto exit;\n        }\n      }\n      else if (false_always(tree->car)) {\n        if (nt == NODE_WHILE) {\n          if (val) {\n            genop_1(s, OP_LOADNIL, cursp());\n            push();\n          }\n          goto exit;\n        }\n      }\n\n      uint32_t pos = JMPLINK_START;\n      struct loopinfo *lp = loop_push(s, LOOP_NORMAL);\n\n      if (!val) lp->reg = -1;\n      lp->pc0 = new_label(s);\n      codegen(s, tree->car, VAL);\n      pop();\n      if (nt == NODE_WHILE) {\n        pos = genjmp2_0(s, OP_JMPNOT, cursp(), NOVAL);\n      }\n      else {\n        pos = genjmp2_0(s, OP_JMPIF, cursp(), NOVAL);\n      }\n      lp->pc1 = new_label(s);\n      codegen(s, tree->cdr, NOVAL);\n      genjmp(s, OP_JMP, lp->pc0);\n      dispatch(s, pos);\n      loop_pop(s, val);\n    }\n    break;\n\n  case NODE_FOR:\n    for_body(s, tree);\n    if (val) push();\n    break;\n\n  case NODE_CASE:\n    {\n      int head = 0;\n      uint32_t pos1, pos2, pos3, tmp;\n      node *n;\n\n      pos3 = JMPLINK_START;\n      if (tree->car) {\n        head = cursp();\n        codegen(s, tree->car, VAL);\n      }\n      tree = tree->cdr;\n      while (tree) {\n        n = tree->car->car;\n        pos1 = pos2 = JMPLINK_START;\n        while (n) {\n          codegen(s, n->car, VAL);\n          if (head) {\n            gen_move(s, cursp(), head, 0);\n            push(); push(); pop(); pop(); pop();\n            if (nint(n->car->car) == NODE_SPLAT) {\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);\n            }\n            else {\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_OPSYM_2(s->mrb, eqq)), 1);\n            }\n          }\n          else {\n            pop();\n          }\n          tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, NOVAL);\n          pos2 = tmp;\n          n = n->cdr;\n        }\n        if (tree->car->car) {\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch_linked(s, pos2);\n        }\n        codegen(s, tree->car->cdr, val);\n        if (val) pop();\n        tmp = genjmp(s, OP_JMP, pos3);\n        pos3 = tmp;\n        dispatch(s, pos1);\n        tree = tree->cdr;\n      }\n      if (val) {\n        uint32_t pos = cursp();\n        genop_1(s, OP_LOADNIL, cursp());\n        if (pos3 != JMPLINK_START) dispatch_linked(s, pos3);\n        if (head) pop();\n        if (cursp() != pos) {\n          gen_move(s, cursp(), pos, 0);\n        }\n        push();\n      }\n      else {\n        if (pos3 != JMPLINK_START) {\n          dispatch_linked(s, pos3);\n        }\n        if (head) {\n          pop();\n        }\n      }\n    }\n    break;\n\n  case NODE_SCOPE:\n    scope_body(s, tree, NOVAL);\n    break;\n\n  case NODE_FCALL:\n  case NODE_CALL:\n    gen_call(s, tree, val, 0);\n    break;\n  case NODE_SCALL:\n    gen_call(s, tree, val, 1);\n    break;\n\n  case NODE_DOT2:\n    codegen(s, tree->car, val);\n    codegen(s, tree->cdr, val);\n    if (val) {\n      pop(); pop();\n      genop_1(s, OP_RANGE_INC, cursp());\n      push();\n    }\n    break;\n\n  case NODE_DOT3:\n    codegen(s, tree->car, val);\n    codegen(s, tree->cdr, val);\n    if (val) {\n      pop(); pop();\n      genop_1(s, OP_RANGE_EXC, cursp());\n      push();\n    }\n    break;\n\n  case NODE_COLON2:\n    {\n      int sym = new_sym(s, nsym(tree->cdr));\n\n      codegen(s, tree->car, VAL);\n      pop();\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_COLON3:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_ARRAY:\n    {\n      int n;\n\n      n = gen_values(s, tree, val, 0);\n      if (val) {\n        if (n >= 0) {\n          pop_n(n);\n          genop_2(s, OP_ARRAY, cursp(), n);\n        }\n        push();\n      }\n    }\n    break;\n\n  case NODE_HASH:\n  case NODE_KW_HASH:\n    {\n      int nk = gen_hash(s, tree, val, GEN_LIT_ARY_MAX);\n      if (val && nk >= 0) {\n        pop_n(nk*2);\n        genop_2(s, OP_HASH, cursp(), nk);\n        push();\n      }\n    }\n    break;\n\n  case NODE_SPLAT:\n    codegen(s, tree, val);\n    break;\n\n  case NODE_ASGN:\n    gen_assignment(s, tree->car, tree->cdr, 0, val);\n    break;\n\n  case NODE_MASGN:\n    {\n      int len = 0, n = 0, post = 0;\n      node *t = tree->cdr, *p;\n      int rhs = cursp();\n\n      if (nint(t->car) == NODE_ARRAY && t->cdr && nosplat(t->cdr)) {\n        /* fixed rhs */\n        t = t->cdr;\n        while (t) {\n          codegen(s, t->car, VAL);\n          len++;\n          t = t->cdr;\n        }\n        tree = tree->car;\n        if (tree->car) {                /* pre */\n          t = tree->car;\n          n = 0;\n          while (t) {\n            if (n < len) {\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n              n++;\n            }\n            else {\n              genop_1(s, OP_LOADNIL, rhs+n);\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n            }\n            t = t->cdr;\n          }\n        }\n        t = tree->cdr;\n        if (t) {\n          if (t->cdr) {         /* post count */\n            p = t->cdr->car;\n            while (p) {\n              post++;\n              p = p->cdr;\n            }\n          }\n          if (t->car) {         /* rest (len - pre - post) */\n            int rn;\n\n            if (len < post + n) {\n              rn = 0;\n            }\n            else {\n              rn = len - post - n;\n            }\n            genop_3(s, OP_ARRAY2, cursp(), rhs+n, rn);\n            gen_assignment(s, t->car, NULL, cursp(), NOVAL);\n            n += rn;\n          }\n          if (t->cdr && t->cdr->car) {\n            t = t->cdr->car;\n            while (n<len) {\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n              t = t->cdr;\n              n++;\n            }\n          }\n        }\n        pop_n(len);\n        if (val) {\n          genop_2(s, OP_ARRAY, rhs, len);\n          push();\n        }\n      }\n      else {\n        /* variable rhs */\n        codegen(s, t, VAL);\n        gen_vmassignment(s, tree->car, rhs, val);\n        if (!val) {\n          pop();\n        }\n      }\n    }\n    break;\n\n  case NODE_OP_ASGN:\n    {\n      mrb_sym sym = nsym(tree->cdr->car);\n      mrb_int len;\n      const char *name = mrb_sym_name_len(s->mrb, sym, &len);\n      int idx, callargs = -1, vsp = -1;\n\n      if ((len == 2 && name[0] == '|' && name[1] == '|') &&\n          (nint(tree->car->car) == NODE_CONST ||\n           nint(tree->car->car) == NODE_CVAR)) {\n        int catch_entry, begin, end;\n        int noexc, exc;\n        struct loopinfo *lp;\n\n        lp = loop_push(s, LOOP_BEGIN);\n        lp->pc0 = new_label(s);\n        catch_entry = catch_handler_new(s);\n        begin = s->pc;\n        exc = cursp();\n        codegen(s, tree->car, VAL);\n        end = s->pc;\n        noexc = genjmp_0(s, OP_JMP);\n        lp->type = LOOP_RESCUE;\n        catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);\n        genop_1(s, OP_EXCEPT, exc);\n        genop_1(s, OP_LOADF, exc);\n        dispatch(s, noexc);\n        loop_pop(s, NOVAL);\n      }\n      else if (nint(tree->car->car) == NODE_CALL) {\n        node *n = tree->car->cdr;\n        int base, i, nargs = 0;\n        callargs = 0;\n\n        if (val) {\n          vsp = cursp();\n          push();\n        }\n        codegen(s, n->car, VAL);   /* receiver */\n        idx = new_sym(s, nsym(n->cdr->car));\n        base = cursp()-1;\n        if (n->cdr->cdr->car) {\n          nargs = gen_values(s, n->cdr->cdr->car->car, VAL, 13);\n          if (nargs >= 0) {\n            callargs = nargs;\n          }\n          else { /* varargs */\n            push();\n            nargs = 1;\n            callargs = CALL_MAXARGS;\n          }\n        }\n        /* copy receiver and arguments */\n        gen_move(s, cursp(), base, 1);\n        for (i=0; i<nargs; i++) {\n          gen_move(s, cursp()+i+1, base+i+1, 1);\n        }\n        push_n(nargs+2);pop_n(nargs+2); /* space for receiver, arguments and a block */\n        genop_3(s, OP_SEND, cursp(), idx, callargs);\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL);\n      }\n      if (len == 2 &&\n          ((name[0] == '|' && name[1] == '|') ||\n           (name[0] == '&' && name[1] == '&'))) {\n        uint32_t pos;\n\n        pop();\n        if (val) {\n          if (vsp >= 0) {\n            gen_move(s, vsp, cursp(), 1);\n          }\n          pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);\n        }\n        else {\n          pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);\n        }\n        codegen(s, tree->cdr->cdr->car, VAL);\n        pop();\n        if (val && vsp >= 0) {\n          gen_move(s, vsp, cursp(), 1);\n        }\n        if (nint(tree->car->car) == NODE_CALL) {\n          if (callargs == CALL_MAXARGS) {\n            pop();\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          else {\n            pop_n(callargs);\n            callargs++;\n          }\n          pop();\n          idx = new_sym(s, attrsym(s, nsym(tree->car->cdr->cdr->car)));\n          genop_3(s, OP_SEND, cursp(), idx, callargs);\n        }\n        else {\n          gen_assignment(s, tree->car, NULL, cursp(), val);\n        }\n        dispatch(s, pos);\n        goto exit;\n      }\n      codegen(s, tree->cdr->cdr->car, VAL);\n      push(); pop();\n      pop(); pop();\n\n      if (len == 1 && name[0] == '+')  {\n        gen_addsub(s, OP_ADD, cursp());\n      }\n      else if (len == 1 && name[0] == '-')  {\n        gen_addsub(s, OP_SUB, cursp());\n      }\n      else if (len == 1 && name[0] == '*')  {\n        genop_1(s, OP_MUL, cursp());\n      }\n      else if (len == 1 && name[0] == '/')  {\n        genop_1(s, OP_DIV, cursp());\n      }\n      else if (len == 1 && name[0] == '<')  {\n        genop_1(s, OP_LT, cursp());\n      }\n      else if (len == 2 && name[0] == '<' && name[1] == '=')  {\n        genop_1(s, OP_LE, cursp());\n      }\n      else if (len == 1 && name[0] == '>')  {\n        genop_1(s, OP_GT, cursp());\n      }\n      else if (len == 2 && name[0] == '>' && name[1] == '=')  {\n        genop_1(s, OP_GE, cursp());\n      }\n      else {\n        idx = new_sym(s, sym);\n        genop_3(s, OP_SEND, cursp(), idx, 1);\n      }\n      if (callargs < 0) {\n        gen_assignment(s, tree->car, NULL, cursp(), val);\n      }\n      else {\n        if (val && vsp >= 0) {\n          gen_move(s, vsp, cursp(), 0);\n        }\n        if (callargs == CALL_MAXARGS) {\n          pop();\n          genop_2(s, OP_ARYPUSH, cursp(), 1);\n        }\n        else {\n          pop_n(callargs);\n          callargs++;\n        }\n        pop();\n        idx = new_sym(s, attrsym(s,nsym(tree->car->cdr->cdr->car)));\n        genop_3(s, OP_SEND, cursp(), idx, callargs);\n      }\n    }\n    break;\n\n  case NODE_SUPER:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0;\n      int n = 0, nk = 0, st = 0;\n\n      push();\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (tree) {\n        node *args = tree->car;\n        if (args) {\n          st = n = gen_values(s, args, VAL, 14);\n          if (n < 0) {\n            st = 1; n = 15;\n            push();\n          }\n        }\n        /* keyword arguments */\n        if (s2 && (s2->ainfo & 0x1) && tree->cdr->car) {\n          nk = gen_hash(s, tree->cdr->car->cdr, VAL, 14);\n          if (nk < 0) {st++; nk = 15;}\n          else st += nk*2;\n          n |= nk<<4;\n        }\n        /* block arguments */\n        if (tree->cdr->cdr) {\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n        else if (!s2) {/* super at top-level */\n          push();      /* no need to push block */\n        }\n        else {\n          gen_blkmove(s, s2->ainfo, lv);\n        }\n        st++;\n      }\n      else {\n        if (!s2) push();\n        else gen_blkmove(s, s2->ainfo, lv);\n        st++;\n      }\n      pop_n(st+1);\n      genop_2(s, OP_SUPER, cursp(), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_ZSUPER:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0;\n      uint16_t ainfo = 0;\n      int n = CALL_MAXARGS;\n      int sp = cursp();\n\n      push();        /* room for receiver */\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (s2 && s2->ainfo > 0) {\n        ainfo = s2->ainfo;\n      }\n      if (ainfo > 0) {\n        genop_2S(s, OP_ARGARY, cursp(), (ainfo<<4)|(lv & 0xf));\n        push(); push(); push();   /* ARGARY pushes 3 values at most */\n        pop(); pop(); pop();\n        /* keyword arguments */\n        if (ainfo & 0x1) {\n          n |= CALL_MAXARGS<<4;\n          push();\n        }\n        /* block argument */\n        if (tree && tree->cdr && tree->cdr->cdr) {\n          push();\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n      }\n      else {\n        /* block argument */\n        if (tree && tree->cdr && tree->cdr->cdr) {\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n        else {\n          gen_blkmove(s, 0, lv);\n        }\n        n = 0;\n      }\n      s->sp = sp;\n      genop_2(s, OP_SUPER, cursp(), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_RETURN:\n    if (tree) {\n      gen_retval(s, tree);\n    }\n    else {\n      genop_1(s, OP_LOADNIL, cursp());\n    }\n    if (s->loop) {\n      gen_return(s, OP_RETURN_BLK, cursp());\n    }\n    else {\n      gen_return(s, OP_RETURN, cursp());\n    }\n    if (val) push();\n    break;\n\n  case NODE_YIELD:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0, ainfo = -1;\n      int n = 0, sendv = 0;\n\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (s2) {\n        ainfo = (int)s2->ainfo;\n      }\n      if (ainfo < 0) codegen_error(s, \"invalid yield (SyntaxError)\");\n      push();\n      if (tree) {\n        n = gen_values(s, tree, VAL, 14);\n        if (n < 0) {\n          n = sendv = 1;\n          push();\n        }\n      }\n      push();pop(); /* space for a block */\n      pop_n(n+1);\n      genop_2S(s, OP_BLKPUSH, cursp(), (ainfo<<4)|(lv & 0xf));\n      if (sendv) n = CALL_MAXARGS;\n      genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, call)), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_BREAK:\n    loop_break(s, tree);\n    if (val) push();\n    break;\n\n  case NODE_NEXT:\n    if (!s->loop) {\n      raise_error(s, \"unexpected next\");\n    }\n    else if (s->loop->type == LOOP_NORMAL) {\n      codegen(s, tree, NOVAL);\n      genjmp(s, OP_JMPUW, s->loop->pc0);\n    }\n    else {\n      if (tree) {\n        codegen(s, tree, VAL);\n        pop();\n      }\n      else {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      gen_return(s, OP_RETURN, cursp());\n    }\n    if (val) push();\n    break;\n\n  case NODE_REDO:\n    if (!s->loop || s->loop->type == LOOP_BEGIN || s->loop->type == LOOP_RESCUE) {\n      raise_error(s, \"unexpected redo\");\n    }\n    else {\n      genjmp(s, OP_JMPUW, s->loop->pc1);\n    }\n    if (val) push();\n    break;\n\n  case NODE_RETRY:\n    {\n      const char *msg = \"unexpected retry\";\n      const struct loopinfo *lp = s->loop;\n\n      while (lp && lp->type != LOOP_RESCUE) {\n        lp = lp->prev;\n      }\n      if (!lp) {\n        raise_error(s, msg);\n      }\n      else {\n        genjmp(s, OP_JMPUW, lp->pc0);\n      }\n      if (val) push();\n    }\n    break;\n\n  case NODE_LVAR:\n    if (val) {\n      int idx = lv_idx(s, nsym(tree));\n\n      if (idx > 0) {\n        gen_move(s, cursp(), idx, val);\n      }\n      else {\n        gen_getupvar(s, cursp(), nsym(tree));\n      }\n      push();\n    }\n    break;\n\n  case NODE_NVAR:\n    if (val) {\n      int idx = nint(tree);\n\n      gen_move(s, cursp(), idx, val);\n\n      push();\n    }\n    break;\n\n  case NODE_GVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETGV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_IVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETIV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_CVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETCV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_CONST:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETCONST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_BACK_REF:\n    if (val) {\n      char buf[] = {'$', nchar(tree)};\n      int sym = new_sym(s, mrb_intern(s->mrb, buf, sizeof(buf)));\n\n      genop_2(s, OP_GETGV, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_NTH_REF:\n    if (val) {\n      mrb_state *mrb = s->mrb;\n      mrb_value str;\n      int sym;\n\n      str = mrb_format(mrb, \"$%d\", nint(tree));\n      sym = new_sym(s, mrb_intern_str(mrb, str));\n      genop_2(s, OP_GETGV, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_ARG:\n    /* should not happen */\n    break;\n\n  case NODE_BLOCK_ARG:\n    if (!tree) {\n      int idx = lv_idx(s, MRB_OPSYM_2(s->mrb, and));\n\n      if (idx == 0) {\n        codegen_error(s, \"no anonymous block argument\");\n      }\n      gen_move(s, cursp(), idx, val);\n    }\n    else {\n      codegen(s, tree, val);\n    }\n    break;\n\n  case NODE_INT:\n    if (val) {\n      char *p = (char*)tree->car;\n      int base = nint(tree->cdr->car);\n      mrb_int i;\n      mrb_bool overflow;\n\n      i = readint(s, p, base, FALSE, &overflow);\n      if (overflow) {\n        int off = new_litbn(s, p, base, FALSE);\n        genop_2(s, OP_LOADL, cursp(), off);\n      }\n      else {\n        gen_int(s, cursp(), i);\n      }\n      push();\n    }\n    break;\n\n#ifndef MRB_NO_FLOAT\n  case NODE_FLOAT:\n    if (val) {\n      char *p = (char*)tree;\n      mrb_float f = mrb_float_read(p, NULL);\n      int off = new_lit(s, mrb_float_value(s->mrb, f));\n\n      genop_2(s, OP_LOADL, cursp(), off);\n      push();\n    }\n    break;\n#endif\n\n  case NODE_NEGATE:\n    {\n      nt = nint(tree->car);\n      switch (nt) {\n#ifndef MRB_NO_FLOAT\n      case NODE_FLOAT:\n        if (val) {\n          char *p = (char*)tree->cdr;\n          mrb_float f = mrb_float_read(p, NULL);\n          int off = new_lit(s, mrb_float_value(s->mrb, -f));\n\n          genop_2(s, OP_LOADL, cursp(), off);\n          push();\n        }\n        break;\n#endif\n\n      case NODE_INT:\n        if (val) {\n          char *p = (char*)tree->cdr->car;\n          int base = nint(tree->cdr->cdr->car);\n          mrb_int i;\n          mrb_bool overflow;\n\n          i = readint(s, p, base, TRUE, &overflow);\n          if (overflow) {\n            int off = new_litbn(s, p, base, TRUE);\n            genop_2(s, OP_LOADL, cursp(), off);\n          }\n          else {\n            gen_int(s, cursp(), i);\n          }\n          push();\n        }\n        break;\n\n      default:\n        if (val) {\n          codegen(s, tree, VAL);\n          pop();\n          push_n(2);pop_n(2); /* space for receiver&block */\n          mrb_sym minus = MRB_OPSYM_2(s->mrb, minus);\n          if (!gen_uniop(s, minus, cursp())) {\n            genop_3(s, OP_SEND, cursp(), new_sym(s, minus), 0);\n          }\n          push();\n        }\n        else {\n          codegen(s, tree, NOVAL);\n        }\n        break;\n      }\n    }\n    break;\n\n  case NODE_STR:\n    if (val) {\n      char *p = (char*)tree->car;\n      size_t len = (intptr_t)tree->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int off = new_lit(s, mrb_str_new(s->mrb, p, len));\n\n      mrb_gc_arena_restore(s->mrb, ai);\n      genop_2(s, OP_STRING, cursp(), off);\n      push();\n    }\n    break;\n\n  case NODE_HEREDOC:\n    tree = ((struct mrb_parser_heredoc_info *)tree)->doc;\n    /* fall through */\n  case NODE_DSTR:\n    if (val) {\n      node *n = tree;\n\n      if (!n) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n        break;\n      }\n      codegen(s, n->car, VAL);\n      n = n->cdr;\n      while (n) {\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n    }\n    else {\n      node *n = tree;\n\n      while (n) {\n        if (nint(n->car->car) != NODE_STR) {\n          codegen(s, n->car, NOVAL);\n        }\n        n = n->cdr;\n      }\n    }\n    break;\n\n  case NODE_WORDS:\n    gen_literal_array(s, tree, FALSE, val);\n    break;\n\n  case NODE_SYMBOLS:\n    gen_literal_array(s, tree, TRUE, val);\n    break;\n\n  case NODE_DXSTR:\n    {\n      node *n;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, MRB_SYM_2(s->mrb, Kernel));\n\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n      codegen(s, tree->car, VAL);\n      n = tree->cdr;\n      while (n) {\n        if (nint(n->car->car) == NODE_XSTR) {\n          n->car->car = (struct mrb_ast_node*)(intptr_t)NODE_STR;\n          mrb_assert(!n->cdr); /* must be the end */\n        }\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n      push();                   /* for block */\n      pop_n(3);\n      sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick)); /* ` */\n      genop_3(s, OP_SEND, cursp(), sym, 1);\n      if (val) push();\n      mrb_gc_arena_restore(s->mrb, ai);\n    }\n    break;\n\n  case NODE_XSTR:\n    {\n      char *p = (char*)tree->car;\n      size_t len = (intptr_t)tree->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int off = new_lit(s, mrb_str_new(s->mrb, p, len));\n      int sym;\n\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n      genop_2(s, OP_STRING, cursp(), off);\n      push(); push();\n      pop_n(3);\n      sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick)); /* ` */\n      genop_3(s, OP_SEND, cursp(), sym, 1);\n      if (val) push();\n      mrb_gc_arena_restore(s->mrb, ai);\n    }\n    break;\n\n  case NODE_REGX:\n    if (val) {\n      char *p1 = (char*)tree->car;\n      char *p2 = (char*)tree->cdr->car;\n      char *p3 = (char*)tree->cdr->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));\n      int off = new_lit(s, mrb_str_new_cstr(s->mrb, p1));\n      int argc = 1;\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      push();\n      genop_2(s, OP_STRING, cursp(), off);\n      push();\n      if (p2 || p3) {\n        if (p2) { /* opt */\n          off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n          genop_2(s, OP_STRING, cursp(), off);\n        }\n        else {\n          genop_1(s, OP_LOADNIL, cursp());\n        }\n        push();\n        argc++;\n        if (p3) { /* enc */\n          off = new_lit(s, mrb_str_new(s->mrb, p3, 1));\n          genop_2(s, OP_STRING, cursp(), off);\n          push();\n          argc++;\n        }\n      }\n      push(); /* space for a block */\n      pop_n(argc+2);\n      sym = new_sym(s, MRB_SYM_2(s->mrb, compile));\n      genop_3(s, OP_SEND, cursp(), sym, argc);\n      mrb_gc_arena_restore(s->mrb, ai);\n      push();\n    }\n    break;\n\n  case NODE_DREGX:\n    if (val) {\n      node *n = tree->car;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));\n      int argc = 1;\n      int off;\n      char *p;\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      push();\n      codegen(s, n->car, VAL);\n      n = n->cdr;\n      while (n) {\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n      n = tree->cdr->cdr;\n      if (n->car) { /* tail */\n        p = (char*)n->car;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p));\n        codegen(s, tree->car, VAL);\n        genop_2(s, OP_STRING, cursp(), off);\n        pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n      }\n      if (n->cdr->car) { /* opt */\n        char *p2 = (char*)n->cdr->car;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n        genop_2(s, OP_STRING, cursp(), off);\n        push();\n        argc++;\n      }\n      if (n->cdr->cdr) { /* enc */\n        char *p2 = (char*)n->cdr->cdr;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n        genop_2(s, OP_STRING, cursp(), off);\n        push();\n        argc++;\n      }\n      push(); /* space for a block */\n      pop_n(argc+2);\n      sym = new_sym(s, MRB_SYM_2(s->mrb, compile));\n      genop_3(s, OP_SEND, cursp(), sym, argc);\n      mrb_gc_arena_restore(s->mrb, ai);\n      push();\n    }\n    else {\n      node *n = tree->car;\n\n      while (n) {\n        if (nint(n->car->car) != NODE_STR) {\n          codegen(s, n->car, NOVAL);\n        }\n        n = n->cdr;\n      }\n    }\n    break;\n\n  case NODE_SYM:\n    if (val) {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_LOADSYM, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_DSYM:\n    codegen(s, tree, val);\n    if (val) {\n      gen_intern(s);\n    }\n    break;\n\n  case NODE_SELF:\n    if (val) {\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n    }\n    break;\n\n  case NODE_NIL:\n    if (val) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    break;\n\n  case NODE_TRUE:\n    if (val) {\n      genop_1(s, OP_LOADT, cursp());\n      push();\n    }\n    break;\n\n  case NODE_FALSE:\n    if (val) {\n      genop_1(s, OP_LOADF, cursp());\n      push();\n    }\n    break;\n\n  case NODE_ALIAS:\n    {\n      int a = new_sym(s, nsym(tree->car));\n      int b = new_sym(s, nsym(tree->cdr));\n\n      genop_2(s, OP_ALIAS, a, b);\n      if (val) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n    }\n   break;\n\n  case NODE_UNDEF:\n    {\n      node *t = tree;\n\n      while (t) {\n        int symbol = new_sym(s, nsym(t->car));\n        genop_1(s, OP_UNDEF, symbol);\n        t = t->cdr;\n      }\n      if (val) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n    }\n    break;\n\n  case NODE_CLASS:\n    {\n      int idx;\n      node *body;\n\n      if (tree->car->car == (node*)0) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      else if (tree->car->car == (node*)1) {\n        genop_1(s, OP_OCLASS, cursp());\n        push();\n      }\n      else {\n        codegen(s, tree->car->car, VAL);\n      }\n      if (tree->cdr->car) {\n        codegen(s, tree->cdr->car, VAL);\n      }\n      else {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      pop(); pop();\n      idx = new_sym(s, nsym(tree->car->cdr));\n      genop_2(s, OP_CLASS, cursp(), idx);\n      body = tree->cdr->cdr->car;\n      if (nint(body->cdr->car) == NODE_BEGIN && body->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, body, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_MODULE:\n    {\n      int idx;\n\n      if (tree->car->car == (node*)0) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      else if (tree->car->car == (node*)1) {\n        genop_1(s, OP_OCLASS, cursp());\n        push();\n      }\n      else {\n        codegen(s, tree->car->car, VAL);\n      }\n      pop();\n      idx = new_sym(s, nsym(tree->car->cdr));\n      genop_2(s, OP_MODULE, cursp(), idx);\n      if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&\n          tree->cdr->car->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, tree->cdr->car, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_SCLASS:\n    {\n      int idx;\n\n      codegen(s, tree->car, VAL);\n      pop();\n      genop_1(s, OP_SCLASS, cursp());\n      if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&\n          tree->cdr->car->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, tree->cdr->car, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_DEF:\n    {\n      int sym = new_sym(s, nsym(tree->car));\n      int idx = lambda_body(s, tree->cdr, 0);\n\n      genop_1(s, OP_TCLASS, cursp());\n      push();\n      genop_2(s, OP_METHOD, cursp(), idx);\n      push(); pop();\n      pop();\n      genop_2(s, OP_DEF, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_SDEF:\n    {\n      node *recv = tree->car;\n      int sym = new_sym(s, nsym(tree->cdr->car));\n      int idx = lambda_body(s, tree->cdr->cdr, 0);\n\n      codegen(s, recv, VAL);\n      pop();\n      genop_1(s, OP_SCLASS, cursp());\n      push();\n      genop_2(s, OP_METHOD, cursp(), idx);\n      pop();\n      genop_2(s, OP_DEF, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_POSTEXE:\n    codegen(s, tree, NOVAL);\n    break;\n\n  default:\n    break;\n  }\n exit:\n  s->rlev = rlev;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147954,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "codegen(codegen_scope *s, node *tree, int val)\n{\n  int nt;\n  int rlev = s->rlev;\n\n  if (!tree) {\n    if (val) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    return;\n  }\n\n  s->rlev++;\n  if (s->rlev > MRB_CODEGEN_LEVEL_MAX) {\n    codegen_error(s, \"too complex expression\");\n  }\n  if (s->irep && s->filename_index != tree->filename_index) {\n    mrb_sym fname = mrb_parser_get_filename(s->parser, s->filename_index);\n    const char *filename = mrb_sym_name_len(s->mrb, fname, NULL);\n\n    mrb_debug_info_append_file(s->mrb, s->irep->debug_info,\n                               filename, s->lines, s->debug_start_pos, s->pc);\n    s->debug_start_pos = s->pc;\n    s->filename_index = tree->filename_index;\n    s->filename_sym = mrb_parser_get_filename(s->parser, tree->filename_index);\n  }\n\n  nt = nint(tree->car);\n  s->lineno = tree->lineno;\n  tree = tree->cdr;\n  switch (nt) {\n  case NODE_BEGIN:\n    if (val && !tree) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    while (tree) {\n      codegen(s, tree->car, tree->cdr ? NOVAL : val);\n      tree = tree->cdr;\n    }\n    break;\n\n  case NODE_RESCUE:\n    {\n      int noexc;\n      uint32_t exend, pos1, pos2, tmp;\n      struct loopinfo *lp;\n      int catch_entry, begin, end;\n\n      if (tree->car == NULL) goto exit;\n      lp = loop_push(s, LOOP_BEGIN);\n      lp->pc0 = new_label(s);\n      catch_entry = catch_handler_new(s);\n      begin = s->pc;\n      codegen(s, tree->car, VAL);\n      pop();\n      lp->type = LOOP_RESCUE;\n      end = s->pc;\n      noexc = genjmp_0(s, OP_JMP);\n      catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);\n      tree = tree->cdr;\n      exend = JMPLINK_START;\n      pos1 = JMPLINK_START;\n      if (tree->car) {\n        node *n2 = tree->car;\n        int exc = cursp();\n\n        genop_1(s, OP_EXCEPT, exc);\n        push();\n        while (n2) {\n          node *n3 = n2->car;\n          node *n4 = n3->car;\n\n          dispatch(s, pos1);\n          pos2 = JMPLINK_START;\n          do {\n            if (n4 && n4->car && nint(n4->car->car) == NODE_SPLAT) {\n              codegen(s, n4->car, VAL);\n              gen_move(s, cursp(), exc, 0);\n              push_n(2); pop_n(2); /* space for one arg and a block */\n              pop();\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);\n            }\n            else {\n              if (n4) {\n                codegen(s, n4->car, VAL);\n              }\n              else {\n                genop_2(s, OP_GETCONST, cursp(), new_sym(s, MRB_SYM_2(s->mrb, StandardError)));\n                push();\n              }\n              pop();\n              genop_2(s, OP_RESCUE, exc, cursp());\n            }\n            tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, val);\n            pos2 = tmp;\n            if (n4) {\n              n4 = n4->cdr;\n            }\n          } while (n4);\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch_linked(s, pos2);\n\n          pop();\n          if (n3->cdr->car) {\n            gen_assignment(s, n3->cdr->car, NULL, exc, NOVAL);\n          }\n          if (n3->cdr->cdr->car) {\n            codegen(s, n3->cdr->cdr->car, val);\n            if (val) pop();\n          }\n          tmp = genjmp(s, OP_JMP, exend);\n          exend = tmp;\n          n2 = n2->cdr;\n          push();\n        }\n        if (pos1 != JMPLINK_START) {\n          dispatch(s, pos1);\n          genop_1(s, OP_RAISEIF, exc);\n        }\n      }\n      pop();\n      tree = tree->cdr;\n      dispatch(s, noexc);\n      if (tree->car) {\n        codegen(s, tree->car, val);\n      }\n      else if (val) {\n        push();\n      }\n      dispatch_linked(s, exend);\n      loop_pop(s, NOVAL);\n    }\n    break;\n\n  case NODE_ENSURE:\n    if (!tree->cdr || !tree->cdr->cdr ||\n        (nint(tree->cdr->cdr->car) == NODE_BEGIN &&\n         tree->cdr->cdr->cdr)) {\n      int catch_entry, begin, end, target;\n      int idx;\n\n      catch_entry = catch_handler_new(s);\n      begin = s->pc;\n      codegen(s, tree->car, val);\n      end = target = s->pc;\n      push();\n      idx = cursp();\n      genop_1(s, OP_EXCEPT, idx);\n      push();\n      codegen(s, tree->cdr->cdr, NOVAL);\n      pop();\n      genop_1(s, OP_RAISEIF, idx);\n      pop();\n      catch_handler_set(s, catch_entry, MRB_CATCH_ENSURE, begin, end, target);\n    }\n    else {                      /* empty ensure ignored */\n      codegen(s, tree->car, val);\n    }\n    break;\n\n  case NODE_LAMBDA:\n    if (val) {\n      int idx = lambda_body(s, tree, 1);\n\n      genop_2(s, OP_LAMBDA, cursp(), idx);\n      push();\n    }\n    break;\n\n  case NODE_BLOCK:\n    if (val) {\n      int idx = lambda_body(s, tree, 1);\n\n      genop_2(s, OP_BLOCK, cursp(), idx);\n      push();\n    }\n    break;\n\n  case NODE_IF:\n    {\n      uint32_t pos1, pos2;\n      mrb_bool nil_p = FALSE;\n      node *elsepart = tree->cdr->cdr->car;\n\n      if (!tree->car) {\n        codegen(s, elsepart, val);\n        goto exit;\n      }\n      if (true_always(tree->car)) {\n        codegen(s, tree->cdr->car, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, elsepart, val);\n        goto exit;\n      }\n      if (nint(tree->car->car) == NODE_CALL) {\n        node *n = tree->car->cdr;\n        mrb_sym mid = nsym(n->cdr->car);\n        mrb_sym sym_nil_p = MRB_SYM_Q_2(s->mrb, nil);\n        if (mid == sym_nil_p && n->cdr->cdr->car == NULL) {\n          nil_p = TRUE;\n          codegen(s, n->car, VAL);\n        }\n      }\n      if (!nil_p) {\n        codegen(s, tree->car, VAL);\n      }\n      pop();\n      if (val || tree->cdr->car) {\n        if (nil_p) {\n          pos2 = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch(s, pos2);\n        }\n        else {\n          pos1 = genjmp2_0(s, OP_JMPNOT, cursp(), val);\n        }\n        codegen(s, tree->cdr->car, val);\n        if (val) pop();\n        if (elsepart || val) {\n          pos2 = genjmp_0(s, OP_JMP);\n          dispatch(s, pos1);\n          codegen(s, elsepart, val);\n          dispatch(s, pos2);\n        }\n        else {\n          dispatch(s, pos1);\n        }\n      }\n      else {                    /* empty then-part */\n        if (elsepart) {\n          if (nil_p) {\n            pos1 = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n          }\n          else {\n            pos1 = genjmp2_0(s, OP_JMPIF, cursp(), val);\n          }\n          codegen(s, elsepart, val);\n          dispatch(s, pos1);\n        }\n        else if (val && !nil_p) {\n          genop_1(s, OP_LOADNIL, cursp());\n          push();\n        }\n      }\n    }\n    break;\n\n  case NODE_AND:\n    {\n      uint32_t pos;\n\n      if (true_always(tree->car)) {\n        codegen(s, tree->cdr, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, tree->car, val);\n        goto exit;\n      }\n      codegen(s, tree->car, VAL);\n      pop();\n      pos = genjmp2_0(s, OP_JMPNOT, cursp(), val);\n      codegen(s, tree->cdr, val);\n      dispatch(s, pos);\n    }\n    break;\n\n  case NODE_OR:\n    {\n      uint32_t pos;\n\n      if (true_always(tree->car)) {\n        codegen(s, tree->car, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, tree->cdr, val);\n        goto exit;\n      }\n      codegen(s, tree->car, VAL);\n      pop();\n      pos = genjmp2_0(s, OP_JMPIF, cursp(), val);\n      codegen(s, tree->cdr, val);\n      dispatch(s, pos);\n    }\n    break;\n\n  case NODE_WHILE:\n  case NODE_UNTIL:\n    {\n      if (true_always(tree->car)) {\n        if (nt == NODE_UNTIL) {\n          if (val) {\n            genop_1(s, OP_LOADNIL, cursp());\n            push();\n          }\n          goto exit;\n        }\n      }\n      else if (false_always(tree->car)) {\n        if (nt == NODE_WHILE) {\n          if (val) {\n            genop_1(s, OP_LOADNIL, cursp());\n            push();\n          }\n          goto exit;\n        }\n      }\n\n      uint32_t pos = JMPLINK_START;\n      struct loopinfo *lp = loop_push(s, LOOP_NORMAL);\n\n      if (!val) lp->reg = -1;\n      lp->pc0 = new_label(s);\n      codegen(s, tree->car, VAL);\n      pop();\n      if (nt == NODE_WHILE) {\n        pos = genjmp2_0(s, OP_JMPNOT, cursp(), NOVAL);\n      }\n      else {\n        pos = genjmp2_0(s, OP_JMPIF, cursp(), NOVAL);\n      }\n      lp->pc1 = new_label(s);\n      codegen(s, tree->cdr, NOVAL);\n      genjmp(s, OP_JMP, lp->pc0);\n      dispatch(s, pos);\n      loop_pop(s, val);\n    }\n    break;\n\n  case NODE_FOR:\n    for_body(s, tree);\n    if (val) push();\n    break;\n\n  case NODE_CASE:\n    {\n      int head = 0;\n      uint32_t pos1, pos2, pos3, tmp;\n      node *n;\n\n      pos3 = JMPLINK_START;\n      if (tree->car) {\n        head = cursp();\n        codegen(s, tree->car, VAL);\n      }\n      tree = tree->cdr;\n      while (tree) {\n        n = tree->car->car;\n        pos1 = pos2 = JMPLINK_START;\n        while (n) {\n          codegen(s, n->car, VAL);\n          if (head) {\n            gen_move(s, cursp(), head, 0);\n            push(); push(); pop(); pop(); pop();\n            if (nint(n->car->car) == NODE_SPLAT) {\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);\n            }\n            else {\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_OPSYM_2(s->mrb, eqq)), 1);\n            }\n          }\n          else {\n            pop();\n          }\n          tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, NOVAL);\n          pos2 = tmp;\n          n = n->cdr;\n        }\n        if (tree->car->car) {\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch_linked(s, pos2);\n        }\n        codegen(s, tree->car->cdr, val);\n        if (val) pop();\n        tmp = genjmp(s, OP_JMP, pos3);\n        pos3 = tmp;\n        dispatch(s, pos1);\n        tree = tree->cdr;\n      }\n      if (val) {\n        uint32_t pos = cursp();\n        genop_1(s, OP_LOADNIL, cursp());\n        if (pos3 != JMPLINK_START) dispatch_linked(s, pos3);\n        if (head) pop();\n        if (cursp() != pos) {\n          gen_move(s, cursp(), pos, 0);\n        }\n        push();\n      }\n      else {\n        if (pos3 != JMPLINK_START) {\n          dispatch_linked(s, pos3);\n        }\n        if (head) {\n          pop();\n        }\n      }\n    }\n    break;\n\n  case NODE_SCOPE:\n    scope_body(s, tree, NOVAL);\n    break;\n\n  case NODE_FCALL:\n  case NODE_CALL:\n    gen_call(s, tree, val, 0);\n    break;\n  case NODE_SCALL:\n    gen_call(s, tree, val, 1);\n    break;\n\n  case NODE_DOT2:\n    codegen(s, tree->car, val);\n    codegen(s, tree->cdr, val);\n    if (val) {\n      pop(); pop();\n      genop_1(s, OP_RANGE_INC, cursp());\n      push();\n    }\n    break;\n\n  case NODE_DOT3:\n    codegen(s, tree->car, val);\n    codegen(s, tree->cdr, val);\n    if (val) {\n      pop(); pop();\n      genop_1(s, OP_RANGE_EXC, cursp());\n      push();\n    }\n    break;\n\n  case NODE_COLON2:\n    {\n      int sym = new_sym(s, nsym(tree->cdr));\n\n      codegen(s, tree->car, VAL);\n      pop();\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_COLON3:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_ARRAY:\n    {\n      int n;\n\n      n = gen_values(s, tree, val, 0);\n      if (val) {\n        if (n >= 0) {\n          pop_n(n);\n          genop_2(s, OP_ARRAY, cursp(), n);\n        }\n        push();\n      }\n    }\n    break;\n\n  case NODE_HASH:\n  case NODE_KW_HASH:\n    {\n      int nk = gen_hash(s, tree, val, GEN_LIT_ARY_MAX);\n      if (val && nk >= 0) {\n        pop_n(nk*2);\n        genop_2(s, OP_HASH, cursp(), nk);\n        push();\n      }\n    }\n    break;\n\n  case NODE_SPLAT:\n    codegen(s, tree, val);\n    break;\n\n  case NODE_ASGN:\n    gen_assignment(s, tree->car, tree->cdr, 0, val);\n    break;\n\n  case NODE_MASGN:\n    {\n      int len = 0, n = 0, post = 0;\n      node *t = tree->cdr, *p;\n      int rhs = cursp();\n\n      if (nint(t->car) == NODE_ARRAY && t->cdr && nosplat(t->cdr)) {\n        /* fixed rhs */\n        t = t->cdr;\n        while (t) {\n          codegen(s, t->car, VAL);\n          len++;\n          t = t->cdr;\n        }\n        tree = tree->car;\n        if (tree->car) {                /* pre */\n          t = tree->car;\n          n = 0;\n          while (t) {\n            if (n < len) {\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n              n++;\n            }\n            else {\n              genop_1(s, OP_LOADNIL, rhs+n);\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n            }\n            t = t->cdr;\n          }\n        }\n        t = tree->cdr;\n        if (t) {\n          if (t->cdr) {         /* post count */\n            p = t->cdr->car;\n            while (p) {\n              post++;\n              p = p->cdr;\n            }\n          }\n          if (t->car) {         /* rest (len - pre - post) */\n            int rn;\n\n            if (len < post + n) {\n              rn = 0;\n            }\n            else {\n              rn = len - post - n;\n            }\n            genop_3(s, OP_ARRAY2, cursp(), rhs+n, rn);\n            gen_assignment(s, t->car, NULL, cursp(), NOVAL);\n            n += rn;\n          }\n          if (t->cdr && t->cdr->car) {\n            t = t->cdr->car;\n            while (n<len) {\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n              t = t->cdr;\n              n++;\n            }\n          }\n        }\n        pop_n(len);\n        if (val) {\n          genop_2(s, OP_ARRAY, rhs, len);\n          push();\n        }\n      }\n      else {\n        /* variable rhs */\n        codegen(s, t, VAL);\n        gen_vmassignment(s, tree->car, rhs, val);\n        if (!val) {\n          pop();\n        }\n      }\n    }\n    break;\n\n  case NODE_OP_ASGN:\n    {\n      mrb_sym sym = nsym(tree->cdr->car);\n      mrb_int len;\n      const char *name = mrb_sym_name_len(s->mrb, sym, &len);\n      int idx, callargs = -1, vsp = -1;\n\n      if ((len == 2 && name[0] == '|' && name[1] == '|') &&\n          (nint(tree->car->car) == NODE_CONST ||\n           nint(tree->car->car) == NODE_CVAR)) {\n        int catch_entry, begin, end;\n        int noexc, exc;\n        struct loopinfo *lp;\n\n        lp = loop_push(s, LOOP_BEGIN);\n        lp->pc0 = new_label(s);\n        catch_entry = catch_handler_new(s);\n        begin = s->pc;\n        exc = cursp();\n        codegen(s, tree->car, VAL);\n        end = s->pc;\n        noexc = genjmp_0(s, OP_JMP);\n        lp->type = LOOP_RESCUE;\n        catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);\n        genop_1(s, OP_EXCEPT, exc);\n        genop_1(s, OP_LOADF, exc);\n        dispatch(s, noexc);\n        loop_pop(s, NOVAL);\n      }\n      else if (nint(tree->car->car) == NODE_CALL) {\n        node *n = tree->car->cdr;\n        int base, i, nargs = 0;\n        callargs = 0;\n\n        if (val) {\n          vsp = cursp();\n          push();\n        }\n        codegen(s, n->car, VAL);   /* receiver */\n        idx = new_sym(s, nsym(n->cdr->car));\n        base = cursp()-1;\n        if (n->cdr->cdr->car) {\n          nargs = gen_values(s, n->cdr->cdr->car->car, VAL, 13);\n          if (nargs >= 0) {\n            callargs = nargs;\n          }\n          else { /* varargs */\n            push();\n            nargs = 1;\n            callargs = CALL_MAXARGS;\n          }\n        }\n        /* copy receiver and arguments */\n        gen_move(s, cursp(), base, 1);\n        for (i=0; i<nargs; i++) {\n          gen_move(s, cursp()+i+1, base+i+1, 1);\n        }\n        push_n(nargs+2);pop_n(nargs+2); /* space for receiver, arguments and a block */\n        genop_3(s, OP_SEND, cursp(), idx, callargs);\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL);\n      }\n      if (len == 2 &&\n          ((name[0] == '|' && name[1] == '|') ||\n           (name[0] == '&' && name[1] == '&'))) {\n        uint32_t pos;\n\n        pop();\n        if (val) {\n          if (vsp >= 0) {\n            gen_move(s, vsp, cursp(), 1);\n          }\n          pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);\n        }\n        else {\n          pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);\n        }\n        codegen(s, tree->cdr->cdr->car, VAL);\n        pop();\n        if (val && vsp >= 0) {\n          gen_move(s, vsp, cursp(), 1);\n        }\n        if (nint(tree->car->car) == NODE_CALL) {\n          if (callargs == CALL_MAXARGS) {\n            pop();\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          else {\n            pop_n(callargs);\n            callargs++;\n          }\n          pop();\n          idx = new_sym(s, attrsym(s, nsym(tree->car->cdr->cdr->car)));\n          genop_3(s, OP_SEND, cursp(), idx, callargs);\n        }\n        else {\n          gen_assignment(s, tree->car, NULL, cursp(), val);\n        }\n        dispatch(s, pos);\n        goto exit;\n      }\n      codegen(s, tree->cdr->cdr->car, VAL);\n      push(); pop();\n      pop(); pop();\n\n      if (len == 1 && name[0] == '+')  {\n        gen_addsub(s, OP_ADD, cursp());\n      }\n      else if (len == 1 && name[0] == '-')  {\n        gen_addsub(s, OP_SUB, cursp());\n      }\n      else if (len == 1 && name[0] == '*')  {\n        genop_1(s, OP_MUL, cursp());\n      }\n      else if (len == 1 && name[0] == '/')  {\n        genop_1(s, OP_DIV, cursp());\n      }\n      else if (len == 1 && name[0] == '<')  {\n        genop_1(s, OP_LT, cursp());\n      }\n      else if (len == 2 && name[0] == '<' && name[1] == '=')  {\n        genop_1(s, OP_LE, cursp());\n      }\n      else if (len == 1 && name[0] == '>')  {\n        genop_1(s, OP_GT, cursp());\n      }\n      else if (len == 2 && name[0] == '>' && name[1] == '=')  {\n        genop_1(s, OP_GE, cursp());\n      }\n      else {\n        idx = new_sym(s, sym);\n        genop_3(s, OP_SEND, cursp(), idx, 1);\n      }\n      if (callargs < 0) {\n        gen_assignment(s, tree->car, NULL, cursp(), val);\n      }\n      else {\n        if (val && vsp >= 0) {\n          gen_move(s, vsp, cursp(), 0);\n        }\n        if (callargs == CALL_MAXARGS) {\n          pop();\n          genop_2(s, OP_ARYPUSH, cursp(), 1);\n        }\n        else {\n          pop_n(callargs);\n          callargs++;\n        }\n        pop();\n        idx = new_sym(s, attrsym(s,nsym(tree->car->cdr->cdr->car)));\n        genop_3(s, OP_SEND, cursp(), idx, callargs);\n      }\n    }\n    break;\n\n  case NODE_SUPER:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0;\n      int n = 0, nk = 0, st = 0;\n\n      push();\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (tree) {\n        node *args = tree->car;\n        if (args) {\n          st = n = gen_values(s, args, VAL, 14);\n          if (n < 0) {\n            st = 1; n = 15;\n            push();\n          }\n        }\n        /* keyword arguments */\n        if (s2 && (s2->ainfo & 0x1) && tree->cdr->car) {\n          nk = gen_hash(s, tree->cdr->car->cdr, VAL, 14);\n          if (nk < 0) {st++; nk = 15;}\n          else st += nk*2;\n          n |= nk<<4;\n        }\n        /* block arguments */\n        if (tree->cdr->cdr) {\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n        else if (s2) gen_blkmove(s, s2->ainfo, lv);\n        else {\n          genop_1(s, OP_LOADNIL, cursp());\n          push();\n        }\n      }\n      else {\n        if (s2) gen_blkmove(s, s2->ainfo, lv);\n        else {\n          genop_1(s, OP_LOADNIL, cursp());\n          push();\n        }\n      }\n      st++;\n      pop_n(st+1);\n      genop_2(s, OP_SUPER, cursp(), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_ZSUPER:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0;\n      uint16_t ainfo = 0;\n      int n = CALL_MAXARGS;\n      int sp = cursp();\n\n      push();        /* room for receiver */\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (s2 && s2->ainfo > 0) {\n        ainfo = s2->ainfo;\n      }\n      if (ainfo > 0) {\n        genop_2S(s, OP_ARGARY, cursp(), (ainfo<<4)|(lv & 0xf));\n        push(); push(); push();   /* ARGARY pushes 3 values at most */\n        pop(); pop(); pop();\n        /* keyword arguments */\n        if (ainfo & 0x1) {\n          n |= CALL_MAXARGS<<4;\n          push();\n        }\n        /* block argument */\n        if (tree && tree->cdr && tree->cdr->cdr) {\n          push();\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n      }\n      else {\n        /* block argument */\n        if (tree && tree->cdr && tree->cdr->cdr) {\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n        else {\n          gen_blkmove(s, 0, lv);\n        }\n        n = 0;\n      }\n      s->sp = sp;\n      genop_2(s, OP_SUPER, cursp(), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_RETURN:\n    if (tree) {\n      gen_retval(s, tree);\n    }\n    else {\n      genop_1(s, OP_LOADNIL, cursp());\n    }\n    if (s->loop) {\n      gen_return(s, OP_RETURN_BLK, cursp());\n    }\n    else {\n      gen_return(s, OP_RETURN, cursp());\n    }\n    if (val) push();\n    break;\n\n  case NODE_YIELD:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0, ainfo = -1;\n      int n = 0, sendv = 0;\n\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (s2) {\n        ainfo = (int)s2->ainfo;\n      }\n      if (ainfo < 0) codegen_error(s, \"invalid yield (SyntaxError)\");\n      push();\n      if (tree) {\n        n = gen_values(s, tree, VAL, 14);\n        if (n < 0) {\n          n = sendv = 1;\n          push();\n        }\n      }\n      push();pop(); /* space for a block */\n      pop_n(n+1);\n      genop_2S(s, OP_BLKPUSH, cursp(), (ainfo<<4)|(lv & 0xf));\n      if (sendv) n = CALL_MAXARGS;\n      genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, call)), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_BREAK:\n    loop_break(s, tree);\n    if (val) push();\n    break;\n\n  case NODE_NEXT:\n    if (!s->loop) {\n      raise_error(s, \"unexpected next\");\n    }\n    else if (s->loop->type == LOOP_NORMAL) {\n      codegen(s, tree, NOVAL);\n      genjmp(s, OP_JMPUW, s->loop->pc0);\n    }\n    else {\n      if (tree) {\n        codegen(s, tree, VAL);\n        pop();\n      }\n      else {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      gen_return(s, OP_RETURN, cursp());\n    }\n    if (val) push();\n    break;\n\n  case NODE_REDO:\n    if (!s->loop || s->loop->type == LOOP_BEGIN || s->loop->type == LOOP_RESCUE) {\n      raise_error(s, \"unexpected redo\");\n    }\n    else {\n      genjmp(s, OP_JMPUW, s->loop->pc1);\n    }\n    if (val) push();\n    break;\n\n  case NODE_RETRY:\n    {\n      const char *msg = \"unexpected retry\";\n      const struct loopinfo *lp = s->loop;\n\n      while (lp && lp->type != LOOP_RESCUE) {\n        lp = lp->prev;\n      }\n      if (!lp) {\n        raise_error(s, msg);\n      }\n      else {\n        genjmp(s, OP_JMPUW, lp->pc0);\n      }\n      if (val) push();\n    }\n    break;\n\n  case NODE_LVAR:\n    if (val) {\n      int idx = lv_idx(s, nsym(tree));\n\n      if (idx > 0) {\n        gen_move(s, cursp(), idx, val);\n      }\n      else {\n        gen_getupvar(s, cursp(), nsym(tree));\n      }\n      push();\n    }\n    break;\n\n  case NODE_NVAR:\n    if (val) {\n      int idx = nint(tree);\n\n      gen_move(s, cursp(), idx, val);\n\n      push();\n    }\n    break;\n\n  case NODE_GVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETGV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_IVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETIV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_CVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETCV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_CONST:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETCONST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_BACK_REF:\n    if (val) {\n      char buf[] = {'$', nchar(tree)};\n      int sym = new_sym(s, mrb_intern(s->mrb, buf, sizeof(buf)));\n\n      genop_2(s, OP_GETGV, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_NTH_REF:\n    if (val) {\n      mrb_state *mrb = s->mrb;\n      mrb_value str;\n      int sym;\n\n      str = mrb_format(mrb, \"$%d\", nint(tree));\n      sym = new_sym(s, mrb_intern_str(mrb, str));\n      genop_2(s, OP_GETGV, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_ARG:\n    /* should not happen */\n    break;\n\n  case NODE_BLOCK_ARG:\n    if (!tree) {\n      int idx = lv_idx(s, MRB_OPSYM_2(s->mrb, and));\n\n      if (idx == 0) {\n        codegen_error(s, \"no anonymous block argument\");\n      }\n      gen_move(s, cursp(), idx, val);\n      if (val) push();\n    }\n    else {\n      codegen(s, tree, val);\n    }\n    break;\n\n  case NODE_INT:\n    if (val) {\n      char *p = (char*)tree->car;\n      int base = nint(tree->cdr->car);\n      mrb_int i;\n      mrb_bool overflow;\n\n      i = readint(s, p, base, FALSE, &overflow);\n      if (overflow) {\n        int off = new_litbn(s, p, base, FALSE);\n        genop_2(s, OP_LOADL, cursp(), off);\n      }\n      else {\n        gen_int(s, cursp(), i);\n      }\n      push();\n    }\n    break;\n\n#ifndef MRB_NO_FLOAT\n  case NODE_FLOAT:\n    if (val) {\n      char *p = (char*)tree;\n      mrb_float f = mrb_float_read(p, NULL);\n      int off = new_lit(s, mrb_float_value(s->mrb, f));\n\n      genop_2(s, OP_LOADL, cursp(), off);\n      push();\n    }\n    break;\n#endif\n\n  case NODE_NEGATE:\n    {\n      nt = nint(tree->car);\n      switch (nt) {\n#ifndef MRB_NO_FLOAT\n      case NODE_FLOAT:\n        if (val) {\n          char *p = (char*)tree->cdr;\n          mrb_float f = mrb_float_read(p, NULL);\n          int off = new_lit(s, mrb_float_value(s->mrb, -f));\n\n          genop_2(s, OP_LOADL, cursp(), off);\n          push();\n        }\n        break;\n#endif\n\n      case NODE_INT:\n        if (val) {\n          char *p = (char*)tree->cdr->car;\n          int base = nint(tree->cdr->cdr->car);\n          mrb_int i;\n          mrb_bool overflow;\n\n          i = readint(s, p, base, TRUE, &overflow);\n          if (overflow) {\n            int off = new_litbn(s, p, base, TRUE);\n            genop_2(s, OP_LOADL, cursp(), off);\n          }\n          else {\n            gen_int(s, cursp(), i);\n          }\n          push();\n        }\n        break;\n\n      default:\n        if (val) {\n          codegen(s, tree, VAL);\n          pop();\n          push_n(2);pop_n(2); /* space for receiver&block */\n          mrb_sym minus = MRB_OPSYM_2(s->mrb, minus);\n          if (!gen_uniop(s, minus, cursp())) {\n            genop_3(s, OP_SEND, cursp(), new_sym(s, minus), 0);\n          }\n          push();\n        }\n        else {\n          codegen(s, tree, NOVAL);\n        }\n        break;\n      }\n    }\n    break;\n\n  case NODE_STR:\n    if (val) {\n      char *p = (char*)tree->car;\n      size_t len = (intptr_t)tree->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int off = new_lit(s, mrb_str_new(s->mrb, p, len));\n\n      mrb_gc_arena_restore(s->mrb, ai);\n      genop_2(s, OP_STRING, cursp(), off);\n      push();\n    }\n    break;\n\n  case NODE_HEREDOC:\n    tree = ((struct mrb_parser_heredoc_info *)tree)->doc;\n    /* fall through */\n  case NODE_DSTR:\n    if (val) {\n      node *n = tree;\n\n      if (!n) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n        break;\n      }\n      codegen(s, n->car, VAL);\n      n = n->cdr;\n      while (n) {\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n    }\n    else {\n      node *n = tree;\n\n      while (n) {\n        if (nint(n->car->car) != NODE_STR) {\n          codegen(s, n->car, NOVAL);\n        }\n        n = n->cdr;\n      }\n    }\n    break;\n\n  case NODE_WORDS:\n    gen_literal_array(s, tree, FALSE, val);\n    break;\n\n  case NODE_SYMBOLS:\n    gen_literal_array(s, tree, TRUE, val);\n    break;\n\n  case NODE_DXSTR:\n    {\n      node *n;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, MRB_SYM_2(s->mrb, Kernel));\n\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n      codegen(s, tree->car, VAL);\n      n = tree->cdr;\n      while (n) {\n        if (nint(n->car->car) == NODE_XSTR) {\n          n->car->car = (struct mrb_ast_node*)(intptr_t)NODE_STR;\n          mrb_assert(!n->cdr); /* must be the end */\n        }\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n      push();                   /* for block */\n      pop_n(3);\n      sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick)); /* ` */\n      genop_3(s, OP_SEND, cursp(), sym, 1);\n      if (val) push();\n      mrb_gc_arena_restore(s->mrb, ai);\n    }\n    break;\n\n  case NODE_XSTR:\n    {\n      char *p = (char*)tree->car;\n      size_t len = (intptr_t)tree->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int off = new_lit(s, mrb_str_new(s->mrb, p, len));\n      int sym;\n\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n      genop_2(s, OP_STRING, cursp(), off);\n      push(); push();\n      pop_n(3);\n      sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick)); /* ` */\n      genop_3(s, OP_SEND, cursp(), sym, 1);\n      if (val) push();\n      mrb_gc_arena_restore(s->mrb, ai);\n    }\n    break;\n\n  case NODE_REGX:\n    if (val) {\n      char *p1 = (char*)tree->car;\n      char *p2 = (char*)tree->cdr->car;\n      char *p3 = (char*)tree->cdr->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));\n      int off = new_lit(s, mrb_str_new_cstr(s->mrb, p1));\n      int argc = 1;\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      push();\n      genop_2(s, OP_STRING, cursp(), off);\n      push();\n      if (p2 || p3) {\n        if (p2) { /* opt */\n          off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n          genop_2(s, OP_STRING, cursp(), off);\n        }\n        else {\n          genop_1(s, OP_LOADNIL, cursp());\n        }\n        push();\n        argc++;\n        if (p3) { /* enc */\n          off = new_lit(s, mrb_str_new(s->mrb, p3, 1));\n          genop_2(s, OP_STRING, cursp(), off);\n          push();\n          argc++;\n        }\n      }\n      push(); /* space for a block */\n      pop_n(argc+2);\n      sym = new_sym(s, MRB_SYM_2(s->mrb, compile));\n      genop_3(s, OP_SEND, cursp(), sym, argc);\n      mrb_gc_arena_restore(s->mrb, ai);\n      push();\n    }\n    break;\n\n  case NODE_DREGX:\n    if (val) {\n      node *n = tree->car;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));\n      int argc = 1;\n      int off;\n      char *p;\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      push();\n      codegen(s, n->car, VAL);\n      n = n->cdr;\n      while (n) {\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n      n = tree->cdr->cdr;\n      if (n->car) { /* tail */\n        p = (char*)n->car;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p));\n        codegen(s, tree->car, VAL);\n        genop_2(s, OP_STRING, cursp(), off);\n        pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n      }\n      if (n->cdr->car) { /* opt */\n        char *p2 = (char*)n->cdr->car;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n        genop_2(s, OP_STRING, cursp(), off);\n        push();\n        argc++;\n      }\n      if (n->cdr->cdr) { /* enc */\n        char *p2 = (char*)n->cdr->cdr;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n        genop_2(s, OP_STRING, cursp(), off);\n        push();\n        argc++;\n      }\n      push(); /* space for a block */\n      pop_n(argc+2);\n      sym = new_sym(s, MRB_SYM_2(s->mrb, compile));\n      genop_3(s, OP_SEND, cursp(), sym, argc);\n      mrb_gc_arena_restore(s->mrb, ai);\n      push();\n    }\n    else {\n      node *n = tree->car;\n\n      while (n) {\n        if (nint(n->car->car) != NODE_STR) {\n          codegen(s, n->car, NOVAL);\n        }\n        n = n->cdr;\n      }\n    }\n    break;\n\n  case NODE_SYM:\n    if (val) {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_LOADSYM, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_DSYM:\n    codegen(s, tree, val);\n    if (val) {\n      gen_intern(s);\n    }\n    break;\n\n  case NODE_SELF:\n    if (val) {\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n    }\n    break;\n\n  case NODE_NIL:\n    if (val) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    break;\n\n  case NODE_TRUE:\n    if (val) {\n      genop_1(s, OP_LOADT, cursp());\n      push();\n    }\n    break;\n\n  case NODE_FALSE:\n    if (val) {\n      genop_1(s, OP_LOADF, cursp());\n      push();\n    }\n    break;\n\n  case NODE_ALIAS:\n    {\n      int a = new_sym(s, nsym(tree->car));\n      int b = new_sym(s, nsym(tree->cdr));\n\n      genop_2(s, OP_ALIAS, a, b);\n      if (val) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n    }\n   break;\n\n  case NODE_UNDEF:\n    {\n      node *t = tree;\n\n      while (t) {\n        int symbol = new_sym(s, nsym(t->car));\n        genop_1(s, OP_UNDEF, symbol);\n        t = t->cdr;\n      }\n      if (val) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n    }\n    break;\n\n  case NODE_CLASS:\n    {\n      int idx;\n      node *body;\n\n      if (tree->car->car == (node*)0) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      else if (tree->car->car == (node*)1) {\n        genop_1(s, OP_OCLASS, cursp());\n        push();\n      }\n      else {\n        codegen(s, tree->car->car, VAL);\n      }\n      if (tree->cdr->car) {\n        codegen(s, tree->cdr->car, VAL);\n      }\n      else {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      pop(); pop();\n      idx = new_sym(s, nsym(tree->car->cdr));\n      genop_2(s, OP_CLASS, cursp(), idx);\n      body = tree->cdr->cdr->car;\n      if (nint(body->cdr->car) == NODE_BEGIN && body->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, body, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_MODULE:\n    {\n      int idx;\n\n      if (tree->car->car == (node*)0) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      else if (tree->car->car == (node*)1) {\n        genop_1(s, OP_OCLASS, cursp());\n        push();\n      }\n      else {\n        codegen(s, tree->car->car, VAL);\n      }\n      pop();\n      idx = new_sym(s, nsym(tree->car->cdr));\n      genop_2(s, OP_MODULE, cursp(), idx);\n      if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&\n          tree->cdr->car->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, tree->cdr->car, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_SCLASS:\n    {\n      int idx;\n\n      codegen(s, tree->car, VAL);\n      pop();\n      genop_1(s, OP_SCLASS, cursp());\n      if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&\n          tree->cdr->car->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, tree->cdr->car, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_DEF:\n    {\n      int sym = new_sym(s, nsym(tree->car));\n      int idx = lambda_body(s, tree->cdr, 0);\n\n      genop_1(s, OP_TCLASS, cursp());\n      push();\n      genop_2(s, OP_METHOD, cursp(), idx);\n      push(); pop();\n      pop();\n      genop_2(s, OP_DEF, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_SDEF:\n    {\n      node *recv = tree->car;\n      int sym = new_sym(s, nsym(tree->cdr->car));\n      int idx = lambda_body(s, tree->cdr->cdr, 0);\n\n      codegen(s, recv, VAL);\n      pop();\n      genop_1(s, OP_SCLASS, cursp());\n      push();\n      genop_2(s, OP_METHOD, cursp(), idx);\n      pop();\n      genop_2(s, OP_DEF, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_POSTEXE:\n    codegen(s, tree, NOVAL);\n    break;\n\n  default:\n    break;\n  }\n exit:\n  s->rlev = rlev;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147955,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "escape_xml(const char *text)\n{\n\tstatic char *escaped;\n\tstatic size_t escaped_size;\n\tchar *out;\n\tsize_t len;\n\n\tif (!strlen(text)) return \"empty string\";\n\n\tfor (out=escaped, len=0; *text; ++len, ++out, ++text) {\n\t\t/* Make sure there's plenty of room for a quoted character */\n\t\tif ((len + 8) > escaped_size) {\n\t\t\tchar *bigger_escaped;\n\t\t\tescaped_size += 128;\n\t\t\tbigger_escaped = realloc(escaped, escaped_size);\n\t\t\tif (!bigger_escaped) {\n\t\t\t\tfree(escaped);\t/* avoid leaking memory */\n\t\t\t\tescaped = NULL;\n\t\t\t\tescaped_size = 0;\n\t\t\t\t/* Error string is cleverly chosen to fail XML validation */\n\t\t\t\treturn \">>> out of memory <<<\";\n\t\t\t}\n\t\t\tout = bigger_escaped + len;\n\t\t\tescaped = bigger_escaped;\n\t\t}\n\t\tswitch (*text) {\n\t\t\tcase '&':\n\t\t\t\tstrcpy(out, \"&amp;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tstrcpy(out, \"&lt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tstrcpy(out, \"&gt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*out = *text;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t*out = '\\x0';  /* NUL terminate the string */\n\treturn escaped;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147972,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "escape_xml(const char *text)\n{\n\tstatic char *escaped;\n\tstatic size_t escaped_size;\n\tchar *out;\n\tsize_t len;\n\n\tif (!strlen(text)) return \"\";\n\n\tfor (out=escaped, len=0; *text; ++len, ++out, ++text) {\n\t\t/* Make sure there's plenty of room for a quoted character */\n\t\tif ((len + 8) > escaped_size) {\n\t\t\tchar *bigger_escaped;\n\t\t\tescaped_size += 128;\n\t\t\tbigger_escaped = realloc(escaped, escaped_size);\n\t\t\tif (!bigger_escaped) {\n\t\t\t\tfree(escaped);\t/* avoid leaking memory */\n\t\t\t\tescaped = NULL;\n\t\t\t\tescaped_size = 0;\n\t\t\t\t/* Error string is cleverly chosen to fail XML validation */\n\t\t\t\treturn \">>> out of memory <<<\";\n\t\t\t}\n\t\t\tout = bigger_escaped + len;\n\t\t\tescaped = bigger_escaped;\n\t\t}\n\t\tswitch (*text) {\n\t\t\tcase '&':\n\t\t\t\tstrcpy(out, \"&amp;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tstrcpy(out, \"&lt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tstrcpy(out, \"&gt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*out = *text;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t*out = '\\x0';  /* NUL terminate the string */\n\treturn escaped;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147973,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void nhmldump_send_header(GF_NHMLDumpCtx *ctx)\n{\n\tGF_FilterPacket *dst_pck;\n\tchar nhml[1024];\n\tu32 size;\n\tu8 *output;\n\tconst GF_PropertyValue *p;\n\n\tctx->szRootName = \"NHNTStream\";\n\tif (ctx->dims) {\n\t\tctx->szRootName = \"DIMSStream\";\n\t}\n\n\tif (!ctx->filep) {\n\t\tsprintf(nhml, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\");\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\n\t/*write header*/\n\tsprintf(nhml, \"<%s version=\\\"1.0\\\" \", ctx->szRootName);\n\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\n\tNHML_PRINT_UINT(GF_PROP_PID_ID, NULL, \"trackID\")\n\tNHML_PRINT_UINT(GF_PROP_PID_TIMESCALE, NULL, \"timeScale\")\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_IN_IOD);\n\tif (p && p->value.boolean) {\n\t\tsprintf(nhml, \"inRootOD=\\\"yes\\\" \");\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\n\tif (ctx->oti && (ctx->oti<GF_CODECID_LAST_MPEG4_MAPPING)) {\n\t\tsprintf(nhml, \"streamType=\\\"%d\\\" objectTypeIndication=\\\"%d\\\" \", ctx->streamtype, ctx->oti);\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32)strlen(nhml));\n\t} else {\n\t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_SUBTYPE);\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"%s=\\\"%s\\\" \", \"mediaType\", gf_4cc_to_str(p->value.uint));\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\t\t\tNHML_PRINT_4CC(GF_PROP_PID_ISOM_SUBTYPE, \"mediaSubType\", \"mediaSubType\")\n\t\t} else {\n\t\t\tNHML_PRINT_4CC(GF_PROP_PID_CODECID, NULL, \"codecID\")\n\t\t}\n\t}\n\n\tif (ctx->w && ctx->h) {\n\t\t//compatibility with old arch, we might want to remove this\n\t\tswitch (ctx->streamtype) {\n\t\tcase GF_STREAM_VISUAL:\n\t\tcase GF_STREAM_SCENE:\n\t\t\tsprintf(nhml, \"width=\\\"%d\\\" height=\\\"%d\\\" \", ctx->w, ctx->h);\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\telse if (ctx->sr && ctx->chan) {\n\t\tsprintf(nhml, \"sampleRate=\\\"%d\\\" numChannels=\\\"%d\\\" \", ctx->sr, ctx->chan);\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\tsprintf(nhml, \"sampleRate=\\\"%d\\\" numChannels=\\\"%d\\\" \", ctx->sr, ctx->chan);\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_AUDIO_FORMAT);\n\t\tsprintf(nhml, \"bitsPerSample=\\\"%d\\\" \", gf_audio_fmt_bit_depth(p->value.uint));\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\n\tNHML_PRINT_4CC(0, \"codec_vendor\", \"codecVendor\")\n\tNHML_PRINT_UINT(0, \"codec_version\", \"codecVersion\")\n\tNHML_PRINT_UINT(0, \"codec_revision\", \"codecRevision\")\n\tNHML_PRINT_STRING(0, \"compressor_name\", \"compressorName\")\n\tNHML_PRINT_UINT(0, \"temporal_quality\", \"temporalQuality\")\n\tNHML_PRINT_UINT(0, \"spatial_quality\", \"spatialQuality\")\n\tNHML_PRINT_UINT(0, \"hres\", \"horizontalResolution\")\n\tNHML_PRINT_UINT(0, \"vres\", \"verticalResolution\")\n\tNHML_PRINT_UINT(GF_PROP_PID_BIT_DEPTH_Y, NULL, \"bitDepth\")\n\n\tNHML_PRINT_STRING(0, \"meta:xmlns\", \"xml_namespace\")\n\tNHML_PRINT_STRING(0, \"meta:schemaloc\", \"xml_schema_location\")\n\tNHML_PRINT_STRING(0, \"meta:mime\", \"mime_type\")\n\n\tNHML_PRINT_STRING(0, \"meta:config\", \"config\")\n\tNHML_PRINT_STRING(0, \"meta:aux_mimes\", \"aux_mime_type\")\n\n\tif (ctx->codecid == GF_CODECID_DIMS) {\n\t\tif (gf_filter_pid_get_property_str(ctx->ipid, \"meta:xmlns\")==NULL) {\n\t\t\tsprintf(nhml, \"xmlns=\\\"http://www.3gpp.org/richmedia\\\" \");\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\n\t\tNHML_PRINT_UINT(0, \"dims:profile\", \"profile\")\n\t\tNHML_PRINT_UINT(0, \"dims:level\", \"level\")\n\t\tNHML_PRINT_UINT(0, \"dims:pathComponents\", \"pathComponents\")\n\n\t\tp = gf_filter_pid_get_property_str(ctx->ipid, \"dims:fullRequestHost\");\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"useFullRequestHost=\\\"%s\\\" \", p->value.boolean ? \"yes\" : \"no\");\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\t\tp = gf_filter_pid_get_property_str(ctx->ipid, \"dims:streamType\");\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"stream_type=\\\"%s\\\" \", p->value.boolean ? \"primary\" : \"secondary\");\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\t\tp = gf_filter_pid_get_property_str(ctx->ipid, \"dims:redundant\");\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"contains_redundant=\\\"%s\\\" \", (p->value.uint==1) ? \"main\" : ((p->value.uint==1) ? \"redundant\" : \"main+redundant\") );\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\t\tNHML_PRINT_UINT(0, \"dims:scriptTypes\", \"scriptTypes\")\n\t}\n\n\t//send DCD\n\tif (ctx->opid_info) {\n\t\tsprintf(nhml, \"specificInfoFile=\\\"%s\\\" \", gf_file_basename(ctx->info_file) );\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\t\tdst_pck = gf_filter_pck_new_shared(ctx->opid_info, ctx->dcfg, ctx->dcfg_size, NULL);\n\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\t\tgf_filter_pck_set_readonly(dst_pck);\n\t\tgf_filter_pck_send(dst_pck);\n\t}\n\n\tNHML_PRINT_STRING(0, \"meta:encoding\", \"encoding\")\n\tNHML_PRINT_STRING(0, \"meta:contentEncoding\", \"content_encoding\")\n\tctx->uncompress = GF_FALSE;\n\tif (p) {\n\t\tif (!strcmp(p->value.string, \"deflate\")) ctx->uncompress = GF_TRUE;\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[NHMLMx] content_encoding %s not supported\\n\", p->value.string ));\n\t\t}\n\t}\n\n\tif (ctx->opid_mdia) {\n\t\tsprintf(nhml, \"baseMediaFile=\\\"%s\\\" \", gf_file_basename(ctx->media_file) );\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\tsprintf(nhml, \">\\n\");\n\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\tgf_bs_get_content_no_truncate(ctx->bs_w, &ctx->nhml_buffer, &size, &ctx->nhml_buffer_size);\n\n\tif (ctx->filep) {\n\t\tgf_fwrite(ctx->nhml_buffer, size, ctx->filep);\n\t\treturn;\n\t}\n\n\tdst_pck = gf_filter_pck_new_alloc(ctx->opid_nhml, size, &output);\n\tmemcpy(output, ctx->nhml_buffer, size);\n\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_FALSE);\n\tgf_filter_pck_send(dst_pck);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147982,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void nhmldump_send_header(GF_NHMLDumpCtx *ctx)\n{\n\tGF_FilterPacket *dst_pck;\n\tchar nhml[1024];\n\tu32 size;\n\tu8 *output;\n\tconst GF_PropertyValue *p;\n\n\tctx->szRootName = \"NHNTStream\";\n\tif (ctx->dims) {\n\t\tctx->szRootName = \"DIMSStream\";\n\t}\n\n\tif (!ctx->filep) {\n\t\tsprintf(nhml, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\");\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\n\t/*write header*/\n\tsprintf(nhml, \"<%s version=\\\"1.0\\\" \", ctx->szRootName);\n\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\n\tNHML_PRINT_UINT(GF_PROP_PID_ID, NULL, \"trackID\")\n\tNHML_PRINT_UINT(GF_PROP_PID_TIMESCALE, NULL, \"timeScale\")\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_IN_IOD);\n\tif (p && p->value.boolean) {\n\t\tsprintf(nhml, \"inRootOD=\\\"yes\\\" \");\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\n\tif (ctx->oti && (ctx->oti<GF_CODECID_LAST_MPEG4_MAPPING)) {\n\t\tsprintf(nhml, \"streamType=\\\"%d\\\" objectTypeIndication=\\\"%d\\\" \", ctx->streamtype, ctx->oti);\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32)strlen(nhml));\n\t} else {\n\t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_SUBTYPE);\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"%s=\\\"%s\\\" \", \"mediaType\", gf_4cc_to_str(p->value.uint));\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\t\t\tNHML_PRINT_4CC(GF_PROP_PID_ISOM_SUBTYPE, \"mediaSubType\", \"mediaSubType\")\n\t\t} else {\n\t\t\tNHML_PRINT_4CC(GF_PROP_PID_CODECID, NULL, \"codecID\")\n\t\t}\n\t}\n\n\tif (ctx->w && ctx->h) {\n\t\t//compatibility with old arch, we might want to remove this\n\t\tswitch (ctx->streamtype) {\n\t\tcase GF_STREAM_VISUAL:\n\t\tcase GF_STREAM_SCENE:\n\t\t\tsprintf(nhml, \"width=\\\"%d\\\" height=\\\"%d\\\" \", ctx->w, ctx->h);\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\telse if (ctx->sr && ctx->chan) {\n\t\tsprintf(nhml, \"sampleRate=\\\"%d\\\" numChannels=\\\"%d\\\" \", ctx->sr, ctx->chan);\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\tsprintf(nhml, \"sampleRate=\\\"%d\\\" numChannels=\\\"%d\\\" \", ctx->sr, ctx->chan);\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_AUDIO_FORMAT);\n\t\tif (p)\n\t\t\tsprintf(nhml, \"bitsPerSample=\\\"%d\\\" \", gf_audio_fmt_bit_depth(p->value.uint));\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\n\tNHML_PRINT_4CC(0, \"codec_vendor\", \"codecVendor\")\n\tNHML_PRINT_UINT(0, \"codec_version\", \"codecVersion\")\n\tNHML_PRINT_UINT(0, \"codec_revision\", \"codecRevision\")\n\tNHML_PRINT_STRING(0, \"compressor_name\", \"compressorName\")\n\tNHML_PRINT_UINT(0, \"temporal_quality\", \"temporalQuality\")\n\tNHML_PRINT_UINT(0, \"spatial_quality\", \"spatialQuality\")\n\tNHML_PRINT_UINT(0, \"hres\", \"horizontalResolution\")\n\tNHML_PRINT_UINT(0, \"vres\", \"verticalResolution\")\n\tNHML_PRINT_UINT(GF_PROP_PID_BIT_DEPTH_Y, NULL, \"bitDepth\")\n\n\tNHML_PRINT_STRING(0, \"meta:xmlns\", \"xml_namespace\")\n\tNHML_PRINT_STRING(0, \"meta:schemaloc\", \"xml_schema_location\")\n\tNHML_PRINT_STRING(0, \"meta:mime\", \"mime_type\")\n\n\tNHML_PRINT_STRING(0, \"meta:config\", \"config\")\n\tNHML_PRINT_STRING(0, \"meta:aux_mimes\", \"aux_mime_type\")\n\n\tif (ctx->codecid == GF_CODECID_DIMS) {\n\t\tif (gf_filter_pid_get_property_str(ctx->ipid, \"meta:xmlns\")==NULL) {\n\t\t\tsprintf(nhml, \"xmlns=\\\"http://www.3gpp.org/richmedia\\\" \");\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\n\t\tNHML_PRINT_UINT(0, \"dims:profile\", \"profile\")\n\t\tNHML_PRINT_UINT(0, \"dims:level\", \"level\")\n\t\tNHML_PRINT_UINT(0, \"dims:pathComponents\", \"pathComponents\")\n\n\t\tp = gf_filter_pid_get_property_str(ctx->ipid, \"dims:fullRequestHost\");\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"useFullRequestHost=\\\"%s\\\" \", p->value.boolean ? \"yes\" : \"no\");\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\t\tp = gf_filter_pid_get_property_str(ctx->ipid, \"dims:streamType\");\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"stream_type=\\\"%s\\\" \", p->value.boolean ? \"primary\" : \"secondary\");\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\t\tp = gf_filter_pid_get_property_str(ctx->ipid, \"dims:redundant\");\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"contains_redundant=\\\"%s\\\" \", (p->value.uint==1) ? \"main\" : ((p->value.uint==1) ? \"redundant\" : \"main+redundant\") );\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\t\tNHML_PRINT_UINT(0, \"dims:scriptTypes\", \"scriptTypes\")\n\t}\n\n\t//send DCD\n\tif (ctx->opid_info) {\n\t\tsprintf(nhml, \"specificInfoFile=\\\"%s\\\" \", gf_file_basename(ctx->info_file) );\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\t\tdst_pck = gf_filter_pck_new_shared(ctx->opid_info, ctx->dcfg, ctx->dcfg_size, NULL);\n\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\t\tgf_filter_pck_set_readonly(dst_pck);\n\t\tgf_filter_pck_send(dst_pck);\n\t}\n\n\tNHML_PRINT_STRING(0, \"meta:encoding\", \"encoding\")\n\tNHML_PRINT_STRING(0, \"meta:contentEncoding\", \"content_encoding\")\n\tctx->uncompress = GF_FALSE;\n\tif (p) {\n\t\tif (!strcmp(p->value.string, \"deflate\")) ctx->uncompress = GF_TRUE;\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[NHMLMx] content_encoding %s not supported\\n\", p->value.string ));\n\t\t}\n\t}\n\n\tif (ctx->opid_mdia) {\n\t\tsprintf(nhml, \"baseMediaFile=\\\"%s\\\" \", gf_file_basename(ctx->media_file) );\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\tsprintf(nhml, \">\\n\");\n\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\tgf_bs_get_content_no_truncate(ctx->bs_w, &ctx->nhml_buffer, &size, &ctx->nhml_buffer_size);\n\n\tif (ctx->filep) {\n\t\tgf_fwrite(ctx->nhml_buffer, size, ctx->filep);\n\t\treturn;\n\t}\n\n\tdst_pck = gf_filter_pck_new_alloc(ctx->opid_nhml, size, &output);\n\tmemcpy(output, ctx->nhml_buffer, size);\n\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_FALSE);\n\tgf_filter_pck_send(dst_pck);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147983,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void UncompressElementOp::Compute(OpKernelContext* ctx) {\n  Tensor tensor = ctx->input(0);\n  const Variant& variant = tensor.scalar<Variant>()();\n  const CompressedElement* compressed = variant.get<CompressedElement>();\n\n  std::vector<Tensor> components;\n  OP_REQUIRES_OK(ctx, UncompressElement(*compressed, &components));\n  OP_REQUIRES(ctx, components.size() == output_types_.size(),\n              errors::FailedPrecondition(\"Expected \", output_types_.size(),\n                                         \" outputs from uncompress, but got \",\n                                         components.size()));\n  for (int i = 0; i < components.size(); ++i) {\n    OP_REQUIRES(\n        ctx, components[i].dtype() == output_types_[i],\n        errors::FailedPrecondition(\"Expected a tensor of type \",\n                                   DataTypeString(output_types_[i]),\n                                   \" but got a tensor of type \",\n                                   DataTypeString(components[i].dtype())));\n    ctx->set_output(i, components[i]);\n  }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147994,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void UncompressElementOp::Compute(OpKernelContext* ctx) {\n  Tensor tensor = ctx->input(0);\n  const Variant& variant = tensor.scalar<Variant>()();\n  const CompressedElement* compressed = variant.get<CompressedElement>();\n  OP_REQUIRES(\n      ctx, compressed != nullptr,\n      errors::InvalidArgument(\n          \"Input does not contain a compressed element. Instead got tensor \",\n          tensor.DebugString()));\n\n  std::vector<Tensor> components;\n  OP_REQUIRES_OK(ctx, UncompressElement(*compressed, &components));\n  OP_REQUIRES(ctx, components.size() == output_types_.size(),\n              errors::FailedPrecondition(\"Expected \", output_types_.size(),\n                                         \" outputs from uncompress, but got \",\n                                         components.size()));\n  for (int i = 0; i < components.size(); ++i) {\n    OP_REQUIRES(\n        ctx, components[i].dtype() == output_types_[i],\n        errors::FailedPrecondition(\"Expected a tensor of type \",\n                                   DataTypeString(output_types_[i]),\n                                   \" but got a tensor of type \",\n                                   DataTypeString(components[i].dtype())));\n    ctx->set_output(i, components[i]);\n  }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147995,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "#ifndef GPAC_DISABLE_ISOM_HINTING\n\nvoid dump_isom_sdp(GF_ISOFile *file, char *inName, Bool is_final_name)\n{\n\tconst char *sdp;\n\tu32 size, i;\n\tFILE *dump;\n\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) {\n\t\t\tchar *ext = strchr(szBuf, '.');\n\t\t\tif (ext) ext[0] = 0;\n\t\t\tstrcat(szBuf, \"_sdp.txt\");\n\t\t}\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tfprintf(stderr, \"Failed to open %s for dumping\\n\", szBuf);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t\tfprintf(dump, \"* File SDP content *\\n\\n\");\n\t}\n\t//get the movie SDP\n\tgf_isom_sdp_get(file, &sdp, &size);\n\tfprintf(dump, \"%s\", sdp);\n\tfprintf(dump, \"\\r\\n\");\n\n\t//then tracks\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (gf_isom_get_media_type(file, i+1) != GF_ISOM_MEDIA_HINT) continue;\n\t\tgf_isom_sdp_track_get(file, i+1, &sdp, &size);\n\t\tfprintf(dump, \"%s\", sdp);\n\t}\n\tfprintf(dump, \"\\n\\n\");",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148016,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "#ifndef GPAC_DISABLE_ISOM_HINTING\n\nvoid dump_isom_sdp(GF_ISOFile *file, char *inName, Bool is_final_name)\n{\n\tconst char *sdp;\n\tu32 size, i;\n\tFILE *dump;\n\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) {\n\t\t\tchar *ext = strchr(szBuf, '.');\n\t\t\tif (ext) ext[0] = 0;\n\t\t\tstrcat(szBuf, \"_sdp.txt\");\n\t\t}\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tfprintf(stderr, \"Failed to open %s for dumping\\n\", szBuf);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t\tfprintf(dump, \"* File SDP content *\\n\\n\");\n\t}\n\t//get the movie SDP\n\tgf_isom_sdp_get(file, &sdp, &size);\n\tif (sdp && size)\n\t\tfprintf(dump, \"%s\", sdp);\n\tfprintf(dump, \"\\r\\n\");\n\n\t//then tracks\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (gf_isom_get_media_type(file, i+1) != GF_ISOM_MEDIA_HINT) continue;\n\t\tgf_isom_sdp_track_get(file, i+1, &sdp, &size);\n\t\tfprintf(dump, \"%s\", sdp);\n\t}\n\tfprintf(dump, \"\\n\\n\");",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148017,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  void ValidateInputs(OpKernelContext* ctx,\n                      const CSRSparseMatrix& sparse_matrix,\n                      const Tensor& permutation_indices, int* batch_size,\n                      int64* num_rows) {\n    OP_REQUIRES(ctx, sparse_matrix.dtype() == DataTypeToEnum<T>::value,\n                errors::InvalidArgument(\n                    \"Asked for a CSRSparseMatrix of type \",\n                    DataTypeString(DataTypeToEnum<T>::value),\n                    \" but saw dtype: \", DataTypeString(sparse_matrix.dtype())));\n\n    const Tensor& dense_shape = sparse_matrix.dense_shape();\n    const int rank = dense_shape.dim_size(0);\n    OP_REQUIRES(ctx, rank == 2 || rank == 3,\n                errors::InvalidArgument(\"sparse matrix must have rank 2 or 3; \",\n                                        \"but dense_shape has size \", rank));\n    const int row_dim = (rank == 2) ? 0 : 1;\n    auto dense_shape_vec = dense_shape.vec<int64>();\n    *num_rows = dense_shape_vec(row_dim);\n    const int64 num_cols = dense_shape_vec(row_dim + 1);\n    OP_REQUIRES(ctx, *num_rows == num_cols,\n                errors::InvalidArgument(\"sparse matrix must be square; got: \",\n                                        *num_rows, \" != \", num_cols));\n    const TensorShape& perm_shape = permutation_indices.shape();\n    OP_REQUIRES(\n        ctx, perm_shape.dims() + 1 == rank,\n        errors::InvalidArgument(\n            \"sparse matrix must have the same rank as permutation; got: \", rank,\n            \" != \", perm_shape.dims(), \" + 1.\"));\n    OP_REQUIRES(\n        ctx, perm_shape.dim_size(rank - 2) == *num_rows,\n        errors::InvalidArgument(\n            \"permutation must have the same number of elements in each batch \"\n            \"as the number of rows in sparse matrix; got: \",\n            perm_shape.dim_size(rank - 2), \" != \", *num_rows));\n\n    *batch_size = sparse_matrix.batch_size();\n    if (*batch_size > 1) {\n      OP_REQUIRES(\n          ctx, perm_shape.dim_size(0) == *batch_size,\n          errors::InvalidArgument(\"permutation must have the same batch size \"\n                                  \"as sparse matrix; got: \",\n                                  perm_shape.dim_size(0), \" != \", *batch_size));\n    }\n  }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148064,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  Status ValidateInputs(const CSRSparseMatrix& sparse_matrix,\n                        const Tensor& permutation_indices, int* batch_size,\n                        int64* num_rows) {\n    if (sparse_matrix.dtype() != DataTypeToEnum<T>::value)\n      return errors::InvalidArgument(\n          \"Asked for a CSRSparseMatrix of type \",\n          DataTypeString(DataTypeToEnum<T>::value),\n          \" but saw dtype: \", DataTypeString(sparse_matrix.dtype()));\n\n    const Tensor& dense_shape = sparse_matrix.dense_shape();\n    const int rank = dense_shape.dim_size(0);\n    if (rank < 2 || rank > 3)\n      return errors::InvalidArgument(\"sparse matrix must have rank 2 or 3; \",\n                                     \"but dense_shape has size \", rank);\n    const int row_dim = (rank == 2) ? 0 : 1;\n    auto dense_shape_vec = dense_shape.vec<int64>();\n    *num_rows = dense_shape_vec(row_dim);\n    const int64 num_cols = dense_shape_vec(row_dim + 1);\n    if (*num_rows != num_cols)\n      return errors::InvalidArgument(\n          \"sparse matrix must be square; got: \", *num_rows, \" != \", num_cols);\n    const TensorShape& perm_shape = permutation_indices.shape();\n    if (perm_shape.dims() + 1 != rank)\n      return errors::InvalidArgument(\n          \"sparse matrix must have the same rank as permutation; got: \", rank,\n          \" != \", perm_shape.dims(), \" + 1.\");\n    if (perm_shape.dim_size(rank - 2) != *num_rows)\n      return errors::InvalidArgument(\n          \"permutation must have the same number of elements in each batch \"\n          \"as the number of rows in sparse matrix; got: \",\n          perm_shape.dim_size(rank - 2), \" != \", *num_rows);\n\n    *batch_size = sparse_matrix.batch_size();\n    if (*batch_size > 1) {\n      if (perm_shape.dim_size(0) != *batch_size)\n        return errors::InvalidArgument(\n            \"permutation must have the same batch size \"\n            \"as sparse matrix; got: \",\n            perm_shape.dim_size(0), \" != \", *batch_size);\n    }\n\n    return Status::OK();\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148065,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err Media_RewriteODFrame(GF_MediaBox *mdia, GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_ODCodec *ODdecode;\n\tGF_ODCodec *ODencode;\n\tGF_ODCom *com;\n\n\t//the commands we proceed\n\tGF_ESDUpdate *esdU, *esdU2;\n\tGF_ESDRemove *esdR, *esdR2;\n\tGF_ODUpdate *odU, *odU2;\n\n\t//the desc they contain\n\tGF_ObjectDescriptor *od;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_ESD *esd;\n\tGF_ES_ID_Ref *ref;\n\tGF_Descriptor *desc;\n\tGF_TrackReferenceTypeBox *mpod;\n\tu32 i, j, skipped;\n\n\tif (!mdia || !sample || !sample->data || !sample->dataLength) return GF_BAD_PARAM;\n\n\tmpod = NULL;\n\te = Track_FindRef(mdia->mediaTrack, GF_ISOM_BOX_TYPE_MPOD, &mpod);\n\tif (e) return e;\n\t//no references, nothing to do...\n\tif (!mpod || !mpod->trackIDs) return GF_OK;\n\n\tODdecode = gf_odf_codec_new();\n\tif (!ODdecode) return GF_OUT_OF_MEM;\n\tODencode = gf_odf_codec_new();\n\tif (!ODencode) {\n\t\tgf_odf_codec_del(ODdecode);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\te = gf_odf_codec_set_au(ODdecode, sample->data, sample->dataLength);\n\tif (e) goto err_exit;\n\te = gf_odf_codec_decode(ODdecode);\n\tif (e) goto err_exit;\n\n\twhile (1) {\n\t\tcom = gf_odf_codec_get_com(ODdecode);\n\t\tif (!com) break;\n\n\t\t//we only need to rewrite commands with ESDs inside: ESDUpdate and ODUpdate\n\t\tswitch (com->tag) {\n\t\tcase GF_ODF_OD_UPDATE_TAG:\n\t\t\todU = (GF_ODUpdate *) com;\n\t\t\todU2 = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);\n\n\t\t\ti=0;\n\t\t\twhile ((desc = (GF_Descriptor*)gf_list_enum(odU->objectDescriptors, &i))) {\n\t\t\t\tswitch (desc->tag) {\n\t\t\t\tcase GF_ODF_OD_TAG:\n\t\t\t\tcase GF_ODF_ISOM_OD_TAG:\n\t\t\t\t//IOD can be used in OD streams\n\t\t\t\tcase GF_ODF_ISOM_IOD_TAG:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t}\n\t\t\t\te = gf_odf_desc_copy(desc, (GF_Descriptor **)&isom_od);\n\t\t\t\tif (e) goto err_exit;\n\n\t\t\t\t//create our OD...\n\t\t\t\tif (desc->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_InitialObjectDescriptor));\n\t\t\t\t} else {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_ObjectDescriptor));\n\t\t\t\t}\n\t\t\t\tif (!od) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t\tod->ESDescriptors = gf_list_new();\n\t\t\t\t//and duplicate...\n\t\t\t\tod->objectDescriptorID = isom_od->objectDescriptorID;\n\t\t\t\tod->tag = GF_ODF_OD_TAG;\n\t\t\t\tod->URLString = isom_od->URLString;\n\t\t\t\tisom_od->URLString = NULL;\n\t\t\t\tod->extensionDescriptors = isom_od->extensionDescriptors;\n\t\t\t\tisom_od->extensionDescriptors = NULL;\n\t\t\t\tod->IPMP_Descriptors = isom_od->IPMP_Descriptors;\n\t\t\t\tisom_od->IPMP_Descriptors = NULL;\n\t\t\t\tod->OCIDescriptors = isom_od->OCIDescriptors;\n\t\t\t\tisom_od->OCIDescriptors = NULL;\n\n\t\t\t\t//init as IOD\n\t\t\t\tif (isom_od->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->audio_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->audio_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->inlineProfileFlag = ((GF_IsomInitialObjectDescriptor *)isom_od)->inlineProfileFlag;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->graphics_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->graphics_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->OD_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->OD_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->scene_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->scene_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->visual_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->visual_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->IPMPToolList = ((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList = NULL;\n\t\t\t\t}\n\n\t\t\t\t//then rewrite the ESDesc\n\t\t\t\tj=0;\n\t\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(isom_od->ES_ID_RefDescriptors, &j))) {\n\t\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\t\tif (!mpod->trackIDs || gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t\t//OK, get the esd\n\t\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\t\tif (!e) e = gf_odf_desc_add_desc((GF_Descriptor *) od, (GF_Descriptor *) esd);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU2);\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\t\t\t\tgoto err_exit;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t//delete our desc\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\tgf_list_add(odU2->objectDescriptors, od);\n\t\t\t}\n\t\t\t//clean a bit\n\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)odU2);\n\t\t\tbreak;\n\n\t\tcase GF_ODF_ESD_UPDATE_TAG:\n\t\t\tesdU = (GF_ESDUpdate *) com;\n\t\t\tesdU2 = (GF_ESDUpdate *) gf_odf_com_new(GF_ODF_ESD_UPDATE_TAG);\n\t\t\tesdU2->ODID = esdU->ODID;\n\t\t\ti=0;\n\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(esdU->ESDescriptors, &i))) {\n\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t//OK, get the esd\n\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t\tgf_list_add(esdU2->ESDescriptors, esd);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdU2);\n\t\t\tbreak;\n\n\t\t//brand new case: the ESRemove follows the same principle according to the spec...\n\t\tcase GF_ODF_ESD_REMOVE_REF_TAG:\n\t\t\t//both commands have the same structure, only the tags change\n\t\t\tesdR = (GF_ESDRemove *) com;\n\t\t\tesdR2 = (GF_ESDRemove *) gf_odf_com_new(GF_ODF_ESD_REMOVE_TAG);\n\t\t\tesdR2->ODID = esdR->ODID;\n\t\t\tesdR2->NbESDs = esdR->NbESDs;\n\t\t\t//alloc our stuff\n\t\t\tesdR2->ES_ID = (unsigned short*)gf_malloc(sizeof(u32) * esdR->NbESDs);\n\t\t\tif (!esdR2->ES_ID) {\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\tskipped = 0;\n\t\t\t//get the ES_ID in the mpod indicated in the ES_ID[]\n\t\t\tfor (i = 0; i < esdR->NbESDs; i++) {\n\t\t\t\t//if the ref index is not valid, remove this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[esdR->ES_ID[i] - 1]) == NULL) {\n\t\t\t\t\tskipped ++;\n\t\t\t\t} else {\n\t\t\t\t\t//the command in the file has the ref index of the trackID in the mpod\n\t\t\t\t\tesdR2->ES_ID[i - skipped] = mpod->trackIDs[esdR->ES_ID[i] - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//gf_realloc...\n\t\t\tif (skipped && (skipped != esdR2->NbESDs) ) {\n\t\t\t\tesdR2->NbESDs -= skipped;\n\t\t\t\tesdR2->ES_ID = (unsigned short*)gf_realloc(esdR2->ES_ID, sizeof(u32) * esdR2->NbESDs);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdR);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdR2);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\te = gf_odf_codec_add_com(ODencode, com);\n\t\t\tif (e) goto err_exit;\n\t\t}\n\t}\n\t//encode our new AU\n\te = gf_odf_codec_encode(ODencode, 1);\n\tif (e) goto err_exit;\n\n\t//and set the buffer in the sample\n\tgf_free(sample->data);\n\tsample->data = NULL;\n\tsample->dataLength = 0;\n\te = gf_odf_codec_get_au(ODencode, &sample->data, &sample->dataLength);\n\nerr_exit:\n\tgf_odf_codec_del(ODdecode);\n\tgf_odf_codec_del(ODencode);\n\treturn e;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148080,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err Media_RewriteODFrame(GF_MediaBox *mdia, GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_ODCodec *ODdecode;\n\tGF_ODCodec *ODencode;\n\tGF_ODCom *com;\n\n\t//the commands we proceed\n\tGF_ESDUpdate *esdU, *esdU2;\n\tGF_ESDRemove *esdR, *esdR2;\n\tGF_ODUpdate *odU, *odU2;\n\n\t//the desc they contain\n\tGF_ObjectDescriptor *od;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_ESD *esd;\n\tGF_ES_ID_Ref *ref;\n\tGF_Descriptor *desc;\n\tGF_TrackReferenceTypeBox *mpod;\n\tu32 i, j, skipped;\n\n\tif (!mdia || !sample || !sample->data || !sample->dataLength) return GF_BAD_PARAM;\n\n\tmpod = NULL;\n\te = Track_FindRef(mdia->mediaTrack, GF_ISOM_BOX_TYPE_MPOD, &mpod);\n\tif (e) return e;\n\t//no references, nothing to do...\n\tif (!mpod || !mpod->trackIDs) return GF_OK;\n\n\tODdecode = gf_odf_codec_new();\n\tif (!ODdecode) return GF_OUT_OF_MEM;\n\tODencode = gf_odf_codec_new();\n\tif (!ODencode) {\n\t\tgf_odf_codec_del(ODdecode);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\te = gf_odf_codec_set_au(ODdecode, sample->data, sample->dataLength);\n\tif (e) goto err_exit;\n\te = gf_odf_codec_decode(ODdecode);\n\tif (e) goto err_exit;\n\n\twhile (1) {\n\t\tcom = gf_odf_codec_get_com(ODdecode);\n\t\tif (!com) break;\n\n\t\t//we only need to rewrite commands with ESDs inside: ESDUpdate and ODUpdate\n\t\tswitch (com->tag) {\n\t\tcase GF_ODF_OD_UPDATE_TAG:\n\t\t\todU = (GF_ODUpdate *) com;\n\t\t\todU2 = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);\n\n\t\t\ti=0;\n\t\t\twhile ((desc = (GF_Descriptor*)gf_list_enum(odU->objectDescriptors, &i))) {\n\t\t\t\tswitch (desc->tag) {\n\t\t\t\tcase GF_ODF_OD_TAG:\n\t\t\t\tcase GF_ODF_ISOM_OD_TAG:\n\t\t\t\t//IOD can be used in OD streams\n\t\t\t\tcase GF_ODF_ISOM_IOD_TAG:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t}\n\t\t\t\te = gf_odf_desc_copy(desc, (GF_Descriptor **)&isom_od);\n\t\t\t\tif (e) goto err_exit;\n\n\t\t\t\t//create our OD...\n\t\t\t\tif (desc->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_InitialObjectDescriptor));\n\t\t\t\t} else {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_ObjectDescriptor));\n\t\t\t\t}\n\t\t\t\tif (!od) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t\tod->ESDescriptors = gf_list_new();\n\t\t\t\t//and duplicate...\n\t\t\t\tod->objectDescriptorID = isom_od->objectDescriptorID;\n\t\t\t\tod->tag = GF_ODF_OD_TAG;\n\t\t\t\tod->URLString = isom_od->URLString;\n\t\t\t\tisom_od->URLString = NULL;\n\t\t\t\tod->extensionDescriptors = isom_od->extensionDescriptors;\n\t\t\t\tisom_od->extensionDescriptors = NULL;\n\t\t\t\tod->IPMP_Descriptors = isom_od->IPMP_Descriptors;\n\t\t\t\tisom_od->IPMP_Descriptors = NULL;\n\t\t\t\tod->OCIDescriptors = isom_od->OCIDescriptors;\n\t\t\t\tisom_od->OCIDescriptors = NULL;\n\n\t\t\t\t//init as IOD\n\t\t\t\tif (isom_od->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->audio_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->audio_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->inlineProfileFlag = ((GF_IsomInitialObjectDescriptor *)isom_od)->inlineProfileFlag;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->graphics_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->graphics_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->OD_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->OD_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->scene_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->scene_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->visual_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->visual_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->IPMPToolList = ((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList = NULL;\n\t\t\t\t}\n\n\t\t\t\t//then rewrite the ESDesc\n\t\t\t\tj=0;\n\t\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(isom_od->ES_ID_RefDescriptors, &j))) {\n\t\t\t\t\tif (!mpod->trackIDs || !ref->trackRef || (ref->trackRef>mpod->trackIDCount)) continue;\n\t\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t\t//OK, get the esd\n\t\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\t\tif (!e) e = gf_odf_desc_add_desc((GF_Descriptor *) od, (GF_Descriptor *) esd);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU2);\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\t\t\t\tgoto err_exit;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t//delete our desc\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\tgf_list_add(odU2->objectDescriptors, od);\n\t\t\t}\n\t\t\t//clean a bit\n\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)odU2);\n\t\t\tbreak;\n\n\t\tcase GF_ODF_ESD_UPDATE_TAG:\n\t\t\tesdU = (GF_ESDUpdate *) com;\n\t\t\tesdU2 = (GF_ESDUpdate *) gf_odf_com_new(GF_ODF_ESD_UPDATE_TAG);\n\t\t\tesdU2->ODID = esdU->ODID;\n\t\t\ti=0;\n\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(esdU->ESDescriptors, &i))) {\n\t\t\t\tif (!mpod->trackIDs || !ref->trackRef || (ref->trackRef>mpod->trackIDCount)) continue;\n\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t//OK, get the esd\n\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t\tgf_list_add(esdU2->ESDescriptors, esd);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdU2);\n\t\t\tbreak;\n\n\t\t//brand new case: the ESRemove follows the same principle according to the spec...\n\t\tcase GF_ODF_ESD_REMOVE_REF_TAG:\n\t\t\t//both commands have the same structure, only the tags change\n\t\t\tesdR = (GF_ESDRemove *) com;\n\t\t\tesdR2 = (GF_ESDRemove *) gf_odf_com_new(GF_ODF_ESD_REMOVE_TAG);\n\t\t\tesdR2->ODID = esdR->ODID;\n\t\t\tesdR2->NbESDs = esdR->NbESDs;\n\t\t\t//alloc our stuff\n\t\t\tesdR2->ES_ID = (unsigned short*)gf_malloc(sizeof(u32) * esdR->NbESDs);\n\t\t\tif (!esdR2->ES_ID) {\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\tskipped = 0;\n\t\t\t//get the ES_ID in the mpod indicated in the ES_ID[]\n\t\t\tfor (i = 0; i < esdR->NbESDs; i++) {\n\t\t\t\tif (!mpod->trackIDs || !esdR->ES_ID[i] || (esdR->ES_ID[i]>mpod->trackIDCount)) continue;\n\t\t\t\t//if the ref index is not valid, remove this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[esdR->ES_ID[i] - 1]) == NULL) {\n\t\t\t\t\tskipped ++;\n\t\t\t\t} else {\n\t\t\t\t\t//the command in the file has the ref index of the trackID in the mpod\n\t\t\t\t\tesdR2->ES_ID[i - skipped] = mpod->trackIDs[esdR->ES_ID[i] - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//gf_realloc...\n\t\t\tif (skipped && (skipped != esdR2->NbESDs) ) {\n\t\t\t\tesdR2->NbESDs -= skipped;\n\t\t\t\tesdR2->ES_ID = (unsigned short*)gf_realloc(esdR2->ES_ID, sizeof(u32) * esdR2->NbESDs);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdR);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdR2);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\te = gf_odf_codec_add_com(ODencode, com);\n\t\t\tif (e) goto err_exit;\n\t\t}\n\t}\n\t//encode our new AU\n\te = gf_odf_codec_encode(ODencode, 1);\n\tif (e) goto err_exit;\n\n\t//and set the buffer in the sample\n\tgf_free(sample->data);\n\tsample->data = NULL;\n\tsample->dataLength = 0;\n\te = gf_odf_codec_get_au(ODencode, &sample->data, &sample->dataLength);\n\nerr_exit:\n\tgf_odf_codec_del(ODdecode);\n\tgf_odf_codec_del(ODencode);\n\treturn e;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148081,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err gf_isom_set_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const GF_SLConfig *slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig **slc;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\n\t//we must be sure we are not using a remote ESD\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (((GF_MPEGSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (((GF_MPEGAudioSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (((GF_MPEGVisualSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (*slc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)*slc);\n\t\t*slc = NULL;\n\t}\n\tif (!slConfig) return GF_OK;\n\t//finally duplicate the SL\n\treturn gf_odf_desc_copy((GF_Descriptor *) slConfig, (GF_Descriptor **) slc);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148088,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err gf_isom_get_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, GF_SLConfig **slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig *slc;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\n\t//we must be sure we are not using a remote ESD\n\tslc = NULL;\n\t*slConfig = NULL;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (((GF_MPEGSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (((GF_MPEGAudioSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (((GF_MPEGVisualSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (!slc) return GF_OK;\n\t//finally duplicate the SL\n\treturn gf_odf_desc_copy((GF_Descriptor *) slc, (GF_Descriptor **) slConfig);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148089,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err gf_hinter_finalize(GF_ISOFile *file, GF_SDP_IODProfile IOD_Profile, u32 bandwidth)\n{\n\tu32 i, sceneT, odT, descIndex, size, size64;\n\tGF_InitialObjectDescriptor *iod;\n\tGF_SLConfig slc;\n\tGF_ISOSample *samp;\n\tBool remove_ocr;\n\tu8 *buffer;\n\tchar buf64[5000], sdpLine[5100];\n\n\n\tgf_isom_sdp_clean(file);\n\n\tif (bandwidth) {\n\t\tsprintf(buf64, \"b=AS:%d\", bandwidth);\n\t\tgf_isom_sdp_add_line(file, buf64);\n\t}\n    //xtended attribute for copyright\n    if (gf_sys_is_test_mode()) {\n        sprintf(buf64, \"a=x-copyright: %s\", \"MP4/3GP File hinted with GPAC - (c) Telecom ParisTech (http://gpac.io)\");\n    } else {\n        sprintf(buf64, \"a=x-copyright: MP4/3GP File hinted with GPAC %s - %s\", gf_gpac_version(), gf_gpac_copyright() );\n    }\n\tgf_isom_sdp_add_line(file, buf64);\n\n\tif (IOD_Profile == GF_SDP_IOD_NONE) return GF_OK;\n\n\todT = sceneT = 0;\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (!gf_isom_is_track_in_root_od(file, i+1)) continue;\n\t\tswitch (gf_isom_get_media_type(file,i+1)) {\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\todT = i+1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tsceneT = i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tremove_ocr = 0;\n\tif (IOD_Profile == GF_SDP_IOD_ISMA_STRICT) {\n\t\tIOD_Profile = GF_SDP_IOD_ISMA;\n\t\tremove_ocr = 1;\n\t}\n\n\t/*if we want ISMA like iods, we need at least BIFS */\n\tif ( (IOD_Profile == GF_SDP_IOD_ISMA) && !sceneT ) return GF_BAD_PARAM;\n\n\t/*do NOT change PLs, we assume they are correct*/\n\tiod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);\n\tif (!iod) return GF_NOT_SUPPORTED;\n\n\t/*rewrite an IOD with good SL config - embbed data if possible*/\n\tif (IOD_Profile == GF_SDP_IOD_ISMA) {\n\t\tGF_ESD *esd;\n\t\tBool is_ok = 1;\n\t\twhile (gf_list_count(iod->ESDescriptors)) {\n\t\t\tesd = (GF_ESD*)gf_list_get(iod->ESDescriptors, 0);\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\tgf_list_rem(iod->ESDescriptors, 0);\n\t\t}\n\n\n\t\t/*get OD esd, and embbed stream data if possible*/\n\t\tif (odT) {\n\t\t\tesd = gf_isom_get_esd(file, odT, 1);\n\t\t\tif (gf_isom_get_sample_count(file, odT)==1) {\n\t\t\t\tsamp = gf_isom_get_sample(file, odT, 1, &descIndex);\n\t\t\t\tif (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_OD)) {\n\t\t\t\t\tInitSL_NULL(&slc);\n\t\t\t\t\tslc.predefined = 0;\n\t\t\t\t\tslc.hasRandomAccessUnitsOnlyFlag = 1;\n\t\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, odT);\n\t\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t\t//set the SL for future extraction\n\t\t\t\t\tgf_isom_set_extraction_slc(file, odT, 1, &slc);\n\n\t\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\t\tbuf64[size64] = 0;\n\t\t\t\t\tsprintf(sdpLine, \"data:application/mpeg4-od-au;base64,%s\", buf64);\n\n\t\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\t\tsize64 = (u32) strlen(sdpLine)+1;\n\t\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * size64);\n\t\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (\"[rtp hinter] OD sample too large to be embedded in IOD - ISMA disabled\\n\"));\n\t\t\t\t\tis_ok = 0;\n\t\t\t\t}\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t}\n\t\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\t\t//OK, add this to our IOD\n\t\t\tgf_list_add(iod->ESDescriptors, esd);\n\t\t}\n\n\t\tesd = gf_isom_get_esd(file, sceneT, 1);\n\t\tif (gf_isom_get_sample_count(file, sceneT)==1) {\n\t\t\tsamp = gf_isom_get_sample(file, sceneT, 1, &descIndex);\n\t\t\tif (gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_SCENE)) {\n\n\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, sceneT);\n\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t//set the SL for future extraction\n\t\t\t\tgf_isom_set_extraction_slc(file, sceneT, 1, &slc);\n\t\t\t\t//encode in Base64 the sample\n\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\tbuf64[size64] = 0;\n\t\t\t\tsprintf(sdpLine, \"data:application/mpeg4-bifs-au;base64,%s\", buf64);\n\n\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * (strlen(sdpLine)+1));\n\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Scene description sample too large to be embedded in IOD - ISMA disabled\\n\"));\n\t\t\t\tis_ok = 0;\n\t\t\t}\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\tgf_list_add(iod->ESDescriptors, esd);\n\n\t\tif (is_ok) {\n\t\t\tu32 has_a, has_v, has_i_a, has_i_v;\n\t\t\thas_a = has_v = has_i_a = has_i_v = 0;\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tesd = gf_isom_get_esd(file, i+1, 1);\n\t\t\t\tif (!esd) continue;\n\t\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) has_i_v ++;\n\t\t\t\t\telse has_v++;\n\t\t\t\t} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_AAC_MPEG4) has_i_a ++;\n\t\t\t\t\telse has_a++;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\t}\n\t\t\t/*only 1 MPEG-4 visual max and 1 MPEG-4 audio max for ISMA compliancy*/\n\t\t\tif (!has_v && !has_a && (has_i_v<=1) && (has_i_a<=1)) {\n\t\t\t\tsprintf(sdpLine, \"a=isma-compliance:1,1.0,1\");\n\t\t\t\tgf_isom_sdp_add_line(file, sdpLine);\n\t\t\t}\n\t\t}\n\t}\n\n\t//encode the IOD\n\tbuffer = NULL;\n\tsize = 0;\n\tgf_odf_desc_write((GF_Descriptor *) iod, &buffer, &size);\n\tgf_odf_desc_del((GF_Descriptor *)iod);\n\n\t//encode in Base64 the iod\n\tsize64 = gf_base64_encode(buffer, size, buf64, 2000);\n\tbuf64[size64] = 0;\n\tgf_free(buffer);\n\n\tsprintf(sdpLine, \"a=mpeg4-iod:\\\"data:application/mpeg4-iod;base64,%s\\\"\", buf64);\n\tgf_isom_sdp_add_line(file, sdpLine);\n\n\treturn GF_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148102,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err gf_hinter_finalize(GF_ISOFile *file, GF_SDP_IODProfile IOD_Profile, u32 bandwidth)\n{\n\tu32 i, sceneT, odT, descIndex, size, size64;\n\tGF_InitialObjectDescriptor *iod;\n\tGF_SLConfig slc;\n\tGF_ISOSample *samp;\n\tBool remove_ocr;\n\tu8 *buffer;\n\tchar buf64[5000], sdpLine[5100];\n\n\n\tgf_isom_sdp_clean(file);\n\n\tif (bandwidth) {\n\t\tsprintf(buf64, \"b=AS:%d\", bandwidth);\n\t\tgf_isom_sdp_add_line(file, buf64);\n\t}\n    //xtended attribute for copyright\n    if (gf_sys_is_test_mode()) {\n        sprintf(buf64, \"a=x-copyright: %s\", \"MP4/3GP File hinted with GPAC - (c) Telecom ParisTech (http://gpac.io)\");\n    } else {\n        sprintf(buf64, \"a=x-copyright: MP4/3GP File hinted with GPAC %s - %s\", gf_gpac_version(), gf_gpac_copyright() );\n    }\n\tgf_isom_sdp_add_line(file, buf64);\n\n\tif (IOD_Profile == GF_SDP_IOD_NONE) return GF_OK;\n\n\todT = sceneT = 0;\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (!gf_isom_is_track_in_root_od(file, i+1)) continue;\n\t\tswitch (gf_isom_get_media_type(file,i+1)) {\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\todT = i+1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tsceneT = i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tremove_ocr = 0;\n\tif (IOD_Profile == GF_SDP_IOD_ISMA_STRICT) {\n\t\tIOD_Profile = GF_SDP_IOD_ISMA;\n\t\tremove_ocr = 1;\n\t}\n\n\t/*if we want ISMA like iods, we need at least BIFS */\n\tif ( (IOD_Profile == GF_SDP_IOD_ISMA) && !sceneT ) return GF_BAD_PARAM;\n\n\t/*do NOT change PLs, we assume they are correct*/\n\tiod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);\n\tif (!iod) return GF_NOT_SUPPORTED;\n\n\t/*rewrite an IOD with good SL config - embbed data if possible*/\n\tif (IOD_Profile == GF_SDP_IOD_ISMA) {\n\t\tGF_ESD *esd;\n\t\tBool is_ok = 1;\n\t\twhile (gf_list_count(iod->ESDescriptors)) {\n\t\t\tesd = (GF_ESD*)gf_list_get(iod->ESDescriptors, 0);\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\tgf_list_rem(iod->ESDescriptors, 0);\n\t\t}\n\n\n\t\t/*get OD esd, and embbed stream data if possible*/\n\t\tif (odT) {\n\t\t\tesd = gf_isom_get_esd(file, odT, 1);\n\t\t\tif (gf_isom_get_sample_count(file, odT)==1) {\n\t\t\t\tsamp = gf_isom_get_sample(file, odT, 1, &descIndex);\n\t\t\t\tif (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_OD)) {\n\t\t\t\t\tInitSL_NULL(&slc);\n\t\t\t\t\tslc.predefined = 0;\n\t\t\t\t\tslc.hasRandomAccessUnitsOnlyFlag = 1;\n\t\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, odT);\n\t\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t\t//set the SL for future extraction\n\t\t\t\t\tgf_isom_set_extraction_slc(file, odT, 1, &slc);\n\n\t\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\t\tbuf64[size64] = 0;\n\t\t\t\t\tsprintf(sdpLine, \"data:application/mpeg4-od-au;base64,%s\", buf64);\n\n\t\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\t\tsize64 = (u32) strlen(sdpLine)+1;\n\t\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * size64);\n\t\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (\"[rtp hinter] OD sample too large to be embedded in IOD - ISMA disabled\\n\"));\n\t\t\t\t\tis_ok = 0;\n\t\t\t\t}\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t}\n\t\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\t\t//OK, add this to our IOD\n\t\t\tgf_list_add(iod->ESDescriptors, esd);\n\t\t}\n\n\t\tesd = gf_isom_get_esd(file, sceneT, 1);\n\t\tif (gf_isom_get_sample_count(file, sceneT)==1) {\n\t\t\tsamp = gf_isom_get_sample(file, sceneT, 1, &descIndex);\n\t\t\tif (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_SCENE)) {\n\n\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, sceneT);\n\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t//set the SL for future extraction\n\t\t\t\tgf_isom_set_extraction_slc(file, sceneT, 1, &slc);\n\t\t\t\t//encode in Base64 the sample\n\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\tbuf64[size64] = 0;\n\t\t\t\tsprintf(sdpLine, \"data:application/mpeg4-bifs-au;base64,%s\", buf64);\n\n\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * (strlen(sdpLine)+1));\n\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Scene description sample too large to be embedded in IOD - ISMA disabled\\n\"));\n\t\t\t\tis_ok = 0;\n\t\t\t}\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\tgf_list_add(iod->ESDescriptors, esd);\n\n\t\tif (is_ok) {\n\t\t\tu32 has_a, has_v, has_i_a, has_i_v;\n\t\t\thas_a = has_v = has_i_a = has_i_v = 0;\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tesd = gf_isom_get_esd(file, i+1, 1);\n\t\t\t\tif (!esd) continue;\n\t\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) has_i_v ++;\n\t\t\t\t\telse has_v++;\n\t\t\t\t} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_AAC_MPEG4) has_i_a ++;\n\t\t\t\t\telse has_a++;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\t}\n\t\t\t/*only 1 MPEG-4 visual max and 1 MPEG-4 audio max for ISMA compliancy*/\n\t\t\tif (!has_v && !has_a && (has_i_v<=1) && (has_i_a<=1)) {\n\t\t\t\tsprintf(sdpLine, \"a=isma-compliance:1,1.0,1\");\n\t\t\t\tgf_isom_sdp_add_line(file, sdpLine);\n\t\t\t}\n\t\t}\n\t}\n\n\t//encode the IOD\n\tbuffer = NULL;\n\tsize = 0;\n\tgf_odf_desc_write((GF_Descriptor *) iod, &buffer, &size);\n\tgf_odf_desc_del((GF_Descriptor *)iod);\n\n\t//encode in Base64 the iod\n\tsize64 = gf_base64_encode(buffer, size, buf64, 2000);\n\tbuf64[size64] = 0;\n\tgf_free(buffer);\n\n\tsprintf(sdpLine, \"a=mpeg4-iod:\\\"data:application/mpeg4-iod;base64,%s\\\"\", buf64);\n\tgf_isom_sdp_add_line(file, sdpLine);\n\n\treturn GF_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148103,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "service_info *FindServiceEventURLPath(\n\tservice_table *table, const char *eventURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\n\tif (table &&\n\t\tparse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) ==\n\t\t\tHTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->eventURL) {\n\t\t\t\tif (parse_uri(finger->eventURL,\n\t\t\t\t\t    strlen(finger->eventURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148108,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "service_info *FindServiceEventURLPath(\n\tservice_table *table, const char *eventURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\n\tif (!table || !eventURLPath) {\n\t\treturn NULL;\n\t}\n\tif (parse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) ==\n\t\tHTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->eventURL) {\n\t\t\t\tif (parse_uri(finger->eventURL,\n\t\t\t\t\t    strlen(finger->eventURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148109,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "service_info *FindServiceControlURLPath(\n\tservice_table *table, const char *controlURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\n\tif (table && parse_uri(controlURLPath,\n\t\t\t     strlen(controlURLPath),\n\t\t\t     &parsed_url_in) == HTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->controlURL) {\n\t\t\t\tif (parse_uri(finger->controlURL,\n\t\t\t\t\t    strlen(finger->controlURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148110,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "service_info *FindServiceControlURLPath(\n\tservice_table *table, const char *controlURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\n\tif (!table || !controlURLPath) {\n\t\treturn NULL;\n\t}\n\tif (parse_uri(controlURLPath, strlen(controlURLPath), &parsed_url_in) ==\n\t\tHTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->controlURL) {\n\t\t\t\tif (parse_uri(finger->controlURL,\n\t\t\t\t\t    strlen(finger->controlURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148111,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err latm_dmx_process(GF_Filter *filter)\n{\n\tGF_LATMDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu32 pos;\n\tu8 *data, *output;\n\tu32 pck_size, prev_pck_size;\n\tu64 cts = GF_FILTER_NO_TS;\n\n\tif (ctx->in_error)\n\t\treturn ctx->in_error;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tlatm_dmx_check_dur(filter, ctx);\n\n\tif (ctx->opid && !ctx->is_playing)\n\t\treturn GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (!ctx->latm_buffer_size) {\n\t\t\t\tif (ctx->opid)\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = NULL;\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale && pck) {\n\t\tcts = gf_filter_pck_get_cts(pck);\n\t}\n\n\tprev_pck_size = ctx->latm_buffer_size;\n\n\tif (pck && !ctx->resume_from) {\n\t\tif (ctx->latm_buffer_size + pck_size > ctx->latm_buffer_alloc) {\n\t\t\tctx->latm_buffer_alloc = ctx->latm_buffer_size + pck_size;\n\t\t\tctx->latm_buffer = gf_realloc(ctx->latm_buffer, ctx->latm_buffer_alloc);\n\t\t}\n\t\tmemcpy(ctx->latm_buffer + ctx->latm_buffer_size, data, pck_size);\n\t\tctx->latm_buffer_size += pck_size;\n\t}\n\n\tif (!ctx->bs) ctx->bs = gf_bs_new(ctx->latm_buffer, ctx->latm_buffer_size, GF_BITSTREAM_READ);\n\telse gf_bs_reassign_buffer(ctx->bs, ctx->latm_buffer, ctx->latm_buffer_size);\n\n\tif (ctx->resume_from) {\n\t\tgf_bs_seek(ctx->bs, ctx->resume_from-1);\n\t\tctx->resume_from = 0;\n\t}\n\n\tif (cts == GF_FILTER_NO_TS)\n\t\tprev_pck_size = 0;\n\n\n\twhile (1) {\n\t\tpos = (u32) gf_bs_get_position(ctx->bs);\n\t\tu8 latm_buffer[4096];\n\t\tu32 latm_frame_size = 4096;\n\t\tif (!latm_dmx_sync_frame_bs(ctx->bs,&ctx->acfg, &latm_frame_size, latm_buffer, NULL)) break;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_samples_at_seek = (u64) (ctx->start_range * GF_M4ASampleRates[ctx->sr_idx]);\n\t\t\tif (ctx->cts + ctx->dts_inc >= nb_samples_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tlatm_dmx_check_pid(filter, ctx);\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = pos+1;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tif (!ctx->in_seek) {\n\t\t\tGF_FilterSAPType sap = GF_FILTER_SAP_1;\n\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, latm_frame_size, &output);\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\n\t\t\tmemcpy(output, latm_buffer, latm_frame_size);\n\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_duration(dst_pck, ctx->dts_inc);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\n\t\t\t/*xHE-AAC, check RAP*/\n\t\t\tif (ctx->acfg.base_object_type==GF_CODECID_USAC) {\n\t\t\t\tif (latm_frame_size && (output[0] & 0x80) && !ctx->prev_sap) {\n\t\t\t\t\tsap = GF_FILTER_SAP_1;\n\t\t\t\t\tctx->prev_sap = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tsap = GF_FILTER_SAP_NONE;\n\t\t\t\t\tctx->prev_sap = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_filter_pck_set_sap(dst_pck, sap);\n\n\t\t\tgf_filter_pck_send(dst_pck);\n\t\t}\n\t\tlatm_dmx_update_cts(ctx);\n\n\t\tif (prev_pck_size) {\n\t\t\tpos = (u32) gf_bs_get_position(ctx->bs);\n\t\t\tif (prev_pck_size<=pos) {\n\t\t\t\tprev_pck_size=0;\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = pck;\n\t\t\t\tif (pck)\n\t\t\t\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pck) {\n\t\tpos = (u32) gf_bs_get_position(ctx->bs);\n\t\tassert(ctx->latm_buffer_size >= pos);\n\t\tmemmove(ctx->latm_buffer, ctx->latm_buffer+pos, ctx->latm_buffer_size - pos);\n\t\tctx->latm_buffer_size -= pos;\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\tassert(!ctx->resume_from);\n\t} else {\n\t\tctx->latm_buffer_size = 0;\n\t\treturn latm_dmx_process(filter);\n\t}\n\treturn GF_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148130,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err latm_dmx_process(GF_Filter *filter)\n{\n\tGF_LATMDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu32 pos;\n\tu8 *data=NULL, *output;\n\tu32 pck_size=0, prev_pck_size;\n\tu64 cts = GF_FILTER_NO_TS;\n\n\tif (ctx->in_error)\n\t\treturn ctx->in_error;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tlatm_dmx_check_dur(filter, ctx);\n\n\tif (ctx->opid && !ctx->is_playing)\n\t\treturn GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (!ctx->latm_buffer_size) {\n\t\t\t\tif (ctx->opid)\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = NULL;\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t} else {\n\t\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\t}\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale && pck) {\n\t\tcts = gf_filter_pck_get_cts(pck);\n\t}\n\n\tprev_pck_size = ctx->latm_buffer_size;\n\n\tif (pck && !ctx->resume_from) {\n\t\tif (ctx->latm_buffer_size + pck_size > ctx->latm_buffer_alloc) {\n\t\t\tctx->latm_buffer_alloc = ctx->latm_buffer_size + pck_size;\n\t\t\tctx->latm_buffer = gf_realloc(ctx->latm_buffer, ctx->latm_buffer_alloc);\n\t\t}\n\t\tmemcpy(ctx->latm_buffer + ctx->latm_buffer_size, data, pck_size);\n\t\tctx->latm_buffer_size += pck_size;\n\t}\n\n\tif (!ctx->bs) ctx->bs = gf_bs_new(ctx->latm_buffer, ctx->latm_buffer_size, GF_BITSTREAM_READ);\n\telse gf_bs_reassign_buffer(ctx->bs, ctx->latm_buffer, ctx->latm_buffer_size);\n\n\tif (ctx->resume_from) {\n\t\tgf_bs_seek(ctx->bs, ctx->resume_from-1);\n\t\tctx->resume_from = 0;\n\t}\n\n\tif (cts == GF_FILTER_NO_TS)\n\t\tprev_pck_size = 0;\n\n\n\twhile (1) {\n\t\tpos = (u32) gf_bs_get_position(ctx->bs);\n\t\tu8 latm_buffer[4096];\n\t\tu32 latm_frame_size = 4096;\n\t\tif (!latm_dmx_sync_frame_bs(ctx->bs,&ctx->acfg, &latm_frame_size, latm_buffer, NULL)) break;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_samples_at_seek = (u64) (ctx->start_range * GF_M4ASampleRates[ctx->sr_idx]);\n\t\t\tif (ctx->cts + ctx->dts_inc >= nb_samples_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tlatm_dmx_check_pid(filter, ctx);\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = pos+1;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tif (!ctx->in_seek) {\n\t\t\tGF_FilterSAPType sap = GF_FILTER_SAP_1;\n\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, latm_frame_size, &output);\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\n\t\t\tmemcpy(output, latm_buffer, latm_frame_size);\n\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_duration(dst_pck, ctx->dts_inc);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\n\t\t\t/*xHE-AAC, check RAP*/\n\t\t\tif (ctx->acfg.base_object_type==GF_CODECID_USAC) {\n\t\t\t\tif (latm_frame_size && (output[0] & 0x80) && !ctx->prev_sap) {\n\t\t\t\t\tsap = GF_FILTER_SAP_1;\n\t\t\t\t\tctx->prev_sap = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tsap = GF_FILTER_SAP_NONE;\n\t\t\t\t\tctx->prev_sap = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_filter_pck_set_sap(dst_pck, sap);\n\n\t\t\tgf_filter_pck_send(dst_pck);\n\t\t}\n\t\tlatm_dmx_update_cts(ctx);\n\n\t\tif (prev_pck_size) {\n\t\t\tpos = (u32) gf_bs_get_position(ctx->bs);\n\t\t\tif (prev_pck_size<=pos) {\n\t\t\t\tprev_pck_size=0;\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = pck;\n\t\t\t\tif (pck)\n\t\t\t\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pck) {\n\t\tpos = (u32) gf_bs_get_position(ctx->bs);\n\t\tassert(ctx->latm_buffer_size >= pos);\n\t\tmemmove(ctx->latm_buffer, ctx->latm_buffer+pos, ctx->latm_buffer_size - pos);\n\t\tctx->latm_buffer_size -= pos;\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\tassert(!ctx->resume_from);\n\t} else {\n\t\tctx->latm_buffer_size = 0;\n\t\treturn latm_dmx_process(filter);\n\t}\n\treturn GF_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148131,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "multi_process_incoming_link(struct multi_context *m, struct multi_instance *instance, const unsigned int mpp_flags)\n{\n    struct gc_arena gc = gc_new();\n\n    struct context *c;\n    struct mroute_addr src, dest;\n    unsigned int mroute_flags;\n    struct multi_instance *mi;\n    bool ret = true;\n    bool floated = false;\n\n    if (m->pending)\n    {\n        return true;\n    }\n\n    if (!instance)\n    {\n#ifdef MULTI_DEBUG_EVENT_LOOP\n        printf(\"TCP/UDP -> TUN [%d]\\n\", BLEN(&m->top.c2.buf));\n#endif\n        multi_set_pending(m, multi_get_create_instance_udp(m, &floated));\n    }\n    else\n    {\n        multi_set_pending(m, instance);\n    }\n\n    if (m->pending)\n    {\n        set_prefix(m->pending);\n\n        /* get instance context */\n        c = &m->pending->context;\n\n        if (!instance)\n        {\n            /* transfer packet pointer from top-level context buffer to instance */\n            c->c2.buf = m->top.c2.buf;\n\n            /* transfer from-addr from top-level context buffer to instance */\n            if (!floated)\n            {\n                c->c2.from = m->top.c2.from;\n            }\n        }\n\n        if (BLEN(&c->c2.buf) > 0)\n        {\n            struct link_socket_info *lsi;\n            const uint8_t *orig_buf;\n\n            /* decrypt in instance context */\n\n            perf_push(PERF_PROC_IN_LINK);\n            lsi = get_link_socket_info(c);\n            orig_buf = c->c2.buf.data;\n            if (process_incoming_link_part1(c, lsi, floated))\n            {\n                if (floated)\n                {\n                    multi_process_float(m, m->pending);\n                }\n\n                process_incoming_link_part2(c, lsi, orig_buf);\n            }\n            perf_pop();\n\n            if (TUNNEL_TYPE(m->top.c1.tuntap) == DEV_TYPE_TUN)\n            {\n                /* extract packet source and dest addresses */\n                mroute_flags = mroute_extract_addr_from_packet(&src,\n                                                               &dest,\n                                                               NULL,\n                                                               NULL,\n                                                               0,\n                                                               &c->c2.to_tun,\n                                                               DEV_TYPE_TUN);\n\n                /* drop packet if extract failed */\n                if (!(mroute_flags & MROUTE_EXTRACT_SUCCEEDED))\n                {\n                    c->c2.to_tun.len = 0;\n                }\n                /* make sure that source address is associated with this client */\n                else if (multi_get_instance_by_virtual_addr(m, &src, true) != m->pending)\n                {\n                    /* IPv6 link-local address (fe80::xxx)? */\n                    if ( (src.type & MR_ADDR_MASK) == MR_ADDR_IPV6\n                         && IN6_IS_ADDR_LINKLOCAL(&src.v6.addr) )\n                    {\n                        /* do nothing, for now.  TODO: add address learning */\n                    }\n                    else\n                    {\n                        msg(D_MULTI_DROPPED, \"MULTI: bad source address from client [%s], packet dropped\",\n                            mroute_addr_print(&src, &gc));\n                    }\n                    c->c2.to_tun.len = 0;\n                }\n                /* client-to-client communication enabled? */\n                else if (m->enable_c2c)\n                {\n                    /* multicast? */\n                    if (mroute_flags & MROUTE_EXTRACT_MCAST)\n                    {\n                        /* for now, treat multicast as broadcast */\n                        multi_bcast(m, &c->c2.to_tun, m->pending, NULL, 0);\n                    }\n                    else /* possible client to client routing */\n                    {\n                        ASSERT(!(mroute_flags & MROUTE_EXTRACT_BCAST));\n                        mi = multi_get_instance_by_virtual_addr(m, &dest, true);\n\n                        /* if dest addr is a known client, route to it */\n                        if (mi)\n                        {\n#ifdef ENABLE_PF\n                            if (!pf_c2c_test(&c->c2.pf, c->c2.tls_multi,\n                                             &mi->context.c2.pf,\n                                             mi->context.c2.tls_multi,\n                                             \"tun_c2c\"))\n                            {\n                                msg(D_PF_DROPPED, \"PF: client -> client[%s] packet dropped by TUN packet filter\",\n                                    mi_prefix(mi));\n                            }\n                            else\n#endif\n                            {\n                                multi_unicast(m, &c->c2.to_tun, mi);\n                                register_activity(c, BLEN(&c->c2.to_tun));\n                            }\n                            c->c2.to_tun.len = 0;\n                        }\n                    }\n                }\n#ifdef ENABLE_PF\n                if (c->c2.to_tun.len && !pf_addr_test(&c->c2.pf, c, &dest,\n                                                      \"tun_dest_addr\"))\n                {\n                    msg(D_PF_DROPPED, \"PF: client -> addr[%s] packet dropped by TUN packet filter\",\n                        mroute_addr_print_ex(&dest, MAPF_SHOW_ARP, &gc));\n                    c->c2.to_tun.len = 0;\n                }\n#endif\n            }\n            else if (TUNNEL_TYPE(m->top.c1.tuntap) == DEV_TYPE_TAP)\n            {\n                uint16_t vid = 0;\n#ifdef ENABLE_PF\n                struct mroute_addr edest;\n                mroute_addr_reset(&edest);\n#endif\n\n                if (m->top.options.vlan_tagging)\n                {\n                    if (vlan_is_tagged(&c->c2.to_tun))\n                    {\n                        /* Drop VLAN-tagged frame. */\n                        msg(D_VLAN_DEBUG, \"dropping incoming VLAN-tagged frame\");\n                        c->c2.to_tun.len = 0;\n                    }\n                    else\n                    {\n                        vid = c->options.vlan_pvid;\n                    }\n                }\n                /* extract packet source and dest addresses */\n                mroute_flags = mroute_extract_addr_from_packet(&src,\n                                                               &dest,\n                                                               NULL,\n#ifdef ENABLE_PF\n                                                               &edest,\n#else\n                                                               NULL,\n#endif\n                                                               vid,\n                                                               &c->c2.to_tun,\n                                                               DEV_TYPE_TAP);\n\n                if (mroute_flags & MROUTE_EXTRACT_SUCCEEDED)\n                {\n                    if (multi_learn_addr(m, m->pending, &src, 0) == m->pending)\n                    {\n                        /* check for broadcast */\n                        if (m->enable_c2c)\n                        {\n                            if (mroute_flags & (MROUTE_EXTRACT_BCAST|MROUTE_EXTRACT_MCAST))\n                            {\n                                multi_bcast(m, &c->c2.to_tun, m->pending, NULL,\n                                            vid);\n                            }\n                            else /* try client-to-client routing */\n                            {\n                                mi = multi_get_instance_by_virtual_addr(m, &dest, false);\n\n                                /* if dest addr is a known client, route to it */\n                                if (mi)\n                                {\n#ifdef ENABLE_PF\n                                    if (!pf_c2c_test(&c->c2.pf, c->c2.tls_multi,\n                                                     &mi->context.c2.pf,\n                                                     mi->context.c2.tls_multi,\n                                                     \"tap_c2c\"))\n                                    {\n                                        msg(D_PF_DROPPED, \"PF: client -> client[%s] packet dropped by TAP packet filter\",\n                                            mi_prefix(mi));\n                                    }\n                                    else\n#endif\n                                    {\n                                        multi_unicast(m, &c->c2.to_tun, mi);\n                                        register_activity(c, BLEN(&c->c2.to_tun));\n                                    }\n                                    c->c2.to_tun.len = 0;\n                                }\n                            }\n                        }\n#ifdef ENABLE_PF\n                        if (c->c2.to_tun.len && !pf_addr_test(&c->c2.pf, c,\n                                                              &edest,\n                                                              \"tap_dest_addr\"))\n                        {\n                            msg(D_PF_DROPPED, \"PF: client -> addr[%s] packet dropped by TAP packet filter\",\n                                mroute_addr_print_ex(&edest, MAPF_SHOW_ARP, &gc));\n                            c->c2.to_tun.len = 0;\n                        }\n#endif\n                    }\n                    else\n                    {\n                        msg(D_MULTI_DROPPED, \"MULTI: bad source address from client [%s], packet dropped\",\n                            mroute_addr_print(&src, &gc));\n                        c->c2.to_tun.len = 0;\n                    }\n                }\n                else\n                {\n                    c->c2.to_tun.len = 0;\n                }\n            }\n        }\n\n        /* postprocess and set wakeup */\n        ret = multi_process_post(m, m->pending, mpp_flags);\n\n        clear_prefix();\n    }\n\n    gc_free(&gc);\n    return ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148134,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "multi_process_incoming_link(struct multi_context *m, struct multi_instance *instance, const unsigned int mpp_flags)\n{\n    struct gc_arena gc = gc_new();\n\n    struct context *c;\n    struct mroute_addr src, dest;\n    unsigned int mroute_flags;\n    struct multi_instance *mi;\n    bool ret = true;\n    bool floated = false;\n\n    if (m->pending)\n    {\n        return true;\n    }\n\n    if (!instance)\n    {\n#ifdef MULTI_DEBUG_EVENT_LOOP\n        printf(\"TCP/UDP -> TUN [%d]\\n\", BLEN(&m->top.c2.buf));\n#endif\n        multi_set_pending(m, multi_get_create_instance_udp(m, &floated));\n    }\n    else\n    {\n        multi_set_pending(m, instance);\n    }\n\n    if (m->pending)\n    {\n        set_prefix(m->pending);\n\n        /* get instance context */\n        c = &m->pending->context;\n\n        if (!instance)\n        {\n            /* transfer packet pointer from top-level context buffer to instance */\n            c->c2.buf = m->top.c2.buf;\n\n            /* transfer from-addr from top-level context buffer to instance */\n            if (!floated)\n            {\n                c->c2.from = m->top.c2.from;\n            }\n        }\n\n        if (BLEN(&c->c2.buf) > 0)\n        {\n            struct link_socket_info *lsi;\n            const uint8_t *orig_buf;\n\n            /* decrypt in instance context */\n\n            perf_push(PERF_PROC_IN_LINK);\n            lsi = get_link_socket_info(c);\n            orig_buf = c->c2.buf.data;\n            if (process_incoming_link_part1(c, lsi, floated))\n            {\n                /* nonzero length means that we have a valid, decrypted packed */\n                if (floated && c->c2.buf.len > 0)\n                {\n                    multi_process_float(m, m->pending);\n                }\n\n                process_incoming_link_part2(c, lsi, orig_buf);\n            }\n            perf_pop();\n\n            if (TUNNEL_TYPE(m->top.c1.tuntap) == DEV_TYPE_TUN)\n            {\n                /* extract packet source and dest addresses */\n                mroute_flags = mroute_extract_addr_from_packet(&src,\n                                                               &dest,\n                                                               NULL,\n                                                               NULL,\n                                                               0,\n                                                               &c->c2.to_tun,\n                                                               DEV_TYPE_TUN);\n\n                /* drop packet if extract failed */\n                if (!(mroute_flags & MROUTE_EXTRACT_SUCCEEDED))\n                {\n                    c->c2.to_tun.len = 0;\n                }\n                /* make sure that source address is associated with this client */\n                else if (multi_get_instance_by_virtual_addr(m, &src, true) != m->pending)\n                {\n                    /* IPv6 link-local address (fe80::xxx)? */\n                    if ( (src.type & MR_ADDR_MASK) == MR_ADDR_IPV6\n                         && IN6_IS_ADDR_LINKLOCAL(&src.v6.addr) )\n                    {\n                        /* do nothing, for now.  TODO: add address learning */\n                    }\n                    else\n                    {\n                        msg(D_MULTI_DROPPED, \"MULTI: bad source address from client [%s], packet dropped\",\n                            mroute_addr_print(&src, &gc));\n                    }\n                    c->c2.to_tun.len = 0;\n                }\n                /* client-to-client communication enabled? */\n                else if (m->enable_c2c)\n                {\n                    /* multicast? */\n                    if (mroute_flags & MROUTE_EXTRACT_MCAST)\n                    {\n                        /* for now, treat multicast as broadcast */\n                        multi_bcast(m, &c->c2.to_tun, m->pending, NULL, 0);\n                    }\n                    else /* possible client to client routing */\n                    {\n                        ASSERT(!(mroute_flags & MROUTE_EXTRACT_BCAST));\n                        mi = multi_get_instance_by_virtual_addr(m, &dest, true);\n\n                        /* if dest addr is a known client, route to it */\n                        if (mi)\n                        {\n#ifdef ENABLE_PF\n                            if (!pf_c2c_test(&c->c2.pf, c->c2.tls_multi,\n                                             &mi->context.c2.pf,\n                                             mi->context.c2.tls_multi,\n                                             \"tun_c2c\"))\n                            {\n                                msg(D_PF_DROPPED, \"PF: client -> client[%s] packet dropped by TUN packet filter\",\n                                    mi_prefix(mi));\n                            }\n                            else\n#endif\n                            {\n                                multi_unicast(m, &c->c2.to_tun, mi);\n                                register_activity(c, BLEN(&c->c2.to_tun));\n                            }\n                            c->c2.to_tun.len = 0;\n                        }\n                    }\n                }\n#ifdef ENABLE_PF\n                if (c->c2.to_tun.len && !pf_addr_test(&c->c2.pf, c, &dest,\n                                                      \"tun_dest_addr\"))\n                {\n                    msg(D_PF_DROPPED, \"PF: client -> addr[%s] packet dropped by TUN packet filter\",\n                        mroute_addr_print_ex(&dest, MAPF_SHOW_ARP, &gc));\n                    c->c2.to_tun.len = 0;\n                }\n#endif\n            }\n            else if (TUNNEL_TYPE(m->top.c1.tuntap) == DEV_TYPE_TAP)\n            {\n                uint16_t vid = 0;\n#ifdef ENABLE_PF\n                struct mroute_addr edest;\n                mroute_addr_reset(&edest);\n#endif\n\n                if (m->top.options.vlan_tagging)\n                {\n                    if (vlan_is_tagged(&c->c2.to_tun))\n                    {\n                        /* Drop VLAN-tagged frame. */\n                        msg(D_VLAN_DEBUG, \"dropping incoming VLAN-tagged frame\");\n                        c->c2.to_tun.len = 0;\n                    }\n                    else\n                    {\n                        vid = c->options.vlan_pvid;\n                    }\n                }\n                /* extract packet source and dest addresses */\n                mroute_flags = mroute_extract_addr_from_packet(&src,\n                                                               &dest,\n                                                               NULL,\n#ifdef ENABLE_PF\n                                                               &edest,\n#else\n                                                               NULL,\n#endif\n                                                               vid,\n                                                               &c->c2.to_tun,\n                                                               DEV_TYPE_TAP);\n\n                if (mroute_flags & MROUTE_EXTRACT_SUCCEEDED)\n                {\n                    if (multi_learn_addr(m, m->pending, &src, 0) == m->pending)\n                    {\n                        /* check for broadcast */\n                        if (m->enable_c2c)\n                        {\n                            if (mroute_flags & (MROUTE_EXTRACT_BCAST|MROUTE_EXTRACT_MCAST))\n                            {\n                                multi_bcast(m, &c->c2.to_tun, m->pending, NULL,\n                                            vid);\n                            }\n                            else /* try client-to-client routing */\n                            {\n                                mi = multi_get_instance_by_virtual_addr(m, &dest, false);\n\n                                /* if dest addr is a known client, route to it */\n                                if (mi)\n                                {\n#ifdef ENABLE_PF\n                                    if (!pf_c2c_test(&c->c2.pf, c->c2.tls_multi,\n                                                     &mi->context.c2.pf,\n                                                     mi->context.c2.tls_multi,\n                                                     \"tap_c2c\"))\n                                    {\n                                        msg(D_PF_DROPPED, \"PF: client -> client[%s] packet dropped by TAP packet filter\",\n                                            mi_prefix(mi));\n                                    }\n                                    else\n#endif\n                                    {\n                                        multi_unicast(m, &c->c2.to_tun, mi);\n                                        register_activity(c, BLEN(&c->c2.to_tun));\n                                    }\n                                    c->c2.to_tun.len = 0;\n                                }\n                            }\n                        }\n#ifdef ENABLE_PF\n                        if (c->c2.to_tun.len && !pf_addr_test(&c->c2.pf, c,\n                                                              &edest,\n                                                              \"tap_dest_addr\"))\n                        {\n                            msg(D_PF_DROPPED, \"PF: client -> addr[%s] packet dropped by TAP packet filter\",\n                                mroute_addr_print_ex(&edest, MAPF_SHOW_ARP, &gc));\n                            c->c2.to_tun.len = 0;\n                        }\n#endif\n                    }\n                    else\n                    {\n                        msg(D_MULTI_DROPPED, \"MULTI: bad source address from client [%s], packet dropped\",\n                            mroute_addr_print(&src, &gc));\n                        c->c2.to_tun.len = 0;\n                    }\n                }\n                else\n                {\n                    c->c2.to_tun.len = 0;\n                }\n            }\n        }\n\n        /* postprocess and set wakeup */\n        ret = multi_process_post(m, m->pending, mpp_flags);\n\n        clear_prefix();\n    }\n\n    gc_free(&gc);\n    return ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148135,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err MergeTrack(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_MovieFragmentBox *moof_box, u64 moof_offset, s32 compressed_diff, u64 *cumulated_offset, Bool is_first_merge)\n{\n\tu32 i, j, chunk_size, track_num;\n\tu64 base_offset, data_offset, traf_duration;\n\tu32 def_duration, DescIndex, def_size, def_flags;\n\tu32 duration, size, flags, prev_trun_data_offset, sample_index;\n\tu8 pad, sync;\n\tu16 degr;\n\tBool first_samp_in_traf=GF_TRUE;\n\tBool store_traf_map=GF_FALSE;\n\tu8 *moof_template=NULL;\n\tu32 moof_template_size=0;\n\tBool is_seg_start = GF_FALSE;\n\tu64 seg_start=0, sidx_start=0, sidx_end=0, frag_start=0, last_dts=0;\n\tGF_TrackFragmentRunBox *trun;\n\tGF_TrunEntry *ent;\n#ifdef GF_ENABLE_CTRN\n\tGF_TrackFragmentBox *traf_ref = NULL;\n#endif\n\n\tGF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack);\n\tGF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack);\n\tGF_Err stbl_AppendChunk(GF_SampleTableBox *stbl, u64 offset);\n\tGF_Err stbl_AppendSampleToChunk(GF_SampleTableBox *stbl, u32 DescIndex, u32 samplesInChunk);\n\tGF_Err stbl_AppendCTSOffset(GF_SampleTableBox *stbl, s32 CTSOffset);\n\tGF_Err stbl_AppendRAP(GF_SampleTableBox *stbl, u8 isRap);\n\tGF_Err stbl_AppendPadding(GF_SampleTableBox *stbl, u8 padding);\n\tGF_Err stbl_AppendDegradation(GF_SampleTableBox *stbl, u16 DegradationPriority);\n\n\tif (trak->Header->trackID != traf->tfhd->trackID) return GF_OK;\n\tif (!trak->Media->information->sampleTable\n\t\t|| !trak->Media->information->sampleTable->SampleSize\n\t\t|| !trak->Media->information->sampleTable->TimeToSample\n\t\t|| !trak->Media->information->sampleTable->SampleToChunk\n\t\t|| !trak->Media->information->sampleTable->ChunkOffset\n\t) {\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tif (!traf->trex->track)\n\t\ttraf->trex->track = trak;\n\n\t//setup all our defaults\n\tDescIndex = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DESC) ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index;\n\tif (!DescIndex) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] default sample description set to 0, likely broken ! Fixing to 1\\n\" ));\n\t\tDescIndex = 1;\n\t} else if (DescIndex > gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] default sample description set to %d but only %d sample description(s), likely broken ! Fixing to 1\\n\", DescIndex, gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)));\n\t\tDescIndex = 1;\n\t}\n#ifdef GF_ENABLE_CTRN\n\tif (traf->trex->inherit_from_traf_id) {\n\t\tu32 traf_count = gf_list_count(moof_box->TrackList);\n\t\tfor (i=0; i<traf_count; i++) {\n\t\t\tGF_TrackFragmentBox *atraf = gf_list_get(moof_box->TrackList, i);\n\t\t\tif (atraf->tfhd && atraf->tfhd->trackID==traf->trex->inherit_from_traf_id) {\n\t\t\t\ttraf_ref = atraf;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tdef_duration = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DUR) ? traf->tfhd->def_sample_duration : traf->trex->def_sample_duration;\n\tdef_size = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_SIZE) ? traf->tfhd->def_sample_size : traf->trex->def_sample_size;\n\tdef_flags = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) ? traf->tfhd->def_sample_flags : traf->trex->def_sample_flags;\n\n\t//locate base offset, by default use moof (dash-like)\n\tbase_offset = moof_offset;\n\t//explicit base offset, use it\n\tif (traf->tfhd->flags & GF_ISOM_TRAF_BASE_OFFSET)\n\t\tbase_offset = traf->tfhd->base_data_offset;\n\t//no moof offset and no explicit offset, the offset is the end of the last written chunk of\n\t//the previous traf. For the first traf, *cumulated_offset is actually moof offset\n\telse if (!(traf->tfhd->flags & GF_ISOM_MOOF_BASE_OFFSET))\n\t\tbase_offset = *cumulated_offset;\n\n\tchunk_size = 0;\n\tprev_trun_data_offset = 0;\n\tdata_offset = 0;\n\ttraf_duration = 0;\n\n\t/*in playback mode*/\n\tif (traf->tfdt && is_first_merge) {\n#ifndef GPAC_DISABLE_LOG\n\t\tif (trak->moov->mov->NextMoofNumber && trak->present_in_scalable_segment && trak->sample_count_at_seg_start && (trak->dts_at_seg_start != traf->tfdt->baseMediaDecodeTime)) {\n\t\t\ts32 drift = (s32) ((s64) traf->tfdt->baseMediaDecodeTime - (s64)trak->dts_at_seg_start);\n\t\t\tif (drift<0)  {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Warning: TFDT timing \"LLD\" less than cumulated timing \"LLD\" - using tfdt\\n\", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start ));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] TFDT timing \"LLD\" higher than cumulated timing \"LLD\" (last sample got extended in duration)\\n\", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start ));\n\t\t\t}\n\t\t}\n#endif\n\t\ttrak->dts_at_seg_start = traf->tfdt->baseMediaDecodeTime;\n\t}\n\telse if (traf->tfxd) {\n\t\ttrak->dts_at_seg_start = traf->tfxd->absolute_time_in_track_timescale;\n\t}\n\n\tif (traf->tfxd) {\n\t\ttrak->last_tfxd_value = traf->tfxd->absolute_time_in_track_timescale;\n\t\ttrak->last_tfxd_value += traf->tfxd->fragment_duration_in_track_timescale;\n\t}\n\tif (traf->tfrf) {\n\t\tif (trak->tfrf) gf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->tfrf);\n\t\ttrak->tfrf = traf->tfrf;\n\t\tgf_list_del_item(traf->child_boxes, traf->tfrf);\n\t\tgf_list_add(trak->child_boxes, trak->tfrf);\n\t}\n\n\tif (trak->moov->mov->signal_frag_bounds) {\n\t\tstore_traf_map = GF_TRUE;\n\t\tif (is_first_merge) {\n\t\t\tGF_MovieFragmentBox *moof_clone = NULL;\n\t\t\tgf_isom_box_freeze_order((GF_Box *)moof_box);\n\t\t\tgf_isom_clone_box((GF_Box *)moof_box, (GF_Box **)&moof_clone);\n\n\t\t\tif (moof_clone) {\n\t\t\t\tGF_BitStream *bs;\n\t\t\t\tfor (i=0; i<gf_list_count(moof_clone->TrackList); i++) {\n\t\t\t\t\tGF_TrackFragmentBox *traf_clone = gf_list_get(moof_clone->TrackList, i);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->TrackRuns);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroups);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroupsDescription);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sub_samples);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_offsets);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_sizes);\n\t\t\t\t\tif (traf_clone->sample_encryption) {\n\t\t\t\t\t\tgf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sample_encryption);\n\t\t\t\t\t\ttraf_clone->sample_encryption = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (traf_clone->sdtp) {\n\t\t\t\t\t\tgf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sdtp);\n\t\t\t\t\t\ttraf_clone->sdtp = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_isom_box_size((GF_Box *)moof_clone);\n\t\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\tif (trak->moov->mov->seg_styp) {\n\t\t\t\t\tgf_isom_box_size(trak->moov->mov->seg_styp);\n\t\t\t\t\tgf_isom_box_write(trak->moov->mov->seg_styp, bs);\n\t\t\t\t}\n\t\t\t\tif (trak->moov->mov->root_sidx) {\n\t\t\t\t\tgf_isom_box_size((GF_Box *)trak->moov->mov->root_sidx);\n\t\t\t\t\tgf_isom_box_write((GF_Box *)trak->moov->mov->root_sidx, bs);\n\t\t\t\t}\n\t\t\t\tif (trak->moov->mov->seg_ssix) {\n\t\t\t\t\tgf_isom_box_size(trak->moov->mov->seg_ssix);\n\t\t\t\t\tgf_isom_box_write(trak->moov->mov->seg_ssix, bs);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_write((GF_Box *)moof_clone, bs);\n\t\t\t\tgf_isom_box_del((GF_Box*)moof_clone);\n\n\t\t\t\tgf_bs_get_content(bs, &moof_template, &moof_template_size);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t}\n\t\t}\n\t\tif (trak->moov->mov->seg_styp) {\n\t\t\tis_seg_start = GF_TRUE;\n\t\t\tseg_start = trak->moov->mov->styp_start_offset;\n\t\t}\n\t\tif (trak->moov->mov->root_sidx) {\n\t\t\tis_seg_start = GF_TRUE;\n\t\t\tsidx_start = trak->moov->mov->sidx_start_offset;\n\t\t\tsidx_end = trak->moov->mov->sidx_end_offset;\n\t\t\tif (! seg_start || (sidx_start<seg_start))\n\t\t\t\tseg_start = sidx_start;\n\t\t}\n\t\tfrag_start = trak->moov->mov->current_top_box_start;\n\t}\n\telse if (trak->moov->mov->store_traf_map) {\n\t\tstore_traf_map = GF_TRUE;\n\t}\n\n\n\tsample_index = 0;\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) {\n\t\t//merge the run\n\t\tfor (j=0; j<trun->sample_count; j++) {\n\t\t\tGF_Err e;\n\t\t\ts32 cts_offset=0;\n\t\t\tif (j<trun->nb_samples) {\n\t\t\t\tent = &trun->samples[j];\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d doesn't have enough trun entries (%d) compared to sample count (%d) in run\\n\", traf->trex->trackID, trun->nb_samples, trun->sample_count ));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsize = def_size;\n\t\t\tduration = def_duration;\n\t\t\tflags = def_flags;\n\n\t\t\t//CTS - if flag not set (trun or ctrn) defaults to 0 which is the base value after alloc\n\t\t\t//we just need to overrite its value if inherited\n\t\t\tcts_offset = ent->CTS_Offset;\n\n#ifdef GF_ENABLE_CTRN\n\t\t\tif (trun->use_ctrn) {\n\t\t\t\tif (!j && (trun->ctrn_flags & GF_ISOM_CTRN_FIRST_SAMPLE) ) {\n\t\t\t\t\tif (trun->ctrn_first_dur) duration = ent->Duration;\n\t\t\t\t\tif (trun->ctrn_first_size) size = ent->size;\n\t\t\t\t\tif (trun->ctrn_first_ctts) flags = ent->flags;\n\t\t\t\t} else {\n\t\t\t\t\tif (trun->ctrn_dur) duration = ent->Duration;\n\t\t\t\t\tif (trun->ctrn_size) size = ent->size;\n\t\t\t\t\tif (trun->ctrn_sample_flags) flags = ent->flags;\n\t\t\t\t}\n\t\t\t\t/*re-override*/\n\t\t\t\tif (trun->ctrn_flags & 0xF0) {\n\t\t\t\t\tGF_TrunEntry *ref_entry;\n\t\t\t\t\tif (!traf_ref) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d use traf inheritance to track ID %d but reference traf not found\\n\", traf->trex->trackID, traf->trex->inherit_from_traf_id ));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tref_entry = traf_get_sample_entry(traf_ref, sample_index);\n\t\t\t\t\tif (!ref_entry) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d use traf inheritance but sample %d not found in reference traf\\n\", traf->trex->trackID, sample_index+1 ));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_DUR)\n\t\t\t\t\t\tduration = ref_entry->Duration;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_SIZE)\n\t\t\t\t\t\tsize = ref_entry->size;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_FLAGS)\n\t\t\t\t\t\tflags = ref_entry->flags;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_CTSO)\n\t\t\t\t\t\tcts_offset = ref_entry->CTS_Offset;\n\t\t\t\t}\n\n\t\t\t} else\n#endif\n\t\t\t{\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DURATION) duration = ent->Duration;\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_SIZE) size = ent->size;\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\t\t\tflags = ent->flags;\n\t\t\t\t} else if (!j && (trun->flags & GF_ISOM_TRUN_FIRST_FLAG)) {\n\t\t\t\t\tflags = trun->first_sample_flags;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsample_index++;\n\t\t\t/*store the resolved value in case we have inheritance*/\n\t\t\tent->size = size;\n\t\t\tent->Duration = duration;\n\t\t\tent->flags = flags;\n\t\t\tent->CTS_Offset = cts_offset;\n\n\t\t\tlast_dts += duration;\n\n\t\t\t//add size first\n\t\t\tif (!trak->Media->information->sampleTable->SampleSize) {\n\t\t\t\ttrak->Media->information->sampleTable->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSZ);\n\t\t\t\tif (!trak->Media->information->sampleTable->SampleSize)\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\te = stbl_AppendSize(trak->Media->information->sampleTable, size, ent->nb_pack);\n\t\t\tif (e) return e;\n\n\t\t\t//then TS\n\t\t\tif (!trak->Media->information->sampleTable->TimeToSample) {\n\t\t\t\ttrak->Media->information->sampleTable->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STTS);\n\t\t\t\tif (!trak->Media->information->sampleTable->TimeToSample)\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\te = stbl_AppendTime(trak->Media->information->sampleTable, duration, ent->nb_pack);\n\t\t\tif (e) return e;\n\n\t\t\t//add chunk on first sample\n\t\t\tif (!j) {\n\t\t\t\tu64 final_offset;\n\t\t\t\tdata_offset = base_offset;\n\t\t\t\t//we have an explicit data offset for this trun\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\t\t\t\tdata_offset += trun->data_offset;\n\t\t\t\t\t/*reset chunk size since data is now relative to this trun*/\n\t\t\t\t\tchunk_size = 0;\n\t\t\t\t\t/*remember this data offset for following trun*/\n\t\t\t\t\tprev_trun_data_offset = trun->data_offset;\n\t\t\t\t\t/*if mdat is located after the moof, and the moof was compressed, adjust offset\n\t\t\t\t\totherwise the offset does not need adjustment*/\n\t\t\t\t\tif (trun->data_offset>=0) {\n\t\t\t\t\t\tdata_offset -= compressed_diff;\n\t\t\t\t\t\tprev_trun_data_offset -= compressed_diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//we had an explicit data offset for the previous trun, use it + chunk size\n\t\t\t\telse if (prev_trun_data_offset) {\n\t\t\t\t\t/*data offset is previous chunk size plus previous offset of the trun*/\n\t\t\t\t\tdata_offset += prev_trun_data_offset + chunk_size;\n\t\t\t\t}\n\t\t\t\t//no explicit data offset, continuous data after last data in previous chunk\n\t\t\t\telse {\n\t\t\t\t\tdata_offset += chunk_size;\n\t\t\t\t\t//data offset of first trun in first traf, adjust if compressed moof\n\t\t\t\t\tif ((i==1) && (trun->data_offset>=0)) {\n\t\t\t\t\t\tdata_offset -= compressed_diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfinal_offset = data_offset;\n\t\t\t\t//adjust offset if moov was also compressed and we are still in the same file\n\t\t\t\t//so that later call to gf_isom_get_sample properly adjust back the offset\n\t\t\t\tif (trak->moov->compressed_diff) {\n\t\t\t\t\tfinal_offset += trak->moov->compressed_diff;\n\t\t\t\t}\n\n\t\t\t\tif (!trak->Media->information->sampleTable->ChunkOffset) {\n\t\t\t\t\ttrak->Media->information->sampleTable->ChunkOffset = gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STCO);\n\t\t\t\t\tif (!trak->Media->information->sampleTable->ChunkOffset)\n\t\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\te = stbl_AppendChunk(trak->Media->information->sampleTable, final_offset);\n\t\t\t\tif (e) return e;\n\t\t\t\t//then sampleToChunk\n\t\t\t\tif (!trak->Media->information->sampleTable->SampleToChunk) {\n\t\t\t\t\ttrak->Media->information->sampleTable->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSC);\n\t\t\t\t\tif (!trak->Media->information->sampleTable->SampleToChunk)\n\t\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\te = stbl_AppendSampleToChunk(trak->Media->information->sampleTable,\n\t\t\t\t                         DescIndex, trun->sample_count);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\tchunk_size += size;\n\n\t\t\tif (store_traf_map && first_samp_in_traf) {\n\t\t\t\tfirst_samp_in_traf = GF_FALSE;\n\t\t\t\te = stbl_AppendTrafMap(trak->Media->information->sampleTable, is_seg_start, seg_start, frag_start, moof_template, moof_template_size, sidx_start, sidx_end);\n\t\t\t\tif (e) return e;\n\t\t\t\t//do not deallocate, the memory is now owned by traf map\n\t\t\t\tmoof_template = NULL;\n\t\t\t\tmoof_template_size = 0;\n\t\t\t}\n\t\t\tif (ent->nb_pack>1) {\n\t\t\t\tj+= ent->nb_pack-1;\n\t\t\t\ttraf_duration += ent->nb_pack*duration;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttraf_duration += duration;\n\n\t\t\te = stbl_AppendCTSOffset(trak->Media->information->sampleTable, cts_offset);\n\t\t\tif (e) return e;\n\t\t\t//flags\n\t\t\tsync = GF_ISOM_GET_FRAG_SYNC(flags);\n\t\t\tif (trak->Media->information->sampleTable->no_sync_found && sync) {\n\t\t\t\ttrak->Media->information->sampleTable->no_sync_found = 0;\n\t\t\t}\n\t\t\te = stbl_AppendRAP(trak->Media->information->sampleTable, sync);\n\t\t\tif (e) return e;\n\t\t\tpad = GF_ISOM_GET_FRAG_PAD(flags);\n\t\t\tif (pad) {\n\t\t\t\te = stbl_AppendPadding(trak->Media->information->sampleTable, pad);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\tdegr = GF_ISOM_GET_FRAG_DEG(flags);\n\t\t\tif (degr) {\n\t\t\t\te = stbl_AppendDegradation(trak->Media->information->sampleTable, degr);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\te = stbl_AppendDependencyType(trak->Media->information->sampleTable, GF_ISOM_GET_FRAG_LEAD(flags), GF_ISOM_GET_FRAG_DEPENDS(flags), GF_ISOM_GET_FRAG_DEPENDED(flags), GF_ISOM_GET_FRAG_REDUNDANT(flags));\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\n\tif (trak->moov->mov->is_smooth && !traf->tfdt && !traf->tfxd) {\n\t\tif (is_first_merge)\n\t\t\ttrak->dts_at_seg_start = trak->dts_at_next_seg_start;\n\t\ttrak->dts_at_next_seg_start += last_dts;\n\t}\n\tif (traf_duration && trak->editBox && trak->editBox->editList) {\n\t\tfor (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) {\n\t\t\tGF_EdtsEntry *edts_e = gf_list_get(trak->editBox->editList->entryList, i);\n\t\t\tif (edts_e->was_empty_dur) {\n\t\t\t\tu64 extend_dur = traf_duration;\n\t\t\t\textend_dur *= trak->moov->mvhd->timeScale;\n\t\t\t\textend_dur /= trak->Media->mediaHeader->timeScale;\n\t\t\t\tedts_e->segmentDuration += extend_dur;\n\t\t\t}\n\t\t\telse if (!edts_e->segmentDuration) {\n\t\t\t\tedts_e->was_empty_dur = GF_TRUE;\n\t\t\t\tif ((s64) traf_duration > edts_e->mediaTime)\n\t\t\t\t\ttraf_duration -= edts_e->mediaTime;\n\t\t\t\telse\n\t\t\t\t\ttraf_duration = 0;\n\n\t\t\t\tedts_e->segmentDuration = traf_duration;\n\t\t\t\tedts_e->segmentDuration *= trak->moov->mvhd->timeScale;\n\t\t\t\tedts_e->segmentDuration /= trak->Media->mediaHeader->timeScale;\n\t\t\t}\n\n\t\t}\n\t}\n\n\t//in any case, update the cumulated offset\n\t//this will handle hypothetical files mixing MOOF offset and implicit non-moof offset\n\t*cumulated_offset = data_offset + chunk_size;\n\n\t/*merge sample groups*/\n\tif (traf->sampleGroups) {\n\t\tGF_List *groups;\n\t\tGF_List *groupDescs;\n\t\tBool is_identical_sgpd = GF_TRUE;\n\t\tu32 *new_idx = NULL, new_idx_count=0;\n\n\t\tif (!trak->Media->information->sampleTable->sampleGroups)\n\t\t\ttrak->Media->information->sampleTable->sampleGroups = gf_list_new();\n\n\t\tif (!trak->Media->information->sampleTable->sampleGroupsDescription)\n\t\t\ttrak->Media->information->sampleTable->sampleGroupsDescription = gf_list_new();\n\n\t\tgroupDescs = trak->Media->information->sampleTable->sampleGroupsDescription;\n\t\tfor (i=0; i<gf_list_count(traf->sampleGroupsDescription); i++) {\n\t\t\tGF_SampleGroupDescriptionBox *new_sgdesc = NULL;\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = gf_list_get(traf->sampleGroupsDescription, i);\n\t\t\tfor (j=0; j<gf_list_count(groupDescs); j++) {\n\t\t\t\tnew_sgdesc = gf_list_get(groupDescs, j);\n\t\t\t\tif (new_sgdesc->grouping_type==sgdesc->grouping_type) break;\n\t\t\t\tnew_sgdesc = NULL;\n\t\t\t}\n\t\t\t/*new description, move it to our sample table*/\n\t\t\tif (!new_sgdesc) {\n\t\t\t\tgf_list_add(groupDescs, sgdesc);\n\t\t\t\tgf_list_add(trak->Media->information->sampleTable->child_boxes, sgdesc);\n\t\t\t\tgf_list_rem(traf->sampleGroupsDescription, i);\n\t\t\t\tgf_list_del_item(traf->child_boxes, sgdesc);\n\t\t\t\ti--;\n\t\t\t}\n\t\t\t/*merge descriptions*/\n\t\t\telse {\n\t\t\t\tu32 count;\n\n\t\t\t\tis_identical_sgpd = gf_isom_is_identical_sgpd(new_sgdesc, sgdesc, 0);\n\t\t\t\tif (is_identical_sgpd)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tnew_idx_count = gf_list_count(sgdesc->group_descriptions);\n\t\t\t\tnew_idx = (u32 *)gf_malloc(new_idx_count * sizeof(u32));\n\t\t\t\tif (!new_idx) return GF_OUT_OF_MEM;\n\n\t\t\t\tcount = 0;\n\t\t\t\twhile (gf_list_count(sgdesc->group_descriptions)) {\n\t\t\t\t\tvoid *sgpd_entry = gf_list_get(sgdesc->group_descriptions, 0);\n\t\t\t\t\tBool new_entry = GF_TRUE;\n\n\t\t\t\t\tfor (j = 0; j < gf_list_count(new_sgdesc->group_descriptions); j++) {\n\t\t\t\t\t\tvoid *ptr = gf_list_get(new_sgdesc->group_descriptions, j);\n\t\t\t\t\t\tif (gf_isom_is_identical_sgpd(sgpd_entry, ptr, new_sgdesc->grouping_type)) {\n\t\t\t\t\t\t\tnew_idx[count] = j + 1;\n\t\t\t\t\t\t\tcount ++;\n\t\t\t\t\t\t\tnew_entry = GF_FALSE;\n\t\t\t\t\t\t\tgf_free(sgpd_entry);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (new_entry) {\n\t\t\t\t\t\tgf_list_add(new_sgdesc->group_descriptions, sgpd_entry);\n\t\t\t\t\t\tnew_idx[count] = gf_list_count(new_sgdesc->group_descriptions);\n\t\t\t\t\t\tcount ++;\n\t\t\t\t\t}\n\n\t\t\t\t\tgf_list_rem(sgdesc->group_descriptions, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgroups = trak->Media->information->sampleTable->sampleGroups;\n\t\tfor (i=0; i<gf_list_count(traf->sampleGroups); i++) {\n\t\t\tGF_SampleGroupBox *stbl_group = NULL;\n\t\t\tGF_SampleGroupBox *frag_group = gf_list_get(traf->sampleGroups, i);\n\n\n\t\t\tfor (j=0; j<gf_list_count(groups); j++) {\n\t\t\t\tstbl_group = gf_list_get(groups, j);\n\t\t\t\tif ((frag_group->grouping_type==stbl_group->grouping_type) && (frag_group->grouping_type_parameter==stbl_group->grouping_type_parameter))\n\t\t\t\t\tbreak;\n\t\t\t\tstbl_group = NULL;\n\t\t\t}\n\t\t\tif (!stbl_group) {\n\t\t\t\tstbl_group = (GF_SampleGroupBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SBGP);\n\t\t\t\tif (!stbl_group) return GF_OUT_OF_MEM;\n\t\t\t\tstbl_group->grouping_type = frag_group->grouping_type;\n\t\t\t\tstbl_group->grouping_type_parameter = frag_group->grouping_type_parameter;\n\t\t\t\tstbl_group->version = frag_group->version;\n\t\t\t\tgf_list_add(groups, stbl_group);\n\t\t\t}\n\n\t\t\tif (is_identical_sgpd) {\n\t\t\t\t//adjust sgpd index: in traf index start at 0x1001\n\t\t\t\tfor (j = 0; j < frag_group->entry_count; j++)\n\t\t\t\t\tfrag_group->sample_entries[j].group_description_index &= 0x0FFFF;\n\t\t\t\tif (frag_group->entry_count && stbl_group->entry_count &&\n\t\t\t\t        (frag_group->sample_entries[0].group_description_index==stbl_group->sample_entries[stbl_group->entry_count-1].group_description_index)\n\t\t\t\t   ) {\n\t\t\t\t\tstbl_group->sample_entries[stbl_group->entry_count - 1].sample_count += frag_group->sample_entries[0].sample_count;\n\t\t\t\t\tif (frag_group->entry_count>1) {\n\t\t\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count - 1));\n\t\t\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[1], sizeof(GF_SampleGroupEntry) * (frag_group->entry_count - 1));\n\t\t\t\t\t\tstbl_group->entry_count += frag_group->entry_count - 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count));\n\t\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count);\n\t\t\t\t\tstbl_group->entry_count += frag_group->entry_count;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count));\n\t\t\t\t//adjust sgpd index\n\t\t\t\tfor (j = 0; j < frag_group->entry_count; j++) {\n\t\t\t\t\tu32 sgidx = frag_group->sample_entries[j].group_description_index;\n\t\t\t\t\tif (sgidx > 0x10000) {\n\t\t\t\t\t\tsgidx -= 0x10001;\n\t\t\t\t\t\tif (sgidx>=new_idx_count) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isobmf] corrupted sample group index in fragment %d but only %d group descriptions in fragment\\n\", sgidx, new_idx_count));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfrag_group->sample_entries[j].group_description_index = new_idx[sgidx];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count);\n\t\t\t\tstbl_group->entry_count += frag_group->entry_count;\n\t\t\t}\n\t\t}\n\n\t\tif (new_idx) gf_free(new_idx);\n\t}\n\n\t/*content is encrypted*/\n\ttrack_num = gf_isom_get_tracknum_from_id(trak->moov, trak->Header->trackID);\n\tif (gf_isom_is_cenc_media(trak->moov->mov, track_num, DescIndex)\n\t\t|| traf->sample_encryption) {\n\t\t/*Merge sample auxiliary encryption information*/\n\t\tGF_SampleEncryptionBox *senc = NULL;\n\t\tu32 scheme_type;\n\t\tgf_isom_get_cenc_info(trak->moov->mov, track_num, DescIndex, NULL, &scheme_type, NULL);\n\n\t\tif (traf->sample_encryption) {\n\t\t\tfor (i = 0; i < gf_list_count(trak->Media->information->sampleTable->child_boxes); i++) {\n\t\t\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->child_boxes, i);\n\t\t\t\tif (a->type != traf->sample_encryption->type) continue;\n\n\t\t\t\tif ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)a;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (a->type ==GF_ISOM_BOX_TYPE_SENC) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)a;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!senc && trak->sample_encryption)\n\t\t\t\tsenc = trak->sample_encryption;\n\n\t\t\tif (!senc) {\n\t\t\t\tif (traf->sample_encryption->piff_type==1) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)gf_isom_create_piff_psec_box(1, 0x2, 0, 0, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tsenc = gf_isom_create_samp_enc_box(1, 0x2);\n\t\t\t\t}\n\n\t\t\t\tif (!trak->Media->information->sampleTable->child_boxes) trak->Media->information->sampleTable->child_boxes = gf_list_new();\n\n\t\t\t\ttrak->sample_encryption = senc;\n\t\t\t\tif (!trak->child_boxes) trak->child_boxes = gf_list_new();\n\t\t\t\tgf_list_add(trak->child_boxes, senc);\n\t\t\t}\n\t\t}\n\n\t\t/*get sample auxiliary information by saiz/saio rather than by parsing senc box*/\n\t\tif (gf_isom_cenc_has_saiz_saio_traf(traf, scheme_type)) {\n\t\t\tu32 nb_saio;\n\t\t\tu32 aux_info_type;\n\t\t\tu64 offset;\n\t\t\tGF_Err e;\n\t\t\tBool is_encrypted;\n\t\t\tGF_SampleAuxiliaryInfoOffsetBox *saio = NULL;\n\t\t\tGF_SampleAuxiliaryInfoSizeBox *saiz = NULL;\n\n\t\t\toffset = nb_saio = 0;\n\n\t\t\tfor (i = 0; i < gf_list_count(traf->sai_offsets); i++) {\n\t\t\t\tsaio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(traf->sai_offsets, i);\n\t\t\t\taux_info_type = saio->aux_info_type;\n\t\t\t\tif (!aux_info_type) aux_info_type = scheme_type;\n\n\t\t\t\t/*if we have only 1 sai_offsets, assume that its type is cenc*/\n\t\t\t\tif ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) ||\n\t\t\t\t\t(aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) ||\n\t\t\t\t\t(gf_list_count(traf->sai_offsets) == 1)) {\n\t\t\t\t\toffset = saio->offsets[0] + moof_offset;\n\t\t\t\t\tnb_saio = saio->entry_count;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < gf_list_count(traf->sai_sizes); i++) {\n\t\t\t\tsaiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(traf->sai_sizes, i);\n\t\t\t\taux_info_type = saiz->aux_info_type;\n\t\t\t\tif (!aux_info_type) aux_info_type = scheme_type;\n\t\t\t\t/*if we have only 1 sai_sizes, assume that its type is cenc*/\n\t\t\t\tif ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) ||\n\t\t\t\t\t(aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) ||\n\t\t\t\t\t(gf_list_count(traf->sai_sizes) == 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (saiz && saio && senc) {\n\t\t\t\tfor (i = 0; i < saiz->sample_count; i++) {\n\t\t\t\t\tGF_CENCSampleAuxInfo *sai;\n\t\t\t\t\tconst u8 *key_info=NULL;\n\t\t\t\t\tu32 key_info_size;\n\t\t\t\t\tu64 cur_position;\n\t\t\t\t\tif (nb_saio != 1)\n\t\t\t\t\t\toffset = saio->offsets[i] + moof_offset;\n\t\t\t\t\tsize = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[i];\n\n\t\t\t\t\tcur_position = gf_bs_get_position(trak->moov->mov->movieFileMap->bs);\n\t\t\t\t\tgf_bs_seek(trak->moov->mov->movieFileMap->bs, offset);\n\n\t\t\t\t\tGF_SAFEALLOC(sai, GF_CENCSampleAuxInfo);\n\t\t\t\t\tif (!sai) return GF_OUT_OF_MEM;\n\n\t\t\t\t\te = gf_isom_get_sample_cenc_info_internal(trak, traf, senc, i+1, &is_encrypted, NULL, NULL, &key_info, &key_info_size);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isobmf] could not get cenc info for sample %d: %s\\n\", i+1, gf_error_to_string(e) ));\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (is_encrypted) {\n\t\t\t\t\t\tsai->cenc_data_size = size;\n\t\t\t\t\t\tsai->cenc_data = gf_malloc(sizeof(u8)*size);\n\t\t\t\t\t\tif (!sai->cenc_data) return GF_OUT_OF_MEM;\n\t\t\t\t\t\tgf_bs_read_data(trak->moov->mov->movieFileMap->bs, sai->cenc_data, sai->cenc_data_size);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsai->isNotProtected=1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (key_info) {\n\t\t\t\t\t\t//not multikey\n\t\t\t\t\t\tif (!key_info[0]) {\n\t\t\t\t\t\t\t//size greater than IV\n\t\t\t\t\t\t\tif (size > key_info[3])\n\t\t\t\t\t\t\t\tsenc->flags = 0x00000002;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//multikey, always use subsamples\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tsenc->flags = 0x00000002;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t\tgf_bs_seek(trak->moov->mov->movieFileMap->bs, cur_position);\n\n\t\t\t\t\tgf_list_add(senc->samp_aux_info, sai);\n\n\t\t\t\t\te = gf_isom_cenc_merge_saiz_saio(senc, trak->Media->information->sampleTable, offset, size);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\tif (nb_saio == 1)\n\t\t\t\t\t\toffset += size;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (traf->sample_encryption) {\n\t\t\tsenc_Parse(trak->moov->mov->movieFileMap->bs, trak, traf, traf->sample_encryption);\n\t\t\ttrak->sample_encryption->AlgorithmID = traf->sample_encryption->AlgorithmID;\n\t\t\tif (!trak->sample_encryption->IV_size)\n\t\t\t\ttrak->sample_encryption->IV_size = traf->sample_encryption->IV_size;\n\t\t\tif (!trak->sample_encryption->samp_aux_info) trak->sample_encryption->samp_aux_info = gf_list_new();\n\t\t\tgf_list_transfer(trak->sample_encryption->samp_aux_info, traf->sample_encryption->samp_aux_info);\n\t\t\tif (traf->sample_encryption->flags & 0x00000002)\n\t\t\t\ttrak->sample_encryption->flags |= 0x00000002;\n\t\t}\n\t}\n\treturn GF_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148136,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err MergeTrack(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_MovieFragmentBox *moof_box, u64 moof_offset, s32 compressed_diff, u64 *cumulated_offset, Bool is_first_merge)\n{\n\tu32 i, j, chunk_size, track_num;\n\tu64 base_offset, data_offset, traf_duration;\n\tu32 def_duration, DescIndex, def_size, def_flags;\n\tu32 duration, size, flags, prev_trun_data_offset, sample_index;\n\tu8 pad, sync;\n\tu16 degr;\n\tBool first_samp_in_traf=GF_TRUE;\n\tBool store_traf_map=GF_FALSE;\n\tu8 *moof_template=NULL;\n\tu32 moof_template_size=0;\n\tBool is_seg_start = GF_FALSE;\n\tu64 seg_start=0, sidx_start=0, sidx_end=0, frag_start=0, last_dts=0;\n\tGF_TrackFragmentRunBox *trun;\n\tGF_TrunEntry *ent;\n#ifdef GF_ENABLE_CTRN\n\tGF_TrackFragmentBox *traf_ref = NULL;\n#endif\n\n\tGF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack);\n\tGF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack);\n\tGF_Err stbl_AppendChunk(GF_SampleTableBox *stbl, u64 offset);\n\tGF_Err stbl_AppendSampleToChunk(GF_SampleTableBox *stbl, u32 DescIndex, u32 samplesInChunk);\n\tGF_Err stbl_AppendCTSOffset(GF_SampleTableBox *stbl, s32 CTSOffset);\n\tGF_Err stbl_AppendRAP(GF_SampleTableBox *stbl, u8 isRap);\n\tGF_Err stbl_AppendPadding(GF_SampleTableBox *stbl, u8 padding);\n\tGF_Err stbl_AppendDegradation(GF_SampleTableBox *stbl, u16 DegradationPriority);\n\n\tif (trak->Header->trackID != traf->tfhd->trackID) return GF_OK;\n\tif (!trak->Media->information->sampleTable\n\t\t|| !trak->Media->information->sampleTable->SampleSize\n\t\t|| !trak->Media->information->sampleTable->TimeToSample\n\t\t|| !trak->Media->information->sampleTable->SampleToChunk\n\t\t|| !trak->Media->information->sampleTable->ChunkOffset\n\t) {\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tif (!traf->trex->track)\n\t\ttraf->trex->track = trak;\n\n\t//setup all our defaults\n\tDescIndex = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DESC) ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index;\n\tif (!DescIndex) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] default sample description set to 0, likely broken ! Fixing to 1\\n\" ));\n\t\tDescIndex = 1;\n\t} else if (DescIndex > gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] default sample description set to %d but only %d sample description(s), likely broken ! Fixing to 1\\n\", DescIndex, gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)));\n\t\tDescIndex = 1;\n\t}\n#ifdef GF_ENABLE_CTRN\n\tif (traf->trex->inherit_from_traf_id) {\n\t\tu32 traf_count = gf_list_count(moof_box->TrackList);\n\t\tfor (i=0; i<traf_count; i++) {\n\t\t\tGF_TrackFragmentBox *atraf = gf_list_get(moof_box->TrackList, i);\n\t\t\tif (atraf->tfhd && atraf->tfhd->trackID==traf->trex->inherit_from_traf_id) {\n\t\t\t\ttraf_ref = atraf;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tdef_duration = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DUR) ? traf->tfhd->def_sample_duration : traf->trex->def_sample_duration;\n\tdef_size = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_SIZE) ? traf->tfhd->def_sample_size : traf->trex->def_sample_size;\n\tdef_flags = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) ? traf->tfhd->def_sample_flags : traf->trex->def_sample_flags;\n\n\t//locate base offset, by default use moof (dash-like)\n\tbase_offset = moof_offset;\n\t//explicit base offset, use it\n\tif (traf->tfhd->flags & GF_ISOM_TRAF_BASE_OFFSET)\n\t\tbase_offset = traf->tfhd->base_data_offset;\n\t//no moof offset and no explicit offset, the offset is the end of the last written chunk of\n\t//the previous traf. For the first traf, *cumulated_offset is actually moof offset\n\telse if (!(traf->tfhd->flags & GF_ISOM_MOOF_BASE_OFFSET))\n\t\tbase_offset = *cumulated_offset;\n\n\tchunk_size = 0;\n\tprev_trun_data_offset = 0;\n\tdata_offset = 0;\n\ttraf_duration = 0;\n\n\t/*in playback mode*/\n\tif (traf->tfdt && is_first_merge) {\n#ifndef GPAC_DISABLE_LOG\n\t\tif (trak->moov->mov->NextMoofNumber && trak->present_in_scalable_segment && trak->sample_count_at_seg_start && (trak->dts_at_seg_start != traf->tfdt->baseMediaDecodeTime)) {\n\t\t\ts32 drift = (s32) ((s64) traf->tfdt->baseMediaDecodeTime - (s64)trak->dts_at_seg_start);\n\t\t\tif (drift<0)  {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Warning: TFDT timing \"LLD\" less than cumulated timing \"LLD\" - using tfdt\\n\", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start ));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] TFDT timing \"LLD\" higher than cumulated timing \"LLD\" (last sample got extended in duration)\\n\", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start ));\n\t\t\t}\n\t\t}\n#endif\n\t\ttrak->dts_at_seg_start = traf->tfdt->baseMediaDecodeTime;\n\t}\n\telse if (traf->tfxd) {\n\t\ttrak->dts_at_seg_start = traf->tfxd->absolute_time_in_track_timescale;\n\t}\n\n\tif (traf->tfxd) {\n\t\ttrak->last_tfxd_value = traf->tfxd->absolute_time_in_track_timescale;\n\t\ttrak->last_tfxd_value += traf->tfxd->fragment_duration_in_track_timescale;\n\t}\n\tif (traf->tfrf) {\n\t\tif (trak->tfrf) gf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->tfrf);\n\t\ttrak->tfrf = traf->tfrf;\n\t\tgf_list_del_item(traf->child_boxes, traf->tfrf);\n\t\tgf_list_add(trak->child_boxes, trak->tfrf);\n\t}\n\n\tif (trak->moov->mov->signal_frag_bounds) {\n\t\tstore_traf_map = GF_TRUE;\n\t\tif (is_first_merge) {\n\t\t\tGF_MovieFragmentBox *moof_clone = NULL;\n\t\t\tgf_isom_box_freeze_order((GF_Box *)moof_box);\n\t\t\tgf_isom_clone_box((GF_Box *)moof_box, (GF_Box **)&moof_clone);\n\n\t\t\tif (moof_clone) {\n\t\t\t\tGF_BitStream *bs;\n\t\t\t\tfor (i=0; i<gf_list_count(moof_clone->TrackList); i++) {\n\t\t\t\t\tGF_TrackFragmentBox *traf_clone = gf_list_get(moof_clone->TrackList, i);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->TrackRuns);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroups);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroupsDescription);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sub_samples);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_offsets);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_sizes);\n\t\t\t\t\tif (traf_clone->sample_encryption) {\n\t\t\t\t\t\tgf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sample_encryption);\n\t\t\t\t\t\ttraf_clone->sample_encryption = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (traf_clone->sdtp) {\n\t\t\t\t\t\tgf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sdtp);\n\t\t\t\t\t\ttraf_clone->sdtp = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_isom_box_size((GF_Box *)moof_clone);\n\t\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\tif (trak->moov->mov->seg_styp) {\n\t\t\t\t\tgf_isom_box_size(trak->moov->mov->seg_styp);\n\t\t\t\t\tgf_isom_box_write(trak->moov->mov->seg_styp, bs);\n\t\t\t\t}\n\t\t\t\tif (trak->moov->mov->root_sidx) {\n\t\t\t\t\tgf_isom_box_size((GF_Box *)trak->moov->mov->root_sidx);\n\t\t\t\t\tgf_isom_box_write((GF_Box *)trak->moov->mov->root_sidx, bs);\n\t\t\t\t}\n\t\t\t\tif (trak->moov->mov->seg_ssix) {\n\t\t\t\t\tgf_isom_box_size(trak->moov->mov->seg_ssix);\n\t\t\t\t\tgf_isom_box_write(trak->moov->mov->seg_ssix, bs);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_write((GF_Box *)moof_clone, bs);\n\t\t\t\tgf_isom_box_del((GF_Box*)moof_clone);\n\n\t\t\t\tgf_bs_get_content(bs, &moof_template, &moof_template_size);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t}\n\t\t}\n\t\tif (trak->moov->mov->seg_styp) {\n\t\t\tis_seg_start = GF_TRUE;\n\t\t\tseg_start = trak->moov->mov->styp_start_offset;\n\t\t}\n\t\tif (trak->moov->mov->root_sidx) {\n\t\t\tis_seg_start = GF_TRUE;\n\t\t\tsidx_start = trak->moov->mov->sidx_start_offset;\n\t\t\tsidx_end = trak->moov->mov->sidx_end_offset;\n\t\t\tif (! seg_start || (sidx_start<seg_start))\n\t\t\t\tseg_start = sidx_start;\n\t\t}\n\t\tfrag_start = trak->moov->mov->current_top_box_start;\n\t}\n\telse if (trak->moov->mov->store_traf_map) {\n\t\tstore_traf_map = GF_TRUE;\n\t}\n\n\n\tsample_index = 0;\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) {\n\t\t//merge the run\n\t\tfor (j=0; j<trun->sample_count; j++) {\n\t\t\tGF_Err e;\n\t\t\ts32 cts_offset=0;\n\t\t\tif (j<trun->nb_samples) {\n\t\t\t\tent = &trun->samples[j];\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d doesn't have enough trun entries (%d) compared to sample count (%d) in run\\n\", traf->trex->trackID, trun->nb_samples, trun->sample_count ));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsize = def_size;\n\t\t\tduration = def_duration;\n\t\t\tflags = def_flags;\n\n\t\t\t//CTS - if flag not set (trun or ctrn) defaults to 0 which is the base value after alloc\n\t\t\t//we just need to overrite its value if inherited\n\t\t\tcts_offset = ent->CTS_Offset;\n\n#ifdef GF_ENABLE_CTRN\n\t\t\tif (trun->use_ctrn) {\n\t\t\t\tif (!j && (trun->ctrn_flags & GF_ISOM_CTRN_FIRST_SAMPLE) ) {\n\t\t\t\t\tif (trun->ctrn_first_dur) duration = ent->Duration;\n\t\t\t\t\tif (trun->ctrn_first_size) size = ent->size;\n\t\t\t\t\tif (trun->ctrn_first_ctts) flags = ent->flags;\n\t\t\t\t} else {\n\t\t\t\t\tif (trun->ctrn_dur) duration = ent->Duration;\n\t\t\t\t\tif (trun->ctrn_size) size = ent->size;\n\t\t\t\t\tif (trun->ctrn_sample_flags) flags = ent->flags;\n\t\t\t\t}\n\t\t\t\t/*re-override*/\n\t\t\t\tif (trun->ctrn_flags & 0xF0) {\n\t\t\t\t\tGF_TrunEntry *ref_entry;\n\t\t\t\t\tif (!traf_ref) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d use traf inheritance to track ID %d but reference traf not found\\n\", traf->trex->trackID, traf->trex->inherit_from_traf_id ));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tref_entry = traf_get_sample_entry(traf_ref, sample_index);\n\t\t\t\t\tif (!ref_entry) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d use traf inheritance but sample %d not found in reference traf\\n\", traf->trex->trackID, sample_index+1 ));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_DUR)\n\t\t\t\t\t\tduration = ref_entry->Duration;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_SIZE)\n\t\t\t\t\t\tsize = ref_entry->size;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_FLAGS)\n\t\t\t\t\t\tflags = ref_entry->flags;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_CTSO)\n\t\t\t\t\t\tcts_offset = ref_entry->CTS_Offset;\n\t\t\t\t}\n\n\t\t\t} else\n#endif\n\t\t\t{\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DURATION) duration = ent->Duration;\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_SIZE) size = ent->size;\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\t\t\tflags = ent->flags;\n\t\t\t\t} else if (!j && (trun->flags & GF_ISOM_TRUN_FIRST_FLAG)) {\n\t\t\t\t\tflags = trun->first_sample_flags;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsample_index++;\n\t\t\t/*store the resolved value in case we have inheritance*/\n\t\t\tent->size = size;\n\t\t\tent->Duration = duration;\n\t\t\tent->flags = flags;\n\t\t\tent->CTS_Offset = cts_offset;\n\n\t\t\tlast_dts += duration;\n\n\t\t\t//add size first\n\t\t\tif (!trak->Media->information->sampleTable->SampleSize) {\n\t\t\t\ttrak->Media->information->sampleTable->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSZ);\n\t\t\t\tif (!trak->Media->information->sampleTable->SampleSize)\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\te = stbl_AppendSize(trak->Media->information->sampleTable, size, ent->nb_pack);\n\t\t\tif (e) return e;\n\n\t\t\t//then TS\n\t\t\tif (!trak->Media->information->sampleTable->TimeToSample) {\n\t\t\t\ttrak->Media->information->sampleTable->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STTS);\n\t\t\t\tif (!trak->Media->information->sampleTable->TimeToSample)\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\te = stbl_AppendTime(trak->Media->information->sampleTable, duration, ent->nb_pack);\n\t\t\tif (e) return e;\n\n\t\t\t//add chunk on first sample\n\t\t\tif (!j) {\n\t\t\t\tu64 final_offset;\n\t\t\t\tdata_offset = base_offset;\n\t\t\t\t//we have an explicit data offset for this trun\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\t\t\t\tdata_offset += trun->data_offset;\n\t\t\t\t\t/*reset chunk size since data is now relative to this trun*/\n\t\t\t\t\tchunk_size = 0;\n\t\t\t\t\t/*remember this data offset for following trun*/\n\t\t\t\t\tprev_trun_data_offset = trun->data_offset;\n\t\t\t\t\t/*if mdat is located after the moof, and the moof was compressed, adjust offset\n\t\t\t\t\totherwise the offset does not need adjustment*/\n\t\t\t\t\tif (trun->data_offset>=0) {\n\t\t\t\t\t\tdata_offset -= compressed_diff;\n\t\t\t\t\t\tprev_trun_data_offset -= compressed_diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//we had an explicit data offset for the previous trun, use it + chunk size\n\t\t\t\telse if (prev_trun_data_offset) {\n\t\t\t\t\t/*data offset is previous chunk size plus previous offset of the trun*/\n\t\t\t\t\tdata_offset += prev_trun_data_offset + chunk_size;\n\t\t\t\t}\n\t\t\t\t//no explicit data offset, continuous data after last data in previous chunk\n\t\t\t\telse {\n\t\t\t\t\tdata_offset += chunk_size;\n\t\t\t\t\t//data offset of first trun in first traf, adjust if compressed moof\n\t\t\t\t\tif ((i==1) && (trun->data_offset>=0)) {\n\t\t\t\t\t\tdata_offset -= compressed_diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfinal_offset = data_offset;\n\t\t\t\t//adjust offset if moov was also compressed and we are still in the same file\n\t\t\t\t//so that later call to gf_isom_get_sample properly adjust back the offset\n\t\t\t\tif (trak->moov->compressed_diff) {\n\t\t\t\t\tfinal_offset += trak->moov->compressed_diff;\n\t\t\t\t}\n\n\t\t\t\tif (!trak->Media->information->sampleTable->ChunkOffset) {\n\t\t\t\t\ttrak->Media->information->sampleTable->ChunkOffset = gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STCO);\n\t\t\t\t\tif (!trak->Media->information->sampleTable->ChunkOffset)\n\t\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\te = stbl_AppendChunk(trak->Media->information->sampleTable, final_offset);\n\t\t\t\tif (e) return e;\n\t\t\t\t//then sampleToChunk\n\t\t\t\tif (!trak->Media->information->sampleTable->SampleToChunk) {\n\t\t\t\t\ttrak->Media->information->sampleTable->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSC);\n\t\t\t\t\tif (!trak->Media->information->sampleTable->SampleToChunk)\n\t\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\te = stbl_AppendSampleToChunk(trak->Media->information->sampleTable,\n\t\t\t\t                         DescIndex, trun->sample_count);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\tchunk_size += size;\n\n\t\t\tif (store_traf_map && first_samp_in_traf) {\n\t\t\t\tfirst_samp_in_traf = GF_FALSE;\n\t\t\t\te = stbl_AppendTrafMap(trak->Media->information->sampleTable, is_seg_start, seg_start, frag_start, moof_template, moof_template_size, sidx_start, sidx_end);\n\t\t\t\tif (e) return e;\n\t\t\t\t//do not deallocate, the memory is now owned by traf map\n\t\t\t\tmoof_template = NULL;\n\t\t\t\tmoof_template_size = 0;\n\t\t\t}\n\t\t\tif (ent->nb_pack>1) {\n\t\t\t\tj+= ent->nb_pack-1;\n\t\t\t\ttraf_duration += ent->nb_pack*duration;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttraf_duration += duration;\n\n\t\t\te = stbl_AppendCTSOffset(trak->Media->information->sampleTable, cts_offset);\n\t\t\tif (e) return e;\n\t\t\t//flags\n\t\t\tsync = GF_ISOM_GET_FRAG_SYNC(flags);\n\t\t\tif (trak->Media->information->sampleTable->no_sync_found && sync) {\n\t\t\t\ttrak->Media->information->sampleTable->no_sync_found = 0;\n\t\t\t}\n\t\t\te = stbl_AppendRAP(trak->Media->information->sampleTable, sync);\n\t\t\tif (e) return e;\n\t\t\tpad = GF_ISOM_GET_FRAG_PAD(flags);\n\t\t\tif (pad) {\n\t\t\t\te = stbl_AppendPadding(trak->Media->information->sampleTable, pad);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\tdegr = GF_ISOM_GET_FRAG_DEG(flags);\n\t\t\tif (degr) {\n\t\t\t\te = stbl_AppendDegradation(trak->Media->information->sampleTable, degr);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\te = stbl_AppendDependencyType(trak->Media->information->sampleTable, GF_ISOM_GET_FRAG_LEAD(flags), GF_ISOM_GET_FRAG_DEPENDS(flags), GF_ISOM_GET_FRAG_DEPENDED(flags), GF_ISOM_GET_FRAG_REDUNDANT(flags));\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\n\tif (trak->moov->mov->is_smooth && !traf->tfdt && !traf->tfxd) {\n\t\tif (is_first_merge)\n\t\t\ttrak->dts_at_seg_start = trak->dts_at_next_seg_start;\n\t\ttrak->dts_at_next_seg_start += last_dts;\n\t}\n\tif (traf_duration && trak->editBox && trak->editBox->editList) {\n\t\tfor (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) {\n\t\t\tGF_EdtsEntry *edts_e = gf_list_get(trak->editBox->editList->entryList, i);\n\t\t\tif (edts_e->was_empty_dur) {\n\t\t\t\tu64 extend_dur = traf_duration;\n\t\t\t\textend_dur *= trak->moov->mvhd->timeScale;\n\t\t\t\textend_dur /= trak->Media->mediaHeader->timeScale;\n\t\t\t\tedts_e->segmentDuration += extend_dur;\n\t\t\t}\n\t\t\telse if (!edts_e->segmentDuration) {\n\t\t\t\tedts_e->was_empty_dur = GF_TRUE;\n\t\t\t\tif ((s64) traf_duration > edts_e->mediaTime)\n\t\t\t\t\ttraf_duration -= edts_e->mediaTime;\n\t\t\t\telse\n\t\t\t\t\ttraf_duration = 0;\n\n\t\t\t\tedts_e->segmentDuration = traf_duration;\n\t\t\t\tedts_e->segmentDuration *= trak->moov->mvhd->timeScale;\n\t\t\t\tedts_e->segmentDuration /= trak->Media->mediaHeader->timeScale;\n\t\t\t}\n\n\t\t}\n\t}\n\n\t//in any case, update the cumulated offset\n\t//this will handle hypothetical files mixing MOOF offset and implicit non-moof offset\n\t*cumulated_offset = data_offset + chunk_size;\n\n\t/*merge sample groups*/\n\tif (traf->sampleGroups) {\n\t\tGF_List *groups;\n\t\tGF_List *groupDescs;\n\t\tBool is_identical_sgpd = GF_TRUE;\n\t\tu32 *new_idx = NULL, new_idx_count=0;\n\n\t\tif (!trak->Media->information->sampleTable->sampleGroups)\n\t\t\ttrak->Media->information->sampleTable->sampleGroups = gf_list_new();\n\n\t\tif (!trak->Media->information->sampleTable->sampleGroupsDescription)\n\t\t\ttrak->Media->information->sampleTable->sampleGroupsDescription = gf_list_new();\n\n\t\tgroupDescs = trak->Media->information->sampleTable->sampleGroupsDescription;\n\t\tfor (i=0; i<gf_list_count(traf->sampleGroupsDescription); i++) {\n\t\t\tGF_SampleGroupDescriptionBox *new_sgdesc = NULL;\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = gf_list_get(traf->sampleGroupsDescription, i);\n\t\t\tfor (j=0; j<gf_list_count(groupDescs); j++) {\n\t\t\t\tnew_sgdesc = gf_list_get(groupDescs, j);\n\t\t\t\tif (new_sgdesc->grouping_type==sgdesc->grouping_type) break;\n\t\t\t\tnew_sgdesc = NULL;\n\t\t\t}\n\t\t\t/*new description, move it to our sample table*/\n\t\t\tif (!new_sgdesc) {\n\t\t\t\tgf_list_add(groupDescs, sgdesc);\n\t\t\t\tgf_list_add(trak->Media->information->sampleTable->child_boxes, sgdesc);\n\t\t\t\tgf_list_rem(traf->sampleGroupsDescription, i);\n\t\t\t\tgf_list_del_item(traf->child_boxes, sgdesc);\n\t\t\t\ti--;\n\t\t\t}\n\t\t\t/*merge descriptions*/\n\t\t\telse {\n\t\t\t\tu32 count;\n\n\t\t\t\tis_identical_sgpd = gf_isom_is_identical_sgpd(new_sgdesc, sgdesc, 0);\n\t\t\t\tif (is_identical_sgpd)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tnew_idx_count = gf_list_count(sgdesc->group_descriptions);\n\t\t\t\tnew_idx = (u32 *)gf_malloc(new_idx_count * sizeof(u32));\n\t\t\t\tif (!new_idx) return GF_OUT_OF_MEM;\n\n\t\t\t\tcount = 0;\n\t\t\t\twhile (gf_list_count(sgdesc->group_descriptions)) {\n\t\t\t\t\tvoid *sgpd_entry = gf_list_get(sgdesc->group_descriptions, 0);\n\t\t\t\t\tBool new_entry = GF_TRUE;\n\n\t\t\t\t\tfor (j = 0; j < gf_list_count(new_sgdesc->group_descriptions); j++) {\n\t\t\t\t\t\tvoid *ptr = gf_list_get(new_sgdesc->group_descriptions, j);\n\t\t\t\t\t\tif (gf_isom_is_identical_sgpd(sgpd_entry, ptr, new_sgdesc->grouping_type)) {\n\t\t\t\t\t\t\tnew_idx[count] = j + 1;\n\t\t\t\t\t\t\tcount ++;\n\t\t\t\t\t\t\tnew_entry = GF_FALSE;\n\t\t\t\t\t\t\tgf_free(sgpd_entry);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (new_entry) {\n\t\t\t\t\t\tgf_list_add(new_sgdesc->group_descriptions, sgpd_entry);\n\t\t\t\t\t\tnew_idx[count] = gf_list_count(new_sgdesc->group_descriptions);\n\t\t\t\t\t\tcount ++;\n\t\t\t\t\t}\n\n\t\t\t\t\tgf_list_rem(sgdesc->group_descriptions, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgroups = trak->Media->information->sampleTable->sampleGroups;\n\t\tfor (i=0; i<gf_list_count(traf->sampleGroups); i++) {\n\t\t\tGF_SampleGroupBox *stbl_group = NULL;\n\t\t\tGF_SampleGroupBox *frag_group = gf_list_get(traf->sampleGroups, i);\n\n\n\t\t\tfor (j=0; j<gf_list_count(groups); j++) {\n\t\t\t\tstbl_group = gf_list_get(groups, j);\n\t\t\t\tif ((frag_group->grouping_type==stbl_group->grouping_type) && (frag_group->grouping_type_parameter==stbl_group->grouping_type_parameter))\n\t\t\t\t\tbreak;\n\t\t\t\tstbl_group = NULL;\n\t\t\t}\n\t\t\tif (!stbl_group) {\n\t\t\t\tstbl_group = (GF_SampleGroupBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SBGP);\n\t\t\t\tif (!stbl_group) return GF_OUT_OF_MEM;\n\t\t\t\tstbl_group->grouping_type = frag_group->grouping_type;\n\t\t\t\tstbl_group->grouping_type_parameter = frag_group->grouping_type_parameter;\n\t\t\t\tstbl_group->version = frag_group->version;\n\t\t\t\tgf_list_add(groups, stbl_group);\n\t\t\t}\n\n\t\t\tif (is_identical_sgpd) {\n\t\t\t\t//adjust sgpd index: in traf index start at 0x1001\n\t\t\t\tfor (j = 0; j < frag_group->entry_count; j++)\n\t\t\t\t\tfrag_group->sample_entries[j].group_description_index &= 0x0FFFF;\n\t\t\t\tif (frag_group->entry_count && stbl_group->entry_count &&\n\t\t\t\t        (frag_group->sample_entries[0].group_description_index==stbl_group->sample_entries[stbl_group->entry_count-1].group_description_index)\n\t\t\t\t   ) {\n\t\t\t\t\tstbl_group->sample_entries[stbl_group->entry_count - 1].sample_count += frag_group->sample_entries[0].sample_count;\n\t\t\t\t\tif (frag_group->entry_count>1) {\n\t\t\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count - 1));\n\t\t\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[1], sizeof(GF_SampleGroupEntry) * (frag_group->entry_count - 1));\n\t\t\t\t\t\tstbl_group->entry_count += frag_group->entry_count - 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count));\n\t\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count);\n\t\t\t\t\tstbl_group->entry_count += frag_group->entry_count;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count));\n\t\t\t\t//adjust sgpd index\n\t\t\t\tfor (j = 0; j < frag_group->entry_count; j++) {\n\t\t\t\t\tu32 sgidx = frag_group->sample_entries[j].group_description_index;\n\t\t\t\t\tif (sgidx > 0x10000) {\n\t\t\t\t\t\tsgidx -= 0x10001;\n\t\t\t\t\t\tif (sgidx>=new_idx_count) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isobmf] corrupted sample group index in fragment %d but only %d group descriptions in fragment\\n\", sgidx, new_idx_count));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfrag_group->sample_entries[j].group_description_index = new_idx[sgidx];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count);\n\t\t\t\tstbl_group->entry_count += frag_group->entry_count;\n\t\t\t}\n\t\t}\n\n\t\tif (new_idx) gf_free(new_idx);\n\t}\n\n\t/*content is encrypted*/\n\ttrack_num = gf_isom_get_tracknum_from_id(trak->moov, trak->Header->trackID);\n\tif (gf_isom_is_cenc_media(trak->moov->mov, track_num, DescIndex)\n\t\t|| traf->sample_encryption) {\n\t\t/*Merge sample auxiliary encryption information*/\n\t\tGF_SampleEncryptionBox *senc = NULL;\n\t\tu32 scheme_type;\n\t\tgf_isom_get_cenc_info(trak->moov->mov, track_num, DescIndex, NULL, &scheme_type, NULL);\n\n\t\tif (traf->sample_encryption) {\n\t\t\tfor (i = 0; i < gf_list_count(trak->Media->information->sampleTable->child_boxes); i++) {\n\t\t\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->child_boxes, i);\n\t\t\t\tif (a->type != traf->sample_encryption->type) continue;\n\n\t\t\t\tif ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)a;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (a->type ==GF_ISOM_BOX_TYPE_SENC) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)a;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!senc && trak->sample_encryption)\n\t\t\t\tsenc = trak->sample_encryption;\n\n\t\t\tif (!senc) {\n\t\t\t\tif (traf->sample_encryption->piff_type==1) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)gf_isom_create_piff_psec_box(1, 0x2, 0, 0, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tsenc = gf_isom_create_samp_enc_box(1, 0x2);\n\t\t\t\t}\n\n\t\t\t\tif (!trak->Media->information->sampleTable->child_boxes) trak->Media->information->sampleTable->child_boxes = gf_list_new();\n\n\t\t\t\ttrak->sample_encryption = senc;\n\t\t\t\tif (!trak->child_boxes) trak->child_boxes = gf_list_new();\n\t\t\t\tgf_list_add(trak->child_boxes, senc);\n\t\t\t}\n\t\t}\n\n\t\t/*get sample auxiliary information by saiz/saio rather than by parsing senc box*/\n\t\tif (gf_isom_cenc_has_saiz_saio_traf(traf, scheme_type)) {\n\t\t\tu32 nb_saio;\n\t\t\tu32 aux_info_type;\n\t\t\tu64 offset;\n\t\t\tGF_Err e;\n\t\t\tBool is_encrypted;\n\t\t\tGF_SampleAuxiliaryInfoOffsetBox *saio = NULL;\n\t\t\tGF_SampleAuxiliaryInfoSizeBox *saiz = NULL;\n\n\t\t\toffset = nb_saio = 0;\n\n\t\t\tfor (i = 0; i < gf_list_count(traf->sai_offsets); i++) {\n\t\t\t\tsaio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(traf->sai_offsets, i);\n\t\t\t\taux_info_type = saio->aux_info_type;\n\t\t\t\tif (!aux_info_type) aux_info_type = scheme_type;\n\n\t\t\t\t/*if we have only 1 sai_offsets, assume that its type is cenc*/\n\t\t\t\tif ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) ||\n\t\t\t\t\t(aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) ||\n\t\t\t\t\t(gf_list_count(traf->sai_offsets) == 1)) {\n\t\t\t\t\tif (saio->offsets && saio->entry_count) {\n\t\t\t\t\t\toffset = saio->offsets[0] + moof_offset;\n\t\t\t\t\t\tnb_saio = saio->entry_count;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsaio = NULL;\n\t\t\t}\n\t\t\tfor (i = 0; i < gf_list_count(traf->sai_sizes); i++) {\n\t\t\t\tsaiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(traf->sai_sizes, i);\n\t\t\t\taux_info_type = saiz->aux_info_type;\n\t\t\t\tif (!aux_info_type) aux_info_type = scheme_type;\n\t\t\t\t/*if we have only 1 sai_sizes, assume that its type is cenc*/\n\t\t\t\tif ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) ||\n\t\t\t\t\t(aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) ||\n\t\t\t\t\t(gf_list_count(traf->sai_sizes) == 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsaiz = NULL;\n\t\t\t}\n\t\t\tif (saiz && saio && senc) {\n\t\t\t\tfor (i = 0; i < saiz->sample_count; i++) {\n\t\t\t\t\tGF_CENCSampleAuxInfo *sai;\n\t\t\t\t\tconst u8 *key_info=NULL;\n\t\t\t\t\tu32 key_info_size;\n\t\t\t\t\tu64 cur_position;\n\t\t\t\t\tif (nb_saio != 1)\n\t\t\t\t\t\toffset = saio->offsets[i] + moof_offset;\n\t\t\t\t\tsize = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[i];\n\n\t\t\t\t\tcur_position = gf_bs_get_position(trak->moov->mov->movieFileMap->bs);\n\t\t\t\t\tgf_bs_seek(trak->moov->mov->movieFileMap->bs, offset);\n\n\t\t\t\t\tGF_SAFEALLOC(sai, GF_CENCSampleAuxInfo);\n\t\t\t\t\tif (!sai) return GF_OUT_OF_MEM;\n\n\t\t\t\t\te = gf_isom_get_sample_cenc_info_internal(trak, traf, senc, i+1, &is_encrypted, NULL, NULL, &key_info, &key_info_size);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isobmf] could not get cenc info for sample %d: %s\\n\", i+1, gf_error_to_string(e) ));\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (is_encrypted) {\n\t\t\t\t\t\tsai->cenc_data_size = size;\n\t\t\t\t\t\tsai->cenc_data = gf_malloc(sizeof(u8)*size);\n\t\t\t\t\t\tif (!sai->cenc_data) return GF_OUT_OF_MEM;\n\t\t\t\t\t\tgf_bs_read_data(trak->moov->mov->movieFileMap->bs, sai->cenc_data, sai->cenc_data_size);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsai->isNotProtected=1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (key_info) {\n\t\t\t\t\t\t//not multikey\n\t\t\t\t\t\tif (!key_info[0]) {\n\t\t\t\t\t\t\t//size greater than IV\n\t\t\t\t\t\t\tif (size > key_info[3])\n\t\t\t\t\t\t\t\tsenc->flags = 0x00000002;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//multikey, always use subsamples\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tsenc->flags = 0x00000002;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t\tgf_bs_seek(trak->moov->mov->movieFileMap->bs, cur_position);\n\n\t\t\t\t\tgf_list_add(senc->samp_aux_info, sai);\n\n\t\t\t\t\te = gf_isom_cenc_merge_saiz_saio(senc, trak->Media->information->sampleTable, offset, size);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\tif (nb_saio == 1)\n\t\t\t\t\t\toffset += size;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (traf->sample_encryption) {\n\t\t\tsenc_Parse(trak->moov->mov->movieFileMap->bs, trak, traf, traf->sample_encryption);\n\t\t\ttrak->sample_encryption->AlgorithmID = traf->sample_encryption->AlgorithmID;\n\t\t\tif (!trak->sample_encryption->IV_size)\n\t\t\t\ttrak->sample_encryption->IV_size = traf->sample_encryption->IV_size;\n\t\t\tif (!trak->sample_encryption->samp_aux_info) trak->sample_encryption->samp_aux_info = gf_list_new();\n\t\t\tgf_list_transfer(trak->sample_encryption->samp_aux_info, traf->sample_encryption->samp_aux_info);\n\t\t\tif (traf->sample_encryption->flags & 0x00000002)\n\t\t\t\ttrak->sample_encryption->flags |= 0x00000002;\n\t\t}\n\t}\n\treturn GF_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148137,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteConcatenationParams*>(node->builtin_data);\n  int axis = params->axis;\n  int num_inputs = node->inputs->size;\n\n  // The number of dimensions of the input tensors must match, and all\n  // dimensions except 'axis' must be equal.\n  const TfLiteTensor* t0;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &t0));\n  TfLiteType input_type = t0->type;\n  if (axis < 0) axis += t0->dims->size;\n  TF_LITE_ENSURE(context, axis >= 0);\n  TF_LITE_ENSURE(context, axis < t0->dims->size);\n\n  TF_LITE_ENSURE_EQ(context, params->activation, kTfLiteActNone);\n  TF_LITE_ENSURE(context,\n                 input_type == kTfLiteFloat32 || input_type == kTfLiteUInt8 ||\n                     input_type == kTfLiteInt8 || input_type == kTfLiteInt16 ||\n                     input_type == kTfLiteInt32 || input_type == kTfLiteInt64 ||\n                     input_type == kTfLiteBool);\n\n  // Output dimensions will match input dimensions, except 'axis', which\n  // will be the sum of inputs\n  int sum_axis = t0->dims->data[axis];\n  for (int i = 1; i < num_inputs; ++i) {\n    const TfLiteTensor* t;\n    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i, &t));\n    TF_LITE_ENSURE_EQ(context, t->dims->size, t0->dims->size);\n    TF_LITE_ENSURE_EQ(context, t->type, input_type);\n    for (int d = 0; d < t0->dims->size; ++d) {\n      if (d == axis) {\n        sum_axis += t->dims->data[axis];\n      } else {\n        TF_LITE_ENSURE_EQ(context, t->dims->data[d], t0->dims->data[d]);\n      }\n    }\n  }\n\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(t0->dims->size);\n  for (int d = 0; d < t0->dims->size; ++d) {\n    output_size->data[d] = (d == axis) ? sum_axis : t0->dims->data[d];\n  }\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TF_LITE_ENSURE_TYPES_EQ(context, output->type, input_type);\n\n  if (input_type == kTfLiteInt8) {\n    // Make sure there is no re-scaling needed for Int8 quantized kernel. This\n    // is a restriction we introduced to Int8 kernels.\n    VectorOfTensors<int8_t> all_inputs(*context, *node->inputs);\n    for (int i = 0; i < node->inputs->size; ++i) {\n      const TfLiteTensor* t;\n      TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i, &t));\n      TF_LITE_ENSURE_EQ(context, t->params.scale, output->params.scale);\n      TF_LITE_ENSURE_EQ(context, t->params.zero_point,\n                        output->params.zero_point);\n    }\n  }\n\n  if (input_type == kTfLiteInt16) {\n    // Make sure that all Int16 inputs have a null zero-point.\n    for (int i = 0; i < node->inputs->size; ++i) {\n      const TfLiteTensor* t = GetInput(context, node, i);\n      TF_LITE_ENSURE_EQ(context, t->params.zero_point, 0);\n    }\n    TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);\n  }\n\n  return context->ResizeTensor(context, output, output_size);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148138,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteConcatenationParams*>(node->builtin_data);\n  int axis = params->axis;\n  int num_inputs = node->inputs->size;\n\n  // The number of dimensions of the input tensors must match, and all\n  // dimensions except 'axis' must be equal.\n  const TfLiteTensor* t0;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &t0));\n  TfLiteType input_type = t0->type;\n  if (axis < 0) axis += t0->dims->size;\n  TF_LITE_ENSURE(context, axis >= 0);\n  TF_LITE_ENSURE(context, axis < t0->dims->size);\n\n  TF_LITE_ENSURE_EQ(context, params->activation, kTfLiteActNone);\n  TF_LITE_ENSURE(context,\n                 input_type == kTfLiteFloat32 || input_type == kTfLiteUInt8 ||\n                     input_type == kTfLiteInt8 || input_type == kTfLiteInt16 ||\n                     input_type == kTfLiteInt32 || input_type == kTfLiteInt64 ||\n                     input_type == kTfLiteBool);\n\n  // Output dimensions will match input dimensions, except 'axis', which\n  // will be the sum of inputs\n  int sum_axis = t0->dims->data[axis];\n  for (int i = 1; i < num_inputs; ++i) {\n    const TfLiteTensor* t;\n    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i, &t));\n    TF_LITE_ENSURE_EQ(context, t->dims->size, t0->dims->size);\n    TF_LITE_ENSURE_EQ(context, t->type, input_type);\n    for (int d = 0; d < t0->dims->size; ++d) {\n      if (d == axis) {\n        // Avoid integer overflow in sum_axis below\n        TF_LITE_ENSURE(context, t->dims->data[axis] >= 0);\n        TF_LITE_ENSURE(context, t->dims->data[axis] <=\n                                    std::numeric_limits<int>::max() - sum_axis);\n        sum_axis += t->dims->data[axis];\n      } else {\n        TF_LITE_ENSURE_EQ(context, t->dims->data[d], t0->dims->data[d]);\n      }\n    }\n  }\n\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(t0->dims->size);\n  for (int d = 0; d < t0->dims->size; ++d) {\n    output_size->data[d] = (d == axis) ? sum_axis : t0->dims->data[d];\n  }\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TF_LITE_ENSURE_TYPES_EQ(context, output->type, input_type);\n\n  if (input_type == kTfLiteInt8) {\n    // Make sure there is no re-scaling needed for Int8 quantized kernel. This\n    // is a restriction we introduced to Int8 kernels.\n    VectorOfTensors<int8_t> all_inputs(*context, *node->inputs);\n    for (int i = 0; i < node->inputs->size; ++i) {\n      const TfLiteTensor* t;\n      TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i, &t));\n      TF_LITE_ENSURE_EQ(context, t->params.scale, output->params.scale);\n      TF_LITE_ENSURE_EQ(context, t->params.zero_point,\n                        output->params.zero_point);\n    }\n  }\n\n  if (input_type == kTfLiteInt16) {\n    // Make sure that all Int16 inputs have a null zero-point.\n    for (int i = 0; i < node->inputs->size; ++i) {\n      const TfLiteTensor* t = GetInput(context, node, i);\n      TF_LITE_ENSURE_EQ(context, t->params.zero_point, 0);\n    }\n    TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);\n  }\n\n  return context->ResizeTensor(context, output, output_size);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148139,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void gf_isom_cenc_get_default_info_internal(GF_TrackBox *trak, u32 sampleDescriptionIndex, u32 *container_type, Bool *default_IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n{\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\n\t//setup all default as not encrypted\n\tif (default_IsEncrypted) *default_IsEncrypted = GF_FALSE;\n\tif (crypt_byte_block) *crypt_byte_block = 0;\n\tif (skip_byte_block) *skip_byte_block = 0;\n\tif (container_type) *container_type = 0;\n\tif (key_info) *key_info = NULL;\n\tif (key_info_size) *key_info_size = 0;\n\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENC_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBC_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENS_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBCS_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_PIFF_SCHEME, NULL);\n\n\tif (!sinf) {\n\t\tu32 i, nb_stsd = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\t\tfor (i=0; i<nb_stsd; i++) {\n\t\t\tGF_ProtectionSchemeInfoBox *a_sinf;\n\t\t\tGF_SampleEntryBox *sentry=NULL;\n\t\t\tif (i+1==sampleDescriptionIndex) continue;\n\t\t\tsentry = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\t\ta_sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(sentry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\t\tif (!a_sinf) continue;\n\t\t\t//signal default (not encrypted)\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (sinf && sinf->info && sinf->info->tenc) {\n\t\tif (default_IsEncrypted) *default_IsEncrypted = sinf->info->tenc->isProtected;\n\t\tif (crypt_byte_block) *crypt_byte_block = sinf->info->tenc->crypt_byte_block;\n\t\tif (skip_byte_block) *skip_byte_block = sinf->info->tenc->skip_byte_block;\n\t\tif (key_info) *key_info = sinf->info->tenc->key_info;\n\t\tif (key_info_size) {\n\t\t\t*key_info_size = 20;\n\t\t\tif (!sinf->info->tenc->key_info[3])\n\t\t\t\t*key_info_size += 1 + sinf->info->tenc->key_info[20];\n\t\t}\n\n\t\t//set default value, overwritten below\n\t\tif (container_type) *container_type = GF_ISOM_BOX_TYPE_SENC;\n\t} else if (sinf && sinf->info && sinf->info->piff_tenc) {\n\t\tif (default_IsEncrypted) *default_IsEncrypted = GF_TRUE;\n\t\tif (key_info) *key_info = sinf->info->piff_tenc->key_info;\n\t\tif (key_info_size) *key_info_size = 19;\n\t\t//set default value, overwritten below\n\t\tif (container_type) *container_type = GF_ISOM_BOX_UUID_PSEC;\n\t} else {\n\t\tu32 i, count = 0;\n\t\tGF_CENCSampleEncryptionGroupEntry *seig_entry = NULL;\n\n\t\tif (!trak->moov->mov->is_smooth)\n\t\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\tif (sgdesc->grouping_type!=GF_ISOM_SAMPLE_GROUP_SEIG) continue;\n\t\t\tif (sgdesc->default_description_index)\n\t\t\t\tseig_entry = gf_list_get(sgdesc->group_descriptions, sgdesc->default_description_index-1);\n\t\t\telse\n\t\t\t\tseig_entry = gf_list_get(sgdesc->group_descriptions, 0);\n\t\t\tif (!seig_entry->key_info[0])\n\t\t\t\tseig_entry = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (seig_entry) {\n\t\t\tif (default_IsEncrypted) *default_IsEncrypted = seig_entry->IsProtected;\n\t\t\tif (crypt_byte_block) *crypt_byte_block = seig_entry->crypt_byte_block;\n\t\t\tif (skip_byte_block) *skip_byte_block = seig_entry->skip_byte_block;\n\t\t\tif (key_info) *key_info = seig_entry->key_info;\n\t\t\tif (key_info_size) *key_info_size = seig_entry->key_info_size;\n\t\t\tif (container_type) *container_type = GF_ISOM_BOX_TYPE_SENC;\n\t\t} else {\n\t\t\tif (! trak->moov->mov->is_smooth ) {\n\t\t\t\ttrak->moov->mov->is_smooth = GF_TRUE;\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] senc box without tenc, assuming MS smooth+piff\\n\"));\n\t\t\t}\n\t\t\tif (default_IsEncrypted) *default_IsEncrypted = GF_TRUE;\n\t\t\t//set default value, overwritten below\n\t\t\tif (container_type) *container_type = GF_ISOM_BOX_UUID_PSEC;\n\t\t}\n\t}\n\n\tif (container_type && trak->sample_encryption) {\n\t\tif (trak->sample_encryption->type == GF_ISOM_BOX_TYPE_SENC) *container_type = GF_ISOM_BOX_TYPE_SENC;\n\t\telse if (trak->sample_encryption->type == GF_ISOM_BOX_TYPE_UUID) *container_type = ((GF_UUIDBox*)trak->sample_encryption)->internal_4cc;\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148158,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void gf_isom_cenc_get_default_info_internal(GF_TrackBox *trak, u32 sampleDescriptionIndex, u32 *container_type, Bool *default_IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n{\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\n\t//setup all default as not encrypted\n\tif (default_IsEncrypted) *default_IsEncrypted = GF_FALSE;\n\tif (crypt_byte_block) *crypt_byte_block = 0;\n\tif (skip_byte_block) *skip_byte_block = 0;\n\tif (container_type) *container_type = 0;\n\tif (key_info) *key_info = NULL;\n\tif (key_info_size) *key_info_size = 0;\n\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENC_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBC_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENS_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBCS_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_PIFF_SCHEME, NULL);\n\n\tif (!sinf) {\n\t\tu32 i, nb_stsd = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\t\tfor (i=0; i<nb_stsd; i++) {\n\t\t\tGF_ProtectionSchemeInfoBox *a_sinf;\n\t\t\tGF_SampleEntryBox *sentry=NULL;\n\t\t\tif (i+1==sampleDescriptionIndex) continue;\n\t\t\tsentry = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\t\ta_sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(sentry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\t\tif (!a_sinf) continue;\n\t\t\t//signal default (not encrypted)\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (sinf && sinf->info && sinf->info->tenc) {\n\t\tif (default_IsEncrypted) *default_IsEncrypted = sinf->info->tenc->isProtected;\n\t\tif (crypt_byte_block) *crypt_byte_block = sinf->info->tenc->crypt_byte_block;\n\t\tif (skip_byte_block) *skip_byte_block = sinf->info->tenc->skip_byte_block;\n\t\tif (key_info) *key_info = sinf->info->tenc->key_info;\n\t\tif (key_info_size) {\n\t\t\t*key_info_size = 20;\n\t\t\tif (!sinf->info->tenc->key_info[3])\n\t\t\t\t*key_info_size += 1 + sinf->info->tenc->key_info[20];\n\t\t}\n\n\t\t//set default value, overwritten below\n\t\tif (container_type) *container_type = GF_ISOM_BOX_TYPE_SENC;\n\t} else if (sinf && sinf->info && sinf->info->piff_tenc) {\n\t\tif (default_IsEncrypted) *default_IsEncrypted = GF_TRUE;\n\t\tif (key_info) *key_info = sinf->info->piff_tenc->key_info;\n\t\tif (key_info_size) *key_info_size = 19;\n\t\t//set default value, overwritten below\n\t\tif (container_type) *container_type = GF_ISOM_BOX_UUID_PSEC;\n\t} else {\n\t\tu32 i, count = 0;\n\t\tGF_CENCSampleEncryptionGroupEntry *seig_entry = NULL;\n\n\t\tif (!trak->moov->mov->is_smooth)\n\t\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\tif (sgdesc->grouping_type!=GF_ISOM_SAMPLE_GROUP_SEIG) continue;\n\t\t\tif (sgdesc->default_description_index)\n\t\t\t\tseig_entry = gf_list_get(sgdesc->group_descriptions, sgdesc->default_description_index-1);\n\t\t\telse\n\t\t\t\tseig_entry = gf_list_get(sgdesc->group_descriptions, 0);\n\t\t\tif (seig_entry && !seig_entry->key_info[0])\n\t\t\t\tseig_entry = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (seig_entry) {\n\t\t\tif (default_IsEncrypted) *default_IsEncrypted = seig_entry->IsProtected;\n\t\t\tif (crypt_byte_block) *crypt_byte_block = seig_entry->crypt_byte_block;\n\t\t\tif (skip_byte_block) *skip_byte_block = seig_entry->skip_byte_block;\n\t\t\tif (key_info) *key_info = seig_entry->key_info;\n\t\t\tif (key_info_size) *key_info_size = seig_entry->key_info_size;\n\t\t\tif (container_type) *container_type = GF_ISOM_BOX_TYPE_SENC;\n\t\t} else {\n\t\t\tif (! trak->moov->mov->is_smooth ) {\n\t\t\t\ttrak->moov->mov->is_smooth = GF_TRUE;\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] senc box without tenc, assuming MS smooth+piff\\n\"));\n\t\t\t}\n\t\t\tif (default_IsEncrypted) *default_IsEncrypted = GF_TRUE;\n\t\t\t//set default value, overwritten below\n\t\t\tif (container_type) *container_type = GF_ISOM_BOX_UUID_PSEC;\n\t\t}\n\t}\n\n\tif (container_type && trak->sample_encryption) {\n\t\tif (trak->sample_encryption->type == GF_ISOM_BOX_TYPE_SENC) *container_type = GF_ISOM_BOX_TYPE_SENC;\n\t\telse if (trak->sample_encryption->type == GF_ISOM_BOX_TYPE_UUID) *container_type = ((GF_UUIDBox*)trak->sample_encryption)->internal_4cc;\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148159,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void set_error_response(h2_stream *stream, int http_status)\n{\n    if (!h2_stream_is_ready(stream)) {\n        stream->rtmp->http_status = http_status;\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148176,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void set_error_response(h2_stream *stream, int http_status)\n{\n    if (!h2_stream_is_ready(stream) && stream->rtmp) {\n        stream->rtmp->http_status = http_status;\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148177,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "sync_create_state_control(Slapi_Entry *e, LDAPControl **ctrlp, int type, Sync_Cookie *cookie)\n{\n    int rc;\n    BerElement *ber;\n    struct berval *bvp;\n    char *uuid;\n    Slapi_Attr *attr;\n    Slapi_Value *val;\n\n    if (type == LDAP_SYNC_NONE || ctrlp == NULL || (ber = der_alloc()) == NULL) {\n        return (LDAP_OPERATIONS_ERROR);\n    }\n\n    *ctrlp = NULL;\n\n    slapi_entry_attr_find(e, SLAPI_ATTR_UNIQUEID, &attr);\n    slapi_attr_first_value(attr, &val);\n    uuid = sync_nsuniqueid2uuid(slapi_value_get_string(val));\n    if ((rc = ber_printf(ber, \"{eo\", type, uuid, 16)) != -1) {\n        if (cookie) {\n            char *cookiestr = sync_cookie2str(cookie);\n            rc = ber_printf(ber, \"s}\", cookiestr);\n            slapi_ch_free((void **)&cookiestr);\n        } else {\n            rc = ber_printf(ber, \"}\");\n        }\n    }\n    if (rc != -1) {\n        rc = ber_flatten(ber, &bvp);\n    }\n    ber_free(ber, 1);\n    slapi_ch_free((void **)&uuid);\n\n    if (rc == -1) {\n        return (LDAP_OPERATIONS_ERROR);\n    }\n\n    *ctrlp = (LDAPControl *)slapi_ch_malloc(sizeof(LDAPControl));\n    (*ctrlp)->ldctl_iscritical = 0;\n    (*ctrlp)->ldctl_oid = slapi_ch_strdup(LDAP_CONTROL_SYNC_STATE);\n    (*ctrlp)->ldctl_value = *bvp; /* struct copy */\n\n    bvp->bv_val = NULL;\n    ber_bvfree(bvp);\n\n    return (LDAP_SUCCESS);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148210,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "sync_create_state_control(Slapi_Entry *e, LDAPControl **ctrlp, int type, Sync_Cookie *cookie)\n{\n    int rc;\n    BerElement *ber;\n    struct berval *bvp;\n    char *uuid;\n    Slapi_Attr *attr = NULL;\n    Slapi_Value *val = NULL;\n\n    if (type == LDAP_SYNC_NONE || ctrlp == NULL || (ber = der_alloc()) == NULL) {\n        return (LDAP_OPERATIONS_ERROR);\n    }\n\n    *ctrlp = NULL;\n\n    slapi_entry_attr_find(e, SLAPI_ATTR_UNIQUEID, &attr);\n    slapi_attr_first_value(attr, &val);\n    if ((attr == NULL) || (val == NULL)) {\n        /* It may happen with entries in special backends\n         * such like cn=config, cn=shema, cn=monitor...\n         */\n        slapi_log_err(SLAPI_LOG_ERR, SYNC_PLUGIN_SUBSYSTEM,\n\t\t      \"sync_create_state_control - Entries are missing nsuniqueid. Unable to proceed.\\n\");\n        return (LDAP_OPERATIONS_ERROR);\n    }\n    uuid = sync_nsuniqueid2uuid(slapi_value_get_string(val));\n    if ((rc = ber_printf(ber, \"{eo\", type, uuid, 16)) != -1) {\n        if (cookie) {\n            char *cookiestr = sync_cookie2str(cookie);\n            rc = ber_printf(ber, \"s}\", cookiestr);\n            slapi_ch_free((void **)&cookiestr);\n        } else {\n            rc = ber_printf(ber, \"}\");\n        }\n    }\n    if (rc != -1) {\n        rc = ber_flatten(ber, &bvp);\n    }\n    ber_free(ber, 1);\n    slapi_ch_free((void **)&uuid);\n\n    if (rc == -1) {\n        return (LDAP_OPERATIONS_ERROR);\n    }\n\n    *ctrlp = (LDAPControl *)slapi_ch_malloc(sizeof(LDAPControl));\n    (*ctrlp)->ldctl_iscritical = 0;\n    (*ctrlp)->ldctl_oid = slapi_ch_strdup(LDAP_CONTROL_SYNC_STATE);\n    (*ctrlp)->ldctl_value = *bvp; /* struct copy */\n\n    bvp->bv_val = NULL;\n    ber_bvfree(bvp);\n\n    return (LDAP_SUCCESS);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148211,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "gdImagePtr gdImageCreateFromXpm (char *filename)\n{\n\tXpmInfo info;\n\tXpmImage image;\n\tint i, j, k, number;\n\tchar buf[5];\n\tgdImagePtr im = 0;\n\tint *pointer;\n\tint red = 0, green = 0, blue = 0;\n\tint *colors;\n\tint ret;\n\n\tret = XpmReadFileToXpmImage(filename, &image, &info);\n\tif (ret != XpmSuccess) {\n\t\treturn 0;\n\t}\n\n\tif (!(im = gdImageCreate(image.width, image.height))) {\n\t\tgoto done;\n\t}\n\n\tnumber = image.ncolors;\n\tcolors = (int *) safe_emalloc(number, sizeof(int), 0);\n\tfor (i = 0; i < number; i++) {\n\t\tswitch (strlen (image.colorTable[i].c_color)) {\n\t\t\tcase 4:\n\t\t\t\tbuf[1] = '\\0';\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[1];\n\t\t\t\tred = strtol(buf, NULL, 16);\n\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[2];\n\t\t\t\tgreen = strtol(buf, NULL, 16);\n\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[3];\n\t\t\t\tblue = strtol(buf, NULL, 16);\n\t\t\t\tbreak;\n\n\t\t\tcase 7:\n\t\t\t\tbuf[2] = '\\0';\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[1];\n\t\t\t\tbuf[1] = image.colorTable[i].c_color[2];\n\t\t\t\tred = strtol(buf, NULL, 16);\n\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[3];\n\t\t\t\tbuf[1] = image.colorTable[i].c_color[4];\n\t\t\t\tgreen = strtol(buf, NULL, 16);\n\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[5];\n\t\t\t\tbuf[1] = image.colorTable[i].c_color[6];\n\t\t\t\tblue = strtol(buf, NULL, 16);\n\t\t\t\tbreak;\n\n\t\t\tcase 10:\n\t\t\t\tbuf[3] = '\\0';\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[1];\n\t\t\t\tbuf[1] = image.colorTable[i].c_color[2];\n\t\t\t\tbuf[2] = image.colorTable[i].c_color[3];\n\t\t\t\tred = strtol(buf, NULL, 16);\n\t\t\t\tred /= 64;\n\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[4];\n\t\t\t\tbuf[1] = image.colorTable[i].c_color[5];\n\t\t\t\tbuf[2] = image.colorTable[i].c_color[6];\n\t\t\t\tgreen = strtol(buf, NULL, 16);\n\t\t\t\tgreen /= 64;\n\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[7];\n\t\t\t\tbuf[1] = image.colorTable[i].c_color[8];\n\t\t\t\tbuf[2] = image.colorTable[i].c_color[9];\n\t\t\t\tblue = strtol(buf, NULL, 16);\n\t\t\t\tblue /= 64;\n\t\t\t\tbreak;\n\n\t\t\tcase 13:\n\t\t\t\tbuf[4] = '\\0';\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[1];\n\t\t\t\tbuf[1] = image.colorTable[i].c_color[2];\n\t\t\t\tbuf[2] = image.colorTable[i].c_color[3];\n\t\t\t\tbuf[3] = image.colorTable[i].c_color[4];\n\t\t\t\tred = strtol(buf, NULL, 16);\n\t\t\t\tred /= 256;\n\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[5];\n\t\t\t\tbuf[1] = image.colorTable[i].c_color[6];\n\t\t\t\tbuf[2] = image.colorTable[i].c_color[7];\n\t\t\t\tbuf[3] = image.colorTable[i].c_color[8];\n\t\t\t\tgreen = strtol(buf, NULL, 16);\n\t\t\t\tgreen /= 256;\n\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[9];\n\t\t\t\tbuf[1] = image.colorTable[i].c_color[10];\n\t\t\t\tbuf[2] = image.colorTable[i].c_color[11];\n\t\t\t\tbuf[3] = image.colorTable[i].c_color[12];\n\t\t\t\tblue = strtol(buf, NULL, 16);\n\t\t\t\tblue /= 256;\n\t\t\t\tbreak;\n\t\t}\n\n\n\t\tcolors[i] = gdImageColorResolve(im, red, green, blue);\n\t}\n\n\tpointer = (int *) image.data;\n\tfor (i = 0; i < image.height; i++) {\n\t\tfor (j = 0; j < image.width; j++) {\n\t\t\tk = *pointer++;\n\t\t\tgdImageSetPixel(im, j, i, colors[k]);\n\t\t}\n\t}\n\n\tgdFree(colors);\n done:\n\tXpmFreeXpmImage(&image);\n\tXpmFreeXpmInfo(&info);\n\treturn im;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148214,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "gdImagePtr gdImageCreateFromXpm (char *filename)\n{\n\tXpmInfo info;\n\tXpmImage image;\n\tint i, j, k, number;\n\tchar buf[5];\n\tgdImagePtr im = 0;\n\tint *pointer;\n\tint red = 0, green = 0, blue = 0;\n\tint *colors;\n\tint ret;\n\n\tret = XpmReadFileToXpmImage(filename, &image, &info);\n\tif (ret != XpmSuccess) {\n\t\treturn 0;\n\t}\n\tnumber = image.ncolors;\n\tfor(i = 0; i < number; i++) {\n\t\tif (!image.colorTable[i].c_color) {\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (!(im = gdImageCreate(image.width, image.height))) {\n\t\tgoto done;\n\t}\n\n\tcolors = (int *) safe_emalloc(number, sizeof(int), 0);\n\tfor (i = 0; i < number; i++) {\n\t\tswitch (strlen (image.colorTable[i].c_color)) {\n\t\t\tcase 4:\n\t\t\t\tbuf[1] = '\\0';\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[1];\n\t\t\t\tred = strtol(buf, NULL, 16);\n\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[2];\n\t\t\t\tgreen = strtol(buf, NULL, 16);\n\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[3];\n\t\t\t\tblue = strtol(buf, NULL, 16);\n\t\t\t\tbreak;\n\n\t\t\tcase 7:\n\t\t\t\tbuf[2] = '\\0';\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[1];\n\t\t\t\tbuf[1] = image.colorTable[i].c_color[2];\n\t\t\t\tred = strtol(buf, NULL, 16);\n\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[3];\n\t\t\t\tbuf[1] = image.colorTable[i].c_color[4];\n\t\t\t\tgreen = strtol(buf, NULL, 16);\n\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[5];\n\t\t\t\tbuf[1] = image.colorTable[i].c_color[6];\n\t\t\t\tblue = strtol(buf, NULL, 16);\n\t\t\t\tbreak;\n\n\t\t\tcase 10:\n\t\t\t\tbuf[3] = '\\0';\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[1];\n\t\t\t\tbuf[1] = image.colorTable[i].c_color[2];\n\t\t\t\tbuf[2] = image.colorTable[i].c_color[3];\n\t\t\t\tred = strtol(buf, NULL, 16);\n\t\t\t\tred /= 64;\n\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[4];\n\t\t\t\tbuf[1] = image.colorTable[i].c_color[5];\n\t\t\t\tbuf[2] = image.colorTable[i].c_color[6];\n\t\t\t\tgreen = strtol(buf, NULL, 16);\n\t\t\t\tgreen /= 64;\n\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[7];\n\t\t\t\tbuf[1] = image.colorTable[i].c_color[8];\n\t\t\t\tbuf[2] = image.colorTable[i].c_color[9];\n\t\t\t\tblue = strtol(buf, NULL, 16);\n\t\t\t\tblue /= 64;\n\t\t\t\tbreak;\n\n\t\t\tcase 13:\n\t\t\t\tbuf[4] = '\\0';\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[1];\n\t\t\t\tbuf[1] = image.colorTable[i].c_color[2];\n\t\t\t\tbuf[2] = image.colorTable[i].c_color[3];\n\t\t\t\tbuf[3] = image.colorTable[i].c_color[4];\n\t\t\t\tred = strtol(buf, NULL, 16);\n\t\t\t\tred /= 256;\n\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[5];\n\t\t\t\tbuf[1] = image.colorTable[i].c_color[6];\n\t\t\t\tbuf[2] = image.colorTable[i].c_color[7];\n\t\t\t\tbuf[3] = image.colorTable[i].c_color[8];\n\t\t\t\tgreen = strtol(buf, NULL, 16);\n\t\t\t\tgreen /= 256;\n\n\t\t\t\tbuf[0] = image.colorTable[i].c_color[9];\n\t\t\t\tbuf[1] = image.colorTable[i].c_color[10];\n\t\t\t\tbuf[2] = image.colorTable[i].c_color[11];\n\t\t\t\tbuf[3] = image.colorTable[i].c_color[12];\n\t\t\t\tblue = strtol(buf, NULL, 16);\n\t\t\t\tblue /= 256;\n\t\t\t\tbreak;\n\t\t}\n\n\n\t\tcolors[i] = gdImageColorResolve(im, red, green, blue);\n\t}\n\n\tpointer = (int *) image.data;\n\tfor (i = 0; i < image.height; i++) {\n\t\tfor (j = 0; j < image.width; j++) {\n\t\t\tk = *pointer++;\n\t\t\tgdImageSetPixel(im, j, i, colors[k]);\n\t\t}\n\t}\n\n\tgdFree(colors);\n done:\n\tXpmFreeXpmImage(&image);\n\tXpmFreeXpmInfo(&info);\n\treturn im;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148215,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void ov511_mode_init_regs(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint hsegs, vsegs, packet_size, fps, needed;\n\tint interlaced = 0;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\tsd->gspca_dev.usb_err = -EIO;\n\t\treturn;\n\t}\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\treg_w(sd, R51x_FIFO_PSIZE, packet_size >> 5);\n\n\treg_w(sd, R511_CAM_UV_EN, 0x01);\n\treg_w(sd, R511_SNAP_UV_EN, 0x01);\n\treg_w(sd, R511_SNAP_OPTS, 0x03);\n\n\t/* Here I'm assuming that snapshot size == image size.\n\t * I hope that's always true. --claudio\n\t */\n\thsegs = (sd->gspca_dev.pixfmt.width >> 3) - 1;\n\tvsegs = (sd->gspca_dev.pixfmt.height >> 3) - 1;\n\n\treg_w(sd, R511_CAM_PXCNT, hsegs);\n\treg_w(sd, R511_CAM_LNCNT, vsegs);\n\treg_w(sd, R511_CAM_PXDIV, 0x00);\n\treg_w(sd, R511_CAM_LNDIV, 0x00);\n\n\t/* YUV420, low pass filter on */\n\treg_w(sd, R511_CAM_OPTS, 0x03);\n\n\t/* Snapshot additions */\n\treg_w(sd, R511_SNAP_PXCNT, hsegs);\n\treg_w(sd, R511_SNAP_LNCNT, vsegs);\n\treg_w(sd, R511_SNAP_PXDIV, 0x00);\n\treg_w(sd, R511_SNAP_LNDIV, 0x00);\n\n\t/******** Set the framerate ********/\n\tif (frame_rate > 0)\n\t\tsd->frame_rate = frame_rate;\n\n\tswitch (sd->sensor) {\n\tcase SEN_OV6620:\n\t\t/* No framerate control, doesn't like higher rates yet */\n\t\tsd->clockdiv = 3;\n\t\tbreak;\n\n\t/* Note once the FIXME's in mode_init_ov_sensor_regs() are fixed\n\t   for more sensors we need to do this for them too */\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE:\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\tcase SEN_OV76BE:\n\t\tif (sd->gspca_dev.pixfmt.width == 320)\n\t\t\tinterlaced = 1;\n\t\t/* Fall through */\n\tcase SEN_OV6630:\n\tcase SEN_OV7610:\n\tcase SEN_OV7670:\n\t\tswitch (sd->frame_rate) {\n\t\tcase 30:\n\t\tcase 25:\n\t\t\t/* Not enough bandwidth to do 640x480 @ 30 fps */\n\t\t\tif (sd->gspca_dev.pixfmt.width != 640) {\n\t\t\t\tsd->clockdiv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* For 640x480 case */\n\t\t\t/* fall through */\n\t\tdefault:\n/*\t\tcase 20: */\n/*\t\tcase 15: */\n\t\t\tsd->clockdiv = 1;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tsd->clockdiv = 2;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tsd->clockdiv = 5;\n\t\t\tbreak;\n\t\t}\n\t\tif (interlaced) {\n\t\t\tsd->clockdiv = (sd->clockdiv + 1) * 2 - 1;\n\t\t\t/* Higher then 10 does not work */\n\t\t\tif (sd->clockdiv > 10)\n\t\t\t\tsd->clockdiv = 10;\n\t\t}\n\t\tbreak;\n\n\tcase SEN_OV8610:\n\t\t/* No framerate control ?? */\n\t\tsd->clockdiv = 0;\n\t\tbreak;\n\t}\n\n\t/* Check if we have enough bandwidth to disable compression */\n\tfps = (interlaced ? 60 : 30) / (sd->clockdiv + 1) + 1;\n\tneeded = fps * sd->gspca_dev.pixfmt.width *\n\t\t\tsd->gspca_dev.pixfmt.height * 3 / 2;\n\t/* 1000 isoc packets/sec */\n\tif (needed > 1000 * packet_size) {\n\t\t/* Enable Y and UV quantization and compression */\n\t\treg_w(sd, R511_COMP_EN, 0x07);\n\t\treg_w(sd, R511_COMP_LUT_EN, 0x03);\n\t} else {\n\t\treg_w(sd, R511_COMP_EN, 0x06);\n\t\treg_w(sd, R511_COMP_LUT_EN, 0x00);\n\t}\n\n\treg_w(sd, R51x_SYS_RESET, OV511_RESET_OMNICE);\n\treg_w(sd, R51x_SYS_RESET, 0);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148216,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void ov511_mode_init_regs(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint hsegs, vsegs, packet_size, fps, needed;\n\tint interlaced = 0;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\tsd->gspca_dev.usb_err = -EIO;\n\t\treturn;\n\t}\n\n\tif (alt->desc.bNumEndpoints < 1) {\n\t\tsd->gspca_dev.usb_err = -ENODEV;\n\t\treturn;\n\t}\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\treg_w(sd, R51x_FIFO_PSIZE, packet_size >> 5);\n\n\treg_w(sd, R511_CAM_UV_EN, 0x01);\n\treg_w(sd, R511_SNAP_UV_EN, 0x01);\n\treg_w(sd, R511_SNAP_OPTS, 0x03);\n\n\t/* Here I'm assuming that snapshot size == image size.\n\t * I hope that's always true. --claudio\n\t */\n\thsegs = (sd->gspca_dev.pixfmt.width >> 3) - 1;\n\tvsegs = (sd->gspca_dev.pixfmt.height >> 3) - 1;\n\n\treg_w(sd, R511_CAM_PXCNT, hsegs);\n\treg_w(sd, R511_CAM_LNCNT, vsegs);\n\treg_w(sd, R511_CAM_PXDIV, 0x00);\n\treg_w(sd, R511_CAM_LNDIV, 0x00);\n\n\t/* YUV420, low pass filter on */\n\treg_w(sd, R511_CAM_OPTS, 0x03);\n\n\t/* Snapshot additions */\n\treg_w(sd, R511_SNAP_PXCNT, hsegs);\n\treg_w(sd, R511_SNAP_LNCNT, vsegs);\n\treg_w(sd, R511_SNAP_PXDIV, 0x00);\n\treg_w(sd, R511_SNAP_LNDIV, 0x00);\n\n\t/******** Set the framerate ********/\n\tif (frame_rate > 0)\n\t\tsd->frame_rate = frame_rate;\n\n\tswitch (sd->sensor) {\n\tcase SEN_OV6620:\n\t\t/* No framerate control, doesn't like higher rates yet */\n\t\tsd->clockdiv = 3;\n\t\tbreak;\n\n\t/* Note once the FIXME's in mode_init_ov_sensor_regs() are fixed\n\t   for more sensors we need to do this for them too */\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE:\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\tcase SEN_OV76BE:\n\t\tif (sd->gspca_dev.pixfmt.width == 320)\n\t\t\tinterlaced = 1;\n\t\t/* Fall through */\n\tcase SEN_OV6630:\n\tcase SEN_OV7610:\n\tcase SEN_OV7670:\n\t\tswitch (sd->frame_rate) {\n\t\tcase 30:\n\t\tcase 25:\n\t\t\t/* Not enough bandwidth to do 640x480 @ 30 fps */\n\t\t\tif (sd->gspca_dev.pixfmt.width != 640) {\n\t\t\t\tsd->clockdiv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* For 640x480 case */\n\t\t\t/* fall through */\n\t\tdefault:\n/*\t\tcase 20: */\n/*\t\tcase 15: */\n\t\t\tsd->clockdiv = 1;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tsd->clockdiv = 2;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tsd->clockdiv = 5;\n\t\t\tbreak;\n\t\t}\n\t\tif (interlaced) {\n\t\t\tsd->clockdiv = (sd->clockdiv + 1) * 2 - 1;\n\t\t\t/* Higher then 10 does not work */\n\t\t\tif (sd->clockdiv > 10)\n\t\t\t\tsd->clockdiv = 10;\n\t\t}\n\t\tbreak;\n\n\tcase SEN_OV8610:\n\t\t/* No framerate control ?? */\n\t\tsd->clockdiv = 0;\n\t\tbreak;\n\t}\n\n\t/* Check if we have enough bandwidth to disable compression */\n\tfps = (interlaced ? 60 : 30) / (sd->clockdiv + 1) + 1;\n\tneeded = fps * sd->gspca_dev.pixfmt.width *\n\t\t\tsd->gspca_dev.pixfmt.height * 3 / 2;\n\t/* 1000 isoc packets/sec */\n\tif (needed > 1000 * packet_size) {\n\t\t/* Enable Y and UV quantization and compression */\n\t\treg_w(sd, R511_COMP_EN, 0x07);\n\t\treg_w(sd, R511_COMP_LUT_EN, 0x03);\n\t} else {\n\t\treg_w(sd, R511_COMP_EN, 0x06);\n\t\treg_w(sd, R511_COMP_LUT_EN, 0x00);\n\t}\n\n\treg_w(sd, R51x_SYS_RESET, OV511_RESET_OMNICE);\n\treg_w(sd, R51x_SYS_RESET, 0);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148217,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void ov518_mode_init_regs(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint hsegs, vsegs, packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\tsd->gspca_dev.usb_err = -EIO;\n\t\treturn;\n\t}\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\tov518_reg_w32(sd, R51x_FIFO_PSIZE, packet_size & ~7, 2);\n\n\t/******** Set the mode ********/\n\treg_w(sd, 0x2b, 0);\n\treg_w(sd, 0x2c, 0);\n\treg_w(sd, 0x2d, 0);\n\treg_w(sd, 0x2e, 0);\n\treg_w(sd, 0x3b, 0);\n\treg_w(sd, 0x3c, 0);\n\treg_w(sd, 0x3d, 0);\n\treg_w(sd, 0x3e, 0);\n\n\tif (sd->bridge == BRIDGE_OV518) {\n\t\t/* Set 8-bit (YVYU) input format */\n\t\treg_w_mask(sd, 0x20, 0x08, 0x08);\n\n\t\t/* Set 12-bit (4:2:0) output format */\n\t\treg_w_mask(sd, 0x28, 0x80, 0xf0);\n\t\treg_w_mask(sd, 0x38, 0x80, 0xf0);\n\t} else {\n\t\treg_w(sd, 0x28, 0x80);\n\t\treg_w(sd, 0x38, 0x80);\n\t}\n\n\thsegs = sd->gspca_dev.pixfmt.width / 16;\n\tvsegs = sd->gspca_dev.pixfmt.height / 4;\n\n\treg_w(sd, 0x29, hsegs);\n\treg_w(sd, 0x2a, vsegs);\n\n\treg_w(sd, 0x39, hsegs);\n\treg_w(sd, 0x3a, vsegs);\n\n\t/* Windows driver does this here; who knows why */\n\treg_w(sd, 0x2f, 0x80);\n\n\t/******** Set the framerate ********/\n\tif (sd->bridge == BRIDGE_OV518PLUS && sd->revision == 0 &&\n\t\t\t\t\t      sd->sensor == SEN_OV7620AE)\n\t\tsd->clockdiv = 0;\n\telse\n\t\tsd->clockdiv = 1;\n\n\t/* Mode independent, but framerate dependent, regs */\n\t/* 0x51: Clock divider; Only works on some cams which use 2 crystals */\n\treg_w(sd, 0x51, 0x04);\n\treg_w(sd, 0x22, 0x18);\n\treg_w(sd, 0x23, 0xff);\n\n\tif (sd->bridge == BRIDGE_OV518PLUS) {\n\t\tswitch (sd->sensor) {\n\t\tcase SEN_OV7620AE:\n\t\t\t/*\n\t\t\t * HdG: 640x480 needs special handling on device\n\t\t\t * revision 2, we check for device revision > 0 to\n\t\t\t * avoid regressions, as we don't know the correct\n\t\t\t * thing todo for revision 1.\n\t\t\t *\n\t\t\t * Also this likely means we don't need to\n\t\t\t * differentiate between the OV7620 and OV7620AE,\n\t\t\t * earlier testing hitting this same problem likely\n\t\t\t * happened to be with revision < 2 cams using an\n\t\t\t * OV7620 and revision 2 cams using an OV7620AE.\n\t\t\t */\n\t\t\tif (sd->revision > 0 &&\n\t\t\t\t\tsd->gspca_dev.pixfmt.width == 640) {\n\t\t\t\treg_w(sd, 0x20, 0x60);\n\t\t\t\treg_w(sd, 0x21, 0x1f);\n\t\t\t} else {\n\t\t\t\treg_w(sd, 0x20, 0x00);\n\t\t\t\treg_w(sd, 0x21, 0x19);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SEN_OV7620:\n\t\t\treg_w(sd, 0x20, 0x00);\n\t\t\treg_w(sd, 0x21, 0x19);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treg_w(sd, 0x21, 0x19);\n\t\t}\n\t} else\n\t\treg_w(sd, 0x71, 0x17);\t/* Compression-related? */\n\n\t/* FIXME: Sensor-specific */\n\t/* Bit 5 is what matters here. Of course, it is \"reserved\" */\n\ti2c_w(sd, 0x54, 0x23);\n\n\treg_w(sd, 0x2f, 0x80);\n\n\tif (sd->bridge == BRIDGE_OV518PLUS) {\n\t\treg_w(sd, 0x24, 0x94);\n\t\treg_w(sd, 0x25, 0x90);\n\t\tov518_reg_w32(sd, 0xc4,    400, 2);\t/* 190h   */\n\t\tov518_reg_w32(sd, 0xc6,    540, 2);\t/* 21ch   */\n\t\tov518_reg_w32(sd, 0xc7,    540, 2);\t/* 21ch   */\n\t\tov518_reg_w32(sd, 0xc8,    108, 2);\t/* 6ch    */\n\t\tov518_reg_w32(sd, 0xca, 131098, 3);\t/* 2001ah */\n\t\tov518_reg_w32(sd, 0xcb,    532, 2);\t/* 214h   */\n\t\tov518_reg_w32(sd, 0xcc,   2400, 2);\t/* 960h   */\n\t\tov518_reg_w32(sd, 0xcd,     32, 2);\t/* 20h    */\n\t\tov518_reg_w32(sd, 0xce,    608, 2);\t/* 260h   */\n\t} else {\n\t\treg_w(sd, 0x24, 0x9f);\n\t\treg_w(sd, 0x25, 0x90);\n\t\tov518_reg_w32(sd, 0xc4,    400, 2);\t/* 190h   */\n\t\tov518_reg_w32(sd, 0xc6,    381, 2);\t/* 17dh   */\n\t\tov518_reg_w32(sd, 0xc7,    381, 2);\t/* 17dh   */\n\t\tov518_reg_w32(sd, 0xc8,    128, 2);\t/* 80h    */\n\t\tov518_reg_w32(sd, 0xca, 183331, 3);\t/* 2cc23h */\n\t\tov518_reg_w32(sd, 0xcb,    746, 2);\t/* 2eah   */\n\t\tov518_reg_w32(sd, 0xcc,   1750, 2);\t/* 6d6h   */\n\t\tov518_reg_w32(sd, 0xcd,     45, 2);\t/* 2dh    */\n\t\tov518_reg_w32(sd, 0xce,    851, 2);\t/* 353h   */\n\t}\n\n\treg_w(sd, 0x2f, 0x80);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148218,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void ov518_mode_init_regs(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint hsegs, vsegs, packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\tsd->gspca_dev.usb_err = -EIO;\n\t\treturn;\n\t}\n\n\tif (alt->desc.bNumEndpoints < 1) {\n\t\tsd->gspca_dev.usb_err = -ENODEV;\n\t\treturn;\n\t}\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\tov518_reg_w32(sd, R51x_FIFO_PSIZE, packet_size & ~7, 2);\n\n\t/******** Set the mode ********/\n\treg_w(sd, 0x2b, 0);\n\treg_w(sd, 0x2c, 0);\n\treg_w(sd, 0x2d, 0);\n\treg_w(sd, 0x2e, 0);\n\treg_w(sd, 0x3b, 0);\n\treg_w(sd, 0x3c, 0);\n\treg_w(sd, 0x3d, 0);\n\treg_w(sd, 0x3e, 0);\n\n\tif (sd->bridge == BRIDGE_OV518) {\n\t\t/* Set 8-bit (YVYU) input format */\n\t\treg_w_mask(sd, 0x20, 0x08, 0x08);\n\n\t\t/* Set 12-bit (4:2:0) output format */\n\t\treg_w_mask(sd, 0x28, 0x80, 0xf0);\n\t\treg_w_mask(sd, 0x38, 0x80, 0xf0);\n\t} else {\n\t\treg_w(sd, 0x28, 0x80);\n\t\treg_w(sd, 0x38, 0x80);\n\t}\n\n\thsegs = sd->gspca_dev.pixfmt.width / 16;\n\tvsegs = sd->gspca_dev.pixfmt.height / 4;\n\n\treg_w(sd, 0x29, hsegs);\n\treg_w(sd, 0x2a, vsegs);\n\n\treg_w(sd, 0x39, hsegs);\n\treg_w(sd, 0x3a, vsegs);\n\n\t/* Windows driver does this here; who knows why */\n\treg_w(sd, 0x2f, 0x80);\n\n\t/******** Set the framerate ********/\n\tif (sd->bridge == BRIDGE_OV518PLUS && sd->revision == 0 &&\n\t\t\t\t\t      sd->sensor == SEN_OV7620AE)\n\t\tsd->clockdiv = 0;\n\telse\n\t\tsd->clockdiv = 1;\n\n\t/* Mode independent, but framerate dependent, regs */\n\t/* 0x51: Clock divider; Only works on some cams which use 2 crystals */\n\treg_w(sd, 0x51, 0x04);\n\treg_w(sd, 0x22, 0x18);\n\treg_w(sd, 0x23, 0xff);\n\n\tif (sd->bridge == BRIDGE_OV518PLUS) {\n\t\tswitch (sd->sensor) {\n\t\tcase SEN_OV7620AE:\n\t\t\t/*\n\t\t\t * HdG: 640x480 needs special handling on device\n\t\t\t * revision 2, we check for device revision > 0 to\n\t\t\t * avoid regressions, as we don't know the correct\n\t\t\t * thing todo for revision 1.\n\t\t\t *\n\t\t\t * Also this likely means we don't need to\n\t\t\t * differentiate between the OV7620 and OV7620AE,\n\t\t\t * earlier testing hitting this same problem likely\n\t\t\t * happened to be with revision < 2 cams using an\n\t\t\t * OV7620 and revision 2 cams using an OV7620AE.\n\t\t\t */\n\t\t\tif (sd->revision > 0 &&\n\t\t\t\t\tsd->gspca_dev.pixfmt.width == 640) {\n\t\t\t\treg_w(sd, 0x20, 0x60);\n\t\t\t\treg_w(sd, 0x21, 0x1f);\n\t\t\t} else {\n\t\t\t\treg_w(sd, 0x20, 0x00);\n\t\t\t\treg_w(sd, 0x21, 0x19);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SEN_OV7620:\n\t\t\treg_w(sd, 0x20, 0x00);\n\t\t\treg_w(sd, 0x21, 0x19);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treg_w(sd, 0x21, 0x19);\n\t\t}\n\t} else\n\t\treg_w(sd, 0x71, 0x17);\t/* Compression-related? */\n\n\t/* FIXME: Sensor-specific */\n\t/* Bit 5 is what matters here. Of course, it is \"reserved\" */\n\ti2c_w(sd, 0x54, 0x23);\n\n\treg_w(sd, 0x2f, 0x80);\n\n\tif (sd->bridge == BRIDGE_OV518PLUS) {\n\t\treg_w(sd, 0x24, 0x94);\n\t\treg_w(sd, 0x25, 0x90);\n\t\tov518_reg_w32(sd, 0xc4,    400, 2);\t/* 190h   */\n\t\tov518_reg_w32(sd, 0xc6,    540, 2);\t/* 21ch   */\n\t\tov518_reg_w32(sd, 0xc7,    540, 2);\t/* 21ch   */\n\t\tov518_reg_w32(sd, 0xc8,    108, 2);\t/* 6ch    */\n\t\tov518_reg_w32(sd, 0xca, 131098, 3);\t/* 2001ah */\n\t\tov518_reg_w32(sd, 0xcb,    532, 2);\t/* 214h   */\n\t\tov518_reg_w32(sd, 0xcc,   2400, 2);\t/* 960h   */\n\t\tov518_reg_w32(sd, 0xcd,     32, 2);\t/* 20h    */\n\t\tov518_reg_w32(sd, 0xce,    608, 2);\t/* 260h   */\n\t} else {\n\t\treg_w(sd, 0x24, 0x9f);\n\t\treg_w(sd, 0x25, 0x90);\n\t\tov518_reg_w32(sd, 0xc4,    400, 2);\t/* 190h   */\n\t\tov518_reg_w32(sd, 0xc6,    381, 2);\t/* 17dh   */\n\t\tov518_reg_w32(sd, 0xc7,    381, 2);\t/* 17dh   */\n\t\tov518_reg_w32(sd, 0xc8,    128, 2);\t/* 80h    */\n\t\tov518_reg_w32(sd, 0xca, 183331, 3);\t/* 2cc23h */\n\t\tov518_reg_w32(sd, 0xcb,    746, 2);\t/* 2eah   */\n\t\tov518_reg_w32(sd, 0xcc,   1750, 2);\t/* 6d6h   */\n\t\tov518_reg_w32(sd, 0xcd,     45, 2);\t/* 2dh    */\n\t\tov518_reg_w32(sd, 0xce,    851, 2);\t/* 353h   */\n\t}\n\n\treg_w(sd, 0x2f, 0x80);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148219,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "slap_modrdn2mods(\n\tOperation\t*op,\n\tSlapReply\t*rs )\n{\n\tint\t\ta_cnt, d_cnt;\n\tLDAPRDN\t\told_rdn = NULL;\n\tLDAPRDN\t\tnew_rdn = NULL;\n\n\tassert( !BER_BVISEMPTY( &op->oq_modrdn.rs_newrdn ) );\n\n\t/* if requestDN is empty, silently reset deleteOldRDN */\n\tif ( BER_BVISEMPTY( &op->o_req_dn ) ) op->orr_deleteoldrdn = 0;\n\n\tif ( ldap_bv2rdn_x( &op->oq_modrdn.rs_newrdn, &new_rdn,\n\t\t(char **)&rs->sr_text, LDAP_DN_FORMAT_LDAP, op->o_tmpmemctx ) ) {\n\t\tDebug( LDAP_DEBUG_TRACE,\n\t\t\t\"%s slap_modrdn2mods: can't figure out \"\n\t\t\t\"type(s)/value(s) of newrdn\\n\",\n\t\t\top->o_log_prefix, 0, 0 );\n\t\trs->sr_err = LDAP_INVALID_DN_SYNTAX;\n\t\trs->sr_text = \"unknown type(s)/value(s) used in RDN\";\n\t\tgoto done;\n\t}\n\n\tif ( op->oq_modrdn.rs_deleteoldrdn ) {\n\t\tif ( ldap_bv2rdn_x( &op->o_req_dn, &old_rdn,\n\t\t\t(char **)&rs->sr_text, LDAP_DN_FORMAT_LDAP, op->o_tmpmemctx ) ) {\n\t\t\tDebug( LDAP_DEBUG_TRACE,\n\t\t\t\t\"%s slap_modrdn2mods: can't figure out \"\n\t\t\t\t\"type(s)/value(s) of oldrdn\\n\",\n\t\t\t\top->o_log_prefix, 0, 0 );\n\t\t\trs->sr_err = LDAP_OTHER;\n\t\t\trs->sr_text = \"cannot parse RDN from old DN\";\n\t\t\tgoto done;\n\t\t}\n\t}\n\trs->sr_text = NULL;\n\n\t/* Add new attribute values to the entry */\n\tfor ( a_cnt = 0; new_rdn[a_cnt]; a_cnt++ ) {\n\t\tAttributeDescription\t*desc = NULL;\n\t\tModifications \t\t*mod_tmp;\n\n\t\trs->sr_err = slap_bv2ad( &new_rdn[a_cnt]->la_attr, &desc, &rs->sr_text );\n\n\t\tif ( rs->sr_err != LDAP_SUCCESS ) {\n\t\t\tDebug( LDAP_DEBUG_TRACE,\n\t\t\t\t\"%s slap_modrdn2mods: %s: %s (new)\\n\",\n\t\t\t\top->o_log_prefix,\n\t\t\t\trs->sr_text,\n\t\t\t\tnew_rdn[ a_cnt ]->la_attr.bv_val );\n\t\t\tgoto done;\t\t\n\t\t}\n\n\t\tif ( !desc->ad_type->sat_equality ) {\n\t\t\tDebug( LDAP_DEBUG_TRACE,\n\t\t\t\t\"%s slap_modrdn2mods: %s: %s (new)\\n\",\n\t\t\t\top->o_log_prefix,\n\t\t\t\trs->sr_text,\n\t\t\t\tnew_rdn[ a_cnt ]->la_attr.bv_val );\n\t\t\trs->sr_text = \"naming attribute has no equality matching rule\";\n\t\t\trs->sr_err = LDAP_NAMING_VIOLATION;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Apply modification */\n\t\tmod_tmp = ( Modifications * )ch_malloc( sizeof( Modifications ) );\n\t\tmod_tmp->sml_desc = desc;\n\t\tBER_BVZERO( &mod_tmp->sml_type );\n\t\tmod_tmp->sml_numvals = 1;\n\t\tmod_tmp->sml_values = ( BerVarray )ch_malloc( 2 * sizeof( struct berval ) );\n\t\tber_dupbv( &mod_tmp->sml_values[0], &new_rdn[a_cnt]->la_value );\n\t\tmod_tmp->sml_values[1].bv_val = NULL;\n\t\tif( desc->ad_type->sat_equality->smr_normalize) {\n\t\t\tmod_tmp->sml_nvalues = ( BerVarray )ch_malloc( 2 * sizeof( struct berval ) );\n\t\t\trs->sr_err = desc->ad_type->sat_equality->smr_normalize(\n\t\t\t\tSLAP_MR_EQUALITY|SLAP_MR_VALUE_OF_ASSERTION_SYNTAX,\n\t\t\t\tdesc->ad_type->sat_syntax,\n\t\t\t\tdesc->ad_type->sat_equality,\n\t\t\t\t&mod_tmp->sml_values[0],\n\t\t\t\t&mod_tmp->sml_nvalues[0], NULL );\n\t\t\tif (rs->sr_err != LDAP_SUCCESS) {\n\t\t\t\tch_free(mod_tmp->sml_nvalues);\n\t\t\t\tch_free(mod_tmp->sml_values[0].bv_val);\n\t\t\t\tch_free(mod_tmp->sml_values);\n\t\t\t\tch_free(mod_tmp);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tmod_tmp->sml_nvalues[1].bv_val = NULL;\n\t\t} else {\n\t\t\tmod_tmp->sml_nvalues = NULL;\n\t\t}\n\t\tmod_tmp->sml_op = SLAP_MOD_SOFTADD;\n\t\tmod_tmp->sml_flags = 0;\n\t\tmod_tmp->sml_next = op->orr_modlist;\n\t\top->orr_modlist = mod_tmp;\n\t}\n\n\t/* Remove old rdn value if required */\n\tif ( op->orr_deleteoldrdn ) {\n\t\tfor ( d_cnt = 0; old_rdn[d_cnt]; d_cnt++ ) {\n\t\t\tAttributeDescription\t*desc = NULL;\n\t\t\tModifications \t\t*mod_tmp;\n\n\t\t\trs->sr_err = slap_bv2ad( &old_rdn[d_cnt]->la_attr, &desc, &rs->sr_text );\n\t\t\tif ( rs->sr_err != LDAP_SUCCESS ) {\n\t\t\t\tDebug( LDAP_DEBUG_TRACE,\n\t\t\t\t\t\"%s slap_modrdn2mods: %s: %s (old)\\n\",\n\t\t\t\t\top->o_log_prefix,\n\t\t\t\t\trs->sr_text, \n\t\t\t\t\told_rdn[d_cnt]->la_attr.bv_val );\n\t\t\t\tgoto done;\t\t\n\t\t\t}\n\n\t\t\t/* Apply modification */\n\t\t\tmod_tmp = ( Modifications * )ch_malloc( sizeof( Modifications ) );\n\t\t\tmod_tmp->sml_desc = desc;\n\t\t\tBER_BVZERO( &mod_tmp->sml_type );\n\t\t\tmod_tmp->sml_numvals = 1;\n\t\t\tmod_tmp->sml_values = ( BerVarray )ch_malloc( 2 * sizeof( struct berval ) );\n\t\t\tber_dupbv( &mod_tmp->sml_values[0], &old_rdn[d_cnt]->la_value );\n\t\t\tmod_tmp->sml_values[1].bv_val = NULL;\n\t\t\tif( desc->ad_type->sat_equality->smr_normalize) {\n\t\t\t\tmod_tmp->sml_nvalues = ( BerVarray )ch_malloc( 2 * sizeof( struct berval ) );\n\t\t\t\t(void) (*desc->ad_type->sat_equality->smr_normalize)(\n\t\t\t\t\tSLAP_MR_EQUALITY|SLAP_MR_VALUE_OF_ASSERTION_SYNTAX,\n\t\t\t\t\tdesc->ad_type->sat_syntax,\n\t\t\t\t\tdesc->ad_type->sat_equality,\n\t\t\t\t\t&mod_tmp->sml_values[0],\n\t\t\t\t\t&mod_tmp->sml_nvalues[0], NULL );\n\t\t\t\tmod_tmp->sml_nvalues[1].bv_val = NULL;\n\t\t\t} else {\n\t\t\t\tmod_tmp->sml_nvalues = NULL;\n\t\t\t}\n\t\t\tmod_tmp->sml_op = LDAP_MOD_DELETE;\n\t\t\tmod_tmp->sml_flags = 0;\n\t\t\tmod_tmp->sml_next = op->orr_modlist;\n\t\t\top->orr_modlist = mod_tmp;\n\t\t}\n\t}\n\t\ndone:\n\n\t/* LDAP v2 supporting correct attribute handling. */\n\tif ( rs->sr_err != LDAP_SUCCESS && op->orr_modlist != NULL ) {\n\t\tModifications *tmp;\n\n\t\tfor ( ; op->orr_modlist != NULL; op->orr_modlist = tmp ) {\n\t\t\ttmp = op->orr_modlist->sml_next;\n\t\t\tch_free( op->orr_modlist );\n\t\t}\n\t}\n\n\tif ( new_rdn != NULL ) {\n\t\tldap_rdnfree_x( new_rdn, op->o_tmpmemctx );\n\t}\n\tif ( old_rdn != NULL ) {\n\t\tldap_rdnfree_x( old_rdn, op->o_tmpmemctx );\n\t}\n\n\treturn rs->sr_err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148254,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "slap_modrdn2mods(\n\tOperation\t*op,\n\tSlapReply\t*rs )\n{\n\tint\t\ta_cnt, d_cnt;\n\tLDAPRDN\t\told_rdn = NULL;\n\tLDAPRDN\t\tnew_rdn = NULL;\n\n\tassert( !BER_BVISEMPTY( &op->oq_modrdn.rs_newrdn ) );\n\n\t/* if requestDN is empty, silently reset deleteOldRDN */\n\tif ( BER_BVISEMPTY( &op->o_req_dn ) ) op->orr_deleteoldrdn = 0;\n\n\tif ( ldap_bv2rdn_x( &op->oq_modrdn.rs_newrdn, &new_rdn,\n\t\t(char **)&rs->sr_text, LDAP_DN_FORMAT_LDAP, op->o_tmpmemctx ) ) {\n\t\tDebug( LDAP_DEBUG_TRACE,\n\t\t\t\"%s slap_modrdn2mods: can't figure out \"\n\t\t\t\"type(s)/value(s) of newrdn\\n\",\n\t\t\top->o_log_prefix, 0, 0 );\n\t\trs->sr_err = LDAP_INVALID_DN_SYNTAX;\n\t\trs->sr_text = \"unknown type(s)/value(s) used in RDN\";\n\t\tgoto done;\n\t}\n\n\tif ( op->oq_modrdn.rs_deleteoldrdn ) {\n\t\tif ( ldap_bv2rdn_x( &op->o_req_dn, &old_rdn,\n\t\t\t(char **)&rs->sr_text, LDAP_DN_FORMAT_LDAP, op->o_tmpmemctx ) ) {\n\t\t\tDebug( LDAP_DEBUG_TRACE,\n\t\t\t\t\"%s slap_modrdn2mods: can't figure out \"\n\t\t\t\t\"type(s)/value(s) of oldrdn\\n\",\n\t\t\t\top->o_log_prefix, 0, 0 );\n\t\t\trs->sr_err = LDAP_OTHER;\n\t\t\trs->sr_text = \"cannot parse RDN from old DN\";\n\t\t\tgoto done;\n\t\t}\n\t}\n\trs->sr_text = NULL;\n\n\t/* Add new attribute values to the entry */\n\tfor ( a_cnt = 0; new_rdn[a_cnt]; a_cnt++ ) {\n\t\tAttributeDescription\t*desc = NULL;\n\t\tModifications \t\t*mod_tmp;\n\n\t\trs->sr_err = slap_bv2ad( &new_rdn[a_cnt]->la_attr, &desc, &rs->sr_text );\n\n\t\tif ( rs->sr_err != LDAP_SUCCESS ) {\n\t\t\tDebug( LDAP_DEBUG_TRACE,\n\t\t\t\t\"%s slap_modrdn2mods: %s: %s (new)\\n\",\n\t\t\t\top->o_log_prefix,\n\t\t\t\trs->sr_text,\n\t\t\t\tnew_rdn[ a_cnt ]->la_attr.bv_val );\n\t\t\tgoto done;\t\t\n\t\t}\n\n\t\tif ( !desc->ad_type->sat_equality ) {\n\t\t\tDebug( LDAP_DEBUG_TRACE,\n\t\t\t\t\"%s slap_modrdn2mods: %s: %s (new)\\n\",\n\t\t\t\top->o_log_prefix,\n\t\t\t\trs->sr_text,\n\t\t\t\tnew_rdn[ a_cnt ]->la_attr.bv_val );\n\t\t\trs->sr_text = \"naming attribute has no equality matching rule\";\n\t\t\trs->sr_err = LDAP_NAMING_VIOLATION;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Apply modification */\n\t\tmod_tmp = ( Modifications * )ch_malloc( sizeof( Modifications ) );\n\t\tmod_tmp->sml_desc = desc;\n\t\tBER_BVZERO( &mod_tmp->sml_type );\n\t\tmod_tmp->sml_numvals = 1;\n\t\tmod_tmp->sml_values = ( BerVarray )ch_malloc( 2 * sizeof( struct berval ) );\n\t\tber_dupbv( &mod_tmp->sml_values[0], &new_rdn[a_cnt]->la_value );\n\t\tmod_tmp->sml_values[1].bv_val = NULL;\n\t\tif( desc->ad_type->sat_equality->smr_normalize) {\n\t\t\tmod_tmp->sml_nvalues = ( BerVarray )ch_malloc( 2 * sizeof( struct berval ) );\n\t\t\trs->sr_err = desc->ad_type->sat_equality->smr_normalize(\n\t\t\t\tSLAP_MR_EQUALITY|SLAP_MR_VALUE_OF_ASSERTION_SYNTAX,\n\t\t\t\tdesc->ad_type->sat_syntax,\n\t\t\t\tdesc->ad_type->sat_equality,\n\t\t\t\t&mod_tmp->sml_values[0],\n\t\t\t\t&mod_tmp->sml_nvalues[0], NULL );\n\t\t\tif (rs->sr_err != LDAP_SUCCESS) {\n\t\t\t\tch_free(mod_tmp->sml_nvalues);\n\t\t\t\tch_free(mod_tmp->sml_values[0].bv_val);\n\t\t\t\tch_free(mod_tmp->sml_values);\n\t\t\t\tch_free(mod_tmp);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tmod_tmp->sml_nvalues[1].bv_val = NULL;\n\t\t} else {\n\t\t\tmod_tmp->sml_nvalues = NULL;\n\t\t}\n\t\tmod_tmp->sml_op = SLAP_MOD_SOFTADD;\n\t\tmod_tmp->sml_flags = 0;\n\t\tmod_tmp->sml_next = op->orr_modlist;\n\t\top->orr_modlist = mod_tmp;\n\t}\n\n\t/* Remove old rdn value if required */\n\tif ( op->orr_deleteoldrdn ) {\n\t\tfor ( d_cnt = 0; old_rdn[d_cnt]; d_cnt++ ) {\n\t\t\tAttributeDescription\t*desc = NULL;\n\t\t\tModifications \t\t*mod_tmp;\n\n\t\t\trs->sr_err = slap_bv2ad( &old_rdn[d_cnt]->la_attr, &desc, &rs->sr_text );\n\t\t\tif ( rs->sr_err != LDAP_SUCCESS ) {\n\t\t\t\tDebug( LDAP_DEBUG_TRACE,\n\t\t\t\t\t\"%s slap_modrdn2mods: %s: %s (old)\\n\",\n\t\t\t\t\top->o_log_prefix,\n\t\t\t\t\trs->sr_text, \n\t\t\t\t\told_rdn[d_cnt]->la_attr.bv_val );\n\t\t\t\tgoto done;\t\t\n\t\t\t}\n\n\t\t\t/* Apply modification */\n\t\t\tmod_tmp = ( Modifications * )ch_malloc( sizeof( Modifications ) );\n\t\t\tmod_tmp->sml_desc = desc;\n\t\t\tBER_BVZERO( &mod_tmp->sml_type );\n\t\t\tmod_tmp->sml_numvals = 1;\n\t\t\tmod_tmp->sml_values = ( BerVarray )ch_malloc( 2 * sizeof( struct berval ) );\n\t\t\tber_dupbv( &mod_tmp->sml_values[0], &old_rdn[d_cnt]->la_value );\n\t\t\tmod_tmp->sml_values[1].bv_val = NULL;\n\t\t\tif( desc->ad_type->sat_equality && desc->ad_type->sat_equality->smr_normalize) {\n\t\t\t\tmod_tmp->sml_nvalues = ( BerVarray )ch_malloc( 2 * sizeof( struct berval ) );\n\t\t\t\t(void) (*desc->ad_type->sat_equality->smr_normalize)(\n\t\t\t\t\tSLAP_MR_EQUALITY|SLAP_MR_VALUE_OF_ASSERTION_SYNTAX,\n\t\t\t\t\tdesc->ad_type->sat_syntax,\n\t\t\t\t\tdesc->ad_type->sat_equality,\n\t\t\t\t\t&mod_tmp->sml_values[0],\n\t\t\t\t\t&mod_tmp->sml_nvalues[0], NULL );\n\t\t\t\tmod_tmp->sml_nvalues[1].bv_val = NULL;\n\t\t\t} else {\n\t\t\t\tmod_tmp->sml_nvalues = NULL;\n\t\t\t}\n\t\t\tmod_tmp->sml_op = LDAP_MOD_DELETE;\n\t\t\tmod_tmp->sml_flags = 0;\n\t\t\tmod_tmp->sml_next = op->orr_modlist;\n\t\t\top->orr_modlist = mod_tmp;\n\t\t}\n\t}\n\t\ndone:\n\n\t/* LDAP v2 supporting correct attribute handling. */\n\tif ( rs->sr_err != LDAP_SUCCESS && op->orr_modlist != NULL ) {\n\t\tModifications *tmp;\n\n\t\tfor ( ; op->orr_modlist != NULL; op->orr_modlist = tmp ) {\n\t\t\ttmp = op->orr_modlist->sml_next;\n\t\t\tch_free( op->orr_modlist );\n\t\t}\n\t}\n\n\tif ( new_rdn != NULL ) {\n\t\tldap_rdnfree_x( new_rdn, op->o_tmpmemctx );\n\t}\n\tif ( old_rdn != NULL ) {\n\t\tldap_rdnfree_x( old_rdn, op->o_tmpmemctx );\n\t}\n\n\treturn rs->sr_err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148255,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vpidx)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tvcpu = get_vcpu_by_vpidx(kvm, vpidx);\n\tif (!vcpu)\n\t\treturn NULL;\n\tsynic = to_hv_synic(vcpu);\n\treturn (synic->active) ? synic : NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148278,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vpidx)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tvcpu = get_vcpu_by_vpidx(kvm, vpidx);\n\tif (!vcpu || !to_hv_vcpu(vcpu))\n\t\treturn NULL;\n\tsynic = to_hv_synic(vcpu);\n\treturn (synic->active) ? synic : NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148279,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int ssh_buffer_add_data(struct ssh_buffer_struct *buffer, const void *data, uint32_t len)\n{\n  buffer_verify(buffer);\n\n  if (data == NULL) {\n      return -1;\n  }\n\n  if (buffer->used + len < len) {\n    return -1;\n  }\n\n  if (buffer->allocated < (buffer->used + len)) {\n    if(buffer->pos > 0)\n      buffer_shift(buffer);\n    if (realloc_buffer(buffer, buffer->used + len) < 0) {\n      return -1;\n    }\n  }\n\n  memcpy(buffer->data+buffer->used, data, len);\n  buffer->used+=len;\n  buffer_verify(buffer);\n  return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148280,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void *ssh_buffer_allocate(struct ssh_buffer_struct *buffer, uint32_t len)\n{\n    void *ptr;\n    buffer_verify(buffer);\n\n    if (buffer->used + len < len) {\n        return NULL;\n    }\n\n    if (buffer->allocated < (buffer->used + len)) {\n        if (buffer->pos > 0) {\n            buffer_shift(buffer);\n        }\n\n        if (realloc_buffer(buffer, buffer->used + len) < 0) {\n            return NULL;\n        }\n    }\n\n    ptr = buffer->data + buffer->used;\n    buffer->used+=len;\n    buffer_verify(buffer);\n\n    return ptr;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148281,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "vmod_append(VRT_CTX, VCL_HEADER hdr, VCL_STRANDS s)\n{\n\tstruct http *hp;\n\tstruct strands st[1];\n\tconst char *p[s->n + 2];\n\tconst char *b;\n\n\tCHECK_OBJ_NOTNULL(ctx, VRT_CTX_MAGIC);\n\n\t/* prefix the strand with $hdr_name + space */\n\tp[0] = hdr->what + 1;\n\tp[1] = \" \";\n\tAN(memcpy(p + 2, s->p, s->n * sizeof *s->p));\n\tst->n = s->n + 2;\n\tst->p = p;\n\n\tb = VRT_StrandsWS(ctx->ws, NULL, st);\n\n\thp = VRT_selecthttp(ctx, hdr->where);\n\thttp_SetHeader(hp, b);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148346,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "vmod_append(VRT_CTX, VCL_HEADER hdr, VCL_STRANDS s)\n{\n\tstruct http *hp;\n\tstruct strands st[1];\n\tconst char *p[s->n + 2];\n\tconst char *b;\n\n\tCHECK_OBJ_NOTNULL(ctx, VRT_CTX_MAGIC);\n\n\t/* prefix the strand with $hdr_name + space */\n\tp[0] = hdr->what + 1;\n\tp[1] = \" \";\n\tAN(memcpy(p + 2, s->p, s->n * sizeof *s->p));\n\tst->n = s->n + 2;\n\tst->p = p;\n\n\tb = VRT_StrandsWS(ctx->ws, NULL, st);\n\tif (b == NULL) {\n\t\tVRT_fail(ctx, \"vmod_header: workspace allocation failure\");\n\t\treturn;\n\t}\n\n\thp = VRT_selecthttp(ctx, hdr->where);\n\thttp_SetHeader(hp, b);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148347,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "unsigned long perf_instruction_pointer(struct pt_regs *regs)\n{\n\tbool use_siar = regs_use_siar(regs);\n\tunsigned long siar = mfspr(SPRN_SIAR);\n\n\tif (ppmu->flags & PPMU_P10_DD1) {\n\t\tif (siar)\n\t\t\treturn siar;\n\t\telse\n\t\t\treturn regs->nip;\n\t} else if (use_siar && siar_valid(regs))\n\t\treturn mfspr(SPRN_SIAR) + perf_ip_adjust(regs);\n\telse if (use_siar)\n\t\treturn 0;\t\t// no valid instruction pointer\n\telse\n\t\treturn regs->nip;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148348,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "unsigned long perf_instruction_pointer(struct pt_regs *regs)\n{\n\tbool use_siar = regs_use_siar(regs);\n\tunsigned long siar = mfspr(SPRN_SIAR);\n\n\tif (ppmu && (ppmu->flags & PPMU_P10_DD1)) {\n\t\tif (siar)\n\t\t\treturn siar;\n\t\telse\n\t\t\treturn regs->nip;\n\t} else if (use_siar && siar_valid(regs))\n\t\treturn mfspr(SPRN_SIAR) + perf_ip_adjust(regs);\n\telse if (use_siar)\n\t\treturn 0;\t\t// no valid instruction pointer\n\telse\n\t\treturn regs->nip;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148349,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static struct property *dlpar_parse_cc_property(struct cc_workarea *ccwa)\n{\n\tstruct property *prop;\n\tchar *name;\n\tchar *value;\n\n\tprop = kzalloc(sizeof(*prop), GFP_KERNEL);\n\tif (!prop)\n\t\treturn NULL;\n\n\tname = (char *)ccwa + be32_to_cpu(ccwa->name_offset);\n\tprop->name = kstrdup(name, GFP_KERNEL);\n\n\tprop->length = be32_to_cpu(ccwa->prop_length);\n\tvalue = (char *)ccwa + be32_to_cpu(ccwa->prop_offset);\n\tprop->value = kmemdup(value, prop->length, GFP_KERNEL);\n\tif (!prop->value) {\n\t\tdlpar_free_cc_property(prop);\n\t\treturn NULL;\n\t}\n\n\treturn prop;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148374,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static struct property *dlpar_parse_cc_property(struct cc_workarea *ccwa)\n{\n\tstruct property *prop;\n\tchar *name;\n\tchar *value;\n\n\tprop = kzalloc(sizeof(*prop), GFP_KERNEL);\n\tif (!prop)\n\t\treturn NULL;\n\n\tname = (char *)ccwa + be32_to_cpu(ccwa->name_offset);\n\tprop->name = kstrdup(name, GFP_KERNEL);\n\tif (!prop->name) {\n\t\tdlpar_free_cc_property(prop);\n\t\treturn NULL;\n\t}\n\n\tprop->length = be32_to_cpu(ccwa->prop_length);\n\tvalue = (char *)ccwa + be32_to_cpu(ccwa->prop_offset);\n\tprop->value = kmemdup(value, prop->length, GFP_KERNEL);\n\tif (!prop->value) {\n\t\tdlpar_free_cc_property(prop);\n\t\treturn NULL;\n\t}\n\n\treturn prop;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148375,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int llcp_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_dev *dev;\n\tstruct sockaddr_nfc_llcp llcp_addr;\n\tint len, ret = 0;\n\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"sk %p addr %p family %d\\n\", sk, addr, addr->sa_family);\n\n\tmemset(&llcp_addr, 0, sizeof(llcp_addr));\n\tlen = min_t(unsigned int, sizeof(llcp_addr), alen);\n\tmemcpy(&llcp_addr, addr, len);\n\n\t/* This is going to be a listening socket, dsap must be 0 */\n\tif (llcp_addr.dsap != 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != LLCP_CLOSED) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\n\tdev = nfc_get_device(llcp_addr.dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\tllcp_sock->service_name_len = min_t(unsigned int,\n\t\t\t\t\t    llcp_addr.service_name_len,\n\t\t\t\t\t    NFC_LLCP_MAX_SERVICE_NAME);\n\tllcp_sock->service_name = kmemdup(llcp_addr.service_name,\n\t\t\t\t\t  llcp_sock->service_name_len,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!llcp_sock->service_name) {\n\t\tnfc_llcp_local_put(llcp_sock->local);\n\t\tllcp_sock->local = NULL;\n\t\tret = -ENOMEM;\n\t\tgoto put_dev;\n\t}\n\tllcp_sock->ssap = nfc_llcp_get_sdp_ssap(local, llcp_sock);\n\tif (llcp_sock->ssap == LLCP_SAP_MAX) {\n\t\tnfc_llcp_local_put(llcp_sock->local);\n\t\tllcp_sock->local = NULL;\n\t\tkfree(llcp_sock->service_name);\n\t\tllcp_sock->service_name = NULL;\n\t\tret = -EADDRINUSE;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->reserved_ssap = llcp_sock->ssap;\n\n\tnfc_llcp_sock_link(&local->sockets, sk);\n\n\tpr_debug(\"Socket bound to SAP %d\\n\", llcp_sock->ssap);\n\n\tsk->sk_state = LLCP_BOUND;\n\nput_dev:\n\tnfc_put_device(dev);\n\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148386,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int llcp_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_dev *dev;\n\tstruct sockaddr_nfc_llcp llcp_addr;\n\tint len, ret = 0;\n\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"sk %p addr %p family %d\\n\", sk, addr, addr->sa_family);\n\n\tmemset(&llcp_addr, 0, sizeof(llcp_addr));\n\tlen = min_t(unsigned int, sizeof(llcp_addr), alen);\n\tmemcpy(&llcp_addr, addr, len);\n\n\t/* This is going to be a listening socket, dsap must be 0 */\n\tif (llcp_addr.dsap != 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != LLCP_CLOSED) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\n\tdev = nfc_get_device(llcp_addr.dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\tllcp_sock->service_name_len = min_t(unsigned int,\n\t\t\t\t\t    llcp_addr.service_name_len,\n\t\t\t\t\t    NFC_LLCP_MAX_SERVICE_NAME);\n\tllcp_sock->service_name = kmemdup(llcp_addr.service_name,\n\t\t\t\t\t  llcp_sock->service_name_len,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!llcp_sock->service_name) {\n\t\tnfc_llcp_local_put(llcp_sock->local);\n\t\tllcp_sock->local = NULL;\n\t\tllcp_sock->dev = NULL;\n\t\tret = -ENOMEM;\n\t\tgoto put_dev;\n\t}\n\tllcp_sock->ssap = nfc_llcp_get_sdp_ssap(local, llcp_sock);\n\tif (llcp_sock->ssap == LLCP_SAP_MAX) {\n\t\tnfc_llcp_local_put(llcp_sock->local);\n\t\tllcp_sock->local = NULL;\n\t\tkfree(llcp_sock->service_name);\n\t\tllcp_sock->service_name = NULL;\n\t\tllcp_sock->dev = NULL;\n\t\tret = -EADDRINUSE;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->reserved_ssap = llcp_sock->ssap;\n\n\tnfc_llcp_sock_link(&local->sockets, sk);\n\n\tpr_debug(\"Socket bound to SAP %d\\n\", llcp_sock->ssap);\n\n\tsk->sk_state = LLCP_BOUND;\n\nput_dev:\n\tnfc_put_device(dev);\n\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148387,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void get_cmdln_options(int argc, char *argv[]) {\n\tint o;\n#if CONFIG_FILE && HAVE_GETPWUID\n    static struct passwd *pwd_entry;\n    char *str;\n#endif\n#ifdef LONG_OPTIONS\n    int option_index = 0;\n    static struct option long_options[] = {\n        {\"timeout\", 1, 0, 't'},\n#ifdef PROC_NET_DEV\n        {\"procfile\",1,0,'f'},\n#endif\n#ifdef PROC_DISKSTATS\n\t\t\t{\"diskstatsfile\",1,0,1000},\n\t\t\t{\"partitionsfile\",1,0,1001},\n#endif\t\t  \n#if NETSTAT && ALLOW_NETSTATPATH\n        {\"netstat\",1,0,'n'},\n#endif\n#if IOSERVICE_IN\n\t\t  {\"longdisknames\",0,0,1002},\n#endif\n        {\"input\",1,0,'i'},\n        {\"dynamic\",1,0,'d'},\n        {\"help\", 0, 0, 'h'},\n        {\"version\",0,0,'V'},\n        {\"allif\",1,0,'a'},\n        {\"unit\",1,0,'u'},\n\t\t  {\"ansiout\",0,0,'N'},\n#if EXTENDED_STATS        \n        {\"type\",1,0,'T'},\n        {\"avglength\",1,0,'A'},\n#endif        \n        {\"interfaces\",1,0,'I'},\n        {\"sumhidden\",1,0,'S'},\n        {\"output\",1,0,'o'},\n#ifdef CSV\n        {\"csvchar\",1,0,'C'},\n        {\"csvfile\",1,0,'F'},\n#endif\n        {\"count\",1,0,'c'},\n        {\"daemon\",1,0,'D'},\n#ifdef HTML\n        {\"htmlrefresh\",1,0,'R'},\n        {\"htmlheader\",1,0,'H'},\n#endif\n        {0,0,0,0}\n    };\n#endif\n#ifdef CONFIG_FILE\n    /* loop till first non option argument */\n    opterr=0;\n    while (1) {\n#ifdef LONG_OPTIONS\n        o=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n        o=getopt (argc,argv,SHORT_OPTIONS);\n#endif\n        if (o==-1) break;\n    }\n    opterr=1;\n    if (optind < argc) {\n        read_config(argv[optind]);\n    } else {\n        read_config(\"/etc/bwm-ng.conf\");\n#ifdef HAVE_GETPWUID    \n        pwd_entry=getpwuid(getuid());\n        if (pwd_entry!=NULL) {\n            str=(char*)malloc(strlen(pwd_entry->pw_dir)+14);\n            snprintf(str,strlen(pwd_entry->pw_dir)+14,\"%s/.bwm-ng.conf\",pwd_entry->pw_dir);\n            read_config(str);\n            free(str);\n        }\n#endif    \n    }\n    /* reset getopt again  */\n    optind=1;\n#endif\n    /* get command line arguments, kinda ugly, wanna rewrite it? */\n    while (1) {\n#ifdef LONG_OPTIONS\n\t\to=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n\t\to=getopt (argc,argv,SHORT_OPTIONS);\n#endif\t\t\n        if (o==-1) break;\n        switch (o) {\n            case '?': printf(\"unknown option: %s\\n\",argv[optind-1]);\n                      exit(EXIT_FAILURE);\n                      break;\n            /* ugly workaround to handle optional arguments for all platforms */                      \n            case ':': if (!strcmp(argv[optind-1],\"-a\") || !strcasecmp(argv[optind-1],\"--allif\")) \n                            show_all_if=1;\n                      else if (!strcmp(argv[optind-1],\"-d\") || !strcasecmp(argv[optind-1],\"--dynamic\"))\n                            dynamic=1;\n                      else if (!strcmp(argv[optind-1],\"-D\") || !strcasecmp(argv[optind-1],\"--daemon\"))\n                            daemonize=1;\n#ifdef HTML                      \n                      else if (!strcmp(argv[optind-1],\"-H\") || !strcasecmp(argv[optind-1],\"--htmlheader\"))\n                            html_header=1;\n#endif                      \n                      else if (!strcmp(argv[optind-1],\"-S\") || !strcasecmp(argv[optind-1],\"--sumhidden\"))\n                            sumhidden=1;    \n                          else {\n                              printf(\"%s requires an argument!\\n\",argv[optind-1]);\n                              exit(EXIT_FAILURE);\n                          }\n                      break;\n#ifdef PROC_DISKSTATS\n\t\t\tcase 1000:\n\t\t\t\tif (strlen(optarg)<PATH_MAX) \n\t\t\t\t\tstrcpy(PROC_DISKSTATS_FILE,optarg);\n\t\t\t\tbreak;\n         case 1001:\n            if (strlen(optarg)<PATH_MAX)\n               strcpy(PROC_PARTITIONS_FILE,optarg);\n\t\t\t\tbreak;\n#endif\t\t\t\t\n#if IOSERVICE_IN\n\t\t\tcase 1002:\n\t\t\t\tlong_darwin_disk_names=!long_darwin_disk_names;\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'D':\n\t\t\t\tif (optarg) daemonize=atoi(optarg);\n\t\t\t\tbreak;\n#ifdef HTML\n\t\t\tcase 'R':\n\t\t\t\tif ((optarg) && atol(optarg)>0) { html_refresh=atol(optarg); }\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\tif (optarg) html_header=atoi(optarg);\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'c':\n\t\t\t\tif (optarg) output_count=atol(optarg);\n\t\t\t\tbreak;\n#if CSV || HTML\n            case 'F':\n                if (optarg) { \n                    if (out_file) fclose(out_file);\n                    out_file=fopen(optarg,\"a\"); \n                    if (!out_file) deinit(1, \"failed to open outfile\\n\");\n                    if (out_file_path) free(out_file_path);\n                    out_file_path=(char *)strdup(optarg);\n                }\n                break;\n#endif\n#ifdef CSV\n\t\t\tcase 'C':\n\t\t\t\tif (optarg) csv_char=optarg[0];\n\t\t\t\tbreak;\n#endif\n            case 'h':\n                cmdln_printhelp();\n                break;\n#ifdef PROC_NET_DEV\n\t\t\tcase 'f':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(PROC_FILE,optarg);\n                break;\n#endif\t\t\t\n\t\t\tcase 'i':\n                if (optarg) {\n                    input_method=str2in_method(optarg);\n                }\n\t\t\t\tbreak;\t\t\t\t\n            case 'I':\n                if (optarg) iface_list=(char *)strdup(optarg);\n                break;\n            case 'S':\n                if (optarg) sumhidden=atoi(optarg);\n                break;\n            case 'o':\n                if (optarg) {\n                    output_method=str2out_method(optarg);\n                }\n                break;\n\t\t\t\tcase 'N':\n\t\t\t\t\t ansi_output=!ansi_output;\n            case 'a':\n                if (optarg) show_all_if=atoi(optarg);\n                break;\n            case 't':\n                if ((optarg) && atol(optarg)>0) { delay=atol(optarg); }\n                break;\n#if EXTENDED_STATS                \n            case 'T':\n                output_type=str2output_type(optarg);\n                break;\n            case 'A':\n                if (optarg) avg_length=atoi(optarg)*1000;\n                break;\n#endif                \n            case 'd':\n                if (optarg) dynamic=atoi(optarg);\n                break;\n            case 'u':\n                output_unit=str2output_unit(optarg);\n                break;\n#if NETSTAT && ALLOW_NETSTATPATH\n            case 'n':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(NETSTAT_FILE,optarg);\n                break;\n#endif                \n            case 'V':\n                print_version;\n                exit(EXIT_SUCCESS);\n                break;\n        }\n    }\n    if (iface_list==NULL && show_all_if==1) show_all_if=2;\n#if EXTENDED_STATS    \n    /* default init of avg_length */\n    if (avg_length==0) {\n        if (delay<AVG_LENGTH/2) \n            avg_length=AVG_LENGTH; \n        else  \n            avg_length=(delay*2)+1;\n    } else /* avg_length was set via cmdline or config file, better check it */\n        if (delay*2>=avg_length) deinit(1, \"avglength needs to be a least twice the value of timeout\\n\");\n#endif    \n\t if ((output_unit==ERRORS_OUT && !net_input_method(input_method)) || \n\t\t\t (output_unit==PACKETS_OUT && input_method==LIBSTATDISK_IN)) \n\t\toutput_unit=BYTES_OUT;\n    return;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148412,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void get_cmdln_options(int argc, char *argv[]) {\n\tint o;\n#if CONFIG_FILE && HAVE_GETPWUID\n    static struct passwd *pwd_entry;\n    char *str;\n#endif\n#ifdef LONG_OPTIONS\n    int option_index = 0;\n    static struct option long_options[] = {\n        {\"timeout\", 1, 0, 't'},\n#ifdef PROC_NET_DEV\n        {\"procfile\",1,0,'f'},\n#endif\n#ifdef PROC_DISKSTATS\n\t\t\t{\"diskstatsfile\",1,0,1000},\n\t\t\t{\"partitionsfile\",1,0,1001},\n#endif\t\t  \n#if NETSTAT && ALLOW_NETSTATPATH\n        {\"netstat\",1,0,'n'},\n#endif\n#if IOSERVICE_IN\n\t\t  {\"longdisknames\",0,0,1002},\n#endif\n        {\"input\",1,0,'i'},\n        {\"dynamic\",1,0,'d'},\n        {\"help\", 0, 0, 'h'},\n        {\"version\",0,0,'V'},\n        {\"allif\",1,0,'a'},\n        {\"unit\",1,0,'u'},\n\t\t  {\"ansiout\",0,0,'N'},\n#if EXTENDED_STATS        \n        {\"type\",1,0,'T'},\n        {\"avglength\",1,0,'A'},\n#endif        \n        {\"interfaces\",1,0,'I'},\n        {\"sumhidden\",1,0,'S'},\n        {\"output\",1,0,'o'},\n#ifdef CSV\n        {\"csvchar\",1,0,'C'},\n        {\"csvfile\",1,0,'F'},\n#endif\n        {\"count\",1,0,'c'},\n        {\"daemon\",1,0,'D'},\n#ifdef HTML\n        {\"htmlrefresh\",1,0,'R'},\n        {\"htmlheader\",1,0,'H'},\n#endif\n        {0,0,0,0}\n    };\n#endif\n#ifdef CONFIG_FILE\n    /* loop till first non option argument */\n    opterr=0;\n    while (1) {\n#ifdef LONG_OPTIONS\n        o=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n        o=getopt (argc,argv,SHORT_OPTIONS);\n#endif\n        if (o==-1) break;\n    }\n    opterr=1;\n    if (optind < argc) {\n        read_config(argv[optind]);\n    } else {\n        read_config(\"/etc/bwm-ng.conf\");\n#ifdef HAVE_GETPWUID    \n        pwd_entry=getpwuid(getuid());\n        if (pwd_entry!=NULL) {\n            str=(char*)malloc(strlen(pwd_entry->pw_dir)+14);\n            if(!str) {\n              printf(\"Fatal: failed to allocate %zu bytes.\\n\", strlen(pwd_entry->pw_dir)+14);\n              exit(EXIT_FAILURE);\n            }\n            snprintf(str,strlen(pwd_entry->pw_dir)+14,\"%s/.bwm-ng.conf\",pwd_entry->pw_dir);\n            read_config(str);\n            free(str);\n        }\n#endif    \n    }\n    /* reset getopt again  */\n    optind=1;\n#endif\n    /* get command line arguments, kinda ugly, wanna rewrite it? */\n    while (1) {\n#ifdef LONG_OPTIONS\n\t\to=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n\t\to=getopt (argc,argv,SHORT_OPTIONS);\n#endif\t\t\n        if (o==-1) break;\n        switch (o) {\n            case '?': printf(\"unknown option: %s\\n\",argv[optind-1]);\n                      exit(EXIT_FAILURE);\n                      break;\n            /* ugly workaround to handle optional arguments for all platforms */                      \n            case ':': if (!strcmp(argv[optind-1],\"-a\") || !strcasecmp(argv[optind-1],\"--allif\")) \n                            show_all_if=1;\n                      else if (!strcmp(argv[optind-1],\"-d\") || !strcasecmp(argv[optind-1],\"--dynamic\"))\n                            dynamic=1;\n                      else if (!strcmp(argv[optind-1],\"-D\") || !strcasecmp(argv[optind-1],\"--daemon\"))\n                            daemonize=1;\n#ifdef HTML                      \n                      else if (!strcmp(argv[optind-1],\"-H\") || !strcasecmp(argv[optind-1],\"--htmlheader\"))\n                            html_header=1;\n#endif                      \n                      else if (!strcmp(argv[optind-1],\"-S\") || !strcasecmp(argv[optind-1],\"--sumhidden\"))\n                            sumhidden=1;    \n                          else {\n                              printf(\"%s requires an argument!\\n\",argv[optind-1]);\n                              exit(EXIT_FAILURE);\n                          }\n                      break;\n#ifdef PROC_DISKSTATS\n\t\t\tcase 1000:\n\t\t\t\tif (strlen(optarg)<PATH_MAX) \n\t\t\t\t\tstrcpy(PROC_DISKSTATS_FILE,optarg);\n\t\t\t\tbreak;\n         case 1001:\n            if (strlen(optarg)<PATH_MAX)\n               strcpy(PROC_PARTITIONS_FILE,optarg);\n\t\t\t\tbreak;\n#endif\t\t\t\t\n#if IOSERVICE_IN\n\t\t\tcase 1002:\n\t\t\t\tlong_darwin_disk_names=!long_darwin_disk_names;\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'D':\n\t\t\t\tif (optarg) daemonize=atoi(optarg);\n\t\t\t\tbreak;\n#ifdef HTML\n\t\t\tcase 'R':\n\t\t\t\tif ((optarg) && atol(optarg)>0) { html_refresh=atol(optarg); }\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\tif (optarg) html_header=atoi(optarg);\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'c':\n\t\t\t\tif (optarg) output_count=atol(optarg);\n\t\t\t\tbreak;\n#if CSV || HTML\n            case 'F':\n                if (optarg) { \n                    if (out_file) fclose(out_file);\n                    out_file=fopen(optarg,\"a\"); \n                    if (!out_file) deinit(1, \"failed to open outfile\\n\");\n                    if (out_file_path) free(out_file_path);\n                    out_file_path=(char *)strdup(optarg);\n                }\n                break;\n#endif\n#ifdef CSV\n\t\t\tcase 'C':\n\t\t\t\tif (optarg) csv_char=optarg[0];\n\t\t\t\tbreak;\n#endif\n            case 'h':\n                cmdln_printhelp();\n                break;\n#ifdef PROC_NET_DEV\n\t\t\tcase 'f':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(PROC_FILE,optarg);\n                break;\n#endif\t\t\t\n\t\t\tcase 'i':\n                if (optarg) {\n                    input_method=str2in_method(optarg);\n                }\n\t\t\t\tbreak;\t\t\t\t\n            case 'I':\n                if (optarg) iface_list=(char *)strdup(optarg);\n                break;\n            case 'S':\n                if (optarg) sumhidden=atoi(optarg);\n                break;\n            case 'o':\n                if (optarg) {\n                    output_method=str2out_method(optarg);\n                }\n                break;\n\t\t\t\tcase 'N':\n\t\t\t\t\t ansi_output=!ansi_output;\n            case 'a':\n                if (optarg) show_all_if=atoi(optarg);\n                break;\n            case 't':\n                if ((optarg) && atol(optarg)>0) { delay=atol(optarg); }\n                break;\n#if EXTENDED_STATS                \n            case 'T':\n                output_type=str2output_type(optarg);\n                break;\n            case 'A':\n                if (optarg) avg_length=atoi(optarg)*1000;\n                break;\n#endif                \n            case 'd':\n                if (optarg) dynamic=atoi(optarg);\n                break;\n            case 'u':\n                output_unit=str2output_unit(optarg);\n                break;\n#if NETSTAT && ALLOW_NETSTATPATH\n            case 'n':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(NETSTAT_FILE,optarg);\n                break;\n#endif                \n            case 'V':\n                print_version;\n                exit(EXIT_SUCCESS);\n                break;\n        }\n    }\n    if (iface_list==NULL && show_all_if==1) show_all_if=2;\n#if EXTENDED_STATS    \n    /* default init of avg_length */\n    if (avg_length==0) {\n        if (delay<AVG_LENGTH/2) \n            avg_length=AVG_LENGTH; \n        else  \n            avg_length=(delay*2)+1;\n    } else /* avg_length was set via cmdline or config file, better check it */\n        if (delay*2>=avg_length) deinit(1, \"avglength needs to be a least twice the value of timeout\\n\");\n#endif    \n\t if ((output_unit==ERRORS_OUT && !net_input_method(input_method)) || \n\t\t\t (output_unit==PACKETS_OUT && input_method==LIBSTATDISK_IN)) \n\t\toutput_unit=BYTES_OUT;\n    return;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148413,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static Image *ReadSVGImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  const char\n    *option;\n\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next;\n\n  int\n    status,\n    unique_file;\n\n  ssize_t\n    n;\n\n  SVGInfo\n    *svg_info;\n\n  unsigned char\n    message[MagickPathExtent];\n\n  xmlSAXHandler\n    sax_modules;\n\n  xmlSAXHandlerPtr\n    sax_handler;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if ((fabs(image->resolution.x) < MagickEpsilon) ||\n      (fabs(image->resolution.y) < MagickEpsilon))\n    {\n      GeometryInfo\n        geometry_info;\n\n      int\n        flags;\n\n      flags=ParseGeometry(SVGDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  if (LocaleCompare(image_info->magick,\"MSVG\") != 0)\n    {\n      Image\n        *svg_image;\n\n      svg_image=RenderSVGImage(image_info,image,exception);\n      if (svg_image != (Image *) NULL)\n        {\n          image=DestroyImageList(image);\n          return(svg_image);\n        }\n      {\n#if defined(MAGICKCORE_RSVG_DELEGATE)\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n        cairo_surface_t\n          *cairo_surface;\n\n        cairo_t\n          *cairo_image;\n\n        MagickBooleanType\n          apply_density;\n\n        MemoryInfo\n          *pixel_info;\n\n        register unsigned char\n          *p;\n\n        RsvgDimensionData\n          dimension_info;\n\n        unsigned char\n          *pixels;\n\n#else\n        GdkPixbuf\n          *pixel_buffer;\n\n        register const guchar\n          *p;\n#endif\n\n        GError\n          *error;\n\n        PixelInfo\n          fill_color;\n\n        register ssize_t\n          x;\n\n        register Quantum\n          *q;\n\n        RsvgHandle\n          *svg_handle;\n\n        ssize_t\n          y;\n\n        unsigned char\n          *buffer;\n\n        buffer=(unsigned char *) AcquireQuantumMemory(MagickMaxBufferExtent,\n          sizeof(*buffer));\n        if (buffer == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n#if LIBRSVG_CHECK_VERSION(2,40,3)\n        option=GetImageOption(image_info,\"svg:xml-parse-huge\");\n        if ((option != (char *) NULL) && (IsStringTrue(option) != MagickFalse))\n          svg_handle=rsvg_handle_new_with_flags(RSVG_HANDLE_FLAG_UNLIMITED);\n        else\n#endif\n          svg_handle=rsvg_handle_new();\n        if (svg_handle == (RsvgHandle *) NULL)\n          {\n            buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        rsvg_handle_set_base_uri(svg_handle,image_info->filename);\n        if ((fabs(image->resolution.x) > MagickEpsilon) &&\n            (fabs(image->resolution.y) > MagickEpsilon))\n          rsvg_handle_set_dpi_x_y(svg_handle,image->resolution.x,\n            image->resolution.y);\n        while ((n=ReadBlob(image,MagickMaxBufferExtent-1,buffer)) != 0)\n        {\n          buffer[n]='\\0';\n          error=(GError *) NULL;\n          (void) rsvg_handle_write(svg_handle,buffer,n,&error);\n          if (error != (GError *) NULL)\n            g_error_free(error);\n        }\n        buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n        error=(GError *) NULL;\n        rsvg_handle_close(svg_handle,&error);\n        if (error != (GError *) NULL)\n          g_error_free(error);\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n        apply_density=MagickTrue;\n        rsvg_handle_get_dimensions(svg_handle,&dimension_info);\n        if ((image->resolution.x > 0.0) && (image->resolution.y > 0.0))\n          {\n            RsvgDimensionData\n              dpi_dimension_info;\n\n            /*\n              We should not apply the density when the internal 'factor' is 'i'.\n              This can be checked by using the trick below.\n            */\n            rsvg_handle_set_dpi_x_y(svg_handle,image->resolution.x*256,\n              image->resolution.y*256);\n            rsvg_handle_get_dimensions(svg_handle,&dpi_dimension_info);\n            if ((dpi_dimension_info.width != dimension_info.width) ||\n                (dpi_dimension_info.height != dimension_info.height))\n              apply_density=MagickFalse;\n            rsvg_handle_set_dpi_x_y(svg_handle,image->resolution.x,\n              image->resolution.y);\n          }\n        if (image_info->size != (char *) NULL)\n          {\n            (void) GetGeometry(image_info->size,(ssize_t *) NULL,\n              (ssize_t *) NULL,&image->columns,&image->rows);\n            if ((image->columns != 0) || (image->rows != 0))\n              {\n                image->resolution.x=DefaultSVGDensity*image->columns/\n                  dimension_info.width;\n                image->resolution.y=DefaultSVGDensity*image->rows/\n                  dimension_info.height;\n                if (fabs(image->resolution.x) < MagickEpsilon)\n                  image->resolution.x=image->resolution.y;\n                else\n                  if (fabs(image->resolution.y) < MagickEpsilon)\n                    image->resolution.y=image->resolution.x;\n                  else\n                    image->resolution.x=image->resolution.y=MagickMin(\n                      image->resolution.x,image->resolution.y);\n                apply_density=MagickTrue;\n              }\n          }\n        if (apply_density != MagickFalse)\n          {\n            image->columns=image->resolution.x*dimension_info.width/\n              DefaultSVGDensity;\n            image->rows=image->resolution.y*dimension_info.height/\n              DefaultSVGDensity;\n          }\n        else\n          {\n            image->columns=dimension_info.width;\n            image->rows=dimension_info.height;\n          }\n        pixel_info=(MemoryInfo *) NULL;\n#else\n        pixel_buffer=rsvg_handle_get_pixbuf(svg_handle);\n        rsvg_handle_free(svg_handle);\n        image->columns=gdk_pixbuf_get_width(pixel_buffer);\n        image->rows=gdk_pixbuf_get_height(pixel_buffer);\n#endif\n        image->alpha_trait=BlendPixelTrait;\n        if (image_info->ping == MagickFalse)\n          {\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n            size_t\n              stride;\n#endif\n\n            status=SetImageExtent(image,image->columns,image->rows,exception);\n            if (status == MagickFalse)\n              {\n#if !defined(MAGICKCORE_CAIRO_DELEGATE)\n                g_object_unref(G_OBJECT(pixel_buffer));\n#endif\n                g_object_unref(svg_handle);\n                ThrowReaderException(MissingDelegateError,\n                  \"NoDecodeDelegateForThisImageFormat\");\n              }\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n            stride=4*image->columns;\n#if defined(MAGICKCORE_PANGOCAIRO_DELEGATE)\n            stride=(size_t) cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32,\n              (int) image->columns);\n#endif\n            pixel_info=AcquireVirtualMemory(stride,image->rows*sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              {\n                g_object_unref(svg_handle);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n#endif\n            (void) SetImageBackgroundColor(image,exception);\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n            cairo_surface=cairo_image_surface_create_for_data(pixels,\n              CAIRO_FORMAT_ARGB32,(int) image->columns,(int) image->rows,(int)\n              stride);\n            if ((cairo_surface == (cairo_surface_t *) NULL) ||\n                (cairo_surface_status(cairo_surface) != CAIRO_STATUS_SUCCESS))\n              {\n                if (cairo_surface != (cairo_surface_t *) NULL)\n                  cairo_surface_destroy(cairo_surface);\n                pixel_info=RelinquishVirtualMemory(pixel_info);\n                g_object_unref(svg_handle);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n            cairo_image=cairo_create(cairo_surface);\n            cairo_set_operator(cairo_image,CAIRO_OPERATOR_CLEAR);\n            cairo_paint(cairo_image);\n            cairo_set_operator(cairo_image,CAIRO_OPERATOR_OVER);\n            if (apply_density != MagickFalse)\n              cairo_scale(cairo_image,image->resolution.x/DefaultSVGDensity,\n                image->resolution.y/DefaultSVGDensity);\n            rsvg_handle_render_cairo(svg_handle,cairo_image);\n            cairo_destroy(cairo_image);\n            cairo_surface_destroy(cairo_surface);\n            g_object_unref(svg_handle);\n            p=pixels;\n#else\n            p=gdk_pixbuf_get_pixels(pixel_buffer);\n#endif\n            GetPixelInfo(image,&fill_color);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n                fill_color.blue=ScaleCharToQuantum(*p++);\n                fill_color.green=ScaleCharToQuantum(*p++);\n                fill_color.red=ScaleCharToQuantum(*p++);\n#else\n                fill_color.red=ScaleCharToQuantum(*p++);\n                fill_color.green=ScaleCharToQuantum(*p++);\n                fill_color.blue=ScaleCharToQuantum(*p++);\n#endif\n                fill_color.alpha=ScaleCharToQuantum(*p++);\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n                {\n                  double\n                    gamma;\n\n                  gamma=QuantumScale*fill_color.alpha;\n                  gamma=PerceptibleReciprocal(gamma);\n                  fill_color.blue*=gamma;\n                  fill_color.green*=gamma;\n                  fill_color.red*=gamma;\n                }\n#endif\n                CompositePixelOver(image,&fill_color,fill_color.alpha,q,(double)\n                  GetPixelAlpha(image,q),q);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n        if (pixel_info != (MemoryInfo *) NULL)\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n#else\n        g_object_unref(G_OBJECT(pixel_buffer));\n#endif\n        (void) CloseBlob(image);\n        for (next=GetFirstImageInList(image); next != (Image *) NULL; )\n        {\n          (void) CopyMagickString(next->filename,image->filename,MaxTextExtent);\n          (void) CopyMagickString(next->magick,image->magick,MaxTextExtent);\n          next=GetNextImageInList(next);\n        }\n        return(GetFirstImageInList(image));\n#endif\n      }\n    }\n  /*\n    Open draw file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"w\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Parse SVG file.\n  */\n  svg_info=AcquireSVGInfo();\n  if (svg_info == (SVGInfo *) NULL)\n    {\n      (void) fclose(file);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  svg_info->file=file;\n  svg_info->exception=exception;\n  svg_info->image=image;\n  svg_info->image_info=image_info;\n  svg_info->bounds.width=image->columns;\n  svg_info->bounds.height=image->rows;\n  svg_info->svgDepth=0;\n  if (image_info->size != (char *) NULL)\n    (void) CloneString(&svg_info->size,image_info->size);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"begin SAX\");\n  xmlInitParser();\n  (void) xmlSubstituteEntitiesDefault(1);\n  (void) memset(&sax_modules,0,sizeof(sax_modules));\n  sax_modules.internalSubset=SVGInternalSubset;\n  sax_modules.isStandalone=SVGIsStandalone;\n  sax_modules.hasInternalSubset=SVGHasInternalSubset;\n  sax_modules.hasExternalSubset=SVGHasExternalSubset;\n  sax_modules.resolveEntity=SVGResolveEntity;\n  sax_modules.getEntity=SVGGetEntity;\n  sax_modules.entityDecl=SVGEntityDeclaration;\n  sax_modules.notationDecl=SVGNotationDeclaration;\n  sax_modules.attributeDecl=SVGAttributeDeclaration;\n  sax_modules.elementDecl=SVGElementDeclaration;\n  sax_modules.unparsedEntityDecl=SVGUnparsedEntityDeclaration;\n  sax_modules.setDocumentLocator=SVGSetDocumentLocator;\n  sax_modules.startDocument=SVGStartDocument;\n  sax_modules.endDocument=SVGEndDocument;\n  sax_modules.startElement=SVGStartElement;\n  sax_modules.endElement=SVGEndElement;\n  sax_modules.reference=SVGReference;\n  sax_modules.characters=SVGCharacters;\n  sax_modules.ignorableWhitespace=SVGIgnorableWhitespace;\n  sax_modules.processingInstruction=SVGProcessingInstructions;\n  sax_modules.comment=SVGComment;\n  sax_modules.warning=SVGWarning;\n  sax_modules.error=SVGError;\n  sax_modules.fatalError=SVGError;\n  sax_modules.getParameterEntity=SVGGetParameterEntity;\n  sax_modules.cdataBlock=SVGCDataBlock;\n  sax_modules.externalSubset=SVGExternalSubset;\n  sax_handler=(&sax_modules);\n  n=ReadBlob(image,MagickPathExtent-1,message);\n  message[n]='\\0';\n  if (n > 0)\n    {\n      svg_info->parser=xmlCreatePushParserCtxt(sax_handler,svg_info,(char *)\n        message,n,image->filename);\n      option=GetImageOption(image_info,\"svg:xml-parse-huge\");\n      if ((option != (char *) NULL) && (IsStringTrue(option) != MagickFalse))\n        (void) xmlCtxtUseOptions(svg_info->parser,XML_PARSE_HUGE);\n      while ((n=ReadBlob(image,MagickPathExtent-1,message)) != 0)\n      {\n        message[n]='\\0';\n        status=xmlParseChunk(svg_info->parser,(char *) message,(int) n,0);\n        if (status != 0)\n          break;\n      }\n    }\n  (void) xmlParseChunk(svg_info->parser,(char *) message,0,1);\n  SVGEndDocument(svg_info);\n  if (svg_info->parser->myDoc != (xmlDocPtr) NULL)\n    xmlFreeDoc(svg_info->parser->myDoc);\n  xmlFreeParserCtxt(svg_info->parser);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"end SAX\");\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image->columns=svg_info->width;\n  image->rows=svg_info->height;\n  if (exception->severity >= ErrorException)\n    {\n      svg_info=DestroySVGInfo(svg_info);\n      (void) RelinquishUniqueFileResource(filename);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  if (image_info->ping == MagickFalse)\n    {\n      ImageInfo\n        *read_info;\n\n      /*\n        Draw image.\n      */\n      image=DestroyImage(image);\n      image=(Image *) NULL;\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"mvg:%s\",\n        filename);\n      image=ReadImage(read_info,exception);\n      read_info=DestroyImageInfo(read_info);\n      if (image != (Image *) NULL)\n        (void) CopyMagickString(image->filename,image_info->filename,\n          MagickPathExtent);\n    }\n  /*\n    Relinquish resources.\n  */\n  if (image != (Image *) NULL)\n    {\n      if (svg_info->title != (char *) NULL)\n        (void) SetImageProperty(image,\"svg:title\",svg_info->title,exception);\n      if (svg_info->comment != (char *) NULL)\n        (void) SetImageProperty(image,\"svg:comment\",svg_info->comment,\n          exception);\n    }\n  for (next=GetFirstImageInList(image); next != (Image *) NULL; )\n  {\n    (void) CopyMagickString(next->filename,image->filename,MaxTextExtent);\n    (void) CopyMagickString(next->magick,image->magick,MaxTextExtent);\n    next=GetNextImageInList(next);\n  }\n  svg_info=DestroySVGInfo(svg_info);\n  (void) RelinquishUniqueFileResource(filename);\n  return(GetFirstImageInList(image));\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148474,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static Image *ReadSVGImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  const char\n    *option;\n\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next;\n\n  int\n    status,\n    unique_file;\n\n  ssize_t\n    n;\n\n  SVGInfo\n    *svg_info;\n\n  unsigned char\n    message[MagickPathExtent];\n\n  xmlSAXHandler\n    sax_modules;\n\n  xmlSAXHandlerPtr\n    sax_handler;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if ((fabs(image->resolution.x) < MagickEpsilon) ||\n      (fabs(image->resolution.y) < MagickEpsilon))\n    {\n      GeometryInfo\n        geometry_info;\n\n      int\n        flags;\n\n      flags=ParseGeometry(SVGDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  if (LocaleCompare(image_info->magick,\"MSVG\") != 0)\n    {\n      Image\n        *svg_image;\n\n      svg_image=RenderSVGImage(image_info,image,exception);\n      if (svg_image != (Image *) NULL)\n        {\n          image=DestroyImageList(image);\n          return(svg_image);\n        }\n      {\n#if defined(MAGICKCORE_RSVG_DELEGATE)\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n        cairo_surface_t\n          *cairo_surface;\n\n        cairo_t\n          *cairo_image;\n\n        MagickBooleanType\n          apply_density;\n\n        MemoryInfo\n          *pixel_info;\n\n        register unsigned char\n          *p;\n\n        RsvgDimensionData\n          dimension_info;\n\n        unsigned char\n          *pixels;\n\n#else\n        GdkPixbuf\n          *pixel_buffer;\n\n        register const guchar\n          *p;\n#endif\n\n        GError\n          *error;\n\n        PixelInfo\n          fill_color;\n\n        register ssize_t\n          x;\n\n        register Quantum\n          *q;\n\n        RsvgHandle\n          *svg_handle;\n\n        ssize_t\n          y;\n\n        unsigned char\n          *buffer;\n\n        buffer=(unsigned char *) AcquireQuantumMemory(MagickMaxBufferExtent,\n          sizeof(*buffer));\n        if (buffer == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n#if LIBRSVG_CHECK_VERSION(2,40,3)\n        option=GetImageOption(image_info,\"svg:xml-parse-huge\");\n        if ((option != (char *) NULL) && (IsStringTrue(option) != MagickFalse))\n          svg_handle=rsvg_handle_new_with_flags(RSVG_HANDLE_FLAG_UNLIMITED);\n        else\n#endif\n          svg_handle=rsvg_handle_new();\n        if (svg_handle == (RsvgHandle *) NULL)\n          {\n            buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        rsvg_handle_set_base_uri(svg_handle,image_info->filename);\n        if ((fabs(image->resolution.x) > MagickEpsilon) &&\n            (fabs(image->resolution.y) > MagickEpsilon))\n          rsvg_handle_set_dpi_x_y(svg_handle,image->resolution.x,\n            image->resolution.y);\n        while ((n=ReadBlob(image,MagickMaxBufferExtent-1,buffer)) != 0)\n        {\n          buffer[n]='\\0';\n          error=(GError *) NULL;\n          (void) rsvg_handle_write(svg_handle,buffer,n,&error);\n          if (error != (GError *) NULL)\n            g_error_free(error);\n        }\n        buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n        error=(GError *) NULL;\n        rsvg_handle_close(svg_handle,&error);\n        if (error != (GError *) NULL)\n          g_error_free(error);\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n        apply_density=MagickTrue;\n        rsvg_handle_get_dimensions(svg_handle,&dimension_info);\n        if ((image->resolution.x > 0.0) && (image->resolution.y > 0.0))\n          {\n            RsvgDimensionData\n              dpi_dimension_info;\n\n            /*\n              We should not apply the density when the internal 'factor' is 'i'.\n              This can be checked by using the trick below.\n            */\n            rsvg_handle_set_dpi_x_y(svg_handle,image->resolution.x*256,\n              image->resolution.y*256);\n            rsvg_handle_get_dimensions(svg_handle,&dpi_dimension_info);\n            if ((dpi_dimension_info.width != dimension_info.width) ||\n                (dpi_dimension_info.height != dimension_info.height))\n              apply_density=MagickFalse;\n            rsvg_handle_set_dpi_x_y(svg_handle,image->resolution.x,\n              image->resolution.y);\n          }\n        if (image_info->size != (char *) NULL)\n          {\n            (void) GetGeometry(image_info->size,(ssize_t *) NULL,\n              (ssize_t *) NULL,&image->columns,&image->rows);\n            if ((image->columns != 0) || (image->rows != 0))\n              {\n                image->resolution.x=DefaultSVGDensity*image->columns/\n                  dimension_info.width;\n                image->resolution.y=DefaultSVGDensity*image->rows/\n                  dimension_info.height;\n                if (fabs(image->resolution.x) < MagickEpsilon)\n                  image->resolution.x=image->resolution.y;\n                else\n                  if (fabs(image->resolution.y) < MagickEpsilon)\n                    image->resolution.y=image->resolution.x;\n                  else\n                    image->resolution.x=image->resolution.y=MagickMin(\n                      image->resolution.x,image->resolution.y);\n                apply_density=MagickTrue;\n              }\n          }\n        if (apply_density != MagickFalse)\n          {\n            image->columns=image->resolution.x*dimension_info.width/\n              DefaultSVGDensity;\n            image->rows=image->resolution.y*dimension_info.height/\n              DefaultSVGDensity;\n          }\n        else\n          {\n            image->columns=dimension_info.width;\n            image->rows=dimension_info.height;\n          }\n        pixel_info=(MemoryInfo *) NULL;\n#else\n        pixel_buffer=rsvg_handle_get_pixbuf(svg_handle);\n        rsvg_handle_free(svg_handle);\n        image->columns=gdk_pixbuf_get_width(pixel_buffer);\n        image->rows=gdk_pixbuf_get_height(pixel_buffer);\n#endif\n        image->alpha_trait=BlendPixelTrait;\n        if (image_info->ping == MagickFalse)\n          {\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n            size_t\n              stride;\n#endif\n\n            status=SetImageExtent(image,image->columns,image->rows,exception);\n            if (status == MagickFalse)\n              {\n#if !defined(MAGICKCORE_CAIRO_DELEGATE)\n                g_object_unref(G_OBJECT(pixel_buffer));\n#endif\n                g_object_unref(svg_handle);\n                ThrowReaderException(MissingDelegateError,\n                  \"NoDecodeDelegateForThisImageFormat\");\n              }\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n            stride=4*image->columns;\n#if defined(MAGICKCORE_PANGOCAIRO_DELEGATE)\n            stride=(size_t) cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32,\n              (int) image->columns);\n#endif\n            pixel_info=AcquireVirtualMemory(stride,image->rows*sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              {\n                g_object_unref(svg_handle);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n#endif\n            (void) SetImageBackgroundColor(image,exception);\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n            cairo_surface=cairo_image_surface_create_for_data(pixels,\n              CAIRO_FORMAT_ARGB32,(int) image->columns,(int) image->rows,(int)\n              stride);\n            if ((cairo_surface == (cairo_surface_t *) NULL) ||\n                (cairo_surface_status(cairo_surface) != CAIRO_STATUS_SUCCESS))\n              {\n                if (cairo_surface != (cairo_surface_t *) NULL)\n                  cairo_surface_destroy(cairo_surface);\n                pixel_info=RelinquishVirtualMemory(pixel_info);\n                g_object_unref(svg_handle);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n            cairo_image=cairo_create(cairo_surface);\n            cairo_set_operator(cairo_image,CAIRO_OPERATOR_CLEAR);\n            cairo_paint(cairo_image);\n            cairo_set_operator(cairo_image,CAIRO_OPERATOR_OVER);\n            if (apply_density != MagickFalse)\n              cairo_scale(cairo_image,image->resolution.x/DefaultSVGDensity,\n                image->resolution.y/DefaultSVGDensity);\n            rsvg_handle_render_cairo(svg_handle,cairo_image);\n            cairo_destroy(cairo_image);\n            cairo_surface_destroy(cairo_surface);\n            g_object_unref(svg_handle);\n            p=pixels;\n#else\n            p=gdk_pixbuf_get_pixels(pixel_buffer);\n#endif\n            GetPixelInfo(image,&fill_color);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n                fill_color.blue=ScaleCharToQuantum(*p++);\n                fill_color.green=ScaleCharToQuantum(*p++);\n                fill_color.red=ScaleCharToQuantum(*p++);\n#else\n                fill_color.red=ScaleCharToQuantum(*p++);\n                fill_color.green=ScaleCharToQuantum(*p++);\n                fill_color.blue=ScaleCharToQuantum(*p++);\n#endif\n                fill_color.alpha=ScaleCharToQuantum(*p++);\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n                {\n                  double\n                    gamma;\n\n                  gamma=QuantumScale*fill_color.alpha;\n                  gamma=PerceptibleReciprocal(gamma);\n                  fill_color.blue*=gamma;\n                  fill_color.green*=gamma;\n                  fill_color.red*=gamma;\n                }\n#endif\n                CompositePixelOver(image,&fill_color,fill_color.alpha,q,(double)\n                  GetPixelAlpha(image,q),q);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n        if (pixel_info != (MemoryInfo *) NULL)\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n#else\n        g_object_unref(G_OBJECT(pixel_buffer));\n#endif\n        (void) CloseBlob(image);\n        for (next=GetFirstImageInList(image); next != (Image *) NULL; )\n        {\n          (void) CopyMagickString(next->filename,image->filename,MaxTextExtent);\n          (void) CopyMagickString(next->magick,image->magick,MaxTextExtent);\n          next=GetNextImageInList(next);\n        }\n        return(GetFirstImageInList(image));\n#endif\n      }\n    }\n  /*\n    Open draw file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"w\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Parse SVG file.\n  */\n  svg_info=AcquireSVGInfo();\n  if (svg_info == (SVGInfo *) NULL)\n    {\n      (void) fclose(file);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  svg_info->file=file;\n  svg_info->exception=exception;\n  svg_info->image=image;\n  svg_info->image_info=image_info;\n  svg_info->bounds.width=image->columns;\n  svg_info->bounds.height=image->rows;\n  svg_info->svgDepth=0;\n  if (image_info->size != (char *) NULL)\n    (void) CloneString(&svg_info->size,image_info->size);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"begin SAX\");\n  xmlInitParser();\n  (void) xmlSubstituteEntitiesDefault(1);\n  (void) memset(&sax_modules,0,sizeof(sax_modules));\n  sax_modules.internalSubset=SVGInternalSubset;\n  sax_modules.isStandalone=SVGIsStandalone;\n  sax_modules.hasInternalSubset=SVGHasInternalSubset;\n  sax_modules.hasExternalSubset=SVGHasExternalSubset;\n  sax_modules.resolveEntity=SVGResolveEntity;\n  sax_modules.getEntity=SVGGetEntity;\n  sax_modules.entityDecl=SVGEntityDeclaration;\n  sax_modules.notationDecl=SVGNotationDeclaration;\n  sax_modules.attributeDecl=SVGAttributeDeclaration;\n  sax_modules.elementDecl=SVGElementDeclaration;\n  sax_modules.unparsedEntityDecl=SVGUnparsedEntityDeclaration;\n  sax_modules.setDocumentLocator=SVGSetDocumentLocator;\n  sax_modules.startDocument=SVGStartDocument;\n  sax_modules.endDocument=SVGEndDocument;\n  sax_modules.startElement=SVGStartElement;\n  sax_modules.endElement=SVGEndElement;\n  sax_modules.reference=SVGReference;\n  sax_modules.characters=SVGCharacters;\n  sax_modules.ignorableWhitespace=SVGIgnorableWhitespace;\n  sax_modules.processingInstruction=SVGProcessingInstructions;\n  sax_modules.comment=SVGComment;\n  sax_modules.warning=SVGWarning;\n  sax_modules.error=SVGError;\n  sax_modules.fatalError=SVGError;\n  sax_modules.getParameterEntity=SVGGetParameterEntity;\n  sax_modules.cdataBlock=SVGCDataBlock;\n  sax_modules.externalSubset=SVGExternalSubset;\n  sax_handler=(&sax_modules);\n  n=ReadBlob(image,MagickPathExtent-1,message);\n  message[n]='\\0';\n  if (n > 0)\n    {\n      svg_info->parser=xmlCreatePushParserCtxt(sax_handler,svg_info,(char *)\n        message,n,image->filename);\n      if (svg_info->parser != (xmlParserCtxtPtr) NULL)\n        {\n          option=GetImageOption(image_info,\"svg:xml-parse-huge\");\n          if ((option != (char *) NULL) && (IsStringTrue(option) != MagickFalse))\n            (void) xmlCtxtUseOptions(svg_info->parser,XML_PARSE_HUGE);\n          while ((n=ReadBlob(image,MagickPathExtent-1,message)) != 0)\n          {\n            message[n]='\\0';\n            status=xmlParseChunk(svg_info->parser,(char *) message,(int) n,0);\n            if (status != 0)\n              break;\n          }\n        }\n    }\n  if (svg_info->parser == (xmlParserCtxtPtr) NULL)\n    {\n      svg_info=DestroySVGInfo(svg_info);\n      (void) RelinquishUniqueFileResource(filename);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  (void) xmlParseChunk(svg_info->parser,(char *) message,0,1);\n  SVGEndDocument(svg_info);\n  if (svg_info->parser->myDoc != (xmlDocPtr) NULL)\n    xmlFreeDoc(svg_info->parser->myDoc);\n  xmlFreeParserCtxt(svg_info->parser);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"end SAX\");\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image->columns=svg_info->width;\n  image->rows=svg_info->height;\n  if (exception->severity >= ErrorException)\n    {\n      svg_info=DestroySVGInfo(svg_info);\n      (void) RelinquishUniqueFileResource(filename);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  if (image_info->ping == MagickFalse)\n    {\n      ImageInfo\n        *read_info;\n\n      /*\n        Draw image.\n      */\n      image=DestroyImage(image);\n      image=(Image *) NULL;\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"mvg:%s\",\n        filename);\n      image=ReadImage(read_info,exception);\n      read_info=DestroyImageInfo(read_info);\n      if (image != (Image *) NULL)\n        (void) CopyMagickString(image->filename,image_info->filename,\n          MagickPathExtent);\n    }\n  /*\n    Relinquish resources.\n  */\n  if (image != (Image *) NULL)\n    {\n      if (svg_info->title != (char *) NULL)\n        (void) SetImageProperty(image,\"svg:title\",svg_info->title,exception);\n      if (svg_info->comment != (char *) NULL)\n        (void) SetImageProperty(image,\"svg:comment\",svg_info->comment,\n          exception);\n    }\n  for (next=GetFirstImageInList(image); next != (Image *) NULL; )\n  {\n    (void) CopyMagickString(next->filename,image->filename,MaxTextExtent);\n    (void) CopyMagickString(next->magick,image->magick,MaxTextExtent);\n    next=GetNextImageInList(next);\n  }\n  svg_info=DestroySVGInfo(svg_info);\n  (void) RelinquishUniqueFileResource(filename);\n  return(GetFirstImageInList(image));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148475,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "filter_session_io(struct io *io, int evt, void *arg)\n{\n\tstruct filter_session *fs = arg;\n\tchar *line = NULL;\n\tssize_t len;\n\n\tlog_trace(TRACE_IO, \"filter session: %p: %s %s\", fs, io_strevent(evt),\n\t    io_strio(io));\n\n\tswitch (evt) {\n\tcase IO_DATAIN:\n\tnextline:\n\t\tline = io_getline(fs->io, &len);\n\t\t/* No complete line received */\n\t\tif (line == NULL)\n\t\t\treturn;\n\n\t\tfilter_data(fs->id, line);\n\n\t\tgoto nextline;\n\n\tcase IO_DISCONNECTED:\n\t\tio_free(fs->io);\n\t\tfs->io = NULL;\n\t\tbreak;\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148532,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "filter_session_io(struct io *io, int evt, void *arg)\n{\n\tstruct filter_session *fs = arg;\n\tchar *line = NULL;\n\tssize_t len;\n\n\tlog_trace(TRACE_IO, \"filter session: %p: %s %s\", fs, io_strevent(evt),\n\t    io_strio(io));\n\n\tswitch (evt) {\n\tcase IO_DATAIN:\n\tnextline:\n\t\tline = io_getline(fs->io, &len);\n\t\t/* No complete line received */\n\t\tif (line == NULL)\n\t\t\treturn;\n\n\t\tfilter_data(fs->id, line);\n\n\t\tgoto nextline;\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148533,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "sftp_client_message sftp_get_client_message(sftp_session sftp) {\n  ssh_session session = sftp->session;\n  sftp_packet packet;\n  sftp_client_message msg;\n  ssh_buffer payload;\n  int rc;\n\n  msg = malloc(sizeof (struct sftp_client_message_struct));\n  if (msg == NULL) {\n    ssh_set_error_oom(session);\n    return NULL;\n  }\n  ZERO_STRUCTP(msg);\n\n  packet = sftp_packet_read(sftp);\n  if (packet == NULL) {\n    ssh_set_error_oom(session);\n    sftp_client_message_free(msg);\n    return NULL;\n  }\n\n  payload = packet->payload;\n  msg->type = packet->type;\n  msg->sftp = sftp;\n\n  /* take a copy of the whole packet */\n  msg->complete_message = ssh_buffer_new();\n  if (msg->complete_message == NULL) {\n      ssh_set_error_oom(session);\n      sftp_client_message_free(msg);\n      return NULL;\n  }\n\n  ssh_buffer_add_data(msg->complete_message,\n                      ssh_buffer_get(payload),\n                      ssh_buffer_get_len(payload));\n\n  ssh_buffer_get_u32(payload, &msg->id);\n\n  switch(msg->type) {\n    case SSH_FXP_CLOSE:\n    case SSH_FXP_READDIR:\n      msg->handle = ssh_buffer_get_ssh_string(payload);\n      if (msg->handle == NULL) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      break;\n    case SSH_FXP_READ:\n      rc = ssh_buffer_unpack(payload,\n                             \"Sqd\",\n                             &msg->handle,\n                             &msg->offset,\n                             &msg->len);\n      if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      break;\n    case SSH_FXP_WRITE:\n      rc = ssh_buffer_unpack(payload,\n                             \"SqS\",\n                             &msg->handle,\n                             &msg->offset,\n                             &msg->data);\n      if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      break;\n    case SSH_FXP_REMOVE:\n    case SSH_FXP_RMDIR:\n    case SSH_FXP_OPENDIR:\n    case SSH_FXP_READLINK:\n    case SSH_FXP_REALPATH:\n      rc = ssh_buffer_unpack(payload,\n                             \"s\",\n                             &msg->filename);\n      if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      break;\n    case SSH_FXP_RENAME:\n    case SSH_FXP_SYMLINK:\n      rc = ssh_buffer_unpack(payload,\n                             \"sS\",\n                             &msg->filename,\n                             &msg->data);\n      if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      break;\n    case SSH_FXP_MKDIR:\n    case SSH_FXP_SETSTAT:\n      rc = ssh_buffer_unpack(payload,\n                             \"s\",\n                             &msg->filename);\n      if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      msg->attr = sftp_parse_attr(sftp, payload, 0);\n      if (msg->attr == NULL) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      break;\n    case SSH_FXP_FSETSTAT:\n      msg->handle = ssh_buffer_get_ssh_string(payload);\n      if (msg->handle == NULL) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      msg->attr = sftp_parse_attr(sftp, payload, 0);\n      if (msg->attr == NULL) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      break;\n    case SSH_FXP_LSTAT:\n    case SSH_FXP_STAT:\n      rc = ssh_buffer_unpack(payload,\n                             \"s\",\n                             &msg->filename);\n      if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      if(sftp->version > 3) {\n        ssh_buffer_unpack(payload, \"d\", &msg->flags);\n      }\n      break;\n    case SSH_FXP_OPEN:\n      rc = ssh_buffer_unpack(payload,\n                             \"sd\",\n                             &msg->filename,\n                             &msg->flags);\n      if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      msg->attr = sftp_parse_attr(sftp, payload, 0);\n      if (msg->attr == NULL) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      break;\n    case SSH_FXP_FSTAT:\n      rc = ssh_buffer_unpack(payload,\n                             \"S\",\n                             &msg->handle);\n      if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      break;\n    case SSH_FXP_EXTENDED:\n      rc = ssh_buffer_unpack(payload,\n                             \"s\",\n                             &msg->submessage);\n      if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n\n      if (strcmp(msg->submessage, \"hardlink@openssh.com\") == 0 ||\n          strcmp(msg->submessage, \"posix-rename@openssh.com\") == 0) {\n        rc = ssh_buffer_unpack(payload,\n                               \"sS\",\n                               &msg->filename,\n                               &msg->data);\n        if (rc != SSH_OK) {\n          ssh_set_error_oom(session);\n          sftp_client_message_free(msg);\n          return NULL;\n        }\n      }\n      break;\n    default:\n      ssh_set_error(sftp->session, SSH_FATAL,\n                    \"Received unhandled sftp message %d\", msg->type);\n      sftp_client_message_free(msg);\n      return NULL;\n  }\n\n  return msg;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148544,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "sftp_client_message sftp_get_client_message(sftp_session sftp) {\n  ssh_session session = sftp->session;\n  sftp_packet packet;\n  sftp_client_message msg;\n  ssh_buffer payload;\n  int rc;\n\n  msg = malloc(sizeof (struct sftp_client_message_struct));\n  if (msg == NULL) {\n    ssh_set_error_oom(session);\n    return NULL;\n  }\n  ZERO_STRUCTP(msg);\n\n  packet = sftp_packet_read(sftp);\n  if (packet == NULL) {\n    ssh_set_error_oom(session);\n    sftp_client_message_free(msg);\n    return NULL;\n  }\n\n  payload = packet->payload;\n  msg->type = packet->type;\n  msg->sftp = sftp;\n\n  /* take a copy of the whole packet */\n  msg->complete_message = ssh_buffer_new();\n  if (msg->complete_message == NULL) {\n      ssh_set_error_oom(session);\n      sftp_client_message_free(msg);\n      return NULL;\n  }\n\n  rc = ssh_buffer_add_data(msg->complete_message,\n                           ssh_buffer_get(payload),\n                           ssh_buffer_get_len(payload));\n  if (rc < 0) {\n      ssh_set_error_oom(session);\n      sftp_client_message_free(msg);\n      return NULL;\n  }\n\n  ssh_buffer_get_u32(payload, &msg->id);\n\n  switch(msg->type) {\n    case SSH_FXP_CLOSE:\n    case SSH_FXP_READDIR:\n      msg->handle = ssh_buffer_get_ssh_string(payload);\n      if (msg->handle == NULL) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      break;\n    case SSH_FXP_READ:\n      rc = ssh_buffer_unpack(payload,\n                             \"Sqd\",\n                             &msg->handle,\n                             &msg->offset,\n                             &msg->len);\n      if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      break;\n    case SSH_FXP_WRITE:\n      rc = ssh_buffer_unpack(payload,\n                             \"SqS\",\n                             &msg->handle,\n                             &msg->offset,\n                             &msg->data);\n      if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      break;\n    case SSH_FXP_REMOVE:\n    case SSH_FXP_RMDIR:\n    case SSH_FXP_OPENDIR:\n    case SSH_FXP_READLINK:\n    case SSH_FXP_REALPATH:\n      rc = ssh_buffer_unpack(payload,\n                             \"s\",\n                             &msg->filename);\n      if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      break;\n    case SSH_FXP_RENAME:\n    case SSH_FXP_SYMLINK:\n      rc = ssh_buffer_unpack(payload,\n                             \"sS\",\n                             &msg->filename,\n                             &msg->data);\n      if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      break;\n    case SSH_FXP_MKDIR:\n    case SSH_FXP_SETSTAT:\n      rc = ssh_buffer_unpack(payload,\n                             \"s\",\n                             &msg->filename);\n      if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      msg->attr = sftp_parse_attr(sftp, payload, 0);\n      if (msg->attr == NULL) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      break;\n    case SSH_FXP_FSETSTAT:\n      msg->handle = ssh_buffer_get_ssh_string(payload);\n      if (msg->handle == NULL) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      msg->attr = sftp_parse_attr(sftp, payload, 0);\n      if (msg->attr == NULL) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      break;\n    case SSH_FXP_LSTAT:\n    case SSH_FXP_STAT:\n      rc = ssh_buffer_unpack(payload,\n                             \"s\",\n                             &msg->filename);\n      if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      if(sftp->version > 3) {\n        ssh_buffer_unpack(payload, \"d\", &msg->flags);\n      }\n      break;\n    case SSH_FXP_OPEN:\n      rc = ssh_buffer_unpack(payload,\n                             \"sd\",\n                             &msg->filename,\n                             &msg->flags);\n      if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      msg->attr = sftp_parse_attr(sftp, payload, 0);\n      if (msg->attr == NULL) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      break;\n    case SSH_FXP_FSTAT:\n      rc = ssh_buffer_unpack(payload,\n                             \"S\",\n                             &msg->handle);\n      if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n      break;\n    case SSH_FXP_EXTENDED:\n      rc = ssh_buffer_unpack(payload,\n                             \"s\",\n                             &msg->submessage);\n      if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        sftp_client_message_free(msg);\n        return NULL;\n      }\n\n      if (strcmp(msg->submessage, \"hardlink@openssh.com\") == 0 ||\n          strcmp(msg->submessage, \"posix-rename@openssh.com\") == 0) {\n        rc = ssh_buffer_unpack(payload,\n                               \"sS\",\n                               &msg->filename,\n                               &msg->data);\n        if (rc != SSH_OK) {\n          ssh_set_error_oom(session);\n          sftp_client_message_free(msg);\n          return NULL;\n        }\n      }\n      break;\n    default:\n      ssh_set_error(sftp->session, SSH_FATAL,\n                    \"Received unhandled sftp message %d\", msg->type);\n      sftp_client_message_free(msg);\n      return NULL;\n  }\n\n  return msg;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148545,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int multiSelect(\n  Parse *pParse,        /* Parsing context */\n  Select *p,            /* The right-most of SELECTs to be coded */\n  SelectDest *pDest     /* What to do with query results */\n){\n  int rc = SQLITE_OK;   /* Success code from a subroutine */\n  Select *pPrior;       /* Another SELECT immediately to our left */\n  Vdbe *v;              /* Generate code to this VDBE */\n  SelectDest dest;      /* Alternative data destination */\n  Select *pDelete = 0;  /* Chain of simple selects to delete */\n  sqlite3 *db;          /* Database connection */\n\n  /* Make sure there is no ORDER BY or LIMIT clause on prior SELECTs.  Only\n  ** the last (right-most) SELECT in the series may have an ORDER BY or LIMIT.\n  */\n  assert( p && p->pPrior );  /* Calling function guarantees this much */\n  assert( (p->selFlags & SF_Recursive)==0 || p->op==TK_ALL || p->op==TK_UNION );\n  assert( p->selFlags & SF_Compound );\n  db = pParse->db;\n  pPrior = p->pPrior;\n  dest = *pDest;\n  if( pPrior->pOrderBy || pPrior->pLimit ){\n    sqlite3ErrorMsg(pParse,\"%s clause should come after %s not before\",\n      pPrior->pOrderBy!=0 ? \"ORDER BY\" : \"LIMIT\", selectOpName(p->op));\n    rc = 1;\n    goto multi_select_end;\n  }\n\n  v = sqlite3GetVdbe(pParse);\n  assert( v!=0 );  /* The VDBE already created by calling function */\n\n  /* Create the destination temporary table if necessary\n  */\n  if( dest.eDest==SRT_EphemTab ){\n    assert( p->pEList );\n    sqlite3VdbeAddOp2(v, OP_OpenEphemeral, dest.iSDParm, p->pEList->nExpr);\n    dest.eDest = SRT_Table;\n  }\n\n  /* Special handling for a compound-select that originates as a VALUES clause.\n  */\n  if( p->selFlags & SF_MultiValue ){\n    rc = multiSelectValues(pParse, p, &dest);\n    if( rc>=0 ) goto multi_select_end;\n    rc = SQLITE_OK;\n  }\n\n  /* Make sure all SELECTs in the statement have the same number of elements\n  ** in their result sets.\n  */\n  assert( p->pEList && pPrior->pEList );\n  assert( p->pEList->nExpr==pPrior->pEList->nExpr );\n\n#ifndef SQLITE_OMIT_CTE\n  if( p->selFlags & SF_Recursive ){\n    generateWithRecursiveQuery(pParse, p, &dest);\n  }else\n#endif\n\n  /* Compound SELECTs that have an ORDER BY clause are handled separately.\n  */\n  if( p->pOrderBy ){\n    return multiSelectOrderBy(pParse, p, pDest);\n  }else{\n\n#ifndef SQLITE_OMIT_EXPLAIN\n    if( pPrior->pPrior==0 ){\n      ExplainQueryPlan((pParse, 1, \"COMPOUND QUERY\"));\n      ExplainQueryPlan((pParse, 1, \"LEFT-MOST SUBQUERY\"));\n    }\n#endif\n\n    /* Generate code for the left and right SELECT statements.\n    */\n    switch( p->op ){\n      case TK_ALL: {\n        int addr = 0;\n        int nLimit;\n        assert( !pPrior->pLimit );\n        pPrior->iLimit = p->iLimit;\n        pPrior->iOffset = p->iOffset;\n        pPrior->pLimit = p->pLimit;\n        rc = sqlite3Select(pParse, pPrior, &dest);\n        p->pLimit = 0;\n        if( rc ){\n          goto multi_select_end;\n        }\n        p->pPrior = 0;\n        p->iLimit = pPrior->iLimit;\n        p->iOffset = pPrior->iOffset;\n        if( p->iLimit ){\n          addr = sqlite3VdbeAddOp1(v, OP_IfNot, p->iLimit); VdbeCoverage(v);\n          VdbeComment((v, \"Jump ahead if LIMIT reached\"));\n          if( p->iOffset ){\n            sqlite3VdbeAddOp3(v, OP_OffsetLimit,\n                              p->iLimit, p->iOffset+1, p->iOffset);\n          }\n        }\n        ExplainQueryPlan((pParse, 1, \"UNION ALL\"));\n        rc = sqlite3Select(pParse, p, &dest);\n        testcase( rc!=SQLITE_OK );\n        pDelete = p->pPrior;\n        p->pPrior = pPrior;\n        p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n        if( pPrior->pLimit\n         && sqlite3ExprIsInteger(pPrior->pLimit->pLeft, &nLimit)\n         && nLimit>0 && p->nSelectRow > sqlite3LogEst((u64)nLimit) \n        ){\n          p->nSelectRow = sqlite3LogEst((u64)nLimit);\n        }\n        if( addr ){\n          sqlite3VdbeJumpHere(v, addr);\n        }\n        break;\n      }\n      case TK_EXCEPT:\n      case TK_UNION: {\n        int unionTab;    /* Cursor number of the temp table holding result */\n        u8 op = 0;       /* One of the SRT_ operations to apply to self */\n        int priorOp;     /* The SRT_ operation to apply to prior selects */\n        Expr *pLimit;    /* Saved values of p->nLimit  */\n        int addr;\n        SelectDest uniondest;\n  \n        testcase( p->op==TK_EXCEPT );\n        testcase( p->op==TK_UNION );\n        priorOp = SRT_Union;\n        if( dest.eDest==priorOp ){\n          /* We can reuse a temporary table generated by a SELECT to our\n          ** right.\n          */\n          assert( p->pLimit==0 );      /* Not allowed on leftward elements */\n          unionTab = dest.iSDParm;\n        }else{\n          /* We will need to create our own temporary table to hold the\n          ** intermediate results.\n          */\n          unionTab = pParse->nTab++;\n          assert( p->pOrderBy==0 );\n          addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, unionTab, 0);\n          assert( p->addrOpenEphm[0] == -1 );\n          p->addrOpenEphm[0] = addr;\n          findRightmost(p)->selFlags |= SF_UsesEphemeral;\n          assert( p->pEList );\n        }\n  \n        /* Code the SELECT statements to our left\n        */\n        assert( !pPrior->pOrderBy );\n        sqlite3SelectDestInit(&uniondest, priorOp, unionTab);\n        rc = sqlite3Select(pParse, pPrior, &uniondest);\n        if( rc ){\n          goto multi_select_end;\n        }\n  \n        /* Code the current SELECT statement\n        */\n        if( p->op==TK_EXCEPT ){\n          op = SRT_Except;\n        }else{\n          assert( p->op==TK_UNION );\n          op = SRT_Union;\n        }\n        p->pPrior = 0;\n        pLimit = p->pLimit;\n        p->pLimit = 0;\n        uniondest.eDest = op;\n        ExplainQueryPlan((pParse, 1, \"%s USING TEMP B-TREE\",\n                          selectOpName(p->op)));\n        rc = sqlite3Select(pParse, p, &uniondest);\n        testcase( rc!=SQLITE_OK );\n        /* Query flattening in sqlite3Select() might refill p->pOrderBy.\n        ** Be sure to delete p->pOrderBy, therefore, to avoid a memory leak. */\n        sqlite3ExprListDelete(db, p->pOrderBy);\n        pDelete = p->pPrior;\n        p->pPrior = pPrior;\n        p->pOrderBy = 0;\n        if( p->op==TK_UNION ){\n          p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n        }\n        sqlite3ExprDelete(db, p->pLimit);\n        p->pLimit = pLimit;\n        p->iLimit = 0;\n        p->iOffset = 0;\n  \n        /* Convert the data in the temporary table into whatever form\n        ** it is that we currently need.\n        */\n        assert( unionTab==dest.iSDParm || dest.eDest!=priorOp );\n        if( dest.eDest!=priorOp ){\n          int iCont, iBreak, iStart;\n          assert( p->pEList );\n          iBreak = sqlite3VdbeMakeLabel(pParse);\n          iCont = sqlite3VdbeMakeLabel(pParse);\n          computeLimitRegisters(pParse, p, iBreak);\n          sqlite3VdbeAddOp2(v, OP_Rewind, unionTab, iBreak); VdbeCoverage(v);\n          iStart = sqlite3VdbeCurrentAddr(v);\n          selectInnerLoop(pParse, p, unionTab,\n                          0, 0, &dest, iCont, iBreak);\n          sqlite3VdbeResolveLabel(v, iCont);\n          sqlite3VdbeAddOp2(v, OP_Next, unionTab, iStart); VdbeCoverage(v);\n          sqlite3VdbeResolveLabel(v, iBreak);\n          sqlite3VdbeAddOp2(v, OP_Close, unionTab, 0);\n        }\n        break;\n      }\n      default: assert( p->op==TK_INTERSECT ); {\n        int tab1, tab2;\n        int iCont, iBreak, iStart;\n        Expr *pLimit;\n        int addr;\n        SelectDest intersectdest;\n        int r1;\n  \n        /* INTERSECT is different from the others since it requires\n        ** two temporary tables.  Hence it has its own case.  Begin\n        ** by allocating the tables we will need.\n        */\n        tab1 = pParse->nTab++;\n        tab2 = pParse->nTab++;\n        assert( p->pOrderBy==0 );\n  \n        addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab1, 0);\n        assert( p->addrOpenEphm[0] == -1 );\n        p->addrOpenEphm[0] = addr;\n        findRightmost(p)->selFlags |= SF_UsesEphemeral;\n        assert( p->pEList );\n  \n        /* Code the SELECTs to our left into temporary table \"tab1\".\n        */\n        sqlite3SelectDestInit(&intersectdest, SRT_Union, tab1);\n        rc = sqlite3Select(pParse, pPrior, &intersectdest);\n        if( rc ){\n          goto multi_select_end;\n        }\n  \n        /* Code the current SELECT into temporary table \"tab2\"\n        */\n        addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab2, 0);\n        assert( p->addrOpenEphm[1] == -1 );\n        p->addrOpenEphm[1] = addr;\n        p->pPrior = 0;\n        pLimit = p->pLimit;\n        p->pLimit = 0;\n        intersectdest.iSDParm = tab2;\n        ExplainQueryPlan((pParse, 1, \"%s USING TEMP B-TREE\",\n                          selectOpName(p->op)));\n        rc = sqlite3Select(pParse, p, &intersectdest);\n        testcase( rc!=SQLITE_OK );\n        pDelete = p->pPrior;\n        p->pPrior = pPrior;\n        if( p->nSelectRow>pPrior->nSelectRow ){\n          p->nSelectRow = pPrior->nSelectRow;\n        }\n        sqlite3ExprDelete(db, p->pLimit);\n        p->pLimit = pLimit;\n  \n        /* Generate code to take the intersection of the two temporary\n        ** tables.\n        */\n        assert( p->pEList );\n        iBreak = sqlite3VdbeMakeLabel(pParse);\n        iCont = sqlite3VdbeMakeLabel(pParse);\n        computeLimitRegisters(pParse, p, iBreak);\n        sqlite3VdbeAddOp2(v, OP_Rewind, tab1, iBreak); VdbeCoverage(v);\n        r1 = sqlite3GetTempReg(pParse);\n        iStart = sqlite3VdbeAddOp2(v, OP_RowData, tab1, r1);\n        sqlite3VdbeAddOp4Int(v, OP_NotFound, tab2, iCont, r1, 0);\n        VdbeCoverage(v);\n        sqlite3ReleaseTempReg(pParse, r1);\n        selectInnerLoop(pParse, p, tab1,\n                        0, 0, &dest, iCont, iBreak);\n        sqlite3VdbeResolveLabel(v, iCont);\n        sqlite3VdbeAddOp2(v, OP_Next, tab1, iStart); VdbeCoverage(v);\n        sqlite3VdbeResolveLabel(v, iBreak);\n        sqlite3VdbeAddOp2(v, OP_Close, tab2, 0);\n        sqlite3VdbeAddOp2(v, OP_Close, tab1, 0);\n        break;\n      }\n    }\n  \n  #ifndef SQLITE_OMIT_EXPLAIN\n    if( p->pNext==0 ){\n      ExplainQueryPlanPop(pParse);\n    }\n  #endif\n  }\n  \n  /* Compute collating sequences used by \n  ** temporary tables needed to implement the compound select.\n  ** Attach the KeyInfo structure to all temporary tables.\n  **\n  ** This section is run by the right-most SELECT statement only.\n  ** SELECT statements to the left always skip this part.  The right-most\n  ** SELECT might also skip this part if it has no ORDER BY clause and\n  ** no temp tables are required.\n  */\n  if( p->selFlags & SF_UsesEphemeral ){\n    int i;                        /* Loop counter */\n    KeyInfo *pKeyInfo;            /* Collating sequence for the result set */\n    Select *pLoop;                /* For looping through SELECT statements */\n    CollSeq **apColl;             /* For looping through pKeyInfo->aColl[] */\n    int nCol;                     /* Number of columns in result set */\n\n    assert( p->pNext==0 );\n    nCol = p->pEList->nExpr;\n    pKeyInfo = sqlite3KeyInfoAlloc(db, nCol, 1);\n    if( !pKeyInfo ){\n      rc = SQLITE_NOMEM_BKPT;\n      goto multi_select_end;\n    }\n    for(i=0, apColl=pKeyInfo->aColl; i<nCol; i++, apColl++){\n      *apColl = multiSelectCollSeq(pParse, p, i);\n      if( 0==*apColl ){\n        *apColl = db->pDfltColl;\n      }\n    }\n\n    for(pLoop=p; pLoop; pLoop=pLoop->pPrior){\n      for(i=0; i<2; i++){\n        int addr = pLoop->addrOpenEphm[i];\n        if( addr<0 ){\n          /* If [0] is unused then [1] is also unused.  So we can\n          ** always safely abort as soon as the first unused slot is found */\n          assert( pLoop->addrOpenEphm[1]<0 );\n          break;\n        }\n        sqlite3VdbeChangeP2(v, addr, nCol);\n        sqlite3VdbeChangeP4(v, addr, (char*)sqlite3KeyInfoRef(pKeyInfo),\n                            P4_KEYINFO);\n        pLoop->addrOpenEphm[i] = -1;\n      }\n    }\n    sqlite3KeyInfoUnref(pKeyInfo);\n  }\n\nmulti_select_end:\n  pDest->iSdst = dest.iSdst;\n  pDest->nSdst = dest.nSdst;\n  sqlite3SelectDelete(db, pDelete);\n  return rc;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148580,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int multiSelect(\n  Parse *pParse,        /* Parsing context */\n  Select *p,            /* The right-most of SELECTs to be coded */\n  SelectDest *pDest     /* What to do with query results */\n){\n  int rc = SQLITE_OK;   /* Success code from a subroutine */\n  Select *pPrior;       /* Another SELECT immediately to our left */\n  Vdbe *v;              /* Generate code to this VDBE */\n  SelectDest dest;      /* Alternative data destination */\n  Select *pDelete = 0;  /* Chain of simple selects to delete */\n  sqlite3 *db;          /* Database connection */\n\n  /* Make sure there is no ORDER BY or LIMIT clause on prior SELECTs.  Only\n  ** the last (right-most) SELECT in the series may have an ORDER BY or LIMIT.\n  */\n  assert( p && p->pPrior );  /* Calling function guarantees this much */\n  assert( (p->selFlags & SF_Recursive)==0 || p->op==TK_ALL || p->op==TK_UNION );\n  assert( p->selFlags & SF_Compound );\n  db = pParse->db;\n  pPrior = p->pPrior;\n  dest = *pDest;\n  if( pPrior->pOrderBy || pPrior->pLimit ){\n    sqlite3ErrorMsg(pParse,\"%s clause should come after %s not before\",\n      pPrior->pOrderBy!=0 ? \"ORDER BY\" : \"LIMIT\", selectOpName(p->op));\n    rc = 1;\n    goto multi_select_end;\n  }\n\n  v = sqlite3GetVdbe(pParse);\n  assert( v!=0 );  /* The VDBE already created by calling function */\n\n  /* Create the destination temporary table if necessary\n  */\n  if( dest.eDest==SRT_EphemTab ){\n    assert( p->pEList );\n    sqlite3VdbeAddOp2(v, OP_OpenEphemeral, dest.iSDParm, p->pEList->nExpr);\n    dest.eDest = SRT_Table;\n  }\n\n  /* Special handling for a compound-select that originates as a VALUES clause.\n  */\n  if( p->selFlags & SF_MultiValue ){\n    rc = multiSelectValues(pParse, p, &dest);\n    if( rc>=0 ) goto multi_select_end;\n    rc = SQLITE_OK;\n  }\n\n  /* Make sure all SELECTs in the statement have the same number of elements\n  ** in their result sets.\n  */\n  assert( p->pEList && pPrior->pEList );\n  assert( p->pEList->nExpr==pPrior->pEList->nExpr );\n\n#ifndef SQLITE_OMIT_CTE\n  if( p->selFlags & SF_Recursive ){\n    generateWithRecursiveQuery(pParse, p, &dest);\n  }else\n#endif\n\n  /* Compound SELECTs that have an ORDER BY clause are handled separately.\n  */\n  if( p->pOrderBy ){\n    return multiSelectOrderBy(pParse, p, pDest);\n  }else{\n\n#ifndef SQLITE_OMIT_EXPLAIN\n    if( pPrior->pPrior==0 ){\n      ExplainQueryPlan((pParse, 1, \"COMPOUND QUERY\"));\n      ExplainQueryPlan((pParse, 1, \"LEFT-MOST SUBQUERY\"));\n    }\n#endif\n\n    /* Generate code for the left and right SELECT statements.\n    */\n    switch( p->op ){\n      case TK_ALL: {\n        int addr = 0;\n        int nLimit;\n        assert( !pPrior->pLimit );\n        pPrior->iLimit = p->iLimit;\n        pPrior->iOffset = p->iOffset;\n        pPrior->pLimit = p->pLimit;\n        rc = sqlite3Select(pParse, pPrior, &dest);\n        p->pLimit = 0;\n        if( rc ){\n          goto multi_select_end;\n        }\n        p->pPrior = 0;\n        p->iLimit = pPrior->iLimit;\n        p->iOffset = pPrior->iOffset;\n        if( p->iLimit ){\n          addr = sqlite3VdbeAddOp1(v, OP_IfNot, p->iLimit); VdbeCoverage(v);\n          VdbeComment((v, \"Jump ahead if LIMIT reached\"));\n          if( p->iOffset ){\n            sqlite3VdbeAddOp3(v, OP_OffsetLimit,\n                              p->iLimit, p->iOffset+1, p->iOffset);\n          }\n        }\n        ExplainQueryPlan((pParse, 1, \"UNION ALL\"));\n        rc = sqlite3Select(pParse, p, &dest);\n        testcase( rc!=SQLITE_OK );\n        pDelete = p->pPrior;\n        p->pPrior = pPrior;\n        p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n        if( pPrior->pLimit\n         && sqlite3ExprIsInteger(pPrior->pLimit->pLeft, &nLimit)\n         && nLimit>0 && p->nSelectRow > sqlite3LogEst((u64)nLimit) \n        ){\n          p->nSelectRow = sqlite3LogEst((u64)nLimit);\n        }\n        if( addr ){\n          sqlite3VdbeJumpHere(v, addr);\n        }\n        break;\n      }\n      case TK_EXCEPT:\n      case TK_UNION: {\n        int unionTab;    /* Cursor number of the temp table holding result */\n        u8 op = 0;       /* One of the SRT_ operations to apply to self */\n        int priorOp;     /* The SRT_ operation to apply to prior selects */\n        Expr *pLimit;    /* Saved values of p->nLimit  */\n        int addr;\n        SelectDest uniondest;\n  \n        testcase( p->op==TK_EXCEPT );\n        testcase( p->op==TK_UNION );\n        priorOp = SRT_Union;\n        if( dest.eDest==priorOp ){\n          /* We can reuse a temporary table generated by a SELECT to our\n          ** right.\n          */\n          assert( p->pLimit==0 );      /* Not allowed on leftward elements */\n          unionTab = dest.iSDParm;\n        }else{\n          /* We will need to create our own temporary table to hold the\n          ** intermediate results.\n          */\n          unionTab = pParse->nTab++;\n          assert( p->pOrderBy==0 );\n          addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, unionTab, 0);\n          assert( p->addrOpenEphm[0] == -1 );\n          p->addrOpenEphm[0] = addr;\n          findRightmost(p)->selFlags |= SF_UsesEphemeral;\n          assert( p->pEList );\n        }\n  \n        /* Code the SELECT statements to our left\n        */\n        assert( !pPrior->pOrderBy );\n        sqlite3SelectDestInit(&uniondest, priorOp, unionTab);\n        rc = sqlite3Select(pParse, pPrior, &uniondest);\n        if( rc ){\n          goto multi_select_end;\n        }\n  \n        /* Code the current SELECT statement\n        */\n        if( p->op==TK_EXCEPT ){\n          op = SRT_Except;\n        }else{\n          assert( p->op==TK_UNION );\n          op = SRT_Union;\n        }\n        p->pPrior = 0;\n        pLimit = p->pLimit;\n        p->pLimit = 0;\n        uniondest.eDest = op;\n        ExplainQueryPlan((pParse, 1, \"%s USING TEMP B-TREE\",\n                          selectOpName(p->op)));\n        rc = sqlite3Select(pParse, p, &uniondest);\n        testcase( rc!=SQLITE_OK );\n        /* Query flattening in sqlite3Select() might refill p->pOrderBy.\n        ** Be sure to delete p->pOrderBy, therefore, to avoid a memory leak. */\n        sqlite3ExprListDelete(db, p->pOrderBy);\n        pDelete = p->pPrior;\n        p->pPrior = pPrior;\n        p->pOrderBy = 0;\n        if( p->op==TK_UNION ){\n          p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n        }\n        sqlite3ExprDelete(db, p->pLimit);\n        p->pLimit = pLimit;\n        p->iLimit = 0;\n        p->iOffset = 0;\n  \n        /* Convert the data in the temporary table into whatever form\n        ** it is that we currently need.\n        */\n        assert( unionTab==dest.iSDParm || dest.eDest!=priorOp );\n        if( dest.eDest!=priorOp ){\n          int iCont, iBreak, iStart;\n          assert( p->pEList );\n          iBreak = sqlite3VdbeMakeLabel(pParse);\n          iCont = sqlite3VdbeMakeLabel(pParse);\n          computeLimitRegisters(pParse, p, iBreak);\n          sqlite3VdbeAddOp2(v, OP_Rewind, unionTab, iBreak); VdbeCoverage(v);\n          iStart = sqlite3VdbeCurrentAddr(v);\n          selectInnerLoop(pParse, p, unionTab,\n                          0, 0, &dest, iCont, iBreak);\n          sqlite3VdbeResolveLabel(v, iCont);\n          sqlite3VdbeAddOp2(v, OP_Next, unionTab, iStart); VdbeCoverage(v);\n          sqlite3VdbeResolveLabel(v, iBreak);\n          sqlite3VdbeAddOp2(v, OP_Close, unionTab, 0);\n        }\n        break;\n      }\n      default: assert( p->op==TK_INTERSECT ); {\n        int tab1, tab2;\n        int iCont, iBreak, iStart;\n        Expr *pLimit;\n        int addr;\n        SelectDest intersectdest;\n        int r1;\n  \n        /* INTERSECT is different from the others since it requires\n        ** two temporary tables.  Hence it has its own case.  Begin\n        ** by allocating the tables we will need.\n        */\n        tab1 = pParse->nTab++;\n        tab2 = pParse->nTab++;\n        assert( p->pOrderBy==0 );\n  \n        addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab1, 0);\n        assert( p->addrOpenEphm[0] == -1 );\n        p->addrOpenEphm[0] = addr;\n        findRightmost(p)->selFlags |= SF_UsesEphemeral;\n        assert( p->pEList );\n  \n        /* Code the SELECTs to our left into temporary table \"tab1\".\n        */\n        sqlite3SelectDestInit(&intersectdest, SRT_Union, tab1);\n        rc = sqlite3Select(pParse, pPrior, &intersectdest);\n        if( rc ){\n          goto multi_select_end;\n        }\n  \n        /* Code the current SELECT into temporary table \"tab2\"\n        */\n        addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab2, 0);\n        assert( p->addrOpenEphm[1] == -1 );\n        p->addrOpenEphm[1] = addr;\n        p->pPrior = 0;\n        pLimit = p->pLimit;\n        p->pLimit = 0;\n        intersectdest.iSDParm = tab2;\n        ExplainQueryPlan((pParse, 1, \"%s USING TEMP B-TREE\",\n                          selectOpName(p->op)));\n        rc = sqlite3Select(pParse, p, &intersectdest);\n        testcase( rc!=SQLITE_OK );\n        pDelete = p->pPrior;\n        p->pPrior = pPrior;\n        if( p->nSelectRow>pPrior->nSelectRow ){\n          p->nSelectRow = pPrior->nSelectRow;\n        }\n        sqlite3ExprDelete(db, p->pLimit);\n        p->pLimit = pLimit;\n  \n        /* Generate code to take the intersection of the two temporary\n        ** tables.\n        */\n        assert( p->pEList );\n        iBreak = sqlite3VdbeMakeLabel(pParse);\n        iCont = sqlite3VdbeMakeLabel(pParse);\n        computeLimitRegisters(pParse, p, iBreak);\n        sqlite3VdbeAddOp2(v, OP_Rewind, tab1, iBreak); VdbeCoverage(v);\n        r1 = sqlite3GetTempReg(pParse);\n        iStart = sqlite3VdbeAddOp2(v, OP_RowData, tab1, r1);\n        sqlite3VdbeAddOp4Int(v, OP_NotFound, tab2, iCont, r1, 0);\n        VdbeCoverage(v);\n        sqlite3ReleaseTempReg(pParse, r1);\n        selectInnerLoop(pParse, p, tab1,\n                        0, 0, &dest, iCont, iBreak);\n        sqlite3VdbeResolveLabel(v, iCont);\n        sqlite3VdbeAddOp2(v, OP_Next, tab1, iStart); VdbeCoverage(v);\n        sqlite3VdbeResolveLabel(v, iBreak);\n        sqlite3VdbeAddOp2(v, OP_Close, tab2, 0);\n        sqlite3VdbeAddOp2(v, OP_Close, tab1, 0);\n        break;\n      }\n    }\n  \n  #ifndef SQLITE_OMIT_EXPLAIN\n    if( p->pNext==0 ){\n      ExplainQueryPlanPop(pParse);\n    }\n  #endif\n  }\n  if( pParse->nErr ) goto multi_select_end;\n  \n  /* Compute collating sequences used by \n  ** temporary tables needed to implement the compound select.\n  ** Attach the KeyInfo structure to all temporary tables.\n  **\n  ** This section is run by the right-most SELECT statement only.\n  ** SELECT statements to the left always skip this part.  The right-most\n  ** SELECT might also skip this part if it has no ORDER BY clause and\n  ** no temp tables are required.\n  */\n  if( p->selFlags & SF_UsesEphemeral ){\n    int i;                        /* Loop counter */\n    KeyInfo *pKeyInfo;            /* Collating sequence for the result set */\n    Select *pLoop;                /* For looping through SELECT statements */\n    CollSeq **apColl;             /* For looping through pKeyInfo->aColl[] */\n    int nCol;                     /* Number of columns in result set */\n\n    assert( p->pNext==0 );\n    nCol = p->pEList->nExpr;\n    pKeyInfo = sqlite3KeyInfoAlloc(db, nCol, 1);\n    if( !pKeyInfo ){\n      rc = SQLITE_NOMEM_BKPT;\n      goto multi_select_end;\n    }\n    for(i=0, apColl=pKeyInfo->aColl; i<nCol; i++, apColl++){\n      *apColl = multiSelectCollSeq(pParse, p, i);\n      if( 0==*apColl ){\n        *apColl = db->pDfltColl;\n      }\n    }\n\n    for(pLoop=p; pLoop; pLoop=pLoop->pPrior){\n      for(i=0; i<2; i++){\n        int addr = pLoop->addrOpenEphm[i];\n        if( addr<0 ){\n          /* If [0] is unused then [1] is also unused.  So we can\n          ** always safely abort as soon as the first unused slot is found */\n          assert( pLoop->addrOpenEphm[1]<0 );\n          break;\n        }\n        sqlite3VdbeChangeP2(v, addr, nCol);\n        sqlite3VdbeChangeP4(v, addr, (char*)sqlite3KeyInfoRef(pKeyInfo),\n                            P4_KEYINFO);\n        pLoop->addrOpenEphm[i] = -1;\n      }\n    }\n    sqlite3KeyInfoUnref(pKeyInfo);\n  }\n\nmulti_select_end:\n  pDest->iSdst = dest.iSdst;\n  pDest->nSdst = dest.nSdst;\n  sqlite3SelectDelete(db, pDelete);\n  return rc;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148581,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static const char *GetMagickPropertyLetter(const ImageInfo *image_info,\n  Image *image,const char letter)\n{\n  char\n    value[MaxTextExtent];\n\n  const char\n    *string;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  *value='\\0';\n  string=(char *) NULL;\n  switch (letter)\n  {\n    case 'b':\n    {\n      /*\n        Image size read in - in bytes.\n      */\n      (void) FormatMagickSize(image->extent,MagickFalse,value);\n      if (image->extent == 0)\n        (void) FormatMagickSize(GetBlobSize(image),MagickFalse,value);\n      break;\n    }\n    case 'c':\n    {\n      /*\n        Image comment property - empty string by default.\n      */\n      string=GetImageProperty(image,\"comment\");\n      if (string == (const char *) NULL)\n        string=\"\";\n      break;\n    }\n    case 'd':\n    {\n      /*\n        Directory component of filename.\n      */\n      GetPathComponent(image->magick_filename,HeadPath,value);\n      if (*value == '\\0')\n        string=\"\";\n      break;\n    }\n    case 'e':\n    {\n      /*\n        Filename extension (suffix) of image file.\n      */\n      GetPathComponent(image->magick_filename,ExtensionPath,value);\n      if (*value == '\\0')\n        string=\"\";\n      break;\n    }\n    case 'f':\n    {\n      /*\n        Filename without directory component.\n      */\n      GetPathComponent(image->magick_filename,TailPath,value);\n      if (*value == '\\0')\n        string=\"\";\n      break;\n    }\n    case 'g':\n    {\n      /*\n        Image geometry, canvas and offset  %Wx%H+%X+%Y.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20gx%.20g%+.20g%+.20g\",\n        (double) image->page.width,(double) image->page.height,\n        (double) image->page.x,(double) image->page.y);\n      break;\n    }\n    case 'h':\n    {\n      /*\n        Image height (current).\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        (image->rows != 0 ? image->rows : image->magick_rows));\n      break;\n    }\n    case 'i':\n    {\n      /*\n        Filename last used for image (read or write).\n      */\n      string=image->filename;\n      break;\n    }\n    case 'k':\n    {\n      /*\n        Number of unique colors.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        GetNumberColors(image,(FILE *) NULL,&image->exception));\n      break;\n    }\n    case 'l':\n    {\n      /*\n        Image label property - empty string by default.\n      */\n      string=GetImageProperty(image,\"label\");\n      if (string == (const char *) NULL)\n        string=\"\";\n      break;\n    }\n    case 'm':\n    {\n      /*\n        Image format (file magick).\n      */\n      string=image->magick;\n      break;\n    }\n    case 'n':\n    {\n      /*\n        Number of images in the list.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        GetImageListLength(image));\n      break;\n    }\n    case 'o':\n    {\n      /*\n        Output Filename - for delegate use only\n      */\n      string=image_info->filename;\n      break;\n    }\n    case 'p':\n    {\n      /*\n        Image index in current image list -- As 'n' OBSOLETE.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        GetImageIndexInList(image));\n      break;\n    }\n    case 'q':\n    {\n      /*\n        Quantum depth of image in memory.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        MAGICKCORE_QUANTUM_DEPTH);\n      break;\n    }\n    case 'r':\n    {\n      ColorspaceType\n        colorspace;\n\n      /*\n        Image storage class and colorspace.\n      */\n      colorspace=image->colorspace;\n      if ((image->columns != 0) && (image->rows != 0) &&\n          (SetImageGray(image,&image->exception) != MagickFalse))\n        colorspace=GRAYColorspace;\n      (void) FormatLocaleString(value,MaxTextExtent,\"%s %s %s\",\n        CommandOptionToMnemonic(MagickClassOptions,(ssize_t)\n        image->storage_class),CommandOptionToMnemonic(MagickColorspaceOptions,\n        (ssize_t) colorspace),image->matte != MagickFalse ? \"Matte\" : \"\" );\n      break;\n    }\n    case 's':\n    {\n      /*\n        Image scene number.\n      */\n      if (image_info->number_scenes != 0)\n        (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n          image_info->scene);\n      else\n        (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n          image->scene);\n      break;\n    }\n    case 't':\n    {\n      /*\n        Base filename without directory or extension.\n      */\n      GetPathComponent(image->magick_filename,BasePath,value);\n      break;\n    }\n    case 'u':\n    {\n      /*\n        Unique filename.\n      */\n      string=image_info->unique;\n      break;\n    }\n    case 'w':\n    {\n      /*\n        Image width (current).\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        (image->columns != 0 ? image->columns : image->magick_columns));\n      break;\n    }\n    case 'x':\n    {\n      /*\n        Image horizontal resolution.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",\n        fabs(image->x_resolution) > MagickEpsilon ? image->x_resolution : 72.0);\n      break;\n    }\n    case 'y':\n    {\n      /*\n        Image vertical resolution.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",\n        fabs(image->y_resolution) > MagickEpsilon ? image->y_resolution : 72.0);\n      break;\n    }\n    case 'z':\n    {\n      /*\n        Image depth.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        image->depth);\n      break;\n    }\n    case 'A':\n    {\n      /*\n        Image alpha channel.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%s\",\n         CommandOptionToMnemonic(MagickBooleanOptions,(ssize_t) image->matte));\n      break;\n    }\n    case 'B':\n    {\n      /*\n        Image size read in - in bytes.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        image->extent);\n      if (image->extent == 0)\n        (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n          GetBlobSize(image));\n      break;\n    }\n    case 'C':\n    {\n      /*\n        Image compression method.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%s\",\n        CommandOptionToMnemonic(MagickCompressOptions,(ssize_t)\n          image->compression));\n      break;\n    }\n    case 'D':\n    {\n      /*\n        Image dispose method.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%s\",\n        CommandOptionToMnemonic(MagickDisposeOptions,(ssize_t) image->dispose));\n      break;\n    }\n    case 'F':\n    {\n      const char\n        *q;\n\n      register char\n        *p;\n\n      static char\n        whitelist[] =\n          \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 \"\n          \"$-_.+!*'(),{}|\\\\^~[]`\\\"><#%;/?:@&=\";\n\n      /*\n        Magick filename (sanitized) - filename given incl. coder & read mods.\n      */\n      (void) CopyMagickString(value,image->magick_filename,MaxTextExtent);\n      p=value;\n      q=value+strlen(value);\n      for (p+=strspn(p,whitelist); p != q; p+=strspn(p,whitelist))\n        *p='_';\n      break;\n    }\n    case 'G':\n    {\n      /*\n        Image size as geometry = \"%wx%h\".\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20gx%.20g\",(double)\n        image->magick_columns,(double) image->magick_rows);\n      break;\n    }\n    case 'H':\n    {\n      /*\n        Layer canvas height.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        image->page.height);\n      break;\n    }\n    case 'M':\n    {\n      /*\n        Magick filename - filename given incl. coder & read mods.\n      */\n      string=image->magick_filename;\n      break;\n    }\n    case 'O':\n    {\n      /*\n        Layer canvas offset with sign = \"+%X+%Y\".\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%+ld%+ld\",(long)\n        image->page.x,(long) image->page.y);\n      break;\n    }\n    case 'P':\n    {\n      /*\n        Layer canvas page size = \"%Wx%H\".\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20gx%.20g\",(double)\n        image->page.width,(double) image->page.height);\n      break;\n    }\n    case 'Q':\n    {\n      /*\n        Image compression quality.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        (image->quality == 0 ? 92 : image->quality));\n      break;\n    }\n    case 'S':\n    {\n      /*\n        Image scenes.\n      */\n      if (image_info->number_scenes == 0)\n        string=\"2147483647\";\n      else\n        (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n          image_info->scene+image_info->number_scenes);\n      break;\n    }\n    case 'T':\n    {\n      /*\n        Image time delay for animations.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        image->delay);\n      break;\n    }\n    case 'U':\n    {\n      /*\n        Image resolution units.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%s\",\n        CommandOptionToMnemonic(MagickResolutionOptions,(ssize_t)\n          image->units));\n      break;\n    }\n    case 'W':\n    {\n      /*\n        Layer canvas width.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        image->page.width);\n      break;\n    }\n    case 'X':\n    {\n      /*\n        Layer canvas X offset.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%+.20g\",(double)\n        image->page.x);\n      break;\n    }\n    case 'Y':\n    {\n      /*\n        Layer canvas Y offset.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%+.20g\",(double)\n        image->page.y);\n      break;\n    }\n    case 'Z':\n    {\n      /*\n        Zero filename.\n      */\n      string=image_info->zero;\n      break;\n    }\n    case '@':\n    {\n      RectangleInfo\n        page;\n\n      /*\n        Image bounding box.\n      */\n      page=GetImageBoundingBox(image,&image->exception);\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20gx%.20g%+.20g%+.20g\",\n        (double) page.width,(double) page.height,(double) page.x,(double)\n        page.y);\n      break;\n    }\n    case '#':\n    {\n      /*\n        Image signature.\n      */\n      if ((image->columns != 0) && (image->rows != 0))\n        (void) SignatureImage(image);\n      string=GetImageProperty(image,\"signature\");\n      break;\n    }\n    case '%':\n    {\n      /*\n        Percent escaped.\n      */\n      string=\"%\";\n      break;\n    }\n  }\n  if (*value != '\\0')\n    string=value;\n  if (string != (char *) NULL)\n    {\n      (void) SetImageArtifact(image,\"get-property\",string);\n      return(GetImageArtifact(image,\"get-property\"));\n    }\n  return((char *) NULL);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148674,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static const char *GetMagickPropertyLetter(const ImageInfo *image_info,\n  Image *image,const char letter)\n{\n#define WarnNoImageInfoReturn(format,arg) \\\n  if (image_info == (ImageInfo *) NULL ) { \\\n    (void) ThrowMagickException(&image->exception,GetMagickModule(), \\\n      OptionWarning,\"NoImageInfoForProperty\",format,arg); \\\n    return((const char *) NULL); \\\n  }\n\n  char\n    value[MaxTextExtent];\n\n  const char\n    *string;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  *value='\\0';\n  string=(char *) NULL;\n  switch (letter)\n  {\n    case 'b':\n    {\n      /*\n        Image size read in - in bytes.\n      */\n      (void) FormatMagickSize(image->extent,MagickFalse,value);\n      if (image->extent == 0)\n        (void) FormatMagickSize(GetBlobSize(image),MagickFalse,value);\n      break;\n    }\n    case 'c':\n    {\n      /*\n        Image comment property - empty string by default.\n      */\n      string=GetImageProperty(image,\"comment\");\n      if (string == (const char *) NULL)\n        string=\"\";\n      break;\n    }\n    case 'd':\n    {\n      /*\n        Directory component of filename.\n      */\n      GetPathComponent(image->magick_filename,HeadPath,value);\n      if (*value == '\\0')\n        string=\"\";\n      break;\n    }\n    case 'e':\n    {\n      /*\n        Filename extension (suffix) of image file.\n      */\n      GetPathComponent(image->magick_filename,ExtensionPath,value);\n      if (*value == '\\0')\n        string=\"\";\n      break;\n    }\n    case 'f':\n    {\n      /*\n        Filename without directory component.\n      */\n      GetPathComponent(image->magick_filename,TailPath,value);\n      if (*value == '\\0')\n        string=\"\";\n      break;\n    }\n    case 'g':\n    {\n      /*\n        Image geometry, canvas and offset  %Wx%H+%X+%Y.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20gx%.20g%+.20g%+.20g\",\n        (double) image->page.width,(double) image->page.height,\n        (double) image->page.x,(double) image->page.y);\n      break;\n    }\n    case 'h':\n    {\n      /*\n        Image height (current).\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        (image->rows != 0 ? image->rows : image->magick_rows));\n      break;\n    }\n    case 'i':\n    {\n      /*\n        Filename last used for image (read or write).\n      */\n      string=image->filename;\n      break;\n    }\n    case 'k':\n    {\n      /*\n        Number of unique colors.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        GetNumberColors(image,(FILE *) NULL,&image->exception));\n      break;\n    }\n    case 'l':\n    {\n      /*\n        Image label property - empty string by default.\n      */\n      string=GetImageProperty(image,\"label\");\n      if (string == (const char *) NULL)\n        string=\"\";\n      break;\n    }\n    case 'm':\n    {\n      /*\n        Image format (file magick).\n      */\n      string=image->magick;\n      break;\n    }\n    case 'n':\n    {\n      /*\n        Number of images in the list.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        GetImageListLength(image));\n      break;\n    }\n    case 'o':\n    {\n      /*\n        Output Filename - for delegate use only\n      */\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n      string=image_info->filename;\n      break;\n    }\n    case 'p':\n    {\n      /*\n        Image index in current image list -- As 'n' OBSOLETE.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        GetImageIndexInList(image));\n      break;\n    }\n    case 'q':\n    {\n      /*\n        Quantum depth of image in memory.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        MAGICKCORE_QUANTUM_DEPTH);\n      break;\n    }\n    case 'r':\n    {\n      ColorspaceType\n        colorspace;\n\n      /*\n        Image storage class and colorspace.\n      */\n      colorspace=image->colorspace;\n      if ((image->columns != 0) && (image->rows != 0) &&\n          (SetImageGray(image,&image->exception) != MagickFalse))\n        colorspace=GRAYColorspace;\n      (void) FormatLocaleString(value,MaxTextExtent,\"%s %s %s\",\n        CommandOptionToMnemonic(MagickClassOptions,(ssize_t)\n        image->storage_class),CommandOptionToMnemonic(MagickColorspaceOptions,\n        (ssize_t) colorspace),image->matte != MagickFalse ? \"Matte\" : \"\" );\n      break;\n    }\n    case 's':\n    {\n      /*\n        Image scene number.\n      */\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n      if (image_info->number_scenes != 0)\n        (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n          image_info->scene);\n      else\n        (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n          image->scene);\n      break;\n    }\n    case 't':\n    {\n      /*\n        Base filename without directory or extension.\n      */\n      GetPathComponent(image->magick_filename,BasePath,value);\n      break;\n    }\n    case 'u':\n    {\n      /*\n        Unique filename.\n      */\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n      string=image_info->unique;\n      break;\n    }\n    case 'w':\n    {\n      /*\n        Image width (current).\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        (image->columns != 0 ? image->columns : image->magick_columns));\n      break;\n    }\n    case 'x':\n    {\n      /*\n        Image horizontal resolution.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",\n        fabs(image->x_resolution) > MagickEpsilon ? image->x_resolution : 72.0);\n      break;\n    }\n    case 'y':\n    {\n      /*\n        Image vertical resolution.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",\n        fabs(image->y_resolution) > MagickEpsilon ? image->y_resolution : 72.0);\n      break;\n    }\n    case 'z':\n    {\n      /*\n        Image depth.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        image->depth);\n      break;\n    }\n    case 'A':\n    {\n      /*\n        Image alpha channel.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%s\",\n         CommandOptionToMnemonic(MagickBooleanOptions,(ssize_t) image->matte));\n      break;\n    }\n    case 'B':\n    {\n      /*\n        Image size read in - in bytes.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        image->extent);\n      if (image->extent == 0)\n        (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n          GetBlobSize(image));\n      break;\n    }\n    case 'C':\n    {\n      /*\n        Image compression method.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%s\",\n        CommandOptionToMnemonic(MagickCompressOptions,(ssize_t)\n          image->compression));\n      break;\n    }\n    case 'D':\n    {\n      /*\n        Image dispose method.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%s\",\n        CommandOptionToMnemonic(MagickDisposeOptions,(ssize_t) image->dispose));\n      break;\n    }\n    case 'F':\n    {\n      const char\n        *q;\n\n      register char\n        *p;\n\n      static char\n        whitelist[] =\n          \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 \"\n          \"$-_.+!*'(),{}|\\\\^~[]`\\\"><#%;/?:@&=\";\n\n      /*\n        Magick filename (sanitized) - filename given incl. coder & read mods.\n      */\n      (void) CopyMagickString(value,image->magick_filename,MaxTextExtent);\n      p=value;\n      q=value+strlen(value);\n      for (p+=strspn(p,whitelist); p != q; p+=strspn(p,whitelist))\n        *p='_';\n      break;\n    }\n    case 'G':\n    {\n      /*\n        Image size as geometry = \"%wx%h\".\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20gx%.20g\",(double)\n        image->magick_columns,(double) image->magick_rows);\n      break;\n    }\n    case 'H':\n    {\n      /*\n        Layer canvas height.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        image->page.height);\n      break;\n    }\n    case 'M':\n    {\n      /*\n        Magick filename - filename given incl. coder & read mods.\n      */\n      string=image->magick_filename;\n      break;\n    }\n    case 'O':\n    {\n      /*\n        Layer canvas offset with sign = \"+%X+%Y\".\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%+ld%+ld\",(long)\n        image->page.x,(long) image->page.y);\n      break;\n    }\n    case 'P':\n    {\n      /*\n        Layer canvas page size = \"%Wx%H\".\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20gx%.20g\",(double)\n        image->page.width,(double) image->page.height);\n      break;\n    }\n    case 'Q':\n    {\n      /*\n        Image compression quality.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        (image->quality == 0 ? 92 : image->quality));\n      break;\n    }\n    case 'S':\n    {\n      /*\n        Image scenes.\n      */\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n      if (image_info->number_scenes == 0)\n        string=\"2147483647\";\n      else\n        (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n          image_info->scene+image_info->number_scenes);\n      break;\n    }\n    case 'T':\n    {\n      /*\n        Image time delay for animations.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        image->delay);\n      break;\n    }\n    case 'U':\n    {\n      /*\n        Image resolution units.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%s\",\n        CommandOptionToMnemonic(MagickResolutionOptions,(ssize_t)\n          image->units));\n      break;\n    }\n    case 'W':\n    {\n      /*\n        Layer canvas width.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n        image->page.width);\n      break;\n    }\n    case 'X':\n    {\n      /*\n        Layer canvas X offset.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%+.20g\",(double)\n        image->page.x);\n      break;\n    }\n    case 'Y':\n    {\n      /*\n        Layer canvas Y offset.\n      */\n      (void) FormatLocaleString(value,MaxTextExtent,\"%+.20g\",(double)\n        image->page.y);\n      break;\n    }\n    case 'Z':\n    {\n      /*\n        Zero filename.\n      */\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n      string=image_info->zero;\n      break;\n    }\n    case '@':\n    {\n      RectangleInfo\n        page;\n\n      /*\n        Image bounding box.\n      */\n      page=GetImageBoundingBox(image,&image->exception);\n      (void) FormatLocaleString(value,MaxTextExtent,\"%.20gx%.20g%+.20g%+.20g\",\n        (double) page.width,(double) page.height,(double) page.x,(double)\n        page.y);\n      break;\n    }\n    case '#':\n    {\n      /*\n        Image signature.\n      */\n      if ((image->columns != 0) && (image->rows != 0))\n        (void) SignatureImage(image);\n      string=GetImageProperty(image,\"signature\");\n      break;\n    }\n    case '%':\n    {\n      /*\n        Percent escaped.\n      */\n      string=\"%\";\n      break;\n    }\n  }\n  if (*value != '\\0')\n    string=value;\n  if (string != (char *) NULL)\n    {\n      (void) SetImageArtifact(image,\"get-property\",string);\n      return(GetImageArtifact(image,\"get-property\"));\n    }\n  return((char *) NULL);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148675,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n\trows = form->rows ? form->rows : 1;\n\tcol = COLPOS(l, a->start.pos);\n\tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n\t    if (rows > 1) {\n\t\tpos = columnPos(l, col);\n\t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len || spos < 0 || epos < 0)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148676,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (buf->currentLine == NULL ||\n\t    spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n\trows = form->rows ? form->rows : 1;\n\tcol = COLPOS(l, a->start.pos);\n\tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n\t    if (rows > 1) {\n\t\tpos = columnPos(l, col);\n\t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len || spos < 0 || epos < 0)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148677,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "open_ssl_connection (rfbClient *client, int sockfd, rfbBool anonTLS, rfbCredential *cred)\n{\n  SSL_CTX *ssl_ctx = NULL;\n  SSL *ssl = NULL;\n  int n, finished = 0;\n  X509_VERIFY_PARAM *param;\n  uint8_t verify_crls = cred->x509Credential.x509CrlVerifyMode;\n\n  if (!(ssl_ctx = SSL_CTX_new(SSLv23_client_method())))\n  {\n    rfbClientLog(\"Could not create new SSL context.\\n\");\n    return NULL;\n  }\n\n  param = X509_VERIFY_PARAM_new();\n\n  /* Setup verification if not anonymous */\n  if (!anonTLS)\n  {\n    if (cred->x509Credential.x509CACertFile)\n    {\n      if (!SSL_CTX_load_verify_locations(ssl_ctx, cred->x509Credential.x509CACertFile, NULL))\n      {\n        rfbClientLog(\"Failed to load CA certificate from %s.\\n\",\n                     cred->x509Credential.x509CACertFile);\n        goto error_free_ctx;\n      }\n    } else {\n      rfbClientLog(\"Using default paths for certificate verification.\\n\");\n      SSL_CTX_set_default_verify_paths (ssl_ctx);\n    }\n\n    if (cred->x509Credential.x509CACrlFile)\n    {\n      if (!load_crls_from_file(cred->x509Credential.x509CACrlFile, ssl_ctx))\n      {\n        rfbClientLog(\"CRLs could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n      if (verify_crls == rfbX509CrlVerifyNone) verify_crls = rfbX509CrlVerifyAll;\n    }\n\n    if (cred->x509Credential.x509ClientCertFile && cred->x509Credential.x509ClientKeyFile)\n    {\n      if (SSL_CTX_use_certificate_chain_file(ssl_ctx, cred->x509Credential.x509ClientCertFile) != 1)\n      {\n        rfbClientLog(\"Client certificate could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_use_PrivateKey_file(ssl_ctx, cred->x509Credential.x509ClientKeyFile,\n                                      SSL_FILETYPE_PEM) != 1)\n      {\n        rfbClientLog(\"Client private key could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_check_private_key(ssl_ctx) == 0) {\n        rfbClientLog(\"Client certificate and private key do not match.\\n\");\n        goto error_free_ctx;\n      }\n    }\n\n    SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);\n\n    if (verify_crls == rfbX509CrlVerifyClient) \n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK);\n    else if (verify_crls == rfbX509CrlVerifyAll)\n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n\n    if(!X509_VERIFY_PARAM_set1_host(param, client->serverHost, strlen(client->serverHost)))\n    {\n      rfbClientLog(\"Could not set server name for verification.\\n\");\n      goto error_free_ctx;\n    }\n    SSL_CTX_set1_param(ssl_ctx, param);\n  }\n\n  if (!(ssl = SSL_new (ssl_ctx)))\n  {\n    rfbClientLog(\"Could not create a new SSL session.\\n\");\n    goto error_free_ctx;\n  }\n\n  /* TODO: finetune this list, take into account anonTLS bool */\n  SSL_set_cipher_list(ssl, \"ALL\");\n\n  SSL_set_fd (ssl, sockfd);\n  SSL_CTX_set_app_data (ssl_ctx, client);\n\n  do\n  {\n    n = SSL_connect(ssl);\n\t\t\n    if (n != 1) \n    {\n      if (wait_for_data(ssl, n, 1) != 1) \n      {\n        finished = 1;\n        SSL_shutdown(ssl);\n\n        goto error_free_ssl;\n      }\n    }\n  } while( n != 1 && finished != 1 );\n\n  X509_VERIFY_PARAM_free(param);\n  return ssl;\n\nerror_free_ssl:\n  SSL_free(ssl);\n\nerror_free_ctx:\n  X509_VERIFY_PARAM_free(param);\n  SSL_CTX_free(ssl_ctx);\n\n  return NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148686,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "open_ssl_connection (rfbClient *client, int sockfd, rfbBool anonTLS, rfbCredential *cred)\n{\n  SSL_CTX *ssl_ctx = NULL;\n  SSL *ssl = NULL;\n  int n, finished = 0;\n  X509_VERIFY_PARAM *param;\n  uint8_t verify_crls;\n\n  if (!(ssl_ctx = SSL_CTX_new(SSLv23_client_method())))\n  {\n    rfbClientLog(\"Could not create new SSL context.\\n\");\n    return NULL;\n  }\n\n  param = X509_VERIFY_PARAM_new();\n\n  /* Setup verification if not anonymous */\n  if (!anonTLS)\n  {\n    verify_crls = cred->x509Credential.x509CrlVerifyMode;\n    if (cred->x509Credential.x509CACertFile)\n    {\n      if (!SSL_CTX_load_verify_locations(ssl_ctx, cred->x509Credential.x509CACertFile, NULL))\n      {\n        rfbClientLog(\"Failed to load CA certificate from %s.\\n\",\n                     cred->x509Credential.x509CACertFile);\n        goto error_free_ctx;\n      }\n    } else {\n      rfbClientLog(\"Using default paths for certificate verification.\\n\");\n      SSL_CTX_set_default_verify_paths (ssl_ctx);\n    }\n\n    if (cred->x509Credential.x509CACrlFile)\n    {\n      if (!load_crls_from_file(cred->x509Credential.x509CACrlFile, ssl_ctx))\n      {\n        rfbClientLog(\"CRLs could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n      if (verify_crls == rfbX509CrlVerifyNone) verify_crls = rfbX509CrlVerifyAll;\n    }\n\n    if (cred->x509Credential.x509ClientCertFile && cred->x509Credential.x509ClientKeyFile)\n    {\n      if (SSL_CTX_use_certificate_chain_file(ssl_ctx, cred->x509Credential.x509ClientCertFile) != 1)\n      {\n        rfbClientLog(\"Client certificate could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_use_PrivateKey_file(ssl_ctx, cred->x509Credential.x509ClientKeyFile,\n                                      SSL_FILETYPE_PEM) != 1)\n      {\n        rfbClientLog(\"Client private key could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_check_private_key(ssl_ctx) == 0) {\n        rfbClientLog(\"Client certificate and private key do not match.\\n\");\n        goto error_free_ctx;\n      }\n    }\n\n    SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);\n\n    if (verify_crls == rfbX509CrlVerifyClient) \n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK);\n    else if (verify_crls == rfbX509CrlVerifyAll)\n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n\n    if(!X509_VERIFY_PARAM_set1_host(param, client->serverHost, strlen(client->serverHost)))\n    {\n      rfbClientLog(\"Could not set server name for verification.\\n\");\n      goto error_free_ctx;\n    }\n    SSL_CTX_set1_param(ssl_ctx, param);\n  }\n\n  if (!(ssl = SSL_new (ssl_ctx)))\n  {\n    rfbClientLog(\"Could not create a new SSL session.\\n\");\n    goto error_free_ctx;\n  }\n\n  /* TODO: finetune this list, take into account anonTLS bool */\n  SSL_set_cipher_list(ssl, \"ALL\");\n\n  SSL_set_fd (ssl, sockfd);\n  SSL_CTX_set_app_data (ssl_ctx, client);\n\n  do\n  {\n    n = SSL_connect(ssl);\n\t\t\n    if (n != 1) \n    {\n      if (wait_for_data(ssl, n, 1) != 1) \n      {\n        finished = 1;\n        SSL_shutdown(ssl);\n\n        goto error_free_ssl;\n      }\n    }\n  } while( n != 1 && finished != 1 );\n\n  X509_VERIFY_PARAM_free(param);\n  return ssl;\n\nerror_free_ssl:\n  SSL_free(ssl);\n\nerror_free_ctx:\n  X509_VERIFY_PARAM_free(param);\n  SSL_CTX_free(ssl_ctx);\n\n  return NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148687,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "long keyctl_session_to_parent(void)\n{\n#ifdef TIF_NOTIFY_RESUME\n\tstruct task_struct *me, *parent;\n\tconst struct cred *mycred, *pcred;\n\tstruct cred *cred, *oldcred;\n\tkey_ref_t keyring_r;\n\tint ret;\n\n\tkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_LINK);\n\tif (IS_ERR(keyring_r))\n\t\treturn PTR_ERR(keyring_r);\n\n\t/* our parent is going to need a new cred struct, a new tgcred struct\n\t * and new security data, so we allocate them here to prevent ENOMEM in\n\t * our parent */\n\tret = -ENOMEM;\n\tcred = cred_alloc_blank();\n\tif (!cred)\n\t\tgoto error_keyring;\n\n\tcred->tgcred->session_keyring = key_ref_to_ptr(keyring_r);\n\tkeyring_r = NULL;\n\n\tme = current;\n\trcu_read_lock();\n\twrite_lock_irq(&tasklist_lock);\n\n\tparent = me->real_parent;\n\tret = -EPERM;\n\n\t/* the parent mustn't be init and mustn't be a kernel thread */\n\tif (parent->pid <= 1 || !parent->mm)\n\t\tgoto not_permitted;\n\n\t/* the parent must be single threaded */\n\tif (!thread_group_empty(parent))\n\t\tgoto not_permitted;\n\n\t/* the parent and the child must have different session keyrings or\n\t * there's no point */\n\tmycred = current_cred();\n\tpcred = __task_cred(parent);\n\tif (mycred == pcred ||\n\t    mycred->tgcred->session_keyring == pcred->tgcred->session_keyring)\n\t\tgoto already_same;\n\n\t/* the parent must have the same effective ownership and mustn't be\n\t * SUID/SGID */\n\tif (pcred->uid\t!= mycred->euid\t||\n\t    pcred->euid\t!= mycred->euid\t||\n\t    pcred->suid\t!= mycred->euid\t||\n\t    pcred->gid\t!= mycred->egid\t||\n\t    pcred->egid\t!= mycred->egid\t||\n\t    pcred->sgid\t!= mycred->egid)\n\t\tgoto not_permitted;\n\n\t/* the keyrings must have the same UID */\n\tif (pcred->tgcred->session_keyring->uid != mycred->euid ||\n\t    mycred->tgcred->session_keyring->uid != mycred->euid)\n\t\tgoto not_permitted;\n\n\t/* if there's an already pending keyring replacement, then we replace\n\t * that */\n\toldcred = parent->replacement_session_keyring;\n\n\t/* the replacement session keyring is applied just prior to userspace\n\t * restarting */\n\tparent->replacement_session_keyring = cred;\n\tcred = NULL;\n\tset_ti_thread_flag(task_thread_info(parent), TIF_NOTIFY_RESUME);\n\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tif (oldcred)\n\t\tput_cred(oldcred);\n\treturn 0;\n\nalready_same:\n\tret = 0;\nnot_permitted:\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tput_cred(cred);\n\treturn ret;\n\nerror_keyring:\n\tkey_ref_put(keyring_r);\n\treturn ret;\n\n#else /* !TIF_NOTIFY_RESUME */\n\t/*\n\t * To be removed when TIF_NOTIFY_RESUME has been implemented on\n\t * m68k/xtensa\n\t */\n#warning TIF_NOTIFY_RESUME not implemented\n\treturn -EOPNOTSUPP;\n#endif /* !TIF_NOTIFY_RESUME */\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148734,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "long keyctl_session_to_parent(void)\n{\n#ifdef TIF_NOTIFY_RESUME\n\tstruct task_struct *me, *parent;\n\tconst struct cred *mycred, *pcred;\n\tstruct cred *cred, *oldcred;\n\tkey_ref_t keyring_r;\n\tint ret;\n\n\tkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_LINK);\n\tif (IS_ERR(keyring_r))\n\t\treturn PTR_ERR(keyring_r);\n\n\t/* our parent is going to need a new cred struct, a new tgcred struct\n\t * and new security data, so we allocate them here to prevent ENOMEM in\n\t * our parent */\n\tret = -ENOMEM;\n\tcred = cred_alloc_blank();\n\tif (!cred)\n\t\tgoto error_keyring;\n\n\tcred->tgcred->session_keyring = key_ref_to_ptr(keyring_r);\n\tkeyring_r = NULL;\n\n\tme = current;\n\trcu_read_lock();\n\twrite_lock_irq(&tasklist_lock);\n\n\tparent = me->real_parent;\n\tret = -EPERM;\n\n\t/* the parent mustn't be init and mustn't be a kernel thread */\n\tif (parent->pid <= 1 || !parent->mm)\n\t\tgoto not_permitted;\n\n\t/* the parent must be single threaded */\n\tif (!thread_group_empty(parent))\n\t\tgoto not_permitted;\n\n\t/* the parent and the child must have different session keyrings or\n\t * there's no point */\n\tmycred = current_cred();\n\tpcred = __task_cred(parent);\n\tif (mycred == pcred ||\n\t    mycred->tgcred->session_keyring == pcred->tgcred->session_keyring)\n\t\tgoto already_same;\n\n\t/* the parent must have the same effective ownership and mustn't be\n\t * SUID/SGID */\n\tif (pcred->uid\t!= mycred->euid\t||\n\t    pcred->euid\t!= mycred->euid\t||\n\t    pcred->suid\t!= mycred->euid\t||\n\t    pcred->gid\t!= mycred->egid\t||\n\t    pcred->egid\t!= mycred->egid\t||\n\t    pcred->sgid\t!= mycred->egid)\n\t\tgoto not_permitted;\n\n\t/* the keyrings must have the same UID */\n\tif ((pcred->tgcred->session_keyring &&\n\t     pcred->tgcred->session_keyring->uid != mycred->euid) ||\n\t    mycred->tgcred->session_keyring->uid != mycred->euid)\n\t\tgoto not_permitted;\n\n\t/* if there's an already pending keyring replacement, then we replace\n\t * that */\n\toldcred = parent->replacement_session_keyring;\n\n\t/* the replacement session keyring is applied just prior to userspace\n\t * restarting */\n\tparent->replacement_session_keyring = cred;\n\tcred = NULL;\n\tset_ti_thread_flag(task_thread_info(parent), TIF_NOTIFY_RESUME);\n\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tif (oldcred)\n\t\tput_cred(oldcred);\n\treturn 0;\n\nalready_same:\n\tret = 0;\nnot_permitted:\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tput_cred(cred);\n\treturn ret;\n\nerror_keyring:\n\tkey_ref_put(keyring_r);\n\treturn ret;\n\n#else /* !TIF_NOTIFY_RESUME */\n\t/*\n\t * To be removed when TIF_NOTIFY_RESUME has been implemented on\n\t * m68k/xtensa\n\t */\n#warning TIF_NOTIFY_RESUME not implemented\n\treturn -EOPNOTSUPP;\n#endif /* !TIF_NOTIFY_RESUME */\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148735,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int ssl3_send_client_key_exchange(SSL *s)\n\t{\n\tunsigned char *p,*d;\n\tint n;\n\tunsigned long l;\n#ifndef OPENSSL_NO_RSA\n\tunsigned char *q;\n\tEVP_PKEY *pkey=NULL;\n#endif\n#ifndef OPENSSL_NO_KRB5\n\tKSSL_ERR kssl_err;\n#endif /* OPENSSL_NO_KRB5 */\n#ifndef OPENSSL_NO_ECDH\n\tEC_KEY *clnt_ecdh = NULL;\n\tconst EC_POINT *srvr_ecpoint = NULL;\n\tEVP_PKEY *srvr_pub_pkey = NULL;\n\tunsigned char *encodedPoint = NULL;\n\tint encoded_pt_len = 0;\n\tBN_CTX * bn_ctx = NULL;\n#endif\n\n\tif (s->state == SSL3_ST_CW_KEY_EXCH_A)\n\t\t{\n\t\td=(unsigned char *)s->init_buf->data;\n\t\tp= &(d[4]);\n\n\t\tl=s->s3->tmp.new_cipher->algorithms;\n\n\t\t/* Fool emacs indentation */\n\t\tif (0) {}\n#ifndef OPENSSL_NO_RSA\n\t\telse if (l & SSL_kRSA)\n\t\t\t{\n\t\t\tRSA *rsa;\n\t\t\tunsigned char tmp_buf[SSL_MAX_MASTER_KEY_LENGTH];\n\n\t\t\tif (s->session->sess_cert->peer_rsa_tmp != NULL)\n\t\t\t\trsa=s->session->sess_cert->peer_rsa_tmp;\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n\t\t\t\tif ((pkey == NULL) ||\n\t\t\t\t\t(pkey->type != EVP_PKEY_RSA) ||\n\t\t\t\t\t(pkey->pkey.rsa == NULL))\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\trsa=pkey->pkey.rsa;\n\t\t\t\tEVP_PKEY_free(pkey);\n\t\t\t\t}\n\t\t\t\t\n\t\t\ttmp_buf[0]=s->client_version>>8;\n\t\t\ttmp_buf[1]=s->client_version&0xff;\n\t\t\tif (RAND_bytes(&(tmp_buf[2]),sizeof tmp_buf-2) <= 0)\n\t\t\t\t\tgoto err;\n\n\t\t\ts->session->master_key_length=sizeof tmp_buf;\n\n\t\t\tq=p;\n\t\t\t/* Fix buf for TLS and beyond */\n\t\t\tif (s->version > SSL3_VERSION)\n\t\t\t\tp+=2;\n\t\t\tn=RSA_public_encrypt(sizeof tmp_buf,\n\t\t\t\ttmp_buf,p,rsa,RSA_PKCS1_PADDING);\n#ifdef PKCS1_CHECK\n\t\t\tif (s->options & SSL_OP_PKCS1_CHECK_1) p[1]++;\n\t\t\tif (s->options & SSL_OP_PKCS1_CHECK_2) tmp_buf[0]=0x70;\n#endif\n\t\t\tif (n <= 0)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_BAD_RSA_ENCRYPT);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t/* Fix buf for TLS and beyond */\n\t\t\tif (s->version > SSL3_VERSION)\n\t\t\t\t{\n\t\t\t\ts2n(n,q);\n\t\t\t\tn+=2;\n\t\t\t\t}\n\n\t\t\ts->session->master_key_length=\n\t\t\t\ts->method->ssl3_enc->generate_master_secret(s,\n\t\t\t\t\ts->session->master_key,\n\t\t\t\t\ttmp_buf,sizeof tmp_buf);\n\t\t\tOPENSSL_cleanse(tmp_buf,sizeof tmp_buf);\n\t\t\t}\n#endif\n#ifndef OPENSSL_NO_KRB5\n\t\telse if (l & SSL_kKRB5)\n\t\t\t{\n\t\t\tkrb5_error_code\tkrb5rc;\n\t\t\tKSSL_CTX\t*kssl_ctx = s->kssl_ctx;\n\t\t\t/*  krb5_data\tkrb5_ap_req;  */\n\t\t\tkrb5_data\t*enc_ticket;\n\t\t\tkrb5_data\tauthenticator, *authp = NULL;\n\t\t\tEVP_CIPHER_CTX\tciph_ctx;\n\t\t\tEVP_CIPHER\t*enc = NULL;\n\t\t\tunsigned char\tiv[EVP_MAX_IV_LENGTH];\n\t\t\tunsigned char\ttmp_buf[SSL_MAX_MASTER_KEY_LENGTH];\n\t\t\tunsigned char\tepms[SSL_MAX_MASTER_KEY_LENGTH \n\t\t\t\t\t\t+ EVP_MAX_IV_LENGTH];\n\t\t\tint \t\tpadl, outl = sizeof(epms);\n\n\t\t\tEVP_CIPHER_CTX_init(&ciph_ctx);\n\n#ifdef KSSL_DEBUG\n\t\t\tprintf(\"ssl3_send_client_key_exchange(%lx & %lx)\\n\",\n\t\t\t        l, SSL_kKRB5);\n#endif\t/* KSSL_DEBUG */\n\n\t\t\tauthp = NULL;\n#ifdef KRB5SENDAUTH\n\t\t\tif (KRB5SENDAUTH)  authp = &authenticator;\n#endif\t/* KRB5SENDAUTH */\n\n\t\t\tkrb5rc = kssl_cget_tkt(kssl_ctx, &enc_ticket, authp,\n\t\t\t\t&kssl_err);\n\t\t\tenc = kssl_map_enc(kssl_ctx->enctype);\n\t\t\tif (enc == NULL)\n\t\t\t    goto err;\n#ifdef KSSL_DEBUG\n\t\t\t{\n\t\t\tprintf(\"kssl_cget_tkt rtn %d\\n\", krb5rc);\n\t\t\tif (krb5rc && kssl_err.text)\n\t\t\t  printf(\"kssl_cget_tkt kssl_err=%s\\n\", kssl_err.text);\n\t\t\t}\n#endif\t/* KSSL_DEBUG */\n\n\t\t\tif (krb5rc)\n\t\t\t\t{\n\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,\n\t\t\t\t\t\tSSL_AD_HANDSHAKE_FAILURE);\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n\t\t\t\t\t\tkssl_err.reason);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t/*  20010406 VRS - Earlier versions used KRB5 AP_REQ\n\t\t\t**  in place of RFC 2712 KerberosWrapper, as in:\n\t\t\t**\n\t\t\t**  Send ticket (copy to *p, set n = length)\n\t\t\t**  n = krb5_ap_req.length;\n\t\t\t**  memcpy(p, krb5_ap_req.data, krb5_ap_req.length);\n\t\t\t**  if (krb5_ap_req.data)  \n\t\t\t**    kssl_krb5_free_data_contents(NULL,&krb5_ap_req);\n\t\t\t**\n\t\t\t**  Now using real RFC 2712 KerberosWrapper\n\t\t\t**  (Thanks to Simon Wilkinson <sxw@sxw.org.uk>)\n\t\t\t**  Note: 2712 \"opaque\" types are here replaced\n\t\t\t**  with a 2-byte length followed by the value.\n\t\t\t**  Example:\n\t\t\t**  KerberosWrapper= xx xx asn1ticket 0 0 xx xx encpms\n\t\t\t**  Where \"xx xx\" = length bytes.  Shown here with\n\t\t\t**  optional authenticator omitted.\n\t\t\t*/\n\n\t\t\t/*  KerberosWrapper.Ticket\t\t*/\n\t\t\ts2n(enc_ticket->length,p);\n\t\t\tmemcpy(p, enc_ticket->data, enc_ticket->length);\n\t\t\tp+= enc_ticket->length;\n\t\t\tn = enc_ticket->length + 2;\n\n\t\t\t/*  KerberosWrapper.Authenticator\t*/\n\t\t\tif (authp  &&  authp->length)  \n\t\t\t\t{\n\t\t\t\ts2n(authp->length,p);\n\t\t\t\tmemcpy(p, authp->data, authp->length);\n\t\t\t\tp+= authp->length;\n\t\t\t\tn+= authp->length + 2;\n\t\t\t\t\n\t\t\t\tfree(authp->data);\n\t\t\t\tauthp->data = NULL;\n\t\t\t\tauthp->length = 0;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ts2n(0,p);/*  null authenticator length\t*/\n\t\t\t\tn+=2;\n\t\t\t\t}\n \n\t\t\t    tmp_buf[0]=s->client_version>>8;\n\t\t\t    tmp_buf[1]=s->client_version&0xff;\n\t\t\t    if (RAND_bytes(&(tmp_buf[2]),sizeof tmp_buf-2) <= 0)\n\t\t\t\tgoto err;\n\n\t\t\t/*  20010420 VRS.  Tried it this way; failed.\n\t\t\t**\tEVP_EncryptInit_ex(&ciph_ctx,enc, NULL,NULL);\n\t\t\t**\tEVP_CIPHER_CTX_set_key_length(&ciph_ctx,\n\t\t\t**\t\t\t\tkssl_ctx->length);\n\t\t\t**\tEVP_EncryptInit_ex(&ciph_ctx,NULL, key,iv);\n\t\t\t*/\n\n\t\t\tmemset(iv, 0, sizeof iv);  /* per RFC 1510 */\n\t\t\tEVP_EncryptInit_ex(&ciph_ctx,enc, NULL,\n\t\t\t\tkssl_ctx->key,iv);\n\t\t\tEVP_EncryptUpdate(&ciph_ctx,epms,&outl,tmp_buf,\n\t\t\t\tsizeof tmp_buf);\n\t\t\tEVP_EncryptFinal_ex(&ciph_ctx,&(epms[outl]),&padl);\n\t\t\toutl += padl;\n\t\t\tif (outl > sizeof epms)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tEVP_CIPHER_CTX_cleanup(&ciph_ctx);\n\n\t\t\t/*  KerberosWrapper.EncryptedPreMasterSecret\t*/\n\t\t\ts2n(outl,p);\n\t\t\tmemcpy(p, epms, outl);\n\t\t\tp+=outl;\n\t\t\tn+=outl + 2;\n\n\t\t\ts->session->master_key_length=\n\t\t\t        s->method->ssl3_enc->generate_master_secret(s,\n\t\t\t\t\ts->session->master_key,\n\t\t\t\t\ttmp_buf, sizeof tmp_buf);\n\n\t\t\tOPENSSL_cleanse(tmp_buf, sizeof tmp_buf);\n\t\t\tOPENSSL_cleanse(epms, outl);\n\t\t\t}\n#endif\n#ifndef OPENSSL_NO_DH\n\t\telse if (l & (SSL_kEDH|SSL_kDHr|SSL_kDHd))\n\t\t\t{\n\t\t\tDH *dh_srvr,*dh_clnt;\n\n\t\t\tif (s->session->sess_cert == NULL) \n\t\t\t\t{\n\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\t\t\tgoto err;\n\t\t\t        }\n\n\t\t\tif (s->session->sess_cert->peer_dh_tmp != NULL)\n\t\t\t\tdh_srvr=s->session->sess_cert->peer_dh_tmp;\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t/* we get them from the cert */\n\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_DH_PARAMETERS);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\n\t\t\t/* generate a new random key */\n\t\t\tif ((dh_clnt=DHparams_dup(dh_srvr)) == NULL)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tif (!DH_generate_key(dh_clnt))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t/* use the 'p' output buffer for the DH key, but\n\t\t\t * make sure to clear it out afterwards */\n\n\t\t\tn=DH_compute_key(p,dh_srvr->pub_key,dh_clnt);\n\n\t\t\tif (n <= 0)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t/* generate master key from the result */\n\t\t\ts->session->master_key_length=\n\t\t\t\ts->method->ssl3_enc->generate_master_secret(s,\n\t\t\t\t\ts->session->master_key,p,n);\n\t\t\t/* clean up */\n\t\t\tmemset(p,0,n);\n\n\t\t\t/* send off the data */\n\t\t\tn=BN_num_bytes(dh_clnt->pub_key);\n\t\t\ts2n(n,p);\n\t\t\tBN_bn2bin(dh_clnt->pub_key,p);\n\t\t\tn+=2;\n\n\t\t\tDH_free(dh_clnt);\n\n\t\t\t/* perhaps clean things up a bit EAY EAY EAY EAY*/\n\t\t\t}\n#endif\n\n#ifndef OPENSSL_NO_ECDH \n\t\telse if ((l & SSL_kECDH) || (l & SSL_kECDHE))\n\t\t\t{\n\t\t\tconst EC_GROUP *srvr_group = NULL;\n\t\t\tEC_KEY *tkey;\n\t\t\tint ecdh_clnt_cert = 0;\n\t\t\tint field_size = 0;\n\n\t\t\t/* Did we send out the client's\n\t\t\t * ECDH share for use in premaster\n\t\t\t * computation as part of client certificate?\n\t\t\t * If so, set ecdh_clnt_cert to 1.\n\t\t\t */\n\t\t\tif ((l & SSL_kECDH) && (s->cert != NULL)) \n\t\t\t\t{\n\t\t\t\t/* XXX: For now, we do not support client\n\t\t\t\t * authentication using ECDH certificates.\n\t\t\t\t * To add such support, one needs to add\n\t\t\t\t * code that checks for appropriate \n\t\t\t\t * conditions and sets ecdh_clnt_cert to 1.\n\t\t\t\t * For example, the cert have an ECC\n\t\t\t\t * key on the same curve as the server's\n\t\t\t\t * and the key should be authorized for\n\t\t\t\t * key agreement.\n\t\t\t\t *\n\t\t\t\t * One also needs to add code in ssl3_connect\n\t\t\t\t * to skip sending the certificate verify\n\t\t\t\t * message.\n\t\t\t\t *\n\t\t\t\t * if ((s->cert->key->privatekey != NULL) &&\n\t\t\t\t *     (s->cert->key->privatekey->type ==\n\t\t\t\t *      EVP_PKEY_EC) && ...)\n\t\t\t\t * ecdh_clnt_cert = 1;\n\t\t\t\t */\n\t\t\t\t}\n\n\t\t\tif (s->session->sess_cert->peer_ecdh_tmp != NULL)\n\t\t\t\t{\n\t\t\t\ttkey = s->session->sess_cert->peer_ecdh_tmp;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t/* Get the Server Public Key from Cert */\n\t\t\t\tsrvr_pub_pkey = X509_get_pubkey(s->session-> \\\n\t\t\t\t    sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);\n\t\t\t\tif ((srvr_pub_pkey == NULL) ||\n\t\t\t\t    (srvr_pub_pkey->type != EVP_PKEY_EC) ||\n\t\t\t\t    (srvr_pub_pkey->pkey.ec == NULL))\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n\t\t\t\t\t    ERR_R_INTERNAL_ERROR);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\n\t\t\t\ttkey = srvr_pub_pkey->pkey.ec;\n\t\t\t\t}\n\n\t\t\tsrvr_group   = EC_KEY_get0_group(tkey);\n\t\t\tsrvr_ecpoint = EC_KEY_get0_public_key(tkey);\n\n\t\t\tif ((srvr_group == NULL) || (srvr_ecpoint == NULL))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n\t\t\t\t    ERR_R_INTERNAL_ERROR);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\tif ((clnt_ecdh=EC_KEY_new()) == NULL) \n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\tif (!EC_KEY_set_group(clnt_ecdh, srvr_group))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tif (ecdh_clnt_cert) \n\t\t\t\t{ \n\t\t\t\t/* Reuse key info from our certificate\n\t\t\t\t * We only need our private key to perform\n\t\t\t\t * the ECDH computation.\n\t\t\t\t */\n\t\t\t\tconst BIGNUM *priv_key;\n\t\t\t\ttkey = s->cert->key->privatekey->pkey.ec;\n\t\t\t\tpriv_key = EC_KEY_get0_private_key(tkey);\n\t\t\t\tif (priv_key == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\tif (!EC_KEY_set_private_key(clnt_ecdh, priv_key))\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_EC_LIB);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse \n\t\t\t\t{\n\t\t\t\t/* Generate a new ECDH key pair */\n\t\t\t\tif (!(EC_KEY_generate_key(clnt_ecdh)))\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_ECDH_LIB);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t/* use the 'p' output buffer for the ECDH key, but\n\t\t\t * make sure to clear it out afterwards\n\t\t\t */\n\n\t\t\tfield_size = EC_GROUP_get_degree(srvr_group);\n\t\t\tif (field_size <= 0)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, \n\t\t\t\t       ERR_R_ECDH_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tn=ECDH_compute_key(p, (field_size+7)/8, srvr_ecpoint, clnt_ecdh, NULL);\n\t\t\tif (n <= 0)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, \n\t\t\t\t       ERR_R_ECDH_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t/* generate master key from the result */\n\t\t\ts->session->master_key_length = s->method->ssl3_enc \\\n\t\t\t    -> generate_master_secret(s, \n\t\t\t\ts->session->master_key,\n\t\t\t\tp, n);\n\n\t\t\tmemset(p, 0, n); /* clean up */\n\n\t\t\tif (ecdh_clnt_cert) \n\t\t\t\t{\n\t\t\t\t/* Send empty client key exch message */\n\t\t\t\tn = 0;\n\t\t\t\t}\n\t\t\telse \n\t\t\t\t{\n\t\t\t\t/* First check the size of encoding and\n\t\t\t\t * allocate memory accordingly.\n\t\t\t\t */\n\t\t\t\tencoded_pt_len = \n\t\t\t\t    EC_POINT_point2oct(srvr_group, \n\t\t\t\t\tEC_KEY_get0_public_key(clnt_ecdh), \n\t\t\t\t\tPOINT_CONVERSION_UNCOMPRESSED, \n\t\t\t\t\tNULL, 0, NULL);\n\n\t\t\t\tencodedPoint = (unsigned char *) \n\t\t\t\t    OPENSSL_malloc(encoded_pt_len * \n\t\t\t\t\tsizeof(unsigned char)); \n\t\t\t\tbn_ctx = BN_CTX_new();\n\t\t\t\tif ((encodedPoint == NULL) || \n\t\t\t\t    (bn_ctx == NULL)) \n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\n\t\t\t\t/* Encode the public key */\n\t\t\t\tn = EC_POINT_point2oct(srvr_group, \n\t\t\t\t    EC_KEY_get0_public_key(clnt_ecdh), \n\t\t\t\t    POINT_CONVERSION_UNCOMPRESSED, \n\t\t\t\t    encodedPoint, encoded_pt_len, bn_ctx);\n\n\t\t\t\t*p = n; /* length of encoded point */\n\t\t\t\t/* Encoded point will be copied here */\n\t\t\t\tp += 1; \n\t\t\t\t/* copy the point */\n\t\t\t\tmemcpy((unsigned char *)p, encodedPoint, n);\n\t\t\t\t/* increment n to account for length field */\n\t\t\t\tn += 1; \n\t\t\t\t}\n\n\t\t\t/* Free allocated memory */\n\t\t\tBN_CTX_free(bn_ctx);\n\t\t\tif (encodedPoint != NULL) OPENSSL_free(encodedPoint);\n\t\t\tif (clnt_ecdh != NULL) \n\t\t\t\t EC_KEY_free(clnt_ecdh);\n\t\t\tEVP_PKEY_free(srvr_pub_pkey);\n\t\t\t}\n#endif /* !OPENSSL_NO_ECDH */\n\t\telse\n\t\t\t{\n\t\t\tssl3_send_alert(s, SSL3_AL_FATAL,\n\t\t\t    SSL_AD_HANDSHAKE_FAILURE);\n\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n\t\t\t    ERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\t\n\t\t*(d++)=SSL3_MT_CLIENT_KEY_EXCHANGE;\n\t\tl2n3(n,d);\n\n\t\ts->state=SSL3_ST_CW_KEY_EXCH_B;\n\t\t/* number of bytes to write */\n\t\ts->init_num=n+4;\n\t\ts->init_off=0;\n\t\t}\n\n\t/* SSL3_ST_CW_KEY_EXCH_B */\n\treturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\nerr:\n#ifndef OPENSSL_NO_ECDH\n\tBN_CTX_free(bn_ctx);\n\tif (encodedPoint != NULL) OPENSSL_free(encodedPoint);\n\tif (clnt_ecdh != NULL) \n\t\tEC_KEY_free(clnt_ecdh);\n\tEVP_PKEY_free(srvr_pub_pkey);\n#endif\n\treturn(-1);\n\t}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148746,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int ssl3_send_client_key_exchange(SSL *s)\n\t{\n\tunsigned char *p,*d;\n\tint n;\n\tunsigned long l;\n#ifndef OPENSSL_NO_RSA\n\tunsigned char *q;\n\tEVP_PKEY *pkey=NULL;\n#endif\n#ifndef OPENSSL_NO_KRB5\n\tKSSL_ERR kssl_err;\n#endif /* OPENSSL_NO_KRB5 */\n#ifndef OPENSSL_NO_ECDH\n\tEC_KEY *clnt_ecdh = NULL;\n\tconst EC_POINT *srvr_ecpoint = NULL;\n\tEVP_PKEY *srvr_pub_pkey = NULL;\n\tunsigned char *encodedPoint = NULL;\n\tint encoded_pt_len = 0;\n\tBN_CTX * bn_ctx = NULL;\n#endif\n\n\tif (s->state == SSL3_ST_CW_KEY_EXCH_A)\n\t\t{\n\t\td=(unsigned char *)s->init_buf->data;\n\t\tp= &(d[4]);\n\n\t\tl=s->s3->tmp.new_cipher->algorithms;\n\n\t\t/* Fool emacs indentation */\n\t\tif (0) {}\n#ifndef OPENSSL_NO_RSA\n\t\telse if (l & SSL_kRSA)\n\t\t\t{\n\t\t\tRSA *rsa;\n\t\t\tunsigned char tmp_buf[SSL_MAX_MASTER_KEY_LENGTH];\n\n\t\t\tif (s->session->sess_cert->peer_rsa_tmp != NULL)\n\t\t\t\trsa=s->session->sess_cert->peer_rsa_tmp;\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n\t\t\t\tif ((pkey == NULL) ||\n\t\t\t\t\t(pkey->type != EVP_PKEY_RSA) ||\n\t\t\t\t\t(pkey->pkey.rsa == NULL))\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\trsa=pkey->pkey.rsa;\n\t\t\t\tEVP_PKEY_free(pkey);\n\t\t\t\t}\n\t\t\t\t\n\t\t\ttmp_buf[0]=s->client_version>>8;\n\t\t\ttmp_buf[1]=s->client_version&0xff;\n\t\t\tif (RAND_bytes(&(tmp_buf[2]),sizeof tmp_buf-2) <= 0)\n\t\t\t\t\tgoto err;\n\n\t\t\ts->session->master_key_length=sizeof tmp_buf;\n\n\t\t\tq=p;\n\t\t\t/* Fix buf for TLS and beyond */\n\t\t\tif (s->version > SSL3_VERSION)\n\t\t\t\tp+=2;\n\t\t\tn=RSA_public_encrypt(sizeof tmp_buf,\n\t\t\t\ttmp_buf,p,rsa,RSA_PKCS1_PADDING);\n#ifdef PKCS1_CHECK\n\t\t\tif (s->options & SSL_OP_PKCS1_CHECK_1) p[1]++;\n\t\t\tif (s->options & SSL_OP_PKCS1_CHECK_2) tmp_buf[0]=0x70;\n#endif\n\t\t\tif (n <= 0)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_BAD_RSA_ENCRYPT);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t/* Fix buf for TLS and beyond */\n\t\t\tif (s->version > SSL3_VERSION)\n\t\t\t\t{\n\t\t\t\ts2n(n,q);\n\t\t\t\tn+=2;\n\t\t\t\t}\n\n\t\t\ts->session->master_key_length=\n\t\t\t\ts->method->ssl3_enc->generate_master_secret(s,\n\t\t\t\t\ts->session->master_key,\n\t\t\t\t\ttmp_buf,sizeof tmp_buf);\n\t\t\tOPENSSL_cleanse(tmp_buf,sizeof tmp_buf);\n\t\t\t}\n#endif\n#ifndef OPENSSL_NO_KRB5\n\t\telse if (l & SSL_kKRB5)\n\t\t\t{\n\t\t\tkrb5_error_code\tkrb5rc;\n\t\t\tKSSL_CTX\t*kssl_ctx = s->kssl_ctx;\n\t\t\t/*  krb5_data\tkrb5_ap_req;  */\n\t\t\tkrb5_data\t*enc_ticket;\n\t\t\tkrb5_data\tauthenticator, *authp = NULL;\n\t\t\tEVP_CIPHER_CTX\tciph_ctx;\n\t\t\tEVP_CIPHER\t*enc = NULL;\n\t\t\tunsigned char\tiv[EVP_MAX_IV_LENGTH];\n\t\t\tunsigned char\ttmp_buf[SSL_MAX_MASTER_KEY_LENGTH];\n\t\t\tunsigned char\tepms[SSL_MAX_MASTER_KEY_LENGTH \n\t\t\t\t\t\t+ EVP_MAX_IV_LENGTH];\n\t\t\tint \t\tpadl, outl = sizeof(epms);\n\n\t\t\tEVP_CIPHER_CTX_init(&ciph_ctx);\n\n#ifdef KSSL_DEBUG\n\t\t\tprintf(\"ssl3_send_client_key_exchange(%lx & %lx)\\n\",\n\t\t\t        l, SSL_kKRB5);\n#endif\t/* KSSL_DEBUG */\n\n\t\t\tauthp = NULL;\n#ifdef KRB5SENDAUTH\n\t\t\tif (KRB5SENDAUTH)  authp = &authenticator;\n#endif\t/* KRB5SENDAUTH */\n\n\t\t\tkrb5rc = kssl_cget_tkt(kssl_ctx, &enc_ticket, authp,\n\t\t\t\t&kssl_err);\n\t\t\tenc = kssl_map_enc(kssl_ctx->enctype);\n\t\t\tif (enc == NULL)\n\t\t\t    goto err;\n#ifdef KSSL_DEBUG\n\t\t\t{\n\t\t\tprintf(\"kssl_cget_tkt rtn %d\\n\", krb5rc);\n\t\t\tif (krb5rc && kssl_err.text)\n\t\t\t  printf(\"kssl_cget_tkt kssl_err=%s\\n\", kssl_err.text);\n\t\t\t}\n#endif\t/* KSSL_DEBUG */\n\n\t\t\tif (krb5rc)\n\t\t\t\t{\n\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,\n\t\t\t\t\t\tSSL_AD_HANDSHAKE_FAILURE);\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n\t\t\t\t\t\tkssl_err.reason);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t/*  20010406 VRS - Earlier versions used KRB5 AP_REQ\n\t\t\t**  in place of RFC 2712 KerberosWrapper, as in:\n\t\t\t**\n\t\t\t**  Send ticket (copy to *p, set n = length)\n\t\t\t**  n = krb5_ap_req.length;\n\t\t\t**  memcpy(p, krb5_ap_req.data, krb5_ap_req.length);\n\t\t\t**  if (krb5_ap_req.data)  \n\t\t\t**    kssl_krb5_free_data_contents(NULL,&krb5_ap_req);\n\t\t\t**\n\t\t\t**  Now using real RFC 2712 KerberosWrapper\n\t\t\t**  (Thanks to Simon Wilkinson <sxw@sxw.org.uk>)\n\t\t\t**  Note: 2712 \"opaque\" types are here replaced\n\t\t\t**  with a 2-byte length followed by the value.\n\t\t\t**  Example:\n\t\t\t**  KerberosWrapper= xx xx asn1ticket 0 0 xx xx encpms\n\t\t\t**  Where \"xx xx\" = length bytes.  Shown here with\n\t\t\t**  optional authenticator omitted.\n\t\t\t*/\n\n\t\t\t/*  KerberosWrapper.Ticket\t\t*/\n\t\t\ts2n(enc_ticket->length,p);\n\t\t\tmemcpy(p, enc_ticket->data, enc_ticket->length);\n\t\t\tp+= enc_ticket->length;\n\t\t\tn = enc_ticket->length + 2;\n\n\t\t\t/*  KerberosWrapper.Authenticator\t*/\n\t\t\tif (authp  &&  authp->length)  \n\t\t\t\t{\n\t\t\t\ts2n(authp->length,p);\n\t\t\t\tmemcpy(p, authp->data, authp->length);\n\t\t\t\tp+= authp->length;\n\t\t\t\tn+= authp->length + 2;\n\t\t\t\t\n\t\t\t\tfree(authp->data);\n\t\t\t\tauthp->data = NULL;\n\t\t\t\tauthp->length = 0;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ts2n(0,p);/*  null authenticator length\t*/\n\t\t\t\tn+=2;\n\t\t\t\t}\n \n\t\t\t    tmp_buf[0]=s->client_version>>8;\n\t\t\t    tmp_buf[1]=s->client_version&0xff;\n\t\t\t    if (RAND_bytes(&(tmp_buf[2]),sizeof tmp_buf-2) <= 0)\n\t\t\t\tgoto err;\n\n\t\t\t/*  20010420 VRS.  Tried it this way; failed.\n\t\t\t**\tEVP_EncryptInit_ex(&ciph_ctx,enc, NULL,NULL);\n\t\t\t**\tEVP_CIPHER_CTX_set_key_length(&ciph_ctx,\n\t\t\t**\t\t\t\tkssl_ctx->length);\n\t\t\t**\tEVP_EncryptInit_ex(&ciph_ctx,NULL, key,iv);\n\t\t\t*/\n\n\t\t\tmemset(iv, 0, sizeof iv);  /* per RFC 1510 */\n\t\t\tEVP_EncryptInit_ex(&ciph_ctx,enc, NULL,\n\t\t\t\tkssl_ctx->key,iv);\n\t\t\tEVP_EncryptUpdate(&ciph_ctx,epms,&outl,tmp_buf,\n\t\t\t\tsizeof tmp_buf);\n\t\t\tEVP_EncryptFinal_ex(&ciph_ctx,&(epms[outl]),&padl);\n\t\t\toutl += padl;\n\t\t\tif (outl > sizeof epms)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tEVP_CIPHER_CTX_cleanup(&ciph_ctx);\n\n\t\t\t/*  KerberosWrapper.EncryptedPreMasterSecret\t*/\n\t\t\ts2n(outl,p);\n\t\t\tmemcpy(p, epms, outl);\n\t\t\tp+=outl;\n\t\t\tn+=outl + 2;\n\n\t\t\ts->session->master_key_length=\n\t\t\t        s->method->ssl3_enc->generate_master_secret(s,\n\t\t\t\t\ts->session->master_key,\n\t\t\t\t\ttmp_buf, sizeof tmp_buf);\n\n\t\t\tOPENSSL_cleanse(tmp_buf, sizeof tmp_buf);\n\t\t\tOPENSSL_cleanse(epms, outl);\n\t\t\t}\n#endif\n#ifndef OPENSSL_NO_DH\n\t\telse if (l & (SSL_kEDH|SSL_kDHr|SSL_kDHd))\n\t\t\t{\n\t\t\tDH *dh_srvr,*dh_clnt;\n\n\t\t\tif (s->session->sess_cert == NULL) \n\t\t\t\t{\n\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\t\t\tgoto err;\n\t\t\t        }\n\n\t\t\tif (s->session->sess_cert->peer_dh_tmp != NULL)\n\t\t\t\tdh_srvr=s->session->sess_cert->peer_dh_tmp;\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t/* we get them from the cert */\n\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_DH_PARAMETERS);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\n\t\t\t/* generate a new random key */\n\t\t\tif ((dh_clnt=DHparams_dup(dh_srvr)) == NULL)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tif (!DH_generate_key(dh_clnt))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t/* use the 'p' output buffer for the DH key, but\n\t\t\t * make sure to clear it out afterwards */\n\n\t\t\tn=DH_compute_key(p,dh_srvr->pub_key,dh_clnt);\n\n\t\t\tif (n <= 0)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t/* generate master key from the result */\n\t\t\ts->session->master_key_length=\n\t\t\t\ts->method->ssl3_enc->generate_master_secret(s,\n\t\t\t\t\ts->session->master_key,p,n);\n\t\t\t/* clean up */\n\t\t\tmemset(p,0,n);\n\n\t\t\t/* send off the data */\n\t\t\tn=BN_num_bytes(dh_clnt->pub_key);\n\t\t\ts2n(n,p);\n\t\t\tBN_bn2bin(dh_clnt->pub_key,p);\n\t\t\tn+=2;\n\n\t\t\tDH_free(dh_clnt);\n\n\t\t\t/* perhaps clean things up a bit EAY EAY EAY EAY*/\n\t\t\t}\n#endif\n\n#ifndef OPENSSL_NO_ECDH \n\t\telse if ((l & SSL_kECDH) || (l & SSL_kECDHE))\n\t\t\t{\n\t\t\tconst EC_GROUP *srvr_group = NULL;\n\t\t\tEC_KEY *tkey;\n\t\t\tint ecdh_clnt_cert = 0;\n\t\t\tint field_size = 0;\n\n\t\t\tif (s->session->sess_cert == NULL) \n\t\t\t\t{\n\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t/* Did we send out the client's\n\t\t\t * ECDH share for use in premaster\n\t\t\t * computation as part of client certificate?\n\t\t\t * If so, set ecdh_clnt_cert to 1.\n\t\t\t */\n\t\t\tif ((l & SSL_kECDH) && (s->cert != NULL)) \n\t\t\t\t{\n\t\t\t\t/* XXX: For now, we do not support client\n\t\t\t\t * authentication using ECDH certificates.\n\t\t\t\t * To add such support, one needs to add\n\t\t\t\t * code that checks for appropriate \n\t\t\t\t * conditions and sets ecdh_clnt_cert to 1.\n\t\t\t\t * For example, the cert have an ECC\n\t\t\t\t * key on the same curve as the server's\n\t\t\t\t * and the key should be authorized for\n\t\t\t\t * key agreement.\n\t\t\t\t *\n\t\t\t\t * One also needs to add code in ssl3_connect\n\t\t\t\t * to skip sending the certificate verify\n\t\t\t\t * message.\n\t\t\t\t *\n\t\t\t\t * if ((s->cert->key->privatekey != NULL) &&\n\t\t\t\t *     (s->cert->key->privatekey->type ==\n\t\t\t\t *      EVP_PKEY_EC) && ...)\n\t\t\t\t * ecdh_clnt_cert = 1;\n\t\t\t\t */\n\t\t\t\t}\n\n\t\t\tif (s->session->sess_cert->peer_ecdh_tmp != NULL)\n\t\t\t\t{\n\t\t\t\ttkey = s->session->sess_cert->peer_ecdh_tmp;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t/* Get the Server Public Key from Cert */\n\t\t\t\tsrvr_pub_pkey = X509_get_pubkey(s->session-> \\\n\t\t\t\t    sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);\n\t\t\t\tif ((srvr_pub_pkey == NULL) ||\n\t\t\t\t    (srvr_pub_pkey->type != EVP_PKEY_EC) ||\n\t\t\t\t    (srvr_pub_pkey->pkey.ec == NULL))\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n\t\t\t\t\t    ERR_R_INTERNAL_ERROR);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\n\t\t\t\ttkey = srvr_pub_pkey->pkey.ec;\n\t\t\t\t}\n\n\t\t\tsrvr_group   = EC_KEY_get0_group(tkey);\n\t\t\tsrvr_ecpoint = EC_KEY_get0_public_key(tkey);\n\n\t\t\tif ((srvr_group == NULL) || (srvr_ecpoint == NULL))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n\t\t\t\t    ERR_R_INTERNAL_ERROR);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\tif ((clnt_ecdh=EC_KEY_new()) == NULL) \n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\tif (!EC_KEY_set_group(clnt_ecdh, srvr_group))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tif (ecdh_clnt_cert) \n\t\t\t\t{ \n\t\t\t\t/* Reuse key info from our certificate\n\t\t\t\t * We only need our private key to perform\n\t\t\t\t * the ECDH computation.\n\t\t\t\t */\n\t\t\t\tconst BIGNUM *priv_key;\n\t\t\t\ttkey = s->cert->key->privatekey->pkey.ec;\n\t\t\t\tpriv_key = EC_KEY_get0_private_key(tkey);\n\t\t\t\tif (priv_key == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\tif (!EC_KEY_set_private_key(clnt_ecdh, priv_key))\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_EC_LIB);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse \n\t\t\t\t{\n\t\t\t\t/* Generate a new ECDH key pair */\n\t\t\t\tif (!(EC_KEY_generate_key(clnt_ecdh)))\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_ECDH_LIB);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t/* use the 'p' output buffer for the ECDH key, but\n\t\t\t * make sure to clear it out afterwards\n\t\t\t */\n\n\t\t\tfield_size = EC_GROUP_get_degree(srvr_group);\n\t\t\tif (field_size <= 0)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, \n\t\t\t\t       ERR_R_ECDH_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tn=ECDH_compute_key(p, (field_size+7)/8, srvr_ecpoint, clnt_ecdh, NULL);\n\t\t\tif (n <= 0)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, \n\t\t\t\t       ERR_R_ECDH_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t/* generate master key from the result */\n\t\t\ts->session->master_key_length = s->method->ssl3_enc \\\n\t\t\t    -> generate_master_secret(s, \n\t\t\t\ts->session->master_key,\n\t\t\t\tp, n);\n\n\t\t\tmemset(p, 0, n); /* clean up */\n\n\t\t\tif (ecdh_clnt_cert) \n\t\t\t\t{\n\t\t\t\t/* Send empty client key exch message */\n\t\t\t\tn = 0;\n\t\t\t\t}\n\t\t\telse \n\t\t\t\t{\n\t\t\t\t/* First check the size of encoding and\n\t\t\t\t * allocate memory accordingly.\n\t\t\t\t */\n\t\t\t\tencoded_pt_len = \n\t\t\t\t    EC_POINT_point2oct(srvr_group, \n\t\t\t\t\tEC_KEY_get0_public_key(clnt_ecdh), \n\t\t\t\t\tPOINT_CONVERSION_UNCOMPRESSED, \n\t\t\t\t\tNULL, 0, NULL);\n\n\t\t\t\tencodedPoint = (unsigned char *) \n\t\t\t\t    OPENSSL_malloc(encoded_pt_len * \n\t\t\t\t\tsizeof(unsigned char)); \n\t\t\t\tbn_ctx = BN_CTX_new();\n\t\t\t\tif ((encodedPoint == NULL) || \n\t\t\t\t    (bn_ctx == NULL)) \n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\n\t\t\t\t/* Encode the public key */\n\t\t\t\tn = EC_POINT_point2oct(srvr_group, \n\t\t\t\t    EC_KEY_get0_public_key(clnt_ecdh), \n\t\t\t\t    POINT_CONVERSION_UNCOMPRESSED, \n\t\t\t\t    encodedPoint, encoded_pt_len, bn_ctx);\n\n\t\t\t\t*p = n; /* length of encoded point */\n\t\t\t\t/* Encoded point will be copied here */\n\t\t\t\tp += 1; \n\t\t\t\t/* copy the point */\n\t\t\t\tmemcpy((unsigned char *)p, encodedPoint, n);\n\t\t\t\t/* increment n to account for length field */\n\t\t\t\tn += 1; \n\t\t\t\t}\n\n\t\t\t/* Free allocated memory */\n\t\t\tBN_CTX_free(bn_ctx);\n\t\t\tif (encodedPoint != NULL) OPENSSL_free(encodedPoint);\n\t\t\tif (clnt_ecdh != NULL) \n\t\t\t\t EC_KEY_free(clnt_ecdh);\n\t\t\tEVP_PKEY_free(srvr_pub_pkey);\n\t\t\t}\n#endif /* !OPENSSL_NO_ECDH */\n\t\telse\n\t\t\t{\n\t\t\tssl3_send_alert(s, SSL3_AL_FATAL,\n\t\t\t    SSL_AD_HANDSHAKE_FAILURE);\n\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n\t\t\t    ERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\t\n\t\t*(d++)=SSL3_MT_CLIENT_KEY_EXCHANGE;\n\t\tl2n3(n,d);\n\n\t\ts->state=SSL3_ST_CW_KEY_EXCH_B;\n\t\t/* number of bytes to write */\n\t\ts->init_num=n+4;\n\t\ts->init_off=0;\n\t\t}\n\n\t/* SSL3_ST_CW_KEY_EXCH_B */\n\treturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\nerr:\n#ifndef OPENSSL_NO_ECDH\n\tBN_CTX_free(bn_ctx);\n\tif (encodedPoint != NULL) OPENSSL_free(encodedPoint);\n\tif (clnt_ecdh != NULL) \n\t\tEC_KEY_free(clnt_ecdh);\n\tEVP_PKEY_free(srvr_pub_pkey);\n#endif\n\treturn(-1);\n\t}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148747,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "Agraph_t *agroot(void* obj)\n{\n    switch (AGTYPE(obj)) {\n    case AGINEDGE:\n    case AGOUTEDGE:\n\treturn ((Agedge_t *) obj)->node->root;\n    case AGNODE:\n\treturn ((Agnode_t *) obj)->root;\n    case AGRAPH:\n\treturn ((Agraph_t *) obj)->root;\n    default:\t\t\t/* actually can't occur if only 2 bit tags */\n\tagerr(AGERR, \"agroot of a bad object\");\n\treturn NILgraph;\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148754,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "Agraph_t *agraphof(void *obj)\n{\n    switch (AGTYPE(obj)) {\n    case AGINEDGE:\n    case AGOUTEDGE:\n\treturn ((Agedge_t *) obj)->node->root;\n    case AGNODE:\n\treturn ((Agnode_t *) obj)->root;\n    case AGRAPH:\n\treturn (Agraph_t *) obj;\n    default:\t\t\t/* actually can't occur if only 2 bit tags */\n\tagerr(AGERR, \"agraphof a bad object\");\n\treturn NILgraph;\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148755,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int multiSelect(\n  Parse *pParse,        /* Parsing context */\n  Select *p,            /* The right-most of SELECTs to be coded */\n  SelectDest *pDest     /* What to do with query results */\n){\n  int rc = SQLITE_OK;   /* Success code from a subroutine */\n  Select *pPrior;       /* Another SELECT immediately to our left */\n  Vdbe *v;              /* Generate code to this VDBE */\n  SelectDest dest;      /* Alternative data destination */\n  Select *pDelete = 0;  /* Chain of simple selects to delete */\n  sqlite3 *db;          /* Database connection */\n\n  /* Make sure there is no ORDER BY or LIMIT clause on prior SELECTs.  Only\n  ** the last (right-most) SELECT in the series may have an ORDER BY or LIMIT.\n  */\n  assert( p && p->pPrior );  /* Calling function guarantees this much */\n  assert( (p->selFlags & SF_Recursive)==0 || p->op==TK_ALL || p->op==TK_UNION );\n  assert( p->selFlags & SF_Compound );\n  db = pParse->db;\n  pPrior = p->pPrior;\n  dest = *pDest;\n  if( pPrior->pOrderBy || pPrior->pLimit ){\n    sqlite3ErrorMsg(pParse,\"%s clause should come after %s not before\",\n      pPrior->pOrderBy!=0 ? \"ORDER BY\" : \"LIMIT\", selectOpName(p->op));\n    rc = 1;\n    goto multi_select_end;\n  }\n\n  v = sqlite3GetVdbe(pParse);\n  assert( v!=0 );  /* The VDBE already created by calling function */\n\n  /* Create the destination temporary table if necessary\n  */\n  if( dest.eDest==SRT_EphemTab ){\n    assert( p->pEList );\n    sqlite3VdbeAddOp2(v, OP_OpenEphemeral, dest.iSDParm, p->pEList->nExpr);\n    dest.eDest = SRT_Table;\n  }\n\n  /* Special handling for a compound-select that originates as a VALUES clause.\n  */\n  if( p->selFlags & SF_MultiValue ){\n    rc = multiSelectValues(pParse, p, &dest);\n    if( rc>=0 ) goto multi_select_end;\n    rc = SQLITE_OK;\n  }\n\n  /* Make sure all SELECTs in the statement have the same number of elements\n  ** in their result sets.\n  */\n  assert( p->pEList && pPrior->pEList );\n  assert( p->pEList->nExpr==pPrior->pEList->nExpr );\n\n#ifndef SQLITE_OMIT_CTE\n  if( p->selFlags & SF_Recursive ){\n    generateWithRecursiveQuery(pParse, p, &dest);\n  }else\n#endif\n\n  /* Compound SELECTs that have an ORDER BY clause are handled separately.\n  */\n  if( p->pOrderBy ){\n    return multiSelectOrderBy(pParse, p, pDest);\n  }else{\n\n#ifndef SQLITE_OMIT_EXPLAIN\n    if( pPrior->pPrior==0 ){\n      ExplainQueryPlan((pParse, 1, \"COMPOUND QUERY\"));\n      ExplainQueryPlan((pParse, 1, \"LEFT-MOST SUBQUERY\"));\n    }\n#endif\n\n    /* Generate code for the left and right SELECT statements.\n    */\n    switch( p->op ){\n      case TK_ALL: {\n        int addr = 0;\n        int nLimit;\n        assert( !pPrior->pLimit );\n        pPrior->iLimit = p->iLimit;\n        pPrior->iOffset = p->iOffset;\n        pPrior->pLimit = p->pLimit;\n        rc = sqlite3Select(pParse, pPrior, &dest);\n        p->pLimit = 0;\n        if( rc ){\n          goto multi_select_end;\n        }\n        p->pPrior = 0;\n        p->iLimit = pPrior->iLimit;\n        p->iOffset = pPrior->iOffset;\n        if( p->iLimit ){\n          addr = sqlite3VdbeAddOp1(v, OP_IfNot, p->iLimit); VdbeCoverage(v);\n          VdbeComment((v, \"Jump ahead if LIMIT reached\"));\n          if( p->iOffset ){\n            sqlite3VdbeAddOp3(v, OP_OffsetLimit,\n                              p->iLimit, p->iOffset+1, p->iOffset);\n          }\n        }\n        ExplainQueryPlan((pParse, 1, \"UNION ALL\"));\n        rc = sqlite3Select(pParse, p, &dest);\n        testcase( rc!=SQLITE_OK );\n        pDelete = p->pPrior;\n        p->pPrior = pPrior;\n        p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n        if( pPrior->pLimit\n         && sqlite3ExprIsInteger(pPrior->pLimit->pLeft, &nLimit)\n         && nLimit>0 && p->nSelectRow > sqlite3LogEst((u64)nLimit) \n        ){\n          p->nSelectRow = sqlite3LogEst((u64)nLimit);\n        }\n        if( addr ){\n          sqlite3VdbeJumpHere(v, addr);\n        }\n        break;\n      }\n      case TK_EXCEPT:\n      case TK_UNION: {\n        int unionTab;    /* Cursor number of the temp table holding result */\n        u8 op = 0;       /* One of the SRT_ operations to apply to self */\n        int priorOp;     /* The SRT_ operation to apply to prior selects */\n        Expr *pLimit;    /* Saved values of p->nLimit  */\n        int addr;\n        SelectDest uniondest;\n  \n        testcase( p->op==TK_EXCEPT );\n        testcase( p->op==TK_UNION );\n        priorOp = SRT_Union;\n        if( dest.eDest==priorOp ){\n          /* We can reuse a temporary table generated by a SELECT to our\n          ** right.\n          */\n          assert( p->pLimit==0 );      /* Not allowed on leftward elements */\n          unionTab = dest.iSDParm;\n        }else{\n          /* We will need to create our own temporary table to hold the\n          ** intermediate results.\n          */\n          unionTab = pParse->nTab++;\n          assert( p->pOrderBy==0 );\n          addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, unionTab, 0);\n          assert( p->addrOpenEphm[0] == -1 );\n          p->addrOpenEphm[0] = addr;\n          findRightmost(p)->selFlags |= SF_UsesEphemeral;\n          assert( p->pEList );\n        }\n  \n        /* Code the SELECT statements to our left\n        */\n        assert( !pPrior->pOrderBy );\n        sqlite3SelectDestInit(&uniondest, priorOp, unionTab);\n        rc = sqlite3Select(pParse, pPrior, &uniondest);\n        if( rc ){\n          goto multi_select_end;\n        }\n  \n        /* Code the current SELECT statement\n        */\n        if( p->op==TK_EXCEPT ){\n          op = SRT_Except;\n        }else{\n          assert( p->op==TK_UNION );\n          op = SRT_Union;\n        }\n        p->pPrior = 0;\n        pLimit = p->pLimit;\n        p->pLimit = 0;\n        uniondest.eDest = op;\n        ExplainQueryPlan((pParse, 1, \"%s USING TEMP B-TREE\",\n                          selectOpName(p->op)));\n        rc = sqlite3Select(pParse, p, &uniondest);\n        testcase( rc!=SQLITE_OK );\n        /* Query flattening in sqlite3Select() might refill p->pOrderBy.\n        ** Be sure to delete p->pOrderBy, therefore, to avoid a memory leak. */\n        sqlite3ExprListDelete(db, p->pOrderBy);\n        pDelete = p->pPrior;\n        p->pPrior = pPrior;\n        p->pOrderBy = 0;\n        if( p->op==TK_UNION ){\n          p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n        }\n        sqlite3ExprDelete(db, p->pLimit);\n        p->pLimit = pLimit;\n        p->iLimit = 0;\n        p->iOffset = 0;\n  \n        /* Convert the data in the temporary table into whatever form\n        ** it is that we currently need.\n        */\n        assert( unionTab==dest.iSDParm || dest.eDest!=priorOp );\n        if( dest.eDest!=priorOp ){\n          int iCont, iBreak, iStart;\n          assert( p->pEList );\n          iBreak = sqlite3VdbeMakeLabel(pParse);\n          iCont = sqlite3VdbeMakeLabel(pParse);\n          computeLimitRegisters(pParse, p, iBreak);\n          sqlite3VdbeAddOp2(v, OP_Rewind, unionTab, iBreak); VdbeCoverage(v);\n          iStart = sqlite3VdbeCurrentAddr(v);\n          selectInnerLoop(pParse, p, unionTab,\n                          0, 0, &dest, iCont, iBreak);\n          sqlite3VdbeResolveLabel(v, iCont);\n          sqlite3VdbeAddOp2(v, OP_Next, unionTab, iStart); VdbeCoverage(v);\n          sqlite3VdbeResolveLabel(v, iBreak);\n          sqlite3VdbeAddOp2(v, OP_Close, unionTab, 0);\n        }\n        break;\n      }\n      default: assert( p->op==TK_INTERSECT ); {\n        int tab1, tab2;\n        int iCont, iBreak, iStart;\n        Expr *pLimit;\n        int addr;\n        SelectDest intersectdest;\n        int r1;\n  \n        /* INTERSECT is different from the others since it requires\n        ** two temporary tables.  Hence it has its own case.  Begin\n        ** by allocating the tables we will need.\n        */\n        tab1 = pParse->nTab++;\n        tab2 = pParse->nTab++;\n        assert( p->pOrderBy==0 );\n  \n        addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab1, 0);\n        assert( p->addrOpenEphm[0] == -1 );\n        p->addrOpenEphm[0] = addr;\n        findRightmost(p)->selFlags |= SF_UsesEphemeral;\n        assert( p->pEList );\n  \n        /* Code the SELECTs to our left into temporary table \"tab1\".\n        */\n        sqlite3SelectDestInit(&intersectdest, SRT_Union, tab1);\n        rc = sqlite3Select(pParse, pPrior, &intersectdest);\n        if( rc ){\n          goto multi_select_end;\n        }\n  \n        /* Code the current SELECT into temporary table \"tab2\"\n        */\n        addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab2, 0);\n        assert( p->addrOpenEphm[1] == -1 );\n        p->addrOpenEphm[1] = addr;\n        p->pPrior = 0;\n        pLimit = p->pLimit;\n        p->pLimit = 0;\n        intersectdest.iSDParm = tab2;\n        ExplainQueryPlan((pParse, 1, \"%s USING TEMP B-TREE\",\n                          selectOpName(p->op)));\n        rc = sqlite3Select(pParse, p, &intersectdest);\n        testcase( rc!=SQLITE_OK );\n        pDelete = p->pPrior;\n        p->pPrior = pPrior;\n        if( p->nSelectRow>pPrior->nSelectRow ){\n          p->nSelectRow = pPrior->nSelectRow;\n        }\n        sqlite3ExprDelete(db, p->pLimit);\n        p->pLimit = pLimit;\n  \n        /* Generate code to take the intersection of the two temporary\n        ** tables.\n        */\n        assert( p->pEList );\n        iBreak = sqlite3VdbeMakeLabel(pParse);\n        iCont = sqlite3VdbeMakeLabel(pParse);\n        computeLimitRegisters(pParse, p, iBreak);\n        sqlite3VdbeAddOp2(v, OP_Rewind, tab1, iBreak); VdbeCoverage(v);\n        r1 = sqlite3GetTempReg(pParse);\n        iStart = sqlite3VdbeAddOp2(v, OP_RowData, tab1, r1);\n        sqlite3VdbeAddOp4Int(v, OP_NotFound, tab2, iCont, r1, 0);\n        VdbeCoverage(v);\n        sqlite3ReleaseTempReg(pParse, r1);\n        selectInnerLoop(pParse, p, tab1,\n                        0, 0, &dest, iCont, iBreak);\n        sqlite3VdbeResolveLabel(v, iCont);\n        sqlite3VdbeAddOp2(v, OP_Next, tab1, iStart); VdbeCoverage(v);\n        sqlite3VdbeResolveLabel(v, iBreak);\n        sqlite3VdbeAddOp2(v, OP_Close, tab2, 0);\n        sqlite3VdbeAddOp2(v, OP_Close, tab1, 0);\n        break;\n      }\n    }\n  \n  #ifndef SQLITE_OMIT_EXPLAIN\n    if( p->pNext==0 ){\n      ExplainQueryPlanPop(pParse);\n    }\n  #endif\n  }\n  \n  /* Compute collating sequences used by \n  ** temporary tables needed to implement the compound select.\n  ** Attach the KeyInfo structure to all temporary tables.\n  **\n  ** This section is run by the right-most SELECT statement only.\n  ** SELECT statements to the left always skip this part.  The right-most\n  ** SELECT might also skip this part if it has no ORDER BY clause and\n  ** no temp tables are required.\n  */\n  if( p->selFlags & SF_UsesEphemeral ){\n    int i;                        /* Loop counter */\n    KeyInfo *pKeyInfo;            /* Collating sequence for the result set */\n    Select *pLoop;                /* For looping through SELECT statements */\n    CollSeq **apColl;             /* For looping through pKeyInfo->aColl[] */\n    int nCol;                     /* Number of columns in result set */\n\n    assert( p->pNext==0 );\n    nCol = p->pEList->nExpr;\n    pKeyInfo = sqlite3KeyInfoAlloc(db, nCol, 1);\n    if( !pKeyInfo ){\n      rc = SQLITE_NOMEM_BKPT;\n      goto multi_select_end;\n    }\n    for(i=0, apColl=pKeyInfo->aColl; i<nCol; i++, apColl++){\n      *apColl = multiSelectCollSeq(pParse, p, i);\n      if( 0==*apColl ){\n        *apColl = db->pDfltColl;\n      }\n    }\n\n    for(pLoop=p; pLoop; pLoop=pLoop->pPrior){\n      for(i=0; i<2; i++){\n        int addr = pLoop->addrOpenEphm[i];\n        if( addr<0 ){\n          /* If [0] is unused then [1] is also unused.  So we can\n          ** always safely abort as soon as the first unused slot is found */\n          assert( pLoop->addrOpenEphm[1]<0 );\n          break;\n        }\n        sqlite3VdbeChangeP2(v, addr, nCol);\n        sqlite3VdbeChangeP4(v, addr, (char*)sqlite3KeyInfoRef(pKeyInfo),\n                            P4_KEYINFO);\n        pLoop->addrOpenEphm[i] = -1;\n      }\n    }\n    sqlite3KeyInfoUnref(pKeyInfo);\n  }\n\nmulti_select_end:\n  pDest->iSdst = dest.iSdst;\n  pDest->nSdst = dest.nSdst;\n  sqlite3SelectDelete(db, pDelete);\n  return rc;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149606,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int multiSelect(\n  Parse *pParse,        /* Parsing context */\n  Select *p,            /* The right-most of SELECTs to be coded */\n  SelectDest *pDest     /* What to do with query results */\n){\n  int rc = SQLITE_OK;   /* Success code from a subroutine */\n  Select *pPrior;       /* Another SELECT immediately to our left */\n  Vdbe *v;              /* Generate code to this VDBE */\n  SelectDest dest;      /* Alternative data destination */\n  Select *pDelete = 0;  /* Chain of simple selects to delete */\n  sqlite3 *db;          /* Database connection */\n\n  /* Make sure there is no ORDER BY or LIMIT clause on prior SELECTs.  Only\n  ** the last (right-most) SELECT in the series may have an ORDER BY or LIMIT.\n  */\n  assert( p && p->pPrior );  /* Calling function guarantees this much */\n  assert( (p->selFlags & SF_Recursive)==0 || p->op==TK_ALL || p->op==TK_UNION );\n  assert( p->selFlags & SF_Compound );\n  db = pParse->db;\n  pPrior = p->pPrior;\n  dest = *pDest;\n  if( pPrior->pOrderBy || pPrior->pLimit ){\n    sqlite3ErrorMsg(pParse,\"%s clause should come after %s not before\",\n      pPrior->pOrderBy!=0 ? \"ORDER BY\" : \"LIMIT\", selectOpName(p->op));\n    rc = 1;\n    goto multi_select_end;\n  }\n\n  v = sqlite3GetVdbe(pParse);\n  assert( v!=0 );  /* The VDBE already created by calling function */\n\n  /* Create the destination temporary table if necessary\n  */\n  if( dest.eDest==SRT_EphemTab ){\n    assert( p->pEList );\n    sqlite3VdbeAddOp2(v, OP_OpenEphemeral, dest.iSDParm, p->pEList->nExpr);\n    dest.eDest = SRT_Table;\n  }\n\n  /* Special handling for a compound-select that originates as a VALUES clause.\n  */\n  if( p->selFlags & SF_MultiValue ){\n    rc = multiSelectValues(pParse, p, &dest);\n    if( rc>=0 ) goto multi_select_end;\n    rc = SQLITE_OK;\n  }\n\n  /* Make sure all SELECTs in the statement have the same number of elements\n  ** in their result sets.\n  */\n  assert( p->pEList && pPrior->pEList );\n  assert( p->pEList->nExpr==pPrior->pEList->nExpr );\n\n#ifndef SQLITE_OMIT_CTE\n  if( p->selFlags & SF_Recursive ){\n    generateWithRecursiveQuery(pParse, p, &dest);\n  }else\n#endif\n\n  /* Compound SELECTs that have an ORDER BY clause are handled separately.\n  */\n  if( p->pOrderBy ){\n    return multiSelectOrderBy(pParse, p, pDest);\n  }else{\n\n#ifndef SQLITE_OMIT_EXPLAIN\n    if( pPrior->pPrior==0 ){\n      ExplainQueryPlan((pParse, 1, \"COMPOUND QUERY\"));\n      ExplainQueryPlan((pParse, 1, \"LEFT-MOST SUBQUERY\"));\n    }\n#endif\n\n    /* Generate code for the left and right SELECT statements.\n    */\n    switch( p->op ){\n      case TK_ALL: {\n        int addr = 0;\n        int nLimit;\n        assert( !pPrior->pLimit );\n        pPrior->iLimit = p->iLimit;\n        pPrior->iOffset = p->iOffset;\n        pPrior->pLimit = p->pLimit;\n        rc = sqlite3Select(pParse, pPrior, &dest);\n        p->pLimit = 0;\n        if( rc ){\n          goto multi_select_end;\n        }\n        p->pPrior = 0;\n        p->iLimit = pPrior->iLimit;\n        p->iOffset = pPrior->iOffset;\n        if( p->iLimit ){\n          addr = sqlite3VdbeAddOp1(v, OP_IfNot, p->iLimit); VdbeCoverage(v);\n          VdbeComment((v, \"Jump ahead if LIMIT reached\"));\n          if( p->iOffset ){\n            sqlite3VdbeAddOp3(v, OP_OffsetLimit,\n                              p->iLimit, p->iOffset+1, p->iOffset);\n          }\n        }\n        ExplainQueryPlan((pParse, 1, \"UNION ALL\"));\n        rc = sqlite3Select(pParse, p, &dest);\n        testcase( rc!=SQLITE_OK );\n        pDelete = p->pPrior;\n        p->pPrior = pPrior;\n        p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n        if( pPrior->pLimit\n         && sqlite3ExprIsInteger(pPrior->pLimit->pLeft, &nLimit)\n         && nLimit>0 && p->nSelectRow > sqlite3LogEst((u64)nLimit) \n        ){\n          p->nSelectRow = sqlite3LogEst((u64)nLimit);\n        }\n        if( addr ){\n          sqlite3VdbeJumpHere(v, addr);\n        }\n        break;\n      }\n      case TK_EXCEPT:\n      case TK_UNION: {\n        int unionTab;    /* Cursor number of the temp table holding result */\n        u8 op = 0;       /* One of the SRT_ operations to apply to self */\n        int priorOp;     /* The SRT_ operation to apply to prior selects */\n        Expr *pLimit;    /* Saved values of p->nLimit  */\n        int addr;\n        SelectDest uniondest;\n  \n        testcase( p->op==TK_EXCEPT );\n        testcase( p->op==TK_UNION );\n        priorOp = SRT_Union;\n        if( dest.eDest==priorOp ){\n          /* We can reuse a temporary table generated by a SELECT to our\n          ** right.\n          */\n          assert( p->pLimit==0 );      /* Not allowed on leftward elements */\n          unionTab = dest.iSDParm;\n        }else{\n          /* We will need to create our own temporary table to hold the\n          ** intermediate results.\n          */\n          unionTab = pParse->nTab++;\n          assert( p->pOrderBy==0 );\n          addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, unionTab, 0);\n          assert( p->addrOpenEphm[0] == -1 );\n          p->addrOpenEphm[0] = addr;\n          findRightmost(p)->selFlags |= SF_UsesEphemeral;\n          assert( p->pEList );\n        }\n  \n        /* Code the SELECT statements to our left\n        */\n        assert( !pPrior->pOrderBy );\n        sqlite3SelectDestInit(&uniondest, priorOp, unionTab);\n        rc = sqlite3Select(pParse, pPrior, &uniondest);\n        if( rc ){\n          goto multi_select_end;\n        }\n  \n        /* Code the current SELECT statement\n        */\n        if( p->op==TK_EXCEPT ){\n          op = SRT_Except;\n        }else{\n          assert( p->op==TK_UNION );\n          op = SRT_Union;\n        }\n        p->pPrior = 0;\n        pLimit = p->pLimit;\n        p->pLimit = 0;\n        uniondest.eDest = op;\n        ExplainQueryPlan((pParse, 1, \"%s USING TEMP B-TREE\",\n                          selectOpName(p->op)));\n        rc = sqlite3Select(pParse, p, &uniondest);\n        testcase( rc!=SQLITE_OK );\n        /* Query flattening in sqlite3Select() might refill p->pOrderBy.\n        ** Be sure to delete p->pOrderBy, therefore, to avoid a memory leak. */\n        sqlite3ExprListDelete(db, p->pOrderBy);\n        pDelete = p->pPrior;\n        p->pPrior = pPrior;\n        p->pOrderBy = 0;\n        if( p->op==TK_UNION ){\n          p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n        }\n        sqlite3ExprDelete(db, p->pLimit);\n        p->pLimit = pLimit;\n        p->iLimit = 0;\n        p->iOffset = 0;\n  \n        /* Convert the data in the temporary table into whatever form\n        ** it is that we currently need.\n        */\n        assert( unionTab==dest.iSDParm || dest.eDest!=priorOp );\n        if( dest.eDest!=priorOp ){\n          int iCont, iBreak, iStart;\n          assert( p->pEList );\n          iBreak = sqlite3VdbeMakeLabel(pParse);\n          iCont = sqlite3VdbeMakeLabel(pParse);\n          computeLimitRegisters(pParse, p, iBreak);\n          sqlite3VdbeAddOp2(v, OP_Rewind, unionTab, iBreak); VdbeCoverage(v);\n          iStart = sqlite3VdbeCurrentAddr(v);\n          selectInnerLoop(pParse, p, unionTab,\n                          0, 0, &dest, iCont, iBreak);\n          sqlite3VdbeResolveLabel(v, iCont);\n          sqlite3VdbeAddOp2(v, OP_Next, unionTab, iStart); VdbeCoverage(v);\n          sqlite3VdbeResolveLabel(v, iBreak);\n          sqlite3VdbeAddOp2(v, OP_Close, unionTab, 0);\n        }\n        break;\n      }\n      default: assert( p->op==TK_INTERSECT ); {\n        int tab1, tab2;\n        int iCont, iBreak, iStart;\n        Expr *pLimit;\n        int addr;\n        SelectDest intersectdest;\n        int r1;\n  \n        /* INTERSECT is different from the others since it requires\n        ** two temporary tables.  Hence it has its own case.  Begin\n        ** by allocating the tables we will need.\n        */\n        tab1 = pParse->nTab++;\n        tab2 = pParse->nTab++;\n        assert( p->pOrderBy==0 );\n  \n        addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab1, 0);\n        assert( p->addrOpenEphm[0] == -1 );\n        p->addrOpenEphm[0] = addr;\n        findRightmost(p)->selFlags |= SF_UsesEphemeral;\n        assert( p->pEList );\n  \n        /* Code the SELECTs to our left into temporary table \"tab1\".\n        */\n        sqlite3SelectDestInit(&intersectdest, SRT_Union, tab1);\n        rc = sqlite3Select(pParse, pPrior, &intersectdest);\n        if( rc ){\n          goto multi_select_end;\n        }\n  \n        /* Code the current SELECT into temporary table \"tab2\"\n        */\n        addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab2, 0);\n        assert( p->addrOpenEphm[1] == -1 );\n        p->addrOpenEphm[1] = addr;\n        p->pPrior = 0;\n        pLimit = p->pLimit;\n        p->pLimit = 0;\n        intersectdest.iSDParm = tab2;\n        ExplainQueryPlan((pParse, 1, \"%s USING TEMP B-TREE\",\n                          selectOpName(p->op)));\n        rc = sqlite3Select(pParse, p, &intersectdest);\n        testcase( rc!=SQLITE_OK );\n        pDelete = p->pPrior;\n        p->pPrior = pPrior;\n        if( p->nSelectRow>pPrior->nSelectRow ){\n          p->nSelectRow = pPrior->nSelectRow;\n        }\n        sqlite3ExprDelete(db, p->pLimit);\n        p->pLimit = pLimit;\n  \n        /* Generate code to take the intersection of the two temporary\n        ** tables.\n        */\n        assert( p->pEList );\n        iBreak = sqlite3VdbeMakeLabel(pParse);\n        iCont = sqlite3VdbeMakeLabel(pParse);\n        computeLimitRegisters(pParse, p, iBreak);\n        sqlite3VdbeAddOp2(v, OP_Rewind, tab1, iBreak); VdbeCoverage(v);\n        r1 = sqlite3GetTempReg(pParse);\n        iStart = sqlite3VdbeAddOp2(v, OP_RowData, tab1, r1);\n        sqlite3VdbeAddOp4Int(v, OP_NotFound, tab2, iCont, r1, 0);\n        VdbeCoverage(v);\n        sqlite3ReleaseTempReg(pParse, r1);\n        selectInnerLoop(pParse, p, tab1,\n                        0, 0, &dest, iCont, iBreak);\n        sqlite3VdbeResolveLabel(v, iCont);\n        sqlite3VdbeAddOp2(v, OP_Next, tab1, iStart); VdbeCoverage(v);\n        sqlite3VdbeResolveLabel(v, iBreak);\n        sqlite3VdbeAddOp2(v, OP_Close, tab2, 0);\n        sqlite3VdbeAddOp2(v, OP_Close, tab1, 0);\n        break;\n      }\n    }\n  \n  #ifndef SQLITE_OMIT_EXPLAIN\n    if( p->pNext==0 ){\n      ExplainQueryPlanPop(pParse);\n    }\n  #endif\n  }\n  if( pParse->nErr ) goto multi_select_end;\n  \n  /* Compute collating sequences used by \n  ** temporary tables needed to implement the compound select.\n  ** Attach the KeyInfo structure to all temporary tables.\n  **\n  ** This section is run by the right-most SELECT statement only.\n  ** SELECT statements to the left always skip this part.  The right-most\n  ** SELECT might also skip this part if it has no ORDER BY clause and\n  ** no temp tables are required.\n  */\n  if( p->selFlags & SF_UsesEphemeral ){\n    int i;                        /* Loop counter */\n    KeyInfo *pKeyInfo;            /* Collating sequence for the result set */\n    Select *pLoop;                /* For looping through SELECT statements */\n    CollSeq **apColl;             /* For looping through pKeyInfo->aColl[] */\n    int nCol;                     /* Number of columns in result set */\n\n    assert( p->pNext==0 );\n    nCol = p->pEList->nExpr;\n    pKeyInfo = sqlite3KeyInfoAlloc(db, nCol, 1);\n    if( !pKeyInfo ){\n      rc = SQLITE_NOMEM_BKPT;\n      goto multi_select_end;\n    }\n    for(i=0, apColl=pKeyInfo->aColl; i<nCol; i++, apColl++){\n      *apColl = multiSelectCollSeq(pParse, p, i);\n      if( 0==*apColl ){\n        *apColl = db->pDfltColl;\n      }\n    }\n\n    for(pLoop=p; pLoop; pLoop=pLoop->pPrior){\n      for(i=0; i<2; i++){\n        int addr = pLoop->addrOpenEphm[i];\n        if( addr<0 ){\n          /* If [0] is unused then [1] is also unused.  So we can\n          ** always safely abort as soon as the first unused slot is found */\n          assert( pLoop->addrOpenEphm[1]<0 );\n          break;\n        }\n        sqlite3VdbeChangeP2(v, addr, nCol);\n        sqlite3VdbeChangeP4(v, addr, (char*)sqlite3KeyInfoRef(pKeyInfo),\n                            P4_KEYINFO);\n        pLoop->addrOpenEphm[i] = -1;\n      }\n    }\n    sqlite3KeyInfoUnref(pKeyInfo);\n  }\n\nmulti_select_end:\n  pDest->iSdst = dest.iSdst;\n  pDest->nSdst = dest.nSdst;\n  sqlite3SelectDelete(db, pDelete);\n  return rc;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149607,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {\n\tRASN1Object *object;\n\tRCMS *container;\n\tif (!buffer || !length) {\n\t\treturn NULL;\n\t}\n\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {\n\t\tr_asn1_free_object (object);\n\t\tfree (container);\n\t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tr_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);\n\tr_asn1_free_object (object);\n\treturn container;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149608,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {\n\tRASN1Object *object;\n\tRCMS *container;\n\tif (!buffer || !length) {\n\t\treturn NULL;\n\t}\n\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects ||\n\t\t!object->list.objects[0] || !object->list.objects[1] ||\n\t\tobject->list.objects[1]->list.length != 1) {\n\t\tr_asn1_free_object (object);\n\t\tfree (container);\n\t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tr_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);\n\tr_asn1_free_object (object);\n\treturn container;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149609,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    explicit_vr[MagickPathExtent],\n    implicit_vr[MagickPathExtent],\n    magick[MagickPathExtent],\n    photometric[MagickPathExtent];\n\n  DCMStreamInfo\n    *stream_info;\n\n  Image\n    *image;\n\n  int\n    *bluemap,\n    datum,\n    *greenmap,\n    *graymap,\n    index,\n    *redmap;\n\n  MagickBooleanType\n    explicit_file,\n    explicit_retry,\n    polarity,\n    sequence,\n    use_explicit;\n\n  MagickOffsetType\n    offset;\n\n  Quantum\n    *scale;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_allocated,\n    bytes_per_pixel,\n    colors,\n    depth,\n    height,\n    length,\n    mask,\n    max_value,\n    number_scenes,\n    quantum,\n    samples_per_pixel,\n    signed_data,\n    significant_bits,\n    status,\n    width,\n    window_width;\n\n  ssize_t\n    count,\n    rescale_intercept,\n    rescale_slope,\n    scene,\n    window_center,\n    y;\n\n  unsigned char\n    *data;\n\n  unsigned short\n    group,\n    element;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=8UL;\n  image->endian=LSBEndian;\n  /*\n    Read DCM preamble.\n  */\n  stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));\n  if (stream_info == (DCMStreamInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(stream_info,0,sizeof(*stream_info));\n  count=ReadBlob(image,128,(unsigned char *) magick);\n  if (count != 128)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  if ((count != 4) || (LocaleNCompare(magick,\"DICM\",4) != 0))\n    {\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  /*\n    Read DCM Medical image.\n  */\n  (void) CopyMagickString(photometric,\"MONOCHROME1 \",MagickPathExtent);\n  bits_allocated=8;\n  bytes_per_pixel=1;\n  polarity=MagickFalse;\n  data=(unsigned char *) NULL;\n  depth=8;\n  element=0;\n  explicit_vr[2]='\\0';\n  explicit_file=MagickFalse;\n  colors=0;\n  redmap=(int *) NULL;\n  greenmap=(int *) NULL;\n  bluemap=(int *) NULL;\n  graymap=(int *) NULL;\n  height=0;\n  max_value=255UL;\n  mask=0xffff;\n  number_scenes=1;\n  rescale_intercept=0;\n  rescale_slope=1;\n  samples_per_pixel=1;\n  scale=(Quantum *) NULL;\n  sequence=MagickFalse;\n  signed_data=(~0UL);\n  significant_bits=0;\n  use_explicit=MagickFalse;\n  explicit_retry = MagickFalse;\n  width=0;\n  window_center=0;\n  window_width=0;\n  for (group=0; (group != 0x7FE0) || (element != 0x0010) ||\n                (sequence != MagickFalse); )\n  {\n    /*\n      Read a group.\n    */\n    image->offset=(ssize_t) TellBlob(image);\n    group=ReadBlobLSBShort(image);\n    element=ReadBlobLSBShort(image);\n    if ((group != 0x0002) && (image->endian == MSBEndian))\n      {\n        group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));\n        element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));\n      }\n    quantum=0;\n    /*\n      Find corresponding VR for this group and element.\n    */\n    for (i=0; dicom_info[i].group < 0xffff; i++)\n      if ((group == dicom_info[i].group) && (element == dicom_info[i].element))\n        break;\n    (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);\n    count=ReadBlob(image,2,(unsigned char *) explicit_vr);\n    if (count != 2)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    /*\n      Check for \"explicitness\", but meta-file headers always explicit.\n    */\n    if ((explicit_file == MagickFalse) && (group != 0x0002))\n      explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&\n        (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?\n        MagickTrue : MagickFalse;\n    use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||\n      (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;\n    if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,\"xs\",2) == 0))\n      (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);\n    if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,\"!!\",2) == 0))\n      {\n        offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        quantum=4;\n      }\n    else\n      {\n        /*\n          Assume explicit type.\n        */\n        quantum=2;\n        if ((strncmp(explicit_vr,\"OB\",2) == 0) ||\n            (strncmp(explicit_vr,\"UN\",2) == 0) ||\n            (strncmp(explicit_vr,\"OW\",2) == 0) ||\n            (strncmp(explicit_vr,\"SQ\",2) == 0))\n          {\n            (void) ReadBlobLSBShort(image);\n            quantum=4;\n          }\n      }\n    datum=0;\n    if (quantum == 4)\n      {\n        if (group == 0x0002)\n          datum=ReadBlobLSBSignedLong(image);\n        else\n          datum=ReadBlobSignedLong(image);\n      }\n    else\n      if (quantum == 2)\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedShort(image);\n          else\n            datum=ReadBlobSignedShort(image);\n        }\n    quantum=0;\n    length=1;\n    if (datum != 0)\n      {\n        if ((strncmp(implicit_vr,\"SS\",2) == 0) ||\n            (strncmp(implicit_vr,\"US\",2) == 0))\n          quantum=2;\n        else\n          if ((strncmp(implicit_vr,\"UL\",2) == 0) ||\n              (strncmp(implicit_vr,\"SL\",2) == 0) ||\n              (strncmp(implicit_vr,\"FL\",2) == 0))\n            quantum=4;\n          else\n            if (strncmp(implicit_vr,\"FD\",2) != 0)\n              quantum=1;\n            else\n              quantum=8;\n        if (datum != ~0)\n          length=(size_t) datum/quantum;\n        else\n          {\n            /*\n              Sequence and item of undefined length.\n            */\n            quantum=0;\n            length=0;\n          }\n      }\n    if (image_info->verbose != MagickFalse)\n      {\n        /*\n          Display Dicom info.\n        */\n        if (use_explicit == MagickFalse)\n          explicit_vr[0]='\\0';\n        for (i=0; dicom_info[i].description != (char *) NULL; i++)\n          if ((group == dicom_info[i].group) &&\n              (element == dicom_info[i].element))\n            break;\n        (void) FormatLocaleFile(stdout,\"0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)\",\n          (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,\n          (unsigned long) group,(unsigned long) element);\n        if (dicom_info[i].description != (char *) NULL)\n          (void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);\n        (void) FormatLocaleFile(stdout,\": \");\n      }\n    if ((sequence == MagickFalse) && (group == 0x7FE0) && (element == 0x0010))\n      {\n        if (image_info->verbose != MagickFalse)\n          (void) FormatLocaleFile(stdout,\"\\n\");\n        break;\n      }\n    /*\n      Allocate space and read an array.\n    */\n    data=(unsigned char *) NULL;\n    if ((length == 1) && (quantum == 1))\n      datum=ReadBlobByte(image);\n    else\n      if ((length == 1) && (quantum == 2))\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedShort(image);\n          else\n            datum=ReadBlobSignedShort(image);\n        }\n      else\n        if ((length == 1) && (quantum == 4))\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedLong(image);\n            else\n              datum=ReadBlobSignedLong(image);\n          }\n        else\n          if ((quantum != 0) && (length != 0))\n            {\n              if (~length >= 1)\n                data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*\n                  sizeof(*data));\n              if (data == (unsigned char *) NULL)\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              count=ReadBlob(image,(size_t) quantum*length,data);\n              if (count != (ssize_t) (quantum*length))\n                {\n                  if (image_info->verbose != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"\n                      \"length=%d group=%d\\n\",(int) count,(int) quantum,(int)\n                      length,(int) group);\n                   ThrowReaderException(CorruptImageError,\n                     \"InsufficientImageDataInFile\");\n                }\n              data[length*quantum]='\\0';\n            }\n          else\n            if ((unsigned int) datum == 0xFFFFFFFFU)\n              {\n                sequence=MagickTrue;\n                continue;\n              }\n\n    if ((unsigned int) ((group << 16) | element) == 0xFFFEE0DD)\n      {\n        if (data != (unsigned char *) NULL)\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        sequence=MagickFalse;\n        continue;\n      }\n\n    if (sequence != MagickFalse)\n      {\n        if (data != (unsigned char *) NULL)\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        continue;\n      }\n\n    switch (group)\n    {\n      case 0x0002:\n      {\n        switch (element)\n        {\n          case 0x0010:\n          {\n            char\n              transfer_syntax[MagickPathExtent];\n\n            /*\n              Transfer Syntax.\n            */\n            if ((datum == 0) && (explicit_retry == MagickFalse))\n              {\n                explicit_retry=MagickTrue;\n                (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);\n                group=0;\n                element=0;\n                if (image_info->verbose != MagickFalse)\n                  (void) FormatLocaleFile(stdout,\n                    \"Corrupted image - trying explicit format\\n\");\n                break;\n              }\n            *transfer_syntax='\\0';\n            if (data != (unsigned char *) NULL)\n              (void) CopyMagickString(transfer_syntax,(char *) data,\n                MagickPathExtent);\n            if (image_info->verbose != MagickFalse)\n              (void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",\n                (const char *) transfer_syntax);\n            if (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)\n              {\n                int\n                  count,\n                  subtype,\n                  type;\n\n                type=1;\n                subtype=0;\n                if (strlen(transfer_syntax) > 17)\n                  {\n                    count=sscanf(transfer_syntax+17,\".%d.%d\",&type,&subtype);\n                    if (count < 1)\n                      ThrowReaderException(CorruptImageError,\n                        \"ImproperImageHeader\");\n                  }\n                switch (type)\n                {\n                  case 1:\n                  {\n                    image->endian=LSBEndian;\n                    break;\n                  }\n                  case 2:\n                  {\n                    image->endian=MSBEndian;\n                    break;\n                  }\n                  case 4:\n                  {\n                    if ((subtype >= 80) && (subtype <= 81))\n                      image->compression=JPEGCompression;\n                    else\n                      if ((subtype >= 90) && (subtype <= 93))\n                        image->compression=JPEG2000Compression;\n                      else\n                        image->compression=JPEGCompression;\n                    break;\n                  }\n                  case 5:\n                  {\n                    image->compression=RLECompression;\n                    break;\n                  }\n                }\n              }\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      case 0x0028:\n      {\n        switch (element)\n        {\n          case 0x0002:\n          {\n            /*\n              Samples per pixel.\n            */\n            samples_per_pixel=(size_t) datum;\n            break;\n          }\n          case 0x0004:\n          {\n            /*\n              Photometric interpretation.\n            */\n            for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)\n              photometric[i]=(char) data[i];\n            photometric[i]='\\0';\n            polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?\n              MagickTrue : MagickFalse;\n            break;\n          }\n          case 0x0006:\n          {\n            /*\n              Planar configuration.\n            */\n            if (datum == 1)\n              image->interlace=PlaneInterlace;\n            break;\n          }\n          case 0x0008:\n          {\n            /*\n              Number of frames.\n            */\n            number_scenes=StringToUnsignedLong((char *) data);\n            break;\n          }\n          case 0x0010:\n          {\n            /*\n              Image rows.\n            */\n            height=(size_t) datum;\n            break;\n          }\n          case 0x0011:\n          {\n            /*\n              Image columns.\n            */\n            width=(size_t) datum;\n            break;\n          }\n          case 0x0100:\n          {\n            /*\n              Bits allocated.\n            */\n            bits_allocated=(size_t) datum;\n            bytes_per_pixel=1;\n            if (datum > 8)\n              bytes_per_pixel=2;\n            depth=bits_allocated;\n            if (depth > 32)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            max_value=(1UL << bits_allocated)-1;\n            break;\n          }\n          case 0x0101:\n          {\n            /*\n              Bits stored.\n            */\n            significant_bits=(size_t) datum;\n            bytes_per_pixel=1;\n            if (significant_bits > 8)\n              bytes_per_pixel=2;\n            depth=significant_bits;\n            if (depth > 32)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            max_value=(1UL << significant_bits)-1;\n            mask=(size_t) GetQuantumRange(significant_bits);\n            break;\n          }\n          case 0x0102:\n          {\n            /*\n              High bit.\n            */\n            break;\n          }\n          case 0x0103:\n          {\n            /*\n              Pixel representation.\n            */\n            signed_data=(size_t) datum;\n            break;\n          }\n          case 0x1050:\n          {\n            /*\n              Visible pixel range: center.\n            */\n            if (data != (unsigned char *) NULL)\n              window_center=(ssize_t) StringToLong((char *) data);\n            break;\n          }\n          case 0x1051:\n          {\n            /*\n              Visible pixel range: width.\n            */\n            if (data != (unsigned char *) NULL)\n              window_width=StringToUnsignedLong((char *) data);\n            break;\n          }\n          case 0x1052:\n          {\n            /*\n              Rescale intercept\n            */\n            if (data != (unsigned char *) NULL)\n              rescale_intercept=(ssize_t) StringToLong((char *) data);\n            break;\n          }\n          case 0x1053:\n          {\n            /*\n              Rescale slope\n            */\n            if (data != (unsigned char *) NULL)\n              rescale_slope=(ssize_t) StringToLong((char *) data);\n            break;\n          }\n          case 0x1200:\n          case 0x3006:\n          {\n            /*\n              Populate graymap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/bytes_per_pixel);\n            datum=(int) colors;\n            graymap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*graymap));\n            if (graymap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            for (i=0; i < (ssize_t) colors; i++)\n              if (bytes_per_pixel == 1)\n                graymap[i]=(int) data[i];\n              else\n                graymap[i]=(int) ((short *) data)[i];\n            break;\n          }\n          case 0x1201:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate redmap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            redmap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*redmap));\n            if (redmap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              redmap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          case 0x1202:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate greenmap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            greenmap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*greenmap));\n            if (greenmap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              greenmap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          case 0x1203:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate bluemap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            bluemap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*bluemap));\n            if (bluemap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              bluemap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      case 0x2050:\n      {\n        switch (element)\n        {\n          case 0x0020:\n          {\n            if ((data != (unsigned char *) NULL) &&\n                (strncmp((char *) data,\"INVERSE\",7) == 0))\n              polarity=MagickTrue;\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      default:\n        break;\n    }\n    if (data != (unsigned char *) NULL)\n      {\n        char\n          *attribute;\n\n        for (i=0; dicom_info[i].description != (char *) NULL; i++)\n          if ((group == dicom_info[i].group) &&\n              (element == dicom_info[i].element))\n            break;\n        if (dicom_info[i].description != (char *) NULL)\n          {\n            attribute=AcquireString(\"dcm:\");\n            (void) ConcatenateString(&attribute,dicom_info[i].description);\n            for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n              if (isprint((int) data[i]) == MagickFalse)\n                break;\n            if ((i == (ssize_t) length) || (length > 4))\n              {\n                (void) SubstituteString(&attribute,\" \",\"\");\n                (void) SetImageProperty(image,attribute,(char *) data,exception);\n              }\n            attribute=DestroyString(attribute);\n          }\n      }\n    if (image_info->verbose != MagickFalse)\n      {\n        if (data == (unsigned char *) NULL)\n          (void) FormatLocaleFile(stdout,\"%d\\n\",datum);\n        else\n          {\n            /*\n              Display group data.\n            */\n            for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n              if (isprint((int) data[i]) == MagickFalse)\n                break;\n            if ((i != (ssize_t) length) && (length <= 4))\n              {\n                ssize_t\n                  j;\n\n                datum=0;\n                for (j=(ssize_t) length-1; j >= 0; j--)\n                  datum=(256*datum+data[j]);\n                (void) FormatLocaleFile(stdout,\"%d\",datum);\n              }\n            else\n              for (i=0; i < (ssize_t) length; i++)\n                if (isprint((int) data[i]) != MagickFalse)\n                  (void) FormatLocaleFile(stdout,\"%c\",data[i]);\n                else\n                  (void) FormatLocaleFile(stdout,\"%c\",'.');\n            (void) FormatLocaleFile(stdout,\"\\n\");\n          }\n      }\n    if (data != (unsigned char *) NULL)\n      data=(unsigned char *) RelinquishMagickMemory(data);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n  }\n  if ((width == 0) || (height == 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  image->columns=(size_t) width;\n  image->rows=(size_t) height;\n  if (signed_data == 0xffff)\n    signed_data=(size_t) (significant_bits == 16 ? 1 : 0);\n  if ((image->compression == JPEGCompression) ||\n      (image->compression == JPEG2000Compression))\n    {\n      Image\n        *images;\n\n      ImageInfo\n        *read_info;\n\n      int\n        c;\n\n      size_t\n        length;\n\n      unsigned int\n        tag;\n\n      /*\n        Read offset table.\n      */\n      for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        (void) ReadBlobByte(image);\n      tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n      (void) tag;\n      length=(size_t) ReadBlobLSBLong(image);\n      stream_info->offset_count=length >> 2;\n      if (stream_info->offset_count != 0)\n        {\n          MagickOffsetType\n            offset;\n\n          stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n            stream_info->offset_count,sizeof(*stream_info->offsets));\n          if (stream_info->offsets == (ssize_t *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          offset=TellBlob(image);\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]+=offset;\n        }\n      /*\n        Handle non-native image formats.\n      */\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      images=NewImageList();\n      for (scene=0; scene < (ssize_t) number_scenes; scene++)\n      {\n        char\n          filename[MagickPathExtent];\n\n        const char\n          *property;\n\n        FILE\n          *file;\n\n        Image\n          *jpeg_image;\n\n        int\n          unique_file;\n\n        unsigned int\n          tag;\n\n        tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n        length=(size_t) ReadBlobLSBLong(image);\n        if (tag == 0xFFFEE0DD)\n          break; /* sequence delimiter tag */\n        if (tag != 0xFFFEE000)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if (file == (FILE *) NULL)\n          {\n            (void) RelinquishUniqueFileResource(filename);\n            ThrowFileException(exception,FileOpenError,\n              \"UnableToCreateTemporaryFile\",filename);\n            break;\n          }\n        for ( ; length != 0; length--)\n        {\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          (void) fputc(c,file);\n        }\n        (void) fclose(file);\n        (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n          \"jpeg:%s\",filename);\n        if (image->compression == JPEG2000Compression)\n          (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n            \"j2k:%s\",filename);\n        jpeg_image=ReadImage(read_info,exception);\n        if (jpeg_image != (Image *) NULL)\n          {\n            ResetImagePropertyIterator(image);\n            property=GetNextImageProperty(image);\n            while (property != (const char *) NULL)\n            {\n              (void) SetImageProperty(jpeg_image,property,\n                GetImageProperty(image,property,exception),exception);\n              property=GetNextImageProperty(image);\n            }\n            AppendImageToList(&images,jpeg_image);\n          }\n        (void) RelinquishUniqueFileResource(filename);\n      }\n      read_info=DestroyImageInfo(read_info);\n      image=DestroyImage(image);\n      return(GetFirstImageInList(images));\n    }\n  if (depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))\n    {\n      QuantumAny\n        range;\n\n      size_t\n        length;\n\n      /*\n        Compute pixel scaling table.\n      */\n      length=(size_t) (GetQuantumRange(depth)+1);\n      scale=(Quantum *) AcquireQuantumMemory(length,sizeof(*scale));\n      if (scale == (Quantum *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      range=GetQuantumRange(depth);\n      for (i=0; i < (ssize_t) (GetQuantumRange(depth)+1); i++)\n        scale[i]=ScaleAnyToQuantum((size_t) i,range);\n    }\n  if (image->compression == RLECompression)\n    {\n      size_t\n        length;\n\n      unsigned int\n        tag;\n\n      /*\n        Read RLE offset table.\n      */\n      for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        (void) ReadBlobByte(image);\n      tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n      (void) tag;\n      length=(size_t) ReadBlobLSBLong(image);\n      stream_info->offset_count=length >> 2;\n      if (stream_info->offset_count != 0)\n        {\n          MagickOffsetType\n            offset;\n\n          stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n            stream_info->offset_count,sizeof(*stream_info->offsets));\n          if (stream_info->offsets == (ssize_t *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          offset=TellBlob(image);\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]+=offset;\n        }\n    }\n  for (scene=0; scene < (ssize_t) number_scenes; scene++)\n  {\n    if (image_info->ping != MagickFalse)\n      break;\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=depth;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      break;\n    image->colorspace=RGBColorspace;\n    if ((image->colormap == (PixelInfo *) NULL) && (samples_per_pixel == 1))\n      {\n        size_t\n          one;\n\n        one=1;\n        if (colors == 0)\n          colors=one << depth;\n        if (AcquireImageColormap(image,one << depth,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (redmap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=redmap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].red=(MagickRealType) index;\n          }\n        if (greenmap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=greenmap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].green=(MagickRealType) index;\n          }\n        if (bluemap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=bluemap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].blue=(MagickRealType) index;\n          }\n        if (graymap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=graymap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].red=(MagickRealType) index;\n            image->colormap[i].green=(MagickRealType) index;\n            image->colormap[i].blue=(MagickRealType) index;\n          }\n      }\n    if (image->compression == RLECompression)\n      {\n        unsigned int\n          tag;\n\n        /*\n          Read RLE segment table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          (void) ReadBlobByte(image);\n        tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n        stream_info->remaining=(size_t) ReadBlobLSBLong(image);\n        if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||\n            (EOFBlob(image) != MagickFalse))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        stream_info->count=0;\n        stream_info->segment_count=ReadBlobLSBLong(image);\n        if (stream_info->segment_count > 1)\n          {\n            bytes_per_pixel=1;\n            depth=8;\n          }\n        for (i=0; i < 15; i++)\n          stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n        stream_info->remaining-=64;\n      }\n    if ((samples_per_pixel > 1) && (image->interlace == PlaneInterlace))\n      {\n        /*\n          Convert Planar RGB DCM Medical image to pixel packets.\n        */\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              switch ((int) i)\n              {\n                case 0:\n                {\n                  SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 1:\n                {\n                  SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 2:\n                {\n                  SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 3:\n                {\n                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                default:\n                  break;\n              }\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      }\n    else\n      {\n        const char\n          *option;\n\n        int\n          byte;\n\n        PixelPacket\n          pixel;\n\n        /*\n          Convert DCM Medical image to pixel packets.\n        */\n        byte=0;\n        i=0;\n        if ((window_center != 0) && (window_width == 0))\n          window_width=(size_t) window_center;\n        option=GetImageOption(image_info,\"dcm:display-range\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"reset\") == 0)\n              window_width=0;\n          }\n        (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (samples_per_pixel == 1)\n              {\n                int\n                  pixel_value;\n\n                if (bytes_per_pixel == 1)\n                  pixel_value=polarity != MagickFalse ?\n                    ((int) max_value-ReadDCMByte(stream_info,image)) :\n                    ReadDCMByte(stream_info,image);\n                else\n                  if ((bits_allocated != 12) || (significant_bits != 12))\n                    {\n                      if (signed_data)\n                        pixel_value=ReadDCMSignedShort(stream_info,image);\n                      else\n                        pixel_value=ReadDCMShort(stream_info,image);\n                      if (polarity != MagickFalse)\n                        pixel_value=(int)max_value-pixel_value;\n                    }\n                  else\n                    {\n                      if ((i & 0x01) != 0)\n                        pixel_value=(ReadDCMByte(stream_info,image) << 8) |\n                          byte;\n                      else\n                        {\n                          pixel_value=ReadDCMSignedShort(stream_info,image);\n                          byte=(int) (pixel_value & 0x0f);\n                          pixel_value>>=4;\n                        }\n                      i++;\n                    }\n                index=(pixel_value*rescale_slope)+rescale_intercept;\n                if (window_width == 0)\n                  {\n                    if (signed_data == 1)\n                      index-=32767;\n                  }\n                else\n                  {\n                    ssize_t\n                      window_max,\n                      window_min;\n\n                    window_min=(ssize_t) ceil((double) window_center-\n                      (window_width-1.0)/2.0-0.5);\n                    window_max=(ssize_t) floor((double) window_center+\n                      (window_width-1.0)/2.0+0.5);\n                    if ((ssize_t)index <= window_min)\n                      index=0;\n                    else\n                      if ((ssize_t)index > window_max)\n                        index=(int) max_value;\n                      else\n                        index=(int) (max_value*(((index-window_center-\n                          0.5)/(window_width-1))+0.5));\n                  }\n                index&=mask;\n                index=(int) ConstrainColormapIndex(image,(size_t) index,\n                  exception);\n                SetPixelIndex(image,(Quantum) index,q);\n                pixel.red=(unsigned int) image->colormap[index].red;\n                pixel.green=(unsigned int) image->colormap[index].green;\n                pixel.blue=(unsigned int) image->colormap[index].blue;\n              }\n            else\n              {\n                if (bytes_per_pixel == 1)\n                  {\n                    pixel.red=(unsigned int) ReadDCMByte(stream_info,image);\n                    pixel.green=(unsigned int) ReadDCMByte(stream_info,image);\n                    pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);\n                  }\n                else\n                  {\n                    pixel.red=ReadDCMShort(stream_info,image);\n                    pixel.green=ReadDCMShort(stream_info,image);\n                    pixel.blue=ReadDCMShort(stream_info,image);\n                  }\n                pixel.red&=mask;\n                pixel.green&=mask;\n                pixel.blue&=mask;\n                if (scale != (Quantum *) NULL)\n                  {\n                    pixel.red=scale[pixel.red];\n                    pixel.green=scale[pixel.green];\n                    pixel.blue=scale[pixel.blue];\n                  }\n              }\n            SetPixelRed(image,(Quantum) pixel.red,q);\n            SetPixelGreen(image,(Quantum) pixel.green,q);\n            SetPixelBlue(image,(Quantum) pixel.blue,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (stream_info->segment_count > 1)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (samples_per_pixel == 1)\n                {\n                  int\n                    pixel_value;\n\n                  if (bytes_per_pixel == 1)\n                    pixel_value=polarity != MagickFalse ?\n                      ((int) max_value-ReadDCMByte(stream_info,image)) :\n                      ReadDCMByte(stream_info,image);\n                  else\n                    if ((bits_allocated != 12) || (significant_bits != 12))\n                      {\n                        pixel_value=(int) (polarity != MagickFalse ?\n                          (max_value-ReadDCMShort(stream_info,image)) :\n                          ReadDCMShort(stream_info,image));\n                        if (signed_data == 1)\n                          pixel_value=((signed short) pixel_value);\n                      }\n                    else\n                      {\n                        if ((i & 0x01) != 0)\n                          pixel_value=(ReadDCMByte(stream_info,image) << 8) |\n                            byte;\n                        else\n                          {\n                            pixel_value=ReadDCMShort(stream_info,image);\n                            byte=(int) (pixel_value & 0x0f);\n                            pixel_value>>=4;\n                          }\n                        i++;\n                      }\n                  index=(pixel_value*rescale_slope)+rescale_intercept;\n                  if (window_width == 0)\n                    {\n                      if (signed_data == 1)\n                        index-=32767;\n                    }\n                  else\n                    {\n                      ssize_t\n                        window_max,\n                        window_min;\n\n                      window_min=(ssize_t) ceil((double) window_center-\n                        (window_width-1.0)/2.0-0.5);\n                      window_max=(ssize_t) floor((double) window_center+\n                        (window_width-1.0)/2.0+0.5);\n                      if ((ssize_t)index <= window_min)\n                        index=0;\n                      else\n                        if ((ssize_t)index > window_max)\n                          index=(int) max_value;\n                        else\n                          index=(int) (max_value*(((index-window_center-\n                            0.5)/(window_width-1))+0.5));\n                    }\n                  index&=mask;\n                  index=(int) ConstrainColormapIndex(image,(size_t) index,\n                    exception);\n                  SetPixelIndex(image,(Quantum) (((size_t)\n                    GetPixelIndex(image,q)) | (((size_t) index) << 8)),q);\n                  pixel.red=(unsigned int) image->colormap[index].red;\n                  pixel.green=(unsigned int) image->colormap[index].green;\n                  pixel.blue=(unsigned int) image->colormap[index].blue;\n                }\n              else\n                {\n                  if (bytes_per_pixel == 1)\n                    {\n                      pixel.red=(unsigned int) ReadDCMByte(stream_info,image);\n                      pixel.green=(unsigned int) ReadDCMByte(stream_info,image);\n                      pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);\n                    }\n                  else\n                    {\n                      pixel.red=ReadDCMShort(stream_info,image);\n                      pixel.green=ReadDCMShort(stream_info,image);\n                      pixel.blue=ReadDCMShort(stream_info,image);\n                    }\n                  pixel.red&=mask;\n                  pixel.green&=mask;\n                  pixel.blue&=mask;\n                  if (scale != (Quantum *) NULL)\n                    {\n                      pixel.red=scale[pixel.red];\n                      pixel.green=scale[pixel.green];\n                      pixel.blue=scale[pixel.blue];\n                    }\n                }\n              SetPixelRed(image,(Quantum) (((size_t) GetPixelRed(image,q)) |\n                (((size_t) pixel.red) << 8)),q);\n              SetPixelGreen(image,(Quantum) (((size_t) GetPixelGreen(image,q)) |\n                (((size_t) pixel.green) << 8)),q);\n              SetPixelBlue(image,(Quantum) (((size_t) GetPixelBlue(image,q)) |\n                (((size_t) pixel.blue) << 8)),q);\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n      }\n    if (SetImageGray(image,exception) != MagickFalse)\n      (void) SetImageColorspace(image,GRAYColorspace,exception);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (scene < (ssize_t) (number_scenes-1))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  /*\n    Free resources.\n  */\n  if (stream_info->offsets != (ssize_t *) NULL)\n    stream_info->offsets=(ssize_t *)\n      RelinquishMagickMemory(stream_info->offsets);\n  stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (scale != (Quantum *) NULL)\n    scale=(Quantum *) RelinquishMagickMemory(scale);\n  if (graymap != (int *) NULL)\n    graymap=(int *) RelinquishMagickMemory(graymap);\n  if (bluemap != (int *) NULL)\n    bluemap=(int *) RelinquishMagickMemory(bluemap);\n  if (greenmap != (int *) NULL)\n    greenmap=(int *) RelinquishMagickMemory(greenmap);\n  if (redmap != (int *) NULL)\n    redmap=(int *) RelinquishMagickMemory(redmap);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149610,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    explicit_vr[MagickPathExtent],\n    implicit_vr[MagickPathExtent],\n    magick[MagickPathExtent],\n    photometric[MagickPathExtent];\n\n  DCMStreamInfo\n    *stream_info;\n\n  Image\n    *image;\n\n  int\n    *bluemap,\n    datum,\n    *greenmap,\n    *graymap,\n    index,\n    *redmap;\n\n  MagickBooleanType\n    explicit_file,\n    explicit_retry,\n    polarity,\n    sequence,\n    use_explicit;\n\n  MagickOffsetType\n    offset;\n\n  Quantum\n    *scale;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_allocated,\n    bytes_per_pixel,\n    colors,\n    depth,\n    height,\n    length,\n    mask,\n    max_value,\n    number_scenes,\n    quantum,\n    samples_per_pixel,\n    signed_data,\n    significant_bits,\n    status,\n    width,\n    window_width;\n\n  ssize_t\n    count,\n    rescale_intercept,\n    rescale_slope,\n    scene,\n    window_center,\n    y;\n\n  unsigned char\n    *data;\n\n  unsigned short\n    group,\n    element;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=8UL;\n  image->endian=LSBEndian;\n  /*\n    Read DCM preamble.\n  */\n  stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));\n  if (stream_info == (DCMStreamInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(stream_info,0,sizeof(*stream_info));\n  count=ReadBlob(image,128,(unsigned char *) magick);\n  if (count != 128)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  if ((count != 4) || (LocaleNCompare(magick,\"DICM\",4) != 0))\n    {\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  /*\n    Read DCM Medical image.\n  */\n  (void) CopyMagickString(photometric,\"MONOCHROME1 \",MagickPathExtent);\n  bits_allocated=8;\n  bytes_per_pixel=1;\n  polarity=MagickFalse;\n  data=(unsigned char *) NULL;\n  depth=8;\n  element=0;\n  explicit_vr[2]='\\0';\n  explicit_file=MagickFalse;\n  colors=0;\n  redmap=(int *) NULL;\n  greenmap=(int *) NULL;\n  bluemap=(int *) NULL;\n  graymap=(int *) NULL;\n  height=0;\n  max_value=255UL;\n  mask=0xffff;\n  number_scenes=1;\n  rescale_intercept=0;\n  rescale_slope=1;\n  samples_per_pixel=1;\n  scale=(Quantum *) NULL;\n  sequence=MagickFalse;\n  signed_data=(~0UL);\n  significant_bits=0;\n  use_explicit=MagickFalse;\n  explicit_retry = MagickFalse;\n  width=0;\n  window_center=0;\n  window_width=0;\n  for (group=0; (group != 0x7FE0) || (element != 0x0010) ||\n                (sequence != MagickFalse); )\n  {\n    /*\n      Read a group.\n    */\n    image->offset=(ssize_t) TellBlob(image);\n    group=ReadBlobLSBShort(image);\n    element=ReadBlobLSBShort(image);\n    if ((group != 0x0002) && (image->endian == MSBEndian))\n      {\n        group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));\n        element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));\n      }\n    quantum=0;\n    /*\n      Find corresponding VR for this group and element.\n    */\n    for (i=0; dicom_info[i].group < 0xffff; i++)\n      if ((group == dicom_info[i].group) && (element == dicom_info[i].element))\n        break;\n    (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);\n    count=ReadBlob(image,2,(unsigned char *) explicit_vr);\n    if (count != 2)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    /*\n      Check for \"explicitness\", but meta-file headers always explicit.\n    */\n    if ((explicit_file == MagickFalse) && (group != 0x0002))\n      explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&\n        (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?\n        MagickTrue : MagickFalse;\n    use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||\n      (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;\n    if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,\"xs\",2) == 0))\n      (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);\n    if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,\"!!\",2) == 0))\n      {\n        offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        quantum=4;\n      }\n    else\n      {\n        /*\n          Assume explicit type.\n        */\n        quantum=2;\n        if ((strncmp(explicit_vr,\"OB\",2) == 0) ||\n            (strncmp(explicit_vr,\"UN\",2) == 0) ||\n            (strncmp(explicit_vr,\"OW\",2) == 0) ||\n            (strncmp(explicit_vr,\"SQ\",2) == 0))\n          {\n            (void) ReadBlobLSBShort(image);\n            quantum=4;\n          }\n      }\n    datum=0;\n    if (quantum == 4)\n      {\n        if (group == 0x0002)\n          datum=ReadBlobLSBSignedLong(image);\n        else\n          datum=ReadBlobSignedLong(image);\n      }\n    else\n      if (quantum == 2)\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedShort(image);\n          else\n            datum=ReadBlobSignedShort(image);\n        }\n    quantum=0;\n    length=1;\n    if (datum != 0)\n      {\n        if ((strncmp(implicit_vr,\"SS\",2) == 0) ||\n            (strncmp(implicit_vr,\"US\",2) == 0))\n          quantum=2;\n        else\n          if ((strncmp(implicit_vr,\"UL\",2) == 0) ||\n              (strncmp(implicit_vr,\"SL\",2) == 0) ||\n              (strncmp(implicit_vr,\"FL\",2) == 0))\n            quantum=4;\n          else\n            if (strncmp(implicit_vr,\"FD\",2) != 0)\n              quantum=1;\n            else\n              quantum=8;\n        if (datum != ~0)\n          length=(size_t) datum/quantum;\n        else\n          {\n            /*\n              Sequence and item of undefined length.\n            */\n            quantum=0;\n            length=0;\n          }\n      }\n    if (image_info->verbose != MagickFalse)\n      {\n        /*\n          Display Dicom info.\n        */\n        if (use_explicit == MagickFalse)\n          explicit_vr[0]='\\0';\n        for (i=0; dicom_info[i].description != (char *) NULL; i++)\n          if ((group == dicom_info[i].group) &&\n              (element == dicom_info[i].element))\n            break;\n        (void) FormatLocaleFile(stdout,\"0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)\",\n          (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,\n          (unsigned long) group,(unsigned long) element);\n        if (dicom_info[i].description != (char *) NULL)\n          (void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);\n        (void) FormatLocaleFile(stdout,\": \");\n      }\n    if ((sequence == MagickFalse) && (group == 0x7FE0) && (element == 0x0010))\n      {\n        if (image_info->verbose != MagickFalse)\n          (void) FormatLocaleFile(stdout,\"\\n\");\n        break;\n      }\n    /*\n      Allocate space and read an array.\n    */\n    data=(unsigned char *) NULL;\n    if ((length == 1) && (quantum == 1))\n      datum=ReadBlobByte(image);\n    else\n      if ((length == 1) && (quantum == 2))\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedShort(image);\n          else\n            datum=ReadBlobSignedShort(image);\n        }\n      else\n        if ((length == 1) && (quantum == 4))\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedLong(image);\n            else\n              datum=ReadBlobSignedLong(image);\n          }\n        else\n          if ((quantum != 0) && (length != 0))\n            {\n              if (~length >= 1)\n                data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*\n                  sizeof(*data));\n              if (data == (unsigned char *) NULL)\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              count=ReadBlob(image,(size_t) quantum*length,data);\n              if (count != (ssize_t) (quantum*length))\n                {\n                  if (image_info->verbose != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"\n                      \"length=%d group=%d\\n\",(int) count,(int) quantum,(int)\n                      length,(int) group);\n                   ThrowReaderException(CorruptImageError,\n                     \"InsufficientImageDataInFile\");\n                }\n              data[length*quantum]='\\0';\n            }\n          else\n            if ((unsigned int) datum == 0xFFFFFFFFU)\n              {\n                sequence=MagickTrue;\n                continue;\n              }\n\n    if ((unsigned int) ((group << 16) | element) == 0xFFFEE0DD)\n      {\n        if (data != (unsigned char *) NULL)\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        sequence=MagickFalse;\n        continue;\n      }\n\n    if (sequence != MagickFalse)\n      {\n        if (data != (unsigned char *) NULL)\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        continue;\n      }\n\n    switch (group)\n    {\n      case 0x0002:\n      {\n        switch (element)\n        {\n          case 0x0010:\n          {\n            char\n              transfer_syntax[MagickPathExtent];\n\n            /*\n              Transfer Syntax.\n            */\n            if ((datum == 0) && (explicit_retry == MagickFalse))\n              {\n                explicit_retry=MagickTrue;\n                (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);\n                group=0;\n                element=0;\n                if (image_info->verbose != MagickFalse)\n                  (void) FormatLocaleFile(stdout,\n                    \"Corrupted image - trying explicit format\\n\");\n                break;\n              }\n            *transfer_syntax='\\0';\n            if (data != (unsigned char *) NULL)\n              (void) CopyMagickString(transfer_syntax,(char *) data,\n                MagickPathExtent);\n            if (image_info->verbose != MagickFalse)\n              (void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",\n                (const char *) transfer_syntax);\n            if (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)\n              {\n                int\n                  count,\n                  subtype,\n                  type;\n\n                type=1;\n                subtype=0;\n                if (strlen(transfer_syntax) > 17)\n                  {\n                    count=sscanf(transfer_syntax+17,\".%d.%d\",&type,&subtype);\n                    if (count < 1)\n                      ThrowReaderException(CorruptImageError,\n                        \"ImproperImageHeader\");\n                  }\n                switch (type)\n                {\n                  case 1:\n                  {\n                    image->endian=LSBEndian;\n                    break;\n                  }\n                  case 2:\n                  {\n                    image->endian=MSBEndian;\n                    break;\n                  }\n                  case 4:\n                  {\n                    if ((subtype >= 80) && (subtype <= 81))\n                      image->compression=JPEGCompression;\n                    else\n                      if ((subtype >= 90) && (subtype <= 93))\n                        image->compression=JPEG2000Compression;\n                      else\n                        image->compression=JPEGCompression;\n                    break;\n                  }\n                  case 5:\n                  {\n                    image->compression=RLECompression;\n                    break;\n                  }\n                }\n              }\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      case 0x0028:\n      {\n        switch (element)\n        {\n          case 0x0002:\n          {\n            /*\n              Samples per pixel.\n            */\n            samples_per_pixel=(size_t) datum;\n            break;\n          }\n          case 0x0004:\n          {\n            /*\n              Photometric interpretation.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)\n              photometric[i]=(char) data[i];\n            photometric[i]='\\0';\n            polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?\n              MagickTrue : MagickFalse;\n            break;\n          }\n          case 0x0006:\n          {\n            /*\n              Planar configuration.\n            */\n            if (datum == 1)\n              image->interlace=PlaneInterlace;\n            break;\n          }\n          case 0x0008:\n          {\n            /*\n              Number of frames.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            number_scenes=StringToUnsignedLong((char *) data);\n            break;\n          }\n          case 0x0010:\n          {\n            /*\n              Image rows.\n            */\n            height=(size_t) datum;\n            break;\n          }\n          case 0x0011:\n          {\n            /*\n              Image columns.\n            */\n            width=(size_t) datum;\n            break;\n          }\n          case 0x0100:\n          {\n            /*\n              Bits allocated.\n            */\n            bits_allocated=(size_t) datum;\n            bytes_per_pixel=1;\n            if (datum > 8)\n              bytes_per_pixel=2;\n            depth=bits_allocated;\n            if (depth > 32)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            max_value=(1UL << bits_allocated)-1;\n            break;\n          }\n          case 0x0101:\n          {\n            /*\n              Bits stored.\n            */\n            significant_bits=(size_t) datum;\n            bytes_per_pixel=1;\n            if (significant_bits > 8)\n              bytes_per_pixel=2;\n            depth=significant_bits;\n            if (depth > 32)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            max_value=(1UL << significant_bits)-1;\n            mask=(size_t) GetQuantumRange(significant_bits);\n            break;\n          }\n          case 0x0102:\n          {\n            /*\n              High bit.\n            */\n            break;\n          }\n          case 0x0103:\n          {\n            /*\n              Pixel representation.\n            */\n            signed_data=(size_t) datum;\n            break;\n          }\n          case 0x1050:\n          {\n            /*\n              Visible pixel range: center.\n            */\n            if (data != (unsigned char *) NULL)\n              window_center=(ssize_t) StringToLong((char *) data);\n            break;\n          }\n          case 0x1051:\n          {\n            /*\n              Visible pixel range: width.\n            */\n            if (data != (unsigned char *) NULL)\n              window_width=StringToUnsignedLong((char *) data);\n            break;\n          }\n          case 0x1052:\n          {\n            /*\n              Rescale intercept\n            */\n            if (data != (unsigned char *) NULL)\n              rescale_intercept=(ssize_t) StringToLong((char *) data);\n            break;\n          }\n          case 0x1053:\n          {\n            /*\n              Rescale slope\n            */\n            if (data != (unsigned char *) NULL)\n              rescale_slope=(ssize_t) StringToLong((char *) data);\n            break;\n          }\n          case 0x1200:\n          case 0x3006:\n          {\n            /*\n              Populate graymap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/bytes_per_pixel);\n            datum=(int) colors;\n            graymap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*graymap));\n            if (graymap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            for (i=0; i < (ssize_t) colors; i++)\n              if (bytes_per_pixel == 1)\n                graymap[i]=(int) data[i];\n              else\n                graymap[i]=(int) ((short *) data)[i];\n            break;\n          }\n          case 0x1201:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate redmap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            redmap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*redmap));\n            if (redmap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              redmap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          case 0x1202:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate greenmap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            greenmap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*greenmap));\n            if (greenmap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              greenmap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          case 0x1203:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate bluemap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            bluemap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*bluemap));\n            if (bluemap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              bluemap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      case 0x2050:\n      {\n        switch (element)\n        {\n          case 0x0020:\n          {\n            if ((data != (unsigned char *) NULL) &&\n                (strncmp((char *) data,\"INVERSE\",7) == 0))\n              polarity=MagickTrue;\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      default:\n        break;\n    }\n    if (data != (unsigned char *) NULL)\n      {\n        char\n          *attribute;\n\n        for (i=0; dicom_info[i].description != (char *) NULL; i++)\n          if ((group == dicom_info[i].group) &&\n              (element == dicom_info[i].element))\n            break;\n        if (dicom_info[i].description != (char *) NULL)\n          {\n            attribute=AcquireString(\"dcm:\");\n            (void) ConcatenateString(&attribute,dicom_info[i].description);\n            for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n              if (isprint((int) data[i]) == MagickFalse)\n                break;\n            if ((i == (ssize_t) length) || (length > 4))\n              {\n                (void) SubstituteString(&attribute,\" \",\"\");\n                (void) SetImageProperty(image,attribute,(char *) data,exception);\n              }\n            attribute=DestroyString(attribute);\n          }\n      }\n    if (image_info->verbose != MagickFalse)\n      {\n        if (data == (unsigned char *) NULL)\n          (void) FormatLocaleFile(stdout,\"%d\\n\",datum);\n        else\n          {\n            /*\n              Display group data.\n            */\n            for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n              if (isprint((int) data[i]) == MagickFalse)\n                break;\n            if ((i != (ssize_t) length) && (length <= 4))\n              {\n                ssize_t\n                  j;\n\n                datum=0;\n                for (j=(ssize_t) length-1; j >= 0; j--)\n                  datum=(256*datum+data[j]);\n                (void) FormatLocaleFile(stdout,\"%d\",datum);\n              }\n            else\n              for (i=0; i < (ssize_t) length; i++)\n                if (isprint((int) data[i]) != MagickFalse)\n                  (void) FormatLocaleFile(stdout,\"%c\",data[i]);\n                else\n                  (void) FormatLocaleFile(stdout,\"%c\",'.');\n            (void) FormatLocaleFile(stdout,\"\\n\");\n          }\n      }\n    if (data != (unsigned char *) NULL)\n      data=(unsigned char *) RelinquishMagickMemory(data);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n  }\n  if ((width == 0) || (height == 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  image->columns=(size_t) width;\n  image->rows=(size_t) height;\n  if (signed_data == 0xffff)\n    signed_data=(size_t) (significant_bits == 16 ? 1 : 0);\n  if ((image->compression == JPEGCompression) ||\n      (image->compression == JPEG2000Compression))\n    {\n      Image\n        *images;\n\n      ImageInfo\n        *read_info;\n\n      int\n        c;\n\n      size_t\n        length;\n\n      unsigned int\n        tag;\n\n      /*\n        Read offset table.\n      */\n      for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        (void) ReadBlobByte(image);\n      tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n      (void) tag;\n      length=(size_t) ReadBlobLSBLong(image);\n      stream_info->offset_count=length >> 2;\n      if (stream_info->offset_count != 0)\n        {\n          MagickOffsetType\n            offset;\n\n          stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n            stream_info->offset_count,sizeof(*stream_info->offsets));\n          if (stream_info->offsets == (ssize_t *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          offset=TellBlob(image);\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]+=offset;\n        }\n      /*\n        Handle non-native image formats.\n      */\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      images=NewImageList();\n      for (scene=0; scene < (ssize_t) number_scenes; scene++)\n      {\n        char\n          filename[MagickPathExtent];\n\n        const char\n          *property;\n\n        FILE\n          *file;\n\n        Image\n          *jpeg_image;\n\n        int\n          unique_file;\n\n        unsigned int\n          tag;\n\n        tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n        length=(size_t) ReadBlobLSBLong(image);\n        if (tag == 0xFFFEE0DD)\n          break; /* sequence delimiter tag */\n        if (tag != 0xFFFEE000)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if (file == (FILE *) NULL)\n          {\n            (void) RelinquishUniqueFileResource(filename);\n            ThrowFileException(exception,FileOpenError,\n              \"UnableToCreateTemporaryFile\",filename);\n            break;\n          }\n        for ( ; length != 0; length--)\n        {\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          (void) fputc(c,file);\n        }\n        (void) fclose(file);\n        (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n          \"jpeg:%s\",filename);\n        if (image->compression == JPEG2000Compression)\n          (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n            \"j2k:%s\",filename);\n        jpeg_image=ReadImage(read_info,exception);\n        if (jpeg_image != (Image *) NULL)\n          {\n            ResetImagePropertyIterator(image);\n            property=GetNextImageProperty(image);\n            while (property != (const char *) NULL)\n            {\n              (void) SetImageProperty(jpeg_image,property,\n                GetImageProperty(image,property,exception),exception);\n              property=GetNextImageProperty(image);\n            }\n            AppendImageToList(&images,jpeg_image);\n          }\n        (void) RelinquishUniqueFileResource(filename);\n      }\n      read_info=DestroyImageInfo(read_info);\n      image=DestroyImage(image);\n      return(GetFirstImageInList(images));\n    }\n  if (depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))\n    {\n      QuantumAny\n        range;\n\n      size_t\n        length;\n\n      /*\n        Compute pixel scaling table.\n      */\n      length=(size_t) (GetQuantumRange(depth)+1);\n      scale=(Quantum *) AcquireQuantumMemory(length,sizeof(*scale));\n      if (scale == (Quantum *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      range=GetQuantumRange(depth);\n      for (i=0; i <= (ssize_t) GetQuantumRange(depth); i++)\n        scale[i]=ScaleAnyToQuantum((size_t) i,range);\n    }\n  if (image->compression == RLECompression)\n    {\n      size_t\n        length;\n\n      unsigned int\n        tag;\n\n      /*\n        Read RLE offset table.\n      */\n      for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        (void) ReadBlobByte(image);\n      tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n      (void) tag;\n      length=(size_t) ReadBlobLSBLong(image);\n      stream_info->offset_count=length >> 2;\n      if (stream_info->offset_count != 0)\n        {\n          MagickOffsetType\n            offset;\n\n          stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n            stream_info->offset_count,sizeof(*stream_info->offsets));\n          if (stream_info->offsets == (ssize_t *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          offset=TellBlob(image);\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]+=offset;\n        }\n    }\n  for (scene=0; scene < (ssize_t) number_scenes; scene++)\n  {\n    if (image_info->ping != MagickFalse)\n      break;\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=depth;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      break;\n    image->colorspace=RGBColorspace;\n    if ((image->colormap == (PixelInfo *) NULL) && (samples_per_pixel == 1))\n      {\n        size_t\n          one;\n\n        one=1;\n        if (colors == 0)\n          colors=one << depth;\n        if (AcquireImageColormap(image,one << depth,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (redmap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=redmap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].red=(MagickRealType) index;\n          }\n        if (greenmap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=greenmap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].green=(MagickRealType) index;\n          }\n        if (bluemap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=bluemap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].blue=(MagickRealType) index;\n          }\n        if (graymap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=graymap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].red=(MagickRealType) index;\n            image->colormap[i].green=(MagickRealType) index;\n            image->colormap[i].blue=(MagickRealType) index;\n          }\n      }\n    if (image->compression == RLECompression)\n      {\n        unsigned int\n          tag;\n\n        /*\n          Read RLE segment table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          (void) ReadBlobByte(image);\n        tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n        stream_info->remaining=(size_t) ReadBlobLSBLong(image);\n        if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||\n            (EOFBlob(image) != MagickFalse))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        stream_info->count=0;\n        stream_info->segment_count=ReadBlobLSBLong(image);\n        if (stream_info->segment_count > 1)\n          {\n            bytes_per_pixel=1;\n            depth=8;\n          }\n        for (i=0; i < 15; i++)\n          stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n        stream_info->remaining-=64;\n      }\n    if ((samples_per_pixel > 1) && (image->interlace == PlaneInterlace))\n      {\n        /*\n          Convert Planar RGB DCM Medical image to pixel packets.\n        */\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              switch ((int) i)\n              {\n                case 0:\n                {\n                  SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 1:\n                {\n                  SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 2:\n                {\n                  SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 3:\n                {\n                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                default:\n                  break;\n              }\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      }\n    else\n      {\n        const char\n          *option;\n\n        int\n          byte;\n\n        PixelPacket\n          pixel;\n\n        /*\n          Convert DCM Medical image to pixel packets.\n        */\n        byte=0;\n        i=0;\n        if ((window_center != 0) && (window_width == 0))\n          window_width=(size_t) window_center;\n        option=GetImageOption(image_info,\"dcm:display-range\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"reset\") == 0)\n              window_width=0;\n          }\n        (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (samples_per_pixel == 1)\n              {\n                int\n                  pixel_value;\n\n                if (bytes_per_pixel == 1)\n                  pixel_value=polarity != MagickFalse ?\n                    ((int) max_value-ReadDCMByte(stream_info,image)) :\n                    ReadDCMByte(stream_info,image);\n                else\n                  if ((bits_allocated != 12) || (significant_bits != 12))\n                    {\n                      if (signed_data)\n                        pixel_value=ReadDCMSignedShort(stream_info,image);\n                      else\n                        pixel_value=ReadDCMShort(stream_info,image);\n                      if (polarity != MagickFalse)\n                        pixel_value=(int)max_value-pixel_value;\n                    }\n                  else\n                    {\n                      if ((i & 0x01) != 0)\n                        pixel_value=(ReadDCMByte(stream_info,image) << 8) |\n                          byte;\n                      else\n                        {\n                          pixel_value=ReadDCMSignedShort(stream_info,image);\n                          byte=(int) (pixel_value & 0x0f);\n                          pixel_value>>=4;\n                        }\n                      i++;\n                    }\n                index=(pixel_value*rescale_slope)+rescale_intercept;\n                if (window_width == 0)\n                  {\n                    if (signed_data == 1)\n                      index-=32767;\n                  }\n                else\n                  {\n                    ssize_t\n                      window_max,\n                      window_min;\n\n                    window_min=(ssize_t) ceil((double) window_center-\n                      (window_width-1.0)/2.0-0.5);\n                    window_max=(ssize_t) floor((double) window_center+\n                      (window_width-1.0)/2.0+0.5);\n                    if ((ssize_t)index <= window_min)\n                      index=0;\n                    else\n                      if ((ssize_t)index > window_max)\n                        index=(int) max_value;\n                      else\n                        index=(int) (max_value*(((index-window_center-\n                          0.5)/(window_width-1))+0.5));\n                  }\n                index&=mask;\n                index=(int) ConstrainColormapIndex(image,(size_t) index,\n                  exception);\n                SetPixelIndex(image,(Quantum) index,q);\n                pixel.red=(unsigned int) image->colormap[index].red;\n                pixel.green=(unsigned int) image->colormap[index].green;\n                pixel.blue=(unsigned int) image->colormap[index].blue;\n              }\n            else\n              {\n                if (bytes_per_pixel == 1)\n                  {\n                    pixel.red=(unsigned int) ReadDCMByte(stream_info,image);\n                    pixel.green=(unsigned int) ReadDCMByte(stream_info,image);\n                    pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);\n                  }\n                else\n                  {\n                    pixel.red=ReadDCMShort(stream_info,image);\n                    pixel.green=ReadDCMShort(stream_info,image);\n                    pixel.blue=ReadDCMShort(stream_info,image);\n                  }\n                pixel.red&=mask;\n                pixel.green&=mask;\n                pixel.blue&=mask;\n                if (scale != (Quantum *) NULL)\n                  {\n                    if (pixel.red <= GetQuantumRange(depth))\n                      pixel.red=scale[pixel.red];\n                    if (pixel.green <= GetQuantumRange(depth))\n                      pixel.green=scale[pixel.green];\n                    if (pixel.blue <= GetQuantumRange(depth))\n                      pixel.blue=scale[pixel.blue];\n                  }\n              }\n            SetPixelRed(image,(Quantum) pixel.red,q);\n            SetPixelGreen(image,(Quantum) pixel.green,q);\n            SetPixelBlue(image,(Quantum) pixel.blue,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (stream_info->segment_count > 1)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (samples_per_pixel == 1)\n                {\n                  int\n                    pixel_value;\n\n                  if (bytes_per_pixel == 1)\n                    pixel_value=polarity != MagickFalse ?\n                      ((int) max_value-ReadDCMByte(stream_info,image)) :\n                      ReadDCMByte(stream_info,image);\n                  else\n                    if ((bits_allocated != 12) || (significant_bits != 12))\n                      {\n                        pixel_value=(int) (polarity != MagickFalse ?\n                          (max_value-ReadDCMShort(stream_info,image)) :\n                          ReadDCMShort(stream_info,image));\n                        if (signed_data == 1)\n                          pixel_value=((signed short) pixel_value);\n                      }\n                    else\n                      {\n                        if ((i & 0x01) != 0)\n                          pixel_value=(ReadDCMByte(stream_info,image) << 8) |\n                            byte;\n                        else\n                          {\n                            pixel_value=ReadDCMShort(stream_info,image);\n                            byte=(int) (pixel_value & 0x0f);\n                            pixel_value>>=4;\n                          }\n                        i++;\n                      }\n                  index=(pixel_value*rescale_slope)+rescale_intercept;\n                  if (window_width == 0)\n                    {\n                      if (signed_data == 1)\n                        index-=32767;\n                    }\n                  else\n                    {\n                      ssize_t\n                        window_max,\n                        window_min;\n\n                      window_min=(ssize_t) ceil((double) window_center-\n                        (window_width-1.0)/2.0-0.5);\n                      window_max=(ssize_t) floor((double) window_center+\n                        (window_width-1.0)/2.0+0.5);\n                      if ((ssize_t)index <= window_min)\n                        index=0;\n                      else\n                        if ((ssize_t)index > window_max)\n                          index=(int) max_value;\n                        else\n                          index=(int) (max_value*(((index-window_center-\n                            0.5)/(window_width-1))+0.5));\n                    }\n                  index&=mask;\n                  index=(int) ConstrainColormapIndex(image,(size_t) index,\n                    exception);\n                  SetPixelIndex(image,(Quantum) (((size_t)\n                    GetPixelIndex(image,q)) | (((size_t) index) << 8)),q);\n                  pixel.red=(unsigned int) image->colormap[index].red;\n                  pixel.green=(unsigned int) image->colormap[index].green;\n                  pixel.blue=(unsigned int) image->colormap[index].blue;\n                }\n              else\n                {\n                  if (bytes_per_pixel == 1)\n                    {\n                      pixel.red=(unsigned int) ReadDCMByte(stream_info,image);\n                      pixel.green=(unsigned int) ReadDCMByte(stream_info,image);\n                      pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);\n                    }\n                  else\n                    {\n                      pixel.red=ReadDCMShort(stream_info,image);\n                      pixel.green=ReadDCMShort(stream_info,image);\n                      pixel.blue=ReadDCMShort(stream_info,image);\n                    }\n                  pixel.red&=mask;\n                  pixel.green&=mask;\n                  pixel.blue&=mask;\n                  if (scale != (Quantum *) NULL)\n                    {\n                      pixel.red=scale[pixel.red];\n                      pixel.green=scale[pixel.green];\n                      pixel.blue=scale[pixel.blue];\n                    }\n                }\n              SetPixelRed(image,(Quantum) (((size_t) GetPixelRed(image,q)) |\n                (((size_t) pixel.red) << 8)),q);\n              SetPixelGreen(image,(Quantum) (((size_t) GetPixelGreen(image,q)) |\n                (((size_t) pixel.green) << 8)),q);\n              SetPixelBlue(image,(Quantum) (((size_t) GetPixelBlue(image,q)) |\n                (((size_t) pixel.blue) << 8)),q);\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n      }\n    if (SetImageGray(image,exception) != MagickFalse)\n      (void) SetImageColorspace(image,GRAYColorspace,exception);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (scene < (ssize_t) (number_scenes-1))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  /*\n    Free resources.\n  */\n  if (stream_info->offsets != (ssize_t *) NULL)\n    stream_info->offsets=(ssize_t *)\n      RelinquishMagickMemory(stream_info->offsets);\n  stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (scale != (Quantum *) NULL)\n    scale=(Quantum *) RelinquishMagickMemory(scale);\n  if (graymap != (int *) NULL)\n    graymap=(int *) RelinquishMagickMemory(graymap);\n  if (bluemap != (int *) NULL)\n    bluemap=(int *) RelinquishMagickMemory(bluemap);\n  if (greenmap != (int *) NULL)\n    greenmap=(int *) RelinquishMagickMemory(greenmap);\n  if (redmap != (int *) NULL)\n    redmap=(int *) RelinquishMagickMemory(redmap);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149611,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n\tstruct sock *sk2;\n\tstruct alg_sock *ask2;\n\tstruct hash_ctx *ctx2;\n\tint err;\n\n\terr = crypto_ahash_export(req, state);\n\tif (err)\n\t\treturn err;\n\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\n\tsk2 = newsock->sk;\n\task2 = alg_sk(sk2);\n\tctx2 = ask2->private;\n\tctx2->more = 1;\n\n\terr = crypto_ahash_import(&ctx2->req, state);\n\tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149612,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n\tstruct sock *sk2;\n\tstruct alg_sock *ask2;\n\tstruct hash_ctx *ctx2;\n\tbool more;\n\tint err;\n\n\tlock_sock(sk);\n\tmore = ctx->more;\n\terr = more ? crypto_ahash_export(req, state) : 0;\n\trelease_sock(sk);\n\n\tif (err)\n\t\treturn err;\n\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\n\tsk2 = newsock->sk;\n\task2 = alg_sk(sk2);\n\tctx2 = ask2->private;\n\tctx2->more = more;\n\n\tif (!more)\n\t\treturn err;\n\n\terr = crypto_ahash_import(&ctx2->req, state);\n\tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149613,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " */\nstatic void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t**pce;\n\tzval\t\t\t\t*obj;\n\tzval\t\t\t\t*tmp;\n\tTSRMLS_FETCH();\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||\n\t\t!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||\n\t  \t!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||\n\t\t!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||\n\t\t!strcmp(name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (!ent1->data) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp(name, EL_BINARY)) {\n\t\t\tint new_len=0;\n\t\t\tunsigned char *new_str;\n\n\t\t\tnew_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);\n\t\t\tSTR_FREE(Z_STRVAL_P(ent1->data));\n\t\t\tZ_STRVAL_P(ent1->data) = new_str;\n\t\t\tZ_STRLEN_P(ent1->data) = new_len;\n\t\t}\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE_P(ent1->data) == IS_OBJECT) {\n\t\t\tzval *fname, *retval = NULL;\n\n\t\t\tMAKE_STD_ZVAL(fname);\n\t\t\tZVAL_STRING(fname, \"__wakeup\", 1);\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);\n\n\t\t\tzval_dtor(fname);\n\t\t\tFREE_ZVAL(fname);\n\t\t\tif (retval) {\n\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t}\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (ent2->type == ST_FIELD && ent2->data == NULL) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\tif (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),\n\t\t\t\t\t\t\t\t\t\t   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = &PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n\t\t\t\t\t\tobject_init_ex(obj, *pce);\n\n\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n\n\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\tent2->data = obj;\n\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE_P(ent2->data);\n\t\t\t\t\t\tZ_DELREF_P(ent1->data);\n\t\t\t\t\t\tadd_property_zval(ent2->data, ent1->varname, ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp(name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149614,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " */\nstatic void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t**pce;\n\tzval\t\t\t\t*obj;\n\tzval\t\t\t\t*tmp;\n\tTSRMLS_FETCH();\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||\n\t\t!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||\n\t  \t!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||\n\t\t!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||\n\t\t!strcmp(name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (!ent1->data) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp(name, EL_BINARY)) {\n\t\t\tint new_len=0;\n\t\t\tunsigned char *new_str;\n\n\t\t\tnew_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);\n\t\t\tSTR_FREE(Z_STRVAL_P(ent1->data));\n\t\t\tif (new_str) {\n\t\t\t\tZ_STRVAL_P(ent1->data) = new_str;\n\t\t\t\tZ_STRLEN_P(ent1->data) = new_len;\n\t\t\t} else {\n\t\t\t\tZVAL_EMPTY_STRING(ent1->data);\n\t\t\t}\n\t\t}\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE_P(ent1->data) == IS_OBJECT) {\n\t\t\tzval *fname, *retval = NULL;\n\n\t\t\tMAKE_STD_ZVAL(fname);\n\t\t\tZVAL_STRING(fname, \"__wakeup\", 1);\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);\n\n\t\t\tzval_dtor(fname);\n\t\t\tFREE_ZVAL(fname);\n\t\t\tif (retval) {\n\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t}\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (ent2->type == ST_FIELD && ent2->data == NULL) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\tif (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),\n\t\t\t\t\t\t\t\t\t\t   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = &PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n\t\t\t\t\t\tobject_init_ex(obj, *pce);\n\n\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n\n\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\tent2->data = obj;\n\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE_P(ent2->data);\n\t\t\t\t\t\tZ_DELREF_P(ent1->data);\n\t\t\t\t\t\tadd_property_zval(ent2->data, ent1->varname, ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp(name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149615,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "lexer_process_char_literal (parser_context_t *context_p, /**< context */\n                            const uint8_t *char_p, /**< characters */\n                            size_t length, /**< length of string */\n                            uint8_t literal_type, /**< final literal type */\n                            bool has_escape) /**< has escape sequences */\n{\n  parser_list_iterator_t literal_iterator;\n  lexer_literal_t *literal_p;\n  uint32_t literal_index = 0;\n\n  JERRY_ASSERT (literal_type == LEXER_IDENT_LITERAL\n                || literal_type == LEXER_STRING_LITERAL);\n\n  JERRY_ASSERT (literal_type != LEXER_IDENT_LITERAL || length <= PARSER_MAXIMUM_IDENT_LENGTH);\n  JERRY_ASSERT (literal_type != LEXER_STRING_LITERAL || length <= PARSER_MAXIMUM_STRING_LENGTH);\n\n  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n\n  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n  {\n    if (literal_p->type == literal_type\n        && literal_p->prop.length == length\n        && memcmp (literal_p->u.char_p, char_p, length) == 0)\n    {\n      context_p->lit_object.literal_p = literal_p;\n      context_p->lit_object.index = (uint16_t) literal_index;\n      literal_p->status_flags = (uint8_t) (literal_p->status_flags & ~LEXER_FLAG_UNUSED_IDENT);\n      return;\n    }\n\n    literal_index++;\n  }\n\n  JERRY_ASSERT (literal_index == context_p->literal_count);\n\n  if (literal_index >= PARSER_MAXIMUM_NUMBER_OF_LITERALS)\n  {\n    parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);\n  }\n\n  literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);\n  literal_p->prop.length = (uint16_t) length;\n  literal_p->type = literal_type;\n  literal_p->status_flags = has_escape ? 0 : LEXER_FLAG_SOURCE_PTR;\n\n  if (has_escape)\n  {\n    literal_p->u.char_p = (uint8_t *) jmem_heap_alloc_block (length);\n    memcpy ((uint8_t *) literal_p->u.char_p, char_p, length);\n  }\n  else\n  {\n    literal_p->u.char_p = char_p;\n  }\n\n  context_p->lit_object.literal_p = literal_p;\n  context_p->lit_object.index = (uint16_t) literal_index;\n  context_p->literal_count++;\n} /* lexer_process_char_literal */",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149714,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "lexer_process_char_literal (parser_context_t *context_p, /**< context */\n                            const uint8_t *char_p, /**< characters */\n                            size_t length, /**< length of string */\n                            uint8_t literal_type, /**< final literal type */\n                            bool has_escape) /**< has escape sequences */\n{\n  parser_list_iterator_t literal_iterator;\n  lexer_literal_t *literal_p;\n  uint32_t literal_index = 0;\n\n  JERRY_ASSERT (literal_type == LEXER_IDENT_LITERAL\n                || literal_type == LEXER_STRING_LITERAL);\n\n  JERRY_ASSERT (literal_type != LEXER_IDENT_LITERAL || length <= PARSER_MAXIMUM_IDENT_LENGTH);\n  JERRY_ASSERT (literal_type != LEXER_STRING_LITERAL || length <= PARSER_MAXIMUM_STRING_LENGTH);\n\n  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n\n  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n  {\n    if (literal_p->type == literal_type\n        && literal_p->prop.length == length\n        && memcmp (literal_p->u.char_p, char_p, length) == 0)\n    {\n      context_p->lit_object.literal_p = literal_p;\n      context_p->lit_object.index = (uint16_t) literal_index;\n      literal_p->status_flags = (uint8_t) (literal_p->status_flags & ~LEXER_FLAG_UNUSED_IDENT);\n      return;\n    }\n\n    literal_index++;\n  }\n\n  JERRY_ASSERT (literal_index == context_p->literal_count);\n\n  if (literal_index >= PARSER_MAXIMUM_NUMBER_OF_LITERALS)\n  {\n    parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);\n  }\n\n  if (length == 0)\n  {\n    has_escape = false;\n  }\n\n  literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);\n  literal_p->prop.length = (uint16_t) length;\n  literal_p->type = literal_type;\n  literal_p->status_flags = has_escape ? 0 : LEXER_FLAG_SOURCE_PTR;\n\n  if (has_escape)\n  {\n    literal_p->u.char_p = (uint8_t *) jmem_heap_alloc_block (length);\n    memcpy ((uint8_t *) literal_p->u.char_p, char_p, length);\n  }\n  else\n  {\n    literal_p->u.char_p = char_p;\n  }\n\n  context_p->lit_object.literal_p = literal_p;\n  context_p->lit_object.index = (uint16_t) literal_index;\n  context_p->literal_count++;\n} /* lexer_process_char_literal */",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149715,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "mrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n\n  if (mrb_immediate_p(self)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't clone %S\", self);\n  }\n  if (mrb_type(self) == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n  clone = mrb_obj_value(p);\n  init_copy(mrb, clone, self);\n  p->flags = mrb_obj_ptr(self)->flags;\n\n  return clone;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149716,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "mrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n\n  if (mrb_immediate_p(self)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't clone %S\", self);\n  }\n  if (mrb_type(self) == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n  clone = mrb_obj_value(p);\n  init_copy(mrb, clone, self);\n  p->flags |= mrb_obj_ptr(self)->flags & MRB_FLAG_IS_FROZEN;\n\n  return clone;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149717,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int __init big_key_init(void)\n{\n\treturn register_key_type(&key_type_big_key);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149718,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int __init big_key_init(void)\n{\n\tstruct crypto_skcipher *cipher;\n\tstruct crypto_rng *rng;\n\tint ret;\n\n\trng = crypto_alloc_rng(big_key_rng_name, 0, 0);\n\tif (IS_ERR(rng)) {\n\t\tpr_err(\"Can't alloc rng: %ld\\n\", PTR_ERR(rng));\n\t\treturn PTR_ERR(rng);\n\t}\n\n\tbig_key_rng = rng;\n\n\t/* seed RNG */\n\tret = crypto_rng_reset(rng, NULL, crypto_rng_seedsize(rng));\n\tif (ret) {\n\t\tpr_err(\"Can't reset rng: %d\\n\", ret);\n\t\tgoto error_rng;\n\t}\n\n\t/* init block cipher */\n\tcipher = crypto_alloc_skcipher(big_key_alg_name, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(cipher)) {\n\t\tret = PTR_ERR(cipher);\n\t\tpr_err(\"Can't alloc crypto: %d\\n\", ret);\n\t\tgoto error_rng;\n\t}\n\n\tbig_key_skcipher = cipher;\n\n\tret = register_key_type(&key_type_big_key);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't register type: %d\\n\", ret);\n\t\tgoto error_cipher;\n\t}\n\n\treturn 0;\n\nerror_cipher:\n\tcrypto_free_skcipher(big_key_skcipher);\nerror_rng:\n\tcrypto_free_rng(big_key_rng);\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149719,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int flattenSubquery(\n  Parse *pParse,       /* Parsing context */\n  Select *p,           /* The parent or outer SELECT statement */\n  int iFrom,           /* Index in p->pSrc->a[] of the inner subquery */\n  int isAgg            /* True if outer SELECT uses aggregate functions */\n){\n  const char *zSavedAuthContext = pParse->zAuthContext;\n  Select *pParent;    /* Current UNION ALL term of the other query */\n  Select *pSub;       /* The inner query or \"subquery\" */\n  Select *pSub1;      /* Pointer to the rightmost select in sub-query */\n  SrcList *pSrc;      /* The FROM clause of the outer query */\n  SrcList *pSubSrc;   /* The FROM clause of the subquery */\n  int iParent;        /* VDBE cursor number of the pSub result set temp table */\n  int iNewParent = -1;/* Replacement table for iParent */\n  int isLeftJoin = 0; /* True if pSub is the right side of a LEFT JOIN */    \n  int i;              /* Loop counter */\n  Expr *pWhere;                    /* The WHERE clause */\n  struct SrcList_item *pSubitem;   /* The subquery */\n  sqlite3 *db = pParse->db;\n\n  /* Check to see if flattening is permitted.  Return 0 if not.\n  */\n  assert( p!=0 );\n  assert( p->pPrior==0 );\n  if( OptimizationDisabled(db, SQLITE_QueryFlattener) ) return 0;\n  pSrc = p->pSrc;\n  assert( pSrc && iFrom>=0 && iFrom<pSrc->nSrc );\n  pSubitem = &pSrc->a[iFrom];\n  iParent = pSubitem->iCursor;\n  pSub = pSubitem->pSelect;\n  assert( pSub!=0 );\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  if( p->pWin || pSub->pWin ) return 0;                  /* Restriction (25) */\n#endif\n\n  pSubSrc = pSub->pSrc;\n  assert( pSubSrc );\n  /* Prior to version 3.1.2, when LIMIT and OFFSET had to be simple constants,\n  ** not arbitrary expressions, we allowed some combining of LIMIT and OFFSET\n  ** because they could be computed at compile-time.  But when LIMIT and OFFSET\n  ** became arbitrary expressions, we were forced to add restrictions (13)\n  ** and (14). */\n  if( pSub->pLimit && p->pLimit ) return 0;              /* Restriction (13) */\n  if( pSub->pLimit && pSub->pLimit->pRight ) return 0;   /* Restriction (14) */\n  if( (p->selFlags & SF_Compound)!=0 && pSub->pLimit ){\n    return 0;                                            /* Restriction (15) */\n  }\n  if( pSubSrc->nSrc==0 ) return 0;                       /* Restriction (7)  */\n  if( pSub->selFlags & SF_Distinct ) return 0;           /* Restriction (4)  */\n  if( pSub->pLimit && (pSrc->nSrc>1 || isAgg) ){\n     return 0;         /* Restrictions (8)(9) */\n  }\n  if( p->pOrderBy && pSub->pOrderBy ){\n     return 0;                                           /* Restriction (11) */\n  }\n  if( isAgg && pSub->pOrderBy ) return 0;                /* Restriction (16) */\n  if( pSub->pLimit && p->pWhere ) return 0;              /* Restriction (19) */\n  if( pSub->pLimit && (p->selFlags & SF_Distinct)!=0 ){\n     return 0;         /* Restriction (21) */\n  }\n  if( pSub->selFlags & (SF_Recursive) ){\n    return 0; /* Restrictions (22) */\n  }\n\n  /*\n  ** If the subquery is the right operand of a LEFT JOIN, then the\n  ** subquery may not be a join itself (3a). Example of why this is not\n  ** allowed:\n  **\n  **         t1 LEFT OUTER JOIN (t2 JOIN t3)\n  **\n  ** If we flatten the above, we would get\n  **\n  **         (t1 LEFT OUTER JOIN t2) JOIN t3\n  **\n  ** which is not at all the same thing.\n  **\n  ** If the subquery is the right operand of a LEFT JOIN, then the outer\n  ** query cannot be an aggregate. (3c)  This is an artifact of the way\n  ** aggregates are processed - there is no mechanism to determine if\n  ** the LEFT JOIN table should be all-NULL.\n  **\n  ** See also tickets #306, #350, and #3300.\n  */\n  if( (pSubitem->fg.jointype & JT_OUTER)!=0 ){\n    isLeftJoin = 1;\n    if( pSubSrc->nSrc>1 || isAgg || IsVirtual(pSubSrc->a[0].pTab) ){\n      /*  (3a)             (3c)     (3b) */\n      return 0;\n    }\n  }\n#ifdef SQLITE_EXTRA_IFNULLROW\n  else if( iFrom>0 && !isAgg ){\n    /* Setting isLeftJoin to -1 causes OP_IfNullRow opcodes to be generated for\n    ** every reference to any result column from subquery in a join, even\n    ** though they are not necessary.  This will stress-test the OP_IfNullRow \n    ** opcode. */\n    isLeftJoin = -1;\n  }\n#endif\n\n  /* Restriction (17): If the sub-query is a compound SELECT, then it must\n  ** use only the UNION ALL operator. And none of the simple select queries\n  ** that make up the compound SELECT are allowed to be aggregate or distinct\n  ** queries.\n  */\n  if( pSub->pPrior ){\n    if( pSub->pOrderBy ){\n      return 0;  /* Restriction (20) */\n    }\n    if( isAgg || (p->selFlags & SF_Distinct)!=0 || pSrc->nSrc!=1 ){\n      return 0; /* (17d1), (17d2), or (17d3) */\n    }\n    for(pSub1=pSub; pSub1; pSub1=pSub1->pPrior){\n      testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct );\n      testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Aggregate );\n      assert( pSub->pSrc!=0 );\n      assert( pSub->pEList->nExpr==pSub1->pEList->nExpr );\n      if( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))!=0    /* (17b) */\n       || (pSub1->pPrior && pSub1->op!=TK_ALL)                 /* (17a) */\n       || pSub1->pSrc->nSrc<1                                  /* (17c) */\n      ){\n        return 0;\n      }\n      testcase( pSub1->pSrc->nSrc>1 );\n    }\n\n    /* Restriction (18). */\n    if( p->pOrderBy ){\n      int ii;\n      for(ii=0; ii<p->pOrderBy->nExpr; ii++){\n        if( p->pOrderBy->a[ii].u.x.iOrderByCol==0 ) return 0;\n      }\n    }\n  }\n\n  /* Ex-restriction (23):\n  ** The only way that the recursive part of a CTE can contain a compound\n  ** subquery is for the subquery to be one term of a join.  But if the\n  ** subquery is a join, then the flattening has already been stopped by\n  ** restriction (17d3)\n  */\n  assert( (p->selFlags & SF_Recursive)==0 || pSub->pPrior==0 );\n\n  /***** If we reach this point, flattening is permitted. *****/\n  SELECTTRACE(1,pParse,p,(\"flatten %u.%p from term %d\\n\",\n                   pSub->selId, pSub, iFrom));\n\n  /* Authorize the subquery */\n  pParse->zAuthContext = pSubitem->zName;\n  TESTONLY(i =) sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0);\n  testcase( i==SQLITE_DENY );\n  pParse->zAuthContext = zSavedAuthContext;\n\n  /* If the sub-query is a compound SELECT statement, then (by restrictions\n  ** 17 and 18 above) it must be a UNION ALL and the parent query must \n  ** be of the form:\n  **\n  **     SELECT <expr-list> FROM (<sub-query>) <where-clause> \n  **\n  ** followed by any ORDER BY, LIMIT and/or OFFSET clauses. This block\n  ** creates N-1 copies of the parent query without any ORDER BY, LIMIT or \n  ** OFFSET clauses and joins them to the left-hand-side of the original\n  ** using UNION ALL operators. In this case N is the number of simple\n  ** select statements in the compound sub-query.\n  **\n  ** Example:\n  **\n  **     SELECT a+1 FROM (\n  **        SELECT x FROM tab\n  **        UNION ALL\n  **        SELECT y FROM tab\n  **        UNION ALL\n  **        SELECT abs(z*2) FROM tab2\n  **     ) WHERE a!=5 ORDER BY 1\n  **\n  ** Transformed into:\n  **\n  **     SELECT x+1 FROM tab WHERE x+1!=5\n  **     UNION ALL\n  **     SELECT y+1 FROM tab WHERE y+1!=5\n  **     UNION ALL\n  **     SELECT abs(z*2)+1 FROM tab2 WHERE abs(z*2)+1!=5\n  **     ORDER BY 1\n  **\n  ** We call this the \"compound-subquery flattening\".\n  */\n  for(pSub=pSub->pPrior; pSub; pSub=pSub->pPrior){\n    Select *pNew;\n    ExprList *pOrderBy = p->pOrderBy;\n    Expr *pLimit = p->pLimit;\n    Select *pPrior = p->pPrior;\n    p->pOrderBy = 0;\n    p->pSrc = 0;\n    p->pPrior = 0;\n    p->pLimit = 0;\n    pNew = sqlite3SelectDup(db, p, 0);\n    p->pLimit = pLimit;\n    p->pOrderBy = pOrderBy;\n    p->pSrc = pSrc;\n    p->op = TK_ALL;\n    if( pNew==0 ){\n      p->pPrior = pPrior;\n    }else{\n      pNew->pPrior = pPrior;\n      if( pPrior ) pPrior->pNext = pNew;\n      pNew->pNext = p;\n      p->pPrior = pNew;\n      SELECTTRACE(2,pParse,p,(\"compound-subquery flattener\"\n                              \" creates %u as peer\\n\",pNew->selId));\n    }\n    if( db->mallocFailed ) return 1;\n  }\n\n  /* Begin flattening the iFrom-th entry of the FROM clause \n  ** in the outer query.\n  */\n  pSub = pSub1 = pSubitem->pSelect;\n\n  /* Delete the transient table structure associated with the\n  ** subquery\n  */\n  sqlite3DbFree(db, pSubitem->zDatabase);\n  sqlite3DbFree(db, pSubitem->zName);\n  sqlite3DbFree(db, pSubitem->zAlias);\n  pSubitem->zDatabase = 0;\n  pSubitem->zName = 0;\n  pSubitem->zAlias = 0;\n  pSubitem->pSelect = 0;\n\n  /* Defer deleting the Table object associated with the\n  ** subquery until code generation is\n  ** complete, since there may still exist Expr.pTab entries that\n  ** refer to the subquery even after flattening.  Ticket #3346.\n  **\n  ** pSubitem->pTab is always non-NULL by test restrictions and tests above.\n  */\n  if( ALWAYS(pSubitem->pTab!=0) ){\n    Table *pTabToDel = pSubitem->pTab;\n    if( pTabToDel->nTabRef==1 ){\n      Parse *pToplevel = sqlite3ParseToplevel(pParse);\n      pTabToDel->pNextZombie = pToplevel->pZombieTab;\n      pToplevel->pZombieTab = pTabToDel;\n    }else{\n      pTabToDel->nTabRef--;\n    }\n    pSubitem->pTab = 0;\n  }\n\n  /* The following loop runs once for each term in a compound-subquery\n  ** flattening (as described above).  If we are doing a different kind\n  ** of flattening - a flattening other than a compound-subquery flattening -\n  ** then this loop only runs once.\n  **\n  ** This loop moves all of the FROM elements of the subquery into the\n  ** the FROM clause of the outer query.  Before doing this, remember\n  ** the cursor number for the original outer query FROM element in\n  ** iParent.  The iParent cursor will never be used.  Subsequent code\n  ** will scan expressions looking for iParent references and replace\n  ** those references with expressions that resolve to the subquery FROM\n  ** elements we are now copying in.\n  */\n  for(pParent=p; pParent; pParent=pParent->pPrior, pSub=pSub->pPrior){\n    int nSubSrc;\n    u8 jointype = 0;\n    assert( pSub!=0 );\n    pSubSrc = pSub->pSrc;     /* FROM clause of subquery */\n    nSubSrc = pSubSrc->nSrc;  /* Number of terms in subquery FROM clause */\n    pSrc = pParent->pSrc;     /* FROM clause of the outer query */\n\n    if( pSrc ){\n      assert( pParent==p );  /* First time through the loop */\n      jointype = pSubitem->fg.jointype;\n    }else{\n      assert( pParent!=p );  /* 2nd and subsequent times through the loop */\n      pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);\n      if( pSrc==0 ) break;\n      pParent->pSrc = pSrc;\n    }\n\n    /* The subquery uses a single slot of the FROM clause of the outer\n    ** query.  If the subquery has more than one element in its FROM clause,\n    ** then expand the outer query to make space for it to hold all elements\n    ** of the subquery.\n    **\n    ** Example:\n    **\n    **    SELECT * FROM tabA, (SELECT * FROM sub1, sub2), tabB;\n    **\n    ** The outer query has 3 slots in its FROM clause.  One slot of the\n    ** outer query (the middle slot) is used by the subquery.  The next\n    ** block of code will expand the outer query FROM clause to 4 slots.\n    ** The middle slot is expanded to two slots in order to make space\n    ** for the two elements in the FROM clause of the subquery.\n    */\n    if( nSubSrc>1 ){\n      pSrc = sqlite3SrcListEnlarge(pParse, pSrc, nSubSrc-1,iFrom+1);\n      if( pSrc==0 ) break;\n      pParent->pSrc = pSrc;\n    }\n\n    /* Transfer the FROM clause terms from the subquery into the\n    ** outer query.\n    */\n    for(i=0; i<nSubSrc; i++){\n      sqlite3IdListDelete(db, pSrc->a[i+iFrom].pUsing);\n      assert( pSrc->a[i+iFrom].fg.isTabFunc==0 );\n      pSrc->a[i+iFrom] = pSubSrc->a[i];\n      iNewParent = pSubSrc->a[i].iCursor;\n      memset(&pSubSrc->a[i], 0, sizeof(pSubSrc->a[i]));\n    }\n    pSrc->a[iFrom].fg.jointype = jointype;\n  \n    /* Now begin substituting subquery result set expressions for \n    ** references to the iParent in the outer query.\n    ** \n    ** Example:\n    **\n    **   SELECT a+5, b*10 FROM (SELECT x*3 AS a, y+10 AS b FROM t1) WHERE a>b;\n    **   \\                     \\_____________ subquery __________/          /\n    **    \\_____________________ outer query ______________________________/\n    **\n    ** We look at every expression in the outer query and every place we see\n    ** \"a\" we substitute \"x*3\" and every place we see \"b\" we substitute \"y+10\".\n    */\n    if( pSub->pOrderBy ){\n      /* At this point, any non-zero iOrderByCol values indicate that the\n      ** ORDER BY column expression is identical to the iOrderByCol'th\n      ** expression returned by SELECT statement pSub. Since these values\n      ** do not necessarily correspond to columns in SELECT statement pParent,\n      ** zero them before transfering the ORDER BY clause.\n      **\n      ** Not doing this may cause an error if a subsequent call to this\n      ** function attempts to flatten a compound sub-query into pParent\n      ** (the only way this can happen is if the compound sub-query is\n      ** currently part of pSub->pSrc). See ticket [d11a6e908f].  */\n      ExprList *pOrderBy = pSub->pOrderBy;\n      for(i=0; i<pOrderBy->nExpr; i++){\n        pOrderBy->a[i].u.x.iOrderByCol = 0;\n      }\n      assert( pParent->pOrderBy==0 );\n      pParent->pOrderBy = pOrderBy;\n      pSub->pOrderBy = 0;\n    }\n    pWhere = pSub->pWhere;\n    pSub->pWhere = 0;\n    if( isLeftJoin>0 ){\n      sqlite3SetJoinExpr(pWhere, iNewParent);\n    }\n    pParent->pWhere = sqlite3ExprAnd(pParse, pWhere, pParent->pWhere);\n    if( db->mallocFailed==0 ){\n      SubstContext x;\n      x.pParse = pParse;\n      x.iTable = iParent;\n      x.iNewTable = iNewParent;\n      x.isLeftJoin = isLeftJoin;\n      x.pEList = pSub->pEList;\n      substSelect(&x, pParent, 0);\n    }\n  \n    /* The flattened query is a compound if either the inner or the\n    ** outer query is a compound. */\n    pParent->selFlags |= pSub->selFlags & SF_Compound;\n    assert( (pSub->selFlags & SF_Distinct)==0 ); /* restriction (17b) */\n  \n    /*\n    ** SELECT ... FROM (SELECT ... LIMIT a OFFSET b) LIMIT x OFFSET y;\n    **\n    ** One is tempted to try to add a and b to combine the limits.  But this\n    ** does not work if either limit is negative.\n    */\n    if( pSub->pLimit ){\n      pParent->pLimit = pSub->pLimit;\n      pSub->pLimit = 0;\n    }\n  }\n\n  /* Finially, delete what is left of the subquery and return\n  ** success.\n  */\n  sqlite3SelectDelete(db, pSub1);\n\n#if SELECTTRACE_ENABLED\n  if( sqlite3SelectTrace & 0x100 ){\n    SELECTTRACE(0x100,pParse,p,(\"After flattening:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  return 1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149720,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int flattenSubquery(\n  Parse *pParse,       /* Parsing context */\n  Select *p,           /* The parent or outer SELECT statement */\n  int iFrom,           /* Index in p->pSrc->a[] of the inner subquery */\n  int isAgg            /* True if outer SELECT uses aggregate functions */\n){\n  const char *zSavedAuthContext = pParse->zAuthContext;\n  Select *pParent;    /* Current UNION ALL term of the other query */\n  Select *pSub;       /* The inner query or \"subquery\" */\n  Select *pSub1;      /* Pointer to the rightmost select in sub-query */\n  SrcList *pSrc;      /* The FROM clause of the outer query */\n  SrcList *pSubSrc;   /* The FROM clause of the subquery */\n  int iParent;        /* VDBE cursor number of the pSub result set temp table */\n  int iNewParent = -1;/* Replacement table for iParent */\n  int isLeftJoin = 0; /* True if pSub is the right side of a LEFT JOIN */    \n  int i;              /* Loop counter */\n  Expr *pWhere;                    /* The WHERE clause */\n  struct SrcList_item *pSubitem;   /* The subquery */\n  sqlite3 *db = pParse->db;\n\n  /* Check to see if flattening is permitted.  Return 0 if not.\n  */\n  assert( p!=0 );\n  assert( p->pPrior==0 );\n  if( OptimizationDisabled(db, SQLITE_QueryFlattener) ) return 0;\n  pSrc = p->pSrc;\n  assert( pSrc && iFrom>=0 && iFrom<pSrc->nSrc );\n  pSubitem = &pSrc->a[iFrom];\n  iParent = pSubitem->iCursor;\n  pSub = pSubitem->pSelect;\n  assert( pSub!=0 );\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  if( p->pWin || pSub->pWin ) return 0;                  /* Restriction (25) */\n#endif\n\n  pSubSrc = pSub->pSrc;\n  assert( pSubSrc );\n  /* Prior to version 3.1.2, when LIMIT and OFFSET had to be simple constants,\n  ** not arbitrary expressions, we allowed some combining of LIMIT and OFFSET\n  ** because they could be computed at compile-time.  But when LIMIT and OFFSET\n  ** became arbitrary expressions, we were forced to add restrictions (13)\n  ** and (14). */\n  if( pSub->pLimit && p->pLimit ) return 0;              /* Restriction (13) */\n  if( pSub->pLimit && pSub->pLimit->pRight ) return 0;   /* Restriction (14) */\n  if( (p->selFlags & SF_Compound)!=0 && pSub->pLimit ){\n    return 0;                                            /* Restriction (15) */\n  }\n  if( pSubSrc->nSrc==0 ) return 0;                       /* Restriction (7)  */\n  if( pSub->selFlags & SF_Distinct ) return 0;           /* Restriction (4)  */\n  if( pSub->pLimit && (pSrc->nSrc>1 || isAgg) ){\n     return 0;         /* Restrictions (8)(9) */\n  }\n  if( p->pOrderBy && pSub->pOrderBy ){\n     return 0;                                           /* Restriction (11) */\n  }\n  if( isAgg && pSub->pOrderBy ) return 0;                /* Restriction (16) */\n  if( pSub->pLimit && p->pWhere ) return 0;              /* Restriction (19) */\n  if( pSub->pLimit && (p->selFlags & SF_Distinct)!=0 ){\n     return 0;         /* Restriction (21) */\n  }\n  if( pSub->selFlags & (SF_Recursive) ){\n    return 0; /* Restrictions (22) */\n  }\n\n  /*\n  ** If the subquery is the right operand of a LEFT JOIN, then the\n  ** subquery may not be a join itself (3a). Example of why this is not\n  ** allowed:\n  **\n  **         t1 LEFT OUTER JOIN (t2 JOIN t3)\n  **\n  ** If we flatten the above, we would get\n  **\n  **         (t1 LEFT OUTER JOIN t2) JOIN t3\n  **\n  ** which is not at all the same thing.\n  **\n  ** If the subquery is the right operand of a LEFT JOIN, then the outer\n  ** query cannot be an aggregate. (3c)  This is an artifact of the way\n  ** aggregates are processed - there is no mechanism to determine if\n  ** the LEFT JOIN table should be all-NULL.\n  **\n  ** See also tickets #306, #350, and #3300.\n  */\n  if( (pSubitem->fg.jointype & JT_OUTER)!=0 ){\n    isLeftJoin = 1;\n    if( pSubSrc->nSrc>1                   /* (3a) */\n     || isAgg                             /* (3b) */\n     || IsVirtual(pSubSrc->a[0].pTab)     /* (3c) */\n     || (p->selFlags & SF_Distinct)!=0    /* (3d) */\n    ){\n      return 0;\n    }\n  }\n#ifdef SQLITE_EXTRA_IFNULLROW\n  else if( iFrom>0 && !isAgg ){\n    /* Setting isLeftJoin to -1 causes OP_IfNullRow opcodes to be generated for\n    ** every reference to any result column from subquery in a join, even\n    ** though they are not necessary.  This will stress-test the OP_IfNullRow \n    ** opcode. */\n    isLeftJoin = -1;\n  }\n#endif\n\n  /* Restriction (17): If the sub-query is a compound SELECT, then it must\n  ** use only the UNION ALL operator. And none of the simple select queries\n  ** that make up the compound SELECT are allowed to be aggregate or distinct\n  ** queries.\n  */\n  if( pSub->pPrior ){\n    if( pSub->pOrderBy ){\n      return 0;  /* Restriction (20) */\n    }\n    if( isAgg || (p->selFlags & SF_Distinct)!=0 || pSrc->nSrc!=1 ){\n      return 0; /* (17d1), (17d2), or (17d3) */\n    }\n    for(pSub1=pSub; pSub1; pSub1=pSub1->pPrior){\n      testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct );\n      testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Aggregate );\n      assert( pSub->pSrc!=0 );\n      assert( pSub->pEList->nExpr==pSub1->pEList->nExpr );\n      if( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))!=0    /* (17b) */\n       || (pSub1->pPrior && pSub1->op!=TK_ALL)                 /* (17a) */\n       || pSub1->pSrc->nSrc<1                                  /* (17c) */\n      ){\n        return 0;\n      }\n      testcase( pSub1->pSrc->nSrc>1 );\n    }\n\n    /* Restriction (18). */\n    if( p->pOrderBy ){\n      int ii;\n      for(ii=0; ii<p->pOrderBy->nExpr; ii++){\n        if( p->pOrderBy->a[ii].u.x.iOrderByCol==0 ) return 0;\n      }\n    }\n  }\n\n  /* Ex-restriction (23):\n  ** The only way that the recursive part of a CTE can contain a compound\n  ** subquery is for the subquery to be one term of a join.  But if the\n  ** subquery is a join, then the flattening has already been stopped by\n  ** restriction (17d3)\n  */\n  assert( (p->selFlags & SF_Recursive)==0 || pSub->pPrior==0 );\n\n  /***** If we reach this point, flattening is permitted. *****/\n  SELECTTRACE(1,pParse,p,(\"flatten %u.%p from term %d\\n\",\n                   pSub->selId, pSub, iFrom));\n\n  /* Authorize the subquery */\n  pParse->zAuthContext = pSubitem->zName;\n  TESTONLY(i =) sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0);\n  testcase( i==SQLITE_DENY );\n  pParse->zAuthContext = zSavedAuthContext;\n\n  /* If the sub-query is a compound SELECT statement, then (by restrictions\n  ** 17 and 18 above) it must be a UNION ALL and the parent query must \n  ** be of the form:\n  **\n  **     SELECT <expr-list> FROM (<sub-query>) <where-clause> \n  **\n  ** followed by any ORDER BY, LIMIT and/or OFFSET clauses. This block\n  ** creates N-1 copies of the parent query without any ORDER BY, LIMIT or \n  ** OFFSET clauses and joins them to the left-hand-side of the original\n  ** using UNION ALL operators. In this case N is the number of simple\n  ** select statements in the compound sub-query.\n  **\n  ** Example:\n  **\n  **     SELECT a+1 FROM (\n  **        SELECT x FROM tab\n  **        UNION ALL\n  **        SELECT y FROM tab\n  **        UNION ALL\n  **        SELECT abs(z*2) FROM tab2\n  **     ) WHERE a!=5 ORDER BY 1\n  **\n  ** Transformed into:\n  **\n  **     SELECT x+1 FROM tab WHERE x+1!=5\n  **     UNION ALL\n  **     SELECT y+1 FROM tab WHERE y+1!=5\n  **     UNION ALL\n  **     SELECT abs(z*2)+1 FROM tab2 WHERE abs(z*2)+1!=5\n  **     ORDER BY 1\n  **\n  ** We call this the \"compound-subquery flattening\".\n  */\n  for(pSub=pSub->pPrior; pSub; pSub=pSub->pPrior){\n    Select *pNew;\n    ExprList *pOrderBy = p->pOrderBy;\n    Expr *pLimit = p->pLimit;\n    Select *pPrior = p->pPrior;\n    p->pOrderBy = 0;\n    p->pSrc = 0;\n    p->pPrior = 0;\n    p->pLimit = 0;\n    pNew = sqlite3SelectDup(db, p, 0);\n    p->pLimit = pLimit;\n    p->pOrderBy = pOrderBy;\n    p->pSrc = pSrc;\n    p->op = TK_ALL;\n    if( pNew==0 ){\n      p->pPrior = pPrior;\n    }else{\n      pNew->pPrior = pPrior;\n      if( pPrior ) pPrior->pNext = pNew;\n      pNew->pNext = p;\n      p->pPrior = pNew;\n      SELECTTRACE(2,pParse,p,(\"compound-subquery flattener\"\n                              \" creates %u as peer\\n\",pNew->selId));\n    }\n    if( db->mallocFailed ) return 1;\n  }\n\n  /* Begin flattening the iFrom-th entry of the FROM clause \n  ** in the outer query.\n  */\n  pSub = pSub1 = pSubitem->pSelect;\n\n  /* Delete the transient table structure associated with the\n  ** subquery\n  */\n  sqlite3DbFree(db, pSubitem->zDatabase);\n  sqlite3DbFree(db, pSubitem->zName);\n  sqlite3DbFree(db, pSubitem->zAlias);\n  pSubitem->zDatabase = 0;\n  pSubitem->zName = 0;\n  pSubitem->zAlias = 0;\n  pSubitem->pSelect = 0;\n\n  /* Defer deleting the Table object associated with the\n  ** subquery until code generation is\n  ** complete, since there may still exist Expr.pTab entries that\n  ** refer to the subquery even after flattening.  Ticket #3346.\n  **\n  ** pSubitem->pTab is always non-NULL by test restrictions and tests above.\n  */\n  if( ALWAYS(pSubitem->pTab!=0) ){\n    Table *pTabToDel = pSubitem->pTab;\n    if( pTabToDel->nTabRef==1 ){\n      Parse *pToplevel = sqlite3ParseToplevel(pParse);\n      pTabToDel->pNextZombie = pToplevel->pZombieTab;\n      pToplevel->pZombieTab = pTabToDel;\n    }else{\n      pTabToDel->nTabRef--;\n    }\n    pSubitem->pTab = 0;\n  }\n\n  /* The following loop runs once for each term in a compound-subquery\n  ** flattening (as described above).  If we are doing a different kind\n  ** of flattening - a flattening other than a compound-subquery flattening -\n  ** then this loop only runs once.\n  **\n  ** This loop moves all of the FROM elements of the subquery into the\n  ** the FROM clause of the outer query.  Before doing this, remember\n  ** the cursor number for the original outer query FROM element in\n  ** iParent.  The iParent cursor will never be used.  Subsequent code\n  ** will scan expressions looking for iParent references and replace\n  ** those references with expressions that resolve to the subquery FROM\n  ** elements we are now copying in.\n  */\n  for(pParent=p; pParent; pParent=pParent->pPrior, pSub=pSub->pPrior){\n    int nSubSrc;\n    u8 jointype = 0;\n    assert( pSub!=0 );\n    pSubSrc = pSub->pSrc;     /* FROM clause of subquery */\n    nSubSrc = pSubSrc->nSrc;  /* Number of terms in subquery FROM clause */\n    pSrc = pParent->pSrc;     /* FROM clause of the outer query */\n\n    if( pSrc ){\n      assert( pParent==p );  /* First time through the loop */\n      jointype = pSubitem->fg.jointype;\n    }else{\n      assert( pParent!=p );  /* 2nd and subsequent times through the loop */\n      pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);\n      if( pSrc==0 ) break;\n      pParent->pSrc = pSrc;\n    }\n\n    /* The subquery uses a single slot of the FROM clause of the outer\n    ** query.  If the subquery has more than one element in its FROM clause,\n    ** then expand the outer query to make space for it to hold all elements\n    ** of the subquery.\n    **\n    ** Example:\n    **\n    **    SELECT * FROM tabA, (SELECT * FROM sub1, sub2), tabB;\n    **\n    ** The outer query has 3 slots in its FROM clause.  One slot of the\n    ** outer query (the middle slot) is used by the subquery.  The next\n    ** block of code will expand the outer query FROM clause to 4 slots.\n    ** The middle slot is expanded to two slots in order to make space\n    ** for the two elements in the FROM clause of the subquery.\n    */\n    if( nSubSrc>1 ){\n      pSrc = sqlite3SrcListEnlarge(pParse, pSrc, nSubSrc-1,iFrom+1);\n      if( pSrc==0 ) break;\n      pParent->pSrc = pSrc;\n    }\n\n    /* Transfer the FROM clause terms from the subquery into the\n    ** outer query.\n    */\n    for(i=0; i<nSubSrc; i++){\n      sqlite3IdListDelete(db, pSrc->a[i+iFrom].pUsing);\n      assert( pSrc->a[i+iFrom].fg.isTabFunc==0 );\n      pSrc->a[i+iFrom] = pSubSrc->a[i];\n      iNewParent = pSubSrc->a[i].iCursor;\n      memset(&pSubSrc->a[i], 0, sizeof(pSubSrc->a[i]));\n    }\n    pSrc->a[iFrom].fg.jointype = jointype;\n  \n    /* Now begin substituting subquery result set expressions for \n    ** references to the iParent in the outer query.\n    ** \n    ** Example:\n    **\n    **   SELECT a+5, b*10 FROM (SELECT x*3 AS a, y+10 AS b FROM t1) WHERE a>b;\n    **   \\                     \\_____________ subquery __________/          /\n    **    \\_____________________ outer query ______________________________/\n    **\n    ** We look at every expression in the outer query and every place we see\n    ** \"a\" we substitute \"x*3\" and every place we see \"b\" we substitute \"y+10\".\n    */\n    if( pSub->pOrderBy ){\n      /* At this point, any non-zero iOrderByCol values indicate that the\n      ** ORDER BY column expression is identical to the iOrderByCol'th\n      ** expression returned by SELECT statement pSub. Since these values\n      ** do not necessarily correspond to columns in SELECT statement pParent,\n      ** zero them before transfering the ORDER BY clause.\n      **\n      ** Not doing this may cause an error if a subsequent call to this\n      ** function attempts to flatten a compound sub-query into pParent\n      ** (the only way this can happen is if the compound sub-query is\n      ** currently part of pSub->pSrc). See ticket [d11a6e908f].  */\n      ExprList *pOrderBy = pSub->pOrderBy;\n      for(i=0; i<pOrderBy->nExpr; i++){\n        pOrderBy->a[i].u.x.iOrderByCol = 0;\n      }\n      assert( pParent->pOrderBy==0 );\n      pParent->pOrderBy = pOrderBy;\n      pSub->pOrderBy = 0;\n    }\n    pWhere = pSub->pWhere;\n    pSub->pWhere = 0;\n    if( isLeftJoin>0 ){\n      sqlite3SetJoinExpr(pWhere, iNewParent);\n    }\n    pParent->pWhere = sqlite3ExprAnd(pParse, pWhere, pParent->pWhere);\n    if( db->mallocFailed==0 ){\n      SubstContext x;\n      x.pParse = pParse;\n      x.iTable = iParent;\n      x.iNewTable = iNewParent;\n      x.isLeftJoin = isLeftJoin;\n      x.pEList = pSub->pEList;\n      substSelect(&x, pParent, 0);\n    }\n  \n    /* The flattened query is a compound if either the inner or the\n    ** outer query is a compound. */\n    pParent->selFlags |= pSub->selFlags & SF_Compound;\n    assert( (pSub->selFlags & SF_Distinct)==0 ); /* restriction (17b) */\n  \n    /*\n    ** SELECT ... FROM (SELECT ... LIMIT a OFFSET b) LIMIT x OFFSET y;\n    **\n    ** One is tempted to try to add a and b to combine the limits.  But this\n    ** does not work if either limit is negative.\n    */\n    if( pSub->pLimit ){\n      pParent->pLimit = pSub->pLimit;\n      pSub->pLimit = 0;\n    }\n  }\n\n  /* Finially, delete what is left of the subquery and return\n  ** success.\n  */\n  sqlite3SelectDelete(db, pSub1);\n\n#if SELECTTRACE_ENABLED\n  if( sqlite3SelectTrace & 0x100 ){\n    SELECTTRACE(0x100,pParse,p,(\"After flattening:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  return 1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149721,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n\n    /* Collect section files and check for duplicates. */\n    for (file = (XkbFile *) file->defs; file;\n         file = (XkbFile *) file->common.next) {\n        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \"More than one %s section in keymap file; \"\n                    \"All sections after the first ignored\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        files[file->file_type] = file;\n    }\n\n    /*\n     * Check that all required section were provided.\n     * Report everything before failing.\n     */\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \"Required section %s missing from keymap\\n\",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n    if (!ok)\n        return false;\n\n    /* Compile sections. */\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \"Compiling %s \\\"%s\\\"\\n\",\n                xkb_file_type_to_string(type), files[type]->name);\n\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \"Failed to compile %s\\n\",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n\n    return UpdateDerivedKeymapFields(keymap);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149722,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n\n    /* Collect section files and check for duplicates. */\n    for (file = (XkbFile *) file->defs; file;\n         file = (XkbFile *) file->common.next) {\n        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            if (file->file_type == FILE_TYPE_GEOMETRY) {\n                log_vrb(ctx, 1,\n                        \"Geometry sections are not supported; ignoring\\n\");\n            } else {\n                log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n                        xkb_file_type_to_string(file->file_type));\n            }\n            continue;\n        }\n\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \"More than one %s section in keymap file; \"\n                    \"All sections after the first ignored\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        files[file->file_type] = file;\n    }\n\n    /*\n     * Check that all required section were provided.\n     * Report everything before failing.\n     */\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \"Required section %s missing from keymap\\n\",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n    if (!ok)\n        return false;\n\n    /* Compile sections. */\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \"Compiling %s \\\"%s\\\"\\n\",\n                xkb_file_type_to_string(type), files[type]->name);\n\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \"Failed to compile %s\\n\",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n\n    return UpdateDerivedKeymapFields(keymap);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149723,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo *hdr;\n    int err;\n\n    if (!*phdr)\n        *phdr = av_mallocz(sizeof(AC3HeaderInfo));\n    if (!*phdr)\n        return AVERROR(ENOMEM);\n    hdr = *phdr;\n\n    init_get_bits8(&gb, buf, size);\n    err = ff_ac3_parse_header(&gb, hdr);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n\n    return get_bits_count(&gb);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149724,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo *hdr;\n    int err;\n\n    if (!*phdr)\n        *phdr = av_mallocz(sizeof(AC3HeaderInfo));\n    if (!*phdr)\n        return AVERROR(ENOMEM);\n    hdr = *phdr;\n\n    err = init_get_bits8(&gb, buf, size);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n    err = ff_ac3_parse_header(&gb, hdr);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n\n    return get_bits_count(&gb);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149725,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int mailimf_group_parse(const char * message, size_t length,\n\t\t\t       size_t * indx,\n\t\t\t       struct mailimf_group ** result)\n{\n  size_t cur_token;\n  char * display_name;\n  struct mailimf_mailbox_list * mailbox_list;\n  struct mailimf_group * group;\n  int r;\n  int res;\n\n  cur_token = * indx;\n\n  mailbox_list = NULL;\n\n  r = mailimf_display_name_parse(message, length, &cur_token, &display_name);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_display_name;\n  }\n\n  r = mailimf_mailbox_list_parse(message, length, &cur_token, &mailbox_list);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    break;\n  case MAILIMF_ERROR_PARSE:\n    r = mailimf_cfws_parse(message, length, &cur_token);\n    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n      res = r;\n      goto free_display_name;\n    }\n    break;\n  default:\n    res = r;\n    goto free_display_name;\n  }\n\n  r = mailimf_semi_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_mailbox_list;\n  }\n\n  group = mailimf_group_new(display_name, mailbox_list);\n  if (group == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_mailbox_list;\n  }\n\n  * indx = cur_token;\n  * result = group;\n\n  return MAILIMF_NO_ERROR;\n\n free_mailbox_list:\n  if (mailbox_list != NULL) {\n    mailimf_mailbox_list_free(mailbox_list);\n  }\n free_display_name:\n  mailimf_display_name_free(display_name);\n err:\n  return res;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149726,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int mailimf_group_parse(const char * message, size_t length,\n\t\t\t       size_t * indx,\n\t\t\t       struct mailimf_group ** result)\n{\n  size_t cur_token;\n  char * display_name;\n  struct mailimf_mailbox_list * mailbox_list;\n  struct mailimf_group * group;\n  int r;\n  int res;\n  clist * list;\n\n  cur_token = * indx;\n\n  mailbox_list = NULL;\n\n  r = mailimf_display_name_parse(message, length, &cur_token, &display_name);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_display_name;\n  }\n\n  r = mailimf_mailbox_list_parse(message, length, &cur_token, &mailbox_list);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    break;\n  case MAILIMF_ERROR_PARSE:\n    r = mailimf_cfws_parse(message, length, &cur_token);\n    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n      res = r;\n      goto free_display_name;\n    }\n    list = clist_new();\n    if (list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      goto free_display_name;\n    }\n    mailbox_list = mailimf_mailbox_list_new(list);\n    if (mailbox_list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      clist_free(list);\n      goto free_display_name;\n    }\n    break;\n  default:\n    res = r;\n    goto free_display_name;\n  }\n\n  r = mailimf_semi_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_mailbox_list;\n  }\n\n  group = mailimf_group_new(display_name, mailbox_list);\n  if (group == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_mailbox_list;\n  }\n\n  * indx = cur_token;\n  * result = group;\n\n  return MAILIMF_NO_ERROR;\n\n free_mailbox_list:\n  if (mailbox_list != NULL) {\n    mailimf_mailbox_list_free(mailbox_list);\n  }\n free_display_name:\n  mailimf_display_name_free(display_name);\n err:\n  return res;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149727,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,\n\t\t\t\t struct srpt_recv_ioctx *recv_ioctx,\n\t\t\t\t struct srpt_send_ioctx *send_ioctx)\n{\n\tstruct srp_tsk_mgmt *srp_tsk;\n\tstruct se_cmd *cmd;\n\tstruct se_session *sess = ch->sess;\n\tuint64_t unpacked_lun;\n\tuint32_t tag = 0;\n\tint tcm_tmr;\n\tint rc;\n\n\tBUG_ON(!send_ioctx);\n\n\tsrp_tsk = recv_ioctx->ioctx.buf;\n\tcmd = &send_ioctx->cmd;\n\n\tpr_debug(\"recv tsk_mgmt fn %d for task_tag %lld and cmd tag %lld\"\n\t\t \" cm_id %p sess %p\\n\", srp_tsk->tsk_mgmt_func,\n\t\t srp_tsk->task_tag, srp_tsk->tag, ch->cm_id, ch->sess);\n\n\tsrpt_set_cmd_state(send_ioctx, SRPT_STATE_MGMT);\n\tsend_ioctx->cmd.tag = srp_tsk->tag;\n\ttcm_tmr = srp_tmr_to_tcm(srp_tsk->tsk_mgmt_func);\n\tif (tcm_tmr < 0) {\n\t\tsend_ioctx->cmd.se_tmr_req->response =\n\t\t\tTMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;\n\t\tgoto fail;\n\t}\n\tunpacked_lun = srpt_unpack_lun((uint8_t *)&srp_tsk->lun,\n\t\t\t\t       sizeof(srp_tsk->lun));\n\n\tif (srp_tsk->tsk_mgmt_func == SRP_TSK_ABORT_TASK) {\n\t\trc = srpt_rx_mgmt_fn_tag(send_ioctx, srp_tsk->task_tag);\n\t\tif (rc < 0) {\n\t\t\tsend_ioctx->cmd.se_tmr_req->response =\n\t\t\t\t\tTMR_TASK_DOES_NOT_EXIST;\n\t\t\tgoto fail;\n\t\t}\n\t\ttag = srp_tsk->task_tag;\n\t}\n\trc = target_submit_tmr(&send_ioctx->cmd, sess, NULL, unpacked_lun,\n\t\t\t\tsrp_tsk, tcm_tmr, GFP_KERNEL, tag,\n\t\t\t\tTARGET_SCF_ACK_KREF);\n\tif (rc != 0) {\n\t\tsend_ioctx->cmd.se_tmr_req->response = TMR_FUNCTION_REJECTED;\n\t\tgoto fail;\n\t}\n\treturn;\nfail:\n\ttransport_send_check_condition_and_sense(cmd, 0, 0); // XXX:\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149728,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,\n\t\t\t\t struct srpt_recv_ioctx *recv_ioctx,\n\t\t\t\t struct srpt_send_ioctx *send_ioctx)\n{\n\tstruct srp_tsk_mgmt *srp_tsk;\n\tstruct se_cmd *cmd;\n\tstruct se_session *sess = ch->sess;\n\tuint64_t unpacked_lun;\n\tint tcm_tmr;\n\tint rc;\n\n\tBUG_ON(!send_ioctx);\n\n\tsrp_tsk = recv_ioctx->ioctx.buf;\n\tcmd = &send_ioctx->cmd;\n\n\tpr_debug(\"recv tsk_mgmt fn %d for task_tag %lld and cmd tag %lld\"\n\t\t \" cm_id %p sess %p\\n\", srp_tsk->tsk_mgmt_func,\n\t\t srp_tsk->task_tag, srp_tsk->tag, ch->cm_id, ch->sess);\n\n\tsrpt_set_cmd_state(send_ioctx, SRPT_STATE_MGMT);\n\tsend_ioctx->cmd.tag = srp_tsk->tag;\n\ttcm_tmr = srp_tmr_to_tcm(srp_tsk->tsk_mgmt_func);\n\tunpacked_lun = srpt_unpack_lun((uint8_t *)&srp_tsk->lun,\n\t\t\t\t       sizeof(srp_tsk->lun));\n\trc = target_submit_tmr(&send_ioctx->cmd, sess, NULL, unpacked_lun,\n\t\t\t\tsrp_tsk, tcm_tmr, GFP_KERNEL, srp_tsk->task_tag,\n\t\t\t\tTARGET_SCF_ACK_KREF);\n\tif (rc != 0) {\n\t\tsend_ioctx->cmd.se_tmr_req->response = TMR_FUNCTION_REJECTED;\n\t\tgoto fail;\n\t}\n\treturn;\nfail:\n\ttransport_send_check_condition_and_sense(cmd, 0, 0); // XXX:\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149729,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n    *pred_rtrn = MATCH_EXACTLY;\n    if (expr->expr.op == EXPR_ACTION_DECL) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {\n            log_err(info->ctx,\n                    \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n            return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149730,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n    *pred_rtrn = MATCH_EXACTLY;\n    if (expr->expr.op == EXPR_ACTION_DECL) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn) ||\n            !expr->action.args) {\n            log_err(info->ctx,\n                    \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n            return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149731,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n\trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n\tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\"*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149732,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n\trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n\tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n\n\tif (!int_port || !ext_port || !protocol)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\"*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149733,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "acc_ctx_cont(OM_uint32 *minstat,\n\t     gss_buffer_t buf,\n\t     gss_ctx_id_t *ctx,\n\t     gss_buffer_t *responseToken,\n\t     gss_buffer_t *mechListMIC,\n\t     OM_uint32 *negState,\n\t     send_token_flag *return_token)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_OID supportedMech;\n\tspnego_gss_ctx_id_t sc;\n\tunsigned int len;\n\tunsigned char *ptr, *bufstart;\n\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\t*negState = REJECT;\n\t*minstat = 0;\n\tsupportedMech = GSS_C_NO_OID;\n\t*return_token = ERROR_TOKEN_SEND;\n\t*responseToken = *mechListMIC = GSS_C_NO_BUFFER;\n\n\tptr = bufstart = buf->value;\n#define REMAIN (buf->length - (ptr - bufstart))\n\tif (REMAIN > INT_MAX)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t/*\n\t * Attempt to work with old Sun SPNEGO.\n\t */\n\tif (*ptr == HEADER_ID) {\n\t\tret = g_verify_token_header(gss_mech_spnego,\n\t\t\t\t\t    &len, &ptr, 0, REMAIN);\n\t\tif (ret) {\n\t\t\t*minstat = ret;\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t}\n\tif (*ptr != (CONTEXT | 0x01)) {\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tret = get_negTokenResp(minstat, ptr, REMAIN,\n\t\t\t       negState, &supportedMech,\n\t\t\t       responseToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tif (*responseToken == GSS_C_NO_BUFFER &&\n\t    *mechListMIC == GSS_C_NO_BUFFER) {\n\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tsc->firstpass = 0;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = CONT_TOKEN_SEND;\ncleanup:\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tgeneric_gss_release_oid(&tmpmin, &supportedMech);\n\t}\n\treturn ret;\n#undef REMAIN\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149736,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "acc_ctx_cont(OM_uint32 *minstat,\n\t     gss_buffer_t buf,\n\t     gss_ctx_id_t *ctx,\n\t     gss_buffer_t *responseToken,\n\t     gss_buffer_t *mechListMIC,\n\t     OM_uint32 *negState,\n\t     send_token_flag *return_token)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_OID supportedMech;\n\tspnego_gss_ctx_id_t sc;\n\tunsigned int len;\n\tunsigned char *ptr, *bufstart;\n\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\t*negState = REJECT;\n\t*minstat = 0;\n\tsupportedMech = GSS_C_NO_OID;\n\t*return_token = ERROR_TOKEN_SEND;\n\t*responseToken = *mechListMIC = GSS_C_NO_BUFFER;\n\n\tptr = bufstart = buf->value;\n#define REMAIN (buf->length - (ptr - bufstart))\n\tif (REMAIN == 0 || REMAIN > INT_MAX)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t/*\n\t * Attempt to work with old Sun SPNEGO.\n\t */\n\tif (*ptr == HEADER_ID) {\n\t\tret = g_verify_token_header(gss_mech_spnego,\n\t\t\t\t\t    &len, &ptr, 0, REMAIN);\n\t\tif (ret) {\n\t\t\t*minstat = ret;\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t}\n\tif (*ptr != (CONTEXT | 0x01)) {\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tret = get_negTokenResp(minstat, ptr, REMAIN,\n\t\t\t       negState, &supportedMech,\n\t\t\t       responseToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tif (*responseToken == GSS_C_NO_BUFFER &&\n\t    *mechListMIC == GSS_C_NO_BUFFER) {\n\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tsc->firstpass = 0;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = CONT_TOKEN_SEND;\ncleanup:\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tgeneric_gss_release_oid(&tmpmin, &supportedMech);\n\t}\n\treturn ret;\n#undef REMAIN\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149737,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,\n\t\t\t     struct mschmd_header *chm, int entire)\n{\n  unsigned int section, name_len, x, errors, num_chunks;\n  unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;\n  struct mschmd_file *fi, *link = NULL;\n  off_t offset, length;\n  int num_entries;\n\n  /* initialise pointers */\n  chm->files         = NULL;\n  chm->sysfiles      = NULL;\n  chm->chunk_cache   = NULL;\n  chm->sec0.base.chm = chm;\n  chm->sec0.base.id  = 0;\n  chm->sec1.base.chm = chm;\n  chm->sec1.base.id  = 1;\n  chm->sec1.content  = NULL;\n  chm->sec1.control  = NULL;\n  chm->sec1.spaninfo = NULL;\n  chm->sec1.rtable   = NULL;\n\n  /* read the first header */\n  if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* check ITSF signature */\n  if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  /* check both header GUIDs */\n  if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {\n    D((\"incorrect GUIDs\"))\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  chm->version   = EndGetI32(&buf[chmhead_Version]);\n  chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);\n  chm->language  = EndGetI32(&buf[chmhead_LanguageID]);\n  if (chm->version > 3) {\n    sys->message(fh, \"WARNING; CHM version > 3\");\n  }\n\n  /* read the header section table */\n  if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* chmhst3_OffsetCS0 does not exist in version 1 or 2 CHM files.\n   * The offset will be corrected later, once HS1 is read.\n   */\n  if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||\n      read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||\n      read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))\n  {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 0 */\n  if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 0 */\n  if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n  if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 1 */\n  if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 1 */\n  if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  chm->dir_offset = sys->tell(fh);\n  chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);\n  chm->density    = EndGetI32(&buf[chmhs1_Density]);\n  chm->depth      = EndGetI32(&buf[chmhs1_Depth]);\n  chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);\n  chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);\n  chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);\n  chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);\n\n  if (chm->version < 3) {\n    /* versions before 3 don't have chmhst3_OffsetCS0 */\n    chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);\n  }\n\n  /* check if content offset or file size is wrong */\n  if (chm->sec0.offset > chm->length) {\n    D((\"content section begins after file has ended\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  \n  /* ensure there are chunks and that chunk size is\n   * large enough for signature and num_entries */\n  if (chm->chunk_size < (pmgl_Entries + 2)) {\n    D((\"chunk size not large enough\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->num_chunks == 0) {\n    D((\"no chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* The chunk_cache data structure is not great; large values for num_chunks\n   * or num_chunks*chunk_size can exhaust all memory. Until a better chunk\n   * cache is implemented, put arbitrary limits on num_chunks and chunk size.\n   */\n  if (chm->num_chunks > 100000) {\n    D((\"more than 100,000 chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }   \n  if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {\n    D((\"chunks larger than entire file\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* common sense checks on header section 1 fields */\n  if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {\n    sys->message(fh, \"WARNING; chunk size is not a power of two\");\n  }\n  if (chm->first_pmgl != 0) {\n    sys->message(fh, \"WARNING; first PMGL chunk is not zero\");\n  }\n  if (chm->first_pmgl > chm->last_pmgl) {\n    D((\"first pmgl chunk is after last pmgl chunk\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) {\n    D((\"index_root outside valid range\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* if we are doing a quick read, stop here! */\n  if (!entire) {\n    return MSPACK_ERR_OK;\n  }\n\n  /* seek to the first PMGL chunk, and reduce the number of chunks to read */\n  if ((x = chm->first_pmgl) != 0) {\n    if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {\n      return MSPACK_ERR_SEEK;\n    }\n  }\n  num_chunks = chm->last_pmgl - x + 1;\n\n  if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {\n    return MSPACK_ERR_NOMEMORY;\n  }\n\n  /* read and process all chunks from FirstPMGL to LastPMGL */\n  errors = 0;\n  while (num_chunks--) {\n    /* read next chunk */\n    if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {\n      sys->free(chunk);\n      return MSPACK_ERR_READ;\n    }\n\n    /* process only directory (PMGL) chunks */\n    if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;\n\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {\n      sys->message(fh, \"WARNING; PMGL quickref area is too small\");\n    }\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) > \n\t((int)chm->chunk_size - pmgl_Entries))\n    {\n      sys->message(fh, \"WARNING; PMGL quickref area is too large\");\n    }\n\n    p = &chunk[pmgl_Entries];\n    end = &chunk[chm->chunk_size - 2];\n    num_entries = EndGetI16(end);\n\n    while (num_entries--) {\n      READ_ENCINT(name_len);\n      if (name_len > (unsigned int) (end - p)) goto chunk_end;\n      /* consider blank filenames to be an error */\n      if (name_len == 0) goto chunk_end;\n      name = p; p += name_len;\n\n      READ_ENCINT(section);\n      READ_ENCINT(offset);\n      READ_ENCINT(length);\n\n      /* empty files and directory names are stored as a file entry at\n       * offset 0 with length 0. We want to keep empty files, but not\n       * directory names, which end with a \"/\" */\n      if ((offset == 0) && (length == 0)) {\n\tif ((name_len > 0) && (name[name_len-1] == '/')) continue;\n      }\n\n      if (section > 1) {\n\tsys->message(fh, \"invalid section number '%u'.\", section);\n\tcontinue;\n      }\n\n      if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {\n\tsys->free(chunk);\n\treturn MSPACK_ERR_NOMEMORY;\n      }\n\n      fi->next     = NULL;\n      fi->filename = (char *) &fi[1];\n      fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)\n\t\t                     : (struct mschmd_section *) (&chm->sec1));\n      fi->offset   = offset;\n      fi->length   = length;\n      sys->copy(name, fi->filename, (size_t) name_len);\n      fi->filename[name_len] = '\\0';\n\n      if (name[0] == ':' && name[1] == ':') {\n\t/* system file */\n\tif (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) {\n\t  if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) {\n\t    chm->sec1.content = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) {\n\t    chm->sec1.control = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {\n\t    chm->sec1.spaninfo = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) {\n\t    chm->sec1.rtable = fi;\n\t  }\n\t}\n\tfi->next = chm->sysfiles;\n\tchm->sysfiles = fi;\n      }\n      else {\n\t/* normal file */\n\tif (link) link->next = fi; else chm->files = fi;\n\tlink = fi;\n      }\n    }\n\n    /* this is reached either when num_entries runs out, or if\n     * reading data from the chunk reached a premature end of chunk */\n  chunk_end:\n    if (num_entries >= 0) {\n      D((\"chunk ended before all entries could be read\"))\n      errors++;\n    }\n\n  }\n  sys->free(chunk);\n  return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149738,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,\n\t\t\t     struct mschmd_header *chm, int entire)\n{\n  unsigned int section, name_len, x, errors, num_chunks;\n  unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;\n  struct mschmd_file *fi, *link = NULL;\n  off_t offset, length;\n  int num_entries;\n\n  /* initialise pointers */\n  chm->files         = NULL;\n  chm->sysfiles      = NULL;\n  chm->chunk_cache   = NULL;\n  chm->sec0.base.chm = chm;\n  chm->sec0.base.id  = 0;\n  chm->sec1.base.chm = chm;\n  chm->sec1.base.id  = 1;\n  chm->sec1.content  = NULL;\n  chm->sec1.control  = NULL;\n  chm->sec1.spaninfo = NULL;\n  chm->sec1.rtable   = NULL;\n\n  /* read the first header */\n  if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* check ITSF signature */\n  if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  /* check both header GUIDs */\n  if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {\n    D((\"incorrect GUIDs\"))\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  chm->version   = EndGetI32(&buf[chmhead_Version]);\n  chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);\n  chm->language  = EndGetI32(&buf[chmhead_LanguageID]);\n  if (chm->version > 3) {\n    sys->message(fh, \"WARNING; CHM version > 3\");\n  }\n\n  /* read the header section table */\n  if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* chmhst3_OffsetCS0 does not exist in version 1 or 2 CHM files.\n   * The offset will be corrected later, once HS1 is read.\n   */\n  if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||\n      read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||\n      read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))\n  {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 0 */\n  if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 0 */\n  if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n  if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 1 */\n  if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 1 */\n  if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  chm->dir_offset = sys->tell(fh);\n  chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);\n  chm->density    = EndGetI32(&buf[chmhs1_Density]);\n  chm->depth      = EndGetI32(&buf[chmhs1_Depth]);\n  chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);\n  chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);\n  chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);\n  chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);\n\n  if (chm->version < 3) {\n    /* versions before 3 don't have chmhst3_OffsetCS0 */\n    chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);\n  }\n\n  /* check if content offset or file size is wrong */\n  if (chm->sec0.offset > chm->length) {\n    D((\"content section begins after file has ended\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  \n  /* ensure there are chunks and that chunk size is\n   * large enough for signature and num_entries */\n  if (chm->chunk_size < (pmgl_Entries + 2)) {\n    D((\"chunk size not large enough\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->num_chunks == 0) {\n    D((\"no chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* The chunk_cache data structure is not great; large values for num_chunks\n   * or num_chunks*chunk_size can exhaust all memory. Until a better chunk\n   * cache is implemented, put arbitrary limits on num_chunks and chunk size.\n   */\n  if (chm->num_chunks > 100000) {\n    D((\"more than 100,000 chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }   \n  if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {\n    D((\"chunks larger than entire file\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* common sense checks on header section 1 fields */\n  if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {\n    sys->message(fh, \"WARNING; chunk size is not a power of two\");\n  }\n  if (chm->first_pmgl != 0) {\n    sys->message(fh, \"WARNING; first PMGL chunk is not zero\");\n  }\n  if (chm->first_pmgl > chm->last_pmgl) {\n    D((\"first pmgl chunk is after last pmgl chunk\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) {\n    D((\"index_root outside valid range\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* if we are doing a quick read, stop here! */\n  if (!entire) {\n    return MSPACK_ERR_OK;\n  }\n\n  /* seek to the first PMGL chunk, and reduce the number of chunks to read */\n  if ((x = chm->first_pmgl) != 0) {\n    if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {\n      return MSPACK_ERR_SEEK;\n    }\n  }\n  num_chunks = chm->last_pmgl - x + 1;\n\n  if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {\n    return MSPACK_ERR_NOMEMORY;\n  }\n\n  /* read and process all chunks from FirstPMGL to LastPMGL */\n  errors = 0;\n  while (num_chunks--) {\n    /* read next chunk */\n    if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {\n      sys->free(chunk);\n      return MSPACK_ERR_READ;\n    }\n\n    /* process only directory (PMGL) chunks */\n    if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;\n\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {\n      sys->message(fh, \"WARNING; PMGL quickref area is too small\");\n    }\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) > \n\t((int)chm->chunk_size - pmgl_Entries))\n    {\n      sys->message(fh, \"WARNING; PMGL quickref area is too large\");\n    }\n\n    p = &chunk[pmgl_Entries];\n    end = &chunk[chm->chunk_size - 2];\n    num_entries = EndGetI16(end);\n\n    while (num_entries--) {\n      READ_ENCINT(name_len);\n      if (name_len > (unsigned int) (end - p)) goto chunk_end;\n      name = p; p += name_len;\n      READ_ENCINT(section);\n      READ_ENCINT(offset);\n      READ_ENCINT(length);\n\n      /* ignore blank or one-char (e.g. \"/\") filenames we'd return as blank */\n      if (name_len < 2 || !name[0] || !name[1]) continue;\n\n      /* empty files and directory names are stored as a file entry at\n       * offset 0 with length 0. We want to keep empty files, but not\n       * directory names, which end with a \"/\" */\n      if ((offset == 0) && (length == 0)) {\n\tif ((name_len > 0) && (name[name_len-1] == '/')) continue;\n      }\n\n      if (section > 1) {\n\tsys->message(fh, \"invalid section number '%u'.\", section);\n\tcontinue;\n      }\n\n      if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {\n\tsys->free(chunk);\n\treturn MSPACK_ERR_NOMEMORY;\n      }\n\n      fi->next     = NULL;\n      fi->filename = (char *) &fi[1];\n      fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)\n\t\t                     : (struct mschmd_section *) (&chm->sec1));\n      fi->offset   = offset;\n      fi->length   = length;\n      sys->copy(name, fi->filename, (size_t) name_len);\n      fi->filename[name_len] = '\\0';\n\n      if (name[0] == ':' && name[1] == ':') {\n\t/* system file */\n\tif (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) {\n\t  if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) {\n\t    chm->sec1.content = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) {\n\t    chm->sec1.control = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {\n\t    chm->sec1.spaninfo = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) {\n\t    chm->sec1.rtable = fi;\n\t  }\n\t}\n\tfi->next = chm->sysfiles;\n\tchm->sysfiles = fi;\n      }\n      else {\n\t/* normal file */\n\tif (link) link->next = fi; else chm->files = fi;\n\tlink = fi;\n      }\n    }\n\n    /* this is reached either when num_entries runs out, or if\n     * reading data from the chunk reached a premature end of chunk */\n  chunk_end:\n    if (num_entries >= 0) {\n      D((\"chunk ended before all entries could be read\"))\n      errors++;\n    }\n\n  }\n  sys->free(chunk);\n  return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149739,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "filter_session_io(struct io *io, int evt, void *arg)\n{\n\tstruct filter_session *fs = arg;\n\tchar *line = NULL;\n\tssize_t len;\n\n\tlog_trace(TRACE_IO, \"filter session: %p: %s %s\", fs, io_strevent(evt),\n\t    io_strio(io));\n\n\tswitch (evt) {\n\tcase IO_DATAIN:\n\tnextline:\n\t\tline = io_getline(fs->io, &len);\n\t\t/* No complete line received */\n\t\tif (line == NULL)\n\t\t\treturn;\n\n\t\tfilter_data(fs->id, line);\n\n\t\tgoto nextline;\n\n\tcase IO_DISCONNECTED:\n\t\tio_free(fs->io);\n\t\tfs->io = NULL;\n\t\tbreak;\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149740,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "filter_session_io(struct io *io, int evt, void *arg)\n{\n\tstruct filter_session *fs = arg;\n\tchar *line = NULL;\n\tssize_t len;\n\n\tlog_trace(TRACE_IO, \"filter session: %p: %s %s\", fs, io_strevent(evt),\n\t    io_strio(io));\n\n\tswitch (evt) {\n\tcase IO_DATAIN:\n\tnextline:\n\t\tline = io_getline(fs->io, &len);\n\t\t/* No complete line received */\n\t\tif (line == NULL)\n\t\t\treturn;\n\n\t\tfilter_data(fs->id, line);\n\n\t\tgoto nextline;\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149741,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tint mode = ctxt->mode;\n\tint def_op_bytes, def_ad_bytes, goffset, simd_prefix;\n\tbool op_prefix = false;\n\tbool has_seg_override = false;\n\tstruct opcode opcode;\n\n\tctxt->memop.type = OP_NONE;\n\tctxt->memopp = NULL;\n\tctxt->_eip = ctxt->eip;\n\tctxt->fetch.ptr = ctxt->fetch.data;\n\tctxt->fetch.end = ctxt->fetch.data + insn_len;\n\tctxt->opcode_len = 1;\n\tif (insn_len > 0)\n\t\tmemcpy(ctxt->fetch.data, insn, insn_len);\n\telse {\n\t\trc = __do_insn_fetch_bytes(ctxt, 1);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t}\n\n\tswitch (mode) {\n\tcase X86EMUL_MODE_REAL:\n\tcase X86EMUL_MODE_VM86:\n\tcase X86EMUL_MODE_PROT16:\n\t\tdef_op_bytes = def_ad_bytes = 2;\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT32:\n\t\tdef_op_bytes = def_ad_bytes = 4;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase X86EMUL_MODE_PROT64:\n\t\tdef_op_bytes = 4;\n\t\tdef_ad_bytes = 8;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn EMULATION_FAILED;\n\t}\n\n\tctxt->op_bytes = def_op_bytes;\n\tctxt->ad_bytes = def_ad_bytes;\n\n\t/* Legacy prefixes. */\n\tfor (;;) {\n\t\tswitch (ctxt->b = insn_fetch(u8, ctxt)) {\n\t\tcase 0x66:\t/* operand-size override */\n\t\t\top_prefix = true;\n\t\t\t/* switch between 2/4 bytes */\n\t\t\tctxt->op_bytes = def_op_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x67:\t/* address-size override */\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\t/* switch between 4/8 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 12;\n\t\t\telse\n\t\t\t\t/* switch between 2/4 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x26:\t/* ES override */\n\t\tcase 0x2e:\t/* CS override */\n\t\tcase 0x36:\t/* SS override */\n\t\tcase 0x3e:\t/* DS override */\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = (ctxt->b >> 3) & 3;\n\t\t\tbreak;\n\t\tcase 0x64:\t/* FS override */\n\t\tcase 0x65:\t/* GS override */\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = ctxt->b & 7;\n\t\t\tbreak;\n\t\tcase 0x40 ... 0x4f: /* REX */\n\t\t\tif (mode != X86EMUL_MODE_PROT64)\n\t\t\t\tgoto done_prefixes;\n\t\t\tctxt->rex_prefix = ctxt->b;\n\t\t\tcontinue;\n\t\tcase 0xf0:\t/* LOCK */\n\t\t\tctxt->lock_prefix = 1;\n\t\t\tbreak;\n\t\tcase 0xf2:\t/* REPNE/REPNZ */\n\t\tcase 0xf3:\t/* REP/REPE/REPZ */\n\t\t\tctxt->rep_prefix = ctxt->b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done_prefixes;\n\t\t}\n\n\t\t/* Any legacy prefix after a REX prefix nullifies its effect. */\n\n\t\tctxt->rex_prefix = 0;\n\t}\n\ndone_prefixes:\n\n\t/* REX prefix. */\n\tif (ctxt->rex_prefix & 8)\n\t\tctxt->op_bytes = 8;\t/* REX.W */\n\n\t/* Opcode byte(s). */\n\topcode = opcode_table[ctxt->b];\n\t/* Two-byte opcode? */\n\tif (ctxt->b == 0x0f) {\n\t\tctxt->opcode_len = 2;\n\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\topcode = twobyte_table[ctxt->b];\n\n\t\t/* 0F_38 opcode map */\n\t\tif (ctxt->b == 0x38) {\n\t\t\tctxt->opcode_len = 3;\n\t\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\t\topcode = opcode_map_0f_38[ctxt->b];\n\t\t}\n\t}\n\tctxt->d = opcode.flags;\n\n\tif (ctxt->d & ModRM)\n\t\tctxt->modrm = insn_fetch(u8, ctxt);\n\n\t/* vex-prefix instructions are not implemented */\n\tif (ctxt->opcode_len == 1 && (ctxt->b == 0xc5 || ctxt->b == 0xc4) &&\n\t    (mode == X86EMUL_MODE_PROT64 || (ctxt->modrm & 0xc0) == 0xc0)) {\n\t\tctxt->d = NotImpl;\n\t}\n\n\twhile (ctxt->d & GroupMask) {\n\t\tswitch (ctxt->d & GroupMask) {\n\t\tcase Group:\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase GroupDual:\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\tif ((ctxt->modrm >> 6) == 3)\n\t\t\t\topcode = opcode.u.gdual->mod3[goffset];\n\t\t\telse\n\t\t\t\topcode = opcode.u.gdual->mod012[goffset];\n\t\t\tbreak;\n\t\tcase RMExt:\n\t\t\tgoffset = ctxt->modrm & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase Prefix:\n\t\t\tif (ctxt->rep_prefix && op_prefix)\n\t\t\t\treturn EMULATION_FAILED;\n\t\t\tsimd_prefix = op_prefix ? 0x66 : ctxt->rep_prefix;\n\t\t\tswitch (simd_prefix) {\n\t\t\tcase 0x00: opcode = opcode.u.gprefix->pfx_no; break;\n\t\t\tcase 0x66: opcode = opcode.u.gprefix->pfx_66; break;\n\t\t\tcase 0xf2: opcode = opcode.u.gprefix->pfx_f2; break;\n\t\t\tcase 0xf3: opcode = opcode.u.gprefix->pfx_f3; break;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Escape:\n\t\t\tif (ctxt->modrm > 0xbf)\n\t\t\t\topcode = opcode.u.esc->high[ctxt->modrm - 0xc0];\n\t\t\telse\n\t\t\t\topcode = opcode.u.esc->op[(ctxt->modrm >> 3) & 7];\n\t\t\tbreak;\n\t\tcase InstrDual:\n\t\t\tif ((ctxt->modrm >> 6) == 3)\n\t\t\t\topcode = opcode.u.idual->mod3;\n\t\t\telse\n\t\t\t\topcode = opcode.u.idual->mod012;\n\t\t\tbreak;\n\t\tcase ModeDual:\n\t\t\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\t\t\topcode = opcode.u.mdual->mode64;\n\t\t\telse\n\t\t\t\topcode = opcode.u.mdual->mode32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn EMULATION_FAILED;\n\t\t}\n\n\t\tctxt->d &= ~(u64)GroupMask;\n\t\tctxt->d |= opcode.flags;\n\t}\n\n\t/* Unrecognised? */\n\tif (ctxt->d == 0)\n\t\treturn EMULATION_FAILED;\n\n\tctxt->execute = opcode.u.execute;\n\n\tif (unlikely(ctxt->ud) && likely(!(ctxt->d & EmulateOnUD)))\n\t\treturn EMULATION_FAILED;\n\n\tif (unlikely(ctxt->d &\n\t    (NotImpl|Stack|Op3264|Sse|Mmx|Intercept|CheckPerm|NearBranch|\n\t     No16))) {\n\t\t/*\n\t\t * These are copied unconditionally here, and checked unconditionally\n\t\t * in x86_emulate_insn.\n\t\t */\n\t\tctxt->check_perm = opcode.check_perm;\n\t\tctxt->intercept = opcode.intercept;\n\n\t\tif (ctxt->d & NotImpl)\n\t\t\treturn EMULATION_FAILED;\n\n\t\tif (mode == X86EMUL_MODE_PROT64) {\n\t\t\tif (ctxt->op_bytes == 4 && (ctxt->d & Stack))\n\t\t\t\tctxt->op_bytes = 8;\n\t\t\telse if (ctxt->d & NearBranch)\n\t\t\t\tctxt->op_bytes = 8;\n\t\t}\n\n\t\tif (ctxt->d & Op3264) {\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\tctxt->op_bytes = 8;\n\t\t\telse\n\t\t\t\tctxt->op_bytes = 4;\n\t\t}\n\n\t\tif ((ctxt->d & No16) && ctxt->op_bytes == 2)\n\t\t\tctxt->op_bytes = 4;\n\n\t\tif (ctxt->d & Sse)\n\t\t\tctxt->op_bytes = 16;\n\t\telse if (ctxt->d & Mmx)\n\t\t\tctxt->op_bytes = 8;\n\t}\n\n\t/* ModRM and SIB bytes. */\n\tif (ctxt->d & ModRM) {\n\t\trc = decode_modrm(ctxt, &ctxt->memop);\n\t\tif (!has_seg_override) {\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = ctxt->modrm_seg;\n\t\t}\n\t} else if (ctxt->d & MemAbs)\n\t\trc = decode_abs(ctxt, &ctxt->memop);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\tif (!has_seg_override)\n\t\tctxt->seg_override = VCPU_SREG_DS;\n\n\tctxt->memop.addr.mem.seg = ctxt->seg_override;\n\n\t/*\n\t * Decode and fetch the source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src, (ctxt->d >> SrcShift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/*\n\t * Decode and fetch the second source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src2, (ctxt->d >> Src2Shift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/* Decode and fetch the destination operand: register or memory. */\n\trc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask);\n\n\tif (ctxt->rip_relative)\n\t\tctxt->memopp->addr.mem.ea = address_mask(ctxt,\n\t\t\t\t\tctxt->memopp->addr.mem.ea + ctxt->_eip);\n\ndone:\n\treturn (rc != X86EMUL_CONTINUE) ? EMULATION_FAILED : EMULATION_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149742,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tint mode = ctxt->mode;\n\tint def_op_bytes, def_ad_bytes, goffset, simd_prefix;\n\tbool op_prefix = false;\n\tbool has_seg_override = false;\n\tstruct opcode opcode;\n\n\tctxt->memop.type = OP_NONE;\n\tctxt->memopp = NULL;\n\tctxt->_eip = ctxt->eip;\n\tctxt->fetch.ptr = ctxt->fetch.data;\n\tctxt->fetch.end = ctxt->fetch.data + insn_len;\n\tctxt->opcode_len = 1;\n\tif (insn_len > 0)\n\t\tmemcpy(ctxt->fetch.data, insn, insn_len);\n\telse {\n\t\trc = __do_insn_fetch_bytes(ctxt, 1);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t}\n\n\tswitch (mode) {\n\tcase X86EMUL_MODE_REAL:\n\tcase X86EMUL_MODE_VM86:\n\tcase X86EMUL_MODE_PROT16:\n\t\tdef_op_bytes = def_ad_bytes = 2;\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT32:\n\t\tdef_op_bytes = def_ad_bytes = 4;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase X86EMUL_MODE_PROT64:\n\t\tdef_op_bytes = 4;\n\t\tdef_ad_bytes = 8;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn EMULATION_FAILED;\n\t}\n\n\tctxt->op_bytes = def_op_bytes;\n\tctxt->ad_bytes = def_ad_bytes;\n\n\t/* Legacy prefixes. */\n\tfor (;;) {\n\t\tswitch (ctxt->b = insn_fetch(u8, ctxt)) {\n\t\tcase 0x66:\t/* operand-size override */\n\t\t\top_prefix = true;\n\t\t\t/* switch between 2/4 bytes */\n\t\t\tctxt->op_bytes = def_op_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x67:\t/* address-size override */\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\t/* switch between 4/8 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 12;\n\t\t\telse\n\t\t\t\t/* switch between 2/4 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x26:\t/* ES override */\n\t\tcase 0x2e:\t/* CS override */\n\t\tcase 0x36:\t/* SS override */\n\t\tcase 0x3e:\t/* DS override */\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = (ctxt->b >> 3) & 3;\n\t\t\tbreak;\n\t\tcase 0x64:\t/* FS override */\n\t\tcase 0x65:\t/* GS override */\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = ctxt->b & 7;\n\t\t\tbreak;\n\t\tcase 0x40 ... 0x4f: /* REX */\n\t\t\tif (mode != X86EMUL_MODE_PROT64)\n\t\t\t\tgoto done_prefixes;\n\t\t\tctxt->rex_prefix = ctxt->b;\n\t\t\tcontinue;\n\t\tcase 0xf0:\t/* LOCK */\n\t\t\tctxt->lock_prefix = 1;\n\t\t\tbreak;\n\t\tcase 0xf2:\t/* REPNE/REPNZ */\n\t\tcase 0xf3:\t/* REP/REPE/REPZ */\n\t\t\tctxt->rep_prefix = ctxt->b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done_prefixes;\n\t\t}\n\n\t\t/* Any legacy prefix after a REX prefix nullifies its effect. */\n\n\t\tctxt->rex_prefix = 0;\n\t}\n\ndone_prefixes:\n\n\t/* REX prefix. */\n\tif (ctxt->rex_prefix & 8)\n\t\tctxt->op_bytes = 8;\t/* REX.W */\n\n\t/* Opcode byte(s). */\n\topcode = opcode_table[ctxt->b];\n\t/* Two-byte opcode? */\n\tif (ctxt->b == 0x0f) {\n\t\tctxt->opcode_len = 2;\n\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\topcode = twobyte_table[ctxt->b];\n\n\t\t/* 0F_38 opcode map */\n\t\tif (ctxt->b == 0x38) {\n\t\t\tctxt->opcode_len = 3;\n\t\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\t\topcode = opcode_map_0f_38[ctxt->b];\n\t\t}\n\t}\n\tctxt->d = opcode.flags;\n\n\tif (ctxt->d & ModRM)\n\t\tctxt->modrm = insn_fetch(u8, ctxt);\n\n\t/* vex-prefix instructions are not implemented */\n\tif (ctxt->opcode_len == 1 && (ctxt->b == 0xc5 || ctxt->b == 0xc4) &&\n\t    (mode == X86EMUL_MODE_PROT64 || (ctxt->modrm & 0xc0) == 0xc0)) {\n\t\tctxt->d = NotImpl;\n\t}\n\n\twhile (ctxt->d & GroupMask) {\n\t\tswitch (ctxt->d & GroupMask) {\n\t\tcase Group:\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase GroupDual:\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\tif ((ctxt->modrm >> 6) == 3)\n\t\t\t\topcode = opcode.u.gdual->mod3[goffset];\n\t\t\telse\n\t\t\t\topcode = opcode.u.gdual->mod012[goffset];\n\t\t\tbreak;\n\t\tcase RMExt:\n\t\t\tgoffset = ctxt->modrm & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase Prefix:\n\t\t\tif (ctxt->rep_prefix && op_prefix)\n\t\t\t\treturn EMULATION_FAILED;\n\t\t\tsimd_prefix = op_prefix ? 0x66 : ctxt->rep_prefix;\n\t\t\tswitch (simd_prefix) {\n\t\t\tcase 0x00: opcode = opcode.u.gprefix->pfx_no; break;\n\t\t\tcase 0x66: opcode = opcode.u.gprefix->pfx_66; break;\n\t\t\tcase 0xf2: opcode = opcode.u.gprefix->pfx_f2; break;\n\t\t\tcase 0xf3: opcode = opcode.u.gprefix->pfx_f3; break;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Escape:\n\t\t\tif (ctxt->modrm > 0xbf)\n\t\t\t\topcode = opcode.u.esc->high[ctxt->modrm - 0xc0];\n\t\t\telse\n\t\t\t\topcode = opcode.u.esc->op[(ctxt->modrm >> 3) & 7];\n\t\t\tbreak;\n\t\tcase InstrDual:\n\t\t\tif ((ctxt->modrm >> 6) == 3)\n\t\t\t\topcode = opcode.u.idual->mod3;\n\t\t\telse\n\t\t\t\topcode = opcode.u.idual->mod012;\n\t\t\tbreak;\n\t\tcase ModeDual:\n\t\t\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\t\t\topcode = opcode.u.mdual->mode64;\n\t\t\telse\n\t\t\t\topcode = opcode.u.mdual->mode32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn EMULATION_FAILED;\n\t\t}\n\n\t\tctxt->d &= ~(u64)GroupMask;\n\t\tctxt->d |= opcode.flags;\n\t}\n\n\t/* Unrecognised? */\n\tif (ctxt->d == 0)\n\t\treturn EMULATION_FAILED;\n\n\tctxt->execute = opcode.u.execute;\n\n\tif (unlikely(ctxt->ud) && likely(!(ctxt->d & EmulateOnUD)))\n\t\treturn EMULATION_FAILED;\n\n\tif (unlikely(ctxt->d &\n\t    (NotImpl|Stack|Op3264|Sse|Mmx|Intercept|CheckPerm|NearBranch|\n\t     No16))) {\n\t\t/*\n\t\t * These are copied unconditionally here, and checked unconditionally\n\t\t * in x86_emulate_insn.\n\t\t */\n\t\tctxt->check_perm = opcode.check_perm;\n\t\tctxt->intercept = opcode.intercept;\n\n\t\tif (ctxt->d & NotImpl)\n\t\t\treturn EMULATION_FAILED;\n\n\t\tif (mode == X86EMUL_MODE_PROT64) {\n\t\t\tif (ctxt->op_bytes == 4 && (ctxt->d & Stack))\n\t\t\t\tctxt->op_bytes = 8;\n\t\t\telse if (ctxt->d & NearBranch)\n\t\t\t\tctxt->op_bytes = 8;\n\t\t}\n\n\t\tif (ctxt->d & Op3264) {\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\tctxt->op_bytes = 8;\n\t\t\telse\n\t\t\t\tctxt->op_bytes = 4;\n\t\t}\n\n\t\tif ((ctxt->d & No16) && ctxt->op_bytes == 2)\n\t\t\tctxt->op_bytes = 4;\n\n\t\tif (ctxt->d & Sse)\n\t\t\tctxt->op_bytes = 16;\n\t\telse if (ctxt->d & Mmx)\n\t\t\tctxt->op_bytes = 8;\n\t}\n\n\t/* ModRM and SIB bytes. */\n\tif (ctxt->d & ModRM) {\n\t\trc = decode_modrm(ctxt, &ctxt->memop);\n\t\tif (!has_seg_override) {\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = ctxt->modrm_seg;\n\t\t}\n\t} else if (ctxt->d & MemAbs)\n\t\trc = decode_abs(ctxt, &ctxt->memop);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\tif (!has_seg_override)\n\t\tctxt->seg_override = VCPU_SREG_DS;\n\n\tctxt->memop.addr.mem.seg = ctxt->seg_override;\n\n\t/*\n\t * Decode and fetch the source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src, (ctxt->d >> SrcShift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/*\n\t * Decode and fetch the second source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src2, (ctxt->d >> Src2Shift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/* Decode and fetch the destination operand: register or memory. */\n\trc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask);\n\n\tif (ctxt->rip_relative && likely(ctxt->memopp))\n\t\tctxt->memopp->addr.mem.ea = address_mask(ctxt,\n\t\t\t\t\tctxt->memopp->addr.mem.ea + ctxt->_eip);\n\ndone:\n\treturn (rc != X86EMUL_CONTINUE) ? EMULATION_FAILED : EMULATION_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149743,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int expand_downwards(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *prev;\n\tint error;\n\n\taddress &= PAGE_MASK;\n\terror = security_mmap_addr(address);\n\tif (error)\n\t\treturn error;\n\n\t/* Enforce stack_guard_gap */\n\tprev = vma->vm_prev;\n\t/* Check that both stack segments have the same anon_vma? */\n\tif (prev && !(prev->vm_flags & VM_GROWSDOWN) &&\n\t\t\t(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (address - prev->vm_end < stack_guard_gap)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* We must make sure the anon_vma is allocated. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * vma->vm_start/vm_end cannot change under us because the caller\n\t * is required to hold the mmap_sem in read mode.  We need the\n\t * anon_vma lock to serialize against concurrent expand_stacks.\n\t */\n\tanon_vma_lock_write(vma->anon_vma);\n\n\t/* Somebody else might have raced and expanded it already */\n\tif (address < vma->vm_start) {\n\t\tunsigned long size, grow;\n\n\t\tsize = vma->vm_end - address;\n\t\tgrow = (vma->vm_start - address) >> PAGE_SHIFT;\n\n\t\terror = -ENOMEM;\n\t\tif (grow <= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\t/*\n\t\t\t\t * vma_gap_update() doesn't support concurrent\n\t\t\t\t * updates, but we only hold a shared mmap_sem\n\t\t\t\t * lock here, so we need to protect against\n\t\t\t\t * concurrent vma expansions.\n\t\t\t\t * anon_vma_lock_write() doesn't help here, as\n\t\t\t\t * we don't guarantee that all growable vmas\n\t\t\t\t * in a mm share the same root anon vma.\n\t\t\t\t * So, we reuse mm->page_table_lock to guard\n\t\t\t\t * against concurrent vma expansions.\n\t\t\t\t */\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_start = address;\n\t\t\t\tvma->vm_pgoff -= grow;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tvma_gap_update(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149744,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int expand_downwards(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *prev;\n\tint error = 0;\n\n\taddress &= PAGE_MASK;\n\tif (address < mmap_min_addr)\n\t\treturn -EPERM;\n\n\t/* Enforce stack_guard_gap */\n\tprev = vma->vm_prev;\n\t/* Check that both stack segments have the same anon_vma? */\n\tif (prev && !(prev->vm_flags & VM_GROWSDOWN) &&\n\t\t\t(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (address - prev->vm_end < stack_guard_gap)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* We must make sure the anon_vma is allocated. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * vma->vm_start/vm_end cannot change under us because the caller\n\t * is required to hold the mmap_sem in read mode.  We need the\n\t * anon_vma lock to serialize against concurrent expand_stacks.\n\t */\n\tanon_vma_lock_write(vma->anon_vma);\n\n\t/* Somebody else might have raced and expanded it already */\n\tif (address < vma->vm_start) {\n\t\tunsigned long size, grow;\n\n\t\tsize = vma->vm_end - address;\n\t\tgrow = (vma->vm_start - address) >> PAGE_SHIFT;\n\n\t\terror = -ENOMEM;\n\t\tif (grow <= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\t/*\n\t\t\t\t * vma_gap_update() doesn't support concurrent\n\t\t\t\t * updates, but we only hold a shared mmap_sem\n\t\t\t\t * lock here, so we need to protect against\n\t\t\t\t * concurrent vma expansions.\n\t\t\t\t * anon_vma_lock_write() doesn't help here, as\n\t\t\t\t * we don't guarantee that all growable vmas\n\t\t\t\t * in a mm share the same root anon vma.\n\t\t\t\t * So, we reuse mm->page_table_lock to guard\n\t\t\t\t * against concurrent vma expansions.\n\t\t\t\t */\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_start = address;\n\t\t\t\tvma->vm_pgoff -= grow;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tvma_gap_update(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149745,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static bool check_client_passwd(PgSocket *client, const char *passwd)\n{\n\tchar md5[MD5_PASSWD_LEN + 1];\n\tconst char *correct;\n\tPgUser *user = client->auth_user;\n\n\t/* disallow empty passwords */\n\tif (!*passwd || !*user->passwd)\n\t\treturn false;\n\n\tswitch (cf_auth_type) {\n\tcase AUTH_PLAIN:\n\t\treturn strcmp(user->passwd, passwd) == 0;\n\tcase AUTH_CRYPT:\n\t\tcorrect = crypt(user->passwd, (char *)client->tmp_login_salt);\n\t\treturn correct && strcmp(correct, passwd) == 0;\n\tcase AUTH_MD5:\n\t\tif (strlen(passwd) != MD5_PASSWD_LEN)\n\t\t\treturn false;\n\t\tif (!isMD5(user->passwd))\n\t\t\tpg_md5_encrypt(user->passwd, user->name, strlen(user->name), user->passwd);\n\t\tpg_md5_encrypt(user->passwd + 3, (char *)client->tmp_login_salt, 4, md5);\n\t\treturn strcmp(md5, passwd) == 0;\n\t}\n\treturn false;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 150324,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static bool check_client_passwd(PgSocket *client, const char *passwd)\n{\n\tchar md5[MD5_PASSWD_LEN + 1];\n\tconst char *correct;\n\tPgUser *user = client->auth_user;\n\n\t/* auth_user may be missing */\n\tif (!user) {\n\t\tslog_error(client, \"Password packet before auth packet?\");\n\t\treturn false;\n\t}\n\n\t/* disallow empty passwords */\n\tif (!*passwd || !*user->passwd)\n\t\treturn false;\n\n\tswitch (cf_auth_type) {\n\tcase AUTH_PLAIN:\n\t\treturn strcmp(user->passwd, passwd) == 0;\n\tcase AUTH_CRYPT:\n\t\tcorrect = crypt(user->passwd, (char *)client->tmp_login_salt);\n\t\treturn correct && strcmp(correct, passwd) == 0;\n\tcase AUTH_MD5:\n\t\tif (strlen(passwd) != MD5_PASSWD_LEN)\n\t\t\treturn false;\n\t\tif (!isMD5(user->passwd))\n\t\t\tpg_md5_encrypt(user->passwd, user->name, strlen(user->name), user->passwd);\n\t\tpg_md5_encrypt(user->passwd + 3, (char *)client->tmp_login_salt, 4, md5);\n\t\treturn strcmp(md5, passwd) == 0;\n\t}\n\treturn false;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 150325,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void rds_tcp_kill_sock(struct net *net)\n{\n\tstruct rds_tcp_connection *tc, *_tc;\n\tstruct sock *sk;\n\tLIST_HEAD(tmp_list);\n\tstruct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);\n\n\trds_tcp_listen_stop(rtn->rds_tcp_listen_sock);\n\trtn->rds_tcp_listen_sock = NULL;\n\tflush_work(&rtn->rds_tcp_accept_w);\n\tspin_lock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) {\n\t\tstruct net *c_net = read_pnet(&tc->conn->c_net);\n\n\t\tif (net != c_net)\n\t\t\tcontinue;\n\t\tlist_move_tail(&tc->t_tcp_node, &tmp_list);\n\t}\n\tspin_unlock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &tmp_list, t_tcp_node) {\n\t\tsk = tc->t_sock->sk;\n\t\tsk->sk_prot->disconnect(sk, 0);\n\t\ttcp_done(sk);\n\t\tif (tc->conn->c_passive)\n\t\t\trds_conn_destroy(tc->conn->c_passive);\n\t\trds_conn_destroy(tc->conn);\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 150326,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static void rds_tcp_kill_sock(struct net *net)\n{\n\tstruct rds_tcp_connection *tc, *_tc;\n\tstruct sock *sk;\n\tLIST_HEAD(tmp_list);\n\tstruct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);\n\n\trds_tcp_listen_stop(rtn->rds_tcp_listen_sock);\n\trtn->rds_tcp_listen_sock = NULL;\n\tflush_work(&rtn->rds_tcp_accept_w);\n\tspin_lock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) {\n\t\tstruct net *c_net = read_pnet(&tc->conn->c_net);\n\n\t\tif (net != c_net)\n\t\t\tcontinue;\n\t\tlist_move_tail(&tc->t_tcp_node, &tmp_list);\n\t}\n\tspin_unlock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &tmp_list, t_tcp_node) {\n\t\tif (tc->t_sock) {\n\t\t\tsk = tc->t_sock->sk;\n\t\t\tsk->sk_prot->disconnect(sk, 0);\n\t\t\ttcp_done(sk);\n\t\t}\n\t\tif (tc->conn->c_passive)\n\t\t\trds_conn_destroy(tc->conn->c_passive);\n\t\trds_conn_destroy(tc->conn);\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 150327,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    magick[14];\n\n  Image\n    *image;\n\n  int\n    foundPropEnd = 0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  register ssize_t\n    i;\n\n  size_t\n    image_type,\n    length;\n\n  ssize_t\n    count;\n\n  XCFDocInfo\n    doc_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  count=ReadBlob(image,14,(unsigned char *) magick);\n  if ((count != 14) ||\n      (LocaleNCompare((char *) magick,\"gimp xcf\",8) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ResetMagickMemory(&doc_info,0,sizeof(XCFDocInfo));\n  doc_info.exception=exception;\n  doc_info.width=ReadBlobMSBLong(image);\n  doc_info.height=ReadBlobMSBLong(image);\n  if ((doc_info.width > 262144) || (doc_info.height > 262144))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  doc_info.image_type=ReadBlobMSBLong(image);\n  /*\n    Initialize image attributes.\n  */\n  image->columns=doc_info.width;\n  image->rows=doc_info.height;\n  image_type=doc_info.image_type;\n  doc_info.file_size=GetBlobSize(image);\n  image->compression=NoCompression;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (image_type == GIMP_RGB)\n    ;\n  else\n    if (image_type == GIMP_GRAY)\n      image->colorspace=GRAYColorspace;\n    else\n      if (image_type == GIMP_INDEXED)\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n  (void) SetImageOpacity(image,OpaqueOpacity); \n  (void) SetImageBackgroundColor(image);\n  /*\n    Read properties.\n  */\n  while ((foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse))\n  {\n    PropType prop_type = (PropType) ReadBlobMSBLong(image);\n    size_t prop_size = ReadBlobMSBLong(image);\n\n    switch (prop_type)\n    {\n      case PROP_END:\n        foundPropEnd=1;\n        break;\n      case PROP_COLORMAP:\n      {\n        /* Cannot rely on prop_size here--the value is set incorrectly\n           by some Gimp versions.\n        */\n        size_t num_colours = ReadBlobMSBLong(image);\n        if (DiscardBlobBytes(image,3*num_colours) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n    /*\n      if (info->file_version == 0)\n      {\n        gint i;\n\n        g_message (_(\"XCF warning: version 0 of XCF file format\\n\"\n           \"did not save indexed colormaps correctly.\\n\"\n           \"Substituting grayscale map.\"));\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        xcf_seek_pos (info, info->cp + gimage->num_cols);\n        for (i = 0; i<gimage->num_cols; i++)\n          {\n            gimage->cmap[i*3+0] = i;\n            gimage->cmap[i*3+1] = i;\n            gimage->cmap[i*3+2] = i;\n          }\n      }\n      else\n      {\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        info->cp +=\n          xcf_read_int8 (info->fp,\n                   (guint8*) gimage->cmap, gimage->num_cols*3);\n      }\n     */\n        break;\n      }\n      case PROP_COMPRESSION:\n      {\n        doc_info.compression = ReadBlobByte(image);\n        if ((doc_info.compression != COMPRESS_NONE) &&\n            (doc_info.compression != COMPRESS_RLE) &&\n            (doc_info.compression != COMPRESS_ZLIB) &&\n            (doc_info.compression != COMPRESS_FRACTAL))\n          ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n      }\n      break;\n\n      case PROP_GUIDES:\n      {\n         /* just skip it - we don't care about guides */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n      }\n      break;\n\n    case PROP_RESOLUTION:\n      {\n        /* float xres = (float) */ (void) ReadBlobMSBLong(image);\n        /* float yres = (float) */ (void) ReadBlobMSBLong(image);\n\n        /*\n        if (xres < GIMP_MIN_RESOLUTION || xres > GIMP_MAX_RESOLUTION ||\n            yres < GIMP_MIN_RESOLUTION || yres > GIMP_MAX_RESOLUTION)\n        {\n        g_message (\"Warning, resolution out of range in XCF file\");\n        xres = gimage->gimp->config->default_xresolution;\n        yres = gimage->gimp->config->default_yresolution;\n        }\n        */\n\n\n        /* BOGUS: we don't write these yet because we aren't\n              reading them properly yet :(\n              image->x_resolution = xres;\n              image->y_resolution = yres;\n        */\n      }\n      break;\n\n    case PROP_TATTOO:\n      {\n        /* we need to read it, even if we ignore it */\n        /*size_t  tattoo_state = */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PARASITES:\n      {\n        /* BOGUS: we may need these for IPTC stuff */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n        /*\n      gssize_t         base = info->cp;\n      GimpParasite *p;\n\n      while (info->cp - base < prop_size)\n        {\n          p = xcf_load_parasite (info);\n          gimp_image_parasite_attach (gimage, p);\n          gimp_parasite_free (p);\n        }\n      if (info->cp - base != prop_size)\n        g_message (\"Error detected while loading an image's parasites\");\n      */\n          }\n      break;\n\n    case PROP_UNIT:\n      {\n        /* BOGUS: ignore for now... */\n      /*size_t unit =  */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PATHS:\n      {\n      /* BOGUS: just skip it for now */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n\n        /*\n      PathList *paths = xcf_load_bzpaths (gimage, info);\n      gimp_image_set_paths (gimage, paths);\n      */\n      }\n      break;\n\n    case PROP_USER_UNIT:\n      {\n        char  unit_string[1000];\n        /*BOGUS: ignored for now */\n        /*float  factor = (float) */ (void) ReadBlobMSBLong(image);\n        /* size_t digits =  */ (void) ReadBlobMSBLong(image);\n        for (i=0; i<5; i++)\n         (void) ReadBlobStringWithLongSize(image, unit_string,\n           sizeof(unit_string));\n      }\n     break;\n\n      default:\n      {\n        int buf[16];\n        ssize_t amount;\n\n      /* read over it... */\n      while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))\n      {\n        amount=(ssize_t) MagickMin(16, prop_size);\n        amount=(ssize_t) ReadBlob(image,(size_t) amount,(unsigned char *) &buf);\n        if (!amount)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n        prop_size -= (size_t) MagickMin(16,(size_t) amount);\n      }\n    }\n    break;\n  }\n  }\n  if (foundPropEnd == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    {\n      ; /* do nothing, were just pinging! */\n    }\n  else\n    {\n      int\n        current_layer = 0,\n        foundAllLayers = MagickFalse,\n        number_layers = 0;\n\n      MagickOffsetType\n        oldPos=TellBlob(image);\n\n      XCFLayerInfo\n        *layer_info;\n\n      /*\n        The read pointer.\n      */\n      do\n      {\n        ssize_t offset = ReadBlobMSBSignedLong(image);\n        if (offset == 0)\n          foundAllLayers=MagickTrue;\n        else\n          number_layers++;\n        if (EOFBlob(image) != MagickFalse)\n          {\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n    } while (foundAllLayers == MagickFalse);\n    doc_info.number_layers=number_layers;\n    offset=SeekBlob(image,oldPos,SEEK_SET); /* restore the position! */\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    /* allocate our array of layer info blocks */\n    length=(size_t) number_layers;\n    layer_info=(XCFLayerInfo *) AcquireQuantumMemory(length,\n      sizeof(*layer_info));\n    if (layer_info == (XCFLayerInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(layer_info,0,number_layers*sizeof(XCFLayerInfo));\n    for ( ; ; )\n    {\n      MagickBooleanType\n        layer_ok;\n\n      MagickOffsetType\n        offset,\n        saved_pos;\n\n      /* read in the offset of the next layer */\n      offset=(MagickOffsetType) ReadBlobMSBLong(image);\n      /* if the offset is 0 then we are at the end\n      *  of the layer list.\n      */\n      if (offset == 0)\n        break;\n      /* save the current position as it is where the\n      *  next layer offset is stored.\n      */\n      saved_pos=TellBlob(image);\n      /* seek to the layer offset */\n      if (SeekBlob(image,offset,SEEK_SET) != offset)\n        ThrowReaderException(ResourceLimitError,\"NotEnoughPixelData\");\n      /* read in the layer */\n      layer_ok=ReadOneLayer(image_info,image,&doc_info,\n        &layer_info[current_layer],current_layer);\n      if (layer_ok == MagickFalse)\n        {\n          int j;\n\n          for (j=0; j < current_layer; j++)\n            layer_info[j].image=DestroyImage(layer_info[j].image);\n          layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      offset=SeekBlob(image, saved_pos, SEEK_SET);\n      current_layer++;\n    }\n#if 0\n        {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        signed int  j;\n        for (j=number_layers-1; j>=0; j--) {\n          /* BOGUS: need to consider layer blending modes!! */\n\n          if ( layer_info[j].visible ) { /* only visible ones, please! */\n            CompositeImage(image, OverCompositeOp, layer_info[j].image,\n                     layer_info[j].offset_x, layer_info[j].offset_y );\n             layer_info[j].image =DestroyImage( layer_info[j].image );\n\n            /* If we do this, we'll get REAL gray images! */\n            if ( image_type == GIMP_GRAY ) {\n              QuantizeInfo  qi;\n              GetQuantizeInfo(&qi);\n              qi.colorspace = GRAYColorspace;\n              QuantizeImage( &qi, layer_info[j].image );\n            }\n          }\n        }\n      }\n#else\n      {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        ssize_t  j;\n\n        /* now reverse the order of the layers as they are put\n           into subimages\n        */\n        for (j=(long) number_layers-1; j >= 0; j--)\n          AppendImageToList(&image,layer_info[j].image);\n      }\n#endif\n\n    layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n\n#if 0  /* BOGUS: do we need the channels?? */\n    while (MagickTrue)\n    {\n      /* read in the offset of the next channel */\n      info->cp += xcf_read_int32 (info->fp, &offset, 1);\n\n      /* if the offset is 0 then we are at the end\n      *  of the channel list.\n      */\n      if (offset == 0)\n        break;\n\n      /* save the current position as it is where the\n      *  next channel offset is stored.\n      */\n      saved_pos = info->cp;\n\n      /* seek to the channel offset */\n      xcf_seek_pos (info, offset);\n\n      /* read in the layer */\n      channel = xcf_load_channel (info, gimage);\n      if (channel == 0)\n        goto error;\n\n      num_successful_elements++;\n\n      /* add the channel to the image if its not the selection */\n      if (channel != gimage->selection_mask)\n        gimp_image_add_channel (gimage, channel, -1);\n\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      xcf_seek_pos (info, saved_pos);\n    }\n#endif\n  }\n\n  (void) CloseBlob(image);\n  DestroyImage(RemoveFirstImageFromList(&image));\n  if (image_type == GIMP_GRAY)\n    image->type=GrayscaleType;\n  return(GetFirstImageInList(image));\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 150328,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    magick[14];\n\n  Image\n    *image;\n\n  int\n    foundPropEnd = 0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  register ssize_t\n    i;\n\n  size_t\n    image_type,\n    length;\n\n  ssize_t\n    count;\n\n  XCFDocInfo\n    doc_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  count=ReadBlob(image,14,(unsigned char *) magick);\n  if ((count != 14) ||\n      (LocaleNCompare((char *) magick,\"gimp xcf\",8) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ResetMagickMemory(&doc_info,0,sizeof(XCFDocInfo));\n  doc_info.exception=exception;\n  doc_info.width=ReadBlobMSBLong(image);\n  doc_info.height=ReadBlobMSBLong(image);\n  if ((doc_info.width > 262144) || (doc_info.height > 262144))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  doc_info.image_type=ReadBlobMSBLong(image);\n  /*\n    Initialize image attributes.\n  */\n  image->columns=doc_info.width;\n  image->rows=doc_info.height;\n  image_type=doc_info.image_type;\n  doc_info.file_size=GetBlobSize(image);\n  image->compression=NoCompression;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (image_type == GIMP_RGB)\n    ;\n  else\n    if (image_type == GIMP_GRAY)\n      image->colorspace=GRAYColorspace;\n    else\n      if (image_type == GIMP_INDEXED)\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n  (void) SetImageOpacity(image,OpaqueOpacity); \n  (void) SetImageBackgroundColor(image);\n  /*\n    Read properties.\n  */\n  while ((foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse))\n  {\n    PropType prop_type = (PropType) ReadBlobMSBLong(image);\n    size_t prop_size = ReadBlobMSBLong(image);\n\n    switch (prop_type)\n    {\n      case PROP_END:\n        foundPropEnd=1;\n        break;\n      case PROP_COLORMAP:\n      {\n        /* Cannot rely on prop_size here--the value is set incorrectly\n           by some Gimp versions.\n        */\n        size_t num_colours = ReadBlobMSBLong(image);\n        if (DiscardBlobBytes(image,3*num_colours) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n    /*\n      if (info->file_version == 0)\n      {\n        gint i;\n\n        g_message (_(\"XCF warning: version 0 of XCF file format\\n\"\n           \"did not save indexed colormaps correctly.\\n\"\n           \"Substituting grayscale map.\"));\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        xcf_seek_pos (info, info->cp + gimage->num_cols);\n        for (i = 0; i<gimage->num_cols; i++)\n          {\n            gimage->cmap[i*3+0] = i;\n            gimage->cmap[i*3+1] = i;\n            gimage->cmap[i*3+2] = i;\n          }\n      }\n      else\n      {\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        info->cp +=\n          xcf_read_int8 (info->fp,\n                   (guint8*) gimage->cmap, gimage->num_cols*3);\n      }\n     */\n        break;\n      }\n      case PROP_COMPRESSION:\n      {\n        doc_info.compression = ReadBlobByte(image);\n        if ((doc_info.compression != COMPRESS_NONE) &&\n            (doc_info.compression != COMPRESS_RLE) &&\n            (doc_info.compression != COMPRESS_ZLIB) &&\n            (doc_info.compression != COMPRESS_FRACTAL))\n          ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n      }\n      break;\n\n      case PROP_GUIDES:\n      {\n         /* just skip it - we don't care about guides */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n      }\n      break;\n\n    case PROP_RESOLUTION:\n      {\n        /* float xres = (float) */ (void) ReadBlobMSBLong(image);\n        /* float yres = (float) */ (void) ReadBlobMSBLong(image);\n\n        /*\n        if (xres < GIMP_MIN_RESOLUTION || xres > GIMP_MAX_RESOLUTION ||\n            yres < GIMP_MIN_RESOLUTION || yres > GIMP_MAX_RESOLUTION)\n        {\n        g_message (\"Warning, resolution out of range in XCF file\");\n        xres = gimage->gimp->config->default_xresolution;\n        yres = gimage->gimp->config->default_yresolution;\n        }\n        */\n\n\n        /* BOGUS: we don't write these yet because we aren't\n              reading them properly yet :(\n              image->x_resolution = xres;\n              image->y_resolution = yres;\n        */\n      }\n      break;\n\n    case PROP_TATTOO:\n      {\n        /* we need to read it, even if we ignore it */\n        /*size_t  tattoo_state = */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PARASITES:\n      {\n        /* BOGUS: we may need these for IPTC stuff */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n        /*\n      gssize_t         base = info->cp;\n      GimpParasite *p;\n\n      while (info->cp - base < prop_size)\n        {\n          p = xcf_load_parasite (info);\n          gimp_image_parasite_attach (gimage, p);\n          gimp_parasite_free (p);\n        }\n      if (info->cp - base != prop_size)\n        g_message (\"Error detected while loading an image's parasites\");\n      */\n          }\n      break;\n\n    case PROP_UNIT:\n      {\n        /* BOGUS: ignore for now... */\n      /*size_t unit =  */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PATHS:\n      {\n      /* BOGUS: just skip it for now */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n\n        /*\n      PathList *paths = xcf_load_bzpaths (gimage, info);\n      gimp_image_set_paths (gimage, paths);\n      */\n      }\n      break;\n\n    case PROP_USER_UNIT:\n      {\n        char  unit_string[1000];\n        /*BOGUS: ignored for now */\n        /*float  factor = (float) */ (void) ReadBlobMSBLong(image);\n        /* size_t digits =  */ (void) ReadBlobMSBLong(image);\n        for (i=0; i<5; i++)\n         (void) ReadBlobStringWithLongSize(image, unit_string,\n           sizeof(unit_string));\n      }\n     break;\n\n      default:\n      {\n        int buf[16];\n        ssize_t amount;\n\n      /* read over it... */\n      while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))\n      {\n        amount=(ssize_t) MagickMin(16, prop_size);\n        amount=(ssize_t) ReadBlob(image,(size_t) amount,(unsigned char *) &buf);\n        if (!amount)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n        prop_size -= (size_t) MagickMin(16,(size_t) amount);\n      }\n    }\n    break;\n  }\n  }\n  if (foundPropEnd == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    {\n      ; /* do nothing, were just pinging! */\n    }\n  else\n    {\n      int\n        current_layer = 0,\n        foundAllLayers = MagickFalse,\n        number_layers = 0;\n\n      MagickOffsetType\n        oldPos=TellBlob(image);\n\n      XCFLayerInfo\n        *layer_info;\n\n      /*\n        The read pointer.\n      */\n      do\n      {\n        ssize_t offset = ReadBlobMSBSignedLong(image);\n        if (offset == 0)\n          foundAllLayers=MagickTrue;\n        else\n          number_layers++;\n        if (EOFBlob(image) != MagickFalse)\n          {\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n    } while (foundAllLayers == MagickFalse);\n    doc_info.number_layers=number_layers;\n    offset=SeekBlob(image,oldPos,SEEK_SET); /* restore the position! */\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    /* allocate our array of layer info blocks */\n    length=(size_t) number_layers;\n    layer_info=(XCFLayerInfo *) AcquireQuantumMemory(length,\n      sizeof(*layer_info));\n    if (layer_info == (XCFLayerInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(layer_info,0,number_layers*sizeof(XCFLayerInfo));\n    for ( ; ; )\n    {\n      MagickBooleanType\n        layer_ok;\n\n      MagickOffsetType\n        offset,\n        saved_pos;\n\n      /* read in the offset of the next layer */\n      offset=(MagickOffsetType) ReadBlobMSBLong(image);\n      /* if the offset is 0 then we are at the end\n      *  of the layer list.\n      */\n      if (offset == 0)\n        break;\n      /* save the current position as it is where the\n      *  next layer offset is stored.\n      */\n      saved_pos=TellBlob(image);\n      /* seek to the layer offset */\n      if (SeekBlob(image,offset,SEEK_SET) != offset)\n        ThrowReaderException(ResourceLimitError,\"NotEnoughPixelData\");\n      /* read in the layer */\n      layer_ok=ReadOneLayer(image_info,image,&doc_info,\n        &layer_info[current_layer],current_layer);\n      if (layer_ok == MagickFalse)\n        {\n          int j;\n\n          for (j=0; j < current_layer; j++)\n            layer_info[j].image=DestroyImage(layer_info[j].image);\n          layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      offset=SeekBlob(image, saved_pos, SEEK_SET);\n      current_layer++;\n    }\n#if 0\n        {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        signed int  j;\n        for (j=number_layers-1; j>=0; j--) {\n          /* BOGUS: need to consider layer blending modes!! */\n\n          if ( layer_info[j].visible ) { /* only visible ones, please! */\n            CompositeImage(image, OverCompositeOp, layer_info[j].image,\n                     layer_info[j].offset_x, layer_info[j].offset_y );\n             layer_info[j].image =DestroyImage( layer_info[j].image );\n\n            /* If we do this, we'll get REAL gray images! */\n            if ( image_type == GIMP_GRAY ) {\n              QuantizeInfo  qi;\n              GetQuantizeInfo(&qi);\n              qi.colorspace = GRAYColorspace;\n              QuantizeImage( &qi, layer_info[j].image );\n            }\n          }\n        }\n      }\n#else\n      {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        ssize_t  j;\n\n        /* now reverse the order of the layers as they are put\n           into subimages\n        */\n        for (j=(long) number_layers-1; j >= 0; j--)\n          AppendImageToList(&image,layer_info[j].image);\n      }\n#endif\n\n    layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n\n#if 0  /* BOGUS: do we need the channels?? */\n    while (MagickTrue)\n    {\n      /* read in the offset of the next channel */\n      info->cp += xcf_read_int32 (info->fp, &offset, 1);\n\n      /* if the offset is 0 then we are at the end\n      *  of the channel list.\n      */\n      if (offset == 0)\n        break;\n\n      /* save the current position as it is where the\n      *  next channel offset is stored.\n      */\n      saved_pos = info->cp;\n\n      /* seek to the channel offset */\n      xcf_seek_pos (info, offset);\n\n      /* read in the layer */\n      channel = xcf_load_channel (info, gimage);\n      if (channel == 0)\n        goto error;\n\n      num_successful_elements++;\n\n      /* add the channel to the image if its not the selection */\n      if (channel != gimage->selection_mask)\n        gimp_image_add_channel (gimage, channel, -1);\n\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      xcf_seek_pos (info, saved_pos);\n    }\n#endif\n  }\n\n  (void) CloseBlob(image);\n  if (GetNextImageInList(image) != (Image *) NULL)\n    DestroyImage(RemoveFirstImageFromList(&image));\n  if (image_type == GIMP_GRAY)\n    image->type=GrayscaleType;\n  return(GetFirstImageInList(image));\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 150329,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n\n    /*\n     * Do some sanity checking on the aliases. We can't do it before\n     * because keys and their aliases may be added out-of-order.\n     */\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        /* Check that ->real is a key. */\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        /* Check that ->alias is not a key. */\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        num_key_aliases++;\n    }\n\n    /* Copy key aliases. */\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n        key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n        if (!key_aliases)\n            return false;\n    }\n\n    i = 0;\n    darray_foreach(alias, info->aliases) {\n        if (alias->real != XKB_ATOM_NONE) {\n            key_aliases[i].alias = alias->alias;\n            key_aliases[i].real = alias->real;\n            i++;\n        }\n    }\n\n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 150330,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n\n    /*\n     * Do some sanity checking on the aliases. We can't do it before\n     * because keys and their aliases may be added out-of-order.\n     */\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        /* Check that ->real is a key. */\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        /* Check that ->alias is not a key. */\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        num_key_aliases++;\n    }\n\n    /* Copy key aliases. */\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n        key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n        if (!key_aliases)\n            return false;\n\n        i = 0;\n        darray_foreach(alias, info->aliases) {\n            if (alias->real != XKB_ATOM_NONE) {\n                key_aliases[i].alias = alias->alias;\n                key_aliases[i].real = alias->real;\n                i++;\n            }\n        }\n    }\n\n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 150331,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)\n{\n\tstruct tun_struct *tun;\n\tstruct tun_file *tfile = file->private_data;\n\tstruct net_device *dev;\n\tint err;\n\n\tif (tfile->detached)\n\t\treturn -EINVAL;\n\n\tdev = __dev_get_by_name(net, ifr->ifr_name);\n\tif (dev) {\n\t\tif (ifr->ifr_flags & IFF_TUN_EXCL)\n\t\t\treturn -EBUSY;\n\t\tif ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tif (!!(ifr->ifr_flags & IFF_MULTI_QUEUE) !=\n\t\t    !!(tun->flags & IFF_MULTI_QUEUE))\n\t\t\treturn -EINVAL;\n\n\t\tif (tun_not_capable(tun))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_open(tun->security);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = tun_attach(tun, file, ifr->ifr_flags & IFF_NOFILTER);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (tun->flags & IFF_MULTI_QUEUE &&\n\t\t    (tun->numqueues + tun->numdisabled > 1)) {\n\t\t\t/* One or more queue has already been attached, no need\n\t\t\t * to initialize the device again.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse {\n\t\tchar *name;\n\t\tunsigned long flags = 0;\n\t\tint queues = ifr->ifr_flags & IFF_MULTI_QUEUE ?\n\t\t\t     MAX_TAP_QUEUES : 1;\n\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_create();\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t/* Set dev type */\n\t\tif (ifr->ifr_flags & IFF_TUN) {\n\t\t\t/* TUN device */\n\t\t\tflags |= IFF_TUN;\n\t\t\tname = \"tun%d\";\n\t\t} else if (ifr->ifr_flags & IFF_TAP) {\n\t\t\t/* TAP device */\n\t\t\tflags |= IFF_TAP;\n\t\t\tname = \"tap%d\";\n\t\t} else\n\t\t\treturn -EINVAL;\n\n\t\tif (*ifr->ifr_name)\n\t\t\tname = ifr->ifr_name;\n\n\t\tdev = alloc_netdev_mqs(sizeof(struct tun_struct), name,\n\t\t\t\t       NET_NAME_UNKNOWN, tun_setup, queues,\n\t\t\t\t       queues);\n\n\t\tif (!dev)\n\t\t\treturn -ENOMEM;\n\t\terr = dev_get_valid_name(net, dev, name);\n\t\tif (err)\n\t\t\tgoto err_free_dev;\n\n\t\tdev_net_set(dev, net);\n\t\tdev->rtnl_link_ops = &tun_link_ops;\n\t\tdev->ifindex = tfile->ifindex;\n\t\tdev->sysfs_groups[0] = &tun_attr_group;\n\n\t\ttun = netdev_priv(dev);\n\t\ttun->dev = dev;\n\t\ttun->flags = flags;\n\t\ttun->txflt.count = 0;\n\t\ttun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);\n\n\t\ttun->align = NET_SKB_PAD;\n\t\ttun->filter_attached = false;\n\t\ttun->sndbuf = tfile->socket.sk->sk_sndbuf;\n\t\ttun->rx_batched = 0;\n\n\t\ttun->pcpu_stats = netdev_alloc_pcpu_stats(struct tun_pcpu_stats);\n\t\tif (!tun->pcpu_stats) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_free_dev;\n\t\t}\n\n\t\tspin_lock_init(&tun->lock);\n\n\t\terr = security_tun_dev_alloc_security(&tun->security);\n\t\tif (err < 0)\n\t\t\tgoto err_free_stat;\n\n\t\ttun_net_init(dev);\n\t\ttun_flow_init(tun);\n\n\t\tdev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |\n\t\t\t\t   TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t   NETIF_F_HW_VLAN_STAG_TX;\n\t\tdev->features = dev->hw_features | NETIF_F_LLTX;\n\t\tdev->vlan_features = dev->features &\n\t\t\t\t     ~(NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t       NETIF_F_HW_VLAN_STAG_TX);\n\n\t\tINIT_LIST_HEAD(&tun->disabled);\n\t\terr = tun_attach(tun, file, false);\n\t\tif (err < 0)\n\t\t\tgoto err_free_flow;\n\n\t\terr = register_netdevice(tun->dev);\n\t\tif (err < 0)\n\t\t\tgoto err_detach;\n\t}\n\n\tnetif_carrier_on(tun->dev);\n\n\ttun_debug(KERN_INFO, tun, \"tun_set_iff\\n\");\n\n\ttun->flags = (tun->flags & ~TUN_FEATURES) |\n\t\t(ifr->ifr_flags & TUN_FEATURES);\n\n\t/* Make sure persistent devices do not get stuck in\n\t * xoff state.\n\t */\n\tif (netif_running(tun->dev))\n\t\tnetif_tx_wake_all_queues(tun->dev);\n\n\tstrcpy(ifr->ifr_name, tun->dev->name);\n\treturn 0;\n\nerr_detach:\n\ttun_detach_all(dev);\n\t/* register_netdevice() already called tun_free_netdev() */\n\tgoto err_free_dev;\n\nerr_free_flow:\n\ttun_flow_uninit(tun);\n\tsecurity_tun_dev_free_security(tun->security);\nerr_free_stat:\n\tfree_percpu(tun->pcpu_stats);\nerr_free_dev:\n\tfree_netdev(dev);\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 150334,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)\n{\n\tstruct tun_struct *tun;\n\tstruct tun_file *tfile = file->private_data;\n\tstruct net_device *dev;\n\tint err;\n\n\tif (tfile->detached)\n\t\treturn -EINVAL;\n\n\tdev = __dev_get_by_name(net, ifr->ifr_name);\n\tif (dev) {\n\t\tif (ifr->ifr_flags & IFF_TUN_EXCL)\n\t\t\treturn -EBUSY;\n\t\tif ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tif (!!(ifr->ifr_flags & IFF_MULTI_QUEUE) !=\n\t\t    !!(tun->flags & IFF_MULTI_QUEUE))\n\t\t\treturn -EINVAL;\n\n\t\tif (tun_not_capable(tun))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_open(tun->security);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = tun_attach(tun, file, ifr->ifr_flags & IFF_NOFILTER);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (tun->flags & IFF_MULTI_QUEUE &&\n\t\t    (tun->numqueues + tun->numdisabled > 1)) {\n\t\t\t/* One or more queue has already been attached, no need\n\t\t\t * to initialize the device again.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse {\n\t\tchar *name;\n\t\tunsigned long flags = 0;\n\t\tint queues = ifr->ifr_flags & IFF_MULTI_QUEUE ?\n\t\t\t     MAX_TAP_QUEUES : 1;\n\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_create();\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t/* Set dev type */\n\t\tif (ifr->ifr_flags & IFF_TUN) {\n\t\t\t/* TUN device */\n\t\t\tflags |= IFF_TUN;\n\t\t\tname = \"tun%d\";\n\t\t} else if (ifr->ifr_flags & IFF_TAP) {\n\t\t\t/* TAP device */\n\t\t\tflags |= IFF_TAP;\n\t\t\tname = \"tap%d\";\n\t\t} else\n\t\t\treturn -EINVAL;\n\n\t\tif (*ifr->ifr_name)\n\t\t\tname = ifr->ifr_name;\n\n\t\tdev = alloc_netdev_mqs(sizeof(struct tun_struct), name,\n\t\t\t\t       NET_NAME_UNKNOWN, tun_setup, queues,\n\t\t\t\t       queues);\n\n\t\tif (!dev)\n\t\t\treturn -ENOMEM;\n\t\terr = dev_get_valid_name(net, dev, name);\n\t\tif (err < 0)\n\t\t\tgoto err_free_dev;\n\n\t\tdev_net_set(dev, net);\n\t\tdev->rtnl_link_ops = &tun_link_ops;\n\t\tdev->ifindex = tfile->ifindex;\n\t\tdev->sysfs_groups[0] = &tun_attr_group;\n\n\t\ttun = netdev_priv(dev);\n\t\ttun->dev = dev;\n\t\ttun->flags = flags;\n\t\ttun->txflt.count = 0;\n\t\ttun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);\n\n\t\ttun->align = NET_SKB_PAD;\n\t\ttun->filter_attached = false;\n\t\ttun->sndbuf = tfile->socket.sk->sk_sndbuf;\n\t\ttun->rx_batched = 0;\n\n\t\ttun->pcpu_stats = netdev_alloc_pcpu_stats(struct tun_pcpu_stats);\n\t\tif (!tun->pcpu_stats) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_free_dev;\n\t\t}\n\n\t\tspin_lock_init(&tun->lock);\n\n\t\terr = security_tun_dev_alloc_security(&tun->security);\n\t\tif (err < 0)\n\t\t\tgoto err_free_stat;\n\n\t\ttun_net_init(dev);\n\t\ttun_flow_init(tun);\n\n\t\tdev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |\n\t\t\t\t   TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t   NETIF_F_HW_VLAN_STAG_TX;\n\t\tdev->features = dev->hw_features | NETIF_F_LLTX;\n\t\tdev->vlan_features = dev->features &\n\t\t\t\t     ~(NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t       NETIF_F_HW_VLAN_STAG_TX);\n\n\t\tINIT_LIST_HEAD(&tun->disabled);\n\t\terr = tun_attach(tun, file, false);\n\t\tif (err < 0)\n\t\t\tgoto err_free_flow;\n\n\t\terr = register_netdevice(tun->dev);\n\t\tif (err < 0)\n\t\t\tgoto err_detach;\n\t}\n\n\tnetif_carrier_on(tun->dev);\n\n\ttun_debug(KERN_INFO, tun, \"tun_set_iff\\n\");\n\n\ttun->flags = (tun->flags & ~TUN_FEATURES) |\n\t\t(ifr->ifr_flags & TUN_FEATURES);\n\n\t/* Make sure persistent devices do not get stuck in\n\t * xoff state.\n\t */\n\tif (netif_running(tun->dev))\n\t\tnetif_tx_wake_all_queues(tun->dev);\n\n\tstrcpy(ifr->ifr_name, tun->dev->name);\n\treturn 0;\n\nerr_detach:\n\ttun_detach_all(dev);\n\t/* register_netdevice() already called tun_free_netdev() */\n\tgoto err_free_dev;\n\nerr_free_flow:\n\ttun_flow_uninit(tun);\n\tsecurity_tun_dev_free_security(tun->security);\nerr_free_stat:\n\tfree_percpu(tun->pcpu_stats);\nerr_free_dev:\n\tfree_netdev(dev);\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 150335,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "MagickExport MagickBooleanType WriteImages(const ImageInfo *image_info,\n  Image *images,const char *filename,ExceptionInfo *exception)\n{\n#define WriteImageTag  \"Write/Image\"\n\n  ExceptionInfo\n    *sans_exception;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    proceed;\n\n  MagickOffsetType\n    progress;\n\n  MagickProgressMonitor\n    progress_monitor;\n\n  MagickSizeType\n    number_images;\n\n  MagickStatusType\n    status;\n\n  register Image\n    *p;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  write_info=CloneImageInfo(image_info);\n  *write_info->magick='\\0';\n  images=GetFirstImageInList(images);\n  if (filename != (const char *) NULL)\n    for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n      (void) CopyMagickString(p->filename,filename,MagickPathExtent);\n  (void) CopyMagickString(write_info->filename,images->filename,MagickPathExtent);\n  sans_exception=AcquireExceptionInfo();\n  (void) SetImageInfo(write_info,(unsigned int) GetImageListLength(images),\n    sans_exception);\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if (*write_info->magick == '\\0')\n    (void) CopyMagickString(write_info->magick,images->magick,MagickPathExtent);\n  p=images;\n  for ( ; GetNextImageInList(p) != (Image *) NULL; p=GetNextImageInList(p))\n    if (p->scene >= GetNextImageInList(p)->scene)\n      {\n        register ssize_t\n          i;\n\n        /*\n          Generate consistent scene numbers.\n        */\n        i=(ssize_t) images->scene;\n        for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n          p->scene=(size_t) i++;\n        break;\n      }\n  /*\n    Write images.\n  */\n  status=MagickTrue;\n  progress_monitor=(MagickProgressMonitor) NULL;\n  progress=0;\n  number_images=GetImageListLength(images);\n  for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n  {\n    if (number_images != 1)\n      progress_monitor=SetImageProgressMonitor(p,(MagickProgressMonitor) NULL,\n        p->client_data);\n    status&=WriteImage(write_info,p,exception);\n    if (number_images != 1)\n      (void) SetImageProgressMonitor(p,progress_monitor,p->client_data);\n    if (write_info->adjoin != MagickFalse)\n      break;\n    if (number_images != 1)\n      {\n        proceed=SetImageProgress(p,WriteImageTag,progress++,number_images);\n        if (proceed == MagickFalse)\n          break;\n      }\n  }\n  write_info=DestroyImageInfo(write_info);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 150336,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "MagickExport MagickBooleanType WriteImages(const ImageInfo *image_info,\n  Image *images,const char *filename,ExceptionInfo *exception)\n{\n#define WriteImageTag  \"Write/Image\"\n\n  ExceptionInfo\n    *sans_exception;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    proceed;\n\n  MagickOffsetType\n    progress;\n\n  MagickProgressMonitor\n    progress_monitor;\n\n  MagickSizeType\n    number_images;\n\n  MagickStatusType\n    status;\n\n  register Image\n    *p;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  write_info=CloneImageInfo(image_info);\n  *write_info->magick='\\0';\n  images=GetFirstImageInList(images);\n  if (filename != (const char *) NULL)\n    for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n      (void) CopyMagickString(p->filename,filename,MagickPathExtent);\n  (void) CopyMagickString(write_info->filename,images->filename,MagickPathExtent);\n  sans_exception=AcquireExceptionInfo();\n  (void) SetImageInfo(write_info,(unsigned int) GetImageListLength(images),\n    sans_exception);\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if (*write_info->magick == '\\0')\n    (void) CopyMagickString(write_info->magick,images->magick,MagickPathExtent);\n  p=images;\n  for ( ; GetNextImageInList(p) != (Image *) NULL; p=GetNextImageInList(p))\n  {\n    register Image\n      *next;\n    \n    next=GetNextImageInList(p);\n    if (next == (Image *) NULL)\n      break;\n    if (p->scene >= next->scene)\n      {\n        register ssize_t\n          i;\n\n        /*\n          Generate consistent scene numbers.\n        */\n        i=(ssize_t) images->scene;\n        for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n          p->scene=(size_t) i++;\n        break;\n      }\n  }\n  /*\n    Write images.\n  */\n  status=MagickTrue;\n  progress_monitor=(MagickProgressMonitor) NULL;\n  progress=0;\n  number_images=GetImageListLength(images);\n  for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n  {\n    if (number_images != 1)\n      progress_monitor=SetImageProgressMonitor(p,(MagickProgressMonitor) NULL,\n        p->client_data);\n    status&=WriteImage(write_info,p,exception);\n    if (number_images != 1)\n      (void) SetImageProgressMonitor(p,progress_monitor,p->client_data);\n    if (write_info->adjoin != MagickFalse)\n      break;\n    if (number_images != 1)\n      {\n        proceed=SetImageProgress(p,WriteImageTag,progress++,number_images);\n        if (proceed == MagickFalse)\n          break;\n      }\n  }\n  write_info=DestroyImageInfo(write_info);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 150337,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "Status GetInitOp(const string& export_dir, const MetaGraphDef& meta_graph_def,\n                 string* init_op_name) {\n  const auto& sig_def_map = meta_graph_def.signature_def();\n  const auto& init_op_sig_it =\n      meta_graph_def.signature_def().find(kSavedModelInitOpSignatureKey);\n  if (init_op_sig_it != sig_def_map.end()) {\n    const auto& sig_def_outputs = init_op_sig_it->second.outputs();\n    const auto& sig_def_outputs_it =\n        sig_def_outputs.find(kSavedModelInitOpSignatureKey);\n    if (sig_def_outputs_it == sig_def_outputs.end()) {\n      return errors::FailedPrecondition(\"Could not find output \",\n                                        kSavedModelInitOpSignatureKey);\n    }\n    *init_op_name = sig_def_outputs_it->second.name();\n    return Status::OK();\n  }\n\n  const auto& collection_def_map = meta_graph_def.collection_def();\n  string init_op_collection_key;\n  if (collection_def_map.find(kSavedModelMainOpKey) !=\n      collection_def_map.end()) {\n    init_op_collection_key = kSavedModelMainOpKey;\n  } else {\n    init_op_collection_key = kSavedModelLegacyInitOpKey;\n  }\n\n  const auto init_op_it = collection_def_map.find(init_op_collection_key);\n  if (init_op_it != collection_def_map.end()) {\n    if (init_op_it->second.node_list().value_size() != 1) {\n      return errors::FailedPrecondition(\n          strings::StrCat(\"Expected exactly one main op in : \", export_dir));\n    }\n    *init_op_name = init_op_it->second.node_list().value(0);\n  }\n  return Status::OK();\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 7,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "u32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (!hmhd || (hmhd->type != GF_ISOM_BOX_TYPE_HMHD))\n\t\treturn 0;\n\t\t\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;\n\t\tif (a) hmhd->subType = a->type;\n\t\treturn hmhd->subType;\n\t}\n\treturn hmhd->subType;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 11,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "mrb_ary_shift_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_int n;\n\n  if (mrb_get_args(mrb, \"|i\", &n) == 0) {\n    return mrb_ary_shift(mrb, self);\n  }\n\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int len = ARY_LEN(a);\n  mrb_value val;\n\n  ary_modify_check(mrb, a);\n  if (len == 0 || n == 0) return mrb_ary_new(mrb);\n  if (n < 0) mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative array shift\");\n  if (n > len) n = len;\n  val = mrb_ary_new_from_values(mrb, n, ARY_PTR(a));\n  if (ARY_SHARED_P(a)) {\n  L_SHIFT:\n    a->as.heap.ptr+=n;\n    a->as.heap.len-=n;\n    return val;\n  }\n  if (len > ARY_SHIFT_SHARED_MIN) {\n    ary_make_shared(mrb, a);\n    goto L_SHIFT;\n  }\n  else if (len == n) {\n    ARY_SET_LEN(a, 0);\n  }\n  else {\n    mrb_value *ptr = ARY_PTR(a);\n    mrb_int size = len-n;\n\n    while (size--) {\n      *ptr = *(ptr+n);\n      ++ptr;\n    }\n    ARY_SET_LEN(a, len-n);\n  }\n  return val;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 25,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "Status BuildXlaCompilationCache(DeviceBase* device, FunctionLibraryRuntime* flr,\n                                const XlaPlatformInfo& platform_info,\n                                XlaCompilationCache** cache) {\n  if (platform_info.xla_device_metadata()) {\n    *cache = new XlaCompilationCache(\n        platform_info.xla_device_metadata()->client(),\n        platform_info.xla_device_metadata()->jit_device_type());\n    return Status::OK();\n  }\n\n  auto platform =\n      se::MultiPlatformManager::PlatformWithId(platform_info.platform_id());\n  if (!platform.ok()) {\n    return platform.status();\n  }\n\n  StatusOr<xla::Compiler*> compiler_for_platform =\n      xla::Compiler::GetForPlatform(platform.ValueOrDie());\n  if (!compiler_for_platform.ok()) {\n    // In some rare cases (usually in unit tests with very small clusters) we\n    // may end up transforming an XLA cluster with at least one GPU operation\n    // (which would normally force the cluster to be compiled using XLA:GPU)\n    // into an XLA cluster with no GPU operations (i.e. containing only CPU\n    // operations).  Such a cluster can fail compilation (in way that\n    // MarkForCompilation could not have detected) if the CPU JIT is not linked\n    // in.\n    //\n    // So bail out of _XlaCompile in this case, and let the executor handle the\n    // situation for us.\n    const Status& status = compiler_for_platform.status();\n    if (status.code() == error::NOT_FOUND) {\n      return errors::Unimplemented(\"Could not find compiler for platform \",\n                                   platform.ValueOrDie()->Name(), \": \",\n                                   status.ToString());\n    }\n  }\n\n  xla::LocalClientOptions client_options;\n  client_options.set_platform(platform.ValueOrDie());\n  client_options.set_intra_op_parallelism_threads(\n      device->tensorflow_cpu_worker_threads()->num_threads);\n\n  if (flr->config_proto()) {\n    string allowed_gpus =\n        flr->config_proto()->gpu_options().visible_device_list();\n    TF_ASSIGN_OR_RETURN(absl::optional<std::set<int>> gpu_ids,\n                        ParseVisibleDeviceList(allowed_gpus));\n    client_options.set_allowed_devices(gpu_ids);\n  }\n\n  auto client = xla::ClientLibrary::GetOrCreateLocalClient(client_options);\n  if (!client.ok()) {\n    return client.status();\n  }\n  const XlaOpRegistry::DeviceRegistration* registration;\n  if (!XlaOpRegistry::GetCompilationDevice(platform_info.device_type().type(),\n                                           &registration)) {\n    return errors::InvalidArgument(\"No JIT device registered for \",\n                                   platform_info.device_type().type());\n  }\n  *cache = new XlaCompilationCache(\n      client.ValueOrDie(), DeviceType(registration->compilation_device_name));\n  return Status::OK();\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 29,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err mpgviddmx_process(GF_Filter *filter)\n{\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu64 byte_offset;\n\ts64 vosh_start = -1;\n\ts64 vosh_end = -1;\n\tGF_Err e;\n\tchar *data;\n\tu8 *start;\n\tu32 pck_size;\n\ts32 remain;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tmpgviddmx_check_dur(filter, ctx);\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_TRUE);\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\tctx->src_pck = NULL;\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\tbyte_offset = gf_filter_pck_get_byte_offset(pck);\n\n\tstart = data;\n\tremain = pck_size;\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (!ctx->resume_from && ctx->timescale) {\n\t\tu64 ts = gf_filter_pck_get_cts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (!ctx->cts || !ctx->recompute_cts)\n\t\t\t\tctx->cts = ts;\n\t\t}\n\t\tts = gf_filter_pck_get_dts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (!ctx->dts || !ctx->recompute_cts)\n\t\t\t\tctx->dts = ts;\n\n\t\t\tif (!ctx->prev_dts) ctx->prev_dts = ts;\n\t\t\telse if (ctx->prev_dts != ts) {\n\t\t\t\tu64 diff = ts;\n\t\t\t\tdiff -= ctx->prev_dts;\n\t\t\t\tif (!ctx->cur_fps.den) ctx->cur_fps.den = (u32) diff;\n\t\t\t\telse if (ctx->cur_fps.den > diff)\n\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\t\t\t}\n\t\t}\n\t\tgf_filter_pck_get_framing(pck, &ctx->input_is_au_start, &ctx->input_is_au_end);\n\t\t//this will force CTS recomput of each frame\n\t\tif (ctx->recompute_cts) ctx->input_is_au_start = GF_FALSE;\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = pck;\n\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t}\n\n\t//we stored some data to find the complete vosh, aggregate this packet with current one\n\tif (!ctx->resume_from && ctx->hdr_store_size) {\n\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size) {\n\t\t\tctx->hdr_store_alloc = ctx->hdr_store_size + pck_size;\n\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t}\n\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size);\n\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\tif (byte_offset >= ctx->hdr_store_size)\n\t\t\t\tbyte_offset -= ctx->hdr_store_size;\n\t\t\telse\n\t\t\t\tbyte_offset = GF_FILTER_NO_BO;\n\t\t}\n\t\tctx->hdr_store_size += pck_size;\n\t\tstart = data = ctx->hdr_store;\n\t\tremain = pck_size = ctx->hdr_store_size;\n\t}\n\n\tif (ctx->resume_from) {\n\t\tif (gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\n\t\t//resume from data copied internally\n\t\tif (ctx->hdr_store_size) {\n\t\t\tassert(ctx->resume_from <= ctx->hdr_store_size);\n\t\t\tstart = data = ctx->hdr_store + ctx->resume_from;\n\t\t\tremain = pck_size = ctx->hdr_store_size - ctx->resume_from;\n\t\t} else {\n\t\t\tassert(remain >= (s32) ctx->resume_from);\n\t\t\tstart += ctx->resume_from;\n\t\t\tremain -= ctx->resume_from;\n\t\t}\n\t\tctx->resume_from = 0;\n\t}\n\n\tif (!ctx->bs) {\n\t\tctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);\n\t} else {\n\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t}\n\tif (!ctx->vparser) {\n\t\tctx->vparser = gf_m4v_parser_bs_new(ctx->bs, ctx->is_mpg12);\n\t}\n\n\n\twhile (remain) {\n\t\tBool full_frame;\n\t\tu8 *pck_data;\n\t\ts32 current;\n\t\tu8 sc_type, forced_sc_type=0;\n\t\tBool sc_type_forced = GF_FALSE;\n\t\tBool skip_pck = GF_FALSE;\n\t\tu8 ftype;\n\t\tu32 tinc;\n\t\tu64 size=0;\n\t\tu64 fstart;\n\t\tBool is_coded;\n\t\tu32 bytes_from_store = 0;\n\t\tu32 hdr_offset = 0;\n\t\tBool copy_last_bytes = GF_FALSE;\n\n\t\t//not enough bytes to parse start code\n\t\tif (remain<5) {\n\t\t\tmemcpy(ctx->hdr_store, start, remain);\n\t\t\tctx->bytes_in_header = remain;\n\t\t\tbreak;\n\t\t}\n\t\tcurrent = -1;\n\n\t\t//we have some potential bytes of a start code in the store, copy some more bytes and check if valid start code.\n\t\t//if not, dispatch these bytes as continuation of the data\n\t\tif (ctx->bytes_in_header) {\n\n\t\t\tmemcpy(ctx->hdr_store + ctx->bytes_in_header, start, 8 - ctx->bytes_in_header);\n\t\t\tcurrent = mpgviddmx_next_start_code(ctx->hdr_store, 8);\n\n\t\t\t//no start code in stored buffer\n\t\t\tif ((current<0) || (current >= (s32) ctx->bytes_in_header) )  {\n\t\t\t\tif (ctx->opid) {\n\t\t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data);\n\t\t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\t\tmemcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header);\n\t\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\n\t\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);\n\t\t\t\t\t}\n\n\t\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\t}\n\n\t\t\t\tif (current<0) current = -1;\n\t\t\t\telse current -= ctx->bytes_in_header;\n\t\t\t\tctx->bytes_in_header = 0;\n\t\t\t} else {\n\t\t\t\t//we have a valid start code, check which byte in our store or in the packet payload is the start code type\n\t\t\t\t//and remember its location to reinit the parser from there\n\t\t\t\thdr_offset = 4 - ctx->bytes_in_header + current;\n\t\t\t\t//bytes still to dispatch\n\t\t\t\tbytes_from_store = ctx->bytes_in_header;\n\t\t\t\tctx->bytes_in_header = 0;\n\t\t\t\tif (!hdr_offset) {\n\t\t\t\t\tforced_sc_type = ctx->hdr_store[current+3];\n\t\t\t\t} else {\n\t\t\t\t\tforced_sc_type = start[hdr_offset-1];\n\t\t\t\t}\n\t\t\t\tsc_type_forced = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\t//no starcode in store, look for startcode in packet\n\t\tif (current == -1) {\n\t\t\t//locate next start code\n\t\t\tcurrent = mpgviddmx_next_start_code(start, remain);\n\t\t\t//no start code, dispatch the block\n\t\t\tif (current<0) {\n\t\t\t\tu8 b3, b2, b1;\n\t\t\t\tif (! ctx->frame_started) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MPGVid] no start code in block and no frame started, discarding data\\n\" ));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsize = remain;\n\t\t\t\tb3 = start[remain-3];\n\t\t\t\tb2 = start[remain-2];\n\t\t\t\tb1 = start[remain-1];\n\t\t\t\t//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !\n\t\t\t\tif (!b1 || !b2 || !b3) {\n\t\t\t\t\tcopy_last_bytes = GF_TRUE;\n\t\t\t\t\tassert(size >= 3);\n\t\t\t\t\tsize -= 3;\n\t\t\t\t\tctx->bytes_in_header = 3;\n\t\t\t\t}\n\n\t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n\t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\t\tmemcpy(pck_data, start, (size_t) size);\n\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\t}\n\n\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\tif (copy_last_bytes) {\n\t\t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tassert(current>=0);\n\n\t\t//if we are in the middle of parsing the vosh, skip over bytes remaining from previous obj not parsed\n\t\tif ((vosh_start>=0) && current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t}\n\t\t//also skip if no output pid\n\t\tif (!ctx->opid && current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t}\n\t\t//dispatch remaining bytes\n\t\tif (current>0) {\n\t\t\t//flush remaining\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &pck_data);\n\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_TRUE);\n\t\t\t//bytes were partly in store, partly in packet\n\t\t\tif (bytes_from_store) {\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n\t\t\t\t}\n\t\t\t\tassert(bytes_from_store>=(u32) current);\n\t\t\t\tbytes_from_store -= current;\n\t\t\t\tmemcpy(pck_data, ctx->hdr_store, current);\n\t\t\t} else {\n\t\t\t\t//bytes were only in packet\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\t}\n\t\t\t\tmemcpy(pck_data, start, current);\n\t\t\t\tassert(remain>=current);\n\t\t\t\tstart += current;\n\t\t\t\tremain -= current;\n\t\t\t\tcurrent = 0;\n\t\t\t}\n\t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t}\n\n\t\t//not enough bytes to parse start code\n\t\tif (remain<5) {\n\t\t\tmemcpy(ctx->hdr_store, start, remain);\n\t\t\tctx->bytes_in_header = remain;\n\t\t\tbreak;\n\t\t}\n\n\t\t//parse headers\n\t\t//we have a start code loaded, eg the data packet does not have a full start code at the beginning\n\t\tif (sc_type_forced) {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, start + hdr_offset, remain - hdr_offset);\n\t\t\tsc_type = forced_sc_type;\n\t\t} else {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\tgf_bs_read_int(ctx->bs, 24);\n\t\t\tsc_type = gf_bs_read_int(ctx->bs, 8);\n\t\t}\n\n\t\tif (ctx->is_mpg12) {\n\t\t\tswitch (sc_type) {\n\t\t\tcase M2V_SEQ_START_CODE:\n\t\t\tcase M2V_EXT_START_CODE:\n\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\t//not enough data, accumulate until we can parse the full header\n\t\t\t\tif (e==GF_EOS) {\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tif (data == ctx->hdr_store) {\n\t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);\n\t\t\t\t\t\tctx->hdr_store_size = remain;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n\t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);\n\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n\t\t\t\t\t}\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t} else if (e != GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t} else {\n\t\t\t\t\tmpgviddmx_check_pid(filter, ctx, 0, NULL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase M2V_PIC_START_CODE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else {\n\t\t\tu8 PL;\n\t\t\tswitch (sc_type) {\n\t\t\tcase M4V_VOS_START_CODE:\n\t\t\t\tctx->dsi.VideoPL = (u8) gf_bs_read_u8(ctx->bs);\n\t\t\t\tvosh_start = start - (u8 *)data;\n\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\tassert(remain>=5);\n\t\t\t\tstart += 5;\n\t\t\t\tremain -= 5;\n\t\t\t\tbreak;\n\t\t\tcase M4V_VOL_START_CODE:\n\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\tPL = ctx->dsi.VideoPL;\n\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\tctx->dsi.VideoPL = PL;\n\t\t\t\t//not enough data, accumulate until we can parse the full header\n\t\t\t\tif (e==GF_EOS) {\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tif (data == ctx->hdr_store) {\n\t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);\n\t\t\t\t\t\tctx->hdr_store_size = remain;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n\t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);\n\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n\t\t\t\t\t}\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t} else if (e != GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t} else {\n\t\t\t\t\tu32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser);\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tvosh_end = start - (u8 *)data + obj_size;\n\t\t\t\t\tvosh_end -= vosh_start;\n\t\t\t\t\tmpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start);\n\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\tassert(remain>=(s32) obj_size);\n\t\t\t\t\tstart += obj_size;\n\t\t\t\t\tremain -= obj_size;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase M4V_VOP_START_CODE:\n\t\t\tcase M4V_GOV_START_CODE:\n\t\t\t\tbreak;\n\n\t\t\tcase M4V_VO_START_CODE:\n\t\t\tcase M4V_VISOBJ_START_CODE:\n\t\t\tdefault:\n\t\t\t\tif (vosh_start>=0) {\n\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\tassert(remain>=4);\n\t\t\t\t\tstart += 4;\n\t\t\t\t\tremain -= 4;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (skip_pck) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->opid) {\n\t\t\tassert(remain>=4);\n\t\t\tstart += 4;\n\t\t\tremain -= 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = (u32) ((char *)start -  (char *)data);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//at this point, we no longer reaggregate packets\n\t\tctx->hdr_store_size = 0;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->cur_fps.num);\n\t\t\tif (ctx->cts + ctx->cur_fps.den >= nb_frames_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\t//may happen that after all our checks, only 4 bytes are left, continue to store these 4 bytes\n\t\tif (remain<5)\n\t\t\tcontinue;\n\n\t\t//good to go\n\t\tgf_m4v_parser_reset(ctx->vparser, sc_type_forced ? forced_sc_type + 1 : 0);\n\t\tsize = 0;\n\t\te = gf_m4v_parse_frame(ctx->vparser, &ctx->dsi, &ftype, &tinc, &size, &fstart, &is_coded);\n\t\t//true if we strip VO and VISOBJ assert(!fstart);\n\n\t\t//we skipped bytes already in store + end of start code present in packet, so the size of the first object\n\t\t//needs adjustement\n\t\tif (bytes_from_store) {\n\t\t\tsize += bytes_from_store + hdr_offset;\n\t\t}\n\n\t\tif ((e == GF_EOS) && !ctx->input_is_au_end) {\n\t\t\tu8 b3 = start[remain-3];\n\t\t\tu8 b2 = start[remain-2];\n\t\t\tu8 b1 = start[remain-1];\n\n\t\t\t//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !\n\t\t\tif (!b1 || !b2 || !b3) {\n\t\t\t\tcopy_last_bytes = GF_TRUE;\n\t\t\t\tassert(size >= 3);\n\t\t\t\tsize -= 3;\n\t\t\t\tctx->bytes_in_header = 3;\n\t\t\t}\n\t\t\tfull_frame = GF_FALSE;\n\t\t} else {\n\t\t\tfull_frame = GF_TRUE;\n\t\t}\n\n\t\tif (!is_coded) {\n\t\t\t/*if prev is B and we're parsing a packed bitstream discard n-vop*/\n\t\t\tif (ctx->forced_packed && ctx->b_frames) {\n\t\t\t\tctx->is_packed = GF_TRUE;\n\t\t\t\tassert(remain>=size);\n\t\t\t\tstart += size;\n\t\t\t\tremain -= (s32) size;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*policy is to import at variable frame rate, skip*/\n\t\t\tif (ctx->vfr) {\n\t\t\t\tctx->is_vfr = GF_TRUE;\n\t\t\t\tmpgviddmx_update_time(ctx);\n\t\t\t\tassert(remain>=size);\n\t\t\t\tstart += size;\n\t\t\t\tremain -= (s32) size;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*policy is to keep non coded frame (constant frame rate), add*/\n\t\t}\n\n\t\tif (ftype==2) {\n\t\t\t//count number of B-frames since last ref\n\t\t\tctx->b_frames++;\n\t\t\tctx->nb_b++;\n\t\t} else {\n\t\t\t//flush all pending packets\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);\n\t\t\t//remeber the CTS of the last ref\n\t\t\tctx->last_ref_cts = ctx->cts;\n\t\t\tif (ctx->max_b < ctx->b_frames) ctx->max_b = ctx->b_frames;\n\t\t\t\n\t\t\tctx->b_frames = 0;\n\t\t\tif (ftype)\n\t\t\t\tctx->nb_p++;\n\t\t\telse\n\t\t\t\tctx->nb_i++;\n\t\t}\n\t\tctx->nb_frames++;\n\n\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t//bytes come from both our store and the data packet\n\t\tif (bytes_from_store) {\n\t\t\tmemcpy(pck_data, ctx->hdr_store+current, bytes_from_store);\n\t\t\tassert(size >= bytes_from_store);\n\t\t\tsize -= bytes_from_store;\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n\t\t\t}\n\t\t\tmemcpy(pck_data + bytes_from_store, start, (size_t) size);\n\t\t} else {\n\t\t\t//bytes only come the data packet\n\t\t\tmemcpy(pck_data, start, (size_t) size);\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data);\n\t\t\t}\n\t\t}\n\t\tassert(pck_data[0] == 0);\n\t\tassert(pck_data[1] == 0);\n\t\tassert(pck_data[2] == 0x01);\n\n\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE);\n\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\tgf_filter_pck_set_dts(dst_pck, ctx->dts);\n\t\tif (ctx->input_is_au_start) {\n\t\t\tctx->input_is_au_start = GF_FALSE;\n\t\t} else {\n\t\t\t//we use the carousel flag temporarly to indicate the cts must be recomputed\n\t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n\t\t}\n\t\tgf_filter_pck_set_sap(dst_pck, ftype ? GF_FILTER_SAP_NONE : GF_FILTER_SAP_1);\n\t\tgf_filter_pck_set_duration(dst_pck, ctx->cur_fps.den);\n\t\tif (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);\n\t\tctx->frame_started = GF_TRUE;\n\n\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\n\t\tmpgviddmx_update_time(ctx);\n\n\t\tif (!full_frame) {\n\t\t\tif (copy_last_bytes) {\n\t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tassert(remain>=size);\n\t\tstart += size;\n\t\tremain -= (s32) size;\n\t}\n\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\treturn GF_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 37,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "s32 gf_avc_parse_nalu(GF_BitStream *bs, AVCState *avc)\n{\n\tu8 idr_flag;\n\ts32 slice, ret;\n\tu32 nal_hdr;\n\tAVCSliceInfo n_state;\n\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tnal_hdr = gf_bs_read_u8(bs);\n\n\tslice = 0;\n\tmemcpy(&n_state, &avc->s_info, sizeof(AVCSliceInfo));\n\tavc->last_nal_type_parsed = n_state.nal_unit_type = nal_hdr & 0x1F;\n\tn_state.nal_ref_idc = (nal_hdr >> 5) & 0x3;\n\n\tidr_flag = 0;\n\n\tswitch (n_state.nal_unit_type) {\n\tcase GF_AVC_NALU_ACCESS_UNIT:\n\tcase GF_AVC_NALU_END_OF_SEQ:\n\tcase GF_AVC_NALU_END_OF_STREAM:\n\t\tret = 1;\n\t\tbreak;\n\n\tcase GF_AVC_NALU_SVC_SLICE:\n\t\tSVC_ReadNal_header_extension(bs, &n_state.NalHeader);\n\t\t// slice buffer - read the info and compare.\n\t\t/*ret = */svc_parse_slice(bs, avc, &n_state);\n\t\tif (avc->s_info.nal_ref_idc) {\n\t\t\tn_state.poc_lsb_prev = avc->s_info.poc_lsb;\n\t\t\tn_state.poc_msb_prev = avc->s_info.poc_msb;\n\t\t}\n\t\tavc_compute_poc(&n_state);\n\n\t\tif (avc->s_info.poc != n_state.poc) {\n\t\t\tmemcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));\n\t\t\treturn 1;\n\t\t}\n\t\tmemcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_SVC_PREFIX_NALU:\n\t\tSVC_ReadNal_header_extension(bs, &n_state.NalHeader);\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_IDR_SLICE:\n\tcase GF_AVC_NALU_NON_IDR_SLICE:\n\tcase GF_AVC_NALU_DP_A_SLICE:\n\tcase GF_AVC_NALU_DP_B_SLICE:\n\tcase GF_AVC_NALU_DP_C_SLICE:\n\t\tslice = 1;\n\t\t/* slice buffer - read the info and compare.*/\n\t\tret = avc_parse_slice(bs, avc, idr_flag, &n_state);\n\t\tif (ret < 0) return ret;\n\t\tret = 0;\n\t\tif (\n\t\t\t((avc->s_info.nal_unit_type > GF_AVC_NALU_IDR_SLICE) || (avc->s_info.nal_unit_type < GF_AVC_NALU_NON_IDR_SLICE))\n\t\t\t&& (avc->s_info.nal_unit_type != GF_AVC_NALU_SVC_SLICE)\n\t\t\t) {\n\t\t\tbreak;\n\t\t}\n\t\tif (avc->s_info.frame_num != n_state.frame_num) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (avc->s_info.field_pic_flag != n_state.field_pic_flag) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif ((avc->s_info.nal_ref_idc != n_state.nal_ref_idc) &&\n\t\t\t(!avc->s_info.nal_ref_idc || !n_state.nal_ref_idc)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!avc->s_info.sps)\n\t\t\treturn -1;\n\n\t\tif (avc->s_info.sps->poc_type == n_state.sps->poc_type) {\n\t\t\tif (!avc->s_info.sps->poc_type) {\n\t\t\t\tif (!n_state.bottom_field_flag && (avc->s_info.poc_lsb != n_state.poc_lsb)) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (avc->s_info.delta_poc_bottom != n_state.delta_poc_bottom) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (avc->s_info.sps->poc_type == 1) {\n\t\t\t\tif (avc->s_info.delta_poc[0] != n_state.delta_poc[0]) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (avc->s_info.delta_poc[1] != n_state.delta_poc[1]) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (n_state.nal_unit_type == GF_AVC_NALU_IDR_SLICE) {\n\t\t\tif (avc->s_info.nal_unit_type != GF_AVC_NALU_IDR_SLICE) { /*IdrPicFlag differs in value*/\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (avc->s_info.idr_pic_id != n_state.idr_pic_id) { /*both IDR and idr_pic_id differs*/\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\tavc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 0, NULL, nal_hdr);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_PIC_PARAM:\n\t\tavc->last_ps_idx = gf_avc_read_pps_bs_internal(bs, avc, nal_hdr);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\tavc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 1, NULL, nal_hdr);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\tavc->last_ps_idx = (s32) gf_bs_read_ue(bs);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_SEI:\n\tcase GF_AVC_NALU_FILLER_DATA:\n\t\treturn 0;\n\n\tdefault:\n\t\tif (avc->s_info.nal_unit_type <= GF_AVC_NALU_IDR_SLICE) ret = 1;\n\t\t//To detect change of AU when multiple sps and pps in stream\n\t\telse if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEI && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)\n\t\t\tret = 1;\n\t\telse if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEQ_PARAM && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)\n\t\t\tret = 1;\n\t\telse\n\t\t\tret = 0;\n\t\tbreak;\n\t}\n\n\t/* save _prev values */\n\tif (ret && avc->s_info.sps) {\n\t\tn_state.frame_num_offset_prev = avc->s_info.frame_num_offset;\n\t\tif ((avc->s_info.sps->poc_type != 2) || (avc->s_info.nal_ref_idc != 0))\n\t\t\tn_state.frame_num_prev = avc->s_info.frame_num;\n\t\tif (avc->s_info.nal_ref_idc) {\n\t\t\tn_state.poc_lsb_prev = avc->s_info.poc_lsb;\n\t\t\tn_state.poc_msb_prev = avc->s_info.poc_msb;\n\t\t}\n\t}\n\tif (slice)\n\t\tavc_compute_poc(&n_state);\n\tmemcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 59,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "bool ConstantFolding::MulConvPushDown(GraphDef* optimized_graph, NodeDef* node,\n                                      const GraphProperties& properties) {\n  // Push down multiplication on ConvND.\n  //                       *                  ConvND\n  //                     /   \\                /    \\\n  //                 ConvND  C2    -- >      X      *\n  //                  / \\                          / \\\n  //                 X  C1                       C1  C2\n  //\n  // where C1 and C2 are constants and X is non-constant.\n  //\n  // TODO(rmlarsen): Use PrepareConstantPushDown() to simplify this code.\n\n  if (!IsAnyMul(*node) || NumNonControlInputs(*node) != 2) return false;\n\n  NodeDef* mul_left_child = node_map_->GetNode(node->input(0));\n  NodeDef* mul_right_child = node_map_->GetNode(node->input(1));\n  if (mul_left_child == nullptr || mul_right_child == nullptr) {\n    return false;\n  }\n  // One child must be constant, and the second must be Conv op.\n  const bool left_child_is_constant = IsReallyConstant(*mul_left_child);\n  const bool right_child_is_constant = IsReallyConstant(*mul_right_child);\n  if (!left_child_is_constant && !right_child_is_constant) {\n    return false;\n  }\n  NodeDef* conv_node =\n      left_child_is_constant ? mul_right_child : mul_left_child;\n  if (!IsConv2D(*conv_node) && !IsConv3D(*conv_node)) {\n    return false;\n  }\n  if (node->device() != mul_left_child->device() ||\n      node->device() != mul_right_child->device()) {\n    return false;\n  }\n\n  // Make sure that it is safe to change the value of the convolution\n  // output.\n  if (conv_node->input_size() < 2 ||\n      NumNonControlOutputs(*conv_node, *node_map_) > 1 ||\n      nodes_to_preserve_.find(conv_node->name()) != nodes_to_preserve_.end()) {\n    return false;\n  }\n\n  // Identify the nodes to swap.\n  NodeDef* conv_left_child = node_map_->GetNode(conv_node->input(0));\n  NodeDef* conv_right_child = node_map_->GetNode(conv_node->input(1));\n  const bool conv_left_is_constant = IsReallyConstant(*conv_left_child);\n  const bool conv_right_is_constant = IsReallyConstant(*conv_right_child);\n  if (!conv_left_is_constant && !conv_right_is_constant) {\n    // At least one of the convolution inputs should be constant.\n    return false;\n  }\n  if (conv_left_is_constant && conv_right_is_constant) {\n    // Leverage regular constant folding to handle this.\n    return false;\n  }\n  const auto& mul_props = properties.GetOutputProperties(node->name());\n  const auto& conv_props = properties.GetOutputProperties(conv_node->name());\n  if (mul_props.empty() || conv_props.empty()) {\n    return false;\n  }\n  const auto& mul_shape = mul_props[0].shape();\n  const auto& conv_shape = conv_props[0].shape();\n  if (!ShapesSymbolicallyEqual(mul_shape, conv_shape)) {\n    return false;\n  }\n\n  const auto& input_props = properties.GetInputProperties(conv_node->name());\n  if (input_props.size() < 2) {\n    return false;\n  }\n  const auto& filter_shape = input_props[1].shape();\n\n  NodeDef* const_node =\n      left_child_is_constant ? mul_left_child : mul_right_child;\n  const auto& const_props = properties.GetOutputProperties(const_node->name());\n  if (const_props.empty()) {\n    return false;\n  }\n  const auto& const_shape = const_props[0].shape();\n  if (!IsValidConstShapeForMulConvPushDown(\n          conv_node->attr().at(\"data_format\").s(), filter_shape, const_shape)) {\n    return false;\n  }\n\n  string mul_new_name = AddPrefixToNodeName(\"merged_input\", conv_node->name());\n  if (node_map_->NodeExists(mul_new_name)) {\n    return false;\n  }\n  // Make sure we don't introduce loops in the graph by removing control\n  // dependencies from the conv2d node to c2.\n  string conv_const_input =\n      conv_left_is_constant ? conv_node->input(0) : conv_node->input(1);\n  if (MaybeRemoveControlInput(conv_node->name(), const_node, optimized_graph,\n                              node_map_.get())) {\n    // Add a control dep from c1 to c2 to ensure c2 is in the right frame\n    MaybeAddControlInput(conv_const_input, const_node, optimized_graph,\n                         node_map_.get());\n  }\n\n  conv_node->set_name(node->name());\n  node->set_name(mul_new_name);\n  if (conv_left_is_constant) {\n    node_map_->UpdateInput(conv_node->name(), node->input(0), mul_new_name);\n    conv_node->set_input(0, mul_new_name);\n  } else {\n    node_map_->UpdateInput(conv_node->name(), node->input(1), mul_new_name);\n    conv_node->set_input(1, mul_new_name);\n  }\n  NodeDef* conv_const_node =\n      conv_left_is_constant ? conv_left_child : conv_right_child;\n  if (left_child_is_constant) {\n    node->set_input(1, conv_const_node->name());\n  } else {\n    node->set_input(0, conv_const_node->name());\n  }\n  node_map_->AddNode(mul_new_name, node);\n\n  return true;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 69,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "gen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (val && len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (val && (len > 0 || update)) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n  }\n  if (update) {\n    if (val && len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  /* variable length */\n  }\n  return len;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 73,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "bool IsIdentityConsumingSwitch(const MutableGraphView& graph,\n                               const NodeDef& node) {\n  if ((IsIdentity(node) || IsIdentityNSingleInput(node)) &&\n      node.input_size() > 0) {\n    TensorId tensor_id = ParseTensorName(node.input(0));\n    if (IsTensorIdControlling(tensor_id)) {\n      return false;\n    }\n\n    NodeDef* input_node = graph.GetNode(tensor_id.node());\n    if (input_node == nullptr) {\n      return false;\n    }\n    return IsSwitch(*input_node);\n  }\n  return false;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 105,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "\nvoid gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) {\n\t\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t\t}\n\t\tgf_free(ptr->entries);\n\t}\n\tgf_free(ptr);",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 115,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override {\n    // Create a new SparseTensorSliceDatasetOp::Dataset, insert it in\n    // the step container, and return it as the output.\n    const Tensor* indices;\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices));\n    const Tensor* values;\n    OP_REQUIRES_OK(ctx, ctx->input(\"values\", &values));\n    const Tensor* dense_shape;\n    OP_REQUIRES_OK(ctx, ctx->input(\"dense_shape\", &dense_shape));\n\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices->shape()),\n                errors::InvalidArgument(\"Input indices must be a matrix. Got: \",\n                                        indices->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()),\n                errors::InvalidArgument(\"Input values must be a vector. Got: \",\n                                        values->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape->shape()),\n                errors::InvalidArgument(\"Input shape must be a vector. Got: \",\n                                        dense_shape->shape().DebugString()));\n    OP_REQUIRES(\n        ctx, values->shape().dim_size(0) == indices->shape().dim_size(0),\n        errors::InvalidArgument(\n            \"Number of values must match first dimension of indices. \", \"Got \",\n            values->shape().dim_size(0),\n            \" values, indices shape: \", indices->shape().DebugString()));\n    OP_REQUIRES(\n        ctx, dense_shape->shape().dim_size(0) == indices->shape().dim_size(1),\n        errors::InvalidArgument(\n            \"Number of dimensions must match second dimension of indices. \",\n            \"Got \", dense_shape->shape().dim_size(0),\n            \" dimensions, indices shape: \", indices->shape().DebugString()));\n    OP_REQUIRES(ctx, dense_shape->NumElements() > 0,\n                errors::InvalidArgument(\n                    \"The shape argument requires at least one element.\"));\n\n    // We currently ensure that `sparse_tensor` is ordered in the\n    // batch dimension.\n    // TODO(mrry): Investigate ways to avoid this unconditional check\n    // if we can be sure that the sparse tensor was produced in an\n    // appropriate order (e.g. by `tf.parse_example()` or a Dataset\n    // that batches elements into rows of a SparseTensor).\n    int64_t previous_batch_index = -1;\n    for (int64_t i = 0; i < indices->dim_size(0); ++i) {\n      int64_t next_batch_index = indices->matrix<int64_t>()(i, 0);\n      OP_REQUIRES(\n          ctx, next_batch_index >= previous_batch_index,\n          errors::Unimplemented(\"The SparseTensor must be ordered in the batch \"\n                                \"dimension; handling arbitrarily ordered input \"\n                                \"is not currently supported.\"));\n      previous_batch_index = next_batch_index;\n    }\n    gtl::InlinedVector<int64_t, 8> std_order(dense_shape->NumElements(), 0);\n    sparse::SparseTensor tensor;\n    OP_REQUIRES_OK(\n        ctx, sparse::SparseTensor::Create(\n                 *indices, *values, TensorShape(dense_shape->vec<int64_t>()),\n                 std_order, &tensor));\n    *output = new Dataset<T>(ctx, std::move(tensor));\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 117,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "IRC_PROTOCOL_CALLBACK(352)\n{\n    char *pos_attr, *pos_hopcount, *pos_realname, *str_host;\n    int arg_start, length;\n    struct t_irc_channel *ptr_channel;\n    struct t_irc_nick *ptr_nick;\n\n    IRC_PROTOCOL_MIN_ARGS(5);\n\n    /* silently ignore malformed 352 message (missing infos) */\n    if (argc < 8)\n        return WEECHAT_RC_OK;\n\n    pos_attr = NULL;\n    pos_hopcount = NULL;\n    pos_realname = NULL;\n\n    if (argc > 8)\n    {\n        arg_start = ((argc > 9) && (strcmp (argv[8], \"*\") == 0)) ? 9 : 8;\n        if (argv[arg_start][0] == ':')\n        {\n            pos_attr = NULL;\n            pos_hopcount = (argc > arg_start) ? argv[arg_start] + 1 : NULL;\n            pos_realname = (argc > arg_start + 1) ? argv_eol[arg_start + 1] : NULL;\n        }\n        else\n        {\n            pos_attr = argv[arg_start];\n            pos_hopcount = (argc > arg_start + 1) ? argv[arg_start + 1] + 1 : NULL;\n            pos_realname = (argc > arg_start + 2) ? argv_eol[arg_start + 2] : NULL;\n        }\n    }\n\n    ptr_channel = irc_channel_search (server, argv[3]);\n    ptr_nick = (ptr_channel) ?\n        irc_nick_search (server, ptr_channel, argv[7]) : NULL;\n\n    /* update host in nick */\n    if (ptr_nick)\n    {\n        length = strlen (argv[4]) + 1 + strlen (argv[5]) + 1;\n        str_host = malloc (length);\n        if (str_host)\n        {\n            snprintf (str_host, length, \"%s@%s\", argv[4], argv[5]);\n            irc_nick_set_host (ptr_nick, str_host);\n            free (str_host);\n        }\n    }\n\n    /* update away flag in nick */\n    if (ptr_channel && ptr_nick && pos_attr)\n    {\n        irc_nick_set_away (server, ptr_channel, ptr_nick,\n                           (pos_attr[0] == 'G') ? 1 : 0);\n    }\n\n    /* update realname in nick */\n    if (ptr_channel && ptr_nick && pos_realname)\n    {\n        if (ptr_nick->realname)\n            free (ptr_nick->realname);\n        if (pos_realname &&\n            weechat_hashtable_has_key (server->cap_list, \"extended-join\"))\n        {\n            ptr_nick->realname = strdup (pos_realname);\n        }\n        else\n        {\n            ptr_nick->realname = NULL;\n        }\n    }\n\n    /* display output of who (manual who from user) */\n    if (!ptr_channel || (ptr_channel->checking_whox <= 0))\n    {\n        weechat_printf_date_tags (\n            irc_msgbuffer_get_target_buffer (\n                server, NULL, command, \"who\", NULL),\n            date,\n            irc_protocol_tags (command, \"irc_numeric\", NULL, NULL),\n            \"%s%s[%s%s%s] %s%s %s(%s%s@%s%s)%s %s%s%s%s(%s)\",\n            weechat_prefix (\"network\"),\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_CHAT_CHANNEL,\n            argv[3],\n            IRC_COLOR_CHAT_DELIMITERS,\n            irc_nick_color_for_msg (server, 1, NULL, argv[7]),\n            argv[7],\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_CHAT_HOST,\n            argv[4],\n            argv[5],\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_RESET,\n            (pos_attr) ? pos_attr : \"\",\n            (pos_attr) ? \" \" : \"\",\n            (pos_hopcount) ? pos_hopcount : \"\",\n            (pos_hopcount) ? \" \" : \"\",\n            (pos_realname) ? pos_realname : \"\");\n    }\n\n    return WEECHAT_RC_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 119,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "Status GetDeviceForInput(const EagerOperation& op, const EagerContext& ctx,\n                         TensorHandle* tensor_handle, Device** result) {\n  Device* cpu_device = ctx.HostCPU();\n  string device_name;\n  if (tensor_handle->Type() != TensorHandle::LOCAL) {\n    Device* device = tensor_handle->device();\n    device_name = device != nullptr ? device->name() : cpu_device->name();\n    *result = (device == nullptr ? cpu_device : device);\n  } else if (tensor_handle->dtype == DT_RESOURCE) {\n    // Use the resource's actual device because it is the device that will\n    // influence partitioning the multi-device function.\n    const Tensor* tensor;\n    // TODO(fishx): Avoid blocking here.\n    TF_RETURN_IF_ERROR(tensor_handle->Tensor(&tensor));\n    if (tensor->NumElements() == 0) {\n      return errors::InvalidArgument(\"Empty resource handle\");\n    }\n    const ResourceHandle& handle = tensor->flat<ResourceHandle>()(0);\n    device_name = handle.device();\n\n    Device* input_device;\n    TF_RETURN_IF_ERROR(\n        ctx.FindDeviceFromName(device_name.c_str(), &input_device));\n    *result = input_device;\n  } else {\n    Device* device = tensor_handle->device();\n    const bool is_tpu = device != nullptr && device->device_type() == \"TPU\";\n    // int32 return values can be placed on TPUs.\n    const bool use_host_memory =\n        is_tpu ? MTypeFromDTypeIntsOnDevice(tensor_handle->dtype)\n               : MTypeFromDType(tensor_handle->dtype);\n    if (use_host_memory) {\n      *result = cpu_device;\n    } else {\n      // Eager ops executing as functions should have their preferred inputs set\n      // to the op's device. This allows us to avoid expensive D2H copies if a\n      // mirror of the tensor already exists on the op's device.\n      if (!op.is_function() && device != nullptr && device != cpu_device) {\n        device = absl::get<Device*>(op.Device());\n      }\n      *result = (device == nullptr ? cpu_device : device);\n    }\n  }\n  return Status::OK();\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 125,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static GF_Err gf_isom_parse_movie_boxes_internal(GF_ISOFile *mov, u32 *boxType, u64 *bytesMissing, Bool progressive_mode)\n{\n\tGF_Box *a;\n\tu64 totSize, mdat_end=0;\n\tGF_Err e = GF_OK;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (mov->single_moof_mode && mov->single_moof_state == 2) {\n\t\treturn e;\n\t}\n\n\t/*restart from where we stopped last*/\n\ttotSize = mov->current_top_box_start;\n\tif (mov->bytes_removed) {\n\t\tassert(totSize >= mov->bytes_removed);\n\t\ttotSize -= mov->bytes_removed;\n\t}\n\tgf_bs_seek(mov->movieFileMap->bs, totSize);\n#endif\n\n\n\t/*while we have some data, parse our boxes*/\n\twhile (gf_bs_available(mov->movieFileMap->bs)) {\n\t\t*bytesMissing = 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tmov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Parsing a top-level box at position %d\\n\", mov->current_top_box_start));\n#endif\n\n\t\te = gf_isom_parse_root_box(&a, mov->movieFileMap->bs, boxType, bytesMissing, progressive_mode);\n\n\t\tif (e >= 0) {\n\t\t\t//safety check, should never happen\n\t\t\tif (!a) return GF_ISOM_INVALID_FILE;\n\t\t} else if (e == GF_ISOM_INCOMPLETE_FILE) {\n\t\t\t/*our mdat is uncomplete, only valid for READ ONLY files...*/\n\t\t\tif (mov->openMode != GF_ISOM_OPEN_READ) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete MDAT while file is not read-only\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tif ((mov->openMode == GF_ISOM_OPEN_READ) && !progressive_mode) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete file while reading for dump - aborting parsing\\n\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn e;\n\t\t} else {\n\t\t\treturn e;\n\t\t}\n\n\t\tswitch (a->type) {\n\t\t/*MOOV box*/\n\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\t\tif (mov->moov) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate MOOV detected!\\n\"));\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->moov = (GF_MovieBox *)a;\n\t\t\tmov->original_moov_offset = mov->current_top_box_start;\n\t\t\t/*set our pointer to the movie*/\n\t\t\tmov->moov->mov = mov;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (mov->moov->mvex) mov->moov->mvex->mov = mov;\n\n#ifdef GF_ENABLE_CTRN\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\tgf_isom_setup_traf_inheritance(mov);\n\t\t\t}\n#endif\n\n#endif\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\n\t\t\ttotSize += a->size;\n\n            if (!mov->moov->mvhd) {\n                GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MovieHeaderBox\\n\"));\n                return GF_ISOM_INVALID_FILE;\n            }\n\n            if (mov->meta) {\n\t\t\t\tgf_isom_meta_restore_items_ref(mov, mov->meta);\n\t\t\t}\n\n\t\t\t//dump senc info in dump mode\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moov->trackList); k++) {\n\t\t\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);\n\n\t\t\t\t\tif (trak->sample_encryption) {\n\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, trak, NULL, trak->sample_encryption);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moov->trackList); k++) {\n\t\t\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);\n\t\t\t\t\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\t\t\t\t\tconvert_compact_sample_groups(trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroups);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n            if (mdat_end && mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {\n                gf_isom_push_mdat_end(mov, mdat_end);\n                mdat_end=0;\n            }\n\t\t\tbreak;\n\n\t\t/*META box*/\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tif (mov->meta) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate META detected!\\n\"));\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->meta = (GF_MetaBox *)a;\n\t\t\tmov->original_meta_offset = mov->current_top_box_start;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) {\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\ttotSize += a->size;\n\t\t\tgf_isom_meta_restore_items_ref(mov, mov->meta);\n\t\t\tbreak;\n\n\t\t/*we only keep the MDAT in READ for dump purposes*/\n\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\tif (!mov->first_data_toplevel_offset) {\n\t\t\t\tmov->first_data_toplevel_offset = mov->current_top_box_start;\n\t\t\t\tmov->first_data_toplevel_size = a->size;\n\t\t\t}\n\t\t\ttotSize += a->size;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (mov->emsgs) {\n\t\t\t\tgf_isom_box_array_del(mov->emsgs);\n\t\t\t\tmov->emsgs = NULL;\n\t\t\t}\n#endif\n\n\t\t\tif (mov->openMode == GF_ISOM_OPEN_READ) {\n\t\t\t\tif (!mov->mdat) {\n\t\t\t\t\tmov->mdat = (GF_MediaDataBox *) a;\n\t\t\t\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\t\t\t\t}\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\telse if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) gf_list_add(mov->TopBoxes, a);\n#endif\n\t\t\t\telse gf_isom_box_del(a); //in other modes we don't care\n\n\n\t\t\t\tif (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {\n                    mdat_end = gf_bs_get_position(mov->movieFileMap->bs);\n                    if (mov->moov) {\n                        gf_isom_push_mdat_end(mov, mdat_end);\n                        mdat_end=0;\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*if we don't have any MDAT yet, create one (edit-write mode)\n\t\t\tWe only work with one mdat, but we're puting it at the place\n\t\t\tof the first mdat found when opening a file for editing*/\n\t\t\telse if (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n\t\t\t\tif (!mov->mdat) return GF_OUT_OF_MEM;\n\t\t\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\t\t\tif (e) {\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\t\t/*ONE AND ONLY ONE FTYP*/\n\t\t\tif (mov->brand) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'ftyp' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->brand = (GF_FileTypeBox *)a;\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_OTYP:\n\t\t\t/*ONE AND ONLY ONE FTYP*/\n\t\t\tif (mov->otyp) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'otyp' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tmov->otyp = (GF_Box *)a;\n\t\t\t\ttotSize += a->size;\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t} else {\n\t\t\t\tGF_FileTypeBox *brand = (GF_FileTypeBox *) gf_isom_box_find_child(a->child_boxes, GF_ISOM_BOX_TYPE_FTYP);\n\t\t\t\tif (brand) {\n\t\t\t\t\ts32 pos;\n\t\t\t\t\tgf_list_del_item(a->child_boxes, brand);\n\t\t\t\t\tpos = gf_list_del_item(mov->TopBoxes, mov->brand);\n\t\t\t\t\tgf_isom_box_del((GF_Box *) mov->brand);\n\t\t\t\t\tmov->brand = brand;\n\t\t\t\t\tif (pos<0) pos=0;\n\t\t\t\t\tgf_list_insert(mov->TopBoxes, brand, pos);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\t\t/*ONE AND ONLY ONE PDIN*/\n\t\t\tif (mov->pdin) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'pdin'' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->pdin = (GF_ProgressiveDownloadBox *) a;\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tcase GF_ISOM_BOX_TYPE_STYP:\n\t\t{\n\t\t\tu32 brand = ((GF_FileTypeBox *)a)->majorBrand;\n\t\t\tswitch (brand) {\n\t\t\tcase GF_ISOM_BRAND_SISX:\n\t\t\tcase GF_ISOM_BRAND_RISX:\n\t\t\tcase GF_ISOM_BRAND_SSSS:\n\t\t\t\tmov->is_index_segment = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*fall-through*/\n\n\t\tcase GF_ISOM_BOX_TYPE_SIDX:\n\t\tcase GF_ISOM_BOX_TYPE_SSIX:\n\t\t\tif (mov->moov && !mov->first_data_toplevel_offset) {\n\t\t\t\tmov->first_data_toplevel_offset = mov->current_top_box_start;\n\t\t\t\tmov->first_data_toplevel_size = a->size;\n\t\t\t}\n\t\t\ttotSize += a->size;\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t} else if (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)  && (mov->openMode!=GF_ISOM_OPEN_KEEP_FRAGMENTS)\n\t\t\t) {\n\t\t\t\tif (a->type==GF_ISOM_BOX_TYPE_SIDX) {\n\t\t\t\t\tif (mov->root_sidx) gf_isom_box_del( (GF_Box *) mov->root_sidx);\n\t\t\t\t\tmov->root_sidx = (GF_SegmentIndexBox *) a;\n\t\t\t\t\tmov->sidx_start_offset = mov->current_top_box_start;\n\t\t\t\t\tmov->sidx_end_offset = gf_bs_get_position(mov->movieFileMap->bs);\n\n\t\t\t\t}\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_STYP) {\n\t\t\t\t\tmov->styp_start_offset = mov->current_top_box_start;\n\n\t\t\t\t\tif (mov->seg_styp) gf_isom_box_del(mov->seg_styp);\n\t\t\t\t\tmov->seg_styp = a;\n\t\t\t\t} else if (a->type==GF_ISOM_BOX_TYPE_SSIX) {\n\t\t\t\t\tif (mov->seg_ssix) gf_isom_box_del(mov->seg_ssix);\n\t\t\t\t\tmov->seg_ssix = a;\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\t}\n\t\t\t\tgf_isom_push_mdat_end(mov, mov->current_top_box_start);\n\t\t\t} else if (!mov->NextMoofNumber && (a->type==GF_ISOM_BOX_TYPE_SIDX)) {\n\t\t\t\tif (mov->main_sidx) gf_isom_box_del( (GF_Box *) mov->main_sidx);\n\t\t\t\tmov->main_sidx = (GF_SegmentIndexBox *) a;\n\t\t\t\tmov->main_sidx_end_pos = mov->current_top_box_start + a->size;\n\t\t\t} else {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_MOOF:\n\t\t\t//no support for inplace rewrite for fragmented files\n\t\t\tgf_isom_disable_inplace_rewrite(mov);\n\t\t\tif (!mov->moov) {\n\t\t\t\tGF_LOG(mov->moof ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Movie fragment but no moov (yet) - possibly broken parsing!\\n\"));\n\t\t\t}\n\t\t\tif (mov->single_moof_mode) {\n\t\t\t\tmov->single_moof_state++;\n\t\t\t\tif (mov->single_moof_state > 1) {\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t\t((GF_MovieFragmentBox *)a)->mov = mov;\n\n\t\t\ttotSize += a->size;\n\t\t\tmov->moof = (GF_MovieFragmentBox *) a;\n\n\t\t\t/*some smooth streaming streams contain a SDTP under the TRAF: this is incorrect, convert it*/\n\t\t\tFixTrackID(mov);\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\tFixSDTPInTRAF(mov->moof);\n\t\t\t} else {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\tGF_TrackFragmentBox *traf = (GF_TrackFragmentBox *)gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\tif (traf->sampleGroups) {\n\t\t\t\t\t\tconvert_compact_sample_groups(traf->child_boxes, traf->sampleGroups);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*read & debug: store at root level*/\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tu32 k;\n\t\t\t\tgf_list_add(mov->TopBoxes, a);\n\t\t\t\t/*also update pointers to trex for debug*/\n\t\t\t\tif (mov->moov) {\n\t\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\t\tGF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\t\tif (traf->tfhd && mov->moov->mvex && mov->moov->mvex->TrackExList) {\n\t\t\t\t\t\t\tGF_TrackBox *trak = gf_isom_get_track_from_id(mov->moov, traf->tfhd->trackID);\n\t\t\t\t\t\t\tu32 j=0;\n\t\t\t\t\t\t\twhile ((traf->trex = (GF_TrackExtendsBox*)gf_list_enum(mov->moov->mvex->TrackExList, &j))) {\n\t\t\t\t\t\t\t\tif (traf->trex->trackID == traf->tfhd->trackID) {\n\t\t\t\t\t\t\t\t\tif (!traf->trex->track) traf->trex->track = trak;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttraf->trex = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//we should only parse senc/psec when no saiz/saio is present, otherwise we fetch the info directly\n\t\t\t\t\t\tif (traf->trex && traf->tfhd && traf->trex->track && traf->sample_encryption) {\n\t\t\t\t\t\t\tGF_TrackBox *trak = GetTrackbyID(mov->moov, traf->tfhd->trackID);\n\t\t\t\t\t\t\tif (trak) {\n\t\t\t\t\t\t\t\ttrak->current_traf_stsd_idx = traf->tfhd->sample_desc_index ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index;\n\t\t\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, trak, traf, traf->sample_encryption);\n\t\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t\t\ttrak->current_traf_stsd_idx = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\t\tGF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\t\tif (traf->sample_encryption) {\n\t\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, NULL, traf, traf->sample_encryption);\n\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t} else if (mov->openMode==GF_ISOM_OPEN_KEEP_FRAGMENTS) {\n\t\t\t\tmov->NextMoofNumber = mov->moof->mfhd->sequence_number+1;\n\t\t\t\tmov->moof = NULL;\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t} else {\n\t\t\t\t/*merge all info*/\n\t\t\t\te = MergeFragment((GF_MovieFragmentBox *)a, mov);\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\n\t\t\t//done with moov\n\t\t\tif (mov->root_sidx) {\n\t\t\t\tgf_isom_box_del((GF_Box *) mov->root_sidx);\n\t\t\t\tmov->root_sidx = NULL;\n\t\t\t}\n\t\t\tif (mov->root_ssix) {\n\t\t\t\tgf_isom_box_del(mov->seg_ssix);\n\t\t\t\tmov->root_ssix = NULL;\n\t\t\t}\n\t\t\tif (mov->seg_styp) {\n\t\t\t\tgf_isom_box_del(mov->seg_styp);\n\t\t\t\tmov->seg_styp = NULL;\n\t\t\t}\n\t\t\tmov->sidx_start_offset = 0;\n\t\t\tmov->sidx_end_offset = 0;\n\t\t\tmov->styp_start_offset = 0;\n\t\t\tbreak;\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t{\n\t\t\tGF_UnknownBox *box = (GF_UnknownBox*)a;\n\t\t\tif (box->original_4cc == GF_ISOM_BOX_TYPE_JP) {\n\t\t\t\tu8 *c = (u8 *) box->data;\n\t\t\t\tif ((box->dataSize==4) && (GF_4CC(c[0],c[1],c[2],c[3])==(u32)0x0D0A870A))\n\t\t\t\t\tmov->is_jp2 = 1;\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t} else {\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_PRFT:\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (!(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\t//keep the last one read\n\t\t\t\tif (mov->last_producer_ref_time)\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\telse\n\t\t\t\t\tmov->last_producer_ref_time = (GF_ProducerReferenceTimeBox *)a;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t//fallthrough\n\t\tcase GF_ISOM_BOX_TYPE_EMSG:\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\tif (!mov->emsgs) mov->emsgs = gf_list_new();\n\t\t\t\tgf_list_add(mov->emsgs, a);\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_MFRA:\n\t\tcase GF_ISOM_BOX_TYPE_MFRO:\n\t\t\t//only keep for dump mode, otherwise we ignore these boxes and we don't want to carry them over in non-fragmented file\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\ttotSize += a->size;\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t}\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t/*remember where we left, in case we append an entire number of movie fragments*/\n\t\tmov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;\n#endif\n\t}\n\n\t/*we need at least moov or meta*/\n\tif (!mov->moov && !mov->meta\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t        && !mov->moof && !mov->is_index_segment\n#endif\n\t   ) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\t/*we MUST have movie header*/\n\tif (!gf_opts_get_bool(\"core\", \"no-check\")) {\n\t\tif (mov->moov && !mov->moov->mvhd) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MVHD in MOOV!\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\t/*we MUST have meta handler*/\n\t\tif (mov->meta && !mov->meta->handler) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing handler in META!\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\tif (mov->moov) {\n\t\t/*set the default interleaving time*/\n\t\tmov->interleavingTime = mov->moov->mvhd->timeScale;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t/*in edit mode with successfully loaded fragments, delete all fragment signaling since\n\t\tfile is no longer fragmented*/\n\t\tif ((mov->openMode > GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS) && mov->moov->mvex) {\n\t\t\tgf_isom_box_del_parent(&mov->moov->child_boxes, (GF_Box *)mov->moov->mvex);\n\t\t\tmov->moov->mvex = NULL;\n\t\t}\n#endif\n\n\t}\n\n\t//create a default mdat if none was found\n\tif (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {\n\t\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n\t\tif (!mov->mdat) return GF_OUT_OF_MEM;\n\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\tif (e) return e;\n\t}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\treturn GF_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override {\n    // Create a new SparseTensorSliceDatasetOp::Dataset, insert it in\n    // the step container, and return it as the output.\n    const Tensor* indices;\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices));\n    const Tensor* values;\n    OP_REQUIRES_OK(ctx, ctx->input(\"values\", &values));\n    const Tensor* dense_shape;\n    OP_REQUIRES_OK(ctx, ctx->input(\"dense_shape\", &dense_shape));\n\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    indices->shape().DebugString()));\n\n    const auto num_indices = indices->NumElements();\n    const auto num_values = values->NumElements();\n    if (num_indices == 0 || num_values == 0) {\n      OP_REQUIRES(ctx, num_indices == num_values,\n                  errors::InvalidArgument(\n                      \"If indices or values are empty, the other one must also \"\n                      \"be. Got indices of shape \",\n                      indices->shape().DebugString(), \" and values of shape \",\n                      values->shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    indices->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    dense_shape->shape().DebugString()));\n\n    // We currently ensure that `sparse_tensor` is ordered in the\n    // batch dimension.\n    // TODO(mrry): Investigate ways to avoid this unconditional check\n    // if we can be sure that the sparse tensor was produced in an\n    // appropriate order (e.g. by `tf.parse_example()` or a Dataset\n    // that batches elements into rows of a SparseTensor).\n    int64_t previous_batch_index = -1;\n    for (int64_t i = 0; i < indices->dim_size(0); ++i) {\n      int64_t next_batch_index = indices->matrix<int64>()(i, 0);\n      OP_REQUIRES(\n          ctx, next_batch_index >= previous_batch_index,\n          errors::Unimplemented(\"The SparseTensor must be ordered in the batch \"\n                                \"dimension; handling arbitrarily ordered input \"\n                                \"is not currently supported.\"));\n      previous_batch_index = next_batch_index;\n    }\n    gtl::InlinedVector<int64, 8> std_order(dense_shape->NumElements(), 0);\n    sparse::SparseTensor tensor;\n    OP_REQUIRES_OK(\n        ctx, sparse::SparseTensor::Create(\n                 *indices, *values, TensorShape(dense_shape->vec<int64>()),\n                 std_order, &tensor));\n    *output = new Dataset<T>(ctx, std::move(tensor));\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " */\nstatic void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t*pce;\n\tzval\t\t\t\tobj;\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp((char *)name, EL_STRING) || !strcmp((char *)name, EL_NUMBER) ||\n\t\t!strcmp((char *)name, EL_BOOLEAN) || !strcmp((char *)name, EL_NULL) ||\n\t  \t!strcmp((char *)name, EL_ARRAY) || !strcmp((char *)name, EL_STRUCT) ||\n\t\t!strcmp((char *)name, EL_RECORDSET) || !strcmp((char *)name, EL_BINARY) ||\n\t\t!strcmp((char *)name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (Z_TYPE(ent1->data) == IS_UNDEF) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t\tefree(ent1);\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp((char *)name, EL_BINARY)) {\n\t\t\tzend_string *new_str = php_base64_decode(\n\t\t\t\t(unsigned char *)Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\tZVAL_STR(&ent1->data, new_str);\n\t\t}\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE(ent1->data) == IS_OBJECT) {\n\t\t\tzval fname, retval;\n\n\t\t\tZVAL_STRING(&fname, \"__wakeup\");\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, &fname, &retval, 0, 0, 0, NULL);\n\n\t\t\tzval_ptr_dtor(&fname);\n\t\t\tzval_ptr_dtor(&retval);\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (ent2->type == ST_FIELD && Z_ISUNDEF(ent2->data)) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE(ent2->data) == IS_ARRAY || Z_TYPE(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(&ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE(ent1->data) == IS_STRING && Z_STRLEN(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\t\t\t\tzend_string_forget_hash_val(Z_STR(ent1->data));\n\t\t\t\t\t\tif ((pce = zend_hash_find_ptr(EG(class_table), Z_STR(ent1->data))) == NULL) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\tobject_init_ex(&obj, pce);\n\n\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP(obj),\n\t\t\t\t\t\t\t\t\t\tZ_ARRVAL(ent2->data),\n\t\t\t\t\t\t\t\t\t\tzval_add_ref, 0);\n\n\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\tphp_store_class_name(&obj, Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\tZVAL_COPY_VALUE(&ent2->data, &obj);\n\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE(ent2->data);\n\t\t\t\t\t\tadd_property_zval(&ent2->data, ent1->varname, &ent1->data);\n\t\t\t\t\t\tif Z_REFCOUNTED(ent1->data) Z_DELREF(ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_str_update(target_hash, ent1->varname, strlen(ent1->varname), &ent1->data);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp((char *)name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp((char *)name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 149,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& val = ctx->input(0);\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"GetSessionHandle called on null session state\"));\n    int64 id = session_state->GetNewId();\n    TensorStore::TensorAndKey tk{val, id, requested_device()};\n    OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));\n\n    Tensor* handle = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));\n    if (ctx->expected_output_dtype(0) == DT_RESOURCE) {\n      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(\n          ctx, SessionState::kTensorHandleResourceTypeName,\n          tk.GetHandle(name()));\n      resource_handle.set_maybe_type_name(\n          SessionState::kTensorHandleResourceTypeName);\n      handle->scalar<ResourceHandle>()() = resource_handle;\n    } else {\n      // Legacy behavior in V1.\n      handle->flat<tstring>().setConstant(tk.GetHandle(name()));\n    }\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 189,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "GF_Err SetupWriters(MovieWriter *mw, GF_List *writers, u8 interleaving)\n{\n\tu32 i, trackCount;\n\tTrackWriter *writer;\n\tGF_TrackBox *trak;\n\tGF_ISOFile *movie = mw->movie;\n\n\tmw->total_samples = mw->nb_done = 0;\n\tif (!movie->moov) return GF_OK;\n\n\ttrackCount = gf_list_count(movie->moov->trackList);\n\tfor (i = 0; i < trackCount; i++) {\n\t\tGF_SampleTableBox *stbl;\n\t\ttrak = gf_isom_get_track(movie->moov, i+1);\n\n\t\tstbl = (trak->Media && trak->Media->information) ? trak->Media->information->sampleTable : NULL;\n\t\tif (!stbl || !stbl->SampleSize || !stbl->ChunkOffset || !stbl->SampleToChunk) {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\tGF_SAFEALLOC(writer, TrackWriter);\n\t\tif (!writer) goto exit;\n\t\twriter->sampleNumber = 1;\n\t\twriter->mdia = trak->Media;\n\t\twriter->stbl = trak->Media->information->sampleTable;\n\t\twriter->timeScale = trak->Media->mediaHeader->timeScale;\n\t\twriter->all_dref_mode = Media_SelfContainedType(writer->mdia);\n\n\t\tif (trak->sample_encryption)\n\t\t\twriter->prevent_dispatch = GF_TRUE;\n\n\t\twriter->isDone = 0;\n\t\twriter->DTSprev = 0;\n\t\twriter->chunkDur = 0;\n\t\twriter->chunkSize = 0;\n\t\twriter->constant_size = writer->constant_dur = 0;\n\t\tif (writer->stbl->SampleSize->sampleSize)\n\t\t\twriter->constant_size = writer->stbl->SampleSize->sampleSize;\n\t\tif (writer->stbl->TimeToSample->nb_entries==1) {\n\t\t\twriter->constant_dur = writer->stbl->TimeToSample->entries[0].sampleDelta;\n\t\t\tif (writer->constant_dur>1) writer->constant_dur = 0;\n\t\t}\n\t\tif (!writer->constant_dur || !writer->constant_size || (writer->constant_size>=10))\n\t\t\twriter->constant_size = writer->constant_dur = 0;\n\n\t\twriter->stsc = (GF_SampleToChunkBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STSC);\n\t\tif (!writer->stsc) return GF_OUT_OF_MEM;\n\t\tif (writer->stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\t\twriter->stco = gf_isom_box_new(GF_ISOM_BOX_TYPE_STCO);\n\t\t} else {\n\t\t\twriter->stco = gf_isom_box_new(GF_ISOM_BOX_TYPE_CO64);\n\t\t}\n\t\tif (!writer->stco) return GF_OUT_OF_MEM;\n\t\t/*stops from chunk escape*/\n\t\tif (interleaving) writer->stbl->MaxSamplePerChunk = 0;\n\t\t/*for progress, assume only one descIndex*/\n\t\tif (Media_IsSelfContained(writer->mdia, 1))\n\t\t\tmw->total_samples += writer->stbl->SampleSize->sampleCount;\n\t\t/*optimization for interleaving: put audio last (this can be overridden by priorities)*/\n\t\tif (movie->storageMode != GF_ISOM_STORE_INTERLEAVED) {\n\t\t\tgf_list_add(writers, writer);\n\t\t} else {\n\t\t\tif (writer->mdia->information->InfoHeader && writer->mdia->information->InfoHeader->type == GF_ISOM_BOX_TYPE_SMHD) {\n\t\t\t\tgf_list_add(writers, writer);\n\t\t\t} else {\n\t\t\t\tgf_list_insert(writers, writer, 0);\n\t\t\t}\n\t\t}\n\t\tif (movie->sample_groups_in_traf && trak->Media->information->sampleTable) {\n\t\t\tgf_isom_box_array_del_parent(&trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroupsDescription);\n\t\t\ttrak->Media->information->sampleTable->sampleGroupsDescription = NULL;\n\t\t}\n\t}\n\treturn GF_OK;\n\nexit:\n\tCleanWriters(writers);\n\treturn GF_OUT_OF_MEM;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 207,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n    const Tensor& input_min_range = ctx->input(1);\n    const Tensor& input_max_range = ctx->input(2);\n\n    int num_slices = 1;\n    if (axis_ > -1) {\n      OP_REQUIRES(\n          ctx, input.dims() > axis_,\n          errors::InvalidArgument(\n              \"Axis is on a zero-based index, so its value must always be less \"\n              \"than number of input's dims, but given axis value was \",\n              axis_, \" and input's dims was \", input.dims()));\n      num_slices = input.dim_size(axis_);\n      OP_REQUIRES(ctx, input_min_range.dims() == 1,\n                  errors::InvalidArgument(\n                      \"If axis is specified, min_range must be a 1-D tensor \"\n                      \"whose size matches the axis dimension of the input and \"\n                      \"output tensors, but min_range dims are \",\n                      input_min_range.dims()));\n      OP_REQUIRES(ctx, input_min_range.dim_size(0) == num_slices,\n                  errors::InvalidArgument(\n                      \"If axis is specified, min_range must be a 1-D tensor \"\n                      \"whose size matches the axis dimension of the input and \"\n                      \"output tensors, but min_range is a 1-D tensor of size \",\n                      input_min_range.dim_size(0),\n                      \" and input's axis dimension is of size \", num_slices));\n      OP_REQUIRES(ctx, input_max_range.dims() == 1,\n                  errors::InvalidArgument(\n                      \"If axis is specified, max_range must be a 1-D tensor \"\n                      \"whose size matches the axis dimension of the input and \"\n                      \"output tensors, but max_range dims are \",\n                      input_max_range.dims()));\n      OP_REQUIRES(ctx, input_max_range.dim_size(0) == num_slices,\n                  errors::InvalidArgument(\n                      \"If axis is specified, max_range must be a 1-D tensor \"\n                      \"whose size matches the axis dimension of the input and \"\n                      \"output tensors, but max_range is a 1-D tensor of size \",\n                      input_max_range.dim_size(0),\n                      \" and input's axis dimension is of size \", num_slices));\n    } else {\n      OP_REQUIRES(ctx, input_min_range.NumElements() == 1,\n                  errors::InvalidArgument(\n                      \"If axis is not specified, min_range must contain a \"\n                      \"single float element, but it contains \",\n                      input_min_range.NumElements(), \" elements\"));\n      OP_REQUIRES(ctx, input_max_range.NumElements() == 1,\n                  errors::InvalidArgument(\n                      \"If axis is not specified, max_range must contain a \"\n                      \"single float element, but it contains \",\n                      input_max_range.NumElements(), \" elements\"));\n    }\n\n    const TensorShape& minmax_shape = ctx->input(1).shape();\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));\n\n    Tensor* output_min_tensor = nullptr;\n    Tensor* output_max_tensor = nullptr;\n\n    if (num_slices == 1) {\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(1, {}, &output_min_tensor));\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(2, {}, &output_max_tensor));\n      const float min_range = input_min_range.template flat<float>()(0);\n      const float max_range = input_max_range.template flat<float>()(0);\n      QuantizeTensor(ctx, input, min_range, max_range, output,\n                     output_min_tensor, output_max_tensor);\n      return;\n    }\n\n    OP_REQUIRES(ctx, mode_ != QUANTIZE_MODE_MIN_FIRST,\n                errors::Unimplemented(\"MIN_FIRST mode is not implemented for \"\n                                      \"Quantize with axis != -1.\"));\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(1, minmax_shape, &output_min_tensor));\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(2, minmax_shape, &output_max_tensor));\n\n    auto input_tensor =\n        input.template flat_inner_outer_dims<float, 3>(axis_ - 1);\n    int64_t pre_dim = 1, post_dim = 1;\n    for (int i = 0; i < axis_; ++i) {\n      pre_dim *= output->dim_size(i);\n    }\n    for (int i = axis_ + 1; i < output->dims(); ++i) {\n      post_dim *= output->dim_size(i);\n    }\n    auto output_tensor = output->template bit_casted_shaped<T, 3>(\n        {pre_dim, num_slices, post_dim});\n    auto min_ranges = input_min_range.template vec<float>();\n    auto max_ranges = input_max_range.template vec<float>();\n    for (int i = 0; i < num_slices; ++i) {\n      QuantizeSlice(ctx->eigen_device<Device>(), ctx,\n                    input_tensor.template chip<1>(i), min_ranges(i),\n                    max_ranges(i), output_tensor.template chip<1>(i),\n                    &output_min_tensor->flat<float>()(i),\n                    &output_max_tensor->flat<float>()(i));\n    }\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 219,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void RestoreTensor(OpKernelContext* context,\n                   checkpoint::TensorSliceReader::OpenTableFunction open_func,\n                   int preferred_shard, bool restore_slice, int restore_index) {\n  const Tensor& file_pattern_t = context->input(0);\n  {\n    const int64_t size = file_pattern_t.NumElements();\n    OP_REQUIRES(\n        context, size == 1,\n        errors::InvalidArgument(\n            \"Input 0 (file_pattern) must be a string scalar; got a tensor of \",\n            size, \" elements\"));\n  }\n  const string& file_pattern = file_pattern_t.flat<tstring>()(0);\n\n  const Tensor& tensor_name_t = context->input(1);\n  {\n    const int64_t size = tensor_name_t.NumElements();\n    OP_REQUIRES(context, size > restore_index,\n                errors::InvalidArgument(\n                    \"Input 1 (file_pattern) must be a have at least \",\n                    restore_index + 1, \" elements\"));\n  }\n  const string& tensor_name = tensor_name_t.flat<tstring>()(restore_index);\n\n  // If we cannot find a cached reader we will allocate our own.\n  std::unique_ptr<checkpoint::TensorSliceReader> allocated_reader;\n\n  const checkpoint::TensorSliceReader* reader = nullptr;\n\n  if (context->slice_reader_cache()) {\n    reader = context->slice_reader_cache()->GetReader(file_pattern, open_func,\n                                                      preferred_shard);\n  }\n  if (!reader) {\n    allocated_reader.reset(new checkpoint::TensorSliceReader(\n        file_pattern, open_func, preferred_shard));\n    reader = allocated_reader.get();\n  }\n  OP_REQUIRES_OK(context, CHECK_NOTNULL(reader)->status());\n\n  // Get the shape and type from the save file.\n  DataType type;\n  TensorShape saved_shape;\n  OP_REQUIRES(\n      context, reader->HasTensor(tensor_name, &saved_shape, &type),\n      errors::NotFound(\"Tensor name \\\"\", tensor_name,\n                       \"\\\" not found in checkpoint files \", file_pattern));\n  OP_REQUIRES(\n      context, type == context->expected_output_dtype(restore_index),\n      errors::InvalidArgument(\"Expected to restore a tensor of type \",\n                              DataTypeString(context->expected_output_dtype(0)),\n                              \", got a tensor of type \", DataTypeString(type),\n                              \" instead: tensor_name = \", tensor_name));\n\n  // Shape of the output and slice to load.\n  TensorShape output_shape(saved_shape);\n  TensorSlice slice_to_load(saved_shape.dims());\n  if (restore_slice) {\n    const tstring& shape_spec =\n        context->input(2).flat<tstring>()(restore_index);\n    if (!shape_spec.empty()) {\n      TensorShape parsed_shape;\n      OP_REQUIRES_OK(context, checkpoint::ParseShapeAndSlice(\n                                  shape_spec, &parsed_shape, &slice_to_load,\n                                  &output_shape));\n      OP_REQUIRES(\n          context, parsed_shape.IsSameSize(saved_shape),\n          errors::InvalidArgument(\n              \"Shape in shape_and_slice spec does not match the shape in the \"\n              \"save file: \",\n              parsed_shape.DebugString(),\n              \", save file shape: \", saved_shape.DebugString()));\n    }\n  }\n\n  Tensor* t = nullptr;\n  OP_REQUIRES_OK(context,\n                 context->allocate_output(restore_index, output_shape, &t));\n\n  if (output_shape.num_elements() == 0) return;\n\n#define READER_COPY(T)                                                \\\n  case DataTypeToEnum<T>::value:                                      \\\n    OP_REQUIRES(context,                                              \\\n                reader->CopySliceData(tensor_name, slice_to_load,     \\\n                                      t->flat<T>().data()),           \\\n                errors::InvalidArgument(\"Error copying slice data\")); \\\n    break;\n\n  switch (type) {\n    TF_CALL_SAVE_RESTORE_TYPES(READER_COPY)\n    default:\n      context->SetStatus(errors::Unimplemented(\n          \"Restoring data type \", DataTypeString(type), \" not yet supported\"));\n  }\n#undef READER_COPY\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 243,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "  void Compute(OpKernelContext* context) override {\n    // Here's the basic idea:\n    // Batch and depth dimension are independent from row and col dimension. And\n    // because FractionalAvgPool currently only support pooling along row and\n    // col, we can basically think of this 4D tensor backpropagation as\n    // operation of a series of 2D planes.\n    //\n    // For each element of a 'slice' (2D plane) of output_backprop, we need to\n    // figure out its contributors when doing FractionalAvgPool operation. This\n    // can be done based on row_pooling_sequence, col_pooling_seq and\n    // overlapping.\n    // Once we figure out the original contributors, we just need to evenly\n    // divide the value of this element among these contributors.\n    //\n    // Internally, we divide the out_backprop tensor and store it in a temporary\n    // tensor of double type. And cast it to the corresponding type.\n    typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n        ConstEigenMatrixMap;\n    typedef Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>\n        EigenDoubleMatrixMap;\n\n    // Grab the inputs.\n    const Tensor& orig_input_tensor_shape = context->input(0);\n    OP_REQUIRES(context,\n                orig_input_tensor_shape.dims() == 1 &&\n                    orig_input_tensor_shape.NumElements() == 4,\n                errors::InvalidArgument(\"original input tensor shape must be\"\n                                        \"1-dimensional and 4 elements\"));\n    const Tensor& out_backprop = context->input(1);\n    const Tensor& row_seq_tensor = context->input(2);\n    const Tensor& col_seq_tensor = context->input(3);\n\n    const int64_t out_batch = out_backprop.dim_size(0);\n    const int64_t out_rows = out_backprop.dim_size(1);\n    const int64_t out_cols = out_backprop.dim_size(2);\n    const int64_t out_depth = out_backprop.dim_size(3);\n\n    OP_REQUIRES(context, row_seq_tensor.NumElements() > out_rows,\n                errors::InvalidArgument(\"Given out_backprop shape \",\n                                        out_backprop.shape().DebugString(),\n                                        \", row_seq_tensor must have at least \",\n                                        out_rows + 1, \" elements, but got \",\n                                        row_seq_tensor.NumElements()));\n    OP_REQUIRES(context, col_seq_tensor.NumElements() > out_cols,\n                errors::InvalidArgument(\"Given out_backprop shape \",\n                                        out_backprop.shape().DebugString(),\n                                        \", col_seq_tensor must have at least \",\n                                        out_cols + 1, \" elements, but got \",\n                                        col_seq_tensor.NumElements()));\n\n    auto row_seq_tensor_flat = row_seq_tensor.flat<int64>();\n    auto col_seq_tensor_flat = col_seq_tensor.flat<int64>();\n    auto orig_input_tensor_shape_flat = orig_input_tensor_shape.flat<int64>();\n\n    const int64_t in_batch = orig_input_tensor_shape_flat(0);\n    const int64_t in_rows = orig_input_tensor_shape_flat(1);\n    const int64_t in_cols = orig_input_tensor_shape_flat(2);\n    const int64_t in_depth = orig_input_tensor_shape_flat(3);\n    OP_REQUIRES(\n        context, in_batch != 0,\n        errors::InvalidArgument(\"Batch dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_rows != 0,\n        errors::InvalidArgument(\"Rows dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_cols != 0,\n        errors::InvalidArgument(\"Columns dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_depth != 0,\n        errors::InvalidArgument(\"Depth dimension of input must not be 0\"));\n\n    constexpr int tensor_in_and_out_dims = 4;\n    // Transform orig_input_tensor_shape into TensorShape\n    TensorShape in_shape;\n    for (auto i = 0; i < tensor_in_and_out_dims; ++i) {\n      in_shape.AddDim(orig_input_tensor_shape_flat(i));\n    }\n\n    // Create intermediate in_backprop.\n    Tensor in_backprop_tensor_temp;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_temp(\n                                {0}, DataTypeToEnum<double>::v(), in_shape,\n                                &in_backprop_tensor_temp));\n    in_backprop_tensor_temp.flat<double>().setZero();\n    // Transform 4D tensor to 2D matrix.\n    EigenDoubleMatrixMap in_backprop_tensor_temp_mat(\n        in_backprop_tensor_temp.flat<double>().data(), in_depth,\n        in_cols * in_rows * in_batch);\n    ConstEigenMatrixMap out_backprop_mat(out_backprop.flat<T>().data(),\n                                         out_depth,\n                                         out_cols * out_rows * out_batch);\n    // Loop through each element of out_backprop and evenly distribute the\n    // element to the corresponding pooling cell.\n    const int64_t in_max_row_index = in_rows - 1;\n    const int64_t in_max_col_index = in_cols - 1;\n    for (int64_t b = 0; b < out_batch; ++b) {\n      for (int64_t r = 0; r < out_rows; ++r) {\n        const int64_t in_row_start = row_seq_tensor_flat(r);\n        int64_t in_row_end = overlapping_ ? row_seq_tensor_flat(r + 1)\n                                          : row_seq_tensor_flat(r + 1) - 1;\n        in_row_end = std::min(in_row_end, in_max_row_index);\n        for (int64_t c = 0; c < out_cols; ++c) {\n          const int64_t in_col_start = col_seq_tensor_flat(c);\n          int64_t in_col_end = overlapping_ ? col_seq_tensor_flat(c + 1)\n                                            : col_seq_tensor_flat(c + 1) - 1;\n          in_col_end = std::min(in_col_end, in_max_col_index);\n\n          const int64_t num_elements_in_pooling_cell =\n              (in_row_end - in_row_start + 1) * (in_col_end - in_col_start + 1);\n          const int64_t out_index = (b * out_rows + r) * out_cols + c;\n          // Now we can evenly distribute out_backprop(b, h, w, *) to\n          // in_backprop(b, hs:he, ws:we, *).\n          for (int64_t in_r = in_row_start; in_r <= in_row_end; ++in_r) {\n            for (int64_t in_c = in_col_start; in_c <= in_col_end; ++in_c) {\n              const int64_t in_index = (b * in_rows + in_r) * in_cols + in_c;\n              // Walk through each channel (depth).\n              for (int64_t d = 0; d < out_depth; ++d) {\n                const double out_backprop_element = static_cast<double>(\n                    out_backprop_mat.coeffRef(d, out_index));\n                double& in_backprop_ref =\n                    in_backprop_tensor_temp_mat.coeffRef(d, in_index);\n                in_backprop_ref +=\n                    out_backprop_element / num_elements_in_pooling_cell;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Depending on the type, cast double to type T.\n    Tensor* in_backprop_tensor = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, in_shape, &in_backprop_tensor));\n    auto in_backprop_tensor_flat = in_backprop_tensor->flat<T>();\n    auto in_backprop_tensor_temp_flat = in_backprop_tensor_temp.flat<double>();\n    for (int64_t i = 0; i < in_backprop_tensor_flat.size(); ++i) {\n      in_backprop_tensor_flat(i) =\n          static_cast<T>(in_backprop_tensor_temp_flat(i));\n    }\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 284,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "gif_internal_decode_frame(gif_animation *gif,\n                          unsigned int frame,\n                          bool clear_image)\n{\n        unsigned int index = 0;\n        const unsigned char *gif_data, *gif_end;\n        ssize_t gif_bytes;\n        unsigned int width, height, offset_x, offset_y;\n        unsigned int flags, colour_table_size, interlace;\n        unsigned int *colour_table;\n        unsigned int *frame_data = 0;\t// Set to 0 for no warnings\n        unsigned int *frame_scanline;\n        ssize_t save_buffer_position;\n        unsigned int return_value = 0;\n        unsigned int x, y, decode_y, burst_bytes;\n        register unsigned char colour;\n\n        /* If the GIF has no frame data, frame holders will not be allocated in\n         * gif_initialise() */\n        if (gif->frames == NULL) {\n                return GIF_INSUFFICIENT_DATA;\n        }\n\n        /* Ensure this frame is supposed to be decoded */\n        if (gif->frames[frame].display == false) {\n                return GIF_OK;\n        }\n\n        /* Ensure the frame is in range to decode */\n        if (frame > gif->frame_count_partial) {\n                return GIF_INSUFFICIENT_DATA;\n        }\n\n        /* done if frame is already decoded */\n        if ((!clear_image) &&\n            ((int)frame == gif->decoded_frame)) {\n                return GIF_OK;\n        }\n\n        /* Get the start of our frame data and the end of the GIF data */\n        gif_data = gif->gif_data + gif->frames[frame].frame_pointer;\n        gif_end = gif->gif_data + gif->buffer_size;\n        gif_bytes = (gif_end - gif_data);\n\n        /*\n         * Ensure there is a minimal amount of data to proceed.  The shortest\n         * block of data is a 10-byte image descriptor + 1-byte gif trailer\n         */\n        if (gif_bytes < 12) {\n                return GIF_INSUFFICIENT_FRAME_DATA;\n        }\n\n        /* Save the buffer position */\n        save_buffer_position = gif->buffer_position;\n        gif->buffer_position = gif_data - gif->gif_data;\n\n        /* Skip any extensions because they have allready been processed */\n        if ((return_value = gif_skip_frame_extensions(gif)) != GIF_OK) {\n                goto gif_decode_frame_exit;\n        }\n        gif_data = (gif->gif_data + gif->buffer_position);\n        gif_bytes = (gif_end - gif_data);\n\n        /* Ensure we have enough data for the 10-byte image descriptor + 1-byte\n         * gif trailer\n         */\n        if (gif_bytes < 12) {\n                return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                goto gif_decode_frame_exit;\n        }\n\n        /* 10-byte Image Descriptor is:\n         *\n         *\t+0\tCHAR\tImage Separator (0x2c)\n         *\t+1\tSHORT\tImage Left Position\n         *\t+3\tSHORT\tImage Top Position\n         *\t+5\tSHORT\tWidth\n         *\t+7\tSHORT\tHeight\n         *\t+9\tCHAR\t__Packed Fields__\n         *\t\t\t1BIT\tLocal Colour Table Flag\n         *\t\t\t1BIT\tInterlace Flag\n         *\t\t\t1BIT\tSort Flag\n         *\t\t\t2BITS\tReserved\n         *\t\t\t3BITS\tSize of Local Colour Table\n         */\n        if (gif_data[0] != GIF_IMAGE_SEPARATOR) {\n                return_value = GIF_DATA_ERROR;\n                goto gif_decode_frame_exit;\n        }\n        offset_x = gif_data[1] | (gif_data[2] << 8);\n        offset_y = gif_data[3] | (gif_data[4] << 8);\n        width = gif_data[5] | (gif_data[6] << 8);\n        height = gif_data[7] | (gif_data[8] << 8);\n\n        /* Boundary checking - shouldn't ever happen except unless the data has\n         * been modified since initialisation.\n         */\n        if ((offset_x + width > gif->width) ||\n            (offset_y + height > gif->height)) {\n                return_value = GIF_DATA_ERROR;\n                goto gif_decode_frame_exit;\n        }\n\n        /* Decode the flags */\n        flags = gif_data[9];\n        colour_table_size = 2 << (flags & GIF_COLOUR_TABLE_SIZE_MASK);\n        interlace = flags & GIF_INTERLACE_MASK;\n\n        /* Advance data pointer to next block either colour table or image\n         * data.\n         */\n        gif_data += 10;\n        gif_bytes = (gif_end - gif_data);\n\n        /* Set up the colour table */\n        if (flags & GIF_COLOUR_TABLE_MASK) {\n                if (gif_bytes < (int)(3 * colour_table_size)) {\n                        return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                        goto gif_decode_frame_exit;\n                }\n                colour_table = gif->local_colour_table;\n                if (!clear_image) {\n                        for (index = 0; index < colour_table_size; index++) {\n                                /* Gif colour map contents are r,g,b.\n                                 *\n                                 * We want to pack them bytewise into the\n                                 * colour table, such that the red component\n                                 * is in byte 0 and the alpha component is in\n                                 * byte 3.\n                                 */\n                                unsigned char *entry =\n                                        (unsigned char *) &colour_table[index];\n\n                                entry[0] = gif_data[0];\t/* r */\n                                entry[1] = gif_data[1];\t/* g */\n                                entry[2] = gif_data[2];\t/* b */\n                                entry[3] = 0xff;\t/* a */\n\n                                gif_data += 3;\n                        }\n                } else {\n                        gif_data += 3 * colour_table_size;\n                }\n                gif_bytes = (gif_end - gif_data);\n        } else {\n                colour_table = gif->global_colour_table;\n        }\n\n        /* Ensure sufficient data remains */\n        if (gif_bytes < 1) {\n                return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                goto gif_decode_frame_exit;\n        }\n\n        /* check for an end marker */\n        if (gif_data[0] == GIF_TRAILER) {\n                return_value = GIF_OK;\n                goto gif_decode_frame_exit;\n        }\n\n        /* Get the frame data */\n        assert(gif->bitmap_callbacks.bitmap_get_buffer);\n        frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);\n        if (!frame_data) {\n                return GIF_INSUFFICIENT_MEMORY;\n        }\n\n        /* If we are clearing the image we just clear, if not decode */\n        if (!clear_image) {\n                lzw_result res;\n                const uint8_t *stack_base;\n                const uint8_t *stack_pos;\n\n                /* Ensure we have enough data for a 1-byte LZW code size +\n                 * 1-byte gif trailer\n                 */\n                if (gif_bytes < 2) {\n                        return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                        goto gif_decode_frame_exit;\n                }\n\n                /* If we only have a 1-byte LZW code size + 1-byte gif trailer,\n                 * we're finished\n                 */\n                if ((gif_bytes == 2) && (gif_data[1] == GIF_TRAILER)) {\n                        return_value = GIF_OK;\n                        goto gif_decode_frame_exit;\n                }\n\n                /* If the previous frame's disposal method requires we restore\n                 * the background colour or this is the first frame, clear\n                 * the frame data\n                 */\n                if ((frame == 0) || (gif->decoded_frame == GIF_INVALID_FRAME)) {\n                        memset((char*)frame_data,\n                               GIF_TRANSPARENT_COLOUR,\n                               gif->width * gif->height * sizeof(int));\n                        gif->decoded_frame = frame;\n                        /* The line below would fill the image with its\n                         * background color, but because GIFs support\n                         * transparency we likely wouldn't want to do that. */\n                        /* memset((char*)frame_data, colour_table[gif->background_index], gif->width * gif->height * sizeof(int)); */\n                } else if ((frame != 0) &&\n                           (gif->frames[frame - 1].disposal_method == GIF_FRAME_CLEAR)) {\n                        return_value = gif_internal_decode_frame(gif,\n                                                                 (frame - 1),\n                                                                 true);\n                        if (return_value != GIF_OK) {\n                                goto gif_decode_frame_exit;\n                        }\n\n                } else if ((frame != 0) &&\n                           (gif->frames[frame - 1].disposal_method == GIF_FRAME_RESTORE)) {\n                        /*\n                         * If the previous frame's disposal method requires we\n                         * restore the previous image, find the last image set\n                         * to \"do not dispose\" and get that frame data\n                         */\n                        int last_undisposed_frame = frame - 2;\n                        while ((last_undisposed_frame >= 0) &&\n                               (gif->frames[last_undisposed_frame].disposal_method == GIF_FRAME_RESTORE)) {\n                                last_undisposed_frame--;\n                        }\n\n                        /* If we don't find one, clear the frame data */\n                        if (last_undisposed_frame == -1) {\n                                /* see notes above on transparency\n                                 * vs. background color\n                                 */\n                                memset((char*)frame_data,\n                                       GIF_TRANSPARENT_COLOUR,\n                                       gif->width * gif->height * sizeof(int));\n                        } else {\n                                return_value = gif_internal_decode_frame(gif, last_undisposed_frame, false);\n                                if (return_value != GIF_OK) {\n                                        goto gif_decode_frame_exit;\n                                }\n                                /* Get this frame's data */\n                                assert(gif->bitmap_callbacks.bitmap_get_buffer);\n                                frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);\n                                if (!frame_data) {\n                                        return GIF_INSUFFICIENT_MEMORY;\n                                }\n                        }\n                }\n                gif->decoded_frame = frame;\n                gif->buffer_position = (gif_data - gif->gif_data) + 1;\n\n                /* Initialise the LZW decoding */\n                res = lzw_decode_init(gif->lzw_ctx, gif->gif_data,\n                                gif->buffer_size, gif->buffer_position,\n                                gif_data[0], &stack_base, &stack_pos);\n                if (res != LZW_OK) {\n                        return gif_error_from_lzw(res);\n                }\n\n                /* Decompress the data */\n                for (y = 0; y < height; y++) {\n                        if (interlace) {\n                                decode_y = gif_interlaced_line(height, y) + offset_y;\n                        } else {\n                                decode_y = y + offset_y;\n                        }\n                        frame_scanline = frame_data + offset_x + (decode_y * gif->width);\n\n                        /* Rather than decoding pixel by pixel, we try to burst\n                         * out streams of data to remove the need for end-of\n                         * data checks every pixel.\n                         */\n                        x = width;\n                        while (x > 0) {\n                                burst_bytes = (stack_pos - stack_base);\n                                if (burst_bytes > 0) {\n                                        if (burst_bytes > x) {\n                                                burst_bytes = x;\n                                        }\n                                        x -= burst_bytes;\n                                        while (burst_bytes-- > 0) {\n                                                colour = *--stack_pos;\n                                                if (((gif->frames[frame].transparency) &&\n                                                     (colour != gif->frames[frame].transparency_index)) ||\n                                                    (!gif->frames[frame].transparency)) {\n                                                        *frame_scanline = colour_table[colour];\n                                                }\n                                                frame_scanline++;\n                                        }\n                                } else {\n                                        res = lzw_decode(gif->lzw_ctx, &stack_pos);\n                                        if (res != LZW_OK) {\n                                                /* Unexpected end of frame, try to recover */\n                                                if (res == LZW_OK_EOD) {\n                                                        return_value = GIF_OK;\n                                                } else {\n                                                        return_value = gif_error_from_lzw(res);\n                                                }\n                                                goto gif_decode_frame_exit;\n                                        }\n                                }\n                        }\n                }\n        } else {\n                /* Clear our frame */\n                if (gif->frames[frame].disposal_method == GIF_FRAME_CLEAR) {\n                        for (y = 0; y < height; y++) {\n                                frame_scanline = frame_data + offset_x + ((offset_y + y) * gif->width);\n                                if (gif->frames[frame].transparency) {\n                                        memset(frame_scanline,\n                                               GIF_TRANSPARENT_COLOUR,\n                                               width * 4);\n                                } else {\n                                        memset(frame_scanline,\n                                               colour_table[gif->background_index],\n                                               width * 4);\n                                }\n                        }\n                }\n        }\ngif_decode_frame_exit:\n\n        /* Check if we should test for optimisation */\n        if (gif->frames[frame].virgin) {\n                if (gif->bitmap_callbacks.bitmap_test_opaque) {\n                        gif->frames[frame].opaque = gif->bitmap_callbacks.bitmap_test_opaque(gif->frame_image);\n                } else {\n                        gif->frames[frame].opaque = false;\n                }\n                gif->frames[frame].virgin = false;\n        }\n\n        if (gif->bitmap_callbacks.bitmap_set_opaque) {\n                gif->bitmap_callbacks.bitmap_set_opaque(gif->frame_image, gif->frames[frame].opaque);\n        }\n\n        if (gif->bitmap_callbacks.bitmap_modified) {\n                gif->bitmap_callbacks.bitmap_modified(gif->frame_image);\n        }\n\n        /* Restore the buffer position */\n        gif->buffer_position = save_buffer_position;\n\n        return return_value;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 342,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tRBuffer *fbuf = r_buf_ref (buf);\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\tstruct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts);\n\tif (!main_mach0) {\n\t\treturn false;\n\t}\n\n\tRRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0);\n\tRKernelCacheObj *obj = NULL;\n\n\tRPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0);\n\tif (!prelink_range) {\n\t\tgoto beach;\n\t}\n\n\tobj = R_NEW0 (RKernelCacheObj);\n\tif (!obj) {\n\t\tR_FREE (prelink_range);\n\t\tgoto beach;\n\t}\n\n\tRCFValueDict *prelink_info = NULL;\n\tif (main_mach0->hdr.filetype != MH_FILESET && prelink_range->range.size) {\n\t\tprelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset,\n\t\t\t\tprelink_range->range.size, R_CF_OPTION_SKIP_NSDATA);\n\t\tif (!prelink_info) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\n\tif (!pending_bin_files) {\n\t\tpending_bin_files = r_list_new ();\n\t\tif (!pending_bin_files) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tR_FREE (prelink_info);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\n\tobj->mach0 = main_mach0;\n\tobj->rebase_info = rebase_info;\n\tobj->prelink_info = prelink_info;\n\tobj->cache_buf = fbuf;\n\tobj->pa2va_exec = prelink_range->pa2va_exec;\n\tobj->pa2va_data = prelink_range->pa2va_data;\n\n\tR_FREE (prelink_range);\n\n\t*bin_obj = obj;\n\n\tr_list_push (pending_bin_files, bf);\n\n\tif (rebase_info || main_mach0->chained_starts) {\n\t\tRIO *io = bf->rbin->iob.io;\n\t\tswizzle_io_read (obj, io);\n\t}\n\n\treturn true;\n\nbeach:\n\tr_buf_free (fbuf);\n\tif (obj) {\n\t\tobj->cache_buf = NULL;\n\t}\n\tMACH0_(mach0_free) (main_mach0);\n\treturn false;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 346,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin || !bin->segment_entries) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\"%s.%\" PFMT64d, se->flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 366,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "*vidtv_s302m_encoder_init(struct vidtv_s302m_encoder_init_args args)\n{\n\tu32 priv_sz = sizeof(struct vidtv_s302m_ctx);\n\tstruct vidtv_s302m_ctx *ctx;\n\tstruct vidtv_encoder *e;\n\n\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\tif (!e)\n\t\treturn NULL;\n\n\te->id = S302M;\n\n\tif (args.name)\n\t\te->name = kstrdup(args.name, GFP_KERNEL);\n\n\te->encoder_buf = vzalloc(VIDTV_S302M_BUF_SZ);\n\tif (!e->encoder_buf)\n\t\tgoto out_kfree_e;\n\n\te->encoder_buf_sz = VIDTV_S302M_BUF_SZ;\n\te->encoder_buf_offset = 0;\n\n\te->sample_count = 0;\n\n\te->src_buf = (args.src_buf) ? args.src_buf : NULL;\n\te->src_buf_sz = (args.src_buf) ? args.src_buf_sz : 0;\n\te->src_buf_offset = 0;\n\n\te->is_video_encoder = false;\n\n\tctx = kzalloc(priv_sz, GFP_KERNEL);\n\tif (!ctx)\n\t\tgoto out_kfree_buf;\n\n\te->ctx = ctx;\n\tctx->last_duration = 0;\n\n\te->encode = vidtv_s302m_encode;\n\te->clear = vidtv_s302m_clear;\n\n\te->es_pid = cpu_to_be16(args.es_pid);\n\te->stream_id = cpu_to_be16(PES_PRIVATE_STREAM_1);\n\n\te->sync = args.sync;\n\te->sampling_rate_hz = S302M_SAMPLING_RATE_HZ;\n\n\te->last_sample_cb = args.last_sample_cb;\n\n\te->destroy = vidtv_s302m_encoder_destroy;\n\n\tif (args.head) {\n\t\twhile (args.head->next)\n\t\t\targs.head = args.head->next;\n\n\t\targs.head->next = e;\n\t}\n\n\te->next = NULL;\n\n\treturn e;\n\nout_kfree_buf:\n\tkfree(e->encoder_buf);\n\nout_kfree_e:\n\tkfree(e->name);\n\tkfree(e);\n\treturn NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 394,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "fname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse if (rmp->regprog != NULL)\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 416,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int udf_expand_file_adinicb(struct inode *inode)\n{\n\tstruct page *page;\n\tchar *kaddr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint err;\n\n\tWARN_ON_ONCE(!inode_is_locked(inode));\n\tif (!iinfo->i_lenAlloc) {\n\t\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\t\telse\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t\t/* from now on we have normal address_space methods */\n\t\tinode->i_data.a_ops = &udf_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t\tmark_inode_dirty(inode);\n\t\treturn 0;\n\t}\n\t/*\n\t * Release i_data_sem so that we can lock a page - page lock ranks\n\t * above i_data_sem. i_mutex still protects us against file changes.\n\t */\n\tup_write(&iinfo->i_data_sem);\n\n\tpage = find_or_create_page(inode->i_mapping, 0, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (!PageUptodate(page)) {\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr + iinfo->i_lenAlloc, 0x00,\n\t\t       PAGE_SIZE - iinfo->i_lenAlloc);\n\t\tmemcpy(kaddr, iinfo->i_data + iinfo->i_lenEAttr,\n\t\t\tiinfo->i_lenAlloc);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t\tkunmap_atomic(kaddr);\n\t}\n\tdown_write(&iinfo->i_data_sem);\n\tmemset(iinfo->i_data + iinfo->i_lenEAttr, 0x00,\n\t       iinfo->i_lenAlloc);\n\tiinfo->i_lenAlloc = 0;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t/* from now on we have normal address_space methods */\n\tinode->i_data.a_ops = &udf_aops;\n\tset_page_dirty(page);\n\tunlock_page(page);\n\tup_write(&iinfo->i_data_sem);\n\terr = filemap_fdatawrite(inode->i_mapping);\n\tif (err) {\n\t\t/* Restore everything back so that we don't lose data... */\n\t\tlock_page(page);\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy(iinfo->i_data + iinfo->i_lenEAttr, kaddr, inode->i_size);\n\t\tkunmap_atomic(kaddr);\n\t\tunlock_page(page);\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\tiinfo->i_lenAlloc = inode->i_size;\n\t\tup_write(&iinfo->i_data_sem);\n\t}\n\tput_page(page);\n\tmark_inode_dirty(inode);\n\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 518,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "tgs_build_reply(astgs_request_t priv,\n\t\thdb_entry_ex *krbtgt,\n\t\tkrb5_enctype krbtgt_etype,\n\t\tconst krb5_keyblock *replykey,\n\t\tint rk_is_subkey,\n\t\tkrb5_ticket *ticket,\n\t\tconst char **e_text,\n\t\tAuthorizationData **auth_data,\n\t\tconst struct sockaddr *from_addr)\n{\n    krb5_context context = priv->context;\n    krb5_kdc_configuration *config = priv->config;\n    KDC_REQ *req = &priv->req;\n    KDC_REQ_BODY *b = &priv->req.req_body;\n    const char *from = priv->from;\n    krb5_error_code ret, ret2;\n    krb5_principal cp = NULL, sp = NULL, rsp = NULL, tp = NULL, dp = NULL;\n    krb5_principal krbtgt_out_principal = NULL;\n    char *spn = NULL, *cpn = NULL, *tpn = NULL, *dpn = NULL, *krbtgt_out_n = NULL;\n    hdb_entry_ex *server = NULL, *client = NULL, *s4u2self_impersonated_client = NULL;\n    HDB *clientdb, *s4u2self_impersonated_clientdb;\n    krb5_realm ref_realm = NULL;\n    EncTicketPart *tgt = &ticket->ticket;\n    krb5_principals spp = NULL;\n    const EncryptionKey *ekey;\n    krb5_keyblock sessionkey;\n    krb5_kvno kvno;\n    krb5_data rspac;\n    const char *tgt_realm = /* Realm of TGT issuer */\n        krb5_principal_get_realm(context, krbtgt->entry.principal);\n    const char *our_realm = /* Realm of this KDC */\n        krb5_principal_get_comp_string(context, krbtgt->entry.principal, 1);\n    char **capath = NULL;\n    size_t num_capath = 0;\n\n    hdb_entry_ex *krbtgt_out = NULL;\n\n    METHOD_DATA enc_pa_data;\n\n    PrincipalName *s;\n    Realm r;\n    EncTicketPart adtkt;\n    char opt_str[128];\n    int signedpath = 0;\n\n    Key *tkey_check;\n    Key *tkey_sign;\n    int flags = HDB_F_FOR_TGS_REQ;\n\n    memset(&sessionkey, 0, sizeof(sessionkey));\n    memset(&adtkt, 0, sizeof(adtkt));\n    krb5_data_zero(&rspac);\n    memset(&enc_pa_data, 0, sizeof(enc_pa_data));\n\n    s = b->sname;\n    r = b->realm;\n\n    /*\n     * The canonicalize KDC option is passed as a hint to the backend, but\n     * can typically be ignored. Per RFC 6806, names are not canonicalized\n     * in response to a TGS request (although we make an exception, see\n     * force-canonicalize below).\n     */\n    if (b->kdc_options.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->kdc_options.enc_tkt_in_skey){\n\tTicket *t;\n\thdb_entry_ex *uu;\n\tkrb5_principal p;\n\tKey *uukey;\n\tkrb5uint32 second_kvno = 0;\n\tkrb5uint32 *kvno_ptr = NULL;\n\n\tif(b->additional_tickets == NULL ||\n\t   b->additional_tickets->len == 0){\n\t    ret = KRB5KDC_ERR_BADOPTION; /* ? */\n\t    kdc_log(context, config, 4,\n\t\t    \"No second ticket present in user-to-user request\");\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"No second ticket present in user-to-user request\");\n\t    goto out;\n\t}\n\tt = &b->additional_tickets->val[0];\n\tif(!get_krbtgt_realm(&t->sname)){\n\t    kdc_log(context, config, 4,\n\t\t    \"Additional ticket is not a ticket-granting ticket\");\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Additional ticket is not a ticket-granting ticket\");\n\t    ret = KRB5KDC_ERR_POLICY;\n\t    goto out;\n\t}\n\t_krb5_principalname2krb5_principal(context, &p, t->sname, t->realm);\n\tret = krb5_unparse_name(context, p, &tpn);\n\tif (ret)\n\t\tgoto out;\n\tif(t->enc_part.kvno){\n\t    second_kvno = *t->enc_part.kvno;\n\t    kvno_ptr = &second_kvno;\n\t}\n\tret = _kdc_db_fetch(context, config, p,\n\t\t\t    HDB_F_GET_KRBTGT, kvno_ptr,\n\t\t\t    NULL, &uu);\n\tkrb5_free_principal(context, p);\n\tif(ret){\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user service principal (TGS) unknown\");\n\t    goto out;\n\t}\n\tret = hdb_enctype2key(context, &uu->entry, NULL,\n\t\t\t      t->enc_part.etype, &uukey);\n\tif(ret){\n\t    _kdc_free_ent(context, uu);\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user enctype not supported\");\n\t    goto out;\n\t}\n\tret = krb5_decrypt_ticket(context, t, &uukey->key, &adtkt, 0);\n\t_kdc_free_ent(context, uu);\n\tif(ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user TGT decrypt failure\");\n\t    goto out;\n        }\n\n\tret = verify_flags(context, config, &adtkt, tpn);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user TGT expired or invalid\");\n\t    goto out;\n        }\n\n\ts = &adtkt.cname;\n\tr = adtkt.crealm;\n    } else if (s == NULL) {\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\t_kdc_set_e_text(r, \"No server in request\");\n\tgoto out;\n    }\n\n    _krb5_principalname2krb5_principal(context, &sp, *s, r);\n    ret = krb5_unparse_name(context, sp, &priv->sname);\n    if (ret)\n\tgoto out;\n    spn = priv->sname;\n    _krb5_principalname2krb5_principal(context, &cp, tgt->cname, tgt->crealm);\n    ret = krb5_unparse_name(context, cp, &priv->cname);\n    if (ret)\n\tgoto out;\n    cpn = priv->cname;\n    unparse_flags (KDCOptions2int(b->kdc_options),\n\t\t   asn1_KDCOptions_units(),\n\t\t   opt_str, sizeof(opt_str));\n    if(*opt_str)\n\tkdc_log(context, config, 4,\n\t\t\"TGS-REQ %s from %s for %s [%s]\",\n\t\tcpn, from, spn, opt_str);\n    else\n\tkdc_log(context, config, 4,\n\t\t\"TGS-REQ %s from %s for %s\", cpn, from, spn);\n\n    /*\n     * Fetch server\n     */\n\nserver_lookup:\n    ret = _kdc_db_fetch(context, config, sp,\n                        HDB_F_GET_SERVER | HDB_F_DELAY_NEW_KEYS | flags,\n\t\t\tNULL, NULL, &server);\n    priv->server = server;\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\", spn);\n        _kdc_audit_addreason((kdc_request_t)priv, \"Target not found here\");\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n        free(ref_realm);\n\tref_realm = strdup(server->entry.principal->realm);\n\tif (ref_realm == NULL) {\n            ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 4,\n\t\t\"Returning a referral to realm %s for \"\n\t\t\"server %s.\",\n\t\tref_realm, spn);\n\tkrb5_free_principal(context, sp);\n\tsp = NULL;\n\tret = krb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t  ref_realm, NULL);\n\tif (ret)\n\t    goto out;\n\tfree(priv->sname);\n        priv->sname = NULL;\n\tret = krb5_unparse_name(context, sp, &priv->sname);\n\tif (ret)\n\t    goto out;\n\tspn = priv->sname;\n\n\tgoto server_lookup;\n    } else if (ret) {\n\tconst char *new_rlm, *msg;\n\tRealm req_rlm;\n\tkrb5_realm *realms;\n\n\tif ((req_rlm = get_krbtgt_realm(&sp->name)) != NULL) {\n            if (capath == NULL) {\n                /* With referalls, hierarchical capaths are always enabled */\n                ret2 = _krb5_find_capath(context, tgt->crealm, our_realm,\n                                         req_rlm, TRUE, &capath, &num_capath);\n                if (ret2) {\n                    ret = ret2;\n                    _kdc_audit_addreason((kdc_request_t)priv,\n                                         \"No trusted path from client realm to ours\");\n                    goto out;\n                }\n            }\n            new_rlm = num_capath > 0 ? capath[--num_capath] : NULL;\n            if (new_rlm) {\n                kdc_log(context, config, 5, \"krbtgt from %s via %s for \"\n                        \"realm %s not found, trying %s\", tgt->crealm,\n                        our_realm, req_rlm, new_rlm);\n\n                free(ref_realm);\n                ref_realm = strdup(new_rlm);\n                if (ref_realm == NULL) {\n                    ret = krb5_enomem(context);\n                    goto out;\n                }\n\n                krb5_free_principal(context, sp);\n                sp = NULL;\n                krb5_make_principal(context, &sp, r,\n                                    KRB5_TGS_NAME, ref_realm, NULL);\n                free(priv->sname);\n                priv->sname = NULL;\n                ret = krb5_unparse_name(context, sp, &priv->sname);\n                if (ret)\n                    goto out;\n                spn = priv->sname;\n                goto server_lookup;\n            }\n\t} else if (need_referral(context, config, &b->kdc_options, sp, &realms)) {\n\t    if (strcmp(realms[0], sp->realm) != 0) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Returning a referral to realm %s for \"\n\t\t\t\"server %s that was not found\",\n\t\t\trealms[0], spn);\n\t\tkrb5_free_principal(context, sp);\n                sp = NULL;\n\t\tkrb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t    realms[0], NULL);\n\t\tfree(priv->sname);\n                priv->sname = NULL;\n\t\tret = krb5_unparse_name(context, sp, &priv->sname);\n\t\tif (ret) {\n\t\t    krb5_free_host_realm(context, realms);\n\t\t    goto out;\n\t\t}\n\t\tspn = priv->sname;\n\n                free(ref_realm);\n\t\tref_realm = strdup(realms[0]);\n\n\t\tkrb5_free_host_realm(context, realms);\n\t\tgoto server_lookup;\n\t    }\n\t    krb5_free_host_realm(context, realms);\n\t}\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 3,\n\t\t\"Server not found in database: %s: %s\", spn, msg);\n\tkrb5_free_error_message(context, msg);\n\tif (ret == HDB_ERR_NOENTRY)\n\t    ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"Service principal unknown\");\n\tgoto out;\n    }\n\n    /*\n     * RFC 6806 notes that names MUST NOT be changed in the response to\n     * a TGS request. Hence we ignore the setting of the canonicalize\n     * KDC option. However, for legacy interoperability we do allow the\n     * backend to override this by setting the force-canonicalize HDB\n     * flag in the server entry.\n     */\n    if (server->entry.flags.force_canonicalize)\n\trsp = server->entry.principal;\n    else\n\trsp = sp;\n\n    /*\n     * Select enctype, return key and kvno.\n     */\n\n    {\n\tkrb5_enctype etype;\n\n\tif(b->kdc_options.enc_tkt_in_skey) {\n\t    size_t i;\n\t    ekey = &adtkt.key;\n\t    for(i = 0; i < b->etype.len; i++)\n\t\tif (b->etype.val[i] == adtkt.key.keytype)\n\t\t    break;\n\t    if(i == b->etype.len) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Addition ticket have not matching etypes\");\n\t\tkrb5_clear_error_message(context);\n\t\tret = KRB5KDC_ERR_ETYPE_NOSUPP;\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"No matching enctypes for 2nd ticket\");\n\t\tgoto out;\n\t    }\n\t    etype = b->etype.val[i];\n\t    kvno = 0;\n\t} else {\n\t    Key *skey;\n\n\t    ret = _kdc_find_etype(priv, krb5_principal_is_krbtgt(context, sp)\n\t\t\t\t\t\t\t     ? KFE_IS_TGS : 0,\n\t\t\t\t  b->etype.val, b->etype.len, &etype, NULL,\n\t\t\t\t  NULL);\n\t    if(ret) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Server (%s) has no support for etypes\", spn);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"Enctype not supported\");\n\t\tgoto out;\n\t    }\n\t    ret = _kdc_get_preferred_key(context, config, server, spn,\n\t\t\t\t\t NULL, &skey);\n\t    if(ret) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Server (%s) has no supported etypes\", spn);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"Enctype not supported\");\n\t\tgoto out;\n\t    }\n\t    ekey = &skey->key;\n\t    kvno = server->entry.kvno;\n\t}\n\n\tret = krb5_generate_random_keyblock(context, etype, &sessionkey);\n\tif (ret)\n\t    goto out;\n    }\n\n    /*\n     * Check that service is in the same realm as the krbtgt. If it's\n     * not the same, it's someone that is using a uni-directional trust\n     * backward.\n     */\n\n    /*\n     * Validate authorization data\n     */\n\n    ret = hdb_enctype2key(context, &krbtgt->entry, NULL, /* XXX use the right kvno! */\n\t\t\t  krbtgt_etype, &tkey_check);\n    if(ret) {\n\tkdc_log(context, config, 4,\n\t\t    \"Failed to find key for krbtgt PAC check\");\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"No key for krbtgt PAC check\");\n\tgoto out;\n    }\n\n    /* \n     * Now refetch the primary krbtgt, and get the current kvno (the\n     * sign check may have been on an old kvno, and the server may\n     * have been an incoming trust)\n     */\n    \n    ret = krb5_make_principal(context,\n                              &krbtgt_out_principal,\n                              our_realm,\n                              KRB5_TGS_NAME,\n                              our_realm,\n                              NULL);\n    if (ret) {\n        kdc_log(context, config, 4,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n    ret = krb5_unparse_name(context, krbtgt_out_principal, &krbtgt_out_n);\n    if (ret) {\n        kdc_log(context, config, 4,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n\n    ret = _kdc_db_fetch(context, config, krbtgt_out_principal,\n\t\t\tHDB_F_GET_KRBTGT, NULL, NULL, &krbtgt_out);\n    if (ret) {\n\tchar *ktpn = NULL;\n\tret = krb5_unparse_name(context, krbtgt->entry.principal, &ktpn);\n\tkdc_log(context, config, 4,\n\t\t\"No such principal %s (needed for authz-data signature keys) \"\n\t\t\"while processing TGS-REQ for service %s with krbtg %s\",\n\t\tkrbtgt_out_n, spn, (ret == 0) ? ktpn : \"<unknown>\");\n\tfree(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    /* \n     * The first realm is the realm of the service, the second is\n     * krbtgt/<this>/@REALM component of the krbtgt DN the request was\n     * encrypted to.  The redirection via the krbtgt_out entry allows\n     * the DB to possibly correct the case of the realm (Samba4 does\n     * this) before the strcmp() \n     */\n    if (strcmp(krb5_principal_get_realm(context, server->entry.principal),\n\t       krb5_principal_get_realm(context, krbtgt_out->entry.principal)) != 0) {\n\tchar *ktpn;\n\tret = krb5_unparse_name(context, krbtgt_out->entry.principal, &ktpn);\n\tkdc_log(context, config, 4,\n\t\t\"Request with wrong krbtgt: %s\",\n\t\t(ret == 0) ? ktpn : \"<unknown>\");\n\tif(ret == 0)\n\t    free(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n        _kdc_audit_addreason((kdc_request_t)priv, \"Request with wrong TGT\");\n\tgoto out;\n    }\n\n    ret = _kdc_get_preferred_key(context, config, krbtgt_out, krbtgt_out_n,\n\t\t\t\t NULL, &tkey_sign);\n    if (ret) {\n\tkdc_log(context, config, 4,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n    ret = hdb_enctype2key(context, &krbtgt_out->entry, NULL,\n\t\t\t  tkey_sign->key.keytype, &tkey_sign);\n    if(ret) {\n\tkdc_log(context, config, 4,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n\n    {\n        krb5_data verified_cas;\n\n        /*\n         * If the client doesn't exist in the HDB but has a TGT and it's\n         * obtained with PKINIT then we assume it's a synthetic client -- that\n         * is, a client whose name was vouched for by a CA using a PKINIT SAN,\n         * but which doesn't exist in the HDB proper.  We'll allow such a\n         * client to do TGT requests even though normally we'd reject all\n         * clients that don't exist in the HDB.\n         */\n        ret = krb5_ticket_get_authorization_data_type(context, ticket,\n                                                      KRB5_AUTHDATA_INITIAL_VERIFIED_CAS,\n                                                      &verified_cas);\n        if (ret == 0) {\n            krb5_data_free(&verified_cas);\n            flags |= HDB_F_SYNTHETIC_OK;\n        }\n    }\n    ret = _kdc_db_fetch(context, config, cp, HDB_F_GET_CLIENT | flags,\n\t\t\tNULL, &clientdb, &client);\n    flags &= ~HDB_F_SYNTHETIC_OK;\n    priv->client = client;\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* This is OK, we are just trying to find out if they have\n\t * been disabled or deleted in the meantime, missing secrets\n\t * is OK */\n    } else if(ret){\n\tconst char *krbtgt_realm, *msg;\n\n\t/*\n\t * If the client belongs to the same realm as our krbtgt, it\n\t * should exist in the local database.\n\t *\n\t */\n\n\tkrbtgt_realm = krb5_principal_get_realm(context, krbtgt_out->entry.principal);\n\n\tif(strcmp(krb5_principal_get_realm(context, cp), krbtgt_realm) == 0) {\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    kdc_log(context, config, 4, \"Client no longer in database: %s\",\n\t\t    cpn);\n            _kdc_audit_addreason((kdc_request_t)priv, \"Client no longer in HDB\");\n\t    goto out;\n\t}\n\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 4, \"Client not found in database: %s\", msg);\n        _kdc_audit_addreason((kdc_request_t)priv, \"Client does not exist\");\n\tkrb5_free_error_message(context, msg);\n    } else if (ret == 0 &&\n               (client->entry.flags.invalid || !client->entry.flags.client)) {\n        _kdc_audit_addreason((kdc_request_t)priv, \"Client has invalid bit set\");\n        kdc_log(context, config, 4, \"Client has invalid bit set\");\n        ret = KRB5KDC_ERR_POLICY;\n        goto out;\n    }\n\n    ret = check_PAC(context, config, cp, NULL,\n\t\t    client, server, krbtgt,\n\t\t    &tkey_check->key,\n\t\t    ekey, &tkey_sign->key,\n\t\t    tgt, &rspac, &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n        _kdc_audit_addreason((kdc_request_t)priv, \"PAC check failed\");\n\tkdc_log(context, config, 4,\n\t\t\"Verify PAC failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /* also check the krbtgt for signature */\n    ret = check_KRB5SignedPath(context,\n\t\t\t       config,\n\t\t\t       krbtgt,\n\t\t\t       cp,\n\t\t\t       tgt,\n\t\t\t       &spp,\n\t\t\t       &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n        _kdc_audit_addreason((kdc_request_t)priv, \"KRB5SignedPath check failed\");\n\tkdc_log(context, config, 4,\n\t\t\"KRB5SignedPath check failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /*\n     * Process request\n     */\n\n    /* by default the tgt principal matches the client principal */\n    tp = cp;\n    tpn = cpn;\n\n    if (client) {\n\tconst PA_DATA *sdata;\n\tint i = 0;\n\n\tsdata = _kdc_find_padata(req, &i, KRB5_PADATA_FOR_USER);\n\tif (sdata) {\n\t    struct astgs_request_desc imp_req;\n\t    krb5_crypto crypto;\n\t    krb5_data datack;\n\t    PA_S4U2Self self;\n\t    const char *str;\n\n\t    ret = decode_PA_S4U2Self(sdata->padata_value.data,\n\t\t\t\t     sdata->padata_value.length,\n\t\t\t\t     &self, NULL);\n\t    if (ret) {\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"Failed to decode PA-S4U2Self\");\n\t\tkdc_log(context, config, 4, \"Failed to decode PA-S4U2Self\");\n\t\tgoto out;\n\t    }\n\n\t    if (!krb5_checksum_is_keyed(context, self.cksum.cksumtype)) {\n\t\tfree_PA_S4U2Self(&self);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"PA-S4U2Self with unkeyed checksum\");\n\t\tkdc_log(context, config, 4, \"Reject PA-S4U2Self with unkeyed checksum\");\n\t\tret = KRB5KRB_AP_ERR_INAPP_CKSUM;\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_s4u2self_to_checksumdata(context, &self, &datack);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_crypto_init(context, &tgt->key, 0, &crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n\t\tkrb5_data_free(&datack);\n\t\tkdc_log(context, config, 4, \"krb5_crypto_init failed: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    /* Allow HMAC_MD5 checksum with any key type */\n\t    if (self.cksum.cksumtype == CKSUMTYPE_HMAC_MD5) {\n\t\tstruct krb5_crypto_iov iov;\n\t\tunsigned char csdata[16];\n\t\tChecksum cs;\n\n\t\tcs.checksum.length = sizeof(csdata);\n\t\tcs.checksum.data = &csdata;\n\n\t\tiov.data.data = datack.data;\n\t\tiov.data.length = datack.length;\n\t\tiov.flags = KRB5_CRYPTO_TYPE_DATA;\n\n\t\tret = _krb5_HMAC_MD5_checksum(context, NULL, &crypto->key,\n\t\t\t\t\t      KRB5_KU_OTHER_CKSUM, &iov, 1,\n\t\t\t\t\t      &cs);\n\t\tif (ret == 0 &&\n\t\t    krb5_data_ct_cmp(&cs.checksum, &self.cksum.checksum) != 0)\n\t\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY;\n\t    }\n\t    else {\n\t\tret = krb5_verify_checksum(context,\n\t\t\t\t\t   crypto,\n\t\t\t\t\t   KRB5_KU_OTHER_CKSUM,\n\t\t\t\t\t   datack.data,\n\t\t\t\t\t   datack.length,\n\t\t\t\t\t   &self.cksum);\n\t    }\n\t    krb5_data_free(&datack);\n\t    krb5_crypto_destroy(context, crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"S4U2Self checksum failed\");\n\t\tkdc_log(context, config, 4,\n\t\t\t\"krb5_verify_checksum failed for S4U2Self: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t     &tp,\n\t\t\t\t\t\t     self.name,\n\t\t\t\t\t\t     self.realm);\n\t    free_PA_S4U2Self(&self);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_unparse_name(context, tp, &tpn);\n\t    if (ret)\n\t\tgoto out;\n\n            /*\n             * Note no HDB_F_SYNTHETIC_OK -- impersonating non-existent clients\n             * is probably not desirable!\n             */\n\t    ret = _kdc_db_fetch(context, config, tp, HDB_F_GET_CLIENT | flags,\n\t\t\t\tNULL, &s4u2self_impersonated_clientdb,\n\t\t\t\t&s4u2self_impersonated_client);\n\t    if (ret) {\n\t\tconst char *msg;\n\n\t\t/*\n\t\t * If the client belongs to the same realm as our krbtgt, it\n\t\t * should exist in the local database.\n\t\t *\n\t\t */\n\n\t\tif (ret == HDB_ERR_NOENTRY)\n\t\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t\tmsg = krb5_get_error_message(context, ret);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"S4U2Self principal to impersonate not found\");\n\t\tkdc_log(context, config, 2,\n\t\t\t\"S4U2Self principal to impersonate %s not found in database: %s\",\n\t\t\ttpn, msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    /* Ignore require_pwchange and pw_end attributes (as Windows does),\n\t     * since S4U2Self is not password authentication. */\n\t    s4u2self_impersonated_client->entry.flags.require_pwchange = FALSE;\n\t    free(s4u2self_impersonated_client->entry.pw_end);\n\t    s4u2self_impersonated_client->entry.pw_end = NULL;\n\n\t    imp_req = *priv;\n\t    imp_req.client = s4u2self_impersonated_client;\n\t    imp_req.client_princ = tp;\n\n\t    ret = kdc_check_flags(&imp_req, FALSE);\n\t    if (ret)\n\t\tgoto out; /* kdc_check_flags() calls _kdc_audit_addreason() */\n\n\t    /* If we were about to put a PAC into the ticket, we better fix it to be the right PAC */\n\t    if(rspac.data) {\n\t\tkrb5_pac p = NULL;\n\t\tkrb5_data_free(&rspac);\n\t\tret = _kdc_pac_generate(context, s4u2self_impersonated_client, &p);\n\t\tif (ret) {\n                    _kdc_audit_addreason((kdc_request_t)priv,\n                                         \"KRB5SignedPath missing\");\n\t\t    kdc_log(context, config, 4, \"PAC generation failed for -- %s\",\n\t\t\t    tpn);\n\t\t    goto out;\n\t\t}\n\t\tif (p != NULL) {\n\t\t    ret = _krb5_pac_sign(context, p, ticket->ticket.authtime,\n\t\t\t\t\t s4u2self_impersonated_client->entry.principal,\n\t\t\t\t\t ekey, &tkey_sign->key,\n\t\t\t\t\t &rspac);\n\t\t    krb5_pac_free(context, p);\n\t\t    if (ret) {\n\t\t\tkdc_log(context, config, 4, \"PAC signing failed for -- %s\",\n\t\t\t\ttpn);\n\t\t\tgoto out;\n\t\t    }\n\t\t}\n\t    }\n\n\t    /*\n\t     * Check that service doing the impersonating is\n\t     * requesting a ticket to it-self.\n\t     */\n\t    ret = check_s4u2self(context, config, clientdb, client, sp);\n\t    if (ret) {\n\t\tkdc_log(context, config, 4, \"S4U2Self: %s is not allowed \"\n\t\t\t\"to impersonate to service \"\n\t\t\t\"(tried for user %s to service %s)\",\n\t\t\tcpn, tpn, spn);\n\t\tgoto out;\n\t    }\n\n\t    /*\n\t     * If the service isn't trusted for authentication to\n\t     * delegation or if the impersonate client is disallowed\n\t     * forwardable, remove the forwardable flag.\n\t     */\n\n\t    if (client->entry.flags.trusted_for_delegation &&\n\t\ts4u2self_impersonated_client->entry.flags.forwardable) {\n\t\tstr = \"[forwardable]\";\n\t    } else {\n\t\tb->kdc_options.forwardable = 0;\n\t\tstr = \"\";\n\t    }\n\t    kdc_log(context, config, 4, \"s4u2self %s impersonating %s to \"\n\t\t    \"service %s %s\", cpn, tpn, spn, str);\n\t}\n    }\n\n    /*\n     * Constrained delegation\n     */\n\n    if (client != NULL\n\t&& b->additional_tickets != NULL\n\t&& b->additional_tickets->len != 0\n\t&& b->kdc_options.cname_in_addl_tkt\n\t&& b->kdc_options.enc_tkt_in_skey == 0)\n    {\n\tint ad_signedpath = 0;\n\tKey *clientkey;\n\tTicket *t;\n\n\t/*\n\t * Require that the KDC have issued the service's krbtgt (not\n\t * self-issued ticket with kimpersonate(1).\n\t */\n\tif (!signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n            _kdc_audit_addreason((kdc_request_t)priv, \"KRB5SignedPath missing\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Constrained delegation done on service ticket %s/%s\",\n\t\t    cpn, spn);\n\t    goto out;\n\t}\n\n\tt = &b->additional_tickets->val[0];\n\n\tret = hdb_enctype2key(context, &client->entry,\n\t\t\t      hdb_kvno2keys(context, &client->entry,\n\t\t\t\t\t    t->enc_part.kvno ? * t->enc_part.kvno : 0),\n\t\t\t      t->enc_part.etype, &clientkey);\n\tif(ret){\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n\t    goto out;\n\t}\n\n\tret = krb5_decrypt_ticket(context, t, &clientkey->key, &adtkt, 0);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Failed to decrypt constrained delegation ticket\");\n\t    kdc_log(context, config, 4,\n\t\t    \"failed to decrypt ticket for \"\n\t\t    \"constrained delegation from %s to %s \", cpn, spn);\n\t    goto out;\n\t}\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &tp,\n\t\t\t\t\t\t adtkt.cname,\n\t\t\t\t\t\t adtkt.crealm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, tp, &tpn);\n\tif (ret)\n\t    goto out;\n\n        _kdc_audit_addkv((kdc_request_t)priv, 0, \"impersonatee\", \"%s\", tpn);\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &dp,\n\t\t\t\t\t\t t->sname,\n\t\t\t\t\t\t t->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, dp, &dpn);\n\tif (ret)\n\t    goto out;\n\n\t/* check that ticket is valid */\n\tif (adtkt.flags.forwardable == 0) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Missing forwardable flag on ticket for constrained delegation\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Missing forwardable flag on ticket for \"\n\t\t    \"constrained delegation from %s (%s) as %s to %s \",\n\t\t    cpn, dpn, tpn, spn);\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    goto out;\n\t}\n\n\tret = check_constrained_delegation(context, config, clientdb,\n\t\t\t\t\t   client, server, sp);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation not allowed\");\n\t    kdc_log(context, config, 4,\n\t\t    \"constrained delegation from %s (%s) as %s to %s not allowed\",\n\t\t    cpn, dpn, tpn, spn);\n\t    goto out;\n\t}\n\n\tret = verify_flags(context, config, &adtkt, tpn);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation ticket expired or invalid\");\n\t    goto out;\n\t}\n\n\tkrb5_data_free(&rspac);\n\n\t/*\n\t * generate the PAC for the user.\n\t *\n\t * TODO: pass in t->sname and t->realm and build\n\t * a S4U_DELEGATION_INFO blob to the PAC.\n\t */\n\tret = check_PAC(context, config, tp, dp,\n\t\t\tclient, server, krbtgt,\n\t\t\t&clientkey->key,\n\t\t\tekey, &tkey_sign->key,\n\t\t\t&adtkt, &rspac, &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation ticket PAC check failed\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Verify delegated PAC failed to %s for client\"\n\t\t    \"%s (%s) as %s from %s with %s\",\n\t\t    spn, cpn, dpn, tpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\n\t/*\n\t * Check that the KDC issued the user's ticket.\n\t */\n\tret = check_KRB5SignedPath(context,\n\t\t\t\t   config,\n\t\t\t\t   krbtgt,\n\t\t\t\t   cp,\n\t\t\t\t   &adtkt,\n\t\t\t\t   NULL,\n\t\t\t\t   &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 4,\n\t\t    \"KRB5SignedPath check from service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s failed with %s\",\n\t\t    spn, tpn, dpn, cpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"KRB5SignedPath check failed\");\n\t    goto out;\n\t}\n\n\tif (!ad_signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    kdc_log(context, config, 4,\n\t\t    \"Ticket not signed with PAC nor SignedPath service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s\",\n\t\t    spn, tpn, dpn, cpn, from);\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation ticket not signed\");\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 4, \"constrained delegation for %s \"\n\t\t\"from %s (%s) to %s\", tpn, cpn, dpn, spn);\n    }\n\n    /*\n     * Check flags\n     */\n\n    ret = kdc_check_flags(priv, FALSE);\n    if(ret)\n\tgoto out;\n\n    if((b->kdc_options.validate || b->kdc_options.renew) &&\n       !krb5_principal_compare(context,\n\t\t\t       krbtgt->entry.principal,\n\t\t\t       server->entry.principal)){\n        _kdc_audit_addreason((kdc_request_t)priv, \"Inconsistent request\");\n\tkdc_log(context, config, 4, \"Inconsistent request.\");\n\tret = KRB5KDC_ERR_SERVER_NOMATCH;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if (!_kdc_check_addresses(priv, tgt->caddr, from_addr)) {\n        if (config->check_ticket_addresses) {\n            ret = KRB5KRB_AP_ERR_BADADDR;\n            _kdc_audit_addkv((kdc_request_t)priv, 0, \"wrongaddr\", \"yes\");\n            kdc_log(context, config, 4, \"Request from wrong address\");\n            _kdc_audit_addreason((kdc_request_t)priv, \"Request from wrong address\");\n            goto out;\n        } else if (config->warn_ticket_addresses) {\n            _kdc_audit_addkv((kdc_request_t)priv, 0, \"wrongaddr\", \"yes\");\n        }\n    }\n\n    /* check local and per-principal anonymous ticket issuance policy */\n    if (is_anon_tgs_request_p(b, tgt)) {\n\tret = _kdc_check_anon_policy(priv);\n\tif (ret)\n\t    goto out;\n    }\n\n    /*\n     * If this is an referral, add server referral data to the\n     * auth_data reply .\n     */\n    if (ref_realm) {\n\tPA_DATA pa;\n\tkrb5_crypto crypto;\n\n\tkdc_log(context, config, 3,\n\t\t\"Adding server referral to %s\", ref_realm);\n\n\tret = krb5_crypto_init(context, &sessionkey, 0, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = build_server_referral(context, config, crypto, ref_realm,\n\t\t\t\t    NULL, s, &pa.padata_value);\n\tkrb5_crypto_destroy(context, crypto);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv, \"Referral build failed\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Failed building server referral\");\n\t    goto out;\n\t}\n\tpa.padata_type = KRB5_PADATA_SERVER_REFERRAL;\n\n\tret = add_METHOD_DATA(&enc_pa_data, &pa);\n\tkrb5_data_free(&pa.padata_value);\n\tif (ret) {\n\t    kdc_log(context, config, 4,\n\t\t    \"Add server referral METHOD-DATA failed\");\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = tgs_make_reply(priv,\n\t\t\t tp,\n\t\t\t tgt,\n\t\t\t replykey,\n\t\t\t rk_is_subkey,\n\t\t\t ekey,\n\t\t\t &sessionkey,\n\t\t\t kvno,\n\t\t\t *auth_data,\n\t\t\t server,\n\t\t\t rsp,\n\t\t\t client,\n\t\t\t cp,\n                         tgt_realm,\n\t\t\t krbtgt_out,\n\t\t\t tkey_sign->key.keytype,\n\t\t\t spp,\n\t\t\t &rspac,\n\t\t\t &enc_pa_data);\n\nout:\n    if (tpn != cpn)\n\t    free(tpn);\n    free(dpn);\n    free(krbtgt_out_n);\n    _krb5_free_capath(context, capath);\n\n    krb5_data_free(&rspac);\n    krb5_free_keyblock_contents(context, &sessionkey);\n    if(krbtgt_out)\n\t_kdc_free_ent(context, krbtgt_out);\n    if(server)\n\t_kdc_free_ent(context, server);\n    if(client)\n\t_kdc_free_ent(context, client);\n    if(s4u2self_impersonated_client)\n\t_kdc_free_ent(context, s4u2self_impersonated_client);\n\n    if (tp && tp != cp)\n\tkrb5_free_principal(context, tp);\n    krb5_free_principal(context, cp);\n    krb5_free_principal(context, dp);\n    krb5_free_principal(context, sp);\n    krb5_free_principal(context, krbtgt_out_principal);\n    free(ref_realm);\n    free_METHOD_DATA(&enc_pa_data);\n\n    free_EncTicketPart(&adtkt);\n\n    return ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 568,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void jsP_dumpsyntax(js_State *J, js_Ast *prog, int dominify)\n{\n\tminify = dominify;\n\tif (prog) {\n\t\tif (prog->type == AST_LIST)\n\t\t\tpstmlist(-1, prog);\n\t\telse {\n\t\t\tpstm(0, prog);\n\t\t\tnl();\n\t\t}\n\t}\n\tif (minify > 1)\n\t\tputchar('\\n');\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 588,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "struct iwl_trans *iwl_trans_pcie_alloc(struct pci_dev *pdev,\n\t\t\t       const struct pci_device_id *ent,\n\t\t\t       const struct iwl_cfg_trans_params *cfg_trans)\n{\n\tstruct iwl_trans_pcie *trans_pcie;\n\tstruct iwl_trans *trans;\n\tint ret, addr_size;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (cfg_trans->gen2)\n\t\ttrans = iwl_trans_alloc(sizeof(struct iwl_trans_pcie),\n\t\t\t\t\t&pdev->dev, &trans_ops_pcie_gen2);\n\telse\n\t\ttrans = iwl_trans_alloc(sizeof(struct iwl_trans_pcie),\n\t\t\t\t\t&pdev->dev, &trans_ops_pcie);\n\n\tif (!trans)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttrans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\n\ttrans_pcie->trans = trans;\n\ttrans_pcie->opmode_down = true;\n\tspin_lock_init(&trans_pcie->irq_lock);\n\tspin_lock_init(&trans_pcie->reg_lock);\n\tmutex_init(&trans_pcie->mutex);\n\tinit_waitqueue_head(&trans_pcie->ucode_write_waitq);\n\n\ttrans_pcie->rba.alloc_wq = alloc_workqueue(\"rb_allocator\",\n\t\t\t\t\t\t   WQ_HIGHPRI | WQ_UNBOUND, 1);\n\tif (!trans_pcie->rba.alloc_wq) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_trans;\n\t}\n\tINIT_WORK(&trans_pcie->rba.rx_alloc, iwl_pcie_rx_allocator_work);\n\n\ttrans_pcie->tso_hdr_page = alloc_percpu(struct iwl_tso_hdr_page);\n\tif (!trans_pcie->tso_hdr_page) {\n\t\tret = -ENOMEM;\n\t\tgoto out_no_pci;\n\t}\n\ttrans_pcie->debug_rfkill = -1;\n\n\tif (!cfg_trans->base_params->pcie_l1_allowed) {\n\t\t/*\n\t\t * W/A - seems to solve weird behavior. We need to remove this\n\t\t * if we don't want to stay in L1 all the time. This wastes a\n\t\t * lot of power.\n\t\t */\n\t\tpci_disable_link_state(pdev, PCIE_LINK_STATE_L0S |\n\t\t\t\t       PCIE_LINK_STATE_L1 |\n\t\t\t\t       PCIE_LINK_STATE_CLKPM);\n\t}\n\n\ttrans_pcie->def_rx_queue = 0;\n\n\tif (cfg_trans->use_tfh) {\n\t\taddr_size = 64;\n\t\ttrans_pcie->max_tbs = IWL_TFH_NUM_TBS;\n\t\ttrans_pcie->tfd_size = sizeof(struct iwl_tfh_tfd);\n\t} else {\n\t\taddr_size = 36;\n\t\ttrans_pcie->max_tbs = IWL_NUM_OF_TBS;\n\t\ttrans_pcie->tfd_size = sizeof(struct iwl_tfd);\n\t}\n\ttrans->max_skb_frags = IWL_PCIE_MAX_FRAGS(trans_pcie);\n\n\tpci_set_master(pdev);\n\n\tret = pci_set_dma_mask(pdev, DMA_BIT_MASK(addr_size));\n\tif (!ret)\n\t\tret = pci_set_consistent_dma_mask(pdev,\n\t\t\t\t\t\t  DMA_BIT_MASK(addr_size));\n\tif (ret) {\n\t\tret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n\t\tif (!ret)\n\t\t\tret = pci_set_consistent_dma_mask(pdev,\n\t\t\t\t\t\t\t  DMA_BIT_MASK(32));\n\t\t/* both attempts failed: */\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"No suitable DMA available\\n\");\n\t\t\tgoto out_no_pci;\n\t\t}\n\t}\n\n\tret = pcim_iomap_regions_request_all(pdev, BIT(0), DRV_NAME);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"pcim_iomap_regions_request_all failed\\n\");\n\t\tgoto out_no_pci;\n\t}\n\n\ttrans_pcie->hw_base = pcim_iomap_table(pdev)[0];\n\tif (!trans_pcie->hw_base) {\n\t\tdev_err(&pdev->dev, \"pcim_iomap_table failed\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_no_pci;\n\t}\n\n\t/* We disable the RETRY_TIMEOUT register (0x41) to keep\n\t * PCI Tx retries from interfering with C3 CPU state */\n\tpci_write_config_byte(pdev, PCI_CFG_RETRY_TIMEOUT, 0x00);\n\n\ttrans_pcie->pci_dev = pdev;\n\tiwl_disable_interrupts(trans);\n\n\ttrans->hw_rev = iwl_read32(trans, CSR_HW_REV);\n\tif (trans->hw_rev == 0xffffffff) {\n\t\tdev_err(&pdev->dev, \"HW_REV=0xFFFFFFFF, PCI issues?\\n\");\n\t\tret = -EIO;\n\t\tgoto out_no_pci;\n\t}\n\n\t/*\n\t * In the 8000 HW family the format of the 4 bytes of CSR_HW_REV have\n\t * changed, and now the revision step also includes bit 0-1 (no more\n\t * \"dash\" value). To keep hw_rev backwards compatible - we'll store it\n\t * in the old format.\n\t */\n\tif (cfg_trans->device_family >= IWL_DEVICE_FAMILY_8000) {\n\t\ttrans->hw_rev = (trans->hw_rev & 0xfff0) |\n\t\t\t\t(CSR_HW_REV_STEP(trans->hw_rev << 2) << 2);\n\n\t\tret = iwl_pcie_prepare_card_hw(trans);\n\t\tif (ret) {\n\t\t\tIWL_WARN(trans, \"Exit HW not ready\\n\");\n\t\t\tgoto out_no_pci;\n\t\t}\n\n\t\t/*\n\t\t * in-order to recognize C step driver should read chip version\n\t\t * id located at the AUX bus MISC address space.\n\t\t */\n\t\tret = iwl_finish_nic_init(trans, cfg_trans);\n\t\tif (ret)\n\t\t\tgoto out_no_pci;\n\n\t}\n\n\tIWL_DEBUG_INFO(trans, \"HW REV: 0x%0x\\n\", trans->hw_rev);\n\n\tiwl_pcie_set_interrupt_capa(pdev, trans, cfg_trans);\n\ttrans->hw_id = (pdev->device << 16) + pdev->subsystem_device;\n\tsnprintf(trans->hw_id_str, sizeof(trans->hw_id_str),\n\t\t \"PCI ID: 0x%04X:0x%04X\", pdev->device, pdev->subsystem_device);\n\n\t/* Initialize the wait queue for commands */\n\tinit_waitqueue_head(&trans_pcie->wait_command_queue);\n\n\tinit_waitqueue_head(&trans_pcie->sx_waitq);\n\n\tif (trans_pcie->msix_enabled) {\n\t\tret = iwl_pcie_init_msix_handler(pdev, trans_pcie);\n\t\tif (ret)\n\t\t\tgoto out_no_pci;\n\t } else {\n\t\tret = iwl_pcie_alloc_ict(trans);\n\t\tif (ret)\n\t\t\tgoto out_no_pci;\n\n\t\tret = devm_request_threaded_irq(&pdev->dev, pdev->irq,\n\t\t\t\t\t\tiwl_pcie_isr,\n\t\t\t\t\t\tiwl_pcie_irq_handler,\n\t\t\t\t\t\tIRQF_SHARED, DRV_NAME, trans);\n\t\tif (ret) {\n\t\t\tIWL_ERR(trans, \"Error allocating IRQ %d\\n\", pdev->irq);\n\t\t\tgoto out_free_ict;\n\t\t}\n\t\ttrans_pcie->inta_mask = CSR_INI_SET_MASK;\n\t }\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\ttrans_pcie->fw_mon_data.state = IWL_FW_MON_DBGFS_STATE_CLOSED;\n\tmutex_init(&trans_pcie->fw_mon_data.mutex);\n#endif\n\n\treturn trans;\n\nout_free_ict:\n\tiwl_pcie_free_ict(trans);\nout_no_pci:\n\tfree_percpu(trans_pcie->tso_hdr_page);\n\tdestroy_workqueue(trans_pcie->rba.alloc_wq);\nout_free_trans:\n\tiwl_trans_free(trans);\n\treturn ERR_PTR(ret);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 592,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n\n    //if (block->host) {\n    //    ram_block_notify_remove(block->host, block->max_length);\n    //}\n\n    QLIST_REMOVE_RCU(block, next);\n    uc->ram_list.mru_block = NULL;\n    /* Write list before version */\n    //smp_wmb();\n    // call_rcu(block, reclaim_ramblock, rcu);\n    reclaim_ramblock(uc, block);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 610,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "void jfs_evict_inode(struct inode *inode)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\n\tjfs_info(\"In jfs_evict_inode, inode = 0x%p\", inode);\n\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\tdquot_initialize(inode);\n\n\t\tif (JFS_IP(inode)->fileset == FILESYSTEM_I) {\n\t\t\tstruct inode *ipimap = JFS_SBI(inode->i_sb)->ipimap;\n\t\t\ttruncate_inode_pages_final(&inode->i_data);\n\n\t\t\tif (test_cflag(COMMIT_Freewmap, inode))\n\t\t\t\tjfs_free_zero_link(inode);\n\n\t\t\tif (ipimap && JFS_IP(ipimap)->i_imap)\n\t\t\t\tdiFree(inode);\n\n\t\t\t/*\n\t\t\t * Free the inode from the quota allocation.\n\t\t\t */\n\t\t\tdquot_free_inode(inode);\n\t\t}\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t}\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\n\tBUG_ON(!list_empty(&ji->anon_inode_list));\n\n\tspin_lock_irq(&ji->ag_lock);\n\tif (ji->active_ag != -1) {\n\t\tstruct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;\n\t\tatomic_dec(&bmap->db_active[ji->active_ag]);\n\t\tji->active_ag = -1;\n\t}\n\tspin_unlock_irq(&ji->ag_lock);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 662,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": " */\nstatic void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t**pce;\n\tzval\t\t\t\t*obj;\n\tzval\t\t\t\t*tmp;\n\tTSRMLS_FETCH();\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||\n\t\t!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||\n\t  \t!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||\n\t\t!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||\n\t\t!strcmp(name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (!ent1->data) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp(name, EL_BINARY)) {\n\t\t\tint new_len=0;\n\t\t\tunsigned char *new_str;\n\n\t\t\tnew_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);\n\t\t\tSTR_FREE(Z_STRVAL_P(ent1->data));\n\t\t\tif (new_str) {\n\t\t\t\tZ_STRVAL_P(ent1->data) = new_str;\n\t\t\t\tZ_STRLEN_P(ent1->data) = new_len;\n\t\t\t} else {\n\t\t\t\tZVAL_EMPTY_STRING(ent1->data);\n\t\t\t}\n\t\t}\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE_P(ent1->data) == IS_OBJECT) {\n\t\t\tzval *fname, *retval = NULL;\n\n\t\t\tMAKE_STD_ZVAL(fname);\n\t\t\tZVAL_STRING(fname, \"__wakeup\", 1);\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);\n\n\t\t\tzval_dtor(fname);\n\t\t\tFREE_ZVAL(fname);\n\t\t\tif (retval) {\n\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t}\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (ent2->type == ST_FIELD && ent2->data == NULL) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\tif (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),\n\t\t\t\t\t\t\t\t\t\t   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = &PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n\t\t\t\t\t\tobject_init_ex(obj, *pce);\n\n\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n\n\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\tent2->data = obj;\n\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE_P(ent2->data);\n\t\t\t\t\t\tZ_DELREF_P(ent1->data);\n\t\t\t\t\t\tadd_property_zval(ent2->data, ent1->varname, ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp(name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 728,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int ax25_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tax25_cb *ax25;\n\tax25_dev *ax25_dev;\n\n\tif (sk == NULL)\n\t\treturn 0;\n\n\tsock_hold(sk);\n\tlock_sock(sk);\n\tsock_orphan(sk);\n\tax25 = sk_to_ax25(sk);\n\tax25_dev = ax25->ax25_dev;\n\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\tswitch (ax25->state) {\n\t\tcase AX25_STATE_0:\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(ax25, 0);\n\t\t\tlock_sock(sk);\n\t\t\tax25_destroy_socket(ax25);\n\t\t\tbreak;\n\n\t\tcase AX25_STATE_1:\n\t\tcase AX25_STATE_2:\n\t\t\tax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(ax25, 0);\n\t\t\tlock_sock(sk);\n\t\t\tif (!sock_flag(ax25->sk, SOCK_DESTROY))\n\t\t\t\tax25_destroy_socket(ax25);\n\t\t\tbreak;\n\n\t\tcase AX25_STATE_3:\n\t\tcase AX25_STATE_4:\n\t\t\tax25_clear_queues(ax25);\n\t\t\tax25->n2count = 0;\n\n\t\t\tswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\n\t\t\tcase AX25_PROTO_STD_SIMPLEX:\n\t\t\tcase AX25_PROTO_STD_DUPLEX:\n\t\t\t\tax25_send_control(ax25,\n\t\t\t\t\t\t  AX25_DISC,\n\t\t\t\t\t\t  AX25_POLLON,\n\t\t\t\t\t\t  AX25_COMMAND);\n\t\t\t\tax25_stop_t2timer(ax25);\n\t\t\t\tax25_stop_t3timer(ax25);\n\t\t\t\tax25_stop_idletimer(ax25);\n\t\t\t\tbreak;\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\t\t\tcase AX25_PROTO_DAMA_SLAVE:\n\t\t\t\tax25_stop_t3timer(ax25);\n\t\t\t\tax25_stop_idletimer(ax25);\n\t\t\t\tbreak;\n#endif\n\t\t\t}\n\t\t\tax25_calculate_t1(ax25);\n\t\t\tax25_start_t1timer(ax25);\n\t\t\tax25->state = AX25_STATE_2;\n\t\t\tsk->sk_state                = TCP_CLOSE;\n\t\t\tsk->sk_shutdown            |= SEND_SHUTDOWN;\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsock_set_flag(sk, SOCK_DESTROY);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tsk->sk_state     = TCP_CLOSE;\n\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tsk->sk_state_change(sk);\n\t\tax25_destroy_socket(ax25);\n\t}\n\tif (ax25_dev) {\n\t\tdel_timer_sync(&ax25->timer);\n\t\tdel_timer_sync(&ax25->t1timer);\n\t\tdel_timer_sync(&ax25->t2timer);\n\t\tdel_timer_sync(&ax25->t3timer);\n\t\tdel_timer_sync(&ax25->idletimer);\n\t\tdev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);\n\t\tax25_dev_put(ax25_dev);\n\t}\n\n\tsock->sk   = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 740,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "static int qh_help(int sd, char *buf, unsigned int len)\n{\n\tstruct query_handler *qh = NULL;\n\n\tif (buf == NULL || !strcmp(buf, \"help\")) {\n\t\tnsock_printf_nul(sd,\n\t\t\t\"  help <name>   show help for handler <name>\\n\"\n\t\t\t\"  help list     list registered handlers\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(buf, \"list\")) {\n\n\t\tfor (qh = qhandlers; qh != NULL; qh = qh->next_qh) {\n\t\t\tnsock_printf(sd, \"%-10s %s\\n\", qh->name, qh->description ? qh->description : \"(No description available)\");\n\t\t}\n\n\t\tnsock_printf(sd, \"%c\", 0);\n\t\treturn 0;\n\t}\n\n\tqh = qh_find_handler(buf);\n\tif (qh == NULL) {\n\n\t\tnsock_printf_nul(sd, \"No handler named '%s' is registered\\n\", buf);\n\n\t} else if (qh->handler(sd, \"help\", 4) > 200) {\n\n\t\tnsock_printf_nul(sd, \"The handler %s doesn't have any help yet.\", buf);\n\t}\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 776,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "pax_decode_header (struct tar_sparse_file *file)\n{\n  if (file->stat_info->sparse_major > 0)\n    {\n      uintmax_t u;\n      char nbuf[UINTMAX_STRSIZE_BOUND];\n      union block *blk;\n      char *p;\n      size_t i;\n      off_t start;\n      \n#define COPY_BUF(b,buf,src) do                                     \\\n {                                                                 \\\n   char *endp = b->buffer + BLOCKSIZE;                             \\\n   char *dst = buf;                                                \\\n   do                                                              \\\n     {                                                             \\\n       if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \\\n         {                                                         \\\n           ERROR ((0, 0, _(\"%s: numeric overflow in sparse archive member\"), \\\n\t          file->stat_info->orig_file_name));               \\\n           return false;                                           \\\n         }                                                         \\\n       if (src == endp)                                            \\\n\t {                                                         \\\n\t   set_next_block_after (b);                               \\\n           b = find_next_block ();                                 \\\n           if (!b)                                                 \\\n             FATAL_ERROR ((0, 0, _(\"Unexpected EOF in archive\"))); \\\n           src = b->buffer;                                        \\\n\t   endp = b->buffer + BLOCKSIZE;                           \\\n\t }                                                         \\\n       *dst = *src++;                                              \\\n     }                                                             \\\n   while (*dst++ != '\\n');                                         \\\n   dst[-1] = 0;                                                    \\\n } while (0)\n\n      start = current_block_ordinal ();\n      set_next_block_after (current_header);\n      blk = find_next_block ();\n      if (!blk)\n        FATAL_ERROR ((0, 0, _(\"Unexpected EOF in archive\")));\n      p = blk->buffer;\n      COPY_BUF (blk,nbuf,p);\n      if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))\n\t{\n\t  ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t  file->stat_info->orig_file_name));\n\t  return false;\n\t}\n      file->stat_info->sparse_map_size = u;\n      file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,\n\t\t\t\t\t     sizeof (*file->stat_info->sparse_map));\n      file->stat_info->sparse_map_avail = 0;\n      for (i = 0; i < file->stat_info->sparse_map_size; i++)\n\t{\n\t  struct sp_array sp;\n\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.offset = u;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.numbytes = u;\n\t  sparse_add_map (file->stat_info, &sp);\n\t}\n      set_next_block_after (blk);\n\n      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);\n    }\n\n  return true;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 804,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "int setup_tests(void)\n{\n    ADD_ALL_TESTS(call_run_cert, OSSL_NELEM(name_fns));\n    ADD_TEST(test_GENERAL_NAME_cmp);\n    return 1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 820,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-476"
    ],
    "code": "bool st_select_lex::optimize_unflattened_subqueries(bool const_only)\n{\n  SELECT_LEX_UNIT *next_unit= NULL;\n  for (SELECT_LEX_UNIT *un= first_inner_unit();\n       un;\n       un= next_unit ? next_unit : un->next_unit())\n  {\n    Item_subselect *subquery_predicate= un->item;\n    next_unit= NULL;\n\n    if (subquery_predicate)\n    {\n      if (!subquery_predicate->fixed)\n      {\n\t/*\n\t This subquery was excluded as part of some expression so it is\n\t invisible from all prepared expression.\n       */\n\tnext_unit= un->next_unit();\n\tun->exclude_level();\n\tif (next_unit)\n\t  continue;\n\tbreak;\n      }\n      if (subquery_predicate->substype() == Item_subselect::IN_SUBS)\n      {\n        Item_in_subselect *in_subs= (Item_in_subselect*) subquery_predicate;\n        if (in_subs->is_jtbm_merged)\n          continue;\n      }\n\n      if (const_only && !subquery_predicate->const_item())\n      {\n        /* Skip non-constant subqueries if the caller asked so. */\n        continue;\n      }\n\n      bool empty_union_result= true;\n      bool is_correlated_unit= false;\n      bool first= true;\n      bool union_plan_saved= false;\n      /*\n        If the subquery is a UNION, optimize all the subqueries in the UNION. If\n        there is no UNION, then the loop will execute once for the subquery.\n      */\n      for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n      {\n        JOIN *inner_join= sl->join;\n        if (first)\n          first= false;\n        else\n        {\n          if (!union_plan_saved)\n          {\n            union_plan_saved= true;\n            if (un->save_union_explain(un->thd->lex->explain))\n              return true; /* Failure */\n          }\n        }\n        if (!inner_join)\n          continue;\n        SELECT_LEX *save_select= un->thd->lex->current_select;\n        ulonglong save_options;\n        int res;\n        /* We need only 1 row to determine existence */\n        un->set_limit(un->global_parameters());\n        un->thd->lex->current_select= sl;\n        save_options= inner_join->select_options;\n        if (options & SELECT_DESCRIBE)\n        {\n          /* Optimize the subquery in the context of EXPLAIN. */\n          sl->set_explain_type(FALSE);\n          sl->options|= SELECT_DESCRIBE;\n          inner_join->select_options|= SELECT_DESCRIBE;\n        }\n        if ((res= inner_join->optimize()))\n          return TRUE;\n        if (!inner_join->cleaned)\n          sl->update_used_tables();\n        sl->update_correlated_cache();\n        is_correlated_unit|= sl->is_correlated;\n        inner_join->select_options= save_options;\n        un->thd->lex->current_select= save_select;\n\n        Explain_query *eq;\n        if ((eq= inner_join->thd->lex->explain))\n        {\n          Explain_select *expl_sel;\n          if ((expl_sel= eq->get_select(inner_join->select_lex->select_number)))\n          {\n            sl->set_explain_type(TRUE);\n            expl_sel->select_type= sl->type;\n          }\n        }\n\n        if (empty_union_result)\n        {\n          /*\n            If at least one subquery in a union is non-empty, the UNION result\n            is non-empty. If there is no UNION, the only subquery is non-empy.\n          */\n          empty_union_result= inner_join->empty_result();\n        }\n        if (res)\n          return TRUE;\n      }\n      if (empty_union_result)\n        subquery_predicate->no_rows_in_result();\n\n      if (is_correlated_unit)\n      {\n        /*\n          Some parts of UNION are not correlated. This means we will need to\n          re-execute the whole UNION every time. Mark all parts of the UNION\n          as correlated so that they are prepared to be executed multiple\n          times (if we don't do that, some part of the UNION may free its\n          execution data at the end of first execution and crash on the second\n          execution)\n        */\n        for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n          sl->uncacheable |= UNCACHEABLE_DEPENDENT;\n      }\n      else\n        un->uncacheable&= ~UNCACHEABLE_DEPENDENT;\n      subquery_predicate->is_correlated= is_correlated_unit;\n    }\n  }\n  return FALSE;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 824,
    "RELATED_CWE": [
      "CWE-416",
      "CWE-415",
      "CWE-457"
    ]
  }
]