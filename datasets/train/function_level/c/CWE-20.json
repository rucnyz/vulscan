[
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " pdf_show_image(fz_context *ctx, pdf_run_processor *pr, fz_image *image)\n {\n        pdf_gstate *gstate = pr->gstate + pr->gtop;\n        fz_matrix image_ctm;\n        fz_rect bbox;\n       softmask_save softmask = { NULL };\n \n        if (pr->super.hidden)\n                return;\n\t\t\tbreak;\n\t\tcase PDF_MAT_SHADE:\n\t\t\tif (gstate->fill.shade)\n\t\t\t{\n\t\t\t\tfz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);\n        bbox = fz_unit_rect;\n        fz_transform_rect(&bbox, &image_ctm);\n \n       if (image->mask)\n        {\n                /* apply blend group even though we skip the soft mask */\n               if (gstate->blendmode)\n                       fz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 0, gstate->blendmode, 1);\n               fz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);\n       }\n       else\n               gstate = pdf_begin_group(ctx, pr, &bbox, &softmask);\n \n       if (!image->colorspace)\n       {\n               switch (gstate->fill.kind)\n                {\n               case PDF_MAT_NONE:\n                       break;\n               case PDF_MAT_COLOR:\n                       fz_fill_image_mask(ctx, pr->dev, image, &image_ctm,\n                               gstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);\n                       break;\n               case PDF_MAT_PATTERN:\n                       if (gstate->fill.pattern)\n                       {\n                               fz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);\n                               pdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], &bbox, PDF_FILL);\n                               fz_pop_clip(ctx, pr->dev);\n                       }\n                       break;\n               case PDF_MAT_SHADE:\n                       if (gstate->fill.shade)\n                       {\n                               fz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);\n                               fz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);\n                               fz_pop_clip(ctx, pr->dev);\n                       }\n                       break;\n                }\n        }\n       else\n        {\n               fz_fill_image(ctx, pr->dev, image, &image_ctm, gstate->fill.alpha, &gstate->fill.color_params);\n        }\n       if (image->mask)\n        {\n               fz_pop_clip(ctx, pr->dev);\n               if (gstate->blendmode)\n                       fz_end_group(ctx, pr->dev);\n        }\n       else\n               pdf_end_group(ctx, pr, &softmask);\n }\n \n static void\n\n\t\tif (pr->clip)\n\t\t{\n\t\t\tgstate->clip_depth++;\n\t\t\tfz_clip_path(ctx, pr->dev, path, pr->clip_even_odd, &gstate->ctm, &bbox);\n\t\t\tpr->clip = 0;\n\t\t}\n\n\t\tif (pr->super.hidden)\n\t\t\tdostroke = dofill = 0;\n\n\t\tif (dofill || dostroke)\n\t\t\tgstate = pdf_begin_group(ctx, pr, &bbox, &softmask);\n\n\t\tif (dofill && dostroke)\n\t\t{\n\t\t\t/* We may need to push a knockout group */\n\t\t\tif (gstate->stroke.alpha == 0)\n\t\t\t{\n\t\t\t\t/* No need for group, as stroke won't do anything */\n\t\t\t}\n\t\t\telse if (gstate->stroke.alpha == 1.0f && gstate->blendmode == FZ_BLEND_NORMAL)\n\t\t\t{\n\t\t\t\t/* No need for group, as stroke won't show up */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tknockout_group = 1;\n\t\t\t\tfz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 1, FZ_BLEND_NORMAL, 1);\n\t\t\t}\n\t\t}\n\n\t\tif (dofill)\n\t\t{\n\t\t\tswitch (gstate->fill.kind)\n\t\t\t{\n\t\t\tcase PDF_MAT_NONE:\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_COLOR:\n\t\t\t\tfz_fill_path(ctx, pr->dev, path, even_odd, &gstate->ctm,\n\t\t\t\t\tgstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_PATTERN:\n\t\t\t\tif (gstate->fill.pattern)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_path(ctx, pr->dev, path, even_odd, &gstate->ctm, &bbox);\n\t\t\t\t\tpdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], &bbox, PDF_FILL);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_SHADE:\n\t\t\t\tif (gstate->fill.shade)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_path(ctx, pr->dev, path, even_odd, &gstate->ctm, &bbox);\n\t\t\t\t\t/* The cluster and page 2 of patterns.pdf shows that fz_fill_shade should NOT be called with gstate->ctm. */\n\t\t\t\t\tfz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (dostroke)\n\t\t{\n\t\t\tswitch (gstate->stroke.kind)\n\t\t\t{\n\t\t\tcase PDF_MAT_NONE:\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_COLOR:\n\t\t\t\tfz_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm,\n\t\t\t\t\tgstate->stroke.colorspace, gstate->stroke.v, gstate->stroke.alpha, &gstate->stroke.color_params);\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_PATTERN:\n\t\t\t\tif (gstate->stroke.pattern)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm, &bbox);\n\t\t\t\t\tpdf_show_pattern(ctx, pr, gstate->stroke.pattern, &pr->gstate[gstate->stroke.gstate_num], &bbox, PDF_STROKE);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_SHADE:\n\t\t\t\tif (gstate->stroke.shade)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm, &bbox);\n\t\t\t\t\tfz_fill_shade(ctx, pr->dev, gstate->stroke.shade, &pr->gstate[gstate->stroke.gstate_num].ctm, gstate->stroke.alpha, &gstate->stroke.color_params);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (knockout_group)\n\t\t\tfz_end_group(ctx, pr->dev);\n\n\t\tif (dofill || dostroke)\n\t\t\tpdf_end_group(ctx, pr, &softmask);\n\t}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141353,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " pdf_show_image(fz_context *ctx, pdf_run_processor *pr, fz_image *image)\n {\n        pdf_gstate *gstate = pr->gstate + pr->gtop;\n        fz_matrix image_ctm;\n        fz_rect bbox;\n \n        if (pr->super.hidden)\n                return;\n\t\t\tbreak;\n\t\tcase PDF_MAT_SHADE:\n\t\t\tif (gstate->fill.shade)\n\t\t\t{\n\t\t\t\tfz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);\n        bbox = fz_unit_rect;\n        fz_transform_rect(&bbox, &image_ctm);\n \n       if (image->mask && gstate->blendmode)\n        {\n                /* apply blend group even though we skip the soft mask */\n               fz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 0, gstate->blendmode, 1);\n \n               fz_try(ctx)\n                       fz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);\n               fz_catch(ctx)\n                {\n                       fz_end_group(ctx, pr->dev);\n                       fz_rethrow(ctx);\n                }\n\n               fz_try(ctx)\n                       pdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox);\n               fz_always(ctx)\n               {\n                       fz_pop_clip(ctx, pr->dev);\n                       fz_end_group(ctx, pr->dev);\n               }\n               fz_catch(ctx)\n                       fz_rethrow(ctx);\n        }\n       else if (image->mask)\n        {\n               fz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);\n               fz_try(ctx)\n                       pdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox);\n               fz_always(ctx)\n                       fz_pop_clip(ctx, pr->dev);\n               fz_catch(ctx)\n                       fz_rethrow(ctx);\n        }\n       else\n        {\n               softmask_save softmask = { NULL };\n\n               gstate = pdf_begin_group(ctx, pr, &bbox, &softmask);\n\n               fz_try(ctx)\n                       pdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox);\n               fz_always(ctx)\n                       pdf_end_group(ctx, pr, &softmask);\n               fz_catch(ctx)\n                       fz_rethrow(ctx);\n        }\n }\n \n static void\n\n\t\tif (pr->clip)\n\t\t{\n\t\t\tgstate->clip_depth++;\n\t\t\tfz_clip_path(ctx, pr->dev, path, pr->clip_even_odd, &gstate->ctm, &bbox);\n\t\t\tpr->clip = 0;\n\t\t}\n\n\t\tif (pr->super.hidden)\n\t\t\tdostroke = dofill = 0;\n\n\t\tif (dofill || dostroke)\n\t\t\tgstate = pdf_begin_group(ctx, pr, &bbox, &softmask);\n\n\t\tif (dofill && dostroke)\n\t\t{\n\t\t\t/* We may need to push a knockout group */\n\t\t\tif (gstate->stroke.alpha == 0)\n\t\t\t{\n\t\t\t\t/* No need for group, as stroke won't do anything */\n\t\t\t}\n\t\t\telse if (gstate->stroke.alpha == 1.0f && gstate->blendmode == FZ_BLEND_NORMAL)\n\t\t\t{\n\t\t\t\t/* No need for group, as stroke won't show up */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tknockout_group = 1;\n\t\t\t\tfz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 1, FZ_BLEND_NORMAL, 1);\n\t\t\t}\n\t\t}\n\n\t\tif (dofill)\n\t\t{\n\t\t\tswitch (gstate->fill.kind)\n\t\t\t{\n\t\t\tcase PDF_MAT_NONE:\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_COLOR:\n\t\t\t\tfz_fill_path(ctx, pr->dev, path, even_odd, &gstate->ctm,\n\t\t\t\t\tgstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_PATTERN:\n\t\t\t\tif (gstate->fill.pattern)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_path(ctx, pr->dev, path, even_odd, &gstate->ctm, &bbox);\n\t\t\t\t\tpdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], &bbox, PDF_FILL);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_SHADE:\n\t\t\t\tif (gstate->fill.shade)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_path(ctx, pr->dev, path, even_odd, &gstate->ctm, &bbox);\n\t\t\t\t\t/* The cluster and page 2 of patterns.pdf shows that fz_fill_shade should NOT be called with gstate->ctm. */\n\t\t\t\t\tfz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (dostroke)\n\t\t{\n\t\t\tswitch (gstate->stroke.kind)\n\t\t\t{\n\t\t\tcase PDF_MAT_NONE:\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_COLOR:\n\t\t\t\tfz_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm,\n\t\t\t\t\tgstate->stroke.colorspace, gstate->stroke.v, gstate->stroke.alpha, &gstate->stroke.color_params);\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_PATTERN:\n\t\t\t\tif (gstate->stroke.pattern)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm, &bbox);\n\t\t\t\t\tpdf_show_pattern(ctx, pr, gstate->stroke.pattern, &pr->gstate[gstate->stroke.gstate_num], &bbox, PDF_STROKE);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_SHADE:\n\t\t\t\tif (gstate->stroke.shade)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm, &bbox);\n\t\t\t\t\tfz_fill_shade(ctx, pr->dev, gstate->stroke.shade, &pr->gstate[gstate->stroke.gstate_num].ctm, gstate->stroke.alpha, &gstate->stroke.color_params);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (knockout_group)\n\t\t\tfz_end_group(ctx, pr->dev);\n\n\t\tif (dofill || dostroke)\n\t\t\tpdf_end_group(ctx, pr, &softmask);\n\t}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141354,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool extractPages (const char *srcFileName, const char *destFileName) {\n  char pathName[4096];\n  GooString *gfileName = new GooString (srcFileName);\n  PDFDoc *doc = new PDFDoc (gfileName, NULL, NULL, NULL);\n\n  if (!doc->isOk()) {\n    error(errSyntaxError, -1, \"Could not extract page(s) from damaged file ('{0:s}')\", srcFileName);\n    return false;\n  }\n\n  if (firstPage == 0 && lastPage == 0) {\n    firstPage = 1;\n    lastPage = doc->getNumPages();\n  }\n  if (lastPage == 0)\n    lastPage = doc->getNumPages();\n  if (firstPage == 0)\n   if (firstPage == 0)\n     firstPage = 1;\n   if (firstPage != lastPage && strstr(destFileName, \"%d\") == NULL) {\n    error(errSyntaxError, -1, \"'{0:s}' must contain '%%d' if more than one page should be extracted\", destFileName);\n     return false;\n   }\n   for (int pageNo = firstPage; pageNo <= lastPage; pageNo++) {\n     snprintf (pathName, sizeof (pathName) - 1, destFileName, pageNo);\n     GooString *gpageName = new GooString (pathName);\n\t{\n\t  printUsage (\"pdfseparate\", \"<PDF-sourcefile> <PDF-pattern-destfile>\",\n\t\t      argDesc);\n\t}\n      if (printVersion || printHelp)\n\texitCode = 0;\n      goto err0;\n    }\n  globalParams = new GlobalParams();\n  ok = extractPages (argv[1], argv[2]);\n  if (ok) {\n    exitCode = 0;\n  }\n  delete globalParams;\n\nerr0:\n\n  return exitCode;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141375,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool extractPages (const char *srcFileName, const char *destFileName) {\n  char pathName[4096];\n  GooString *gfileName = new GooString (srcFileName);\n  PDFDoc *doc = new PDFDoc (gfileName, NULL, NULL, NULL);\n\n  if (!doc->isOk()) {\n    error(errSyntaxError, -1, \"Could not extract page(s) from damaged file ('{0:s}')\", srcFileName);\n    return false;\n  }\n\n  if (firstPage == 0 && lastPage == 0) {\n    firstPage = 1;\n    lastPage = doc->getNumPages();\n  }\n  if (lastPage == 0)\n    lastPage = doc->getNumPages();\n  if (firstPage == 0)\n   if (firstPage == 0)\n     firstPage = 1;\n   if (firstPage != lastPage && strstr(destFileName, \"%d\") == NULL) {\n    error(errSyntaxError, -1, \"'{0:s}' must contain '%d' if more than one page should be extracted\", destFileName);\n     return false;\n   }\n  \n  // destFileName can have multiple %% and one %d\n  // We use auxDestFileName to replace all the valid % appearances\n  // by 'A' (random char that is not %), if at the end of replacing\n  // any of the valid appearances there is still any % around, the\n  // pattern is wrong\n  char *auxDestFileName = strdup(destFileName);\n  // %% can appear as many times as you want\n  char *p = strstr(auxDestFileName, \"%%\");\n  while (p != NULL) {\n    *p = 'A';\n    *(p + 1) = 'A';\n    p = strstr(p, \"%%\"); \n  }\n  // %d can appear only one time\n  p = strstr(auxDestFileName, \"%d\");\n  if (p != NULL) {\n    *p = 'A';\n  }\n  // at this point any other % is wrong\n  p = strstr(auxDestFileName, \"%\");\n  if (p != NULL) {\n    error(errSyntaxError, -1, \"'{0:s}' can only contain one '%d' pattern\", destFileName);\n    free(auxDestFileName);\n    return false;\n  }\n  free(auxDestFileName);\n  \n   for (int pageNo = firstPage; pageNo <= lastPage; pageNo++) {\n     snprintf (pathName, sizeof (pathName) - 1, destFileName, pageNo);\n     GooString *gpageName = new GooString (pathName);\n\t{\n\t  printUsage (\"pdfseparate\", \"<PDF-sourcefile> <PDF-pattern-destfile>\",\n\t\t      argDesc);\n\t}\n      if (printVersion || printHelp)\n\texitCode = 0;\n      goto err0;\n    }\n  globalParams = new GlobalParams();\n  ok = extractPages (argv[1], argv[2]);\n  if (ok) {\n    exitCode = 0;\n  }\n  delete globalParams;\n\nerr0:\n\n  return exitCode;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141376,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " _dbus_header_byteswap (DBusHeader *header,\n                        int         new_order)\n {\n   if (header->byte_order == new_order)\n     return;\n \n   _dbus_marshal_byteswap (&_dbus_header_signature_str,\n                           0, header->byte_order,\n                           new_order,\n                           &header->data, 0);\n \n   header->byte_order = new_order;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141393,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " _dbus_header_byteswap (DBusHeader *header,\n                        int         new_order)\n {\n  unsigned char byte_order;\n\n   if (header->byte_order == new_order)\n     return;\n \n  byte_order = _dbus_string_get_byte (&header->data, BYTE_ORDER_OFFSET);\n  _dbus_assert (header->byte_order == byte_order);\n\n   _dbus_marshal_byteswap (&_dbus_header_signature_str,\n                           0, header->byte_order,\n                           new_order,\n                           &header->data, 0);\n \n  _dbus_string_set_byte (&header->data, BYTE_ORDER_OFFSET, new_order);\n   header->byte_order = new_order;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141394,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "dbus_g_proxy_manager_filter (DBusConnection    *connection,\n                             DBusMessage       *message,\n                             void              *user_data)\n{\n  DBusGProxyManager *manager;\n  \n  if (dbus_message_get_type (message) != DBUS_MESSAGE_TYPE_SIGNAL)\n    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n\n  manager = user_data;\n\n  dbus_g_proxy_manager_ref (manager);\n  \n  LOCK_MANAGER (manager);\n  \n  if (dbus_message_is_signal (message,\n                              DBUS_INTERFACE_LOCAL,\n                              \"Disconnected\"))\n    {\n      /* Destroy all the proxies, quite possibly resulting in unreferencing\n       * the proxy manager and the connection as well.\n       */\n      GSList *all;\n      GSList *tmp;\n\n      all = dbus_g_proxy_manager_list_all (manager);\n\n      tmp = all;\n      while (tmp != NULL)\n        {\n          DBusGProxy *proxy;\n\n          proxy = DBUS_G_PROXY (tmp->data);\n\n          UNLOCK_MANAGER (manager);\n          dbus_g_proxy_destroy (proxy);\n          g_object_unref (G_OBJECT (proxy));\n          LOCK_MANAGER (manager);\n          \n          tmp = tmp->next;\n        }\n\n      g_slist_free (all);\n\n#ifndef G_DISABLE_CHECKS\n      if (manager->proxy_lists != NULL)\n        g_warning (\"Disconnection emitted \\\"destroy\\\" on all DBusGProxy, but somehow new proxies were created in response to one of those destroy signals. This will cause a memory leak.\");\n#endif\n    }\n  else\n    {\n      char *tri;\n      GSList *full_list;\n      GSList *owned_names;\n       GSList *tmp;\n       const char *sender;\n \n       /* First we handle NameOwnerChanged internally */\n      if (dbus_message_is_signal (message,\n \t\t\t\t  DBUS_INTERFACE_DBUS,\n \t\t\t\t  \"NameOwnerChanged\"))\n \t{\n\t  DBusError derr;\n\n\t  dbus_error_init (&derr);\n\t  if (!dbus_message_get_args (message,\n\t\t\t\t      &derr,\n\t\t\t\t      DBUS_TYPE_STRING,\n\t\t\t\t      &name,\n\t\t\t\t      DBUS_TYPE_STRING,\n\t\t\t\t      &prev_owner,\n\t\t\t\t      DBUS_TYPE_STRING,\n\t\t\t\t      &new_owner,\n\t\t\t\t      DBUS_TYPE_INVALID))\n\t    {\n\t      /* Ignore this error */\n\t      dbus_error_free (&derr);\n\t    }\n\t  else if (manager->owner_names != NULL)\n\t    {\n\t      dbus_g_proxy_manager_replace_name_owner (manager, name, prev_owner, new_owner);\n\t    }\n\t}\n\n \t    }\n \t}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141441,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "dbus_g_proxy_manager_filter (DBusConnection    *connection,\n                             DBusMessage       *message,\n                             void              *user_data)\n{\n  DBusGProxyManager *manager;\n  \n  if (dbus_message_get_type (message) != DBUS_MESSAGE_TYPE_SIGNAL)\n    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n\n  manager = user_data;\n\n  dbus_g_proxy_manager_ref (manager);\n  \n  LOCK_MANAGER (manager);\n  \n  if (dbus_message_is_signal (message,\n                              DBUS_INTERFACE_LOCAL,\n                              \"Disconnected\"))\n    {\n      /* Destroy all the proxies, quite possibly resulting in unreferencing\n       * the proxy manager and the connection as well.\n       */\n      GSList *all;\n      GSList *tmp;\n\n      all = dbus_g_proxy_manager_list_all (manager);\n\n      tmp = all;\n      while (tmp != NULL)\n        {\n          DBusGProxy *proxy;\n\n          proxy = DBUS_G_PROXY (tmp->data);\n\n          UNLOCK_MANAGER (manager);\n          dbus_g_proxy_destroy (proxy);\n          g_object_unref (G_OBJECT (proxy));\n          LOCK_MANAGER (manager);\n          \n          tmp = tmp->next;\n        }\n\n      g_slist_free (all);\n\n#ifndef G_DISABLE_CHECKS\n      if (manager->proxy_lists != NULL)\n        g_warning (\"Disconnection emitted \\\"destroy\\\" on all DBusGProxy, but somehow new proxies were created in response to one of those destroy signals. This will cause a memory leak.\");\n#endif\n    }\n  else\n    {\n      char *tri;\n      GSList *full_list;\n      GSList *owned_names;\n       GSList *tmp;\n       const char *sender;\n \n      sender = dbus_message_get_sender (message);\n\n       /* First we handle NameOwnerChanged internally */\n      if (g_strcmp0 (sender, DBUS_SERVICE_DBUS) == 0 &&\n\t  dbus_message_is_signal (message,\n \t\t\t\t  DBUS_INTERFACE_DBUS,\n \t\t\t\t  \"NameOwnerChanged\"))\n \t{\n\t  DBusError derr;\n\n\t  dbus_error_init (&derr);\n\t  if (!dbus_message_get_args (message,\n\t\t\t\t      &derr,\n\t\t\t\t      DBUS_TYPE_STRING,\n\t\t\t\t      &name,\n\t\t\t\t      DBUS_TYPE_STRING,\n\t\t\t\t      &prev_owner,\n\t\t\t\t      DBUS_TYPE_STRING,\n\t\t\t\t      &new_owner,\n\t\t\t\t      DBUS_TYPE_INVALID))\n\t    {\n\t      /* Ignore this error */\n\t      dbus_error_free (&derr);\n\t    }\n\t  else if (manager->owner_names != NULL)\n\t    {\n\t      dbus_g_proxy_manager_replace_name_owner (manager, name, prev_owner, new_owner);\n\t    }\n\t}\n\n \t    }\n \t}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141442,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void get_socket_name(SingleInstData* data, char* buf, int len)\n{\n    const char* dpy = g_getenv(\"DISPLAY\");\n    char* host = NULL;\n    int dpynum;\n    if(dpy)\n    {\n        const char* p = strrchr(dpy, ':');\n        host = g_strndup(dpy, (p - dpy));\n        dpynum = atoi(p + 1);\n     }\n     else\n         dpynum = 0;\n     g_snprintf(buf, len, \"%s/.%s-socket-%s-%d-%s\",\n                 g_get_tmp_dir(),\n                 data->prog_name,\n                 host ? host : \"\",\n                 dpynum,\n                 g_get_user_name());\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141451,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void get_socket_name(SingleInstData* data, char* buf, int len)\n{\n    const char* dpy = g_getenv(\"DISPLAY\");\n    char* host = NULL;\n    int dpynum;\n    if(dpy)\n    {\n        const char* p = strrchr(dpy, ':');\n        host = g_strndup(dpy, (p - dpy));\n        dpynum = atoi(p + 1);\n     }\n     else\n         dpynum = 0;\n#if GLIB_CHECK_VERSION(2, 28, 0)\n    g_snprintf(buf, len, \"%s/%s-socket-%s-%d\", g_get_user_runtime_dir(),\n               data->prog_name, host ? host : \"\", dpynum);\n#else\n     g_snprintf(buf, len, \"%s/.%s-socket-%s-%d-%s\",\n                 g_get_tmp_dir(),\n                 data->prog_name,\n                 host ? host : \"\",\n                 dpynum,\n                 g_get_user_name());\n#endif\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141452,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " ActionReply Smb4KMountHelper::mount(const QVariantMap &args)\n {\n   ActionReply reply;\n   \n   QMapIterator<QString, QVariant> it(args);\n    proc.setOutputChannelMode(KProcess::SeparateChannels);\n    proc.setProcessEnvironment(QProcessEnvironment::systemEnvironment());\n#if defined(Q_OS_LINUX)\n    proc.setEnv(\"PASSWD\", entry[\"mh_url\"].toUrl().password(), true);\n#endif\n     QVariantMap entry = it.value().toMap();\n     \n     KProcess proc(this);\n    command << entry[\"mh_mountpoint\"].toString();\n    command << entry[\"mh_options\"].toStringList();\n#elif defined(Q_OS_FREEBSD) || defined(Q_OS_NETBSD)\n    command << entry[\"mh_command\"].toString();\n    command << entry[\"mh_options\"].toStringList();\n    command << entry[\"mh_unc\"].toString();\n    command << entry[\"mh_mountpoint\"].toString();\n#else\n#endif\n    proc.setProgram(command);\n\n    proc.start();\n    \n    if (proc.waitForStarted(-1))\n    {\n      bool userKill = false;\n     QStringList command;\n #if defined(Q_OS_LINUX)\n    command << entry[\"mh_command\"].toString();\n     command << entry[\"mh_unc\"].toString();\n     command << entry[\"mh_mountpoint\"].toString();\n     command << entry[\"mh_options\"].toStringList();\n #elif defined(Q_OS_FREEBSD) || defined(Q_OS_NETBSD)\n    command << entry[\"mh_command\"].toString();\n     command << entry[\"mh_options\"].toStringList();\n     command << entry[\"mh_unc\"].toString();\n     command << entry[\"mh_mountpoint\"].toString();\n        else\n        {\n        }\n\n        if (HelperSupport::isStopped())\n        {\n          proc.kill();\n          userKill = true;\n          break;\n        }\n        else\n        {\n        }\n      }\n\n      if (proc.exitStatus() == KProcess::CrashExit)\n      {\n        if (!userKill)\n        {\n          reply.setType(ActionReply::HelperErrorType);\n          reply.setErrorDescription(i18n(\"The mount process crashed.\"));\n          break;\n        }\n        else\n        {\n        }\n      }\n      else\n      {\n        QString stdErr = QString::fromUtf8(proc.readAllStandardError());\n        reply.addData(QString(\"mh_error_message_%1\").arg(index), stdErr.trimmed());\n      }\n    }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141457,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " ActionReply Smb4KMountHelper::mount(const QVariantMap &args)\n {\n  //\n  // The action reply\n  //\n   ActionReply reply;\n   \n  // Get the mount executable\n  //\n  const QString mount = findMountExecutable();\n  \n  //\n   QMapIterator<QString, QVariant> it(args);\n    proc.setOutputChannelMode(KProcess::SeparateChannels);\n    proc.setProcessEnvironment(QProcessEnvironment::systemEnvironment());\n#if defined(Q_OS_LINUX)\n    proc.setEnv(\"PASSWD\", entry[\"mh_url\"].toUrl().password(), true);\n#endif\n     QVariantMap entry = it.value().toMap();\n     \n    // Check the executable\n    //\n    if (mount != entry[\"mh_command\"].toString())\n    {\n      // Something weird is going on, bail out.\n      reply.setType(ActionReply::HelperErrorType);\n      return reply;\n    }\n    else\n    {\n      // Do nothing\n    }\n    \n    //\n     KProcess proc(this);\n    command << entry[\"mh_mountpoint\"].toString();\n    command << entry[\"mh_options\"].toStringList();\n#elif defined(Q_OS_FREEBSD) || defined(Q_OS_NETBSD)\n    command << entry[\"mh_command\"].toString();\n    command << entry[\"mh_options\"].toStringList();\n    command << entry[\"mh_unc\"].toString();\n    command << entry[\"mh_mountpoint\"].toString();\n#else\n#endif\n    proc.setProgram(command);\n\n    proc.start();\n    \n    if (proc.waitForStarted(-1))\n    {\n      bool userKill = false;\n     QStringList command;\n #if defined(Q_OS_LINUX)\n    command << mount;\n     command << entry[\"mh_unc\"].toString();\n     command << entry[\"mh_mountpoint\"].toString();\n     command << entry[\"mh_options\"].toStringList();\n #elif defined(Q_OS_FREEBSD) || defined(Q_OS_NETBSD)\n    command << mount;\n     command << entry[\"mh_options\"].toStringList();\n     command << entry[\"mh_unc\"].toString();\n     command << entry[\"mh_mountpoint\"].toString();\n        else\n        {\n        }\n\n        if (HelperSupport::isStopped())\n        {\n          proc.kill();\n          userKill = true;\n          break;\n        }\n        else\n        {\n        }\n      }\n\n      if (proc.exitStatus() == KProcess::CrashExit)\n      {\n        if (!userKill)\n        {\n          reply.setType(ActionReply::HelperErrorType);\n          reply.setErrorDescription(i18n(\"The mount process crashed.\"));\n          break;\n        }\n        else\n        {\n        }\n      }\n      else\n      {\n        QString stdErr = QString::fromUtf8(proc.readAllStandardError());\n        reply.addData(QString(\"mh_error_message_%1\").arg(index), stdErr.trimmed());\n      }\n    }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141458,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int tls_decrypt_ticket(SSL *s, const unsigned char *etick,\n                              int eticklen, const unsigned char *sess_id,\n                              int sesslen, SSL_SESSION **psess)\n{\n    SSL_SESSION *sess;\n    unsigned char *sdec;\n    const unsigned char *p;\n    int slen, mlen, renew_ticket = 0, ret = -1;\n    unsigned char tick_hmac[EVP_MAX_MD_SIZE];\n     HMAC_CTX *hctx = NULL;\n     EVP_CIPHER_CTX *ctx;\n     SSL_CTX *tctx = s->initial_ctx;\n    /* Need at least keyname + iv + some encrypted data */\n    if (eticklen < 48)\n        return 2;\n     /* Initialize session ticket encryption and HMAC contexts */\n     hctx = HMAC_CTX_new();\n     if (hctx == NULL)\n    hctx = HMAC_CTX_new();\n    if (hctx == NULL)\n        return -2;\n    ctx = EVP_CIPHER_CTX_new();\n    if (ctx == NULL) {\n        ret = -2;\n        goto err;\n    }\n    if (tctx->tlsext_ticket_key_cb) {\n        unsigned char *nctick = (unsigned char *)etick;\n        int rv = tctx->tlsext_ticket_key_cb(s, nctick, nctick + 16,\n                                            ctx, hctx, 0);\n        if (rv < 0)\n            goto err;\n        if (rv == 0) {\n            ret = 2;\n            goto err;\n        }\n        if (rv == 2)\n            renew_ticket = 1;\n    } else {\n        /* Check key name matches */\n        if (memcmp(etick, tctx->tlsext_tick_key_name,\n                   sizeof(tctx->tlsext_tick_key_name)) != 0) {\n            ret = 2;\n            goto err;\n        }\n        if (HMAC_Init_ex(hctx, tctx->tlsext_tick_hmac_key,\n                         sizeof(tctx->tlsext_tick_hmac_key),\n                         EVP_sha256(), NULL) <= 0\n            || EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL,\n                                  tctx->tlsext_tick_aes_key,\n                                  etick + sizeof(tctx->tlsext_tick_key_name)) <=\n            0) {\n            goto err;\n        }\n    }\n    /*\n     * Attempt to process session ticket, first conduct sanity and integrity\n     * checks on ticket.\n     if (mlen < 0) {\n         goto err;\n     }\n     eticklen -= mlen;\n     /* Check HMAC of encrypted ticket */\n     if (HMAC_Update(hctx, etick, eticklen) <= 0\n    if (CRYPTO_memcmp(tick_hmac, etick + eticklen, mlen)) {\n        EVP_CIPHER_CTX_free(ctx);\n        return 2;\n    }\n    /* Attempt to decrypt session data */\n    /* Move p after IV to start of encrypted ticket, update length */\n    p = etick + 16 + EVP_CIPHER_CTX_iv_length(ctx);\n    eticklen -= 16 + EVP_CIPHER_CTX_iv_length(ctx);\n    sdec = OPENSSL_malloc(eticklen);\n    if (sdec == NULL || EVP_DecryptUpdate(ctx, sdec, &slen, p, eticklen) <= 0) {\n        EVP_CIPHER_CTX_free(ctx);\n        OPENSSL_free(sdec);\n        return -1;\n    }\n    if (EVP_DecryptFinal(ctx, sdec + slen, &mlen) <= 0) {\n        EVP_CIPHER_CTX_free(ctx);\n        OPENSSL_free(sdec);\n        return 2;\n    }\n    slen += mlen;\n    EVP_CIPHER_CTX_free(ctx);\n    ctx = NULL;\n    p = sdec;\n\n    sess = d2i_SSL_SESSION(NULL, &p, slen);\n    OPENSSL_free(sdec);\n    if (sess) {\n        /*\n         * The session ID, if non-empty, is used by some clients to detect\n         * that the ticket has been accepted. So we copy it to the session\n         * structure. If it is empty set length to zero as required by\n         * standard.\n         */\n        if (sesslen)\n            memcpy(sess->session_id, sess_id, sesslen);\n        sess->session_id_length = sesslen;\n        *psess = sess;\n        if (renew_ticket)\n            return 4;\n        else\n            return 3;\n    }\n    ERR_clear_error();\n    /*\n     * For session parse failure, indicate that we need to send a new ticket.\n     */\n    return 2;\n err:\n    EVP_CIPHER_CTX_free(ctx);\n    HMAC_CTX_free(hctx);\n    return ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141513,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int tls_decrypt_ticket(SSL *s, const unsigned char *etick,\n                              int eticklen, const unsigned char *sess_id,\n                              int sesslen, SSL_SESSION **psess)\n{\n    SSL_SESSION *sess;\n    unsigned char *sdec;\n    const unsigned char *p;\n    int slen, mlen, renew_ticket = 0, ret = -1;\n    unsigned char tick_hmac[EVP_MAX_MD_SIZE];\n     HMAC_CTX *hctx = NULL;\n     EVP_CIPHER_CTX *ctx;\n     SSL_CTX *tctx = s->initial_ctx;\n\n     /* Initialize session ticket encryption and HMAC contexts */\n     hctx = HMAC_CTX_new();\n     if (hctx == NULL)\n    hctx = HMAC_CTX_new();\n    if (hctx == NULL)\n        return -2;\n    ctx = EVP_CIPHER_CTX_new();\n    if (ctx == NULL) {\n        ret = -2;\n        goto err;\n    }\n    if (tctx->tlsext_ticket_key_cb) {\n        unsigned char *nctick = (unsigned char *)etick;\n        int rv = tctx->tlsext_ticket_key_cb(s, nctick, nctick + 16,\n                                            ctx, hctx, 0);\n        if (rv < 0)\n            goto err;\n        if (rv == 0) {\n            ret = 2;\n            goto err;\n        }\n        if (rv == 2)\n            renew_ticket = 1;\n    } else {\n        /* Check key name matches */\n        if (memcmp(etick, tctx->tlsext_tick_key_name,\n                   sizeof(tctx->tlsext_tick_key_name)) != 0) {\n            ret = 2;\n            goto err;\n        }\n        if (HMAC_Init_ex(hctx, tctx->tlsext_tick_hmac_key,\n                         sizeof(tctx->tlsext_tick_hmac_key),\n                         EVP_sha256(), NULL) <= 0\n            || EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL,\n                                  tctx->tlsext_tick_aes_key,\n                                  etick + sizeof(tctx->tlsext_tick_key_name)) <=\n            0) {\n            goto err;\n        }\n    }\n    /*\n     * Attempt to process session ticket, first conduct sanity and integrity\n     * checks on ticket.\n     if (mlen < 0) {\n         goto err;\n     }\n    /* Sanity check ticket length: must exceed keyname + IV + HMAC */\n    if (eticklen <=\n        TLSEXT_KEYNAME_LENGTH + EVP_CIPHER_CTX_iv_length(ctx) + mlen) {\n        ret = 2;\n        goto err;\n    }\n     eticklen -= mlen;\n     /* Check HMAC of encrypted ticket */\n     if (HMAC_Update(hctx, etick, eticklen) <= 0\n    if (CRYPTO_memcmp(tick_hmac, etick + eticklen, mlen)) {\n        EVP_CIPHER_CTX_free(ctx);\n        return 2;\n    }\n    /* Attempt to decrypt session data */\n    /* Move p after IV to start of encrypted ticket, update length */\n    p = etick + 16 + EVP_CIPHER_CTX_iv_length(ctx);\n    eticklen -= 16 + EVP_CIPHER_CTX_iv_length(ctx);\n    sdec = OPENSSL_malloc(eticklen);\n    if (sdec == NULL || EVP_DecryptUpdate(ctx, sdec, &slen, p, eticklen) <= 0) {\n        EVP_CIPHER_CTX_free(ctx);\n        OPENSSL_free(sdec);\n        return -1;\n    }\n    if (EVP_DecryptFinal(ctx, sdec + slen, &mlen) <= 0) {\n        EVP_CIPHER_CTX_free(ctx);\n        OPENSSL_free(sdec);\n        return 2;\n    }\n    slen += mlen;\n    EVP_CIPHER_CTX_free(ctx);\n    ctx = NULL;\n    p = sdec;\n\n    sess = d2i_SSL_SESSION(NULL, &p, slen);\n    OPENSSL_free(sdec);\n    if (sess) {\n        /*\n         * The session ID, if non-empty, is used by some clients to detect\n         * that the ticket has been accepted. So we copy it to the session\n         * structure. If it is empty set length to zero as required by\n         * standard.\n         */\n        if (sesslen)\n            memcpy(sess->session_id, sess_id, sesslen);\n        sess->session_id_length = sesslen;\n        *psess = sess;\n        if (renew_ticket)\n            return 4;\n        else\n            return 3;\n    }\n    ERR_clear_error();\n    /*\n     * For session parse failure, indicate that we need to send a new ticket.\n     */\n    return 2;\n err:\n    EVP_CIPHER_CTX_free(ctx);\n    HMAC_CTX_free(hctx);\n    return ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141514,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "  FT_Stream_EnterFrame( FT_Stream  stream,\n                        FT_ULong   count )\n  {\n    FT_Error  error = FT_Err_Ok;\n    FT_ULong  read_bytes;\n\n\n    /* check for nested frame access */\n    FT_ASSERT( stream && stream->cursor == 0 );\n\n    if ( stream->read )\n    {\n      /* allocate the frame in memory */\n      FT_Memory  memory = stream->memory;\n\n\n      /* simple sanity check */\n      if ( count > stream->size )\n      {\n        FT_ERROR(( \"FT_Stream_EnterFrame:\"\n                   \" frame size (%lu) larger than stream size (%lu)\\n\",\n                   count, stream->size ));\n\n        error = FT_Err_Invalid_Stream_Operation;\n        goto Exit;\n      }\n\n#ifdef FT_DEBUG_MEMORY\n      /* assume _ft_debug_file and _ft_debug_lineno are already set */\n      stream->base = (unsigned char*)ft_mem_qalloc( memory, count, &error );\n      if ( error )\n        goto Exit;\n#else\n      if ( FT_QALLOC( stream->base, count ) )\n        goto Exit;\n#endif\n      /* read it */\n      read_bytes = stream->read( stream, stream->pos,\n                                 stream->base, count );\n      if ( read_bytes < count )\n      {\n        FT_ERROR(( \"FT_Stream_EnterFrame:\"\n                   \" invalid read; expected %lu bytes, got %lu\\n\",\n                   count, read_bytes ));\n\n        FT_FREE( stream->base );\n        error = FT_Err_Invalid_Stream_Operation;\n      }\n      stream->cursor = stream->base;\n      stream->limit  = stream->cursor + count;\n      stream->pos   += read_bytes;\n    }\n    else\n     {\n       /* check current and new position */\n       if ( stream->pos >= stream->size        ||\n           stream->pos + count > stream->size )\n       {\n         FT_ERROR(( \"FT_Stream_EnterFrame:\"\n                    \" invalid i/o; pos = 0x%lx, count = %lu, size = 0x%lx\\n\",\n                   stream->pos, count, stream->size ));\n\n        error = FT_Err_Invalid_Stream_Operation;\n        goto Exit;\n      }\n\n      /* set cursor */\n      stream->cursor = stream->base + stream->pos;\n      stream->limit  = stream->cursor + count;\n      stream->pos   += count;\n    }\n\n  Exit:\n    return error;\n  }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141517,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "  FT_Stream_EnterFrame( FT_Stream  stream,\n                        FT_ULong   count )\n  {\n    FT_Error  error = FT_Err_Ok;\n    FT_ULong  read_bytes;\n\n\n    /* check for nested frame access */\n    FT_ASSERT( stream && stream->cursor == 0 );\n\n    if ( stream->read )\n    {\n      /* allocate the frame in memory */\n      FT_Memory  memory = stream->memory;\n\n\n      /* simple sanity check */\n      if ( count > stream->size )\n      {\n        FT_ERROR(( \"FT_Stream_EnterFrame:\"\n                   \" frame size (%lu) larger than stream size (%lu)\\n\",\n                   count, stream->size ));\n\n        error = FT_Err_Invalid_Stream_Operation;\n        goto Exit;\n      }\n\n#ifdef FT_DEBUG_MEMORY\n      /* assume _ft_debug_file and _ft_debug_lineno are already set */\n      stream->base = (unsigned char*)ft_mem_qalloc( memory, count, &error );\n      if ( error )\n        goto Exit;\n#else\n      if ( FT_QALLOC( stream->base, count ) )\n        goto Exit;\n#endif\n      /* read it */\n      read_bytes = stream->read( stream, stream->pos,\n                                 stream->base, count );\n      if ( read_bytes < count )\n      {\n        FT_ERROR(( \"FT_Stream_EnterFrame:\"\n                   \" invalid read; expected %lu bytes, got %lu\\n\",\n                   count, read_bytes ));\n\n        FT_FREE( stream->base );\n        error = FT_Err_Invalid_Stream_Operation;\n      }\n      stream->cursor = stream->base;\n      stream->limit  = stream->cursor + count;\n      stream->pos   += read_bytes;\n    }\n    else\n     {\n       /* check current and new position */\n       if ( stream->pos >= stream->size        ||\n           stream->size - stream->pos < count )\n       {\n         FT_ERROR(( \"FT_Stream_EnterFrame:\"\n                    \" invalid i/o; pos = 0x%lx, count = %lu, size = 0x%lx\\n\",\n                   stream->pos, count, stream->size ));\n\n        error = FT_Err_Invalid_Stream_Operation;\n        goto Exit;\n      }\n\n      /* set cursor */\n      stream->cursor = stream->base + stream->pos;\n      stream->limit  = stream->cursor + count;\n      stream->pos   += count;\n    }\n\n  Exit:\n    return error;\n  }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141518,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int tls_decrypt_ticket(SSL *s, const unsigned char *etick, int eticklen,\n\t\t\t\tconst unsigned char *sess_id, int sesslen,\n\t\t\t\tSSL_SESSION **psess)\n\t{\n\tSSL_SESSION *sess;\n\tunsigned char *sdec;\n\tconst unsigned char *p;\n\tint slen, mlen, renew_ticket = 0;\n\tunsigned char tick_hmac[EVP_MAX_MD_SIZE];\n\tHMAC_CTX hctx;\n\tEVP_CIPHER_CTX ctx;\n\tSSL_CTX *tctx = s->initial_ctx;\n\t/* Need at least keyname + iv + some encrypted data */\n\tif (eticklen < 48)\n\t\treturn 2;\n\t/* Initialize session ticket encryption and HMAC contexts */\n\tHMAC_CTX_init(&hctx);\n\tEVP_CIPHER_CTX_init(&ctx);\n\tif (tctx->tlsext_ticket_key_cb)\n\t\t{\n\t\tunsigned char *nctick = (unsigned char *)etick;\n\t\tint rv = tctx->tlsext_ticket_key_cb(s, nctick, nctick + 16,\n\t\t\t\t\t\t\t&ctx, &hctx, 0);\n\t\tif (rv < 0)\n\t\t\treturn -1;\n\t\tif (rv == 0)\n\t\t\treturn 2;\n\t\tif (rv == 2)\n\t\t\trenew_ticket = 1;\n\t\t}\n\telse\n\t\t{\n\t\t/* Check key name matches */\n\t\tif (memcmp(etick, tctx->tlsext_tick_key_name, 16))\n\t\t\treturn 2;\n\t\tHMAC_Init_ex(&hctx, tctx->tlsext_tick_hmac_key, 16,\n\t\t\t\t\ttlsext_tick_md(), NULL);\n\t\tEVP_DecryptInit_ex(&ctx, EVP_aes_128_cbc(), NULL,\n\t\t\t\ttctx->tlsext_tick_aes_key, etick + 16);\n\t\t}\n\t/* Attempt to process session ticket, first conduct sanity and\n\t * integrity checks on ticket.\n\t */\n\tmlen = HMAC_size(&hctx);\n\tif (mlen < 0)\n\t\t{\n\t\tEVP_CIPHER_CTX_cleanup(&ctx);\n\t\treturn -1;\n\t\t}\n\teticklen -= mlen;\n\t/* Check HMAC of encrypted ticket */\n\tHMAC_Update(&hctx, etick, eticklen);\n        HMAC_Final(&hctx, tick_hmac, NULL);\n        HMAC_CTX_cleanup(&hctx);\n        if (CRYPTO_memcmp(tick_hmac, etick + eticklen, mlen))\n                return 2;\n        /* Attempt to decrypt session data */\n        /* Move p after IV to start of encrypted ticket, update length */\n        p = etick + 16 + EVP_CIPHER_CTX_iv_length(&ctx);\n\t\t{\n\t\tEVP_CIPHER_CTX_cleanup(&ctx);\n\t\treturn -1;\n\t\t}\n\tEVP_DecryptUpdate(&ctx, sdec, &slen, p, eticklen);\n\tif (EVP_DecryptFinal(&ctx, sdec + slen, &mlen) <= 0)\n\t\t{\n\t\tEVP_CIPHER_CTX_cleanup(&ctx);\n\t\tOPENSSL_free(sdec);\n\t\treturn 2;\n\t\t}\n\tslen += mlen;\n\tEVP_CIPHER_CTX_cleanup(&ctx);\n\tp = sdec;\n\n\tsess = d2i_SSL_SESSION(NULL, &p, slen);\n\tOPENSSL_free(sdec);\n\tif (sess)\n\t\t{\n\t\t/* The session ID, if non-empty, is used by some clients to\n\t\t * detect that the ticket has been accepted. So we copy it to\n\t\t * the session structure. If it is empty set length to zero\n\t\t * as required by standard.\n\t\t */\n\t\tif (sesslen)\n\t\t\tmemcpy(sess->session_id, sess_id, sesslen);\n\t\tsess->session_id_length = sesslen;\n\t\t*psess = sess;\n\t\tif (renew_ticket)\n\t\t\treturn 4;\n\t\telse\n\t\t\treturn 3;\n\t\t}\n        ERR_clear_error();\n\t/* For session parse failure, indicate that we need to send a new\n\t * ticket. */\n\treturn 2;\n\t}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141553,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int tls_decrypt_ticket(SSL *s, const unsigned char *etick, int eticklen,\n\t\t\t\tconst unsigned char *sess_id, int sesslen,\n\t\t\t\tSSL_SESSION **psess)\n\t{\n\tSSL_SESSION *sess;\n\tunsigned char *sdec;\n\tconst unsigned char *p;\n\tint slen, mlen, renew_ticket = 0;\n\tunsigned char tick_hmac[EVP_MAX_MD_SIZE];\n\tHMAC_CTX hctx;\n\tEVP_CIPHER_CTX ctx;\n\tSSL_CTX *tctx = s->initial_ctx;\n\t/* Need at least keyname + iv + some encrypted data */\n\tif (eticklen < 48)\n\t\treturn 2;\n\t/* Initialize session ticket encryption and HMAC contexts */\n\tHMAC_CTX_init(&hctx);\n\tEVP_CIPHER_CTX_init(&ctx);\n\tif (tctx->tlsext_ticket_key_cb)\n\t\t{\n\t\tunsigned char *nctick = (unsigned char *)etick;\n\t\tint rv = tctx->tlsext_ticket_key_cb(s, nctick, nctick + 16,\n\t\t\t\t\t\t\t&ctx, &hctx, 0);\n\t\tif (rv < 0)\n\t\t\treturn -1;\n\t\tif (rv == 0)\n\t\t\treturn 2;\n\t\tif (rv == 2)\n\t\t\trenew_ticket = 1;\n\t\t}\n\telse\n\t\t{\n\t\t/* Check key name matches */\n\t\tif (memcmp(etick, tctx->tlsext_tick_key_name, 16))\n\t\t\treturn 2;\n\t\tHMAC_Init_ex(&hctx, tctx->tlsext_tick_hmac_key, 16,\n\t\t\t\t\ttlsext_tick_md(), NULL);\n\t\tEVP_DecryptInit_ex(&ctx, EVP_aes_128_cbc(), NULL,\n\t\t\t\ttctx->tlsext_tick_aes_key, etick + 16);\n\t\t}\n\t/* Attempt to process session ticket, first conduct sanity and\n\t * integrity checks on ticket.\n\t */\n\tmlen = HMAC_size(&hctx);\n\tif (mlen < 0)\n\t\t{\n\t\tEVP_CIPHER_CTX_cleanup(&ctx);\n\t\treturn -1;\n\t\t}\n\teticklen -= mlen;\n\t/* Check HMAC of encrypted ticket */\n\tHMAC_Update(&hctx, etick, eticklen);\n        HMAC_Final(&hctx, tick_hmac, NULL);\n        HMAC_CTX_cleanup(&hctx);\n        if (CRYPTO_memcmp(tick_hmac, etick + eticklen, mlen))\n               {\n               EVP_CIPHER_CTX_cleanup(&ctx);\n                return 2;\n               }\n        /* Attempt to decrypt session data */\n        /* Move p after IV to start of encrypted ticket, update length */\n        p = etick + 16 + EVP_CIPHER_CTX_iv_length(&ctx);\n\t\t{\n\t\tEVP_CIPHER_CTX_cleanup(&ctx);\n\t\treturn -1;\n\t\t}\n\tEVP_DecryptUpdate(&ctx, sdec, &slen, p, eticklen);\n\tif (EVP_DecryptFinal(&ctx, sdec + slen, &mlen) <= 0)\n\t\t{\n\t\tEVP_CIPHER_CTX_cleanup(&ctx);\n\t\tOPENSSL_free(sdec);\n\t\treturn 2;\n\t\t}\n\tslen += mlen;\n\tEVP_CIPHER_CTX_cleanup(&ctx);\n\tp = sdec;\n\n\tsess = d2i_SSL_SESSION(NULL, &p, slen);\n\tOPENSSL_free(sdec);\n\tif (sess)\n\t\t{\n\t\t/* The session ID, if non-empty, is used by some clients to\n\t\t * detect that the ticket has been accepted. So we copy it to\n\t\t * the session structure. If it is empty set length to zero\n\t\t * as required by standard.\n\t\t */\n\t\tif (sesslen)\n\t\t\tmemcpy(sess->session_id, sess_id, sesslen);\n\t\tsess->session_id_length = sesslen;\n\t\t*psess = sess;\n\t\tif (renew_ticket)\n\t\t\treturn 4;\n\t\telse\n\t\t\treturn 3;\n\t\t}\n        ERR_clear_error();\n\t/* For session parse failure, indicate that we need to send a new\n\t * ticket. */\n\treturn 2;\n\t}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141554,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static const char *check_secret(int module, const char *user, const char *group,\n\t\t\t\tconst char *challenge, const char *pass)\n{\n\tchar line[1024];\n        char pass2[MAX_DIGEST_LEN*2];\n        const char *fname = lp_secrets_file(module);\n        STRUCT_STAT st;\n       int fd, ok = 1;\n        int user_len = strlen(user);\n        int group_len = group ? strlen(group) : 0;\n        char *err;\n \n       if (!fname || !*fname || (fd = open(fname, O_RDONLY)) < 0)\n                return \"no secrets file\";\n \n       if (do_fstat(fd, &st) == -1) {\n                rsyserr(FLOG, errno, \"fstat(%s)\", fname);\n                ok = 0;\n        } else if (lp_strict_modes(module)) {\n\t\t\trprintf(FLOG, \"secrets file must not be other-accessible (see strict modes option)\\n\");\n\t\t\tok = 0;\n\t\t} else if (MY_UID() == 0 && st.st_uid != 0) {\n\t\t\trprintf(FLOG, \"secrets file must be owned by root when running as root (see strict modes)\\n\");\n\t\t\tok = 0;\n\t\t}\n                }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141571,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static const char *check_secret(int module, const char *user, const char *group,\n\t\t\t\tconst char *challenge, const char *pass)\n{\n\tchar line[1024];\n        char pass2[MAX_DIGEST_LEN*2];\n        const char *fname = lp_secrets_file(module);\n        STRUCT_STAT st;\n       int ok = 1;\n        int user_len = strlen(user);\n        int group_len = group ? strlen(group) : 0;\n        char *err;\n       FILE *fh;\n \n       if (!fname || !*fname || (fh = fopen(fname, \"r\")) == NULL)\n                return \"no secrets file\";\n \n       if (do_fstat(fileno(fh), &st) == -1) {\n                rsyserr(FLOG, errno, \"fstat(%s)\", fname);\n                ok = 0;\n        } else if (lp_strict_modes(module)) {\n\t\t\trprintf(FLOG, \"secrets file must not be other-accessible (see strict modes option)\\n\");\n\t\t\tok = 0;\n\t\t} else if (MY_UID() == 0 && st.st_uid != 0) {\n\t\t\trprintf(FLOG, \"secrets file must be owned by root when running as root (see strict modes)\\n\");\n\t\t\tok = 0;\n\t\t}\n                }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141572,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "  cf2_initGlobalRegionBuffer( CFF_Decoder*  decoder,\n                               CF2_UInt      idx,\n                               CF2_Buffer    buf )\n   {\n    FT_ASSERT( decoder && decoder->globals );\n \n     FT_ZERO( buf );\n \n    idx += decoder->globals_bias;\n     if ( idx >= decoder->num_globals )\n       return TRUE;     /* error */\n \n     buf->start =\n     buf->ptr   = decoder->globals[idx];\n     buf->end   = decoder->globals[idx + 1];\n  }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141577,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "  cf2_initGlobalRegionBuffer( CFF_Decoder*  decoder,\n                               CF2_UInt      idx,\n                               CF2_Buffer    buf )\n   {\n    FT_ASSERT( decoder );\n \n     FT_ZERO( buf );\n \n    idx += decoder->globals_bias;\n     if ( idx >= decoder->num_globals )\n       return TRUE;     /* error */\n \n    FT_ASSERT( decoder->globals );\n\n     buf->start =\n     buf->ptr   = decoder->globals[idx];\n     buf->end   = decoder->globals[idx + 1];\n  }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141578,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int dv_extract_audio_info(DVDemuxContext* c, uint8_t* frame)\n{\n    const uint8_t* as_pack;\n    int freq, stype, smpls, quant, i, ach;\n\n    as_pack = dv_extract_pack(frame, dv_audio_source);\n    if (!as_pack || !c->sys) {    /* No audio ? */\n        c->ach = 0;\n        return 0;\n    }\n\n    smpls =  as_pack[1] & 0x3f;       /* samples in this frame - min. samples */\n    freq  = (as_pack[4] >> 3) & 0x07; /* 0 - 48kHz, 1 - 44,1kHz, 2 - 32kHz */\n     stype = (as_pack[3] & 0x1f);      /* 0 - 2CH, 2 - 4CH, 3 - 8CH */\n     quant =  as_pack[4] & 0x07;       /* 0 - 16bit linear, 1 - 12bit nonlinear */\n \n     /* note: ach counts PAIRS of channels (i.e. stereo channels) */\n     ach = ((int[4]){  1,  0,  2,  4})[stype];\n     if (ach == 1 && quant && freq == 2)\n           if (!c->ast[i])\n               break;\n           avpriv_set_pts_info(c->ast[i], 64, 1, 30000);\n           c->ast[i]->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n           c->ast[i]->codec->codec_id   = CODEC_ID_PCM_S16LE;\n\n           av_init_packet(&c->audio_pkt[i]);\n           c->audio_pkt[i].size         = 0;\n           c->audio_pkt[i].data         = c->audio_buf[i];\n           c->audio_pkt[i].stream_index = c->ast[i]->index;\n           c->audio_pkt[i].flags       |= AV_PKT_FLAG_KEY;\n       }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141589,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int dv_extract_audio_info(DVDemuxContext* c, uint8_t* frame)\n{\n    const uint8_t* as_pack;\n    int freq, stype, smpls, quant, i, ach;\n\n    as_pack = dv_extract_pack(frame, dv_audio_source);\n    if (!as_pack || !c->sys) {    /* No audio ? */\n        c->ach = 0;\n        return 0;\n    }\n\n    smpls =  as_pack[1] & 0x3f;       /* samples in this frame - min. samples */\n    freq  = (as_pack[4] >> 3) & 0x07; /* 0 - 48kHz, 1 - 44,1kHz, 2 - 32kHz */\n     stype = (as_pack[3] & 0x1f);      /* 0 - 2CH, 2 - 4CH, 3 - 8CH */\n     quant =  as_pack[4] & 0x07;       /* 0 - 16bit linear, 1 - 12bit nonlinear */\n \n    if (stype > 3) {\n        av_log(c->fctx, AV_LOG_ERROR, \"stype %d is invalid\\n\", stype);\n        c->ach = 0;\n        return 0;\n    }\n\n     /* note: ach counts PAIRS of channels (i.e. stereo channels) */\n     ach = ((int[4]){  1,  0,  2,  4})[stype];\n     if (ach == 1 && quant && freq == 2)\n           if (!c->ast[i])\n               break;\n           avpriv_set_pts_info(c->ast[i], 64, 1, 30000);\n           c->ast[i]->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n           c->ast[i]->codec->codec_id   = CODEC_ID_PCM_S16LE;\n\n           av_init_packet(&c->audio_pkt[i]);\n           c->audio_pkt[i].size         = 0;\n           c->audio_pkt[i].data         = c->audio_buf[i];\n           c->audio_pkt[i].stream_index = c->ast[i]->index;\n           c->audio_pkt[i].flags       |= AV_PKT_FLAG_KEY;\n       }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141590,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "validGlxScreen(ClientPtr client, int screen, __GLXscreen **pGlxScreen, int *err)\n{\n     /*\n     ** Check if screen exists.\n     */\n    if (screen >= screenInfo.numScreens) {\n \tclient->errorValue = screen;\n \t*err = BadValue;\n \treturn FALSE;\n    }\n    *pGlxScreen = glxGetScreen(screenInfo.screens[screen]);\n\n    return TRUE;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141605,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "validGlxScreen(ClientPtr client, int screen, __GLXscreen **pGlxScreen, int *err)\n{\n     /*\n     ** Check if screen exists.\n     */\n    if (screen < 0 || screen >= screenInfo.numScreens) {\n \tclient->errorValue = screen;\n \t*err = BadValue;\n \treturn FALSE;\n    }\n    *pGlxScreen = glxGetScreen(screenInfo.screens[screen]);\n\n    return TRUE;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141606,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " int __glXDisp_CreateContext(__GLXclientState *cl, GLbyte *pc)\n {\n     xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;\n     __GLXconfig *config;\n     __GLXscreen *pGlxScreen;\n     int err;\n \n     if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))\n \treturn err;\n     if (!validGlxVisual(cl->client, pGlxScreen, req->visual, &config, &err))\n\t\t\t   config, pGlxScreen, req->isDirect);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141607,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " int __glXDisp_CreateContext(__GLXclientState *cl, GLbyte *pc)\n {\n    ClientPtr client = cl->client;\n     xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;\n     __GLXconfig *config;\n     __GLXscreen *pGlxScreen;\n     int err;\n \n    REQUEST_SIZE_MATCH(xGLXCreateContextReq);\n\n     if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))\n \treturn err;\n     if (!validGlxVisual(cl->client, pGlxScreen, req->visual, &config, &err))\n\t\t\t   config, pGlxScreen, req->isDirect);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141608,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "load(ImlibImage * im, ImlibProgressFunction progress, char progress_granularity,\n     char immediate_load)\n{\n   static const int    intoffset[] = { 0, 4, 2, 1 };\n   static const int    intjump[] = { 8, 8, 4, 2 };\n   int                 rc;\n   DATA32             *ptr;\n   GifFileType        *gif;\n   GifRowType         *rows;\n   GifRecordType       rec;\n   ColorMapObject     *cmap;\n   int                 i, j, done, bg, r, g, b, w = 0, h = 0;\n   float               per = 0.0, per_inc;\n   int                 last_per = 0, last_y = 0;\n   int                 transp;\n   int                 fd;\n\n   done = 0;\n   rows = NULL;\n   transp = -1;\n\n   /* if immediate_load is 1, then dont delay image laoding as below, or */\n   /* already data in this image - dont load it again */\n   if (im->data)\n      return 0;\n\n   fd = open(im->real_file, O_RDONLY);\n   if (fd < 0)\n      return 0;\n\n#if GIFLIB_MAJOR >= 5\n   gif = DGifOpenFileHandle(fd, NULL);\n#else\n   gif = DGifOpenFileHandle(fd);\n#endif\n   if (!gif)\n     {\n        close(fd);\n        return 0;\n     }\n\n   rc = 0;                      /* Failure */\n\n   do\n     {\n        if (DGifGetRecordType(gif, &rec) == GIF_ERROR)\n          {\n             /* PrintGifError(); */\n             rec = TERMINATE_RECORD_TYPE;\n          }\n        if ((rec == IMAGE_DESC_RECORD_TYPE) && (!done))\n          {\n             if (DGifGetImageDesc(gif) == GIF_ERROR)\n               {\n                  /* PrintGifError(); */\n                  rec = TERMINATE_RECORD_TYPE;\n                  break;\n               }\n             w = gif->Image.Width;\n             h = gif->Image.Height;\n             if (!IMAGE_DIMENSIONS_OK(w, h))\n                goto quit2;\n\n             rows = calloc(h, sizeof(GifRowType *));\n             if (!rows)\n                goto quit2;\n\n             for (i = 0; i < h; i++)\n               {\n                  rows[i] = malloc(w * sizeof(GifPixelType));\n                  if (!rows[i])\n                     goto quit;\n               }\n\n             if (gif->Image.Interlace)\n               {\n                  for (i = 0; i < 4; i++)\n                    {\n                       for (j = intoffset[i]; j < h; j += intjump[i])\n                         {\n                            if (DGifGetLine(gif, rows[i], w) == GIF_ERROR)\n                               {\n                                  break;\n                               }\n                         }\n                    }\n               }\n             else\n               {\n                  for (i = 0; i < h; i++)\n                    {\n                       if (DGifGetLine(gif, rows[i], w) == GIF_ERROR)\n                          {\n                             break;\n                          }\n                    }\n               }\n             done = 1;\n          }\n        else if (rec == EXTENSION_RECORD_TYPE)\n          {\n             int                 ext_code;\n             GifByteType        *ext;\n\n             ext = NULL;\n             DGifGetExtension(gif, &ext_code, &ext);\n             while (ext)\n               {\n                  if ((ext_code == 0xf9) && (ext[1] & 1) && (transp < 0))\n                    {\n                       transp = (int)ext[4];\n                    }\n                  ext = NULL;\n                  DGifGetExtensionNext(gif, &ext);\n               }\n          }\n     }\n   while (rec != TERMINATE_RECORD_TYPE);\n\n   if (transp >= 0)\n     {\n        SET_FLAG(im->flags, F_HAS_ALPHA);\n     }\n   else\n      {\n         UNSET_FLAG(im->flags, F_HAS_ALPHA);\n      }\n \n    /* set the format string member to the lower-case full extension */\n    /* name for the format - so example names would be: */\n      im->format = strdup(\"gif\");\n\n   if (im->loader || immediate_load || progress)\n     {\n        bg = gif->SBackGroundColor;\n        cmap = (gif->Image.ColorMap ? gif->Image.ColorMap : gif->SColorMap);\n        im->data = (DATA32 *) malloc(sizeof(DATA32) * w * h);\n        if (!im->data)\n           goto quit;\n\n        if (!cmap)\n          {\n             /* No colormap? Now what?? Let's clear the image (and not segv) */\n             memset(im->data, 0, sizeof(DATA32) * w * h);\n             rc = 1;\n             goto finish;\n          }\n\n        ptr = im->data;\n        per_inc = 100.0 / (((float)w) * h);\n        for (i = 0; i < h; i++)\n          {\n             for (j = 0; j < w; j++)\n               {\n                  if (rows[i][j] == transp)\n                    {\n                       r = cmap->Colors[bg].Red;\n                       g = cmap->Colors[bg].Green;\n                       b = cmap->Colors[bg].Blue;\n                       *ptr++ = 0x00ffffff & ((r << 16) | (g << 8) | b);\n                    }\n                  else\n                    {\n                       r = cmap->Colors[rows[i][j]].Red;\n                       g = cmap->Colors[rows[i][j]].Green;\n                       b = cmap->Colors[rows[i][j]].Blue;\n                       *ptr++ = (0xff << 24) | (r << 16) | (g << 8) | b;\n                    }\n                  per += per_inc;\n                  if (progress && (((int)per) != last_per)\n                      && (((int)per) % progress_granularity == 0))\n                    {\n                       last_per = (int)per;\n                       if (!(progress(im, (int)per, 0, last_y, w, i)))\n                         {\n                            rc = 2;\n                            goto quit;\n                         }\n                       last_y = i;\n                    }\n               }\n          }\n\n      finish:\n        if (progress)\n           progress(im, 100, 0, last_y, w, h);\n     }\n\n   rc = 1;                      /* Success */\n\n quit:\n   for (i = 0; i < h; i++)\n      free(rows[i]);\n   free(rows);\n\n quit2:\n#if GIFLIB_MAJOR > 5 || (GIFLIB_MAJOR == 5 && GIFLIB_MINOR >= 1)\n   DGifCloseFile(gif, NULL);\n#else\n   DGifCloseFile(gif);\n#endif\n\n   return rc;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141621,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "load(ImlibImage * im, ImlibProgressFunction progress, char progress_granularity,\n     char immediate_load)\n{\n   static const int    intoffset[] = { 0, 4, 2, 1 };\n   static const int    intjump[] = { 8, 8, 4, 2 };\n   int                 rc;\n   DATA32             *ptr;\n   GifFileType        *gif;\n   GifRowType         *rows;\n   GifRecordType       rec;\n   ColorMapObject     *cmap;\n   int                 i, j, done, bg, r, g, b, w = 0, h = 0;\n   float               per = 0.0, per_inc;\n   int                 last_per = 0, last_y = 0;\n   int                 transp;\n   int                 fd;\n\n   done = 0;\n   rows = NULL;\n   transp = -1;\n\n   /* if immediate_load is 1, then dont delay image laoding as below, or */\n   /* already data in this image - dont load it again */\n   if (im->data)\n      return 0;\n\n   fd = open(im->real_file, O_RDONLY);\n   if (fd < 0)\n      return 0;\n\n#if GIFLIB_MAJOR >= 5\n   gif = DGifOpenFileHandle(fd, NULL);\n#else\n   gif = DGifOpenFileHandle(fd);\n#endif\n   if (!gif)\n     {\n        close(fd);\n        return 0;\n     }\n\n   rc = 0;                      /* Failure */\n\n   do\n     {\n        if (DGifGetRecordType(gif, &rec) == GIF_ERROR)\n          {\n             /* PrintGifError(); */\n             rec = TERMINATE_RECORD_TYPE;\n          }\n        if ((rec == IMAGE_DESC_RECORD_TYPE) && (!done))\n          {\n             if (DGifGetImageDesc(gif) == GIF_ERROR)\n               {\n                  /* PrintGifError(); */\n                  rec = TERMINATE_RECORD_TYPE;\n                  break;\n               }\n             w = gif->Image.Width;\n             h = gif->Image.Height;\n             if (!IMAGE_DIMENSIONS_OK(w, h))\n                goto quit2;\n\n             rows = calloc(h, sizeof(GifRowType *));\n             if (!rows)\n                goto quit2;\n\n             for (i = 0; i < h; i++)\n               {\n                  rows[i] = malloc(w * sizeof(GifPixelType));\n                  if (!rows[i])\n                     goto quit;\n               }\n\n             if (gif->Image.Interlace)\n               {\n                  for (i = 0; i < 4; i++)\n                    {\n                       for (j = intoffset[i]; j < h; j += intjump[i])\n                         {\n                            if (DGifGetLine(gif, rows[i], w) == GIF_ERROR)\n                               {\n                                  break;\n                               }\n                         }\n                    }\n               }\n             else\n               {\n                  for (i = 0; i < h; i++)\n                    {\n                       if (DGifGetLine(gif, rows[i], w) == GIF_ERROR)\n                          {\n                             break;\n                          }\n                    }\n               }\n             done = 1;\n          }\n        else if (rec == EXTENSION_RECORD_TYPE)\n          {\n             int                 ext_code;\n             GifByteType        *ext;\n\n             ext = NULL;\n             DGifGetExtension(gif, &ext_code, &ext);\n             while (ext)\n               {\n                  if ((ext_code == 0xf9) && (ext[1] & 1) && (transp < 0))\n                    {\n                       transp = (int)ext[4];\n                    }\n                  ext = NULL;\n                  DGifGetExtensionNext(gif, &ext);\n               }\n          }\n     }\n   while (rec != TERMINATE_RECORD_TYPE);\n\n   if (transp >= 0)\n     {\n        SET_FLAG(im->flags, F_HAS_ALPHA);\n     }\n   else\n      {\n         UNSET_FLAG(im->flags, F_HAS_ALPHA);\n      }\n   if (!rows)\n     {\n        goto quit2;\n     }\n \n    /* set the format string member to the lower-case full extension */\n    /* name for the format - so example names would be: */\n      im->format = strdup(\"gif\");\n\n   if (im->loader || immediate_load || progress)\n     {\n        bg = gif->SBackGroundColor;\n        cmap = (gif->Image.ColorMap ? gif->Image.ColorMap : gif->SColorMap);\n        im->data = (DATA32 *) malloc(sizeof(DATA32) * w * h);\n        if (!im->data)\n           goto quit;\n\n        if (!cmap)\n          {\n             /* No colormap? Now what?? Let's clear the image (and not segv) */\n             memset(im->data, 0, sizeof(DATA32) * w * h);\n             rc = 1;\n             goto finish;\n          }\n\n        ptr = im->data;\n        per_inc = 100.0 / (((float)w) * h);\n        for (i = 0; i < h; i++)\n          {\n             for (j = 0; j < w; j++)\n               {\n                  if (rows[i][j] == transp)\n                    {\n                       r = cmap->Colors[bg].Red;\n                       g = cmap->Colors[bg].Green;\n                       b = cmap->Colors[bg].Blue;\n                       *ptr++ = 0x00ffffff & ((r << 16) | (g << 8) | b);\n                    }\n                  else\n                    {\n                       r = cmap->Colors[rows[i][j]].Red;\n                       g = cmap->Colors[rows[i][j]].Green;\n                       b = cmap->Colors[rows[i][j]].Blue;\n                       *ptr++ = (0xff << 24) | (r << 16) | (g << 8) | b;\n                    }\n                  per += per_inc;\n                  if (progress && (((int)per) != last_per)\n                      && (((int)per) % progress_granularity == 0))\n                    {\n                       last_per = (int)per;\n                       if (!(progress(im, (int)per, 0, last_y, w, i)))\n                         {\n                            rc = 2;\n                            goto quit;\n                         }\n                       last_y = i;\n                    }\n               }\n          }\n\n      finish:\n        if (progress)\n           progress(im, 100, 0, last_y, w, h);\n     }\n\n   rc = 1;                      /* Success */\n\n quit:\n   for (i = 0; i < h; i++)\n      free(rows[i]);\n   free(rows);\n\n quit2:\n#if GIFLIB_MAJOR > 5 || (GIFLIB_MAJOR == 5 && GIFLIB_MINOR >= 1)\n   DGifCloseFile(gif, NULL);\n#else\n   DGifCloseFile(gif);\n#endif\n\n   return rc;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141622,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "load(ImlibImage * im, ImlibProgressFunction progress, char progress_granularity,\n     char immediate_load)\n{\n   static const int    intoffset[] = { 0, 4, 2, 1 };\n   static const int    intjump[] = { 8, 8, 4, 2 };\n   int                 rc;\n   DATA32             *ptr;\n   GifFileType        *gif;\n   GifRowType         *rows;\n   GifRecordType       rec;\n   ColorMapObject     *cmap;\n   int                 i, j, done, bg, r, g, b, w = 0, h = 0;\n   float               per = 0.0, per_inc;\n   int                 last_per = 0, last_y = 0;\n   int                 transp;\n   int                 fd;\n\n   done = 0;\n   rows = NULL;\n   transp = -1;\n\n   /* if immediate_load is 1, then dont delay image laoding as below, or */\n   /* already data in this image - dont load it again */\n   if (im->data)\n      return 0;\n\n   fd = open(im->real_file, O_RDONLY);\n   if (fd < 0)\n      return 0;\n\n#if GIFLIB_MAJOR >= 5\n   gif = DGifOpenFileHandle(fd, NULL);\n#else\n   gif = DGifOpenFileHandle(fd);\n#endif\n   if (!gif)\n     {\n        close(fd);\n        return 0;\n     }\n\n   rc = 0;                      /* Failure */\n\n   do\n     {\n        if (DGifGetRecordType(gif, &rec) == GIF_ERROR)\n          {\n             /* PrintGifError(); */\n             rec = TERMINATE_RECORD_TYPE;\n          }\n        if ((rec == IMAGE_DESC_RECORD_TYPE) && (!done))\n          {\n             if (DGifGetImageDesc(gif) == GIF_ERROR)\n               {\n                  /* PrintGifError(); */\n                  rec = TERMINATE_RECORD_TYPE;\n               }\n             w = gif->Image.Width;\n             h = gif->Image.Height;\n             if (!IMAGE_DIMENSIONS_OK(w, h))\n                goto quit2;\n\n             rows = calloc(h, sizeof(GifRowType *));\n             if (!rows)\n                goto quit2;\n\n             for (i = 0; i < h; i++)\n               {\n                  rows[i] = malloc(w * sizeof(GifPixelType));\n                  if (!rows[i])\n                     goto quit;\n               }\n\n             if (gif->Image.Interlace)\n               {\n                  for (i = 0; i < 4; i++)\n                    {\n                       for (j = intoffset[i]; j < h; j += intjump[i])\n                         {\n                            DGifGetLine(gif, rows[j], w);\n                         }\n                    }\n               }\n             else\n               {\n                  for (i = 0; i < h; i++)\n                    {\n                       DGifGetLine(gif, rows[i], w);\n                    }\n               }\n             done = 1;\n          }\n        else if (rec == EXTENSION_RECORD_TYPE)\n          {\n             int                 ext_code;\n             GifByteType        *ext;\n\n             ext = NULL;\n             DGifGetExtension(gif, &ext_code, &ext);\n             while (ext)\n               {\n                  if ((ext_code == 0xf9) && (ext[1] & 1) && (transp < 0))\n                    {\n                       transp = (int)ext[4];\n                    }\n                  ext = NULL;\n                  DGifGetExtensionNext(gif, &ext);\n               }\n          }\n     }\n   while (rec != TERMINATE_RECORD_TYPE);\n\n   if (transp >= 0)\n     {\n        SET_FLAG(im->flags, F_HAS_ALPHA);\n     }\n   else\n     {\n        UNSET_FLAG(im->flags, F_HAS_ALPHA);\n     }\n\n   /* set the format string member to the lower-case full extension */\n   /* name for the format - so example names would be: */\n   /* \"png\", \"jpeg\", \"tiff\", \"ppm\", \"pgm\", \"pbm\", \"gif\", \"xpm\" ... */\n   im->w = w;\n   im->h = h;\n   if (!im->format)\n      im->format = strdup(\"gif\");\n\n   if (im->loader || immediate_load || progress)\n     {\n        bg = gif->SBackGroundColor;\n        cmap = (gif->Image.ColorMap ? gif->Image.ColorMap : gif->SColorMap);\n        im->data = (DATA32 *) malloc(sizeof(DATA32) * w * h);\n         if (!im->data)\n            goto quit;\n \n         ptr = im->data;\n         per_inc = 100.0 / (((float)w) * h);\n         for (i = 0; i < h; i++)\n                       *ptr++ = 0x00ffffff & ((r << 16) | (g << 8) | b);\n                    }\n                  else\n                    {\n                       r = cmap->Colors[rows[i][j]].Red;\n                       g = cmap->Colors[rows[i][j]].Green;\n                       b = cmap->Colors[rows[i][j]].Blue;\n                       *ptr++ = (0xff << 24) | (r << 16) | (g << 8) | b;\n                    }\n                  per += per_inc;\n                  if (progress && (((int)per) != last_per)\n                      && (((int)per) % progress_granularity == 0))\n                    {\n                       last_per = (int)per;\n                       if (!(progress(im, (int)per, 0, last_y, w, i)))\n                         {\n                            rc = 2;\n                            goto quit;\n                         }\n                       last_y = i;\n                    }\n               }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141623,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "load(ImlibImage * im, ImlibProgressFunction progress, char progress_granularity,\n     char immediate_load)\n{\n   static const int    intoffset[] = { 0, 4, 2, 1 };\n   static const int    intjump[] = { 8, 8, 4, 2 };\n   int                 rc;\n   DATA32             *ptr;\n   GifFileType        *gif;\n   GifRowType         *rows;\n   GifRecordType       rec;\n   ColorMapObject     *cmap;\n   int                 i, j, done, bg, r, g, b, w = 0, h = 0;\n   float               per = 0.0, per_inc;\n   int                 last_per = 0, last_y = 0;\n   int                 transp;\n   int                 fd;\n\n   done = 0;\n   rows = NULL;\n   transp = -1;\n\n   /* if immediate_load is 1, then dont delay image laoding as below, or */\n   /* already data in this image - dont load it again */\n   if (im->data)\n      return 0;\n\n   fd = open(im->real_file, O_RDONLY);\n   if (fd < 0)\n      return 0;\n\n#if GIFLIB_MAJOR >= 5\n   gif = DGifOpenFileHandle(fd, NULL);\n#else\n   gif = DGifOpenFileHandle(fd);\n#endif\n   if (!gif)\n     {\n        close(fd);\n        return 0;\n     }\n\n   rc = 0;                      /* Failure */\n\n   do\n     {\n        if (DGifGetRecordType(gif, &rec) == GIF_ERROR)\n          {\n             /* PrintGifError(); */\n             rec = TERMINATE_RECORD_TYPE;\n          }\n        if ((rec == IMAGE_DESC_RECORD_TYPE) && (!done))\n          {\n             if (DGifGetImageDesc(gif) == GIF_ERROR)\n               {\n                  /* PrintGifError(); */\n                  rec = TERMINATE_RECORD_TYPE;\n               }\n             w = gif->Image.Width;\n             h = gif->Image.Height;\n             if (!IMAGE_DIMENSIONS_OK(w, h))\n                goto quit2;\n\n             rows = calloc(h, sizeof(GifRowType *));\n             if (!rows)\n                goto quit2;\n\n             for (i = 0; i < h; i++)\n               {\n                  rows[i] = malloc(w * sizeof(GifPixelType));\n                  if (!rows[i])\n                     goto quit;\n               }\n\n             if (gif->Image.Interlace)\n               {\n                  for (i = 0; i < 4; i++)\n                    {\n                       for (j = intoffset[i]; j < h; j += intjump[i])\n                         {\n                            DGifGetLine(gif, rows[j], w);\n                         }\n                    }\n               }\n             else\n               {\n                  for (i = 0; i < h; i++)\n                    {\n                       DGifGetLine(gif, rows[i], w);\n                    }\n               }\n             done = 1;\n          }\n        else if (rec == EXTENSION_RECORD_TYPE)\n          {\n             int                 ext_code;\n             GifByteType        *ext;\n\n             ext = NULL;\n             DGifGetExtension(gif, &ext_code, &ext);\n             while (ext)\n               {\n                  if ((ext_code == 0xf9) && (ext[1] & 1) && (transp < 0))\n                    {\n                       transp = (int)ext[4];\n                    }\n                  ext = NULL;\n                  DGifGetExtensionNext(gif, &ext);\n               }\n          }\n     }\n   while (rec != TERMINATE_RECORD_TYPE);\n\n   if (transp >= 0)\n     {\n        SET_FLAG(im->flags, F_HAS_ALPHA);\n     }\n   else\n     {\n        UNSET_FLAG(im->flags, F_HAS_ALPHA);\n     }\n\n   /* set the format string member to the lower-case full extension */\n   /* name for the format - so example names would be: */\n   /* \"png\", \"jpeg\", \"tiff\", \"ppm\", \"pgm\", \"pbm\", \"gif\", \"xpm\" ... */\n   im->w = w;\n   im->h = h;\n   if (!im->format)\n      im->format = strdup(\"gif\");\n\n   if (im->loader || immediate_load || progress)\n     {\n        bg = gif->SBackGroundColor;\n        cmap = (gif->Image.ColorMap ? gif->Image.ColorMap : gif->SColorMap);\n        im->data = (DATA32 *) malloc(sizeof(DATA32) * w * h);\n         if (!im->data)\n            goto quit;\n \n        if (!cmap)\n          {\n             /* No colormap? Now what?? Let's clear the image (and not segv) */\n             memset(im->data, 0, sizeof(DATA32) * w * h);\n             rc = 1;\n             goto finish;\n          }\n\n         ptr = im->data;\n         per_inc = 100.0 / (((float)w) * h);\n         for (i = 0; i < h; i++)\n                       *ptr++ = 0x00ffffff & ((r << 16) | (g << 8) | b);\n                    }\n                  else\n                    {\n                       r = cmap->Colors[rows[i][j]].Red;\n                       g = cmap->Colors[rows[i][j]].Green;\n                       b = cmap->Colors[rows[i][j]].Blue;\n                       *ptr++ = (0xff << 24) | (r << 16) | (g << 8) | b;\n                    }\n                  per += per_inc;\n                  if (progress && (((int)per) != last_per)\n                      && (((int)per) % progress_granularity == 0))\n                    {\n                       last_per = (int)per;\n                       if (!(progress(im, (int)per, 0, last_y, w, i)))\n                         {\n                            rc = 2;\n                            goto quit;\n                         }\n                       last_y = i;\n                    }\n               }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141624,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "  cid_parse_font_matrix( CID_Face     face,\n                         CID_Parser*  parser )\n  {\n    CID_FaceDict  dict;\n    FT_Face       root = (FT_Face)&face->root;\n    FT_Fixed      temp[6];\n    FT_Fixed      temp_scale;\n\n\n    if ( parser->num_dict >= 0 && parser->num_dict < face->cid.num_dicts )\n     {\n       FT_Matrix*  matrix;\n       FT_Vector*  offset;\n \n \n       dict   = face->cid.font_dicts + parser->num_dict;\n       matrix = &dict->font_matrix;\n       offset = &dict->font_offset;\n \n      (void)cid_parser_to_fixed_array( parser, 6, temp, 3 );\n \n       temp_scale = FT_ABS( temp[3] );\n \n       /* Set Units per EM based on FontMatrix values.  We set the value to */\n       /* 1000 / temp_scale, because temp_scale was already multiplied by   */\n       /* 1000 (in t1_tofixed, from psobjs.c).                              */\n        temp[5] = FT_DivFix( temp[5], temp_scale );\n        temp[3] = 0x10000L;\n      }\n\n      matrix->xx = temp[0];\n      matrix->yx = temp[1];\n      matrix->xy = temp[2];\n      matrix->yy = temp[3];\n         temp[2] = FT_DivFix( temp[2], temp_scale );\n         temp[4] = FT_DivFix( temp[4], temp_scale );\n         temp[5] = FT_DivFix( temp[5], temp_scale );\n        temp[3] = 0x10000L;\n       }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141625,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "  cid_parse_font_matrix( CID_Face     face,\n                         CID_Parser*  parser )\n  {\n    CID_FaceDict  dict;\n    FT_Face       root = (FT_Face)&face->root;\n    FT_Fixed      temp[6];\n    FT_Fixed      temp_scale;\n\n\n    if ( parser->num_dict >= 0 && parser->num_dict < face->cid.num_dicts )\n     {\n       FT_Matrix*  matrix;\n       FT_Vector*  offset;\n      FT_Int      result;\n \n \n       dict   = face->cid.font_dicts + parser->num_dict;\n       matrix = &dict->font_matrix;\n       offset = &dict->font_offset;\n \n      result = cid_parser_to_fixed_array( parser, 6, temp, 3 );\n\n      if ( result < 6 )\n        return FT_THROW( Invalid_File_Format );\n \n       temp_scale = FT_ABS( temp[3] );\n \n      if ( temp_scale == 0 )\n      {\n        FT_ERROR(( \"cid_parse_font_matrix: invalid font matrix\\n\" ));\n        return FT_THROW( Invalid_File_Format );\n      }\n\n       /* Set Units per EM based on FontMatrix values.  We set the value to */\n       /* 1000 / temp_scale, because temp_scale was already multiplied by   */\n       /* 1000 (in t1_tofixed, from psobjs.c).                              */\n        temp[5] = FT_DivFix( temp[5], temp_scale );\n        temp[3] = 0x10000L;\n      }\n\n      matrix->xx = temp[0];\n      matrix->yx = temp[1];\n      matrix->xy = temp[2];\n      matrix->yy = temp[3];\n         temp[2] = FT_DivFix( temp[2], temp_scale );\n         temp[4] = FT_DivFix( temp[4], temp_scale );\n         temp[5] = FT_DivFix( temp[5], temp_scale );\n        temp[3] = temp[3] < 0 ? -0x10000L : 0x10000L;\n       }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141626,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "  t1_parse_font_matrix( T1_Face    face,\n                        T1_Loader  loader )\n  {\n    T1_Parser   parser = &loader->parser;\n    FT_Matrix*  matrix = &face->type1.font_matrix;\n    FT_Vector*  offset = &face->type1.font_offset;\n    FT_Face     root   = (FT_Face)&face->root;\n    FT_Fixed    temp[6];\n    FT_Fixed    temp_scale;\n    FT_Int      result;\n\n \n     result = T1_ToFixedArray( parser, 6, temp, 3 );\n \n    if ( result < 0 )\n     {\n       parser->root.error = FT_THROW( Invalid_File_Format );\n       return;\n    }\n\n    temp_scale = FT_ABS( temp[3] );\n\n    if ( temp_scale == 0 )\n    {\n      FT_ERROR(( \"t1_parse_font_matrix: invalid font matrix\\n\" ));\n      parser->root.error = FT_THROW( Invalid_File_Format );\n      return;\n    }\n\n    /* Set Units per EM based on FontMatrix values.  We set the value to */\n    /* 1000 / temp_scale, because temp_scale was already multiplied by   */\n    /* 1000 (in t1_tofixed, from psobjs.c).                              */\n\n    root->units_per_EM = (FT_UShort)FT_DivFix( 1000, temp_scale );\n\n    /* we need to scale the values by 1.0/temp_scale */\n    if ( temp_scale != 0x10000L )\n    {\n      temp[0] = FT_DivFix( temp[0], temp_scale );\n      temp[1] = FT_DivFix( temp[1], temp_scale );\n      temp[2] = FT_DivFix( temp[2], temp_scale );\n      temp[4] = FT_DivFix( temp[4], temp_scale );\n      temp[5] = FT_DivFix( temp[5], temp_scale );\n      temp[3] = temp[3] < 0 ? -0x10000L : 0x10000L;\n    }\n\n    matrix->xx = temp[0];\n    matrix->yx = temp[1];\n    matrix->xy = temp[2];\n    matrix->yy = temp[3];\n\n    /* note that the offsets must be expressed in integer font units */\n    offset->x = temp[4] >> 16;\n    offset->y = temp[5] >> 16;\n  }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141627,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "  t1_parse_font_matrix( T1_Face    face,\n                        T1_Loader  loader )\n  {\n    T1_Parser   parser = &loader->parser;\n    FT_Matrix*  matrix = &face->type1.font_matrix;\n    FT_Vector*  offset = &face->type1.font_offset;\n    FT_Face     root   = (FT_Face)&face->root;\n    FT_Fixed    temp[6];\n    FT_Fixed    temp_scale;\n    FT_Int      result;\n\n \n     result = T1_ToFixedArray( parser, 6, temp, 3 );\n \n    if ( result < 6 )\n     {\n       parser->root.error = FT_THROW( Invalid_File_Format );\n       return;\n    }\n\n    temp_scale = FT_ABS( temp[3] );\n\n    if ( temp_scale == 0 )\n    {\n      FT_ERROR(( \"t1_parse_font_matrix: invalid font matrix\\n\" ));\n      parser->root.error = FT_THROW( Invalid_File_Format );\n      return;\n    }\n\n    /* Set Units per EM based on FontMatrix values.  We set the value to */\n    /* 1000 / temp_scale, because temp_scale was already multiplied by   */\n    /* 1000 (in t1_tofixed, from psobjs.c).                              */\n\n    root->units_per_EM = (FT_UShort)FT_DivFix( 1000, temp_scale );\n\n    /* we need to scale the values by 1.0/temp_scale */\n    if ( temp_scale != 0x10000L )\n    {\n      temp[0] = FT_DivFix( temp[0], temp_scale );\n      temp[1] = FT_DivFix( temp[1], temp_scale );\n      temp[2] = FT_DivFix( temp[2], temp_scale );\n      temp[4] = FT_DivFix( temp[4], temp_scale );\n      temp[5] = FT_DivFix( temp[5], temp_scale );\n      temp[3] = temp[3] < 0 ? -0x10000L : 0x10000L;\n    }\n\n    matrix->xx = temp[0];\n    matrix->yx = temp[1];\n    matrix->xy = temp[2];\n    matrix->yy = temp[3];\n\n    /* note that the offsets must be expressed in integer font units */\n    offset->x = temp[4] >> 16;\n    offset->y = temp[5] >> 16;\n  }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141628,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "  t42_parse_font_matrix( T42_Face    face,\n                         T42_Loader  loader )\n  {\n    T42_Parser  parser = &loader->parser;\n    FT_Matrix*  matrix = &face->type1.font_matrix;\n    FT_Vector*  offset = &face->type1.font_offset;\n     FT_Face     root   = (FT_Face)&face->root;\n     FT_Fixed    temp[6];\n     FT_Fixed    temp_scale;\n \n \n    (void)T1_ToFixedArray( parser, 6, temp, 3 );\n \n     temp_scale = FT_ABS( temp[3] );\n \n     /* Set Units per EM based on FontMatrix values.  We set the value to */\n     /* 1000 / temp_scale, because temp_scale was already multiplied by   */\n     /* 1000 (in t1_tofixed, from psobjs.c).                              */\n    matrix->xx = temp[0];\n    matrix->yx = temp[1];\n    matrix->xy = temp[2];\n    matrix->yy = temp[3];\n\n    /* note that the offsets must be expressed in integer font units */\n    offset->x = temp[4] >> 16;\n    offset->y = temp[5] >> 16;\n       temp[2] = FT_DivFix( temp[2], temp_scale );\n       temp[4] = FT_DivFix( temp[4], temp_scale );\n       temp[5] = FT_DivFix( temp[5], temp_scale );\n      temp[3] = 0x10000L;\n     }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141629,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "  t42_parse_font_matrix( T42_Face    face,\n                         T42_Loader  loader )\n  {\n    T42_Parser  parser = &loader->parser;\n    FT_Matrix*  matrix = &face->type1.font_matrix;\n    FT_Vector*  offset = &face->type1.font_offset;\n     FT_Face     root   = (FT_Face)&face->root;\n     FT_Fixed    temp[6];\n     FT_Fixed    temp_scale;\n    FT_Int      result;\n \n \n    result = T1_ToFixedArray( parser, 6, temp, 3 );\n\n    if ( result < 6 )\n    {\n      parser->root.error = FT_THROW( Invalid_File_Format );\n      return;\n    }\n \n     temp_scale = FT_ABS( temp[3] );\n \n    if ( temp_scale == 0 )\n    {\n      FT_ERROR(( \"t1_parse_font_matrix: invalid font matrix\\n\" ));\n      parser->root.error = FT_THROW( Invalid_File_Format );\n      return;\n    }\n\n     /* Set Units per EM based on FontMatrix values.  We set the value to */\n     /* 1000 / temp_scale, because temp_scale was already multiplied by   */\n     /* 1000 (in t1_tofixed, from psobjs.c).                              */\n    matrix->xx = temp[0];\n    matrix->yx = temp[1];\n    matrix->xy = temp[2];\n    matrix->yy = temp[3];\n\n    /* note that the offsets must be expressed in integer font units */\n    offset->x = temp[4] >> 16;\n    offset->y = temp[5] >> 16;\n       temp[2] = FT_DivFix( temp[2], temp_scale );\n       temp[4] = FT_DivFix( temp[4], temp_scale );\n       temp[5] = FT_DivFix( temp[5], temp_scale );\n      temp[3] = temp[3] < 0 ? -0x10000L : 0x10000L;\n     }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141630,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void ssl3_take_mac(SSL *s)\n        {\n        const char *sender;\n        int slen;\n        if (s->state & SSL_ST_CONNECT)\n                {\n                sender=s->method->ssl3_enc->server_finished_label;\n\t\tsender=s->method->ssl3_enc->client_finished_label;\n\t\tslen=s->method->ssl3_enc->client_finished_label_len;\n\t\t}\n\n\ts->s3->tmp.peer_finish_md_len = s->method->ssl3_enc->final_finish_mac(s,\n\t\tsender,slen,s->s3->tmp.peer_finish_md);\n\t}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141635,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void ssl3_take_mac(SSL *s)\n        {\n        const char *sender;\n        int slen;\n       /* If no new cipher setup return immediately: other functions will\n        * set the appropriate error.\n        */\n       if (s->s3->tmp.new_cipher == NULL)\n               return;\n        if (s->state & SSL_ST_CONNECT)\n                {\n                sender=s->method->ssl3_enc->server_finished_label;\n\t\tsender=s->method->ssl3_enc->client_finished_label;\n\t\tslen=s->method->ssl3_enc->client_finished_label_len;\n\t\t}\n\n\ts->s3->tmp.peer_finish_md_len = s->method->ssl3_enc->final_finish_mac(s,\n\t\tsender,slen,s->s3->tmp.peer_finish_md);\n\t}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141636,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void add_probe(const char *name)\n {\n \tstruct module_entry *m;\n \n \tm = get_or_add_modentry(name);\n \tif (!(option_mask32 & (OPT_REMOVE | OPT_SHOW_DEPS))\n \t && (m->flags & MODULE_FLAG_LOADED)\n\t && strncmp(m->modname, \"symbol:\", 7) == 0\n\t) {\n\t\tG.need_symbols = 1;\n\t}\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141639,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void add_probe(const char *name)\n {\n \tstruct module_entry *m;\n \n\t/*\n\t * get_or_add_modentry() strips path from name and works\n\t * on remaining basename.\n\t * This would make \"rmmod dir/name\" and \"modprobe dir/name\"\n\t * to work like \"rmmod name\" and \"modprobe name\",\n\t * which is wrong, and can be abused via implicit modprobing:\n\t * \"ifconfig /usbserial up\" tries to modprobe netdev-/usbserial.\n\t */\n\tif (strchr(name, '/'))\n\t\tbb_error_msg_and_die(\"malformed module name '%s'\", name);\n\n \tm = get_or_add_modentry(name);\n \tif (!(option_mask32 & (OPT_REMOVE | OPT_SHOW_DEPS))\n \t && (m->flags & MODULE_FLAG_LOADED)\n\t && strncmp(m->modname, \"symbol:\", 7) == 0\n\t) {\n\t\tG.need_symbols = 1;\n\t}\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141640,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "ProcXIChangeHierarchy(ClientPtr client)\n{\n    xXIAnyHierarchyChangeInfo *any;\n    size_t len;\t\t\t/* length of data remaining in request */\n    int rc = Success;\n    int flags[MAXDEVICES] = { 0 };\n\n    REQUEST(xXIChangeHierarchyReq);\n    REQUEST_AT_LEAST_SIZE(xXIChangeHierarchyReq);\n\n     if (!stuff->num_changes)\n         return rc;\n \n    len = ((size_t)stuff->length << 2) - sizeof(xXIAnyHierarchyChangeInfo);\n \n     any = (xXIAnyHierarchyChangeInfo *) &stuff[1];\n     while (stuff->num_changes--) {\n        if (len < sizeof(xXIAnyHierarchyChangeInfo)) {\n            rc = BadLength;\n            goto unwind;\n        }\n\n        SWAPIF(swaps(&any->type));\n        SWAPIF(swaps(&any->length));\n\n        if (len < ((size_t)any->length << 2))\n            return BadLength;\n\n#define CHANGE_SIZE_MATCH(type) \\\n    do { \\\n        if ((len < sizeof(type)) || (any->length != (sizeof(type) >> 2))) { \\\n            rc = BadLength; \\\n            goto unwind; \\\n        } \\\n    } while(0)\n\n        switch (any->type) {\n        case XIAddMaster:\n        {\n            xXIAddMasterInfo *c = (xXIAddMasterInfo *) any;\n\n            /* Variable length, due to appended name string */\n            if (len < sizeof(xXIAddMasterInfo)) {\n                rc = BadLength;\n                goto unwind;\n            }\n            SWAPIF(swaps(&c->name_len));\n            if (c->name_len > (len - sizeof(xXIAddMasterInfo))) {\n                rc = BadLength;\n                goto unwind;\n            }\n\n            rc = add_master(client, c, flags);\n            if (rc != Success)\n                goto unwind;\n        }\n            break;\n        case XIRemoveMaster:\n        {\n            xXIRemoveMasterInfo *r = (xXIRemoveMasterInfo *) any;\n\n            CHANGE_SIZE_MATCH(xXIRemoveMasterInfo);\n            rc = remove_master(client, r, flags);\n            if (rc != Success)\n                goto unwind;\n        }\n            break;\n        case XIDetachSlave:\n        {\n            xXIDetachSlaveInfo *c = (xXIDetachSlaveInfo *) any;\n\n            CHANGE_SIZE_MATCH(xXIDetachSlaveInfo);\n            rc = detach_slave(client, c, flags);\n            if (rc != Success)\n                goto unwind;\n        }\n            break;\n        case XIAttachSlave:\n        {\n            xXIAttachSlaveInfo *c = (xXIAttachSlaveInfo *) any;\n\n            CHANGE_SIZE_MATCH(xXIAttachSlaveInfo);\n            rc = attach_slave(client, c, flags);\n            if (rc != Success)\n                goto unwind;\n        }\n            break;\n        }\n\n        len -= any->length * 4;\n        any = (xXIAnyHierarchyChangeInfo *) ((char *) any + any->length * 4);\n    }\n\n unwind:\n\n    XISendDeviceHierarchyEvent(flags);\n    return rc;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141649,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "ProcXIChangeHierarchy(ClientPtr client)\n{\n    xXIAnyHierarchyChangeInfo *any;\n    size_t len;\t\t\t/* length of data remaining in request */\n    int rc = Success;\n    int flags[MAXDEVICES] = { 0 };\n\n    REQUEST(xXIChangeHierarchyReq);\n    REQUEST_AT_LEAST_SIZE(xXIChangeHierarchyReq);\n\n     if (!stuff->num_changes)\n         return rc;\n \n    len = ((size_t)stuff->length << 2) - sizeof(xXIChangeHierarchyReq);\n \n     any = (xXIAnyHierarchyChangeInfo *) &stuff[1];\n     while (stuff->num_changes--) {\n        if (len < sizeof(xXIAnyHierarchyChangeInfo)) {\n            rc = BadLength;\n            goto unwind;\n        }\n\n        SWAPIF(swaps(&any->type));\n        SWAPIF(swaps(&any->length));\n\n        if (len < ((size_t)any->length << 2))\n            return BadLength;\n\n#define CHANGE_SIZE_MATCH(type) \\\n    do { \\\n        if ((len < sizeof(type)) || (any->length != (sizeof(type) >> 2))) { \\\n            rc = BadLength; \\\n            goto unwind; \\\n        } \\\n    } while(0)\n\n        switch (any->type) {\n        case XIAddMaster:\n        {\n            xXIAddMasterInfo *c = (xXIAddMasterInfo *) any;\n\n            /* Variable length, due to appended name string */\n            if (len < sizeof(xXIAddMasterInfo)) {\n                rc = BadLength;\n                goto unwind;\n            }\n            SWAPIF(swaps(&c->name_len));\n            if (c->name_len > (len - sizeof(xXIAddMasterInfo))) {\n                rc = BadLength;\n                goto unwind;\n            }\n\n            rc = add_master(client, c, flags);\n            if (rc != Success)\n                goto unwind;\n        }\n            break;\n        case XIRemoveMaster:\n        {\n            xXIRemoveMasterInfo *r = (xXIRemoveMasterInfo *) any;\n\n            CHANGE_SIZE_MATCH(xXIRemoveMasterInfo);\n            rc = remove_master(client, r, flags);\n            if (rc != Success)\n                goto unwind;\n        }\n            break;\n        case XIDetachSlave:\n        {\n            xXIDetachSlaveInfo *c = (xXIDetachSlaveInfo *) any;\n\n            CHANGE_SIZE_MATCH(xXIDetachSlaveInfo);\n            rc = detach_slave(client, c, flags);\n            if (rc != Success)\n                goto unwind;\n        }\n            break;\n        case XIAttachSlave:\n        {\n            xXIAttachSlaveInfo *c = (xXIAttachSlaveInfo *) any;\n\n            CHANGE_SIZE_MATCH(xXIAttachSlaveInfo);\n            rc = attach_slave(client, c, flags);\n            if (rc != Success)\n                goto unwind;\n        }\n            break;\n        }\n\n        len -= any->length * 4;\n        any = (xXIAnyHierarchyChangeInfo *) ((char *) any + any->length * 4);\n    }\n\n unwind:\n\n    XISendDeviceHierarchyEvent(flags);\n    return rc;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141650,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "ProcEstablishConnection(ClientPtr client)\n{\n    const char *reason;\n    char *auth_proto, *auth_string;\n    xConnClientPrefix *prefix;\n\n    REQUEST(xReq);\n\n     prefix = (xConnClientPrefix *) ((char *) stuff + sz_xReq);\n     auth_proto = (char *) prefix + sz_xConnClientPrefix;\n     auth_string = auth_proto + pad_to_int32(prefix->nbytesAuthProto);\n    if ((prefix->majorVersion != X_PROTOCOL) ||\n         (prefix->minorVersion != X_PROTOCOL_REVISION))\n         reason = \"Protocol version mismatch\";\n     else\n\n    return (SendConnSetup(client, reason));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141653,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "ProcEstablishConnection(ClientPtr client)\n{\n    const char *reason;\n    char *auth_proto, *auth_string;\n    xConnClientPrefix *prefix;\n\n    REQUEST(xReq);\n\n     prefix = (xConnClientPrefix *) ((char *) stuff + sz_xReq);\n     auth_proto = (char *) prefix + sz_xConnClientPrefix;\n     auth_string = auth_proto + pad_to_int32(prefix->nbytesAuthProto);\n\n    if ((client->req_len << 2) != sz_xReq + sz_xConnClientPrefix +\n\tpad_to_int32(prefix->nbytesAuthProto) +\n\tpad_to_int32(prefix->nbytesAuthString))\n        reason = \"Bad length\";\n    else if ((prefix->majorVersion != X_PROTOCOL) ||\n         (prefix->minorVersion != X_PROTOCOL_REVISION))\n         reason = \"Protocol version mismatch\";\n     else\n\n    return (SendConnSetup(client, reason));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141654,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int try_read_command(conn *c) {\n    assert(c != NULL);\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n    assert(c->rbytes > 0);\n\n    if (c->protocol == negotiating_prot || c->transport == udp_transport)  {\n        if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {\n            c->protocol = binary_prot;\n        } else {\n            c->protocol = ascii_prot;\n        }\n\n        if (settings.verbose > 1) {\n            fprintf(stderr, \"%d: Client using the %s protocol\\n\", c->sfd,\n                    prot_text(c->protocol));\n        }\n    }\n\n    if (c->protocol == binary_prot) {\n        /* Do we have the complete packet header? */\n        if (c->rbytes < sizeof(c->binary_header)) {\n            /* need more data! */\n            return 0;\n        } else {\n#ifdef NEED_ALIGN\n            if (((long)(c->rcurr)) % 8 != 0) {\n                /* must realign input buffer */\n                memmove(c->rbuf, c->rcurr, c->rbytes);\n                c->rcurr = c->rbuf;\n                if (settings.verbose > 1) {\n                    fprintf(stderr, \"%d: Realign input buffer\\n\", c->sfd);\n                }\n            }\n#endif\n            protocol_binary_request_header* req;\n            req = (protocol_binary_request_header*)c->rcurr;\n\n            if (settings.verbose > 1) {\n                /* Dump the packet before we convert it to host order */\n                int ii;\n                fprintf(stderr, \"<%d Read binary protocol data:\", c->sfd);\n                for (ii = 0; ii < sizeof(req->bytes); ++ii) {\n                    if (ii % 4 == 0) {\n                        fprintf(stderr, \"\\n<%d   \", c->sfd);\n                    }\n                    fprintf(stderr, \" 0x%02x\", req->bytes[ii]);\n                }\n                fprintf(stderr, \"\\n\");\n            }\n\n            c->binary_header = *req;\n            c->binary_header.request.keylen = ntohs(req->request.keylen);\n            c->binary_header.request.bodylen = ntohl(req->request.bodylen);\n            c->binary_header.request.cas = ntohll(req->request.cas);\n\n            if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {\n                if (settings.verbose) {\n                    fprintf(stderr, \"Invalid magic:  %x\\n\",\n                            c->binary_header.request.magic);\n                }\n                conn_set_state(c, conn_closing);\n                return -1;\n            }\n\n            c->msgcurr = 0;\n            c->msgused = 0;\n            c->iovused = 0;\n            if (add_msghdr(c) != 0) {\n                out_string(c, \"SERVER_ERROR out of memory\");\n                return 0;\n            }\n\n            c->cmd = c->binary_header.request.opcode;\n            c->keylen = c->binary_header.request.keylen;\n            c->opaque = c->binary_header.request.opaque;\n            /* clear the returned cas value */\n            c->cas = 0;\n\n            dispatch_bin_command(c);\n\n            c->rbytes -= sizeof(c->binary_header);\n            c->rcurr += sizeof(c->binary_header);\n        }\n    } else {\n        char *el, *cont;\n\n        if (c->rbytes == 0)\n            return 0;\n\n        el = memchr(c->rcurr, '\\n', c->rbytes);\n        if (!el) {\n            if (c->rbytes > 1024) {\n                /*\n                 * We didn't have a '\\n' in the first k. This _has_ to be a\n                 * large multiget, if not we should just nuke the connection.\n                 */\n                char *ptr = c->rcurr;\n                while (*ptr == ' ') { /* ignore leading whitespaces */\n                     ++ptr;\n                 }\n \n                if (strcmp(ptr, \"get \") && strcmp(ptr, \"gets \")) {\n                     conn_set_state(c, conn_closing);\n                     return 1;\n                 }\n            }\n\n            return 0;\n        }\n        cont = el + 1;\n        if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {\n            el--;\n        }\n        *el = '\\0';\n\n        assert(cont <= (c->rcurr + c->rbytes));\n\n        process_command(c, c->rcurr);\n\n        c->rbytes -= (cont - c->rcurr);\n        c->rcurr = cont;\n\n        assert(c->rcurr <= (c->rbuf + c->rsize));\n    }\n\n    return 1;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141665,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int try_read_command(conn *c) {\n    assert(c != NULL);\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n    assert(c->rbytes > 0);\n\n    if (c->protocol == negotiating_prot || c->transport == udp_transport)  {\n        if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {\n            c->protocol = binary_prot;\n        } else {\n            c->protocol = ascii_prot;\n        }\n\n        if (settings.verbose > 1) {\n            fprintf(stderr, \"%d: Client using the %s protocol\\n\", c->sfd,\n                    prot_text(c->protocol));\n        }\n    }\n\n    if (c->protocol == binary_prot) {\n        /* Do we have the complete packet header? */\n        if (c->rbytes < sizeof(c->binary_header)) {\n            /* need more data! */\n            return 0;\n        } else {\n#ifdef NEED_ALIGN\n            if (((long)(c->rcurr)) % 8 != 0) {\n                /* must realign input buffer */\n                memmove(c->rbuf, c->rcurr, c->rbytes);\n                c->rcurr = c->rbuf;\n                if (settings.verbose > 1) {\n                    fprintf(stderr, \"%d: Realign input buffer\\n\", c->sfd);\n                }\n            }\n#endif\n            protocol_binary_request_header* req;\n            req = (protocol_binary_request_header*)c->rcurr;\n\n            if (settings.verbose > 1) {\n                /* Dump the packet before we convert it to host order */\n                int ii;\n                fprintf(stderr, \"<%d Read binary protocol data:\", c->sfd);\n                for (ii = 0; ii < sizeof(req->bytes); ++ii) {\n                    if (ii % 4 == 0) {\n                        fprintf(stderr, \"\\n<%d   \", c->sfd);\n                    }\n                    fprintf(stderr, \" 0x%02x\", req->bytes[ii]);\n                }\n                fprintf(stderr, \"\\n\");\n            }\n\n            c->binary_header = *req;\n            c->binary_header.request.keylen = ntohs(req->request.keylen);\n            c->binary_header.request.bodylen = ntohl(req->request.bodylen);\n            c->binary_header.request.cas = ntohll(req->request.cas);\n\n            if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {\n                if (settings.verbose) {\n                    fprintf(stderr, \"Invalid magic:  %x\\n\",\n                            c->binary_header.request.magic);\n                }\n                conn_set_state(c, conn_closing);\n                return -1;\n            }\n\n            c->msgcurr = 0;\n            c->msgused = 0;\n            c->iovused = 0;\n            if (add_msghdr(c) != 0) {\n                out_string(c, \"SERVER_ERROR out of memory\");\n                return 0;\n            }\n\n            c->cmd = c->binary_header.request.opcode;\n            c->keylen = c->binary_header.request.keylen;\n            c->opaque = c->binary_header.request.opaque;\n            /* clear the returned cas value */\n            c->cas = 0;\n\n            dispatch_bin_command(c);\n\n            c->rbytes -= sizeof(c->binary_header);\n            c->rcurr += sizeof(c->binary_header);\n        }\n    } else {\n        char *el, *cont;\n\n        if (c->rbytes == 0)\n            return 0;\n\n        el = memchr(c->rcurr, '\\n', c->rbytes);\n        if (!el) {\n            if (c->rbytes > 1024) {\n                /*\n                 * We didn't have a '\\n' in the first k. This _has_ to be a\n                 * large multiget, if not we should just nuke the connection.\n                 */\n                char *ptr = c->rcurr;\n                while (*ptr == ' ') { /* ignore leading whitespaces */\n                     ++ptr;\n                 }\n \n                if (ptr - c->rcurr > 100 ||\n                    (strncmp(ptr, \"get \", 4) && strncmp(ptr, \"gets \", 5))) {\n\n                     conn_set_state(c, conn_closing);\n                     return 1;\n                 }\n            }\n\n            return 0;\n        }\n        cont = el + 1;\n        if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {\n            el--;\n        }\n        *el = '\\0';\n\n        assert(cont <= (c->rcurr + c->rbytes));\n\n        process_command(c, c->rcurr);\n\n        c->rbytes -= (cont - c->rcurr);\n        c->rcurr = cont;\n\n        assert(c->rcurr <= (c->rbuf + c->rsize));\n    }\n\n    return 1;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141666,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int main(void)\n{\n\tint fd, len, sock_opt;\n\tint error;\n\tstruct cn_msg *message;\n\tstruct pollfd pfd;\n\tstruct nlmsghdr *incoming_msg;\n\tstruct cn_msg\t*incoming_cn_msg;\n\tstruct hv_kvp_msg *hv_msg;\n\tchar\t*p;\n\tchar\t*key_value;\n\tchar\t*key_name;\n\n\tdaemon(1, 0);\n\topenlog(\"KVP\", 0, LOG_USER);\n\tsyslog(LOG_INFO, \"KVP starting; pid is:%d\", getpid());\n\t/*\n\t * Retrieve OS release information.\n\t */\n\tkvp_get_os_info();\n\n\tif (kvp_file_init()) {\n\t\tsyslog(LOG_ERR, \"Failed to initialize the pools\");\n\t\texit(-1);\n\t}\n\n\tfd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR);\n\tif (fd < 0) {\n\t\tsyslog(LOG_ERR, \"netlink socket creation failed; error:%d\", fd);\n\t\texit(-1);\n\t}\n\taddr.nl_family = AF_NETLINK;\n\taddr.nl_pad = 0;\n\taddr.nl_pid = 0;\n\taddr.nl_groups = CN_KVP_IDX;\n\n\n\terror = bind(fd, (struct sockaddr *)&addr, sizeof(addr));\n\tif (error < 0) {\n\t\tsyslog(LOG_ERR, \"bind failed; error:%d\", error);\n\t\tclose(fd);\n\t\texit(-1);\n\t}\n\tsock_opt = addr.nl_groups;\n\tsetsockopt(fd, 270, 1, &sock_opt, sizeof(sock_opt));\n\t/*\n\t * Register ourselves with the kernel.\n\t */\n\tmessage = (struct cn_msg *)kvp_send_buffer;\n\tmessage->id.idx = CN_KVP_IDX;\n\tmessage->id.val = CN_KVP_VAL;\n\n\thv_msg = (struct hv_kvp_msg *)message->data;\n\thv_msg->kvp_hdr.operation = KVP_OP_REGISTER;\n\tmessage->ack = 0;\n\tmessage->len = sizeof(struct hv_kvp_msg);\n\n\tlen = netlink_send(fd, message);\n\tif (len < 0) {\n\t\tsyslog(LOG_ERR, \"netlink_send failed; error:%d\", len);\n\t\tclose(fd);\n\t\texit(-1);\n\t}\n\n \tpfd.fd = fd;\n \n \twhile (1) {\n \t\tpfd.events = POLLIN;\n \t\tpfd.revents = 0;\n \t\tpoll(&pfd, 1, -1);\n \n\t\tlen = recv(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0);\n \n\t\tif (len < 0) {\n\t\t\tsyslog(LOG_ERR, \"recv failed; error:%d\", len);\n \t\t\tclose(fd);\n \t\t\treturn -1;\n \t\t}\n\n\t\tincoming_msg = (struct nlmsghdr *)kvp_recv_buffer;\n\t\tincoming_cn_msg = (struct cn_msg *)NLMSG_DATA(incoming_msg);\n\t\thv_msg = (struct hv_kvp_msg *)incoming_cn_msg->data;\n\n\t\tswitch (hv_msg->kvp_hdr.operation) {\n\t\tcase KVP_OP_REGISTER:\n\t\t\t/*\n\t\t\t * Driver is registering with us; stash away the version\n\t\t\t * information.\n\t\t\t */\n\t\t\tp = (char *)hv_msg->body.kvp_register.version;\n\t\t\tlic_version = malloc(strlen(p) + 1);\n\t\t\tif (lic_version) {\n\t\t\t\tstrcpy(lic_version, p);\n\t\t\t\tsyslog(LOG_INFO, \"KVP LIC Version: %s\",\n\t\t\t\t\tlic_version);\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_ERR, \"malloc failed\");\n\t\t\t}\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The current protocol with the kernel component uses a\n\t\t * NULL key name to pass an error condition.\n\t\t * For the SET, GET and DELETE operations,\n\t\t * use the existing protocol to pass back error.\n\t\t */\n\n\t\tcase KVP_OP_SET:\n\t\t\tif (kvp_key_add_or_modify(hv_msg->kvp_hdr.pool,\n\t\t\t\t\thv_msg->body.kvp_set.data.key,\n\t\t\t\t\thv_msg->body.kvp_set.data.key_size,\n\t\t\t\t\thv_msg->body.kvp_set.data.value,\n\t\t\t\t\thv_msg->body.kvp_set.data.value_size))\n\t\t\t\tstrcpy(hv_msg->body.kvp_set.data.key, \"\");\n\t\t\tbreak;\n\n\t\tcase KVP_OP_GET:\n\t\t\tif (kvp_get_value(hv_msg->kvp_hdr.pool,\n\t\t\t\t\thv_msg->body.kvp_set.data.key,\n\t\t\t\t\thv_msg->body.kvp_set.data.key_size,\n\t\t\t\t\thv_msg->body.kvp_set.data.value,\n\t\t\t\t\thv_msg->body.kvp_set.data.value_size))\n\t\t\t\tstrcpy(hv_msg->body.kvp_set.data.key, \"\");\n\t\t\tbreak;\n\n\t\tcase KVP_OP_DELETE:\n\t\t\tif (kvp_key_delete(hv_msg->kvp_hdr.pool,\n\t\t\t\t\thv_msg->body.kvp_delete.key,\n\t\t\t\t\thv_msg->body.kvp_delete.key_size))\n\t\t\t\tstrcpy(hv_msg->body.kvp_delete.key, \"\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (hv_msg->kvp_hdr.operation != KVP_OP_ENUMERATE)\n\t\t\tgoto kvp_done;\n\n\t\t/*\n\t\t * If the pool is KVP_POOL_AUTO, dynamically generate\n\t\t * both the key and the value; if not read from the\n\t\t * appropriate pool.\n\t\t */\n\t\tif (hv_msg->kvp_hdr.pool != KVP_POOL_AUTO) {\n\t\t\tkvp_pool_enumerate(hv_msg->kvp_hdr.pool,\n\t\t\t\t\thv_msg->body.kvp_enum_data.index,\n\t\t\t\t\thv_msg->body.kvp_enum_data.data.key,\n\t\t\t\t\tHV_KVP_EXCHANGE_MAX_KEY_SIZE,\n\t\t\t\t\thv_msg->body.kvp_enum_data.data.value,\n\t\t\t\t\tHV_KVP_EXCHANGE_MAX_VALUE_SIZE);\n\t\t\tgoto kvp_done;\n\t\t}\n\n\t\thv_msg = (struct hv_kvp_msg *)incoming_cn_msg->data;\n\t\tkey_name = (char *)hv_msg->body.kvp_enum_data.data.key;\n\t\tkey_value = (char *)hv_msg->body.kvp_enum_data.data.value;\n\n\t\tswitch (hv_msg->body.kvp_enum_data.index) {\n\t\tcase FullyQualifiedDomainName:\n\t\t\tkvp_get_domain_name(key_value,\n\t\t\t\t\tHV_KVP_EXCHANGE_MAX_VALUE_SIZE);\n\t\t\tstrcpy(key_name, \"FullyQualifiedDomainName\");\n\t\t\tbreak;\n\t\tcase IntegrationServicesVersion:\n\t\t\tstrcpy(key_name, \"IntegrationServicesVersion\");\n\t\t\tstrcpy(key_value, lic_version);\n\t\t\tbreak;\n\t\tcase NetworkAddressIPv4:\n\t\t\tkvp_get_ip_address(AF_INET, key_value,\n\t\t\t\t\tHV_KVP_EXCHANGE_MAX_VALUE_SIZE);\n\t\t\tstrcpy(key_name, \"NetworkAddressIPv4\");\n\t\t\tbreak;\n\t\tcase NetworkAddressIPv6:\n\t\t\tkvp_get_ip_address(AF_INET6, key_value,\n\t\t\t\t\tHV_KVP_EXCHANGE_MAX_VALUE_SIZE);\n\t\t\tstrcpy(key_name, \"NetworkAddressIPv6\");\n\t\t\tbreak;\n\t\tcase OSBuildNumber:\n\t\t\tstrcpy(key_value, os_build);\n\t\t\tstrcpy(key_name, \"OSBuildNumber\");\n\t\t\tbreak;\n\t\tcase OSName:\n\t\t\tstrcpy(key_value, os_name);\n\t\t\tstrcpy(key_name, \"OSName\");\n\t\t\tbreak;\n\t\tcase OSMajorVersion:\n\t\t\tstrcpy(key_value, os_major);\n\t\t\tstrcpy(key_name, \"OSMajorVersion\");\n\t\t\tbreak;\n\t\tcase OSMinorVersion:\n\t\t\tstrcpy(key_value, os_minor);\n\t\t\tstrcpy(key_name, \"OSMinorVersion\");\n\t\t\tbreak;\n\t\tcase OSVersion:\n\t\t\tstrcpy(key_value, os_build);\n\t\t\tstrcpy(key_name, \"OSVersion\");\n\t\t\tbreak;\n\t\tcase ProcessorArchitecture:\n\t\t\tstrcpy(key_value, processor_arch);\n\t\t\tstrcpy(key_name, \"ProcessorArchitecture\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(key_value, \"Unknown Key\");\n\t\t\t/*\n\t\t\t * We use a null key name to terminate enumeration.\n\t\t\t */\n\t\t\tstrcpy(key_name, \"\");\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Send the value back to the kernel. The response is\n\t\t * already in the receive buffer. Update the cn_msg header to\n\t\t * reflect the key value that has been added to the message\n\t\t */\nkvp_done:\n\n\t\tincoming_cn_msg->id.idx = CN_KVP_IDX;\n\t\tincoming_cn_msg->id.val = CN_KVP_VAL;\n\t\tincoming_cn_msg->ack = 0;\n\t\tincoming_cn_msg->len = sizeof(struct hv_kvp_msg);\n\n\t\tlen = netlink_send(fd, incoming_cn_msg);\n\t\tif (len < 0) {\n\t\t\tsyslog(LOG_ERR, \"net_link send failed; error:%d\", len);\n\t\t\texit(-1);\n\t\t}\n\t}\n\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141671,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int main(void)\n{\n\tint fd, len, sock_opt;\n\tint error;\n\tstruct cn_msg *message;\n\tstruct pollfd pfd;\n\tstruct nlmsghdr *incoming_msg;\n\tstruct cn_msg\t*incoming_cn_msg;\n\tstruct hv_kvp_msg *hv_msg;\n\tchar\t*p;\n\tchar\t*key_value;\n\tchar\t*key_name;\n\n\tdaemon(1, 0);\n\topenlog(\"KVP\", 0, LOG_USER);\n\tsyslog(LOG_INFO, \"KVP starting; pid is:%d\", getpid());\n\t/*\n\t * Retrieve OS release information.\n\t */\n\tkvp_get_os_info();\n\n\tif (kvp_file_init()) {\n\t\tsyslog(LOG_ERR, \"Failed to initialize the pools\");\n\t\texit(-1);\n\t}\n\n\tfd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR);\n\tif (fd < 0) {\n\t\tsyslog(LOG_ERR, \"netlink socket creation failed; error:%d\", fd);\n\t\texit(-1);\n\t}\n\taddr.nl_family = AF_NETLINK;\n\taddr.nl_pad = 0;\n\taddr.nl_pid = 0;\n\taddr.nl_groups = CN_KVP_IDX;\n\n\n\terror = bind(fd, (struct sockaddr *)&addr, sizeof(addr));\n\tif (error < 0) {\n\t\tsyslog(LOG_ERR, \"bind failed; error:%d\", error);\n\t\tclose(fd);\n\t\texit(-1);\n\t}\n\tsock_opt = addr.nl_groups;\n\tsetsockopt(fd, 270, 1, &sock_opt, sizeof(sock_opt));\n\t/*\n\t * Register ourselves with the kernel.\n\t */\n\tmessage = (struct cn_msg *)kvp_send_buffer;\n\tmessage->id.idx = CN_KVP_IDX;\n\tmessage->id.val = CN_KVP_VAL;\n\n\thv_msg = (struct hv_kvp_msg *)message->data;\n\thv_msg->kvp_hdr.operation = KVP_OP_REGISTER;\n\tmessage->ack = 0;\n\tmessage->len = sizeof(struct hv_kvp_msg);\n\n\tlen = netlink_send(fd, message);\n\tif (len < 0) {\n\t\tsyslog(LOG_ERR, \"netlink_send failed; error:%d\", len);\n\t\tclose(fd);\n\t\texit(-1);\n\t}\n\n \tpfd.fd = fd;\n \n \twhile (1) {\n\t\tstruct sockaddr *addr_p = (struct sockaddr *) &addr;\n\t\tsocklen_t addr_l = sizeof(addr);\n \t\tpfd.events = POLLIN;\n \t\tpfd.revents = 0;\n \t\tpoll(&pfd, 1, -1);\n \n\t\tlen = recvfrom(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0,\n\t\t\t\taddr_p, &addr_l);\n \n\t\tif (len < 0 || addr.nl_pid) {\n\t\t\tsyslog(LOG_ERR, \"recvfrom failed; pid:%u error:%d %s\",\n\t\t\t\t\taddr.nl_pid, errno, strerror(errno));\n \t\t\tclose(fd);\n \t\t\treturn -1;\n \t\t}\n\n\t\tincoming_msg = (struct nlmsghdr *)kvp_recv_buffer;\n\t\tincoming_cn_msg = (struct cn_msg *)NLMSG_DATA(incoming_msg);\n\t\thv_msg = (struct hv_kvp_msg *)incoming_cn_msg->data;\n\n\t\tswitch (hv_msg->kvp_hdr.operation) {\n\t\tcase KVP_OP_REGISTER:\n\t\t\t/*\n\t\t\t * Driver is registering with us; stash away the version\n\t\t\t * information.\n\t\t\t */\n\t\t\tp = (char *)hv_msg->body.kvp_register.version;\n\t\t\tlic_version = malloc(strlen(p) + 1);\n\t\t\tif (lic_version) {\n\t\t\t\tstrcpy(lic_version, p);\n\t\t\t\tsyslog(LOG_INFO, \"KVP LIC Version: %s\",\n\t\t\t\t\tlic_version);\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_ERR, \"malloc failed\");\n\t\t\t}\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The current protocol with the kernel component uses a\n\t\t * NULL key name to pass an error condition.\n\t\t * For the SET, GET and DELETE operations,\n\t\t * use the existing protocol to pass back error.\n\t\t */\n\n\t\tcase KVP_OP_SET:\n\t\t\tif (kvp_key_add_or_modify(hv_msg->kvp_hdr.pool,\n\t\t\t\t\thv_msg->body.kvp_set.data.key,\n\t\t\t\t\thv_msg->body.kvp_set.data.key_size,\n\t\t\t\t\thv_msg->body.kvp_set.data.value,\n\t\t\t\t\thv_msg->body.kvp_set.data.value_size))\n\t\t\t\tstrcpy(hv_msg->body.kvp_set.data.key, \"\");\n\t\t\tbreak;\n\n\t\tcase KVP_OP_GET:\n\t\t\tif (kvp_get_value(hv_msg->kvp_hdr.pool,\n\t\t\t\t\thv_msg->body.kvp_set.data.key,\n\t\t\t\t\thv_msg->body.kvp_set.data.key_size,\n\t\t\t\t\thv_msg->body.kvp_set.data.value,\n\t\t\t\t\thv_msg->body.kvp_set.data.value_size))\n\t\t\t\tstrcpy(hv_msg->body.kvp_set.data.key, \"\");\n\t\t\tbreak;\n\n\t\tcase KVP_OP_DELETE:\n\t\t\tif (kvp_key_delete(hv_msg->kvp_hdr.pool,\n\t\t\t\t\thv_msg->body.kvp_delete.key,\n\t\t\t\t\thv_msg->body.kvp_delete.key_size))\n\t\t\t\tstrcpy(hv_msg->body.kvp_delete.key, \"\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (hv_msg->kvp_hdr.operation != KVP_OP_ENUMERATE)\n\t\t\tgoto kvp_done;\n\n\t\t/*\n\t\t * If the pool is KVP_POOL_AUTO, dynamically generate\n\t\t * both the key and the value; if not read from the\n\t\t * appropriate pool.\n\t\t */\n\t\tif (hv_msg->kvp_hdr.pool != KVP_POOL_AUTO) {\n\t\t\tkvp_pool_enumerate(hv_msg->kvp_hdr.pool,\n\t\t\t\t\thv_msg->body.kvp_enum_data.index,\n\t\t\t\t\thv_msg->body.kvp_enum_data.data.key,\n\t\t\t\t\tHV_KVP_EXCHANGE_MAX_KEY_SIZE,\n\t\t\t\t\thv_msg->body.kvp_enum_data.data.value,\n\t\t\t\t\tHV_KVP_EXCHANGE_MAX_VALUE_SIZE);\n\t\t\tgoto kvp_done;\n\t\t}\n\n\t\thv_msg = (struct hv_kvp_msg *)incoming_cn_msg->data;\n\t\tkey_name = (char *)hv_msg->body.kvp_enum_data.data.key;\n\t\tkey_value = (char *)hv_msg->body.kvp_enum_data.data.value;\n\n\t\tswitch (hv_msg->body.kvp_enum_data.index) {\n\t\tcase FullyQualifiedDomainName:\n\t\t\tkvp_get_domain_name(key_value,\n\t\t\t\t\tHV_KVP_EXCHANGE_MAX_VALUE_SIZE);\n\t\t\tstrcpy(key_name, \"FullyQualifiedDomainName\");\n\t\t\tbreak;\n\t\tcase IntegrationServicesVersion:\n\t\t\tstrcpy(key_name, \"IntegrationServicesVersion\");\n\t\t\tstrcpy(key_value, lic_version);\n\t\t\tbreak;\n\t\tcase NetworkAddressIPv4:\n\t\t\tkvp_get_ip_address(AF_INET, key_value,\n\t\t\t\t\tHV_KVP_EXCHANGE_MAX_VALUE_SIZE);\n\t\t\tstrcpy(key_name, \"NetworkAddressIPv4\");\n\t\t\tbreak;\n\t\tcase NetworkAddressIPv6:\n\t\t\tkvp_get_ip_address(AF_INET6, key_value,\n\t\t\t\t\tHV_KVP_EXCHANGE_MAX_VALUE_SIZE);\n\t\t\tstrcpy(key_name, \"NetworkAddressIPv6\");\n\t\t\tbreak;\n\t\tcase OSBuildNumber:\n\t\t\tstrcpy(key_value, os_build);\n\t\t\tstrcpy(key_name, \"OSBuildNumber\");\n\t\t\tbreak;\n\t\tcase OSName:\n\t\t\tstrcpy(key_value, os_name);\n\t\t\tstrcpy(key_name, \"OSName\");\n\t\t\tbreak;\n\t\tcase OSMajorVersion:\n\t\t\tstrcpy(key_value, os_major);\n\t\t\tstrcpy(key_name, \"OSMajorVersion\");\n\t\t\tbreak;\n\t\tcase OSMinorVersion:\n\t\t\tstrcpy(key_value, os_minor);\n\t\t\tstrcpy(key_name, \"OSMinorVersion\");\n\t\t\tbreak;\n\t\tcase OSVersion:\n\t\t\tstrcpy(key_value, os_build);\n\t\t\tstrcpy(key_name, \"OSVersion\");\n\t\t\tbreak;\n\t\tcase ProcessorArchitecture:\n\t\t\tstrcpy(key_value, processor_arch);\n\t\t\tstrcpy(key_name, \"ProcessorArchitecture\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(key_value, \"Unknown Key\");\n\t\t\t/*\n\t\t\t * We use a null key name to terminate enumeration.\n\t\t\t */\n\t\t\tstrcpy(key_name, \"\");\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Send the value back to the kernel. The response is\n\t\t * already in the receive buffer. Update the cn_msg header to\n\t\t * reflect the key value that has been added to the message\n\t\t */\nkvp_done:\n\n\t\tincoming_cn_msg->id.idx = CN_KVP_IDX;\n\t\tincoming_cn_msg->id.val = CN_KVP_VAL;\n\t\tincoming_cn_msg->ack = 0;\n\t\tincoming_cn_msg->len = sizeof(struct hv_kvp_msg);\n\n\t\tlen = netlink_send(fd, incoming_cn_msg);\n\t\tif (len < 0) {\n\t\t\tsyslog(LOG_ERR, \"net_link send failed; error:%d\", len);\n\t\t\texit(-1);\n\t\t}\n\t}\n\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141672,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char l, n = 0;\n\tchar callsign[11];\n\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\n\t\tcase 0x40:\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\n\t\tcase 0x80:\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n \n \t\tcase 0xC0:\n \t\t\tl = p[1];\n \t\t\tif (*p == FAC_CCITT_DEST_NSAP) {\n \t\t\t\tmemcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);\n \t\t\t\tmemcpy(callsign, p + 12,   l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->source_call, callsign);\n\t\t\t}\n\t\t\tif (*p == FAC_CCITT_SRC_NSAP) {\n\t\t\t\tmemcpy(&facilities->dest_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12, l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->dest_call, callsign);\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141677,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char l, n = 0;\n\tchar callsign[11];\n\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\n\t\tcase 0x40:\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\n\t\tcase 0x80:\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n \n \t\tcase 0xC0:\n \t\t\tl = p[1];\n\n\t\t\t/* Prevent overflows*/\n\t\t\tif (l < 10 || l > 20)\n\t\t\t\treturn -1;\n\n \t\t\tif (*p == FAC_CCITT_DEST_NSAP) {\n \t\t\t\tmemcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);\n \t\t\t\tmemcpy(callsign, p + 12,   l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->source_call, callsign);\n\t\t\t}\n\t\t\tif (*p == FAC_CCITT_SRC_NSAP) {\n\t\t\t\tmemcpy(&facilities->dest_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12, l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->dest_call, callsign);\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141678,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int rose_parse_national(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char *pt;\n\tunsigned char l, lg, n = 0;\n\tint fac_national_digis_received = 0;\n\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\n\t\tcase 0x40:\n\t\t\tif (*p == FAC_NATIONAL_RAND)\n\t\t\t\tfacilities->rand = ((p[1] << 8) & 0xFF00) + ((p[2] << 0) & 0x00FF);\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\n\t\tcase 0x80:\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n\n\t\tcase 0xC0:\n\t\t\tl = p[1];\n\t\t\tif (*p == FAC_NATIONAL_DEST_DIGI) {\n\t\t\t\tif (!fac_national_digis_received) {\n\t\t\t\t\tmemcpy(&facilities->source_digis[0], p + 2, AX25_ADDR_LEN);\n\t\t\t\t\tfacilities->source_ndigis = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_SRC_DIGI) {\n\t\t\t\tif (!fac_national_digis_received) {\n\t\t\t\t\tmemcpy(&facilities->dest_digis[0], p + 2, AX25_ADDR_LEN);\n\t\t\t\t\tfacilities->dest_ndigis = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_FAIL_CALL) {\n\t\t\t\tmemcpy(&facilities->fail_call, p + 2, AX25_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_FAIL_ADD) {\n\t\t\t\tmemcpy(&facilities->fail_addr, p + 3, ROSE_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_DIGIS) {\n\t\t\t\tfac_national_digis_received = 1;\n \t\t\t\tfacilities->source_ndigis = 0;\n \t\t\t\tfacilities->dest_ndigis   = 0;\n \t\t\t\tfor (pt = p + 2, lg = 0 ; lg < l ; pt += AX25_ADDR_LEN, lg += AX25_ADDR_LEN) {\n\t\t\t\t\tif (pt[6] & AX25_HBIT)\n \t\t\t\t\t\tmemcpy(&facilities->dest_digis[facilities->dest_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\telse\n \t\t\t\t\t\tmemcpy(&facilities->source_digis[facilities->source_ndigis++], pt, AX25_ADDR_LEN);\n \t\t\t\t}\n \t\t\t}\n \t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141679,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int rose_parse_national(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char *pt;\n\tunsigned char l, lg, n = 0;\n\tint fac_national_digis_received = 0;\n\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\n\t\tcase 0x40:\n\t\t\tif (*p == FAC_NATIONAL_RAND)\n\t\t\t\tfacilities->rand = ((p[1] << 8) & 0xFF00) + ((p[2] << 0) & 0x00FF);\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\n\t\tcase 0x80:\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n\n\t\tcase 0xC0:\n\t\t\tl = p[1];\n\t\t\tif (*p == FAC_NATIONAL_DEST_DIGI) {\n\t\t\t\tif (!fac_national_digis_received) {\n\t\t\t\t\tmemcpy(&facilities->source_digis[0], p + 2, AX25_ADDR_LEN);\n\t\t\t\t\tfacilities->source_ndigis = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_SRC_DIGI) {\n\t\t\t\tif (!fac_national_digis_received) {\n\t\t\t\t\tmemcpy(&facilities->dest_digis[0], p + 2, AX25_ADDR_LEN);\n\t\t\t\t\tfacilities->dest_ndigis = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_FAIL_CALL) {\n\t\t\t\tmemcpy(&facilities->fail_call, p + 2, AX25_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_FAIL_ADD) {\n\t\t\t\tmemcpy(&facilities->fail_addr, p + 3, ROSE_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_DIGIS) {\n\t\t\t\tfac_national_digis_received = 1;\n \t\t\t\tfacilities->source_ndigis = 0;\n \t\t\t\tfacilities->dest_ndigis   = 0;\n \t\t\t\tfor (pt = p + 2, lg = 0 ; lg < l ; pt += AX25_ADDR_LEN, lg += AX25_ADDR_LEN) {\n\t\t\t\t\tif (pt[6] & AX25_HBIT) {\n\t\t\t\t\t\tif (facilities->dest_ndigis >= ROSE_MAX_DIGIS)\n\t\t\t\t\t\t\treturn -1;\n \t\t\t\t\t\tmemcpy(&facilities->dest_digis[facilities->dest_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (facilities->source_ndigis >= ROSE_MAX_DIGIS)\n\t\t\t\t\t\t\treturn -1;\n \t\t\t\t\t\tmemcpy(&facilities->source_digis[facilities->source_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141680,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "cifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb,\n\t\tchar *mount_data_global, const char *devname)\n{\n\tint rc;\n\tint xid;\n\tstruct smb_vol *volume_info;\n\tstruct cifsSesInfo *pSesInfo;\n\tstruct cifsTconInfo *tcon;\n\tstruct TCP_Server_Info *srvTcp;\n\tchar   *full_path;\n\tchar *mount_data = mount_data_global;\n\tstruct tcon_link *tlink;\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tstruct dfs_info3_param *referrals = NULL;\n\tunsigned int num_referrals = 0;\n\tint referral_walks_count = 0;\ntry_mount_again:\n#endif\n\trc = 0;\n\ttcon = NULL;\n\tpSesInfo = NULL;\n\tsrvTcp = NULL;\n\tfull_path = NULL;\n\ttlink = NULL;\n\n\txid = GetXid();\n\n\tvolume_info = kzalloc(sizeof(struct smb_vol), GFP_KERNEL);\n\tif (!volume_info) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (cifs_parse_mount_options(mount_data, devname, volume_info)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (volume_info->nullauth) {\n\t\tcFYI(1, \"null user\");\n\t\tvolume_info->username = \"\";\n\t} else if (volume_info->username) {\n\t\t/* BB fixme parse for domain name here */\n\t\tcFYI(1, \"Username: %s\", volume_info->username);\n\t} else {\n\t\tcifserror(\"No username specified\");\n\t/* In userspace mount helper we can get user name from alternate\n\t   locations such as env variables and files on disk */\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* this is needed for ASCII cp to Unicode converts */\n\tif (volume_info->iocharset == NULL) {\n\t\t/* load_nls_default cannot return null */\n\t\tvolume_info->local_nls = load_nls_default();\n\t} else {\n\t\tvolume_info->local_nls = load_nls(volume_info->iocharset);\n\t\tif (volume_info->local_nls == NULL) {\n\t\t\tcERROR(1, \"CIFS mount error: iocharset %s not found\",\n\t\t\t\t volume_info->iocharset);\n\t\t\trc = -ELIBACC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tcifs_sb->local_nls = volume_info->local_nls;\n\n\t/* get a reference to a tcp session */\n\tsrvTcp = cifs_get_tcp_session(volume_info);\n\tif (IS_ERR(srvTcp)) {\n\t\trc = PTR_ERR(srvTcp);\n\t\tgoto out;\n\t}\n\n\t/* get a reference to a SMB session */\n\tpSesInfo = cifs_get_smb_ses(srvTcp, volume_info);\n\tif (IS_ERR(pSesInfo)) {\n\t\trc = PTR_ERR(pSesInfo);\n\t\tpSesInfo = NULL;\n\t\tgoto mount_fail_check;\n\t}\n\n\tsetup_cifs_sb(volume_info, cifs_sb);\n\tif (pSesInfo->capabilities & CAP_LARGE_FILES)\n\t\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\telse\n\t\tsb->s_maxbytes = MAX_NON_LFS;\n\n\t/* BB FIXME fix time_gran to be larger for LANMAN sessions */\n\tsb->s_time_gran = 100;\n\n\t/* search for existing tcon to this server share */\n\ttcon = cifs_get_tcon(pSesInfo, volume_info);\n\tif (IS_ERR(tcon)) {\n\t\trc = PTR_ERR(tcon);\n\t\ttcon = NULL;\n\t\tgoto remote_path_check;\n\t}\n\n\t/* do not care if following two calls succeed - informational */\n\tif (!tcon->ipc) {\n\t\tCIFSSMBQFSDeviceInfo(xid, tcon);\n\t\tCIFSSMBQFSAttributeInfo(xid, tcon);\n\t}\n\n\t/* tell server which Unix caps we support */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\t/* reset of caps checks mount to see if unix extensions\n\t\t   disabled for just this mount */\n\t\treset_cifs_unix_caps(xid, tcon, sb, volume_info);\n\telse\n\t\ttcon->unix_ext = 0; /* server does not support them */\n\n\t/* convert forward to back slashes in prepath here if needed */\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) == 0)\n\t\tconvert_delimiter(cifs_sb->prepath, CIFS_DIR_SEP(cifs_sb));\n\n\tif ((tcon->unix_ext == 0) && (cifs_sb->rsize > (1024 * 127))) {\n\t\tcifs_sb->rsize = 1024 * 127;\n\t\tcFYI(DBG2, \"no very large read support, rsize now 127K\");\n\t}\n\tif (!(tcon->ses->capabilities & CAP_LARGE_WRITE_X))\n\t\tcifs_sb->wsize = min(cifs_sb->wsize,\n\t\t\t       (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE));\n\tif (!(tcon->ses->capabilities & CAP_LARGE_READ_X))\n\t\tcifs_sb->rsize = min(cifs_sb->rsize,\n\t\t\t       (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE));\n \n remote_path_check:\n \t/* check if a whole path (including prepath) is not remote */\n\tif (!rc && cifs_sb->prepathlen && tcon) {\n \t\t/* build_path_to_root works only when we have a valid tcon */\n \t\tfull_path = cifs_build_path_to_root(cifs_sb, tcon);\n \t\tif (full_path == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\trc = is_path_accessible(xid, tcon, cifs_sb, full_path);\n\t\tif (rc != 0 && rc != -EREMOTE) {\n\t\t\tkfree(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\tkfree(full_path);\n\t}\n\n\t/* get referral if needed */\n\tif (rc == -EREMOTE) {\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t\tif (referral_walks_count > MAX_NESTED_LINKS) {\n\t\t\t/*\n\t\t\t * BB: when we implement proper loop detection,\n\t\t\t *     we will remove this check. But now we need it\n\t\t\t *     to prevent an indefinite loop if 'DFS tree' is\n\t\t\t *     misconfigured (i.e. has loops).\n\t\t\t */\n\t\t\trc = -ELOOP;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\t/* convert forward to back slashes in prepath here if needed */\n\t\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) == 0)\n\t\t\tconvert_delimiter(cifs_sb->prepath,\n\t\t\t\t\tCIFS_DIR_SEP(cifs_sb));\n\t\tfull_path = build_unc_path_to_root(volume_info, cifs_sb);\n\t\tif (IS_ERR(full_path)) {\n\t\t\trc = PTR_ERR(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\n\t\tcFYI(1, \"Getting referral for: %s\", full_path);\n\t\trc = get_dfs_path(xid, pSesInfo , full_path + 1,\n\t\t\tcifs_sb->local_nls, &num_referrals, &referrals,\n\t\t\tcifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\t\tif (!rc && num_referrals > 0) {\n\t\t\tchar *fake_devname = NULL;\n\n\t\t\tif (mount_data != mount_data_global)\n\t\t\t\tkfree(mount_data);\n\n\t\t\tmount_data = cifs_compose_mount_options(\n\t\t\t\t\tcifs_sb->mountdata, full_path + 1,\n\t\t\t\t\treferrals, &fake_devname);\n\n\t\t\tfree_dfs_info_array(referrals, num_referrals);\n\t\t\tkfree(fake_devname);\n\t\t\tkfree(full_path);\n\n\t\t\tif (IS_ERR(mount_data)) {\n\t\t\t\trc = PTR_ERR(mount_data);\n\t\t\t\tmount_data = NULL;\n\t\t\t\tgoto mount_fail_check;\n\t\t\t}\n\n\t\t\tif (tcon)\n\t\t\t\tcifs_put_tcon(tcon);\n\t\t\telse if (pSesInfo)\n\t\t\t\tcifs_put_smb_ses(pSesInfo);\n\n\t\t\tcleanup_volume_info(&volume_info);\n\t\t\treferral_walks_count++;\n\t\t\tFreeXid(xid);\n\t\t\tgoto try_mount_again;\n\t\t}\n#else /* No DFS support, return error on mount */\n\t\trc = -EOPNOTSUPP;\n#endif\n\t}\n\n\tif (rc)\n\t\tgoto mount_fail_check;\n\n\t/* now, hang the tcon off of the superblock */\n\ttlink = kzalloc(sizeof *tlink, GFP_KERNEL);\n\tif (tlink == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto mount_fail_check;\n\t}\n\n\ttlink->tl_uid = pSesInfo->linux_uid;\n\ttlink->tl_tcon = tcon;\n\ttlink->tl_time = jiffies;\n\tset_bit(TCON_LINK_MASTER, &tlink->tl_flags);\n\tset_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\n\tcifs_sb->master_tlink = tlink;\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(system_nrt_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n\nmount_fail_check:\n\t/* on error free sesinfo and tcon struct if needed */\n\tif (rc) {\n\t\tif (mount_data != mount_data_global)\n\t\t\tkfree(mount_data);\n\t\t/* If find_unc succeeded then rc == 0 so we can not end */\n\t\t/* up accidentally freeing someone elses tcon struct */\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (pSesInfo)\n\t\t\tcifs_put_smb_ses(pSesInfo);\n\t\telse\n\t\t\tcifs_put_tcp_session(srvTcp);\n\t\tgoto out;\n\t}\n\n\t/* volume_info->password is freed above when existing session found\n\t(in which case it is not needed anymore) but when new sesion is created\n\tthe password ptr is put in the new session structure (in which case the\n\tpassword will be freed at unmount time) */\nout:\n\t/* zero out password before freeing */\n\tcleanup_volume_info(&volume_info);\n\tFreeXid(xid);\n\treturn rc;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141687,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "cifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb,\n\t\tchar *mount_data_global, const char *devname)\n{\n\tint rc;\n\tint xid;\n\tstruct smb_vol *volume_info;\n\tstruct cifsSesInfo *pSesInfo;\n\tstruct cifsTconInfo *tcon;\n\tstruct TCP_Server_Info *srvTcp;\n\tchar   *full_path;\n\tchar *mount_data = mount_data_global;\n\tstruct tcon_link *tlink;\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tstruct dfs_info3_param *referrals = NULL;\n\tunsigned int num_referrals = 0;\n\tint referral_walks_count = 0;\ntry_mount_again:\n#endif\n\trc = 0;\n\ttcon = NULL;\n\tpSesInfo = NULL;\n\tsrvTcp = NULL;\n\tfull_path = NULL;\n\ttlink = NULL;\n\n\txid = GetXid();\n\n\tvolume_info = kzalloc(sizeof(struct smb_vol), GFP_KERNEL);\n\tif (!volume_info) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (cifs_parse_mount_options(mount_data, devname, volume_info)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (volume_info->nullauth) {\n\t\tcFYI(1, \"null user\");\n\t\tvolume_info->username = \"\";\n\t} else if (volume_info->username) {\n\t\t/* BB fixme parse for domain name here */\n\t\tcFYI(1, \"Username: %s\", volume_info->username);\n\t} else {\n\t\tcifserror(\"No username specified\");\n\t/* In userspace mount helper we can get user name from alternate\n\t   locations such as env variables and files on disk */\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* this is needed for ASCII cp to Unicode converts */\n\tif (volume_info->iocharset == NULL) {\n\t\t/* load_nls_default cannot return null */\n\t\tvolume_info->local_nls = load_nls_default();\n\t} else {\n\t\tvolume_info->local_nls = load_nls(volume_info->iocharset);\n\t\tif (volume_info->local_nls == NULL) {\n\t\t\tcERROR(1, \"CIFS mount error: iocharset %s not found\",\n\t\t\t\t volume_info->iocharset);\n\t\t\trc = -ELIBACC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tcifs_sb->local_nls = volume_info->local_nls;\n\n\t/* get a reference to a tcp session */\n\tsrvTcp = cifs_get_tcp_session(volume_info);\n\tif (IS_ERR(srvTcp)) {\n\t\trc = PTR_ERR(srvTcp);\n\t\tgoto out;\n\t}\n\n\t/* get a reference to a SMB session */\n\tpSesInfo = cifs_get_smb_ses(srvTcp, volume_info);\n\tif (IS_ERR(pSesInfo)) {\n\t\trc = PTR_ERR(pSesInfo);\n\t\tpSesInfo = NULL;\n\t\tgoto mount_fail_check;\n\t}\n\n\tsetup_cifs_sb(volume_info, cifs_sb);\n\tif (pSesInfo->capabilities & CAP_LARGE_FILES)\n\t\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\telse\n\t\tsb->s_maxbytes = MAX_NON_LFS;\n\n\t/* BB FIXME fix time_gran to be larger for LANMAN sessions */\n\tsb->s_time_gran = 100;\n\n\t/* search for existing tcon to this server share */\n\ttcon = cifs_get_tcon(pSesInfo, volume_info);\n\tif (IS_ERR(tcon)) {\n\t\trc = PTR_ERR(tcon);\n\t\ttcon = NULL;\n\t\tgoto remote_path_check;\n\t}\n\n\t/* do not care if following two calls succeed - informational */\n\tif (!tcon->ipc) {\n\t\tCIFSSMBQFSDeviceInfo(xid, tcon);\n\t\tCIFSSMBQFSAttributeInfo(xid, tcon);\n\t}\n\n\t/* tell server which Unix caps we support */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\t/* reset of caps checks mount to see if unix extensions\n\t\t   disabled for just this mount */\n\t\treset_cifs_unix_caps(xid, tcon, sb, volume_info);\n\telse\n\t\ttcon->unix_ext = 0; /* server does not support them */\n\n\t/* convert forward to back slashes in prepath here if needed */\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) == 0)\n\t\tconvert_delimiter(cifs_sb->prepath, CIFS_DIR_SEP(cifs_sb));\n\n\tif ((tcon->unix_ext == 0) && (cifs_sb->rsize > (1024 * 127))) {\n\t\tcifs_sb->rsize = 1024 * 127;\n\t\tcFYI(DBG2, \"no very large read support, rsize now 127K\");\n\t}\n\tif (!(tcon->ses->capabilities & CAP_LARGE_WRITE_X))\n\t\tcifs_sb->wsize = min(cifs_sb->wsize,\n\t\t\t       (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE));\n\tif (!(tcon->ses->capabilities & CAP_LARGE_READ_X))\n\t\tcifs_sb->rsize = min(cifs_sb->rsize,\n\t\t\t       (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE));\n \n remote_path_check:\n \t/* check if a whole path (including prepath) is not remote */\n\tif (!rc && tcon) {\n \t\t/* build_path_to_root works only when we have a valid tcon */\n \t\tfull_path = cifs_build_path_to_root(cifs_sb, tcon);\n \t\tif (full_path == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\trc = is_path_accessible(xid, tcon, cifs_sb, full_path);\n\t\tif (rc != 0 && rc != -EREMOTE) {\n\t\t\tkfree(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\tkfree(full_path);\n\t}\n\n\t/* get referral if needed */\n\tif (rc == -EREMOTE) {\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t\tif (referral_walks_count > MAX_NESTED_LINKS) {\n\t\t\t/*\n\t\t\t * BB: when we implement proper loop detection,\n\t\t\t *     we will remove this check. But now we need it\n\t\t\t *     to prevent an indefinite loop if 'DFS tree' is\n\t\t\t *     misconfigured (i.e. has loops).\n\t\t\t */\n\t\t\trc = -ELOOP;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\t/* convert forward to back slashes in prepath here if needed */\n\t\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) == 0)\n\t\t\tconvert_delimiter(cifs_sb->prepath,\n\t\t\t\t\tCIFS_DIR_SEP(cifs_sb));\n\t\tfull_path = build_unc_path_to_root(volume_info, cifs_sb);\n\t\tif (IS_ERR(full_path)) {\n\t\t\trc = PTR_ERR(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\n\t\tcFYI(1, \"Getting referral for: %s\", full_path);\n\t\trc = get_dfs_path(xid, pSesInfo , full_path + 1,\n\t\t\tcifs_sb->local_nls, &num_referrals, &referrals,\n\t\t\tcifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\t\tif (!rc && num_referrals > 0) {\n\t\t\tchar *fake_devname = NULL;\n\n\t\t\tif (mount_data != mount_data_global)\n\t\t\t\tkfree(mount_data);\n\n\t\t\tmount_data = cifs_compose_mount_options(\n\t\t\t\t\tcifs_sb->mountdata, full_path + 1,\n\t\t\t\t\treferrals, &fake_devname);\n\n\t\t\tfree_dfs_info_array(referrals, num_referrals);\n\t\t\tkfree(fake_devname);\n\t\t\tkfree(full_path);\n\n\t\t\tif (IS_ERR(mount_data)) {\n\t\t\t\trc = PTR_ERR(mount_data);\n\t\t\t\tmount_data = NULL;\n\t\t\t\tgoto mount_fail_check;\n\t\t\t}\n\n\t\t\tif (tcon)\n\t\t\t\tcifs_put_tcon(tcon);\n\t\t\telse if (pSesInfo)\n\t\t\t\tcifs_put_smb_ses(pSesInfo);\n\n\t\t\tcleanup_volume_info(&volume_info);\n\t\t\treferral_walks_count++;\n\t\t\tFreeXid(xid);\n\t\t\tgoto try_mount_again;\n\t\t}\n#else /* No DFS support, return error on mount */\n\t\trc = -EOPNOTSUPP;\n#endif\n\t}\n\n\tif (rc)\n\t\tgoto mount_fail_check;\n\n\t/* now, hang the tcon off of the superblock */\n\ttlink = kzalloc(sizeof *tlink, GFP_KERNEL);\n\tif (tlink == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto mount_fail_check;\n\t}\n\n\ttlink->tl_uid = pSesInfo->linux_uid;\n\ttlink->tl_tcon = tcon;\n\ttlink->tl_time = jiffies;\n\tset_bit(TCON_LINK_MASTER, &tlink->tl_flags);\n\tset_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\n\tcifs_sb->master_tlink = tlink;\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(system_nrt_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n\nmount_fail_check:\n\t/* on error free sesinfo and tcon struct if needed */\n\tif (rc) {\n\t\tif (mount_data != mount_data_global)\n\t\t\tkfree(mount_data);\n\t\t/* If find_unc succeeded then rc == 0 so we can not end */\n\t\t/* up accidentally freeing someone elses tcon struct */\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (pSesInfo)\n\t\t\tcifs_put_smb_ses(pSesInfo);\n\t\telse\n\t\t\tcifs_put_tcp_session(srvTcp);\n\t\tgoto out;\n\t}\n\n\t/* volume_info->password is freed above when existing session found\n\t(in which case it is not needed anymore) but when new sesion is created\n\tthe password ptr is put in the new session structure (in which case the\n\tpassword will be freed at unmount time) */\nout:\n\t/* zero out password before freeing */\n\tcleanup_volume_info(&volume_info);\n\tFreeXid(xid);\n\treturn rc;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141688,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int ptrace_setxregs(struct task_struct *child, void __user *uregs)\n{\n\tstruct thread_info *ti = task_thread_info(child);\n\tstruct pt_regs *regs = task_pt_regs(child);\n \telf_xtregs_t *xtregs = uregs;\n \tint ret = 0;\n \n #if XTENSA_HAVE_COPROCESSORS\n \t/* Flush all coprocessors before we overwrite them. */\n \tcoprocessor_flush_all(ti);\n\tcoprocessor_release_all(ti);\n\n\tret |= __copy_from_user(&ti->xtregs_cp, &xtregs->cp0, \n\t\t\t\tsizeof(xtregs_coprocessor_t));\n#endif\n\tret |= __copy_from_user(&regs->xtregs_opt, &xtregs->opt,\n\t\t\t\tsizeof(xtregs->opt));\n\tret |= __copy_from_user(&ti->xtregs_user, &xtregs->user,\n\t\t\t\tsizeof(xtregs->user));\n\n\treturn ret ? -EFAULT : 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141693,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int ptrace_setxregs(struct task_struct *child, void __user *uregs)\n{\n\tstruct thread_info *ti = task_thread_info(child);\n\tstruct pt_regs *regs = task_pt_regs(child);\n \telf_xtregs_t *xtregs = uregs;\n \tint ret = 0;\n \n\tif (!access_ok(VERIFY_READ, uregs, sizeof(elf_xtregs_t)))\n\t\treturn -EFAULT;\n\n #if XTENSA_HAVE_COPROCESSORS\n \t/* Flush all coprocessors before we overwrite them. */\n \tcoprocessor_flush_all(ti);\n\tcoprocessor_release_all(ti);\n\n\tret |= __copy_from_user(&ti->xtregs_cp, &xtregs->cp0, \n\t\t\t\tsizeof(xtregs_coprocessor_t));\n#endif\n\tret |= __copy_from_user(&regs->xtregs_opt, &xtregs->opt,\n\t\t\t\tsizeof(xtregs->opt));\n\tret |= __copy_from_user(&ti->xtregs_user, &xtregs->user,\n\t\t\t\tsizeof(xtregs->user));\n\n\treturn ret ? -EFAULT : 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141694,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int bnep_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct bnep_connlist_req cl;\n\tstruct bnep_connadd_req  ca;\n\tstruct bnep_conndel_req  cd;\n\tstruct bnep_conninfo ci;\n\tstruct socket *nsock;\n\tvoid __user *argp = (void __user *)arg;\n\tint err;\n\n\tBT_DBG(\"cmd %x arg %lx\", cmd, arg);\n\n\tswitch (cmd) {\n\tcase BNEPCONNADD:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\n\t\tif (copy_from_user(&ca, argp, sizeof(ca)))\n\t\t\treturn -EFAULT;\n\n\t\tnsock = sockfd_lookup(ca.sock, &err);\n\t\tif (!nsock)\n\t\t\treturn err;\n\n\t\tif (nsock->sk->sk_state != BT_CONNECTED) {\n \t\t\tsockfd_put(nsock);\n \t\t\treturn -EBADFD;\n \t\t}\n \n \t\terr = bnep_add_connection(&ca, nsock);\n \t\tif (!err) {\n\t\t\tif (copy_to_user(argp, &ca, sizeof(ca)))\n\t\t\t\terr = -EFAULT;\n\t\t} else\n\t\t\tsockfd_put(nsock);\n\n\t\treturn err;\n\n\tcase BNEPCONNDEL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\treturn -EFAULT;\n\n\t\treturn bnep_del_connection(&cd);\n\n\tcase BNEPGETCONNLIST:\n\t\tif (copy_from_user(&cl, argp, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\n\t\terr = bnep_get_connlist(&cl);\n\t\tif (!err && copy_to_user(argp, &cl, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\n\t\treturn err;\n\n\tcase BNEPGETCONNINFO:\n\t\tif (copy_from_user(&ci, argp, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\n\t\terr = bnep_get_conninfo(&ci);\n\t\tif (!err && copy_to_user(argp, &ci, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\n\t\treturn err;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141701,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int bnep_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct bnep_connlist_req cl;\n\tstruct bnep_connadd_req  ca;\n\tstruct bnep_conndel_req  cd;\n\tstruct bnep_conninfo ci;\n\tstruct socket *nsock;\n\tvoid __user *argp = (void __user *)arg;\n\tint err;\n\n\tBT_DBG(\"cmd %x arg %lx\", cmd, arg);\n\n\tswitch (cmd) {\n\tcase BNEPCONNADD:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\n\t\tif (copy_from_user(&ca, argp, sizeof(ca)))\n\t\t\treturn -EFAULT;\n\n\t\tnsock = sockfd_lookup(ca.sock, &err);\n\t\tif (!nsock)\n\t\t\treturn err;\n\n\t\tif (nsock->sk->sk_state != BT_CONNECTED) {\n \t\t\tsockfd_put(nsock);\n \t\t\treturn -EBADFD;\n \t\t}\n\t\tca.device[sizeof(ca.device)-1] = 0;\n \n \t\terr = bnep_add_connection(&ca, nsock);\n \t\tif (!err) {\n\t\t\tif (copy_to_user(argp, &ca, sizeof(ca)))\n\t\t\t\terr = -EFAULT;\n\t\t} else\n\t\t\tsockfd_put(nsock);\n\n\t\treturn err;\n\n\tcase BNEPCONNDEL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\treturn -EFAULT;\n\n\t\treturn bnep_del_connection(&cd);\n\n\tcase BNEPGETCONNLIST:\n\t\tif (copy_from_user(&cl, argp, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\n\t\terr = bnep_get_connlist(&cl);\n\t\tif (!err && copy_to_user(argp, &cl, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\n\t\treturn err;\n\n\tcase BNEPGETCONNINFO:\n\t\tif (copy_from_user(&ci, argp, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\n\t\terr = bnep_get_conninfo(&ci);\n\t\tif (!err && copy_to_user(argp, &ci, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\n\t\treturn err;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141702,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int flashsv_decode_frame(AVCodecContext *avctx, void *data,\n                                int *got_frame, AVPacket *avpkt)\n{\n    int buf_size       = avpkt->size;\n    FlashSVContext *s  = avctx->priv_data;\n    int h_blocks, v_blocks, h_part, v_part, i, j, ret;\n    GetBitContext gb;\n    int last_blockwidth = s->block_width;\n    int last_blockheight= s->block_height;\n\n    /* no supplementary picture */\n    if (buf_size == 0)\n        return 0;\n    if (buf_size < 4)\n        return -1;\n\n    init_get_bits(&gb, avpkt->data, buf_size * 8);\n\n    /* start to parse the bitstream */\n    s->block_width  = 16 * (get_bits(&gb,  4) + 1);\n    s->image_width  =       get_bits(&gb, 12);\n    s->block_height = 16 * (get_bits(&gb,  4) + 1);\n    s->image_height =       get_bits(&gb, 12);\n\n    if (   last_blockwidth != s->block_width\n        || last_blockheight!= s->block_height)\n        av_freep(&s->blocks);\n\n    if (s->ver == 2) {\n        skip_bits(&gb, 6);\n        if (get_bits1(&gb)) {\n            avpriv_request_sample(avctx, \"iframe\");\n            return AVERROR_PATCHWELCOME;\n        }\n        if (get_bits1(&gb)) {\n            avpriv_request_sample(avctx, \"Custom palette\");\n            return AVERROR_PATCHWELCOME;\n        }\n    }\n\n    /* calculate number of blocks and size of border (partial) blocks */\n    h_blocks = s->image_width  / s->block_width;\n    h_part   = s->image_width  % s->block_width;\n    v_blocks = s->image_height / s->block_height;\n    v_part   = s->image_height % s->block_height;\n\n    /* the block size could change between frames, make sure the buffer\n     * is large enough, if not, get a larger one */\n    if (s->block_size < s->block_width * s->block_height) {\n        int tmpblock_size = 3 * s->block_width * s->block_height;\n\n        s->tmpblock = av_realloc(s->tmpblock, tmpblock_size);\n        if (!s->tmpblock) {\n            av_log(avctx, AV_LOG_ERROR, \"Can't allocate decompression buffer.\\n\");\n            return AVERROR(ENOMEM);\n        }\n        if (s->ver == 2) {\n            s->deflate_block_size = calc_deflate_block_size(tmpblock_size);\n            if (s->deflate_block_size <= 0) {\n                av_log(avctx, AV_LOG_ERROR, \"Can't determine deflate buffer size.\\n\");\n                return -1;\n            }\n            s->deflate_block = av_realloc(s->deflate_block, s->deflate_block_size);\n            if (!s->deflate_block) {\n                av_log(avctx, AV_LOG_ERROR, \"Can't allocate deflate buffer.\\n\");\n                return AVERROR(ENOMEM);\n            }\n        }\n    }\n    s->block_size = s->block_width * s->block_height;\n\n    /* initialize the image size once */\n    if (avctx->width == 0 && avctx->height == 0) {\n        avcodec_set_dimensions(avctx, s->image_width, s->image_height);\n    }\n\n    /* check for changes of image width and image height */\n    if (avctx->width != s->image_width || avctx->height != s->image_height) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Frame width or height differs from first frame!\\n\");\n        av_log(avctx, AV_LOG_ERROR, \"fh = %d, fv %d  vs  ch = %d, cv = %d\\n\",\n               avctx->height, avctx->width, s->image_height, s->image_width);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* we care for keyframes only in Screen Video v2 */\n    s->is_keyframe = (avpkt->flags & AV_PKT_FLAG_KEY) && (s->ver == 2);\n    if (s->is_keyframe) {\n        s->keyframedata = av_realloc(s->keyframedata, avpkt->size);\n        memcpy(s->keyframedata, avpkt->data, avpkt->size);\n    }\n    if(s->ver == 2 && !s->blocks)\n        s->blocks = av_mallocz((v_blocks + !!v_part) * (h_blocks + !!h_part)\n                                * sizeof(s->blocks[0]));\n\n    av_dlog(avctx, \"image: %dx%d block: %dx%d num: %dx%d part: %dx%d\\n\",\n            s->image_width, s->image_height, s->block_width, s->block_height,\n            h_blocks, v_blocks, h_part, v_part);\n\n    if ((ret = ff_reget_buffer(avctx, &s->frame)) < 0)\n        return ret;\n\n    /* loop over all block columns */\n    for (j = 0; j < v_blocks + (v_part ? 1 : 0); j++) {\n\n        int y_pos  = j * s->block_height; // vertical position in frame\n        int cur_blk_height = (j < v_blocks) ? s->block_height : v_part;\n\n        /* loop over all block rows */\n        for (i = 0; i < h_blocks + (h_part ? 1 : 0); i++) {\n            int x_pos = i * s->block_width; // horizontal position in frame\n            int cur_blk_width = (i < h_blocks) ? s->block_width : h_part;\n            int has_diff = 0;\n\n            /* get the size of the compressed zlib chunk */\n            int size = get_bits(&gb, 16);\n\n            s->color_depth    = 0;\n            s->zlibprime_curr = 0;\n            s->zlibprime_prev = 0;\n            s->diff_start     = 0;\n            s->diff_height    = cur_blk_height;\n\n            if (8 * size > get_bits_left(&gb)) {\n                av_frame_unref(&s->frame);\n                return AVERROR_INVALIDDATA;\n            }\n\n            if (s->ver == 2 && size) {\n                skip_bits(&gb, 3);\n                s->color_depth    = get_bits(&gb, 2);\n                has_diff          = get_bits1(&gb);\n                s->zlibprime_curr = get_bits1(&gb);\n                s->zlibprime_prev = get_bits1(&gb);\n\n                if (s->color_depth != 0 && s->color_depth != 2) {\n                    av_log(avctx, AV_LOG_ERROR,\n                           \"%dx%d invalid color depth %d\\n\", i, j, s->color_depth);\n                    return AVERROR_INVALIDDATA;\n                }\n\n                if (has_diff) {\n                    if (!s->keyframe) {\n                        av_log(avctx, AV_LOG_ERROR,\n                               \"inter frame without keyframe\\n\");\n                        return AVERROR_INVALIDDATA;\n                     }\n                     s->diff_start  = get_bits(&gb, 8);\n                     s->diff_height = get_bits(&gb, 8);\n                     av_log(avctx, AV_LOG_DEBUG,\n                            \"%dx%d diff start %d height %d\\n\",\n                            i, j, s->diff_start, s->diff_height);\n                    size -= 2;\n                }\n\n                if (s->zlibprime_prev)\n                    av_log(avctx, AV_LOG_DEBUG, \"%dx%d zlibprime_prev\\n\", i, j);\n\n                if (s->zlibprime_curr) {\n                    int col = get_bits(&gb, 8);\n                    int row = get_bits(&gb, 8);\n                    av_log(avctx, AV_LOG_DEBUG, \"%dx%d zlibprime_curr %dx%d\\n\", i, j, col, row);\n                    size -= 2;\n                    avpriv_request_sample(avctx, \"zlibprime_curr\");\n                    return AVERROR_PATCHWELCOME;\n                }\n                if (!s->blocks && (s->zlibprime_curr || s->zlibprime_prev)) {\n                    av_log(avctx, AV_LOG_ERROR, \"no data available for zlib \"\n                           \"priming\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                size--; // account for flags byte\n            }\n\n            if (has_diff) {\n                int k;\n                int off = (s->image_height - y_pos - 1) * s->frame.linesize[0];\n\n                for (k = 0; k < cur_blk_height; k++)\n                    memcpy(s->frame.data[0] + off - k*s->frame.linesize[0] + x_pos*3,\n                           s->keyframe + off - k*s->frame.linesize[0] + x_pos*3,\n                           cur_blk_width * 3);\n            }\n\n            /* skip unchanged blocks, which have size 0 */\n            if (size) {\n                if (flashsv_decode_block(avctx, avpkt, &gb, size,\n                                         cur_blk_width, cur_blk_height,\n                                         x_pos, y_pos,\n                                         i + j * (h_blocks + !!h_part)))\n                    av_log(avctx, AV_LOG_ERROR,\n                           \"error in decompression of block %dx%d\\n\", i, j);\n            }\n        }\n    }\n    if (s->is_keyframe && s->ver == 2) {\n        if (!s->keyframe) {\n            s->keyframe = av_malloc(s->frame.linesize[0] * avctx->height);\n            if (!s->keyframe) {\n                av_log(avctx, AV_LOG_ERROR, \"Cannot allocate image data\\n\");\n                return AVERROR(ENOMEM);\n            }\n        }\n        memcpy(s->keyframe, s->frame.data[0], s->frame.linesize[0] * avctx->height);\n    }\n\n    if ((ret = av_frame_ref(data, &s->frame)) < 0)\n        return ret;\n\n    *got_frame = 1;\n\n    if ((get_bits_count(&gb) / 8) != buf_size)\n        av_log(avctx, AV_LOG_ERROR, \"buffer not fully consumed (%d != %d)\\n\",\n               buf_size, (get_bits_count(&gb) / 8));\n\n    /* report that the buffer was completely consumed */\n    return buf_size;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141713,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int flashsv_decode_frame(AVCodecContext *avctx, void *data,\n                                int *got_frame, AVPacket *avpkt)\n{\n    int buf_size       = avpkt->size;\n    FlashSVContext *s  = avctx->priv_data;\n    int h_blocks, v_blocks, h_part, v_part, i, j, ret;\n    GetBitContext gb;\n    int last_blockwidth = s->block_width;\n    int last_blockheight= s->block_height;\n\n    /* no supplementary picture */\n    if (buf_size == 0)\n        return 0;\n    if (buf_size < 4)\n        return -1;\n\n    init_get_bits(&gb, avpkt->data, buf_size * 8);\n\n    /* start to parse the bitstream */\n    s->block_width  = 16 * (get_bits(&gb,  4) + 1);\n    s->image_width  =       get_bits(&gb, 12);\n    s->block_height = 16 * (get_bits(&gb,  4) + 1);\n    s->image_height =       get_bits(&gb, 12);\n\n    if (   last_blockwidth != s->block_width\n        || last_blockheight!= s->block_height)\n        av_freep(&s->blocks);\n\n    if (s->ver == 2) {\n        skip_bits(&gb, 6);\n        if (get_bits1(&gb)) {\n            avpriv_request_sample(avctx, \"iframe\");\n            return AVERROR_PATCHWELCOME;\n        }\n        if (get_bits1(&gb)) {\n            avpriv_request_sample(avctx, \"Custom palette\");\n            return AVERROR_PATCHWELCOME;\n        }\n    }\n\n    /* calculate number of blocks and size of border (partial) blocks */\n    h_blocks = s->image_width  / s->block_width;\n    h_part   = s->image_width  % s->block_width;\n    v_blocks = s->image_height / s->block_height;\n    v_part   = s->image_height % s->block_height;\n\n    /* the block size could change between frames, make sure the buffer\n     * is large enough, if not, get a larger one */\n    if (s->block_size < s->block_width * s->block_height) {\n        int tmpblock_size = 3 * s->block_width * s->block_height;\n\n        s->tmpblock = av_realloc(s->tmpblock, tmpblock_size);\n        if (!s->tmpblock) {\n            av_log(avctx, AV_LOG_ERROR, \"Can't allocate decompression buffer.\\n\");\n            return AVERROR(ENOMEM);\n        }\n        if (s->ver == 2) {\n            s->deflate_block_size = calc_deflate_block_size(tmpblock_size);\n            if (s->deflate_block_size <= 0) {\n                av_log(avctx, AV_LOG_ERROR, \"Can't determine deflate buffer size.\\n\");\n                return -1;\n            }\n            s->deflate_block = av_realloc(s->deflate_block, s->deflate_block_size);\n            if (!s->deflate_block) {\n                av_log(avctx, AV_LOG_ERROR, \"Can't allocate deflate buffer.\\n\");\n                return AVERROR(ENOMEM);\n            }\n        }\n    }\n    s->block_size = s->block_width * s->block_height;\n\n    /* initialize the image size once */\n    if (avctx->width == 0 && avctx->height == 0) {\n        avcodec_set_dimensions(avctx, s->image_width, s->image_height);\n    }\n\n    /* check for changes of image width and image height */\n    if (avctx->width != s->image_width || avctx->height != s->image_height) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Frame width or height differs from first frame!\\n\");\n        av_log(avctx, AV_LOG_ERROR, \"fh = %d, fv %d  vs  ch = %d, cv = %d\\n\",\n               avctx->height, avctx->width, s->image_height, s->image_width);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* we care for keyframes only in Screen Video v2 */\n    s->is_keyframe = (avpkt->flags & AV_PKT_FLAG_KEY) && (s->ver == 2);\n    if (s->is_keyframe) {\n        s->keyframedata = av_realloc(s->keyframedata, avpkt->size);\n        memcpy(s->keyframedata, avpkt->data, avpkt->size);\n    }\n    if(s->ver == 2 && !s->blocks)\n        s->blocks = av_mallocz((v_blocks + !!v_part) * (h_blocks + !!h_part)\n                                * sizeof(s->blocks[0]));\n\n    av_dlog(avctx, \"image: %dx%d block: %dx%d num: %dx%d part: %dx%d\\n\",\n            s->image_width, s->image_height, s->block_width, s->block_height,\n            h_blocks, v_blocks, h_part, v_part);\n\n    if ((ret = ff_reget_buffer(avctx, &s->frame)) < 0)\n        return ret;\n\n    /* loop over all block columns */\n    for (j = 0; j < v_blocks + (v_part ? 1 : 0); j++) {\n\n        int y_pos  = j * s->block_height; // vertical position in frame\n        int cur_blk_height = (j < v_blocks) ? s->block_height : v_part;\n\n        /* loop over all block rows */\n        for (i = 0; i < h_blocks + (h_part ? 1 : 0); i++) {\n            int x_pos = i * s->block_width; // horizontal position in frame\n            int cur_blk_width = (i < h_blocks) ? s->block_width : h_part;\n            int has_diff = 0;\n\n            /* get the size of the compressed zlib chunk */\n            int size = get_bits(&gb, 16);\n\n            s->color_depth    = 0;\n            s->zlibprime_curr = 0;\n            s->zlibprime_prev = 0;\n            s->diff_start     = 0;\n            s->diff_height    = cur_blk_height;\n\n            if (8 * size > get_bits_left(&gb)) {\n                av_frame_unref(&s->frame);\n                return AVERROR_INVALIDDATA;\n            }\n\n            if (s->ver == 2 && size) {\n                skip_bits(&gb, 3);\n                s->color_depth    = get_bits(&gb, 2);\n                has_diff          = get_bits1(&gb);\n                s->zlibprime_curr = get_bits1(&gb);\n                s->zlibprime_prev = get_bits1(&gb);\n\n                if (s->color_depth != 0 && s->color_depth != 2) {\n                    av_log(avctx, AV_LOG_ERROR,\n                           \"%dx%d invalid color depth %d\\n\", i, j, s->color_depth);\n                    return AVERROR_INVALIDDATA;\n                }\n\n                if (has_diff) {\n                    if (!s->keyframe) {\n                        av_log(avctx, AV_LOG_ERROR,\n                               \"inter frame without keyframe\\n\");\n                        return AVERROR_INVALIDDATA;\n                     }\n                     s->diff_start  = get_bits(&gb, 8);\n                     s->diff_height = get_bits(&gb, 8);\n                    if (s->diff_start + s->diff_height > cur_blk_height) {\n                        av_log(avctx, AV_LOG_ERROR, \"Block parameters invalid\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                     av_log(avctx, AV_LOG_DEBUG,\n                            \"%dx%d diff start %d height %d\\n\",\n                            i, j, s->diff_start, s->diff_height);\n                    size -= 2;\n                }\n\n                if (s->zlibprime_prev)\n                    av_log(avctx, AV_LOG_DEBUG, \"%dx%d zlibprime_prev\\n\", i, j);\n\n                if (s->zlibprime_curr) {\n                    int col = get_bits(&gb, 8);\n                    int row = get_bits(&gb, 8);\n                    av_log(avctx, AV_LOG_DEBUG, \"%dx%d zlibprime_curr %dx%d\\n\", i, j, col, row);\n                    size -= 2;\n                    avpriv_request_sample(avctx, \"zlibprime_curr\");\n                    return AVERROR_PATCHWELCOME;\n                }\n                if (!s->blocks && (s->zlibprime_curr || s->zlibprime_prev)) {\n                    av_log(avctx, AV_LOG_ERROR, \"no data available for zlib \"\n                           \"priming\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                size--; // account for flags byte\n            }\n\n            if (has_diff) {\n                int k;\n                int off = (s->image_height - y_pos - 1) * s->frame.linesize[0];\n\n                for (k = 0; k < cur_blk_height; k++)\n                    memcpy(s->frame.data[0] + off - k*s->frame.linesize[0] + x_pos*3,\n                           s->keyframe + off - k*s->frame.linesize[0] + x_pos*3,\n                           cur_blk_width * 3);\n            }\n\n            /* skip unchanged blocks, which have size 0 */\n            if (size) {\n                if (flashsv_decode_block(avctx, avpkt, &gb, size,\n                                         cur_blk_width, cur_blk_height,\n                                         x_pos, y_pos,\n                                         i + j * (h_blocks + !!h_part)))\n                    av_log(avctx, AV_LOG_ERROR,\n                           \"error in decompression of block %dx%d\\n\", i, j);\n            }\n        }\n    }\n    if (s->is_keyframe && s->ver == 2) {\n        if (!s->keyframe) {\n            s->keyframe = av_malloc(s->frame.linesize[0] * avctx->height);\n            if (!s->keyframe) {\n                av_log(avctx, AV_LOG_ERROR, \"Cannot allocate image data\\n\");\n                return AVERROR(ENOMEM);\n            }\n        }\n        memcpy(s->keyframe, s->frame.data[0], s->frame.linesize[0] * avctx->height);\n    }\n\n    if ((ret = av_frame_ref(data, &s->frame)) < 0)\n        return ret;\n\n    *got_frame = 1;\n\n    if ((get_bits_count(&gb) / 8) != buf_size)\n        av_log(avctx, AV_LOG_ERROR, \"buffer not fully consumed (%d != %d)\\n\",\n               buf_size, (get_bits_count(&gb) / 8));\n\n    /* report that the buffer was completely consumed */\n    return buf_size;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141714,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int ssl_parse_certificate( ssl_context *ssl )\n{\n    int ret;\n    size_t i, n;\n\n    SSL_DEBUG_MSG( 2, ( \"=> parse certificate\" ) );\n\n    if( ssl->endpoint == SSL_IS_SERVER &&\n        ssl->authmode == SSL_VERIFY_NONE )\n    {\n        ssl->verify_result = BADCERT_SKIP_VERIFY;\n        SSL_DEBUG_MSG( 2, ( \"<= skip parse certificate\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n\n    if( ( ret = ssl_read_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_read_record\", ret );\n        return( ret );\n    }\n\n    ssl->state++;\n\n    /*\n     * Check if the client sent an empty certificate\n     */\n    if( ssl->endpoint  == SSL_IS_SERVER &&\n        ssl->minor_ver == SSL_MINOR_VERSION_0 )\n    {\n        if( ssl->in_msglen  == 2                        &&\n            ssl->in_msgtype == SSL_MSG_ALERT            &&\n            ssl->in_msg[0]  == SSL_ALERT_LEVEL_WARNING  &&\n            ssl->in_msg[1]  == SSL_ALERT_MSG_NO_CERT )\n        {\n            SSL_DEBUG_MSG( 1, ( \"SSLv3 client has no certificate\" ) );\n\n            ssl->verify_result = BADCERT_MISSING;\n            if( ssl->authmode == SSL_VERIFY_OPTIONAL )\n                return( 0 );\n            else\n                return( POLARSSL_ERR_SSL_NO_CLIENT_CERTIFICATE );\n        }\n    }\n\n    if( ssl->endpoint  == SSL_IS_SERVER &&\n        ssl->minor_ver != SSL_MINOR_VERSION_0 )\n    {\n        if( ssl->in_hslen   == 7                    &&\n            ssl->in_msgtype == SSL_MSG_HANDSHAKE    &&\n            ssl->in_msg[0]  == SSL_HS_CERTIFICATE   &&\n            memcmp( ssl->in_msg + 4, \"\\0\\0\\0\", 3 ) == 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"TLSv1 client has no certificate\" ) );\n\n            ssl->verify_result = BADCERT_MISSING;\n            if( ssl->authmode == SSL_VERIFY_REQUIRED )\n                return( POLARSSL_ERR_SSL_NO_CLIENT_CERTIFICATE );\n            else\n                return( 0 );\n        }\n    }\n\n    if( ssl->in_msgtype != SSL_MSG_HANDSHAKE )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n        return( POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    if( ssl->in_msg[0] != SSL_HS_CERTIFICATE || ssl->in_hslen < 10 )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n    }\n\n    /*\n     * Same message structure as in ssl_write_certificate()\n     */\n    n = ( ssl->in_msg[5] << 8 ) | ssl->in_msg[6];\n\n    if( ssl->in_msg[4] != 0 || ssl->in_hslen != 7 + n )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n    }\n\n    if( ( ssl->session_negotiate->peer_cert = (x509_cert *) malloc(\n                    sizeof( x509_cert ) ) ) == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"malloc(%d bytes) failed\",\n                       sizeof( x509_cert ) ) );\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    }\n\n    memset( ssl->session_negotiate->peer_cert, 0, sizeof( x509_cert ) );\n\n    i = 7;\n\n    while( i < ssl->in_hslen )\n    {\n        if( ssl->in_msg[i] != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n            return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n\n        n = ( (unsigned int) ssl->in_msg[i + 1] << 8 )\n            | (unsigned int) ssl->in_msg[i + 2];\n        i += 3;\n\n        if( n < 128 || i + n > ssl->in_hslen )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n             return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n         }\n \n        ret = x509parse_crt( ssl->session_negotiate->peer_cert, ssl->in_msg + i,\n                             n );\n         if( ret != 0 )\n         {\n             SSL_DEBUG_RET( 1, \" x509parse_crt\", ret );\n            return( ret );\n        }\n\n        i += n;\n    }\n\n    SSL_DEBUG_CRT( 3, \"peer certificate\", ssl->session_negotiate->peer_cert );\n\n    if( ssl->authmode != SSL_VERIFY_NONE )\n    {\n        if( ssl->ca_chain == NULL )\n        {\n            SSL_DEBUG_MSG( 1, ( \"got no CA chain\" ) );\n            return( POLARSSL_ERR_SSL_CA_CHAIN_REQUIRED );\n        }\n\n        ret = x509parse_verify( ssl->session_negotiate->peer_cert,\n                                ssl->ca_chain, ssl->ca_crl,\n                                ssl->peer_cn,  &ssl->verify_result,\n                                ssl->f_vrfy, ssl->p_vrfy );\n\n        if( ret != 0 )\n            SSL_DEBUG_RET( 1, \"x509_verify_cert\", ret );\n\n        if( ssl->authmode != SSL_VERIFY_REQUIRED )\n            ret = 0;\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= parse certificate\" ) );\n\n    return( ret );\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141731,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int ssl_parse_certificate( ssl_context *ssl )\n{\n    int ret;\n    size_t i, n;\n\n    SSL_DEBUG_MSG( 2, ( \"=> parse certificate\" ) );\n\n    if( ssl->endpoint == SSL_IS_SERVER &&\n        ssl->authmode == SSL_VERIFY_NONE )\n    {\n        ssl->verify_result = BADCERT_SKIP_VERIFY;\n        SSL_DEBUG_MSG( 2, ( \"<= skip parse certificate\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n\n    if( ( ret = ssl_read_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_read_record\", ret );\n        return( ret );\n    }\n\n    ssl->state++;\n\n    /*\n     * Check if the client sent an empty certificate\n     */\n    if( ssl->endpoint  == SSL_IS_SERVER &&\n        ssl->minor_ver == SSL_MINOR_VERSION_0 )\n    {\n        if( ssl->in_msglen  == 2                        &&\n            ssl->in_msgtype == SSL_MSG_ALERT            &&\n            ssl->in_msg[0]  == SSL_ALERT_LEVEL_WARNING  &&\n            ssl->in_msg[1]  == SSL_ALERT_MSG_NO_CERT )\n        {\n            SSL_DEBUG_MSG( 1, ( \"SSLv3 client has no certificate\" ) );\n\n            ssl->verify_result = BADCERT_MISSING;\n            if( ssl->authmode == SSL_VERIFY_OPTIONAL )\n                return( 0 );\n            else\n                return( POLARSSL_ERR_SSL_NO_CLIENT_CERTIFICATE );\n        }\n    }\n\n    if( ssl->endpoint  == SSL_IS_SERVER &&\n        ssl->minor_ver != SSL_MINOR_VERSION_0 )\n    {\n        if( ssl->in_hslen   == 7                    &&\n            ssl->in_msgtype == SSL_MSG_HANDSHAKE    &&\n            ssl->in_msg[0]  == SSL_HS_CERTIFICATE   &&\n            memcmp( ssl->in_msg + 4, \"\\0\\0\\0\", 3 ) == 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"TLSv1 client has no certificate\" ) );\n\n            ssl->verify_result = BADCERT_MISSING;\n            if( ssl->authmode == SSL_VERIFY_REQUIRED )\n                return( POLARSSL_ERR_SSL_NO_CLIENT_CERTIFICATE );\n            else\n                return( 0 );\n        }\n    }\n\n    if( ssl->in_msgtype != SSL_MSG_HANDSHAKE )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n        return( POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    if( ssl->in_msg[0] != SSL_HS_CERTIFICATE || ssl->in_hslen < 10 )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n    }\n\n    /*\n     * Same message structure as in ssl_write_certificate()\n     */\n    n = ( ssl->in_msg[5] << 8 ) | ssl->in_msg[6];\n\n    if( ssl->in_msg[4] != 0 || ssl->in_hslen != 7 + n )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n    }\n\n    if( ( ssl->session_negotiate->peer_cert = (x509_cert *) malloc(\n                    sizeof( x509_cert ) ) ) == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"malloc(%d bytes) failed\",\n                       sizeof( x509_cert ) ) );\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    }\n\n    memset( ssl->session_negotiate->peer_cert, 0, sizeof( x509_cert ) );\n\n    i = 7;\n\n    while( i < ssl->in_hslen )\n    {\n        if( ssl->in_msg[i] != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n            return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n\n        n = ( (unsigned int) ssl->in_msg[i + 1] << 8 )\n            | (unsigned int) ssl->in_msg[i + 2];\n        i += 3;\n\n        if( n < 128 || i + n > ssl->in_hslen )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n             return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n         }\n \n        ret = x509parse_crt_der( ssl->session_negotiate->peer_cert,\n                                 ssl->in_msg + i, n );\n         if( ret != 0 )\n         {\n             SSL_DEBUG_RET( 1, \" x509parse_crt\", ret );\n            return( ret );\n        }\n\n        i += n;\n    }\n\n    SSL_DEBUG_CRT( 3, \"peer certificate\", ssl->session_negotiate->peer_cert );\n\n    if( ssl->authmode != SSL_VERIFY_NONE )\n    {\n        if( ssl->ca_chain == NULL )\n        {\n            SSL_DEBUG_MSG( 1, ( \"got no CA chain\" ) );\n            return( POLARSSL_ERR_SSL_CA_CHAIN_REQUIRED );\n        }\n\n        ret = x509parse_verify( ssl->session_negotiate->peer_cert,\n                                ssl->ca_chain, ssl->ca_crl,\n                                ssl->peer_cn,  &ssl->verify_result,\n                                ssl->f_vrfy, ssl->p_vrfy );\n\n        if( ret != 0 )\n            SSL_DEBUG_RET( 1, \"x509_verify_cert\", ret );\n\n        if( ssl->authmode != SSL_VERIFY_REQUIRED )\n            ret = 0;\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= parse certificate\" ) );\n\n    return( ret );\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141732,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)\n{\n \tint r;\n \tstruct kvm_vcpu *vcpu, *v;\n \n \tvcpu = kvm_arch_vcpu_create(kvm, id);\n \tif (IS_ERR(vcpu))\n \t\treturn PTR_ERR(vcpu);\n\n\tpreempt_notifier_init(&vcpu->preempt_notifier, &kvm_preempt_ops);\n\n\tr = kvm_arch_vcpu_setup(vcpu);\n\tif (r)\n\t\tgoto vcpu_destroy;\n\n\tmutex_lock(&kvm->lock);\n\tif (!kvm_vcpu_compatible(vcpu)) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tif (atomic_read(&kvm->online_vcpus) == KVM_MAX_VCPUS) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\n\tkvm_for_each_vcpu(r, v, kvm)\n\t\tif (v->vcpu_id == id) {\n\t\t\tr = -EEXIST;\n\t\t\tgoto unlock_vcpu_destroy;\n\t\t}\n\n\tBUG_ON(kvm->vcpus[atomic_read(&kvm->online_vcpus)]);\n\n\t/* Now it's all set up, let userspace reach it */\n\tkvm_get_kvm(kvm);\n\tr = create_vcpu_fd(vcpu);\n\tif (r < 0) {\n\t\tkvm_put_kvm(kvm);\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\n\tkvm->vcpus[atomic_read(&kvm->online_vcpus)] = vcpu;\n\tsmp_wmb();\n\tatomic_inc(&kvm->online_vcpus);\n\n\tmutex_unlock(&kvm->lock);\n\tkvm_arch_vcpu_postcreate(vcpu);\n\treturn r;\n\nunlock_vcpu_destroy:\n\tmutex_unlock(&kvm->lock);\nvcpu_destroy:\n\tkvm_arch_vcpu_destroy(vcpu);\n\treturn r;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141737,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)\n{\n \tint r;\n \tstruct kvm_vcpu *vcpu, *v;\n \n\tif (id >= KVM_MAX_VCPUS)\n\t\treturn -EINVAL;\n\n \tvcpu = kvm_arch_vcpu_create(kvm, id);\n \tif (IS_ERR(vcpu))\n \t\treturn PTR_ERR(vcpu);\n\n\tpreempt_notifier_init(&vcpu->preempt_notifier, &kvm_preempt_ops);\n\n\tr = kvm_arch_vcpu_setup(vcpu);\n\tif (r)\n\t\tgoto vcpu_destroy;\n\n\tmutex_lock(&kvm->lock);\n\tif (!kvm_vcpu_compatible(vcpu)) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tif (atomic_read(&kvm->online_vcpus) == KVM_MAX_VCPUS) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\n\tkvm_for_each_vcpu(r, v, kvm)\n\t\tif (v->vcpu_id == id) {\n\t\t\tr = -EEXIST;\n\t\t\tgoto unlock_vcpu_destroy;\n\t\t}\n\n\tBUG_ON(kvm->vcpus[atomic_read(&kvm->online_vcpus)]);\n\n\t/* Now it's all set up, let userspace reach it */\n\tkvm_get_kvm(kvm);\n\tr = create_vcpu_fd(vcpu);\n\tif (r < 0) {\n\t\tkvm_put_kvm(kvm);\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\n\tkvm->vcpus[atomic_read(&kvm->online_vcpus)] = vcpu;\n\tsmp_wmb();\n\tatomic_inc(&kvm->online_vcpus);\n\n\tmutex_unlock(&kvm->lock);\n\tkvm_arch_vcpu_postcreate(vcpu);\n\treturn r;\n\nunlock_vcpu_destroy:\n\tmutex_unlock(&kvm->lock);\nvcpu_destroy:\n\tkvm_arch_vcpu_destroy(vcpu);\n\treturn r;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141738,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int net_ctl_permissions(struct ctl_table_header *head,\n\t\t\t       struct ctl_table *table)\n{\n\tstruct net *net = container_of(head->set, struct net, sysctls);\n\tkuid_t root_uid = make_kuid(net->user_ns, 0);\n\tkgid_t root_gid = make_kgid(net->user_ns, 0);\n \n \t/* Allow network administrator to have same access as root. */\n \tif (ns_capable(net->user_ns, CAP_NET_ADMIN) ||\n\t    uid_eq(root_uid, current_uid())) {\n \t\tint mode = (table->mode >> 6) & 7;\n \t\treturn (mode << 6) | (mode << 3) | mode;\n \t}\n \t/* Allow netns root group to have the same access as the root group */\n\tif (gid_eq(root_gid, current_gid())) {\n \t\tint mode = (table->mode >> 3) & 7;\n \t\treturn (mode << 3) | mode;\n \t}\n\treturn table->mode;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141749,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int net_ctl_permissions(struct ctl_table_header *head,\n\t\t\t       struct ctl_table *table)\n{\n\tstruct net *net = container_of(head->set, struct net, sysctls);\n\tkuid_t root_uid = make_kuid(net->user_ns, 0);\n\tkgid_t root_gid = make_kgid(net->user_ns, 0);\n \n \t/* Allow network administrator to have same access as root. */\n \tif (ns_capable(net->user_ns, CAP_NET_ADMIN) ||\n\t    uid_eq(root_uid, current_euid())) {\n \t\tint mode = (table->mode >> 6) & 7;\n \t\treturn (mode << 6) | (mode << 3) | mode;\n \t}\n \t/* Allow netns root group to have the same access as the root group */\n\tif (in_egroup_p(root_gid)) {\n \t\tint mode = (table->mode >> 3) & 7;\n \t\treturn (mode << 3) | mode;\n \t}\n\treturn table->mode;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141750,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "validate_event(struct pmu_hw_events *hw_events,\n\t       struct perf_event *event)\n{\n \tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n \tstruct pmu *leader_pmu = event->group_leader->pmu;\n \n \tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n \t\treturn 1;\n \n\tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n\t\treturn 1;\n\n\treturn armpmu->get_event_idx(hw_events, event) >= 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141753,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "validate_event(struct pmu_hw_events *hw_events,\n\t       struct perf_event *event)\n{\n \tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n \tstruct pmu *leader_pmu = event->group_leader->pmu;\n \n\tif (is_software_event(event))\n\t\treturn 1;\n\n \tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n \t\treturn 1;\n \n\tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n\t\treturn 1;\n\n\treturn armpmu->get_event_idx(hw_events, event) >= 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141754,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct br_ip ip;\n\tint err = -EINVAL;\n\n\tif (!netif_running(br->dev) || br->multicast_disabled)\n\t\treturn -EINVAL;\n\n\tif (timer_pending(&br->multicast_querier_timer))\n\t\treturn -EBUSY;\n\n\tip.proto = entry->addr.proto;\n\tif (ip.proto == htons(ETH_P_IP))\n\t\tip.u.ip4 = entry->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tip.u.ip6 = entry->addr.u.ip6;\n#endif\n\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\n\tmp = br_mdb_ip_get(mdb, &ip);\n\tif (!mp)\n\t\tgoto unlock;\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (!p->port || p->port->dev->ifindex != entry->ifindex)\n\t\t\tcontinue;\n\n\t\tif (p->port->state == BR_STATE_DISABLED)\n\t\t\tgoto unlock;\n\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n \t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n \t\terr = 0;\n \n\t\tif (!mp->ports && !mp->mglist &&\n \t\t    netif_running(br->dev))\n \t\t\tmod_timer(&mp->timer, jiffies);\n \t\tbreak;\n\t}\n\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141759,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct br_ip ip;\n\tint err = -EINVAL;\n\n\tif (!netif_running(br->dev) || br->multicast_disabled)\n\t\treturn -EINVAL;\n\n\tif (timer_pending(&br->multicast_querier_timer))\n\t\treturn -EBUSY;\n\n\tip.proto = entry->addr.proto;\n\tif (ip.proto == htons(ETH_P_IP))\n\t\tip.u.ip4 = entry->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tip.u.ip6 = entry->addr.u.ip6;\n#endif\n\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\n\tmp = br_mdb_ip_get(mdb, &ip);\n\tif (!mp)\n\t\tgoto unlock;\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (!p->port || p->port->dev->ifindex != entry->ifindex)\n\t\t\tcontinue;\n\n\t\tif (p->port->state == BR_STATE_DISABLED)\n\t\t\tgoto unlock;\n\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n \t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n \t\terr = 0;\n \n\t\tif (!mp->ports && !mp->mglist && mp->timer_armed &&\n \t\t    netif_running(br->dev))\n \t\t\tmod_timer(&mp->timer, jiffies);\n \t\tbreak;\n\t}\n\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141760,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void br_multicast_del_pg(struct net_bridge *br,\n\t\t\t\tstruct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\n\tmp = br_mdb_ip_get(mdb, &pg->addr);\n\tif (WARN_ON(!mp))\n\t\treturn;\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p != pg)\n\t\t\tcontinue;\n\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n \t\tdel_timer(&p->timer);\n \t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n \n\t\tif (!mp->ports && !mp->mglist &&\n \t\t    netif_running(br->dev))\n \t\t\tmod_timer(&mp->timer, jiffies);\n \n\t\treturn;\n\t}\n\n\tWARN_ON(1);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141761,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void br_multicast_del_pg(struct net_bridge *br,\n\t\t\t\tstruct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\n\tmp = br_mdb_ip_get(mdb, &pg->addr);\n\tif (WARN_ON(!mp))\n\t\treturn;\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p != pg)\n\t\t\tcontinue;\n\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n \t\tdel_timer(&p->timer);\n \t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n \n\t\tif (!mp->ports && !mp->mglist && mp->timer_armed &&\n \t\t    netif_running(br->dev))\n \t\t\tmod_timer(&mp->timer, jiffies);\n \n\t\treturn;\n\t}\n\n\tWARN_ON(1);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141762,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int dispatch_discard_io(struct xen_blkif *blkif,\n\t\t\t\tstruct blkif_request *req)\n{\n\tint err = 0;\n \tint status = BLKIF_RSP_OKAY;\n \tstruct block_device *bdev = blkif->vbd.bdev;\n \tunsigned long secure;\n \n \tblkif->st_ds_req++;\n \n \txen_blkif_get(blkif);\n\tsecure = (blkif->vbd.discard_secure &&\n\t\t (req->u.discard.flag & BLKIF_DISCARD_SECURE)) ?\n\t\t BLKDEV_DISCARD_SECURE : 0;\n\n \terr = blkdev_issue_discard(bdev, req->u.discard.sector_number,\n \t\t\t\t   req->u.discard.nr_sectors,\n \t\t\t\t   GFP_KERNEL, secure);\n \tif (err == -EOPNOTSUPP) {\n \t\tpr_debug(DRV_PFX \"discard op failed, not supported\\n\");\n \t\tstatus = BLKIF_RSP_EOPNOTSUPP;\n\t} else if (err)\n\t\tstatus = BLKIF_RSP_ERROR;\n\n\tmake_response(blkif, req->u.discard.id, req->operation, status);\n\txen_blkif_put(blkif);\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141777,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int dispatch_discard_io(struct xen_blkif *blkif,\n\t\t\t\tstruct blkif_request *req)\n{\n\tint err = 0;\n \tint status = BLKIF_RSP_OKAY;\n \tstruct block_device *bdev = blkif->vbd.bdev;\n \tunsigned long secure;\n\tstruct phys_req preq;\n\n\tpreq.sector_number = req->u.discard.sector_number;\n\tpreq.nr_sects      = req->u.discard.nr_sectors;\n \n\terr = xen_vbd_translate(&preq, blkif, WRITE);\n\tif (err) {\n\t\tpr_warn(DRV_PFX \"access denied: DISCARD [%llu->%llu] on dev=%04x\\n\",\n\t\t\tpreq.sector_number,\n\t\t\tpreq.sector_number + preq.nr_sects, blkif->vbd.pdevice);\n\t\tgoto fail_response;\n\t}\n \tblkif->st_ds_req++;\n \n \txen_blkif_get(blkif);\n\tsecure = (blkif->vbd.discard_secure &&\n\t\t (req->u.discard.flag & BLKIF_DISCARD_SECURE)) ?\n\t\t BLKDEV_DISCARD_SECURE : 0;\n\n \terr = blkdev_issue_discard(bdev, req->u.discard.sector_number,\n \t\t\t\t   req->u.discard.nr_sectors,\n \t\t\t\t   GFP_KERNEL, secure);\nfail_response:\n \tif (err == -EOPNOTSUPP) {\n \t\tpr_debug(DRV_PFX \"discard op failed, not supported\\n\");\n \t\tstatus = BLKIF_RSP_EOPNOTSUPP;\n\t} else if (err)\n\t\tstatus = BLKIF_RSP_ERROR;\n\n\tmake_response(blkif, req->u.discard.id, req->operation, status);\n\txen_blkif_put(blkif);\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141778,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int sctp_getsockopt_assoc_stats(struct sock *sk, int len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tstruct sctp_assoc_stats sas;\n\tstruct sctp_association *asoc = NULL;\n\n\t/* User must provide at least the assoc id */\n \tif (len < sizeof(sctp_assoc_t))\n \t\treturn -EINVAL;\n \n \tif (copy_from_user(&sas, optval, len))\n \t\treturn -EFAULT;\n \n\tasoc = sctp_id2assoc(sk, sas.sas_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tsas.sas_rtxchunks = asoc->stats.rtxchunks;\n\tsas.sas_gapcnt = asoc->stats.gapcnt;\n\tsas.sas_outofseqtsns = asoc->stats.outofseqtsns;\n\tsas.sas_osacks = asoc->stats.osacks;\n\tsas.sas_isacks = asoc->stats.isacks;\n\tsas.sas_octrlchunks = asoc->stats.octrlchunks;\n\tsas.sas_ictrlchunks = asoc->stats.ictrlchunks;\n\tsas.sas_oodchunks = asoc->stats.oodchunks;\n\tsas.sas_iodchunks = asoc->stats.iodchunks;\n\tsas.sas_ouodchunks = asoc->stats.ouodchunks;\n\tsas.sas_iuodchunks = asoc->stats.iuodchunks;\n\tsas.sas_idupchunks = asoc->stats.idupchunks;\n\tsas.sas_opackets = asoc->stats.opackets;\n\tsas.sas_ipackets = asoc->stats.ipackets;\n\n\t/* New high max rto observed, will return 0 if not a single\n\t * RTO update took place. obs_rto_ipaddr will be bogus\n\t * in such a case\n\t */\n\tsas.sas_maxrto = asoc->stats.max_obs_rto;\n\tmemcpy(&sas.sas_obs_rto_ipaddr, &asoc->stats.obs_rto_ipaddr,\n\t\tsizeof(struct sockaddr_storage));\n\n \t/* Mark beginning of a new observation period */\n \tasoc->stats.max_obs_rto = asoc->rto_min;\n \n\t/* Allow the struct to grow and fill in as much as possible */\n\tlen = min_t(size_t, len, sizeof(sas));\n \tif (put_user(len, optlen))\n \t\treturn -EFAULT;\n \n\tSCTP_DEBUG_PRINTK(\"sctp_getsockopt_assoc_stat(%d): %d\\n\",\n\t\t\t  len, sas.sas_assoc_id);\n\n\tif (copy_to_user(optval, &sas, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141791,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int sctp_getsockopt_assoc_stats(struct sock *sk, int len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tstruct sctp_assoc_stats sas;\n\tstruct sctp_association *asoc = NULL;\n\n\t/* User must provide at least the assoc id */\n \tif (len < sizeof(sctp_assoc_t))\n \t\treturn -EINVAL;\n \n\t/* Allow the struct to grow and fill in as much as possible */\n\tlen = min_t(size_t, len, sizeof(sas));\n\n \tif (copy_from_user(&sas, optval, len))\n \t\treturn -EFAULT;\n \n\tasoc = sctp_id2assoc(sk, sas.sas_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tsas.sas_rtxchunks = asoc->stats.rtxchunks;\n\tsas.sas_gapcnt = asoc->stats.gapcnt;\n\tsas.sas_outofseqtsns = asoc->stats.outofseqtsns;\n\tsas.sas_osacks = asoc->stats.osacks;\n\tsas.sas_isacks = asoc->stats.isacks;\n\tsas.sas_octrlchunks = asoc->stats.octrlchunks;\n\tsas.sas_ictrlchunks = asoc->stats.ictrlchunks;\n\tsas.sas_oodchunks = asoc->stats.oodchunks;\n\tsas.sas_iodchunks = asoc->stats.iodchunks;\n\tsas.sas_ouodchunks = asoc->stats.ouodchunks;\n\tsas.sas_iuodchunks = asoc->stats.iuodchunks;\n\tsas.sas_idupchunks = asoc->stats.idupchunks;\n\tsas.sas_opackets = asoc->stats.opackets;\n\tsas.sas_ipackets = asoc->stats.ipackets;\n\n\t/* New high max rto observed, will return 0 if not a single\n\t * RTO update took place. obs_rto_ipaddr will be bogus\n\t * in such a case\n\t */\n\tsas.sas_maxrto = asoc->stats.max_obs_rto;\n\tmemcpy(&sas.sas_obs_rto_ipaddr, &asoc->stats.obs_rto_ipaddr,\n\t\tsizeof(struct sockaddr_storage));\n\n \t/* Mark beginning of a new observation period */\n \tasoc->stats.max_obs_rto = asoc->rto_min;\n \n \tif (put_user(len, optlen))\n \t\treturn -EFAULT;\n \n\tSCTP_DEBUG_PRINTK(\"sctp_getsockopt_assoc_stat(%d): %d\\n\",\n\t\t\t  len, sas.sas_assoc_id);\n\n\tif (copy_to_user(optval, &sas, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141792,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "_xfs_buf_find(\n\tstruct xfs_buftarg\t*btp,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\txfs_buf_t\t\t*new_bp)\n{\n\tsize_t\t\t\tnumbytes;\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t**rbp;\n \tstruct rb_node\t\t*parent;\n \txfs_buf_t\t\t*bp;\n \txfs_daddr_t\t\tblkno = map[0].bm_bn;\n \tint\t\t\tnumblks = 0;\n \tint\t\t\ti;\n \n\tfor (i = 0; i < nmaps; i++)\n\t\tnumblks += map[i].bm_len;\n\tnumbytes = BBTOB(numblks);\n\n\t/* Check for IOs smaller than the sector size / not sector aligned */\n \tASSERT(!(numbytes < (1 << btp->bt_sshift)));\n \tASSERT(!(BBTOB(blkno) & (xfs_off_t)btp->bt_smask));\n \n \t/* get tree root */\n \tpag = xfs_perag_get(btp->bt_mount,\n \t\t\t\txfs_daddr_to_agno(btp->bt_mount, blkno));\n\n\t/* walk tree */\n\tspin_lock(&pag->pag_buf_lock);\n\trbp = &pag->pag_buf_tree.rb_node;\n\tparent = NULL;\n\tbp = NULL;\n\twhile (*rbp) {\n\t\tparent = *rbp;\n\t\tbp = rb_entry(parent, struct xfs_buf, b_rbnode);\n\n\t\tif (blkno < bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_left;\n\t\telse if (blkno > bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_right;\n\t\telse {\n\t\t\t/*\n\t\t\t * found a block number match. If the range doesn't\n\t\t\t * match, the only way this is allowed is if the buffer\n\t\t\t * in the cache is stale and the transaction that made\n\t\t\t * it stale has not yet committed. i.e. we are\n\t\t\t * reallocating a busy extent. Skip this buffer and\n\t\t\t * continue searching to the right for an exact match.\n\t\t\t */\n\t\t\tif (bp->b_length != numblks) {\n\t\t\t\tASSERT(bp->b_flags & XBF_STALE);\n\t\t\t\trbp = &(*rbp)->rb_right;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_inc(&bp->b_hold);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* No match found */\n\tif (new_bp) {\n\t\trb_link_node(&new_bp->b_rbnode, parent, rbp);\n\t\trb_insert_color(&new_bp->b_rbnode, &pag->pag_buf_tree);\n\t\t/* the buffer keeps the perag reference until it is freed */\n\t\tnew_bp->b_pag = pag;\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t} else {\n\t\tXFS_STATS_INC(xb_miss_locked);\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t\txfs_perag_put(pag);\n\t}\n\treturn new_bp;\n\nfound:\n\tspin_unlock(&pag->pag_buf_lock);\n\txfs_perag_put(pag);\n\n\tif (!xfs_buf_trylock(bp)) {\n\t\tif (flags & XBF_TRYLOCK) {\n\t\t\txfs_buf_rele(bp);\n\t\t\tXFS_STATS_INC(xb_busy_locked);\n\t\t\treturn NULL;\n\t\t}\n\t\txfs_buf_lock(bp);\n\t\tXFS_STATS_INC(xb_get_locked_waited);\n\t}\n\n\t/*\n\t * if the buffer is stale, clear all the external state associated with\n\t * it. We need to keep flags such as how we allocated the buffer memory\n\t * intact here.\n\t */\n\tif (bp->b_flags & XBF_STALE) {\n\t\tASSERT((bp->b_flags & _XBF_DELWRI_Q) == 0);\n\t\tASSERT(bp->b_iodone == NULL);\n\t\tbp->b_flags &= _XBF_KMEM | _XBF_PAGES;\n\t\tbp->b_ops = NULL;\n\t}\n\n\ttrace_xfs_buf_find(bp, flags, _RET_IP_);\n\tXFS_STATS_INC(xb_get_locked);\n\treturn bp;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141795,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "_xfs_buf_find(\n\tstruct xfs_buftarg\t*btp,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\txfs_buf_t\t\t*new_bp)\n{\n\tsize_t\t\t\tnumbytes;\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t**rbp;\n \tstruct rb_node\t\t*parent;\n \txfs_buf_t\t\t*bp;\n \txfs_daddr_t\t\tblkno = map[0].bm_bn;\n\txfs_daddr_t\t\teofs;\n \tint\t\t\tnumblks = 0;\n \tint\t\t\ti;\n \n\tfor (i = 0; i < nmaps; i++)\n\t\tnumblks += map[i].bm_len;\n\tnumbytes = BBTOB(numblks);\n\n\t/* Check for IOs smaller than the sector size / not sector aligned */\n \tASSERT(!(numbytes < (1 << btp->bt_sshift)));\n \tASSERT(!(BBTOB(blkno) & (xfs_off_t)btp->bt_smask));\n \n\t/*\n\t * Corrupted block numbers can get through to here, unfortunately, so we\n\t * have to check that the buffer falls within the filesystem bounds.\n\t */\n\teofs = XFS_FSB_TO_BB(btp->bt_mount, btp->bt_mount->m_sb.sb_dblocks);\n\tif (blkno >= eofs) {\n\t\t/*\n\t\t * XXX (dgc): we should really be returning EFSCORRUPTED here,\n\t\t * but none of the higher level infrastructure supports\n\t\t * returning a specific error on buffer lookup failures.\n\t\t */\n\t\txfs_alert(btp->bt_mount,\n\t\t\t  \"%s: Block out of range: block 0x%llx, EOFS 0x%llx \",\n\t\t\t  __func__, blkno, eofs);\n\t\treturn NULL;\n\t}\n\n \t/* get tree root */\n \tpag = xfs_perag_get(btp->bt_mount,\n \t\t\t\txfs_daddr_to_agno(btp->bt_mount, blkno));\n\n\t/* walk tree */\n\tspin_lock(&pag->pag_buf_lock);\n\trbp = &pag->pag_buf_tree.rb_node;\n\tparent = NULL;\n\tbp = NULL;\n\twhile (*rbp) {\n\t\tparent = *rbp;\n\t\tbp = rb_entry(parent, struct xfs_buf, b_rbnode);\n\n\t\tif (blkno < bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_left;\n\t\telse if (blkno > bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_right;\n\t\telse {\n\t\t\t/*\n\t\t\t * found a block number match. If the range doesn't\n\t\t\t * match, the only way this is allowed is if the buffer\n\t\t\t * in the cache is stale and the transaction that made\n\t\t\t * it stale has not yet committed. i.e. we are\n\t\t\t * reallocating a busy extent. Skip this buffer and\n\t\t\t * continue searching to the right for an exact match.\n\t\t\t */\n\t\t\tif (bp->b_length != numblks) {\n\t\t\t\tASSERT(bp->b_flags & XBF_STALE);\n\t\t\t\trbp = &(*rbp)->rb_right;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_inc(&bp->b_hold);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* No match found */\n\tif (new_bp) {\n\t\trb_link_node(&new_bp->b_rbnode, parent, rbp);\n\t\trb_insert_color(&new_bp->b_rbnode, &pag->pag_buf_tree);\n\t\t/* the buffer keeps the perag reference until it is freed */\n\t\tnew_bp->b_pag = pag;\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t} else {\n\t\tXFS_STATS_INC(xb_miss_locked);\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t\txfs_perag_put(pag);\n\t}\n\treturn new_bp;\n\nfound:\n\tspin_unlock(&pag->pag_buf_lock);\n\txfs_perag_put(pag);\n\n\tif (!xfs_buf_trylock(bp)) {\n\t\tif (flags & XBF_TRYLOCK) {\n\t\t\txfs_buf_rele(bp);\n\t\t\tXFS_STATS_INC(xb_busy_locked);\n\t\t\treturn NULL;\n\t\t}\n\t\txfs_buf_lock(bp);\n\t\tXFS_STATS_INC(xb_get_locked_waited);\n\t}\n\n\t/*\n\t * if the buffer is stale, clear all the external state associated with\n\t * it. We need to keep flags such as how we allocated the buffer memory\n\t * intact here.\n\t */\n\tif (bp->b_flags & XBF_STALE) {\n\t\tASSERT((bp->b_flags & _XBF_DELWRI_Q) == 0);\n\t\tASSERT(bp->b_iodone == NULL);\n\t\tbp->b_flags &= _XBF_KMEM | _XBF_PAGES;\n\t\tbp->b_ops = NULL;\n\t}\n\n\ttrace_xfs_buf_find(bp, flags, _RET_IP_);\n\tXFS_STATS_INC(xb_get_locked);\n\treturn bp;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141796,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,\n\t\t\t\t    int *peeked, int *off, int *err)\n{\n\tstruct sk_buff *skb;\n\tlong timeo;\n\t/*\n\t * Caller is allowed not to check sk->sk_err before skb_recv_datagram()\n\t */\n\tint error = sock_error(sk);\n\n\tif (error)\n\t\tgoto no_packet;\n\n\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\n\tdo {\n\t\t/* Again only user level code calls this function, so nothing\n\t\t * interrupt level will suddenly eat the receive_queue.\n\t\t *\n\t\t * Look at current nfs client by the way...\n\t\t * However, this function was correct in any case. 8)\n\t\t */\n\t\tunsigned long cpu_flags;\n\t\tstruct sk_buff_head *queue = &sk->sk_receive_queue;\n\n\t\tspin_lock_irqsave(&queue->lock, cpu_flags);\n \t\tskb_queue_walk(queue, skb) {\n \t\t\t*peeked = skb->peeked;\n \t\t\tif (flags & MSG_PEEK) {\n\t\t\t\tif (*off >= skb->len) {\n \t\t\t\t\t*off -= skb->len;\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n\t\t\t\tskb->peeked = 1;\n\t\t\t\tatomic_inc(&skb->users);\n\t\t\t} else\n\t\t\t\t__skb_unlink(skb, queue);\n\n\t\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\t\t\treturn skb;\n\t\t}\n\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\n\t\t/* User doesn't want to wait */\n\t\terror = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto no_packet;\n\n\t} while (!wait_for_packet(sk, err, &timeo));\n\n\treturn NULL;\n\nno_packet:\n\t*err = error;\n\treturn NULL;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141811,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,\n\t\t\t\t    int *peeked, int *off, int *err)\n{\n\tstruct sk_buff *skb;\n\tlong timeo;\n\t/*\n\t * Caller is allowed not to check sk->sk_err before skb_recv_datagram()\n\t */\n\tint error = sock_error(sk);\n\n\tif (error)\n\t\tgoto no_packet;\n\n\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\n\tdo {\n\t\t/* Again only user level code calls this function, so nothing\n\t\t * interrupt level will suddenly eat the receive_queue.\n\t\t *\n\t\t * Look at current nfs client by the way...\n\t\t * However, this function was correct in any case. 8)\n\t\t */\n\t\tunsigned long cpu_flags;\n\t\tstruct sk_buff_head *queue = &sk->sk_receive_queue;\n\n\t\tspin_lock_irqsave(&queue->lock, cpu_flags);\n \t\tskb_queue_walk(queue, skb) {\n \t\t\t*peeked = skb->peeked;\n \t\t\tif (flags & MSG_PEEK) {\n\t\t\t\tif (*off >= skb->len && skb->len) {\n \t\t\t\t\t*off -= skb->len;\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n\t\t\t\tskb->peeked = 1;\n\t\t\t\tatomic_inc(&skb->users);\n\t\t\t} else\n\t\t\t\t__skb_unlink(skb, queue);\n\n\t\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\t\t\treturn skb;\n\t\t}\n\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\n\t\t/* User doesn't want to wait */\n\t\terror = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto no_packet;\n\n\t} while (!wait_for_packet(sk, err, &timeo));\n\n\treturn NULL;\n\nno_packet:\n\t*err = error;\n\treturn NULL;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141812,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\t/* args points to a PAGE_SIZE buffer, AppArmor requires that\n\t * the buffer must be null terminated or have size <= PAGE_SIZE -1\n\t * so that AppArmor can null terminate them\n\t */\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\n\t/* task can only write its own attributes */\n\tif (current != task)\n\t\treturn -EACCES;\n\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permipc\") == 0) {\n\t\t\terror = aa_setprocattr_permipc(args);\n\t\t} else {\n\t\t\tstruct common_audit_data sa;\n\t\t\tCOMMON_AUDIT_DATA_INIT(&sa, NONE);\n \t\t\tsa.aad.op = OP_SETPROCATTR;\n \t\t\tsa.aad.info = name;\n \t\t\tsa.aad.error = -EINVAL;\n\t\t\treturn aa_audit(AUDIT_APPARMOR_DENIED, NULL, GFP_KERNEL,\n \t\t\t\t\t&sa, NULL);\n \t\t}\n \t} else if (strcmp(name, \"exec\") == 0) {\n\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t     !AA_DO_TEST);\n\t} else {\n\t\t/* only support the \"current\" and \"exec\" process attributes */\n\t\treturn -EINVAL;\n\t}\n\tif (!error)\n\t\terror = size;\n\treturn error;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141833,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\t/* args points to a PAGE_SIZE buffer, AppArmor requires that\n\t * the buffer must be null terminated or have size <= PAGE_SIZE -1\n\t * so that AppArmor can null terminate them\n\t */\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\n\t/* task can only write its own attributes */\n\tif (current != task)\n\t\treturn -EACCES;\n\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permipc\") == 0) {\n\t\t\terror = aa_setprocattr_permipc(args);\n\t\t} else {\n\t\t\tstruct common_audit_data sa;\n\t\t\tCOMMON_AUDIT_DATA_INIT(&sa, NONE);\n \t\t\tsa.aad.op = OP_SETPROCATTR;\n \t\t\tsa.aad.info = name;\n \t\t\tsa.aad.error = -EINVAL;\n\t\t\treturn aa_audit(AUDIT_APPARMOR_DENIED,\n\t\t\t\t\t__aa_current_profile(), GFP_KERNEL,\n \t\t\t\t\t&sa, NULL);\n \t\t}\n \t} else if (strcmp(name, \"exec\") == 0) {\n\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t     !AA_DO_TEST);\n\t} else {\n\t\t/* only support the \"current\" and \"exec\" process attributes */\n\t\treturn -EINVAL;\n\t}\n\tif (!error)\n\t\terror = size;\n\treturn error;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141834,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "process_chpw_request(krb5_context context, void *server_handle, char *realm,\n                     krb5_keytab keytab, const krb5_fulladdr *local_faddr,\n                     const krb5_fulladdr *remote_faddr, krb5_data *req,\n                     krb5_data *rep)\n{\n    krb5_error_code ret;\n    char *ptr;\n    unsigned int plen, vno;\n    krb5_data ap_req, ap_rep = empty_data();\n    krb5_data cipher = empty_data(), clear = empty_data();\n    krb5_auth_context auth_context = NULL;\n    krb5_principal changepw = NULL;\n    krb5_principal client, target = NULL;\n    krb5_ticket *ticket = NULL;\n    krb5_replay_data replay;\n    krb5_error krberror;\n    int numresult;\n    char strresult[1024];\n    char *clientstr = NULL, *targetstr = NULL;\n    const char *errmsg = NULL;\n    size_t clen;\n    char *cdots;\n    struct sockaddr_storage ss;\n    socklen_t salen;\n    char addrbuf[100];\n    krb5_address *addr = remote_faddr->address;\n\n    *rep = empty_data();\n\n    if (req->length < 4) {\n        /* either this, or the server is printing bad messages,\n           or the caller passed in garbage */\n         ret = KRB5KRB_AP_ERR_MODIFIED;\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request was truncated\", sizeof(strresult));\n        goto chpwfail;\n     }\n \n     ptr = req->data;\n\n    /* verify length */\n\n    plen = (*ptr++ & 0xff);\n    plen = (plen<<8) | (*ptr++ & 0xff);\n\n    if (plen != req->length) {\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request length was inconsistent\",\n                 sizeof(strresult));\n        goto chpwfail;\n     }\n \n     /* verify version number */\n\n    vno = (*ptr++ & 0xff) ;\n    vno = (vno<<8) | (*ptr++ & 0xff);\n\n    if (vno != 1 && vno != RFC3244_VERSION) {\n        ret = KRB5KDC_ERR_BAD_PVNO;\n         numresult = KRB5_KPASSWD_BAD_VERSION;\n         snprintf(strresult, sizeof(strresult),\n                  \"Request contained unknown protocol version number %d\", vno);\n        goto chpwfail;\n     }\n \n     /* read, check ap-req length */\n\n    ap_req.length = (*ptr++ & 0xff);\n    ap_req.length = (ap_req.length<<8) | (*ptr++ & 0xff);\n\n    if (ptr + ap_req.length >= req->data + req->length) {\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request was truncated in AP-REQ\",\n                 sizeof(strresult));\n        goto chpwfail;\n     }\n \n     /* verify ap_req */\n\n    ap_req.data = ptr;\n    ptr += ap_req.length;\n\n    ret = krb5_auth_con_init(context, &auth_context);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed initializing auth context\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_auth_con_setflags(context, auth_context,\n                                 KRB5_AUTH_CONTEXT_DO_SEQUENCE);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed initializing auth context\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_build_principal(context, &changepw, strlen(realm), realm,\n                               \"kadmin\", \"changepw\", NULL);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed building kadmin/changepw principal\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_rd_req(context, &auth_context, &ap_req, changepw, keytab,\n                      NULL, &ticket);\n\n    if (ret) {\n        numresult = KRB5_KPASSWD_AUTHERROR;\n        strlcpy(strresult, \"Failed reading application request\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* construct the ap-rep */\n\n    ret = krb5_mk_rep(context, auth_context, &ap_rep);\n    if (ret) {\n        numresult = KRB5_KPASSWD_AUTHERROR;\n        strlcpy(strresult, \"Failed replying to application request\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* decrypt the ChangePasswdData */\n\n    cipher.length = (req->data + req->length) - ptr;\n    cipher.data = ptr;\n\n    /*\n     * Don't set a remote address in auth_context before calling krb5_rd_priv,\n     * so that we can work against clients behind a NAT.  Reflection attacks\n     * aren't a concern since we use sequence numbers and since our requests\n     * don't look anything like our responses.  Also don't set a local address,\n     * since we don't know what interface the request was received on.\n     */\n\n    ret = krb5_rd_priv(context, auth_context, &cipher, &clear, &replay);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed decrypting request\", sizeof(strresult));\n        goto chpwfail;\n    }\n\n    client = ticket->enc_part2->client;\n\n    /* decode ChangePasswdData for setpw requests */\n    if (vno == RFC3244_VERSION) {\n        krb5_data *clear_data;\n\n        ret = decode_krb5_setpw_req(&clear, &clear_data, &target);\n        if (ret != 0) {\n            numresult = KRB5_KPASSWD_MALFORMED;\n            strlcpy(strresult, \"Failed decoding ChangePasswdData\",\n                    sizeof(strresult));\n            goto chpwfail;\n        }\n\n        zapfree(clear.data, clear.length);\n\n        clear = *clear_data;\n        free(clear_data);\n\n        if (target != NULL) {\n            ret = krb5_unparse_name(context, target, &targetstr);\n            if (ret != 0) {\n                numresult = KRB5_KPASSWD_HARDERROR;\n                strlcpy(strresult, \"Failed unparsing target name for log\",\n                        sizeof(strresult));\n                goto chpwfail;\n            }\n        }\n    }\n\n    ret = krb5_unparse_name(context, client, &clientstr);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed unparsing client name for log\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* for cpw, verify that this is an AS_REQ ticket */\n    if (vno == 1 &&\n        (ticket->enc_part2->flags & TKT_FLG_INITIAL) == 0) {\n        numresult = KRB5_KPASSWD_INITIAL_FLAG_NEEDED;\n        strlcpy(strresult, \"Ticket must be derived from a password\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* change the password */\n\n    ptr = k5memdup0(clear.data, clear.length, &ret);\n    ret = schpw_util_wrapper(server_handle, client, target,\n                             (ticket->enc_part2->flags & TKT_FLG_INITIAL) != 0,\n                             ptr, NULL, strresult, sizeof(strresult));\n    if (ret)\n        errmsg = krb5_get_error_message(context, ret);\n\n    /* zap the password */\n    zapfree(clear.data, clear.length);\n    zapfree(ptr, clear.length);\n    clear = empty_data();\n\n    clen = strlen(clientstr);\n    trunc_name(&clen, &cdots);\n\n    switch (addr->addrtype) {\n    case ADDRTYPE_INET: {\n        struct sockaddr_in *sin = ss2sin(&ss);\n\n        sin->sin_family = AF_INET;\n        memcpy(&sin->sin_addr, addr->contents, addr->length);\n        sin->sin_port = htons(remote_faddr->port);\n        salen = sizeof(*sin);\n        break;\n    }\n    case ADDRTYPE_INET6: {\n        struct sockaddr_in6 *sin6 = ss2sin6(&ss);\n\n        sin6->sin6_family = AF_INET6;\n        memcpy(&sin6->sin6_addr, addr->contents, addr->length);\n        sin6->sin6_port = htons(remote_faddr->port);\n        salen = sizeof(*sin6);\n        break;\n    }\n    default: {\n        struct sockaddr *sa = ss2sa(&ss);\n\n        sa->sa_family = AF_UNSPEC;\n        salen = sizeof(*sa);\n        break;\n    }\n    }\n\n    if (getnameinfo(ss2sa(&ss), salen,\n                    addrbuf, sizeof(addrbuf), NULL, 0,\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0)\n        strlcpy(addrbuf, \"<unprintable>\", sizeof(addrbuf));\n\n    if (vno == RFC3244_VERSION) {\n        size_t tlen;\n        char *tdots;\n        const char *targetp;\n\n        if (target == NULL) {\n            tlen = clen;\n            tdots = cdots;\n            targetp = targetstr;\n        } else {\n            tlen = strlen(targetstr);\n            trunc_name(&tlen, &tdots);\n            targetp = clientstr;\n        }\n\n        krb5_klog_syslog(LOG_NOTICE, _(\"setpw request from %s by %.*s%s for \"\n                                       \"%.*s%s: %s\"), addrbuf, (int) clen,\n                         clientstr, cdots, (int) tlen, targetp, tdots,\n                         errmsg ? errmsg : \"success\");\n    } else {\n        krb5_klog_syslog(LOG_NOTICE, _(\"chpw request from %s for %.*s%s: %s\"),\n                         addrbuf, (int) clen, clientstr, cdots,\n                         errmsg ? errmsg : \"success\");\n    }\n    switch (ret) {\n    case KADM5_AUTH_CHANGEPW:\n        numresult = KRB5_KPASSWD_ACCESSDENIED;\n        break;\n    case KADM5_PASS_Q_TOOSHORT:\n    case KADM5_PASS_REUSE:\n    case KADM5_PASS_Q_CLASS:\n    case KADM5_PASS_Q_DICT:\n    case KADM5_PASS_Q_GENERIC:\n    case KADM5_PASS_TOOSOON:\n        numresult = KRB5_KPASSWD_SOFTERROR;\n        break;\n    case 0:\n        numresult = KRB5_KPASSWD_SUCCESS;\n        strlcpy(strresult, \"\", sizeof(strresult));\n        break;\n    default:\n        numresult = KRB5_KPASSWD_HARDERROR;\n        break;\n    }\n\nchpwfail:\n\n    clear.length = 2 + strlen(strresult);\n    clear.data = (char *) malloc(clear.length);\n\n    ptr = clear.data;\n\n    *ptr++ = (numresult>>8) & 0xff;\n    *ptr++ = numresult & 0xff;\n\n    memcpy(ptr, strresult, strlen(strresult));\n\n    cipher = empty_data();\n\n    if (ap_rep.length) {\n        ret = krb5_auth_con_setaddrs(context, auth_context,\n                                     local_faddr->address, NULL);\n        if (ret) {\n            numresult = KRB5_KPASSWD_HARDERROR;\n            strlcpy(strresult,\n                    \"Failed storing client and server internet addresses\",\n                    sizeof(strresult));\n        } else {\n            ret = krb5_mk_priv(context, auth_context, &clear, &cipher,\n                               &replay);\n            if (ret) {\n                numresult = KRB5_KPASSWD_HARDERROR;\n                strlcpy(strresult, \"Failed encrypting reply\",\n                        sizeof(strresult));\n            }\n        }\n    }\n\n    /* if no KRB-PRIV was constructed, then we need a KRB-ERROR.\n       if this fails, just bail.  there's nothing else we can do. */\n\n    if (cipher.length == 0) {\n        /* clear out ap_rep now, so that it won't be inserted in the\n           reply */\n\n        if (ap_rep.length) {\n            free(ap_rep.data);\n            ap_rep = empty_data();\n        }\n\n        krberror.ctime = 0;\n        krberror.cusec = 0;\n        krberror.susec = 0;\n        ret = krb5_timeofday(context, &krberror.stime);\n        if (ret)\n            goto bailout;\n\n        /* this is really icky.  but it's what all the other callers\n           to mk_error do. */\n        krberror.error = ret;\n        krberror.error -= ERROR_TABLE_BASE_krb5;\n        if (krberror.error < 0 || krberror.error > 128)\n            krberror.error = KRB_ERR_GENERIC;\n\n        krberror.client = NULL;\n\n        ret = krb5_build_principal(context, &krberror.server,\n                                   strlen(realm), realm,\n                                   \"kadmin\", \"changepw\", NULL);\n        if (ret)\n            goto bailout;\n        krberror.text.length = 0;\n        krberror.e_data = clear;\n\n        ret = krb5_mk_error(context, &krberror, &cipher);\n\n        krb5_free_principal(context, krberror.server);\n\n        if (ret)\n            goto bailout;\n    }\n\n    /* construct the reply */\n\n    ret = alloc_data(rep, 6 + ap_rep.length + cipher.length);\n    if (ret)\n        goto bailout;\n    ptr = rep->data;\n\n    /* length */\n\n    *ptr++ = (rep->length>>8) & 0xff;\n    *ptr++ = rep->length & 0xff;\n\n    /* version == 0x0001 big-endian */\n\n    *ptr++ = 0;\n    *ptr++ = 1;\n\n    /* ap_rep length, big-endian */\n\n    *ptr++ = (ap_rep.length>>8) & 0xff;\n    *ptr++ = ap_rep.length & 0xff;\n\n    /* ap-rep data */\n\n    if (ap_rep.length) {\n        memcpy(ptr, ap_rep.data, ap_rep.length);\n        ptr += ap_rep.length;\n    }\n\n    /* krb-priv or krb-error */\n\n    memcpy(ptr, cipher.data, cipher.length);\n\nbailout:\n    krb5_auth_con_free(context, auth_context);\n    krb5_free_principal(context, changepw);\n    krb5_free_ticket(context, ticket);\n    free(ap_rep.data);\n    free(clear.data);\n    free(cipher.data);\n    krb5_free_principal(context, target);\n    krb5_free_unparsed_name(context, targetstr);\n    krb5_free_unparsed_name(context, clientstr);\n    krb5_free_error_message(context, errmsg);\n    return ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141841,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "process_chpw_request(krb5_context context, void *server_handle, char *realm,\n                     krb5_keytab keytab, const krb5_fulladdr *local_faddr,\n                     const krb5_fulladdr *remote_faddr, krb5_data *req,\n                     krb5_data *rep)\n{\n    krb5_error_code ret;\n    char *ptr;\n    unsigned int plen, vno;\n    krb5_data ap_req, ap_rep = empty_data();\n    krb5_data cipher = empty_data(), clear = empty_data();\n    krb5_auth_context auth_context = NULL;\n    krb5_principal changepw = NULL;\n    krb5_principal client, target = NULL;\n    krb5_ticket *ticket = NULL;\n    krb5_replay_data replay;\n    krb5_error krberror;\n    int numresult;\n    char strresult[1024];\n    char *clientstr = NULL, *targetstr = NULL;\n    const char *errmsg = NULL;\n    size_t clen;\n    char *cdots;\n    struct sockaddr_storage ss;\n    socklen_t salen;\n    char addrbuf[100];\n    krb5_address *addr = remote_faddr->address;\n\n    *rep = empty_data();\n\n    if (req->length < 4) {\n        /* either this, or the server is printing bad messages,\n           or the caller passed in garbage */\n         ret = KRB5KRB_AP_ERR_MODIFIED;\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request was truncated\", sizeof(strresult));\n        goto bailout;\n     }\n \n     ptr = req->data;\n\n    /* verify length */\n\n    plen = (*ptr++ & 0xff);\n    plen = (plen<<8) | (*ptr++ & 0xff);\n\n    if (plen != req->length) {\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request length was inconsistent\",\n                 sizeof(strresult));\n        goto bailout;\n     }\n \n     /* verify version number */\n\n    vno = (*ptr++ & 0xff) ;\n    vno = (vno<<8) | (*ptr++ & 0xff);\n\n    if (vno != 1 && vno != RFC3244_VERSION) {\n        ret = KRB5KDC_ERR_BAD_PVNO;\n         numresult = KRB5_KPASSWD_BAD_VERSION;\n         snprintf(strresult, sizeof(strresult),\n                  \"Request contained unknown protocol version number %d\", vno);\n        goto bailout;\n     }\n \n     /* read, check ap-req length */\n\n    ap_req.length = (*ptr++ & 0xff);\n    ap_req.length = (ap_req.length<<8) | (*ptr++ & 0xff);\n\n    if (ptr + ap_req.length >= req->data + req->length) {\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request was truncated in AP-REQ\",\n                 sizeof(strresult));\n        goto bailout;\n     }\n \n     /* verify ap_req */\n\n    ap_req.data = ptr;\n    ptr += ap_req.length;\n\n    ret = krb5_auth_con_init(context, &auth_context);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed initializing auth context\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_auth_con_setflags(context, auth_context,\n                                 KRB5_AUTH_CONTEXT_DO_SEQUENCE);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed initializing auth context\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_build_principal(context, &changepw, strlen(realm), realm,\n                               \"kadmin\", \"changepw\", NULL);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed building kadmin/changepw principal\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_rd_req(context, &auth_context, &ap_req, changepw, keytab,\n                      NULL, &ticket);\n\n    if (ret) {\n        numresult = KRB5_KPASSWD_AUTHERROR;\n        strlcpy(strresult, \"Failed reading application request\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* construct the ap-rep */\n\n    ret = krb5_mk_rep(context, auth_context, &ap_rep);\n    if (ret) {\n        numresult = KRB5_KPASSWD_AUTHERROR;\n        strlcpy(strresult, \"Failed replying to application request\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* decrypt the ChangePasswdData */\n\n    cipher.length = (req->data + req->length) - ptr;\n    cipher.data = ptr;\n\n    /*\n     * Don't set a remote address in auth_context before calling krb5_rd_priv,\n     * so that we can work against clients behind a NAT.  Reflection attacks\n     * aren't a concern since we use sequence numbers and since our requests\n     * don't look anything like our responses.  Also don't set a local address,\n     * since we don't know what interface the request was received on.\n     */\n\n    ret = krb5_rd_priv(context, auth_context, &cipher, &clear, &replay);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed decrypting request\", sizeof(strresult));\n        goto chpwfail;\n    }\n\n    client = ticket->enc_part2->client;\n\n    /* decode ChangePasswdData for setpw requests */\n    if (vno == RFC3244_VERSION) {\n        krb5_data *clear_data;\n\n        ret = decode_krb5_setpw_req(&clear, &clear_data, &target);\n        if (ret != 0) {\n            numresult = KRB5_KPASSWD_MALFORMED;\n            strlcpy(strresult, \"Failed decoding ChangePasswdData\",\n                    sizeof(strresult));\n            goto chpwfail;\n        }\n\n        zapfree(clear.data, clear.length);\n\n        clear = *clear_data;\n        free(clear_data);\n\n        if (target != NULL) {\n            ret = krb5_unparse_name(context, target, &targetstr);\n            if (ret != 0) {\n                numresult = KRB5_KPASSWD_HARDERROR;\n                strlcpy(strresult, \"Failed unparsing target name for log\",\n                        sizeof(strresult));\n                goto chpwfail;\n            }\n        }\n    }\n\n    ret = krb5_unparse_name(context, client, &clientstr);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed unparsing client name for log\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* for cpw, verify that this is an AS_REQ ticket */\n    if (vno == 1 &&\n        (ticket->enc_part2->flags & TKT_FLG_INITIAL) == 0) {\n        numresult = KRB5_KPASSWD_INITIAL_FLAG_NEEDED;\n        strlcpy(strresult, \"Ticket must be derived from a password\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* change the password */\n\n    ptr = k5memdup0(clear.data, clear.length, &ret);\n    ret = schpw_util_wrapper(server_handle, client, target,\n                             (ticket->enc_part2->flags & TKT_FLG_INITIAL) != 0,\n                             ptr, NULL, strresult, sizeof(strresult));\n    if (ret)\n        errmsg = krb5_get_error_message(context, ret);\n\n    /* zap the password */\n    zapfree(clear.data, clear.length);\n    zapfree(ptr, clear.length);\n    clear = empty_data();\n\n    clen = strlen(clientstr);\n    trunc_name(&clen, &cdots);\n\n    switch (addr->addrtype) {\n    case ADDRTYPE_INET: {\n        struct sockaddr_in *sin = ss2sin(&ss);\n\n        sin->sin_family = AF_INET;\n        memcpy(&sin->sin_addr, addr->contents, addr->length);\n        sin->sin_port = htons(remote_faddr->port);\n        salen = sizeof(*sin);\n        break;\n    }\n    case ADDRTYPE_INET6: {\n        struct sockaddr_in6 *sin6 = ss2sin6(&ss);\n\n        sin6->sin6_family = AF_INET6;\n        memcpy(&sin6->sin6_addr, addr->contents, addr->length);\n        sin6->sin6_port = htons(remote_faddr->port);\n        salen = sizeof(*sin6);\n        break;\n    }\n    default: {\n        struct sockaddr *sa = ss2sa(&ss);\n\n        sa->sa_family = AF_UNSPEC;\n        salen = sizeof(*sa);\n        break;\n    }\n    }\n\n    if (getnameinfo(ss2sa(&ss), salen,\n                    addrbuf, sizeof(addrbuf), NULL, 0,\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0)\n        strlcpy(addrbuf, \"<unprintable>\", sizeof(addrbuf));\n\n    if (vno == RFC3244_VERSION) {\n        size_t tlen;\n        char *tdots;\n        const char *targetp;\n\n        if (target == NULL) {\n            tlen = clen;\n            tdots = cdots;\n            targetp = targetstr;\n        } else {\n            tlen = strlen(targetstr);\n            trunc_name(&tlen, &tdots);\n            targetp = clientstr;\n        }\n\n        krb5_klog_syslog(LOG_NOTICE, _(\"setpw request from %s by %.*s%s for \"\n                                       \"%.*s%s: %s\"), addrbuf, (int) clen,\n                         clientstr, cdots, (int) tlen, targetp, tdots,\n                         errmsg ? errmsg : \"success\");\n    } else {\n        krb5_klog_syslog(LOG_NOTICE, _(\"chpw request from %s for %.*s%s: %s\"),\n                         addrbuf, (int) clen, clientstr, cdots,\n                         errmsg ? errmsg : \"success\");\n    }\n    switch (ret) {\n    case KADM5_AUTH_CHANGEPW:\n        numresult = KRB5_KPASSWD_ACCESSDENIED;\n        break;\n    case KADM5_PASS_Q_TOOSHORT:\n    case KADM5_PASS_REUSE:\n    case KADM5_PASS_Q_CLASS:\n    case KADM5_PASS_Q_DICT:\n    case KADM5_PASS_Q_GENERIC:\n    case KADM5_PASS_TOOSOON:\n        numresult = KRB5_KPASSWD_SOFTERROR;\n        break;\n    case 0:\n        numresult = KRB5_KPASSWD_SUCCESS;\n        strlcpy(strresult, \"\", sizeof(strresult));\n        break;\n    default:\n        numresult = KRB5_KPASSWD_HARDERROR;\n        break;\n    }\n\nchpwfail:\n\n    clear.length = 2 + strlen(strresult);\n    clear.data = (char *) malloc(clear.length);\n\n    ptr = clear.data;\n\n    *ptr++ = (numresult>>8) & 0xff;\n    *ptr++ = numresult & 0xff;\n\n    memcpy(ptr, strresult, strlen(strresult));\n\n    cipher = empty_data();\n\n    if (ap_rep.length) {\n        ret = krb5_auth_con_setaddrs(context, auth_context,\n                                     local_faddr->address, NULL);\n        if (ret) {\n            numresult = KRB5_KPASSWD_HARDERROR;\n            strlcpy(strresult,\n                    \"Failed storing client and server internet addresses\",\n                    sizeof(strresult));\n        } else {\n            ret = krb5_mk_priv(context, auth_context, &clear, &cipher,\n                               &replay);\n            if (ret) {\n                numresult = KRB5_KPASSWD_HARDERROR;\n                strlcpy(strresult, \"Failed encrypting reply\",\n                        sizeof(strresult));\n            }\n        }\n    }\n\n    /* if no KRB-PRIV was constructed, then we need a KRB-ERROR.\n       if this fails, just bail.  there's nothing else we can do. */\n\n    if (cipher.length == 0) {\n        /* clear out ap_rep now, so that it won't be inserted in the\n           reply */\n\n        if (ap_rep.length) {\n            free(ap_rep.data);\n            ap_rep = empty_data();\n        }\n\n        krberror.ctime = 0;\n        krberror.cusec = 0;\n        krberror.susec = 0;\n        ret = krb5_timeofday(context, &krberror.stime);\n        if (ret)\n            goto bailout;\n\n        /* this is really icky.  but it's what all the other callers\n           to mk_error do. */\n        krberror.error = ret;\n        krberror.error -= ERROR_TABLE_BASE_krb5;\n        if (krberror.error < 0 || krberror.error > 128)\n            krberror.error = KRB_ERR_GENERIC;\n\n        krberror.client = NULL;\n\n        ret = krb5_build_principal(context, &krberror.server,\n                                   strlen(realm), realm,\n                                   \"kadmin\", \"changepw\", NULL);\n        if (ret)\n            goto bailout;\n        krberror.text.length = 0;\n        krberror.e_data = clear;\n\n        ret = krb5_mk_error(context, &krberror, &cipher);\n\n        krb5_free_principal(context, krberror.server);\n\n        if (ret)\n            goto bailout;\n    }\n\n    /* construct the reply */\n\n    ret = alloc_data(rep, 6 + ap_rep.length + cipher.length);\n    if (ret)\n        goto bailout;\n    ptr = rep->data;\n\n    /* length */\n\n    *ptr++ = (rep->length>>8) & 0xff;\n    *ptr++ = rep->length & 0xff;\n\n    /* version == 0x0001 big-endian */\n\n    *ptr++ = 0;\n    *ptr++ = 1;\n\n    /* ap_rep length, big-endian */\n\n    *ptr++ = (ap_rep.length>>8) & 0xff;\n    *ptr++ = ap_rep.length & 0xff;\n\n    /* ap-rep data */\n\n    if (ap_rep.length) {\n        memcpy(ptr, ap_rep.data, ap_rep.length);\n        ptr += ap_rep.length;\n    }\n\n    /* krb-priv or krb-error */\n\n    memcpy(ptr, cipher.data, cipher.length);\n\nbailout:\n    krb5_auth_con_free(context, auth_context);\n    krb5_free_principal(context, changepw);\n    krb5_free_ticket(context, ticket);\n    free(ap_rep.data);\n    free(clear.data);\n    free(cipher.data);\n    krb5_free_principal(context, target);\n    krb5_free_unparsed_name(context, targetstr);\n    krb5_free_unparsed_name(context, clientstr);\n    krb5_free_error_message(context, errmsg);\n    return ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141842,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int lz4_uncompress(const char *source, char *dest, int osize)\n{\n\tconst BYTE *ip = (const BYTE *) source;\n\tconst BYTE *ref;\n\tBYTE *op = (BYTE *) dest;\n\tBYTE * const oend = op + osize;\n\tBYTE *cpy;\n\tunsigned token;\n\tsize_t length;\n\tsize_t dec32table[] = {0, 3, 2, 3, 0, 0, 0, 0};\n#if LZ4_ARCH64\n\tsize_t dec64table[] = {0, 0, 0, -1, 0, 1, 2, 3};\n#endif\n\n\twhile (1) {\n\n\t\t/* get runlength */\n\t\ttoken = *ip++;\n\t\tlength = (token >> ML_BITS);\n\t\tif (length == RUN_MASK) {\n\t\t\tsize_t len;\n\n \t\t\tlen = *ip++;\n \t\t\tfor (; len == 255; length += 255)\n \t\t\t\tlen = *ip++;\n \t\t\tlength += len;\n \t\t}\n \n\t\t/* copy literals */\n\t\tcpy = op + length;\n\t\tif (unlikely(cpy > oend - COPYLENGTH)) {\n\t\t\t/*\n\t\t\t * Error: not enough place for another match\n\t\t\t * (min 4) + 5 literals\n\t\t\t */\n\t\t\tif (cpy != oend)\n\t\t\t\tgoto _output_error;\n\n\t\t\tmemcpy(op, ip, length);\n\t\t\tip += length;\n\t\t\tbreak; /* EOF */\n\t\t}\n\t\tLZ4_WILDCOPY(ip, op, cpy);\n\t\tip -= (op - cpy);\n\t\top = cpy;\n\n\t\t/* get offset */\n\t\tLZ4_READ_LITTLEENDIAN_16(ref, cpy, ip);\n\t\tip += 2;\n\n\t\t/* Error: offset create reference outside destination buffer */\n\t\tif (unlikely(ref < (BYTE *const) dest))\n\t\t\tgoto _output_error;\n\n\t\t/* get matchlength */\n\t\tlength = token & ML_MASK;\n\t\tif (length == ML_MASK) {\n\t\t\tfor (; *ip == 255; length += 255)\n\t\t\t\tip++;\n\t\t\tlength += *ip++;\n\t\t}\n\n\t\t/* copy repeated sequence */\n\t\tif (unlikely((op - ref) < STEPSIZE)) {\n#if LZ4_ARCH64\n\t\t\tsize_t dec64 = dec64table[op - ref];\n#else\n\t\t\tconst int dec64 = 0;\n#endif\n\t\t\top[0] = ref[0];\n\t\t\top[1] = ref[1];\n\t\t\top[2] = ref[2];\n\t\t\top[3] = ref[3];\n\t\t\top += 4;\n\t\t\tref += 4;\n\t\t\tref -= dec32table[op-ref];\n\t\t\tPUT4(ref, op);\n\t\t\top += STEPSIZE - 4;\n\t\t\tref -= dec64;\n\t\t} else {\n\t\t\tLZ4_COPYSTEP(ref, op);\n\t\t}\n\t\tcpy = op + length - (STEPSIZE - 4);\n\t\tif (cpy > (oend - COPYLENGTH)) {\n\n\t\t\t/* Error: request to write beyond destination buffer */\n\t\t\tif (cpy > oend)\n\t\t\t\tgoto _output_error;\n\t\t\tLZ4_SECURECOPY(ref, op, (oend - COPYLENGTH));\n\t\t\twhile (op < cpy)\n\t\t\t\t*op++ = *ref++;\n\t\t\top = cpy;\n\t\t\t/*\n\t\t\t * Check EOF (should never happen, since last 5 bytes\n\t\t\t * are supposed to be literals)\n\t\t\t */\n\t\t\tif (op == oend)\n\t\t\t\tgoto _output_error;\n\t\t\tcontinue;\n\t\t}\n\t\tLZ4_SECURECOPY(ref, op, cpy);\n\t\top = cpy; /* correction */\n\t}\n\t/* end of decoding */\n\treturn (int) (((char *)ip) - source);\n\n\t/* write overflow error detected */\n_output_error:\n\treturn (int) (-(((char *)ip) - source));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141851,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int lz4_uncompress(const char *source, char *dest, int osize)\n{\n\tconst BYTE *ip = (const BYTE *) source;\n\tconst BYTE *ref;\n\tBYTE *op = (BYTE *) dest;\n\tBYTE * const oend = op + osize;\n\tBYTE *cpy;\n\tunsigned token;\n\tsize_t length;\n\tsize_t dec32table[] = {0, 3, 2, 3, 0, 0, 0, 0};\n#if LZ4_ARCH64\n\tsize_t dec64table[] = {0, 0, 0, -1, 0, 1, 2, 3};\n#endif\n\n\twhile (1) {\n\n\t\t/* get runlength */\n\t\ttoken = *ip++;\n\t\tlength = (token >> ML_BITS);\n\t\tif (length == RUN_MASK) {\n\t\t\tsize_t len;\n\n \t\t\tlen = *ip++;\n \t\t\tfor (; len == 255; length += 255)\n \t\t\t\tlen = *ip++;\n\t\t\tif (unlikely(length > (size_t)(length + len)))\n\t\t\t\tgoto _output_error;\n \t\t\tlength += len;\n \t\t}\n \n\t\t/* copy literals */\n\t\tcpy = op + length;\n\t\tif (unlikely(cpy > oend - COPYLENGTH)) {\n\t\t\t/*\n\t\t\t * Error: not enough place for another match\n\t\t\t * (min 4) + 5 literals\n\t\t\t */\n\t\t\tif (cpy != oend)\n\t\t\t\tgoto _output_error;\n\n\t\t\tmemcpy(op, ip, length);\n\t\t\tip += length;\n\t\t\tbreak; /* EOF */\n\t\t}\n\t\tLZ4_WILDCOPY(ip, op, cpy);\n\t\tip -= (op - cpy);\n\t\top = cpy;\n\n\t\t/* get offset */\n\t\tLZ4_READ_LITTLEENDIAN_16(ref, cpy, ip);\n\t\tip += 2;\n\n\t\t/* Error: offset create reference outside destination buffer */\n\t\tif (unlikely(ref < (BYTE *const) dest))\n\t\t\tgoto _output_error;\n\n\t\t/* get matchlength */\n\t\tlength = token & ML_MASK;\n\t\tif (length == ML_MASK) {\n\t\t\tfor (; *ip == 255; length += 255)\n\t\t\t\tip++;\n\t\t\tlength += *ip++;\n\t\t}\n\n\t\t/* copy repeated sequence */\n\t\tif (unlikely((op - ref) < STEPSIZE)) {\n#if LZ4_ARCH64\n\t\t\tsize_t dec64 = dec64table[op - ref];\n#else\n\t\t\tconst int dec64 = 0;\n#endif\n\t\t\top[0] = ref[0];\n\t\t\top[1] = ref[1];\n\t\t\top[2] = ref[2];\n\t\t\top[3] = ref[3];\n\t\t\top += 4;\n\t\t\tref += 4;\n\t\t\tref -= dec32table[op-ref];\n\t\t\tPUT4(ref, op);\n\t\t\top += STEPSIZE - 4;\n\t\t\tref -= dec64;\n\t\t} else {\n\t\t\tLZ4_COPYSTEP(ref, op);\n\t\t}\n\t\tcpy = op + length - (STEPSIZE - 4);\n\t\tif (cpy > (oend - COPYLENGTH)) {\n\n\t\t\t/* Error: request to write beyond destination buffer */\n\t\t\tif (cpy > oend)\n\t\t\t\tgoto _output_error;\n\t\t\tLZ4_SECURECOPY(ref, op, (oend - COPYLENGTH));\n\t\t\twhile (op < cpy)\n\t\t\t\t*op++ = *ref++;\n\t\t\top = cpy;\n\t\t\t/*\n\t\t\t * Check EOF (should never happen, since last 5 bytes\n\t\t\t * are supposed to be literals)\n\t\t\t */\n\t\t\tif (op == oend)\n\t\t\t\tgoto _output_error;\n\t\t\tcontinue;\n\t\t}\n\t\tLZ4_SECURECOPY(ref, op, cpy);\n\t\top = cpy; /* correction */\n\t}\n\t/* end of decoding */\n\treturn (int) (((char *)ip) - source);\n\n\t/* write overflow error detected */\n_output_error:\n\treturn (int) (-(((char *)ip) - source));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141852,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static bool parse_notify(struct pool *pool, json_t *val)\n{\n\tchar *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit,\n\t     *ntime, *header;\n\tsize_t cb1_len, cb2_len, alloc_len;\n\tunsigned char *cb1, *cb2;\n\tbool clean, ret = false;\n\tint merkles, i;\n\tjson_t *arr;\n\n\tarr = json_array_get(val, 4);\n\tif (!arr || !json_is_array(arr))\n\t\tgoto out;\n\n\tmerkles = json_array_size(arr);\n\n\tjob_id = json_array_string(val, 0);\n\tprev_hash = json_array_string(val, 1);\n\tcoinbase1 = json_array_string(val, 2);\n\tcoinbase2 = json_array_string(val, 3);\n\tbbversion = json_array_string(val, 5);\n\tnbit = json_array_string(val, 6);\n\tntime = json_array_string(val, 7);\n\tclean = json_is_true(json_array_get(val, 8));\n\n\tif (!job_id || !prev_hash || !coinbase1 || !coinbase2 || !bbversion || !nbit || !ntime) {\n\t\t/* Annoying but we must not leak memory */\n\t\tif (job_id)\n\t\t\tfree(job_id);\n\t\tif (prev_hash)\n\t\t\tfree(prev_hash);\n\t\tif (coinbase1)\n\t\t\tfree(coinbase1);\n\t\tif (coinbase2)\n\t\t\tfree(coinbase2);\n\t\tif (bbversion)\n\t\t\tfree(bbversion);\n\t\tif (nbit)\n\t\t\tfree(nbit);\n\t\tif (ntime)\n\t\t\tfree(ntime);\n\t\tgoto out;\n\t}\n\n\tcg_wlock(&pool->data_lock);\n\tfree(pool->swork.job_id);\n\tfree(pool->swork.prev_hash);\n\tfree(pool->swork.bbversion);\n\tfree(pool->swork.nbit);\n\tfree(pool->swork.ntime);\n\tpool->swork.job_id = job_id;\n\tpool->swork.prev_hash = prev_hash;\n\tcb1_len = strlen(coinbase1) / 2;\n\tcb2_len = strlen(coinbase2) / 2;\n\tpool->swork.bbversion = bbversion;\n\tpool->swork.nbit = nbit;\n\tpool->swork.ntime = ntime;\n\tpool->swork.clean = clean;\n\talloc_len = pool->swork.cb_len = cb1_len + pool->n1_len + pool->n2size + cb2_len;\n\tpool->nonce2_offset = cb1_len + pool->n1_len;\n\n\tfor (i = 0; i < pool->swork.merkles; i++)\n\t\tfree(pool->swork.merkle_bin[i]);\n\tif (merkles) {\n\t\tpool->swork.merkle_bin = (unsigned char **)realloc(pool->swork.merkle_bin,\n\t\t\t\t\t\t sizeof(char *) * merkles + 1);\n\t\tfor (i = 0; i < merkles; i++) {\n\t\t\tchar *merkle = json_array_string(arr, i);\n\n\t\t\tpool->swork.merkle_bin[i] = (unsigned char *)malloc(32);\n\t\t\tif (unlikely(!pool->swork.merkle_bin[i]))\n\t\t\t\tquit(1, \"Failed to malloc pool swork merkle_bin\");\n\t\t\thex2bin(pool->swork.merkle_bin[i], merkle, 32);\n\t\t\tfree(merkle);\n\t\t}\n\t}\n\tpool->swork.merkles = merkles;\n\tif (clean)\n\t\tpool->nonce2 = 0;\n\tpool->merkle_offset = strlen(pool->swork.bbversion) +\n\t\t\t      strlen(pool->swork.prev_hash);\n\tpool->swork.header_len = pool->merkle_offset +\n\t/* merkle_hash */\t 32 +\n\t\t\t\t strlen(pool->swork.ntime) +\n\t\t\t\t strlen(pool->swork.nbit) +\n\t/* nonce */\t\t 8 +\n\t/* workpadding */\t 96;\n\tpool->merkle_offset /= 2;\n\tpool->swork.header_len = pool->swork.header_len * 2 + 1;\n\talign_len(&pool->swork.header_len);\n\theader = (char *)alloca(pool->swork.header_len);\n\tsnprintf(header, pool->swork.header_len,\n\t\t\"%s%s%s%s%s%s%s\",\n\t\tpool->swork.bbversion,\n\t\tpool->swork.prev_hash,\n\t\tblank_merkel,\n\t\tpool->swork.ntime,\n \t\tpool->swork.nbit,\n \t\t\"00000000\", /* nonce */\n \t\tworkpadding);\n\tif (unlikely(!hex2bin(pool->header_bin, header, 128)))\n\t\tquit(1, \"Failed to convert header to header_bin in parse_notify\");\n \n \tcb1 = (unsigned char *)calloc(cb1_len, 1);\n \tif (unlikely(!cb1))\n \t\tquithere(1, \"Failed to calloc cb1 in parse_notify\");\n \thex2bin(cb1, coinbase1, cb1_len);\n \tcb2 = (unsigned char *)calloc(cb2_len, 1);\n \tif (unlikely(!cb2))\n \t\tquithere(1, \"Failed to calloc cb2 in parse_notify\");\n \thex2bin(cb2, coinbase2, cb2_len);\n \tfree(pool->coinbase);\n \talign_len(&alloc_len);\n \tpool->coinbase = (unsigned char *)calloc(alloc_len, 1);\n \tif (unlikely(!pool->coinbase))\n \t\tquit(1, \"Failed to calloc pool coinbase in parse_notify\");\n \tmemcpy(pool->coinbase, cb1, cb1_len);\n \tmemcpy(pool->coinbase + cb1_len, pool->nonce1bin, pool->n1_len);\n \tmemcpy(pool->coinbase + cb1_len + pool->n1_len + pool->n2size, cb2, cb2_len);\n \tcg_wunlock(&pool->data_lock);\n \n\tif (opt_protocol) {\n\t\tapplog(LOG_DEBUG, \"job_id: %s\", job_id);\n\t\tapplog(LOG_DEBUG, \"prev_hash: %s\", prev_hash);\n\t\tapplog(LOG_DEBUG, \"coinbase1: %s\", coinbase1);\n\t\tapplog(LOG_DEBUG, \"coinbase2: %s\", coinbase2);\n\t\tapplog(LOG_DEBUG, \"bbversion: %s\", bbversion);\n\t\tapplog(LOG_DEBUG, \"nbit: %s\", nbit);\n\t\tapplog(LOG_DEBUG, \"ntime: %s\", ntime);\n\t\tapplog(LOG_DEBUG, \"clean: %s\", clean ? \"yes\" : \"no\");\n\t}\n\tfree(coinbase1);\n\tfree(coinbase2);\n\tfree(cb1);\n\tfree(cb2);\n\n\t/* A notify message is the closest stratum gets to a getwork */\n\tpool->getwork_requested++;\n\ttotal_getworks++;\n\tret = true;\n\tif (pool == current_pool())\n\t\topt_work_update = true;\nout:\n\treturn ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141855,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static bool parse_notify(struct pool *pool, json_t *val)\n{\n\tchar *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit,\n\t     *ntime, *header;\n\tsize_t cb1_len, cb2_len, alloc_len;\n\tunsigned char *cb1, *cb2;\n\tbool clean, ret = false;\n\tint merkles, i;\n\tjson_t *arr;\n\n\tarr = json_array_get(val, 4);\n\tif (!arr || !json_is_array(arr))\n\t\tgoto out;\n\n\tmerkles = json_array_size(arr);\n\n\tjob_id = json_array_string(val, 0);\n\tprev_hash = json_array_string(val, 1);\n\tcoinbase1 = json_array_string(val, 2);\n\tcoinbase2 = json_array_string(val, 3);\n\tbbversion = json_array_string(val, 5);\n\tnbit = json_array_string(val, 6);\n\tntime = json_array_string(val, 7);\n\tclean = json_is_true(json_array_get(val, 8));\n\n\tif (!job_id || !prev_hash || !coinbase1 || !coinbase2 || !bbversion || !nbit || !ntime) {\n\t\t/* Annoying but we must not leak memory */\n\t\tif (job_id)\n\t\t\tfree(job_id);\n\t\tif (prev_hash)\n\t\t\tfree(prev_hash);\n\t\tif (coinbase1)\n\t\t\tfree(coinbase1);\n\t\tif (coinbase2)\n\t\t\tfree(coinbase2);\n\t\tif (bbversion)\n\t\t\tfree(bbversion);\n\t\tif (nbit)\n\t\t\tfree(nbit);\n\t\tif (ntime)\n\t\t\tfree(ntime);\n\t\tgoto out;\n\t}\n\n\tcg_wlock(&pool->data_lock);\n\tfree(pool->swork.job_id);\n\tfree(pool->swork.prev_hash);\n\tfree(pool->swork.bbversion);\n\tfree(pool->swork.nbit);\n\tfree(pool->swork.ntime);\n\tpool->swork.job_id = job_id;\n\tpool->swork.prev_hash = prev_hash;\n\tcb1_len = strlen(coinbase1) / 2;\n\tcb2_len = strlen(coinbase2) / 2;\n\tpool->swork.bbversion = bbversion;\n\tpool->swork.nbit = nbit;\n\tpool->swork.ntime = ntime;\n\tpool->swork.clean = clean;\n\talloc_len = pool->swork.cb_len = cb1_len + pool->n1_len + pool->n2size + cb2_len;\n\tpool->nonce2_offset = cb1_len + pool->n1_len;\n\n\tfor (i = 0; i < pool->swork.merkles; i++)\n\t\tfree(pool->swork.merkle_bin[i]);\n\tif (merkles) {\n\t\tpool->swork.merkle_bin = (unsigned char **)realloc(pool->swork.merkle_bin,\n\t\t\t\t\t\t sizeof(char *) * merkles + 1);\n\t\tfor (i = 0; i < merkles; i++) {\n\t\t\tchar *merkle = json_array_string(arr, i);\n\n\t\t\tpool->swork.merkle_bin[i] = (unsigned char *)malloc(32);\n\t\t\tif (unlikely(!pool->swork.merkle_bin[i]))\n\t\t\t\tquit(1, \"Failed to malloc pool swork merkle_bin\");\n\t\t\thex2bin(pool->swork.merkle_bin[i], merkle, 32);\n\t\t\tfree(merkle);\n\t\t}\n\t}\n\tpool->swork.merkles = merkles;\n\tif (clean)\n\t\tpool->nonce2 = 0;\n\tpool->merkle_offset = strlen(pool->swork.bbversion) +\n\t\t\t      strlen(pool->swork.prev_hash);\n\tpool->swork.header_len = pool->merkle_offset +\n\t/* merkle_hash */\t 32 +\n\t\t\t\t strlen(pool->swork.ntime) +\n\t\t\t\t strlen(pool->swork.nbit) +\n\t/* nonce */\t\t 8 +\n\t/* workpadding */\t 96;\n\tpool->merkle_offset /= 2;\n\tpool->swork.header_len = pool->swork.header_len * 2 + 1;\n\talign_len(&pool->swork.header_len);\n\theader = (char *)alloca(pool->swork.header_len);\n\tsnprintf(header, pool->swork.header_len,\n\t\t\"%s%s%s%s%s%s%s\",\n\t\tpool->swork.bbversion,\n\t\tpool->swork.prev_hash,\n\t\tblank_merkel,\n\t\tpool->swork.ntime,\n \t\tpool->swork.nbit,\n \t\t\"00000000\", /* nonce */\n \t\tworkpadding);\n\tif (unlikely(!hex2bin(pool->header_bin, header, 128))) {\n\t\tapplog(LOG_WARNING, \"%s: Failed to convert header to header_bin, got %s\", __func__, header);\n\t\tpool_failed(pool);\n\t\t// TODO: memory leaks? goto out, clean up there?\n\t\treturn false;\n\t}\n \n \tcb1 = (unsigned char *)calloc(cb1_len, 1);\n \tif (unlikely(!cb1))\n \t\tquithere(1, \"Failed to calloc cb1 in parse_notify\");\n \thex2bin(cb1, coinbase1, cb1_len);\n\n \tcb2 = (unsigned char *)calloc(cb2_len, 1);\n \tif (unlikely(!cb2))\n \t\tquithere(1, \"Failed to calloc cb2 in parse_notify\");\n \thex2bin(cb2, coinbase2, cb2_len);\n\n \tfree(pool->coinbase);\n \talign_len(&alloc_len);\n \tpool->coinbase = (unsigned char *)calloc(alloc_len, 1);\n \tif (unlikely(!pool->coinbase))\n \t\tquit(1, \"Failed to calloc pool coinbase in parse_notify\");\n \tmemcpy(pool->coinbase, cb1, cb1_len);\n \tmemcpy(pool->coinbase + cb1_len, pool->nonce1bin, pool->n1_len);\n\t// NOTE: gap for nonce2, filled at work generation time\n \tmemcpy(pool->coinbase + cb1_len + pool->n1_len + pool->n2size, cb2, cb2_len);\n \tcg_wunlock(&pool->data_lock);\n \n\tif (opt_protocol) {\n\t\tapplog(LOG_DEBUG, \"job_id: %s\", job_id);\n\t\tapplog(LOG_DEBUG, \"prev_hash: %s\", prev_hash);\n\t\tapplog(LOG_DEBUG, \"coinbase1: %s\", coinbase1);\n\t\tapplog(LOG_DEBUG, \"coinbase2: %s\", coinbase2);\n\t\tapplog(LOG_DEBUG, \"bbversion: %s\", bbversion);\n\t\tapplog(LOG_DEBUG, \"nbit: %s\", nbit);\n\t\tapplog(LOG_DEBUG, \"ntime: %s\", ntime);\n\t\tapplog(LOG_DEBUG, \"clean: %s\", clean ? \"yes\" : \"no\");\n\t}\n\tfree(coinbase1);\n\tfree(coinbase2);\n\tfree(cb1);\n\tfree(cb2);\n\n\t/* A notify message is the closest stratum gets to a getwork */\n\tpool->getwork_requested++;\n\ttotal_getworks++;\n\tret = true;\n\tif (pool == current_pool())\n\t\topt_work_update = true;\nout:\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141856,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static bool nested_vmx_exit_handled(struct kvm_vcpu *vcpu)\n{\n\tu32 intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tu32 exit_reason = vmx->exit_reason;\n\n\tif (vmx->nested.nested_run_pending)\n\t\treturn 0;\n\n\tif (unlikely(vmx->fail)) {\n\t\tpr_info_ratelimited(\"%s failed vm entry %x\\n\", __func__,\n\t\t\t\t    vmcs_read32(VM_INSTRUCTION_ERROR));\n\t\treturn 1;\n\t}\n\n\tswitch (exit_reason) {\n\tcase EXIT_REASON_EXCEPTION_NMI:\n\t\tif (!is_exception(intr_info))\n\t\t\treturn 0;\n\t\telse if (is_page_fault(intr_info))\n\t\t\treturn enable_ept;\n\t\treturn vmcs12->exception_bitmap &\n\t\t\t\t(1u << (intr_info & INTR_INFO_VECTOR_MASK));\n\tcase EXIT_REASON_EXTERNAL_INTERRUPT:\n\t\treturn 0;\n\tcase EXIT_REASON_TRIPLE_FAULT:\n\t\treturn 1;\n\tcase EXIT_REASON_PENDING_INTERRUPT:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_INTR_PENDING);\n\tcase EXIT_REASON_NMI_WINDOW:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_NMI_PENDING);\n\tcase EXIT_REASON_TASK_SWITCH:\n\t\treturn 1;\n\tcase EXIT_REASON_CPUID:\n\t\treturn 1;\n\tcase EXIT_REASON_HLT:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_HLT_EXITING);\n\tcase EXIT_REASON_INVD:\n\t\treturn 1;\n\tcase EXIT_REASON_INVLPG:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_INVLPG_EXITING);\n\tcase EXIT_REASON_RDPMC:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_RDPMC_EXITING);\n\tcase EXIT_REASON_RDTSC:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_RDTSC_EXITING);\n\tcase EXIT_REASON_VMCALL: case EXIT_REASON_VMCLEAR:\n\tcase EXIT_REASON_VMLAUNCH: case EXIT_REASON_VMPTRLD:\n \tcase EXIT_REASON_VMPTRST: case EXIT_REASON_VMREAD:\n \tcase EXIT_REASON_VMRESUME: case EXIT_REASON_VMWRITE:\n \tcase EXIT_REASON_VMOFF: case EXIT_REASON_VMON:\n \t\t/*\n \t\t * VMX instructions trap unconditionally. This allows L1 to\n \t\t * emulate them for its L2 guest, i.e., allows 3-level nesting!\n\t\t */\n\t\treturn 1;\n\tcase EXIT_REASON_CR_ACCESS:\n\t\treturn nested_vmx_exit_handled_cr(vcpu, vmcs12);\n\tcase EXIT_REASON_DR_ACCESS:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MOV_DR_EXITING);\n\tcase EXIT_REASON_IO_INSTRUCTION:\n\t\treturn nested_vmx_exit_handled_io(vcpu, vmcs12);\n\tcase EXIT_REASON_MSR_READ:\n\tcase EXIT_REASON_MSR_WRITE:\n\t\treturn nested_vmx_exit_handled_msr(vcpu, vmcs12, exit_reason);\n\tcase EXIT_REASON_INVALID_STATE:\n\t\treturn 1;\n\tcase EXIT_REASON_MWAIT_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MWAIT_EXITING);\n\tcase EXIT_REASON_MONITOR_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MONITOR_EXITING);\n\tcase EXIT_REASON_PAUSE_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_PAUSE_EXITING) ||\n\t\t\tnested_cpu_has2(vmcs12,\n\t\t\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING);\n\tcase EXIT_REASON_MCE_DURING_VMENTRY:\n\t\treturn 0;\n\tcase EXIT_REASON_TPR_BELOW_THRESHOLD:\n\t\treturn 1;\n\tcase EXIT_REASON_APIC_ACCESS:\n\t\treturn nested_cpu_has2(vmcs12,\n\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES);\n\tcase EXIT_REASON_EPT_VIOLATION:\n\tcase EXIT_REASON_EPT_MISCONFIG:\n\t\treturn 0;\n\tcase EXIT_REASON_PREEMPTION_TIMER:\n\t\treturn vmcs12->pin_based_vm_exec_control &\n\t\t\tPIN_BASED_VMX_PREEMPTION_TIMER;\n\tcase EXIT_REASON_WBINVD:\n\t\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_WBINVD_EXITING);\n\tcase EXIT_REASON_XSETBV:\n\t\treturn 1;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141867,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static bool nested_vmx_exit_handled(struct kvm_vcpu *vcpu)\n{\n\tu32 intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tu32 exit_reason = vmx->exit_reason;\n\n\tif (vmx->nested.nested_run_pending)\n\t\treturn 0;\n\n\tif (unlikely(vmx->fail)) {\n\t\tpr_info_ratelimited(\"%s failed vm entry %x\\n\", __func__,\n\t\t\t\t    vmcs_read32(VM_INSTRUCTION_ERROR));\n\t\treturn 1;\n\t}\n\n\tswitch (exit_reason) {\n\tcase EXIT_REASON_EXCEPTION_NMI:\n\t\tif (!is_exception(intr_info))\n\t\t\treturn 0;\n\t\telse if (is_page_fault(intr_info))\n\t\t\treturn enable_ept;\n\t\treturn vmcs12->exception_bitmap &\n\t\t\t\t(1u << (intr_info & INTR_INFO_VECTOR_MASK));\n\tcase EXIT_REASON_EXTERNAL_INTERRUPT:\n\t\treturn 0;\n\tcase EXIT_REASON_TRIPLE_FAULT:\n\t\treturn 1;\n\tcase EXIT_REASON_PENDING_INTERRUPT:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_INTR_PENDING);\n\tcase EXIT_REASON_NMI_WINDOW:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_NMI_PENDING);\n\tcase EXIT_REASON_TASK_SWITCH:\n\t\treturn 1;\n\tcase EXIT_REASON_CPUID:\n\t\treturn 1;\n\tcase EXIT_REASON_HLT:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_HLT_EXITING);\n\tcase EXIT_REASON_INVD:\n\t\treturn 1;\n\tcase EXIT_REASON_INVLPG:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_INVLPG_EXITING);\n\tcase EXIT_REASON_RDPMC:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_RDPMC_EXITING);\n\tcase EXIT_REASON_RDTSC:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_RDTSC_EXITING);\n\tcase EXIT_REASON_VMCALL: case EXIT_REASON_VMCLEAR:\n\tcase EXIT_REASON_VMLAUNCH: case EXIT_REASON_VMPTRLD:\n \tcase EXIT_REASON_VMPTRST: case EXIT_REASON_VMREAD:\n \tcase EXIT_REASON_VMRESUME: case EXIT_REASON_VMWRITE:\n \tcase EXIT_REASON_VMOFF: case EXIT_REASON_VMON:\n\tcase EXIT_REASON_INVEPT:\n \t\t/*\n \t\t * VMX instructions trap unconditionally. This allows L1 to\n \t\t * emulate them for its L2 guest, i.e., allows 3-level nesting!\n\t\t */\n\t\treturn 1;\n\tcase EXIT_REASON_CR_ACCESS:\n\t\treturn nested_vmx_exit_handled_cr(vcpu, vmcs12);\n\tcase EXIT_REASON_DR_ACCESS:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MOV_DR_EXITING);\n\tcase EXIT_REASON_IO_INSTRUCTION:\n\t\treturn nested_vmx_exit_handled_io(vcpu, vmcs12);\n\tcase EXIT_REASON_MSR_READ:\n\tcase EXIT_REASON_MSR_WRITE:\n\t\treturn nested_vmx_exit_handled_msr(vcpu, vmcs12, exit_reason);\n\tcase EXIT_REASON_INVALID_STATE:\n\t\treturn 1;\n\tcase EXIT_REASON_MWAIT_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MWAIT_EXITING);\n\tcase EXIT_REASON_MONITOR_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MONITOR_EXITING);\n\tcase EXIT_REASON_PAUSE_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_PAUSE_EXITING) ||\n\t\t\tnested_cpu_has2(vmcs12,\n\t\t\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING);\n\tcase EXIT_REASON_MCE_DURING_VMENTRY:\n\t\treturn 0;\n\tcase EXIT_REASON_TPR_BELOW_THRESHOLD:\n\t\treturn 1;\n\tcase EXIT_REASON_APIC_ACCESS:\n\t\treturn nested_cpu_has2(vmcs12,\n\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES);\n\tcase EXIT_REASON_EPT_VIOLATION:\n\tcase EXIT_REASON_EPT_MISCONFIG:\n\t\treturn 0;\n\tcase EXIT_REASON_PREEMPTION_TIMER:\n\t\treturn vmcs12->pin_based_vm_exec_control &\n\t\t\tPIN_BASED_VMX_PREEMPTION_TIMER;\n\tcase EXIT_REASON_WBINVD:\n\t\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_WBINVD_EXITING);\n\tcase EXIT_REASON_XSETBV:\n\t\treturn 1;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141868,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int cma_req_handler(struct ib_cm_id *cm_id, struct ib_cm_event *ib_event)\n{\n \tstruct rdma_id_private *listen_id, *conn_id;\n \tstruct rdma_cm_event event;\n \tint offset, ret;\n\tu8 smac[ETH_ALEN];\n\tu8 alt_smac[ETH_ALEN];\n\tu8 *psmac = smac;\n\tu8 *palt_smac = alt_smac;\n\tint is_iboe = ((rdma_node_get_transport(cm_id->device->node_type) ==\n\t\t\tRDMA_TRANSPORT_IB) &&\n\t\t       (rdma_port_get_link_layer(cm_id->device,\n\t\t\tib_event->param.req_rcvd.port) ==\n\t\t\tIB_LINK_LAYER_ETHERNET));\n \n \tlisten_id = cm_id->context;\n \tif (!cma_check_req_qp_type(&listen_id->id, ib_event))\n\t\treturn -EINVAL;\n\n\tif (cma_disable_callback(listen_id, RDMA_CM_LISTEN))\n\t\treturn -ECONNABORTED;\n\n\tmemset(&event, 0, sizeof event);\n\toffset = cma_user_data_offset(listen_id);\n\tevent.event = RDMA_CM_EVENT_CONNECT_REQUEST;\n\tif (ib_event->event == IB_CM_SIDR_REQ_RECEIVED) {\n\t\tconn_id = cma_new_udp_id(&listen_id->id, ib_event);\n\t\tevent.param.ud.private_data = ib_event->private_data + offset;\n\t\tevent.param.ud.private_data_len =\n\t\t\t\tIB_CM_SIDR_REQ_PRIVATE_DATA_SIZE - offset;\n\t} else {\n\t\tconn_id = cma_new_conn_id(&listen_id->id, ib_event);\n\t\tcma_set_req_event_data(&event, &ib_event->param.req_rcvd,\n\t\t\t\t       ib_event->private_data, offset);\n\t}\n\tif (!conn_id) {\n\t\tret = -ENOMEM;\n\t\tgoto err1;\n\t}\n\n\tmutex_lock_nested(&conn_id->handler_mutex, SINGLE_DEPTH_NESTING);\n\tret = cma_acquire_dev(conn_id, listen_id);\n\tif (ret)\n\t\tgoto err2;\n\n\tconn_id->cm_id.ib = cm_id;\n\tcm_id->context = conn_id;\n\tcm_id->cm_handler = cma_ib_handler;\n\n\t/*\n\t * Protect against the user destroying conn_id from another thread\n\t * until we're done accessing it.\n\t */\n\tatomic_inc(&conn_id->refcount);\n \tret = conn_id->id.event_handler(&conn_id->id, &event);\n \tif (ret)\n \t\tgoto err3;\n\tif (is_iboe) {\n\t\tif (ib_event->param.req_rcvd.primary_path != NULL)\n\t\t\trdma_addr_find_smac_by_sgid(\n\t\t\t\t&ib_event->param.req_rcvd.primary_path->sgid,\n\t\t\t\tpsmac, NULL);\n\t\telse\n\t\t\tpsmac = NULL;\n\t\tif (ib_event->param.req_rcvd.alternate_path != NULL)\n\t\t\trdma_addr_find_smac_by_sgid(\n\t\t\t\t&ib_event->param.req_rcvd.alternate_path->sgid,\n\t\t\t\tpalt_smac, NULL);\n\t\telse\n\t\t\tpalt_smac = NULL;\n\t}\n \t/*\n \t * Acquire mutex to prevent user executing rdma_destroy_id()\n \t * while we're accessing the cm_id.\n \t */\n \tmutex_lock(&lock);\n\tif (is_iboe)\n\t\tib_update_cm_av(cm_id, psmac, palt_smac);\n \tif (cma_comp(conn_id, RDMA_CM_CONNECT) &&\n \t    (conn_id->id.qp_type != IB_QPT_UD))\n \t\tib_send_cm_mra(cm_id, CMA_CM_MRA_SETTING, NULL, 0);\n\tmutex_unlock(&lock);\n\tmutex_unlock(&conn_id->handler_mutex);\n\tmutex_unlock(&listen_id->handler_mutex);\n\tcma_deref_id(conn_id);\n\treturn 0;\n\nerr3:\n\tcma_deref_id(conn_id);\n\t/* Destroy the CM ID by returning a non-zero value. */\n\tconn_id->cm_id.ib = NULL;\nerr2:\n\tcma_exch(conn_id, RDMA_CM_DESTROYING);\n\tmutex_unlock(&conn_id->handler_mutex);\nerr1:\n\tmutex_unlock(&listen_id->handler_mutex);\n\tif (conn_id)\n\t\trdma_destroy_id(&conn_id->id);\n\treturn ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141891,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int cma_req_handler(struct ib_cm_id *cm_id, struct ib_cm_event *ib_event)\n{\n \tstruct rdma_id_private *listen_id, *conn_id;\n \tstruct rdma_cm_event event;\n \tint offset, ret;\n \n \tlisten_id = cm_id->context;\n \tif (!cma_check_req_qp_type(&listen_id->id, ib_event))\n\t\treturn -EINVAL;\n\n\tif (cma_disable_callback(listen_id, RDMA_CM_LISTEN))\n\t\treturn -ECONNABORTED;\n\n\tmemset(&event, 0, sizeof event);\n\toffset = cma_user_data_offset(listen_id);\n\tevent.event = RDMA_CM_EVENT_CONNECT_REQUEST;\n\tif (ib_event->event == IB_CM_SIDR_REQ_RECEIVED) {\n\t\tconn_id = cma_new_udp_id(&listen_id->id, ib_event);\n\t\tevent.param.ud.private_data = ib_event->private_data + offset;\n\t\tevent.param.ud.private_data_len =\n\t\t\t\tIB_CM_SIDR_REQ_PRIVATE_DATA_SIZE - offset;\n\t} else {\n\t\tconn_id = cma_new_conn_id(&listen_id->id, ib_event);\n\t\tcma_set_req_event_data(&event, &ib_event->param.req_rcvd,\n\t\t\t\t       ib_event->private_data, offset);\n\t}\n\tif (!conn_id) {\n\t\tret = -ENOMEM;\n\t\tgoto err1;\n\t}\n\n\tmutex_lock_nested(&conn_id->handler_mutex, SINGLE_DEPTH_NESTING);\n\tret = cma_acquire_dev(conn_id, listen_id);\n\tif (ret)\n\t\tgoto err2;\n\n\tconn_id->cm_id.ib = cm_id;\n\tcm_id->context = conn_id;\n\tcm_id->cm_handler = cma_ib_handler;\n\n\t/*\n\t * Protect against the user destroying conn_id from another thread\n\t * until we're done accessing it.\n\t */\n\tatomic_inc(&conn_id->refcount);\n \tret = conn_id->id.event_handler(&conn_id->id, &event);\n \tif (ret)\n \t\tgoto err3;\n \t/*\n \t * Acquire mutex to prevent user executing rdma_destroy_id()\n \t * while we're accessing the cm_id.\n \t */\n \tmutex_lock(&lock);\n \tif (cma_comp(conn_id, RDMA_CM_CONNECT) &&\n \t    (conn_id->id.qp_type != IB_QPT_UD))\n \t\tib_send_cm_mra(cm_id, CMA_CM_MRA_SETTING, NULL, 0);\n\tmutex_unlock(&lock);\n\tmutex_unlock(&conn_id->handler_mutex);\n\tmutex_unlock(&listen_id->handler_mutex);\n\tcma_deref_id(conn_id);\n\treturn 0;\n\nerr3:\n\tcma_deref_id(conn_id);\n\t/* Destroy the CM ID by returning a non-zero value. */\n\tconn_id->cm_id.ib = NULL;\nerr2:\n\tcma_exch(conn_id, RDMA_CM_DESTROYING);\n\tmutex_unlock(&conn_id->handler_mutex);\nerr1:\n\tmutex_unlock(&listen_id->handler_mutex);\n\tif (conn_id)\n\t\trdma_destroy_id(&conn_id->id);\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141892,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)\n{\n\tflush_fp_to_thread(src);\n \tflush_altivec_to_thread(src);\n \tflush_vsx_to_thread(src);\n \tflush_spe_to_thread(src);\n \n \t*dst = *src;\n \n\tclear_task_ebb(dst);\n\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141895,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)\n{\n\tflush_fp_to_thread(src);\n \tflush_altivec_to_thread(src);\n \tflush_vsx_to_thread(src);\n \tflush_spe_to_thread(src);\n\t/*\n\t * Flush TM state out so we can copy it.  __switch_to_tm() does this\n\t * flush but it removes the checkpointed state from the current CPU and\n\t * transitions the CPU out of TM mode.  Hence we need to call\n\t * tm_recheckpoint_new_task() (on the same task) to restore the\n\t * checkpointed state back and the TM mode.\n\t */\n\t__switch_to_tm(src);\n\ttm_recheckpoint_new_task(src);\n \n \t*dst = *src;\n \n\tclear_task_ebb(dst);\n\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141896,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int dccp_error(struct net *net, struct nf_conn *tmpl,\n\t\t      struct sk_buff *skb, unsigned int dataoff,\n\t\t      enum ip_conntrack_info *ctinfo,\n\t\t      u_int8_t pf, unsigned int hooknum)\n{\n\tstruct dccp_hdr _dh, *dh;\n\tunsigned int dccp_len = skb->len - dataoff;\n \tunsigned int cscov;\n \tconst char *msg;\n \n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n \tif (dh == NULL) {\n \t\tmsg = \"nf_ct_dccp: short packet \";\n \t\tgoto out_invalid;\n\t}\n\n\tif (dh->dccph_doff * 4 < sizeof(struct dccp_hdr) ||\n\t    dh->dccph_doff * 4 > dccp_len) {\n\t\tmsg = \"nf_ct_dccp: truncated/malformed packet \";\n\t\tgoto out_invalid;\n\t}\n\n\tcscov = dccp_len;\n\tif (dh->dccph_cscov) {\n\t\tcscov = (dh->dccph_cscov - 1) * 4;\n\t\tif (cscov > dccp_len) {\n\t\t\tmsg = \"nf_ct_dccp: bad checksum coverage \";\n\t\t\tgoto out_invalid;\n\t\t}\n\t}\n\n\tif (net->ct.sysctl_checksum && hooknum == NF_INET_PRE_ROUTING &&\n\t    nf_checksum_partial(skb, hooknum, dataoff, cscov, IPPROTO_DCCP,\n\t\t\t\tpf)) {\n\t\tmsg = \"nf_ct_dccp: bad checksum \";\n\t\tgoto out_invalid;\n\t}\n\n\tif (dh->dccph_type >= DCCP_PKT_INVALID) {\n\t\tmsg = \"nf_ct_dccp: reserved packet type \";\n\t\tgoto out_invalid;\n\t}\n\n\treturn NF_ACCEPT;\n\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL, \"%s\", msg);\n\treturn -NF_ACCEPT;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141899,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int dccp_error(struct net *net, struct nf_conn *tmpl,\n\t\t      struct sk_buff *skb, unsigned int dataoff,\n\t\t      enum ip_conntrack_info *ctinfo,\n\t\t      u_int8_t pf, unsigned int hooknum)\n{\n\tstruct dccp_hdr _dh, *dh;\n\tunsigned int dccp_len = skb->len - dataoff;\n \tunsigned int cscov;\n \tconst char *msg;\n \n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);\n \tif (dh == NULL) {\n \t\tmsg = \"nf_ct_dccp: short packet \";\n \t\tgoto out_invalid;\n\t}\n\n\tif (dh->dccph_doff * 4 < sizeof(struct dccp_hdr) ||\n\t    dh->dccph_doff * 4 > dccp_len) {\n\t\tmsg = \"nf_ct_dccp: truncated/malformed packet \";\n\t\tgoto out_invalid;\n\t}\n\n\tcscov = dccp_len;\n\tif (dh->dccph_cscov) {\n\t\tcscov = (dh->dccph_cscov - 1) * 4;\n\t\tif (cscov > dccp_len) {\n\t\t\tmsg = \"nf_ct_dccp: bad checksum coverage \";\n\t\t\tgoto out_invalid;\n\t\t}\n\t}\n\n\tif (net->ct.sysctl_checksum && hooknum == NF_INET_PRE_ROUTING &&\n\t    nf_checksum_partial(skb, hooknum, dataoff, cscov, IPPROTO_DCCP,\n\t\t\t\tpf)) {\n\t\tmsg = \"nf_ct_dccp: bad checksum \";\n\t\tgoto out_invalid;\n\t}\n\n\tif (dh->dccph_type >= DCCP_PKT_INVALID) {\n\t\tmsg = \"nf_ct_dccp: reserved packet type \";\n\t\tgoto out_invalid;\n\t}\n\n\treturn NF_ACCEPT;\n\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL, \"%s\", msg);\n\treturn -NF_ACCEPT;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141900,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t     unsigned int dataoff, unsigned int *timeouts)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tstruct dccp_net *dn;\n\tstruct dccp_hdr _dh, *dh;\n \tconst char *msg;\n \tu_int8_t state;\n \n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n \tBUG_ON(dh == NULL);\n \n \tstate = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];\n\tswitch (state) {\n\tdefault:\n\t\tdn = dccp_pernet(net);\n\t\tif (dn->dccp_loose == 0) {\n\t\t\tmsg = \"nf_ct_dccp: not picking up existing connection \";\n\t\t\tgoto out_invalid;\n\t\t}\n\tcase CT_DCCP_REQUEST:\n\t\tbreak;\n\tcase CT_DCCP_INVALID:\n\t\tmsg = \"nf_ct_dccp: invalid state transition \";\n\t\tgoto out_invalid;\n\t}\n\n\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\n\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\n\tct->proto.dccp.state = CT_DCCP_NONE;\n\tct->proto.dccp.last_pkt = DCCP_PKT_REQUEST;\n\tct->proto.dccp.last_dir = IP_CT_DIR_ORIGINAL;\n\tct->proto.dccp.handshake_seq = 0;\n\treturn true;\n\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, nf_ct_l3num(ct), 0, skb, NULL, NULL,\n\t\t\t      NULL, \"%s\", msg);\n\treturn false;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141901,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t     unsigned int dataoff, unsigned int *timeouts)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tstruct dccp_net *dn;\n\tstruct dccp_hdr _dh, *dh;\n \tconst char *msg;\n \tu_int8_t state;\n \n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);\n \tBUG_ON(dh == NULL);\n \n \tstate = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];\n\tswitch (state) {\n\tdefault:\n\t\tdn = dccp_pernet(net);\n\t\tif (dn->dccp_loose == 0) {\n\t\t\tmsg = \"nf_ct_dccp: not picking up existing connection \";\n\t\t\tgoto out_invalid;\n\t\t}\n\tcase CT_DCCP_REQUEST:\n\t\tbreak;\n\tcase CT_DCCP_INVALID:\n\t\tmsg = \"nf_ct_dccp: invalid state transition \";\n\t\tgoto out_invalid;\n\t}\n\n\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\n\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\n\tct->proto.dccp.state = CT_DCCP_NONE;\n\tct->proto.dccp.last_pkt = DCCP_PKT_REQUEST;\n\tct->proto.dccp.last_dir = IP_CT_DIR_ORIGINAL;\n\tct->proto.dccp.handshake_seq = 0;\n\treturn true;\n\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, nf_ct_l3num(ct), 0, skb, NULL, NULL,\n\t\t\t      NULL, \"%s\", msg);\n\treturn false;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141902,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int dccp_packet(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t       unsigned int dataoff, enum ip_conntrack_info ctinfo,\n\t\t       u_int8_t pf, unsigned int hooknum,\n\t\t       unsigned int *timeouts)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\tstruct dccp_hdr _dh, *dh;\n \tu_int8_t type, old_state, new_state;\n \tenum ct_dccp_roles role;\n \n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n \tBUG_ON(dh == NULL);\n \ttype = dh->dccph_type;\n \n\tif (type == DCCP_PKT_RESET &&\n\t    !test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {\n\t\t/* Tear down connection immediately if only reply is a RESET */\n\t\tnf_ct_kill_acct(ct, ctinfo, skb);\n\t\treturn NF_ACCEPT;\n\t}\n\n\tspin_lock_bh(&ct->lock);\n\n\trole = ct->proto.dccp.role[dir];\n\told_state = ct->proto.dccp.state;\n\tnew_state = dccp_state_table[role][type][old_state];\n\n\tswitch (new_state) {\n\tcase CT_DCCP_REQUEST:\n\t\tif (old_state == CT_DCCP_TIMEWAIT &&\n\t\t    role == CT_DCCP_ROLE_SERVER) {\n\t\t\t/* Reincarnation in the reverse direction: reopen and\n\t\t\t * reverse client/server roles. */\n\t\t\tct->proto.dccp.role[dir] = CT_DCCP_ROLE_CLIENT;\n\t\t\tct->proto.dccp.role[!dir] = CT_DCCP_ROLE_SERVER;\n\t\t}\n\t\tbreak;\n\tcase CT_DCCP_RESPOND:\n\t\tif (old_state == CT_DCCP_REQUEST)\n\t\t\tct->proto.dccp.handshake_seq = dccp_hdr_seq(dh);\n\t\tbreak;\n\tcase CT_DCCP_PARTOPEN:\n\t\tif (old_state == CT_DCCP_RESPOND &&\n\t\t    type == DCCP_PKT_ACK &&\n\t\t    dccp_ack_seq(dh) == ct->proto.dccp.handshake_seq)\n\t\t\tset_bit(IPS_ASSURED_BIT, &ct->status);\n\t\tbreak;\n\tcase CT_DCCP_IGNORE:\n\t\t/*\n\t\t * Connection tracking might be out of sync, so we ignore\n\t\t * packets that might establish a new connection and resync\n\t\t * if the server responds with a valid Response.\n\t\t */\n\t\tif (ct->proto.dccp.last_dir == !dir &&\n\t\t    ct->proto.dccp.last_pkt == DCCP_PKT_REQUEST &&\n\t\t    type == DCCP_PKT_RESPONSE) {\n\t\t\tct->proto.dccp.role[!dir] = CT_DCCP_ROLE_CLIENT;\n\t\t\tct->proto.dccp.role[dir] = CT_DCCP_ROLE_SERVER;\n\t\t\tct->proto.dccp.handshake_seq = dccp_hdr_seq(dh);\n\t\t\tnew_state = CT_DCCP_RESPOND;\n\t\t\tbreak;\n\t\t}\n\t\tct->proto.dccp.last_dir = dir;\n\t\tct->proto.dccp.last_pkt = type;\n\n\t\tspin_unlock_bh(&ct->lock);\n\t\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL,\n\t\t\t\t      \"nf_ct_dccp: invalid packet ignored \");\n\t\treturn NF_ACCEPT;\n\tcase CT_DCCP_INVALID:\n\t\tspin_unlock_bh(&ct->lock);\n\t\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL,\n\t\t\t\t      \"nf_ct_dccp: invalid state transition \");\n\t\treturn -NF_ACCEPT;\n\t}\n\n\tct->proto.dccp.last_dir = dir;\n\tct->proto.dccp.last_pkt = type;\n\tct->proto.dccp.state = new_state;\n\tspin_unlock_bh(&ct->lock);\n\n\tif (new_state != old_state)\n\t\tnf_conntrack_event_cache(IPCT_PROTOINFO, ct);\n\n\tnf_ct_refresh_acct(ct, ctinfo, skb, timeouts[new_state]);\n\n\treturn NF_ACCEPT;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141903,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int dccp_packet(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t       unsigned int dataoff, enum ip_conntrack_info ctinfo,\n\t\t       u_int8_t pf, unsigned int hooknum,\n\t\t       unsigned int *timeouts)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\tstruct dccp_hdr _dh, *dh;\n \tu_int8_t type, old_state, new_state;\n \tenum ct_dccp_roles role;\n \n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);\n \tBUG_ON(dh == NULL);\n \ttype = dh->dccph_type;\n \n\tif (type == DCCP_PKT_RESET &&\n\t    !test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {\n\t\t/* Tear down connection immediately if only reply is a RESET */\n\t\tnf_ct_kill_acct(ct, ctinfo, skb);\n\t\treturn NF_ACCEPT;\n\t}\n\n\tspin_lock_bh(&ct->lock);\n\n\trole = ct->proto.dccp.role[dir];\n\told_state = ct->proto.dccp.state;\n\tnew_state = dccp_state_table[role][type][old_state];\n\n\tswitch (new_state) {\n\tcase CT_DCCP_REQUEST:\n\t\tif (old_state == CT_DCCP_TIMEWAIT &&\n\t\t    role == CT_DCCP_ROLE_SERVER) {\n\t\t\t/* Reincarnation in the reverse direction: reopen and\n\t\t\t * reverse client/server roles. */\n\t\t\tct->proto.dccp.role[dir] = CT_DCCP_ROLE_CLIENT;\n\t\t\tct->proto.dccp.role[!dir] = CT_DCCP_ROLE_SERVER;\n\t\t}\n\t\tbreak;\n\tcase CT_DCCP_RESPOND:\n\t\tif (old_state == CT_DCCP_REQUEST)\n\t\t\tct->proto.dccp.handshake_seq = dccp_hdr_seq(dh);\n\t\tbreak;\n\tcase CT_DCCP_PARTOPEN:\n\t\tif (old_state == CT_DCCP_RESPOND &&\n\t\t    type == DCCP_PKT_ACK &&\n\t\t    dccp_ack_seq(dh) == ct->proto.dccp.handshake_seq)\n\t\t\tset_bit(IPS_ASSURED_BIT, &ct->status);\n\t\tbreak;\n\tcase CT_DCCP_IGNORE:\n\t\t/*\n\t\t * Connection tracking might be out of sync, so we ignore\n\t\t * packets that might establish a new connection and resync\n\t\t * if the server responds with a valid Response.\n\t\t */\n\t\tif (ct->proto.dccp.last_dir == !dir &&\n\t\t    ct->proto.dccp.last_pkt == DCCP_PKT_REQUEST &&\n\t\t    type == DCCP_PKT_RESPONSE) {\n\t\t\tct->proto.dccp.role[!dir] = CT_DCCP_ROLE_CLIENT;\n\t\t\tct->proto.dccp.role[dir] = CT_DCCP_ROLE_SERVER;\n\t\t\tct->proto.dccp.handshake_seq = dccp_hdr_seq(dh);\n\t\t\tnew_state = CT_DCCP_RESPOND;\n\t\t\tbreak;\n\t\t}\n\t\tct->proto.dccp.last_dir = dir;\n\t\tct->proto.dccp.last_pkt = type;\n\n\t\tspin_unlock_bh(&ct->lock);\n\t\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL,\n\t\t\t\t      \"nf_ct_dccp: invalid packet ignored \");\n\t\treturn NF_ACCEPT;\n\tcase CT_DCCP_INVALID:\n\t\tspin_unlock_bh(&ct->lock);\n\t\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL,\n\t\t\t\t      \"nf_ct_dccp: invalid state transition \");\n\t\treturn -NF_ACCEPT;\n\t}\n\n\tct->proto.dccp.last_dir = dir;\n\tct->proto.dccp.last_pkt = type;\n\tct->proto.dccp.state = new_state;\n\tspin_unlock_bh(&ct->lock);\n\n\tif (new_state != old_state)\n\t\tnf_conntrack_event_cache(IPCT_PROTOINFO, ct);\n\n\tnf_ct_refresh_acct(ct, ctinfo, skb, timeouts[new_state]);\n\n\treturn NF_ACCEPT;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141904,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n {\n \tif (file->f_flags & O_DSYNC)\n \t\treturn 0;\n \tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n \t\treturn 1;\n\tif (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL ||\n\t\t\t(inode->i_flock->fl_start == 0 &&\n \t\t\tinode->i_flock->fl_end == OFFSET_MAX &&\n\t\t\tinode->i_flock->fl_type != F_RDLCK)))\n \t\treturn 1;\n \treturn 0;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141905,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n {\n \tif (file->f_flags & O_DSYNC)\n \t\treturn 0;\n\tif (!nfs_write_pageuptodate(page, inode))\n\t\treturn 0;\n \tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n \t\treturn 1;\n\tif (inode->i_flock == NULL || (inode->i_flock->fl_start == 0 &&\n \t\t\tinode->i_flock->fl_end == OFFSET_MAX &&\n\t\t\tinode->i_flock->fl_type != F_RDLCK))\n \t\treturn 1;\n \treturn 0;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141906,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static __always_inline int __do_follow_link(struct path *path, struct nameidata *nd)\n{\n\tint error;\n\tvoid *cookie;\n\tstruct dentry *dentry = path->dentry;\n\n\ttouch_atime(path->mnt, dentry);\n\tnd_set_link(nd, NULL);\n\n\tif (path->mnt != nd->path.mnt) {\n\t\tpath_to_nameidata(path, nd);\n \t\tdget(dentry);\n \t}\n \tmntget(path->mnt);\n \tcookie = dentry->d_inode->i_op->follow_link(dentry, nd);\n \terror = PTR_ERR(cookie);\n \tif (!IS_ERR(cookie)) {\n\t\tchar *s = nd_get_link(nd);\n\t\terror = 0;\n\t\tif (s)\n\t\t\terror = __vfs_follow_link(nd, s);\n\t\telse if (nd->last_type == LAST_BIND) {\n\t\t\terror = force_reval_path(&nd->path, nd);\n\t\t\tif (error)\n\t\t\t\tpath_put(&nd->path);\n\t\t}\n\t\tif (dentry->d_inode->i_op->put_link)\n\t\t\tdentry->d_inode->i_op->put_link(dentry, nd, cookie);\n\t}\n\treturn error;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141913,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static __always_inline int __do_follow_link(struct path *path, struct nameidata *nd)\n{\n\tint error;\n\tvoid *cookie;\n\tstruct dentry *dentry = path->dentry;\n\n\ttouch_atime(path->mnt, dentry);\n\tnd_set_link(nd, NULL);\n\n\tif (path->mnt != nd->path.mnt) {\n\t\tpath_to_nameidata(path, nd);\n \t\tdget(dentry);\n \t}\n \tmntget(path->mnt);\n\tnd->last_type = LAST_BIND;\n \tcookie = dentry->d_inode->i_op->follow_link(dentry, nd);\n \terror = PTR_ERR(cookie);\n \tif (!IS_ERR(cookie)) {\n\t\tchar *s = nd_get_link(nd);\n\t\terror = 0;\n\t\tif (s)\n\t\t\terror = __vfs_follow_link(nd, s);\n\t\telse if (nd->last_type == LAST_BIND) {\n\t\t\terror = force_reval_path(&nd->path, nd);\n\t\t\tif (error)\n\t\t\t\tpath_put(&nd->path);\n\t\t}\n\t\tif (dentry->d_inode->i_op->put_link)\n\t\t\tdentry->d_inode->i_op->put_link(dentry, nd, cookie);\n\t}\n\treturn error;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141914,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void handle_rx(struct vhost_net *net)\n{\n\tstruct vhost_net_virtqueue *nvq = &net->vqs[VHOST_NET_VQ_RX];\n\tstruct vhost_virtqueue *vq = &nvq->vq;\n\tunsigned uninitialized_var(in), log;\n\tstruct vhost_log *vq_log;\n\tstruct msghdr msg = {\n\t\t.msg_name = NULL,\n\t\t.msg_namelen = 0,\n\t\t.msg_control = NULL, /* FIXME: get and handle RX aux data. */\n\t\t.msg_controllen = 0,\n\t\t.msg_iov = vq->iov,\n\t\t.msg_flags = MSG_DONTWAIT,\n\t};\n\tstruct virtio_net_hdr_mrg_rxbuf hdr = {\n\t\t.hdr.flags = 0,\n\t\t.hdr.gso_type = VIRTIO_NET_HDR_GSO_NONE\n\t};\n\tsize_t total_len = 0;\n\tint err, mergeable;\n\ts16 headcount;\n\tsize_t vhost_hlen, sock_hlen;\n\tsize_t vhost_len, sock_len;\n\tstruct socket *sock;\n\n\tmutex_lock(&vq->mutex);\n\tsock = vq->private_data;\n\tif (!sock)\n\t\tgoto out;\n\tvhost_disable_notify(&net->dev, vq);\n\n\tvhost_hlen = nvq->vhost_hlen;\n\tsock_hlen = nvq->sock_hlen;\n\n\tvq_log = unlikely(vhost_has_feature(&net->dev, VHOST_F_LOG_ALL)) ?\n\t\tvq->log : NULL;\n\tmergeable = vhost_has_feature(&net->dev, VIRTIO_NET_F_MRG_RXBUF);\n\n\twhile ((sock_len = peek_head_len(sock->sk))) {\n\t\tsock_len += sock_hlen;\n\t\tvhost_len = sock_len + vhost_hlen;\n\t\theadcount = get_rx_bufs(vq, vq->heads, vhost_len,\n\t\t\t\t\t&in, vq_log, &log,\n\t\t\t\t\tlikely(mergeable) ? UIO_MAXIOV : 1);\n \t\t/* On error, stop handling until the next kick. */\n \t\tif (unlikely(headcount < 0))\n \t\t\tbreak;\n \t\t/* OK, now we need to know about added descriptors. */\n \t\tif (!headcount) {\n \t\t\tif (unlikely(vhost_enable_notify(&net->dev, vq))) {\n\t\t\t\t/* They have slipped one in as we were\n\t\t\t\t * doing that: check again. */\n\t\t\t\tvhost_disable_notify(&net->dev, vq);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Nothing new?  Wait for eventfd to tell us\n\t\t\t * they refilled. */\n\t\t\tbreak;\n\t\t}\n\t\t/* We don't need to be notified again. */\n\t\tif (unlikely((vhost_hlen)))\n\t\t\t/* Skip header. TODO: support TSO. */\n\t\t\tmove_iovec_hdr(vq->iov, nvq->hdr, vhost_hlen, in);\n\t\telse\n\t\t\t/* Copy the header for use in VIRTIO_NET_F_MRG_RXBUF:\n\t\t\t * needed because recvmsg can modify msg_iov. */\n\t\t\tcopy_iovec_hdr(vq->iov, nvq->hdr, sock_hlen, in);\n\t\tmsg.msg_iovlen = in;\n\t\terr = sock->ops->recvmsg(NULL, sock, &msg,\n\t\t\t\t\t sock_len, MSG_DONTWAIT | MSG_TRUNC);\n\t\t/* Userspace might have consumed the packet meanwhile:\n\t\t * it's not supposed to do this usually, but might be hard\n\t\t * to prevent. Discard data we got (if any) and keep going. */\n\t\tif (unlikely(err != sock_len)) {\n\t\t\tpr_debug(\"Discarded rx packet: \"\n\t\t\t\t \" len %d, expected %zd\\n\", err, sock_len);\n\t\t\tvhost_discard_vq_desc(vq, headcount);\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(vhost_hlen) &&\n\t\t    memcpy_toiovecend(nvq->hdr, (unsigned char *)&hdr, 0,\n\t\t\t\t      vhost_hlen)) {\n\t\t\tvq_err(vq, \"Unable to write vnet_hdr at addr %p\\n\",\n\t\t\t       vq->iov->iov_base);\n\t\t\tbreak;\n\t\t}\n\t\t/* TODO: Should check and handle checksum. */\n\t\tif (likely(mergeable) &&\n\t\t    memcpy_toiovecend(nvq->hdr, (unsigned char *)&headcount,\n\t\t\t\t      offsetof(typeof(hdr), num_buffers),\n\t\t\t\t      sizeof hdr.num_buffers)) {\n\t\t\tvq_err(vq, \"Failed num_buffers write\");\n\t\t\tvhost_discard_vq_desc(vq, headcount);\n\t\t\tbreak;\n\t\t}\n\t\tvhost_add_used_and_signal_n(&net->dev, vq, vq->heads,\n\t\t\t\t\t    headcount);\n\t\tif (unlikely(vq_log))\n\t\t\tvhost_log_write(vq, vq_log, log, vhost_len);\n\t\ttotal_len += vhost_len;\n\t\tif (unlikely(total_len >= VHOST_NET_WEIGHT)) {\n\t\t\tvhost_poll_queue(&vq->poll);\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&vq->mutex);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141915,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void handle_rx(struct vhost_net *net)\n{\n\tstruct vhost_net_virtqueue *nvq = &net->vqs[VHOST_NET_VQ_RX];\n\tstruct vhost_virtqueue *vq = &nvq->vq;\n\tunsigned uninitialized_var(in), log;\n\tstruct vhost_log *vq_log;\n\tstruct msghdr msg = {\n\t\t.msg_name = NULL,\n\t\t.msg_namelen = 0,\n\t\t.msg_control = NULL, /* FIXME: get and handle RX aux data. */\n\t\t.msg_controllen = 0,\n\t\t.msg_iov = vq->iov,\n\t\t.msg_flags = MSG_DONTWAIT,\n\t};\n\tstruct virtio_net_hdr_mrg_rxbuf hdr = {\n\t\t.hdr.flags = 0,\n\t\t.hdr.gso_type = VIRTIO_NET_HDR_GSO_NONE\n\t};\n\tsize_t total_len = 0;\n\tint err, mergeable;\n\ts16 headcount;\n\tsize_t vhost_hlen, sock_hlen;\n\tsize_t vhost_len, sock_len;\n\tstruct socket *sock;\n\n\tmutex_lock(&vq->mutex);\n\tsock = vq->private_data;\n\tif (!sock)\n\t\tgoto out;\n\tvhost_disable_notify(&net->dev, vq);\n\n\tvhost_hlen = nvq->vhost_hlen;\n\tsock_hlen = nvq->sock_hlen;\n\n\tvq_log = unlikely(vhost_has_feature(&net->dev, VHOST_F_LOG_ALL)) ?\n\t\tvq->log : NULL;\n\tmergeable = vhost_has_feature(&net->dev, VIRTIO_NET_F_MRG_RXBUF);\n\n\twhile ((sock_len = peek_head_len(sock->sk))) {\n\t\tsock_len += sock_hlen;\n\t\tvhost_len = sock_len + vhost_hlen;\n\t\theadcount = get_rx_bufs(vq, vq->heads, vhost_len,\n\t\t\t\t\t&in, vq_log, &log,\n\t\t\t\t\tlikely(mergeable) ? UIO_MAXIOV : 1);\n \t\t/* On error, stop handling until the next kick. */\n \t\tif (unlikely(headcount < 0))\n \t\t\tbreak;\n\t\t/* On overrun, truncate and discard */\n\t\tif (unlikely(headcount > UIO_MAXIOV)) {\n\t\t\tmsg.msg_iovlen = 1;\n\t\t\terr = sock->ops->recvmsg(NULL, sock, &msg,\n\t\t\t\t\t\t 1, MSG_DONTWAIT | MSG_TRUNC);\n\t\t\tpr_debug(\"Discarded rx packet: len %zd\\n\", sock_len);\n\t\t\tcontinue;\n\t\t}\n \t\t/* OK, now we need to know about added descriptors. */\n \t\tif (!headcount) {\n \t\t\tif (unlikely(vhost_enable_notify(&net->dev, vq))) {\n\t\t\t\t/* They have slipped one in as we were\n\t\t\t\t * doing that: check again. */\n\t\t\t\tvhost_disable_notify(&net->dev, vq);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Nothing new?  Wait for eventfd to tell us\n\t\t\t * they refilled. */\n\t\t\tbreak;\n\t\t}\n\t\t/* We don't need to be notified again. */\n\t\tif (unlikely((vhost_hlen)))\n\t\t\t/* Skip header. TODO: support TSO. */\n\t\t\tmove_iovec_hdr(vq->iov, nvq->hdr, vhost_hlen, in);\n\t\telse\n\t\t\t/* Copy the header for use in VIRTIO_NET_F_MRG_RXBUF:\n\t\t\t * needed because recvmsg can modify msg_iov. */\n\t\t\tcopy_iovec_hdr(vq->iov, nvq->hdr, sock_hlen, in);\n\t\tmsg.msg_iovlen = in;\n\t\terr = sock->ops->recvmsg(NULL, sock, &msg,\n\t\t\t\t\t sock_len, MSG_DONTWAIT | MSG_TRUNC);\n\t\t/* Userspace might have consumed the packet meanwhile:\n\t\t * it's not supposed to do this usually, but might be hard\n\t\t * to prevent. Discard data we got (if any) and keep going. */\n\t\tif (unlikely(err != sock_len)) {\n\t\t\tpr_debug(\"Discarded rx packet: \"\n\t\t\t\t \" len %d, expected %zd\\n\", err, sock_len);\n\t\t\tvhost_discard_vq_desc(vq, headcount);\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(vhost_hlen) &&\n\t\t    memcpy_toiovecend(nvq->hdr, (unsigned char *)&hdr, 0,\n\t\t\t\t      vhost_hlen)) {\n\t\t\tvq_err(vq, \"Unable to write vnet_hdr at addr %p\\n\",\n\t\t\t       vq->iov->iov_base);\n\t\t\tbreak;\n\t\t}\n\t\t/* TODO: Should check and handle checksum. */\n\t\tif (likely(mergeable) &&\n\t\t    memcpy_toiovecend(nvq->hdr, (unsigned char *)&headcount,\n\t\t\t\t      offsetof(typeof(hdr), num_buffers),\n\t\t\t\t      sizeof hdr.num_buffers)) {\n\t\t\tvq_err(vq, \"Failed num_buffers write\");\n\t\t\tvhost_discard_vq_desc(vq, headcount);\n\t\t\tbreak;\n\t\t}\n\t\tvhost_add_used_and_signal_n(&net->dev, vq, vq->heads,\n\t\t\t\t\t    headcount);\n\t\tif (unlikely(vq_log))\n\t\t\tvhost_log_write(vq, vq_log, log, vhost_len);\n\t\ttotal_len += vhost_len;\n\t\tif (unlikely(total_len >= VHOST_NET_WEIGHT)) {\n\t\t\tvhost_poll_queue(&vq->poll);\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&vq->mutex);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141916,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int get_rx_bufs(struct vhost_virtqueue *vq,\n\t\t       struct vring_used_elem *heads,\n\t\t       int datalen,\n\t\t       unsigned *iovcount,\n\t\t       struct vhost_log *log,\n\t\t       unsigned *log_num,\n\t\t       unsigned int quota)\n{\n\tunsigned int out, in;\n\tint seg = 0;\n\tint headcount = 0;\n\tunsigned d;\n\tint r, nlogs = 0;\n\n\twhile (datalen > 0 && headcount < quota) {\n\t\tif (unlikely(seg >= UIO_MAXIOV)) {\n\t\t\tr = -ENOBUFS;\n\t\t\tgoto err;\n\t\t}\n\t\td = vhost_get_vq_desc(vq->dev, vq, vq->iov + seg,\n\t\t\t\t      ARRAY_SIZE(vq->iov) - seg, &out,\n\t\t\t\t      &in, log, log_num);\n\t\tif (d == vq->num) {\n\t\t\tr = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tif (unlikely(out || in <= 0)) {\n\t\t\tvq_err(vq, \"unexpected descriptor format for RX: \"\n\t\t\t\t\"out %d, in %d\\n\", out, in);\n\t\t\tr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tif (unlikely(log)) {\n\t\t\tnlogs += *log_num;\n\t\t\tlog += *log_num;\n\t\t}\n\t\theads[headcount].id = d;\n\t\theads[headcount].len = iov_length(vq->iov + seg, in);\n\t\tdatalen -= heads[headcount].len;\n\t\t++headcount;\n\t\tseg += in;\n\t}\n\theads[headcount - 1].len += datalen;\n \t*iovcount = seg;\n \tif (unlikely(log))\n \t\t*log_num = nlogs;\n \treturn headcount;\n err:\n \tvhost_discard_vq_desc(vq, headcount);\n\treturn r;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141917,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int get_rx_bufs(struct vhost_virtqueue *vq,\n\t\t       struct vring_used_elem *heads,\n\t\t       int datalen,\n\t\t       unsigned *iovcount,\n\t\t       struct vhost_log *log,\n\t\t       unsigned *log_num,\n\t\t       unsigned int quota)\n{\n\tunsigned int out, in;\n\tint seg = 0;\n\tint headcount = 0;\n\tunsigned d;\n\tint r, nlogs = 0;\n\n\twhile (datalen > 0 && headcount < quota) {\n\t\tif (unlikely(seg >= UIO_MAXIOV)) {\n\t\t\tr = -ENOBUFS;\n\t\t\tgoto err;\n\t\t}\n\t\td = vhost_get_vq_desc(vq->dev, vq, vq->iov + seg,\n\t\t\t\t      ARRAY_SIZE(vq->iov) - seg, &out,\n\t\t\t\t      &in, log, log_num);\n\t\tif (d == vq->num) {\n\t\t\tr = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tif (unlikely(out || in <= 0)) {\n\t\t\tvq_err(vq, \"unexpected descriptor format for RX: \"\n\t\t\t\t\"out %d, in %d\\n\", out, in);\n\t\t\tr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tif (unlikely(log)) {\n\t\t\tnlogs += *log_num;\n\t\t\tlog += *log_num;\n\t\t}\n\t\theads[headcount].id = d;\n\t\theads[headcount].len = iov_length(vq->iov + seg, in);\n\t\tdatalen -= heads[headcount].len;\n\t\t++headcount;\n\t\tseg += in;\n\t}\n\theads[headcount - 1].len += datalen;\n \t*iovcount = seg;\n \tif (unlikely(log))\n \t\t*log_num = nlogs;\n\n\t/* Detect overrun */\n\tif (unlikely(datalen > 0)) {\n\t\tr = UIO_MAXIOV + 1;\n\t\tgoto err;\n\t}\n \treturn headcount;\n err:\n \tvhost_discard_vq_desc(vq, headcount);\n\treturn r;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141918,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\n \tif (flags & MSG_CMSG_COMPAT)\n \t\treturn -EINVAL;\n \n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n\t\t\t\t      (struct timespec *) timeout);\n \tif (timeout == NULL)\n \t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n \t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n \n\tif (get_compat_timespec(&ktspec, timeout))\n \t\treturn -EFAULT;\n \n \tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n \t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n \t\tdatagrams = -EFAULT;\n \n \treturn datagrams;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141921,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\n \tif (flags & MSG_CMSG_COMPAT)\n \t\treturn -EINVAL;\n \n \tif (timeout == NULL)\n \t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n \t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n \n\tif (compat_get_timespec(&ktspec, timeout))\n \t\treturn -EFAULT;\n \n \tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n \t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && compat_put_timespec(&ktspec, timeout))\n \t\tdatagrams = -EFAULT;\n \n \treturn datagrams;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141922,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t   struct msghdr *msg, size_t len, int flags)\n {\n \tstruct sk_buff\t\t*skb;\n \tstruct sock\t\t*sk = sock->sk;\n\tstruct sockaddr_mISDN\t*maddr;\n \n \tint\t\tcopied, err;\n \n\tif (*debug & DEBUG_SOCKET)\n\t\tprintk(KERN_DEBUG \"%s: len %d, flags %x ch.nr %d, proto %x\\n\",\n\t\t       __func__, (int)len, flags, _pms(sk)->ch.nr,\n\t\t       sk->sk_protocol);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\tif (sk->sk_state == MISDN_CLOSED)\n\t\treturn 0;\n\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n \tif (!skb)\n \t\treturn err;\n \n\tif (msg->msg_namelen >= sizeof(struct sockaddr_mISDN)) {\n\t\tmsg->msg_namelen = sizeof(struct sockaddr_mISDN);\n\t\tmaddr = (struct sockaddr_mISDN *)msg->msg_name;\n \t\tmaddr->family = AF_ISDN;\n \t\tmaddr->dev = _pms(sk)->dev->id;\n \t\tif ((sk->sk_protocol == ISDN_P_LAPD_TE) ||\n\t\t    (sk->sk_protocol == ISDN_P_LAPD_NT)) {\n\t\t\tmaddr->channel = (mISDN_HEAD_ID(skb) >> 16) & 0xff;\n\t\t\tmaddr->tei =  (mISDN_HEAD_ID(skb) >> 8) & 0xff;\n\t\t\tmaddr->sapi = mISDN_HEAD_ID(skb) & 0xff;\n\t\t} else {\n\t\t\tmaddr->channel = _pms(sk)->ch.nr;\n \t\t\tmaddr->sapi = _pms(sk)->ch.addr & 0xFF;\n \t\t\tmaddr->tei =  (_pms(sk)->ch.addr >> 8) & 0xFF;\n \t\t}\n\t} else {\n\t\tif (msg->msg_namelen)\n\t\t\tprintk(KERN_WARNING \"%s: too small namelen %d\\n\",\n\t\t\t       __func__, msg->msg_namelen);\n\t\tmsg->msg_namelen = 0;\n \t}\n \n \tcopied = skb->len + MISDN_HEADER_LEN;\n\tif (len < copied) {\n\t\tif (flags & MSG_PEEK)\n\t\t\tatomic_dec(&skb->users);\n\t\telse\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\treturn -ENOSPC;\n\t}\n\tmemcpy(skb_push(skb, MISDN_HEADER_LEN), mISDN_HEAD_P(skb),\n\t       MISDN_HEADER_LEN);\n\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\n\tmISDN_sock_cmsg(sk, msg, skb);\n\n\tskb_free_datagram(sk, skb);\n\n\treturn err ? : copied;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141929,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t   struct msghdr *msg, size_t len, int flags)\n {\n \tstruct sk_buff\t\t*skb;\n \tstruct sock\t\t*sk = sock->sk;\n \n \tint\t\tcopied, err;\n \n\tif (*debug & DEBUG_SOCKET)\n\t\tprintk(KERN_DEBUG \"%s: len %d, flags %x ch.nr %d, proto %x\\n\",\n\t\t       __func__, (int)len, flags, _pms(sk)->ch.nr,\n\t\t       sk->sk_protocol);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\tif (sk->sk_state == MISDN_CLOSED)\n\t\treturn 0;\n\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n \tif (!skb)\n \t\treturn err;\n \n\tif (msg->msg_name) {\n\t\tstruct sockaddr_mISDN *maddr = msg->msg_name;\n\n \t\tmaddr->family = AF_ISDN;\n \t\tmaddr->dev = _pms(sk)->dev->id;\n \t\tif ((sk->sk_protocol == ISDN_P_LAPD_TE) ||\n\t\t    (sk->sk_protocol == ISDN_P_LAPD_NT)) {\n\t\t\tmaddr->channel = (mISDN_HEAD_ID(skb) >> 16) & 0xff;\n\t\t\tmaddr->tei =  (mISDN_HEAD_ID(skb) >> 8) & 0xff;\n\t\t\tmaddr->sapi = mISDN_HEAD_ID(skb) & 0xff;\n\t\t} else {\n\t\t\tmaddr->channel = _pms(sk)->ch.nr;\n \t\t\tmaddr->sapi = _pms(sk)->ch.addr & 0xFF;\n \t\t\tmaddr->tei =  (_pms(sk)->ch.addr >> 8) & 0xFF;\n \t\t}\n\t\tmsg->msg_namelen = sizeof(*maddr);\n \t}\n \n \tcopied = skb->len + MISDN_HEADER_LEN;\n\tif (len < copied) {\n\t\tif (flags & MSG_PEEK)\n\t\t\tatomic_dec(&skb->users);\n\t\telse\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\treturn -ENOSPC;\n\t}\n\tmemcpy(skb_push(skb, MISDN_HEADER_LEN), mISDN_HEAD_P(skb),\n\t       MISDN_HEADER_LEN);\n\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\n\tmISDN_sock_cmsg(sk, msg, skb);\n\n\tskb_free_datagram(sk, skb);\n\n\treturn err ? : copied;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141930,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n \t\t\t size_t size, int flags)\n {\n \tstruct sock *sk = sock->sk;\n\tstruct sockaddr_at *sat = (struct sockaddr_at *)msg->msg_name;\n \tstruct ddpehdr *ddp;\n \tint copied = 0;\n \tint offset = 0;\n\tint err = 0;\n\tstruct sk_buff *skb;\n\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tlock_sock(sk);\n\n\tif (!skb)\n\t\tgoto out;\n\n\t/* FIXME: use skb->cb to be able to use shared skbs */\n\tddp = ddp_hdr(skb);\n\tcopied = ntohs(ddp->deh_len_hops) & 1023;\n\n\tif (sk->sk_type != SOCK_RAW) {\n\t\toffset = sizeof(*ddp);\n\t\tcopied -= offset;\n\t}\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n \t}\n \terr = skb_copy_datagram_iovec(skb, offset, msg->msg_iov, copied);\n \n\tif (!err) {\n\t\tif (sat) {\n\t\t\tsat->sat_family      = AF_APPLETALK;\n\t\t\tsat->sat_port        = ddp->deh_sport;\n\t\t\tsat->sat_addr.s_node = ddp->deh_snode;\n\t\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n\t\t}\n\t\tmsg->msg_namelen = sizeof(*sat);\n \t}\n \n \tskb_free_datagram(sk, skb);\t/* Free the datagram. */\n\nout:\n\trelease_sock(sk);\n\treturn err ? : copied;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141931,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n \t\t\t size_t size, int flags)\n {\n \tstruct sock *sk = sock->sk;\n \tstruct ddpehdr *ddp;\n \tint copied = 0;\n \tint offset = 0;\n\tint err = 0;\n\tstruct sk_buff *skb;\n\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tlock_sock(sk);\n\n\tif (!skb)\n\t\tgoto out;\n\n\t/* FIXME: use skb->cb to be able to use shared skbs */\n\tddp = ddp_hdr(skb);\n\tcopied = ntohs(ddp->deh_len_hops) & 1023;\n\n\tif (sk->sk_type != SOCK_RAW) {\n\t\toffset = sizeof(*ddp);\n\t\tcopied -= offset;\n\t}\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n \t}\n \terr = skb_copy_datagram_iovec(skb, offset, msg->msg_iov, copied);\n \n\tif (!err && msg->msg_name) {\n\t\tstruct sockaddr_at *sat = msg->msg_name;\n\t\tsat->sat_family      = AF_APPLETALK;\n\t\tsat->sat_port        = ddp->deh_sport;\n\t\tsat->sat_addr.s_node = ddp->deh_snode;\n\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n\t\tmsg->msg_namelen     = sizeof(*sat);\n \t}\n \n \tskb_free_datagram(sk, skb);\t/* Free the datagram. */\n\nout:\n\trelease_sock(sk);\n\treturn err ? : copied;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141932,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int ipx_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct ipx_sock *ipxs = ipx_sk(sk);\n\tstruct sockaddr_ipx *sipx = (struct sockaddr_ipx *)msg->msg_name;\n\tstruct ipxhdr *ipx = NULL;\n\tstruct sk_buff *skb;\n\tint copied, rc;\n\n\tlock_sock(sk);\n\t/* put the autobinding in */\n\tif (!ipxs->port) {\n\t\tstruct sockaddr_ipx uaddr;\n\n\t\tuaddr.sipx_port\t\t= 0;\n\t\tuaddr.sipx_network \t= 0;\n\n#ifdef CONFIG_IPX_INTERN\n\t\trc = -ENETDOWN;\n\t\tif (!ipxs->intrfc)\n\t\t\tgoto out; /* Someone zonked the iface */\n\t\tmemcpy(uaddr.sipx_node, ipxs->intrfc->if_node, IPX_NODE_LEN);\n#endif\t/* CONFIG_IPX_INTERN */\n\n\t\trc = __ipx_bind(sock, (struct sockaddr *)&uaddr,\n\t\t\t      sizeof(struct sockaddr_ipx));\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = -ENOTCONN;\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\tif (!skb)\n\t\tgoto out;\n\n\tipx \t= ipx_hdr(skb);\n\tcopied \t= ntohs(ipx->ipx_pktsize) - sizeof(struct ipxhdr);\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\trc = skb_copy_datagram_iovec(skb, sizeof(struct ipxhdr), msg->msg_iov,\n\t\t\t\t     copied);\n\tif (rc)\n\t\tgoto out_free;\n \tif (skb->tstamp.tv64)\n \t\tsk->sk_stamp = skb->tstamp;\n \n\tmsg->msg_namelen = sizeof(*sipx);\n \tif (sipx) {\n \t\tsipx->sipx_family\t= AF_IPX;\n \t\tsipx->sipx_port\t\t= ipx->ipx_source.sock;\n \t\tmemcpy(sipx->sipx_node, ipx->ipx_source.node, IPX_NODE_LEN);\n \t\tsipx->sipx_network\t= IPX_SKB_CB(skb)->ipx_source_net;\n \t\tsipx->sipx_type \t= ipx->ipx_type;\n \t\tsipx->sipx_zero\t\t= 0;\n \t}\n \trc = copied;\n \nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141933,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int ipx_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct ipx_sock *ipxs = ipx_sk(sk);\n\tstruct sockaddr_ipx *sipx = (struct sockaddr_ipx *)msg->msg_name;\n\tstruct ipxhdr *ipx = NULL;\n\tstruct sk_buff *skb;\n\tint copied, rc;\n\n\tlock_sock(sk);\n\t/* put the autobinding in */\n\tif (!ipxs->port) {\n\t\tstruct sockaddr_ipx uaddr;\n\n\t\tuaddr.sipx_port\t\t= 0;\n\t\tuaddr.sipx_network \t= 0;\n\n#ifdef CONFIG_IPX_INTERN\n\t\trc = -ENETDOWN;\n\t\tif (!ipxs->intrfc)\n\t\t\tgoto out; /* Someone zonked the iface */\n\t\tmemcpy(uaddr.sipx_node, ipxs->intrfc->if_node, IPX_NODE_LEN);\n#endif\t/* CONFIG_IPX_INTERN */\n\n\t\trc = __ipx_bind(sock, (struct sockaddr *)&uaddr,\n\t\t\t      sizeof(struct sockaddr_ipx));\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = -ENOTCONN;\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\tif (!skb)\n\t\tgoto out;\n\n\tipx \t= ipx_hdr(skb);\n\tcopied \t= ntohs(ipx->ipx_pktsize) - sizeof(struct ipxhdr);\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\trc = skb_copy_datagram_iovec(skb, sizeof(struct ipxhdr), msg->msg_iov,\n\t\t\t\t     copied);\n\tif (rc)\n\t\tgoto out_free;\n \tif (skb->tstamp.tv64)\n \t\tsk->sk_stamp = skb->tstamp;\n \n \tif (sipx) {\n \t\tsipx->sipx_family\t= AF_IPX;\n \t\tsipx->sipx_port\t\t= ipx->ipx_source.sock;\n \t\tmemcpy(sipx->sipx_node, ipx->ipx_source.node, IPX_NODE_LEN);\n \t\tsipx->sipx_network\t= IPX_SKB_CB(skb)->ipx_source_net;\n \t\tsipx->sipx_type \t= ipx->ipx_type;\n \t\tsipx->sipx_zero\t\t= 0;\n\t\tmsg->msg_namelen\t= sizeof(*sipx);\n \t}\n \trc = copied;\n \nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141934,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\tsize_t copied;\n\tstruct sk_buff *skb;\n\tint er;\n\n\t/*\n\t * This works for seqpacket too. The receiver has ordered the queue for\n\t * us! We do one quick check first though\n\t */\n\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\n\t/* Now we can treat all alike */\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\ter = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (er < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\n\tif (sax != NULL) {\n\t\tmemset(sax, 0, sizeof(*sax));\n \t\tsax->sax25_family = AF_NETROM;\n \t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n \t\t\t      AX25_ADDR_LEN);\n \t}\n \n\tmsg->msg_namelen = sizeof(*sax);\n \tskb_free_datagram(sk, skb);\n \n \trelease_sock(sk);\n\treturn copied;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141935,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\tsize_t copied;\n\tstruct sk_buff *skb;\n\tint er;\n\n\t/*\n\t * This works for seqpacket too. The receiver has ordered the queue for\n\t * us! We do one quick check first though\n\t */\n\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\n\t/* Now we can treat all alike */\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\ter = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (er < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\n\tif (sax != NULL) {\n\t\tmemset(sax, 0, sizeof(*sax));\n \t\tsax->sax25_family = AF_NETROM;\n \t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n \t\t\t      AX25_ADDR_LEN);\n\t\tmsg->msg_namelen = sizeof(*sax);\n \t}\n \n \tskb_free_datagram(sk, skb);\n \n \trelease_sock(sk);\n\treturn copied;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141936,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t  struct msghdr *msg, size_t len, int flags)\n{\n \tstruct sock *sk = sock->sk;\n \tstruct sk_buff *skb;\n \tint copied, err;\n\tstruct sockaddr_ll *sll;\n \tint vnet_hdr_len = 0;\n \n \terr = -EINVAL;\n\tif (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT|MSG_ERRQUEUE))\n\t\tgoto out;\n\n#if 0\n\t/* What error should we return now? EUNATTACH? */\n\tif (pkt_sk(sk)->ifindex < 0)\n\t\treturn -ENODEV;\n#endif\n\n\tif (flags & MSG_ERRQUEUE) {\n\t\terr = sock_recv_errqueue(sk, msg, len,\n\t\t\t\t\t SOL_PACKET, PACKET_TX_TIMESTAMP);\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\tCall the generic datagram receiver. This handles all sorts\n\t *\tof horrible races and re-entrancy so we can forget about it\n\t *\tin the protocol layers.\n\t *\n\t *\tNow it will return ENETDOWN, if device have just gone down,\n\t *\tbut then it will block.\n\t */\n\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n\n\t/*\n\t *\tAn error occurred so return it. Because skb_recv_datagram()\n\t *\thandles the blocking we don't see and worry about blocking\n\t *\tretries.\n\t */\n\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tif (pkt_sk(sk)->has_vnet_hdr) {\n\t\tstruct virtio_net_hdr vnet_hdr = { 0 };\n\n\t\terr = -EINVAL;\n\t\tvnet_hdr_len = sizeof(vnet_hdr);\n\t\tif (len < vnet_hdr_len)\n\t\t\tgoto out_free;\n\n\t\tlen -= vnet_hdr_len;\n\n\t\tif (skb_is_gso(skb)) {\n\t\t\tstruct skb_shared_info *sinfo = skb_shinfo(skb);\n\n\t\t\t/* This is a hint as to how much should be linear. */\n\t\t\tvnet_hdr.hdr_len = skb_headlen(skb);\n\t\t\tvnet_hdr.gso_size = sinfo->gso_size;\n\t\t\tif (sinfo->gso_type & SKB_GSO_TCPV4)\n\t\t\t\tvnet_hdr.gso_type = VIRTIO_NET_HDR_GSO_TCPV4;\n\t\t\telse if (sinfo->gso_type & SKB_GSO_TCPV6)\n\t\t\t\tvnet_hdr.gso_type = VIRTIO_NET_HDR_GSO_TCPV6;\n\t\t\telse if (sinfo->gso_type & SKB_GSO_UDP)\n\t\t\t\tvnet_hdr.gso_type = VIRTIO_NET_HDR_GSO_UDP;\n\t\t\telse if (sinfo->gso_type & SKB_GSO_FCOE)\n\t\t\t\tgoto out_free;\n\t\t\telse\n\t\t\t\tBUG();\n\t\t\tif (sinfo->gso_type & SKB_GSO_TCP_ECN)\n\t\t\t\tvnet_hdr.gso_type |= VIRTIO_NET_HDR_GSO_ECN;\n\t\t} else\n\t\t\tvnet_hdr.gso_type = VIRTIO_NET_HDR_GSO_NONE;\n\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\tvnet_hdr.flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;\n\t\t\tvnet_hdr.csum_start = skb_checksum_start_offset(skb);\n\t\t\tvnet_hdr.csum_offset = skb->csum_offset;\n\t\t} else if (skb->ip_summed == CHECKSUM_UNNECESSARY) {\n\t\t\tvnet_hdr.flags = VIRTIO_NET_HDR_F_DATA_VALID;\n\t\t} /* else everything is zero */\n\n\t\terr = memcpy_toiovec(msg->msg_iov, (void *)&vnet_hdr,\n\t\t\t\t     vnet_hdr_len);\n\t\tif (err < 0)\n \t\t\tgoto out_free;\n \t}\n \n\t/*\n\t *\tIf the address length field is there to be filled in, we fill\n\t *\tit in now.\n\t */\n\tsll = &PACKET_SKB_CB(skb)->sa.ll;\n\tif (sock->type == SOCK_PACKET)\n\t\tmsg->msg_namelen = sizeof(struct sockaddr_pkt);\n\telse\n\t\tmsg->msg_namelen = sll->sll_halen + offsetof(struct sockaddr_ll, sll_addr);\n\t/*\n\t *\tYou lose any data beyond the buffer you gave. If it worries a\n\t *\tuser program they can ask the device for its MTU anyway.\n \t */\n \tcopied = skb->len;\n \tif (copied > len) {\n \t\tcopied = len;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto out_free;\n \n \tsock_recv_ts_and_drops(msg, sk, skb);\n \n\tif (msg->msg_name)\n \t\tmemcpy(msg->msg_name, &PACKET_SKB_CB(skb)->sa,\n \t\t       msg->msg_namelen);\n \n \tif (pkt_sk(sk)->auxdata) {\n \t\tstruct tpacket_auxdata aux;\n\n\t\taux.tp_status = TP_STATUS_USER;\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\t\taux.tp_status |= TP_STATUS_CSUMNOTREADY;\n\t\taux.tp_len = PACKET_SKB_CB(skb)->origlen;\n\t\taux.tp_snaplen = skb->len;\n\t\taux.tp_mac = 0;\n\t\taux.tp_net = skb_network_offset(skb);\n\t\tif (vlan_tx_tag_present(skb)) {\n\t\t\taux.tp_vlan_tci = vlan_tx_tag_get(skb);\n\t\t\taux.tp_status |= TP_STATUS_VLAN_VALID;\n\t\t} else {\n\t\t\taux.tp_vlan_tci = 0;\n\t\t}\n\t\taux.tp_padding = 0;\n\t\tput_cmsg(msg, SOL_PACKET, PACKET_AUXDATA, sizeof(aux), &aux);\n\t}\n\n\t/*\n\t *\tFree or return the buffer as appropriate. Again this\n\t *\thides all the races and re-entrancy issues from us.\n\t */\n\terr = vnet_hdr_len + ((flags&MSG_TRUNC) ? skb->len : copied);\n\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141937,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t  struct msghdr *msg, size_t len, int flags)\n{\n \tstruct sock *sk = sock->sk;\n \tstruct sk_buff *skb;\n \tint copied, err;\n \tint vnet_hdr_len = 0;\n \n \terr = -EINVAL;\n\tif (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT|MSG_ERRQUEUE))\n\t\tgoto out;\n\n#if 0\n\t/* What error should we return now? EUNATTACH? */\n\tif (pkt_sk(sk)->ifindex < 0)\n\t\treturn -ENODEV;\n#endif\n\n\tif (flags & MSG_ERRQUEUE) {\n\t\terr = sock_recv_errqueue(sk, msg, len,\n\t\t\t\t\t SOL_PACKET, PACKET_TX_TIMESTAMP);\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\tCall the generic datagram receiver. This handles all sorts\n\t *\tof horrible races and re-entrancy so we can forget about it\n\t *\tin the protocol layers.\n\t *\n\t *\tNow it will return ENETDOWN, if device have just gone down,\n\t *\tbut then it will block.\n\t */\n\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n\n\t/*\n\t *\tAn error occurred so return it. Because skb_recv_datagram()\n\t *\thandles the blocking we don't see and worry about blocking\n\t *\tretries.\n\t */\n\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tif (pkt_sk(sk)->has_vnet_hdr) {\n\t\tstruct virtio_net_hdr vnet_hdr = { 0 };\n\n\t\terr = -EINVAL;\n\t\tvnet_hdr_len = sizeof(vnet_hdr);\n\t\tif (len < vnet_hdr_len)\n\t\t\tgoto out_free;\n\n\t\tlen -= vnet_hdr_len;\n\n\t\tif (skb_is_gso(skb)) {\n\t\t\tstruct skb_shared_info *sinfo = skb_shinfo(skb);\n\n\t\t\t/* This is a hint as to how much should be linear. */\n\t\t\tvnet_hdr.hdr_len = skb_headlen(skb);\n\t\t\tvnet_hdr.gso_size = sinfo->gso_size;\n\t\t\tif (sinfo->gso_type & SKB_GSO_TCPV4)\n\t\t\t\tvnet_hdr.gso_type = VIRTIO_NET_HDR_GSO_TCPV4;\n\t\t\telse if (sinfo->gso_type & SKB_GSO_TCPV6)\n\t\t\t\tvnet_hdr.gso_type = VIRTIO_NET_HDR_GSO_TCPV6;\n\t\t\telse if (sinfo->gso_type & SKB_GSO_UDP)\n\t\t\t\tvnet_hdr.gso_type = VIRTIO_NET_HDR_GSO_UDP;\n\t\t\telse if (sinfo->gso_type & SKB_GSO_FCOE)\n\t\t\t\tgoto out_free;\n\t\t\telse\n\t\t\t\tBUG();\n\t\t\tif (sinfo->gso_type & SKB_GSO_TCP_ECN)\n\t\t\t\tvnet_hdr.gso_type |= VIRTIO_NET_HDR_GSO_ECN;\n\t\t} else\n\t\t\tvnet_hdr.gso_type = VIRTIO_NET_HDR_GSO_NONE;\n\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\tvnet_hdr.flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;\n\t\t\tvnet_hdr.csum_start = skb_checksum_start_offset(skb);\n\t\t\tvnet_hdr.csum_offset = skb->csum_offset;\n\t\t} else if (skb->ip_summed == CHECKSUM_UNNECESSARY) {\n\t\t\tvnet_hdr.flags = VIRTIO_NET_HDR_F_DATA_VALID;\n\t\t} /* else everything is zero */\n\n\t\terr = memcpy_toiovec(msg->msg_iov, (void *)&vnet_hdr,\n\t\t\t\t     vnet_hdr_len);\n\t\tif (err < 0)\n \t\t\tgoto out_free;\n \t}\n \n\t/* You lose any data beyond the buffer you gave. If it worries\n\t * a user program they can ask the device for its MTU\n\t * anyway.\n \t */\n \tcopied = skb->len;\n \tif (copied > len) {\n \t\tcopied = len;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto out_free;\n \n \tsock_recv_ts_and_drops(msg, sk, skb);\n \n\tif (msg->msg_name) {\n\t\t/* If the address length field is there to be filled\n\t\t * in, we fill it in now.\n\t\t */\n\t\tif (sock->type == SOCK_PACKET) {\n\t\t\tmsg->msg_namelen = sizeof(struct sockaddr_pkt);\n\t\t} else {\n\t\t\tstruct sockaddr_ll *sll = &PACKET_SKB_CB(skb)->sa.ll;\n\t\t\tmsg->msg_namelen = sll->sll_halen +\n\t\t\t\toffsetof(struct sockaddr_ll, sll_addr);\n\t\t}\n \t\tmemcpy(msg->msg_name, &PACKET_SKB_CB(skb)->sa,\n \t\t       msg->msg_namelen);\n\t}\n \n \tif (pkt_sk(sk)->auxdata) {\n \t\tstruct tpacket_auxdata aux;\n\n\t\taux.tp_status = TP_STATUS_USER;\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\t\taux.tp_status |= TP_STATUS_CSUMNOTREADY;\n\t\taux.tp_len = PACKET_SKB_CB(skb)->origlen;\n\t\taux.tp_snaplen = skb->len;\n\t\taux.tp_mac = 0;\n\t\taux.tp_net = skb_network_offset(skb);\n\t\tif (vlan_tx_tag_present(skb)) {\n\t\t\taux.tp_vlan_tci = vlan_tx_tag_get(skb);\n\t\t\taux.tp_status |= TP_STATUS_VLAN_VALID;\n\t\t} else {\n\t\t\taux.tp_vlan_tci = 0;\n\t\t}\n\t\taux.tp_padding = 0;\n\t\tput_cmsg(msg, SOL_PACKET, PACKET_AUXDATA, sizeof(aux), &aux);\n\t}\n\n\t/*\n\t *\tFree or return the buffer as appropriate. Again this\n\t *\thides all the races and re-entrancy issues from us.\n\t */\n\terr = vnet_hdr_len + ((flags&MSG_TRUNC) ? skb->len : copied);\n\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141938,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int x25_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t       struct msghdr *msg, size_t size,\n\t\t       int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct sockaddr_x25 *sx25 = (struct sockaddr_x25 *)msg->msg_name;\n\tsize_t copied;\n\tint qbit, header_len;\n\tstruct sk_buff *skb;\n\tunsigned char *asmptr;\n\tint rc = -ENOTCONN;\n\n\tlock_sock(sk);\n\n\tif (x25->neighbour == NULL)\n\t\tgoto out;\n\n\theader_len = x25->neighbour->extended ?\n\t\tX25_EXT_MIN_LEN : X25_STD_MIN_LEN;\n\n\t/*\n\t * This works for seqpacket too. The receiver has ordered the queue for\n\t * us! We do one quick check first though\n\t */\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\tgoto out;\n\n\tif (flags & MSG_OOB) {\n\t\trc = -EINVAL;\n\t\tif (sock_flag(sk, SOCK_URGINLINE) ||\n\t\t    !skb_peek(&x25->interrupt_in_queue))\n\t\t\tgoto out;\n\n\t\tskb = skb_dequeue(&x25->interrupt_in_queue);\n\n\t\tif (!pskb_may_pull(skb, X25_STD_MIN_LEN))\n\t\t\tgoto out_free_dgram;\n\n\t\tskb_pull(skb, X25_STD_MIN_LEN);\n\n\t\t/*\n\t\t *\tNo Q bit information on Interrupt data.\n\t\t */\n\t\tif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\n\t\t\tasmptr  = skb_push(skb, 1);\n\t\t\t*asmptr = 0x00;\n\t\t}\n\n\t\tmsg->msg_flags |= MSG_OOB;\n\t} else {\n\t\t/* Now we can treat all alike */\n\t\trelease_sock(sk);\n\t\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\t\tlock_sock(sk);\n\t\tif (!skb)\n\t\t\tgoto out;\n\n\t\tif (!pskb_may_pull(skb, header_len))\n\t\t\tgoto out_free_dgram;\n\n\t\tqbit = (skb->data[0] & X25_Q_BIT) == X25_Q_BIT;\n\n\t\tskb_pull(skb, header_len);\n\n\t\tif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\n\t\t\tasmptr  = skb_push(skb, 1);\n\t\t\t*asmptr = qbit;\n\t\t}\n\t}\n\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\t/* Currently, each datagram always contains a complete record */\n\tmsg->msg_flags |= MSG_EOR;\n\n\trc = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (rc)\n\t\tgoto out_free_dgram;\n\n \tif (sx25) {\n \t\tsx25->sx25_family = AF_X25;\n \t\tsx25->sx25_addr   = x25->dest_addr;\n \t}\n \n\tmsg->msg_namelen = sizeof(struct sockaddr_x25);\n \tx25_check_rbuf(sk);\n \trc = copied;\n out_free_dgram:\n\tskb_free_datagram(sk, skb);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141939,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int x25_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t       struct msghdr *msg, size_t size,\n\t\t       int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct sockaddr_x25 *sx25 = (struct sockaddr_x25 *)msg->msg_name;\n\tsize_t copied;\n\tint qbit, header_len;\n\tstruct sk_buff *skb;\n\tunsigned char *asmptr;\n\tint rc = -ENOTCONN;\n\n\tlock_sock(sk);\n\n\tif (x25->neighbour == NULL)\n\t\tgoto out;\n\n\theader_len = x25->neighbour->extended ?\n\t\tX25_EXT_MIN_LEN : X25_STD_MIN_LEN;\n\n\t/*\n\t * This works for seqpacket too. The receiver has ordered the queue for\n\t * us! We do one quick check first though\n\t */\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\tgoto out;\n\n\tif (flags & MSG_OOB) {\n\t\trc = -EINVAL;\n\t\tif (sock_flag(sk, SOCK_URGINLINE) ||\n\t\t    !skb_peek(&x25->interrupt_in_queue))\n\t\t\tgoto out;\n\n\t\tskb = skb_dequeue(&x25->interrupt_in_queue);\n\n\t\tif (!pskb_may_pull(skb, X25_STD_MIN_LEN))\n\t\t\tgoto out_free_dgram;\n\n\t\tskb_pull(skb, X25_STD_MIN_LEN);\n\n\t\t/*\n\t\t *\tNo Q bit information on Interrupt data.\n\t\t */\n\t\tif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\n\t\t\tasmptr  = skb_push(skb, 1);\n\t\t\t*asmptr = 0x00;\n\t\t}\n\n\t\tmsg->msg_flags |= MSG_OOB;\n\t} else {\n\t\t/* Now we can treat all alike */\n\t\trelease_sock(sk);\n\t\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\t\tlock_sock(sk);\n\t\tif (!skb)\n\t\t\tgoto out;\n\n\t\tif (!pskb_may_pull(skb, header_len))\n\t\t\tgoto out_free_dgram;\n\n\t\tqbit = (skb->data[0] & X25_Q_BIT) == X25_Q_BIT;\n\n\t\tskb_pull(skb, header_len);\n\n\t\tif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\n\t\t\tasmptr  = skb_push(skb, 1);\n\t\t\t*asmptr = qbit;\n\t\t}\n\t}\n\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\t/* Currently, each datagram always contains a complete record */\n\tmsg->msg_flags |= MSG_EOR;\n\n\trc = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (rc)\n\t\tgoto out_free_dgram;\n\n \tif (sx25) {\n \t\tsx25->sx25_family = AF_X25;\n \t\tsx25->sx25_addr   = x25->dest_addr;\n\t\tmsg->msg_namelen = sizeof(*sx25);\n \t}\n \n \tx25_check_rbuf(sk);\n \trc = copied;\n out_free_dgram:\n\tskb_free_datagram(sk, skb);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141940,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,\n\t\t\t\t u32 val, ktime_t *abs_time, u32 bitset,\n\t\t\t\t u32 __user *uaddr2)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct rt_mutex_waiter rt_waiter;\n\tstruct rt_mutex *pi_mutex = NULL;\n\tstruct futex_hash_bucket *hb;\n\tunion futex_key key2 = FUTEX_KEY_INIT;\n \tstruct futex_q q = futex_q_init;\n \tint res, ret;\n \n \tif (!bitset)\n \t\treturn -EINVAL;\n \n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, (flags & FLAGS_CLOCKRT) ?\n\t\t\t\t      CLOCK_REALTIME : CLOCK_MONOTONIC,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\n\t/*\n\t * The waiter is allocated on our stack, manipulated by the requeue\n\t * code while we sleep on uaddr.\n\t */\n\tdebug_rt_mutex_init_waiter(&rt_waiter);\n\trt_waiter.task = NULL;\n\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2, VERIFY_WRITE);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\tq.bitset = bitset;\n\tq.rt_waiter = &rt_waiter;\n\tq.requeue_pi_key = &key2;\n\n\t/*\n\t * Prepare to wait on uaddr. On success, increments q.key (key1) ref\n\t * count.\n\t */\n\tret = futex_wait_setup(uaddr, val, flags, &q, &hb);\n\tif (ret)\n\t\tgoto out_key2;\n\n\t/* Queue the futex_q, drop the hb lock, wait for wakeup. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\tspin_lock(&hb->lock);\n\tret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);\n\tspin_unlock(&hb->lock);\n\tif (ret)\n\t\tgoto out_put_keys;\n\n\t/*\n\t * In order for us to be here, we know our q.key == key2, and since\n\t * we took the hb->lock above, we also know that futex_requeue() has\n\t * completed and we no longer have to concern ourselves with a wakeup\n\t * race with the atomic proxy lock acquisition by the requeue code. The\n\t * futex_requeue dropped our key1 reference and incremented our key2\n\t * reference count.\n\t */\n\n\t/* Check if the requeue code acquired the second futex for us. */\n\tif (!q.rt_waiter) {\n\t\t/*\n\t\t * Got the lock. We might not be the anticipated owner if we\n\t\t * did a lock-steal - fix up the PI-state in that case.\n\t\t */\n\t\tif (q.pi_state && (q.pi_state->owner != current)) {\n\t\t\tspin_lock(q.lock_ptr);\n\t\t\tret = fixup_pi_state_owner(uaddr2, &q, current);\n\t\t\tspin_unlock(q.lock_ptr);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We have been woken up by futex_unlock_pi(), a timeout, or a\n\t\t * signal.  futex_unlock_pi() will not destroy the lock_ptr nor\n\t\t * the pi_state.\n\t\t */\n\t\tWARN_ON(!q.pi_state);\n\t\tpi_mutex = &q.pi_state->pi_mutex;\n\t\tret = rt_mutex_finish_proxy_lock(pi_mutex, to, &rt_waiter, 1);\n\t\tdebug_rt_mutex_free_waiter(&rt_waiter);\n\n\t\tspin_lock(q.lock_ptr);\n\t\t/*\n\t\t * Fixup the pi_state owner and possibly acquire the lock if we\n\t\t * haven't already.\n\t\t */\n\t\tres = fixup_owner(uaddr2, &q, !ret);\n\t\t/*\n\t\t * If fixup_owner() returned an error, proprogate that.  If it\n\t\t * acquired the lock, clear -ETIMEDOUT or -EINTR.\n\t\t */\n\t\tif (res)\n\t\t\tret = (res < 0) ? res : 0;\n\n\t\t/* Unqueue and drop the lock. */\n\t\tunqueue_me_pi(&q);\n\t}\n\n\t/*\n\t * If fixup_pi_state_owner() faulted and was unable to handle the\n\t * fault, unlock the rt_mutex and return the fault to userspace.\n\t */\n\tif (ret == -EFAULT) {\n\t\tif (pi_mutex && rt_mutex_owner(pi_mutex) == current)\n\t\t\trt_mutex_unlock(pi_mutex);\n\t} else if (ret == -EINTR) {\n\t\t/*\n\t\t * We've already been requeued, but cannot restart by calling\n\t\t * futex_lock_pi() directly. We could restart this syscall, but\n\t\t * it would detect that the user space \"val\" changed and return\n\t\t * -EWOULDBLOCK.  Save the overhead of the restart and return\n\t\t * -EWOULDBLOCK directly.\n\t\t */\n\t\tret = -EWOULDBLOCK;\n\t}\n\nout_put_keys:\n\tput_futex_key(&q.key);\nout_key2:\n\tput_futex_key(&key2);\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141947,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,\n\t\t\t\t u32 val, ktime_t *abs_time, u32 bitset,\n\t\t\t\t u32 __user *uaddr2)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct rt_mutex_waiter rt_waiter;\n\tstruct rt_mutex *pi_mutex = NULL;\n\tstruct futex_hash_bucket *hb;\n\tunion futex_key key2 = FUTEX_KEY_INIT;\n \tstruct futex_q q = futex_q_init;\n \tint res, ret;\n \n\tif (uaddr == uaddr2)\n\t\treturn -EINVAL;\n\n \tif (!bitset)\n \t\treturn -EINVAL;\n \n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, (flags & FLAGS_CLOCKRT) ?\n\t\t\t\t      CLOCK_REALTIME : CLOCK_MONOTONIC,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\n\t/*\n\t * The waiter is allocated on our stack, manipulated by the requeue\n\t * code while we sleep on uaddr.\n\t */\n\tdebug_rt_mutex_init_waiter(&rt_waiter);\n\trt_waiter.task = NULL;\n\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2, VERIFY_WRITE);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\tq.bitset = bitset;\n\tq.rt_waiter = &rt_waiter;\n\tq.requeue_pi_key = &key2;\n\n\t/*\n\t * Prepare to wait on uaddr. On success, increments q.key (key1) ref\n\t * count.\n\t */\n\tret = futex_wait_setup(uaddr, val, flags, &q, &hb);\n\tif (ret)\n\t\tgoto out_key2;\n\n\t/* Queue the futex_q, drop the hb lock, wait for wakeup. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\tspin_lock(&hb->lock);\n\tret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);\n\tspin_unlock(&hb->lock);\n\tif (ret)\n\t\tgoto out_put_keys;\n\n\t/*\n\t * In order for us to be here, we know our q.key == key2, and since\n\t * we took the hb->lock above, we also know that futex_requeue() has\n\t * completed and we no longer have to concern ourselves with a wakeup\n\t * race with the atomic proxy lock acquisition by the requeue code. The\n\t * futex_requeue dropped our key1 reference and incremented our key2\n\t * reference count.\n\t */\n\n\t/* Check if the requeue code acquired the second futex for us. */\n\tif (!q.rt_waiter) {\n\t\t/*\n\t\t * Got the lock. We might not be the anticipated owner if we\n\t\t * did a lock-steal - fix up the PI-state in that case.\n\t\t */\n\t\tif (q.pi_state && (q.pi_state->owner != current)) {\n\t\t\tspin_lock(q.lock_ptr);\n\t\t\tret = fixup_pi_state_owner(uaddr2, &q, current);\n\t\t\tspin_unlock(q.lock_ptr);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We have been woken up by futex_unlock_pi(), a timeout, or a\n\t\t * signal.  futex_unlock_pi() will not destroy the lock_ptr nor\n\t\t * the pi_state.\n\t\t */\n\t\tWARN_ON(!q.pi_state);\n\t\tpi_mutex = &q.pi_state->pi_mutex;\n\t\tret = rt_mutex_finish_proxy_lock(pi_mutex, to, &rt_waiter, 1);\n\t\tdebug_rt_mutex_free_waiter(&rt_waiter);\n\n\t\tspin_lock(q.lock_ptr);\n\t\t/*\n\t\t * Fixup the pi_state owner and possibly acquire the lock if we\n\t\t * haven't already.\n\t\t */\n\t\tres = fixup_owner(uaddr2, &q, !ret);\n\t\t/*\n\t\t * If fixup_owner() returned an error, proprogate that.  If it\n\t\t * acquired the lock, clear -ETIMEDOUT or -EINTR.\n\t\t */\n\t\tif (res)\n\t\t\tret = (res < 0) ? res : 0;\n\n\t\t/* Unqueue and drop the lock. */\n\t\tunqueue_me_pi(&q);\n\t}\n\n\t/*\n\t * If fixup_pi_state_owner() faulted and was unable to handle the\n\t * fault, unlock the rt_mutex and return the fault to userspace.\n\t */\n\tif (ret == -EFAULT) {\n\t\tif (pi_mutex && rt_mutex_owner(pi_mutex) == current)\n\t\t\trt_mutex_unlock(pi_mutex);\n\t} else if (ret == -EINTR) {\n\t\t/*\n\t\t * We've already been requeued, but cannot restart by calling\n\t\t * futex_lock_pi() directly. We could restart this syscall, but\n\t\t * it would detect that the user space \"val\" changed and return\n\t\t * -EWOULDBLOCK.  Save the overhead of the restart and return\n\t\t * -EWOULDBLOCK directly.\n\t\t */\n\t\tret = -EWOULDBLOCK;\n\t}\n\nout_put_keys:\n\tput_futex_key(&q.key);\nout_key2:\n\tput_futex_key(&key2);\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141948,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "mm_sshpam_init_ctx(Authctxt *authctxt)\n{\n\tBuffer m;\n\tint success;\n \n \tdebug3(\"%s\", __func__);\n \tbuffer_init(&m);\n\tbuffer_put_cstring(&m, authctxt->user);\n \tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_INIT_CTX, &m);\n \tdebug3(\"%s: waiting for MONITOR_ANS_PAM_INIT_CTX\", __func__);\n \tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PAM_INIT_CTX, &m);\n\tsuccess = buffer_get_int(&m);\n\tif (success == 0) {\n\t\tdebug3(\"%s: pam_init_ctx failed\", __func__);\n\t\tbuffer_free(&m);\n\t\treturn (NULL);\n\t}\n\tbuffer_free(&m);\n\treturn (authctxt);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141965,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "mm_sshpam_init_ctx(Authctxt *authctxt)\n{\n\tBuffer m;\n\tint success;\n \n \tdebug3(\"%s\", __func__);\n \tbuffer_init(&m);\n \tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_INIT_CTX, &m);\n \tdebug3(\"%s: waiting for MONITOR_ANS_PAM_INIT_CTX\", __func__);\n \tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PAM_INIT_CTX, &m);\n\tsuccess = buffer_get_int(&m);\n\tif (success == 0) {\n\t\tdebug3(\"%s: pam_init_ctx failed\", __func__);\n\t\tbuffer_free(&m);\n\t\treturn (NULL);\n\t}\n\tbuffer_free(&m);\n\treturn (authctxt);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141966,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void icmp6_send(struct sk_buff *skb, u8 type, u8 code, __u32 info,\n\t\t       const struct in6_addr *force_saddr)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct inet6_dev *idev = NULL;\n\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\tstruct sock *sk;\n\tstruct ipv6_pinfo *np;\n\tconst struct in6_addr *saddr = NULL;\n\tstruct dst_entry *dst;\n\tstruct icmp6hdr tmp_hdr;\n\tstruct flowi6 fl6;\n\tstruct icmpv6_msg msg;\n\tstruct sockcm_cookie sockc_unused = {0};\n\tstruct ipcm6_cookie ipc6;\n\tint iif = 0;\n\tint addr_type = 0;\n\tint len;\n\tint err = 0;\n\tu32 mark = IP6_REPLY_MARK(net, skb->mark);\n\n\tif ((u8 *)hdr < skb->head ||\n\t    (skb_network_header(skb) + sizeof(*hdr)) > skb_tail_pointer(skb))\n\t\treturn;\n\n\t/*\n\t *\tMake sure we respect the rules\n\t *\ti.e. RFC 1885 2.4(e)\n\t *\tRule (e.1) is enforced by not using icmp6_send\n\t *\tin any code that processes icmp errors.\n\t */\n\taddr_type = ipv6_addr_type(&hdr->daddr);\n\n\tif (ipv6_chk_addr(net, &hdr->daddr, skb->dev, 0) ||\n\t    ipv6_chk_acast_addr_src(net, skb->dev, &hdr->daddr))\n\t\tsaddr = &hdr->daddr;\n\n\t/*\n\t *\tDest addr check\n\t */\n\n\tif (addr_type & IPV6_ADDR_MULTICAST || skb->pkt_type != PACKET_HOST) {\n\t\tif (type != ICMPV6_PKT_TOOBIG &&\n\t\t    !(type == ICMPV6_PARAMPROB &&\n\t\t      code == ICMPV6_UNK_OPTION &&\n\t\t      (opt_unrec(skb, info))))\n\t\t\treturn;\n\n\t\tsaddr = NULL;\n\t}\n\n\taddr_type = ipv6_addr_type(&hdr->saddr);\n\n\t/*\n\t *\tSource addr check\n\t */\n \n \tif (__ipv6_addr_needs_scope_id(addr_type))\n \t\tiif = skb->dev->ifindex;\n\telse\n\t\tiif = l3mdev_master_ifindex(skb_dst(skb)->dev);\n \n \t/*\n \t *\tMust not send error if the source does not uniquely\n\t *\tidentify a single node (RFC2463 Section 2.4).\n\t *\tWe check unspecified / multicast addresses here,\n\t *\tand anycast addresses will be checked later.\n\t */\n\tif ((addr_type == IPV6_ADDR_ANY) || (addr_type & IPV6_ADDR_MULTICAST)) {\n\t\tnet_dbg_ratelimited(\"icmp6_send: addr_any/mcast source [%pI6c > %pI6c]\\n\",\n\t\t\t\t    &hdr->saddr, &hdr->daddr);\n\t\treturn;\n\t}\n\n\t/*\n\t *\tNever answer to a ICMP packet.\n\t */\n\tif (is_ineligible(skb)) {\n\t\tnet_dbg_ratelimited(\"icmp6_send: no reply to icmp error [%pI6c > %pI6c]\\n\",\n\t\t\t\t    &hdr->saddr, &hdr->daddr);\n\t\treturn;\n\t}\n\n\tmip6_addr_swap(skb);\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = IPPROTO_ICMPV6;\n\tfl6.daddr = hdr->saddr;\n\tif (force_saddr)\n\t\tsaddr = force_saddr;\n\tif (saddr)\n\t\tfl6.saddr = *saddr;\n\tfl6.flowi6_mark = mark;\n\tfl6.flowi6_oif = iif;\n\tfl6.fl6_icmp_type = type;\n\tfl6.fl6_icmp_code = code;\n\tsecurity_skb_classify_flow(skb, flowi6_to_flowi(&fl6));\n\n\tsk = icmpv6_xmit_lock(net);\n\tif (!sk)\n\t\treturn;\n\tsk->sk_mark = mark;\n\tnp = inet6_sk(sk);\n\n\tif (!icmpv6_xrlim_allow(sk, type, &fl6))\n\t\tgoto out;\n\n\ttmp_hdr.icmp6_type = type;\n\ttmp_hdr.icmp6_code = code;\n\ttmp_hdr.icmp6_cksum = 0;\n\ttmp_hdr.icmp6_pointer = htonl(info);\n\n\tif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\telse if (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->ucast_oif;\n\n\tipc6.tclass = np->tclass;\n\tfl6.flowlabel = ip6_make_flowinfo(ipc6.tclass, fl6.flowlabel);\n\n\tdst = icmpv6_route_lookup(net, skb, sk, &fl6);\n\tif (IS_ERR(dst))\n\t\tgoto out;\n\n\tipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);\n\tipc6.dontfrag = np->dontfrag;\n\tipc6.opt = NULL;\n\n\tmsg.skb = skb;\n\tmsg.offset = skb_network_offset(skb);\n\tmsg.type = type;\n\n\tlen = skb->len - msg.offset;\n\tlen = min_t(unsigned int, len, IPV6_MIN_MTU - sizeof(struct ipv6hdr) - sizeof(struct icmp6hdr));\n\tif (len < 0) {\n\t\tnet_dbg_ratelimited(\"icmp: len problem [%pI6c > %pI6c]\\n\",\n\t\t\t\t    &hdr->saddr, &hdr->daddr);\n\t\tgoto out_dst_release;\n\t}\n\n\trcu_read_lock();\n\tidev = __in6_dev_get(skb->dev);\n\n\terr = ip6_append_data(sk, icmpv6_getfrag, &msg,\n\t\t\t      len + sizeof(struct icmp6hdr),\n\t\t\t      sizeof(struct icmp6hdr),\n\t\t\t      &ipc6, &fl6, (struct rt6_info *)dst,\n\t\t\t      MSG_DONTWAIT, &sockc_unused);\n\tif (err) {\n\t\tICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTERRORS);\n\t\tip6_flush_pending_frames(sk);\n\t} else {\n\t\terr = icmpv6_push_pending_frames(sk, &fl6, &tmp_hdr,\n\t\t\t\t\t\t len + sizeof(struct icmp6hdr));\n\t}\n\trcu_read_unlock();\nout_dst_release:\n\tdst_release(dst);\nout:\n\ticmpv6_xmit_unlock(sk);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142027,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void icmp6_send(struct sk_buff *skb, u8 type, u8 code, __u32 info,\n\t\t       const struct in6_addr *force_saddr)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct inet6_dev *idev = NULL;\n\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\tstruct sock *sk;\n\tstruct ipv6_pinfo *np;\n\tconst struct in6_addr *saddr = NULL;\n\tstruct dst_entry *dst;\n\tstruct icmp6hdr tmp_hdr;\n\tstruct flowi6 fl6;\n\tstruct icmpv6_msg msg;\n\tstruct sockcm_cookie sockc_unused = {0};\n\tstruct ipcm6_cookie ipc6;\n\tint iif = 0;\n\tint addr_type = 0;\n\tint len;\n\tint err = 0;\n\tu32 mark = IP6_REPLY_MARK(net, skb->mark);\n\n\tif ((u8 *)hdr < skb->head ||\n\t    (skb_network_header(skb) + sizeof(*hdr)) > skb_tail_pointer(skb))\n\t\treturn;\n\n\t/*\n\t *\tMake sure we respect the rules\n\t *\ti.e. RFC 1885 2.4(e)\n\t *\tRule (e.1) is enforced by not using icmp6_send\n\t *\tin any code that processes icmp errors.\n\t */\n\taddr_type = ipv6_addr_type(&hdr->daddr);\n\n\tif (ipv6_chk_addr(net, &hdr->daddr, skb->dev, 0) ||\n\t    ipv6_chk_acast_addr_src(net, skb->dev, &hdr->daddr))\n\t\tsaddr = &hdr->daddr;\n\n\t/*\n\t *\tDest addr check\n\t */\n\n\tif (addr_type & IPV6_ADDR_MULTICAST || skb->pkt_type != PACKET_HOST) {\n\t\tif (type != ICMPV6_PKT_TOOBIG &&\n\t\t    !(type == ICMPV6_PARAMPROB &&\n\t\t      code == ICMPV6_UNK_OPTION &&\n\t\t      (opt_unrec(skb, info))))\n\t\t\treturn;\n\n\t\tsaddr = NULL;\n\t}\n\n\taddr_type = ipv6_addr_type(&hdr->saddr);\n\n\t/*\n\t *\tSource addr check\n\t */\n \n \tif (__ipv6_addr_needs_scope_id(addr_type))\n \t\tiif = skb->dev->ifindex;\n\telse {\n\t\tdst = skb_dst(skb);\n\t\tiif = l3mdev_master_ifindex(dst ? dst->dev : skb->dev);\n\t}\n \n \t/*\n \t *\tMust not send error if the source does not uniquely\n\t *\tidentify a single node (RFC2463 Section 2.4).\n\t *\tWe check unspecified / multicast addresses here,\n\t *\tand anycast addresses will be checked later.\n\t */\n\tif ((addr_type == IPV6_ADDR_ANY) || (addr_type & IPV6_ADDR_MULTICAST)) {\n\t\tnet_dbg_ratelimited(\"icmp6_send: addr_any/mcast source [%pI6c > %pI6c]\\n\",\n\t\t\t\t    &hdr->saddr, &hdr->daddr);\n\t\treturn;\n\t}\n\n\t/*\n\t *\tNever answer to a ICMP packet.\n\t */\n\tif (is_ineligible(skb)) {\n\t\tnet_dbg_ratelimited(\"icmp6_send: no reply to icmp error [%pI6c > %pI6c]\\n\",\n\t\t\t\t    &hdr->saddr, &hdr->daddr);\n\t\treturn;\n\t}\n\n\tmip6_addr_swap(skb);\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = IPPROTO_ICMPV6;\n\tfl6.daddr = hdr->saddr;\n\tif (force_saddr)\n\t\tsaddr = force_saddr;\n\tif (saddr)\n\t\tfl6.saddr = *saddr;\n\tfl6.flowi6_mark = mark;\n\tfl6.flowi6_oif = iif;\n\tfl6.fl6_icmp_type = type;\n\tfl6.fl6_icmp_code = code;\n\tsecurity_skb_classify_flow(skb, flowi6_to_flowi(&fl6));\n\n\tsk = icmpv6_xmit_lock(net);\n\tif (!sk)\n\t\treturn;\n\tsk->sk_mark = mark;\n\tnp = inet6_sk(sk);\n\n\tif (!icmpv6_xrlim_allow(sk, type, &fl6))\n\t\tgoto out;\n\n\ttmp_hdr.icmp6_type = type;\n\ttmp_hdr.icmp6_code = code;\n\ttmp_hdr.icmp6_cksum = 0;\n\ttmp_hdr.icmp6_pointer = htonl(info);\n\n\tif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\telse if (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->ucast_oif;\n\n\tipc6.tclass = np->tclass;\n\tfl6.flowlabel = ip6_make_flowinfo(ipc6.tclass, fl6.flowlabel);\n\n\tdst = icmpv6_route_lookup(net, skb, sk, &fl6);\n\tif (IS_ERR(dst))\n\t\tgoto out;\n\n\tipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);\n\tipc6.dontfrag = np->dontfrag;\n\tipc6.opt = NULL;\n\n\tmsg.skb = skb;\n\tmsg.offset = skb_network_offset(skb);\n\tmsg.type = type;\n\n\tlen = skb->len - msg.offset;\n\tlen = min_t(unsigned int, len, IPV6_MIN_MTU - sizeof(struct ipv6hdr) - sizeof(struct icmp6hdr));\n\tif (len < 0) {\n\t\tnet_dbg_ratelimited(\"icmp: len problem [%pI6c > %pI6c]\\n\",\n\t\t\t\t    &hdr->saddr, &hdr->daddr);\n\t\tgoto out_dst_release;\n\t}\n\n\trcu_read_lock();\n\tidev = __in6_dev_get(skb->dev);\n\n\terr = ip6_append_data(sk, icmpv6_getfrag, &msg,\n\t\t\t      len + sizeof(struct icmp6hdr),\n\t\t\t      sizeof(struct icmp6hdr),\n\t\t\t      &ipc6, &fl6, (struct rt6_info *)dst,\n\t\t\t      MSG_DONTWAIT, &sockc_unused);\n\tif (err) {\n\t\tICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTERRORS);\n\t\tip6_flush_pending_frames(sk);\n\t} else {\n\t\terr = icmpv6_push_pending_frames(sk, &fl6, &tmp_hdr,\n\t\t\t\t\t\t len + sizeof(struct icmp6hdr));\n\t}\n\trcu_read_unlock();\nout_dst_release:\n\tdst_release(dst);\nout:\n\ticmpv6_xmit_unlock(sk);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142028,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int proc_sys_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct ctl_table_header *head = grab_header(file_inode(file));\n\tstruct ctl_table_header *h = NULL;\n\tstruct ctl_table *entry;\n\tstruct ctl_dir *ctl_dir;\n\tunsigned long pos;\n\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n \tctl_dir = container_of(head, struct ctl_dir, header);\n \n \tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n \n \tpos = 2;\n \n\tfor (first_entry(ctl_dir, &h, &entry); h; next_entry(&h, &entry)) {\n\t\tif (!scan(h, entry, &pos, file, ctx)) {\n\t\t\tsysctl_head_finish(h);\n \t\t\tbreak;\n \t\t}\n \t}\n \tsysctl_head_finish(head);\n \treturn 0;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142049,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int proc_sys_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct ctl_table_header *head = grab_header(file_inode(file));\n\tstruct ctl_table_header *h = NULL;\n\tstruct ctl_table *entry;\n\tstruct ctl_dir *ctl_dir;\n\tunsigned long pos;\n\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n \tctl_dir = container_of(head, struct ctl_dir, header);\n \n \tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n \n \tpos = 2;\n \n\tfor (first_entry(ctl_dir, &h, &entry); h; next_entry(&h, &entry)) {\n\t\tif (!scan(h, entry, &pos, file, ctx)) {\n\t\t\tsysctl_head_finish(h);\n \t\t\tbreak;\n \t\t}\n \t}\nout:\n \tsysctl_head_finish(head);\n \treturn 0;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142050,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "auth_password(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd * pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n \tstatic int expire_checked = 0;\n #endif\n \n #ifndef HAVE_CYGWIN\n \tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n \t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t\t/* Fall back to ordinary passwd authentication. */\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(authctxt, password);\n\tif (authctxt->force_pwchange)\n\t\tdisable_forwarding();\n\treturn (result && ok);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142083,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "auth_password(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd * pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n \tstatic int expire_checked = 0;\n #endif\n \n\tif (strlen(password) > MAX_PASSWORD_LEN)\n\t\treturn 0;\n\n #ifndef HAVE_CYGWIN\n \tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n \t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t\t/* Fall back to ordinary passwd authentication. */\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(authctxt, password);\n\tif (authctxt->force_pwchange)\n\t\tdisable_forwarding();\n\treturn (result && ok);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142084,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    explicit_vr[MagickPathExtent],\n    implicit_vr[MagickPathExtent],\n    magick[MagickPathExtent],\n    photometric[MagickPathExtent];\n\n  DCMStreamInfo\n    *stream_info;\n\n  Image\n    *image;\n\n  int\n    *bluemap,\n    datum,\n    *greenmap,\n    *graymap,\n    index,\n    *redmap;\n\n  MagickBooleanType\n    explicit_file,\n    explicit_retry,\n    polarity,\n    sequence,\n    use_explicit;\n\n  MagickOffsetType\n    offset;\n\n  Quantum\n    *scale;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_allocated,\n    bytes_per_pixel,\n    colors,\n    depth,\n    height,\n    length,\n    mask,\n    max_value,\n    number_scenes,\n    quantum,\n    samples_per_pixel,\n    signed_data,\n    significant_bits,\n    status,\n    width,\n    window_width;\n\n  ssize_t\n    count,\n    rescale_intercept,\n    rescale_slope,\n    scene,\n    window_center,\n    y;\n\n  unsigned char\n    *data;\n\n  unsigned short\n    group,\n    element;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=8UL;\n  image->endian=LSBEndian;\n  /*\n    Read DCM preamble.\n  */\n  stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));\n  if (stream_info == (DCMStreamInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(stream_info,0,sizeof(*stream_info));\n  count=ReadBlob(image,128,(unsigned char *) magick);\n  if (count != 128)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  if ((count != 4) || (LocaleNCompare(magick,\"DICM\",4) != 0))\n    {\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  /*\n    Read DCM Medical image.\n  */\n  (void) CopyMagickString(photometric,\"MONOCHROME1 \",MagickPathExtent);\n  bits_allocated=8;\n  bytes_per_pixel=1;\n  polarity=MagickFalse;\n  data=(unsigned char *) NULL;\n  depth=8;\n  element=0;\n  explicit_vr[2]='\\0';\n  explicit_file=MagickFalse;\n  colors=0;\n  redmap=(int *) NULL;\n  greenmap=(int *) NULL;\n  bluemap=(int *) NULL;\n  graymap=(int *) NULL;\n  height=0;\n  max_value=255UL;\n  mask=0xffff;\n  number_scenes=1;\n  rescale_intercept=0;\n  rescale_slope=1;\n  samples_per_pixel=1;\n  scale=(Quantum *) NULL;\n  sequence=MagickFalse;\n  signed_data=(~0UL);\n  significant_bits=0;\n  use_explicit=MagickFalse;\n  explicit_retry = MagickFalse;\n  width=0;\n  window_center=0;\n  window_width=0;\n  for (group=0; (group != 0x7FE0) || (element != 0x0010) ||\n                (sequence != MagickFalse); )\n  {\n    /*\n      Read a group.\n    */\n    image->offset=(ssize_t) TellBlob(image);\n    group=ReadBlobLSBShort(image);\n    element=ReadBlobLSBShort(image);\n    if ((group != 0x0002) && (image->endian == MSBEndian))\n      {\n        group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));\n        element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));\n      }\n    quantum=0;\n    /*\n      Find corresponding VR for this group and element.\n    */\n    for (i=0; dicom_info[i].group < 0xffff; i++)\n      if ((group == dicom_info[i].group) && (element == dicom_info[i].element))\n        break;\n    (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);\n    count=ReadBlob(image,2,(unsigned char *) explicit_vr);\n    if (count != 2)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    /*\n      Check for \"explicitness\", but meta-file headers always explicit.\n    */\n    if ((explicit_file == MagickFalse) && (group != 0x0002))\n      explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&\n        (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?\n        MagickTrue : MagickFalse;\n    use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||\n      (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;\n    if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,\"xs\",2) == 0))\n      (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);\n    if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,\"!!\",2) == 0))\n      {\n        offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        quantum=4;\n      }\n    else\n      {\n        /*\n          Assume explicit type.\n        */\n        quantum=2;\n        if ((strncmp(explicit_vr,\"OB\",2) == 0) ||\n            (strncmp(explicit_vr,\"UN\",2) == 0) ||\n            (strncmp(explicit_vr,\"OW\",2) == 0) ||\n            (strncmp(explicit_vr,\"SQ\",2) == 0))\n          {\n            (void) ReadBlobLSBShort(image);\n            quantum=4;\n          }\n      }\n    datum=0;\n    if (quantum == 4)\n      {\n        if (group == 0x0002)\n          datum=ReadBlobLSBSignedLong(image);\n        else\n          datum=ReadBlobSignedLong(image);\n      }\n    else\n      if (quantum == 2)\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedShort(image);\n          else\n            datum=ReadBlobSignedShort(image);\n        }\n    quantum=0;\n    length=1;\n    if (datum != 0)\n      {\n        if ((strncmp(implicit_vr,\"SS\",2) == 0) ||\n            (strncmp(implicit_vr,\"US\",2) == 0))\n          quantum=2;\n        else\n          if ((strncmp(implicit_vr,\"UL\",2) == 0) ||\n              (strncmp(implicit_vr,\"SL\",2) == 0) ||\n              (strncmp(implicit_vr,\"FL\",2) == 0))\n            quantum=4;\n          else\n            if (strncmp(implicit_vr,\"FD\",2) != 0)\n              quantum=1;\n            else\n              quantum=8;\n        if (datum != ~0)\n          length=(size_t) datum/quantum;\n        else\n          {\n            /*\n              Sequence and item of undefined length.\n            */\n            quantum=0;\n            length=0;\n          }\n      }\n    if (image_info->verbose != MagickFalse)\n      {\n        /*\n          Display Dicom info.\n        */\n        if (use_explicit == MagickFalse)\n          explicit_vr[0]='\\0';\n        for (i=0; dicom_info[i].description != (char *) NULL; i++)\n          if ((group == dicom_info[i].group) &&\n              (element == dicom_info[i].element))\n            break;\n        (void) FormatLocaleFile(stdout,\"0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)\",\n          (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,\n          (unsigned long) group,(unsigned long) element);\n        if (dicom_info[i].description != (char *) NULL)\n          (void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);\n        (void) FormatLocaleFile(stdout,\": \");\n      }\n    if ((sequence == MagickFalse) && (group == 0x7FE0) && (element == 0x0010))\n      {\n        if (image_info->verbose != MagickFalse)\n          (void) FormatLocaleFile(stdout,\"\\n\");\n        break;\n      }\n    /*\n      Allocate space and read an array.\n    */\n    data=(unsigned char *) NULL;\n    if ((length == 1) && (quantum == 1))\n      datum=ReadBlobByte(image);\n    else\n      if ((length == 1) && (quantum == 2))\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedShort(image);\n          else\n            datum=ReadBlobSignedShort(image);\n        }\n      else\n        if ((length == 1) && (quantum == 4))\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedLong(image);\n            else\n              datum=ReadBlobSignedLong(image);\n          }\n        else\n          if ((quantum != 0) && (length != 0))\n            {\n              if (~length >= 1)\n                data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*\n                  sizeof(*data));\n              if (data == (unsigned char *) NULL)\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              count=ReadBlob(image,(size_t) quantum*length,data);\n              if (count != (ssize_t) (quantum*length))\n                {\n                  if (image_info->verbose != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"\n                      \"length=%d group=%d\\n\",(int) count,(int) quantum,(int)\n                      length,(int) group);\n                   ThrowReaderException(CorruptImageError,\n                     \"InsufficientImageDataInFile\");\n                }\n              data[length*quantum]='\\0';\n            }\n          else\n            if ((unsigned int) datum == 0xFFFFFFFFU)\n              {\n                sequence=MagickTrue;\n                continue;\n              }\n\n    if ((unsigned int) ((group << 16) | element) == 0xFFFEE0DD)\n      {\n        if (data != (unsigned char *) NULL)\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        sequence=MagickFalse;\n        continue;\n      }\n\n    if (sequence != MagickFalse)\n      {\n        if (data != (unsigned char *) NULL)\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        continue;\n      }\n\n    switch (group)\n    {\n      case 0x0002:\n      {\n        switch (element)\n        {\n          case 0x0010:\n          {\n            char\n              transfer_syntax[MagickPathExtent];\n\n            /*\n              Transfer Syntax.\n            */\n            if ((datum == 0) && (explicit_retry == MagickFalse))\n              {\n                explicit_retry=MagickTrue;\n                (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);\n                group=0;\n                element=0;\n                if (image_info->verbose != MagickFalse)\n                  (void) FormatLocaleFile(stdout,\n                    \"Corrupted image - trying explicit format\\n\");\n                break;\n              }\n            *transfer_syntax='\\0';\n            if (data != (unsigned char *) NULL)\n              (void) CopyMagickString(transfer_syntax,(char *) data,\n                MagickPathExtent);\n            if (image_info->verbose != MagickFalse)\n              (void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",\n                (const char *) transfer_syntax);\n            if (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)\n              {\n                int\n                  count,\n                  subtype,\n                  type;\n\n                type=1;\n                subtype=0;\n                if (strlen(transfer_syntax) > 17)\n                  {\n                    count=sscanf(transfer_syntax+17,\".%d.%d\",&type,&subtype);\n                    if (count < 1)\n                      ThrowReaderException(CorruptImageError,\n                        \"ImproperImageHeader\");\n                  }\n                switch (type)\n                {\n                  case 1:\n                  {\n                    image->endian=LSBEndian;\n                    break;\n                  }\n                  case 2:\n                  {\n                    image->endian=MSBEndian;\n                    break;\n                  }\n                  case 4:\n                  {\n                    if ((subtype >= 80) && (subtype <= 81))\n                      image->compression=JPEGCompression;\n                    else\n                      if ((subtype >= 90) && (subtype <= 93))\n                        image->compression=JPEG2000Compression;\n                      else\n                        image->compression=JPEGCompression;\n                    break;\n                  }\n                  case 5:\n                  {\n                    image->compression=RLECompression;\n                    break;\n                  }\n                }\n              }\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      case 0x0028:\n      {\n        switch (element)\n        {\n          case 0x0002:\n          {\n            /*\n              Samples per pixel.\n            */\n            samples_per_pixel=(size_t) datum;\n            break;\n          }\n          case 0x0004:\n          {\n             /*\n               Photometric interpretation.\n             */\n             for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)\n               photometric[i]=(char) data[i];\n             photometric[i]='\\0';\n            polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?\n              MagickTrue : MagickFalse;\n            break;\n          }\n          case 0x0006:\n          {\n            /*\n              Planar configuration.\n            */\n            if (datum == 1)\n              image->interlace=PlaneInterlace;\n            break;\n          }\n          case 0x0008:\n          {\n             /*\n               Number of frames.\n             */\n             number_scenes=StringToUnsignedLong((char *) data);\n             break;\n           }\n          case 0x0010:\n          {\n            /*\n              Image rows.\n            */\n            height=(size_t) datum;\n            break;\n          }\n          case 0x0011:\n          {\n            /*\n              Image columns.\n            */\n            width=(size_t) datum;\n            break;\n          }\n          case 0x0100:\n          {\n            /*\n              Bits allocated.\n            */\n            bits_allocated=(size_t) datum;\n            bytes_per_pixel=1;\n            if (datum > 8)\n              bytes_per_pixel=2;\n            depth=bits_allocated;\n            if (depth > 32)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            max_value=(1UL << bits_allocated)-1;\n            break;\n          }\n          case 0x0101:\n          {\n            /*\n              Bits stored.\n            */\n            significant_bits=(size_t) datum;\n            bytes_per_pixel=1;\n            if (significant_bits > 8)\n              bytes_per_pixel=2;\n            depth=significant_bits;\n            if (depth > 32)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            max_value=(1UL << significant_bits)-1;\n            mask=(size_t) GetQuantumRange(significant_bits);\n            break;\n          }\n          case 0x0102:\n          {\n            /*\n              High bit.\n            */\n            break;\n          }\n          case 0x0103:\n          {\n            /*\n              Pixel representation.\n            */\n            signed_data=(size_t) datum;\n            break;\n          }\n          case 0x1050:\n          {\n            /*\n              Visible pixel range: center.\n            */\n            if (data != (unsigned char *) NULL)\n              window_center=(ssize_t) StringToLong((char *) data);\n            break;\n          }\n          case 0x1051:\n          {\n            /*\n              Visible pixel range: width.\n            */\n            if (data != (unsigned char *) NULL)\n              window_width=StringToUnsignedLong((char *) data);\n            break;\n          }\n          case 0x1052:\n          {\n            /*\n              Rescale intercept\n            */\n            if (data != (unsigned char *) NULL)\n              rescale_intercept=(ssize_t) StringToLong((char *) data);\n            break;\n          }\n          case 0x1053:\n          {\n            /*\n              Rescale slope\n            */\n            if (data != (unsigned char *) NULL)\n              rescale_slope=(ssize_t) StringToLong((char *) data);\n            break;\n          }\n          case 0x1200:\n          case 0x3006:\n          {\n            /*\n              Populate graymap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/bytes_per_pixel);\n            datum=(int) colors;\n            graymap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*graymap));\n            if (graymap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            for (i=0; i < (ssize_t) colors; i++)\n              if (bytes_per_pixel == 1)\n                graymap[i]=(int) data[i];\n              else\n                graymap[i]=(int) ((short *) data)[i];\n            break;\n          }\n          case 0x1201:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate redmap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            redmap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*redmap));\n            if (redmap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              redmap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          case 0x1202:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate greenmap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            greenmap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*greenmap));\n            if (greenmap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              greenmap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          case 0x1203:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate bluemap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            bluemap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*bluemap));\n            if (bluemap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              bluemap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      case 0x2050:\n      {\n        switch (element)\n        {\n          case 0x0020:\n          {\n            if ((data != (unsigned char *) NULL) &&\n                (strncmp((char *) data,\"INVERSE\",7) == 0))\n              polarity=MagickTrue;\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      default:\n        break;\n    }\n    if (data != (unsigned char *) NULL)\n      {\n        char\n          *attribute;\n\n        for (i=0; dicom_info[i].description != (char *) NULL; i++)\n          if ((group == dicom_info[i].group) &&\n              (element == dicom_info[i].element))\n            break;\n        if (dicom_info[i].description != (char *) NULL)\n          {\n            attribute=AcquireString(\"dcm:\");\n            (void) ConcatenateString(&attribute,dicom_info[i].description);\n            for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n              if (isprint((int) data[i]) == MagickFalse)\n                break;\n            if ((i == (ssize_t) length) || (length > 4))\n              {\n                (void) SubstituteString(&attribute,\" \",\"\");\n                (void) SetImageProperty(image,attribute,(char *) data,exception);\n              }\n            attribute=DestroyString(attribute);\n          }\n      }\n    if (image_info->verbose != MagickFalse)\n      {\n        if (data == (unsigned char *) NULL)\n          (void) FormatLocaleFile(stdout,\"%d\\n\",datum);\n        else\n          {\n            /*\n              Display group data.\n            */\n            for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n              if (isprint((int) data[i]) == MagickFalse)\n                break;\n            if ((i != (ssize_t) length) && (length <= 4))\n              {\n                ssize_t\n                  j;\n\n                datum=0;\n                for (j=(ssize_t) length-1; j >= 0; j--)\n                  datum=(256*datum+data[j]);\n                (void) FormatLocaleFile(stdout,\"%d\",datum);\n              }\n            else\n              for (i=0; i < (ssize_t) length; i++)\n                if (isprint((int) data[i]) != MagickFalse)\n                  (void) FormatLocaleFile(stdout,\"%c\",data[i]);\n                else\n                  (void) FormatLocaleFile(stdout,\"%c\",'.');\n            (void) FormatLocaleFile(stdout,\"\\n\");\n          }\n      }\n    if (data != (unsigned char *) NULL)\n      data=(unsigned char *) RelinquishMagickMemory(data);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n  }\n  if ((width == 0) || (height == 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  image->columns=(size_t) width;\n  image->rows=(size_t) height;\n  if (signed_data == 0xffff)\n    signed_data=(size_t) (significant_bits == 16 ? 1 : 0);\n  if ((image->compression == JPEGCompression) ||\n      (image->compression == JPEG2000Compression))\n    {\n      Image\n        *images;\n\n      ImageInfo\n        *read_info;\n\n      int\n        c;\n\n      size_t\n        length;\n\n      unsigned int\n        tag;\n\n      /*\n        Read offset table.\n      */\n      for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        (void) ReadBlobByte(image);\n      tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n      (void) tag;\n      length=(size_t) ReadBlobLSBLong(image);\n      stream_info->offset_count=length >> 2;\n      if (stream_info->offset_count != 0)\n        {\n          MagickOffsetType\n            offset;\n\n          stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n            stream_info->offset_count,sizeof(*stream_info->offsets));\n          if (stream_info->offsets == (ssize_t *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          offset=TellBlob(image);\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]+=offset;\n        }\n      /*\n        Handle non-native image formats.\n      */\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      images=NewImageList();\n      for (scene=0; scene < (ssize_t) number_scenes; scene++)\n      {\n        char\n          filename[MagickPathExtent];\n\n        const char\n          *property;\n\n        FILE\n          *file;\n\n        Image\n          *jpeg_image;\n\n        int\n          unique_file;\n\n        unsigned int\n          tag;\n\n        tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n        length=(size_t) ReadBlobLSBLong(image);\n        if (tag == 0xFFFEE0DD)\n          break; /* sequence delimiter tag */\n        if (tag != 0xFFFEE000)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if (file == (FILE *) NULL)\n          {\n            (void) RelinquishUniqueFileResource(filename);\n            ThrowFileException(exception,FileOpenError,\n              \"UnableToCreateTemporaryFile\",filename);\n            break;\n          }\n        for ( ; length != 0; length--)\n        {\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          (void) fputc(c,file);\n        }\n        (void) fclose(file);\n        (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n          \"jpeg:%s\",filename);\n        if (image->compression == JPEG2000Compression)\n          (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n            \"j2k:%s\",filename);\n        jpeg_image=ReadImage(read_info,exception);\n        if (jpeg_image != (Image *) NULL)\n          {\n            ResetImagePropertyIterator(image);\n            property=GetNextImageProperty(image);\n            while (property != (const char *) NULL)\n            {\n              (void) SetImageProperty(jpeg_image,property,\n                GetImageProperty(image,property,exception),exception);\n              property=GetNextImageProperty(image);\n            }\n            AppendImageToList(&images,jpeg_image);\n          }\n        (void) RelinquishUniqueFileResource(filename);\n      }\n      read_info=DestroyImageInfo(read_info);\n      image=DestroyImage(image);\n      return(GetFirstImageInList(images));\n    }\n  if (depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))\n    {\n      QuantumAny\n        range;\n\n      size_t\n        length;\n\n      /*\n        Compute pixel scaling table.\n      */\n      length=(size_t) (GetQuantumRange(depth)+1);\n      scale=(Quantum *) AcquireQuantumMemory(length,sizeof(*scale));\n       if (scale == (Quantum *) NULL)\n         ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n       range=GetQuantumRange(depth);\n      for (i=0; i < (ssize_t) (GetQuantumRange(depth)+1); i++)\n         scale[i]=ScaleAnyToQuantum((size_t) i,range);\n     }\n   if (image->compression == RLECompression)\n    {\n      size_t\n        length;\n\n      unsigned int\n        tag;\n\n      /*\n        Read RLE offset table.\n      */\n      for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        (void) ReadBlobByte(image);\n      tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n      (void) tag;\n      length=(size_t) ReadBlobLSBLong(image);\n      stream_info->offset_count=length >> 2;\n      if (stream_info->offset_count != 0)\n        {\n          MagickOffsetType\n            offset;\n\n          stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n            stream_info->offset_count,sizeof(*stream_info->offsets));\n          if (stream_info->offsets == (ssize_t *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          offset=TellBlob(image);\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]+=offset;\n        }\n    }\n  for (scene=0; scene < (ssize_t) number_scenes; scene++)\n  {\n    if (image_info->ping != MagickFalse)\n      break;\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=depth;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      break;\n    image->colorspace=RGBColorspace;\n    if ((image->colormap == (PixelInfo *) NULL) && (samples_per_pixel == 1))\n      {\n        size_t\n          one;\n\n        one=1;\n        if (colors == 0)\n          colors=one << depth;\n        if (AcquireImageColormap(image,one << depth,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (redmap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=redmap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].red=(MagickRealType) index;\n          }\n        if (greenmap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=greenmap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].green=(MagickRealType) index;\n          }\n        if (bluemap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=bluemap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].blue=(MagickRealType) index;\n          }\n        if (graymap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=graymap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].red=(MagickRealType) index;\n            image->colormap[i].green=(MagickRealType) index;\n            image->colormap[i].blue=(MagickRealType) index;\n          }\n      }\n    if (image->compression == RLECompression)\n      {\n        unsigned int\n          tag;\n\n        /*\n          Read RLE segment table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          (void) ReadBlobByte(image);\n        tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n        stream_info->remaining=(size_t) ReadBlobLSBLong(image);\n        if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||\n            (EOFBlob(image) != MagickFalse))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        stream_info->count=0;\n        stream_info->segment_count=ReadBlobLSBLong(image);\n        if (stream_info->segment_count > 1)\n          {\n            bytes_per_pixel=1;\n            depth=8;\n          }\n        for (i=0; i < 15; i++)\n          stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n        stream_info->remaining-=64;\n      }\n    if ((samples_per_pixel > 1) && (image->interlace == PlaneInterlace))\n      {\n        /*\n          Convert Planar RGB DCM Medical image to pixel packets.\n        */\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              switch ((int) i)\n              {\n                case 0:\n                {\n                  SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 1:\n                {\n                  SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 2:\n                {\n                  SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 3:\n                {\n                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                default:\n                  break;\n              }\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      }\n    else\n      {\n        const char\n          *option;\n\n        int\n          byte;\n\n        PixelPacket\n          pixel;\n\n        /*\n          Convert DCM Medical image to pixel packets.\n        */\n        byte=0;\n        i=0;\n        if ((window_center != 0) && (window_width == 0))\n          window_width=(size_t) window_center;\n        option=GetImageOption(image_info,\"dcm:display-range\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"reset\") == 0)\n              window_width=0;\n          }\n        (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (samples_per_pixel == 1)\n              {\n                int\n                  pixel_value;\n\n                if (bytes_per_pixel == 1)\n                  pixel_value=polarity != MagickFalse ?\n                    ((int) max_value-ReadDCMByte(stream_info,image)) :\n                    ReadDCMByte(stream_info,image);\n                else\n                  if ((bits_allocated != 12) || (significant_bits != 12))\n                    {\n                      if (signed_data)\n                        pixel_value=ReadDCMSignedShort(stream_info,image);\n                      else\n                        pixel_value=ReadDCMShort(stream_info,image);\n                      if (polarity != MagickFalse)\n                        pixel_value=(int)max_value-pixel_value;\n                    }\n                  else\n                    {\n                      if ((i & 0x01) != 0)\n                        pixel_value=(ReadDCMByte(stream_info,image) << 8) |\n                          byte;\n                      else\n                        {\n                          pixel_value=ReadDCMSignedShort(stream_info,image);\n                          byte=(int) (pixel_value & 0x0f);\n                          pixel_value>>=4;\n                        }\n                      i++;\n                    }\n                index=(pixel_value*rescale_slope)+rescale_intercept;\n                if (window_width == 0)\n                  {\n                    if (signed_data == 1)\n                      index-=32767;\n                  }\n                else\n                  {\n                    ssize_t\n                      window_max,\n                      window_min;\n\n                    window_min=(ssize_t) ceil((double) window_center-\n                      (window_width-1.0)/2.0-0.5);\n                    window_max=(ssize_t) floor((double) window_center+\n                      (window_width-1.0)/2.0+0.5);\n                    if ((ssize_t)index <= window_min)\n                      index=0;\n                    else\n                      if ((ssize_t)index > window_max)\n                        index=(int) max_value;\n                      else\n                        index=(int) (max_value*(((index-window_center-\n                          0.5)/(window_width-1))+0.5));\n                  }\n                index&=mask;\n                index=(int) ConstrainColormapIndex(image,(size_t) index,\n                  exception);\n                SetPixelIndex(image,(Quantum) index,q);\n                pixel.red=(unsigned int) image->colormap[index].red;\n                pixel.green=(unsigned int) image->colormap[index].green;\n                pixel.blue=(unsigned int) image->colormap[index].blue;\n              }\n            else\n              {\n                if (bytes_per_pixel == 1)\n                  {\n                    pixel.red=(unsigned int) ReadDCMByte(stream_info,image);\n                    pixel.green=(unsigned int) ReadDCMByte(stream_info,image);\n                    pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);\n                  }\n                else\n                  {\n                    pixel.red=ReadDCMShort(stream_info,image);\n                    pixel.green=ReadDCMShort(stream_info,image);\n                    pixel.blue=ReadDCMShort(stream_info,image);\n                  }\n                pixel.red&=mask;\n                pixel.green&=mask;\n                 pixel.blue&=mask;\n                 if (scale != (Quantum *) NULL)\n                   {\n                    pixel.red=scale[pixel.red];\n                    pixel.green=scale[pixel.green];\n                    pixel.blue=scale[pixel.blue];\n                   }\n               }\n             SetPixelRed(image,(Quantum) pixel.red,q);\n            SetPixelGreen(image,(Quantum) pixel.green,q);\n            SetPixelBlue(image,(Quantum) pixel.blue,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (stream_info->segment_count > 1)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (samples_per_pixel == 1)\n                {\n                  int\n                    pixel_value;\n\n                  if (bytes_per_pixel == 1)\n                    pixel_value=polarity != MagickFalse ?\n                      ((int) max_value-ReadDCMByte(stream_info,image)) :\n                      ReadDCMByte(stream_info,image);\n                  else\n                    if ((bits_allocated != 12) || (significant_bits != 12))\n                      {\n                        pixel_value=(int) (polarity != MagickFalse ?\n                          (max_value-ReadDCMShort(stream_info,image)) :\n                          ReadDCMShort(stream_info,image));\n                        if (signed_data == 1)\n                          pixel_value=((signed short) pixel_value);\n                      }\n                    else\n                      {\n                        if ((i & 0x01) != 0)\n                          pixel_value=(ReadDCMByte(stream_info,image) << 8) |\n                            byte;\n                        else\n                          {\n                            pixel_value=ReadDCMShort(stream_info,image);\n                            byte=(int) (pixel_value & 0x0f);\n                            pixel_value>>=4;\n                          }\n                        i++;\n                      }\n                  index=(pixel_value*rescale_slope)+rescale_intercept;\n                  if (window_width == 0)\n                    {\n                      if (signed_data == 1)\n                        index-=32767;\n                    }\n                  else\n                    {\n                      ssize_t\n                        window_max,\n                        window_min;\n\n                      window_min=(ssize_t) ceil((double) window_center-\n                        (window_width-1.0)/2.0-0.5);\n                      window_max=(ssize_t) floor((double) window_center+\n                        (window_width-1.0)/2.0+0.5);\n                      if ((ssize_t)index <= window_min)\n                        index=0;\n                      else\n                        if ((ssize_t)index > window_max)\n                          index=(int) max_value;\n                        else\n                          index=(int) (max_value*(((index-window_center-\n                            0.5)/(window_width-1))+0.5));\n                    }\n                  index&=mask;\n                  index=(int) ConstrainColormapIndex(image,(size_t) index,\n                    exception);\n                  SetPixelIndex(image,(Quantum) (((size_t)\n                    GetPixelIndex(image,q)) | (((size_t) index) << 8)),q);\n                  pixel.red=(unsigned int) image->colormap[index].red;\n                  pixel.green=(unsigned int) image->colormap[index].green;\n                  pixel.blue=(unsigned int) image->colormap[index].blue;\n                }\n              else\n                {\n                  if (bytes_per_pixel == 1)\n                    {\n                      pixel.red=(unsigned int) ReadDCMByte(stream_info,image);\n                      pixel.green=(unsigned int) ReadDCMByte(stream_info,image);\n                      pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);\n                    }\n                  else\n                    {\n                      pixel.red=ReadDCMShort(stream_info,image);\n                      pixel.green=ReadDCMShort(stream_info,image);\n                      pixel.blue=ReadDCMShort(stream_info,image);\n                    }\n                  pixel.red&=mask;\n                  pixel.green&=mask;\n                  pixel.blue&=mask;\n                  if (scale != (Quantum *) NULL)\n                    {\n                      pixel.red=scale[pixel.red];\n                      pixel.green=scale[pixel.green];\n                      pixel.blue=scale[pixel.blue];\n                    }\n                }\n              SetPixelRed(image,(Quantum) (((size_t) GetPixelRed(image,q)) |\n                (((size_t) pixel.red) << 8)),q);\n              SetPixelGreen(image,(Quantum) (((size_t) GetPixelGreen(image,q)) |\n                (((size_t) pixel.green) << 8)),q);\n              SetPixelBlue(image,(Quantum) (((size_t) GetPixelBlue(image,q)) |\n                (((size_t) pixel.blue) << 8)),q);\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n      }\n    if (SetImageGray(image,exception) != MagickFalse)\n      (void) SetImageColorspace(image,GRAYColorspace,exception);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (scene < (ssize_t) (number_scenes-1))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  /*\n    Free resources.\n  */\n  if (stream_info->offsets != (ssize_t *) NULL)\n    stream_info->offsets=(ssize_t *)\n      RelinquishMagickMemory(stream_info->offsets);\n  stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (scale != (Quantum *) NULL)\n    scale=(Quantum *) RelinquishMagickMemory(scale);\n  if (graymap != (int *) NULL)\n    graymap=(int *) RelinquishMagickMemory(graymap);\n  if (bluemap != (int *) NULL)\n    bluemap=(int *) RelinquishMagickMemory(bluemap);\n  if (greenmap != (int *) NULL)\n    greenmap=(int *) RelinquishMagickMemory(greenmap);\n  if (redmap != (int *) NULL)\n    redmap=(int *) RelinquishMagickMemory(redmap);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142101,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    explicit_vr[MagickPathExtent],\n    implicit_vr[MagickPathExtent],\n    magick[MagickPathExtent],\n    photometric[MagickPathExtent];\n\n  DCMStreamInfo\n    *stream_info;\n\n  Image\n    *image;\n\n  int\n    *bluemap,\n    datum,\n    *greenmap,\n    *graymap,\n    index,\n    *redmap;\n\n  MagickBooleanType\n    explicit_file,\n    explicit_retry,\n    polarity,\n    sequence,\n    use_explicit;\n\n  MagickOffsetType\n    offset;\n\n  Quantum\n    *scale;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_allocated,\n    bytes_per_pixel,\n    colors,\n    depth,\n    height,\n    length,\n    mask,\n    max_value,\n    number_scenes,\n    quantum,\n    samples_per_pixel,\n    signed_data,\n    significant_bits,\n    status,\n    width,\n    window_width;\n\n  ssize_t\n    count,\n    rescale_intercept,\n    rescale_slope,\n    scene,\n    window_center,\n    y;\n\n  unsigned char\n    *data;\n\n  unsigned short\n    group,\n    element;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=8UL;\n  image->endian=LSBEndian;\n  /*\n    Read DCM preamble.\n  */\n  stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));\n  if (stream_info == (DCMStreamInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(stream_info,0,sizeof(*stream_info));\n  count=ReadBlob(image,128,(unsigned char *) magick);\n  if (count != 128)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  if ((count != 4) || (LocaleNCompare(magick,\"DICM\",4) != 0))\n    {\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  /*\n    Read DCM Medical image.\n  */\n  (void) CopyMagickString(photometric,\"MONOCHROME1 \",MagickPathExtent);\n  bits_allocated=8;\n  bytes_per_pixel=1;\n  polarity=MagickFalse;\n  data=(unsigned char *) NULL;\n  depth=8;\n  element=0;\n  explicit_vr[2]='\\0';\n  explicit_file=MagickFalse;\n  colors=0;\n  redmap=(int *) NULL;\n  greenmap=(int *) NULL;\n  bluemap=(int *) NULL;\n  graymap=(int *) NULL;\n  height=0;\n  max_value=255UL;\n  mask=0xffff;\n  number_scenes=1;\n  rescale_intercept=0;\n  rescale_slope=1;\n  samples_per_pixel=1;\n  scale=(Quantum *) NULL;\n  sequence=MagickFalse;\n  signed_data=(~0UL);\n  significant_bits=0;\n  use_explicit=MagickFalse;\n  explicit_retry = MagickFalse;\n  width=0;\n  window_center=0;\n  window_width=0;\n  for (group=0; (group != 0x7FE0) || (element != 0x0010) ||\n                (sequence != MagickFalse); )\n  {\n    /*\n      Read a group.\n    */\n    image->offset=(ssize_t) TellBlob(image);\n    group=ReadBlobLSBShort(image);\n    element=ReadBlobLSBShort(image);\n    if ((group != 0x0002) && (image->endian == MSBEndian))\n      {\n        group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));\n        element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));\n      }\n    quantum=0;\n    /*\n      Find corresponding VR for this group and element.\n    */\n    for (i=0; dicom_info[i].group < 0xffff; i++)\n      if ((group == dicom_info[i].group) && (element == dicom_info[i].element))\n        break;\n    (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);\n    count=ReadBlob(image,2,(unsigned char *) explicit_vr);\n    if (count != 2)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    /*\n      Check for \"explicitness\", but meta-file headers always explicit.\n    */\n    if ((explicit_file == MagickFalse) && (group != 0x0002))\n      explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&\n        (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?\n        MagickTrue : MagickFalse;\n    use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||\n      (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;\n    if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,\"xs\",2) == 0))\n      (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);\n    if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,\"!!\",2) == 0))\n      {\n        offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        quantum=4;\n      }\n    else\n      {\n        /*\n          Assume explicit type.\n        */\n        quantum=2;\n        if ((strncmp(explicit_vr,\"OB\",2) == 0) ||\n            (strncmp(explicit_vr,\"UN\",2) == 0) ||\n            (strncmp(explicit_vr,\"OW\",2) == 0) ||\n            (strncmp(explicit_vr,\"SQ\",2) == 0))\n          {\n            (void) ReadBlobLSBShort(image);\n            quantum=4;\n          }\n      }\n    datum=0;\n    if (quantum == 4)\n      {\n        if (group == 0x0002)\n          datum=ReadBlobLSBSignedLong(image);\n        else\n          datum=ReadBlobSignedLong(image);\n      }\n    else\n      if (quantum == 2)\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedShort(image);\n          else\n            datum=ReadBlobSignedShort(image);\n        }\n    quantum=0;\n    length=1;\n    if (datum != 0)\n      {\n        if ((strncmp(implicit_vr,\"SS\",2) == 0) ||\n            (strncmp(implicit_vr,\"US\",2) == 0))\n          quantum=2;\n        else\n          if ((strncmp(implicit_vr,\"UL\",2) == 0) ||\n              (strncmp(implicit_vr,\"SL\",2) == 0) ||\n              (strncmp(implicit_vr,\"FL\",2) == 0))\n            quantum=4;\n          else\n            if (strncmp(implicit_vr,\"FD\",2) != 0)\n              quantum=1;\n            else\n              quantum=8;\n        if (datum != ~0)\n          length=(size_t) datum/quantum;\n        else\n          {\n            /*\n              Sequence and item of undefined length.\n            */\n            quantum=0;\n            length=0;\n          }\n      }\n    if (image_info->verbose != MagickFalse)\n      {\n        /*\n          Display Dicom info.\n        */\n        if (use_explicit == MagickFalse)\n          explicit_vr[0]='\\0';\n        for (i=0; dicom_info[i].description != (char *) NULL; i++)\n          if ((group == dicom_info[i].group) &&\n              (element == dicom_info[i].element))\n            break;\n        (void) FormatLocaleFile(stdout,\"0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)\",\n          (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,\n          (unsigned long) group,(unsigned long) element);\n        if (dicom_info[i].description != (char *) NULL)\n          (void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);\n        (void) FormatLocaleFile(stdout,\": \");\n      }\n    if ((sequence == MagickFalse) && (group == 0x7FE0) && (element == 0x0010))\n      {\n        if (image_info->verbose != MagickFalse)\n          (void) FormatLocaleFile(stdout,\"\\n\");\n        break;\n      }\n    /*\n      Allocate space and read an array.\n    */\n    data=(unsigned char *) NULL;\n    if ((length == 1) && (quantum == 1))\n      datum=ReadBlobByte(image);\n    else\n      if ((length == 1) && (quantum == 2))\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedShort(image);\n          else\n            datum=ReadBlobSignedShort(image);\n        }\n      else\n        if ((length == 1) && (quantum == 4))\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedLong(image);\n            else\n              datum=ReadBlobSignedLong(image);\n          }\n        else\n          if ((quantum != 0) && (length != 0))\n            {\n              if (~length >= 1)\n                data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*\n                  sizeof(*data));\n              if (data == (unsigned char *) NULL)\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              count=ReadBlob(image,(size_t) quantum*length,data);\n              if (count != (ssize_t) (quantum*length))\n                {\n                  if (image_info->verbose != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"\n                      \"length=%d group=%d\\n\",(int) count,(int) quantum,(int)\n                      length,(int) group);\n                   ThrowReaderException(CorruptImageError,\n                     \"InsufficientImageDataInFile\");\n                }\n              data[length*quantum]='\\0';\n            }\n          else\n            if ((unsigned int) datum == 0xFFFFFFFFU)\n              {\n                sequence=MagickTrue;\n                continue;\n              }\n\n    if ((unsigned int) ((group << 16) | element) == 0xFFFEE0DD)\n      {\n        if (data != (unsigned char *) NULL)\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        sequence=MagickFalse;\n        continue;\n      }\n\n    if (sequence != MagickFalse)\n      {\n        if (data != (unsigned char *) NULL)\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        continue;\n      }\n\n    switch (group)\n    {\n      case 0x0002:\n      {\n        switch (element)\n        {\n          case 0x0010:\n          {\n            char\n              transfer_syntax[MagickPathExtent];\n\n            /*\n              Transfer Syntax.\n            */\n            if ((datum == 0) && (explicit_retry == MagickFalse))\n              {\n                explicit_retry=MagickTrue;\n                (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);\n                group=0;\n                element=0;\n                if (image_info->verbose != MagickFalse)\n                  (void) FormatLocaleFile(stdout,\n                    \"Corrupted image - trying explicit format\\n\");\n                break;\n              }\n            *transfer_syntax='\\0';\n            if (data != (unsigned char *) NULL)\n              (void) CopyMagickString(transfer_syntax,(char *) data,\n                MagickPathExtent);\n            if (image_info->verbose != MagickFalse)\n              (void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",\n                (const char *) transfer_syntax);\n            if (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)\n              {\n                int\n                  count,\n                  subtype,\n                  type;\n\n                type=1;\n                subtype=0;\n                if (strlen(transfer_syntax) > 17)\n                  {\n                    count=sscanf(transfer_syntax+17,\".%d.%d\",&type,&subtype);\n                    if (count < 1)\n                      ThrowReaderException(CorruptImageError,\n                        \"ImproperImageHeader\");\n                  }\n                switch (type)\n                {\n                  case 1:\n                  {\n                    image->endian=LSBEndian;\n                    break;\n                  }\n                  case 2:\n                  {\n                    image->endian=MSBEndian;\n                    break;\n                  }\n                  case 4:\n                  {\n                    if ((subtype >= 80) && (subtype <= 81))\n                      image->compression=JPEGCompression;\n                    else\n                      if ((subtype >= 90) && (subtype <= 93))\n                        image->compression=JPEG2000Compression;\n                      else\n                        image->compression=JPEGCompression;\n                    break;\n                  }\n                  case 5:\n                  {\n                    image->compression=RLECompression;\n                    break;\n                  }\n                }\n              }\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      case 0x0028:\n      {\n        switch (element)\n        {\n          case 0x0002:\n          {\n            /*\n              Samples per pixel.\n            */\n            samples_per_pixel=(size_t) datum;\n            break;\n          }\n          case 0x0004:\n          {\n             /*\n               Photometric interpretation.\n             */\n            if (data == (unsigned char *) NULL)\n              break;\n             for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)\n               photometric[i]=(char) data[i];\n             photometric[i]='\\0';\n            polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?\n              MagickTrue : MagickFalse;\n            break;\n          }\n          case 0x0006:\n          {\n            /*\n              Planar configuration.\n            */\n            if (datum == 1)\n              image->interlace=PlaneInterlace;\n            break;\n          }\n          case 0x0008:\n          {\n             /*\n               Number of frames.\n             */\n            if (data == (unsigned char *) NULL)\n              break;\n             number_scenes=StringToUnsignedLong((char *) data);\n             break;\n           }\n          case 0x0010:\n          {\n            /*\n              Image rows.\n            */\n            height=(size_t) datum;\n            break;\n          }\n          case 0x0011:\n          {\n            /*\n              Image columns.\n            */\n            width=(size_t) datum;\n            break;\n          }\n          case 0x0100:\n          {\n            /*\n              Bits allocated.\n            */\n            bits_allocated=(size_t) datum;\n            bytes_per_pixel=1;\n            if (datum > 8)\n              bytes_per_pixel=2;\n            depth=bits_allocated;\n            if (depth > 32)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            max_value=(1UL << bits_allocated)-1;\n            break;\n          }\n          case 0x0101:\n          {\n            /*\n              Bits stored.\n            */\n            significant_bits=(size_t) datum;\n            bytes_per_pixel=1;\n            if (significant_bits > 8)\n              bytes_per_pixel=2;\n            depth=significant_bits;\n            if (depth > 32)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            max_value=(1UL << significant_bits)-1;\n            mask=(size_t) GetQuantumRange(significant_bits);\n            break;\n          }\n          case 0x0102:\n          {\n            /*\n              High bit.\n            */\n            break;\n          }\n          case 0x0103:\n          {\n            /*\n              Pixel representation.\n            */\n            signed_data=(size_t) datum;\n            break;\n          }\n          case 0x1050:\n          {\n            /*\n              Visible pixel range: center.\n            */\n            if (data != (unsigned char *) NULL)\n              window_center=(ssize_t) StringToLong((char *) data);\n            break;\n          }\n          case 0x1051:\n          {\n            /*\n              Visible pixel range: width.\n            */\n            if (data != (unsigned char *) NULL)\n              window_width=StringToUnsignedLong((char *) data);\n            break;\n          }\n          case 0x1052:\n          {\n            /*\n              Rescale intercept\n            */\n            if (data != (unsigned char *) NULL)\n              rescale_intercept=(ssize_t) StringToLong((char *) data);\n            break;\n          }\n          case 0x1053:\n          {\n            /*\n              Rescale slope\n            */\n            if (data != (unsigned char *) NULL)\n              rescale_slope=(ssize_t) StringToLong((char *) data);\n            break;\n          }\n          case 0x1200:\n          case 0x3006:\n          {\n            /*\n              Populate graymap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/bytes_per_pixel);\n            datum=(int) colors;\n            graymap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*graymap));\n            if (graymap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            for (i=0; i < (ssize_t) colors; i++)\n              if (bytes_per_pixel == 1)\n                graymap[i]=(int) data[i];\n              else\n                graymap[i]=(int) ((short *) data)[i];\n            break;\n          }\n          case 0x1201:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate redmap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            redmap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*redmap));\n            if (redmap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              redmap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          case 0x1202:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate greenmap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            greenmap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*greenmap));\n            if (greenmap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              greenmap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          case 0x1203:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate bluemap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            bluemap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*bluemap));\n            if (bluemap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              bluemap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      case 0x2050:\n      {\n        switch (element)\n        {\n          case 0x0020:\n          {\n            if ((data != (unsigned char *) NULL) &&\n                (strncmp((char *) data,\"INVERSE\",7) == 0))\n              polarity=MagickTrue;\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      default:\n        break;\n    }\n    if (data != (unsigned char *) NULL)\n      {\n        char\n          *attribute;\n\n        for (i=0; dicom_info[i].description != (char *) NULL; i++)\n          if ((group == dicom_info[i].group) &&\n              (element == dicom_info[i].element))\n            break;\n        if (dicom_info[i].description != (char *) NULL)\n          {\n            attribute=AcquireString(\"dcm:\");\n            (void) ConcatenateString(&attribute,dicom_info[i].description);\n            for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n              if (isprint((int) data[i]) == MagickFalse)\n                break;\n            if ((i == (ssize_t) length) || (length > 4))\n              {\n                (void) SubstituteString(&attribute,\" \",\"\");\n                (void) SetImageProperty(image,attribute,(char *) data,exception);\n              }\n            attribute=DestroyString(attribute);\n          }\n      }\n    if (image_info->verbose != MagickFalse)\n      {\n        if (data == (unsigned char *) NULL)\n          (void) FormatLocaleFile(stdout,\"%d\\n\",datum);\n        else\n          {\n            /*\n              Display group data.\n            */\n            for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n              if (isprint((int) data[i]) == MagickFalse)\n                break;\n            if ((i != (ssize_t) length) && (length <= 4))\n              {\n                ssize_t\n                  j;\n\n                datum=0;\n                for (j=(ssize_t) length-1; j >= 0; j--)\n                  datum=(256*datum+data[j]);\n                (void) FormatLocaleFile(stdout,\"%d\",datum);\n              }\n            else\n              for (i=0; i < (ssize_t) length; i++)\n                if (isprint((int) data[i]) != MagickFalse)\n                  (void) FormatLocaleFile(stdout,\"%c\",data[i]);\n                else\n                  (void) FormatLocaleFile(stdout,\"%c\",'.');\n            (void) FormatLocaleFile(stdout,\"\\n\");\n          }\n      }\n    if (data != (unsigned char *) NULL)\n      data=(unsigned char *) RelinquishMagickMemory(data);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n  }\n  if ((width == 0) || (height == 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  image->columns=(size_t) width;\n  image->rows=(size_t) height;\n  if (signed_data == 0xffff)\n    signed_data=(size_t) (significant_bits == 16 ? 1 : 0);\n  if ((image->compression == JPEGCompression) ||\n      (image->compression == JPEG2000Compression))\n    {\n      Image\n        *images;\n\n      ImageInfo\n        *read_info;\n\n      int\n        c;\n\n      size_t\n        length;\n\n      unsigned int\n        tag;\n\n      /*\n        Read offset table.\n      */\n      for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        (void) ReadBlobByte(image);\n      tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n      (void) tag;\n      length=(size_t) ReadBlobLSBLong(image);\n      stream_info->offset_count=length >> 2;\n      if (stream_info->offset_count != 0)\n        {\n          MagickOffsetType\n            offset;\n\n          stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n            stream_info->offset_count,sizeof(*stream_info->offsets));\n          if (stream_info->offsets == (ssize_t *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          offset=TellBlob(image);\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]+=offset;\n        }\n      /*\n        Handle non-native image formats.\n      */\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      images=NewImageList();\n      for (scene=0; scene < (ssize_t) number_scenes; scene++)\n      {\n        char\n          filename[MagickPathExtent];\n\n        const char\n          *property;\n\n        FILE\n          *file;\n\n        Image\n          *jpeg_image;\n\n        int\n          unique_file;\n\n        unsigned int\n          tag;\n\n        tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n        length=(size_t) ReadBlobLSBLong(image);\n        if (tag == 0xFFFEE0DD)\n          break; /* sequence delimiter tag */\n        if (tag != 0xFFFEE000)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if (file == (FILE *) NULL)\n          {\n            (void) RelinquishUniqueFileResource(filename);\n            ThrowFileException(exception,FileOpenError,\n              \"UnableToCreateTemporaryFile\",filename);\n            break;\n          }\n        for ( ; length != 0; length--)\n        {\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          (void) fputc(c,file);\n        }\n        (void) fclose(file);\n        (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n          \"jpeg:%s\",filename);\n        if (image->compression == JPEG2000Compression)\n          (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n            \"j2k:%s\",filename);\n        jpeg_image=ReadImage(read_info,exception);\n        if (jpeg_image != (Image *) NULL)\n          {\n            ResetImagePropertyIterator(image);\n            property=GetNextImageProperty(image);\n            while (property != (const char *) NULL)\n            {\n              (void) SetImageProperty(jpeg_image,property,\n                GetImageProperty(image,property,exception),exception);\n              property=GetNextImageProperty(image);\n            }\n            AppendImageToList(&images,jpeg_image);\n          }\n        (void) RelinquishUniqueFileResource(filename);\n      }\n      read_info=DestroyImageInfo(read_info);\n      image=DestroyImage(image);\n      return(GetFirstImageInList(images));\n    }\n  if (depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))\n    {\n      QuantumAny\n        range;\n\n      size_t\n        length;\n\n      /*\n        Compute pixel scaling table.\n      */\n      length=(size_t) (GetQuantumRange(depth)+1);\n      scale=(Quantum *) AcquireQuantumMemory(length,sizeof(*scale));\n       if (scale == (Quantum *) NULL)\n         ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n       range=GetQuantumRange(depth);\n      for (i=0; i <= (ssize_t) GetQuantumRange(depth); i++)\n         scale[i]=ScaleAnyToQuantum((size_t) i,range);\n     }\n   if (image->compression == RLECompression)\n    {\n      size_t\n        length;\n\n      unsigned int\n        tag;\n\n      /*\n        Read RLE offset table.\n      */\n      for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        (void) ReadBlobByte(image);\n      tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n      (void) tag;\n      length=(size_t) ReadBlobLSBLong(image);\n      stream_info->offset_count=length >> 2;\n      if (stream_info->offset_count != 0)\n        {\n          MagickOffsetType\n            offset;\n\n          stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n            stream_info->offset_count,sizeof(*stream_info->offsets));\n          if (stream_info->offsets == (ssize_t *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          offset=TellBlob(image);\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]+=offset;\n        }\n    }\n  for (scene=0; scene < (ssize_t) number_scenes; scene++)\n  {\n    if (image_info->ping != MagickFalse)\n      break;\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=depth;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      break;\n    image->colorspace=RGBColorspace;\n    if ((image->colormap == (PixelInfo *) NULL) && (samples_per_pixel == 1))\n      {\n        size_t\n          one;\n\n        one=1;\n        if (colors == 0)\n          colors=one << depth;\n        if (AcquireImageColormap(image,one << depth,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (redmap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=redmap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].red=(MagickRealType) index;\n          }\n        if (greenmap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=greenmap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].green=(MagickRealType) index;\n          }\n        if (bluemap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=bluemap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].blue=(MagickRealType) index;\n          }\n        if (graymap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=graymap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].red=(MagickRealType) index;\n            image->colormap[i].green=(MagickRealType) index;\n            image->colormap[i].blue=(MagickRealType) index;\n          }\n      }\n    if (image->compression == RLECompression)\n      {\n        unsigned int\n          tag;\n\n        /*\n          Read RLE segment table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          (void) ReadBlobByte(image);\n        tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n        stream_info->remaining=(size_t) ReadBlobLSBLong(image);\n        if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||\n            (EOFBlob(image) != MagickFalse))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        stream_info->count=0;\n        stream_info->segment_count=ReadBlobLSBLong(image);\n        if (stream_info->segment_count > 1)\n          {\n            bytes_per_pixel=1;\n            depth=8;\n          }\n        for (i=0; i < 15; i++)\n          stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n        stream_info->remaining-=64;\n      }\n    if ((samples_per_pixel > 1) && (image->interlace == PlaneInterlace))\n      {\n        /*\n          Convert Planar RGB DCM Medical image to pixel packets.\n        */\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              switch ((int) i)\n              {\n                case 0:\n                {\n                  SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 1:\n                {\n                  SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 2:\n                {\n                  SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 3:\n                {\n                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                default:\n                  break;\n              }\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      }\n    else\n      {\n        const char\n          *option;\n\n        int\n          byte;\n\n        PixelPacket\n          pixel;\n\n        /*\n          Convert DCM Medical image to pixel packets.\n        */\n        byte=0;\n        i=0;\n        if ((window_center != 0) && (window_width == 0))\n          window_width=(size_t) window_center;\n        option=GetImageOption(image_info,\"dcm:display-range\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"reset\") == 0)\n              window_width=0;\n          }\n        (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (samples_per_pixel == 1)\n              {\n                int\n                  pixel_value;\n\n                if (bytes_per_pixel == 1)\n                  pixel_value=polarity != MagickFalse ?\n                    ((int) max_value-ReadDCMByte(stream_info,image)) :\n                    ReadDCMByte(stream_info,image);\n                else\n                  if ((bits_allocated != 12) || (significant_bits != 12))\n                    {\n                      if (signed_data)\n                        pixel_value=ReadDCMSignedShort(stream_info,image);\n                      else\n                        pixel_value=ReadDCMShort(stream_info,image);\n                      if (polarity != MagickFalse)\n                        pixel_value=(int)max_value-pixel_value;\n                    }\n                  else\n                    {\n                      if ((i & 0x01) != 0)\n                        pixel_value=(ReadDCMByte(stream_info,image) << 8) |\n                          byte;\n                      else\n                        {\n                          pixel_value=ReadDCMSignedShort(stream_info,image);\n                          byte=(int) (pixel_value & 0x0f);\n                          pixel_value>>=4;\n                        }\n                      i++;\n                    }\n                index=(pixel_value*rescale_slope)+rescale_intercept;\n                if (window_width == 0)\n                  {\n                    if (signed_data == 1)\n                      index-=32767;\n                  }\n                else\n                  {\n                    ssize_t\n                      window_max,\n                      window_min;\n\n                    window_min=(ssize_t) ceil((double) window_center-\n                      (window_width-1.0)/2.0-0.5);\n                    window_max=(ssize_t) floor((double) window_center+\n                      (window_width-1.0)/2.0+0.5);\n                    if ((ssize_t)index <= window_min)\n                      index=0;\n                    else\n                      if ((ssize_t)index > window_max)\n                        index=(int) max_value;\n                      else\n                        index=(int) (max_value*(((index-window_center-\n                          0.5)/(window_width-1))+0.5));\n                  }\n                index&=mask;\n                index=(int) ConstrainColormapIndex(image,(size_t) index,\n                  exception);\n                SetPixelIndex(image,(Quantum) index,q);\n                pixel.red=(unsigned int) image->colormap[index].red;\n                pixel.green=(unsigned int) image->colormap[index].green;\n                pixel.blue=(unsigned int) image->colormap[index].blue;\n              }\n            else\n              {\n                if (bytes_per_pixel == 1)\n                  {\n                    pixel.red=(unsigned int) ReadDCMByte(stream_info,image);\n                    pixel.green=(unsigned int) ReadDCMByte(stream_info,image);\n                    pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);\n                  }\n                else\n                  {\n                    pixel.red=ReadDCMShort(stream_info,image);\n                    pixel.green=ReadDCMShort(stream_info,image);\n                    pixel.blue=ReadDCMShort(stream_info,image);\n                  }\n                pixel.red&=mask;\n                pixel.green&=mask;\n                 pixel.blue&=mask;\n                 if (scale != (Quantum *) NULL)\n                   {\n                    if (pixel.red <= GetQuantumRange(depth))\n                      pixel.red=scale[pixel.red];\n                    if (pixel.green <= GetQuantumRange(depth))\n                      pixel.green=scale[pixel.green];\n                    if (pixel.blue <= GetQuantumRange(depth))\n                      pixel.blue=scale[pixel.blue];\n                   }\n               }\n             SetPixelRed(image,(Quantum) pixel.red,q);\n            SetPixelGreen(image,(Quantum) pixel.green,q);\n            SetPixelBlue(image,(Quantum) pixel.blue,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (stream_info->segment_count > 1)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (samples_per_pixel == 1)\n                {\n                  int\n                    pixel_value;\n\n                  if (bytes_per_pixel == 1)\n                    pixel_value=polarity != MagickFalse ?\n                      ((int) max_value-ReadDCMByte(stream_info,image)) :\n                      ReadDCMByte(stream_info,image);\n                  else\n                    if ((bits_allocated != 12) || (significant_bits != 12))\n                      {\n                        pixel_value=(int) (polarity != MagickFalse ?\n                          (max_value-ReadDCMShort(stream_info,image)) :\n                          ReadDCMShort(stream_info,image));\n                        if (signed_data == 1)\n                          pixel_value=((signed short) pixel_value);\n                      }\n                    else\n                      {\n                        if ((i & 0x01) != 0)\n                          pixel_value=(ReadDCMByte(stream_info,image) << 8) |\n                            byte;\n                        else\n                          {\n                            pixel_value=ReadDCMShort(stream_info,image);\n                            byte=(int) (pixel_value & 0x0f);\n                            pixel_value>>=4;\n                          }\n                        i++;\n                      }\n                  index=(pixel_value*rescale_slope)+rescale_intercept;\n                  if (window_width == 0)\n                    {\n                      if (signed_data == 1)\n                        index-=32767;\n                    }\n                  else\n                    {\n                      ssize_t\n                        window_max,\n                        window_min;\n\n                      window_min=(ssize_t) ceil((double) window_center-\n                        (window_width-1.0)/2.0-0.5);\n                      window_max=(ssize_t) floor((double) window_center+\n                        (window_width-1.0)/2.0+0.5);\n                      if ((ssize_t)index <= window_min)\n                        index=0;\n                      else\n                        if ((ssize_t)index > window_max)\n                          index=(int) max_value;\n                        else\n                          index=(int) (max_value*(((index-window_center-\n                            0.5)/(window_width-1))+0.5));\n                    }\n                  index&=mask;\n                  index=(int) ConstrainColormapIndex(image,(size_t) index,\n                    exception);\n                  SetPixelIndex(image,(Quantum) (((size_t)\n                    GetPixelIndex(image,q)) | (((size_t) index) << 8)),q);\n                  pixel.red=(unsigned int) image->colormap[index].red;\n                  pixel.green=(unsigned int) image->colormap[index].green;\n                  pixel.blue=(unsigned int) image->colormap[index].blue;\n                }\n              else\n                {\n                  if (bytes_per_pixel == 1)\n                    {\n                      pixel.red=(unsigned int) ReadDCMByte(stream_info,image);\n                      pixel.green=(unsigned int) ReadDCMByte(stream_info,image);\n                      pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);\n                    }\n                  else\n                    {\n                      pixel.red=ReadDCMShort(stream_info,image);\n                      pixel.green=ReadDCMShort(stream_info,image);\n                      pixel.blue=ReadDCMShort(stream_info,image);\n                    }\n                  pixel.red&=mask;\n                  pixel.green&=mask;\n                  pixel.blue&=mask;\n                  if (scale != (Quantum *) NULL)\n                    {\n                      pixel.red=scale[pixel.red];\n                      pixel.green=scale[pixel.green];\n                      pixel.blue=scale[pixel.blue];\n                    }\n                }\n              SetPixelRed(image,(Quantum) (((size_t) GetPixelRed(image,q)) |\n                (((size_t) pixel.red) << 8)),q);\n              SetPixelGreen(image,(Quantum) (((size_t) GetPixelGreen(image,q)) |\n                (((size_t) pixel.green) << 8)),q);\n              SetPixelBlue(image,(Quantum) (((size_t) GetPixelBlue(image,q)) |\n                (((size_t) pixel.blue) << 8)),q);\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n      }\n    if (SetImageGray(image,exception) != MagickFalse)\n      (void) SetImageColorspace(image,GRAYColorspace,exception);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (scene < (ssize_t) (number_scenes-1))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  /*\n    Free resources.\n  */\n  if (stream_info->offsets != (ssize_t *) NULL)\n    stream_info->offsets=(ssize_t *)\n      RelinquishMagickMemory(stream_info->offsets);\n  stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (scale != (Quantum *) NULL)\n    scale=(Quantum *) RelinquishMagickMemory(scale);\n  if (graymap != (int *) NULL)\n    graymap=(int *) RelinquishMagickMemory(graymap);\n  if (bluemap != (int *) NULL)\n    bluemap=(int *) RelinquishMagickMemory(bluemap);\n  if (greenmap != (int *) NULL)\n    greenmap=(int *) RelinquishMagickMemory(greenmap);\n  if (redmap != (int *) NULL)\n    redmap=(int *) RelinquishMagickMemory(redmap);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142102,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "dissect_pktap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n{\n\tproto_tree *pktap_tree = NULL;\n\tproto_item *ti = NULL;\n \ttvbuff_t *next_tvb;\n \tint offset = 0;\n \tguint32 pkt_len, rectype, dlt;\n \n \tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"PKTAP\");\n \tcol_clear(pinfo->cinfo, COL_INFO);\n\n\tpkt_len = tvb_get_letohl(tvb, offset);\n\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"PKTAP, %u byte header\", pkt_len);\n\n\t/* Dissect the packet */\n\tti = proto_tree_add_item(tree, proto_pktap, tvb, offset, pkt_len, ENC_NA);\n\tpktap_tree = proto_item_add_subtree(ti, ett_pktap);\n\n\tproto_tree_add_item(pktap_tree, hf_pktap_hdrlen, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\tif (pkt_len < MIN_PKTAP_HDR_LEN) {\n\t\tproto_tree_add_expert(tree, pinfo, &ei_pktap_hdrlen_too_short,\n\t\t    tvb, offset, 4);\n\t\treturn;\n\t}\n\toffset += 4;\n\n\tproto_tree_add_item(pktap_tree, hf_pktap_rectype, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\trectype = tvb_get_letohl(tvb, offset);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_dlt, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\tdlt = tvb_get_letohl(tvb, offset);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_ifname, tvb, offset, 24,\n\t    ENC_ASCII|ENC_NA);\n\toffset += 24;\n\tproto_tree_add_item(pktap_tree, hf_pktap_flags, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_pfamily, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_llhdrlen, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_lltrlrlen, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_pid, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_cmdname, tvb, offset, 20,\n\t    ENC_UTF_8|ENC_NA);\n\toffset += 20;\n\tproto_tree_add_item(pktap_tree, hf_pktap_svc_class, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_iftype, tvb, offset, 2,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 2;\n\tproto_tree_add_item(pktap_tree, hf_pktap_ifunit, tvb, offset, 2,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 2;\n\tproto_tree_add_item(pktap_tree, hf_pktap_epid, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_ecmdname, tvb, offset, 20,\n\t    ENC_UTF_8|ENC_NA);\n\t/*offset += 20;*/\n \n \tif (rectype == PKT_REC_PACKET) {\n \t\tnext_tvb = tvb_new_subset_remaining(tvb, pkt_len);\n\t\tdissector_try_uint(wtap_encap_dissector_table,\n\t\t    wtap_pcap_encap_to_wtap_encap(dlt), next_tvb, pinfo, tree);\n \t}\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142105,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "dissect_pktap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n{\n\tproto_tree *pktap_tree = NULL;\n\tproto_item *ti = NULL;\n \ttvbuff_t *next_tvb;\n \tint offset = 0;\n \tguint32 pkt_len, rectype, dlt;\n\tint wtap_encap;\n\tstruct eth_phdr eth;\n\tvoid *phdr;\n \n \tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"PKTAP\");\n \tcol_clear(pinfo->cinfo, COL_INFO);\n\n\tpkt_len = tvb_get_letohl(tvb, offset);\n\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"PKTAP, %u byte header\", pkt_len);\n\n\t/* Dissect the packet */\n\tti = proto_tree_add_item(tree, proto_pktap, tvb, offset, pkt_len, ENC_NA);\n\tpktap_tree = proto_item_add_subtree(ti, ett_pktap);\n\n\tproto_tree_add_item(pktap_tree, hf_pktap_hdrlen, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\tif (pkt_len < MIN_PKTAP_HDR_LEN) {\n\t\tproto_tree_add_expert(tree, pinfo, &ei_pktap_hdrlen_too_short,\n\t\t    tvb, offset, 4);\n\t\treturn;\n\t}\n\toffset += 4;\n\n\tproto_tree_add_item(pktap_tree, hf_pktap_rectype, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\trectype = tvb_get_letohl(tvb, offset);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_dlt, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\tdlt = tvb_get_letohl(tvb, offset);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_ifname, tvb, offset, 24,\n\t    ENC_ASCII|ENC_NA);\n\toffset += 24;\n\tproto_tree_add_item(pktap_tree, hf_pktap_flags, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_pfamily, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_llhdrlen, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_lltrlrlen, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_pid, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_cmdname, tvb, offset, 20,\n\t    ENC_UTF_8|ENC_NA);\n\toffset += 20;\n\tproto_tree_add_item(pktap_tree, hf_pktap_svc_class, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_iftype, tvb, offset, 2,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 2;\n\tproto_tree_add_item(pktap_tree, hf_pktap_ifunit, tvb, offset, 2,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 2;\n\tproto_tree_add_item(pktap_tree, hf_pktap_epid, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_ecmdname, tvb, offset, 20,\n\t    ENC_UTF_8|ENC_NA);\n\t/*offset += 20;*/\n \n \tif (rectype == PKT_REC_PACKET) {\n \t\tnext_tvb = tvb_new_subset_remaining(tvb, pkt_len);\n\t\twtap_encap = wtap_pcap_encap_to_wtap_encap(dlt);\n\t\tswitch (wtap_encap) {\n\n\t\tcase WTAP_ENCAP_ETHERNET:\n\t\t\teth.fcs_len = -1;    /* Unknown whether we have an FCS */\n\t\t\tphdr = &eth;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphdr = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tdissector_try_uint_new(wtap_encap_dissector_table,\n\t\t    wtap_encap, next_tvb, pinfo, tree, TRUE, phdr);\n \t}\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142106,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n    int *err, gchar **err_info)\n{\n \tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n \tchar\tline[TOSHIBA_LINE_LENGTH];\n \tint\tnum_items_scanned;\n\tguint\tpkt_len;\n\tint\tpktnum, hr, min, sec, csec;\n \tchar\tchannel[10], direction[10];\n \tint\ti, hex_lines;\n \tguint8\t*pd;\n\n\t/* Our file pointer should be on the line containing the\n\t * summary information for a packet. Read in that line and\n\t * extract the useful information\n\t */\n\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t*err = file_error(fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/* Find text in line after \"[No.\". Limit the length of the\n\t * two strings since we have fixed buffers for channel[] and\n\t * direction[] */\n\tnum_items_scanned = sscanf(line, \"%9d] %2d:%2d:%2d.%9d %9s %9s\",\n\t\t\t&pktnum, &hr, &min, &sec, &csec, channel, direction);\n\n\tif (num_items_scanned != 7) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: record header isn't valid\");\n\t\treturn FALSE;\n\t}\n\n\t/* Scan lines until we find the OFFSET line. In a \"telnet\" trace,\n\t * this will be the next line. But if you save your telnet session\n\t * to a file from within a Windows-based telnet client, it may\n\t * put in line breaks at 80 columns (or however big your \"telnet\" box\n\t * is). CRT (a Windows telnet app from VanDyke) does this.\n\t * Here we assume that 80 columns will be the minimum size, and that\n\t * the OFFSET line is not broken in the middle. It's the previous\n\t * line that is normally long and can thus be broken at column 80.\n\t */\n\tdo {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/* Check for \"OFFSET 0001-0203\" at beginning of line */\n\t\tline[16] = '\\0';\n \n \t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\n \n\tnum_items_scanned = sscanf(line+64, \"LEN=%9u\", &pkt_len);\n \tif (num_items_scanned != 1) {\n \t\t*err = WTAP_ERR_BAD_FILE;\n \t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\n \t\treturn FALSE;\n \t}\n \tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n \t\t/*\n \t\t * Probably a corrupt capture file; don't blow up trying\n\t\t * to allocate space for an immensely-large packet.\n\t\t */\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"toshiba: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n\t\treturn FALSE;\n\t}\n\n\tphdr->rec_type = REC_TYPE_PACKET;\n\tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\tphdr->ts.secs = hr * 3600 + min * 60 + sec;\n\tphdr->ts.nsecs = csec * 10000000;\n\tphdr->caplen = pkt_len;\n\tphdr->len = pkt_len;\n\n\tswitch (channel[0]) {\n\t\tcase 'B':\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ISDN;\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\n\t\t\tpseudo_header->isdn.channel = (guint8)\n\t\t\t    strtol(&channel[1], NULL, 10);\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ISDN;\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\n\t\t\tpseudo_header->isdn.channel = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\t\t\t/* XXX - is there an FCS in the frame? */\n\t\t\tpseudo_header->eth.fcs_len = -1;\n\t\t\tbreak;\n\t}\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(buf, pkt_len);\n\tpd = ws_buffer_start_ptr(buf);\n\n\t/* Calculate the number of hex dump lines, each\n\t * containing 16 bytes of data */\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\n\n\tfor (i = 0; i < hex_lines; i++) {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (!parse_single_hex_dump_line(line, pd, i * 16)) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"toshiba: hex dump not valid\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142109,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n    int *err, gchar **err_info)\n{\n \tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n \tchar\tline[TOSHIBA_LINE_LENGTH];\n \tint\tnum_items_scanned;\n\tint\tpkt_len, pktnum, hr, min, sec, csec;\n \tchar\tchannel[10], direction[10];\n \tint\ti, hex_lines;\n \tguint8\t*pd;\n\n\t/* Our file pointer should be on the line containing the\n\t * summary information for a packet. Read in that line and\n\t * extract the useful information\n\t */\n\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t*err = file_error(fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/* Find text in line after \"[No.\". Limit the length of the\n\t * two strings since we have fixed buffers for channel[] and\n\t * direction[] */\n\tnum_items_scanned = sscanf(line, \"%9d] %2d:%2d:%2d.%9d %9s %9s\",\n\t\t\t&pktnum, &hr, &min, &sec, &csec, channel, direction);\n\n\tif (num_items_scanned != 7) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: record header isn't valid\");\n\t\treturn FALSE;\n\t}\n\n\t/* Scan lines until we find the OFFSET line. In a \"telnet\" trace,\n\t * this will be the next line. But if you save your telnet session\n\t * to a file from within a Windows-based telnet client, it may\n\t * put in line breaks at 80 columns (or however big your \"telnet\" box\n\t * is). CRT (a Windows telnet app from VanDyke) does this.\n\t * Here we assume that 80 columns will be the minimum size, and that\n\t * the OFFSET line is not broken in the middle. It's the previous\n\t * line that is normally long and can thus be broken at column 80.\n\t */\n\tdo {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/* Check for \"OFFSET 0001-0203\" at beginning of line */\n\t\tline[16] = '\\0';\n \n \t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\n \n\tnum_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);\n \tif (num_items_scanned != 1) {\n \t\t*err = WTAP_ERR_BAD_FILE;\n \t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\n \t\treturn FALSE;\n \t}\n\tif (pkt_len < 0) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: packet header has a negative packet length\");\n\t\treturn FALSE;\n\t}\n \tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n \t\t/*\n \t\t * Probably a corrupt capture file; don't blow up trying\n\t\t * to allocate space for an immensely-large packet.\n\t\t */\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"toshiba: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n\t\treturn FALSE;\n\t}\n\n\tphdr->rec_type = REC_TYPE_PACKET;\n\tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\tphdr->ts.secs = hr * 3600 + min * 60 + sec;\n\tphdr->ts.nsecs = csec * 10000000;\n\tphdr->caplen = pkt_len;\n\tphdr->len = pkt_len;\n\n\tswitch (channel[0]) {\n\t\tcase 'B':\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ISDN;\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\n\t\t\tpseudo_header->isdn.channel = (guint8)\n\t\t\t    strtol(&channel[1], NULL, 10);\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ISDN;\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\n\t\t\tpseudo_header->isdn.channel = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\t\t\t/* XXX - is there an FCS in the frame? */\n\t\t\tpseudo_header->eth.fcs_len = -1;\n\t\t\tbreak;\n\t}\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(buf, pkt_len);\n\tpd = ws_buffer_start_ptr(buf);\n\n\t/* Calculate the number of hex dump lines, each\n\t * containing 16 bytes of data */\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\n\n\tfor (i = 0; i < hex_lines; i++) {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (!parse_single_hex_dump_line(line, pd, i * 16)) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"toshiba: hex dump not valid\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142110,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "fp_set_per_packet_inf_from_conv(umts_fp_conversation_info_t *p_conv_data,\n                                tvbuff_t *tvb, packet_info *pinfo,\n                                proto_tree *tree _U_)\n{\n    fp_info  *fpi;\n    guint8    tfi, c_t;\n    int       offset = 0, i=0, j=0, num_tbs, chan, tb_size, tb_bit_off;\n    gboolean  is_control_frame;\n    umts_mac_info *macinf;\n    rlc_info *rlcinf;\n    guint8 fake_lchid=0;\n    gint *cur_val=NULL;\n\n    fpi = wmem_new0(wmem_file_scope(), fp_info);\n    p_add_proto_data(wmem_file_scope(), pinfo, proto_fp, 0, fpi);\n\n    fpi->iface_type = p_conv_data->iface_type;\n    fpi->division = p_conv_data->division;\n    fpi->release = 7;               /* Set values greater then the checks performed */\n    fpi->release_year = 2006;\n    fpi->release_month = 12;\n    fpi->channel = p_conv_data->channel;\n    fpi->dch_crc_present = p_conv_data->dch_crc_present;\n    /*fpi->paging_indications;*/\n    fpi->link_type = FP_Link_Ethernet;\n\n#if 0\n    /*Only do this the first run, signals that we need to reset the RLC fragtable*/\n    if (!pinfo->fd->flags.visited &&  p_conv_data->reset_frag ) {\n        fpi->reset_frag = p_conv_data->reset_frag;\n        p_conv_data->reset_frag = FALSE;\n    }\n#endif\n    /* remember 'lower' UDP layer port information so we can later\n     * differentiate 'lower' UDP layer from 'user data' UDP layer */\n    fpi->srcport = pinfo->srcport;\n    fpi->destport = pinfo->destport;\n\n    fpi->com_context_id = p_conv_data->com_context_id;\n\n    if (pinfo->link_dir == P2P_DIR_UL) {\n        fpi->is_uplink = TRUE;\n    } else {\n        fpi->is_uplink = FALSE;\n    }\n\n    is_control_frame = tvb_get_guint8(tvb, offset) & 0x01;\n\n    switch (fpi->channel) {\n        case CHANNEL_HSDSCH: /* HS-DSCH - High Speed Downlink Shared Channel */\n            fpi->hsdsch_entity = p_conv_data->hsdsch_entity;\n            macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            fpi->hsdsch_macflowd_id = p_conv_data->hsdsch_macdflow_id;\n           macinf->content[0] = hsdsch_macdflow_id_mac_content_map[p_conv_data->hsdsch_macdflow_id]; /*MAC_CONTENT_PS_DTCH;*/\n            macinf->lchid[0] = p_conv_data->hsdsch_macdflow_id;\n            /*macinf->content[0] = lchId_type_table[p_conv_data->edch_lchId[0]];*/\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n\n            rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n\n            /*Figure out RLC_MODE based on MACd-flow-ID, basically MACd-flow-ID = 0 then it's SRB0 == UM else AM*/\n            rlcinf->mode[0] = hsdsch_macdflow_id_rlc_map[p_conv_data->hsdsch_macdflow_id];\n\n            if (fpi->hsdsch_entity == hs /*&& !rlc_is_ciphered(pinfo)*/) {\n                for (i=0; i<MAX_NUM_HSDHSCH_MACDFLOW; i++) {\n                    /*Figure out if this channel is multiplexed (signaled from RRC)*/\n                    if ((cur_val=(gint *)g_tree_lookup(hsdsch_muxed_flows, GINT_TO_POINTER((gint)p_conv_data->hrnti))) != NULL) {\n                        j = 1 << i;\n                        fpi->hsdhsch_macfdlow_is_mux[i] = j & *cur_val;\n                    } else {\n                        fpi->hsdhsch_macfdlow_is_mux[i] = FALSE;\n                    }\n\n                }\n            }\n            /* Make configurable ?(available in NBAP?) */\n            /* urnti[MAX_RLC_CHANS] */\n            /*\n            switch (p_conv_data->rlc_mode) {\n                case FP_RLC_TM:\n                    rlcinf->mode[0] = RLC_TM;\n                    break;\n                case FP_RLC_UM:\n                    rlcinf->mode[0] = RLC_UM;\n                    break;\n                case FP_RLC_AM:\n                    rlcinf->mode[0] = RLC_AM;\n                    break;\n                case FP_RLC_MODE_UNKNOWN:\n                default:\n                    rlcinf->mode[0] = RLC_UNKNOWN_MODE;\n                    break;\n            }*/\n            /* rbid[MAX_RLC_CHANS] */\n            /* For RLC re-assembly to work we urnti signaled from NBAP */\n            rlcinf->urnti[0] = fpi->com_context_id;\n            rlcinf->li_size[0] = RLC_LI_7BITS;\n            rlcinf->ciphered[0] = FALSE;\n            rlcinf->deciphered[0] = FALSE;\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf);\n\n\n            return fpi;\n\n        case CHANNEL_EDCH:\n            /*Most configuration is now done in the actual dissecting function*/\n            macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n            fpi->no_ddi_entries = p_conv_data->no_ddi_entries;\n            for (i=0; i<fpi->no_ddi_entries; i++) {\n                fpi->edch_ddi[i] = p_conv_data->edch_ddi[i];    /*Set the DDI value*/\n                fpi->edch_macd_pdu_size[i] = p_conv_data->edch_macd_pdu_size[i];    /*Set the size*/\n                fpi->edch_lchId[i] = p_conv_data->edch_lchId[i];    /*Set the channel id for this entry*/\n                /*macinf->content[i] = lchId_type_table[p_conv_data->edch_lchId[i]]; */    /*Set the proper Content type for the mac layer.*/\n            /*    rlcinf->mode[i] = lchId_rlc_map[p_conv_data->edch_lchId[i]];*/ /* Set RLC mode by lchid to RLC_MODE map in nbap.h */\n\n            }\n            fpi->edch_type = p_conv_data->edch_type;\n\n           /* macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            macinf->content[0] = MAC_CONTENT_PS_DTCH;*/\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n\n\n            /* For RLC re-assembly to work we need a urnti signaled from NBAP */\n            rlcinf->urnti[0] = fpi->com_context_id;\n           /* rlcinf->mode[0] = RLC_AM;*/\n            rlcinf->li_size[0] = RLC_LI_7BITS;\n            rlcinf->ciphered[0] = FALSE;\n            rlcinf->deciphered[0] = FALSE;\n\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf);\n\n            return fpi;\n\n        case CHANNEL_PCH:\n            fpi->paging_indications = p_conv_data->paging_indications;\n            fpi->num_chans = p_conv_data->num_dch_in_flow;\n            /* Set offset to point to first TFI\n             */\n            if (is_control_frame) {\n                /* control frame, we're done */\n                return fpi;\n            }\n            /* Set offset to TFI */\n            offset = 3;\n            break;\n        case CHANNEL_DCH:\n            fpi->num_chans = p_conv_data->num_dch_in_flow;\n            if (is_control_frame) {\n                /* control frame, we're done */\n                return fpi;\n            }\n\n            rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n            macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            offset = 2;    /*To correctly read the tfi*/\n            fakes  = 5; /* Reset fake counter. */\n            for (chan=0; chan < fpi->num_chans; chan++) {    /*Iterate over the what channels*/\n                    /*Iterate over the transport blocks*/\n                   /*tfi = tvb_get_guint8(tvb, offset);*/\n                   /*TFI is 5 bits according to 3GPP TS 25.321, paragraph 6.2.4.4*/\n                    tfi = tvb_get_bits8(tvb, 3+offset*8, 5);\n\n                   /*Figure out the number of tbs and size*/\n                   num_tbs = (fpi->is_uplink) ? p_conv_data->fp_dch_channel_info[chan].ul_chan_num_tbs[tfi] : p_conv_data->fp_dch_channel_info[chan].dl_chan_num_tbs[tfi];\n                   tb_size=  (fpi->is_uplink) ? p_conv_data->fp_dch_channel_info[i].ul_chan_tf_size[tfi] :    p_conv_data->fp_dch_channel_info[i].dl_chan_tf_size[tfi];\n\n                    /*TODO: This stuff has to be reworked!*/\n                    /*Generates a fake logical channel id for non multiplexed channel*/\n                    if ( p_conv_data->dchs_in_flow_list[chan] != 31 && (p_conv_data->dchs_in_flow_list[chan] == 24 &&\n                     tb_size != 340) ) {\n                        fake_lchid = make_fake_lchid(pinfo, p_conv_data->dchs_in_flow_list[chan]);\n                    }\n                    tb_bit_off = (2+p_conv_data->num_dch_in_flow)*8;    /*Point to the C/T of first TB*/\n                    /*Set configuration for individual blocks*/\n                    for (j=0; j < num_tbs && j+chan < MAX_MAC_FRAMES; j++) {\n                        /*Set transport channel id (useful for debugging)*/\n                        macinf->trchid[j+chan] = p_conv_data->dchs_in_flow_list[chan];\n\n                        /*Transport Channel m31 and 24 might be multiplexed!*/\n                        if ( p_conv_data->dchs_in_flow_list[chan] == 31 || p_conv_data->dchs_in_flow_list[chan] == 24) {\n\n                            /****** MUST FIGURE OUT IF THIS IS REALLY MULTIPLEXED OR NOT*******/\n                            /*If Trchid == 31 and only on TB, we have no multiplexing*/\n                            if (0/*p_conv_data->dchs_in_flow_list[chan] == 31 && num_tbs == 1*/) {\n                                macinf->ctmux[j+chan] = FALSE;/*Set TRUE if this channel is multiplexed (ie. C/T flag exists)*/\n\n                                macinf->lchid[j+chan] = 1;\n\n                                macinf->content[j+chan] = lchId_type_table[1];    /*Base MAC content on logical channel id (Table is in packet-nbap.h)*/\n                                rlcinf->mode[j+chan] = lchId_rlc_map[1];    /*Based RLC mode on logical channel id*/\n\n                            }\n                            /*Indicate we don't have multiplexing.*/\n                            else if (p_conv_data->dchs_in_flow_list[chan] == 24 && tb_size != 340) {\n                                macinf->ctmux[j+chan] = FALSE;/*Set TRUE if this channel is multiplexed (ie. C/T flag exists)*/\n\n                                /*g_warning(\"settin this for %d\", pinfo->num);*/\n                                macinf->lchid[j+chan] = fake_lchid;\n                                macinf->fake_chid[j+chan] = TRUE;\n                                macinf->content[j+chan] = MAC_CONTENT_PS_DTCH; /*lchId_type_table[fake_lchid];*/    /*Base MAC content on logical channel id (Table is in packet-nbap.h)*/\n                                rlcinf->mode[j+chan] = RLC_AM;/*lchId_rlc_map[fake_lchid];*/    /*Based RLC mode on logical channel id*/\n                            }\n                            /*We have multiplexing*/\n                            else {\n                                macinf->ctmux[j+chan] = TRUE;/*Set TRUE if this channel is multiplexed (ie. C/T flag exists)*/\n \n                                 /* Peek at C/T, different RLC params for different logical channels */\n                                 /*C/T is 4 bits according to 3GPP TS 25.321, paragraph 9.2.1, from MAC header (not FP)*/\n                                c_t = tvb_get_bits8(tvb, tb_bit_off/*(2+p_conv_data->num_dch_in_flow)*8*/, 4);    /* c_t = tvb_get_guint8(tvb, offset);*/\n                                macinf->lchid[j+chan] = c_t+1;\n \n                                macinf->content[j+chan] = lchId_type_table[c_t+1];    /*Base MAC content on logical channel id (Table is in packet-nbap.h)*/\n                                rlcinf->mode[j+chan] = lchId_rlc_map[c_t+1];    /*Based RLC mode on logical channel id*/\n                             }\n                         } else {\n                             fake_lchid = make_fake_lchid(pinfo, p_conv_data->dchs_in_flow_list[chan]);\n                            macinf->ctmux[j+chan] = FALSE;/*Set TRUE if this channel is multiplexed (ie. C/T flag exists)*/\n                            /*macinf->content[j+chan] = MAC_CONTENT_CS_DTCH;*/\n                            macinf->content[j+chan] = lchId_type_table[fake_lchid];\n\n\n                            rlcinf->mode[j+chan] = lchId_rlc_map[fake_lchid];\n\n                            /*Generate virtual logical channel id*/\n                            /************************/\n                            /*TODO: Once proper lchid is always set, this has to be removed*/\n                            macinf->fake_chid[j+chan] = TRUE;\n                            macinf->lchid[j+chan] = fake_lchid;  /*make_fake_lchid(pinfo, p_conv_data->dchs_in_flow_list[chan]);*/\n                            /************************/\n                        }\n\n                        /*** Set rlc info ***/\n                        rlcinf->urnti[j+chan] = p_conv_data->com_context_id;\n                        rlcinf->li_size[j+chan] = RLC_LI_7BITS;\n#if 0\n                        /*If this entry exists, SECRUITY_MODE is completed (signled by RRC)*/\n                        if ( rrc_ciph_inf && g_tree_lookup(rrc_ciph_inf, GINT_TO_POINTER((gint)p_conv_data->com_context_id)) != NULL ) {\n                            rlcinf->ciphered[j+chan] = TRUE;\n                        } else {\n                            rlcinf->ciphered[j+chan] = FALSE;\n                        }\n#endif\n                        rlcinf->ciphered[j+chan] = FALSE;\n                        rlcinf->deciphered[j+chan] = FALSE;\n                        rlcinf->rbid[j+chan] = macinf->lchid[j+chan];\n\n\n                        /*Step over this TB and it's C/T flag.*/\n                        tb_bit_off += tb_size+4;\n                    }\n\n                    offset++;\n            }\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf);\n            /* Set offset to point to first TFI\n             * the Number of TFI's = number of DCH's in the flow\n             */\n            offset = 2;\n            break;\n        case CHANNEL_FACH_FDD:\n            fpi->num_chans = p_conv_data->num_dch_in_flow;\n            if (is_control_frame) {\n                /* control frame, we're done */\n                return fpi;\n            }\n            /* Set offset to point to first TFI\n             * the Number of TFI's = number of DCH's in the flow\n             */\n            offset = 2;\n            /* Set MAC data */\n            macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            macinf->ctmux[0]   = 1;\n            macinf->content[0] = MAC_CONTENT_DCCH;\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n            /* Set RLC data */\n            rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n            /* Make configurable ?(avaliable in NBAP?) */\n            /* For RLC re-assembly to work we need to fake urnti */\n            rlcinf->urnti[0] = fpi->channel;\n            rlcinf->mode[0] = RLC_AM;\n            /* rbid[MAX_RLC_CHANS] */\n            rlcinf->li_size[0] = RLC_LI_7BITS;\n            rlcinf->ciphered[0] = FALSE;\n            rlcinf->deciphered[0] = FALSE;\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf);\n            break;\n\n        case CHANNEL_RACH_FDD:\n            fpi->num_chans = p_conv_data->num_dch_in_flow;\n            if (is_control_frame) {\n                /* control frame, we're done */\n                return fpi;\n            }\n            /* Set offset to point to first TFI\n             * the Number of TFI's = number of DCH's in the flow\n             */\n            offset = 2;\n            /* set MAC data */\n            macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n            for ( chan = 0; chan < fpi->num_chans; chan++ ) {\n                    macinf->ctmux[chan]   = 1;\n                    macinf->content[chan] = MAC_CONTENT_DCCH;\n                    rlcinf->urnti[chan] = fpi->com_context_id;    /*Note that MAC probably will change this*/\n            }\n\n\n\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf);\n            break;\n        case CHANNEL_HSDSCH_COMMON:\n                rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n                macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n                p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n                p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf);\n            break;\n        default:\n            expert_add_info(pinfo, NULL, &ei_fp_transport_channel_type_unknown);\n            return NULL;\n    }\n\n    /* Peek at the packet as the per packet info seems not to take the tfi into account */\n    for (i=0; i<fpi->num_chans; i++) {\n        tfi = tvb_get_guint8(tvb, offset);\n\n        /*TFI is 5 bits according to 3GPP TS 25.321, paragraph 6.2.4.4*/\n        /*tfi = tvb_get_bits8(tvb, offset*8, 5);*/\n        if (pinfo->link_dir == P2P_DIR_UL) {\n            fpi->chan_tf_size[i] = p_conv_data->fp_dch_channel_info[i].ul_chan_tf_size[tfi];\n            fpi->chan_num_tbs[i] = p_conv_data->fp_dch_channel_info[i].ul_chan_num_tbs[tfi];\n        } else {\n            fpi->chan_tf_size[i] = p_conv_data->fp_dch_channel_info[i].dl_chan_tf_size[tfi];\n            fpi->chan_num_tbs[i] = p_conv_data->fp_dch_channel_info[i].dl_chan_num_tbs[tfi];\n        }\n        offset++;\n    }\n\n\n    return fpi;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142111,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "fp_set_per_packet_inf_from_conv(umts_fp_conversation_info_t *p_conv_data,\n                                tvbuff_t *tvb, packet_info *pinfo,\n                                proto_tree *tree _U_)\n{\n    fp_info  *fpi;\n    guint8    tfi, c_t;\n    int       offset = 0, i=0, j=0, num_tbs, chan, tb_size, tb_bit_off;\n    gboolean  is_control_frame;\n    umts_mac_info *macinf;\n    rlc_info *rlcinf;\n    guint8 fake_lchid=0;\n    gint *cur_val=NULL;\n\n    fpi = wmem_new0(wmem_file_scope(), fp_info);\n    p_add_proto_data(wmem_file_scope(), pinfo, proto_fp, 0, fpi);\n\n    fpi->iface_type = p_conv_data->iface_type;\n    fpi->division = p_conv_data->division;\n    fpi->release = 7;               /* Set values greater then the checks performed */\n    fpi->release_year = 2006;\n    fpi->release_month = 12;\n    fpi->channel = p_conv_data->channel;\n    fpi->dch_crc_present = p_conv_data->dch_crc_present;\n    /*fpi->paging_indications;*/\n    fpi->link_type = FP_Link_Ethernet;\n\n#if 0\n    /*Only do this the first run, signals that we need to reset the RLC fragtable*/\n    if (!pinfo->fd->flags.visited &&  p_conv_data->reset_frag ) {\n        fpi->reset_frag = p_conv_data->reset_frag;\n        p_conv_data->reset_frag = FALSE;\n    }\n#endif\n    /* remember 'lower' UDP layer port information so we can later\n     * differentiate 'lower' UDP layer from 'user data' UDP layer */\n    fpi->srcport = pinfo->srcport;\n    fpi->destport = pinfo->destport;\n\n    fpi->com_context_id = p_conv_data->com_context_id;\n\n    if (pinfo->link_dir == P2P_DIR_UL) {\n        fpi->is_uplink = TRUE;\n    } else {\n        fpi->is_uplink = FALSE;\n    }\n\n    is_control_frame = tvb_get_guint8(tvb, offset) & 0x01;\n\n    switch (fpi->channel) {\n        case CHANNEL_HSDSCH: /* HS-DSCH - High Speed Downlink Shared Channel */\n            fpi->hsdsch_entity = p_conv_data->hsdsch_entity;\n            macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            fpi->hsdsch_macflowd_id = p_conv_data->hsdsch_macdflow_id;\n           macinf->content[0] = hsdsch_macdflow_id_mac_content_map[p_conv_data->hsdsch_macdflow_id]; /*MAC_CONTENT_PS_DTCH;*/\n            macinf->lchid[0] = p_conv_data->hsdsch_macdflow_id;\n            /*macinf->content[0] = lchId_type_table[p_conv_data->edch_lchId[0]];*/\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n\n            rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n\n            /*Figure out RLC_MODE based on MACd-flow-ID, basically MACd-flow-ID = 0 then it's SRB0 == UM else AM*/\n            rlcinf->mode[0] = hsdsch_macdflow_id_rlc_map[p_conv_data->hsdsch_macdflow_id];\n\n            if (fpi->hsdsch_entity == hs /*&& !rlc_is_ciphered(pinfo)*/) {\n                for (i=0; i<MAX_NUM_HSDHSCH_MACDFLOW; i++) {\n                    /*Figure out if this channel is multiplexed (signaled from RRC)*/\n                    if ((cur_val=(gint *)g_tree_lookup(hsdsch_muxed_flows, GINT_TO_POINTER((gint)p_conv_data->hrnti))) != NULL) {\n                        j = 1 << i;\n                        fpi->hsdhsch_macfdlow_is_mux[i] = j & *cur_val;\n                    } else {\n                        fpi->hsdhsch_macfdlow_is_mux[i] = FALSE;\n                    }\n\n                }\n            }\n            /* Make configurable ?(available in NBAP?) */\n            /* urnti[MAX_RLC_CHANS] */\n            /*\n            switch (p_conv_data->rlc_mode) {\n                case FP_RLC_TM:\n                    rlcinf->mode[0] = RLC_TM;\n                    break;\n                case FP_RLC_UM:\n                    rlcinf->mode[0] = RLC_UM;\n                    break;\n                case FP_RLC_AM:\n                    rlcinf->mode[0] = RLC_AM;\n                    break;\n                case FP_RLC_MODE_UNKNOWN:\n                default:\n                    rlcinf->mode[0] = RLC_UNKNOWN_MODE;\n                    break;\n            }*/\n            /* rbid[MAX_RLC_CHANS] */\n            /* For RLC re-assembly to work we urnti signaled from NBAP */\n            rlcinf->urnti[0] = fpi->com_context_id;\n            rlcinf->li_size[0] = RLC_LI_7BITS;\n            rlcinf->ciphered[0] = FALSE;\n            rlcinf->deciphered[0] = FALSE;\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf);\n\n\n            return fpi;\n\n        case CHANNEL_EDCH:\n            /*Most configuration is now done in the actual dissecting function*/\n            macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n            fpi->no_ddi_entries = p_conv_data->no_ddi_entries;\n            for (i=0; i<fpi->no_ddi_entries; i++) {\n                fpi->edch_ddi[i] = p_conv_data->edch_ddi[i];    /*Set the DDI value*/\n                fpi->edch_macd_pdu_size[i] = p_conv_data->edch_macd_pdu_size[i];    /*Set the size*/\n                fpi->edch_lchId[i] = p_conv_data->edch_lchId[i];    /*Set the channel id for this entry*/\n                /*macinf->content[i] = lchId_type_table[p_conv_data->edch_lchId[i]]; */    /*Set the proper Content type for the mac layer.*/\n            /*    rlcinf->mode[i] = lchId_rlc_map[p_conv_data->edch_lchId[i]];*/ /* Set RLC mode by lchid to RLC_MODE map in nbap.h */\n\n            }\n            fpi->edch_type = p_conv_data->edch_type;\n\n           /* macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            macinf->content[0] = MAC_CONTENT_PS_DTCH;*/\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n\n\n            /* For RLC re-assembly to work we need a urnti signaled from NBAP */\n            rlcinf->urnti[0] = fpi->com_context_id;\n           /* rlcinf->mode[0] = RLC_AM;*/\n            rlcinf->li_size[0] = RLC_LI_7BITS;\n            rlcinf->ciphered[0] = FALSE;\n            rlcinf->deciphered[0] = FALSE;\n\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf);\n\n            return fpi;\n\n        case CHANNEL_PCH:\n            fpi->paging_indications = p_conv_data->paging_indications;\n            fpi->num_chans = p_conv_data->num_dch_in_flow;\n            /* Set offset to point to first TFI\n             */\n            if (is_control_frame) {\n                /* control frame, we're done */\n                return fpi;\n            }\n            /* Set offset to TFI */\n            offset = 3;\n            break;\n        case CHANNEL_DCH:\n            fpi->num_chans = p_conv_data->num_dch_in_flow;\n            if (is_control_frame) {\n                /* control frame, we're done */\n                return fpi;\n            }\n\n            rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n            macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            offset = 2;    /*To correctly read the tfi*/\n            fakes  = 5; /* Reset fake counter. */\n            for (chan=0; chan < fpi->num_chans; chan++) {    /*Iterate over the what channels*/\n                    /*Iterate over the transport blocks*/\n                   /*tfi = tvb_get_guint8(tvb, offset);*/\n                   /*TFI is 5 bits according to 3GPP TS 25.321, paragraph 6.2.4.4*/\n                    tfi = tvb_get_bits8(tvb, 3+offset*8, 5);\n\n                   /*Figure out the number of tbs and size*/\n                   num_tbs = (fpi->is_uplink) ? p_conv_data->fp_dch_channel_info[chan].ul_chan_num_tbs[tfi] : p_conv_data->fp_dch_channel_info[chan].dl_chan_num_tbs[tfi];\n                   tb_size=  (fpi->is_uplink) ? p_conv_data->fp_dch_channel_info[i].ul_chan_tf_size[tfi] :    p_conv_data->fp_dch_channel_info[i].dl_chan_tf_size[tfi];\n\n                    /*TODO: This stuff has to be reworked!*/\n                    /*Generates a fake logical channel id for non multiplexed channel*/\n                    if ( p_conv_data->dchs_in_flow_list[chan] != 31 && (p_conv_data->dchs_in_flow_list[chan] == 24 &&\n                     tb_size != 340) ) {\n                        fake_lchid = make_fake_lchid(pinfo, p_conv_data->dchs_in_flow_list[chan]);\n                    }\n                    tb_bit_off = (2+p_conv_data->num_dch_in_flow)*8;    /*Point to the C/T of first TB*/\n                    /*Set configuration for individual blocks*/\n                    for (j=0; j < num_tbs && j+chan < MAX_MAC_FRAMES; j++) {\n                        /*Set transport channel id (useful for debugging)*/\n                        macinf->trchid[j+chan] = p_conv_data->dchs_in_flow_list[chan];\n\n                        /*Transport Channel m31 and 24 might be multiplexed!*/\n                        if ( p_conv_data->dchs_in_flow_list[chan] == 31 || p_conv_data->dchs_in_flow_list[chan] == 24) {\n\n                            /****** MUST FIGURE OUT IF THIS IS REALLY MULTIPLEXED OR NOT*******/\n                            /*If Trchid == 31 and only on TB, we have no multiplexing*/\n                            if (0/*p_conv_data->dchs_in_flow_list[chan] == 31 && num_tbs == 1*/) {\n                                macinf->ctmux[j+chan] = FALSE;/*Set TRUE if this channel is multiplexed (ie. C/T flag exists)*/\n\n                                macinf->lchid[j+chan] = 1;\n\n                                macinf->content[j+chan] = lchId_type_table[1];    /*Base MAC content on logical channel id (Table is in packet-nbap.h)*/\n                                rlcinf->mode[j+chan] = lchId_rlc_map[1];    /*Based RLC mode on logical channel id*/\n\n                            }\n                            /*Indicate we don't have multiplexing.*/\n                            else if (p_conv_data->dchs_in_flow_list[chan] == 24 && tb_size != 340) {\n                                macinf->ctmux[j+chan] = FALSE;/*Set TRUE if this channel is multiplexed (ie. C/T flag exists)*/\n\n                                /*g_warning(\"settin this for %d\", pinfo->num);*/\n                                macinf->lchid[j+chan] = fake_lchid;\n                                macinf->fake_chid[j+chan] = TRUE;\n                                macinf->content[j+chan] = MAC_CONTENT_PS_DTCH; /*lchId_type_table[fake_lchid];*/    /*Base MAC content on logical channel id (Table is in packet-nbap.h)*/\n                                rlcinf->mode[j+chan] = RLC_AM;/*lchId_rlc_map[fake_lchid];*/    /*Based RLC mode on logical channel id*/\n                            }\n                            /*We have multiplexing*/\n                            else {\n                                macinf->ctmux[j+chan] = TRUE;/*Set TRUE if this channel is multiplexed (ie. C/T flag exists)*/\n \n                                 /* Peek at C/T, different RLC params for different logical channels */\n                                 /*C/T is 4 bits according to 3GPP TS 25.321, paragraph 9.2.1, from MAC header (not FP)*/\n                                c_t = (tvb_get_bits8(tvb, tb_bit_off/*(2+p_conv_data->num_dch_in_flow)*8*/, 4) + 1) % 0xf;    /* c_t = tvb_get_guint8(tvb, offset);*/\n                                macinf->lchid[j+chan] = c_t;\n \n                                macinf->content[j+chan] = lchId_type_table[c_t];    /*Base MAC content on logical channel id (Table is in packet-nbap.h)*/\n                                rlcinf->mode[j+chan] = lchId_rlc_map[c_t];    /*Based RLC mode on logical channel id*/\n                             }\n                         } else {\n                             fake_lchid = make_fake_lchid(pinfo, p_conv_data->dchs_in_flow_list[chan]);\n                            macinf->ctmux[j+chan] = FALSE;/*Set TRUE if this channel is multiplexed (ie. C/T flag exists)*/\n                            /*macinf->content[j+chan] = MAC_CONTENT_CS_DTCH;*/\n                            macinf->content[j+chan] = lchId_type_table[fake_lchid];\n\n\n                            rlcinf->mode[j+chan] = lchId_rlc_map[fake_lchid];\n\n                            /*Generate virtual logical channel id*/\n                            /************************/\n                            /*TODO: Once proper lchid is always set, this has to be removed*/\n                            macinf->fake_chid[j+chan] = TRUE;\n                            macinf->lchid[j+chan] = fake_lchid;  /*make_fake_lchid(pinfo, p_conv_data->dchs_in_flow_list[chan]);*/\n                            /************************/\n                        }\n\n                        /*** Set rlc info ***/\n                        rlcinf->urnti[j+chan] = p_conv_data->com_context_id;\n                        rlcinf->li_size[j+chan] = RLC_LI_7BITS;\n#if 0\n                        /*If this entry exists, SECRUITY_MODE is completed (signled by RRC)*/\n                        if ( rrc_ciph_inf && g_tree_lookup(rrc_ciph_inf, GINT_TO_POINTER((gint)p_conv_data->com_context_id)) != NULL ) {\n                            rlcinf->ciphered[j+chan] = TRUE;\n                        } else {\n                            rlcinf->ciphered[j+chan] = FALSE;\n                        }\n#endif\n                        rlcinf->ciphered[j+chan] = FALSE;\n                        rlcinf->deciphered[j+chan] = FALSE;\n                        rlcinf->rbid[j+chan] = macinf->lchid[j+chan];\n\n\n                        /*Step over this TB and it's C/T flag.*/\n                        tb_bit_off += tb_size+4;\n                    }\n\n                    offset++;\n            }\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf);\n            /* Set offset to point to first TFI\n             * the Number of TFI's = number of DCH's in the flow\n             */\n            offset = 2;\n            break;\n        case CHANNEL_FACH_FDD:\n            fpi->num_chans = p_conv_data->num_dch_in_flow;\n            if (is_control_frame) {\n                /* control frame, we're done */\n                return fpi;\n            }\n            /* Set offset to point to first TFI\n             * the Number of TFI's = number of DCH's in the flow\n             */\n            offset = 2;\n            /* Set MAC data */\n            macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            macinf->ctmux[0]   = 1;\n            macinf->content[0] = MAC_CONTENT_DCCH;\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n            /* Set RLC data */\n            rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n            /* Make configurable ?(avaliable in NBAP?) */\n            /* For RLC re-assembly to work we need to fake urnti */\n            rlcinf->urnti[0] = fpi->channel;\n            rlcinf->mode[0] = RLC_AM;\n            /* rbid[MAX_RLC_CHANS] */\n            rlcinf->li_size[0] = RLC_LI_7BITS;\n            rlcinf->ciphered[0] = FALSE;\n            rlcinf->deciphered[0] = FALSE;\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf);\n            break;\n\n        case CHANNEL_RACH_FDD:\n            fpi->num_chans = p_conv_data->num_dch_in_flow;\n            if (is_control_frame) {\n                /* control frame, we're done */\n                return fpi;\n            }\n            /* Set offset to point to first TFI\n             * the Number of TFI's = number of DCH's in the flow\n             */\n            offset = 2;\n            /* set MAC data */\n            macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n            for ( chan = 0; chan < fpi->num_chans; chan++ ) {\n                    macinf->ctmux[chan]   = 1;\n                    macinf->content[chan] = MAC_CONTENT_DCCH;\n                    rlcinf->urnti[chan] = fpi->com_context_id;    /*Note that MAC probably will change this*/\n            }\n\n\n\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf);\n            break;\n        case CHANNEL_HSDSCH_COMMON:\n                rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n                macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n                p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n                p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf);\n            break;\n        default:\n            expert_add_info(pinfo, NULL, &ei_fp_transport_channel_type_unknown);\n            return NULL;\n    }\n\n    /* Peek at the packet as the per packet info seems not to take the tfi into account */\n    for (i=0; i<fpi->num_chans; i++) {\n        tfi = tvb_get_guint8(tvb, offset);\n\n        /*TFI is 5 bits according to 3GPP TS 25.321, paragraph 6.2.4.4*/\n        /*tfi = tvb_get_bits8(tvb, offset*8, 5);*/\n        if (pinfo->link_dir == P2P_DIR_UL) {\n            fpi->chan_tf_size[i] = p_conv_data->fp_dch_channel_info[i].ul_chan_tf_size[tfi];\n            fpi->chan_num_tbs[i] = p_conv_data->fp_dch_channel_info[i].ul_chan_num_tbs[tfi];\n        } else {\n            fpi->chan_tf_size[i] = p_conv_data->fp_dch_channel_info[i].dl_chan_tf_size[tfi];\n            fpi->chan_num_tbs[i] = p_conv_data->fp_dch_channel_info[i].dl_chan_num_tbs[tfi];\n        }\n        offset++;\n    }\n\n\n    return fpi;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142112,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static INT AirPDcapScanForKeys(\n    PAIRPDCAP_CONTEXT ctx,\n    const guint8 *data,\n    const guint mac_header_len,\n    const guint tot_len,\n    AIRPDCAP_SEC_ASSOCIATION_ID id\n)\n{\n    const UCHAR *addr;\n    guint bodyLength;\n    PAIRPDCAP_SEC_ASSOCIATION sta_sa;\n    PAIRPDCAP_SEC_ASSOCIATION sa;\n    guint offset = 0;\n    const guint8 dot1x_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\n        0x88, 0x8E        /* Type: 802.1X authentication */\n    };\n    const guint8 bt_dot1x_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x19, 0x58, /* Org. code=Bluetooth SIG */\n        0x00, 0x03        /* Type: Bluetooth Security */\n    };\n    const guint8 tdls_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\n        0x89, 0x0D,       /* Type: 802.11 - Fast Roaming Remote Request */\n        0x02,             /* Payload Type: TDLS */\n        0X0C              /* Action Category: TDLS */\n    };\n\n    const EAPOL_RSN_KEY *pEAPKey;\n#ifdef _DEBUG\n#define MSGBUF_LEN 255\n    CHAR msgbuf[MSGBUF_LEN];\n#endif\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapScanForKeys\");\n\n    /* cache offset in the packet data */\n    offset = mac_header_len;\n\n    /* check if the packet has an LLC header and the packet is 802.1X authentication (IEEE 802.1X-2004, pg. 24) */\n    if (memcmp(data+offset, dot1x_header, 8) == 0 || memcmp(data+offset, bt_dot1x_header, 8) == 0) {\n\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* skip LLC header */\n        offset+=8;\n\n        /* check if the packet is a EAPOL-Key (0x03) (IEEE 802.1X-2004, pg. 25) */\n        if (data[offset+1]!=3) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not EAPOL-Key\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n \n         /* get and check the body length (IEEE 802.1X-2004, pg. 25) */\n         bodyLength=pntoh16(data+offset+2);\n        if ((tot_len-offset-4) < bodyLength) { /* Only check if frame is long enough for eapol header, ignore tailing garbage, see bug 9065 */\n             AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"EAPOL body too short\", AIRPDCAP_DEBUG_LEVEL_3);\n             return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n         }\n\n        /* skip EAPOL MPDU and go to the first byte of the body */\n        offset+=4;\n\n        pEAPKey = (const EAPOL_RSN_KEY *) (data+offset);\n\n        /* check if the key descriptor type is valid (IEEE 802.1X-2004, pg. 27) */\n        if (/*pEAPKey->type!=0x1 &&*/ /* RC4 Key Descriptor Type (deprecated) */\n            pEAPKey->type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR &&             /* IEEE 802.11 Key Descriptor Type  (WPA2) */\n            pEAPKey->type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR)           /* 254 = RSN_KEY_DESCRIPTOR - WPA,              */\n        {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not valid key descriptor type\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* start with descriptor body */\n        offset+=1;\n\n        /* search for a cached Security Association for current BSSID and AP */\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"No SA for BSSID found\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* It could be a Pairwise Key exchange, check */\n        if (AirPDcapRsna4WHandshake(ctx, data, sa, offset, tot_len) == AIRPDCAP_RET_SUCCESS_HANDSHAKE)\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n\n        if (mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Message too short for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* Verify the bitfields: Key = 0(groupwise) Mic = 1 Ack = 1 Secure = 1 */\n        if (AIRPDCAP_EAP_KEY(data[offset+1])!=0 ||\n            AIRPDCAP_EAP_ACK(data[offset+1])!=1 ||\n            AIRPDCAP_EAP_MIC(data[offset]) != 1 ||\n            AIRPDCAP_EAP_SEC(data[offset]) != 1){\n\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Key bitfields not correct for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* force STA address to be the broadcast MAC so we create an SA for the groupkey */\n        memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\n\n        /* get the Security Association structure for the broadcast MAC and AP */\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* Get the SA for the STA, since we need its pairwise key to decrpyt the group key */\n\n        /* get STA address */\n        if ( (addr=AirPDcapGetStaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data))) != NULL) {\n            memcpy(id.sta, addr, AIRPDCAP_MAC_LEN);\n#ifdef _DEBUG\n            g_snprintf(msgbuf, MSGBUF_LEN, \"ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\\t\", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);\n#endif\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\n        } else {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"SA not found\", AIRPDCAP_DEBUG_LEVEL_5);\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        sta_sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sta_sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* Try to extract the group key and install it in the SA */\n        return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sta_sa->wpa.ptk+16, sa, tot_len-offset+1));\n\n    } else if (memcmp(data+offset, tdls_header, 10) == 0) {\n        const guint8 *initiator, *responder;\n        guint8 action;\n        guint status, offset_rsne = 0, offset_fte = 0, offset_link = 0, offset_timeout = 0;\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: TDLS Action Frame\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* skip LLC header */\n        offset+=10;\n\n        /* check if the packet is a TDLS response or confirm */\n        action = data[offset];\n        if (action!=1 && action!=2) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not Response nor confirm\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* check status */\n        offset++;\n        status=pntoh16(data+offset);\n        if (status!=0) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"TDLS setup not successfull\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* skip Token + capabilities */\n        offset+=5;\n\n        /* search for RSN, Fast BSS Transition, Link Identifier and Timeout Interval IEs */\n\n        while(offset < (tot_len - 2)) {\n            if (data[offset] == 48) {\n                offset_rsne = offset;\n            } else if (data[offset] == 55) {\n                offset_fte = offset;\n            } else if (data[offset] == 56) {\n                offset_timeout = offset;\n            } else if (data[offset] == 101) {\n                offset_link = offset;\n            }\n\n            if (tot_len < offset + data[offset + 1] + 2) {\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n            }\n            offset += data[offset + 1] + 2;\n        }\n\n        if (offset_rsne == 0 || offset_fte == 0 ||\n            offset_timeout == 0 || offset_link == 0)\n        {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Cannot Find all necessary IEs\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Found RSNE/Fast BSS/Timeout Interval/Link IEs\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* Will create a Security Association between 2 STA. Need to get both MAC address */\n        initiator = &data[offset_link + 8];\n        responder = &data[offset_link + 14];\n\n        if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {\n            memcpy(id.sta, initiator, AIRPDCAP_MAC_LEN);\n            memcpy(id.bssid, responder, AIRPDCAP_MAC_LEN);\n        } else {\n            memcpy(id.sta, responder, AIRPDCAP_MAC_LEN);\n            memcpy(id.bssid, initiator, AIRPDCAP_MAC_LEN);\n        }\n\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        if (sa->validKey) {\n            if (memcmp(sa->wpa.nonce, data + offset_fte + 52, AIRPDCAP_WPA_NONCE_LEN) == 0) {\n                /* Already have valid key for this SA, no need to redo key derivation */\n                return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n            } else {\n                /* We are opening a new session with the same two STA, save previous sa  */\n                AIRPDCAP_SEC_ASSOCIATION *tmp_sa = g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\n                memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\n                sa->next=tmp_sa;\n                sa->validKey = FALSE;\n            }\n        }\n\n        if (AirPDcapTDLSDeriveKey(sa, data, offset_rsne, offset_fte, offset_timeout, offset_link, action)\n            == AIRPDCAP_RET_SUCCESS) {\n            AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n        }\n    } else {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Skipping: not an EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\n    }\n\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142113,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static INT AirPDcapScanForKeys(\n    PAIRPDCAP_CONTEXT ctx,\n    const guint8 *data,\n    const guint mac_header_len,\n    const guint tot_len,\n    AIRPDCAP_SEC_ASSOCIATION_ID id\n)\n{\n    const UCHAR *addr;\n    guint bodyLength;\n    PAIRPDCAP_SEC_ASSOCIATION sta_sa;\n    PAIRPDCAP_SEC_ASSOCIATION sa;\n    guint offset = 0;\n    const guint8 dot1x_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\n        0x88, 0x8E        /* Type: 802.1X authentication */\n    };\n    const guint8 bt_dot1x_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x19, 0x58, /* Org. code=Bluetooth SIG */\n        0x00, 0x03        /* Type: Bluetooth Security */\n    };\n    const guint8 tdls_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\n        0x89, 0x0D,       /* Type: 802.11 - Fast Roaming Remote Request */\n        0x02,             /* Payload Type: TDLS */\n        0X0C              /* Action Category: TDLS */\n    };\n\n    const EAPOL_RSN_KEY *pEAPKey;\n#ifdef _DEBUG\n#define MSGBUF_LEN 255\n    CHAR msgbuf[MSGBUF_LEN];\n#endif\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapScanForKeys\");\n\n    /* cache offset in the packet data */\n    offset = mac_header_len;\n\n    /* check if the packet has an LLC header and the packet is 802.1X authentication (IEEE 802.1X-2004, pg. 24) */\n    if (memcmp(data+offset, dot1x_header, 8) == 0 || memcmp(data+offset, bt_dot1x_header, 8) == 0) {\n\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* skip LLC header */\n        offset+=8;\n\n        /* check if the packet is a EAPOL-Key (0x03) (IEEE 802.1X-2004, pg. 25) */\n        if (data[offset+1]!=3) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not EAPOL-Key\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n \n         /* get and check the body length (IEEE 802.1X-2004, pg. 25) */\n         bodyLength=pntoh16(data+offset+2);\n        if (((tot_len-offset-4) < bodyLength) || (bodyLength < sizeof(EAPOL_RSN_KEY))) { /* Only check if frame is long enough for eapol header, ignore tailing garbage, see bug 9065 */\n             AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"EAPOL body too short\", AIRPDCAP_DEBUG_LEVEL_3);\n             return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n         }\n\n        /* skip EAPOL MPDU and go to the first byte of the body */\n        offset+=4;\n\n        pEAPKey = (const EAPOL_RSN_KEY *) (data+offset);\n\n        /* check if the key descriptor type is valid (IEEE 802.1X-2004, pg. 27) */\n        if (/*pEAPKey->type!=0x1 &&*/ /* RC4 Key Descriptor Type (deprecated) */\n            pEAPKey->type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR &&             /* IEEE 802.11 Key Descriptor Type  (WPA2) */\n            pEAPKey->type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR)           /* 254 = RSN_KEY_DESCRIPTOR - WPA,              */\n        {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not valid key descriptor type\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* start with descriptor body */\n        offset+=1;\n\n        /* search for a cached Security Association for current BSSID and AP */\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"No SA for BSSID found\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* It could be a Pairwise Key exchange, check */\n        if (AirPDcapRsna4WHandshake(ctx, data, sa, offset, tot_len) == AIRPDCAP_RET_SUCCESS_HANDSHAKE)\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n\n        if (mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Message too short for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* Verify the bitfields: Key = 0(groupwise) Mic = 1 Ack = 1 Secure = 1 */\n        if (AIRPDCAP_EAP_KEY(data[offset+1])!=0 ||\n            AIRPDCAP_EAP_ACK(data[offset+1])!=1 ||\n            AIRPDCAP_EAP_MIC(data[offset]) != 1 ||\n            AIRPDCAP_EAP_SEC(data[offset]) != 1){\n\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Key bitfields not correct for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* force STA address to be the broadcast MAC so we create an SA for the groupkey */\n        memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\n\n        /* get the Security Association structure for the broadcast MAC and AP */\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* Get the SA for the STA, since we need its pairwise key to decrpyt the group key */\n\n        /* get STA address */\n        if ( (addr=AirPDcapGetStaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data))) != NULL) {\n            memcpy(id.sta, addr, AIRPDCAP_MAC_LEN);\n#ifdef _DEBUG\n            g_snprintf(msgbuf, MSGBUF_LEN, \"ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\\t\", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);\n#endif\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\n        } else {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"SA not found\", AIRPDCAP_DEBUG_LEVEL_5);\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        sta_sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sta_sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* Try to extract the group key and install it in the SA */\n        return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sta_sa->wpa.ptk+16, sa, tot_len-offset+1));\n\n    } else if (memcmp(data+offset, tdls_header, 10) == 0) {\n        const guint8 *initiator, *responder;\n        guint8 action;\n        guint status, offset_rsne = 0, offset_fte = 0, offset_link = 0, offset_timeout = 0;\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: TDLS Action Frame\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* skip LLC header */\n        offset+=10;\n\n        /* check if the packet is a TDLS response or confirm */\n        action = data[offset];\n        if (action!=1 && action!=2) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not Response nor confirm\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* check status */\n        offset++;\n        status=pntoh16(data+offset);\n        if (status!=0) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"TDLS setup not successfull\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* skip Token + capabilities */\n        offset+=5;\n\n        /* search for RSN, Fast BSS Transition, Link Identifier and Timeout Interval IEs */\n\n        while(offset < (tot_len - 2)) {\n            if (data[offset] == 48) {\n                offset_rsne = offset;\n            } else if (data[offset] == 55) {\n                offset_fte = offset;\n            } else if (data[offset] == 56) {\n                offset_timeout = offset;\n            } else if (data[offset] == 101) {\n                offset_link = offset;\n            }\n\n            if (tot_len < offset + data[offset + 1] + 2) {\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n            }\n            offset += data[offset + 1] + 2;\n        }\n\n        if (offset_rsne == 0 || offset_fte == 0 ||\n            offset_timeout == 0 || offset_link == 0)\n        {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Cannot Find all necessary IEs\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Found RSNE/Fast BSS/Timeout Interval/Link IEs\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* Will create a Security Association between 2 STA. Need to get both MAC address */\n        initiator = &data[offset_link + 8];\n        responder = &data[offset_link + 14];\n\n        if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {\n            memcpy(id.sta, initiator, AIRPDCAP_MAC_LEN);\n            memcpy(id.bssid, responder, AIRPDCAP_MAC_LEN);\n        } else {\n            memcpy(id.sta, responder, AIRPDCAP_MAC_LEN);\n            memcpy(id.bssid, initiator, AIRPDCAP_MAC_LEN);\n        }\n\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        if (sa->validKey) {\n            if (memcmp(sa->wpa.nonce, data + offset_fte + 52, AIRPDCAP_WPA_NONCE_LEN) == 0) {\n                /* Already have valid key for this SA, no need to redo key derivation */\n                return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n            } else {\n                /* We are opening a new session with the same two STA, save previous sa  */\n                AIRPDCAP_SEC_ASSOCIATION *tmp_sa = g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\n                memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\n                sa->next=tmp_sa;\n                sa->validKey = FALSE;\n            }\n        }\n\n        if (AirPDcapTDLSDeriveKey(sa, data, offset_rsne, offset_fte, offset_timeout, offset_link, action)\n            == AIRPDCAP_RET_SUCCESS) {\n            AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n        }\n    } else {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Skipping: not an EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\n    }\n\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142114,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int _snd_timer_stop(struct snd_timer_instance * timeri,\n\t\t\t   int keep_flag, int event)\n{\n\tstruct snd_timer *timer;\n\tunsigned long flags;\n\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n \t\tif (!keep_flag) {\n \t\t\tspin_lock_irqsave(&slave_active_lock, flags);\n \t\t\ttimeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;\n \t\t\tspin_unlock_irqrestore(&slave_active_lock, flags);\n \t\t}\n \t\tgoto __end;\n\t}\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tlist_del_init(&timeri->ack_list);\n\tlist_del_init(&timeri->active_list);\n\tif ((timeri->flags & SNDRV_TIMER_IFLG_RUNNING) &&\n\t    !(--timer->running)) {\n\t\ttimer->hw.stop(timer);\n\t\tif (timer->flags & SNDRV_TIMER_FLG_RESCHED) {\n\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_RESCHED;\n\t\t\tsnd_timer_reschedule(timer, 0);\n\t\t\tif (timer->flags & SNDRV_TIMER_FLG_CHANGE) {\n\t\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_CHANGE;\n\t\t\t\ttimer->hw.start(timer);\n\t\t\t}\n\t\t}\n\t}\n\tif (!keep_flag)\n\t\ttimeri->flags &=\n\t\t\t~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n      __end:\n\tif (event != SNDRV_TIMER_EVENT_RESOLUTION)\n\t\tsnd_timer_notify1(timeri, event);\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142167,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int _snd_timer_stop(struct snd_timer_instance * timeri,\n\t\t\t   int keep_flag, int event)\n{\n\tstruct snd_timer *timer;\n\tunsigned long flags;\n\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n \t\tif (!keep_flag) {\n \t\t\tspin_lock_irqsave(&slave_active_lock, flags);\n \t\t\ttimeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;\n\t\t\tlist_del_init(&timeri->ack_list);\n\t\t\tlist_del_init(&timeri->active_list);\n \t\t\tspin_unlock_irqrestore(&slave_active_lock, flags);\n \t\t}\n \t\tgoto __end;\n\t}\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tlist_del_init(&timeri->ack_list);\n\tlist_del_init(&timeri->active_list);\n\tif ((timeri->flags & SNDRV_TIMER_IFLG_RUNNING) &&\n\t    !(--timer->running)) {\n\t\ttimer->hw.stop(timer);\n\t\tif (timer->flags & SNDRV_TIMER_FLG_RESCHED) {\n\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_RESCHED;\n\t\t\tsnd_timer_reschedule(timer, 0);\n\t\t\tif (timer->flags & SNDRV_TIMER_FLG_CHANGE) {\n\t\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_CHANGE;\n\t\t\t\ttimer->hw.start(timer);\n\t\t\t}\n\t\t}\n\t}\n\tif (!keep_flag)\n\t\ttimeri->flags &=\n\t\t\t~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n      __end:\n\tif (event != SNDRV_TIMER_EVENT_RESOLUTION)\n\t\tsnd_timer_notify1(timeri, event);\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142168,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int snd_timer_close(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer *timer = NULL;\n\tstruct snd_timer_instance *slave, *tmp;\n\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\n\t/* force to stop the timer */\n\tsnd_timer_stop(timeri);\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&slave_active_lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t}\n\t\tspin_unlock_irq(&slave_active_lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tmutex_unlock(&register_mutex);\n\t} else {\n\t\ttimer = timeri->timer;\n\t\tif (snd_BUG_ON(!timer))\n\t\t\tgoto out;\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&timer->lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&timer->lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&timer->lock);\n\t\t}\n\t\tspin_unlock_irq(&timer->lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tif (timer && list_empty(&timer->open_list_head) &&\n \t\t    timer->hw.close)\n \t\t\ttimer->hw.close(timer);\n \t\t/* remove slave links */\n \t\tlist_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,\n \t\t\t\t\t open_list) {\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t\t_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);\n \t\t\tlist_move_tail(&slave->open_list, &snd_timer_slave_list);\n \t\t\tslave->master = NULL;\n \t\t\tslave->timer = NULL;\n\t\t\tspin_unlock_irq(&slave_active_lock);\n \t\t}\n \t\tmutex_unlock(&register_mutex);\n \t}\n  out:\n\tif (timeri->private_free)\n\t\ttimeri->private_free(timeri);\n\tkfree(timeri->owner);\n\tkfree(timeri);\n\tif (timer)\n\t\tmodule_put(timer->module);\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142169,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int snd_timer_close(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer *timer = NULL;\n\tstruct snd_timer_instance *slave, *tmp;\n\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\n\t/* force to stop the timer */\n\tsnd_timer_stop(timeri);\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&slave_active_lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t}\n\t\tspin_unlock_irq(&slave_active_lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tmutex_unlock(&register_mutex);\n\t} else {\n\t\ttimer = timeri->timer;\n\t\tif (snd_BUG_ON(!timer))\n\t\t\tgoto out;\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&timer->lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&timer->lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&timer->lock);\n\t\t}\n\t\tspin_unlock_irq(&timer->lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tif (timer && list_empty(&timer->open_list_head) &&\n \t\t    timer->hw.close)\n \t\t\ttimer->hw.close(timer);\n \t\t/* remove slave links */\n\t\tspin_lock_irq(&slave_active_lock);\n\t\tspin_lock(&timer->lock);\n \t\tlist_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,\n \t\t\t\t\t open_list) {\n \t\t\tlist_move_tail(&slave->open_list, &snd_timer_slave_list);\n \t\t\tslave->master = NULL;\n \t\t\tslave->timer = NULL;\n\t\t\tlist_del_init(&slave->ack_list);\n\t\t\tlist_del_init(&slave->active_list);\n \t\t}\n\t\tspin_unlock(&timer->lock);\n\t\tspin_unlock_irq(&slave_active_lock);\n \t\tmutex_unlock(&register_mutex);\n \t}\n  out:\n\tif (timeri->private_free)\n\t\ttimeri->private_free(timeri);\n\tkfree(timeri->owner);\n\tkfree(timeri);\n\tif (timer)\n\t\tmodule_put(timer->module);\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142170,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "kvm_irqfd(struct kvm *kvm, struct kvm_irqfd *args)\n {\n \tif (args->flags & ~(KVM_IRQFD_FLAG_DEASSIGN | KVM_IRQFD_FLAG_RESAMPLE))\n \t\treturn -EINVAL;\n \n \tif (args->flags & KVM_IRQFD_FLAG_DEASSIGN)\n \t\treturn kvm_irqfd_deassign(kvm, args);\n\n\treturn kvm_irqfd_assign(kvm, args);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142247,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "kvm_irqfd(struct kvm *kvm, struct kvm_irqfd *args)\n {\n \tif (args->flags & ~(KVM_IRQFD_FLAG_DEASSIGN | KVM_IRQFD_FLAG_RESAMPLE))\n \t\treturn -EINVAL;\n\tif (args->gsi >= KVM_MAX_IRQ_ROUTES)\n\t\treturn -EINVAL;\n \n \tif (args->flags & KVM_IRQFD_FLAG_DEASSIGN)\n \t\treturn kvm_irqfd_deassign(kvm, args);\n\n\treturn kvm_irqfd_assign(kvm, args);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142248,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n \n \tsalsa20_ivsetup(ctx, walk.iv);\n \n\tif (likely(walk.nbytes == nbytes))\n\t{\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr, nbytes);\n\t\treturn blkcipher_walk_done(desc, &walk, 0);\n\t}\n \twhile (walk.nbytes >= 64) {\n \t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n \t\t\t\t      walk.dst.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142261,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n \n \tsalsa20_ivsetup(ctx, walk.iv);\n \n \twhile (walk.nbytes >= 64) {\n \t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n \t\t\t\t      walk.dst.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142262,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n \n \tsalsa20_ivsetup(ctx, walk.iv);\n \n\tif (likely(walk.nbytes == nbytes))\n\t{\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr, nbytes);\n\t\treturn blkcipher_walk_done(desc, &walk, 0);\n\t}\n \twhile (walk.nbytes >= 64) {\n \t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n \t\t\t\t      walk.src.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142263,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n \n \tsalsa20_ivsetup(ctx, walk.iv);\n \n \twhile (walk.nbytes >= 64) {\n \t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n \t\t\t\t      walk.src.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142264,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int bnep_add_connection(struct bnep_connadd_req *req, struct socket *sock)\n{\n\tstruct net_device *dev;\n\tstruct bnep_session *s, *ss;\n\tu8 dst[ETH_ALEN], src[ETH_ALEN];\n\tint err;\n \n \tBT_DBG(\"\");\n \n \tbaswap((void *) dst, &l2cap_pi(sock->sk)->chan->dst);\n \tbaswap((void *) src, &l2cap_pi(sock->sk)->chan->src);\n \n\t/* session struct allocated as private part of net_device */\n\tdev = alloc_netdev(sizeof(struct bnep_session),\n\t\t\t   (*req->device) ? req->device : \"bnep%d\",\n\t\t\t   NET_NAME_UNKNOWN,\n\t\t\t   bnep_net_setup);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdown_write(&bnep_session_sem);\n\n\tss = __bnep_get_session(dst);\n\tif (ss && ss->state == BT_CONNECTED) {\n\t\terr = -EEXIST;\n\t\tgoto failed;\n\t}\n\n\ts = netdev_priv(dev);\n\n\t/* This is rx header therefore addresses are swapped.\n\t * ie. eh.h_dest is our local address. */\n\tmemcpy(s->eh.h_dest,   &src, ETH_ALEN);\n\tmemcpy(s->eh.h_source, &dst, ETH_ALEN);\n\tmemcpy(dev->dev_addr, s->eh.h_dest, ETH_ALEN);\n\n\ts->dev   = dev;\n\ts->sock  = sock;\n\ts->role  = req->role;\n\ts->state = BT_CONNECTED;\n\n\ts->msg.msg_flags = MSG_NOSIGNAL;\n\n#ifdef CONFIG_BT_BNEP_MC_FILTER\n\t/* Set default mc filter */\n\tset_bit(bnep_mc_hash(dev->broadcast), (ulong *) &s->mc_filter);\n#endif\n\n#ifdef CONFIG_BT_BNEP_PROTO_FILTER\n\t/* Set default protocol filter */\n\tbnep_set_default_proto_filter(s);\n#endif\n\n\tSET_NETDEV_DEV(dev, bnep_get_device(s));\n\tSET_NETDEV_DEVTYPE(dev, &bnep_type);\n\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto failed;\n\n\t__bnep_link_session(s);\n\n\t__module_get(THIS_MODULE);\n\ts->task = kthread_run(bnep_session, s, \"kbnepd %s\", dev->name);\n\tif (IS_ERR(s->task)) {\n\t\t/* Session thread start failed, gotta cleanup. */\n\t\tmodule_put(THIS_MODULE);\n\t\tunregister_netdev(dev);\n\t\t__bnep_unlink_session(s);\n\t\terr = PTR_ERR(s->task);\n\t\tgoto failed;\n\t}\n\n\tup_write(&bnep_session_sem);\n\tstrcpy(req->device, dev->name);\n\treturn 0;\n\nfailed:\n\tup_write(&bnep_session_sem);\n\tfree_netdev(dev);\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142299,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int bnep_add_connection(struct bnep_connadd_req *req, struct socket *sock)\n{\n\tstruct net_device *dev;\n\tstruct bnep_session *s, *ss;\n\tu8 dst[ETH_ALEN], src[ETH_ALEN];\n\tint err;\n \n \tBT_DBG(\"\");\n \n\tif (!l2cap_is_socket(sock))\n\t\treturn -EBADFD;\n\n \tbaswap((void *) dst, &l2cap_pi(sock->sk)->chan->dst);\n \tbaswap((void *) src, &l2cap_pi(sock->sk)->chan->src);\n \n\t/* session struct allocated as private part of net_device */\n\tdev = alloc_netdev(sizeof(struct bnep_session),\n\t\t\t   (*req->device) ? req->device : \"bnep%d\",\n\t\t\t   NET_NAME_UNKNOWN,\n\t\t\t   bnep_net_setup);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdown_write(&bnep_session_sem);\n\n\tss = __bnep_get_session(dst);\n\tif (ss && ss->state == BT_CONNECTED) {\n\t\terr = -EEXIST;\n\t\tgoto failed;\n\t}\n\n\ts = netdev_priv(dev);\n\n\t/* This is rx header therefore addresses are swapped.\n\t * ie. eh.h_dest is our local address. */\n\tmemcpy(s->eh.h_dest,   &src, ETH_ALEN);\n\tmemcpy(s->eh.h_source, &dst, ETH_ALEN);\n\tmemcpy(dev->dev_addr, s->eh.h_dest, ETH_ALEN);\n\n\ts->dev   = dev;\n\ts->sock  = sock;\n\ts->role  = req->role;\n\ts->state = BT_CONNECTED;\n\n\ts->msg.msg_flags = MSG_NOSIGNAL;\n\n#ifdef CONFIG_BT_BNEP_MC_FILTER\n\t/* Set default mc filter */\n\tset_bit(bnep_mc_hash(dev->broadcast), (ulong *) &s->mc_filter);\n#endif\n\n#ifdef CONFIG_BT_BNEP_PROTO_FILTER\n\t/* Set default protocol filter */\n\tbnep_set_default_proto_filter(s);\n#endif\n\n\tSET_NETDEV_DEV(dev, bnep_get_device(s));\n\tSET_NETDEV_DEVTYPE(dev, &bnep_type);\n\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto failed;\n\n\t__bnep_link_session(s);\n\n\t__module_get(THIS_MODULE);\n\ts->task = kthread_run(bnep_session, s, \"kbnepd %s\", dev->name);\n\tif (IS_ERR(s->task)) {\n\t\t/* Session thread start failed, gotta cleanup. */\n\t\tmodule_put(THIS_MODULE);\n\t\tunregister_netdev(dev);\n\t\t__bnep_unlink_session(s);\n\t\terr = PTR_ERR(s->task);\n\t\tgoto failed;\n\t}\n\n\tup_write(&bnep_session_sem);\n\tstrcpy(req->device, dev->name);\n\treturn 0;\n\nfailed:\n\tup_write(&bnep_session_sem);\n\tfree_netdev(dev);\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142300,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int mboxlist_do_find(struct find_rock *rock, const strarray_t *patterns)\n{\n    const char *userid = rock->userid;\n    int isadmin = rock->isadmin;\n\n    int crossdomains = config_getswitch(IMAPOPT_CROSSDOMAINS);\n    char inbox[MAX_MAILBOX_BUFFER];\n    size_t inboxlen = 0;\n    size_t prefixlen, len;\n    size_t domainlen = 0;\n    size_t userlen = userid ? strlen(userid) : 0;\n    char domainpat[MAX_MAILBOX_BUFFER]; /* do intra-domain fetches only */\n    char commonpat[MAX_MAILBOX_BUFFER];\n    int r = 0;\n    int i;\n    const char *p;\n\n    if (patterns->count < 1) return 0; /* nothing to do */\n\n    for (i = 0; i < patterns->count; i++) {\n        glob *g = glob_init(strarray_nth(patterns, i), rock->namespace->hier_sep);\n        ptrarray_append(&rock->globs, g);\n    }\n\n    if (config_virtdomains && userid && (p = strchr(userid, '@'))) {\n        userlen = p - userid;\n        domainlen = strlen(p); /* includes separator */\n        snprintf(domainpat, sizeof(domainpat), \"%s!\", p+1);\n    }\n    else\n        domainpat[0] = '\\0';\n\n    /* calculate the inbox (with trailing .INBOX. for later use) */\n    if (userid && (!(p = strchr(userid, rock->namespace->hier_sep)) ||\n        ((p - userid) > (int)userlen)) &&\n        strlen(userid)+7 < MAX_MAILBOX_BUFFER) {\n        char *t, *tmpuser = NULL;\n        const char *inboxuser;\n\n        if (domainlen)\n            snprintf(inbox, sizeof(inbox), \"%s!\", userid+userlen+1);\n        if (rock->namespace->hier_sep == '/' && (p = strchr(userid, '.'))) {\n            tmpuser = xmalloc(userlen);\n            memcpy(tmpuser, userid, userlen);\n            t = tmpuser + (p - userid);\n            while(t < (tmpuser + userlen)) {\n                if (*t == '.')\n                    *t = '^';\n                t++;\n            }\n            inboxuser = tmpuser;\n        } else\n            inboxuser = userid;\n        snprintf(inbox+domainlen, sizeof(inbox)-domainlen,\n                 \"user.%.*s.INBOX.\", (int)userlen, inboxuser);\n        free(tmpuser);\n        inboxlen = strlen(inbox) - 7;\n    }\n    else {\n        userid = 0;\n    }\n\n    /* Find the common search prefix of all patterns */\n    const char *firstpat = strarray_nth(patterns, 0);\n    for (prefixlen = 0; firstpat[prefixlen]; prefixlen++) {\n        if (prefixlen >= MAX_MAILBOX_NAME) {\n            r = IMAP_MAILBOX_BADNAME;\n            goto done;\n        }\n        char c = firstpat[prefixlen];\n        for (i = 1; i < patterns->count; i++) {\n            const char *pat = strarray_nth(patterns, i);\n            if (pat[prefixlen] != c) break;\n        }\n        if (i < patterns->count) break;\n        if (c == '*' || c == '%' || c == '?') break;\n        commonpat[prefixlen] = c;\n    }\n    commonpat[prefixlen] = '\\0';\n\n    if (patterns->count == 1) {\n        /* Skip pattern which matches shared namespace prefix */\n        if (!strcmp(firstpat+prefixlen, \"%\"))\n            rock->singlepercent = 2;\n        /* output prefix regardless */\n        if (!strcmp(firstpat+prefixlen, \"*%\"))\n            rock->singlepercent = 1;\n    }\n\n    /*\n     * Personal (INBOX) namespace (only if not admin)\n     */\n    if (userid && !isadmin) {\n        /* first the INBOX */\n        rock->mb_category = MBNAME_INBOX;\n        r = cyrusdb_forone(rock->db, inbox, inboxlen, &find_p, &find_cb, rock, NULL);\n        if (r == CYRUSDB_DONE) r = 0;\n        if (r) goto done;\n\n        if (rock->namespace->isalt) {\n            /* do exact INBOX subs before resetting the namebuffer */\n            rock->mb_category = MBNAME_INBOXSUB;\n            r = cyrusdb_foreach(rock->db, inbox, inboxlen+7, &find_p, &find_cb, rock, NULL);\n            if (r == CYRUSDB_DONE) r = 0;\n            if (r) goto done;\n\n            /* reset the the namebuffer */\n            r = (*rock->proc)(NULL, rock->procrock);\n            if (r) goto done;\n        }\n\n        /* iterate through all the mailboxes under the user's inbox */\n        rock->mb_category = MBNAME_OWNER;\n        r = cyrusdb_foreach(rock->db, inbox, inboxlen+1, &find_p, &find_cb, rock, NULL);\n        if (r == CYRUSDB_DONE) r = 0;\n        if (r) goto done;\n\n        /* \"Alt Prefix\" folders */\n        if (rock->namespace->isalt) {\n            /* reset the the namebuffer */\n            r = (*rock->proc)(NULL, rock->procrock);\n            if (r) goto done;\n\n            rock->mb_category = MBNAME_ALTINBOX;\n\n            /* special case user.foo.INBOX.  If we're singlepercent == 2, this could\n             return DONE, in which case we don't need to foreach the rest of the\n             altprefix space */\n            r = cyrusdb_forone(rock->db, inbox, inboxlen+6, &find_p, &find_cb, rock, NULL);\n            if (r == CYRUSDB_DONE) goto skipalt;\n            if (r) goto done;\n\n            /* special case any other altprefix stuff */\n            rock->mb_category = MBNAME_ALTPREFIX;\n            r = cyrusdb_foreach(rock->db, inbox, inboxlen+1, &find_p, &find_cb, rock, NULL);\n        skipalt: /* we got a done, so skip out of the foreach early */\n            if (r == CYRUSDB_DONE) r = 0;\n            if (r) goto done;\n        }\n    }\n\n    /*\n     * Other Users namespace\n     *\n     * If \"Other Users*\" can match pattern, search for those mailboxes next\n     */\n    if (isadmin || rock->namespace->accessible[NAMESPACE_USER]) {\n        len = strlen(rock->namespace->prefix[NAMESPACE_USER]);\n         if (len) len--; // trailing separator\n \n         if (!strncmp(rock->namespace->prefix[NAMESPACE_USER], commonpat, MIN(len, prefixlen))) {\n            if (prefixlen < len) {\n                 /* we match all users */\n                 strlcpy(domainpat+domainlen, \"user.\", sizeof(domainpat)-domainlen);\n             }\n            else {\n                /* just those in this prefix */\n                strlcpy(domainpat+domainlen, \"user.\", sizeof(domainpat)-domainlen);\n                strlcpy(domainpat+domainlen+5, commonpat+len+1, sizeof(domainpat)-domainlen-5);\n            }\n\n            rock->mb_category = MBNAME_OTHERUSER;\n\n            /* because of how domains work, with crossdomains or admin you can't prefix at all :( */\n            size_t thislen = (isadmin || crossdomains) ? 0 : strlen(domainpat);\n\n            /* reset the the namebuffer */\n            r = (*rock->proc)(NULL, rock->procrock);\n            if (r) goto done;\n\n            r = mboxlist_find_category(rock, domainpat, thislen);\n            if (r) goto done;\n        }\n    }\n\n    /*\n     * Shared namespace\n     *\n     * search for all remaining mailboxes.\n     * just bother looking at the ones that have the same pattern prefix.\n     */\n    if (isadmin || rock->namespace->accessible[NAMESPACE_SHARED]) {\n        len = strlen(rock->namespace->prefix[NAMESPACE_SHARED]);\n        if (len) len--; // trailing separator\n\n        if (!strncmp(rock->namespace->prefix[NAMESPACE_SHARED], commonpat, MIN(len, prefixlen))) {\n            rock->mb_category = MBNAME_SHARED;\n\n            /* reset the the namebuffer */\n            r = (*rock->proc)(NULL, rock->procrock);\n            if (r) goto done;\n\n            /* iterate through all the non-user folders on the server */\n            r = mboxlist_find_category(rock, domainpat, domainlen);\n            if (r) goto done;\n        }\n    }\n\n    /* finish with a reset call always */\n    r = (*rock->proc)(NULL, rock->procrock);\n\n done:\n    for (i = 0; i < rock->globs.count; i++) {\n        glob *g = ptrarray_nth(&rock->globs, i);\n        glob_free(&g);\n    }\n    ptrarray_fini(&rock->globs);\n\n    return r;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142329,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int mboxlist_do_find(struct find_rock *rock, const strarray_t *patterns)\n{\n    const char *userid = rock->userid;\n    int isadmin = rock->isadmin;\n\n    int crossdomains = config_getswitch(IMAPOPT_CROSSDOMAINS);\n    char inbox[MAX_MAILBOX_BUFFER];\n    size_t inboxlen = 0;\n    size_t prefixlen, len;\n    size_t domainlen = 0;\n    size_t userlen = userid ? strlen(userid) : 0;\n    char domainpat[MAX_MAILBOX_BUFFER]; /* do intra-domain fetches only */\n    char commonpat[MAX_MAILBOX_BUFFER];\n    int r = 0;\n    int i;\n    const char *p;\n\n    if (patterns->count < 1) return 0; /* nothing to do */\n\n    for (i = 0; i < patterns->count; i++) {\n        glob *g = glob_init(strarray_nth(patterns, i), rock->namespace->hier_sep);\n        ptrarray_append(&rock->globs, g);\n    }\n\n    if (config_virtdomains && userid && (p = strchr(userid, '@'))) {\n        userlen = p - userid;\n        domainlen = strlen(p); /* includes separator */\n        snprintf(domainpat, sizeof(domainpat), \"%s!\", p+1);\n    }\n    else\n        domainpat[0] = '\\0';\n\n    /* calculate the inbox (with trailing .INBOX. for later use) */\n    if (userid && (!(p = strchr(userid, rock->namespace->hier_sep)) ||\n        ((p - userid) > (int)userlen)) &&\n        strlen(userid)+7 < MAX_MAILBOX_BUFFER) {\n        char *t, *tmpuser = NULL;\n        const char *inboxuser;\n\n        if (domainlen)\n            snprintf(inbox, sizeof(inbox), \"%s!\", userid+userlen+1);\n        if (rock->namespace->hier_sep == '/' && (p = strchr(userid, '.'))) {\n            tmpuser = xmalloc(userlen);\n            memcpy(tmpuser, userid, userlen);\n            t = tmpuser + (p - userid);\n            while(t < (tmpuser + userlen)) {\n                if (*t == '.')\n                    *t = '^';\n                t++;\n            }\n            inboxuser = tmpuser;\n        } else\n            inboxuser = userid;\n        snprintf(inbox+domainlen, sizeof(inbox)-domainlen,\n                 \"user.%.*s.INBOX.\", (int)userlen, inboxuser);\n        free(tmpuser);\n        inboxlen = strlen(inbox) - 7;\n    }\n    else {\n        userid = 0;\n    }\n\n    /* Find the common search prefix of all patterns */\n    const char *firstpat = strarray_nth(patterns, 0);\n    for (prefixlen = 0; firstpat[prefixlen]; prefixlen++) {\n        if (prefixlen >= MAX_MAILBOX_NAME) {\n            r = IMAP_MAILBOX_BADNAME;\n            goto done;\n        }\n        char c = firstpat[prefixlen];\n        for (i = 1; i < patterns->count; i++) {\n            const char *pat = strarray_nth(patterns, i);\n            if (pat[prefixlen] != c) break;\n        }\n        if (i < patterns->count) break;\n        if (c == '*' || c == '%' || c == '?') break;\n        commonpat[prefixlen] = c;\n    }\n    commonpat[prefixlen] = '\\0';\n\n    if (patterns->count == 1) {\n        /* Skip pattern which matches shared namespace prefix */\n        if (!strcmp(firstpat+prefixlen, \"%\"))\n            rock->singlepercent = 2;\n        /* output prefix regardless */\n        if (!strcmp(firstpat+prefixlen, \"*%\"))\n            rock->singlepercent = 1;\n    }\n\n    /*\n     * Personal (INBOX) namespace (only if not admin)\n     */\n    if (userid && !isadmin) {\n        /* first the INBOX */\n        rock->mb_category = MBNAME_INBOX;\n        r = cyrusdb_forone(rock->db, inbox, inboxlen, &find_p, &find_cb, rock, NULL);\n        if (r == CYRUSDB_DONE) r = 0;\n        if (r) goto done;\n\n        if (rock->namespace->isalt) {\n            /* do exact INBOX subs before resetting the namebuffer */\n            rock->mb_category = MBNAME_INBOXSUB;\n            r = cyrusdb_foreach(rock->db, inbox, inboxlen+7, &find_p, &find_cb, rock, NULL);\n            if (r == CYRUSDB_DONE) r = 0;\n            if (r) goto done;\n\n            /* reset the the namebuffer */\n            r = (*rock->proc)(NULL, rock->procrock);\n            if (r) goto done;\n        }\n\n        /* iterate through all the mailboxes under the user's inbox */\n        rock->mb_category = MBNAME_OWNER;\n        r = cyrusdb_foreach(rock->db, inbox, inboxlen+1, &find_p, &find_cb, rock, NULL);\n        if (r == CYRUSDB_DONE) r = 0;\n        if (r) goto done;\n\n        /* \"Alt Prefix\" folders */\n        if (rock->namespace->isalt) {\n            /* reset the the namebuffer */\n            r = (*rock->proc)(NULL, rock->procrock);\n            if (r) goto done;\n\n            rock->mb_category = MBNAME_ALTINBOX;\n\n            /* special case user.foo.INBOX.  If we're singlepercent == 2, this could\n             return DONE, in which case we don't need to foreach the rest of the\n             altprefix space */\n            r = cyrusdb_forone(rock->db, inbox, inboxlen+6, &find_p, &find_cb, rock, NULL);\n            if (r == CYRUSDB_DONE) goto skipalt;\n            if (r) goto done;\n\n            /* special case any other altprefix stuff */\n            rock->mb_category = MBNAME_ALTPREFIX;\n            r = cyrusdb_foreach(rock->db, inbox, inboxlen+1, &find_p, &find_cb, rock, NULL);\n        skipalt: /* we got a done, so skip out of the foreach early */\n            if (r == CYRUSDB_DONE) r = 0;\n            if (r) goto done;\n        }\n    }\n\n    /*\n     * Other Users namespace\n     *\n     * If \"Other Users*\" can match pattern, search for those mailboxes next\n     */\n    if (isadmin || rock->namespace->accessible[NAMESPACE_USER]) {\n        len = strlen(rock->namespace->prefix[NAMESPACE_USER]);\n         if (len) len--; // trailing separator\n \n         if (!strncmp(rock->namespace->prefix[NAMESPACE_USER], commonpat, MIN(len, prefixlen))) {\n            if (prefixlen <= len) {\n                 /* we match all users */\n                 strlcpy(domainpat+domainlen, \"user.\", sizeof(domainpat)-domainlen);\n             }\n            else {\n                /* just those in this prefix */\n                strlcpy(domainpat+domainlen, \"user.\", sizeof(domainpat)-domainlen);\n                strlcpy(domainpat+domainlen+5, commonpat+len+1, sizeof(domainpat)-domainlen-5);\n            }\n\n            rock->mb_category = MBNAME_OTHERUSER;\n\n            /* because of how domains work, with crossdomains or admin you can't prefix at all :( */\n            size_t thislen = (isadmin || crossdomains) ? 0 : strlen(domainpat);\n\n            /* reset the the namebuffer */\n            r = (*rock->proc)(NULL, rock->procrock);\n            if (r) goto done;\n\n            r = mboxlist_find_category(rock, domainpat, thislen);\n            if (r) goto done;\n        }\n    }\n\n    /*\n     * Shared namespace\n     *\n     * search for all remaining mailboxes.\n     * just bother looking at the ones that have the same pattern prefix.\n     */\n    if (isadmin || rock->namespace->accessible[NAMESPACE_SHARED]) {\n        len = strlen(rock->namespace->prefix[NAMESPACE_SHARED]);\n        if (len) len--; // trailing separator\n\n        if (!strncmp(rock->namespace->prefix[NAMESPACE_SHARED], commonpat, MIN(len, prefixlen))) {\n            rock->mb_category = MBNAME_SHARED;\n\n            /* reset the the namebuffer */\n            r = (*rock->proc)(NULL, rock->procrock);\n            if (r) goto done;\n\n            /* iterate through all the non-user folders on the server */\n            r = mboxlist_find_category(rock, domainpat, domainlen);\n            if (r) goto done;\n        }\n    }\n\n    /* finish with a reset call always */\n    r = (*rock->proc)(NULL, rock->procrock);\n\n done:\n    for (i = 0; i < rock->globs.count; i++) {\n        glob *g = ptrarray_nth(&rock->globs, i);\n        glob_free(&g);\n    }\n    ptrarray_fini(&rock->globs);\n\n    return r;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142330,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool __skb_flow_dissect(const struct sk_buff *skb,\n\t\t\tstruct flow_dissector *flow_dissector,\n\t\t\tvoid *target_container,\n\t\t\tvoid *data, __be16 proto, int nhoff, int hlen)\n{\n\tstruct flow_dissector_key_control *key_control;\n\tstruct flow_dissector_key_basic *key_basic;\n\tstruct flow_dissector_key_addrs *key_addrs;\n\tstruct flow_dissector_key_ports *key_ports;\n \tstruct flow_dissector_key_tags *key_tags;\n \tstruct flow_dissector_key_keyid *key_keyid;\n \tu8 ip_proto = 0;\n \n \tif (!data) {\n \t\tdata = skb->data;\n\t\tproto = skb->protocol;\n\t\tnhoff = skb_network_offset(skb);\n\t\thlen = skb_headlen(skb);\n\t}\n\n\t/* It is ensured by skb_flow_dissector_init() that control key will\n\t * be always present.\n\t */\n\tkey_control = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_CONTROL,\n\t\t\t\t\t\ttarget_container);\n\n\t/* It is ensured by skb_flow_dissector_init() that basic key will\n\t * be always present.\n\t */\n\tkey_basic = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t      FLOW_DISSECTOR_KEY_BASIC,\n\t\t\t\t\t      target_container);\n\n\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct ethhdr *eth = eth_hdr(skb);\n\t\tstruct flow_dissector_key_eth_addrs *key_eth_addrs;\n\n\t\tkey_eth_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t  FLOW_DISSECTOR_KEY_ETH_ADDRS,\n\t\t\t\t\t\t\t  target_container);\n\t\tmemcpy(key_eth_addrs, &eth->h_dest, sizeof(*key_eth_addrs));\n\t}\n\nagain:\n\tswitch (proto) {\n\tcase htons(ETH_P_IP): {\n\t\tconst struct iphdr *iph;\n\t\tstruct iphdr _iph;\n ip:\n \t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n \t\tif (!iph || iph->ihl < 5)\n\t\t\treturn false;\n \t\tnhoff += iph->ihl * 4;\n \n \t\tip_proto = iph->protocol;\n\t\tif (ip_is_fragment(iph))\n\t\t\tip_proto = 0;\n\n\t\tif (!skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t FLOW_DISSECTOR_KEY_IPV4_ADDRS))\n\t\t\tbreak;\n\n\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t      FLOW_DISSECTOR_KEY_IPV4_ADDRS, target_container);\n\t\tmemcpy(&key_addrs->v4addrs, &iph->saddr,\n\t\t       sizeof(key_addrs->v4addrs));\n\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_IPV6): {\n\t\tconst struct ipv6hdr *iph;\n\t\tstruct ipv6hdr _iph;\n\t\t__be32 flow_label;\n\n ipv6:\n \t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n \t\tif (!iph)\n\t\t\treturn false;\n \n \t\tip_proto = iph->nexthdr;\n \t\tnhoff += sizeof(struct ipv6hdr);\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_IPV6_ADDRS)) {\n\t\t\tstruct flow_dissector_key_ipv6_addrs *key_ipv6_addrs;\n\n\t\t\tkey_ipv6_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t   FLOW_DISSECTOR_KEY_IPV6_ADDRS,\n\t\t\t\t\t\t\t\t   target_container);\n\n\t\t\tmemcpy(key_ipv6_addrs, &iph->saddr, sizeof(*key_ipv6_addrs));\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t}\n\n\t\tflow_label = ip6_flowlabel(iph);\n\t\tif (flow_label) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\tFLOW_DISSECTOR_KEY_FLOW_LABEL)) {\n\t\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_FLOW_LABEL,\n\t\t\t\t\t\t\t\t     target_container);\n\t\t\t\tkey_tags->flow_label = ntohl(flow_label);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_8021AD):\n\tcase htons(ETH_P_8021Q): {\n\t\tconst struct vlan_hdr *vlan;\n\t\tstruct vlan_hdr _vlan;\n \n \t\tvlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);\n \t\tif (!vlan)\n\t\t\treturn false;\n \n \t\tif (skb_flow_dissector_uses_key(flow_dissector,\n \t\t\t\t\t\tFLOW_DISSECTOR_KEY_VLANID)) {\n\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_VLANID,\n\t\t\t\t\t\t\t     target_container);\n\n\t\t\tkey_tags->vlan_id = skb_vlan_tag_get_id(skb);\n\t\t}\n\n\t\tproto = vlan->h_vlan_encapsulated_proto;\n\t\tnhoff += sizeof(*vlan);\n\t\tgoto again;\n\t}\n\tcase htons(ETH_P_PPP_SES): {\n\t\tstruct {\n\t\t\tstruct pppoe_hdr hdr;\n\t\t\t__be16 proto;\n \t\t} *hdr, _hdr;\n \t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n \t\tif (!hdr)\n\t\t\treturn false;\n \t\tproto = hdr->proto;\n \t\tnhoff += PPPOE_SES_HLEN;\n \t\tswitch (proto) {\n\t\tcase htons(PPP_IP):\n\t\t\tgoto ip;\n \t\tcase htons(PPP_IPV6):\n \t\t\tgoto ipv6;\n \t\tdefault:\n\t\t\treturn false;\n \t\t}\n \t}\n \tcase htons(ETH_P_TIPC): {\n\t\tstruct {\n\t\t\t__be32 pre[3];\n\t\t\t__be32 srcnode;\n \t\t} *hdr, _hdr;\n \t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n \t\tif (!hdr)\n\t\t\treturn false;\n\t\tkey_basic->n_proto = proto;\n\t\tkey_control->thoff = (u16)nhoff;\n \n \t\tif (skb_flow_dissector_uses_key(flow_dissector,\n \t\t\t\t\t\tFLOW_DISSECTOR_KEY_TIPC_ADDRS)) {\n\t\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_TIPC_ADDRS,\n\t\t\t\t\t\t\t      target_container);\n \t\t\tkey_addrs->tipcaddrs.srcnode = hdr->srcnode;\n \t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;\n \t\t}\n\t\treturn true;\n \t}\n \n \tcase htons(ETH_P_MPLS_UC):\n\tcase htons(ETH_P_MPLS_MC): {\n\t\tstruct mpls_label *hdr, _hdr[2];\nmpls:\n \t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,\n \t\t\t\t\t   hlen, &_hdr);\n \t\tif (!hdr)\n\t\t\treturn false;\n \n \t\tif ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>\n \t\t     MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_MPLS_ENTROPY)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_MPLS_ENTROPY,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = hdr[1].entry &\n \t\t\t\t\thtonl(MPLS_LS_LABEL_MASK);\n \t\t\t}\n \n\t\t\tkey_basic->n_proto = proto;\n\t\t\tkey_basic->ip_proto = ip_proto;\n\t\t\tkey_control->thoff = (u16)nhoff;\n\t\t\treturn true;\n \t\t}\n \n\t\treturn true;\n \t}\n \n \tcase htons(ETH_P_FCOE):\n \t\tkey_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);\n \t\t/* fall through */\n \tdefault:\n\t\treturn false;\n \t}\n \n ip_proto_again:\n\tswitch (ip_proto) {\n\tcase IPPROTO_GRE: {\n\t\tstruct gre_hdr {\n\t\t\t__be16 flags;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n \n \t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n \t\tif (!hdr)\n\t\t\treturn false;\n \t\t/*\n \t\t * Only look inside GRE if version zero and no\n \t\t * routing\n\t\t */\n\t\tif (hdr->flags & (GRE_VERSION | GRE_ROUTING))\n\t\t\tbreak;\n\n\t\tproto = hdr->proto;\n\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_CSUM)\n\t\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_KEY) {\n\t\t\tconst __be32 *keyid;\n\t\t\t__be32 _keyid;\n\n\t\t\tkeyid = __skb_header_pointer(skb, nhoff, sizeof(_keyid),\n \t\t\t\t\t\t     data, hlen, &_keyid);\n \n \t\t\tif (!keyid)\n\t\t\t\treturn false;\n \n \t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n \t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_GRE_KEYID)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_GRE_KEYID,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = *keyid;\n\t\t\t}\n\t\t\tnhoff += 4;\n\t\t}\n\t\tif (hdr->flags & GRE_SEQ)\n\t\t\tnhoff += 4;\n\t\tif (proto == htons(ETH_P_TEB)) {\n\t\t\tconst struct ethhdr *eth;\n\t\t\tstruct ethhdr _eth;\n\n\t\t\teth = __skb_header_pointer(skb, nhoff,\n \t\t\t\t\t\t   sizeof(_eth),\n \t\t\t\t\t\t   data, hlen, &_eth);\n \t\t\tif (!eth)\n\t\t\t\treturn false;\n \t\t\tproto = eth->h_proto;\n \t\t\tnhoff += sizeof(*eth);\n \t\t}\n\t\tgoto again;\n\t}\n\tcase NEXTHDR_HOP:\n\tcase NEXTHDR_ROUTING:\n\tcase NEXTHDR_DEST: {\n\t\tu8 _opthdr[2], *opthdr;\n\n\t\tif (proto != htons(ETH_P_IPV6))\n\t\t\tbreak;\n\n \t\topthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),\n \t\t\t\t\t      data, hlen, &_opthdr);\n \t\tif (!opthdr)\n\t\t\treturn false;\n \n \t\tip_proto = opthdr[0];\n \t\tnhoff += (opthdr[1] + 1) << 3;\n\n\t\tgoto ip_proto_again;\n\t}\n\tcase IPPROTO_IPIP:\n\t\tproto = htons(ETH_P_IP);\n\t\tgoto ip;\n\tcase IPPROTO_IPV6:\n\t\tproto = htons(ETH_P_IPV6);\n\t\tgoto ipv6;\n\tcase IPPROTO_MPLS:\n\t\tproto = htons(ETH_P_MPLS_UC);\n\t\tgoto mpls;\n\tdefault:\n \t\tbreak;\n \t}\n \n\tkey_basic->n_proto = proto;\n\tkey_basic->ip_proto = ip_proto;\n\tkey_control->thoff = (u16)nhoff;\n \tif (skb_flow_dissector_uses_key(flow_dissector,\n \t\t\t\t\tFLOW_DISSECTOR_KEY_PORTS)) {\n \t\tkey_ports = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_PORTS,\n\t\t\t\t\t\t      target_container);\n\t\tkey_ports->ports = __skb_flow_get_ports(skb, nhoff, ip_proto,\n \t\t\t\t\t\t\tdata, hlen);\n \t}\n \n\treturn true;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142359,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool __skb_flow_dissect(const struct sk_buff *skb,\n\t\t\tstruct flow_dissector *flow_dissector,\n\t\t\tvoid *target_container,\n\t\t\tvoid *data, __be16 proto, int nhoff, int hlen)\n{\n\tstruct flow_dissector_key_control *key_control;\n\tstruct flow_dissector_key_basic *key_basic;\n\tstruct flow_dissector_key_addrs *key_addrs;\n\tstruct flow_dissector_key_ports *key_ports;\n \tstruct flow_dissector_key_tags *key_tags;\n \tstruct flow_dissector_key_keyid *key_keyid;\n \tu8 ip_proto = 0;\n\tbool ret = false;\n \n \tif (!data) {\n \t\tdata = skb->data;\n\t\tproto = skb->protocol;\n\t\tnhoff = skb_network_offset(skb);\n\t\thlen = skb_headlen(skb);\n\t}\n\n\t/* It is ensured by skb_flow_dissector_init() that control key will\n\t * be always present.\n\t */\n\tkey_control = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_CONTROL,\n\t\t\t\t\t\ttarget_container);\n\n\t/* It is ensured by skb_flow_dissector_init() that basic key will\n\t * be always present.\n\t */\n\tkey_basic = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t      FLOW_DISSECTOR_KEY_BASIC,\n\t\t\t\t\t      target_container);\n\n\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct ethhdr *eth = eth_hdr(skb);\n\t\tstruct flow_dissector_key_eth_addrs *key_eth_addrs;\n\n\t\tkey_eth_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t  FLOW_DISSECTOR_KEY_ETH_ADDRS,\n\t\t\t\t\t\t\t  target_container);\n\t\tmemcpy(key_eth_addrs, &eth->h_dest, sizeof(*key_eth_addrs));\n\t}\n\nagain:\n\tswitch (proto) {\n\tcase htons(ETH_P_IP): {\n\t\tconst struct iphdr *iph;\n\t\tstruct iphdr _iph;\n ip:\n \t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n \t\tif (!iph || iph->ihl < 5)\n\t\t\tgoto out_bad;\n \t\tnhoff += iph->ihl * 4;\n \n \t\tip_proto = iph->protocol;\n\t\tif (ip_is_fragment(iph))\n\t\t\tip_proto = 0;\n\n\t\tif (!skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t FLOW_DISSECTOR_KEY_IPV4_ADDRS))\n\t\t\tbreak;\n\n\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t      FLOW_DISSECTOR_KEY_IPV4_ADDRS, target_container);\n\t\tmemcpy(&key_addrs->v4addrs, &iph->saddr,\n\t\t       sizeof(key_addrs->v4addrs));\n\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_IPV6): {\n\t\tconst struct ipv6hdr *iph;\n\t\tstruct ipv6hdr _iph;\n\t\t__be32 flow_label;\n\n ipv6:\n \t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n \t\tif (!iph)\n\t\t\tgoto out_bad;\n \n \t\tip_proto = iph->nexthdr;\n \t\tnhoff += sizeof(struct ipv6hdr);\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_IPV6_ADDRS)) {\n\t\t\tstruct flow_dissector_key_ipv6_addrs *key_ipv6_addrs;\n\n\t\t\tkey_ipv6_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t   FLOW_DISSECTOR_KEY_IPV6_ADDRS,\n\t\t\t\t\t\t\t\t   target_container);\n\n\t\t\tmemcpy(key_ipv6_addrs, &iph->saddr, sizeof(*key_ipv6_addrs));\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t}\n\n\t\tflow_label = ip6_flowlabel(iph);\n\t\tif (flow_label) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\tFLOW_DISSECTOR_KEY_FLOW_LABEL)) {\n\t\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_FLOW_LABEL,\n\t\t\t\t\t\t\t\t     target_container);\n\t\t\t\tkey_tags->flow_label = ntohl(flow_label);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_8021AD):\n\tcase htons(ETH_P_8021Q): {\n\t\tconst struct vlan_hdr *vlan;\n\t\tstruct vlan_hdr _vlan;\n \n \t\tvlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);\n \t\tif (!vlan)\n\t\t\tgoto out_bad;\n \n \t\tif (skb_flow_dissector_uses_key(flow_dissector,\n \t\t\t\t\t\tFLOW_DISSECTOR_KEY_VLANID)) {\n\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_VLANID,\n\t\t\t\t\t\t\t     target_container);\n\n\t\t\tkey_tags->vlan_id = skb_vlan_tag_get_id(skb);\n\t\t}\n\n\t\tproto = vlan->h_vlan_encapsulated_proto;\n\t\tnhoff += sizeof(*vlan);\n\t\tgoto again;\n\t}\n\tcase htons(ETH_P_PPP_SES): {\n\t\tstruct {\n\t\t\tstruct pppoe_hdr hdr;\n\t\t\t__be16 proto;\n \t\t} *hdr, _hdr;\n \t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n \t\tif (!hdr)\n\t\t\tgoto out_bad;\n \t\tproto = hdr->proto;\n \t\tnhoff += PPPOE_SES_HLEN;\n \t\tswitch (proto) {\n\t\tcase htons(PPP_IP):\n\t\t\tgoto ip;\n \t\tcase htons(PPP_IPV6):\n \t\t\tgoto ipv6;\n \t\tdefault:\n\t\t\tgoto out_bad;\n \t\t}\n \t}\n \tcase htons(ETH_P_TIPC): {\n\t\tstruct {\n\t\t\t__be32 pre[3];\n\t\t\t__be32 srcnode;\n \t\t} *hdr, _hdr;\n \t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n \t\tif (!hdr)\n\t\t\tgoto out_bad;\n \n \t\tif (skb_flow_dissector_uses_key(flow_dissector,\n \t\t\t\t\t\tFLOW_DISSECTOR_KEY_TIPC_ADDRS)) {\n\t\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_TIPC_ADDRS,\n\t\t\t\t\t\t\t      target_container);\n \t\t\tkey_addrs->tipcaddrs.srcnode = hdr->srcnode;\n \t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;\n \t\t}\n\t\tgoto out_good;\n \t}\n \n \tcase htons(ETH_P_MPLS_UC):\n\tcase htons(ETH_P_MPLS_MC): {\n\t\tstruct mpls_label *hdr, _hdr[2];\nmpls:\n \t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,\n \t\t\t\t\t   hlen, &_hdr);\n \t\tif (!hdr)\n\t\t\tgoto out_bad;\n \n \t\tif ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>\n \t\t     MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_MPLS_ENTROPY)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_MPLS_ENTROPY,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = hdr[1].entry &\n \t\t\t\t\thtonl(MPLS_LS_LABEL_MASK);\n \t\t\t}\n \n\t\t\tgoto out_good;\n \t\t}\n \n\t\tgoto out_good;\n \t}\n \n \tcase htons(ETH_P_FCOE):\n \t\tkey_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);\n \t\t/* fall through */\n \tdefault:\n\t\tgoto out_bad;\n \t}\n \n ip_proto_again:\n\tswitch (ip_proto) {\n\tcase IPPROTO_GRE: {\n\t\tstruct gre_hdr {\n\t\t\t__be16 flags;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n \n \t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n \t\tif (!hdr)\n\t\t\tgoto out_bad;\n \t\t/*\n \t\t * Only look inside GRE if version zero and no\n \t\t * routing\n\t\t */\n\t\tif (hdr->flags & (GRE_VERSION | GRE_ROUTING))\n\t\t\tbreak;\n\n\t\tproto = hdr->proto;\n\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_CSUM)\n\t\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_KEY) {\n\t\t\tconst __be32 *keyid;\n\t\t\t__be32 _keyid;\n\n\t\t\tkeyid = __skb_header_pointer(skb, nhoff, sizeof(_keyid),\n \t\t\t\t\t\t     data, hlen, &_keyid);\n \n \t\t\tif (!keyid)\n\t\t\t\tgoto out_bad;\n \n \t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n \t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_GRE_KEYID)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_GRE_KEYID,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = *keyid;\n\t\t\t}\n\t\t\tnhoff += 4;\n\t\t}\n\t\tif (hdr->flags & GRE_SEQ)\n\t\t\tnhoff += 4;\n\t\tif (proto == htons(ETH_P_TEB)) {\n\t\t\tconst struct ethhdr *eth;\n\t\t\tstruct ethhdr _eth;\n\n\t\t\teth = __skb_header_pointer(skb, nhoff,\n \t\t\t\t\t\t   sizeof(_eth),\n \t\t\t\t\t\t   data, hlen, &_eth);\n \t\t\tif (!eth)\n\t\t\t\tgoto out_bad;\n \t\t\tproto = eth->h_proto;\n \t\t\tnhoff += sizeof(*eth);\n \t\t}\n\t\tgoto again;\n\t}\n\tcase NEXTHDR_HOP:\n\tcase NEXTHDR_ROUTING:\n\tcase NEXTHDR_DEST: {\n\t\tu8 _opthdr[2], *opthdr;\n\n\t\tif (proto != htons(ETH_P_IPV6))\n\t\t\tbreak;\n\n \t\topthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),\n \t\t\t\t\t      data, hlen, &_opthdr);\n \t\tif (!opthdr)\n\t\t\tgoto out_bad;\n \n \t\tip_proto = opthdr[0];\n \t\tnhoff += (opthdr[1] + 1) << 3;\n\n\t\tgoto ip_proto_again;\n\t}\n\tcase IPPROTO_IPIP:\n\t\tproto = htons(ETH_P_IP);\n\t\tgoto ip;\n\tcase IPPROTO_IPV6:\n\t\tproto = htons(ETH_P_IPV6);\n\t\tgoto ipv6;\n\tcase IPPROTO_MPLS:\n\t\tproto = htons(ETH_P_MPLS_UC);\n\t\tgoto mpls;\n\tdefault:\n \t\tbreak;\n \t}\n \n \tif (skb_flow_dissector_uses_key(flow_dissector,\n \t\t\t\t\tFLOW_DISSECTOR_KEY_PORTS)) {\n \t\tkey_ports = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_PORTS,\n\t\t\t\t\t\t      target_container);\n\t\tkey_ports->ports = __skb_flow_get_ports(skb, nhoff, ip_proto,\n \t\t\t\t\t\t\tdata, hlen);\n \t}\n \nout_good:\n\tret = true;\n\nout_bad:\n\tkey_basic->n_proto = proto;\n\tkey_basic->ip_proto = ip_proto;\n\tkey_control->thoff = (u16)nhoff;\n\n\treturn ret;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142360,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,\n                            const uint8_t *name, uint8_t *dst, int dst_size)\n {\n     int namelen = strlen(name);\n     int len;\n \n    while (*data != AMF_DATA_TYPE_OBJECT && data < data_end) {\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0)\n            len = data_end - data;\n        data += len;\n     }\n    if (data_end - data < 3)\n         return -1;\n    data++;\n     for (;;) {\n        int size = bytestream_get_be16(&data);\n         if (!size)\n             break;\n        if (size < 0 || size >= data_end - data)\n             return -1;\n        data += size;\n        if (size == namelen && !memcmp(data-size, name, namelen)) {\n            switch (*data++) {\n             case AMF_DATA_TYPE_NUMBER:\n                snprintf(dst, dst_size, \"%g\", av_int2double(AV_RB64(data)));\n                 break;\n             case AMF_DATA_TYPE_BOOL:\n                snprintf(dst, dst_size, \"%s\", *data ? \"true\" : \"false\");\n                 break;\n             case AMF_DATA_TYPE_STRING:\n                len = bytestream_get_be16(&data);\n                av_strlcpy(dst, data, FFMIN(len+1, dst_size));\n                 break;\n             default:\n                 return -1;\n             }\n             return 0;\n         }\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0 || len >= data_end - data)\n             return -1;\n        data += len;\n     }\n     return -1;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142471,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,\nstatic int amf_get_field_value2(GetByteContext *gb,\n                            const uint8_t *name, uint8_t *dst, int dst_size)\n {\n     int namelen = strlen(name);\n     int len;\n \n    while (bytestream2_peek_byte(gb) != AMF_DATA_TYPE_OBJECT && bytestream2_get_bytes_left(gb) > 0) {\n        int ret = amf_tag_skip(gb);\n        if (ret < 0)\n            return -1;\n     }\n    if (bytestream2_get_bytes_left(gb) < 3)\n         return -1;\n    bytestream2_get_byte(gb);\n\n     for (;;) {\n        int size = bytestream2_get_be16(gb);\n         if (!size)\n             break;\n        if (size < 0 || size >= bytestream2_get_bytes_left(gb))\n             return -1;\n        bytestream2_skip(gb, size);\n        if (size == namelen && !memcmp(gb->buffer-size, name, namelen)) {\n            switch (bytestream2_get_byte(gb)) {\n             case AMF_DATA_TYPE_NUMBER:\n                snprintf(dst, dst_size, \"%g\", av_int2double(bytestream2_get_be64(gb)));\n                 break;\n             case AMF_DATA_TYPE_BOOL:\n                snprintf(dst, dst_size, \"%s\", bytestream2_get_byte(gb) ? \"true\" : \"false\");\n                 break;\n             case AMF_DATA_TYPE_STRING:\n                len = bytestream2_get_be16(gb);\n                if (dst_size < 1)\n                    return -1;\n                if (dst_size < len + 1)\n                    len = dst_size - 1;\n                bytestream2_get_buffer(gb, dst, len);\n                dst[len] = 0;\n                 break;\n             default:\n                 return -1;\n             }\n             return 0;\n         }\n        len = amf_tag_skip(gb);\n        if (len < 0 || bytestream2_get_bytes_left(gb) <= 0)\n             return -1;\n     }\n     return -1;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142472,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int __ip6_append_data(struct sock *sk,\n\t\t\t     struct flowi6 *fl6,\n\t\t\t     struct sk_buff_head *queue,\n\t\t\t     struct inet_cork *cork,\n\t\t\t     struct inet6_cork *v6_cork,\n\t\t\t     struct page_frag *pfrag,\n\t\t\t     int getfrag(void *from, char *to, int offset,\n\t\t\t\t\t int len, int odd, struct sk_buff *skb),\n\t\t\t     void *from, int length, int transhdrlen,\n\t\t\t     unsigned int flags, struct ipcm6_cookie *ipc6,\n\t\t\t     const struct sockcm_cookie *sockc)\n{\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\tunsigned int maxfraglen, fragheaderlen, mtu, orig_mtu;\n\tint exthdrlen = 0;\n\tint dst_exthdrlen = 0;\n\tint hh_len;\n\tint copy;\n\tint err;\n\tint offset = 0;\n\t__u8 tx_flags = 0;\n\tu32 tskey = 0;\n\tstruct rt6_info *rt = (struct rt6_info *)cork->dst;\n\tstruct ipv6_txoptions *opt = v6_cork->opt;\n\tint csummode = CHECKSUM_NONE;\n\tunsigned int maxnonfragsize, headersize;\n\n\tskb = skb_peek_tail(queue);\n\tif (!skb) {\n\t\texthdrlen = opt ? opt->opt_flen : 0;\n\t\tdst_exthdrlen = rt->dst.header_len - rt->rt6i_nfheader_len;\n\t}\n\n\tmtu = cork->fragsize;\n\torig_mtu = mtu;\n\n\thh_len = LL_RESERVED_SPACE(rt->dst.dev);\n\n\tfragheaderlen = sizeof(struct ipv6hdr) + rt->rt6i_nfheader_len +\n\t\t\t(opt ? opt->opt_nflen : 0);\n\tmaxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen -\n\t\t     sizeof(struct frag_hdr);\n\n\theadersize = sizeof(struct ipv6hdr) +\n\t\t     (opt ? opt->opt_flen + opt->opt_nflen : 0) +\n\t\t     (dst_allfrag(&rt->dst) ?\n\t\t      sizeof(struct frag_hdr) : 0) +\n\t\t     rt->rt6i_nfheader_len;\n\n\tif (cork->length + length > mtu - headersize && ipc6->dontfrag &&\n\t    (sk->sk_protocol == IPPROTO_UDP ||\n\t     sk->sk_protocol == IPPROTO_RAW)) {\n\t\tipv6_local_rxpmtu(sk, fl6, mtu - headersize +\n\t\t\t\tsizeof(struct ipv6hdr));\n\t\tgoto emsgsize;\n\t}\n\n\tif (ip6_sk_ignore_df(sk))\n\t\tmaxnonfragsize = sizeof(struct ipv6hdr) + IPV6_MAXPLEN;\n\telse\n\t\tmaxnonfragsize = mtu;\n\n\tif (cork->length + length > maxnonfragsize - headersize) {\nemsgsize:\n\t\tipv6_local_error(sk, EMSGSIZE, fl6,\n\t\t\t\t mtu - headersize +\n\t\t\t\t sizeof(struct ipv6hdr));\n\t\treturn -EMSGSIZE;\n\t}\n\n\t/* CHECKSUM_PARTIAL only with no extension headers and when\n\t * we are not going to fragment\n\t */\n\tif (transhdrlen && sk->sk_protocol == IPPROTO_UDP &&\n\t    headersize == sizeof(struct ipv6hdr) &&\n\t    length <= mtu - headersize &&\n\t    !(flags & MSG_MORE) &&\n\t    rt->dst.dev->features & (NETIF_F_IPV6_CSUM | NETIF_F_HW_CSUM))\n\t\tcsummode = CHECKSUM_PARTIAL;\n\n\tif (sk->sk_type == SOCK_DGRAM || sk->sk_type == SOCK_RAW) {\n\t\tsock_tx_timestamp(sk, sockc->tsflags, &tx_flags);\n\t\tif (tx_flags & SKBTX_ANY_SW_TSTAMP &&\n\t\t    sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)\n\t\t\ttskey = sk->sk_tskey++;\n\t}\n\n\t/*\n\t * Let's try using as much space as possible.\n\t * Use MTU if total length of the message fits into the MTU.\n\t * Otherwise, we need to reserve fragment header and\n\t * fragment alignment (= 8-15 octects, in total).\n\t *\n\t * Note that we may need to \"move\" the data from the tail of\n\t * of the buffer to the new fragment when we split\n\t * the message.\n\t *\n\t * FIXME: It may be fragmented into multiple chunks\n\t *        at once if non-fragmentable extension headers\n\t *        are too large.\n\t * --yoshfuji\n\t */\n\n\tcork->length += length;\n\tif ((((length + fragheaderlen) > mtu) ||\n\t     (skb && skb_is_gso(skb))) &&\n\t    (sk->sk_protocol == IPPROTO_UDP) &&\n\t    (rt->dst.dev->features & NETIF_F_UFO) && !dst_xfrm(&rt->dst) &&\n\t    (sk->sk_type == SOCK_DGRAM) && !udp_get_no_check6_tx(sk)) {\n\t\terr = ip6_ufo_append_data(sk, queue, getfrag, from, length,\n\t\t\t\t\t  hh_len, fragheaderlen, exthdrlen,\n\t\t\t\t\t  transhdrlen, mtu, flags, fl6);\n\t\tif (err)\n\t\t\tgoto error;\n\t\treturn 0;\n\t}\n\n\tif (!skb)\n\t\tgoto alloc_new_skb;\n\n\twhile (length > 0) {\n\t\t/* Check if the remaining data fits into current packet. */\n\t\tcopy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len;\n\t\tif (copy < length)\n\t\t\tcopy = maxfraglen - skb->len;\n\n\t\tif (copy <= 0) {\n\t\t\tchar *data;\n\t\t\tunsigned int datalen;\n\t\t\tunsigned int fraglen;\n\t\t\tunsigned int fraggap;\n\t\t\tunsigned int alloclen;\nalloc_new_skb:\n\t\t\t/* There's no room in the current skb */\n\t\t\tif (skb)\n\t\t\t\tfraggap = skb->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\t\t\t/* update mtu and maxfraglen if necessary */\n\t\t\tif (!skb || !skb_prev)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt,\n\t\t\t\t\t\t    orig_mtu);\n\n\t\t\tskb_prev = skb;\n\n\t\t\t/*\n\t\t\t * If remaining data exceeds the mtu,\n\t\t\t * we know we need more fragment(s).\n\t\t\t */\n\t\t\tdatalen = length + fraggap;\n\n\t\t\tif (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)\n\t\t\t\tdatalen = maxfraglen - fragheaderlen - rt->dst.trailer_len;\n\t\t\tif ((flags & MSG_MORE) &&\n\t\t\t    !(rt->dst.dev->features&NETIF_F_SG))\n\t\t\t\talloclen = mtu;\n\t\t\telse\n\t\t\t\talloclen = datalen + fragheaderlen;\n\n\t\t\talloclen += dst_exthdrlen;\n\n\t\t\tif (datalen != length + fraggap) {\n\t\t\t\t/*\n\t\t\t\t * this is not the last fragment, the trailer\n\t\t\t\t * space is regarded as data space.\n\t\t\t\t */\n\t\t\t\tdatalen += rt->dst.trailer_len;\n\t\t\t}\n\n\t\t\talloclen += rt->dst.trailer_len;\n\t\t\tfraglen = datalen + fragheaderlen;\n\n\t\t\t/*\n\t\t\t * We just reserve space for fragment header.\n\t\t\t * Note: this may be overallocation if the message\n\t\t\t * (without MSG_MORE) fits into the MTU.\n \t\t\t */\n \t\t\talloclen += sizeof(struct frag_hdr);\n \n \t\t\tif (transhdrlen) {\n \t\t\t\tskb = sock_alloc_send_skb(sk,\n \t\t\t\t\t\talloclen + hh_len,\n\t\t\t\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\t\t} else {\n\t\t\t\tskb = NULL;\n\t\t\t\tif (atomic_read(&sk->sk_wmem_alloc) <=\n\t\t\t\t    2 * sk->sk_sndbuf)\n\t\t\t\t\tskb = sock_wmalloc(sk,\n\t\t\t\t\t\t\t   alloclen + hh_len, 1,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\t\tif (unlikely(!skb))\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t}\n\t\t\tif (!skb)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t *\tFill in the control structures\n\t\t\t */\n\t\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\t\tskb->ip_summed = csummode;\n\t\t\tskb->csum = 0;\n\t\t\t/* reserve for fragmentation and ipsec header */\n\t\t\tskb_reserve(skb, hh_len + sizeof(struct frag_hdr) +\n\t\t\t\t    dst_exthdrlen);\n\n\t\t\t/* Only the initial fragment is time stamped */\n\t\t\tskb_shinfo(skb)->tx_flags = tx_flags;\n\t\t\ttx_flags = 0;\n\t\t\tskb_shinfo(skb)->tskey = tskey;\n\t\t\ttskey = 0;\n\n\t\t\t/*\n\t\t\t *\tFind where to start putting bytes\n\t\t\t */\n\t\t\tdata = skb_put(skb, fraglen);\n\t\t\tskb_set_network_header(skb, exthdrlen);\n\t\t\tdata += fragheaderlen;\n\t\t\tskb->transport_header = (skb->network_header +\n\t\t\t\t\t\t fragheaderlen);\n\t\t\tif (fraggap) {\n\t\t\t\tskb->csum = skb_copy_and_csum_bits(\n\t\t\t\t\tskb_prev, maxfraglen,\n\t\t\t\t\tdata + transhdrlen, fraggap, 0);\n\t\t\t\tskb_prev->csum = csum_sub(skb_prev->csum,\n\t\t\t\t\t\t\t  skb->csum);\n \t\t\t\tdata += fraggap;\n \t\t\t\tpskb_trim_unique(skb_prev, maxfraglen);\n \t\t\t}\n\t\t\tcopy = datalen - transhdrlen - fraggap;\n\t\t\tif (copy < 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t} else if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) {\n \t\t\t\terr = -EFAULT;\n \t\t\t\tkfree_skb(skb);\n \t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\toffset += copy;\n\t\t\tlength -= datalen - fraggap;\n\t\t\ttranshdrlen = 0;\n\t\t\texthdrlen = 0;\n\t\t\tdst_exthdrlen = 0;\n\n\t\t\tif ((flags & MSG_CONFIRM) && !skb_prev)\n\t\t\t\tskb_set_dst_pending_confirm(skb, 1);\n\n\t\t\t/*\n\t\t\t * Put the packet on the pending queue\n\t\t\t */\n\t\t\t__skb_queue_tail(queue, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (copy > length)\n\t\t\tcopy = length;\n\n\t\tif (!(rt->dst.dev->features&NETIF_F_SG)) {\n\t\t\tunsigned int off;\n\n\t\t\toff = skb->len;\n\t\t\tif (getfrag(from, skb_put(skb, copy),\n\t\t\t\t\t\toffset, copy, off, skb) < 0) {\n\t\t\t\t__skb_trim(skb, off);\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tint i = skb_shinfo(skb)->nr_frags;\n\n\t\t\terr = -ENOMEM;\n\t\t\tif (!sk_page_frag_refill(sk, pfrag))\n\t\t\t\tgoto error;\n\n\t\t\tif (!skb_can_coalesce(skb, i, pfrag->page,\n\t\t\t\t\t      pfrag->offset)) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tif (i == MAX_SKB_FRAGS)\n\t\t\t\t\tgoto error;\n\n\t\t\t\t__skb_fill_page_desc(skb, i, pfrag->page,\n\t\t\t\t\t\t     pfrag->offset, 0);\n\t\t\t\tskb_shinfo(skb)->nr_frags = ++i;\n\t\t\t\tget_page(pfrag->page);\n\t\t\t}\n\t\t\tcopy = min_t(int, copy, pfrag->size - pfrag->offset);\n\t\t\tif (getfrag(from,\n\t\t\t\t    page_address(pfrag->page) + pfrag->offset,\n\t\t\t\t    offset, copy, skb->len, skb) < 0)\n\t\t\t\tgoto error_efault;\n\n\t\t\tpfrag->offset += copy;\n\t\t\tskb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);\n\t\t\tskb->len += copy;\n\t\t\tskb->data_len += copy;\n\t\t\tskb->truesize += copy;\n\t\t\tatomic_add(copy, &sk->sk_wmem_alloc);\n\t\t}\n\t\toffset += copy;\n\t\tlength -= copy;\n\t}\n\n\treturn 0;\n\nerror_efault:\n\terr = -EFAULT;\nerror:\n\tcork->length -= length;\n\tIP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142527,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int __ip6_append_data(struct sock *sk,\n\t\t\t     struct flowi6 *fl6,\n\t\t\t     struct sk_buff_head *queue,\n\t\t\t     struct inet_cork *cork,\n\t\t\t     struct inet6_cork *v6_cork,\n\t\t\t     struct page_frag *pfrag,\n\t\t\t     int getfrag(void *from, char *to, int offset,\n\t\t\t\t\t int len, int odd, struct sk_buff *skb),\n\t\t\t     void *from, int length, int transhdrlen,\n\t\t\t     unsigned int flags, struct ipcm6_cookie *ipc6,\n\t\t\t     const struct sockcm_cookie *sockc)\n{\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\tunsigned int maxfraglen, fragheaderlen, mtu, orig_mtu;\n\tint exthdrlen = 0;\n\tint dst_exthdrlen = 0;\n\tint hh_len;\n\tint copy;\n\tint err;\n\tint offset = 0;\n\t__u8 tx_flags = 0;\n\tu32 tskey = 0;\n\tstruct rt6_info *rt = (struct rt6_info *)cork->dst;\n\tstruct ipv6_txoptions *opt = v6_cork->opt;\n\tint csummode = CHECKSUM_NONE;\n\tunsigned int maxnonfragsize, headersize;\n\n\tskb = skb_peek_tail(queue);\n\tif (!skb) {\n\t\texthdrlen = opt ? opt->opt_flen : 0;\n\t\tdst_exthdrlen = rt->dst.header_len - rt->rt6i_nfheader_len;\n\t}\n\n\tmtu = cork->fragsize;\n\torig_mtu = mtu;\n\n\thh_len = LL_RESERVED_SPACE(rt->dst.dev);\n\n\tfragheaderlen = sizeof(struct ipv6hdr) + rt->rt6i_nfheader_len +\n\t\t\t(opt ? opt->opt_nflen : 0);\n\tmaxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen -\n\t\t     sizeof(struct frag_hdr);\n\n\theadersize = sizeof(struct ipv6hdr) +\n\t\t     (opt ? opt->opt_flen + opt->opt_nflen : 0) +\n\t\t     (dst_allfrag(&rt->dst) ?\n\t\t      sizeof(struct frag_hdr) : 0) +\n\t\t     rt->rt6i_nfheader_len;\n\n\tif (cork->length + length > mtu - headersize && ipc6->dontfrag &&\n\t    (sk->sk_protocol == IPPROTO_UDP ||\n\t     sk->sk_protocol == IPPROTO_RAW)) {\n\t\tipv6_local_rxpmtu(sk, fl6, mtu - headersize +\n\t\t\t\tsizeof(struct ipv6hdr));\n\t\tgoto emsgsize;\n\t}\n\n\tif (ip6_sk_ignore_df(sk))\n\t\tmaxnonfragsize = sizeof(struct ipv6hdr) + IPV6_MAXPLEN;\n\telse\n\t\tmaxnonfragsize = mtu;\n\n\tif (cork->length + length > maxnonfragsize - headersize) {\nemsgsize:\n\t\tipv6_local_error(sk, EMSGSIZE, fl6,\n\t\t\t\t mtu - headersize +\n\t\t\t\t sizeof(struct ipv6hdr));\n\t\treturn -EMSGSIZE;\n\t}\n\n\t/* CHECKSUM_PARTIAL only with no extension headers and when\n\t * we are not going to fragment\n\t */\n\tif (transhdrlen && sk->sk_protocol == IPPROTO_UDP &&\n\t    headersize == sizeof(struct ipv6hdr) &&\n\t    length <= mtu - headersize &&\n\t    !(flags & MSG_MORE) &&\n\t    rt->dst.dev->features & (NETIF_F_IPV6_CSUM | NETIF_F_HW_CSUM))\n\t\tcsummode = CHECKSUM_PARTIAL;\n\n\tif (sk->sk_type == SOCK_DGRAM || sk->sk_type == SOCK_RAW) {\n\t\tsock_tx_timestamp(sk, sockc->tsflags, &tx_flags);\n\t\tif (tx_flags & SKBTX_ANY_SW_TSTAMP &&\n\t\t    sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)\n\t\t\ttskey = sk->sk_tskey++;\n\t}\n\n\t/*\n\t * Let's try using as much space as possible.\n\t * Use MTU if total length of the message fits into the MTU.\n\t * Otherwise, we need to reserve fragment header and\n\t * fragment alignment (= 8-15 octects, in total).\n\t *\n\t * Note that we may need to \"move\" the data from the tail of\n\t * of the buffer to the new fragment when we split\n\t * the message.\n\t *\n\t * FIXME: It may be fragmented into multiple chunks\n\t *        at once if non-fragmentable extension headers\n\t *        are too large.\n\t * --yoshfuji\n\t */\n\n\tcork->length += length;\n\tif ((((length + fragheaderlen) > mtu) ||\n\t     (skb && skb_is_gso(skb))) &&\n\t    (sk->sk_protocol == IPPROTO_UDP) &&\n\t    (rt->dst.dev->features & NETIF_F_UFO) && !dst_xfrm(&rt->dst) &&\n\t    (sk->sk_type == SOCK_DGRAM) && !udp_get_no_check6_tx(sk)) {\n\t\terr = ip6_ufo_append_data(sk, queue, getfrag, from, length,\n\t\t\t\t\t  hh_len, fragheaderlen, exthdrlen,\n\t\t\t\t\t  transhdrlen, mtu, flags, fl6);\n\t\tif (err)\n\t\t\tgoto error;\n\t\treturn 0;\n\t}\n\n\tif (!skb)\n\t\tgoto alloc_new_skb;\n\n\twhile (length > 0) {\n\t\t/* Check if the remaining data fits into current packet. */\n\t\tcopy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len;\n\t\tif (copy < length)\n\t\t\tcopy = maxfraglen - skb->len;\n\n\t\tif (copy <= 0) {\n\t\t\tchar *data;\n\t\t\tunsigned int datalen;\n\t\t\tunsigned int fraglen;\n\t\t\tunsigned int fraggap;\n\t\t\tunsigned int alloclen;\nalloc_new_skb:\n\t\t\t/* There's no room in the current skb */\n\t\t\tif (skb)\n\t\t\t\tfraggap = skb->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\t\t\t/* update mtu and maxfraglen if necessary */\n\t\t\tif (!skb || !skb_prev)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt,\n\t\t\t\t\t\t    orig_mtu);\n\n\t\t\tskb_prev = skb;\n\n\t\t\t/*\n\t\t\t * If remaining data exceeds the mtu,\n\t\t\t * we know we need more fragment(s).\n\t\t\t */\n\t\t\tdatalen = length + fraggap;\n\n\t\t\tif (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)\n\t\t\t\tdatalen = maxfraglen - fragheaderlen - rt->dst.trailer_len;\n\t\t\tif ((flags & MSG_MORE) &&\n\t\t\t    !(rt->dst.dev->features&NETIF_F_SG))\n\t\t\t\talloclen = mtu;\n\t\t\telse\n\t\t\t\talloclen = datalen + fragheaderlen;\n\n\t\t\talloclen += dst_exthdrlen;\n\n\t\t\tif (datalen != length + fraggap) {\n\t\t\t\t/*\n\t\t\t\t * this is not the last fragment, the trailer\n\t\t\t\t * space is regarded as data space.\n\t\t\t\t */\n\t\t\t\tdatalen += rt->dst.trailer_len;\n\t\t\t}\n\n\t\t\talloclen += rt->dst.trailer_len;\n\t\t\tfraglen = datalen + fragheaderlen;\n\n\t\t\t/*\n\t\t\t * We just reserve space for fragment header.\n\t\t\t * Note: this may be overallocation if the message\n\t\t\t * (without MSG_MORE) fits into the MTU.\n \t\t\t */\n \t\t\talloclen += sizeof(struct frag_hdr);\n \n\t\t\tcopy = datalen - transhdrlen - fraggap;\n\t\t\tif (copy < 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n \t\t\tif (transhdrlen) {\n \t\t\t\tskb = sock_alloc_send_skb(sk,\n \t\t\t\t\t\talloclen + hh_len,\n\t\t\t\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\t\t} else {\n\t\t\t\tskb = NULL;\n\t\t\t\tif (atomic_read(&sk->sk_wmem_alloc) <=\n\t\t\t\t    2 * sk->sk_sndbuf)\n\t\t\t\t\tskb = sock_wmalloc(sk,\n\t\t\t\t\t\t\t   alloclen + hh_len, 1,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\t\tif (unlikely(!skb))\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t}\n\t\t\tif (!skb)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t *\tFill in the control structures\n\t\t\t */\n\t\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\t\tskb->ip_summed = csummode;\n\t\t\tskb->csum = 0;\n\t\t\t/* reserve for fragmentation and ipsec header */\n\t\t\tskb_reserve(skb, hh_len + sizeof(struct frag_hdr) +\n\t\t\t\t    dst_exthdrlen);\n\n\t\t\t/* Only the initial fragment is time stamped */\n\t\t\tskb_shinfo(skb)->tx_flags = tx_flags;\n\t\t\ttx_flags = 0;\n\t\t\tskb_shinfo(skb)->tskey = tskey;\n\t\t\ttskey = 0;\n\n\t\t\t/*\n\t\t\t *\tFind where to start putting bytes\n\t\t\t */\n\t\t\tdata = skb_put(skb, fraglen);\n\t\t\tskb_set_network_header(skb, exthdrlen);\n\t\t\tdata += fragheaderlen;\n\t\t\tskb->transport_header = (skb->network_header +\n\t\t\t\t\t\t fragheaderlen);\n\t\t\tif (fraggap) {\n\t\t\t\tskb->csum = skb_copy_and_csum_bits(\n\t\t\t\t\tskb_prev, maxfraglen,\n\t\t\t\t\tdata + transhdrlen, fraggap, 0);\n\t\t\t\tskb_prev->csum = csum_sub(skb_prev->csum,\n\t\t\t\t\t\t\t  skb->csum);\n \t\t\t\tdata += fraggap;\n \t\t\t\tpskb_trim_unique(skb_prev, maxfraglen);\n \t\t\t}\n\t\t\tif (copy > 0 &&\n\t\t\t    getfrag(from, data + transhdrlen, offset,\n\t\t\t\t    copy, fraggap, skb) < 0) {\n \t\t\t\terr = -EFAULT;\n \t\t\t\tkfree_skb(skb);\n \t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\toffset += copy;\n\t\t\tlength -= datalen - fraggap;\n\t\t\ttranshdrlen = 0;\n\t\t\texthdrlen = 0;\n\t\t\tdst_exthdrlen = 0;\n\n\t\t\tif ((flags & MSG_CONFIRM) && !skb_prev)\n\t\t\t\tskb_set_dst_pending_confirm(skb, 1);\n\n\t\t\t/*\n\t\t\t * Put the packet on the pending queue\n\t\t\t */\n\t\t\t__skb_queue_tail(queue, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (copy > length)\n\t\t\tcopy = length;\n\n\t\tif (!(rt->dst.dev->features&NETIF_F_SG)) {\n\t\t\tunsigned int off;\n\n\t\t\toff = skb->len;\n\t\t\tif (getfrag(from, skb_put(skb, copy),\n\t\t\t\t\t\toffset, copy, off, skb) < 0) {\n\t\t\t\t__skb_trim(skb, off);\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tint i = skb_shinfo(skb)->nr_frags;\n\n\t\t\terr = -ENOMEM;\n\t\t\tif (!sk_page_frag_refill(sk, pfrag))\n\t\t\t\tgoto error;\n\n\t\t\tif (!skb_can_coalesce(skb, i, pfrag->page,\n\t\t\t\t\t      pfrag->offset)) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tif (i == MAX_SKB_FRAGS)\n\t\t\t\t\tgoto error;\n\n\t\t\t\t__skb_fill_page_desc(skb, i, pfrag->page,\n\t\t\t\t\t\t     pfrag->offset, 0);\n\t\t\t\tskb_shinfo(skb)->nr_frags = ++i;\n\t\t\t\tget_page(pfrag->page);\n\t\t\t}\n\t\t\tcopy = min_t(int, copy, pfrag->size - pfrag->offset);\n\t\t\tif (getfrag(from,\n\t\t\t\t    page_address(pfrag->page) + pfrag->offset,\n\t\t\t\t    offset, copy, skb->len, skb) < 0)\n\t\t\t\tgoto error_efault;\n\n\t\t\tpfrag->offset += copy;\n\t\t\tskb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);\n\t\t\tskb->len += copy;\n\t\t\tskb->data_len += copy;\n\t\t\tskb->truesize += copy;\n\t\t\tatomic_add(copy, &sk->sk_wmem_alloc);\n\t\t}\n\t\toffset += copy;\n\t\tlength -= copy;\n\t}\n\n\treturn 0;\n\nerror_efault:\n\terr = -EFAULT;\nerror:\n\tcork->length -= length;\n\tIP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142528,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {\n        int r;\n\n        assert(p);\n        assert(key);\n\n        /* Checks if the specified packet is a reply for the specified\n         * key and the specified key is the only one in the question\n         * section. */\n\n        if (DNS_PACKET_QR(p) != 1)\n                return 0;\n\n        /* Let's unpack the packet, if that hasn't happened yet. */\n        r = dns_packet_extract(p);\n         if (r < 0)\n                 return r;\n \n         if (p->question->n_keys != 1)\n                 return 0;\n \n        return dns_resource_key_equal(p->question->keys[0], key);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142533,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {\n        int r;\n\n        assert(p);\n        assert(key);\n\n        /* Checks if the specified packet is a reply for the specified\n         * key and the specified key is the only one in the question\n         * section. */\n\n        if (DNS_PACKET_QR(p) != 1)\n                return 0;\n\n        /* Let's unpack the packet, if that hasn't happened yet. */\n        r = dns_packet_extract(p);\n         if (r < 0)\n                 return r;\n \n        if (!p->question)\n                return 0;\n\n         if (p->question->n_keys != 1)\n                 return 0;\n \n        return dns_resource_key_equal(p->question->keys[0], key);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142534,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define SkipLinesOp  0x01\n#define SetColorOp  0x02\n#define SkipPixelsOp  0x03\n #define ByteDataOp  0x05\n #define RunDataOp  0x06\n #define EOFOp  0x07\n \n   char\n     magick[12];\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  int\n    opcode,\n    operand,\n    status;\n\n  MagickStatusType\n    flags;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    map_length,\n    number_colormaps,\n    number_planes,\n    number_planes_filled,\n    one,\n    pixel_info_length;\n\n  ssize_t\n    count,\n    offset,\n    y;\n\n  unsigned char\n    background_color[256],\n    *colormap,\n    pixel,\n    plane,\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n   /*\n     Determine if this a RLE file.\n   */\n   count=ReadBlob(image,2,(unsigned char *) magick);\n   if ((count != 2) || (memcmp(magick,\"\\122\\314\",2) != 0))\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n     /*\n       Read image header.\n     */\n    image->page.x=ReadBlobLSBShort(image);\n    image->page.y=ReadBlobLSBShort(image);\n     image->columns=ReadBlobLSBShort(image);\n     image->rows=ReadBlobLSBShort(image);\n     flags=(MagickStatusType) ReadBlobByte(image);\n    image->matte=flags & 0x04 ? MagickTrue : MagickFalse;\n    number_planes=(size_t) ReadBlobByte(image);\n    bits_per_pixel=(size_t) ReadBlobByte(image);\n    number_colormaps=(size_t) ReadBlobByte(image);\n     map_length=(unsigned char) ReadBlobByte(image);\n     if (map_length >= 22)\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     one=1;\n     map_length=one << map_length;\n     if ((number_planes == 0) || (number_planes == 2) ||\n        ((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||\n        (image->columns == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (flags & 0x02)\n      {\n        /*\n          No background color-- initialize to black.\n        */\n        for (i=0; i < (ssize_t) number_planes; i++)\n          background_color[i]=0;\n        (void) ReadBlobByte(image);\n      }\n    else\n      {\n        /*\n          Initialize background color.\n        */\n        p=background_color;\n        for (i=0; i < (ssize_t) number_planes; i++)\n          *p++=(unsigned char) ReadBlobByte(image);\n      }\n     if ((number_planes & 0x01) == 0)\n       (void) ReadBlobByte(image);\n     if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n     colormap=(unsigned char *) NULL;\n     if (number_colormaps != 0)\n       {\n        /*\n          Read image colormaps.\n        */\n        colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,\n          3*map_length*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n         p=colormap;\n         for (i=0; i < (ssize_t) number_colormaps; i++)\n           for (x=0; x < (ssize_t) map_length; x++)\n             *p++=(unsigned char) ScaleQuantumToChar(ScaleShortToQuantum(\n               ReadBlobLSBShort(image)));\n       }\n     if ((flags & 0x08) != 0)\n       {\n        char\n          *comment;\n\n        size_t\n          length;\n\n        /*\n          Read image comment.\n        */\n        length=ReadBlobLSBShort(image);\n        if (length != 0)\n          {\n            comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));\n            if (comment == (char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            (void) ReadBlob(image,length-1,(unsigned char *) comment);\n            comment[length-1]='\\0';\n            (void) SetImageProperty(image,\"comment\",comment);\n            comment=DestroyString(comment);\n            if ((length & 0x01) == 0)\n              (void) ReadBlobByte(image);\n           }\n       }\n     if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    /*\n      Allocate RLE pixels.\n    */\n    if (image->matte != MagickFalse)\n      number_planes++;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    number_planes_filled=(number_planes % 2 == 0) ? number_planes :\n      number_planes+1;\n    if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*\n         number_planes_filled))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info=AcquireVirtualMemory(image->columns,image->rows*\n      MagickMax(number_planes_filled,4)*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info_length=image->columns*image->rows*\n      MagickMax(number_planes_filled,4);\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,pixel_info_length);\n    if ((flags & 0x01) && !(flags & 0x02))\n      {\n        ssize_t\n          j;\n\n        /*\n          Set background color.\n        */\n        p=pixels;\n        for (i=0; i < (ssize_t) number_pixels; i++)\n        {\n          if (image->matte == MagickFalse)\n            for (j=0; j < (ssize_t) number_planes; j++)\n              *p++=background_color[j];\n          else\n            {\n              for (j=0; j < (ssize_t) (number_planes-1); j++)\n                *p++=background_color[j];\n              *p++=0;  /* initialize matte channel */\n            }\n        }\n      }\n    /*\n      Read runlength-encoded image.\n    */\n    plane=0;\n     x=0;\n     y=0;\n     opcode=ReadBlobByte(image);\n     do\n     {\n       switch (opcode & 0x3f)\n       {\n         case SkipLinesOp:\n         {\n           operand=ReadBlobByte(image);\n           if (opcode & 0x40)\n            operand=ReadBlobLSBSignedShort(image);\n           x=0;\n           y+=operand;\n           break;\n         }\n         case SetColorOp:\n         {\n           operand=ReadBlobByte(image);\n           plane=(unsigned char) operand;\n           if (plane == 255)\n             plane=(unsigned char) (number_planes-1);\n          x=0;\n          break;\n        }\n         case SkipPixelsOp:\n         {\n           operand=ReadBlobByte(image);\n           if (opcode & 0x40)\n            operand=ReadBlobLSBSignedShort(image);\n           x+=operand;\n           break;\n         }\n         case ByteDataOp:\n         {\n           operand=ReadBlobByte(image);\n           if (opcode & 0x40)\n            operand=ReadBlobLSBSignedShort(image);\n          offset=((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane;\n           operand++;\n           if ((offset < 0) ||\n              (offset+((size_t) operand*number_planes) > pixel_info_length))\n             {\n               if (number_colormaps != 0)\n                 colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            pixel=(unsigned char) ReadBlobByte(image);\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          if (operand & 0x01)\n            (void) ReadBlobByte(image);\n          x+=operand;\n          break;\n        }\n         case RunDataOp:\n         {\n           operand=ReadBlobByte(image);\n           if (opcode & 0x40)\n            operand=ReadBlobLSBSignedShort(image);\n           pixel=(unsigned char) ReadBlobByte(image);\n           (void) ReadBlobByte(image);\n           operand++;\n          offset=((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane;\n           if ((offset < 0) ||\n              (offset+((size_t) operand*number_planes) > pixel_info_length))\n             {\n               if (number_colormaps != 0)\n                 colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          x+=operand;\n          break;\n        }\n        default:\n           break;\n       }\n       opcode=ReadBlobByte(image);\n     } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));\n     if (number_colormaps != 0)\n       {\n        MagickStatusType\n          mask;\n\n        /*\n          Apply colormap affineation to image.\n        */\n        mask=(MagickStatusType) (map_length-1);\n        p=pixels;\n        x=(ssize_t) number_planes;\n         if (number_colormaps == 1)\n           for (i=0; i < (ssize_t) number_pixels; i++)\n           {\n            if (IsValidColormapIndex(image,*p & mask,&index,exception) ==\n                 MagickFalse)\n               break;\n             *p=colormap[(ssize_t) index];\n            p++;\n          }\n        else\n          if ((number_planes >= 3) && (number_colormaps >= 3))\n             for (i=0; i < (ssize_t) number_pixels; i++)\n               for (x=0; x < (ssize_t) number_planes; x++)\n               {\n                if (IsValidColormapIndex(image,(size_t) (x*map_length+\n                     (*p & mask)),&index,exception) == MagickFalse)\n                   break;\n                 *p=colormap[(ssize_t) index];\n                p++;\n              }\n        if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))\n          {\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n          }\n      }\n    /*\n      Initialize image structure.\n    */\n    if (number_planes >= 3)\n      {\n        /*\n          Convert raster image to DirectClass pixel packets.\n        */\n        p=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum(*p++));\n            SetPixelGreen(q,ScaleCharToQuantum(*p++));\n            SetPixelBlue(q,ScaleCharToQuantum(*p++));\n            if (image->matte != MagickFalse)\n              SetPixelAlpha(q,ScaleCharToQuantum(*p++));\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        /*\n          Create colormap.\n        */\n        if (number_colormaps == 0)\n          map_length=256;\n        if (AcquireImageColormap(image,map_length) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        p=colormap;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            /*\n              Pseudocolor.\n            */\n            image->colormap[i].red=ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].green=ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].blue=ScaleCharToQuantum((unsigned char) i);\n          }\n        else\n          if (number_colormaps > 1)\n            for (i=0; i < (ssize_t) image->colors; i++)\n            {\n              image->colormap[i].red=ScaleCharToQuantum(*p);\n              image->colormap[i].green=ScaleCharToQuantum(*(p+map_length));\n              image->colormap[i].blue=ScaleCharToQuantum(*(p+map_length*2));\n              p++;\n            }\n        p=pixels;\n        if (image->matte == MagickFalse)\n          {\n            /*\n              Convert raster image to PseudoClass pixel packets.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) image->columns; x++)\n                SetPixelIndex(indexes+x,*p++);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            (void) SyncImage(image);\n          }\n        else\n          {\n            /*\n              Image has a matte channel-- promote to DirectClass.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                 break;\n               for (x=0; x < (ssize_t) image->columns; x++)\n               {\n                if (IsValidColormapIndex(image,*p++,&index,exception) ==\n                     MagickFalse)\n                   break;\n                 SetPixelRed(q,image->colormap[(ssize_t) index].red);\n                if (IsValidColormapIndex(image,*p++,&index,exception) ==\n                     MagickFalse)\n                   break;\n                 SetPixelGreen(q,image->colormap[(ssize_t) index].green);\n                if (IsValidColormapIndex(image,*p++,&index,exception) ==\n                     MagickFalse)\n                   break;\n                 SetPixelBlue(q,image->colormap[(ssize_t) index].blue);\n                SetPixelAlpha(q,ScaleCharToQuantum(*p++));\n                q++;\n              }\n              if (x < (ssize_t) image->columns)\n                break;\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            image->colormap=(PixelPacket *) RelinquishMagickMemory(\n              image->colormap);\n            image->storage_class=DirectClass;\n            image->colors=0;\n          }\n      }\n    if (number_colormaps != 0)\n      colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    (void) ReadBlobByte(image);\n    count=ReadBlob(image,2,(unsigned char *) magick);\n    if ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142543,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define SkipLinesOp  0x01\n#define SetColorOp  0x02\n#define SkipPixelsOp  0x03\n #define ByteDataOp  0x05\n #define RunDataOp  0x06\n #define EOFOp  0x07\n#define ThrowRLEException(exception,message) \\\n{ \\\n  if (colormap != (unsigned char *) NULL) \\\n    colormap=(unsigned char *) RelinquishMagickMemory(colormap); \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n \n   char\n     magick[12];\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  int\n    opcode,\n    operand,\n    status;\n\n  MagickStatusType\n    flags;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    map_length,\n    number_colormaps,\n    number_planes,\n    number_planes_filled,\n    one,\n    pixel_info_length;\n\n  ssize_t\n    count,\n    offset,\n    y;\n\n  unsigned char\n    background_color[256],\n    *colormap,\n    pixel,\n    plane,\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n   /*\n     Determine if this a RLE file.\n   */\n  colormap=(unsigned char *) NULL;\n  pixel_info=(MemoryInfo *) NULL;\n   count=ReadBlob(image,2,(unsigned char *) magick);\n   if ((count != 2) || (memcmp(magick,\"\\122\\314\",2) != 0))\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n     /*\n       Read image header.\n     */\n    image->page.x=(ssize_t) ReadBlobLSBShort(image);\n    image->page.y=(ssize_t) ReadBlobLSBShort(image);\n     image->columns=ReadBlobLSBShort(image);\n     image->rows=ReadBlobLSBShort(image);\n     flags=(MagickStatusType) ReadBlobByte(image);\n    image->matte=flags & 0x04 ? MagickTrue : MagickFalse;\n    number_planes=(size_t) ReadBlobByte(image);\n    bits_per_pixel=(size_t) ReadBlobByte(image);\n    number_colormaps=(size_t) ReadBlobByte(image);\n     map_length=(unsigned char) ReadBlobByte(image);\n     if (map_length >= 22)\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (EOFBlob(image) != MagickFalse)\n      ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n     one=1;\n     map_length=one << map_length;\n     if ((number_planes == 0) || (number_planes == 2) ||\n        ((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||\n        (image->columns == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (flags & 0x02)\n      {\n        /*\n          No background color-- initialize to black.\n        */\n        for (i=0; i < (ssize_t) number_planes; i++)\n          background_color[i]=0;\n        (void) ReadBlobByte(image);\n      }\n    else\n      {\n        /*\n          Initialize background color.\n        */\n        p=background_color;\n        for (i=0; i < (ssize_t) number_planes; i++)\n          *p++=(unsigned char) ReadBlobByte(image);\n      }\n     if ((number_planes & 0x01) == 0)\n       (void) ReadBlobByte(image);\n     if (EOFBlob(image) != MagickFalse)\n      ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n     colormap=(unsigned char *) NULL;\n     if (number_colormaps != 0)\n       {\n        /*\n          Read image colormaps.\n        */\n        colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,\n          3*map_length*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n         p=colormap;\n         for (i=0; i < (ssize_t) number_colormaps; i++)\n           for (x=0; x < (ssize_t) map_length; x++)\n          {\n             *p++=(unsigned char) ScaleQuantumToChar(ScaleShortToQuantum(\n               ReadBlobLSBShort(image)));\n            if (EOFBlob(image) != MagickFalse)\n              ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n       }\n     if ((flags & 0x08) != 0)\n       {\n        char\n          *comment;\n\n        size_t\n          length;\n\n        /*\n          Read image comment.\n        */\n        length=ReadBlobLSBShort(image);\n        if (length != 0)\n          {\n            comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));\n            if (comment == (char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            (void) ReadBlob(image,length-1,(unsigned char *) comment);\n            comment[length-1]='\\0';\n            (void) SetImageProperty(image,\"comment\",comment);\n            comment=DestroyString(comment);\n            if ((length & 0x01) == 0)\n              (void) ReadBlobByte(image);\n           }\n       }\n     if (EOFBlob(image) != MagickFalse)\n      ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    /*\n      Allocate RLE pixels.\n    */\n    if (image->matte != MagickFalse)\n      number_planes++;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    number_planes_filled=(number_planes % 2 == 0) ? number_planes :\n      number_planes+1;\n    if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*\n         number_planes_filled))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info=AcquireVirtualMemory(image->columns,image->rows*\n      MagickMax(number_planes_filled,4)*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info_length=image->columns*image->rows*\n      MagickMax(number_planes_filled,4);\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,pixel_info_length);\n    if ((flags & 0x01) && !(flags & 0x02))\n      {\n        ssize_t\n          j;\n\n        /*\n          Set background color.\n        */\n        p=pixels;\n        for (i=0; i < (ssize_t) number_pixels; i++)\n        {\n          if (image->matte == MagickFalse)\n            for (j=0; j < (ssize_t) number_planes; j++)\n              *p++=background_color[j];\n          else\n            {\n              for (j=0; j < (ssize_t) (number_planes-1); j++)\n                *p++=background_color[j];\n              *p++=0;  /* initialize matte channel */\n            }\n        }\n      }\n    /*\n      Read runlength-encoded image.\n    */\n    plane=0;\n     x=0;\n     y=0;\n     opcode=ReadBlobByte(image);\n    if (opcode == EOF)\n      ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n     do\n     {\n       switch (opcode & 0x3f)\n       {\n         case SkipLinesOp:\n         {\n           operand=ReadBlobByte(image);\n          if (opcode == EOF)\n            ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n           if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (opcode == EOF)\n                ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n            }\n           x=0;\n           y+=operand;\n           break;\n         }\n         case SetColorOp:\n         {\n           operand=ReadBlobByte(image);\n          if (opcode == EOF)\n            ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n           plane=(unsigned char) operand;\n           if (plane == 255)\n             plane=(unsigned char) (number_planes-1);\n          x=0;\n          break;\n        }\n         case SkipPixelsOp:\n         {\n           operand=ReadBlobByte(image);\n          if (opcode == EOF)\n            ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n           if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (opcode == EOF)\n                ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n            }\n           x+=operand;\n           break;\n         }\n         case ByteDataOp:\n         {\n           operand=ReadBlobByte(image);\n          if (opcode == EOF)\n            ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n           if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (opcode == EOF)\n                ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n            }\n          offset=(ssize_t) (((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane);\n           operand++;\n           if ((offset < 0) ||\n              ((offset+operand*number_planes) > (ssize_t) pixel_info_length))\n             {\n               if (number_colormaps != 0)\n                 colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            pixel=(unsigned char) ReadBlobByte(image);\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          if (operand & 0x01)\n            (void) ReadBlobByte(image);\n          x+=operand;\n          break;\n        }\n         case RunDataOp:\n         {\n           operand=ReadBlobByte(image);\n          if (opcode == EOF)\n            ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n           if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (opcode == EOF)\n                ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n            }\n           pixel=(unsigned char) ReadBlobByte(image);\n           (void) ReadBlobByte(image);\n           operand++;\n          offset=(ssize_t) (((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane);\n           if ((offset < 0) ||\n              ((offset+operand*number_planes) > (ssize_t) pixel_info_length))\n             {\n               if (number_colormaps != 0)\n                 colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          x+=operand;\n          break;\n        }\n        default:\n           break;\n       }\n       opcode=ReadBlobByte(image);\n      if (opcode == EOF)\n        ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n     } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));\n     if (number_colormaps != 0)\n       {\n        MagickStatusType\n          mask;\n\n        /*\n          Apply colormap affineation to image.\n        */\n        mask=(MagickStatusType) (map_length-1);\n        p=pixels;\n        x=(ssize_t) number_planes;\n         if (number_colormaps == 1)\n           for (i=0; i < (ssize_t) number_pixels; i++)\n           {\n            if (IsValidColormapIndex(image,(ssize_t) (*p & mask),&index,exception) ==\n                 MagickFalse)\n               break;\n             *p=colormap[(ssize_t) index];\n            p++;\n          }\n        else\n          if ((number_planes >= 3) && (number_colormaps >= 3))\n             for (i=0; i < (ssize_t) number_pixels; i++)\n               for (x=0; x < (ssize_t) number_planes; x++)\n               {\n                if (IsValidColormapIndex(image,(ssize_t) (x*map_length+\n                     (*p & mask)),&index,exception) == MagickFalse)\n                   break;\n                 *p=colormap[(ssize_t) index];\n                p++;\n              }\n        if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))\n          {\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n          }\n      }\n    /*\n      Initialize image structure.\n    */\n    if (number_planes >= 3)\n      {\n        /*\n          Convert raster image to DirectClass pixel packets.\n        */\n        p=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum(*p++));\n            SetPixelGreen(q,ScaleCharToQuantum(*p++));\n            SetPixelBlue(q,ScaleCharToQuantum(*p++));\n            if (image->matte != MagickFalse)\n              SetPixelAlpha(q,ScaleCharToQuantum(*p++));\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        /*\n          Create colormap.\n        */\n        if (number_colormaps == 0)\n          map_length=256;\n        if (AcquireImageColormap(image,map_length) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        p=colormap;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            /*\n              Pseudocolor.\n            */\n            image->colormap[i].red=ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].green=ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].blue=ScaleCharToQuantum((unsigned char) i);\n          }\n        else\n          if (number_colormaps > 1)\n            for (i=0; i < (ssize_t) image->colors; i++)\n            {\n              image->colormap[i].red=ScaleCharToQuantum(*p);\n              image->colormap[i].green=ScaleCharToQuantum(*(p+map_length));\n              image->colormap[i].blue=ScaleCharToQuantum(*(p+map_length*2));\n              p++;\n            }\n        p=pixels;\n        if (image->matte == MagickFalse)\n          {\n            /*\n              Convert raster image to PseudoClass pixel packets.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) image->columns; x++)\n                SetPixelIndex(indexes+x,*p++);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            (void) SyncImage(image);\n          }\n        else\n          {\n            /*\n              Image has a matte channel-- promote to DirectClass.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                 break;\n               for (x=0; x < (ssize_t) image->columns; x++)\n               {\n                if (IsValidColormapIndex(image,(ssize_t) *p++,&index,exception) ==\n                     MagickFalse)\n                   break;\n                 SetPixelRed(q,image->colormap[(ssize_t) index].red);\n                if (IsValidColormapIndex(image,(ssize_t) *p++,&index,exception) ==\n                     MagickFalse)\n                   break;\n                 SetPixelGreen(q,image->colormap[(ssize_t) index].green);\n                if (IsValidColormapIndex(image,(ssize_t) *p++,&index,exception) ==\n                     MagickFalse)\n                   break;\n                 SetPixelBlue(q,image->colormap[(ssize_t) index].blue);\n                SetPixelAlpha(q,ScaleCharToQuantum(*p++));\n                q++;\n              }\n              if (x < (ssize_t) image->columns)\n                break;\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            image->colormap=(PixelPacket *) RelinquishMagickMemory(\n              image->colormap);\n            image->storage_class=DirectClass;\n            image->colors=0;\n          }\n      }\n    if (number_colormaps != 0)\n      colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    (void) ReadBlobByte(image);\n    count=ReadBlob(image,2,(unsigned char *) magick);\n    if ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142544,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadOneJNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  Image\n    *alpha_image,\n    *color_image,\n    *image,\n    *jng_image;\n\n  ImageInfo\n    *alpha_image_info,\n    *color_image_info;\n\n  MagickBooleanType\n    logging;\n\n  int\n    unique_filenames;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  png_uint_32\n    jng_height,\n    jng_width;\n\n  png_byte\n    jng_color_type,\n    jng_image_sample_depth,\n    jng_image_compression_method,\n    jng_image_interlace_method,\n    jng_alpha_sample_depth,\n    jng_alpha_compression_method,\n    jng_alpha_filter_method,\n    jng_alpha_interlace_method;\n\n  register const PixelPacket\n    *s;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  unsigned int\n    read_JSEP,\n    reading_idat;\n\n  size_t\n    length;\n\n  jng_alpha_compression_method=0;\n  jng_alpha_sample_depth=8;\n  jng_color_type=0;\n  jng_height=0;\n  jng_width=0;\n  alpha_image=(Image *) NULL;\n  color_image=(Image *) NULL;\n  alpha_image_info=(ImageInfo *) NULL;\n  color_image_info=(ImageInfo *) NULL;\n  unique_filenames=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneJNGImage()\");\n\n  image=mng_info->image;\n\n  if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n    {\n      /*\n        Allocate next image structure.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  AcquireNextImage()\");\n\n      AcquireNextImage(image_info,image);\n\n      if (GetNextImageInList(image) == (Image *) NULL)\n        return(DestroyImageList(image));\n\n      image=SyncNextImageInList(image);\n    }\n  mng_info->image=image;\n\n  /*\n    Signature bytes have already been read.\n  */\n\n  read_JSEP=MagickFalse;\n  reading_idat=MagickFalse;\n  for (;;)\n  {\n    char\n      type[MaxTextExtent];\n\n    unsigned char\n      *chunk;\n\n    unsigned int\n      count;\n\n    /*\n      Read a new JNG chunk.\n    */\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      2*GetBlobSize(image));\n\n    if (status == MagickFalse)\n      break;\n\n    type[0]='\\0';\n    (void) ConcatenateMagickString(type,\"errr\",MaxTextExtent);\n    length=ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n\n    if (length != 0)\n      {\n        chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\n\n        if (chunk == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        for (i=0; i < (ssize_t) length; i++)\n          chunk[i]=(unsigned char) ReadBlobByte(image);\n\n        p=chunk;\n      }\n\n    (void) ReadBlobMSBLong(image);  /* read crc word */\n\n    if (memcmp(type,mng_JHDR,4) == 0)\n      {\n        if (length == 16)\n          {\n            jng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n              (p[2] << 8) | p[3]);\n            jng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n              (p[6] << 8) | p[7]);\n            if ((jng_width == 0) || (jng_height == 0))\n              ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n            jng_color_type=p[8];\n            jng_image_sample_depth=p[9];\n            jng_image_compression_method=p[10];\n            jng_image_interlace_method=p[11];\n\n            image->interlace=jng_image_interlace_method != 0 ? PNGInterlace :\n              NoInterlace;\n\n            jng_alpha_sample_depth=p[12];\n            jng_alpha_compression_method=p[13];\n            jng_alpha_filter_method=p[14];\n            jng_alpha_interlace_method=p[15];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_width:      %16lu,    jng_height:     %16lu\\n\"\n                  \"    jng_color_type: %16d,     jng_image_sample_depth: %3d\\n\"\n                  \"    jng_image_compression_method:%3d\",\n                  (unsigned long) jng_width, (unsigned long) jng_height,\n                  jng_color_type, jng_image_sample_depth,\n                  jng_image_compression_method);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_image_interlace_method:  %3d\"\n                  \"    jng_alpha_sample_depth:      %3d\",\n                  jng_image_interlace_method,\n                  jng_alpha_sample_depth);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_alpha_compression_method:%3d\\n\"\n                  \"    jng_alpha_filter_method:     %3d\\n\"\n                  \"    jng_alpha_interlace_method:  %3d\",\n                  jng_alpha_compression_method,\n                  jng_alpha_filter_method,\n                  jng_alpha_interlace_method);\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n\n    if ((reading_idat == MagickFalse) && (read_JSEP == MagickFalse) &&\n        ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||\n         (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))\n      {\n        /*\n           o create color_image\n           o open color_blob, attached to color_image\n           o if (color type has alpha)\n               open alpha_blob, attached to alpha_image\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Creating color_blob.\");\n\n        color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));\n\n        if (color_image_info == (ImageInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        GetImageInfo(color_image_info);\n        color_image=AcquireImage(color_image_info);\n\n        if (color_image == (Image *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        (void) AcquireUniqueFilename(color_image->filename);\n        unique_filenames++;\n        status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,\n          exception);\n\n        if (status == MagickFalse)\n          {\n            color_image=DestroyImage(color_image);\n            return(DestroyImageList(image));\n          }\n\n        if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n          {\n            alpha_image_info=(ImageInfo *)\n              AcquireMagickMemory(sizeof(ImageInfo));\n\n            if (alpha_image_info == (ImageInfo *) NULL)\n              {\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            GetImageInfo(alpha_image_info);\n            alpha_image=AcquireImage(alpha_image_info);\n\n            if (alpha_image == (Image *) NULL)\n              {\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Creating alpha_blob.\");\n\n            (void) AcquireUniqueFilename(alpha_image->filename);\n            unique_filenames++;\n            status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,\n              exception);\n\n            if (status == MagickFalse)\n              {\n                alpha_image=DestroyImage(alpha_image);\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                return(DestroyImageList(image));\n              }\n\n            if (jng_alpha_compression_method == 0)\n              {\n                unsigned char\n                  data[18];\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Writing IHDR chunk to alpha_blob.\");\n\n                (void) WriteBlob(alpha_image,8,(const unsigned char *)\n                  \"\\211PNG\\r\\n\\032\\n\");\n\n                (void) WriteBlobMSBULong(alpha_image,13L);\n                PNGType(data,mng_IHDR);\n                LogPNGChunk(logging,mng_IHDR,13L);\n                PNGLong(data+4,jng_width);\n                PNGLong(data+8,jng_height);\n                data[12]=jng_alpha_sample_depth;\n                data[13]=0; /* color_type gray */\n                data[14]=0; /* compression method 0 */\n                data[15]=0; /* filter_method 0 */\n                data[16]=0; /* interlace_method 0 */\n                (void) WriteBlob(alpha_image,17,data);\n                (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));\n              }\n          }\n        reading_idat=MagickTrue;\n      }\n\n    if (memcmp(type,mng_JDAT,4) == 0)\n      {\n        /* Copy chunk to color_image->blob */\n\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Copying JDAT chunk data to color_blob.\");\n \n        (void) WriteBlob(color_image,length,chunk);\n         if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n \n         continue;\n       }\n\n    if (memcmp(type,mng_IDAT,4) == 0)\n      {\n        png_byte\n           data[5];\n\n        /* Copy IDAT header and chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying IDAT chunk data to alpha_blob.\");\n\n            (void) WriteBlobMSBULong(alpha_image,(size_t) length);\n            PNGType(data,mng_IDAT);\n            LogPNGChunk(logging,mng_IDAT,length);\n            (void) WriteBlob(alpha_image,4,data);\n            (void) WriteBlob(alpha_image,length,chunk);\n            (void) WriteBlobMSBULong(alpha_image,\n              crc32(crc32(0,data,4),chunk,(uInt) length));\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))\n      {\n        /* Copy chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying JDAA chunk data to alpha_blob.\");\n\n            (void) WriteBlob(alpha_image,length,chunk);\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_JSEP,4) == 0)\n      {\n        read_JSEP=MagickTrue;\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_bKGD,4) == 0)\n      {\n        if (length == 2)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=image->background_color.red;\n            image->background_color.blue=image->background_color.red;\n          }\n\n        if (length == 6)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=ScaleCharToQuantum(p[3]);\n            image->background_color.blue=ScaleCharToQuantum(p[5]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_gAMA,4) == 0)\n      {\n        if (length == 4)\n          image->gamma=((float) mng_get_long(p))*0.00001;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_cHRM,4) == 0)\n      {\n        if (length == 32)\n          {\n            image->chromaticity.white_point.x=0.00001*mng_get_long(p);\n            image->chromaticity.white_point.y=0.00001*mng_get_long(&p[4]);\n            image->chromaticity.red_primary.x=0.00001*mng_get_long(&p[8]);\n            image->chromaticity.red_primary.y=0.00001*mng_get_long(&p[12]);\n            image->chromaticity.green_primary.x=0.00001*mng_get_long(&p[16]);\n            image->chromaticity.green_primary.y=0.00001*mng_get_long(&p[20]);\n            image->chromaticity.blue_primary.x=0.00001*mng_get_long(&p[24]);\n            image->chromaticity.blue_primary.y=0.00001*mng_get_long(&p[28]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_sRGB,4) == 0)\n      {\n        if (length == 1)\n          {\n            image->rendering_intent=\n              Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n            image->gamma=1.000f/2.200f;\n            image->chromaticity.red_primary.x=0.6400f;\n            image->chromaticity.red_primary.y=0.3300f;\n            image->chromaticity.green_primary.x=0.3000f;\n            image->chromaticity.green_primary.y=0.6000f;\n            image->chromaticity.blue_primary.x=0.1500f;\n            image->chromaticity.blue_primary.y=0.0600f;\n            image->chromaticity.white_point.x=0.3127f;\n            image->chromaticity.white_point.y=0.3290f;\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_oFFs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->page.x=(ssize_t) mng_get_long(p);\n            image->page.y=(ssize_t) mng_get_long(&p[4]);\n\n            if ((int) p[8] != 0)\n              {\n                image->page.x/=10000;\n                image->page.y/=10000;\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_pHYs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->x_resolution=(double) mng_get_long(p);\n            image->y_resolution=(double) mng_get_long(&p[4]);\n            if ((int) p[8] == PNG_RESOLUTION_METER)\n              {\n                image->units=PixelsPerCentimeterResolution;\n                image->x_resolution=image->x_resolution/100.0f;\n                image->y_resolution=image->y_resolution/100.0f;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n#if 0\n    if (memcmp(type,mng_iCCP,4) == 0)\n      {\n        /* To do: */\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n#endif\n\n    if (length != 0)\n      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n    if (memcmp(type,mng_IEND,4))\n      continue;\n\n    break;\n  }\n\n\n  /* IEND found */\n\n  /*\n    Finish up reading image data:\n\n       o read main image from color_blob.\n\n       o close color_blob.\n\n       o if (color_type has alpha)\n            if alpha_encoding is PNG\n               read secondary image from alpha_blob via ReadPNG\n            if alpha_encoding is JPEG\n               read secondary image from alpha_blob via ReadJPEG\n\n       o close alpha_blob.\n\n       o copy intensity of secondary image into\n         opacity samples of main image.\n\n       o destroy the secondary image.\n  */\n\n  if (color_image_info == (ImageInfo *) NULL)\n    {\n      assert(color_image == (Image *) NULL);\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  if (color_image == (Image *) NULL)\n    {\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  (void) SeekBlob(color_image,0,SEEK_SET);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading jng_image from color_blob.\");\n\n  assert(color_image_info != (ImageInfo *) NULL);\n  (void) FormatLocaleString(color_image_info->filename,MaxTextExtent,\"%s\",\n    color_image->filename);\n\n  color_image_info->ping=MagickFalse;   /* To do: avoid this */\n  jng_image=ReadImage(color_image_info,exception);\n\n  (void) RelinquishUniqueFileResource(color_image->filename);\n  unique_filenames--;\n  color_image=DestroyImage(color_image);\n  color_image_info=DestroyImageInfo(color_image_info);\n\n  if (jng_image == (Image *) NULL)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Copying jng_image pixels to main image.\");\n  image->columns=jng_width;\n  image->rows=jng_height;\n  length=image->columns*sizeof(PixelPacket);\n\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    s=GetVirtualPixels(jng_image,0,y,image->columns,1,&image->exception);\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    (void) CopyMagickMemory(q,s,length);\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n\n  jng_image=DestroyImage(jng_image);\n\n  if (image_info->ping == MagickFalse)\n    {\n     if (jng_color_type >= 12)\n       {\n         if (jng_alpha_compression_method == 0)\n           {\n             png_byte\n               data[5];\n             (void) WriteBlobMSBULong(alpha_image,0x00000000L);\n             PNGType(data,mng_IEND);\n             LogPNGChunk(logging,mng_IEND,0L);\n             (void) WriteBlob(alpha_image,4,data);\n             (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));\n           }\n\n         (void) SeekBlob(alpha_image,0,SEEK_SET);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading opacity from alpha_blob.\");\n\n         (void) FormatLocaleString(alpha_image_info->filename,MaxTextExtent,\n           \"%s\",alpha_image->filename);\n\n         jng_image=ReadImage(alpha_image_info,exception);\n\n         if (jng_image != (Image *) NULL)\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             s=GetVirtualPixels(jng_image,0,y,image->columns,1,\n                &image->exception);\n             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (image->matte != MagickFalse)\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n                  SetPixelOpacity(q,QuantumRange-\n                      GetPixelRed(s));\n\n             else\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n               {\n                  SetPixelAlpha(q,GetPixelRed(s));\n                  if (GetPixelOpacity(q) != OpaqueOpacity)\n                    image->matte=MagickTrue;\n               }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n           }\n         (void) RelinquishUniqueFileResource(alpha_image->filename);\n         unique_filenames--;\n         alpha_image=DestroyImage(alpha_image);\n         alpha_image_info=DestroyImageInfo(alpha_image_info);\n         if (jng_image != (Image *) NULL)\n           jng_image=DestroyImage(jng_image);\n       }\n    }\n\n  /* Read the JNG image.  */\n\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=jng_width;\n      mng_info->mng_height=jng_height;\n    }\n\n  if (image->page.width == 0 && image->page.height == 0)\n    {\n      image->page.width=jng_width;\n      image->page.height=jng_height;\n    }\n\n  if (image->page.x == 0 && image->page.y == 0)\n    {\n      image->page.x=mng_info->x_off[mng_info->object_id];\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  mng_info->image_found++;\n  status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),\n    2*GetBlobSize(image));\n\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage(); unique_filenames=%d\",unique_filenames);\n\n  return(image);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142547,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadOneJNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  Image\n    *alpha_image,\n    *color_image,\n    *image,\n    *jng_image;\n\n  ImageInfo\n    *alpha_image_info,\n    *color_image_info;\n\n  MagickBooleanType\n    logging;\n\n  int\n    unique_filenames;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  png_uint_32\n    jng_height,\n    jng_width;\n\n  png_byte\n    jng_color_type,\n    jng_image_sample_depth,\n    jng_image_compression_method,\n    jng_image_interlace_method,\n    jng_alpha_sample_depth,\n    jng_alpha_compression_method,\n    jng_alpha_filter_method,\n    jng_alpha_interlace_method;\n\n  register const PixelPacket\n    *s;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  unsigned int\n    read_JSEP,\n    reading_idat;\n\n  size_t\n    length;\n\n  jng_alpha_compression_method=0;\n  jng_alpha_sample_depth=8;\n  jng_color_type=0;\n  jng_height=0;\n  jng_width=0;\n  alpha_image=(Image *) NULL;\n  color_image=(Image *) NULL;\n  alpha_image_info=(ImageInfo *) NULL;\n  color_image_info=(ImageInfo *) NULL;\n  unique_filenames=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneJNGImage()\");\n\n  image=mng_info->image;\n\n  if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n    {\n      /*\n        Allocate next image structure.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  AcquireNextImage()\");\n\n      AcquireNextImage(image_info,image);\n\n      if (GetNextImageInList(image) == (Image *) NULL)\n        return(DestroyImageList(image));\n\n      image=SyncNextImageInList(image);\n    }\n  mng_info->image=image;\n\n  /*\n    Signature bytes have already been read.\n  */\n\n  read_JSEP=MagickFalse;\n  reading_idat=MagickFalse;\n  for (;;)\n  {\n    char\n      type[MaxTextExtent];\n\n    unsigned char\n      *chunk;\n\n    unsigned int\n      count;\n\n    /*\n      Read a new JNG chunk.\n    */\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      2*GetBlobSize(image));\n\n    if (status == MagickFalse)\n      break;\n\n    type[0]='\\0';\n    (void) ConcatenateMagickString(type,\"errr\",MaxTextExtent);\n    length=ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n\n    if (length != 0)\n      {\n        chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\n\n        if (chunk == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        for (i=0; i < (ssize_t) length; i++)\n          chunk[i]=(unsigned char) ReadBlobByte(image);\n\n        p=chunk;\n      }\n\n    (void) ReadBlobMSBLong(image);  /* read crc word */\n\n    if (memcmp(type,mng_JHDR,4) == 0)\n      {\n        if (length == 16)\n          {\n            jng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n              (p[2] << 8) | p[3]);\n            jng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n              (p[6] << 8) | p[7]);\n            if ((jng_width == 0) || (jng_height == 0))\n              ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n            jng_color_type=p[8];\n            jng_image_sample_depth=p[9];\n            jng_image_compression_method=p[10];\n            jng_image_interlace_method=p[11];\n\n            image->interlace=jng_image_interlace_method != 0 ? PNGInterlace :\n              NoInterlace;\n\n            jng_alpha_sample_depth=p[12];\n            jng_alpha_compression_method=p[13];\n            jng_alpha_filter_method=p[14];\n            jng_alpha_interlace_method=p[15];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_width:      %16lu,    jng_height:     %16lu\\n\"\n                  \"    jng_color_type: %16d,     jng_image_sample_depth: %3d\\n\"\n                  \"    jng_image_compression_method:%3d\",\n                  (unsigned long) jng_width, (unsigned long) jng_height,\n                  jng_color_type, jng_image_sample_depth,\n                  jng_image_compression_method);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_image_interlace_method:  %3d\"\n                  \"    jng_alpha_sample_depth:      %3d\",\n                  jng_image_interlace_method,\n                  jng_alpha_sample_depth);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_alpha_compression_method:%3d\\n\"\n                  \"    jng_alpha_filter_method:     %3d\\n\"\n                  \"    jng_alpha_interlace_method:  %3d\",\n                  jng_alpha_compression_method,\n                  jng_alpha_filter_method,\n                  jng_alpha_interlace_method);\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n\n    if ((reading_idat == MagickFalse) && (read_JSEP == MagickFalse) &&\n        ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||\n         (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))\n      {\n        /*\n           o create color_image\n           o open color_blob, attached to color_image\n           o if (color type has alpha)\n               open alpha_blob, attached to alpha_image\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Creating color_blob.\");\n\n        color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));\n\n        if (color_image_info == (ImageInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        GetImageInfo(color_image_info);\n        color_image=AcquireImage(color_image_info);\n\n        if (color_image == (Image *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        (void) AcquireUniqueFilename(color_image->filename);\n        unique_filenames++;\n        status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,\n          exception);\n\n        if (status == MagickFalse)\n          {\n            color_image=DestroyImage(color_image);\n            return(DestroyImageList(image));\n          }\n\n        if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n          {\n            alpha_image_info=(ImageInfo *)\n              AcquireMagickMemory(sizeof(ImageInfo));\n\n            if (alpha_image_info == (ImageInfo *) NULL)\n              {\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            GetImageInfo(alpha_image_info);\n            alpha_image=AcquireImage(alpha_image_info);\n\n            if (alpha_image == (Image *) NULL)\n              {\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Creating alpha_blob.\");\n\n            (void) AcquireUniqueFilename(alpha_image->filename);\n            unique_filenames++;\n            status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,\n              exception);\n\n            if (status == MagickFalse)\n              {\n                alpha_image=DestroyImage(alpha_image);\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                return(DestroyImageList(image));\n              }\n\n            if (jng_alpha_compression_method == 0)\n              {\n                unsigned char\n                  data[18];\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Writing IHDR chunk to alpha_blob.\");\n\n                (void) WriteBlob(alpha_image,8,(const unsigned char *)\n                  \"\\211PNG\\r\\n\\032\\n\");\n\n                (void) WriteBlobMSBULong(alpha_image,13L);\n                PNGType(data,mng_IHDR);\n                LogPNGChunk(logging,mng_IHDR,13L);\n                PNGLong(data+4,jng_width);\n                PNGLong(data+8,jng_height);\n                data[12]=jng_alpha_sample_depth;\n                data[13]=0; /* color_type gray */\n                data[14]=0; /* compression method 0 */\n                data[15]=0; /* filter_method 0 */\n                data[16]=0; /* interlace_method 0 */\n                (void) WriteBlob(alpha_image,17,data);\n                (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));\n              }\n          }\n        reading_idat=MagickTrue;\n      }\n\n    if (memcmp(type,mng_JDAT,4) == 0)\n      {\n        /* Copy chunk to color_image->blob */\n\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Copying JDAT chunk data to color_blob.\");\n \n         if (length != 0)\n          {\n            (void) WriteBlob(color_image,length,chunk);\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n          }\n \n         continue;\n       }\n\n    if (memcmp(type,mng_IDAT,4) == 0)\n      {\n        png_byte\n           data[5];\n\n        /* Copy IDAT header and chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying IDAT chunk data to alpha_blob.\");\n\n            (void) WriteBlobMSBULong(alpha_image,(size_t) length);\n            PNGType(data,mng_IDAT);\n            LogPNGChunk(logging,mng_IDAT,length);\n            (void) WriteBlob(alpha_image,4,data);\n            (void) WriteBlob(alpha_image,length,chunk);\n            (void) WriteBlobMSBULong(alpha_image,\n              crc32(crc32(0,data,4),chunk,(uInt) length));\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))\n      {\n        /* Copy chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying JDAA chunk data to alpha_blob.\");\n\n            (void) WriteBlob(alpha_image,length,chunk);\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_JSEP,4) == 0)\n      {\n        read_JSEP=MagickTrue;\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_bKGD,4) == 0)\n      {\n        if (length == 2)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=image->background_color.red;\n            image->background_color.blue=image->background_color.red;\n          }\n\n        if (length == 6)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=ScaleCharToQuantum(p[3]);\n            image->background_color.blue=ScaleCharToQuantum(p[5]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_gAMA,4) == 0)\n      {\n        if (length == 4)\n          image->gamma=((float) mng_get_long(p))*0.00001;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_cHRM,4) == 0)\n      {\n        if (length == 32)\n          {\n            image->chromaticity.white_point.x=0.00001*mng_get_long(p);\n            image->chromaticity.white_point.y=0.00001*mng_get_long(&p[4]);\n            image->chromaticity.red_primary.x=0.00001*mng_get_long(&p[8]);\n            image->chromaticity.red_primary.y=0.00001*mng_get_long(&p[12]);\n            image->chromaticity.green_primary.x=0.00001*mng_get_long(&p[16]);\n            image->chromaticity.green_primary.y=0.00001*mng_get_long(&p[20]);\n            image->chromaticity.blue_primary.x=0.00001*mng_get_long(&p[24]);\n            image->chromaticity.blue_primary.y=0.00001*mng_get_long(&p[28]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_sRGB,4) == 0)\n      {\n        if (length == 1)\n          {\n            image->rendering_intent=\n              Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n            image->gamma=1.000f/2.200f;\n            image->chromaticity.red_primary.x=0.6400f;\n            image->chromaticity.red_primary.y=0.3300f;\n            image->chromaticity.green_primary.x=0.3000f;\n            image->chromaticity.green_primary.y=0.6000f;\n            image->chromaticity.blue_primary.x=0.1500f;\n            image->chromaticity.blue_primary.y=0.0600f;\n            image->chromaticity.white_point.x=0.3127f;\n            image->chromaticity.white_point.y=0.3290f;\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_oFFs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->page.x=(ssize_t) mng_get_long(p);\n            image->page.y=(ssize_t) mng_get_long(&p[4]);\n\n            if ((int) p[8] != 0)\n              {\n                image->page.x/=10000;\n                image->page.y/=10000;\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_pHYs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->x_resolution=(double) mng_get_long(p);\n            image->y_resolution=(double) mng_get_long(&p[4]);\n            if ((int) p[8] == PNG_RESOLUTION_METER)\n              {\n                image->units=PixelsPerCentimeterResolution;\n                image->x_resolution=image->x_resolution/100.0f;\n                image->y_resolution=image->y_resolution/100.0f;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n#if 0\n    if (memcmp(type,mng_iCCP,4) == 0)\n      {\n        /* To do: */\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n#endif\n\n    if (length != 0)\n      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n    if (memcmp(type,mng_IEND,4))\n      continue;\n\n    break;\n  }\n\n\n  /* IEND found */\n\n  /*\n    Finish up reading image data:\n\n       o read main image from color_blob.\n\n       o close color_blob.\n\n       o if (color_type has alpha)\n            if alpha_encoding is PNG\n               read secondary image from alpha_blob via ReadPNG\n            if alpha_encoding is JPEG\n               read secondary image from alpha_blob via ReadJPEG\n\n       o close alpha_blob.\n\n       o copy intensity of secondary image into\n         opacity samples of main image.\n\n       o destroy the secondary image.\n  */\n\n  if (color_image_info == (ImageInfo *) NULL)\n    {\n      assert(color_image == (Image *) NULL);\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  if (color_image == (Image *) NULL)\n    {\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  (void) SeekBlob(color_image,0,SEEK_SET);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading jng_image from color_blob.\");\n\n  assert(color_image_info != (ImageInfo *) NULL);\n  (void) FormatLocaleString(color_image_info->filename,MaxTextExtent,\"%s\",\n    color_image->filename);\n\n  color_image_info->ping=MagickFalse;   /* To do: avoid this */\n  jng_image=ReadImage(color_image_info,exception);\n\n  (void) RelinquishUniqueFileResource(color_image->filename);\n  unique_filenames--;\n  color_image=DestroyImage(color_image);\n  color_image_info=DestroyImageInfo(color_image_info);\n\n  if (jng_image == (Image *) NULL)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Copying jng_image pixels to main image.\");\n  image->columns=jng_width;\n  image->rows=jng_height;\n  length=image->columns*sizeof(PixelPacket);\n\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    s=GetVirtualPixels(jng_image,0,y,image->columns,1,&image->exception);\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    (void) CopyMagickMemory(q,s,length);\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n\n  jng_image=DestroyImage(jng_image);\n\n  if (image_info->ping == MagickFalse)\n    {\n     if (jng_color_type >= 12)\n       {\n         if (jng_alpha_compression_method == 0)\n           {\n             png_byte\n               data[5];\n             (void) WriteBlobMSBULong(alpha_image,0x00000000L);\n             PNGType(data,mng_IEND);\n             LogPNGChunk(logging,mng_IEND,0L);\n             (void) WriteBlob(alpha_image,4,data);\n             (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));\n           }\n\n         (void) SeekBlob(alpha_image,0,SEEK_SET);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading opacity from alpha_blob.\");\n\n         (void) FormatLocaleString(alpha_image_info->filename,MaxTextExtent,\n           \"%s\",alpha_image->filename);\n\n         jng_image=ReadImage(alpha_image_info,exception);\n\n         if (jng_image != (Image *) NULL)\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             s=GetVirtualPixels(jng_image,0,y,image->columns,1,\n                &image->exception);\n             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (image->matte != MagickFalse)\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n                  SetPixelOpacity(q,QuantumRange-\n                      GetPixelRed(s));\n\n             else\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n               {\n                  SetPixelAlpha(q,GetPixelRed(s));\n                  if (GetPixelOpacity(q) != OpaqueOpacity)\n                    image->matte=MagickTrue;\n               }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n           }\n         (void) RelinquishUniqueFileResource(alpha_image->filename);\n         unique_filenames--;\n         alpha_image=DestroyImage(alpha_image);\n         alpha_image_info=DestroyImageInfo(alpha_image_info);\n         if (jng_image != (Image *) NULL)\n           jng_image=DestroyImage(jng_image);\n       }\n    }\n\n  /* Read the JNG image.  */\n\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=jng_width;\n      mng_info->mng_height=jng_height;\n    }\n\n  if (image->page.width == 0 && image->page.height == 0)\n    {\n      image->page.width=jng_width;\n      image->page.height=jng_height;\n    }\n\n  if (image->page.x == 0 && image->page.y == 0)\n    {\n      image->page.x=mng_info->x_off[mng_info->object_id];\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  mng_info->image_found++;\n  status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),\n    2*GetBlobSize(image));\n\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage(); unique_filenames=%d\",unique_filenames);\n\n  return(image);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142548,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status,\n    cubemap = MagickFalse,\n    volume = MagickFalse,\n    matte;\n\n  CompressionType\n    compression;\n\n  DDSInfo\n    dds_info;\n\n  DDSDecoder\n    *decoder;\n\n  size_t\n    n,\n    num_images;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n\n   /*\n     Initialize image structure.\n   */\n  if (ReadDDSInfo(image, &dds_info) != MagickTrue) {\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n \n   if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP)\n     cubemap = MagickTrue;\n\n  if (dds_info.ddscaps2 & DDSCAPS2_VOLUME && dds_info.depth > 0)\n    volume = MagickTrue;\n\n  (void) SeekBlob(image, 128, SEEK_SET);\n\n  /*\n    Determine pixel format\n  */\n  if (dds_info.pixelformat.flags & DDPF_RGB)\n    {\n      compression = NoCompression;\n      if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)\n        {\n          matte = MagickTrue;\n          decoder = ReadUncompressedRGBA;\n        }\n      else\n        {\n          matte = MagickTrue;\n          decoder = ReadUncompressedRGB;\n        }\n    }\n  else if (dds_info.pixelformat.flags & DDPF_LUMINANCE)\n   {\n      compression = NoCompression;\n      if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)\n        {\n          /* Not sure how to handle this */\n          ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n        }\n      else\n        {\n          matte = MagickFalse;\n          decoder = ReadUncompressedRGB;\n        }\n    }\n  else if (dds_info.pixelformat.flags & DDPF_FOURCC)\n    {\n      switch (dds_info.pixelformat.fourcc)\n      {\n        case FOURCC_DXT1:\n        {\n          matte = MagickFalse;\n          compression = DXT1Compression;\n          decoder = ReadDXT1;\n          break;\n        }\n        case FOURCC_DXT3:\n        {\n          matte = MagickTrue;\n          compression = DXT3Compression;\n          decoder = ReadDXT3;\n          break;\n        }\n        case FOURCC_DXT5:\n        {\n          matte = MagickTrue;\n          compression = DXT5Compression;\n          decoder = ReadDXT5;\n          break;\n        }\n        default:\n        {\n          /* Unknown FOURCC */\n          ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n        }\n      }\n    }\n  else\n    {\n      /* Neither compressed nor uncompressed... thus unsupported */\n      ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n    }\n\n  num_images = 1;\n  if (cubemap)\n    {\n      /*\n        Determine number of faces defined in the cubemap\n      */\n      num_images = 0;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ) num_images++;\n    }\n\n   if (volume)\n     num_images = dds_info.depth;\n \n   for (n = 0; n < num_images; n++)\n   {\n     if (n != 0)\n      {\n        if (EOFBlob(image) != MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        /* Start a new image */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          return(DestroyImageList(image));\n        image=SyncNextImageInList(image);\n      }\n \n    image->matte = matte;\n    image->compression = compression;\n    image->columns = dds_info.width;\n    image->rows = dds_info.height;\n    image->storage_class = DirectClass;\n    image->endian = LSBEndian;\n    image->depth = 8;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n\n    if ((decoder)(image, &dds_info, exception) != MagickTrue)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  }\n\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142549,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status,\n    cubemap = MagickFalse,\n    volume = MagickFalse,\n    matte;\n\n  CompressionType\n    compression;\n\n  DDSInfo\n    dds_info;\n\n  DDSDecoder\n    *decoder;\n\n  size_t\n    n,\n    num_images;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n\n   /*\n     Initialize image structure.\n   */\n  if (ReadDDSInfo(image, &dds_info) != MagickTrue)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n \n   if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP)\n     cubemap = MagickTrue;\n\n  if (dds_info.ddscaps2 & DDSCAPS2_VOLUME && dds_info.depth > 0)\n    volume = MagickTrue;\n\n  (void) SeekBlob(image, 128, SEEK_SET);\n\n  /*\n    Determine pixel format\n  */\n  if (dds_info.pixelformat.flags & DDPF_RGB)\n    {\n      compression = NoCompression;\n      if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)\n        {\n          matte = MagickTrue;\n          decoder = ReadUncompressedRGBA;\n        }\n      else\n        {\n          matte = MagickTrue;\n          decoder = ReadUncompressedRGB;\n        }\n    }\n  else if (dds_info.pixelformat.flags & DDPF_LUMINANCE)\n   {\n      compression = NoCompression;\n      if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)\n        {\n          /* Not sure how to handle this */\n          ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n        }\n      else\n        {\n          matte = MagickFalse;\n          decoder = ReadUncompressedRGB;\n        }\n    }\n  else if (dds_info.pixelformat.flags & DDPF_FOURCC)\n    {\n      switch (dds_info.pixelformat.fourcc)\n      {\n        case FOURCC_DXT1:\n        {\n          matte = MagickFalse;\n          compression = DXT1Compression;\n          decoder = ReadDXT1;\n          break;\n        }\n        case FOURCC_DXT3:\n        {\n          matte = MagickTrue;\n          compression = DXT3Compression;\n          decoder = ReadDXT3;\n          break;\n        }\n        case FOURCC_DXT5:\n        {\n          matte = MagickTrue;\n          compression = DXT5Compression;\n          decoder = ReadDXT5;\n          break;\n        }\n        default:\n        {\n          /* Unknown FOURCC */\n          ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n        }\n      }\n    }\n  else\n    {\n      /* Neither compressed nor uncompressed... thus unsupported */\n      ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n    }\n\n  num_images = 1;\n  if (cubemap)\n    {\n      /*\n        Determine number of faces defined in the cubemap\n      */\n      num_images = 0;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ) num_images++;\n    }\n\n   if (volume)\n     num_images = dds_info.depth;\n \n  if (num_images < 1)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n   for (n = 0; n < num_images; n++)\n   {\n     if (n != 0)\n      {\n        if (EOFBlob(image) != MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        /* Start a new image */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          return(DestroyImageList(image));\n        image=SyncNextImageInList(image);\n      }\n \n    image->matte = matte;\n    image->compression = compression;\n    image->columns = dds_info.width;\n    image->rows = dds_info.height;\n    image->storage_class = DirectClass;\n    image->endian = LSBEndian;\n    image->depth = 8;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n\n    if ((decoder)(image, &dds_info, exception) != MagickTrue)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  }\n\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142550,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " nfsd_dispatch(struct svc_rqst *rqstp, __be32 *statp)\n {\n\tstruct svc_procedure\t*proc;\n\tkxdrproc_t\t\txdr;\n\t__be32\t\t\tnfserr;\n\t__be32\t\t\t*nfserrp;\n\n\tdprintk(\"nfsd_dispatch: vers %d proc %d\\n\",\n \t\t\t\trqstp->rq_vers, rqstp->rq_proc);\n \tproc = rqstp->rq_procinfo;\n \n \t/*\n \t * Give the xdr decoder a chance to change this if it wants\n \t * (necessary in the NFSv4.0 compound case)\n\t */\n\trqstp->rq_cachetype = proc->pc_cachetype;\n\t/* Decode arguments */\n\txdr = proc->pc_decode;\n\tif (xdr && !xdr(rqstp, (__be32*)rqstp->rq_arg.head[0].iov_base,\n\t\t\trqstp->rq_argp)) {\n\t\tdprintk(\"nfsd: failed to decode arguments!\\n\");\n\t\t*statp = rpc_garbage_args;\n\t\treturn 1;\n\t}\n\n\t/* Check whether we have this call in the cache. */\n\tswitch (nfsd_cache_lookup(rqstp)) {\n\tcase RC_DROPIT:\n\t\treturn 0;\n\tcase RC_REPLY:\n\t\treturn 1;\n\tcase RC_DOIT:;\n\t\t/* do it */\n\t}\n\n\t/* need to grab the location to store the status, as\n\t * nfsv4 does some encoding while processing \n\t */\n\tnfserrp = rqstp->rq_res.head[0].iov_base\n\t\t+ rqstp->rq_res.head[0].iov_len;\n\trqstp->rq_res.head[0].iov_len += sizeof(__be32);\n\n\t/* Now call the procedure handler, and encode NFS status. */\n\tnfserr = proc->pc_func(rqstp, rqstp->rq_argp, rqstp->rq_resp);\n\tnfserr = map_new_errors(rqstp->rq_vers, nfserr);\n\tif (nfserr == nfserr_dropit || test_bit(RQ_DROPME, &rqstp->rq_flags)) {\n\t\tdprintk(\"nfsd: Dropping request; may be revisited later\\n\");\n\t\tnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\n\t\treturn 0;\n\t}\n\n\tif (rqstp->rq_proc != 0)\n\t\t*nfserrp++ = nfserr;\n\n\t/* Encode result.\n\t * For NFSv2, additional info is never returned in case of an error.\n\t */\n\tif (!(nfserr && rqstp->rq_vers == 2)) {\n\t\txdr = proc->pc_encode;\n\t\tif (xdr && !xdr(rqstp, nfserrp,\n\t\t\t\trqstp->rq_resp)) {\n\t\t\t/* Failed to encode result. Release cache entry */\n\t\t\tdprintk(\"nfsd: failed to encode result!\\n\");\n\t\t\tnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\n\t\t\t*statp = rpc_system_err;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Store reply in cache. */\n\tnfsd_cache_update(rqstp, rqstp->rq_cachetype, statp + 1);\n\treturn 1;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142597,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " nfsd_dispatch(struct svc_rqst *rqstp, __be32 *statp)\n {\n\tstruct svc_procedure\t*proc;\n\tkxdrproc_t\t\txdr;\n\t__be32\t\t\tnfserr;\n\t__be32\t\t\t*nfserrp;\n\n\tdprintk(\"nfsd_dispatch: vers %d proc %d\\n\",\n \t\t\t\trqstp->rq_vers, rqstp->rq_proc);\n \tproc = rqstp->rq_procinfo;\n \n\tif (nfs_request_too_big(rqstp, proc)) {\n\t\tdprintk(\"nfsd: NFSv%d argument too large\\n\", rqstp->rq_vers);\n\t\t*statp = rpc_garbage_args;\n\t\treturn 1;\n\t}\n \t/*\n \t * Give the xdr decoder a chance to change this if it wants\n \t * (necessary in the NFSv4.0 compound case)\n\t */\n\trqstp->rq_cachetype = proc->pc_cachetype;\n\t/* Decode arguments */\n\txdr = proc->pc_decode;\n\tif (xdr && !xdr(rqstp, (__be32*)rqstp->rq_arg.head[0].iov_base,\n\t\t\trqstp->rq_argp)) {\n\t\tdprintk(\"nfsd: failed to decode arguments!\\n\");\n\t\t*statp = rpc_garbage_args;\n\t\treturn 1;\n\t}\n\n\t/* Check whether we have this call in the cache. */\n\tswitch (nfsd_cache_lookup(rqstp)) {\n\tcase RC_DROPIT:\n\t\treturn 0;\n\tcase RC_REPLY:\n\t\treturn 1;\n\tcase RC_DOIT:;\n\t\t/* do it */\n\t}\n\n\t/* need to grab the location to store the status, as\n\t * nfsv4 does some encoding while processing \n\t */\n\tnfserrp = rqstp->rq_res.head[0].iov_base\n\t\t+ rqstp->rq_res.head[0].iov_len;\n\trqstp->rq_res.head[0].iov_len += sizeof(__be32);\n\n\t/* Now call the procedure handler, and encode NFS status. */\n\tnfserr = proc->pc_func(rqstp, rqstp->rq_argp, rqstp->rq_resp);\n\tnfserr = map_new_errors(rqstp->rq_vers, nfserr);\n\tif (nfserr == nfserr_dropit || test_bit(RQ_DROPME, &rqstp->rq_flags)) {\n\t\tdprintk(\"nfsd: Dropping request; may be revisited later\\n\");\n\t\tnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\n\t\treturn 0;\n\t}\n\n\tif (rqstp->rq_proc != 0)\n\t\t*nfserrp++ = nfserr;\n\n\t/* Encode result.\n\t * For NFSv2, additional info is never returned in case of an error.\n\t */\n\tif (!(nfserr && rqstp->rq_vers == 2)) {\n\t\txdr = proc->pc_encode;\n\t\tif (xdr && !xdr(rqstp, nfserrp,\n\t\t\t\trqstp->rq_resp)) {\n\t\t\t/* Failed to encode result. Release cache entry */\n\t\t\tdprintk(\"nfsd: failed to encode result!\\n\");\n\t\t\tnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\n\t\t\t*statp = rpc_system_err;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Store reply in cache. */\n\tnfsd_cache_update(rqstp, rqstp->rq_cachetype, statp + 1);\n\treturn 1;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142598,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "main (int    argc,\n      char **argv)\n{\n  mode_t old_umask;\n  cleanup_free char *base_path = NULL;\n  int clone_flags;\n  char *old_cwd = NULL;\n  pid_t pid;\n  int event_fd = -1;\n  int child_wait_fd = -1;\n  const char *new_cwd;\n  uid_t ns_uid;\n  gid_t ns_gid;\n  struct stat sbuf;\n  uint64_t val;\n  int res UNUSED;\n\n  real_uid = getuid ();\n  real_gid = getgid ();\n\n  /* Get the (optional) privileges we need */\n  acquire_privs ();\n\n  /* Never gain any more privs during exec */\n  if (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0)\n    die_with_error (\"prctl(PR_SET_NO_NEW_CAPS) failed\");\n\n  /* The initial code is run with high permissions\n     (i.e. CAP_SYS_ADMIN), so take lots of care. */\n\n  read_overflowids ();\n\n  argv0 = argv[0];\n\n  if (isatty (1))\n    host_tty_dev = ttyname (1);\n\n  argv++;\n  argc--;\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  parse_args (&argc, &argv);\n\n  /* We have to do this if we weren't installed setuid (and we're not\n   * root), so let's just DWIM */\n  if (!is_privileged && getuid () != 0)\n    opt_unshare_user = TRUE;\n\n  if (opt_unshare_user_try &&\n      stat (\"/proc/self/ns/user\", &sbuf) == 0)\n    {\n      bool disabled = FALSE;\n\n      /* RHEL7 has a kernel module parameter that lets you enable user namespaces */\n      if (stat (\"/sys/module/user_namespace/parameters/enable\", &sbuf) == 0)\n        {\n          cleanup_free char *enable = NULL;\n          enable = load_file_at (AT_FDCWD, \"/sys/module/user_namespace/parameters/enable\");\n          if (enable != NULL && enable[0] == 'N')\n            disabled = TRUE;\n        }\n\n      /* Debian lets you disable *unprivileged* user namespaces. However this is not\n         a problem if we're privileged, and if we're not opt_unshare_user is TRUE\n         already, and there is not much we can do, its just a non-working setup. */\n\n      if (!disabled)\n        opt_unshare_user = TRUE;\n    }\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  __debug__ ((\"Creating root mount point\\n\"));\n\n  if (opt_sandbox_uid == -1)\n    opt_sandbox_uid = real_uid;\n  if (opt_sandbox_gid == -1)\n    opt_sandbox_gid = real_gid;\n\n  if (!opt_unshare_user && opt_sandbox_uid != real_uid)\n    die (\"Specifying --uid requires --unshare-user\");\n\n  if (!opt_unshare_user && opt_sandbox_gid != real_gid)\n    die (\"Specifying --gid requires --unshare-user\");\n\n  if (!opt_unshare_uts && opt_sandbox_hostname != NULL)\n    die (\"Specifying --hostname requires --unshare-uts\");\n\n  /* We need to read stuff from proc during the pivot_root dance, etc.\n     Lets keep a fd to it open */\n  proc_fd = open (\"/proc\", O_RDONLY | O_PATH);\n  if (proc_fd == -1)\n    die_with_error (\"Can't open /proc\");\n\n  /* We need *some* mountpoint where we can mount the root tmpfs.\n     We first try in /run, and if that fails, try in /tmp. */\n  base_path = xasprintf (\"/run/user/%d/.bubblewrap\", real_uid);\n  if (mkdir (base_path, 0755) && errno != EEXIST)\n    {\n      free (base_path);\n      base_path = xasprintf (\"/tmp/.bubblewrap-%d\", real_uid);\n      if (mkdir (base_path, 0755) && errno != EEXIST)\n        die_with_error (\"Creating root mountpoint failed\");\n    }\n\n  __debug__ ((\"creating new namespace\\n\"));\n\n  if (opt_unshare_pid)\n    {\n      event_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK);\n      if (event_fd == -1)\n        die_with_error (\"eventfd()\");\n    }\n\n  /* We block sigchild here so that we can use signalfd in the monitor. */\n  block_sigchild ();\n\n  clone_flags = SIGCHLD | CLONE_NEWNS;\n  if (opt_unshare_user)\n    clone_flags |= CLONE_NEWUSER;\n  if (opt_unshare_pid)\n    clone_flags |= CLONE_NEWPID;\n  if (opt_unshare_net)\n    clone_flags |= CLONE_NEWNET;\n  if (opt_unshare_ipc)\n    clone_flags |= CLONE_NEWIPC;\n  if (opt_unshare_uts)\n    clone_flags |= CLONE_NEWUTS;\n  if (opt_unshare_cgroup)\n    {\n      if (stat (\"/proc/self/ns/cgroup\", &sbuf))\n        {\n          if (errno == ENOENT)\n            die (\"Cannot create new cgroup namespace because the kernel does not support it\");\n          else\n            die_with_error (\"stat on /proc/self/ns/cgroup failed\");\n        }\n      clone_flags |= CLONE_NEWCGROUP;\n    }\n  if (opt_unshare_cgroup_try)\n    if (!stat (\"/proc/self/ns/cgroup\", &sbuf))\n      clone_flags |= CLONE_NEWCGROUP;\n\n  child_wait_fd = eventfd (0, EFD_CLOEXEC);\n  if (child_wait_fd == -1)\n    die_with_error (\"eventfd()\");\n\n  pid = raw_clone (clone_flags, NULL);\n  if (pid == -1)\n    {\n      if (opt_unshare_user)\n        {\n          if (errno == EINVAL)\n            die (\"Creating new namespace failed, likely because the kernel does not support user namespaces.  bwrap must be installed setuid on such systems.\");\n          else if (errno == EPERM && !is_privileged)\n            die (\"No permissions to creating new namespace, likely because the kernel does not allow non-privileged user namespaces. On e.g. debian this can be enabled with 'sysctl kernel.unprivileged_userns_clone=1'.\");\n        }\n\n      die_with_error (\"Creating new namespace failed\");\n    }\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n\n  if (pid != 0)\n    {\n      /* Parent, outside sandbox, privileged (initially) */\n\n      if (is_privileged && opt_unshare_user)\n        {\n          /* We're running as euid 0, but the uid we want to map is\n           * not 0. This means we're not allowed to write this from\n           * the child user namespace, so we do it from the parent.\n           *\n           * Also, we map uid/gid 0 in the namespace (to overflowuid)\n           * if opt_needs_devpts is true, because otherwise the mount\n           * of devpts fails due to root not being mapped.\n           */\n          write_uid_gid_map (ns_uid, real_uid,\n                             ns_gid, real_gid,\n                             pid, TRUE, opt_needs_devpts);\n        }\n\n      /* Initial launched process, wait for exec:ed command to exit */\n\n      /* We don't need any privileges in the launcher, drop them immediately. */\n      drop_privs ();\n\n      /* Let child run now that the uid maps are set up */\n      val = 1;\n      res = write (child_wait_fd, &val, 8);\n      /* Ignore res, if e.g. the child died and closed child_wait_fd we don't want to error out here */\n      close (child_wait_fd);\n\n      if (opt_info_fd != -1)\n        {\n          cleanup_free char *output = xasprintf (\"{\\n    \\\"child-pid\\\": %i\\n}\\n\", pid);\n          size_t len = strlen (output);\n          if (write (opt_info_fd, output, len) != len)\n            die_with_error (\"Write to info_fd\");\n          close (opt_info_fd);\n        }\n\n      monitor_child (event_fd);\n      exit (0); /* Should not be reached, but better safe... */\n    }\n\n  /* Child, in sandbox, privileged in the parent or in the user namespace (if --unshare-user).\n   *\n   * Note that for user namespaces we run as euid 0 during clone(), so\n   * the child user namespace is owned by euid 0., This means that the\n   * regular user namespace parent (with uid != 0) doesn't have any\n   * capabilities in it, which is nice as we can't exploit those. In\n   * particular the parent user namespace doesn't have CAP_PTRACE\n   * which would otherwise allow the parent to hijack of the child\n   * after this point.\n   *\n   * Unfortunately this also means you can't ptrace the final\n   * sandboxed process from outside the sandbox either.\n   */\n\n  if (opt_info_fd != -1)\n    close (opt_info_fd);\n\n  /* Wait for the parent to init uid/gid maps and drop caps */\n  res = read (child_wait_fd, &val, 8);\n  close (child_wait_fd);\n\n  /* At this point we can completely drop root uid, but retain the\n   * required permitted caps. This allow us to do full setup as\n   * the user uid, which makes e.g. fuse access work.\n   */\n  switch_to_user_with_privs ();\n\n  if (opt_unshare_net && loopback_setup () != 0)\n    die (\"Can't create loopback device\");\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n  if (!is_privileged && opt_unshare_user)\n    {\n      /* In the unprivileged case we have to write the uid/gid maps in\n       * the child, because we have no caps in the parent */\n\n      if (opt_needs_devpts)\n        {\n          /* This is a bit hacky, but we need to first map the real uid/gid to\n             0, otherwise we can't mount the devpts filesystem because root is\n             not mapped. Later we will create another child user namespace and\n             map back to the real uid */\n          ns_uid = 0;\n          ns_gid = 0;\n        }\n\n      write_uid_gid_map (ns_uid, real_uid,\n                         ns_gid, real_gid,\n                         -1, TRUE, FALSE);\n    }\n\n  old_umask = umask (0);\n\n  /* Need to do this before the chroot, but after we're the real uid */\n  resolve_symlinks_in_ops ();\n\n  /* Mark everything as slave, so that we still\n   * receive mounts from the real root, but don't\n   * propagate mounts to the real root. */\n  if (mount (NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0)\n    die_with_error (\"Failed to make / slave\");\n\n  /* Create a tmpfs which we will use as / in the namespace */\n  if (mount (\"\", base_path, \"tmpfs\", MS_NODEV | MS_NOSUID, NULL) != 0)\n    die_with_error (\"Failed to mount tmpfs\");\n\n  old_cwd = get_current_dir_name ();\n\n  /* Chdir to the new root tmpfs mount. This will be the CWD during\n     the entire setup. Access old or new root via \"oldroot\" and \"newroot\". */\n  if (chdir (base_path) != 0)\n    die_with_error (\"chdir base_path\");\n\n  /* We create a subdir \"$base_path/newroot\" for the new root, that\n   * way we can pivot_root to base_path, and put the old root at\n   * \"$base_path/oldroot\". This avoids problems accessing the oldroot\n   * dir if the user requested to bind mount something over / */\n\n  if (mkdir (\"newroot\", 0755))\n    die_with_error (\"Creating newroot failed\");\n\n  if (mkdir (\"oldroot\", 0755))\n    die_with_error (\"Creating oldroot failed\");\n\n  if (pivot_root (base_path, \"oldroot\"))\n    die_with_error (\"pivot_root\");\n\n  if (chdir (\"/\") != 0)\n    die_with_error (\"chdir / (base path)\");\n\n  if (is_privileged)\n    {\n      pid_t child;\n      int privsep_sockets[2];\n\n      if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, privsep_sockets) != 0)\n        die_with_error (\"Can't create privsep socket\");\n\n      child = fork ();\n      if (child == -1)\n        die_with_error (\"Can't fork unprivileged helper\");\n\n      if (child == 0)\n        {\n          /* Unprivileged setup process */\n          drop_privs ();\n          close (privsep_sockets[0]);\n          setup_newroot (opt_unshare_pid, privsep_sockets[1]);\n          exit (0);\n        }\n      else\n        {\n          int status;\n          uint32_t buffer[2048];  /* 8k, but is int32 to guarantee nice alignment */\n          uint32_t op, flags;\n          const char *arg1, *arg2;\n          cleanup_fd int unpriv_socket = -1;\n\n          unpriv_socket = privsep_sockets[0];\n          close (privsep_sockets[1]);\n\n          do\n            {\n              op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer),\n                                     &flags, &arg1, &arg2);\n              privileged_op (-1, op, flags, arg1, arg2);\n              if (write (unpriv_socket, buffer, 1) != 1)\n                die (\"Can't write to op_socket\");\n            }\n          while (op != PRIV_SEP_OP_DONE);\n\n          waitpid (child, &status, 0);\n          /* Continue post setup */\n        }\n    }\n  else\n    {\n      setup_newroot (opt_unshare_pid, -1);\n    }\n\n  /* The old root better be rprivate or we will send unmount events to the parent namespace */\n  if (mount (\"oldroot\", \"oldroot\", NULL, MS_REC | MS_PRIVATE, NULL) != 0)\n    die_with_error (\"Failed to make old root rprivate\");\n\n  if (umount2 (\"oldroot\", MNT_DETACH))\n    die_with_error (\"unmount old root\");\n\n  if (opt_unshare_user &&\n      (ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid))\n    {\n      /* Now that devpts is mounted and we've no need for mount\n         permissions we can create a new userspace and map our uid\n         1:1 */\n\n      if (unshare (CLONE_NEWUSER))\n        die_with_error (\"unshare user ns\");\n\n      write_uid_gid_map (opt_sandbox_uid, ns_uid,\n                         opt_sandbox_gid, ns_gid,\n                         -1, FALSE, FALSE);\n    }\n\n  /* Now make /newroot the real root */\n  if (chdir (\"/newroot\") != 0)\n    die_with_error (\"chdir newroot\");\n  if (chroot (\"/newroot\") != 0)\n    die_with_error (\"chroot /newroot\");\n  if (chdir (\"/\") != 0)\n    die_with_error (\"chdir /\");\n\n  /* All privileged ops are done now, so drop it */\n  drop_privs ();\n\n  if (opt_block_fd != -1)\n    {\n      char b[1];\n      read (opt_block_fd, b, 1);\n      close (opt_block_fd);\n    }\n\n  if (opt_seccomp_fd != -1)\n    {\n      cleanup_free char *seccomp_data = NULL;\n      size_t seccomp_len;\n      struct sock_fprog prog;\n\n      seccomp_data = load_file_data (opt_seccomp_fd, &seccomp_len);\n      if (seccomp_data == NULL)\n        die_with_error (\"Can't read seccomp data\");\n\n      if (seccomp_len % 8 != 0)\n        die (\"Invalid seccomp data, must be multiple of 8\");\n\n      prog.len = seccomp_len / 8;\n      prog.filter = (struct sock_filter *) seccomp_data;\n\n      close (opt_seccomp_fd);\n\n      if (prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog) != 0)\n        die_with_error (\"prctl(PR_SET_SECCOMP)\");\n    }\n\n  umask (old_umask);\n\n  new_cwd = \"/\";\n  if (opt_chdir_path)\n    {\n      if (chdir (opt_chdir_path))\n        die_with_error (\"Can't chdir to %s\", opt_chdir_path);\n      new_cwd = opt_chdir_path;\n    }\n  else if (chdir (old_cwd) == 0)\n    {\n      /* If the old cwd is mapped in the sandbox, go there */\n      new_cwd = old_cwd;\n    }\n  else\n    {\n      /* If the old cwd is not mapped, go to home */\n      const char *home = getenv (\"HOME\");\n      if (home != NULL &&\n          chdir (home) == 0)\n        new_cwd = home;\n    }\n  xsetenv (\"PWD\", new_cwd, 1);\n  free (old_cwd);\n\n  __debug__ ((\"forking for child\\n\"));\n\n  if (opt_unshare_pid || lock_files != NULL || opt_sync_fd != -1)\n    {\n      /* We have to have a pid 1 in the pid namespace, because\n       * otherwise we'll get a bunch of zombies as nothing reaps\n       * them. Alternatively if we're using sync_fd or lock_files we\n       * need some process to own these.\n       */\n\n      pid = fork ();\n      if (pid == -1)\n        die_with_error (\"Can't fork for pid 1\");\n\n      if (pid != 0)\n        {\n          /* Close fds in pid 1, except stdio and optionally event_fd\n             (for syncing pid 2 lifetime with monitor_child) and\n             opt_sync_fd (for syncing sandbox lifetime with outside\n             process).\n             Any other fds will been passed on to the child though. */\n          {\n            int dont_close[3];\n            int j = 0;\n            if (event_fd != -1)\n              dont_close[j++] = event_fd;\n            if (opt_sync_fd != -1)\n              dont_close[j++] = opt_sync_fd;\n            dont_close[j++] = -1;\n            fdwalk (proc_fd, close_extra_fds, dont_close);\n          }\n\n          return do_init (event_fd, pid);\n        }\n    }\n\n  __debug__ ((\"launch executable %s\\n\", argv[0]));\n\n  if (proc_fd != -1)\n    close (proc_fd);\n\n  if (opt_sync_fd != -1)\n    close (opt_sync_fd);\n\n   /* We want sigchild in the child */\n   unblock_sigchild ();\n \n   if (label_exec (opt_exec_label) == -1)\n     die_with_error (\"label_exec %s\", argv[0]);\n \n  if (execvp (argv[0], argv) == -1)\n    die_with_error (\"execvp %s\", argv[0]);\n\n  return 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142667,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "main (int    argc,\n      char **argv)\n{\n  mode_t old_umask;\n  cleanup_free char *base_path = NULL;\n  int clone_flags;\n  char *old_cwd = NULL;\n  pid_t pid;\n  int event_fd = -1;\n  int child_wait_fd = -1;\n  const char *new_cwd;\n  uid_t ns_uid;\n  gid_t ns_gid;\n  struct stat sbuf;\n  uint64_t val;\n  int res UNUSED;\n\n  real_uid = getuid ();\n  real_gid = getgid ();\n\n  /* Get the (optional) privileges we need */\n  acquire_privs ();\n\n  /* Never gain any more privs during exec */\n  if (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0)\n    die_with_error (\"prctl(PR_SET_NO_NEW_CAPS) failed\");\n\n  /* The initial code is run with high permissions\n     (i.e. CAP_SYS_ADMIN), so take lots of care. */\n\n  read_overflowids ();\n\n  argv0 = argv[0];\n\n  if (isatty (1))\n    host_tty_dev = ttyname (1);\n\n  argv++;\n  argc--;\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  parse_args (&argc, &argv);\n\n  /* We have to do this if we weren't installed setuid (and we're not\n   * root), so let's just DWIM */\n  if (!is_privileged && getuid () != 0)\n    opt_unshare_user = TRUE;\n\n  if (opt_unshare_user_try &&\n      stat (\"/proc/self/ns/user\", &sbuf) == 0)\n    {\n      bool disabled = FALSE;\n\n      /* RHEL7 has a kernel module parameter that lets you enable user namespaces */\n      if (stat (\"/sys/module/user_namespace/parameters/enable\", &sbuf) == 0)\n        {\n          cleanup_free char *enable = NULL;\n          enable = load_file_at (AT_FDCWD, \"/sys/module/user_namespace/parameters/enable\");\n          if (enable != NULL && enable[0] == 'N')\n            disabled = TRUE;\n        }\n\n      /* Debian lets you disable *unprivileged* user namespaces. However this is not\n         a problem if we're privileged, and if we're not opt_unshare_user is TRUE\n         already, and there is not much we can do, its just a non-working setup. */\n\n      if (!disabled)\n        opt_unshare_user = TRUE;\n    }\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  __debug__ ((\"Creating root mount point\\n\"));\n\n  if (opt_sandbox_uid == -1)\n    opt_sandbox_uid = real_uid;\n  if (opt_sandbox_gid == -1)\n    opt_sandbox_gid = real_gid;\n\n  if (!opt_unshare_user && opt_sandbox_uid != real_uid)\n    die (\"Specifying --uid requires --unshare-user\");\n\n  if (!opt_unshare_user && opt_sandbox_gid != real_gid)\n    die (\"Specifying --gid requires --unshare-user\");\n\n  if (!opt_unshare_uts && opt_sandbox_hostname != NULL)\n    die (\"Specifying --hostname requires --unshare-uts\");\n\n  /* We need to read stuff from proc during the pivot_root dance, etc.\n     Lets keep a fd to it open */\n  proc_fd = open (\"/proc\", O_RDONLY | O_PATH);\n  if (proc_fd == -1)\n    die_with_error (\"Can't open /proc\");\n\n  /* We need *some* mountpoint where we can mount the root tmpfs.\n     We first try in /run, and if that fails, try in /tmp. */\n  base_path = xasprintf (\"/run/user/%d/.bubblewrap\", real_uid);\n  if (mkdir (base_path, 0755) && errno != EEXIST)\n    {\n      free (base_path);\n      base_path = xasprintf (\"/tmp/.bubblewrap-%d\", real_uid);\n      if (mkdir (base_path, 0755) && errno != EEXIST)\n        die_with_error (\"Creating root mountpoint failed\");\n    }\n\n  __debug__ ((\"creating new namespace\\n\"));\n\n  if (opt_unshare_pid)\n    {\n      event_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK);\n      if (event_fd == -1)\n        die_with_error (\"eventfd()\");\n    }\n\n  /* We block sigchild here so that we can use signalfd in the monitor. */\n  block_sigchild ();\n\n  clone_flags = SIGCHLD | CLONE_NEWNS;\n  if (opt_unshare_user)\n    clone_flags |= CLONE_NEWUSER;\n  if (opt_unshare_pid)\n    clone_flags |= CLONE_NEWPID;\n  if (opt_unshare_net)\n    clone_flags |= CLONE_NEWNET;\n  if (opt_unshare_ipc)\n    clone_flags |= CLONE_NEWIPC;\n  if (opt_unshare_uts)\n    clone_flags |= CLONE_NEWUTS;\n  if (opt_unshare_cgroup)\n    {\n      if (stat (\"/proc/self/ns/cgroup\", &sbuf))\n        {\n          if (errno == ENOENT)\n            die (\"Cannot create new cgroup namespace because the kernel does not support it\");\n          else\n            die_with_error (\"stat on /proc/self/ns/cgroup failed\");\n        }\n      clone_flags |= CLONE_NEWCGROUP;\n    }\n  if (opt_unshare_cgroup_try)\n    if (!stat (\"/proc/self/ns/cgroup\", &sbuf))\n      clone_flags |= CLONE_NEWCGROUP;\n\n  child_wait_fd = eventfd (0, EFD_CLOEXEC);\n  if (child_wait_fd == -1)\n    die_with_error (\"eventfd()\");\n\n  pid = raw_clone (clone_flags, NULL);\n  if (pid == -1)\n    {\n      if (opt_unshare_user)\n        {\n          if (errno == EINVAL)\n            die (\"Creating new namespace failed, likely because the kernel does not support user namespaces.  bwrap must be installed setuid on such systems.\");\n          else if (errno == EPERM && !is_privileged)\n            die (\"No permissions to creating new namespace, likely because the kernel does not allow non-privileged user namespaces. On e.g. debian this can be enabled with 'sysctl kernel.unprivileged_userns_clone=1'.\");\n        }\n\n      die_with_error (\"Creating new namespace failed\");\n    }\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n\n  if (pid != 0)\n    {\n      /* Parent, outside sandbox, privileged (initially) */\n\n      if (is_privileged && opt_unshare_user)\n        {\n          /* We're running as euid 0, but the uid we want to map is\n           * not 0. This means we're not allowed to write this from\n           * the child user namespace, so we do it from the parent.\n           *\n           * Also, we map uid/gid 0 in the namespace (to overflowuid)\n           * if opt_needs_devpts is true, because otherwise the mount\n           * of devpts fails due to root not being mapped.\n           */\n          write_uid_gid_map (ns_uid, real_uid,\n                             ns_gid, real_gid,\n                             pid, TRUE, opt_needs_devpts);\n        }\n\n      /* Initial launched process, wait for exec:ed command to exit */\n\n      /* We don't need any privileges in the launcher, drop them immediately. */\n      drop_privs ();\n\n      /* Let child run now that the uid maps are set up */\n      val = 1;\n      res = write (child_wait_fd, &val, 8);\n      /* Ignore res, if e.g. the child died and closed child_wait_fd we don't want to error out here */\n      close (child_wait_fd);\n\n      if (opt_info_fd != -1)\n        {\n          cleanup_free char *output = xasprintf (\"{\\n    \\\"child-pid\\\": %i\\n}\\n\", pid);\n          size_t len = strlen (output);\n          if (write (opt_info_fd, output, len) != len)\n            die_with_error (\"Write to info_fd\");\n          close (opt_info_fd);\n        }\n\n      monitor_child (event_fd);\n      exit (0); /* Should not be reached, but better safe... */\n    }\n\n  /* Child, in sandbox, privileged in the parent or in the user namespace (if --unshare-user).\n   *\n   * Note that for user namespaces we run as euid 0 during clone(), so\n   * the child user namespace is owned by euid 0., This means that the\n   * regular user namespace parent (with uid != 0) doesn't have any\n   * capabilities in it, which is nice as we can't exploit those. In\n   * particular the parent user namespace doesn't have CAP_PTRACE\n   * which would otherwise allow the parent to hijack of the child\n   * after this point.\n   *\n   * Unfortunately this also means you can't ptrace the final\n   * sandboxed process from outside the sandbox either.\n   */\n\n  if (opt_info_fd != -1)\n    close (opt_info_fd);\n\n  /* Wait for the parent to init uid/gid maps and drop caps */\n  res = read (child_wait_fd, &val, 8);\n  close (child_wait_fd);\n\n  /* At this point we can completely drop root uid, but retain the\n   * required permitted caps. This allow us to do full setup as\n   * the user uid, which makes e.g. fuse access work.\n   */\n  switch_to_user_with_privs ();\n\n  if (opt_unshare_net && loopback_setup () != 0)\n    die (\"Can't create loopback device\");\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n  if (!is_privileged && opt_unshare_user)\n    {\n      /* In the unprivileged case we have to write the uid/gid maps in\n       * the child, because we have no caps in the parent */\n\n      if (opt_needs_devpts)\n        {\n          /* This is a bit hacky, but we need to first map the real uid/gid to\n             0, otherwise we can't mount the devpts filesystem because root is\n             not mapped. Later we will create another child user namespace and\n             map back to the real uid */\n          ns_uid = 0;\n          ns_gid = 0;\n        }\n\n      write_uid_gid_map (ns_uid, real_uid,\n                         ns_gid, real_gid,\n                         -1, TRUE, FALSE);\n    }\n\n  old_umask = umask (0);\n\n  /* Need to do this before the chroot, but after we're the real uid */\n  resolve_symlinks_in_ops ();\n\n  /* Mark everything as slave, so that we still\n   * receive mounts from the real root, but don't\n   * propagate mounts to the real root. */\n  if (mount (NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0)\n    die_with_error (\"Failed to make / slave\");\n\n  /* Create a tmpfs which we will use as / in the namespace */\n  if (mount (\"\", base_path, \"tmpfs\", MS_NODEV | MS_NOSUID, NULL) != 0)\n    die_with_error (\"Failed to mount tmpfs\");\n\n  old_cwd = get_current_dir_name ();\n\n  /* Chdir to the new root tmpfs mount. This will be the CWD during\n     the entire setup. Access old or new root via \"oldroot\" and \"newroot\". */\n  if (chdir (base_path) != 0)\n    die_with_error (\"chdir base_path\");\n\n  /* We create a subdir \"$base_path/newroot\" for the new root, that\n   * way we can pivot_root to base_path, and put the old root at\n   * \"$base_path/oldroot\". This avoids problems accessing the oldroot\n   * dir if the user requested to bind mount something over / */\n\n  if (mkdir (\"newroot\", 0755))\n    die_with_error (\"Creating newroot failed\");\n\n  if (mkdir (\"oldroot\", 0755))\n    die_with_error (\"Creating oldroot failed\");\n\n  if (pivot_root (base_path, \"oldroot\"))\n    die_with_error (\"pivot_root\");\n\n  if (chdir (\"/\") != 0)\n    die_with_error (\"chdir / (base path)\");\n\n  if (is_privileged)\n    {\n      pid_t child;\n      int privsep_sockets[2];\n\n      if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, privsep_sockets) != 0)\n        die_with_error (\"Can't create privsep socket\");\n\n      child = fork ();\n      if (child == -1)\n        die_with_error (\"Can't fork unprivileged helper\");\n\n      if (child == 0)\n        {\n          /* Unprivileged setup process */\n          drop_privs ();\n          close (privsep_sockets[0]);\n          setup_newroot (opt_unshare_pid, privsep_sockets[1]);\n          exit (0);\n        }\n      else\n        {\n          int status;\n          uint32_t buffer[2048];  /* 8k, but is int32 to guarantee nice alignment */\n          uint32_t op, flags;\n          const char *arg1, *arg2;\n          cleanup_fd int unpriv_socket = -1;\n\n          unpriv_socket = privsep_sockets[0];\n          close (privsep_sockets[1]);\n\n          do\n            {\n              op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer),\n                                     &flags, &arg1, &arg2);\n              privileged_op (-1, op, flags, arg1, arg2);\n              if (write (unpriv_socket, buffer, 1) != 1)\n                die (\"Can't write to op_socket\");\n            }\n          while (op != PRIV_SEP_OP_DONE);\n\n          waitpid (child, &status, 0);\n          /* Continue post setup */\n        }\n    }\n  else\n    {\n      setup_newroot (opt_unshare_pid, -1);\n    }\n\n  /* The old root better be rprivate or we will send unmount events to the parent namespace */\n  if (mount (\"oldroot\", \"oldroot\", NULL, MS_REC | MS_PRIVATE, NULL) != 0)\n    die_with_error (\"Failed to make old root rprivate\");\n\n  if (umount2 (\"oldroot\", MNT_DETACH))\n    die_with_error (\"unmount old root\");\n\n  if (opt_unshare_user &&\n      (ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid))\n    {\n      /* Now that devpts is mounted and we've no need for mount\n         permissions we can create a new userspace and map our uid\n         1:1 */\n\n      if (unshare (CLONE_NEWUSER))\n        die_with_error (\"unshare user ns\");\n\n      write_uid_gid_map (opt_sandbox_uid, ns_uid,\n                         opt_sandbox_gid, ns_gid,\n                         -1, FALSE, FALSE);\n    }\n\n  /* Now make /newroot the real root */\n  if (chdir (\"/newroot\") != 0)\n    die_with_error (\"chdir newroot\");\n  if (chroot (\"/newroot\") != 0)\n    die_with_error (\"chroot /newroot\");\n  if (chdir (\"/\") != 0)\n    die_with_error (\"chdir /\");\n\n  /* All privileged ops are done now, so drop it */\n  drop_privs ();\n\n  if (opt_block_fd != -1)\n    {\n      char b[1];\n      read (opt_block_fd, b, 1);\n      close (opt_block_fd);\n    }\n\n  if (opt_seccomp_fd != -1)\n    {\n      cleanup_free char *seccomp_data = NULL;\n      size_t seccomp_len;\n      struct sock_fprog prog;\n\n      seccomp_data = load_file_data (opt_seccomp_fd, &seccomp_len);\n      if (seccomp_data == NULL)\n        die_with_error (\"Can't read seccomp data\");\n\n      if (seccomp_len % 8 != 0)\n        die (\"Invalid seccomp data, must be multiple of 8\");\n\n      prog.len = seccomp_len / 8;\n      prog.filter = (struct sock_filter *) seccomp_data;\n\n      close (opt_seccomp_fd);\n\n      if (prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog) != 0)\n        die_with_error (\"prctl(PR_SET_SECCOMP)\");\n    }\n\n  umask (old_umask);\n\n  new_cwd = \"/\";\n  if (opt_chdir_path)\n    {\n      if (chdir (opt_chdir_path))\n        die_with_error (\"Can't chdir to %s\", opt_chdir_path);\n      new_cwd = opt_chdir_path;\n    }\n  else if (chdir (old_cwd) == 0)\n    {\n      /* If the old cwd is mapped in the sandbox, go there */\n      new_cwd = old_cwd;\n    }\n  else\n    {\n      /* If the old cwd is not mapped, go to home */\n      const char *home = getenv (\"HOME\");\n      if (home != NULL &&\n          chdir (home) == 0)\n        new_cwd = home;\n    }\n  xsetenv (\"PWD\", new_cwd, 1);\n  free (old_cwd);\n\n  __debug__ ((\"forking for child\\n\"));\n\n  if (opt_unshare_pid || lock_files != NULL || opt_sync_fd != -1)\n    {\n      /* We have to have a pid 1 in the pid namespace, because\n       * otherwise we'll get a bunch of zombies as nothing reaps\n       * them. Alternatively if we're using sync_fd or lock_files we\n       * need some process to own these.\n       */\n\n      pid = fork ();\n      if (pid == -1)\n        die_with_error (\"Can't fork for pid 1\");\n\n      if (pid != 0)\n        {\n          /* Close fds in pid 1, except stdio and optionally event_fd\n             (for syncing pid 2 lifetime with monitor_child) and\n             opt_sync_fd (for syncing sandbox lifetime with outside\n             process).\n             Any other fds will been passed on to the child though. */\n          {\n            int dont_close[3];\n            int j = 0;\n            if (event_fd != -1)\n              dont_close[j++] = event_fd;\n            if (opt_sync_fd != -1)\n              dont_close[j++] = opt_sync_fd;\n            dont_close[j++] = -1;\n            fdwalk (proc_fd, close_extra_fds, dont_close);\n          }\n\n          return do_init (event_fd, pid);\n        }\n    }\n\n  __debug__ ((\"launch executable %s\\n\", argv[0]));\n\n  if (proc_fd != -1)\n    close (proc_fd);\n\n  if (opt_sync_fd != -1)\n    close (opt_sync_fd);\n\n   /* We want sigchild in the child */\n   unblock_sigchild ();\n \n  if (setsid () == (pid_t) -1)\n    die_with_error (\"setsid\");\n\n   if (label_exec (opt_exec_label) == -1)\n     die_with_error (\"label_exec %s\", argv[0]);\n \n  if (execvp (argv[0], argv) == -1)\n    die_with_error (\"execvp %s\", argv[0]);\n\n  return 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142668,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=CloneImageInfo(image_info);\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n       case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n          if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n          Frames = ReadBlobXXXLong(image2);\n          break;\n       default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n     }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\n    quantum_info=DestroyQuantumInfo(quantum_info);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\nEND_OF_READING:\n  clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142731,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=CloneImageInfo(image_info);\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n       case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n          if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          break;\n       default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n     }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\n    quantum_info=DestroyQuantumInfo(quantum_info);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\nEND_OF_READING:\n  clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142732,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " static MagickBooleanType ConcatenateImages(int argc,char **argv,\n     ExceptionInfo *exception )\n {\n   FILE\n     *input,\n     *output;\n \n   int\n     c;\n \n  register ssize_t\n    i;\n \n   if (ExpandFilenames(&argc,&argv) == MagickFalse)\n     ThrowFileException(exception,ResourceLimitError,\"MemoryAllocationFailed\",\n         GetExceptionMessage(errno));\n   output=fopen_utf8(argv[argc-1],\"wb\");\n  if (output == (FILE *) NULL) {\n    ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[argc-1]);\n    return(MagickFalse);\n  }\n  for (i=2; i < (ssize_t) (argc-1); i++) {\n#if 0\n    fprintf(stderr, \"DEBUG: Concatenate Image: \\\"%s\\\"\\n\", argv[i]);\n#endif\n     input=fopen_utf8(argv[i],\"rb\");\n    if (input == (FILE *) NULL) {\n         ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[i]);\n         continue;\n       }\n     for (c=fgetc(input); c != EOF; c=fgetc(input))\n      (void) fputc((char) c,output);\n     (void) fclose(input);\n     (void) remove_utf8(argv[i]);\n   }\n   (void) fclose(output);\n  return(MagickTrue);\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142741,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " static MagickBooleanType ConcatenateImages(int argc,char **argv,\n  ExceptionInfo *exception )\n {\n   FILE\n     *input,\n     *output;\n \n  MagickBooleanType\n    status;\n\n   int\n     c;\n \n  register ssize_t\n    i;\n \n   if (ExpandFilenames(&argc,&argv) == MagickFalse)\n     ThrowFileException(exception,ResourceLimitError,\"MemoryAllocationFailed\",\n      GetExceptionMessage(errno));\n   output=fopen_utf8(argv[argc-1],\"wb\");\n  if (output == (FILE *) NULL)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        argv[argc-1]);\n      return(MagickFalse);\n    }\n  status=MagickTrue;\n  for (i=2; i < (ssize_t) (argc-1); i++)\n  {\n     input=fopen_utf8(argv[i],\"rb\");\n    if (input == (FILE *) NULL)\n      {\n         ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[i]);\n         continue;\n       }\n     for (c=fgetc(input); c != EOF; c=fgetc(input))\n      if (fputc((char) c,output) != c)\n        status=MagickFalse;\n     (void) fclose(input);\n     (void) remove_utf8(argv[i]);\n   }\n   (void) fclose(output);\n  return(status);\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142742,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadHDRImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    format[MaxTextExtent],\n    keyword[MaxTextExtent],\n    tag[MaxTextExtent],\n    value[MaxTextExtent];\n\n  double\n    gamma;\n\n  Image\n    *image;\n\n  int\n    c;\n\n  MagickBooleanType\n    status,\n    value_expected;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *end,\n    pixel[4],\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Decode image header.\n  */\n  image->columns=0;\n  image->rows=0;\n  *format='\\0';\n  c=ReadBlobByte(image);\n  if (c == EOF)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  while (isgraph(c) && (image->columns == 0) && (image->rows == 0))\n  {\n    if (c == (int) '#')\n      {\n        char\n          *comment;\n\n        register char\n          *p;\n\n        size_t\n          length;\n\n        /*\n          Read comment-- any text between # and end-of-line.\n        */\n        length=MaxTextExtent;\n        comment=AcquireString((char *) NULL);\n        for (p=comment; comment != (char *) NULL; p++)\n        {\n          c=ReadBlobByte(image);\n          if ((c == EOF) || (c == (int) '\\n'))\n            break;\n          if ((size_t) (p-comment+1) >= length)\n            {\n              *p='\\0';\n              length<<=1;\n              comment=(char *) ResizeQuantumMemory(comment,length+\n                MaxTextExtent,sizeof(*comment));\n              if (comment == (char *) NULL)\n                break;\n              p=comment+strlen(comment);\n            }\n          *p=(char) c;\n        }\n        if (comment == (char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        *p='\\0';\n        (void) SetImageProperty(image,\"comment\",comment,exception);\n        comment=DestroyString(comment);\n        c=ReadBlobByte(image);\n      }\n    else\n      if (isalnum(c) == MagickFalse)\n        c=ReadBlobByte(image);\n      else\n        {\n          register char\n            *p;\n\n          /*\n            Determine a keyword and its value.\n          */\n          p=keyword;\n          do\n          {\n            if ((size_t) (p-keyword) < (MaxTextExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          } while (isalnum(c) || (c == '_'));\n          *p='\\0';\n          value_expected=MagickFalse;\n          while ((isspace((int) ((unsigned char) c)) != 0) || (c == '='))\n          {\n            if (c == '=')\n              value_expected=MagickTrue;\n            c=ReadBlobByte(image);\n          }\n          if (LocaleCompare(keyword,\"Y\") == 0)\n            value_expected=MagickTrue;\n           if (value_expected == MagickFalse)\n             continue;\n           p=value;\n          while ((c != '\\n') && (c != '\\0'))\n           {\n             if ((size_t) (p-value) < (MaxTextExtent-1))\n               *p++=c;\n            c=ReadBlobByte(image);\n          }\n          *p='\\0';\n          /*\n            Assign a value to the specified keyword.\n          */\n          switch (*keyword)\n          {\n            case 'F':\n            case 'f':\n            {\n              if (LocaleCompare(keyword,\"format\") == 0)\n                {\n                  (void) CopyMagickString(format,value,MaxTextExtent);\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'G':\n            case 'g':\n            {\n              if (LocaleCompare(keyword,\"gamma\") == 0)\n                {\n                  image->gamma=StringToDouble(value,(char **) NULL);\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'P':\n            case 'p':\n            {\n              if (LocaleCompare(keyword,\"primaries\") == 0)\n                {\n                  float\n                     chromaticity[6],\n                     white_point[2];\n \n                  (void) sscanf(value,\"%g %g %g %g %g %g %g %g\",\n                    &chromaticity[0],&chromaticity[1],&chromaticity[2],\n                    &chromaticity[3],&chromaticity[4],&chromaticity[5],\n                    &white_point[0],&white_point[1]);\n                  image->chromaticity.red_primary.x=chromaticity[0];\n                  image->chromaticity.red_primary.y=chromaticity[1];\n                  image->chromaticity.green_primary.x=chromaticity[2];\n                  image->chromaticity.green_primary.y=chromaticity[3];\n                  image->chromaticity.blue_primary.x=chromaticity[4];\n                  image->chromaticity.blue_primary.y=chromaticity[5];\n                  image->chromaticity.white_point.x=white_point[0],\n                  image->chromaticity.white_point.y=white_point[1];\n                   break;\n                 }\n               (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'Y':\n            case 'y':\n            {\n              char\n                target[] = \"Y\";\n\n              if (strcmp(keyword,target) == 0)\n                {\n                  int\n                     height,\n                     width;\n \n                  (void) sscanf(value,\"%d +X %d\",&height,&width);\n                  image->columns=(size_t) width;\n                  image->rows=(size_t) height;\n                   break;\n                 }\n               (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            default:\n            {\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n          }\n        }\n    if ((image->columns == 0) && (image->rows == 0))\n      while (isspace((int) ((unsigned char) c)) != 0)\n        c=ReadBlobByte(image);\n  }\n  if ((LocaleCompare(format,\"32-bit_rle_rgbe\") != 0) &&\n      (LocaleCompare(format,\"32-bit_rle_xyze\") != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n  (void) SetImageColorspace(image,RGBColorspace,exception);\n  if (LocaleCompare(format,\"32-bit_rle_xyze\") == 0)\n    (void) SetImageColorspace(image,XYZColorspace,exception);\n  image->compression=(image->columns < 8) || (image->columns > 0x7ffff) ?\n    NoCompression : RLECompression;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Read RGBE (red+green+blue+exponent) pixels.\n  */\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns,4*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    if (image->compression != RLECompression)\n      {\n        count=ReadBlob(image,4*image->columns*sizeof(*pixels),pixels);\n        if (count != (ssize_t) (4*image->columns*sizeof(*pixels)))\n          break;\n      }\n    else\n      {\n        count=ReadBlob(image,4*sizeof(*pixel),pixel);\n        if (count != 4)\n          break;\n        if ((size_t) ((((size_t) pixel[2]) << 8) | pixel[3]) != image->columns)\n          {\n            (void) memcpy(pixels,pixel,4*sizeof(*pixel));\n            count=ReadBlob(image,4*(image->columns-1)*sizeof(*pixels),pixels+4);\n            image->compression=NoCompression;\n          }\n        else\n          {\n            p=pixels;\n            for (i=0; i < 4; i++)\n            {\n              end=&pixels[(i+1)*image->columns];\n              while (p < end)\n              {\n                count=ReadBlob(image,2*sizeof(*pixel),pixel);\n                if (count < 1)\n                  break;\n                if (pixel[0] > 128)\n                  {\n                    count=(ssize_t) pixel[0]-128;\n                    if ((count == 0) || (count > (ssize_t) (end-p)))\n                      break;\n                    while (count-- > 0)\n                      *p++=pixel[1];\n                  }\n                else\n                  {\n                    count=(ssize_t) pixel[0];\n                    if ((count == 0) || (count > (ssize_t) (end-p)))\n                      break;\n                    *p++=pixel[1];\n                    if (--count > 0)\n                      {\n                        count=ReadBlob(image,(size_t) count*sizeof(*p),p);\n                        if (count < 1)\n                          break;\n                        p+=count;\n                      }\n                  }\n              }\n            }\n          }\n      }\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    i=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (image->compression == RLECompression)\n        {\n          pixel[0]=pixels[x];\n          pixel[1]=pixels[x+image->columns];\n          pixel[2]=pixels[x+2*image->columns];\n          pixel[3]=pixels[x+3*image->columns];\n        }\n      else\n        {\n          pixel[0]=pixels[i++];\n          pixel[1]=pixels[i++];\n          pixel[2]=pixels[i++];\n          pixel[3]=pixels[i++];\n        }\n      SetPixelRed(image,0,q);\n      SetPixelGreen(image,0,q);\n      SetPixelBlue(image,0,q);\n      if (pixel[3] != 0)\n        {\n          gamma=pow(2.0,pixel[3]-(128.0+8.0));\n          SetPixelRed(image,ClampToQuantum(QuantumRange*gamma*pixel[0]),q);\n          SetPixelGreen(image,ClampToQuantum(QuantumRange*gamma*pixel[1]),q);\n          SetPixelBlue(image,ClampToQuantum(QuantumRange*gamma*pixel[2]),q);\n        }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142817,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadHDRImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    format[MaxTextExtent],\n    keyword[MaxTextExtent],\n    tag[MaxTextExtent],\n    value[MaxTextExtent];\n\n  double\n    gamma;\n\n  Image\n    *image;\n\n  int\n    c;\n\n  MagickBooleanType\n    status,\n    value_expected;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *end,\n    pixel[4],\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Decode image header.\n  */\n  image->columns=0;\n  image->rows=0;\n  *format='\\0';\n  c=ReadBlobByte(image);\n  if (c == EOF)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  while (isgraph(c) && (image->columns == 0) && (image->rows == 0))\n  {\n    if (c == (int) '#')\n      {\n        char\n          *comment;\n\n        register char\n          *p;\n\n        size_t\n          length;\n\n        /*\n          Read comment-- any text between # and end-of-line.\n        */\n        length=MaxTextExtent;\n        comment=AcquireString((char *) NULL);\n        for (p=comment; comment != (char *) NULL; p++)\n        {\n          c=ReadBlobByte(image);\n          if ((c == EOF) || (c == (int) '\\n'))\n            break;\n          if ((size_t) (p-comment+1) >= length)\n            {\n              *p='\\0';\n              length<<=1;\n              comment=(char *) ResizeQuantumMemory(comment,length+\n                MaxTextExtent,sizeof(*comment));\n              if (comment == (char *) NULL)\n                break;\n              p=comment+strlen(comment);\n            }\n          *p=(char) c;\n        }\n        if (comment == (char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        *p='\\0';\n        (void) SetImageProperty(image,\"comment\",comment,exception);\n        comment=DestroyString(comment);\n        c=ReadBlobByte(image);\n      }\n    else\n      if (isalnum(c) == MagickFalse)\n        c=ReadBlobByte(image);\n      else\n        {\n          register char\n            *p;\n\n          /*\n            Determine a keyword and its value.\n          */\n          p=keyword;\n          do\n          {\n            if ((size_t) (p-keyword) < (MaxTextExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          } while (isalnum(c) || (c == '_'));\n          *p='\\0';\n          value_expected=MagickFalse;\n          while ((isspace((int) ((unsigned char) c)) != 0) || (c == '='))\n          {\n            if (c == '=')\n              value_expected=MagickTrue;\n            c=ReadBlobByte(image);\n          }\n          if (LocaleCompare(keyword,\"Y\") == 0)\n            value_expected=MagickTrue;\n           if (value_expected == MagickFalse)\n             continue;\n           p=value;\n          while ((c != '\\n') && (c != '\\0') && (c != EOF))\n           {\n             if ((size_t) (p-value) < (MaxTextExtent-1))\n               *p++=c;\n            c=ReadBlobByte(image);\n          }\n          *p='\\0';\n          /*\n            Assign a value to the specified keyword.\n          */\n          switch (*keyword)\n          {\n            case 'F':\n            case 'f':\n            {\n              if (LocaleCompare(keyword,\"format\") == 0)\n                {\n                  (void) CopyMagickString(format,value,MaxTextExtent);\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'G':\n            case 'g':\n            {\n              if (LocaleCompare(keyword,\"gamma\") == 0)\n                {\n                  image->gamma=StringToDouble(value,(char **) NULL);\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'P':\n            case 'p':\n            {\n              if (LocaleCompare(keyword,\"primaries\") == 0)\n                {\n                  float\n                     chromaticity[6],\n                     white_point[2];\n \n                  if (sscanf(value,\"%g %g %g %g %g %g %g %g\",&chromaticity[0],\n                      &chromaticity[1],&chromaticity[2],&chromaticity[3],\n                      &chromaticity[4],&chromaticity[5],&white_point[0],\n                      &white_point[1]) == 8)\n                    {\n                      image->chromaticity.red_primary.x=chromaticity[0];\n                      image->chromaticity.red_primary.y=chromaticity[1];\n                      image->chromaticity.green_primary.x=chromaticity[2];\n                      image->chromaticity.green_primary.y=chromaticity[3];\n                      image->chromaticity.blue_primary.x=chromaticity[4];\n                      image->chromaticity.blue_primary.y=chromaticity[5];\n                      image->chromaticity.white_point.x=white_point[0],\n                      image->chromaticity.white_point.y=white_point[1];\n                    }\n                   break;\n                 }\n               (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'Y':\n            case 'y':\n            {\n              char\n                target[] = \"Y\";\n\n              if (strcmp(keyword,target) == 0)\n                {\n                  int\n                     height,\n                     width;\n \n                  if (sscanf(value,\"%d +X %d\",&height,&width) == 2)\n                    {\n                      image->columns=(size_t) width;\n                      image->rows=(size_t) height;\n                    }\n                   break;\n                 }\n               (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            default:\n            {\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n          }\n        }\n    if ((image->columns == 0) && (image->rows == 0))\n      while (isspace((int) ((unsigned char) c)) != 0)\n        c=ReadBlobByte(image);\n  }\n  if ((LocaleCompare(format,\"32-bit_rle_rgbe\") != 0) &&\n      (LocaleCompare(format,\"32-bit_rle_xyze\") != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n  (void) SetImageColorspace(image,RGBColorspace,exception);\n  if (LocaleCompare(format,\"32-bit_rle_xyze\") == 0)\n    (void) SetImageColorspace(image,XYZColorspace,exception);\n  image->compression=(image->columns < 8) || (image->columns > 0x7ffff) ?\n    NoCompression : RLECompression;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Read RGBE (red+green+blue+exponent) pixels.\n  */\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns,4*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    if (image->compression != RLECompression)\n      {\n        count=ReadBlob(image,4*image->columns*sizeof(*pixels),pixels);\n        if (count != (ssize_t) (4*image->columns*sizeof(*pixels)))\n          break;\n      }\n    else\n      {\n        count=ReadBlob(image,4*sizeof(*pixel),pixel);\n        if (count != 4)\n          break;\n        if ((size_t) ((((size_t) pixel[2]) << 8) | pixel[3]) != image->columns)\n          {\n            (void) memcpy(pixels,pixel,4*sizeof(*pixel));\n            count=ReadBlob(image,4*(image->columns-1)*sizeof(*pixels),pixels+4);\n            image->compression=NoCompression;\n          }\n        else\n          {\n            p=pixels;\n            for (i=0; i < 4; i++)\n            {\n              end=&pixels[(i+1)*image->columns];\n              while (p < end)\n              {\n                count=ReadBlob(image,2*sizeof(*pixel),pixel);\n                if (count < 1)\n                  break;\n                if (pixel[0] > 128)\n                  {\n                    count=(ssize_t) pixel[0]-128;\n                    if ((count == 0) || (count > (ssize_t) (end-p)))\n                      break;\n                    while (count-- > 0)\n                      *p++=pixel[1];\n                  }\n                else\n                  {\n                    count=(ssize_t) pixel[0];\n                    if ((count == 0) || (count > (ssize_t) (end-p)))\n                      break;\n                    *p++=pixel[1];\n                    if (--count > 0)\n                      {\n                        count=ReadBlob(image,(size_t) count*sizeof(*p),p);\n                        if (count < 1)\n                          break;\n                        p+=count;\n                      }\n                  }\n              }\n            }\n          }\n      }\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    i=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (image->compression == RLECompression)\n        {\n          pixel[0]=pixels[x];\n          pixel[1]=pixels[x+image->columns];\n          pixel[2]=pixels[x+2*image->columns];\n          pixel[3]=pixels[x+3*image->columns];\n        }\n      else\n        {\n          pixel[0]=pixels[i++];\n          pixel[1]=pixels[i++];\n          pixel[2]=pixels[i++];\n          pixel[3]=pixels[i++];\n        }\n      SetPixelRed(image,0,q);\n      SetPixelGreen(image,0,q);\n      SetPixelBlue(image,0,q);\n      if (pixel[3] != 0)\n        {\n          gamma=pow(2.0,pixel[3]-(128.0+8.0));\n          SetPixelRed(image,ClampToQuantum(QuantumRange*gamma*pixel[0]),q);\n          SetPixelGreen(image,ClampToQuantum(QuantumRange*gamma*pixel[1]),q);\n          SetPixelBlue(image,ClampToQuantum(QuantumRange*gamma*pixel[2]),q);\n        }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142818,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static ssize_t map_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos,\n\t\t\t int cap_setid,\n\t\t\t struct uid_gid_map *map,\n\t\t\t struct uid_gid_map *parent_map)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tstruct uid_gid_map new_map;\n\tunsigned idx;\n\tstruct uid_gid_extent extent;\n\tchar *kbuf = NULL, *pos, *next_line;\n\tssize_t ret;\n\n\t/* Only allow < page size writes at the beginning of the file */\n\tif ((*ppos != 0) || (count >= PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\t/* Slurp in the user data */\n\tkbuf = memdup_user_nul(buf, count);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\t/*\n\t * The userns_state_mutex serializes all writes to any given map.\n\t *\n\t * Any map is only ever written once.\n\t *\n\t * An id map fits within 1 cache line on most architectures.\n\t *\n\t * On read nothing needs to be done unless you are on an\n\t * architecture with a crazy cache coherency model like alpha.\n\t *\n\t * There is a one time data dependency between reading the\n\t * count of the extents and the values of the extents.  The\n\t * desired behavior is to see the values of the extents that\n\t * were written before the count of the extents.\n\t *\n\t * To achieve this smp_wmb() is used on guarantee the write\n\t * order and smp_rmb() is guaranteed that we don't have crazy\n\t * architectures returning stale data.\n\t */\n\tmutex_lock(&userns_state_mutex);\n\n\tmemset(&new_map, 0, sizeof(struct uid_gid_map));\n\n\tret = -EPERM;\n\t/* Only allow one successful write to the map */\n\tif (map->nr_extents != 0)\n\t\tgoto out;\n\n\t/*\n\t * Adjusting namespace settings requires capabilities on the target.\n\t */\n\tif (cap_valid(cap_setid) && !file_ns_capable(file, ns, CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\t/* Parse the user data */\n\tret = -EINVAL;\n\tpos = kbuf;\n\tfor (; pos; pos = next_line) {\n\n\t\t/* Find the end of line and ensure I don't look past it */\n\t\tnext_line = strchr(pos, '\\n');\n\t\tif (next_line) {\n\t\t\t*next_line = '\\0';\n\t\t\tnext_line++;\n\t\t\tif (*next_line == '\\0')\n\t\t\t\tnext_line = NULL;\n\t\t}\n\n\t\tpos = skip_spaces(pos);\n\t\textent.first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent.lower_first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent.count = simple_strtoul(pos, &pos, 10);\n\t\tif (*pos && !isspace(*pos))\n\t\t\tgoto out;\n\n\t\t/* Verify there is not trailing junk on the line */\n\t\tpos = skip_spaces(pos);\n\t\tif (*pos != '\\0')\n\t\t\tgoto out;\n\n\t\t/* Verify we have been given valid starting values */\n\t\tif ((extent.first == (u32) -1) ||\n\t\t    (extent.lower_first == (u32) -1))\n\t\t\tgoto out;\n\n\t\t/* Verify count is not zero and does not cause the\n\t\t * extent to wrap\n\t\t */\n\t\tif ((extent.first + extent.count) <= extent.first)\n\t\t\tgoto out;\n\t\tif ((extent.lower_first + extent.count) <=\n\t\t     extent.lower_first)\n\t\t\tgoto out;\n\n\t\t/* Do the ranges in extent overlap any previous extents? */\n\t\tif (mappings_overlap(&new_map, &extent))\n\t\t\tgoto out;\n\n\t\tif ((new_map.nr_extents + 1) == UID_GID_MAP_MAX_EXTENTS &&\n\t\t    (next_line != NULL))\n\t\t\tgoto out;\n\n\t\tret = insert_extent(&new_map, &extent);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = -EINVAL;\n\t}\n\t/* Be very certaint the new map actually exists */\n\tif (new_map.nr_extents == 0)\n\t\tgoto out;\n\n\tret = -EPERM;\n\t/* Validate the user is allowed to use user id's mapped to. */\n \tif (!new_idmap_permitted(file, ns, cap_setid, &new_map))\n \t\tgoto out;\n \n\tret = sort_idmaps(&new_map);\n\tif (ret < 0)\n\t\tgoto out;\n \tret = -EPERM;\n \t/* Map the lower ids from the parent user namespace to the\n \t * kernel global id space.\n\t */\n\tfor (idx = 0; idx < new_map.nr_extents; idx++) {\n\t\tstruct uid_gid_extent *e;\n\t\tu32 lower_first;\n\n\t\tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\t\te = &new_map.extent[idx];\n\t\telse\n\t\t\te = &new_map.forward[idx];\n\n\t\tlower_first = map_id_range_down(parent_map,\n\t\t\t\t\t\te->lower_first,\n\t\t\t\t\t\te->count);\n\n\t\t/* Fail if we can not map the specified extent to\n\t\t * the kernel global id space.\n\t\t */\n\t\tif (lower_first == (u32) -1)\n\t\t\tgoto out;\n\n \t\te->lower_first = lower_first;\n \t}\n \n \t/* Install the map */\n \tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS) {\n \t\tmemcpy(map->extent, new_map.extent,\n\t\t       new_map.nr_extents * sizeof(new_map.extent[0]));\n\t} else {\n\t\tmap->forward = new_map.forward;\n\t\tmap->reverse = new_map.reverse;\n\t}\n\tsmp_wmb();\n\tmap->nr_extents = new_map.nr_extents;\n\n\t*ppos = count;\n\tret = count;\nout:\n\tif (ret < 0 && new_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\tkfree(new_map.forward);\n\t\tkfree(new_map.reverse);\n\t\tmap->forward = NULL;\n\t\tmap->reverse = NULL;\n\t\tmap->nr_extents = 0;\n\t}\n\n\tmutex_unlock(&userns_state_mutex);\n\tkfree(kbuf);\n\treturn ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142881,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static ssize_t map_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos,\n\t\t\t int cap_setid,\n\t\t\t struct uid_gid_map *map,\n\t\t\t struct uid_gid_map *parent_map)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tstruct uid_gid_map new_map;\n\tunsigned idx;\n\tstruct uid_gid_extent extent;\n\tchar *kbuf = NULL, *pos, *next_line;\n\tssize_t ret;\n\n\t/* Only allow < page size writes at the beginning of the file */\n\tif ((*ppos != 0) || (count >= PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\t/* Slurp in the user data */\n\tkbuf = memdup_user_nul(buf, count);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\t/*\n\t * The userns_state_mutex serializes all writes to any given map.\n\t *\n\t * Any map is only ever written once.\n\t *\n\t * An id map fits within 1 cache line on most architectures.\n\t *\n\t * On read nothing needs to be done unless you are on an\n\t * architecture with a crazy cache coherency model like alpha.\n\t *\n\t * There is a one time data dependency between reading the\n\t * count of the extents and the values of the extents.  The\n\t * desired behavior is to see the values of the extents that\n\t * were written before the count of the extents.\n\t *\n\t * To achieve this smp_wmb() is used on guarantee the write\n\t * order and smp_rmb() is guaranteed that we don't have crazy\n\t * architectures returning stale data.\n\t */\n\tmutex_lock(&userns_state_mutex);\n\n\tmemset(&new_map, 0, sizeof(struct uid_gid_map));\n\n\tret = -EPERM;\n\t/* Only allow one successful write to the map */\n\tif (map->nr_extents != 0)\n\t\tgoto out;\n\n\t/*\n\t * Adjusting namespace settings requires capabilities on the target.\n\t */\n\tif (cap_valid(cap_setid) && !file_ns_capable(file, ns, CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\t/* Parse the user data */\n\tret = -EINVAL;\n\tpos = kbuf;\n\tfor (; pos; pos = next_line) {\n\n\t\t/* Find the end of line and ensure I don't look past it */\n\t\tnext_line = strchr(pos, '\\n');\n\t\tif (next_line) {\n\t\t\t*next_line = '\\0';\n\t\t\tnext_line++;\n\t\t\tif (*next_line == '\\0')\n\t\t\t\tnext_line = NULL;\n\t\t}\n\n\t\tpos = skip_spaces(pos);\n\t\textent.first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent.lower_first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent.count = simple_strtoul(pos, &pos, 10);\n\t\tif (*pos && !isspace(*pos))\n\t\t\tgoto out;\n\n\t\t/* Verify there is not trailing junk on the line */\n\t\tpos = skip_spaces(pos);\n\t\tif (*pos != '\\0')\n\t\t\tgoto out;\n\n\t\t/* Verify we have been given valid starting values */\n\t\tif ((extent.first == (u32) -1) ||\n\t\t    (extent.lower_first == (u32) -1))\n\t\t\tgoto out;\n\n\t\t/* Verify count is not zero and does not cause the\n\t\t * extent to wrap\n\t\t */\n\t\tif ((extent.first + extent.count) <= extent.first)\n\t\t\tgoto out;\n\t\tif ((extent.lower_first + extent.count) <=\n\t\t     extent.lower_first)\n\t\t\tgoto out;\n\n\t\t/* Do the ranges in extent overlap any previous extents? */\n\t\tif (mappings_overlap(&new_map, &extent))\n\t\t\tgoto out;\n\n\t\tif ((new_map.nr_extents + 1) == UID_GID_MAP_MAX_EXTENTS &&\n\t\t    (next_line != NULL))\n\t\t\tgoto out;\n\n\t\tret = insert_extent(&new_map, &extent);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = -EINVAL;\n\t}\n\t/* Be very certaint the new map actually exists */\n\tif (new_map.nr_extents == 0)\n\t\tgoto out;\n\n\tret = -EPERM;\n\t/* Validate the user is allowed to use user id's mapped to. */\n \tif (!new_idmap_permitted(file, ns, cap_setid, &new_map))\n \t\tgoto out;\n \n \tret = -EPERM;\n \t/* Map the lower ids from the parent user namespace to the\n \t * kernel global id space.\n\t */\n\tfor (idx = 0; idx < new_map.nr_extents; idx++) {\n\t\tstruct uid_gid_extent *e;\n\t\tu32 lower_first;\n\n\t\tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\t\te = &new_map.extent[idx];\n\t\telse\n\t\t\te = &new_map.forward[idx];\n\n\t\tlower_first = map_id_range_down(parent_map,\n\t\t\t\t\t\te->lower_first,\n\t\t\t\t\t\te->count);\n\n\t\t/* Fail if we can not map the specified extent to\n\t\t * the kernel global id space.\n\t\t */\n\t\tif (lower_first == (u32) -1)\n\t\t\tgoto out;\n\n \t\te->lower_first = lower_first;\n \t}\n \n\t/*\n\t * If we want to use binary search for lookup, this clones the extent\n\t * array and sorts both copies.\n\t */\n\tret = sort_idmaps(&new_map);\n\tif (ret < 0)\n\t\tgoto out;\n\n \t/* Install the map */\n \tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS) {\n \t\tmemcpy(map->extent, new_map.extent,\n\t\t       new_map.nr_extents * sizeof(new_map.extent[0]));\n\t} else {\n\t\tmap->forward = new_map.forward;\n\t\tmap->reverse = new_map.reverse;\n\t}\n\tsmp_wmb();\n\tmap->nr_extents = new_map.nr_extents;\n\n\t*ppos = count;\n\tret = count;\nout:\n\tif (ret < 0 && new_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\tkfree(new_map.forward);\n\t\tkfree(new_map.reverse);\n\t\tmap->forward = NULL;\n\t\tmap->reverse = NULL;\n\t\tmap->nr_extents = 0;\n\t}\n\n\tmutex_unlock(&userns_state_mutex);\n\tkfree(kbuf);\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142882,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadPICTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define ThrowPICTException(exception,message) \\\n{ \\\n  if (tile_image != (Image *) NULL) \\\n    tile_image=DestroyImage(tile_image); \\\n  if (read_info != (ImageInfo *) NULL) \\\n    read_info=DestroyImageInfo(read_info); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    geometry[MagickPathExtent],\n    header_ole[4];\n\n  Image\n    *image,\n    *tile_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    code;\n\n  MagickBooleanType\n    jpeg,\n    status;\n\n  PICTRectangle\n    frame;\n\n  PICTPixmap\n    pixmap;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    extent,\n    length;\n\n  ssize_t\n    count,\n    flags,\n    j,\n    version,\n    y;\n\n  StringInfo\n    *profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read PICT header.\n  */\n  read_info=(ImageInfo *) NULL;\n  tile_image=(Image *) NULL;\n  pixmap.bits_per_pixel=0;\n  pixmap.component_count=0;\n  /*\n    Skip header : 512 for standard PICT and 4, ie \"PICT\" for OLE2.\n  */\n  header_ole[0]=ReadBlobByte(image);\n  header_ole[1]=ReadBlobByte(image);\n  header_ole[2]=ReadBlobByte(image);\n  header_ole[3]=ReadBlobByte(image);\n  if (!((header_ole[0] == 0x50) && (header_ole[1] == 0x49) &&\n      (header_ole[2] == 0x43) && (header_ole[3] == 0x54 )))\n    for (i=0; i < 508; i++)\n      if (ReadBlobByte(image) == EOF)\n        break;\n  (void) ReadBlobMSBShort(image);  /* skip picture size */\n  if (ReadRectangle(image,&frame) == MagickFalse)\n    ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  while ((c=ReadBlobByte(image)) == 0) ;\n  if (c != 0x11)\n    ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  version=(ssize_t) ReadBlobByte(image);\n  if (version == 2)\n    {\n      c=ReadBlobByte(image);\n      if (c != 0xff)\n        ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  else\n    if (version != 1)\n      ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  if ((frame.left < 0) || (frame.right < 0) || (frame.top < 0) ||\n      (frame.bottom < 0) || (frame.left >= frame.right) ||\n      (frame.top >= frame.bottom))\n    ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Create black canvas.\n  */\n  flags=0;\n  image->depth=8;\n  image->columns=(size_t) (frame.right-frame.left);\n  image->rows=(size_t) (frame.bottom-frame.top);\n  image->resolution.x=DefaultResolution;\n  image->resolution.y=DefaultResolution;\n  image->units=UndefinedResolution;\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status != MagickFalse)\n    status=ResetImagePixels(image,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Interpret PICT opcodes.\n  */\n  jpeg=MagickFalse;\n  for (code=0; EOFBlob(image) == MagickFalse; )\n  {\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((version == 1) || ((TellBlob(image) % 2) != 0))\n      code=ReadBlobByte(image);\n    if (version == 2)\n      code=ReadBlobMSBSignedShort(image);\n    if (code < 0)\n      break;\n    if (code == 0)\n      continue;\n    if (code > 0xa1)\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%04X:\",code);\n      }\n    else\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  %04X %s: %s\",code,codes[code].name,codes[code].description);\n        switch (code)\n        {\n          case 0x01:\n          {\n            /*\n               Clipping rectangle.\n             */\n             length=ReadBlobMSBShort(image);\n             if (length != 0x000a)\n               {\n                 for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            if (((frame.left & 0x8000) != 0) || ((frame.top & 0x8000) != 0))\n              break;\n            image->columns=(size_t) (frame.right-frame.left);\n            image->rows=(size_t) (frame.bottom-frame.top);\n            status=SetImageExtent(image,image->columns,image->rows,exception);\n            if (status != MagickFalse)\n              status=ResetImagePixels(image,exception);\n            if (status == MagickFalse)\n              return(DestroyImageList(image));\n            break;\n          }\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          {\n            ssize_t\n              pattern;\n\n            size_t\n              height,\n              width;\n\n            /*\n              Skip pattern definition.\n            */\n            pattern=(ssize_t) ReadBlobMSBShort(image);\n            for (i=0; i < 8; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            if (pattern == 2)\n              {\n                for (i=0; i < 5; i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n             if (pattern != 1)\n               ThrowPICTException(CorruptImageError,\"UnknownPatternType\");\n             length=ReadBlobMSBShort(image);\n             if (ReadRectangle(image,&frame) == MagickFalse)\n               ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n             if (ReadPixmap(image,&pixmap) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            image->depth=(size_t) pixmap.component_size;\n            image->resolution.x=1.0*pixmap.horizontal_resolution;\n            image->resolution.y=1.0*pixmap.vertical_resolution;\n            image->units=PixelsPerInchResolution;\n             (void) ReadBlobMSBLong(image);\n             flags=(ssize_t) ReadBlobMSBShort(image);\n             length=ReadBlobMSBShort(image);\n             for (i=0; i <= (ssize_t) length; i++)\n               (void) ReadBlobMSBLong(image);\n             width=(size_t) (frame.bottom-frame.top);\n            height=(size_t) (frame.right-frame.left);\n            if (pixmap.bits_per_pixel <= 8)\n              length&=0x7fff;\n            if (pixmap.bits_per_pixel == 16)\n              width<<=1;\n            if (length == 0)\n              length=width;\n            if (length < 8)\n              {\n                for (i=0; i < (ssize_t) (length*height); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            else\n              for (i=0; i < (ssize_t) height; i++)\n              {\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                if (length > 200)\n                  {\n                    for (j=0; j < (ssize_t) ReadBlobMSBShort(image); j++)\n                      if (ReadBlobByte(image) == EOF)\n                        break;\n                  }\n                else\n                  for (j=0; j < (ssize_t) ReadBlobByte(image); j++)\n                    if (ReadBlobByte(image) == EOF)\n                      break;\n              }\n            break;\n          }\n          case 0x1b:\n          {\n            /*\n              Initialize image background color.\n            */\n            image->background_color.red=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.green=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.blue=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            break;\n          }\n          case 0x70:\n          case 0x71:\n          case 0x72:\n          case 0x73:\n          case 0x74:\n          case 0x75:\n          case 0x76:\n          case 0x77:\n          {\n            /*\n               Skip polygon or region.\n             */\n             length=ReadBlobMSBShort(image);\n             for (i=0; i < (ssize_t) (length-2); i++)\n               if (ReadBlobByte(image) == EOF)\n                 break;\n            break;\n          }\n          case 0x90:\n          case 0x91:\n          case 0x98:\n          case 0x99:\n          case 0x9a:\n          case 0x9b:\n          {\n            PICTRectangle\n              source,\n              destination;\n\n            register unsigned char\n              *p;\n\n            size_t\n              j;\n\n            ssize_t\n              bytes_per_line;\n\n            unsigned char\n              *pixels;\n\n            /*\n              Pixmap clipped by a rectangle.\n            */\n            bytes_per_line=0;\n            if ((code != 0x9a) && (code != 0x9b))\n              bytes_per_line=(ssize_t) ReadBlobMSBShort(image);\n            else\n              {\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            /*\n              Initialize tile image.\n            */\n            tile_image=CloneImage(image,(size_t) (frame.right-frame.left),\n              (size_t) (frame.bottom-frame.top),MagickTrue,exception);\n            if (tile_image == (Image *) NULL)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            if ((code == 0x9a) || (code == 0x9b) ||\n                ((bytes_per_line & 0x8000) != 0))\n              {\n                if (ReadPixmap(image,&pixmap) == MagickFalse)\n                  ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n                tile_image->depth=(size_t) pixmap.component_size;\n                tile_image->alpha_trait=pixmap.component_count == 4 ?\n                  BlendPixelTrait : UndefinedPixelTrait;\n                tile_image->resolution.x=(double) pixmap.horizontal_resolution;\n                tile_image->resolution.y=(double) pixmap.vertical_resolution;\n                tile_image->units=PixelsPerInchResolution;\n                if (tile_image->alpha_trait != UndefinedPixelTrait)\n                  (void) SetImageAlpha(tile_image,OpaqueAlpha,exception);\n              }\n            if ((code != 0x9a) && (code != 0x9b))\n              {\n                /*\n                  Initialize colormap.\n                */\n                tile_image->colors=2;\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    (void) ReadBlobMSBLong(image);\n                    flags=(ssize_t) ReadBlobMSBShort(image);\n                    tile_image->colors=1UL*ReadBlobMSBShort(image)+1;\n                  }\n                status=AcquireImageColormap(tile_image,tile_image->colors,\n                  exception);\n                if (status == MagickFalse)\n                  ThrowPICTException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      j=ReadBlobMSBShort(image) % tile_image->colors;\n                      if ((flags & 0x8000) != 0)\n                        j=(size_t) i;\n                      tile_image->colormap[j].red=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].green=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].blue=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                    }\n                  }\n                else\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      tile_image->colormap[i].red=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].red);\n                      tile_image->colormap[i].green=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].green);\n                      tile_image->colormap[i].blue=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].blue);\n                    }\n                  }\n              }\n            if (EOFBlob(image) != MagickFalse)\n              ThrowPICTException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            if (ReadRectangle(image,&source) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            if (ReadRectangle(image,&destination) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            (void) ReadBlobMSBShort(image);\n            if ((code == 0x91) || (code == 0x99) || (code == 0x9b))\n              {\n                /*\n                   Skip region.\n                 */\n                 length=ReadBlobMSBShort(image);\n                 for (i=0; i < (ssize_t) (length-2); i++)\n                   if (ReadBlobByte(image) == EOF)\n                     break;\n              }\n            if ((code != 0x9a) && (code != 0x9b) &&\n                (bytes_per_line & 0x8000) == 0)\n              pixels=DecodeImage(image,tile_image,(size_t) bytes_per_line,1,\n                &extent);\n            else\n              pixels=DecodeImage(image,tile_image,(size_t) bytes_per_line,\n                (unsigned int) pixmap.bits_per_pixel,&extent);\n            if (pixels == (unsigned char *) NULL)\n              ThrowPICTException(CorruptImageError,\"UnableToUncompressImage\");\n            /*\n              Convert PICT tile image to pixel packets.\n            */\n            p=pixels;\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              if (p > (pixels+extent+image->columns))\n                {\n                  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n                  ThrowPICTException(CorruptImageError,\"NotEnoughPixelData\");\n                }\n              q=QueueAuthenticPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                if (tile_image->storage_class == PseudoClass)\n                  {\n                    index=(Quantum) ConstrainColormapIndex(tile_image,(ssize_t)\n                      *p,exception);\n                    SetPixelIndex(tile_image,index,q);\n                    SetPixelRed(tile_image,\n                      tile_image->colormap[(ssize_t) index].red,q);\n                    SetPixelGreen(tile_image,\n                      tile_image->colormap[(ssize_t) index].green,q);\n                    SetPixelBlue(tile_image,\n                      tile_image->colormap[(ssize_t) index].blue,q);\n                  }\n                else\n                  {\n                    if (pixmap.bits_per_pixel == 16)\n                      {\n                        i=(ssize_t) (*p++);\n                        j=(size_t) (*p);\n                        SetPixelRed(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((i & 0x7c) << 1)),q);\n                        SetPixelGreen(tile_image,ScaleCharToQuantum(\n                          (unsigned char) (((i & 0x03) << 6) |\n                          ((j & 0xe0) >> 2))),q);\n                        SetPixelBlue(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((j & 0x1f) << 3)),q);\n                      }\n                    else\n                      if (tile_image->alpha_trait == UndefinedPixelTrait)\n                        {\n                          if (p > (pixels+extent+2*image->columns))\n                            ThrowPICTException(CorruptImageError,\n                              \"NotEnoughPixelData\");\n                          SetPixelRed(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                        }\n                      else\n                        {\n                          if (p > (pixels+extent+3*image->columns))\n                            ThrowPICTException(CorruptImageError,\n                              \"NotEnoughPixelData\");\n                          SetPixelAlpha(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelRed(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+3*tile_image->columns)),q);\n                        }\n                  }\n                p++;\n                q+=GetPixelChannels(tile_image);\n              }\n              if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n                break;\n              if ((tile_image->storage_class == DirectClass) &&\n                  (pixmap.bits_per_pixel != 16))\n                {\n                  p+=(pixmap.component_count-1)*tile_image->columns;\n                  if (p < pixels)\n                    break;\n                }\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                tile_image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            if ((jpeg == MagickFalse) && (EOFBlob(image) == MagickFalse))\n              if ((code == 0x9a) || (code == 0x9b) ||\n                  ((bytes_per_line & 0x8000) != 0))\n                (void) CompositeImage(image,tile_image,CopyCompositeOp,\n                  MagickTrue,(ssize_t) destination.left,(ssize_t)\n                  destination.top,exception);\n            tile_image=DestroyImage(tile_image);\n            break;\n          }\n          case 0xa1:\n          {\n            unsigned char\n              *info;\n\n            size_t\n              type;\n\n            /*\n              Comment.\n             */\n             type=ReadBlobMSBShort(image);\n             length=ReadBlobMSBShort(image);\n             if (length == 0)\n               break;\n             (void) ReadBlobMSBLong(image);\n            length-=MagickMin(length,4);\n            if (length == 0)\n              break;\n            info=(unsigned char *) AcquireQuantumMemory(length,sizeof(*info));\n            if (info == (unsigned char *) NULL)\n              break;\n            count=ReadBlob(image,length,info);\n            if (count != (ssize_t) length)\n              {\n                info=(unsigned char *) RelinquishMagickMemory(info);\n                ThrowPICTException(ResourceLimitError,\"UnableToReadImageData\");\n              }\n            switch (type)\n            {\n              case 0xe0:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"icc\",profile,exception);\n                profile=DestroyStringInfo(profile);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowPICTException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                break;\n              }\n              case 0x1f2:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"iptc\",profile,exception);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowPICTException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                profile=DestroyStringInfo(profile);\n                break;\n              }\n              default:\n                break;\n            }\n            info=(unsigned char *) RelinquishMagickMemory(info);\n            break;\n          }\n          default:\n          {\n            /*\n              Skip to next op code.\n            */\n            if (codes[code].length == -1)\n              (void) ReadBlobMSBShort(image);\n            else\n              for (i=0; i < (ssize_t) codes[code].length; i++)\n                if (ReadBlobByte(image) == EOF)\n                  break;\n          }\n        }\n      }\n    if (code == 0xc00)\n      {\n        /*\n          Skip header.\n        */\n        for (i=0; i < 24; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if (((code >= 0xb0) && (code <= 0xcf)) ||\n        ((code >= 0x8000) && (code <= 0x80ff)))\n      continue;\n    if (code == 0x8200)\n      {\n        char\n          filename[MaxTextExtent];\n\n        FILE\n          *file;\n\n        int\n          unique_file;\n\n        /*\n          Embedded JPEG.\n        */\n        jpeg=MagickTrue;\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(filename);\n        (void) FormatLocaleString(read_info->filename,MaxTextExtent,\"jpeg:%s\",\n          filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if ((unique_file == -1) || (file == (FILE *) NULL))\n          {\n            (void) RelinquishUniqueFileResource(read_info->filename);\n            (void) CopyMagickString(image->filename,read_info->filename,\n              MagickPathExtent);\n             ThrowPICTException(FileOpenError,\"UnableToCreateTemporaryFile\");\n           }\n         length=ReadBlobMSBLong(image);\n         if (length > 154)\n           {\n             for (i=0; i < 6; i++)\n              (void) ReadBlobMSBLong(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              {\n                (void) fclose(file);\n                (void) RelinquishUniqueFileResource(read_info->filename);\n                ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            for (i=0; i < 122; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            for (i=0; i < (ssize_t) (length-154); i++)\n            {\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              if (fputc(c,file) != c)\n                break;\n            }\n          }\n        (void) fclose(file);\n        (void) close(unique_file);\n        tile_image=ReadImage(read_info,exception);\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        if (tile_image == (Image *) NULL)\n          continue;\n        (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",\n          (double) MagickMax(image->columns,tile_image->columns),\n          (double) MagickMax(image->rows,tile_image->rows));\n        (void) SetImageExtent(image,\n          MagickMax(image->columns,tile_image->columns),\n          MagickMax(image->rows,tile_image->rows),exception);\n        (void) TransformImageColorspace(image,tile_image->colorspace,exception);\n        (void) CompositeImage(image,tile_image,CopyCompositeOp,MagickTrue,\n          (ssize_t) frame.left,(ssize_t) frame.right,exception);\n        image->compression=tile_image->compression;\n        tile_image=DestroyImage(tile_image);\n        continue;\n      }\n    if ((code == 0xff) || (code == 0xffff))\n      break;\n    if (((code >= 0xd0) && (code <= 0xfe)) ||\n        ((code >= 0x8100) && (code <= 0xffff)))\n      {\n        /*\n           Skip reserved.\n         */\n         length=ReadBlobMSBShort(image);\n         for (i=0; i < (ssize_t) length; i++)\n           if (ReadBlobByte(image) == EOF)\n             break;\n        continue;\n      }\n    if ((code >= 0x100) && (code <= 0x7fff))\n      {\n        /*\n           Skip reserved.\n         */\n         length=(size_t) ((code >> 7) & 0xff);\n         for (i=0; i < (ssize_t) length; i++)\n           if (ReadBlobByte(image) == EOF)\n             break;\n        continue;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142915,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadPICTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define ThrowPICTException(exception,message) \\\n{ \\\n  if (tile_image != (Image *) NULL) \\\n    tile_image=DestroyImage(tile_image); \\\n  if (read_info != (ImageInfo *) NULL) \\\n    read_info=DestroyImageInfo(read_info); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    geometry[MagickPathExtent],\n    header_ole[4];\n\n  Image\n    *image,\n    *tile_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    code;\n\n  MagickBooleanType\n    jpeg,\n    status;\n\n  PICTRectangle\n    frame;\n\n  PICTPixmap\n    pixmap;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    extent,\n    length;\n\n  ssize_t\n    count,\n    flags,\n    j,\n    version,\n    y;\n\n  StringInfo\n    *profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read PICT header.\n  */\n  read_info=(ImageInfo *) NULL;\n  tile_image=(Image *) NULL;\n  pixmap.bits_per_pixel=0;\n  pixmap.component_count=0;\n  /*\n    Skip header : 512 for standard PICT and 4, ie \"PICT\" for OLE2.\n  */\n  header_ole[0]=ReadBlobByte(image);\n  header_ole[1]=ReadBlobByte(image);\n  header_ole[2]=ReadBlobByte(image);\n  header_ole[3]=ReadBlobByte(image);\n  if (!((header_ole[0] == 0x50) && (header_ole[1] == 0x49) &&\n      (header_ole[2] == 0x43) && (header_ole[3] == 0x54 )))\n    for (i=0; i < 508; i++)\n      if (ReadBlobByte(image) == EOF)\n        break;\n  (void) ReadBlobMSBShort(image);  /* skip picture size */\n  if (ReadRectangle(image,&frame) == MagickFalse)\n    ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  while ((c=ReadBlobByte(image)) == 0) ;\n  if (c != 0x11)\n    ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  version=(ssize_t) ReadBlobByte(image);\n  if (version == 2)\n    {\n      c=ReadBlobByte(image);\n      if (c != 0xff)\n        ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  else\n    if (version != 1)\n      ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  if ((frame.left < 0) || (frame.right < 0) || (frame.top < 0) ||\n      (frame.bottom < 0) || (frame.left >= frame.right) ||\n      (frame.top >= frame.bottom))\n    ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Create black canvas.\n  */\n  flags=0;\n  image->depth=8;\n  image->columns=(size_t) (frame.right-frame.left);\n  image->rows=(size_t) (frame.bottom-frame.top);\n  image->resolution.x=DefaultResolution;\n  image->resolution.y=DefaultResolution;\n  image->units=UndefinedResolution;\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status != MagickFalse)\n    status=ResetImagePixels(image,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Interpret PICT opcodes.\n  */\n  jpeg=MagickFalse;\n  for (code=0; EOFBlob(image) == MagickFalse; )\n  {\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((version == 1) || ((TellBlob(image) % 2) != 0))\n      code=ReadBlobByte(image);\n    if (version == 2)\n      code=ReadBlobMSBSignedShort(image);\n    if (code < 0)\n      break;\n    if (code == 0)\n      continue;\n    if (code > 0xa1)\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%04X:\",code);\n      }\n    else\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  %04X %s: %s\",code,codes[code].name,codes[code].description);\n        switch (code)\n        {\n          case 0x01:\n          {\n            /*\n               Clipping rectangle.\n             */\n             length=ReadBlobMSBShort(image);\n            if (length > GetBlobSize(image))\n              ThrowPICTException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n             if (length != 0x000a)\n               {\n                 for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            if (((frame.left & 0x8000) != 0) || ((frame.top & 0x8000) != 0))\n              break;\n            image->columns=(size_t) (frame.right-frame.left);\n            image->rows=(size_t) (frame.bottom-frame.top);\n            status=SetImageExtent(image,image->columns,image->rows,exception);\n            if (status != MagickFalse)\n              status=ResetImagePixels(image,exception);\n            if (status == MagickFalse)\n              return(DestroyImageList(image));\n            break;\n          }\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          {\n            ssize_t\n              pattern;\n\n            size_t\n              height,\n              width;\n\n            /*\n              Skip pattern definition.\n            */\n            pattern=(ssize_t) ReadBlobMSBShort(image);\n            for (i=0; i < 8; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            if (pattern == 2)\n              {\n                for (i=0; i < 5; i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n             if (pattern != 1)\n               ThrowPICTException(CorruptImageError,\"UnknownPatternType\");\n             length=ReadBlobMSBShort(image);\n            if (length > GetBlobSize(image))\n              ThrowPICTException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n             if (ReadRectangle(image,&frame) == MagickFalse)\n               ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n             if (ReadPixmap(image,&pixmap) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            image->depth=(size_t) pixmap.component_size;\n            image->resolution.x=1.0*pixmap.horizontal_resolution;\n            image->resolution.y=1.0*pixmap.vertical_resolution;\n            image->units=PixelsPerInchResolution;\n             (void) ReadBlobMSBLong(image);\n             flags=(ssize_t) ReadBlobMSBShort(image);\n             length=ReadBlobMSBShort(image);\n            if (length > GetBlobSize(image))\n              ThrowPICTException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n             for (i=0; i <= (ssize_t) length; i++)\n               (void) ReadBlobMSBLong(image);\n             width=(size_t) (frame.bottom-frame.top);\n            height=(size_t) (frame.right-frame.left);\n            if (pixmap.bits_per_pixel <= 8)\n              length&=0x7fff;\n            if (pixmap.bits_per_pixel == 16)\n              width<<=1;\n            if (length == 0)\n              length=width;\n            if (length < 8)\n              {\n                for (i=0; i < (ssize_t) (length*height); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            else\n              for (i=0; i < (ssize_t) height; i++)\n              {\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                if (length > 200)\n                  {\n                    for (j=0; j < (ssize_t) ReadBlobMSBShort(image); j++)\n                      if (ReadBlobByte(image) == EOF)\n                        break;\n                  }\n                else\n                  for (j=0; j < (ssize_t) ReadBlobByte(image); j++)\n                    if (ReadBlobByte(image) == EOF)\n                      break;\n              }\n            break;\n          }\n          case 0x1b:\n          {\n            /*\n              Initialize image background color.\n            */\n            image->background_color.red=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.green=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.blue=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            break;\n          }\n          case 0x70:\n          case 0x71:\n          case 0x72:\n          case 0x73:\n          case 0x74:\n          case 0x75:\n          case 0x76:\n          case 0x77:\n          {\n            /*\n               Skip polygon or region.\n             */\n             length=ReadBlobMSBShort(image);\n            if (length > GetBlobSize(image))\n              ThrowPICTException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n             for (i=0; i < (ssize_t) (length-2); i++)\n               if (ReadBlobByte(image) == EOF)\n                 break;\n            break;\n          }\n          case 0x90:\n          case 0x91:\n          case 0x98:\n          case 0x99:\n          case 0x9a:\n          case 0x9b:\n          {\n            PICTRectangle\n              source,\n              destination;\n\n            register unsigned char\n              *p;\n\n            size_t\n              j;\n\n            ssize_t\n              bytes_per_line;\n\n            unsigned char\n              *pixels;\n\n            /*\n              Pixmap clipped by a rectangle.\n            */\n            bytes_per_line=0;\n            if ((code != 0x9a) && (code != 0x9b))\n              bytes_per_line=(ssize_t) ReadBlobMSBShort(image);\n            else\n              {\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            /*\n              Initialize tile image.\n            */\n            tile_image=CloneImage(image,(size_t) (frame.right-frame.left),\n              (size_t) (frame.bottom-frame.top),MagickTrue,exception);\n            if (tile_image == (Image *) NULL)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            if ((code == 0x9a) || (code == 0x9b) ||\n                ((bytes_per_line & 0x8000) != 0))\n              {\n                if (ReadPixmap(image,&pixmap) == MagickFalse)\n                  ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n                tile_image->depth=(size_t) pixmap.component_size;\n                tile_image->alpha_trait=pixmap.component_count == 4 ?\n                  BlendPixelTrait : UndefinedPixelTrait;\n                tile_image->resolution.x=(double) pixmap.horizontal_resolution;\n                tile_image->resolution.y=(double) pixmap.vertical_resolution;\n                tile_image->units=PixelsPerInchResolution;\n                if (tile_image->alpha_trait != UndefinedPixelTrait)\n                  (void) SetImageAlpha(tile_image,OpaqueAlpha,exception);\n              }\n            if ((code != 0x9a) && (code != 0x9b))\n              {\n                /*\n                  Initialize colormap.\n                */\n                tile_image->colors=2;\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    (void) ReadBlobMSBLong(image);\n                    flags=(ssize_t) ReadBlobMSBShort(image);\n                    tile_image->colors=1UL*ReadBlobMSBShort(image)+1;\n                  }\n                status=AcquireImageColormap(tile_image,tile_image->colors,\n                  exception);\n                if (status == MagickFalse)\n                  ThrowPICTException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      j=ReadBlobMSBShort(image) % tile_image->colors;\n                      if ((flags & 0x8000) != 0)\n                        j=(size_t) i;\n                      tile_image->colormap[j].red=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].green=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].blue=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                    }\n                  }\n                else\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      tile_image->colormap[i].red=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].red);\n                      tile_image->colormap[i].green=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].green);\n                      tile_image->colormap[i].blue=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].blue);\n                    }\n                  }\n              }\n            if (EOFBlob(image) != MagickFalse)\n              ThrowPICTException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            if (ReadRectangle(image,&source) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            if (ReadRectangle(image,&destination) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            (void) ReadBlobMSBShort(image);\n            if ((code == 0x91) || (code == 0x99) || (code == 0x9b))\n              {\n                /*\n                   Skip region.\n                 */\n                 length=ReadBlobMSBShort(image);\n                if (length > GetBlobSize(image))\n                  ThrowPICTException(CorruptImageError,\n                    \"InsufficientImageDataInFile\");\n                 for (i=0; i < (ssize_t) (length-2); i++)\n                   if (ReadBlobByte(image) == EOF)\n                     break;\n              }\n            if ((code != 0x9a) && (code != 0x9b) &&\n                (bytes_per_line & 0x8000) == 0)\n              pixels=DecodeImage(image,tile_image,(size_t) bytes_per_line,1,\n                &extent);\n            else\n              pixels=DecodeImage(image,tile_image,(size_t) bytes_per_line,\n                (unsigned int) pixmap.bits_per_pixel,&extent);\n            if (pixels == (unsigned char *) NULL)\n              ThrowPICTException(CorruptImageError,\"UnableToUncompressImage\");\n            /*\n              Convert PICT tile image to pixel packets.\n            */\n            p=pixels;\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              if (p > (pixels+extent+image->columns))\n                {\n                  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n                  ThrowPICTException(CorruptImageError,\"NotEnoughPixelData\");\n                }\n              q=QueueAuthenticPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                if (tile_image->storage_class == PseudoClass)\n                  {\n                    index=(Quantum) ConstrainColormapIndex(tile_image,(ssize_t)\n                      *p,exception);\n                    SetPixelIndex(tile_image,index,q);\n                    SetPixelRed(tile_image,\n                      tile_image->colormap[(ssize_t) index].red,q);\n                    SetPixelGreen(tile_image,\n                      tile_image->colormap[(ssize_t) index].green,q);\n                    SetPixelBlue(tile_image,\n                      tile_image->colormap[(ssize_t) index].blue,q);\n                  }\n                else\n                  {\n                    if (pixmap.bits_per_pixel == 16)\n                      {\n                        i=(ssize_t) (*p++);\n                        j=(size_t) (*p);\n                        SetPixelRed(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((i & 0x7c) << 1)),q);\n                        SetPixelGreen(tile_image,ScaleCharToQuantum(\n                          (unsigned char) (((i & 0x03) << 6) |\n                          ((j & 0xe0) >> 2))),q);\n                        SetPixelBlue(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((j & 0x1f) << 3)),q);\n                      }\n                    else\n                      if (tile_image->alpha_trait == UndefinedPixelTrait)\n                        {\n                          if (p > (pixels+extent+2*image->columns))\n                            ThrowPICTException(CorruptImageError,\n                              \"NotEnoughPixelData\");\n                          SetPixelRed(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                        }\n                      else\n                        {\n                          if (p > (pixels+extent+3*image->columns))\n                            ThrowPICTException(CorruptImageError,\n                              \"NotEnoughPixelData\");\n                          SetPixelAlpha(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelRed(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+3*tile_image->columns)),q);\n                        }\n                  }\n                p++;\n                q+=GetPixelChannels(tile_image);\n              }\n              if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n                break;\n              if ((tile_image->storage_class == DirectClass) &&\n                  (pixmap.bits_per_pixel != 16))\n                {\n                  p+=(pixmap.component_count-1)*tile_image->columns;\n                  if (p < pixels)\n                    break;\n                }\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                tile_image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            if ((jpeg == MagickFalse) && (EOFBlob(image) == MagickFalse))\n              if ((code == 0x9a) || (code == 0x9b) ||\n                  ((bytes_per_line & 0x8000) != 0))\n                (void) CompositeImage(image,tile_image,CopyCompositeOp,\n                  MagickTrue,(ssize_t) destination.left,(ssize_t)\n                  destination.top,exception);\n            tile_image=DestroyImage(tile_image);\n            break;\n          }\n          case 0xa1:\n          {\n            unsigned char\n              *info;\n\n            size_t\n              type;\n\n            /*\n              Comment.\n             */\n             type=ReadBlobMSBShort(image);\n             length=ReadBlobMSBShort(image);\n            if (length > GetBlobSize(image))\n              ThrowPICTException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n             if (length == 0)\n               break;\n             (void) ReadBlobMSBLong(image);\n            length-=MagickMin(length,4);\n            if (length == 0)\n              break;\n            info=(unsigned char *) AcquireQuantumMemory(length,sizeof(*info));\n            if (info == (unsigned char *) NULL)\n              break;\n            count=ReadBlob(image,length,info);\n            if (count != (ssize_t) length)\n              {\n                info=(unsigned char *) RelinquishMagickMemory(info);\n                ThrowPICTException(ResourceLimitError,\"UnableToReadImageData\");\n              }\n            switch (type)\n            {\n              case 0xe0:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"icc\",profile,exception);\n                profile=DestroyStringInfo(profile);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowPICTException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                break;\n              }\n              case 0x1f2:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"iptc\",profile,exception);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowPICTException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                profile=DestroyStringInfo(profile);\n                break;\n              }\n              default:\n                break;\n            }\n            info=(unsigned char *) RelinquishMagickMemory(info);\n            break;\n          }\n          default:\n          {\n            /*\n              Skip to next op code.\n            */\n            if (codes[code].length == -1)\n              (void) ReadBlobMSBShort(image);\n            else\n              for (i=0; i < (ssize_t) codes[code].length; i++)\n                if (ReadBlobByte(image) == EOF)\n                  break;\n          }\n        }\n      }\n    if (code == 0xc00)\n      {\n        /*\n          Skip header.\n        */\n        for (i=0; i < 24; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if (((code >= 0xb0) && (code <= 0xcf)) ||\n        ((code >= 0x8000) && (code <= 0x80ff)))\n      continue;\n    if (code == 0x8200)\n      {\n        char\n          filename[MaxTextExtent];\n\n        FILE\n          *file;\n\n        int\n          unique_file;\n\n        /*\n          Embedded JPEG.\n        */\n        jpeg=MagickTrue;\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(filename);\n        (void) FormatLocaleString(read_info->filename,MaxTextExtent,\"jpeg:%s\",\n          filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if ((unique_file == -1) || (file == (FILE *) NULL))\n          {\n            (void) RelinquishUniqueFileResource(read_info->filename);\n            (void) CopyMagickString(image->filename,read_info->filename,\n              MagickPathExtent);\n             ThrowPICTException(FileOpenError,\"UnableToCreateTemporaryFile\");\n           }\n         length=ReadBlobMSBLong(image);\n        if (length > GetBlobSize(image))\n          ThrowPICTException(CorruptImageError,\n            \"InsufficientImageDataInFile\");\n         if (length > 154)\n           {\n             for (i=0; i < 6; i++)\n              (void) ReadBlobMSBLong(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              {\n                (void) fclose(file);\n                (void) RelinquishUniqueFileResource(read_info->filename);\n                ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            for (i=0; i < 122; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            for (i=0; i < (ssize_t) (length-154); i++)\n            {\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              if (fputc(c,file) != c)\n                break;\n            }\n          }\n        (void) fclose(file);\n        (void) close(unique_file);\n        tile_image=ReadImage(read_info,exception);\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        if (tile_image == (Image *) NULL)\n          continue;\n        (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",\n          (double) MagickMax(image->columns,tile_image->columns),\n          (double) MagickMax(image->rows,tile_image->rows));\n        (void) SetImageExtent(image,\n          MagickMax(image->columns,tile_image->columns),\n          MagickMax(image->rows,tile_image->rows),exception);\n        (void) TransformImageColorspace(image,tile_image->colorspace,exception);\n        (void) CompositeImage(image,tile_image,CopyCompositeOp,MagickTrue,\n          (ssize_t) frame.left,(ssize_t) frame.right,exception);\n        image->compression=tile_image->compression;\n        tile_image=DestroyImage(tile_image);\n        continue;\n      }\n    if ((code == 0xff) || (code == 0xffff))\n      break;\n    if (((code >= 0xd0) && (code <= 0xfe)) ||\n        ((code >= 0x8100) && (code <= 0xffff)))\n      {\n        /*\n           Skip reserved.\n         */\n         length=ReadBlobMSBShort(image);\n        if (length > GetBlobSize(image))\n          ThrowPICTException(CorruptImageError,\n            \"InsufficientImageDataInFile\");\n         for (i=0; i < (ssize_t) length; i++)\n           if (ReadBlobByte(image) == EOF)\n             break;\n        continue;\n      }\n    if ((code >= 0x100) && (code <= 0x7fff))\n      {\n        /*\n           Skip reserved.\n         */\n         length=(size_t) ((code >> 7) & 0xff);\n        if (length > GetBlobSize(image))\n          ThrowPICTException(CorruptImageError,\n            \"InsufficientImageDataInFile\");\n         for (i=0; i < (ssize_t) length; i++)\n           if (ReadBlobByte(image) == EOF)\n             break;\n        continue;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142916,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadCALSImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    header[MagickPathExtent],\n    message[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  unsigned long\n    density,\n    direction,\n    height,\n    orientation,\n    pel_path,\n    type,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read CALS header.\n  */\n  (void) memset(header,0,sizeof(header));\n  density=0;\n  direction=0;\n  orientation=1;\n  pel_path=0;\n  type=1;\n  width=0;\n  height=0;\n  for (i=0; i < 16; i++)\n  {\n    if (ReadBlob(image,128,(unsigned char *) header) != 128)\n      break;\n    switch (*header)\n    {\n      case 'R':\n      case 'r':\n      {\n        if (LocaleNCompare(header,\"rdensty:\",8) == 0)\n          {\n            (void) sscanf(header+8,\"%lu\",&density);\n            break;\n          }\n        if (LocaleNCompare(header,\"rpelcnt:\",8) == 0)\n          {\n            (void) sscanf(header+8,\"%lu,%lu\",&width,&height);\n            break;\n          }\n        if (LocaleNCompare(header,\"rorient:\",8) == 0)\n          {\n            (void) sscanf(header+8,\"%lu,%lu\",&pel_path,&direction);\n            if (pel_path == 90)\n              orientation=5;\n            else\n              if (pel_path == 180)\n                orientation=3;\n              else\n                if (pel_path == 270)\n                  orientation=7;\n            if (direction == 90)\n              orientation++;\n            break;\n          }\n        if (LocaleNCompare(header,\"rtype:\",6) == 0)\n          {\n            (void) sscanf(header+6,\"%lu\",&type);\n            break;\n          }\n        break;\n      }\n    }\n  }\n  /*\n    Read CALS pixels.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n   if ((unique_file == -1) || (file == (FILE *) NULL))\n     ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n   while ((c=ReadBlobByte(image)) != EOF)\n    (void) fputc(c,file);\n   (void) fclose(file);\n   (void) CloseBlob(image);\n   image=DestroyImage(image);\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"group4:%s\",\n    filename);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%lux%lu\",width,height);\n  (void) CloneString(&read_info->size,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%lu\",density);\n  (void) CloneString(&read_info->density,message);\n  read_info->orientation=(OrientationType) orientation;\n  image=ReadImage(read_info,exception);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick,\"CALS\",MagickPathExtent);\n    }\n  read_info=DestroyImageInfo(read_info);\n  (void) RelinquishUniqueFileResource(filename);\n  return(image);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142917,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadCALSImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    header[MagickPathExtent],\n    message[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  unsigned long\n    density,\n    direction,\n    height,\n    orientation,\n    pel_path,\n    type,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read CALS header.\n  */\n  (void) memset(header,0,sizeof(header));\n  density=0;\n  direction=0;\n  orientation=1;\n  pel_path=0;\n  type=1;\n  width=0;\n  height=0;\n  for (i=0; i < 16; i++)\n  {\n    if (ReadBlob(image,128,(unsigned char *) header) != 128)\n      break;\n    switch (*header)\n    {\n      case 'R':\n      case 'r':\n      {\n        if (LocaleNCompare(header,\"rdensty:\",8) == 0)\n          {\n            (void) sscanf(header+8,\"%lu\",&density);\n            break;\n          }\n        if (LocaleNCompare(header,\"rpelcnt:\",8) == 0)\n          {\n            (void) sscanf(header+8,\"%lu,%lu\",&width,&height);\n            break;\n          }\n        if (LocaleNCompare(header,\"rorient:\",8) == 0)\n          {\n            (void) sscanf(header+8,\"%lu,%lu\",&pel_path,&direction);\n            if (pel_path == 90)\n              orientation=5;\n            else\n              if (pel_path == 180)\n                orientation=3;\n              else\n                if (pel_path == 270)\n                  orientation=7;\n            if (direction == 90)\n              orientation++;\n            break;\n          }\n        if (LocaleNCompare(header,\"rtype:\",6) == 0)\n          {\n            (void) sscanf(header+6,\"%lu\",&type);\n            break;\n          }\n        break;\n      }\n    }\n  }\n  /*\n    Read CALS pixels.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n   if ((unique_file == -1) || (file == (FILE *) NULL))\n     ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n   while ((c=ReadBlobByte(image)) != EOF)\n    if (fputc(c,file) != c)\n      break;\n   (void) fclose(file);\n   (void) CloseBlob(image);\n   image=DestroyImage(image);\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"group4:%s\",\n    filename);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%lux%lu\",width,height);\n  (void) CloneString(&read_info->size,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%lu\",density);\n  (void) CloneString(&read_info->density,message);\n  read_info->orientation=(OrientationType) orientation;\n  image=ReadImage(read_info,exception);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick,\"CALS\",MagickPathExtent);\n    }\n  read_info=DestroyImageInfo(read_info);\n  (void) RelinquishUniqueFileResource(filename);\n  return(image);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142918,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowDCMException(exception,message) \\\n{ \\\n  if (info.scale != (Quantum *) NULL) \\\n    info.scale=(Quantum *) RelinquishMagickMemory(info.scale); \\\n  if (data != (unsigned char *) NULL) \\\n    data=(unsigned char *) RelinquishMagickMemory(data); \\\n  if (graymap != (int *) NULL) \\\n    graymap=(int *) RelinquishMagickMemory(graymap); \\\n  if (bluemap != (int *) NULL) \\\n    bluemap=(int *) RelinquishMagickMemory(bluemap); \\\n  if (greenmap != (int *) NULL) \\\n    greenmap=(int *) RelinquishMagickMemory(greenmap); \\\n  if (redmap != (int *) NULL) \\\n    redmap=(int *) RelinquishMagickMemory(redmap); \\\n  if (stream_info->offsets != (ssize_t *) NULL) \\\n    stream_info->offsets=(ssize_t *) RelinquishMagickMemory( \\\n      stream_info->offsets); \\\n  if (stream_info != (DCMStreamInfo *) NULL) \\\n    stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    explicit_vr[MagickPathExtent],\n    implicit_vr[MagickPathExtent],\n    magick[MagickPathExtent],\n    photometric[MagickPathExtent];\n\n  DCMInfo\n    info;\n\n  DCMStreamInfo\n    *stream_info;\n\n  Image\n    *image;\n\n  int\n    *bluemap,\n    datum,\n    *greenmap,\n    *graymap,\n    *redmap;\n\n  MagickBooleanType\n    explicit_file,\n    explicit_retry,\n    use_explicit;\n\n  MagickOffsetType\n    offset;\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    colors,\n    height,\n    length,\n    number_scenes,\n    quantum,\n    status,\n    width;\n\n  ssize_t\n    count,\n    scene;\n\n  unsigned char\n    *data;\n\n  unsigned short\n    group,\n    element;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=8UL;\n  image->endian=LSBEndian;\n  /*\n    Read DCM preamble.\n  */\n  (void) memset(&info,0,sizeof(info));\n  data=(unsigned char *) NULL;\n  graymap=(int *) NULL;\n  redmap=(int *) NULL;\n  greenmap=(int *) NULL;\n  bluemap=(int *) NULL;\n  stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));\n  if (stream_info == (DCMStreamInfo *) NULL)\n    ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memset(stream_info,0,sizeof(*stream_info));\n  count=ReadBlob(image,128,(unsigned char *) magick);\n  if (count != 128)\n    ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  if ((count != 4) || (LocaleNCompare(magick,\"DICM\",4) != 0))\n    {\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  /*\n    Read DCM Medical image.\n  */\n  (void) CopyMagickString(photometric,\"MONOCHROME1 \",MagickPathExtent);\n  info.bits_allocated=8;\n  info.bytes_per_pixel=1;\n  info.depth=8;\n  info.mask=0xffff;\n  info.max_value=255UL;\n  info.samples_per_pixel=1;\n  info.signed_data=(~0UL);\n  info.rescale_slope=1.0;\n  data=(unsigned char *) NULL;\n  element=0;\n  explicit_vr[2]='\\0';\n  explicit_file=MagickFalse;\n  colors=0;\n  redmap=(int *) NULL;\n  greenmap=(int *) NULL;\n  bluemap=(int *) NULL;\n  graymap=(int *) NULL;\n  height=0;\n  number_scenes=1;\n  use_explicit=MagickFalse;\n  explicit_retry = MagickFalse;\n  width=0;\n  while (TellBlob(image) < (MagickOffsetType) GetBlobSize(image))\n  {\n    for (group=0; (group != 0x7FE0) || (element != 0x0010) ; )\n    {\n      /*\n        Read a group.\n      */\n      image->offset=(ssize_t) TellBlob(image);\n      group=ReadBlobLSBShort(image);\n      element=ReadBlobLSBShort(image);\n      if ((group == 0xfffc) && (element == 0xfffc))\n        break;\n      if ((group != 0x0002) && (image->endian == MSBEndian))\n        {\n          group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));\n          element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));\n        }\n      quantum=0;\n      /*\n        Find corresponding VR for this group and element.\n      */\n      for (i=0; dicom_info[i].group < 0xffff; i++)\n        if ((group == dicom_info[i].group) &&\n            (element == dicom_info[i].element))\n          break;\n      (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);\n      count=ReadBlob(image,2,(unsigned char *) explicit_vr);\n      if (count != 2)\n        ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n      /*\n        Check for \"explicitness\", but meta-file headers always explicit.\n      */\n      if ((explicit_file == MagickFalse) && (group != 0x0002))\n        explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&\n          (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?\n          MagickTrue : MagickFalse;\n      use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||\n        (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;\n      if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,\"xs\",2) == 0))\n        (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);\n      if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,\"!!\",2) == 0))\n        {\n          offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);\n          if (offset < 0)\n            ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n          quantum=4;\n        }\n      else\n        {\n          /*\n            Assume explicit type.\n          */\n          quantum=2;\n          if ((strncmp(explicit_vr,\"OB\",2) == 0) ||\n              (strncmp(explicit_vr,\"UN\",2) == 0) ||\n              (strncmp(explicit_vr,\"OW\",2) == 0) ||\n              (strncmp(explicit_vr,\"SQ\",2) == 0))\n            {\n              (void) ReadBlobLSBShort(image);\n              quantum=4;\n            }\n        }\n      datum=0;\n      if (quantum == 4)\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedLong(image);\n          else\n            datum=ReadBlobSignedLong(image);\n        }\n      else\n        if (quantum == 2)\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedShort(image);\n            else\n              datum=ReadBlobSignedShort(image);\n          }\n      quantum=0;\n      length=1;\n      if (datum != 0)\n        {\n          if ((strncmp(implicit_vr,\"OW\",2) == 0) ||\n               (strncmp(implicit_vr,\"SS\",2) == 0) ||\n               (strncmp(implicit_vr,\"US\",2) == 0))\n             quantum=2;\n          else \n             if ((strncmp(implicit_vr,\"FL\",2) == 0) ||\n                 (strncmp(implicit_vr,\"OF\",2) == 0) ||\n                 (strncmp(implicit_vr,\"SL\",2) == 0) ||\n                 (strncmp(implicit_vr,\"UL\",2) == 0))\n               quantum=4;\n            else \n               if (strncmp(implicit_vr,\"FD\",2) == 0)\n                 quantum=8;\n               else\n                quantum=1;\n          if (datum != ~0)\n            length=(size_t) datum/quantum;\n          else\n            {\n              /*\n                Sequence and item of undefined length.\n              */\n              quantum=0;\n              length=0;\n            }\n        }\n      if (image_info->verbose != MagickFalse)\n        {\n          /*\n            Display Dicom info.\n          */\n          if (use_explicit == MagickFalse)\n            explicit_vr[0]='\\0';\n          for (i=0; dicom_info[i].description != (char *) NULL; i++)\n            if ((group == dicom_info[i].group) &&\n                (element == dicom_info[i].element))\n              break;\n          (void) FormatLocaleFile(stdout,\"0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)\",\n            (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,\n            (unsigned long) group,(unsigned long) element);\n          if (dicom_info[i].description != (char *) NULL)\n            (void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);\n          (void) FormatLocaleFile(stdout,\": \");\n        }\n      if ((group == 0x7FE0) && (element == 0x0010))\n        {\n          if (image_info->verbose != MagickFalse)\n            (void) FormatLocaleFile(stdout,\"\\n\");\n          break;\n        }\n      /*\n        Allocate space and read an array.\n      */\n      data=(unsigned char *) NULL;\n      if ((length == 1) && (quantum == 1))\n        datum=ReadBlobByte(image);\n      else\n        if ((length == 1) && (quantum == 2))\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedShort(image);\n            else\n              datum=ReadBlobSignedShort(image);\n          }\n        else\n          if ((length == 1) && (quantum == 4))\n            {\n              if (group == 0x0002)\n                datum=ReadBlobLSBSignedLong(image);\n              else\n                datum=ReadBlobSignedLong(image);\n            }\n          else\n            if ((quantum != 0) && (length != 0))\n              {\n                if (length > (size_t) GetBlobSize(image))\n                  ThrowDCMException(CorruptImageError,\n                    \"InsufficientImageDataInFile\");\n                if (~length >= 1)\n                  data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*\n                    sizeof(*data));\n                if (data == (unsigned char *) NULL)\n                  ThrowDCMException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n                count=ReadBlob(image,(size_t) quantum*length,data);\n                if (count != (ssize_t) (quantum*length))\n                  {\n                    if (image_info->verbose != MagickFalse)\n                      (void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"\n                        \"length=%d group=%d\\n\",(int) count,(int) quantum,(int)\n                        length,(int) group);\n                     ThrowDCMException(CorruptImageError,\n                       \"InsufficientImageDataInFile\");\n                  }\n                data[length*quantum]='\\0';\n              }\n      if ((((unsigned int) group << 16) | element) == 0xFFFEE0DD)\n        {\n          if (data != (unsigned char *) NULL)\n            data=(unsigned char *) RelinquishMagickMemory(data);\n          continue;\n        }\n      switch (group)\n      {\n        case 0x0002:\n        {\n          switch (element)\n          {\n            case 0x0010:\n            {\n              char\n                transfer_syntax[MagickPathExtent];\n\n              /*\n                Transfer Syntax.\n              */\n              if ((datum == 0) && (explicit_retry == MagickFalse))\n                {\n                  explicit_retry=MagickTrue;\n                  (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);\n                  group=0;\n                  element=0;\n                  if (image_info->verbose != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\n                      \"Corrupted image - trying explicit format\\n\");\n                  break;\n                }\n              *transfer_syntax='\\0';\n              if (data != (unsigned char *) NULL)\n                (void) CopyMagickString(transfer_syntax,(char *) data,\n                  MagickPathExtent);\n              if (image_info->verbose != MagickFalse)\n                (void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",\n                  (const char *) transfer_syntax);\n              if (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)\n                {\n                  int\n                    subtype,\n                    type;\n\n                  type=1;\n                  subtype=0;\n                  if (strlen(transfer_syntax) > 17)\n                    {\n                      count=(ssize_t) sscanf(transfer_syntax+17,\".%d.%d\",&type,\n                        &subtype);\n                      if (count < 1)\n                        ThrowDCMException(CorruptImageError,\n                          \"ImproperImageHeader\");\n                    }\n                  switch (type)\n                  {\n                    case 1:\n                    {\n                      image->endian=LSBEndian;\n                      break;\n                    }\n                    case 2:\n                    {\n                      image->endian=MSBEndian;\n                      break;\n                    }\n                    case 4:\n                    {\n                      if ((subtype >= 80) && (subtype <= 81))\n                        image->compression=JPEGCompression;\n                      else\n                        if ((subtype >= 90) && (subtype <= 93))\n                          image->compression=JPEG2000Compression;\n                        else\n                          image->compression=JPEGCompression;\n                      break;\n                    }\n                    case 5:\n                    {\n                      image->compression=RLECompression;\n                      break;\n                    }\n                  }\n                }\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        case 0x0028:\n        {\n          switch (element)\n          {\n            case 0x0002:\n            {\n              /*\n                Samples per pixel.\n              */\n              info.samples_per_pixel=(size_t) datum;\n              if ((info.samples_per_pixel == 0) || (info.samples_per_pixel > 4))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n              break;\n            }\n            case 0x0004:\n            {\n              /*\n                Photometric interpretation.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)\n                photometric[i]=(char) data[i];\n              photometric[i]='\\0';\n              info.polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?\n                MagickTrue : MagickFalse;\n              break;\n            }\n            case 0x0006:\n            {\n              /*\n                Planar configuration.\n              */\n              if (datum == 1)\n                image->interlace=PlaneInterlace;\n              break;\n            }\n            case 0x0008:\n            {\n              /*\n                Number of frames.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              number_scenes=StringToUnsignedLong((char *) data);\n              break;\n            }\n            case 0x0010:\n            {\n              /*\n                Image rows.\n              */\n              height=(size_t) datum;\n              break;\n            }\n            case 0x0011:\n            {\n              /*\n                Image columns.\n              */\n              width=(size_t) datum;\n              break;\n            }\n            case 0x0100:\n            {\n              /*\n                Bits allocated.\n              */\n              info.bits_allocated=(size_t) datum;\n              info.bytes_per_pixel=1;\n              if (datum > 8)\n                info.bytes_per_pixel=2;\n              info.depth=info.bits_allocated;\n              if ((info.depth == 0) || (info.depth > 32))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n              info.max_value=(1UL << info.bits_allocated)-1;\n              image->depth=info.depth;\n              break;\n            }\n            case 0x0101:\n            {\n              /*\n                Bits stored.\n              */\n              info.significant_bits=(size_t) datum;\n              info.bytes_per_pixel=1;\n              if (info.significant_bits > 8)\n                info.bytes_per_pixel=2;\n              info.depth=info.significant_bits;\n              if ((info.depth == 0) || (info.depth > 16))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n              info.max_value=(1UL << info.significant_bits)-1;\n              info.mask=(size_t) GetQuantumRange(info.significant_bits);\n              image->depth=info.depth;\n              break;\n            }\n            case 0x0102:\n            {\n              /*\n                High bit.\n              */\n              break;\n            }\n            case 0x0103:\n            {\n              /*\n                Pixel representation.\n              */\n              info.signed_data=(size_t) datum;\n              break;\n            }\n            case 0x1050:\n            {\n              /*\n                Visible pixel range: center.\n              */\n              if (data != (unsigned char *) NULL)\n                info.window_center=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1051:\n            {\n              /*\n                Visible pixel range: width.\n              */\n              if (data != (unsigned char *) NULL)\n                info.window_width=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1052:\n            {\n              /*\n                Rescale intercept\n              */\n              if (data != (unsigned char *) NULL)\n                info.rescale_intercept=StringToDouble((char *) data,\n                  (char **) NULL);\n              break;\n            }\n            case 0x1053:\n            {\n              /*\n                Rescale slope\n              */\n              if (data != (unsigned char *) NULL)\n                info.rescale_slope=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1200:\n            case 0x3006:\n            {\n              /*\n                Populate graymap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/info.bytes_per_pixel);\n              datum=(int) colors;\n              if (graymap != (int *) NULL)\n                graymap=(int *) RelinquishMagickMemory(graymap);\n              graymap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*graymap));\n              if (graymap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(graymap,0,MagickMax(colors,65536)*\n                sizeof(*graymap));\n              for (i=0; i < (ssize_t) colors; i++)\n                if (info.bytes_per_pixel == 1)\n                  graymap[i]=(int) data[i];\n                else\n                  graymap[i]=(int) ((short *) data)[i];\n              break;\n            }\n            case 0x1201:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate redmap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/2);\n              datum=(int) colors;\n              if (redmap != (int *) NULL)\n                redmap=(int *) RelinquishMagickMemory(redmap);\n              redmap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*redmap));\n              if (redmap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(redmap,0,MagickMax(colors,65536)*\n                sizeof(*redmap));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                redmap[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            case 0x1202:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate greenmap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/2);\n              datum=(int) colors;\n              if (greenmap != (int *) NULL)\n                greenmap=(int *) RelinquishMagickMemory(greenmap);\n              greenmap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*greenmap));\n              if (greenmap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(greenmap,0,MagickMax(colors,65536)*\n                sizeof(*greenmap));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                greenmap[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            case 0x1203:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate bluemap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/2);\n              datum=(int) colors;\n              if (bluemap != (int *) NULL)\n                bluemap=(int *) RelinquishMagickMemory(bluemap);\n              bluemap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*bluemap));\n              if (bluemap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(bluemap,0,MagickMax(colors,65536)*\n                sizeof(*bluemap));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                bluemap[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        case 0x2050:\n        {\n          switch (element)\n          {\n            case 0x0020:\n            {\n              if ((data != (unsigned char *) NULL) &&\n                  (strncmp((char *) data,\"INVERSE\",7) == 0))\n                info.polarity=MagickTrue;\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        default:\n          break;\n      }\n      if (data != (unsigned char *) NULL)\n        {\n          char\n            *attribute;\n\n          for (i=0; dicom_info[i].description != (char *) NULL; i++)\n            if ((group == dicom_info[i].group) &&\n                (element == dicom_info[i].element))\n              break;\n          if (dicom_info[i].description != (char *) NULL)\n            {\n              attribute=AcquireString(\"dcm:\");\n              (void) ConcatenateString(&attribute,dicom_info[i].description);\n              for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n                if (isprint((int) data[i]) == MagickFalse)\n                  break;\n              if ((i == (ssize_t) length) || (length > 4))\n                {\n                  (void) SubstituteString(&attribute,\" \",\"\");\n                  (void) SetImageProperty(image,attribute,(char *) data,\n                    exception);\n                }\n              attribute=DestroyString(attribute);\n            }\n        }\n      if (image_info->verbose != MagickFalse)\n        {\n          if (data == (unsigned char *) NULL)\n            (void) FormatLocaleFile(stdout,\"%d\\n\",datum);\n          else\n            {\n              /*\n                Display group data.\n              */\n              for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n                if (isprint((int) data[i]) == MagickFalse)\n                  break;\n              if ((i != (ssize_t) length) && (length <= 4))\n                {\n                  ssize_t\n                    j;\n\n                  datum=0;\n                  for (j=(ssize_t) length-1; j >= 0; j--)\n                    datum=(256*datum+data[j]);\n                  (void) FormatLocaleFile(stdout,\"%d\",datum);\n                }\n              else\n                for (i=0; i < (ssize_t) length; i++)\n                  if (isprint((int) data[i]) != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\"%c\",data[i]);\n                  else\n                    (void) FormatLocaleFile(stdout,\"%c\",'.');\n              (void) FormatLocaleFile(stdout,\"\\n\");\n            }\n        }\n      if (data != (unsigned char *) NULL)\n        data=(unsigned char *) RelinquishMagickMemory(data);\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n    }\n    if ((group == 0xfffc) && (element == 0xfffc))\n      {\n        Image\n          *last;\n\n        last=RemoveLastImageFromList(&image);\n        if (last != (Image *) NULL)\n          last=DestroyImage(last);\n        break;\n      }\n    if ((width == 0) || (height == 0))\n      ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    if (info.signed_data == 0xffff)\n      info.signed_data=(size_t) (info.significant_bits == 16 ? 1 : 0);\n    if ((image->compression == JPEGCompression) ||\n        (image->compression == JPEG2000Compression))\n      {\n        Image\n          *images;\n\n        ImageInfo\n          *read_info;\n\n        int\n          c;\n\n        /*\n          Read offset table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        (void) (((ssize_t) ReadBlobLSBShort(image) << 16) |\n          ReadBlobLSBShort(image));\n        length=(size_t) ReadBlobLSBLong(image);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\n        stream_info->offset_count=length >> 2;\n        if (stream_info->offset_count != 0)\n          {\n            if (stream_info->offsets != (ssize_t *) NULL)\n              stream_info->offsets=(ssize_t *) RelinquishMagickMemory(\n                stream_info->offsets);\n            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n              stream_info->offset_count,sizeof(*stream_info->offsets));\n            if (stream_info->offsets == (ssize_t *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n            offset=TellBlob(image);\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]+=offset;\n          }\n        /*\n          Handle non-native image formats.\n        */\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        images=NewImageList();\n        for (scene=0; scene < (ssize_t) number_scenes; scene++)\n        {\n          char\n            filename[MagickPathExtent];\n\n          const char\n            *property;\n\n          FILE\n            *file;\n\n          Image\n            *jpeg_image;\n\n          int\n            unique_file;\n\n          unsigned int\n            tag;\n\n          tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n            ReadBlobLSBShort(image);\n          length=(size_t) ReadBlobLSBLong(image);\n          if (tag == 0xFFFEE0DD)\n            break; /* sequence delimiter tag */\n          if (tag != 0xFFFEE000)\n            {\n              read_info=DestroyImageInfo(read_info);\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n            }\n          file=(FILE *) NULL;\n          unique_file=AcquireUniqueFileResource(filename);\n          if (unique_file != -1)\n            file=fdopen(unique_file,\"wb\");\n          if (file == (FILE *) NULL)\n            {\n              (void) RelinquishUniqueFileResource(filename);\n              ThrowFileException(exception,FileOpenError,\n                \"UnableToCreateTemporaryFile\",filename);\n              break;\n            }\n          for (c=EOF; length != 0; length--)\n          {\n            c=ReadBlobByte(image);\n            if (c == EOF)\n              {\n                ThrowFileException(exception,CorruptImageError,\n                   \"UnexpectedEndOfFile\",image->filename);\n                 break;\n               }\n            (void) fputc(c,file);\n           }\n           (void) fclose(file);\n           if (c == EOF)\n            break;\n          (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n            \"jpeg:%s\",filename);\n          if (image->compression == JPEG2000Compression)\n            (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n              \"j2k:%s\",filename);\n          jpeg_image=ReadImage(read_info,exception);\n          if (jpeg_image != (Image *) NULL)\n            {\n              ResetImagePropertyIterator(image);\n              property=GetNextImageProperty(image);\n              while (property != (const char *) NULL)\n              {\n                (void) SetImageProperty(jpeg_image,property,\n                  GetImageProperty(image,property,exception),exception);\n                property=GetNextImageProperty(image);\n              }\n              AppendImageToList(&images,jpeg_image);\n            }\n          (void) RelinquishUniqueFileResource(filename);\n        }\n        read_info=DestroyImageInfo(read_info);\n        if (stream_info->offsets != (ssize_t *) NULL)\n          stream_info->offsets=(ssize_t *)\n            RelinquishMagickMemory(stream_info->offsets);\n        stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n        if (info.scale != (Quantum *) NULL)\n          info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n        if (graymap != (int *) NULL)\n          graymap=(int *) RelinquishMagickMemory(graymap);\n        if (bluemap != (int *) NULL)\n          bluemap=(int *) RelinquishMagickMemory(bluemap);\n        if (greenmap != (int *) NULL)\n          greenmap=(int *) RelinquishMagickMemory(greenmap);\n        if (redmap != (int *) NULL)\n          redmap=(int *) RelinquishMagickMemory(redmap);\n        image=DestroyImageList(image);\n        return(GetFirstImageInList(images));\n      }\n    if (info.depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))\n      {\n        QuantumAny\n          range;\n\n        /*\n          Compute pixel scaling table.\n        */\n         length=(size_t) (GetQuantumRange(info.depth)+1);\n         if (length > (size_t) GetBlobSize(image))\n           ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\n        if (info.scale != (Quantum *) NULL) \n           info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n         info.scale=(Quantum *) AcquireQuantumMemory(MagickMax(length,256),\n           sizeof(*info.scale));\n        if (info.scale == (Quantum *) NULL)\n          ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(info.scale,0,MagickMax(length,256)*\n          sizeof(*info.scale));\n        range=GetQuantumRange(info.depth);\n        for (i=0; i <= (ssize_t) GetQuantumRange(info.depth); i++)\n          info.scale[i]=ScaleAnyToQuantum((size_t) i,range);\n      }\n    if (image->compression == RLECompression)\n      {\n        unsigned int\n          tag;\n\n        /*\n          Read RLE offset table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n        }\n        tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n          ReadBlobLSBShort(image);\n        (void) tag;\n        length=(size_t) ReadBlobLSBLong(image);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\n        stream_info->offset_count=length >> 2;\n        if (stream_info->offset_count != 0)\n          {\n            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n              stream_info->offset_count,sizeof(*stream_info->offsets));\n            if (stream_info->offsets == (ssize_t *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            {\n              stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n              if (EOFBlob(image) != MagickFalse)\n                break;\n            }\n            offset=TellBlob(image)+8;\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]+=offset;\n          }\n      }\n    for (scene=0; scene < (ssize_t) number_scenes; scene++)\n    {\n      if (image_info->ping != MagickFalse)\n        break;\n      image->columns=(size_t) width;\n      image->rows=(size_t) height;\n      image->depth=info.depth;\n      status=SetImageExtent(image,image->columns,image->rows,exception);\n      if (status == MagickFalse)\n        break;\n      image->colorspace=RGBColorspace;\n      (void) SetImageBackgroundColor(image,exception);\n      if ((image->colormap == (PixelInfo *) NULL) &&\n          (info.samples_per_pixel == 1))\n        {\n          int\n            index;\n\n          size_t\n            one;\n\n          one=1;\n          if (colors == 0)\n            colors=one << info.depth;\n          if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n            ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n          if (redmap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=redmap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].red=(MagickRealType) index;\n            }\n          if (greenmap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=greenmap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].green=(MagickRealType) index;\n            }\n          if (bluemap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=bluemap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].blue=(MagickRealType) index;\n            }\n          if (graymap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=graymap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].red=(MagickRealType) index;\n              image->colormap[i].green=(MagickRealType) index;\n              image->colormap[i].blue=(MagickRealType) index;\n            }\n        }\n      if (image->compression == RLECompression)\n        {\n          unsigned int\n            tag;\n\n          /*\n            Read RLE segment table.\n          */\n          for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          {\n            int\n              c;\n\n            c=ReadBlobByte(image);\n            if (c == EOF)\n              break;\n          }\n          tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n            ReadBlobLSBShort(image);\n          stream_info->remaining=(size_t) ReadBlobLSBLong(image);\n          if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||\n              (EOFBlob(image) != MagickFalse))\n            {\n              if (stream_info->offsets != (ssize_t *) NULL)\n                stream_info->offsets=(ssize_t *)\n                  RelinquishMagickMemory(stream_info->offsets);\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n            }\n          stream_info->count=0;\n          stream_info->segment_count=ReadBlobLSBLong(image);\n          for (i=0; i < 15; i++)\n            stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          stream_info->remaining-=64;\n          if (stream_info->segment_count > 1)\n            {\n              info.bytes_per_pixel=1;\n              info.depth=8;\n              if (stream_info->offset_count > 0)\n                (void) SeekBlob(image,(MagickOffsetType)\n                  stream_info->offsets[0]+stream_info->segments[0],SEEK_SET);\n            }\n        }\n      if ((info.samples_per_pixel > 1) && (image->interlace == PlaneInterlace))\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *q;\n\n          ssize_t\n            y;\n\n          /*\n            Convert Planar RGB DCM Medical image to pixel packets.\n          */\n          for (i=0; i < (ssize_t) info.samples_per_pixel; i++)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                switch ((int) i)\n                {\n                  case 0:\n                  {\n                    SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 1:\n                  {\n                    SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 2:\n                  {\n                    SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 3:\n                  {\n                    SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  default:\n                    break;\n                }\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        }\n      else\n        {\n          const char\n            *option;\n\n          /*\n            Convert DCM Medical image to pixel packets.\n          */\n          option=GetImageOption(image_info,\"dcm:display-range\");\n          if (option != (const char *) NULL)\n            {\n              if (LocaleCompare(option,\"reset\") == 0)\n                info.window_width=0;\n            }\n          option=GetImageOption(image_info,\"dcm:window\");\n          if (option != (char *) NULL)\n            {\n              GeometryInfo\n                geometry_info;\n\n              MagickStatusType\n                flags;\n\n              flags=ParseGeometry(option,&geometry_info);\n              if (flags & RhoValue)\n                info.window_center=geometry_info.rho;\n              if (flags & SigmaValue)\n                info.window_width=geometry_info.sigma;\n              info.rescale=MagickTrue;\n            }\n          option=GetImageOption(image_info,\"dcm:rescale\");\n          if (option != (char *) NULL)\n            info.rescale=IsStringTrue(option);\n          if ((info.window_center != 0) && (info.window_width == 0))\n            info.window_width=info.window_center;\n          status=ReadDCMPixels(image,&info,stream_info,MagickTrue,exception);\n          if ((status != MagickFalse) && (stream_info->segment_count > 1))\n            {\n              if (stream_info->offset_count > 0)\n                (void) SeekBlob(image,(MagickOffsetType)\n                  stream_info->offsets[0]+stream_info->segments[1],SEEK_SET);\n              (void) ReadDCMPixels(image,&info,stream_info,MagickFalse,\n                exception);\n            }\n        }\n      if (SetImageGray(image,exception) != MagickFalse)\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n      /*\n        Proceed to next image.\n      */\n      if (image_info->number_scenes != 0)\n        if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n          break;\n      if (scene < (ssize_t) (number_scenes-1))\n        {\n          /*\n            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image,exception);\n          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n              status=MagickFalse;\n              break;\n            }\n          image=SyncNextImageInList(image);\n          status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n            GetBlobSize(image));\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (TellBlob(image) < (MagickOffsetType) GetBlobSize(image))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n     }\n  }\n  /*\n    Free resources.\n  */\n  if (stream_info->offsets != (ssize_t *) NULL)\n    stream_info->offsets=(ssize_t *)\n      RelinquishMagickMemory(stream_info->offsets);\n  stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (info.scale != (Quantum *) NULL)\n    info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n  if (graymap != (int *) NULL)\n    graymap=(int *) RelinquishMagickMemory(graymap);\n  if (bluemap != (int *) NULL)\n    bluemap=(int *) RelinquishMagickMemory(bluemap);\n  if (greenmap != (int *) NULL)\n    greenmap=(int *) RelinquishMagickMemory(greenmap);\n  if (redmap != (int *) NULL)\n    redmap=(int *) RelinquishMagickMemory(redmap);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142919,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowDCMException(exception,message) \\\n{ \\\n  if (info.scale != (Quantum *) NULL) \\\n    info.scale=(Quantum *) RelinquishMagickMemory(info.scale); \\\n  if (data != (unsigned char *) NULL) \\\n    data=(unsigned char *) RelinquishMagickMemory(data); \\\n  if (graymap != (int *) NULL) \\\n    graymap=(int *) RelinquishMagickMemory(graymap); \\\n  if (bluemap != (int *) NULL) \\\n    bluemap=(int *) RelinquishMagickMemory(bluemap); \\\n  if (greenmap != (int *) NULL) \\\n    greenmap=(int *) RelinquishMagickMemory(greenmap); \\\n  if (redmap != (int *) NULL) \\\n    redmap=(int *) RelinquishMagickMemory(redmap); \\\n  if (stream_info->offsets != (ssize_t *) NULL) \\\n    stream_info->offsets=(ssize_t *) RelinquishMagickMemory( \\\n      stream_info->offsets); \\\n  if (stream_info != (DCMStreamInfo *) NULL) \\\n    stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    explicit_vr[MagickPathExtent],\n    implicit_vr[MagickPathExtent],\n    magick[MagickPathExtent],\n    photometric[MagickPathExtent];\n\n  DCMInfo\n    info;\n\n  DCMStreamInfo\n    *stream_info;\n\n  Image\n    *image;\n\n  int\n    *bluemap,\n    datum,\n    *greenmap,\n    *graymap,\n    *redmap;\n\n  MagickBooleanType\n    explicit_file,\n    explicit_retry,\n    use_explicit;\n\n  MagickOffsetType\n    offset;\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    colors,\n    height,\n    length,\n    number_scenes,\n    quantum,\n    status,\n    width;\n\n  ssize_t\n    count,\n    scene;\n\n  unsigned char\n    *data;\n\n  unsigned short\n    group,\n    element;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=8UL;\n  image->endian=LSBEndian;\n  /*\n    Read DCM preamble.\n  */\n  (void) memset(&info,0,sizeof(info));\n  data=(unsigned char *) NULL;\n  graymap=(int *) NULL;\n  redmap=(int *) NULL;\n  greenmap=(int *) NULL;\n  bluemap=(int *) NULL;\n  stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));\n  if (stream_info == (DCMStreamInfo *) NULL)\n    ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memset(stream_info,0,sizeof(*stream_info));\n  count=ReadBlob(image,128,(unsigned char *) magick);\n  if (count != 128)\n    ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  if ((count != 4) || (LocaleNCompare(magick,\"DICM\",4) != 0))\n    {\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  /*\n    Read DCM Medical image.\n  */\n  (void) CopyMagickString(photometric,\"MONOCHROME1 \",MagickPathExtent);\n  info.bits_allocated=8;\n  info.bytes_per_pixel=1;\n  info.depth=8;\n  info.mask=0xffff;\n  info.max_value=255UL;\n  info.samples_per_pixel=1;\n  info.signed_data=(~0UL);\n  info.rescale_slope=1.0;\n  data=(unsigned char *) NULL;\n  element=0;\n  explicit_vr[2]='\\0';\n  explicit_file=MagickFalse;\n  colors=0;\n  redmap=(int *) NULL;\n  greenmap=(int *) NULL;\n  bluemap=(int *) NULL;\n  graymap=(int *) NULL;\n  height=0;\n  number_scenes=1;\n  use_explicit=MagickFalse;\n  explicit_retry = MagickFalse;\n  width=0;\n  while (TellBlob(image) < (MagickOffsetType) GetBlobSize(image))\n  {\n    for (group=0; (group != 0x7FE0) || (element != 0x0010) ; )\n    {\n      /*\n        Read a group.\n      */\n      image->offset=(ssize_t) TellBlob(image);\n      group=ReadBlobLSBShort(image);\n      element=ReadBlobLSBShort(image);\n      if ((group == 0xfffc) && (element == 0xfffc))\n        break;\n      if ((group != 0x0002) && (image->endian == MSBEndian))\n        {\n          group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));\n          element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));\n        }\n      quantum=0;\n      /*\n        Find corresponding VR for this group and element.\n      */\n      for (i=0; dicom_info[i].group < 0xffff; i++)\n        if ((group == dicom_info[i].group) &&\n            (element == dicom_info[i].element))\n          break;\n      (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);\n      count=ReadBlob(image,2,(unsigned char *) explicit_vr);\n      if (count != 2)\n        ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n      /*\n        Check for \"explicitness\", but meta-file headers always explicit.\n      */\n      if ((explicit_file == MagickFalse) && (group != 0x0002))\n        explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&\n          (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?\n          MagickTrue : MagickFalse;\n      use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||\n        (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;\n      if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,\"xs\",2) == 0))\n        (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);\n      if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,\"!!\",2) == 0))\n        {\n          offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);\n          if (offset < 0)\n            ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n          quantum=4;\n        }\n      else\n        {\n          /*\n            Assume explicit type.\n          */\n          quantum=2;\n          if ((strncmp(explicit_vr,\"OB\",2) == 0) ||\n              (strncmp(explicit_vr,\"UN\",2) == 0) ||\n              (strncmp(explicit_vr,\"OW\",2) == 0) ||\n              (strncmp(explicit_vr,\"SQ\",2) == 0))\n            {\n              (void) ReadBlobLSBShort(image);\n              quantum=4;\n            }\n        }\n      datum=0;\n      if (quantum == 4)\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedLong(image);\n          else\n            datum=ReadBlobSignedLong(image);\n        }\n      else\n        if (quantum == 2)\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedShort(image);\n            else\n              datum=ReadBlobSignedShort(image);\n          }\n      quantum=0;\n      length=1;\n      if (datum != 0)\n        {\n          if ((strncmp(implicit_vr,\"OW\",2) == 0) ||\n               (strncmp(implicit_vr,\"SS\",2) == 0) ||\n               (strncmp(implicit_vr,\"US\",2) == 0))\n             quantum=2;\n          else\n             if ((strncmp(implicit_vr,\"FL\",2) == 0) ||\n                 (strncmp(implicit_vr,\"OF\",2) == 0) ||\n                 (strncmp(implicit_vr,\"SL\",2) == 0) ||\n                 (strncmp(implicit_vr,\"UL\",2) == 0))\n               quantum=4;\n            else\n               if (strncmp(implicit_vr,\"FD\",2) == 0)\n                 quantum=8;\n               else\n                quantum=1;\n          if (datum != ~0)\n            length=(size_t) datum/quantum;\n          else\n            {\n              /*\n                Sequence and item of undefined length.\n              */\n              quantum=0;\n              length=0;\n            }\n        }\n      if (image_info->verbose != MagickFalse)\n        {\n          /*\n            Display Dicom info.\n          */\n          if (use_explicit == MagickFalse)\n            explicit_vr[0]='\\0';\n          for (i=0; dicom_info[i].description != (char *) NULL; i++)\n            if ((group == dicom_info[i].group) &&\n                (element == dicom_info[i].element))\n              break;\n          (void) FormatLocaleFile(stdout,\"0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)\",\n            (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,\n            (unsigned long) group,(unsigned long) element);\n          if (dicom_info[i].description != (char *) NULL)\n            (void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);\n          (void) FormatLocaleFile(stdout,\": \");\n        }\n      if ((group == 0x7FE0) && (element == 0x0010))\n        {\n          if (image_info->verbose != MagickFalse)\n            (void) FormatLocaleFile(stdout,\"\\n\");\n          break;\n        }\n      /*\n        Allocate space and read an array.\n      */\n      data=(unsigned char *) NULL;\n      if ((length == 1) && (quantum == 1))\n        datum=ReadBlobByte(image);\n      else\n        if ((length == 1) && (quantum == 2))\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedShort(image);\n            else\n              datum=ReadBlobSignedShort(image);\n          }\n        else\n          if ((length == 1) && (quantum == 4))\n            {\n              if (group == 0x0002)\n                datum=ReadBlobLSBSignedLong(image);\n              else\n                datum=ReadBlobSignedLong(image);\n            }\n          else\n            if ((quantum != 0) && (length != 0))\n              {\n                if (length > (size_t) GetBlobSize(image))\n                  ThrowDCMException(CorruptImageError,\n                    \"InsufficientImageDataInFile\");\n                if (~length >= 1)\n                  data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*\n                    sizeof(*data));\n                if (data == (unsigned char *) NULL)\n                  ThrowDCMException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n                count=ReadBlob(image,(size_t) quantum*length,data);\n                if (count != (ssize_t) (quantum*length))\n                  {\n                    if (image_info->verbose != MagickFalse)\n                      (void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"\n                        \"length=%d group=%d\\n\",(int) count,(int) quantum,(int)\n                        length,(int) group);\n                     ThrowDCMException(CorruptImageError,\n                       \"InsufficientImageDataInFile\");\n                  }\n                data[length*quantum]='\\0';\n              }\n      if ((((unsigned int) group << 16) | element) == 0xFFFEE0DD)\n        {\n          if (data != (unsigned char *) NULL)\n            data=(unsigned char *) RelinquishMagickMemory(data);\n          continue;\n        }\n      switch (group)\n      {\n        case 0x0002:\n        {\n          switch (element)\n          {\n            case 0x0010:\n            {\n              char\n                transfer_syntax[MagickPathExtent];\n\n              /*\n                Transfer Syntax.\n              */\n              if ((datum == 0) && (explicit_retry == MagickFalse))\n                {\n                  explicit_retry=MagickTrue;\n                  (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);\n                  group=0;\n                  element=0;\n                  if (image_info->verbose != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\n                      \"Corrupted image - trying explicit format\\n\");\n                  break;\n                }\n              *transfer_syntax='\\0';\n              if (data != (unsigned char *) NULL)\n                (void) CopyMagickString(transfer_syntax,(char *) data,\n                  MagickPathExtent);\n              if (image_info->verbose != MagickFalse)\n                (void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",\n                  (const char *) transfer_syntax);\n              if (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)\n                {\n                  int\n                    subtype,\n                    type;\n\n                  type=1;\n                  subtype=0;\n                  if (strlen(transfer_syntax) > 17)\n                    {\n                      count=(ssize_t) sscanf(transfer_syntax+17,\".%d.%d\",&type,\n                        &subtype);\n                      if (count < 1)\n                        ThrowDCMException(CorruptImageError,\n                          \"ImproperImageHeader\");\n                    }\n                  switch (type)\n                  {\n                    case 1:\n                    {\n                      image->endian=LSBEndian;\n                      break;\n                    }\n                    case 2:\n                    {\n                      image->endian=MSBEndian;\n                      break;\n                    }\n                    case 4:\n                    {\n                      if ((subtype >= 80) && (subtype <= 81))\n                        image->compression=JPEGCompression;\n                      else\n                        if ((subtype >= 90) && (subtype <= 93))\n                          image->compression=JPEG2000Compression;\n                        else\n                          image->compression=JPEGCompression;\n                      break;\n                    }\n                    case 5:\n                    {\n                      image->compression=RLECompression;\n                      break;\n                    }\n                  }\n                }\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        case 0x0028:\n        {\n          switch (element)\n          {\n            case 0x0002:\n            {\n              /*\n                Samples per pixel.\n              */\n              info.samples_per_pixel=(size_t) datum;\n              if ((info.samples_per_pixel == 0) || (info.samples_per_pixel > 4))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n              break;\n            }\n            case 0x0004:\n            {\n              /*\n                Photometric interpretation.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)\n                photometric[i]=(char) data[i];\n              photometric[i]='\\0';\n              info.polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?\n                MagickTrue : MagickFalse;\n              break;\n            }\n            case 0x0006:\n            {\n              /*\n                Planar configuration.\n              */\n              if (datum == 1)\n                image->interlace=PlaneInterlace;\n              break;\n            }\n            case 0x0008:\n            {\n              /*\n                Number of frames.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              number_scenes=StringToUnsignedLong((char *) data);\n              break;\n            }\n            case 0x0010:\n            {\n              /*\n                Image rows.\n              */\n              height=(size_t) datum;\n              break;\n            }\n            case 0x0011:\n            {\n              /*\n                Image columns.\n              */\n              width=(size_t) datum;\n              break;\n            }\n            case 0x0100:\n            {\n              /*\n                Bits allocated.\n              */\n              info.bits_allocated=(size_t) datum;\n              info.bytes_per_pixel=1;\n              if (datum > 8)\n                info.bytes_per_pixel=2;\n              info.depth=info.bits_allocated;\n              if ((info.depth == 0) || (info.depth > 32))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n              info.max_value=(1UL << info.bits_allocated)-1;\n              image->depth=info.depth;\n              break;\n            }\n            case 0x0101:\n            {\n              /*\n                Bits stored.\n              */\n              info.significant_bits=(size_t) datum;\n              info.bytes_per_pixel=1;\n              if (info.significant_bits > 8)\n                info.bytes_per_pixel=2;\n              info.depth=info.significant_bits;\n              if ((info.depth == 0) || (info.depth > 16))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n              info.max_value=(1UL << info.significant_bits)-1;\n              info.mask=(size_t) GetQuantumRange(info.significant_bits);\n              image->depth=info.depth;\n              break;\n            }\n            case 0x0102:\n            {\n              /*\n                High bit.\n              */\n              break;\n            }\n            case 0x0103:\n            {\n              /*\n                Pixel representation.\n              */\n              info.signed_data=(size_t) datum;\n              break;\n            }\n            case 0x1050:\n            {\n              /*\n                Visible pixel range: center.\n              */\n              if (data != (unsigned char *) NULL)\n                info.window_center=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1051:\n            {\n              /*\n                Visible pixel range: width.\n              */\n              if (data != (unsigned char *) NULL)\n                info.window_width=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1052:\n            {\n              /*\n                Rescale intercept\n              */\n              if (data != (unsigned char *) NULL)\n                info.rescale_intercept=StringToDouble((char *) data,\n                  (char **) NULL);\n              break;\n            }\n            case 0x1053:\n            {\n              /*\n                Rescale slope\n              */\n              if (data != (unsigned char *) NULL)\n                info.rescale_slope=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1200:\n            case 0x3006:\n            {\n              /*\n                Populate graymap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/info.bytes_per_pixel);\n              datum=(int) colors;\n              if (graymap != (int *) NULL)\n                graymap=(int *) RelinquishMagickMemory(graymap);\n              graymap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*graymap));\n              if (graymap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(graymap,0,MagickMax(colors,65536)*\n                sizeof(*graymap));\n              for (i=0; i < (ssize_t) colors; i++)\n                if (info.bytes_per_pixel == 1)\n                  graymap[i]=(int) data[i];\n                else\n                  graymap[i]=(int) ((short *) data)[i];\n              break;\n            }\n            case 0x1201:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate redmap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/2);\n              datum=(int) colors;\n              if (redmap != (int *) NULL)\n                redmap=(int *) RelinquishMagickMemory(redmap);\n              redmap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*redmap));\n              if (redmap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(redmap,0,MagickMax(colors,65536)*\n                sizeof(*redmap));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                redmap[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            case 0x1202:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate greenmap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/2);\n              datum=(int) colors;\n              if (greenmap != (int *) NULL)\n                greenmap=(int *) RelinquishMagickMemory(greenmap);\n              greenmap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*greenmap));\n              if (greenmap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(greenmap,0,MagickMax(colors,65536)*\n                sizeof(*greenmap));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                greenmap[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            case 0x1203:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate bluemap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/2);\n              datum=(int) colors;\n              if (bluemap != (int *) NULL)\n                bluemap=(int *) RelinquishMagickMemory(bluemap);\n              bluemap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*bluemap));\n              if (bluemap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(bluemap,0,MagickMax(colors,65536)*\n                sizeof(*bluemap));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                bluemap[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        case 0x2050:\n        {\n          switch (element)\n          {\n            case 0x0020:\n            {\n              if ((data != (unsigned char *) NULL) &&\n                  (strncmp((char *) data,\"INVERSE\",7) == 0))\n                info.polarity=MagickTrue;\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        default:\n          break;\n      }\n      if (data != (unsigned char *) NULL)\n        {\n          char\n            *attribute;\n\n          for (i=0; dicom_info[i].description != (char *) NULL; i++)\n            if ((group == dicom_info[i].group) &&\n                (element == dicom_info[i].element))\n              break;\n          if (dicom_info[i].description != (char *) NULL)\n            {\n              attribute=AcquireString(\"dcm:\");\n              (void) ConcatenateString(&attribute,dicom_info[i].description);\n              for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n                if (isprint((int) data[i]) == MagickFalse)\n                  break;\n              if ((i == (ssize_t) length) || (length > 4))\n                {\n                  (void) SubstituteString(&attribute,\" \",\"\");\n                  (void) SetImageProperty(image,attribute,(char *) data,\n                    exception);\n                }\n              attribute=DestroyString(attribute);\n            }\n        }\n      if (image_info->verbose != MagickFalse)\n        {\n          if (data == (unsigned char *) NULL)\n            (void) FormatLocaleFile(stdout,\"%d\\n\",datum);\n          else\n            {\n              /*\n                Display group data.\n              */\n              for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n                if (isprint((int) data[i]) == MagickFalse)\n                  break;\n              if ((i != (ssize_t) length) && (length <= 4))\n                {\n                  ssize_t\n                    j;\n\n                  datum=0;\n                  for (j=(ssize_t) length-1; j >= 0; j--)\n                    datum=(256*datum+data[j]);\n                  (void) FormatLocaleFile(stdout,\"%d\",datum);\n                }\n              else\n                for (i=0; i < (ssize_t) length; i++)\n                  if (isprint((int) data[i]) != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\"%c\",data[i]);\n                  else\n                    (void) FormatLocaleFile(stdout,\"%c\",'.');\n              (void) FormatLocaleFile(stdout,\"\\n\");\n            }\n        }\n      if (data != (unsigned char *) NULL)\n        data=(unsigned char *) RelinquishMagickMemory(data);\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n    }\n    if ((group == 0xfffc) && (element == 0xfffc))\n      {\n        Image\n          *last;\n\n        last=RemoveLastImageFromList(&image);\n        if (last != (Image *) NULL)\n          last=DestroyImage(last);\n        break;\n      }\n    if ((width == 0) || (height == 0))\n      ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    if (info.signed_data == 0xffff)\n      info.signed_data=(size_t) (info.significant_bits == 16 ? 1 : 0);\n    if ((image->compression == JPEGCompression) ||\n        (image->compression == JPEG2000Compression))\n      {\n        Image\n          *images;\n\n        ImageInfo\n          *read_info;\n\n        int\n          c;\n\n        /*\n          Read offset table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        (void) (((ssize_t) ReadBlobLSBShort(image) << 16) |\n          ReadBlobLSBShort(image));\n        length=(size_t) ReadBlobLSBLong(image);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\n        stream_info->offset_count=length >> 2;\n        if (stream_info->offset_count != 0)\n          {\n            if (stream_info->offsets != (ssize_t *) NULL)\n              stream_info->offsets=(ssize_t *) RelinquishMagickMemory(\n                stream_info->offsets);\n            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n              stream_info->offset_count,sizeof(*stream_info->offsets));\n            if (stream_info->offsets == (ssize_t *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n            offset=TellBlob(image);\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]+=offset;\n          }\n        /*\n          Handle non-native image formats.\n        */\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        images=NewImageList();\n        for (scene=0; scene < (ssize_t) number_scenes; scene++)\n        {\n          char\n            filename[MagickPathExtent];\n\n          const char\n            *property;\n\n          FILE\n            *file;\n\n          Image\n            *jpeg_image;\n\n          int\n            unique_file;\n\n          unsigned int\n            tag;\n\n          tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n            ReadBlobLSBShort(image);\n          length=(size_t) ReadBlobLSBLong(image);\n          if (tag == 0xFFFEE0DD)\n            break; /* sequence delimiter tag */\n          if (tag != 0xFFFEE000)\n            {\n              read_info=DestroyImageInfo(read_info);\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n            }\n          file=(FILE *) NULL;\n          unique_file=AcquireUniqueFileResource(filename);\n          if (unique_file != -1)\n            file=fdopen(unique_file,\"wb\");\n          if (file == (FILE *) NULL)\n            {\n              (void) RelinquishUniqueFileResource(filename);\n              ThrowFileException(exception,FileOpenError,\n                \"UnableToCreateTemporaryFile\",filename);\n              break;\n            }\n          for (c=EOF; length != 0; length--)\n          {\n            c=ReadBlobByte(image);\n            if (c == EOF)\n              {\n                ThrowFileException(exception,CorruptImageError,\n                   \"UnexpectedEndOfFile\",image->filename);\n                 break;\n               }\n            if (fputc(c,file) != c)\n              break;\n           }\n           (void) fclose(file);\n           if (c == EOF)\n            break;\n          (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n            \"jpeg:%s\",filename);\n          if (image->compression == JPEG2000Compression)\n            (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n              \"j2k:%s\",filename);\n          jpeg_image=ReadImage(read_info,exception);\n          if (jpeg_image != (Image *) NULL)\n            {\n              ResetImagePropertyIterator(image);\n              property=GetNextImageProperty(image);\n              while (property != (const char *) NULL)\n              {\n                (void) SetImageProperty(jpeg_image,property,\n                  GetImageProperty(image,property,exception),exception);\n                property=GetNextImageProperty(image);\n              }\n              AppendImageToList(&images,jpeg_image);\n            }\n          (void) RelinquishUniqueFileResource(filename);\n        }\n        read_info=DestroyImageInfo(read_info);\n        if (stream_info->offsets != (ssize_t *) NULL)\n          stream_info->offsets=(ssize_t *)\n            RelinquishMagickMemory(stream_info->offsets);\n        stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n        if (info.scale != (Quantum *) NULL)\n          info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n        if (graymap != (int *) NULL)\n          graymap=(int *) RelinquishMagickMemory(graymap);\n        if (bluemap != (int *) NULL)\n          bluemap=(int *) RelinquishMagickMemory(bluemap);\n        if (greenmap != (int *) NULL)\n          greenmap=(int *) RelinquishMagickMemory(greenmap);\n        if (redmap != (int *) NULL)\n          redmap=(int *) RelinquishMagickMemory(redmap);\n        image=DestroyImageList(image);\n        return(GetFirstImageInList(images));\n      }\n    if (info.depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))\n      {\n        QuantumAny\n          range;\n\n        /*\n          Compute pixel scaling table.\n        */\n         length=(size_t) (GetQuantumRange(info.depth)+1);\n         if (length > (size_t) GetBlobSize(image))\n           ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\n        if (info.scale != (Quantum *) NULL)\n           info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n         info.scale=(Quantum *) AcquireQuantumMemory(MagickMax(length,256),\n           sizeof(*info.scale));\n        if (info.scale == (Quantum *) NULL)\n          ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(info.scale,0,MagickMax(length,256)*\n          sizeof(*info.scale));\n        range=GetQuantumRange(info.depth);\n        for (i=0; i <= (ssize_t) GetQuantumRange(info.depth); i++)\n          info.scale[i]=ScaleAnyToQuantum((size_t) i,range);\n      }\n    if (image->compression == RLECompression)\n      {\n        unsigned int\n          tag;\n\n        /*\n          Read RLE offset table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n        }\n        tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n          ReadBlobLSBShort(image);\n        (void) tag;\n        length=(size_t) ReadBlobLSBLong(image);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\n        stream_info->offset_count=length >> 2;\n        if (stream_info->offset_count != 0)\n          {\n            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n              stream_info->offset_count,sizeof(*stream_info->offsets));\n            if (stream_info->offsets == (ssize_t *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            {\n              stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n              if (EOFBlob(image) != MagickFalse)\n                break;\n            }\n            offset=TellBlob(image)+8;\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]+=offset;\n          }\n      }\n    for (scene=0; scene < (ssize_t) number_scenes; scene++)\n    {\n      if (image_info->ping != MagickFalse)\n        break;\n      image->columns=(size_t) width;\n      image->rows=(size_t) height;\n      image->depth=info.depth;\n      status=SetImageExtent(image,image->columns,image->rows,exception);\n      if (status == MagickFalse)\n        break;\n      image->colorspace=RGBColorspace;\n      (void) SetImageBackgroundColor(image,exception);\n      if ((image->colormap == (PixelInfo *) NULL) &&\n          (info.samples_per_pixel == 1))\n        {\n          int\n            index;\n\n          size_t\n            one;\n\n          one=1;\n          if (colors == 0)\n            colors=one << info.depth;\n          if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n            ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n          if (redmap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=redmap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].red=(MagickRealType) index;\n            }\n          if (greenmap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=greenmap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].green=(MagickRealType) index;\n            }\n          if (bluemap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=bluemap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].blue=(MagickRealType) index;\n            }\n          if (graymap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=graymap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].red=(MagickRealType) index;\n              image->colormap[i].green=(MagickRealType) index;\n              image->colormap[i].blue=(MagickRealType) index;\n            }\n        }\n      if (image->compression == RLECompression)\n        {\n          unsigned int\n            tag;\n\n          /*\n            Read RLE segment table.\n          */\n          for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          {\n            int\n              c;\n\n            c=ReadBlobByte(image);\n            if (c == EOF)\n              break;\n          }\n          tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n            ReadBlobLSBShort(image);\n          stream_info->remaining=(size_t) ReadBlobLSBLong(image);\n          if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||\n              (EOFBlob(image) != MagickFalse))\n            {\n              if (stream_info->offsets != (ssize_t *) NULL)\n                stream_info->offsets=(ssize_t *)\n                  RelinquishMagickMemory(stream_info->offsets);\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n            }\n          stream_info->count=0;\n          stream_info->segment_count=ReadBlobLSBLong(image);\n          for (i=0; i < 15; i++)\n            stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          stream_info->remaining-=64;\n          if (stream_info->segment_count > 1)\n            {\n              info.bytes_per_pixel=1;\n              info.depth=8;\n              if (stream_info->offset_count > 0)\n                (void) SeekBlob(image,(MagickOffsetType)\n                  stream_info->offsets[0]+stream_info->segments[0],SEEK_SET);\n            }\n        }\n      if ((info.samples_per_pixel > 1) && (image->interlace == PlaneInterlace))\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *q;\n\n          ssize_t\n            y;\n\n          /*\n            Convert Planar RGB DCM Medical image to pixel packets.\n          */\n          for (i=0; i < (ssize_t) info.samples_per_pixel; i++)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                switch ((int) i)\n                {\n                  case 0:\n                  {\n                    SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 1:\n                  {\n                    SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 2:\n                  {\n                    SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 3:\n                  {\n                    SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  default:\n                    break;\n                }\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        }\n      else\n        {\n          const char\n            *option;\n\n          /*\n            Convert DCM Medical image to pixel packets.\n          */\n          option=GetImageOption(image_info,\"dcm:display-range\");\n          if (option != (const char *) NULL)\n            {\n              if (LocaleCompare(option,\"reset\") == 0)\n                info.window_width=0;\n            }\n          option=GetImageOption(image_info,\"dcm:window\");\n          if (option != (char *) NULL)\n            {\n              GeometryInfo\n                geometry_info;\n\n              MagickStatusType\n                flags;\n\n              flags=ParseGeometry(option,&geometry_info);\n              if (flags & RhoValue)\n                info.window_center=geometry_info.rho;\n              if (flags & SigmaValue)\n                info.window_width=geometry_info.sigma;\n              info.rescale=MagickTrue;\n            }\n          option=GetImageOption(image_info,\"dcm:rescale\");\n          if (option != (char *) NULL)\n            info.rescale=IsStringTrue(option);\n          if ((info.window_center != 0) && (info.window_width == 0))\n            info.window_width=info.window_center;\n          status=ReadDCMPixels(image,&info,stream_info,MagickTrue,exception);\n          if ((status != MagickFalse) && (stream_info->segment_count > 1))\n            {\n              if (stream_info->offset_count > 0)\n                (void) SeekBlob(image,(MagickOffsetType)\n                  stream_info->offsets[0]+stream_info->segments[1],SEEK_SET);\n              (void) ReadDCMPixels(image,&info,stream_info,MagickFalse,\n                exception);\n            }\n        }\n      if (SetImageGray(image,exception) != MagickFalse)\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n      /*\n        Proceed to next image.\n      */\n      if (image_info->number_scenes != 0)\n        if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n          break;\n      if (scene < (ssize_t) (number_scenes-1))\n        {\n          /*\n            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image,exception);\n          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n              status=MagickFalse;\n              break;\n            }\n          image=SyncNextImageInList(image);\n          status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n            GetBlobSize(image));\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (TellBlob(image) < (MagickOffsetType) GetBlobSize(image))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n     }\n  }\n  /*\n    Free resources.\n  */\n  if (stream_info->offsets != (ssize_t *) NULL)\n    stream_info->offsets=(ssize_t *)\n      RelinquishMagickMemory(stream_info->offsets);\n  stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (info.scale != (Quantum *) NULL)\n    info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n  if (graymap != (int *) NULL)\n    graymap=(int *) RelinquishMagickMemory(graymap);\n  if (bluemap != (int *) NULL)\n    bluemap=(int *) RelinquishMagickMemory(bluemap);\n  if (greenmap != (int *) NULL)\n    greenmap=(int *) RelinquishMagickMemory(greenmap);\n  if (redmap != (int *) NULL)\n    redmap=(int *) RelinquishMagickMemory(redmap);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142920,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next_image,\n    *pwp_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register Image\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    filesize,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    magick[MagickPathExtent];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  pwp_image=image;\n  memset(magick,0,sizeof(magick));\n  count=ReadBlob(pwp_image,5,magick);\n  if ((count != 5) || (LocaleNCompare((char *) magick,\"SFW95\",5) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  read_info=CloneImageInfo(image_info);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  unique_file=AcquireUniqueFileResource(filename);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"sfw:%s\",\n    filename);\n  for ( ; ; )\n  {\n    (void) memset(magick,0,sizeof(magick));\n    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))\n    {\n      for (i=0; i < 17; i++)\n        magick[i]=magick[i+1];\n      magick[17]=(unsigned char) c;\n      if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) == 0)\n        break;\n    }\n    if (c == EOF)\n      {\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n      }\n    if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)\n      {\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    /*\n      Dump SFW image to a temporary file.\n    */\n    file=(FILE *) NULL;\n    if (unique_file != -1)\n      file=fdopen(unique_file,\"wb\");\n    if ((unique_file == -1) || (file == (FILE *) NULL))\n      {\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\n          image->filename);\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    length=fwrite(\"SFW94A\",1,6,file);\n    (void) length;\n    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];\n    for (i=0; i < (ssize_t) filesize; i++)\n    {\n       c=ReadBlobByte(pwp_image);\n       if (c == EOF)\n         break;\n      (void) fputc(c,file);\n     }\n     (void) fclose(file);\n     if (c == EOF)\n      {\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n      }\n    next_image=ReadImage(read_info,exception);\n    if (next_image == (Image *) NULL)\n      break;\n    (void) FormatLocaleString(next_image->filename,MagickPathExtent,\n      \"slide_%02ld.sfw\",(long) next_image->scene);\n    if (image == (Image *) NULL)\n      image=next_image;\n    else\n      {\n        /*\n          Link image into image list.\n        */\n        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;\n        next_image->previous=p;\n        next_image->scene=p->scene+1;\n        p->next=next_image;\n      }\n    if (image_info->number_scenes != 0)\n      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),\n      GetBlobSize(pwp_image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (unique_file != -1)\n    (void) close(unique_file);\n  (void) RelinquishUniqueFileResource(filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      if (EOFBlob(image) != MagickFalse)\n        {\n          char\n            *message;\n\n          message=GetExceptionMessage(errno);\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            CorruptImageError,\"UnexpectedEndOfFile\",\"`%s': %s\",image->filename,\n            message);\n          message=DestroyString(message);\n        }\n      (void) CloseBlob(image);\n    }\n  return(GetFirstImageInList(image));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142921,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next_image,\n    *pwp_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register Image\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    filesize,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    magick[MagickPathExtent];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  pwp_image=image;\n  memset(magick,0,sizeof(magick));\n  count=ReadBlob(pwp_image,5,magick);\n  if ((count != 5) || (LocaleNCompare((char *) magick,\"SFW95\",5) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  read_info=CloneImageInfo(image_info);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  unique_file=AcquireUniqueFileResource(filename);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"sfw:%s\",\n    filename);\n  for ( ; ; )\n  {\n    (void) memset(magick,0,sizeof(magick));\n    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))\n    {\n      for (i=0; i < 17; i++)\n        magick[i]=magick[i+1];\n      magick[17]=(unsigned char) c;\n      if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) == 0)\n        break;\n    }\n    if (c == EOF)\n      {\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n      }\n    if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)\n      {\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    /*\n      Dump SFW image to a temporary file.\n    */\n    file=(FILE *) NULL;\n    if (unique_file != -1)\n      file=fdopen(unique_file,\"wb\");\n    if ((unique_file == -1) || (file == (FILE *) NULL))\n      {\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\n          image->filename);\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    length=fwrite(\"SFW94A\",1,6,file);\n    (void) length;\n    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];\n    for (i=0; i < (ssize_t) filesize; i++)\n    {\n       c=ReadBlobByte(pwp_image);\n       if (c == EOF)\n         break;\n      if (fputc(c,file) != c)\n        break;\n     }\n     (void) fclose(file);\n     if (c == EOF)\n      {\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n      }\n    next_image=ReadImage(read_info,exception);\n    if (next_image == (Image *) NULL)\n      break;\n    (void) FormatLocaleString(next_image->filename,MagickPathExtent,\n      \"slide_%02ld.sfw\",(long) next_image->scene);\n    if (image == (Image *) NULL)\n      image=next_image;\n    else\n      {\n        /*\n          Link image into image list.\n        */\n        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;\n        next_image->previous=p;\n        next_image->scene=p->scene+1;\n        p->next=next_image;\n      }\n    if (image_info->number_scenes != 0)\n      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),\n      GetBlobSize(pwp_image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (unique_file != -1)\n    (void) close(unique_file);\n  (void) RelinquishUniqueFileResource(filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      if (EOFBlob(image) != MagickFalse)\n        {\n          char\n            *message;\n\n          message=GetExceptionMessage(errno);\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            CorruptImageError,\"UnexpectedEndOfFile\",\"`%s': %s\",image->filename,\n            message);\n          message=DestroyString(message);\n        }\n      (void) CloseBlob(image);\n    }\n  return(GetFirstImageInList(image));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142922,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n \t\t\t  loff_t *ppos)\n {\n \tstruct usb_yurex *dev;\n\tint retval = 0;\n\tint bytes_read = 0;\n \tchar in_buffer[20];\n \tunsigned long flags;\n \n \tdev = file->private_data;\n \n \tmutex_lock(&dev->io_mutex);\n \tif (!dev->interface) {\t\t/* already disconnected */\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n \t}\n \n \tspin_lock_irqsave(&dev->lock, flags);\n\tbytes_read = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n \tspin_unlock_irqrestore(&dev->lock, flags);\n\tif (*ppos < bytes_read) {\n\t\tif (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))\n\t\t\tretval = -EFAULT;\n\t\telse {\n\t\t\tretval = bytes_read - *ppos;\n\t\t\t*ppos += bytes_read;\n\t\t}\n\t}\nexit:\n \tmutex_unlock(&dev->io_mutex);\n\treturn retval;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142927,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n \t\t\t  loff_t *ppos)\n {\n \tstruct usb_yurex *dev;\n\tint len = 0;\n \tchar in_buffer[20];\n \tunsigned long flags;\n \n \tdev = file->private_data;\n \n \tmutex_lock(&dev->io_mutex);\n \tif (!dev->interface) {\t\t/* already disconnected */\n\t\tmutex_unlock(&dev->io_mutex);\n\t\treturn -ENODEV;\n \t}\n \n \tspin_lock_irqsave(&dev->lock, flags);\n\tlen = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n \tspin_unlock_irqrestore(&dev->lock, flags);\n \tmutex_unlock(&dev->io_mutex);\n\n\treturn simple_read_from_buffer(buffer, count, ppos, in_buffer, len);\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142928,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void cmd_parse_status(struct ImapData *idata, char *s)\n{\n  char *value = NULL;\n  struct Buffy *inc = NULL;\n  struct ImapMbox mx;\n  struct ImapStatus *status = NULL;\n  unsigned int olduv, oldun;\n  unsigned int litlen;\n  short new = 0;\n  short new_msg_count = 0;\n\n  char *mailbox = imap_next_word(s);\n\n  /* We need a real tokenizer. */\n  if (imap_get_literal_count(mailbox, &litlen) == 0)\n  {\n    if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)\n    {\n       idata->status = IMAP_FATAL;\n       return;\n     }\n     mailbox = idata->buf;\n     s = mailbox + litlen;\n     *s = '\\0';\n    s++;\n    SKIPWS(s);\n  }\n  else\n  {\n    s = imap_next_word(mailbox);\n    *(s - 1) = '\\0';\n    imap_unmunge_mbox_name(idata, mailbox);\n  }\n\n  status = imap_mboxcache_get(idata, mailbox, 1);\n  olduv = status->uidvalidity;\n  oldun = status->uidnext;\n\n  if (*s++ != '(')\n  {\n    mutt_debug(1, \"Error parsing STATUS\\n\");\n    return;\n  }\n  while (*s && *s != ')')\n  {\n    value = imap_next_word(s);\n\n    errno = 0;\n    const unsigned long ulcount = strtoul(value, &value, 10);\n    if (((errno == ERANGE) && (ulcount == ULONG_MAX)) || ((unsigned int) ulcount != ulcount))\n    {\n      mutt_debug(1, \"Error parsing STATUS number\\n\");\n      return;\n    }\n    const unsigned int count = (unsigned int) ulcount;\n\n    if (mutt_str_strncmp(\"MESSAGES\", s, 8) == 0)\n    {\n      status->messages = count;\n      new_msg_count = 1;\n    }\n    else if (mutt_str_strncmp(\"RECENT\", s, 6) == 0)\n      status->recent = count;\n    else if (mutt_str_strncmp(\"UIDNEXT\", s, 7) == 0)\n      status->uidnext = count;\n    else if (mutt_str_strncmp(\"UIDVALIDITY\", s, 11) == 0)\n      status->uidvalidity = count;\n    else if (mutt_str_strncmp(\"UNSEEN\", s, 6) == 0)\n      status->unseen = count;\n\n    s = value;\n    if (*s && *s != ')')\n      s = imap_next_word(s);\n  }\n  mutt_debug(3, \"%s (UIDVALIDITY: %u, UIDNEXT: %u) %d messages, %d recent, %d unseen\\n\",\n             status->name, status->uidvalidity, status->uidnext,\n             status->messages, status->recent, status->unseen);\n\n  /* caller is prepared to handle the result herself */\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_STATUS)\n  {\n    memcpy(idata->cmddata, status, sizeof(struct ImapStatus));\n    return;\n  }\n\n  mutt_debug(3, \"Running default STATUS handler\\n\");\n\n  /* should perhaps move this code back to imap_buffy_check */\n  for (inc = Incoming; inc; inc = inc->next)\n  {\n    if (inc->magic != MUTT_IMAP)\n      continue;\n\n    if (imap_parse_path(inc->path, &mx) < 0)\n    {\n      mutt_debug(1, \"Error parsing mailbox %s, skipping\\n\", inc->path);\n      continue;\n    }\n\n    if (imap_account_match(&idata->conn->account, &mx.account))\n    {\n      if (mx.mbox)\n      {\n        value = mutt_str_strdup(mx.mbox);\n        imap_fix_path(idata, mx.mbox, value, mutt_str_strlen(value) + 1);\n        FREE(&mx.mbox);\n      }\n      else\n        value = mutt_str_strdup(\"INBOX\");\n\n      if (value && (imap_mxcmp(mailbox, value) == 0))\n      {\n        mutt_debug(3, \"Found %s in buffy list (OV: %u ON: %u U: %d)\\n\", mailbox,\n                   olduv, oldun, status->unseen);\n\n        if (MailCheckRecent)\n        {\n          if (olduv && olduv == status->uidvalidity)\n          {\n            if (oldun < status->uidnext)\n              new = (status->unseen > 0);\n          }\n          else if (!olduv && !oldun)\n          {\n            /* first check per session, use recent. might need a flag for this. */\n            new = (status->recent > 0);\n          }\n          else\n            new = (status->unseen > 0);\n        }\n        else\n          new = (status->unseen > 0);\n\n#ifdef USE_SIDEBAR\n        if ((inc->new != new) || (inc->msg_count != status->messages) ||\n            (inc->msg_unread != status->unseen))\n        {\n          mutt_menu_set_current_redraw(REDRAW_SIDEBAR);\n        }\n#endif\n        inc->new = new;\n        if (new_msg_count)\n          inc->msg_count = status->messages;\n        inc->msg_unread = status->unseen;\n\n        if (inc->new)\n        {\n          /* force back to keep detecting new mail until the mailbox is\n             opened */\n          status->uidnext = oldun;\n        }\n\n        FREE(&value);\n        return;\n      }\n\n      FREE(&value);\n    }\n\n    FREE(&mx.mbox);\n  }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142971,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void cmd_parse_status(struct ImapData *idata, char *s)\n{\n  char *value = NULL;\n  struct Buffy *inc = NULL;\n  struct ImapMbox mx;\n  struct ImapStatus *status = NULL;\n  unsigned int olduv, oldun;\n  unsigned int litlen;\n  short new = 0;\n  short new_msg_count = 0;\n\n  char *mailbox = imap_next_word(s);\n\n  /* We need a real tokenizer. */\n  if (imap_get_literal_count(mailbox, &litlen) == 0)\n  {\n    if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)\n    {\n       idata->status = IMAP_FATAL;\n       return;\n     }\n\n    if (strlen(idata->buf) < litlen)\n    {\n      mutt_debug(1, \"Error parsing STATUS mailbox\\n\");\n      return;\n    }\n\n     mailbox = idata->buf;\n     s = mailbox + litlen;\n     *s = '\\0';\n    s++;\n    SKIPWS(s);\n  }\n  else\n  {\n    s = imap_next_word(mailbox);\n    *(s - 1) = '\\0';\n    imap_unmunge_mbox_name(idata, mailbox);\n  }\n\n  status = imap_mboxcache_get(idata, mailbox, 1);\n  olduv = status->uidvalidity;\n  oldun = status->uidnext;\n\n  if (*s++ != '(')\n  {\n    mutt_debug(1, \"Error parsing STATUS\\n\");\n    return;\n  }\n  while (*s && *s != ')')\n  {\n    value = imap_next_word(s);\n\n    errno = 0;\n    const unsigned long ulcount = strtoul(value, &value, 10);\n    if (((errno == ERANGE) && (ulcount == ULONG_MAX)) || ((unsigned int) ulcount != ulcount))\n    {\n      mutt_debug(1, \"Error parsing STATUS number\\n\");\n      return;\n    }\n    const unsigned int count = (unsigned int) ulcount;\n\n    if (mutt_str_strncmp(\"MESSAGES\", s, 8) == 0)\n    {\n      status->messages = count;\n      new_msg_count = 1;\n    }\n    else if (mutt_str_strncmp(\"RECENT\", s, 6) == 0)\n      status->recent = count;\n    else if (mutt_str_strncmp(\"UIDNEXT\", s, 7) == 0)\n      status->uidnext = count;\n    else if (mutt_str_strncmp(\"UIDVALIDITY\", s, 11) == 0)\n      status->uidvalidity = count;\n    else if (mutt_str_strncmp(\"UNSEEN\", s, 6) == 0)\n      status->unseen = count;\n\n    s = value;\n    if (*s && *s != ')')\n      s = imap_next_word(s);\n  }\n  mutt_debug(3, \"%s (UIDVALIDITY: %u, UIDNEXT: %u) %d messages, %d recent, %d unseen\\n\",\n             status->name, status->uidvalidity, status->uidnext,\n             status->messages, status->recent, status->unseen);\n\n  /* caller is prepared to handle the result herself */\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_STATUS)\n  {\n    memcpy(idata->cmddata, status, sizeof(struct ImapStatus));\n    return;\n  }\n\n  mutt_debug(3, \"Running default STATUS handler\\n\");\n\n  /* should perhaps move this code back to imap_buffy_check */\n  for (inc = Incoming; inc; inc = inc->next)\n  {\n    if (inc->magic != MUTT_IMAP)\n      continue;\n\n    if (imap_parse_path(inc->path, &mx) < 0)\n    {\n      mutt_debug(1, \"Error parsing mailbox %s, skipping\\n\", inc->path);\n      continue;\n    }\n\n    if (imap_account_match(&idata->conn->account, &mx.account))\n    {\n      if (mx.mbox)\n      {\n        value = mutt_str_strdup(mx.mbox);\n        imap_fix_path(idata, mx.mbox, value, mutt_str_strlen(value) + 1);\n        FREE(&mx.mbox);\n      }\n      else\n        value = mutt_str_strdup(\"INBOX\");\n\n      if (value && (imap_mxcmp(mailbox, value) == 0))\n      {\n        mutt_debug(3, \"Found %s in buffy list (OV: %u ON: %u U: %d)\\n\", mailbox,\n                   olduv, oldun, status->unseen);\n\n        if (MailCheckRecent)\n        {\n          if (olduv && olduv == status->uidvalidity)\n          {\n            if (oldun < status->uidnext)\n              new = (status->unseen > 0);\n          }\n          else if (!olduv && !oldun)\n          {\n            /* first check per session, use recent. might need a flag for this. */\n            new = (status->recent > 0);\n          }\n          else\n            new = (status->unseen > 0);\n        }\n        else\n          new = (status->unseen > 0);\n\n#ifdef USE_SIDEBAR\n        if ((inc->new != new) || (inc->msg_count != status->messages) ||\n            (inc->msg_unread != status->unseen))\n        {\n          mutt_menu_set_current_redraw(REDRAW_SIDEBAR);\n        }\n#endif\n        inc->new = new;\n        if (new_msg_count)\n          inc->msg_count = status->messages;\n        inc->msg_unread = status->unseen;\n\n        if (inc->new)\n        {\n          /* force back to keep detecting new mail until the mailbox is\n             opened */\n          status->uidnext = oldun;\n        }\n\n        FREE(&value);\n        return;\n      }\n\n      FREE(&value);\n    }\n\n    FREE(&mx.mbox);\n  }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142972,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    unsigned startcode, v;\n    int ret;\n    int vol = 0;\n\n     /* search next start code */\n     align_get_bits(gb);\n \n     if (s->codec_tag == AV_RL32(\"WV1F\") && show_bits(gb, 24) == 0x575630) {\n         skip_bits(gb, 24);\n         if (get_bits(gb, 8) == 0xF0)\n            goto end;\n    }\n\n    startcode = 0xff;\n    for (;;) {\n        if (get_bits_count(gb) >= gb->size_in_bits) {\n            if (gb->size_in_bits == 8 &&\n                (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(\"QMP4\")) {\n                av_log(s->avctx, AV_LOG_VERBOSE, \"frame skip %d\\n\", gb->size_in_bits);\n                return FRAME_SKIPPED;  // divx bug\n            } else\n                return AVERROR_INVALIDDATA;  // end of stream\n        }\n\n        /* use the bits after the test */\n        v = get_bits(gb, 8);\n        startcode = ((startcode << 8) | v) & 0xffffffff;\n\n        if ((startcode & 0xFFFFFF00) != 0x100)\n            continue;  // no startcode\n\n        if (s->avctx->debug & FF_DEBUG_STARTCODE) {\n            av_log(s->avctx, AV_LOG_DEBUG, \"startcode: %3X \", startcode);\n            if (startcode <= 0x11F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Start\");\n            else if (startcode <= 0x12F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Layer Start\");\n            else if (startcode <= 0x13F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\n            else if (startcode <= 0x15F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FGS bp start\");\n            else if (startcode <= 0x1AF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\n            else if (startcode == 0x1B0)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq Start\");\n            else if (startcode == 0x1B1)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq End\");\n            else if (startcode == 0x1B2)\n                av_log(s->avctx, AV_LOG_DEBUG, \"User Data\");\n            else if (startcode == 0x1B3)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Group of VOP start\");\n            else if (startcode == 0x1B4)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Session Error\");\n            else if (startcode == 0x1B5)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Start\");\n            else if (startcode == 0x1B6)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Plane start\");\n            else if (startcode == 0x1B7)\n                av_log(s->avctx, AV_LOG_DEBUG, \"slice start\");\n            else if (startcode == 0x1B8)\n                av_log(s->avctx, AV_LOG_DEBUG, \"extension start\");\n            else if (startcode == 0x1B9)\n                av_log(s->avctx, AV_LOG_DEBUG, \"fgs start\");\n            else if (startcode == 0x1BA)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object start\");\n            else if (startcode == 0x1BB)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object Plane start\");\n            else if (startcode == 0x1BC)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object start\");\n            else if (startcode == 0x1BD)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object Plane start\");\n            else if (startcode == 0x1BE)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Still Texture Object start\");\n            else if (startcode == 0x1BF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Spatial Layer start\");\n            else if (startcode == 0x1C0)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture SNR Layer start\");\n            else if (startcode == 0x1C1)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Tile start\");\n            else if (startcode == 0x1C2)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Shape Layer start\");\n            else if (startcode == 0x1C3)\n                av_log(s->avctx, AV_LOG_DEBUG, \"stuffing start\");\n            else if (startcode <= 0x1C5)\n                av_log(s->avctx, AV_LOG_DEBUG, \"reserved\");\n            else if (startcode <= 0x1FF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"System start\");\n            av_log(s->avctx, AV_LOG_DEBUG, \" at %d\\n\", get_bits_count(gb));\n        }\n\n        if (startcode >= 0x120 && startcode <= 0x12F) {\n            if (vol) {\n                av_log(s->avctx, AV_LOG_WARNING, \"Ignoring multiple VOL headers\\n\");\n                continue;\n            }\n            vol++;\n            if ((ret = decode_vol_header(ctx, gb)) < 0)\n                return ret;\n        } else if (startcode == USER_DATA_STARTCODE) {\n            decode_user_data(ctx, gb);\n        } else if (startcode == GOP_STARTCODE) {\n            mpeg4_decode_gop_header(s, gb);\n        } else if (startcode == VOS_STARTCODE) {\n            mpeg4_decode_profile_level(s, gb);\n            if (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n                (s->avctx->level > 0 && s->avctx->level < 9)) {\n                s->studio_profile = 1;\n                next_start_code_studio(gb);\n                extension_and_user_data(s, gb, 0);\n            }\n        } else if (startcode == VISUAL_OBJ_STARTCODE) {\n            if (s->studio_profile) {\n                if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n                    return ret;\n            } else\n                mpeg4_decode_visual_object(s, gb);\n        } else if (startcode == VOP_STARTCODE) {\n            break;\n        }\n\n        align_get_bits(gb);\n        startcode = 0xff;\n    }\n\nend:\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n    s->avctx->has_b_frames = !s->low_delay;\n\n    if (s->studio_profile) {\n        if (!s->avctx->bits_per_raw_sample) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        return decode_studio_vop_header(ctx, gb);\n    } else\n        return decode_vop_header(ctx, gb);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142995,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    unsigned startcode, v;\n    int ret;\n    int vol = 0;\n\n     /* search next start code */\n     align_get_bits(gb);\n \n    // If we have not switched to studio profile than we also did not switch bps\n    // that means something else (like a previous instance) outside set bps which\n    // would be inconsistant with the currect state, thus reset it\n    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)\n        s->avctx->bits_per_raw_sample = 0;\n\n     if (s->codec_tag == AV_RL32(\"WV1F\") && show_bits(gb, 24) == 0x575630) {\n         skip_bits(gb, 24);\n         if (get_bits(gb, 8) == 0xF0)\n            goto end;\n    }\n\n    startcode = 0xff;\n    for (;;) {\n        if (get_bits_count(gb) >= gb->size_in_bits) {\n            if (gb->size_in_bits == 8 &&\n                (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(\"QMP4\")) {\n                av_log(s->avctx, AV_LOG_VERBOSE, \"frame skip %d\\n\", gb->size_in_bits);\n                return FRAME_SKIPPED;  // divx bug\n            } else\n                return AVERROR_INVALIDDATA;  // end of stream\n        }\n\n        /* use the bits after the test */\n        v = get_bits(gb, 8);\n        startcode = ((startcode << 8) | v) & 0xffffffff;\n\n        if ((startcode & 0xFFFFFF00) != 0x100)\n            continue;  // no startcode\n\n        if (s->avctx->debug & FF_DEBUG_STARTCODE) {\n            av_log(s->avctx, AV_LOG_DEBUG, \"startcode: %3X \", startcode);\n            if (startcode <= 0x11F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Start\");\n            else if (startcode <= 0x12F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Layer Start\");\n            else if (startcode <= 0x13F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\n            else if (startcode <= 0x15F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FGS bp start\");\n            else if (startcode <= 0x1AF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\n            else if (startcode == 0x1B0)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq Start\");\n            else if (startcode == 0x1B1)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq End\");\n            else if (startcode == 0x1B2)\n                av_log(s->avctx, AV_LOG_DEBUG, \"User Data\");\n            else if (startcode == 0x1B3)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Group of VOP start\");\n            else if (startcode == 0x1B4)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Session Error\");\n            else if (startcode == 0x1B5)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Start\");\n            else if (startcode == 0x1B6)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Plane start\");\n            else if (startcode == 0x1B7)\n                av_log(s->avctx, AV_LOG_DEBUG, \"slice start\");\n            else if (startcode == 0x1B8)\n                av_log(s->avctx, AV_LOG_DEBUG, \"extension start\");\n            else if (startcode == 0x1B9)\n                av_log(s->avctx, AV_LOG_DEBUG, \"fgs start\");\n            else if (startcode == 0x1BA)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object start\");\n            else if (startcode == 0x1BB)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object Plane start\");\n            else if (startcode == 0x1BC)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object start\");\n            else if (startcode == 0x1BD)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object Plane start\");\n            else if (startcode == 0x1BE)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Still Texture Object start\");\n            else if (startcode == 0x1BF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Spatial Layer start\");\n            else if (startcode == 0x1C0)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture SNR Layer start\");\n            else if (startcode == 0x1C1)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Tile start\");\n            else if (startcode == 0x1C2)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Shape Layer start\");\n            else if (startcode == 0x1C3)\n                av_log(s->avctx, AV_LOG_DEBUG, \"stuffing start\");\n            else if (startcode <= 0x1C5)\n                av_log(s->avctx, AV_LOG_DEBUG, \"reserved\");\n            else if (startcode <= 0x1FF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"System start\");\n            av_log(s->avctx, AV_LOG_DEBUG, \" at %d\\n\", get_bits_count(gb));\n        }\n\n        if (startcode >= 0x120 && startcode <= 0x12F) {\n            if (vol) {\n                av_log(s->avctx, AV_LOG_WARNING, \"Ignoring multiple VOL headers\\n\");\n                continue;\n            }\n            vol++;\n            if ((ret = decode_vol_header(ctx, gb)) < 0)\n                return ret;\n        } else if (startcode == USER_DATA_STARTCODE) {\n            decode_user_data(ctx, gb);\n        } else if (startcode == GOP_STARTCODE) {\n            mpeg4_decode_gop_header(s, gb);\n        } else if (startcode == VOS_STARTCODE) {\n            mpeg4_decode_profile_level(s, gb);\n            if (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n                (s->avctx->level > 0 && s->avctx->level < 9)) {\n                s->studio_profile = 1;\n                next_start_code_studio(gb);\n                extension_and_user_data(s, gb, 0);\n            }\n        } else if (startcode == VISUAL_OBJ_STARTCODE) {\n            if (s->studio_profile) {\n                if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n                    return ret;\n            } else\n                mpeg4_decode_visual_object(s, gb);\n        } else if (startcode == VOP_STARTCODE) {\n            break;\n        }\n\n        align_get_bits(gb);\n        startcode = 0xff;\n    }\n\nend:\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n    s->avctx->has_b_frames = !s->low_delay;\n\n    if (s->studio_profile) {\n        if (!s->avctx->bits_per_raw_sample) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        return decode_studio_vop_header(ctx, gb);\n    } else\n        return decode_vop_header(ctx, gb);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142996,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void *etm_setup_aux(int event_cpu, void **pages,\n\t\t\t   int nr_pages, bool overwrite)\n{\n\tint cpu;\n\tcpumask_t *mask;\n\tstruct coresight_device *sink;\n\tstruct etm_event_data *event_data = NULL;\n\n\tevent_data = alloc_event_data(event_cpu);\n\tif (!event_data)\n\t\treturn NULL;\n\n\t/*\n\t * In theory nothing prevent tracers in a trace session from being\n\t * associated with different sinks, nor having a sink per tracer.  But\n\t * until we have HW with this kind of topology we need to assume tracers\n\t * in a trace session are using the same sink.  Therefore go through\n\t * the coresight bus and pick the first enabled sink.\n\t *\n\t * When operated from sysFS users are responsible to enable the sink\n\t * while from perf, the perf tools will do it based on the choice made\n\t * on the cmd line.  As such the \"enable_sink\" flag in sysFS is reset.\n\t */\n\tsink = coresight_get_enabled_sink(true);\n\tif (!sink)\n\t\tgoto err;\n\n\tINIT_WORK(&event_data->work, free_event_data);\n\n\tmask = &event_data->mask;\n\n\t/* Setup the path for each CPU in a trace session */\n\tfor_each_cpu(cpu, mask) {\n\t\tstruct coresight_device *csdev;\n\n\t\tcsdev = per_cpu(csdev_src, cpu);\n\t\tif (!csdev)\n\t\t\tgoto err;\n\n\t\t/*\n\t\t * Building a path doesn't enable it, it simply builds a\n\t\t * list of devices from source to sink that can be\n\t\t * referenced later when the path is actually needed.\n\t\t */\n\t\tevent_data->path[cpu] = coresight_build_path(csdev, sink);\n\t\tif (IS_ERR(event_data->path[cpu]))\n\t\t\tgoto err;\n\t}\n\n \tif (!sink_ops(sink)->alloc_buffer)\n \t\tgoto err;\n \n \t/* Get the AUX specific data from the sink buffer */\n \tevent_data->snk_config =\n \t\t\tsink_ops(sink)->alloc_buffer(sink, cpu, pages,\n\t\t\t\t\t\t     nr_pages, overwrite);\n\tif (!event_data->snk_config)\n\t\tgoto err;\n\nout:\n\treturn event_data;\n\nerr:\n\tetm_free_aux(event_data);\n\tevent_data = NULL;\n\tgoto out;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143029,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void *etm_setup_aux(int event_cpu, void **pages,\n\t\t\t   int nr_pages, bool overwrite)\n{\n\tint cpu;\n\tcpumask_t *mask;\n\tstruct coresight_device *sink;\n\tstruct etm_event_data *event_data = NULL;\n\n\tevent_data = alloc_event_data(event_cpu);\n\tif (!event_data)\n\t\treturn NULL;\n\n\t/*\n\t * In theory nothing prevent tracers in a trace session from being\n\t * associated with different sinks, nor having a sink per tracer.  But\n\t * until we have HW with this kind of topology we need to assume tracers\n\t * in a trace session are using the same sink.  Therefore go through\n\t * the coresight bus and pick the first enabled sink.\n\t *\n\t * When operated from sysFS users are responsible to enable the sink\n\t * while from perf, the perf tools will do it based on the choice made\n\t * on the cmd line.  As such the \"enable_sink\" flag in sysFS is reset.\n\t */\n\tsink = coresight_get_enabled_sink(true);\n\tif (!sink)\n\t\tgoto err;\n\n\tINIT_WORK(&event_data->work, free_event_data);\n\n\tmask = &event_data->mask;\n\n\t/* Setup the path for each CPU in a trace session */\n\tfor_each_cpu(cpu, mask) {\n\t\tstruct coresight_device *csdev;\n\n\t\tcsdev = per_cpu(csdev_src, cpu);\n\t\tif (!csdev)\n\t\t\tgoto err;\n\n\t\t/*\n\t\t * Building a path doesn't enable it, it simply builds a\n\t\t * list of devices from source to sink that can be\n\t\t * referenced later when the path is actually needed.\n\t\t */\n\t\tevent_data->path[cpu] = coresight_build_path(csdev, sink);\n\t\tif (IS_ERR(event_data->path[cpu]))\n\t\t\tgoto err;\n\t}\n\n \tif (!sink_ops(sink)->alloc_buffer)\n \t\tgoto err;\n \n\tcpu = cpumask_first(mask);\n \t/* Get the AUX specific data from the sink buffer */\n \tevent_data->snk_config =\n \t\t\tsink_ops(sink)->alloc_buffer(sink, cpu, pages,\n\t\t\t\t\t\t     nr_pages, overwrite);\n\tif (!event_data->snk_config)\n\t\tgoto err;\n\nout:\n\treturn event_data;\n\nerr:\n\tetm_free_aux(event_data);\n\tevent_data = NULL;\n\tgoto out;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143030,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "add_job(cupsd_client_t  *con,\t\t/* I - Client connection */\n\tcupsd_printer_t *printer,\t/* I - Destination printer */\n\tmime_type_t     *filetype)\t/* I - First print file type, if any */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  ipp_attribute_t *attr,\t\t/* Current attribute */\n\t\t*auth_info;\t\t/* auth-info attribute */\n  const char\t*mandatory;\t\t/* Current mandatory job attribute */\n  const char\t*val;\t\t\t/* Default option value */\n  int\t\tpriority;\t\t/* Job priority */\n  cupsd_job_t\t*job;\t\t\t/* Current job */\n  char\t\tjob_uri[HTTP_MAX_URI];\t/* Job URI */\n  int\t\tkbytes;\t\t\t/* Size of print file */\n  int\t\ti;\t\t\t/* Looping var */\n  int\t\tlowerpagerange;\t\t/* Page range bound */\n  int\t\texact;\t\t\t/* Did we have an exact match? */\n  ipp_attribute_t *media_col,\t\t/* media-col attribute */\n\t\t*media_margin;\t\t/* media-*-margin attribute */\n  ipp_t\t\t*unsup_col;\t\t/* media-col in unsupported response */\n  static const char * const readonly[] =/* List of read-only attributes */\n  {\n    \"date-time-at-completed\",\n    \"date-time-at-creation\",\n    \"date-time-at-processing\",\n    \"job-detailed-status-messages\",\n    \"job-document-access-errors\",\n    \"job-id\",\n    \"job-impressions-completed\",\n    \"job-k-octets-completed\",\n    \"job-media-sheets-completed\",\n    \"job-pages-completed\",\n    \"job-printer-up-time\",\n    \"job-printer-uri\",\n    \"job-state\",\n    \"job-state-message\",\n    \"job-state-reasons\",\n    \"job-uri\",\n    \"number-of-documents\",\n    \"number-of-intervening-jobs\",\n    \"output-device-assigned\",\n    \"time-at-completed\",\n    \"time-at-creation\",\n    \"time-at-processing\"\n  };\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"add_job(%p[%d], %p(%s), %p(%s/%s))\",\n                  con, con->number, printer, printer->name,\n\t\t  filetype, filetype ? filetype->super : \"none\",\n\t\t  filetype ? filetype->type : \"none\");\n\n /*\n  * Check remote printing to non-shared printer...\n  */\n\n  if (!printer->shared &&\n      _cups_strcasecmp(con->http->hostname, \"localhost\") &&\n      _cups_strcasecmp(con->http->hostname, ServerName))\n  {\n    send_ipp_status(con, IPP_NOT_AUTHORIZED,\n                    _(\"The printer or class is not shared.\"));\n    return (NULL);\n  }\n\n /*\n  * Check policy...\n  */\n\n  auth_info = ippFindAttribute(con->request, \"auth-info\", IPP_TAG_TEXT);\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return (NULL);\n  }\n  else if (printer->num_auth_info_required == 1 &&\n           !strcmp(printer->auth_info_required[0], \"negotiate\") &&\n           !con->username[0])\n  {\n    send_http_error(con, HTTP_UNAUTHORIZED, printer);\n    return (NULL);\n  }\n#ifdef HAVE_SSL\n  else if (auth_info && !con->http->tls &&\n           !httpAddrLocalhost(con->http->hostaddr))\n  {\n   /*\n    * Require encryption of auth-info over non-local connections...\n    */\n\n    send_http_error(con, HTTP_UPGRADE_REQUIRED, printer);\n    return (NULL);\n  }\n#endif /* HAVE_SSL */\n\n /*\n  * See if the printer is accepting jobs...\n  */\n\n  if (!printer->accepting)\n  {\n    send_ipp_status(con, IPP_NOT_ACCEPTING,\n                    _(\"Destination \\\"%s\\\" is not accepting jobs.\"),\n                    printer->name);\n    return (NULL);\n  }\n\n /*\n  * Validate job template attributes; for now just document-format,\n  * copies, job-sheets, number-up, page-ranges, mandatory attributes, and\n  * media...\n  */\n\n  for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++)\n  {\n    if ((attr = ippFindAttribute(con->request, readonly[i], IPP_TAG_ZERO)) != NULL)\n    {\n      ippDeleteAttribute(con->request, attr);\n\n      if (StrictConformance)\n      {\n\tsend_ipp_status(con, IPP_BAD_REQUEST, _(\"The '%s' Job Status attribute cannot be supplied in a job creation request.\"), readonly[i]);\n\treturn (NULL);\n      }\n\n      cupsdLogMessage(CUPSD_LOG_INFO, \"Unexpected '%s' Job Status attribute in a job creation request.\", readonly[i]);\n    }\n  }\n\n  if (printer->pc)\n  {\n    for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);\n\t mandatory;\n\t mandatory = (char *)cupsArrayNext(printer->pc->mandatory))\n    {\n      if (!ippFindAttribute(con->request, mandatory, IPP_TAG_ZERO))\n      {\n       /*\n\t* Missing a required attribute...\n\t*/\n\n\tsend_ipp_status(con, IPP_CONFLICT,\n\t\t\t_(\"The \\\"%s\\\" attribute is required for print jobs.\"),\n\t\t\tmandatory);\n\treturn (NULL);\n      }\n    }\n  }\n\n  if (filetype && printer->filetypes &&\n      !cupsArrayFind(printer->filetypes, filetype))\n  {\n    char\tmimetype[MIME_MAX_SUPER + MIME_MAX_TYPE + 2];\n\t\t\t\t\t/* MIME media type string */\n\n\n    snprintf(mimetype, sizeof(mimetype), \"%s/%s\", filetype->super,\n             filetype->type);\n\n    send_ipp_status(con, IPP_DOCUMENT_FORMAT,\n                    _(\"Unsupported format \\\"%s\\\".\"), mimetype);\n\n    ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_MIMETYPE,\n                 \"document-format\", NULL, mimetype);\n\n    return (NULL);\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"copies\",\n                               IPP_TAG_INTEGER)) != NULL)\n  {\n    if (attr->values[0].integer < 1 || attr->values[0].integer > MaxCopies)\n    {\n      send_ipp_status(con, IPP_ATTRIBUTES, _(\"Bad copies value %d.\"),\n                      attr->values[0].integer);\n      ippAddInteger(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_INTEGER,\n\t            \"copies\", attr->values[0].integer);\n      return (NULL);\n    }\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"job-sheets\",\n                               IPP_TAG_ZERO)) != NULL)\n  {\n    if (attr->value_tag != IPP_TAG_KEYWORD &&\n        attr->value_tag != IPP_TAG_NAME)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-sheets value type.\"));\n      return (NULL);\n    }\n\n    if (attr->num_values > 2)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Too many job-sheets values (%d > 2).\"),\n\t\t      attr->num_values);\n      return (NULL);\n    }\n\n    for (i = 0; i < attr->num_values; i ++)\n      if (strcmp(attr->values[i].string.text, \"none\") &&\n          !cupsdFindBanner(attr->values[i].string.text))\n      {\n\tsend_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-sheets value \\\"%s\\\".\"),\n\t\t\tattr->values[i].string.text);\n\treturn (NULL);\n      }\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"number-up\",\n                               IPP_TAG_INTEGER)) != NULL)\n  {\n    if (attr->values[0].integer != 1 &&\n        attr->values[0].integer != 2 &&\n        attr->values[0].integer != 4 &&\n        attr->values[0].integer != 6 &&\n        attr->values[0].integer != 9 &&\n        attr->values[0].integer != 16)\n    {\n      send_ipp_status(con, IPP_ATTRIBUTES, _(\"Bad number-up value %d.\"),\n                      attr->values[0].integer);\n      ippAddInteger(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_INTEGER,\n\t            \"number-up\", attr->values[0].integer);\n      return (NULL);\n    }\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"page-ranges\",\n                               IPP_TAG_RANGE)) != NULL)\n  {\n    for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++)\n    {\n      if (attr->values[i].range.lower < lowerpagerange ||\n\t  attr->values[i].range.lower > attr->values[i].range.upper)\n      {\n\tsend_ipp_status(con, IPP_BAD_REQUEST,\n\t                _(\"Bad page-ranges values %d-%d.\"),\n\t                attr->values[i].range.lower,\n\t\t\tattr->values[i].range.upper);\n\treturn (NULL);\n      }\n\n      lowerpagerange = attr->values[i].range.upper + 1;\n    }\n  }\n\n /*\n  * Do media selection as needed...\n  */\n\n  if (!ippFindAttribute(con->request, \"PageRegion\", IPP_TAG_ZERO) &&\n      !ippFindAttribute(con->request, \"PageSize\", IPP_TAG_ZERO) &&\n      _ppdCacheGetPageSize(printer->pc, con->request, NULL, &exact))\n  {\n    if (!exact &&\n        (media_col = ippFindAttribute(con->request, \"media-col\",\n\t                              IPP_TAG_BEGIN_COLLECTION)) != NULL)\n    {\n      send_ipp_status(con, IPP_OK_SUBST, _(\"Unsupported margins.\"));\n\n      unsup_col = ippNew();\n      if ((media_margin = ippFindAttribute(media_col->values[0].collection,\n                                           \"media-bottom-margin\",\n\t\t\t\t\t   IPP_TAG_INTEGER)) != NULL)\n        ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,\n\t              \"media-bottom-margin\", media_margin->values[0].integer);\n\n      if ((media_margin = ippFindAttribute(media_col->values[0].collection,\n                                           \"media-left-margin\",\n\t\t\t\t\t   IPP_TAG_INTEGER)) != NULL)\n        ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,\n\t              \"media-left-margin\", media_margin->values[0].integer);\n\n      if ((media_margin = ippFindAttribute(media_col->values[0].collection,\n                                           \"media-right-margin\",\n\t\t\t\t\t   IPP_TAG_INTEGER)) != NULL)\n        ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,\n\t              \"media-right-margin\", media_margin->values[0].integer);\n\n      if ((media_margin = ippFindAttribute(media_col->values[0].collection,\n                                           \"media-top-margin\",\n\t\t\t\t\t   IPP_TAG_INTEGER)) != NULL)\n        ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,\n\t              \"media-top-margin\", media_margin->values[0].integer);\n\n      ippAddCollection(con->response, IPP_TAG_UNSUPPORTED_GROUP, \"media-col\",\n                       unsup_col);\n      ippDelete(unsup_col);\n    }\n  }\n\n /*\n  * Make sure we aren't over our limit...\n  */\n\n  if (MaxJobs && cupsArrayCount(Jobs) >= MaxJobs)\n    cupsdCleanJobs();\n\n  if (MaxJobs && cupsArrayCount(Jobs) >= MaxJobs)\n  {\n    send_ipp_status(con, IPP_NOT_POSSIBLE, _(\"Too many active jobs.\"));\n    return (NULL);\n  }\n\n  if ((i = check_quotas(con, printer)) < 0)\n  {\n    send_ipp_status(con, IPP_NOT_POSSIBLE, _(\"Quota limit reached.\"));\n    return (NULL);\n  }\n  else if (i == 0)\n  {\n    send_ipp_status(con, IPP_NOT_AUTHORIZED, _(\"Not allowed to print.\"));\n    return (NULL);\n  }\n\n /*\n  * Create the job and set things up...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"job-priority\",\n                               IPP_TAG_INTEGER)) != NULL)\n    priority = attr->values[0].integer;\n  else\n  {\n    if ((val = cupsGetOption(\"job-priority\", printer->num_options,\n                             printer->options)) != NULL)\n      priority = atoi(val);\n    else\n      priority = 50;\n\n    ippAddInteger(con->request, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-priority\",\n                  priority);\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"job-name\", IPP_TAG_ZERO)) == NULL)\n    ippAddString(con->request, IPP_TAG_JOB, IPP_TAG_NAME, \"job-name\", NULL, \"Untitled\");\n  else if ((attr->value_tag != IPP_TAG_NAME &&\n            attr->value_tag != IPP_TAG_NAMELANG) ||\n           attr->num_values != 1)\n  {\n    send_ipp_status(con, IPP_ATTRIBUTES,\n                    _(\"Bad job-name value: Wrong type or count.\"));\n    if ((attr = ippCopyAttribute(con->response, attr, 0)) != NULL)\n      attr->group_tag = IPP_TAG_UNSUPPORTED_GROUP;\n    return (NULL);\n  }\n  else if (!ippValidateAttribute(attr))\n  {\n    send_ipp_status(con, IPP_ATTRIBUTES, _(\"Bad job-name value: %s\"),\n                    cupsLastErrorString());\n    if ((attr = ippCopyAttribute(con->response, attr, 0)) != NULL)\n      attr->group_tag = IPP_TAG_UNSUPPORTED_GROUP;\n     return (NULL);\n   }\n \n   if ((job = cupsdAddJob(priority, printer->name)) == NULL)\n   {\n     send_ipp_status(con, IPP_INTERNAL_ERROR,\n                    _(\"Unable to add job for destination \\\"%s\\\".\"),\n\t\t    printer->name);\n    return (NULL);\n  }\n\n  job->dtype   = printer->type & (CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE);\n  job->attrs   = con->request;\n  job->dirty   = 1;\n  con->request = ippNewRequest(job->attrs->request.op.operation_id);\n\n  cupsdMarkDirty(CUPSD_DIRTY_JOBS);\n\n   add_job_uuid(job);\n   apply_printer_defaults(printer, job);\n \n  attr = ippFindAttribute(job->attrs, \"requesting-user-name\", IPP_TAG_NAME);\n   if (con->username[0])\n   {\n     cupsdSetString(&job->username, con->username);\n\n    if (attr)\n      ippSetString(job->attrs, &attr, 0, con->username);\n  }\n  else if (attr)\n  {\n    cupsdLogMessage(CUPSD_LOG_DEBUG,\n                    \"add_job: requesting-user-name=\\\"%s\\\"\",\n                    attr->values[0].string.text);\n\n    cupsdSetString(&job->username, attr->values[0].string.text);\n  }\n  else\n    cupsdSetString(&job->username, \"anonymous\");\n\n  if (!attr)\n    ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME,\n                 \"job-originating-user-name\", NULL, job->username);\n  else\n  {\n    ippSetGroupTag(job->attrs, &attr, IPP_TAG_JOB);\n    ippSetName(job->attrs, &attr, \"job-originating-user-name\");\n  }\n\n  if (con->username[0] || auth_info)\n  {\n    save_auth_info(con, job, auth_info);\n\n   /*\n    * Remove the auth-info attribute from the attribute data...\n    */\n\n    if (auth_info)\n      ippDeleteAttribute(job->attrs, auth_info);\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"job-name\", IPP_TAG_NAME)) != NULL)\n    cupsdSetString(&(job->name), attr->values[0].string.text);\n\n  if ((attr = ippFindAttribute(job->attrs, \"job-originating-host-name\",\n                               IPP_TAG_ZERO)) != NULL)\n  {\n   /*\n    * Request contains a job-originating-host-name attribute; validate it...\n    */\n\n    if (attr->value_tag != IPP_TAG_NAME ||\n        attr->num_values != 1 ||\n        strcmp(con->http->hostname, \"localhost\"))\n    {\n     /*\n      * Can't override the value if we aren't connected via localhost.\n      * Also, we can only have 1 value and it must be a name value.\n      */\n\n      ippDeleteAttribute(job->attrs, attr);\n      ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME, \"job-originating-host-name\", NULL, con->http->hostname);\n    }\n    else\n      ippSetGroupTag(job->attrs, &attr, IPP_TAG_JOB);\n  }\n  else\n  {\n   /*\n    * No job-originating-host-name attribute, so use the hostname from\n    * the connection...\n    */\n\n    ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME,\n        \t \"job-originating-host-name\", NULL, con->http->hostname);\n  }\n\n  ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, \"date-time-at-completed\");\n  ippAddDate(job->attrs, IPP_TAG_JOB, \"date-time-at-creation\", ippTimeToDate(time(NULL)));\n  ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, \"date-time-at-processing\");\n  ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, \"time-at-completed\");\n  ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, \"time-at-creation\", time(NULL));\n  ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, \"time-at-processing\");\n\n /*\n  * Add remaining job attributes...\n  */\n\n  ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-id\", job->id);\n  job->state = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_ENUM,\n                             \"job-state\", IPP_JOB_STOPPED);\n  job->state_value = (ipp_jstate_t)job->state->values[0].integer;\n  job->reasons = ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_KEYWORD,\n                              \"job-state-reasons\", NULL, \"job-incoming\");\n  job->impressions = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-impressions-completed\", 0);\n  job->sheets = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER,\n                              \"job-media-sheets-completed\", 0);\n  ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_URI, \"job-printer-uri\", NULL,\n               printer->uri);\n\n  if ((attr = ippFindAttribute(job->attrs, \"job-k-octets\", IPP_TAG_INTEGER)) != NULL)\n    attr->values[0].integer = 0;\n  else\n    ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-k-octets\", 0);\n\n  if ((attr = ippFindAttribute(job->attrs, \"job-hold-until\",\n                               IPP_TAG_KEYWORD)) == NULL)\n    attr = ippFindAttribute(job->attrs, \"job-hold-until\", IPP_TAG_NAME);\n  if (!attr)\n  {\n    if ((val = cupsGetOption(\"job-hold-until\", printer->num_options,\n                             printer->options)) == NULL)\n      val = \"no-hold\";\n\n    attr = ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_KEYWORD,\n                        \"job-hold-until\", NULL, val);\n  }\n\n  if (printer->holding_new_jobs)\n  {\n   /*\n    * Hold all new jobs on this printer...\n    */\n\n    if (attr && strcmp(attr->values[0].string.text, \"no-hold\"))\n      cupsdSetJobHoldUntil(job, ippGetString(attr, 0, NULL), 0);\n    else\n      cupsdSetJobHoldUntil(job, \"indefinite\", 0);\n\n    job->state->values[0].integer = IPP_JOB_HELD;\n    job->state_value              = IPP_JOB_HELD;\n\n    ippSetString(job->attrs, &job->reasons, 0, \"job-held-on-create\");\n  }\n  else if (attr && strcmp(attr->values[0].string.text, \"no-hold\"))\n  {\n   /*\n    * Hold job until specified time...\n    */\n\n    cupsdSetJobHoldUntil(job, attr->values[0].string.text, 0);\n\n    job->state->values[0].integer = IPP_JOB_HELD;\n    job->state_value              = IPP_JOB_HELD;\n\n    ippSetString(job->attrs, &job->reasons, 0, \"job-hold-until-specified\");\n  }\n  else if (job->attrs->request.op.operation_id == IPP_CREATE_JOB)\n  {\n    job->hold_until               = time(NULL) + MultipleOperationTimeout;\n    job->state->values[0].integer = IPP_JOB_HELD;\n    job->state_value              = IPP_JOB_HELD;\n  }\n  else\n  {\n    job->state->values[0].integer = IPP_JOB_PENDING;\n    job->state_value              = IPP_JOB_PENDING;\n\n    ippSetString(job->attrs, &job->reasons, 0, \"none\");\n  }\n\n  if (!(printer->type & CUPS_PRINTER_REMOTE) || Classification)\n  {\n   /*\n    * Add job sheets options...\n    */\n\n    if ((attr = ippFindAttribute(job->attrs, \"job-sheets\",\n                                 IPP_TAG_ZERO)) == NULL)\n    {\n      cupsdLogMessage(CUPSD_LOG_DEBUG,\n                      \"Adding default job-sheets values \\\"%s,%s\\\"...\",\n                      printer->job_sheets[0], printer->job_sheets[1]);\n\n      attr = ippAddStrings(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME, \"job-sheets\",\n                           2, NULL, NULL);\n      ippSetString(job->attrs, &attr, 0, printer->job_sheets[0]);\n      ippSetString(job->attrs, &attr, 1, printer->job_sheets[1]);\n    }\n\n    job->job_sheets = attr;\n\n   /*\n    * Enforce classification level if set...\n    */\n\n    if (Classification)\n    {\n      cupsdLogMessage(CUPSD_LOG_INFO,\n                      \"Classification=\\\"%s\\\", ClassifyOverride=%d\",\n                      Classification ? Classification : \"(null)\",\n\t\t      ClassifyOverride);\n\n      if (ClassifyOverride)\n      {\n        if (!strcmp(attr->values[0].string.text, \"none\") &&\n\t    (attr->num_values == 1 ||\n\t     !strcmp(attr->values[1].string.text, \"none\")))\n        {\n\t /*\n          * Force the leading banner to have the classification on it...\n\t  */\n\n          ippSetString(job->attrs, &attr, 0, Classification);\n\n\t  cupsdLogJob(job, CUPSD_LOG_NOTICE, \"CLASSIFICATION FORCED \"\n\t                \t\t     \"job-sheets=\\\"%s,none\\\", \"\n\t\t\t\t\t     \"job-originating-user-name=\\\"%s\\\"\",\n\t              Classification, job->username);\n\t}\n\telse if (attr->num_values == 2 &&\n\t         strcmp(attr->values[0].string.text,\n\t\t        attr->values[1].string.text) &&\n\t\t strcmp(attr->values[0].string.text, \"none\") &&\n\t\t strcmp(attr->values[1].string.text, \"none\"))\n        {\n\t /*\n\t  * Can't put two different security markings on the same document!\n\t  */\n\n          ippSetString(job->attrs, &attr, 1, attr->values[0].string.text);\n\n\t  cupsdLogJob(job, CUPSD_LOG_NOTICE, \"CLASSIFICATION FORCED \"\n\t                \t\t     \"job-sheets=\\\"%s,%s\\\", \"\n\t\t\t\t\t     \"job-originating-user-name=\\\"%s\\\"\",\n\t\t      attr->values[0].string.text,\n\t\t      attr->values[1].string.text, job->username);\n\t}\n\telse if (strcmp(attr->values[0].string.text, Classification) &&\n\t         strcmp(attr->values[0].string.text, \"none\") &&\n\t\t (attr->num_values == 1 ||\n\t          (strcmp(attr->values[1].string.text, Classification) &&\n\t           strcmp(attr->values[1].string.text, \"none\"))))\n        {\n\t  if (attr->num_values == 1)\n            cupsdLogJob(job, CUPSD_LOG_NOTICE,\n\t\t\t\"CLASSIFICATION OVERRIDDEN \"\n\t\t\t\"job-sheets=\\\"%s\\\", \"\n\t\t\t\"job-originating-user-name=\\\"%s\\\"\",\n\t                attr->values[0].string.text, job->username);\n          else\n            cupsdLogJob(job, CUPSD_LOG_NOTICE,\n\t\t\t\"CLASSIFICATION OVERRIDDEN \"\n\t\t\t\"job-sheets=\\\"%s,%s\\\",fffff \"\n\t\t\t\"job-originating-user-name=\\\"%s\\\"\",\n\t\t\tattr->values[0].string.text,\n\t\t\tattr->values[1].string.text, job->username);\n        }\n      }\n      else if (strcmp(attr->values[0].string.text, Classification) &&\n               (attr->num_values == 1 ||\n\t       strcmp(attr->values[1].string.text, Classification)))\n      {\n       /*\n        * Force the banner to have the classification on it...\n\t*/\n\n        if (attr->num_values > 1 &&\n\t    !strcmp(attr->values[0].string.text, attr->values[1].string.text))\n\t{\n          ippSetString(job->attrs, &attr, 0, Classification);\n          ippSetString(job->attrs, &attr, 1, Classification);\n\t}\n        else\n\t{\n          if (attr->num_values == 1 ||\n\t      strcmp(attr->values[0].string.text, \"none\"))\n            ippSetString(job->attrs, &attr, 0, Classification);\n\n          if (attr->num_values > 1 &&\n\t      strcmp(attr->values[1].string.text, \"none\"))\n\t    ippSetString(job->attrs, &attr, 1, Classification);\n        }\n\n        if (attr->num_values > 1)\n\t  cupsdLogJob(job, CUPSD_LOG_NOTICE,\n\t\t      \"CLASSIFICATION FORCED \"\n\t\t      \"job-sheets=\\\"%s,%s\\\", \"\n\t\t      \"job-originating-user-name=\\\"%s\\\"\",\n\t\t      attr->values[0].string.text,\n\t\t      attr->values[1].string.text, job->username);\n        else\n\t  cupsdLogJob(job, CUPSD_LOG_NOTICE,\n\t\t      \"CLASSIFICATION FORCED \"\n\t\t      \"job-sheets=\\\"%s\\\", \"\n\t\t      \"job-originating-user-name=\\\"%s\\\"\",\n\t\t      Classification, job->username);\n      }\n    }\n\n   /*\n    * See if we need to add the starting sheet...\n    */\n\n    if (!(printer->type & CUPS_PRINTER_REMOTE))\n    {\n      cupsdLogJob(job, CUPSD_LOG_INFO, \"Adding start banner page \\\"%s\\\".\",\n\t\t  attr->values[0].string.text);\n\n      if ((kbytes = copy_banner(con, job, attr->values[0].string.text)) < 0)\n      {\n        cupsdSetJobState(job, IPP_JOB_ABORTED, CUPSD_JOB_PURGE,\n\t                 \"Aborting job because the start banner could not be \"\n\t\t\t \"copied.\");\n        return (NULL);\n      }\n\n      cupsdUpdateQuota(printer, job->username, 0, kbytes);\n    }\n  }\n  else if ((attr = ippFindAttribute(job->attrs, \"job-sheets\",\n                                    IPP_TAG_ZERO)) != NULL)\n    job->job_sheets = attr;\n\n /*\n  * Fill in the response info...\n  */\n\n  httpAssembleURIf(HTTP_URI_CODING_ALL, job_uri, sizeof(job_uri), \"ipp\", NULL,\n                   con->clientname, con->clientport, \"/jobs/%d\", job->id);\n  ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_URI, \"job-uri\", NULL,\n               job_uri);\n\n  ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-id\", job->id);\n\n  ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_ENUM, \"job-state\",\n                job->state_value);\n  ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_TEXT, \"job-state-message\", NULL, \"\");\n  ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_KEYWORD, \"job-state-reasons\",\n               NULL, job->reasons->values[0].string.text);\n\n  con->response->request.status.status_code = IPP_OK;\n\n /*\n  * Add any job subscriptions...\n  */\n\n  add_job_subscriptions(con, job);\n\n /*\n  * Set all but the first two attributes to the job attributes group...\n  */\n\n  for (attr = job->attrs->attrs->next->next; attr; attr = attr->next)\n    attr->group_tag = IPP_TAG_JOB;\n\n /*\n  * Fire the \"job created\" event...\n  */\n\n  cupsdAddEvent(CUPSD_EVENT_JOB_CREATED, printer, job, \"Job created.\");\n\n /*\n  * Return the new job...\n  */\n\n  return (job);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143115,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "add_job(cupsd_client_t  *con,\t\t/* I - Client connection */\n\tcupsd_printer_t *printer,\t/* I - Destination printer */\n\tmime_type_t     *filetype)\t/* I - First print file type, if any */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  ipp_attribute_t *attr,\t\t/* Current attribute */\n\t\t*auth_info;\t\t/* auth-info attribute */\n  const char\t*mandatory;\t\t/* Current mandatory job attribute */\n  const char\t*val;\t\t\t/* Default option value */\n  int\t\tpriority;\t\t/* Job priority */\n  cupsd_job_t\t*job;\t\t\t/* Current job */\n  char\t\tjob_uri[HTTP_MAX_URI];\t/* Job URI */\n  int\t\tkbytes;\t\t\t/* Size of print file */\n  int\t\ti;\t\t\t/* Looping var */\n  int\t\tlowerpagerange;\t\t/* Page range bound */\n  int\t\texact;\t\t\t/* Did we have an exact match? */\n  ipp_attribute_t *media_col,\t\t/* media-col attribute */\n\t\t*media_margin;\t\t/* media-*-margin attribute */\n  ipp_t\t\t*unsup_col;\t\t/* media-col in unsupported response */\n  static const char * const readonly[] =/* List of read-only attributes */\n  {\n    \"date-time-at-completed\",\n    \"date-time-at-creation\",\n    \"date-time-at-processing\",\n    \"job-detailed-status-messages\",\n    \"job-document-access-errors\",\n    \"job-id\",\n    \"job-impressions-completed\",\n    \"job-k-octets-completed\",\n    \"job-media-sheets-completed\",\n    \"job-pages-completed\",\n    \"job-printer-up-time\",\n    \"job-printer-uri\",\n    \"job-state\",\n    \"job-state-message\",\n    \"job-state-reasons\",\n    \"job-uri\",\n    \"number-of-documents\",\n    \"number-of-intervening-jobs\",\n    \"output-device-assigned\",\n    \"time-at-completed\",\n    \"time-at-creation\",\n    \"time-at-processing\"\n  };\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"add_job(%p[%d], %p(%s), %p(%s/%s))\",\n                  con, con->number, printer, printer->name,\n\t\t  filetype, filetype ? filetype->super : \"none\",\n\t\t  filetype ? filetype->type : \"none\");\n\n /*\n  * Check remote printing to non-shared printer...\n  */\n\n  if (!printer->shared &&\n      _cups_strcasecmp(con->http->hostname, \"localhost\") &&\n      _cups_strcasecmp(con->http->hostname, ServerName))\n  {\n    send_ipp_status(con, IPP_NOT_AUTHORIZED,\n                    _(\"The printer or class is not shared.\"));\n    return (NULL);\n  }\n\n /*\n  * Check policy...\n  */\n\n  auth_info = ippFindAttribute(con->request, \"auth-info\", IPP_TAG_TEXT);\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return (NULL);\n  }\n  else if (printer->num_auth_info_required == 1 &&\n           !strcmp(printer->auth_info_required[0], \"negotiate\") &&\n           !con->username[0])\n  {\n    send_http_error(con, HTTP_UNAUTHORIZED, printer);\n    return (NULL);\n  }\n#ifdef HAVE_SSL\n  else if (auth_info && !con->http->tls &&\n           !httpAddrLocalhost(con->http->hostaddr))\n  {\n   /*\n    * Require encryption of auth-info over non-local connections...\n    */\n\n    send_http_error(con, HTTP_UPGRADE_REQUIRED, printer);\n    return (NULL);\n  }\n#endif /* HAVE_SSL */\n\n /*\n  * See if the printer is accepting jobs...\n  */\n\n  if (!printer->accepting)\n  {\n    send_ipp_status(con, IPP_NOT_ACCEPTING,\n                    _(\"Destination \\\"%s\\\" is not accepting jobs.\"),\n                    printer->name);\n    return (NULL);\n  }\n\n /*\n  * Validate job template attributes; for now just document-format,\n  * copies, job-sheets, number-up, page-ranges, mandatory attributes, and\n  * media...\n  */\n\n  for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++)\n  {\n    if ((attr = ippFindAttribute(con->request, readonly[i], IPP_TAG_ZERO)) != NULL)\n    {\n      ippDeleteAttribute(con->request, attr);\n\n      if (StrictConformance)\n      {\n\tsend_ipp_status(con, IPP_BAD_REQUEST, _(\"The '%s' Job Status attribute cannot be supplied in a job creation request.\"), readonly[i]);\n\treturn (NULL);\n      }\n\n      cupsdLogMessage(CUPSD_LOG_INFO, \"Unexpected '%s' Job Status attribute in a job creation request.\", readonly[i]);\n    }\n  }\n\n  if (printer->pc)\n  {\n    for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);\n\t mandatory;\n\t mandatory = (char *)cupsArrayNext(printer->pc->mandatory))\n    {\n      if (!ippFindAttribute(con->request, mandatory, IPP_TAG_ZERO))\n      {\n       /*\n\t* Missing a required attribute...\n\t*/\n\n\tsend_ipp_status(con, IPP_CONFLICT,\n\t\t\t_(\"The \\\"%s\\\" attribute is required for print jobs.\"),\n\t\t\tmandatory);\n\treturn (NULL);\n      }\n    }\n  }\n\n  if (filetype && printer->filetypes &&\n      !cupsArrayFind(printer->filetypes, filetype))\n  {\n    char\tmimetype[MIME_MAX_SUPER + MIME_MAX_TYPE + 2];\n\t\t\t\t\t/* MIME media type string */\n\n\n    snprintf(mimetype, sizeof(mimetype), \"%s/%s\", filetype->super,\n             filetype->type);\n\n    send_ipp_status(con, IPP_DOCUMENT_FORMAT,\n                    _(\"Unsupported format \\\"%s\\\".\"), mimetype);\n\n    ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_MIMETYPE,\n                 \"document-format\", NULL, mimetype);\n\n    return (NULL);\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"copies\",\n                               IPP_TAG_INTEGER)) != NULL)\n  {\n    if (attr->values[0].integer < 1 || attr->values[0].integer > MaxCopies)\n    {\n      send_ipp_status(con, IPP_ATTRIBUTES, _(\"Bad copies value %d.\"),\n                      attr->values[0].integer);\n      ippAddInteger(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_INTEGER,\n\t            \"copies\", attr->values[0].integer);\n      return (NULL);\n    }\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"job-sheets\",\n                               IPP_TAG_ZERO)) != NULL)\n  {\n    if (attr->value_tag != IPP_TAG_KEYWORD &&\n        attr->value_tag != IPP_TAG_NAME)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-sheets value type.\"));\n      return (NULL);\n    }\n\n    if (attr->num_values > 2)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Too many job-sheets values (%d > 2).\"),\n\t\t      attr->num_values);\n      return (NULL);\n    }\n\n    for (i = 0; i < attr->num_values; i ++)\n      if (strcmp(attr->values[i].string.text, \"none\") &&\n          !cupsdFindBanner(attr->values[i].string.text))\n      {\n\tsend_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-sheets value \\\"%s\\\".\"),\n\t\t\tattr->values[i].string.text);\n\treturn (NULL);\n      }\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"number-up\",\n                               IPP_TAG_INTEGER)) != NULL)\n  {\n    if (attr->values[0].integer != 1 &&\n        attr->values[0].integer != 2 &&\n        attr->values[0].integer != 4 &&\n        attr->values[0].integer != 6 &&\n        attr->values[0].integer != 9 &&\n        attr->values[0].integer != 16)\n    {\n      send_ipp_status(con, IPP_ATTRIBUTES, _(\"Bad number-up value %d.\"),\n                      attr->values[0].integer);\n      ippAddInteger(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_INTEGER,\n\t            \"number-up\", attr->values[0].integer);\n      return (NULL);\n    }\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"page-ranges\",\n                               IPP_TAG_RANGE)) != NULL)\n  {\n    for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++)\n    {\n      if (attr->values[i].range.lower < lowerpagerange ||\n\t  attr->values[i].range.lower > attr->values[i].range.upper)\n      {\n\tsend_ipp_status(con, IPP_BAD_REQUEST,\n\t                _(\"Bad page-ranges values %d-%d.\"),\n\t                attr->values[i].range.lower,\n\t\t\tattr->values[i].range.upper);\n\treturn (NULL);\n      }\n\n      lowerpagerange = attr->values[i].range.upper + 1;\n    }\n  }\n\n /*\n  * Do media selection as needed...\n  */\n\n  if (!ippFindAttribute(con->request, \"PageRegion\", IPP_TAG_ZERO) &&\n      !ippFindAttribute(con->request, \"PageSize\", IPP_TAG_ZERO) &&\n      _ppdCacheGetPageSize(printer->pc, con->request, NULL, &exact))\n  {\n    if (!exact &&\n        (media_col = ippFindAttribute(con->request, \"media-col\",\n\t                              IPP_TAG_BEGIN_COLLECTION)) != NULL)\n    {\n      send_ipp_status(con, IPP_OK_SUBST, _(\"Unsupported margins.\"));\n\n      unsup_col = ippNew();\n      if ((media_margin = ippFindAttribute(media_col->values[0].collection,\n                                           \"media-bottom-margin\",\n\t\t\t\t\t   IPP_TAG_INTEGER)) != NULL)\n        ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,\n\t              \"media-bottom-margin\", media_margin->values[0].integer);\n\n      if ((media_margin = ippFindAttribute(media_col->values[0].collection,\n                                           \"media-left-margin\",\n\t\t\t\t\t   IPP_TAG_INTEGER)) != NULL)\n        ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,\n\t              \"media-left-margin\", media_margin->values[0].integer);\n\n      if ((media_margin = ippFindAttribute(media_col->values[0].collection,\n                                           \"media-right-margin\",\n\t\t\t\t\t   IPP_TAG_INTEGER)) != NULL)\n        ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,\n\t              \"media-right-margin\", media_margin->values[0].integer);\n\n      if ((media_margin = ippFindAttribute(media_col->values[0].collection,\n                                           \"media-top-margin\",\n\t\t\t\t\t   IPP_TAG_INTEGER)) != NULL)\n        ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,\n\t              \"media-top-margin\", media_margin->values[0].integer);\n\n      ippAddCollection(con->response, IPP_TAG_UNSUPPORTED_GROUP, \"media-col\",\n                       unsup_col);\n      ippDelete(unsup_col);\n    }\n  }\n\n /*\n  * Make sure we aren't over our limit...\n  */\n\n  if (MaxJobs && cupsArrayCount(Jobs) >= MaxJobs)\n    cupsdCleanJobs();\n\n  if (MaxJobs && cupsArrayCount(Jobs) >= MaxJobs)\n  {\n    send_ipp_status(con, IPP_NOT_POSSIBLE, _(\"Too many active jobs.\"));\n    return (NULL);\n  }\n\n  if ((i = check_quotas(con, printer)) < 0)\n  {\n    send_ipp_status(con, IPP_NOT_POSSIBLE, _(\"Quota limit reached.\"));\n    return (NULL);\n  }\n  else if (i == 0)\n  {\n    send_ipp_status(con, IPP_NOT_AUTHORIZED, _(\"Not allowed to print.\"));\n    return (NULL);\n  }\n\n /*\n  * Create the job and set things up...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"job-priority\",\n                               IPP_TAG_INTEGER)) != NULL)\n    priority = attr->values[0].integer;\n  else\n  {\n    if ((val = cupsGetOption(\"job-priority\", printer->num_options,\n                             printer->options)) != NULL)\n      priority = atoi(val);\n    else\n      priority = 50;\n\n    ippAddInteger(con->request, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-priority\",\n                  priority);\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"job-name\", IPP_TAG_ZERO)) == NULL)\n    ippAddString(con->request, IPP_TAG_JOB, IPP_TAG_NAME, \"job-name\", NULL, \"Untitled\");\n  else if ((attr->value_tag != IPP_TAG_NAME &&\n            attr->value_tag != IPP_TAG_NAMELANG) ||\n           attr->num_values != 1)\n  {\n    send_ipp_status(con, IPP_ATTRIBUTES,\n                    _(\"Bad job-name value: Wrong type or count.\"));\n    if ((attr = ippCopyAttribute(con->response, attr, 0)) != NULL)\n      attr->group_tag = IPP_TAG_UNSUPPORTED_GROUP;\n    return (NULL);\n  }\n  else if (!ippValidateAttribute(attr))\n  {\n    send_ipp_status(con, IPP_ATTRIBUTES, _(\"Bad job-name value: %s\"),\n                    cupsLastErrorString());\n    if ((attr = ippCopyAttribute(con->response, attr, 0)) != NULL)\n      attr->group_tag = IPP_TAG_UNSUPPORTED_GROUP;\n     return (NULL);\n   }\n \n  attr = ippFindAttribute(con->request, \"requesting-user-name\", IPP_TAG_NAME);\n\n  if (attr && !ippValidateAttribute(attr))\n  {\n    send_ipp_status(con, IPP_ATTRIBUTES, _(\"Bad requesting-user-name value: %s\"), cupsLastErrorString());\n    if ((attr = ippCopyAttribute(con->response, attr, 0)) != NULL)\n      attr->group_tag = IPP_TAG_UNSUPPORTED_GROUP;\n    return (NULL);\n  }\n\n   if ((job = cupsdAddJob(priority, printer->name)) == NULL)\n   {\n     send_ipp_status(con, IPP_INTERNAL_ERROR,\n                    _(\"Unable to add job for destination \\\"%s\\\".\"),\n\t\t    printer->name);\n    return (NULL);\n  }\n\n  job->dtype   = printer->type & (CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE);\n  job->attrs   = con->request;\n  job->dirty   = 1;\n  con->request = ippNewRequest(job->attrs->request.op.operation_id);\n\n  cupsdMarkDirty(CUPSD_DIRTY_JOBS);\n\n   add_job_uuid(job);\n   apply_printer_defaults(printer, job);\n \n   if (con->username[0])\n   {\n     cupsdSetString(&job->username, con->username);\n\n    if (attr)\n      ippSetString(job->attrs, &attr, 0, con->username);\n  }\n  else if (attr)\n  {\n    cupsdLogMessage(CUPSD_LOG_DEBUG,\n                    \"add_job: requesting-user-name=\\\"%s\\\"\",\n                    attr->values[0].string.text);\n\n    cupsdSetString(&job->username, attr->values[0].string.text);\n  }\n  else\n    cupsdSetString(&job->username, \"anonymous\");\n\n  if (!attr)\n    ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME,\n                 \"job-originating-user-name\", NULL, job->username);\n  else\n  {\n    ippSetGroupTag(job->attrs, &attr, IPP_TAG_JOB);\n    ippSetName(job->attrs, &attr, \"job-originating-user-name\");\n  }\n\n  if (con->username[0] || auth_info)\n  {\n    save_auth_info(con, job, auth_info);\n\n   /*\n    * Remove the auth-info attribute from the attribute data...\n    */\n\n    if (auth_info)\n      ippDeleteAttribute(job->attrs, auth_info);\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"job-name\", IPP_TAG_NAME)) != NULL)\n    cupsdSetString(&(job->name), attr->values[0].string.text);\n\n  if ((attr = ippFindAttribute(job->attrs, \"job-originating-host-name\",\n                               IPP_TAG_ZERO)) != NULL)\n  {\n   /*\n    * Request contains a job-originating-host-name attribute; validate it...\n    */\n\n    if (attr->value_tag != IPP_TAG_NAME ||\n        attr->num_values != 1 ||\n        strcmp(con->http->hostname, \"localhost\"))\n    {\n     /*\n      * Can't override the value if we aren't connected via localhost.\n      * Also, we can only have 1 value and it must be a name value.\n      */\n\n      ippDeleteAttribute(job->attrs, attr);\n      ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME, \"job-originating-host-name\", NULL, con->http->hostname);\n    }\n    else\n      ippSetGroupTag(job->attrs, &attr, IPP_TAG_JOB);\n  }\n  else\n  {\n   /*\n    * No job-originating-host-name attribute, so use the hostname from\n    * the connection...\n    */\n\n    ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME,\n        \t \"job-originating-host-name\", NULL, con->http->hostname);\n  }\n\n  ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, \"date-time-at-completed\");\n  ippAddDate(job->attrs, IPP_TAG_JOB, \"date-time-at-creation\", ippTimeToDate(time(NULL)));\n  ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, \"date-time-at-processing\");\n  ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, \"time-at-completed\");\n  ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, \"time-at-creation\", time(NULL));\n  ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, \"time-at-processing\");\n\n /*\n  * Add remaining job attributes...\n  */\n\n  ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-id\", job->id);\n  job->state = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_ENUM,\n                             \"job-state\", IPP_JOB_STOPPED);\n  job->state_value = (ipp_jstate_t)job->state->values[0].integer;\n  job->reasons = ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_KEYWORD,\n                              \"job-state-reasons\", NULL, \"job-incoming\");\n  job->impressions = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-impressions-completed\", 0);\n  job->sheets = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER,\n                              \"job-media-sheets-completed\", 0);\n  ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_URI, \"job-printer-uri\", NULL,\n               printer->uri);\n\n  if ((attr = ippFindAttribute(job->attrs, \"job-k-octets\", IPP_TAG_INTEGER)) != NULL)\n    attr->values[0].integer = 0;\n  else\n    ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-k-octets\", 0);\n\n  if ((attr = ippFindAttribute(job->attrs, \"job-hold-until\",\n                               IPP_TAG_KEYWORD)) == NULL)\n    attr = ippFindAttribute(job->attrs, \"job-hold-until\", IPP_TAG_NAME);\n  if (!attr)\n  {\n    if ((val = cupsGetOption(\"job-hold-until\", printer->num_options,\n                             printer->options)) == NULL)\n      val = \"no-hold\";\n\n    attr = ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_KEYWORD,\n                        \"job-hold-until\", NULL, val);\n  }\n\n  if (printer->holding_new_jobs)\n  {\n   /*\n    * Hold all new jobs on this printer...\n    */\n\n    if (attr && strcmp(attr->values[0].string.text, \"no-hold\"))\n      cupsdSetJobHoldUntil(job, ippGetString(attr, 0, NULL), 0);\n    else\n      cupsdSetJobHoldUntil(job, \"indefinite\", 0);\n\n    job->state->values[0].integer = IPP_JOB_HELD;\n    job->state_value              = IPP_JOB_HELD;\n\n    ippSetString(job->attrs, &job->reasons, 0, \"job-held-on-create\");\n  }\n  else if (attr && strcmp(attr->values[0].string.text, \"no-hold\"))\n  {\n   /*\n    * Hold job until specified time...\n    */\n\n    cupsdSetJobHoldUntil(job, attr->values[0].string.text, 0);\n\n    job->state->values[0].integer = IPP_JOB_HELD;\n    job->state_value              = IPP_JOB_HELD;\n\n    ippSetString(job->attrs, &job->reasons, 0, \"job-hold-until-specified\");\n  }\n  else if (job->attrs->request.op.operation_id == IPP_CREATE_JOB)\n  {\n    job->hold_until               = time(NULL) + MultipleOperationTimeout;\n    job->state->values[0].integer = IPP_JOB_HELD;\n    job->state_value              = IPP_JOB_HELD;\n  }\n  else\n  {\n    job->state->values[0].integer = IPP_JOB_PENDING;\n    job->state_value              = IPP_JOB_PENDING;\n\n    ippSetString(job->attrs, &job->reasons, 0, \"none\");\n  }\n\n  if (!(printer->type & CUPS_PRINTER_REMOTE) || Classification)\n  {\n   /*\n    * Add job sheets options...\n    */\n\n    if ((attr = ippFindAttribute(job->attrs, \"job-sheets\",\n                                 IPP_TAG_ZERO)) == NULL)\n    {\n      cupsdLogMessage(CUPSD_LOG_DEBUG,\n                      \"Adding default job-sheets values \\\"%s,%s\\\"...\",\n                      printer->job_sheets[0], printer->job_sheets[1]);\n\n      attr = ippAddStrings(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME, \"job-sheets\",\n                           2, NULL, NULL);\n      ippSetString(job->attrs, &attr, 0, printer->job_sheets[0]);\n      ippSetString(job->attrs, &attr, 1, printer->job_sheets[1]);\n    }\n\n    job->job_sheets = attr;\n\n   /*\n    * Enforce classification level if set...\n    */\n\n    if (Classification)\n    {\n      cupsdLogMessage(CUPSD_LOG_INFO,\n                      \"Classification=\\\"%s\\\", ClassifyOverride=%d\",\n                      Classification ? Classification : \"(null)\",\n\t\t      ClassifyOverride);\n\n      if (ClassifyOverride)\n      {\n        if (!strcmp(attr->values[0].string.text, \"none\") &&\n\t    (attr->num_values == 1 ||\n\t     !strcmp(attr->values[1].string.text, \"none\")))\n        {\n\t /*\n          * Force the leading banner to have the classification on it...\n\t  */\n\n          ippSetString(job->attrs, &attr, 0, Classification);\n\n\t  cupsdLogJob(job, CUPSD_LOG_NOTICE, \"CLASSIFICATION FORCED \"\n\t                \t\t     \"job-sheets=\\\"%s,none\\\", \"\n\t\t\t\t\t     \"job-originating-user-name=\\\"%s\\\"\",\n\t              Classification, job->username);\n\t}\n\telse if (attr->num_values == 2 &&\n\t         strcmp(attr->values[0].string.text,\n\t\t        attr->values[1].string.text) &&\n\t\t strcmp(attr->values[0].string.text, \"none\") &&\n\t\t strcmp(attr->values[1].string.text, \"none\"))\n        {\n\t /*\n\t  * Can't put two different security markings on the same document!\n\t  */\n\n          ippSetString(job->attrs, &attr, 1, attr->values[0].string.text);\n\n\t  cupsdLogJob(job, CUPSD_LOG_NOTICE, \"CLASSIFICATION FORCED \"\n\t                \t\t     \"job-sheets=\\\"%s,%s\\\", \"\n\t\t\t\t\t     \"job-originating-user-name=\\\"%s\\\"\",\n\t\t      attr->values[0].string.text,\n\t\t      attr->values[1].string.text, job->username);\n\t}\n\telse if (strcmp(attr->values[0].string.text, Classification) &&\n\t         strcmp(attr->values[0].string.text, \"none\") &&\n\t\t (attr->num_values == 1 ||\n\t          (strcmp(attr->values[1].string.text, Classification) &&\n\t           strcmp(attr->values[1].string.text, \"none\"))))\n        {\n\t  if (attr->num_values == 1)\n            cupsdLogJob(job, CUPSD_LOG_NOTICE,\n\t\t\t\"CLASSIFICATION OVERRIDDEN \"\n\t\t\t\"job-sheets=\\\"%s\\\", \"\n\t\t\t\"job-originating-user-name=\\\"%s\\\"\",\n\t                attr->values[0].string.text, job->username);\n          else\n            cupsdLogJob(job, CUPSD_LOG_NOTICE,\n\t\t\t\"CLASSIFICATION OVERRIDDEN \"\n\t\t\t\"job-sheets=\\\"%s,%s\\\",fffff \"\n\t\t\t\"job-originating-user-name=\\\"%s\\\"\",\n\t\t\tattr->values[0].string.text,\n\t\t\tattr->values[1].string.text, job->username);\n        }\n      }\n      else if (strcmp(attr->values[0].string.text, Classification) &&\n               (attr->num_values == 1 ||\n\t       strcmp(attr->values[1].string.text, Classification)))\n      {\n       /*\n        * Force the banner to have the classification on it...\n\t*/\n\n        if (attr->num_values > 1 &&\n\t    !strcmp(attr->values[0].string.text, attr->values[1].string.text))\n\t{\n          ippSetString(job->attrs, &attr, 0, Classification);\n          ippSetString(job->attrs, &attr, 1, Classification);\n\t}\n        else\n\t{\n          if (attr->num_values == 1 ||\n\t      strcmp(attr->values[0].string.text, \"none\"))\n            ippSetString(job->attrs, &attr, 0, Classification);\n\n          if (attr->num_values > 1 &&\n\t      strcmp(attr->values[1].string.text, \"none\"))\n\t    ippSetString(job->attrs, &attr, 1, Classification);\n        }\n\n        if (attr->num_values > 1)\n\t  cupsdLogJob(job, CUPSD_LOG_NOTICE,\n\t\t      \"CLASSIFICATION FORCED \"\n\t\t      \"job-sheets=\\\"%s,%s\\\", \"\n\t\t      \"job-originating-user-name=\\\"%s\\\"\",\n\t\t      attr->values[0].string.text,\n\t\t      attr->values[1].string.text, job->username);\n        else\n\t  cupsdLogJob(job, CUPSD_LOG_NOTICE,\n\t\t      \"CLASSIFICATION FORCED \"\n\t\t      \"job-sheets=\\\"%s\\\", \"\n\t\t      \"job-originating-user-name=\\\"%s\\\"\",\n\t\t      Classification, job->username);\n      }\n    }\n\n   /*\n    * See if we need to add the starting sheet...\n    */\n\n    if (!(printer->type & CUPS_PRINTER_REMOTE))\n    {\n      cupsdLogJob(job, CUPSD_LOG_INFO, \"Adding start banner page \\\"%s\\\".\",\n\t\t  attr->values[0].string.text);\n\n      if ((kbytes = copy_banner(con, job, attr->values[0].string.text)) < 0)\n      {\n        cupsdSetJobState(job, IPP_JOB_ABORTED, CUPSD_JOB_PURGE,\n\t                 \"Aborting job because the start banner could not be \"\n\t\t\t \"copied.\");\n        return (NULL);\n      }\n\n      cupsdUpdateQuota(printer, job->username, 0, kbytes);\n    }\n  }\n  else if ((attr = ippFindAttribute(job->attrs, \"job-sheets\",\n                                    IPP_TAG_ZERO)) != NULL)\n    job->job_sheets = attr;\n\n /*\n  * Fill in the response info...\n  */\n\n  httpAssembleURIf(HTTP_URI_CODING_ALL, job_uri, sizeof(job_uri), \"ipp\", NULL,\n                   con->clientname, con->clientport, \"/jobs/%d\", job->id);\n  ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_URI, \"job-uri\", NULL,\n               job_uri);\n\n  ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-id\", job->id);\n\n  ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_ENUM, \"job-state\",\n                job->state_value);\n  ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_TEXT, \"job-state-message\", NULL, \"\");\n  ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_KEYWORD, \"job-state-reasons\",\n               NULL, job->reasons->values[0].string.text);\n\n  con->response->request.status.status_code = IPP_OK;\n\n /*\n  * Add any job subscriptions...\n  */\n\n  add_job_subscriptions(con, job);\n\n /*\n  * Set all but the first two attributes to the job attributes group...\n  */\n\n  for (attr = job->attrs->attrs->next->next; attr; attr = attr->next)\n    attr->group_tag = IPP_TAG_JOB;\n\n /*\n  * Fire the \"job created\" event...\n  */\n\n  cupsdAddEvent(CUPSD_EVENT_JOB_CREATED, printer, job, \"Job created.\");\n\n /*\n  * Return the new job...\n  */\n\n  return (job);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143116,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void __munlock_pagevec(struct pagevec *pvec, struct zone *zone)\n {\n \tint i;\n \tint nr = pagevec_count(pvec);\n\tint delta_munlocked;\n \tstruct pagevec pvec_putback;\n \tint pgrescued = 0;\n \n\tpagevec_init(&pvec_putback, 0);\n\n\t/* Phase 1: page isolation */\n\tspin_lock_irq(zone_lru_lock(zone));\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\n\t\tif (TestClearPageMlocked(page)) {\n\t\t\t/*\n\t\t\t * We already have pin from follow_page_mask()\n\t\t\t * so we can spare the get_page() here.\n\t\t\t */\n\t\t\tif (__munlock_isolate_lru_page(page, false))\n \t\t\t\tcontinue;\n \t\t\telse\n \t\t\t\t__munlock_isolation_failed(page);\n \t\t}\n \n \t\t/*\n\t\t * We won't be munlocking this page in the next phase\n\t\t * but we still need to release the follow_page_mask()\n\t\t * pin. We cannot do it under lru_lock however. If it's\n\t\t * the last pin, __page_cache_release() would deadlock.\n\t\t */\n \t\tpagevec_add(&pvec_putback, pvec->pages[i]);\n \t\tpvec->pages[i] = NULL;\n \t}\n\tdelta_munlocked = -nr + pagevec_count(&pvec_putback);\n \t__mod_zone_page_state(zone, NR_MLOCK, delta_munlocked);\n \tspin_unlock_irq(zone_lru_lock(zone));\n \n\t/* Now we can release pins of pages that we are not munlocking */\n\tpagevec_release(&pvec_putback);\n\n\t/* Phase 2: page munlock */\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\n\t\tif (page) {\n\t\t\tlock_page(page);\n\t\t\tif (!__putback_lru_fast_prepare(page, &pvec_putback,\n\t\t\t\t\t&pgrescued)) {\n\t\t\t\t/*\n\t\t\t\t * Slow path. We don't want to lose the last\n\t\t\t\t * pin before unlock_page()\n\t\t\t\t */\n\t\t\t\tget_page(page); /* for putback_lru_page() */\n\t\t\t\t__munlock_isolated_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page); /* from follow_page_mask() */\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Phase 3: page putback for pages that qualified for the fast path\n\t * This will also call put_page() to return pin from follow_page_mask()\n\t */\n\tif (pagevec_count(&pvec_putback))\n\t\t__putback_lru_fast(&pvec_putback, pgrescued);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143117,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void __munlock_pagevec(struct pagevec *pvec, struct zone *zone)\n {\n \tint i;\n \tint nr = pagevec_count(pvec);\n\tint delta_munlocked = -nr;\n \tstruct pagevec pvec_putback;\n \tint pgrescued = 0;\n \n\tpagevec_init(&pvec_putback, 0);\n\n\t/* Phase 1: page isolation */\n\tspin_lock_irq(zone_lru_lock(zone));\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\n\t\tif (TestClearPageMlocked(page)) {\n\t\t\t/*\n\t\t\t * We already have pin from follow_page_mask()\n\t\t\t * so we can spare the get_page() here.\n\t\t\t */\n\t\t\tif (__munlock_isolate_lru_page(page, false))\n \t\t\t\tcontinue;\n \t\t\telse\n \t\t\t\t__munlock_isolation_failed(page);\n\t\t} else {\n\t\t\tdelta_munlocked++;\n \t\t}\n \n \t\t/*\n\t\t * We won't be munlocking this page in the next phase\n\t\t * but we still need to release the follow_page_mask()\n\t\t * pin. We cannot do it under lru_lock however. If it's\n\t\t * the last pin, __page_cache_release() would deadlock.\n\t\t */\n \t\tpagevec_add(&pvec_putback, pvec->pages[i]);\n \t\tpvec->pages[i] = NULL;\n \t}\n \t__mod_zone_page_state(zone, NR_MLOCK, delta_munlocked);\n \tspin_unlock_irq(zone_lru_lock(zone));\n \n\t/* Now we can release pins of pages that we are not munlocking */\n\tpagevec_release(&pvec_putback);\n\n\t/* Phase 2: page munlock */\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\n\t\tif (page) {\n\t\t\tlock_page(page);\n\t\t\tif (!__putback_lru_fast_prepare(page, &pvec_putback,\n\t\t\t\t\t&pgrescued)) {\n\t\t\t\t/*\n\t\t\t\t * Slow path. We don't want to lose the last\n\t\t\t\t * pin before unlock_page()\n\t\t\t\t */\n\t\t\t\tget_page(page); /* for putback_lru_page() */\n\t\t\t\t__munlock_isolated_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page); /* from follow_page_mask() */\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Phase 3: page putback for pages that qualified for the fast path\n\t * This will also call put_page() to return pin from follow_page_mask()\n\t */\n\tif (pagevec_count(&pvec_putback))\n\t\t__putback_lru_fast(&pvec_putback, pgrescued);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143118,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)\n {\n \t__issue_discard_cmd(sbi, false);\n \t__drop_discard_cmd(sbi);\n\t__wait_discard_cmd(sbi, false);\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143129,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)\nvoid f2fs_wait_discard_bios(struct f2fs_sb_info *sbi, bool umount)\n {\n \t__issue_discard_cmd(sbi, false);\n \t__drop_discard_cmd(sbi);\n\t__wait_discard_cmd(sbi, !umount);\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143130,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static av_cold int vqa_decode_init(AVCodecContext *avctx)\n{\n    VqaContext *s = avctx->priv_data;\n    int i, j, codebook_index, ret;\n\n    s->avctx = avctx;\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n    /* make sure the extradata made it */\n    if (s->avctx->extradata_size != VQA_HEADER_SIZE) {\n        av_log(s->avctx, AV_LOG_ERROR, \"expected extradata size of %d\\n\", VQA_HEADER_SIZE);\n        return AVERROR(EINVAL);\n    }\n\n    /* load up the VQA parameters from the header */\n    s->vqa_version = s->avctx->extradata[0];\n    switch (s->vqa_version) {\n    case 1:\n    case 2:\n        break;\n    case 3:\n        avpriv_report_missing_feature(avctx, \"VQA Version %d\", s->vqa_version);\n        return AVERROR_PATCHWELCOME;\n    default:\n        avpriv_request_sample(avctx, \"VQA Version %i\", s->vqa_version);\n        return AVERROR_PATCHWELCOME;\n     }\n     s->width = AV_RL16(&s->avctx->extradata[6]);\n     s->height = AV_RL16(&s->avctx->extradata[8]);\n    if ((ret = av_image_check_size(s->width, s->height, 0, avctx)) < 0) {\n         s->width= s->height= 0;\n         return ret;\n     }\n    s->vector_width = s->avctx->extradata[10];\n    s->vector_height = s->avctx->extradata[11];\n    s->partial_count = s->partial_countdown = s->avctx->extradata[13];\n\n    /* the vector dimensions have to meet very stringent requirements */\n    if ((s->vector_width != 4) ||\n        ((s->vector_height != 2) && (s->vector_height != 4))) {\n        /* return without further initialization */\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->width % s->vector_width || s->height % s->vector_height) {\n        av_log(avctx, AV_LOG_ERROR, \"Image size not multiple of block size\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* allocate codebooks */\n    s->codebook_size = MAX_CODEBOOK_SIZE;\n    s->codebook = av_malloc(s->codebook_size);\n    if (!s->codebook)\n        goto fail;\n    s->next_codebook_buffer = av_malloc(s->codebook_size);\n    if (!s->next_codebook_buffer)\n        goto fail;\n\n    /* allocate decode buffer */\n    s->decode_buffer_size = (s->width / s->vector_width) *\n        (s->height / s->vector_height) * 2;\n    s->decode_buffer = av_mallocz(s->decode_buffer_size);\n    if (!s->decode_buffer)\n        goto fail;\n\n    /* initialize the solid-color vectors */\n    if (s->vector_height == 4) {\n        codebook_index = 0xFF00 * 16;\n        for (i = 0; i < 256; i++)\n            for (j = 0; j < 16; j++)\n                s->codebook[codebook_index++] = i;\n    } else {\n        codebook_index = 0xF00 * 8;\n        for (i = 0; i < 256; i++)\n            for (j = 0; j < 8; j++)\n                s->codebook[codebook_index++] = i;\n    }\n    s->next_codebook_buffer_index = 0;\n\n    return 0;\nfail:\n    av_freep(&s->codebook);\n    av_freep(&s->next_codebook_buffer);\n    av_freep(&s->decode_buffer);\n    return AVERROR(ENOMEM);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143169,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static av_cold int vqa_decode_init(AVCodecContext *avctx)\n{\n    VqaContext *s = avctx->priv_data;\n    int i, j, codebook_index, ret;\n\n    s->avctx = avctx;\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n    /* make sure the extradata made it */\n    if (s->avctx->extradata_size != VQA_HEADER_SIZE) {\n        av_log(s->avctx, AV_LOG_ERROR, \"expected extradata size of %d\\n\", VQA_HEADER_SIZE);\n        return AVERROR(EINVAL);\n    }\n\n    /* load up the VQA parameters from the header */\n    s->vqa_version = s->avctx->extradata[0];\n    switch (s->vqa_version) {\n    case 1:\n    case 2:\n        break;\n    case 3:\n        avpriv_report_missing_feature(avctx, \"VQA Version %d\", s->vqa_version);\n        return AVERROR_PATCHWELCOME;\n    default:\n        avpriv_request_sample(avctx, \"VQA Version %i\", s->vqa_version);\n        return AVERROR_PATCHWELCOME;\n     }\n     s->width = AV_RL16(&s->avctx->extradata[6]);\n     s->height = AV_RL16(&s->avctx->extradata[8]);\n    if ((ret = ff_set_dimensions(avctx, s->width, s->height)) < 0) {\n         s->width= s->height= 0;\n         return ret;\n     }\n    s->vector_width = s->avctx->extradata[10];\n    s->vector_height = s->avctx->extradata[11];\n    s->partial_count = s->partial_countdown = s->avctx->extradata[13];\n\n    /* the vector dimensions have to meet very stringent requirements */\n    if ((s->vector_width != 4) ||\n        ((s->vector_height != 2) && (s->vector_height != 4))) {\n        /* return without further initialization */\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->width % s->vector_width || s->height % s->vector_height) {\n        av_log(avctx, AV_LOG_ERROR, \"Image size not multiple of block size\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* allocate codebooks */\n    s->codebook_size = MAX_CODEBOOK_SIZE;\n    s->codebook = av_malloc(s->codebook_size);\n    if (!s->codebook)\n        goto fail;\n    s->next_codebook_buffer = av_malloc(s->codebook_size);\n    if (!s->next_codebook_buffer)\n        goto fail;\n\n    /* allocate decode buffer */\n    s->decode_buffer_size = (s->width / s->vector_width) *\n        (s->height / s->vector_height) * 2;\n    s->decode_buffer = av_mallocz(s->decode_buffer_size);\n    if (!s->decode_buffer)\n        goto fail;\n\n    /* initialize the solid-color vectors */\n    if (s->vector_height == 4) {\n        codebook_index = 0xFF00 * 16;\n        for (i = 0; i < 256; i++)\n            for (j = 0; j < 16; j++)\n                s->codebook[codebook_index++] = i;\n    } else {\n        codebook_index = 0xF00 * 8;\n        for (i = 0; i < 256; i++)\n            for (j = 0; j < 8; j++)\n                s->codebook[codebook_index++] = i;\n    }\n    s->next_codebook_buffer_index = 0;\n\n    return 0;\nfail:\n    av_freep(&s->codebook);\n    av_freep(&s->next_codebook_buffer);\n    av_freep(&s->decode_buffer);\n    return AVERROR(ENOMEM);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143170,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "lmp_print_data_link_subobjs(netdissect_options *ndo, const u_char *obj_tptr,\n                            int total_subobj_len, int offset)\n{\n    int hexdump = FALSE;\n    int subobj_type, subobj_len;\n\n    union { /* int to float conversion buffer */\n        float f;\n        uint32_t i;\n     } bw;\n \n     while (total_subobj_len > 0 && hexdump == FALSE ) {\n \tsubobj_type = EXTRACT_8BITS(obj_tptr + offset);\n \tsubobj_len  = EXTRACT_8BITS(obj_tptr + offset + 1);\n \tND_PRINT((ndo, \"\\n\\t    Subobject, Type: %s (%u), Length: %u\",\n\t\ttok2str(lmp_data_link_subobj,\n\t\t\t\"Unknown\",\n\t\t\tsubobj_type),\n\t\t\tsubobj_type,\n\t\t\tsubobj_len));\n\tif (subobj_len < 4) {\n\t    ND_PRINT((ndo, \" (too short)\"));\n\t    break;\n\t}\n\tif ((subobj_len % 4) != 0) {\n\t    ND_PRINT((ndo, \" (not a multiple of 4)\"));\n\t    break;\n\t}\n\tif (total_subobj_len < subobj_len) {\n\t    ND_PRINT((ndo, \" (goes past the end of the object)\"));\n\t    break;\n \t}\n \tswitch(subobj_type) {\n \tcase INT_SWITCHING_TYPE_SUBOBJ:\n \t    ND_PRINT((ndo, \"\\n\\t      Switching Type: %s (%u)\",\n \t\ttok2str(gmpls_switch_cap_values,\n \t\t\t\"Unknown\",\n \t\t\tEXTRACT_8BITS(obj_tptr + offset + 2)),\n \t\t\tEXTRACT_8BITS(obj_tptr + offset + 2)));\n \t    ND_PRINT((ndo, \"\\n\\t      Encoding Type: %s (%u)\",\n \t\ttok2str(gmpls_encoding_values,\n \t\t\t\"Unknown\",\n\t\t\tEXTRACT_8BITS(obj_tptr + offset + 3)),\n\t\t\tEXTRACT_8BITS(obj_tptr + offset + 3)));\n\t    ND_TCHECK_32BITS(obj_tptr + offset + 4);\n \t    bw.i = EXTRACT_32BITS(obj_tptr+offset+4);\n \t    ND_PRINT((ndo, \"\\n\\t      Min Reservable Bandwidth: %.3f Mbps\",\n                 bw.f*8/1000000));\n \t    bw.i = EXTRACT_32BITS(obj_tptr+offset+8);\n \t    ND_PRINT((ndo, \"\\n\\t      Max Reservable Bandwidth: %.3f Mbps\",\n                 bw.f*8/1000000));\n \t    break;\n \tcase WAVELENGTH_SUBOBJ:\n \t    ND_PRINT((ndo, \"\\n\\t      Wavelength: %u\",\n \t\tEXTRACT_32BITS(obj_tptr+offset+4)));\n \t    break;\n\tdefault:\n\t    /* Any Unknown Subobject ==> Exit loop */\n\t    hexdump=TRUE;\n\t    break;\n\t}\n\ttotal_subobj_len-=subobj_len;\n\toffset+=subobj_len;\n    }\n    return (hexdump);\ntrunc:\n    return -1;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143189,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "lmp_print_data_link_subobjs(netdissect_options *ndo, const u_char *obj_tptr,\n                            int total_subobj_len, int offset)\n{\n    int hexdump = FALSE;\n    int subobj_type, subobj_len;\n\n    union { /* int to float conversion buffer */\n        float f;\n        uint32_t i;\n     } bw;\n \n     while (total_subobj_len > 0 && hexdump == FALSE ) {\n\tND_TCHECK_16BITS(obj_tptr + offset);\n \tsubobj_type = EXTRACT_8BITS(obj_tptr + offset);\n \tsubobj_len  = EXTRACT_8BITS(obj_tptr + offset + 1);\n \tND_PRINT((ndo, \"\\n\\t    Subobject, Type: %s (%u), Length: %u\",\n\t\ttok2str(lmp_data_link_subobj,\n\t\t\t\"Unknown\",\n\t\t\tsubobj_type),\n\t\t\tsubobj_type,\n\t\t\tsubobj_len));\n\tif (subobj_len < 4) {\n\t    ND_PRINT((ndo, \" (too short)\"));\n\t    break;\n\t}\n\tif ((subobj_len % 4) != 0) {\n\t    ND_PRINT((ndo, \" (not a multiple of 4)\"));\n\t    break;\n\t}\n\tif (total_subobj_len < subobj_len) {\n\t    ND_PRINT((ndo, \" (goes past the end of the object)\"));\n\t    break;\n \t}\n \tswitch(subobj_type) {\n \tcase INT_SWITCHING_TYPE_SUBOBJ:\n\t    ND_TCHECK_8BITS(obj_tptr + offset + 2);\n \t    ND_PRINT((ndo, \"\\n\\t      Switching Type: %s (%u)\",\n \t\ttok2str(gmpls_switch_cap_values,\n \t\t\t\"Unknown\",\n \t\t\tEXTRACT_8BITS(obj_tptr + offset + 2)),\n \t\t\tEXTRACT_8BITS(obj_tptr + offset + 2)));\n\t    ND_TCHECK_8BITS(obj_tptr + offset + 3);\n \t    ND_PRINT((ndo, \"\\n\\t      Encoding Type: %s (%u)\",\n \t\ttok2str(gmpls_encoding_values,\n \t\t\t\"Unknown\",\n\t\t\tEXTRACT_8BITS(obj_tptr + offset + 3)),\n\t\t\tEXTRACT_8BITS(obj_tptr + offset + 3)));\n\t    ND_TCHECK_32BITS(obj_tptr + offset + 4);\n \t    bw.i = EXTRACT_32BITS(obj_tptr+offset+4);\n \t    ND_PRINT((ndo, \"\\n\\t      Min Reservable Bandwidth: %.3f Mbps\",\n                 bw.f*8/1000000));\n\t    ND_TCHECK_32BITS(obj_tptr + offset + 8);\n \t    bw.i = EXTRACT_32BITS(obj_tptr+offset+8);\n \t    ND_PRINT((ndo, \"\\n\\t      Max Reservable Bandwidth: %.3f Mbps\",\n                 bw.f*8/1000000));\n \t    break;\n \tcase WAVELENGTH_SUBOBJ:\n\t    ND_TCHECK_32BITS(obj_tptr + offset + 4);\n \t    ND_PRINT((ndo, \"\\n\\t      Wavelength: %u\",\n \t\tEXTRACT_32BITS(obj_tptr+offset+4)));\n \t    break;\n\tdefault:\n\t    /* Any Unknown Subobject ==> Exit loop */\n\t    hexdump=TRUE;\n\t    break;\n\t}\n\ttotal_subobj_len-=subobj_len;\n\toffset+=subobj_len;\n    }\n    return (hexdump);\ntrunc:\n    return -1;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143190,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "pcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,\n    char *errbuf, int *err)\n{\n\tbpf_u_int32 magic_int;\n\tsize_t amt_read;\n\tbpf_u_int32 total_length;\n\tbpf_u_int32 byte_order_magic;\n\tstruct block_header *bhdrp;\n\tstruct section_header_block *shbp;\n\tpcap_t *p;\n\tint swapped = 0;\n\tstruct pcap_ng_sf *ps;\n\tint status;\n\tstruct block_cursor cursor;\n\tstruct interface_description_block *idbp;\n\n\t/*\n\t * Assume no read errors.\n\t */\n\t*err = 0;\n\n\t/*\n\t * Check whether the first 4 bytes of the file are the block\n\t * type for a pcapng savefile.\n\t */\n\tmemcpy(&magic_int, magic, sizeof(magic_int));\n\tif (magic_int != BT_SHB) {\n\t\t/*\n\t\t * XXX - check whether this looks like what the block\n\t\t * type would be after being munged by mapping between\n\t\t * UN*X and DOS/Windows text file format and, if it\n\t\t * does, look for the byte-order magic number in\n\t\t * the appropriate place and, if we find it, report\n\t\t * this as possibly being a pcapng file transferred\n\t\t * between UN*X and Windows in text file format?\n\t\t */\n\t\treturn (NULL);\t/* nope */\n\t}\n\n\t/*\n\t * OK, they are.  However, that's just \\n\\r\\r\\n, so it could,\n\t * conceivably, be an ordinary text file.\n\t *\n\t * It could not, however, conceivably be any other type of\n\t * capture file, so we can read the rest of the putative\n\t * Section Header Block; put the block type in the common\n\t * header, read the rest of the common header and the\n\t * fixed-length portion of the SHB, and look for the byte-order\n\t * magic value.\n\t */\n\tamt_read = fread(&total_length, 1, sizeof(total_length), fp);\n\tif (amt_read < sizeof(total_length)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tamt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);\n\tif (amt_read < sizeof(byte_order_magic)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\tbyte_order_magic = SWAPLONG(byte_order_magic);\n\t\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\t\t/*\n\t\t\t * Not a pcapng file.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\t\tswapped = 1;\n\t\ttotal_length = SWAPLONG(total_length);\n\t}\n\n\t/*\n\t * Check the sanity of the total length.\n\t */\n \tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||\n             (total_length > BT_SHB_INSANE_MAX)) {\n \t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Section Header Block in pcapng dump file has invalid length %\" PRIsize \" < _%lu_ < %lu (BT_SHB_INSANE_MAX)\",\n                              sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),\n                              total_length,\n                              BT_SHB_INSANE_MAX);\n \n \t\t*err = 1;\n \t\treturn (NULL);\n\t}\n\n\n\n\t/*\n\t * OK, this is a good pcapng file.\n\t * Allocate a pcap_t for it.\n\t */\n\tp = pcap_open_offline_common(errbuf, sizeof (struct pcap_ng_sf));\n\tif (p == NULL) {\n\t\t/* Allocation failed. */\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tp->swapped = swapped;\n\tps = p->priv;\n\n\t/*\n\t * What precision does the user want?\n\t */\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\tps->user_tsresol = 1000000;\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tps->user_tsresol = 1000000000;\n\t\tbreak;\n\n\tdefault:\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unknown time stamp resolution %u\", precision);\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Allocate a buffer into which to read blocks.  We default to\n\t * the maximum of:\n\t *\n\t *\tthe total length of the SHB for which we read the header;\n\t *\n\t *\t2K, which should be more than large enough for an Enhanced\n\t *\tPacket Block containing a full-size Ethernet frame, and\n\t *\tleaving room for some options.\n\t *\n\t * If we find a bigger block, we reallocate the buffer, up to\n\t * the maximum size.  We start out with a maximum size of\n\t * INITIAL_MAX_BLOCKSIZE; if we see any link-layer header types\n\t * with a maximum snapshot that results in a larger maximum\n\t * block length, we boost the maximum.\n\t */\n\tp->bufsize = 2048;\n\tif (p->bufsize < total_length)\n\t\tp->bufsize = total_length;\n\tp->buffer = malloc(p->bufsize);\n\tif (p->buffer == NULL) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"out of memory\");\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tps->max_blocksize = INITIAL_MAX_BLOCKSIZE;\n\n\t/*\n\t * Copy the stuff we've read to the buffer, and read the rest\n\t * of the SHB.\n\t */\n\tbhdrp = (struct block_header *)p->buffer;\n\tshbp = (struct section_header_block *)((u_char *)p->buffer + sizeof(struct block_header));\n\tbhdrp->block_type = magic_int;\n\tbhdrp->total_length = total_length;\n\tshbp->byte_order_magic = byte_order_magic;\n\tif (read_bytes(fp,\n\t    (u_char *)p->buffer + (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    total_length - (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    1, errbuf) == -1)\n\t\tgoto fail;\n\n\tif (p->swapped) {\n\t\t/*\n\t\t * Byte-swap the fields we've read.\n\t\t */\n\t\tshbp->major_version = SWAPSHORT(shbp->major_version);\n\t\tshbp->minor_version = SWAPSHORT(shbp->minor_version);\n\n\t\t/*\n\t\t * XXX - we don't care about the section length.\n\t\t */\n\t}\n\t/* currently only SHB version 1.0 is supported */\n\tif (! (shbp->major_version == PCAP_NG_VERSION_MAJOR &&\n\t       shbp->minor_version == PCAP_NG_VERSION_MINOR)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unsupported pcapng savefile version %u.%u\",\n\t\t    shbp->major_version, shbp->minor_version);\n\t\tgoto fail;\n\t}\n\tp->version_major = shbp->major_version;\n\tp->version_minor = shbp->minor_version;\n\n\t/*\n\t * Save the time stamp resolution the user requested.\n\t */\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Now start looking for an Interface Description Block.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read the next block.\n\t\t */\n\t\tstatus = read_block(fp, p, &cursor, errbuf);\n\t\tif (status == 0) {\n\t\t\t/* EOF - no IDB in this file */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has no Interface Description Blocks\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (status == -1)\n\t\t\tgoto fail;\t/* error */\n\t\tswitch (cursor.block_type) {\n\n\t\tcase BT_IDB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * IDB.\n\t\t\t */\n\t\t\tidbp = get_from_block_data(&cursor, sizeof(*idbp),\n\t\t\t    errbuf);\n\t\t\tif (idbp == NULL)\n\t\t\t\tgoto fail;\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tidbp->linktype = SWAPSHORT(idbp->linktype);\n\t\t\t\tidbp->snaplen = SWAPLONG(idbp->snaplen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to add this interface.\n\t\t\t */\n\t\t\tif (!add_interface(p, &cursor, errbuf))\n\t\t\t\tgoto fail;\n\n\t\t\tgoto done;\n\n\t\tcase BT_EPB:\n\t\tcase BT_SPB:\n\t\tcase BT_PB:\n\t\t\t/*\n\t\t\t * Saw a packet before we saw any IDBs.  That's\n\t\t\t * not valid, as we don't know what link-layer\n\t\t\t * encapsulation the packet has.\n\t\t\t */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has a packet block before any Interface Description Blocks\");\n\t\t\tgoto fail;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Just ignore it.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tp->tzoff = 0;\t/* XXX - not used in pcap */\n\tp->linktype = linktype_to_dlt(idbp->linktype);\n\tp->snapshot = pcap_adjust_snapshot(p->linktype, idbp->snaplen);\n\tp->linktype_ext = 0;\n\n\t/*\n\t * If the maximum block size for a packet with the maximum\n\t * snapshot length for this DLT_ is bigger than the current\n\t * maximum block size, increase the maximum.\n\t */\n\tif (MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype)) > ps->max_blocksize)\n\t\tps->max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype));\n\n\tp->next_packet_op = pcap_ng_next_packet;\n\tp->cleanup_op = pcap_ng_cleanup;\n\n\treturn (p);\n\nfail:\n\tfree(ps->ifaces);\n\tfree(p->buffer);\n\tfree(p);\n\t*err = 1;\n\treturn (NULL);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143191,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "pcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,\n    char *errbuf, int *err)\n{\n\tbpf_u_int32 magic_int;\n\tsize_t amt_read;\n\tbpf_u_int32 total_length;\n\tbpf_u_int32 byte_order_magic;\n\tstruct block_header *bhdrp;\n\tstruct section_header_block *shbp;\n\tpcap_t *p;\n\tint swapped = 0;\n\tstruct pcap_ng_sf *ps;\n\tint status;\n\tstruct block_cursor cursor;\n\tstruct interface_description_block *idbp;\n\n\t/*\n\t * Assume no read errors.\n\t */\n\t*err = 0;\n\n\t/*\n\t * Check whether the first 4 bytes of the file are the block\n\t * type for a pcapng savefile.\n\t */\n\tmemcpy(&magic_int, magic, sizeof(magic_int));\n\tif (magic_int != BT_SHB) {\n\t\t/*\n\t\t * XXX - check whether this looks like what the block\n\t\t * type would be after being munged by mapping between\n\t\t * UN*X and DOS/Windows text file format and, if it\n\t\t * does, look for the byte-order magic number in\n\t\t * the appropriate place and, if we find it, report\n\t\t * this as possibly being a pcapng file transferred\n\t\t * between UN*X and Windows in text file format?\n\t\t */\n\t\treturn (NULL);\t/* nope */\n\t}\n\n\t/*\n\t * OK, they are.  However, that's just \\n\\r\\r\\n, so it could,\n\t * conceivably, be an ordinary text file.\n\t *\n\t * It could not, however, conceivably be any other type of\n\t * capture file, so we can read the rest of the putative\n\t * Section Header Block; put the block type in the common\n\t * header, read the rest of the common header and the\n\t * fixed-length portion of the SHB, and look for the byte-order\n\t * magic value.\n\t */\n\tamt_read = fread(&total_length, 1, sizeof(total_length), fp);\n\tif (amt_read < sizeof(total_length)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tamt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);\n\tif (amt_read < sizeof(byte_order_magic)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\tbyte_order_magic = SWAPLONG(byte_order_magic);\n\t\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\t\t/*\n\t\t\t * Not a pcapng file.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\t\tswapped = 1;\n\t\ttotal_length = SWAPLONG(total_length);\n\t}\n\n\t/*\n\t * Check the sanity of the total length.\n\t */\n \tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||\n             (total_length > BT_SHB_INSANE_MAX)) {\n \t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Section Header Block in pcapng dump file has invalid length %\" PRIsize \" < _%u_ < %u (BT_SHB_INSANE_MAX)\",\n\t\t    sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),\n\t\t    total_length,\n\t\t    BT_SHB_INSANE_MAX);\n \n \t\t*err = 1;\n \t\treturn (NULL);\n\t}\n\n\n\n\t/*\n\t * OK, this is a good pcapng file.\n\t * Allocate a pcap_t for it.\n\t */\n\tp = pcap_open_offline_common(errbuf, sizeof (struct pcap_ng_sf));\n\tif (p == NULL) {\n\t\t/* Allocation failed. */\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tp->swapped = swapped;\n\tps = p->priv;\n\n\t/*\n\t * What precision does the user want?\n\t */\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\tps->user_tsresol = 1000000;\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tps->user_tsresol = 1000000000;\n\t\tbreak;\n\n\tdefault:\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unknown time stamp resolution %u\", precision);\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Allocate a buffer into which to read blocks.  We default to\n\t * the maximum of:\n\t *\n\t *\tthe total length of the SHB for which we read the header;\n\t *\n\t *\t2K, which should be more than large enough for an Enhanced\n\t *\tPacket Block containing a full-size Ethernet frame, and\n\t *\tleaving room for some options.\n\t *\n\t * If we find a bigger block, we reallocate the buffer, up to\n\t * the maximum size.  We start out with a maximum size of\n\t * INITIAL_MAX_BLOCKSIZE; if we see any link-layer header types\n\t * with a maximum snapshot that results in a larger maximum\n\t * block length, we boost the maximum.\n\t */\n\tp->bufsize = 2048;\n\tif (p->bufsize < total_length)\n\t\tp->bufsize = total_length;\n\tp->buffer = malloc(p->bufsize);\n\tif (p->buffer == NULL) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"out of memory\");\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tps->max_blocksize = INITIAL_MAX_BLOCKSIZE;\n\n\t/*\n\t * Copy the stuff we've read to the buffer, and read the rest\n\t * of the SHB.\n\t */\n\tbhdrp = (struct block_header *)p->buffer;\n\tshbp = (struct section_header_block *)((u_char *)p->buffer + sizeof(struct block_header));\n\tbhdrp->block_type = magic_int;\n\tbhdrp->total_length = total_length;\n\tshbp->byte_order_magic = byte_order_magic;\n\tif (read_bytes(fp,\n\t    (u_char *)p->buffer + (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    total_length - (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    1, errbuf) == -1)\n\t\tgoto fail;\n\n\tif (p->swapped) {\n\t\t/*\n\t\t * Byte-swap the fields we've read.\n\t\t */\n\t\tshbp->major_version = SWAPSHORT(shbp->major_version);\n\t\tshbp->minor_version = SWAPSHORT(shbp->minor_version);\n\n\t\t/*\n\t\t * XXX - we don't care about the section length.\n\t\t */\n\t}\n\t/* currently only SHB version 1.0 is supported */\n\tif (! (shbp->major_version == PCAP_NG_VERSION_MAJOR &&\n\t       shbp->minor_version == PCAP_NG_VERSION_MINOR)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unsupported pcapng savefile version %u.%u\",\n\t\t    shbp->major_version, shbp->minor_version);\n\t\tgoto fail;\n\t}\n\tp->version_major = shbp->major_version;\n\tp->version_minor = shbp->minor_version;\n\n\t/*\n\t * Save the time stamp resolution the user requested.\n\t */\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Now start looking for an Interface Description Block.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read the next block.\n\t\t */\n\t\tstatus = read_block(fp, p, &cursor, errbuf);\n\t\tif (status == 0) {\n\t\t\t/* EOF - no IDB in this file */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has no Interface Description Blocks\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (status == -1)\n\t\t\tgoto fail;\t/* error */\n\t\tswitch (cursor.block_type) {\n\n\t\tcase BT_IDB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * IDB.\n\t\t\t */\n\t\t\tidbp = get_from_block_data(&cursor, sizeof(*idbp),\n\t\t\t    errbuf);\n\t\t\tif (idbp == NULL)\n\t\t\t\tgoto fail;\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tidbp->linktype = SWAPSHORT(idbp->linktype);\n\t\t\t\tidbp->snaplen = SWAPLONG(idbp->snaplen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to add this interface.\n\t\t\t */\n\t\t\tif (!add_interface(p, &cursor, errbuf))\n\t\t\t\tgoto fail;\n\n\t\t\tgoto done;\n\n\t\tcase BT_EPB:\n\t\tcase BT_SPB:\n\t\tcase BT_PB:\n\t\t\t/*\n\t\t\t * Saw a packet before we saw any IDBs.  That's\n\t\t\t * not valid, as we don't know what link-layer\n\t\t\t * encapsulation the packet has.\n\t\t\t */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has a packet block before any Interface Description Blocks\");\n\t\t\tgoto fail;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Just ignore it.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tp->tzoff = 0;\t/* XXX - not used in pcap */\n\tp->linktype = linktype_to_dlt(idbp->linktype);\n\tp->snapshot = pcap_adjust_snapshot(p->linktype, idbp->snaplen);\n\tp->linktype_ext = 0;\n\n\t/*\n\t * If the maximum block size for a packet with the maximum\n\t * snapshot length for this DLT_ is bigger than the current\n\t * maximum block size, increase the maximum.\n\t */\n\tif (MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype)) > ps->max_blocksize)\n\t\tps->max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype));\n\n\tp->next_packet_op = pcap_ng_next_packet;\n\tp->cleanup_op = pcap_ng_cleanup;\n\n\treturn (p);\n\nfail:\n\tfree(ps->ifaces);\n\tfree(p->buffer);\n\tfree(p);\n\t*err = 1;\n\treturn (NULL);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143192,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static __forceinline void draw_line(float *output, int x0, int y0, int x1, int y1, int n)\n{\n   int dy = y1 - y0;\n   int adx = x1 - x0;\n   int ady = abs(dy);\n   int base;\n   int x=x0,y=y0;\n   int err = 0;\n   int sy;\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n   if (adx < DIVTAB_DENOM && ady < DIVTAB_NUMER) {\n      if (dy < 0) {\n         base = -integer_divide_table[ady][adx];\n         sy = base-1;\n      } else {\n         base =  integer_divide_table[ady][adx];\n         sy = base+1;\n      }\n   } else {\n      base = dy / adx;\n      if (dy < 0)\n         sy = base - 1;\n      else\n         sy = base+1;\n   }\n#else\n   base = dy / adx;\n   if (dy < 0)\n      sy = base - 1;\n   else\n      sy = base+1;\n#endif\n    ady -= abs(base) * adx;\n    if (x1 > n) x1 = n;\n    if (x < x1) {\n      LINE_OP(output[x], inverse_db_table[y]);\n       for (++x; x < x1; ++x) {\n          err += ady;\n          if (err >= adx) {\n             err -= adx;\n             y += sy;\n          } else\n             y += base;\n         LINE_OP(output[x], inverse_db_table[y]);\n       }\n    }\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143233,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static __forceinline void draw_line(float *output, int x0, int y0, int x1, int y1, int n)\n{\n   int dy = y1 - y0;\n   int adx = x1 - x0;\n   int ady = abs(dy);\n   int base;\n   int x=x0,y=y0;\n   int err = 0;\n   int sy;\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n   if (adx < DIVTAB_DENOM && ady < DIVTAB_NUMER) {\n      if (dy < 0) {\n         base = -integer_divide_table[ady][adx];\n         sy = base-1;\n      } else {\n         base =  integer_divide_table[ady][adx];\n         sy = base+1;\n      }\n   } else {\n      base = dy / adx;\n      if (dy < 0)\n         sy = base - 1;\n      else\n         sy = base+1;\n   }\n#else\n   base = dy / adx;\n   if (dy < 0)\n      sy = base - 1;\n   else\n      sy = base+1;\n#endif\n    ady -= abs(base) * adx;\n    if (x1 > n) x1 = n;\n    if (x < x1) {\n      LINE_OP(output[x], inverse_db_table[y&255]);\n       for (++x; x < x1; ++x) {\n          err += ady;\n          if (err >= adx) {\n             err -= adx;\n             y += sy;\n          } else\n             y += base;\n         LINE_OP(output[x], inverse_db_table[y&255]);\n       }\n    }\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143234,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static float *get_window(vorb *f, int len)\n{\n    len <<= 1;\n    if (len == f->blocksize_0) return f->window[0];\n    if (len == f->blocksize_1) return f->window[1];\n   assert(0);\n    return NULL;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143235,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static float *get_window(vorb *f, int len)\n{\n    len <<= 1;\n    if (len == f->blocksize_0) return f->window[0];\n    if (len == f->blocksize_1) return f->window[1];\n    return NULL;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143236,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int lookup1_values(int entries, int dim)\n{\n    int r = (int) floor(exp((float) log((float) entries) / dim));\n    if ((int) floor(pow((float) r+1, dim)) <= entries)   // (int) cast for MinGW warning;\n       ++r;                                              // floor() to avoid _ftol() when non-CRT\n   assert(pow((float) r+1, dim) > entries);\n   assert((int) floor(pow((float) r, dim)) <= entries); // (int),floor() as above\n    return r;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143237,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int lookup1_values(int entries, int dim)\n{\n    int r = (int) floor(exp((float) log((float) entries) / dim));\n    if ((int) floor(pow((float) r+1, dim)) <= entries)   // (int) cast for MinGW warning;\n       ++r;                                              // floor() to avoid _ftol() when non-CRT\n   if (pow((float) r+1, dim) <= entries)\n      return -1;\n   if ((int) floor(pow((float) r, dim)) > entries)\n      return -1;\n    return r;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143238,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int start_decoder(vorb *f)\n{\n   uint8 header[6], x,y;\n   int len,i,j,k, max_submaps = 0;\n   int longest_floorlist=0;\n\n\n   if (!start_page(f))                              return FALSE;\n   if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page);\n   if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page);\n   if (f->segments[0] != 30) {\n      if (f->segments[0] == 64 &&\n          getn(f, header, 6) &&\n          header[0] == 'f' &&\n          header[1] == 'i' &&\n          header[2] == 's' &&\n          header[3] == 'h' &&\n          header[4] == 'e' &&\n          header[5] == 'a' &&\n          get8(f)   == 'd' &&\n          get8(f)   == '\\0')                        return error(f, VORBIS_ogg_skeleton_not_supported);\n      else\n                                                    return error(f, VORBIS_invalid_first_page);\n   }\n\n   if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page);\n   if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page);\n   if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page);\n   f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page);\n   if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels);\n   f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page);\n   get32(f); // bitrate_maximum\n   get32(f); // bitrate_nominal\n   get32(f); // bitrate_minimum\n   x = get8(f);\n   {\n      int log0,log1;\n      log0 = x & 15;\n      log1 = x >> 4;\n      f->blocksize_0 = 1 << log0;\n      f->blocksize_1 = 1 << log1;\n      if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log0 > log1)                                 return error(f, VORBIS_invalid_setup);\n   }\n\n   x = get8(f);\n   if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page);\n\n   if (!start_page(f))                              return FALSE;\n\n   if (!start_packet(f))                            return FALSE;\n   do {\n      len = next_segment(f);\n      skip(f, len);\n      f->bytes_in_seg = 0;\n   } while (len);\n\n   if (!start_packet(f))                            return FALSE;\n\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (IS_PUSH_MODE(f)) {\n      if (!is_whole_packet_present(f, TRUE)) {\n         if (f->error == VORBIS_invalid_stream)\n            f->error = VORBIS_invalid_setup;\n         return FALSE;\n      }\n   }\n   #endif\n\n   crc32_init(); // always init it, to avoid multithread race conditions\n\n   if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup);\n   for (i=0; i < 6; ++i) header[i] = get8_packet(f);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);\n\n\n   f->codebook_count = get_bits(f,8) + 1;\n   f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);\n   if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem);\n   memset(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count);\n   for (i=0; i < f->codebook_count; ++i) {\n      uint32 *values;\n      int ordered, sorted_count;\n      int total=0;\n      uint8 *lengths;\n      Codebook *c = f->codebooks+i;\n      CHECK(f);\n      x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8);\n      c->dimensions = (get_bits(f, 8)<<8) + x;\n      x = get_bits(f, 8);\n      y = get_bits(f, 8);\n      c->entries = (get_bits(f, 8)<<16) + (y<<8) + x;\n      ordered = get_bits(f,1);\n      c->sparse = ordered ? 0 : get_bits(f,1);\n\n      if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup);\n\n      if (c->sparse)\n         lengths = (uint8 *) setup_temp_malloc(f, c->entries);\n      else\n         lengths = c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n\n      if (!lengths) return error(f, VORBIS_outofmem);\n\n      if (ordered) {\n         int current_entry = 0;\n         int current_length = get_bits(f,5) + 1;\n          while (current_entry < c->entries) {\n             int limit = c->entries - current_entry;\n             int n = get_bits(f, ilog(limit));\n             if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }\n             memset(lengths + current_entry, current_length, n);\n             current_entry += n;\n            ++current_length;\n         }\n      } else {\n         for (j=0; j < c->entries; ++j) {\n            int present = c->sparse ? get_bits(f,1) : 1;\n            if (present) {\n               lengths[j] = get_bits(f, 5) + 1;\n               ++total;\n               if (lengths[j] == 32)\n                  return error(f, VORBIS_invalid_setup);\n            } else {\n               lengths[j] = NO_CODE;\n            }\n         }\n      }\n\n      if (c->sparse && total >= c->entries >> 2) {\n         if (c->entries > (int) f->setup_temp_memory_required)\n            f->setup_temp_memory_required = c->entries;\n\n         c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n         if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem);\n         memcpy(c->codeword_lengths, lengths, c->entries);\n         setup_temp_free(f, lengths, c->entries); // note this is only safe if there have been no intervening temp mallocs!\n         lengths = c->codeword_lengths;\n         c->sparse = 0;\n      }\n\n      if (c->sparse) {\n         sorted_count = total;\n      } else {\n         sorted_count = 0;\n         #ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n         for (j=0; j < c->entries; ++j)\n            if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE)\n               ++sorted_count;\n         #endif\n      }\n\n      c->sorted_entries = sorted_count;\n      values = NULL;\n\n      CHECK(f);\n      if (!c->sparse) {\n         c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries);\n         if (!c->codewords)                  return error(f, VORBIS_outofmem);\n      } else {\n         unsigned int size;\n         if (c->sorted_entries) {\n            c->codeword_lengths = (uint8 *) setup_malloc(f, c->sorted_entries);\n            if (!c->codeword_lengths)           return error(f, VORBIS_outofmem);\n            c->codewords = (uint32 *) setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries);\n            if (!c->codewords)                  return error(f, VORBIS_outofmem);\n            values = (uint32 *) setup_temp_malloc(f, sizeof(*values) * c->sorted_entries);\n            if (!values)                        return error(f, VORBIS_outofmem);\n         }\n         size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries;\n         if (size > f->setup_temp_memory_required)\n            f->setup_temp_memory_required = size;\n      }\n\n      if (!compute_codewords(c, lengths, c->entries, values)) {\n         if (c->sparse) setup_temp_free(f, values, 0);\n         return error(f, VORBIS_invalid_setup);\n      }\n\n      if (c->sorted_entries) {\n         c->sorted_codewords = (uint32 *) setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries+1));\n         if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem);\n         c->sorted_values    = ( int   *) setup_malloc(f, sizeof(*c->sorted_values   ) * (c->sorted_entries+1));\n         if (c->sorted_values == NULL) return error(f, VORBIS_outofmem);\n         ++c->sorted_values;\n         c->sorted_values[-1] = -1;\n         compute_sorted_huffman(c, lengths, values);\n      }\n\n      if (c->sparse) {\n         setup_temp_free(f, values, sizeof(*values)*c->sorted_entries);\n         setup_temp_free(f, c->codewords, sizeof(*c->codewords)*c->sorted_entries);\n         setup_temp_free(f, lengths, c->entries);\n         c->codewords = NULL;\n      }\n\n      compute_accelerated_huffman(c);\n\n      CHECK(f);\n      c->lookup_type = get_bits(f, 4);\n      if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup);\n      if (c->lookup_type > 0) {\n         uint16 *mults;\n         c->minimum_value = float32_unpack(get_bits(f, 32));\n         c->delta_value = float32_unpack(get_bits(f, 32));\n          c->value_bits = get_bits(f, 4)+1;\n          c->sequence_p = get_bits(f,1);\n          if (c->lookup_type == 1) {\n            c->lookup_values = lookup1_values(c->entries, c->dimensions);\n          } else {\n             c->lookup_values = c->entries * c->dimensions;\n          }\n         if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup);\n         mults = (uint16 *) setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values);\n         if (mults == NULL) return error(f, VORBIS_outofmem);\n         for (j=0; j < (int) c->lookup_values; ++j) {\n            int q = get_bits(f, c->value_bits);\n            if (q == EOP) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); }\n            mults[j] = q;\n         }\n\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n         if (c->lookup_type == 1) {\n            int len, sparse = c->sparse;\n            float last=0;\n            if (sparse) {\n               if (c->sorted_entries == 0) goto skip;\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions);\n            } else\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries        * c->dimensions);\n            if (c->multiplicands == NULL) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            len = sparse ? c->sorted_entries : c->entries;\n            for (j=0; j < len; ++j) {\n               unsigned int z = sparse ? c->sorted_values[j] : j;\n               unsigned int div=1;\n               for (k=0; k < c->dimensions; ++k) {\n                  int off = (z / div) % c->lookup_values;\n                  float val = mults[off];\n                  val = mults[off]*c->delta_value + c->minimum_value + last;\n                  c->multiplicands[j*c->dimensions + k] = val;\n                  if (c->sequence_p)\n                     last = val;\n                  if (k+1 < c->dimensions) {\n                     if (div > UINT_MAX / (unsigned int) c->lookup_values) {\n                        setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values);\n                        return error(f, VORBIS_invalid_setup);\n                     }\n                     div *= c->lookup_values;\n                  }\n               }\n            }\n            c->lookup_type = 2;\n         }\n         else\n#endif\n         {\n            float last=0;\n            CHECK(f);\n            c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values);\n            if (c->multiplicands == NULL) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            for (j=0; j < (int) c->lookup_values; ++j) {\n               float val = mults[j] * c->delta_value + c->minimum_value + last;\n               c->multiplicands[j] = val;\n               if (c->sequence_p)\n                  last = val;\n            }\n         }\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n        skip:;\n#endif\n         setup_temp_free(f, mults, sizeof(mults[0])*c->lookup_values);\n\n         CHECK(f);\n      }\n      CHECK(f);\n   }\n\n\n   x = get_bits(f, 6) + 1;\n   for (i=0; i < x; ++i) {\n      uint32 z = get_bits(f, 16);\n      if (z != 0) return error(f, VORBIS_invalid_setup);\n   }\n\n   f->floor_count = get_bits(f, 6)+1;\n   f->floor_config = (Floor *)  setup_malloc(f, f->floor_count * sizeof(*f->floor_config));\n   if (f->floor_config == NULL) return error(f, VORBIS_outofmem);\n   for (i=0; i < f->floor_count; ++i) {\n      f->floor_types[i] = get_bits(f, 16);\n      if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup);\n      if (f->floor_types[i] == 0) {\n         Floor0 *g = &f->floor_config[i].floor0;\n         g->order = get_bits(f,8);\n         g->rate = get_bits(f,16);\n         g->bark_map_size = get_bits(f,16);\n         g->amplitude_bits = get_bits(f,6);\n         g->amplitude_offset = get_bits(f,8);\n         g->number_of_books = get_bits(f,4) + 1;\n         for (j=0; j < g->number_of_books; ++j)\n            g->book_list[j] = get_bits(f,8);\n         return error(f, VORBIS_feature_not_supported);\n      } else {\n         stbv__floor_ordering p[31*8+2];\n         Floor1 *g = &f->floor_config[i].floor1;\n         int max_class = -1; \n         g->partitions = get_bits(f, 5);\n         for (j=0; j < g->partitions; ++j) {\n            g->partition_class_list[j] = get_bits(f, 4);\n            if (g->partition_class_list[j] > max_class)\n               max_class = g->partition_class_list[j];\n         }\n         for (j=0; j <= max_class; ++j) {\n            g->class_dimensions[j] = get_bits(f, 3)+1;\n            g->class_subclasses[j] = get_bits(f, 2);\n            if (g->class_subclasses[j]) {\n               g->class_masterbooks[j] = get_bits(f, 8);\n               if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n            for (k=0; k < 1 << g->class_subclasses[j]; ++k) {\n               g->subclass_books[j][k] = get_bits(f,8)-1;\n               if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n         }\n         g->floor1_multiplier = get_bits(f,2)+1;\n         g->rangebits = get_bits(f,4);\n         g->Xlist[0] = 0;\n         g->Xlist[1] = 1 << g->rangebits;\n         g->values = 2;\n         for (j=0; j < g->partitions; ++j) {\n            int c = g->partition_class_list[j];\n            for (k=0; k < g->class_dimensions[c]; ++k) {\n               g->Xlist[g->values] = get_bits(f, g->rangebits);\n               ++g->values;\n            }\n         }\n         for (j=0; j < g->values; ++j) {\n            p[j].x = g->Xlist[j];\n             p[j].id = j;\n          }\n          qsort(p, g->values, sizeof(p[0]), point_compare);\n          for (j=0; j < g->values; ++j)\n             g->sorted_order[j] = (uint8) p[j].id;\n         for (j=2; j < g->values; ++j) {\n            int low,hi;\n            neighbors(g->Xlist, j, &low,&hi);\n            g->neighbors[j][0] = low;\n            g->neighbors[j][1] = hi;\n         }\n\n         if (g->values > longest_floorlist)\n            longest_floorlist = g->values;\n      }\n   }\n\n   f->residue_count = get_bits(f, 6)+1;\n   f->residue_config = (Residue *) setup_malloc(f, f->residue_count * sizeof(f->residue_config[0]));\n   if (f->residue_config == NULL) return error(f, VORBIS_outofmem);\n   memset(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0]));\n   for (i=0; i < f->residue_count; ++i) {\n      uint8 residue_cascade[64];\n      Residue *r = f->residue_config+i;\n      f->residue_types[i] = get_bits(f, 16);\n      if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup);\n      r->begin = get_bits(f, 24);\n      r->end = get_bits(f, 24);\n      if (r->end < r->begin) return error(f, VORBIS_invalid_setup);\n      r->part_size = get_bits(f,24)+1;\n      r->classifications = get_bits(f,6)+1;\n      r->classbook = get_bits(f,8);\n      if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n      for (j=0; j < r->classifications; ++j) {\n         uint8 high_bits=0;\n         uint8 low_bits=get_bits(f,3);\n         if (get_bits(f,1))\n            high_bits = get_bits(f,5);\n         residue_cascade[j] = high_bits*8 + low_bits;\n      }\n      r->residue_books = (short (*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications);\n      if (r->residue_books == NULL) return error(f, VORBIS_outofmem);\n      for (j=0; j < r->classifications; ++j) {\n         for (k=0; k < 8; ++k) {\n            if (residue_cascade[j] & (1 << k)) {\n               r->residue_books[j][k] = get_bits(f, 8);\n               if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            } else {\n               r->residue_books[j][k] = -1;\n            }\n         }\n      }\n      r->classdata = (uint8 **) setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      if (!r->classdata) return error(f, VORBIS_outofmem);\n      memset(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      for (j=0; j < f->codebooks[r->classbook].entries; ++j) {\n         int classwords = f->codebooks[r->classbook].dimensions;\n         int temp = j;\n         r->classdata[j] = (uint8 *) setup_malloc(f, sizeof(r->classdata[j][0]) * classwords);\n         if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem);\n         for (k=classwords-1; k >= 0; --k) {\n            r->classdata[j][k] = temp % r->classifications;\n            temp /= r->classifications;\n         }\n      }\n   }\n\n   f->mapping_count = get_bits(f,6)+1;\n   f->mapping = (Mapping *) setup_malloc(f, f->mapping_count * sizeof(*f->mapping));\n   if (f->mapping == NULL) return error(f, VORBIS_outofmem);\n   memset(f->mapping, 0, f->mapping_count * sizeof(*f->mapping));\n   for (i=0; i < f->mapping_count; ++i) {\n      Mapping *m = f->mapping + i;      \n      int mapping_type = get_bits(f,16);\n      if (mapping_type != 0) return error(f, VORBIS_invalid_setup);\n      m->chan = (MappingChannel *) setup_malloc(f, f->channels * sizeof(*m->chan));\n      if (m->chan == NULL) return error(f, VORBIS_outofmem);\n      if (get_bits(f,1))\n         m->submaps = get_bits(f,4)+1;\n      else\n         m->submaps = 1;\n      if (m->submaps > max_submaps)\n          max_submaps = m->submaps;\n       if (get_bits(f,1)) {\n          m->coupling_steps = get_bits(f,8)+1;\n          for (k=0; k < m->coupling_steps; ++k) {\n             m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));\n             m->chan[k].angle = get_bits(f, ilog(f->channels-1));\n            if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].angle     >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         m->coupling_steps = 0;\n\n      if (get_bits(f,2)) return error(f, VORBIS_invalid_setup);\n      if (m->submaps > 1) {\n         for (j=0; j < f->channels; ++j) {\n            m->chan[j].mux = get_bits(f, 4);\n            if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         for (j=0; j < f->channels; ++j)\n            m->chan[j].mux = 0;\n\n      for (j=0; j < m->submaps; ++j) {\n         get_bits(f,8); // discard\n         m->submap_floor[j] = get_bits(f,8);\n         m->submap_residue[j] = get_bits(f,8);\n         if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);\n         if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);\n      }\n   }\n\n   f->mode_count = get_bits(f, 6)+1;\n   for (i=0; i < f->mode_count; ++i) {\n      Mode *m = f->mode_config+i;\n      m->blockflag = get_bits(f,1);\n      m->windowtype = get_bits(f,16);\n      m->transformtype = get_bits(f,16);\n      m->mapping = get_bits(f,8);\n      if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup);\n      if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup);\n      if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup);\n   }\n\n   flush_packet(f);\n\n   f->previous_length = 0;\n\n   for (i=0; i < f->channels; ++i) {\n      f->channel_buffers[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1);\n      f->previous_window[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      f->finalY[i]          = (int16 *) setup_malloc(f, sizeof(int16) * longest_floorlist);\n      if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem);\n      memset(f->channel_buffers[i], 0, sizeof(float) * f->blocksize_1);\n      #ifdef STB_VORBIS_NO_DEFER_FLOOR\n      f->floor_buffers[i]   = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      if (f->floor_buffers[i] == NULL) return error(f, VORBIS_outofmem);\n      #endif\n   }\n\n   if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE;\n   if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE;\n   f->blocksize[0] = f->blocksize_0;\n   f->blocksize[1] = f->blocksize_1;\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n   if (integer_divide_table[1][1]==0)\n      for (i=0; i < DIVTAB_NUMER; ++i)\n         for (j=1; j < DIVTAB_DENOM; ++j)\n            integer_divide_table[i][j] = i / j;\n#endif\n\n\n   {\n      uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1);\n      uint32 classify_mem;\n      int i,max_part_read=0;\n      for (i=0; i < f->residue_count; ++i) {\n         Residue *r = f->residue_config + i;\n         unsigned int actual_size = f->blocksize_1 / 2;\n         unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size;\n         unsigned int limit_r_end   = r->end   < actual_size ? r->end   : actual_size;\n         int n_read = limit_r_end - limit_r_begin;\n         int part_read = n_read / r->part_size;\n         if (part_read > max_part_read)\n            max_part_read = part_read;\n      }\n      #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8 *));\n      #else\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *));\n      #endif\n\n\n      f->temp_memory_required = classify_mem;\n      if (imdct_mem > f->temp_memory_required)\n         f->temp_memory_required = imdct_mem;\n   }\n\n   f->first_decode = TRUE;\n\n   if (f->alloc.alloc_buffer) {\n      assert(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes);\n      if (f->setup_offset + sizeof(*f) + f->temp_memory_required > (unsigned) f->temp_offset)\n         return error(f, VORBIS_outofmem);\n   }\n\n   f->first_audio_page_offset = stb_vorbis_get_file_offset(f);\n\n   return TRUE;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143239,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int start_decoder(vorb *f)\n{\n   uint8 header[6], x,y;\n   int len,i,j,k, max_submaps = 0;\n   int longest_floorlist=0;\n\n\n   if (!start_page(f))                              return FALSE;\n   if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page);\n   if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page);\n   if (f->segments[0] != 30) {\n      if (f->segments[0] == 64 &&\n          getn(f, header, 6) &&\n          header[0] == 'f' &&\n          header[1] == 'i' &&\n          header[2] == 's' &&\n          header[3] == 'h' &&\n          header[4] == 'e' &&\n          header[5] == 'a' &&\n          get8(f)   == 'd' &&\n          get8(f)   == '\\0')                        return error(f, VORBIS_ogg_skeleton_not_supported);\n      else\n                                                    return error(f, VORBIS_invalid_first_page);\n   }\n\n   if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page);\n   if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page);\n   if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page);\n   f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page);\n   if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels);\n   f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page);\n   get32(f); // bitrate_maximum\n   get32(f); // bitrate_nominal\n   get32(f); // bitrate_minimum\n   x = get8(f);\n   {\n      int log0,log1;\n      log0 = x & 15;\n      log1 = x >> 4;\n      f->blocksize_0 = 1 << log0;\n      f->blocksize_1 = 1 << log1;\n      if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log0 > log1)                                 return error(f, VORBIS_invalid_setup);\n   }\n\n   x = get8(f);\n   if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page);\n\n   if (!start_page(f))                              return FALSE;\n\n   if (!start_packet(f))                            return FALSE;\n   do {\n      len = next_segment(f);\n      skip(f, len);\n      f->bytes_in_seg = 0;\n   } while (len);\n\n   if (!start_packet(f))                            return FALSE;\n\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (IS_PUSH_MODE(f)) {\n      if (!is_whole_packet_present(f, TRUE)) {\n         if (f->error == VORBIS_invalid_stream)\n            f->error = VORBIS_invalid_setup;\n         return FALSE;\n      }\n   }\n   #endif\n\n   crc32_init(); // always init it, to avoid multithread race conditions\n\n   if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup);\n   for (i=0; i < 6; ++i) header[i] = get8_packet(f);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);\n\n\n   f->codebook_count = get_bits(f,8) + 1;\n   f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);\n   if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem);\n   memset(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count);\n   for (i=0; i < f->codebook_count; ++i) {\n      uint32 *values;\n      int ordered, sorted_count;\n      int total=0;\n      uint8 *lengths;\n      Codebook *c = f->codebooks+i;\n      CHECK(f);\n      x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8);\n      c->dimensions = (get_bits(f, 8)<<8) + x;\n      x = get_bits(f, 8);\n      y = get_bits(f, 8);\n      c->entries = (get_bits(f, 8)<<16) + (y<<8) + x;\n      ordered = get_bits(f,1);\n      c->sparse = ordered ? 0 : get_bits(f,1);\n\n      if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup);\n\n      if (c->sparse)\n         lengths = (uint8 *) setup_temp_malloc(f, c->entries);\n      else\n         lengths = c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n\n      if (!lengths) return error(f, VORBIS_outofmem);\n\n      if (ordered) {\n         int current_entry = 0;\n         int current_length = get_bits(f,5) + 1;\n          while (current_entry < c->entries) {\n             int limit = c->entries - current_entry;\n             int n = get_bits(f, ilog(limit));\n            if (current_length >= 32) return error(f, VORBIS_invalid_setup);\n             if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }\n             memset(lengths + current_entry, current_length, n);\n             current_entry += n;\n            ++current_length;\n         }\n      } else {\n         for (j=0; j < c->entries; ++j) {\n            int present = c->sparse ? get_bits(f,1) : 1;\n            if (present) {\n               lengths[j] = get_bits(f, 5) + 1;\n               ++total;\n               if (lengths[j] == 32)\n                  return error(f, VORBIS_invalid_setup);\n            } else {\n               lengths[j] = NO_CODE;\n            }\n         }\n      }\n\n      if (c->sparse && total >= c->entries >> 2) {\n         if (c->entries > (int) f->setup_temp_memory_required)\n            f->setup_temp_memory_required = c->entries;\n\n         c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n         if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem);\n         memcpy(c->codeword_lengths, lengths, c->entries);\n         setup_temp_free(f, lengths, c->entries); // note this is only safe if there have been no intervening temp mallocs!\n         lengths = c->codeword_lengths;\n         c->sparse = 0;\n      }\n\n      if (c->sparse) {\n         sorted_count = total;\n      } else {\n         sorted_count = 0;\n         #ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n         for (j=0; j < c->entries; ++j)\n            if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE)\n               ++sorted_count;\n         #endif\n      }\n\n      c->sorted_entries = sorted_count;\n      values = NULL;\n\n      CHECK(f);\n      if (!c->sparse) {\n         c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries);\n         if (!c->codewords)                  return error(f, VORBIS_outofmem);\n      } else {\n         unsigned int size;\n         if (c->sorted_entries) {\n            c->codeword_lengths = (uint8 *) setup_malloc(f, c->sorted_entries);\n            if (!c->codeword_lengths)           return error(f, VORBIS_outofmem);\n            c->codewords = (uint32 *) setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries);\n            if (!c->codewords)                  return error(f, VORBIS_outofmem);\n            values = (uint32 *) setup_temp_malloc(f, sizeof(*values) * c->sorted_entries);\n            if (!values)                        return error(f, VORBIS_outofmem);\n         }\n         size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries;\n         if (size > f->setup_temp_memory_required)\n            f->setup_temp_memory_required = size;\n      }\n\n      if (!compute_codewords(c, lengths, c->entries, values)) {\n         if (c->sparse) setup_temp_free(f, values, 0);\n         return error(f, VORBIS_invalid_setup);\n      }\n\n      if (c->sorted_entries) {\n         c->sorted_codewords = (uint32 *) setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries+1));\n         if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem);\n         c->sorted_values    = ( int   *) setup_malloc(f, sizeof(*c->sorted_values   ) * (c->sorted_entries+1));\n         if (c->sorted_values == NULL) return error(f, VORBIS_outofmem);\n         ++c->sorted_values;\n         c->sorted_values[-1] = -1;\n         compute_sorted_huffman(c, lengths, values);\n      }\n\n      if (c->sparse) {\n         setup_temp_free(f, values, sizeof(*values)*c->sorted_entries);\n         setup_temp_free(f, c->codewords, sizeof(*c->codewords)*c->sorted_entries);\n         setup_temp_free(f, lengths, c->entries);\n         c->codewords = NULL;\n      }\n\n      compute_accelerated_huffman(c);\n\n      CHECK(f);\n      c->lookup_type = get_bits(f, 4);\n      if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup);\n      if (c->lookup_type > 0) {\n         uint16 *mults;\n         c->minimum_value = float32_unpack(get_bits(f, 32));\n         c->delta_value = float32_unpack(get_bits(f, 32));\n          c->value_bits = get_bits(f, 4)+1;\n          c->sequence_p = get_bits(f,1);\n          if (c->lookup_type == 1) {\n            int values = lookup1_values(c->entries, c->dimensions);\n            if (values < 0) return error(f, VORBIS_invalid_setup);\n            c->lookup_values = (uint32) values;\n          } else {\n             c->lookup_values = c->entries * c->dimensions;\n          }\n         if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup);\n         mults = (uint16 *) setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values);\n         if (mults == NULL) return error(f, VORBIS_outofmem);\n         for (j=0; j < (int) c->lookup_values; ++j) {\n            int q = get_bits(f, c->value_bits);\n            if (q == EOP) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); }\n            mults[j] = q;\n         }\n\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n         if (c->lookup_type == 1) {\n            int len, sparse = c->sparse;\n            float last=0;\n            if (sparse) {\n               if (c->sorted_entries == 0) goto skip;\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions);\n            } else\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries        * c->dimensions);\n            if (c->multiplicands == NULL) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            len = sparse ? c->sorted_entries : c->entries;\n            for (j=0; j < len; ++j) {\n               unsigned int z = sparse ? c->sorted_values[j] : j;\n               unsigned int div=1;\n               for (k=0; k < c->dimensions; ++k) {\n                  int off = (z / div) % c->lookup_values;\n                  float val = mults[off];\n                  val = mults[off]*c->delta_value + c->minimum_value + last;\n                  c->multiplicands[j*c->dimensions + k] = val;\n                  if (c->sequence_p)\n                     last = val;\n                  if (k+1 < c->dimensions) {\n                     if (div > UINT_MAX / (unsigned int) c->lookup_values) {\n                        setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values);\n                        return error(f, VORBIS_invalid_setup);\n                     }\n                     div *= c->lookup_values;\n                  }\n               }\n            }\n            c->lookup_type = 2;\n         }\n         else\n#endif\n         {\n            float last=0;\n            CHECK(f);\n            c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values);\n            if (c->multiplicands == NULL) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            for (j=0; j < (int) c->lookup_values; ++j) {\n               float val = mults[j] * c->delta_value + c->minimum_value + last;\n               c->multiplicands[j] = val;\n               if (c->sequence_p)\n                  last = val;\n            }\n         }\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n        skip:;\n#endif\n         setup_temp_free(f, mults, sizeof(mults[0])*c->lookup_values);\n\n         CHECK(f);\n      }\n      CHECK(f);\n   }\n\n\n   x = get_bits(f, 6) + 1;\n   for (i=0; i < x; ++i) {\n      uint32 z = get_bits(f, 16);\n      if (z != 0) return error(f, VORBIS_invalid_setup);\n   }\n\n   f->floor_count = get_bits(f, 6)+1;\n   f->floor_config = (Floor *)  setup_malloc(f, f->floor_count * sizeof(*f->floor_config));\n   if (f->floor_config == NULL) return error(f, VORBIS_outofmem);\n   for (i=0; i < f->floor_count; ++i) {\n      f->floor_types[i] = get_bits(f, 16);\n      if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup);\n      if (f->floor_types[i] == 0) {\n         Floor0 *g = &f->floor_config[i].floor0;\n         g->order = get_bits(f,8);\n         g->rate = get_bits(f,16);\n         g->bark_map_size = get_bits(f,16);\n         g->amplitude_bits = get_bits(f,6);\n         g->amplitude_offset = get_bits(f,8);\n         g->number_of_books = get_bits(f,4) + 1;\n         for (j=0; j < g->number_of_books; ++j)\n            g->book_list[j] = get_bits(f,8);\n         return error(f, VORBIS_feature_not_supported);\n      } else {\n         stbv__floor_ordering p[31*8+2];\n         Floor1 *g = &f->floor_config[i].floor1;\n         int max_class = -1; \n         g->partitions = get_bits(f, 5);\n         for (j=0; j < g->partitions; ++j) {\n            g->partition_class_list[j] = get_bits(f, 4);\n            if (g->partition_class_list[j] > max_class)\n               max_class = g->partition_class_list[j];\n         }\n         for (j=0; j <= max_class; ++j) {\n            g->class_dimensions[j] = get_bits(f, 3)+1;\n            g->class_subclasses[j] = get_bits(f, 2);\n            if (g->class_subclasses[j]) {\n               g->class_masterbooks[j] = get_bits(f, 8);\n               if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n            for (k=0; k < 1 << g->class_subclasses[j]; ++k) {\n               g->subclass_books[j][k] = get_bits(f,8)-1;\n               if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n         }\n         g->floor1_multiplier = get_bits(f,2)+1;\n         g->rangebits = get_bits(f,4);\n         g->Xlist[0] = 0;\n         g->Xlist[1] = 1 << g->rangebits;\n         g->values = 2;\n         for (j=0; j < g->partitions; ++j) {\n            int c = g->partition_class_list[j];\n            for (k=0; k < g->class_dimensions[c]; ++k) {\n               g->Xlist[g->values] = get_bits(f, g->rangebits);\n               ++g->values;\n            }\n         }\n         for (j=0; j < g->values; ++j) {\n            p[j].x = g->Xlist[j];\n             p[j].id = j;\n          }\n          qsort(p, g->values, sizeof(p[0]), point_compare);\n         for (j=0; j < g->values-1; ++j)\n            if (p[j].x == p[j+1].x)\n               return error(f, VORBIS_invalid_setup);\n          for (j=0; j < g->values; ++j)\n             g->sorted_order[j] = (uint8) p[j].id;\n         for (j=2; j < g->values; ++j) {\n            int low,hi;\n            neighbors(g->Xlist, j, &low,&hi);\n            g->neighbors[j][0] = low;\n            g->neighbors[j][1] = hi;\n         }\n\n         if (g->values > longest_floorlist)\n            longest_floorlist = g->values;\n      }\n   }\n\n   f->residue_count = get_bits(f, 6)+1;\n   f->residue_config = (Residue *) setup_malloc(f, f->residue_count * sizeof(f->residue_config[0]));\n   if (f->residue_config == NULL) return error(f, VORBIS_outofmem);\n   memset(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0]));\n   for (i=0; i < f->residue_count; ++i) {\n      uint8 residue_cascade[64];\n      Residue *r = f->residue_config+i;\n      f->residue_types[i] = get_bits(f, 16);\n      if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup);\n      r->begin = get_bits(f, 24);\n      r->end = get_bits(f, 24);\n      if (r->end < r->begin) return error(f, VORBIS_invalid_setup);\n      r->part_size = get_bits(f,24)+1;\n      r->classifications = get_bits(f,6)+1;\n      r->classbook = get_bits(f,8);\n      if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n      for (j=0; j < r->classifications; ++j) {\n         uint8 high_bits=0;\n         uint8 low_bits=get_bits(f,3);\n         if (get_bits(f,1))\n            high_bits = get_bits(f,5);\n         residue_cascade[j] = high_bits*8 + low_bits;\n      }\n      r->residue_books = (short (*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications);\n      if (r->residue_books == NULL) return error(f, VORBIS_outofmem);\n      for (j=0; j < r->classifications; ++j) {\n         for (k=0; k < 8; ++k) {\n            if (residue_cascade[j] & (1 << k)) {\n               r->residue_books[j][k] = get_bits(f, 8);\n               if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            } else {\n               r->residue_books[j][k] = -1;\n            }\n         }\n      }\n      r->classdata = (uint8 **) setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      if (!r->classdata) return error(f, VORBIS_outofmem);\n      memset(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      for (j=0; j < f->codebooks[r->classbook].entries; ++j) {\n         int classwords = f->codebooks[r->classbook].dimensions;\n         int temp = j;\n         r->classdata[j] = (uint8 *) setup_malloc(f, sizeof(r->classdata[j][0]) * classwords);\n         if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem);\n         for (k=classwords-1; k >= 0; --k) {\n            r->classdata[j][k] = temp % r->classifications;\n            temp /= r->classifications;\n         }\n      }\n   }\n\n   f->mapping_count = get_bits(f,6)+1;\n   f->mapping = (Mapping *) setup_malloc(f, f->mapping_count * sizeof(*f->mapping));\n   if (f->mapping == NULL) return error(f, VORBIS_outofmem);\n   memset(f->mapping, 0, f->mapping_count * sizeof(*f->mapping));\n   for (i=0; i < f->mapping_count; ++i) {\n      Mapping *m = f->mapping + i;      \n      int mapping_type = get_bits(f,16);\n      if (mapping_type != 0) return error(f, VORBIS_invalid_setup);\n      m->chan = (MappingChannel *) setup_malloc(f, f->channels * sizeof(*m->chan));\n      if (m->chan == NULL) return error(f, VORBIS_outofmem);\n      if (get_bits(f,1))\n         m->submaps = get_bits(f,4)+1;\n      else\n         m->submaps = 1;\n      if (m->submaps > max_submaps)\n          max_submaps = m->submaps;\n       if (get_bits(f,1)) {\n          m->coupling_steps = get_bits(f,8)+1;\n         if (m->coupling_steps > f->channels) return error(f, VORBIS_invalid_setup);\n          for (k=0; k < m->coupling_steps; ++k) {\n             m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));\n             m->chan[k].angle = get_bits(f, ilog(f->channels-1));\n            if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].angle     >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         m->coupling_steps = 0;\n\n      if (get_bits(f,2)) return error(f, VORBIS_invalid_setup);\n      if (m->submaps > 1) {\n         for (j=0; j < f->channels; ++j) {\n            m->chan[j].mux = get_bits(f, 4);\n            if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         for (j=0; j < f->channels; ++j)\n            m->chan[j].mux = 0;\n\n      for (j=0; j < m->submaps; ++j) {\n         get_bits(f,8); // discard\n         m->submap_floor[j] = get_bits(f,8);\n         m->submap_residue[j] = get_bits(f,8);\n         if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);\n         if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);\n      }\n   }\n\n   f->mode_count = get_bits(f, 6)+1;\n   for (i=0; i < f->mode_count; ++i) {\n      Mode *m = f->mode_config+i;\n      m->blockflag = get_bits(f,1);\n      m->windowtype = get_bits(f,16);\n      m->transformtype = get_bits(f,16);\n      m->mapping = get_bits(f,8);\n      if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup);\n      if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup);\n      if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup);\n   }\n\n   flush_packet(f);\n\n   f->previous_length = 0;\n\n   for (i=0; i < f->channels; ++i) {\n      f->channel_buffers[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1);\n      f->previous_window[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      f->finalY[i]          = (int16 *) setup_malloc(f, sizeof(int16) * longest_floorlist);\n      if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem);\n      memset(f->channel_buffers[i], 0, sizeof(float) * f->blocksize_1);\n      #ifdef STB_VORBIS_NO_DEFER_FLOOR\n      f->floor_buffers[i]   = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      if (f->floor_buffers[i] == NULL) return error(f, VORBIS_outofmem);\n      #endif\n   }\n\n   if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE;\n   if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE;\n   f->blocksize[0] = f->blocksize_0;\n   f->blocksize[1] = f->blocksize_1;\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n   if (integer_divide_table[1][1]==0)\n      for (i=0; i < DIVTAB_NUMER; ++i)\n         for (j=1; j < DIVTAB_DENOM; ++j)\n            integer_divide_table[i][j] = i / j;\n#endif\n\n\n   {\n      uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1);\n      uint32 classify_mem;\n      int i,max_part_read=0;\n      for (i=0; i < f->residue_count; ++i) {\n         Residue *r = f->residue_config + i;\n         unsigned int actual_size = f->blocksize_1 / 2;\n         unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size;\n         unsigned int limit_r_end   = r->end   < actual_size ? r->end   : actual_size;\n         int n_read = limit_r_end - limit_r_begin;\n         int part_read = n_read / r->part_size;\n         if (part_read > max_part_read)\n            max_part_read = part_read;\n      }\n      #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8 *));\n      #else\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *));\n      #endif\n\n\n      f->temp_memory_required = classify_mem;\n      if (imdct_mem > f->temp_memory_required)\n         f->temp_memory_required = imdct_mem;\n   }\n\n   f->first_decode = TRUE;\n\n   if (f->alloc.alloc_buffer) {\n      assert(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes);\n      if (f->setup_offset + sizeof(*f) + f->temp_memory_required > (unsigned) f->temp_offset)\n         return error(f, VORBIS_outofmem);\n   }\n\n   f->first_audio_page_offset = stb_vorbis_get_file_offset(f);\n\n   return TRUE;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143240,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadCUTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowCUTReaderException(severity,tag) \\\n{ \\\n  if (palette != NULL) \\\n    palette=DestroyImage(palette); \\\n  if (clone_info != NULL) \\\n    clone_info=DestroyImageInfo(clone_info); \\\n  ThrowReaderException(severity,tag); \\\n}\n\n  Image *image,*palette;\n  ImageInfo *clone_info;\n  MagickBooleanType status;\n\n  MagickOffsetType\n    offset;\n\n  size_t EncodedByte;\n  unsigned char RunCount,RunValue,RunCountMasked;\n  CUTHeader  Header;\n  CUTPalHeader PalHeader;\n  ssize_t depth;\n  ssize_t i,j;\n  ssize_t ldblk;\n  unsigned char *BImgBuff=NULL,*ptrB;\n  register Quantum *q;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read CUT image.\n  */\n  palette=NULL;\n  clone_info=NULL;\n  Header.Width=ReadBlobLSBShort(image);\n  Header.Height=ReadBlobLSBShort(image);\n  Header.Reserved=ReadBlobLSBShort(image);\n\n  if (Header.Width==0 || Header.Height==0 || Header.Reserved!=0)\n    CUT_KO:  ThrowCUTReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  /*---This code checks first line of image---*/\n  EncodedByte=ReadBlobLSBShort(image);\n  RunCount=(unsigned char) ReadBlobByte(image);\n  RunCountMasked=RunCount & 0x7F;\n  ldblk=0;\n  while((int) RunCountMasked!=0)  /*end of line?*/\n    {\n      i=1;\n      if((int) RunCount<0x80) i=(ssize_t) RunCountMasked;\n      offset=SeekBlob(image,TellBlob(image)+i,SEEK_SET);\n      if (offset < 0)\n        ThrowCUTReaderException(CorruptImageError,\"ImproperImageHeader\");\n      if(EOFBlob(image) != MagickFalse) goto CUT_KO;  /*wrong data*/\n      EncodedByte-=i+1;\n      ldblk+=(ssize_t) RunCountMasked;\n\n      RunCount=(unsigned char) ReadBlobByte(image);\n      if(EOFBlob(image) != MagickFalse)  goto CUT_KO;  /*wrong data: unexpected eof in line*/\n      RunCountMasked=RunCount & 0x7F;\n    }\n  if(EncodedByte!=1) goto CUT_KO;  /*wrong data: size incorrect*/\n  i=0;        /*guess a number of bit planes*/\n  if(ldblk==(int) Header.Width)   i=8;\n  if(2*ldblk==(int) Header.Width) i=4;\n  if(8*ldblk==(int) Header.Width) i=1;\n  if(i==0) goto CUT_KO;    /*wrong data: incorrect bit planes*/\n  depth=i;\n\n  image->columns=Header.Width;\n  image->rows=Header.Height;\n  image->depth=8;\n  image->colors=(size_t) (GetQuantumRange(1UL*i)+1);\n\n  if (image_info->ping != MagickFalse) goto Finish;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  /* ----- Do something with palette ----- */\n  if ((clone_info=CloneImageInfo(image_info)) == NULL) goto NoPalette;\n\n\n  i=(ssize_t) strlen(clone_info->filename);\n  j=i;\n  while(--i>0)\n    {\n      if(clone_info->filename[i]=='.')\n        {\n          break;\n        }\n      if(clone_info->filename[i]=='/' || clone_info->filename[i]=='\\\\' ||\n         clone_info->filename[i]==':' )\n        {\n          i=j;\n          break;\n        }\n    }\n\n  (void) CopyMagickString(clone_info->filename+i,\".PAL\",(size_t)\n    (MagickPathExtent-i));\n  if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n    {\n      (void) CopyMagickString(clone_info->filename+i,\".pal\",(size_t)\n        (MagickPathExtent-i));\n      if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n        {\n          clone_info->filename[i]='\\0';\n          if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n            {\n              clone_info=DestroyImageInfo(clone_info);\n              clone_info=NULL;\n              goto NoPalette;\n            }\n        }\n    }\n\n  if( (palette=AcquireImage(clone_info,exception))==NULL ) goto NoPalette;\n  status=OpenBlob(clone_info,palette,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n    ErasePalette:\n      palette=DestroyImage(palette);\n      palette=NULL;\n      goto NoPalette;\n    }\n\n\n  if(palette!=NULL)\n    {\n      (void) ReadBlob(palette,2,(unsigned char *) PalHeader.FileId);\n      if(strncmp(PalHeader.FileId,\"AH\",2) != 0) goto ErasePalette;\n      PalHeader.Version=ReadBlobLSBShort(palette);\n      PalHeader.Size=ReadBlobLSBShort(palette);\n      PalHeader.FileType=(char) ReadBlobByte(palette);\n      PalHeader.SubType=(char) ReadBlobByte(palette);\n      PalHeader.BoardID=ReadBlobLSBShort(palette);\n      PalHeader.GraphicsMode=ReadBlobLSBShort(palette);\n      PalHeader.MaxIndex=ReadBlobLSBShort(palette);\n      PalHeader.MaxRed=ReadBlobLSBShort(palette);\n      PalHeader.MaxGreen=ReadBlobLSBShort(palette);\n      PalHeader.MaxBlue=ReadBlobLSBShort(palette);\n      (void) ReadBlob(palette,20,(unsigned char *) PalHeader.PaletteId);\n      if (EOFBlob(image))\n        ThrowCUTReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n\n      if(PalHeader.MaxIndex<1) goto ErasePalette;\n      image->colors=PalHeader.MaxIndex+1;\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse) goto NoMemory;\n\n      if(PalHeader.MaxRed==0) PalHeader.MaxRed=(unsigned int) QuantumRange;  /*avoid division by 0*/\n      if(PalHeader.MaxGreen==0) PalHeader.MaxGreen=(unsigned int) QuantumRange;\n      if(PalHeader.MaxBlue==0) PalHeader.MaxBlue=(unsigned int) QuantumRange;\n\n      for(i=0;i<=(int) PalHeader.MaxIndex;i++)\n        {      /*this may be wrong- I don't know why is palette such strange*/\n          j=(ssize_t) TellBlob(palette);\n          if((j % 512)>512-6)\n            {\n              j=((j / 512)+1)*512;\n              offset=SeekBlob(palette,j,SEEK_SET);\n              if (offset < 0)\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            }\n          image->colormap[i].red=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxRed)\n            {\n              image->colormap[i].red=ClampToQuantum(((double)\n                image->colormap[i].red*QuantumRange+(PalHeader.MaxRed>>1))/\n                PalHeader.MaxRed);\n            }\n          image->colormap[i].green=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxGreen)\n            {\n              image->colormap[i].green=ClampToQuantum\n                (((double) image->colormap[i].green*QuantumRange+(PalHeader.MaxGreen>>1))/PalHeader.MaxGreen);\n            }\n          image->colormap[i].blue=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxBlue)\n            {\n              image->colormap[i].blue=ClampToQuantum\n                (((double)image->colormap[i].blue*QuantumRange+(PalHeader.MaxBlue>>1))/PalHeader.MaxBlue);\n            }\n\n        }\n      if (EOFBlob(image))\n        ThrowCUTReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n\n\n\n NoPalette:\n  if(palette==NULL)\n    {\n\n      image->colors=256;\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n        {\n        NoMemory:\n          ThrowCUTReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            }\n\n      for (i=0; i < (ssize_t)image->colors; i++)\n        {\n          image->colormap[i].red=ScaleCharToQuantum((unsigned char) i);\n          image->colormap[i].green=ScaleCharToQuantum((unsigned char) i);\n          image->colormap[i].blue=ScaleCharToQuantum((unsigned char) i);\n        }\n    }\n\n\n  /* ----- Load RLE compressed raster ----- */\n   BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,\n     sizeof(*BImgBuff));  /*Ldblk was set in the check phase*/\n   if(BImgBuff==NULL) goto NoMemory;\n \n   offset=SeekBlob(image,6 /*sizeof(Header)*/,SEEK_SET);\n   if (offset < 0)\n    {\n      if (palette != NULL)\n        palette=DestroyImage(palette);\n      if (clone_info != NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  for (i=0; i < (int) Header.Height; i++)\n  {\n      EncodedByte=ReadBlobLSBShort(image);\n\n      ptrB=BImgBuff;\n      j=ldblk;\n\n      RunCount=(unsigned char) ReadBlobByte(image);\n      RunCountMasked=RunCount & 0x7F;\n\n      while ((int) RunCountMasked != 0)\n      {\n          if((ssize_t) RunCountMasked>j)\n            {    /*Wrong Data*/\n              RunCountMasked=(unsigned char) j;\n              if(j==0)\n                {\n                  break;\n                }\n            }\n\n          if((int) RunCount>0x80)\n            {\n              RunValue=(unsigned char) ReadBlobByte(image);\n              (void) memset(ptrB,(int) RunValue,(size_t) RunCountMasked);\n            }\n          else {\n            (void) ReadBlob(image,(size_t) RunCountMasked,ptrB);\n          }\n\n          ptrB+=(int) RunCountMasked;\n          j-=(int) RunCountMasked;\n\n          if (EOFBlob(image) != MagickFalse) goto Finish;  /* wrong data: unexpected eof in line */\n          RunCount=(unsigned char) ReadBlobByte(image);\n          RunCountMasked=RunCount & 0x7F;\n        }\n\n      InsertRow(image,depth,BImgBuff,i,exception);\n    }\n  (void) SyncImage(image,exception);\n\n\n  /*detect monochrome image*/\n\n  if(palette==NULL)\n    {    /*attempt to detect binary (black&white) images*/\n      if ((image->storage_class == PseudoClass) &&\n          (SetImageGray(image,exception) != MagickFalse))\n        {\n          if(GetCutColors(image,exception)==2)\n            {\n              for (i=0; i < (ssize_t)image->colors; i++)\n                {\n                  register Quantum\n                    sample;\n                  sample=ScaleCharToQuantum((unsigned char) i);\n                  if(image->colormap[i].red!=sample) goto Finish;\n                  if(image->colormap[i].green!=sample) goto Finish;\n                  if(image->colormap[i].blue!=sample) goto Finish;\n                }\n\n              image->colormap[1].red=image->colormap[1].green=\n                image->colormap[1].blue=QuantumRange;\n              for (i=0; i < (ssize_t)image->rows; i++)\n                {\n                  q=QueueAuthenticPixels(image,0,i,image->columns,1,exception);\n                  if (q == (Quantum *) NULL)\n                    break;\n                  for (j=0; j < (ssize_t)image->columns; j++)\n                    {\n                      if (GetPixelRed(image,q) == ScaleCharToQuantum(1))\n                        {\n                          SetPixelRed(image,QuantumRange,q);\n                          SetPixelGreen(image,QuantumRange,q);\n                          SetPixelBlue(image,QuantumRange,q);\n                        }\n                      q+=GetPixelChannels(image);\n                    }\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse) goto Finish;\n                }\n            }\n        }\n    }\n\n Finish:\n  if (BImgBuff != NULL)\n    BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n  if (palette != NULL)\n    palette=DestroyImage(palette);\n  if (clone_info != NULL)\n    clone_info=DestroyImageInfo(clone_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143241,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadCUTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowCUTReaderException(severity,tag) \\\n{ \\\n  if (palette != NULL) \\\n    palette=DestroyImage(palette); \\\n  if (clone_info != NULL) \\\n    clone_info=DestroyImageInfo(clone_info); \\\n  ThrowReaderException(severity,tag); \\\n}\n\n  Image *image,*palette;\n  ImageInfo *clone_info;\n  MagickBooleanType status;\n\n  MagickOffsetType\n    offset;\n\n  size_t EncodedByte;\n  unsigned char RunCount,RunValue,RunCountMasked;\n  CUTHeader  Header;\n  CUTPalHeader PalHeader;\n  ssize_t depth;\n  ssize_t i,j;\n  ssize_t ldblk;\n  unsigned char *BImgBuff=NULL,*ptrB;\n  register Quantum *q;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read CUT image.\n  */\n  palette=NULL;\n  clone_info=NULL;\n  Header.Width=ReadBlobLSBShort(image);\n  Header.Height=ReadBlobLSBShort(image);\n  Header.Reserved=ReadBlobLSBShort(image);\n\n  if (Header.Width==0 || Header.Height==0 || Header.Reserved!=0)\n    CUT_KO:  ThrowCUTReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  /*---This code checks first line of image---*/\n  EncodedByte=ReadBlobLSBShort(image);\n  RunCount=(unsigned char) ReadBlobByte(image);\n  RunCountMasked=RunCount & 0x7F;\n  ldblk=0;\n  while((int) RunCountMasked!=0)  /*end of line?*/\n    {\n      i=1;\n      if((int) RunCount<0x80) i=(ssize_t) RunCountMasked;\n      offset=SeekBlob(image,TellBlob(image)+i,SEEK_SET);\n      if (offset < 0)\n        ThrowCUTReaderException(CorruptImageError,\"ImproperImageHeader\");\n      if(EOFBlob(image) != MagickFalse) goto CUT_KO;  /*wrong data*/\n      EncodedByte-=i+1;\n      ldblk+=(ssize_t) RunCountMasked;\n\n      RunCount=(unsigned char) ReadBlobByte(image);\n      if(EOFBlob(image) != MagickFalse)  goto CUT_KO;  /*wrong data: unexpected eof in line*/\n      RunCountMasked=RunCount & 0x7F;\n    }\n  if(EncodedByte!=1) goto CUT_KO;  /*wrong data: size incorrect*/\n  i=0;        /*guess a number of bit planes*/\n  if(ldblk==(int) Header.Width)   i=8;\n  if(2*ldblk==(int) Header.Width) i=4;\n  if(8*ldblk==(int) Header.Width) i=1;\n  if(i==0) goto CUT_KO;    /*wrong data: incorrect bit planes*/\n  depth=i;\n\n  image->columns=Header.Width;\n  image->rows=Header.Height;\n  image->depth=8;\n  image->colors=(size_t) (GetQuantumRange(1UL*i)+1);\n\n  if (image_info->ping != MagickFalse) goto Finish;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  /* ----- Do something with palette ----- */\n  if ((clone_info=CloneImageInfo(image_info)) == NULL) goto NoPalette;\n\n\n  i=(ssize_t) strlen(clone_info->filename);\n  j=i;\n  while(--i>0)\n    {\n      if(clone_info->filename[i]=='.')\n        {\n          break;\n        }\n      if(clone_info->filename[i]=='/' || clone_info->filename[i]=='\\\\' ||\n         clone_info->filename[i]==':' )\n        {\n          i=j;\n          break;\n        }\n    }\n\n  (void) CopyMagickString(clone_info->filename+i,\".PAL\",(size_t)\n    (MagickPathExtent-i));\n  if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n    {\n      (void) CopyMagickString(clone_info->filename+i,\".pal\",(size_t)\n        (MagickPathExtent-i));\n      if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n        {\n          clone_info->filename[i]='\\0';\n          if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n            {\n              clone_info=DestroyImageInfo(clone_info);\n              clone_info=NULL;\n              goto NoPalette;\n            }\n        }\n    }\n\n  if( (palette=AcquireImage(clone_info,exception))==NULL ) goto NoPalette;\n  status=OpenBlob(clone_info,palette,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n    ErasePalette:\n      palette=DestroyImage(palette);\n      palette=NULL;\n      goto NoPalette;\n    }\n\n\n  if(palette!=NULL)\n    {\n      (void) ReadBlob(palette,2,(unsigned char *) PalHeader.FileId);\n      if(strncmp(PalHeader.FileId,\"AH\",2) != 0) goto ErasePalette;\n      PalHeader.Version=ReadBlobLSBShort(palette);\n      PalHeader.Size=ReadBlobLSBShort(palette);\n      PalHeader.FileType=(char) ReadBlobByte(palette);\n      PalHeader.SubType=(char) ReadBlobByte(palette);\n      PalHeader.BoardID=ReadBlobLSBShort(palette);\n      PalHeader.GraphicsMode=ReadBlobLSBShort(palette);\n      PalHeader.MaxIndex=ReadBlobLSBShort(palette);\n      PalHeader.MaxRed=ReadBlobLSBShort(palette);\n      PalHeader.MaxGreen=ReadBlobLSBShort(palette);\n      PalHeader.MaxBlue=ReadBlobLSBShort(palette);\n      (void) ReadBlob(palette,20,(unsigned char *) PalHeader.PaletteId);\n      if (EOFBlob(image))\n        ThrowCUTReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n\n      if(PalHeader.MaxIndex<1) goto ErasePalette;\n      image->colors=PalHeader.MaxIndex+1;\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse) goto NoMemory;\n\n      if(PalHeader.MaxRed==0) PalHeader.MaxRed=(unsigned int) QuantumRange;  /*avoid division by 0*/\n      if(PalHeader.MaxGreen==0) PalHeader.MaxGreen=(unsigned int) QuantumRange;\n      if(PalHeader.MaxBlue==0) PalHeader.MaxBlue=(unsigned int) QuantumRange;\n\n      for(i=0;i<=(int) PalHeader.MaxIndex;i++)\n        {      /*this may be wrong- I don't know why is palette such strange*/\n          j=(ssize_t) TellBlob(palette);\n          if((j % 512)>512-6)\n            {\n              j=((j / 512)+1)*512;\n              offset=SeekBlob(palette,j,SEEK_SET);\n              if (offset < 0)\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            }\n          image->colormap[i].red=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxRed)\n            {\n              image->colormap[i].red=ClampToQuantum(((double)\n                image->colormap[i].red*QuantumRange+(PalHeader.MaxRed>>1))/\n                PalHeader.MaxRed);\n            }\n          image->colormap[i].green=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxGreen)\n            {\n              image->colormap[i].green=ClampToQuantum\n                (((double) image->colormap[i].green*QuantumRange+(PalHeader.MaxGreen>>1))/PalHeader.MaxGreen);\n            }\n          image->colormap[i].blue=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxBlue)\n            {\n              image->colormap[i].blue=ClampToQuantum\n                (((double)image->colormap[i].blue*QuantumRange+(PalHeader.MaxBlue>>1))/PalHeader.MaxBlue);\n            }\n\n        }\n      if (EOFBlob(image))\n        ThrowCUTReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n\n\n\n NoPalette:\n  if(palette==NULL)\n    {\n\n      image->colors=256;\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n        {\n        NoMemory:\n          ThrowCUTReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            }\n\n      for (i=0; i < (ssize_t)image->colors; i++)\n        {\n          image->colormap[i].red=ScaleCharToQuantum((unsigned char) i);\n          image->colormap[i].green=ScaleCharToQuantum((unsigned char) i);\n          image->colormap[i].blue=ScaleCharToQuantum((unsigned char) i);\n        }\n    }\n\n\n  /* ----- Load RLE compressed raster ----- */\n   BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,\n     sizeof(*BImgBuff));  /*Ldblk was set in the check phase*/\n   if(BImgBuff==NULL) goto NoMemory;\n  (void) memset(BImgBuff,0,(size_t) ldblk*sizeof(*BImgBuff));\n \n   offset=SeekBlob(image,6 /*sizeof(Header)*/,SEEK_SET);\n   if (offset < 0)\n    {\n      if (palette != NULL)\n        palette=DestroyImage(palette);\n      if (clone_info != NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  for (i=0; i < (int) Header.Height; i++)\n  {\n      EncodedByte=ReadBlobLSBShort(image);\n\n      ptrB=BImgBuff;\n      j=ldblk;\n\n      RunCount=(unsigned char) ReadBlobByte(image);\n      RunCountMasked=RunCount & 0x7F;\n\n      while ((int) RunCountMasked != 0)\n      {\n          if((ssize_t) RunCountMasked>j)\n            {    /*Wrong Data*/\n              RunCountMasked=(unsigned char) j;\n              if(j==0)\n                {\n                  break;\n                }\n            }\n\n          if((int) RunCount>0x80)\n            {\n              RunValue=(unsigned char) ReadBlobByte(image);\n              (void) memset(ptrB,(int) RunValue,(size_t) RunCountMasked);\n            }\n          else {\n            (void) ReadBlob(image,(size_t) RunCountMasked,ptrB);\n          }\n\n          ptrB+=(int) RunCountMasked;\n          j-=(int) RunCountMasked;\n\n          if (EOFBlob(image) != MagickFalse) goto Finish;  /* wrong data: unexpected eof in line */\n          RunCount=(unsigned char) ReadBlobByte(image);\n          RunCountMasked=RunCount & 0x7F;\n        }\n\n      InsertRow(image,depth,BImgBuff,i,exception);\n    }\n  (void) SyncImage(image,exception);\n\n\n  /*detect monochrome image*/\n\n  if(palette==NULL)\n    {    /*attempt to detect binary (black&white) images*/\n      if ((image->storage_class == PseudoClass) &&\n          (SetImageGray(image,exception) != MagickFalse))\n        {\n          if(GetCutColors(image,exception)==2)\n            {\n              for (i=0; i < (ssize_t)image->colors; i++)\n                {\n                  register Quantum\n                    sample;\n                  sample=ScaleCharToQuantum((unsigned char) i);\n                  if(image->colormap[i].red!=sample) goto Finish;\n                  if(image->colormap[i].green!=sample) goto Finish;\n                  if(image->colormap[i].blue!=sample) goto Finish;\n                }\n\n              image->colormap[1].red=image->colormap[1].green=\n                image->colormap[1].blue=QuantumRange;\n              for (i=0; i < (ssize_t)image->rows; i++)\n                {\n                  q=QueueAuthenticPixels(image,0,i,image->columns,1,exception);\n                  if (q == (Quantum *) NULL)\n                    break;\n                  for (j=0; j < (ssize_t)image->columns; j++)\n                    {\n                      if (GetPixelRed(image,q) == ScaleCharToQuantum(1))\n                        {\n                          SetPixelRed(image,QuantumRange,q);\n                          SetPixelGreen(image,QuantumRange,q);\n                          SetPixelBlue(image,QuantumRange,q);\n                        }\n                      q+=GetPixelChannels(image);\n                    }\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse) goto Finish;\n                }\n            }\n        }\n    }\n\n Finish:\n  if (BImgBuff != NULL)\n    BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n  if (palette != NULL)\n    palette=DestroyImage(palette);\n  if (clone_info != NULL)\n    clone_info=DestroyImageInfo(clone_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143242,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "main (int    argc,\n       char **argv)\n {\n   mode_t old_umask;\n  cleanup_free char *base_path = NULL;\n   int clone_flags;\n   char *old_cwd = NULL;\n   pid_t pid;\n  int event_fd = -1;\n  int child_wait_fd = -1;\n  int setup_finished_pipe[] = {-1, -1};\n  const char *new_cwd;\n  uid_t ns_uid;\n  gid_t ns_gid;\n  struct stat sbuf;\n  uint64_t val;\n  int res UNUSED;\n  cleanup_free char *seccomp_data = NULL;\n  size_t seccomp_len;\n  struct sock_fprog seccomp_prog;\n  cleanup_free char *args_data = NULL;\n\n  /* Handle --version early on before we try to acquire/drop\n   * any capabilities so it works in a build environment;\n   * right now flatpak's build runs bubblewrap --version.\n   * https://github.com/projectatomic/bubblewrap/issues/185\n   */\n  if (argc == 2 && (strcmp (argv[1], \"--version\") == 0))\n    print_version_and_exit ();\n\n  real_uid = getuid ();\n  real_gid = getgid ();\n\n  /* Get the (optional) privileges we need */\n  acquire_privs ();\n\n  /* Never gain any more privs during exec */\n  if (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0)\n    die_with_error (\"prctl(PR_SET_NO_NEW_CAPS) failed\");\n\n  /* The initial code is run with high permissions\n     (i.e. CAP_SYS_ADMIN), so take lots of care. */\n\n  read_overflowids ();\n\n  argv0 = argv[0];\n\n  if (isatty (1))\n    host_tty_dev = ttyname (1);\n\n  argv++;\n  argc--;\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  parse_args (&argc, (const char ***) &argv);\n\n  /* suck the args into a cleanup_free variable to control their lifecycle */\n  args_data = opt_args_data;\n  opt_args_data = NULL;\n\n  if ((requested_caps[0] || requested_caps[1]) && is_privileged)\n    die (\"--cap-add in setuid mode can be used only by root\");\n\n  if (opt_userns_block_fd != -1 && !opt_unshare_user)\n    die (\"--userns-block-fd requires --unshare-user\");\n\n  if (opt_userns_block_fd != -1 && opt_info_fd == -1)\n    die (\"--userns-block-fd requires --info-fd\");\n\n  /* We have to do this if we weren't installed setuid (and we're not\n   * root), so let's just DWIM */\n  if (!is_privileged && getuid () != 0)\n    opt_unshare_user = TRUE;\n\n#ifdef ENABLE_REQUIRE_USERNS\n  /* In this build option, we require userns. */\n  if (is_privileged && getuid () != 0)\n    opt_unshare_user = TRUE;\n#endif\n\n  if (opt_unshare_user_try &&\n      stat (\"/proc/self/ns/user\", &sbuf) == 0)\n    {\n      bool disabled = FALSE;\n\n      /* RHEL7 has a kernel module parameter that lets you enable user namespaces */\n      if (stat (\"/sys/module/user_namespace/parameters/enable\", &sbuf) == 0)\n        {\n          cleanup_free char *enable = NULL;\n          enable = load_file_at (AT_FDCWD, \"/sys/module/user_namespace/parameters/enable\");\n          if (enable != NULL && enable[0] == 'N')\n            disabled = TRUE;\n        }\n\n      /* Check for max_user_namespaces */\n      if (stat (\"/proc/sys/user/max_user_namespaces\", &sbuf) == 0)\n        {\n          cleanup_free char *max_user_ns = NULL;\n          max_user_ns = load_file_at (AT_FDCWD, \"/proc/sys/user/max_user_namespaces\");\n          if (max_user_ns != NULL && strcmp(max_user_ns, \"0\\n\") == 0)\n            disabled = TRUE;\n        }\n\n      /* Debian lets you disable *unprivileged* user namespaces. However this is not\n         a problem if we're privileged, and if we're not opt_unshare_user is TRUE\n         already, and there is not much we can do, its just a non-working setup. */\n\n      if (!disabled)\n        opt_unshare_user = TRUE;\n    }\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  __debug__ ((\"Creating root mount point\\n\"));\n\n  if (opt_sandbox_uid == -1)\n    opt_sandbox_uid = real_uid;\n  if (opt_sandbox_gid == -1)\n    opt_sandbox_gid = real_gid;\n\n  if (!opt_unshare_user && opt_sandbox_uid != real_uid)\n    die (\"Specifying --uid requires --unshare-user\");\n\n  if (!opt_unshare_user && opt_sandbox_gid != real_gid)\n    die (\"Specifying --gid requires --unshare-user\");\n\n  if (!opt_unshare_uts && opt_sandbox_hostname != NULL)\n    die (\"Specifying --hostname requires --unshare-uts\");\n\n  if (opt_as_pid_1 && !opt_unshare_pid)\n    die (\"Specifying --as-pid-1 requires --unshare-pid\");\n\n  if (opt_as_pid_1 && lock_files != NULL)\n    die (\"Specifying --as-pid-1 and --lock-file is not permitted\");\n\n  /* We need to read stuff from proc during the pivot_root dance, etc.\n     Lets keep a fd to it open */\n  proc_fd = open (\"/proc\", O_PATH);\n  if (proc_fd == -1)\n     die_with_error (\"Can't open /proc\");\n \n   /* We need *some* mountpoint where we can mount the root tmpfs.\n     We first try in /run, and if that fails, try in /tmp. */\n  base_path = xasprintf (\"/run/user/%d/.bubblewrap\", real_uid);\n  if (ensure_dir (base_path, 0755))\n    {\n      free (base_path);\n      base_path = xasprintf (\"/tmp/.bubblewrap-%d\", real_uid);\n      if (ensure_dir (base_path, 0755))\n        die_with_error (\"Creating root mountpoint failed\");\n    }\n \n   __debug__ ((\"creating new namespace\\n\"));\n \n  if (opt_unshare_pid && !opt_as_pid_1)\n    {\n      event_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK);\n      if (event_fd == -1)\n        die_with_error (\"eventfd()\");\n    }\n\n  /* We block sigchild here so that we can use signalfd in the monitor. */\n  block_sigchild ();\n\n  clone_flags = SIGCHLD | CLONE_NEWNS;\n  if (opt_unshare_user)\n    clone_flags |= CLONE_NEWUSER;\n  if (opt_unshare_pid)\n    clone_flags |= CLONE_NEWPID;\n  if (opt_unshare_net)\n    clone_flags |= CLONE_NEWNET;\n  if (opt_unshare_ipc)\n    clone_flags |= CLONE_NEWIPC;\n  if (opt_unshare_uts)\n    clone_flags |= CLONE_NEWUTS;\n  if (opt_unshare_cgroup)\n    {\n      if (stat (\"/proc/self/ns/cgroup\", &sbuf))\n        {\n          if (errno == ENOENT)\n            die (\"Cannot create new cgroup namespace because the kernel does not support it\");\n          else\n            die_with_error (\"stat on /proc/self/ns/cgroup failed\");\n        }\n      clone_flags |= CLONE_NEWCGROUP;\n    }\n  if (opt_unshare_cgroup_try)\n    if (!stat (\"/proc/self/ns/cgroup\", &sbuf))\n      clone_flags |= CLONE_NEWCGROUP;\n\n  child_wait_fd = eventfd (0, EFD_CLOEXEC);\n  if (child_wait_fd == -1)\n    die_with_error (\"eventfd()\");\n\n  /* Track whether pre-exec setup finished if we're reporting process exit */\n  if (opt_json_status_fd != -1)\n    {\n      int ret;\n      ret = pipe2 (setup_finished_pipe, O_CLOEXEC);\n      if (ret == -1)\n        die_with_error (\"pipe2()\");\n    }\n\n  pid = raw_clone (clone_flags, NULL);\n  if (pid == -1)\n    {\n      if (opt_unshare_user)\n        {\n          if (errno == EINVAL)\n            die (\"Creating new namespace failed, likely because the kernel does not support user namespaces.  bwrap must be installed setuid on such systems.\");\n          else if (errno == EPERM && !is_privileged)\n            die (\"No permissions to creating new namespace, likely because the kernel does not allow non-privileged user namespaces. On e.g. debian this can be enabled with 'sysctl kernel.unprivileged_userns_clone=1'.\");\n        }\n\n      die_with_error (\"Creating new namespace failed\");\n    }\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n\n  if (pid != 0)\n    {\n      /* Parent, outside sandbox, privileged (initially) */\n\n      if (is_privileged && opt_unshare_user && opt_userns_block_fd == -1)\n        {\n          /* We're running as euid 0, but the uid we want to map is\n           * not 0. This means we're not allowed to write this from\n           * the child user namespace, so we do it from the parent.\n           *\n           * Also, we map uid/gid 0 in the namespace (to overflowuid)\n           * if opt_needs_devpts is true, because otherwise the mount\n           * of devpts fails due to root not being mapped.\n           */\n          write_uid_gid_map (ns_uid, real_uid,\n                             ns_gid, real_gid,\n                             pid, TRUE, opt_needs_devpts);\n        }\n\n      /* Initial launched process, wait for exec:ed command to exit */\n\n      /* We don't need any privileges in the launcher, drop them immediately. */\n      drop_privs (FALSE);\n\n      /* Optionally bind our lifecycle to that of the parent */\n      handle_die_with_parent ();\n\n      if (opt_info_fd != -1)\n        {\n          cleanup_free char *output = xasprintf (\"{\\n    \\\"child-pid\\\": %i\\n}\\n\", pid);\n          dump_info (opt_info_fd, output, TRUE);\n          close (opt_info_fd);\n        }\n      if (opt_json_status_fd != -1)\n        {\n          cleanup_free char *output = xasprintf (\"{ \\\"child-pid\\\": %i }\\n\", pid);\n          dump_info (opt_json_status_fd, output, TRUE);\n        }\n\n      if (opt_userns_block_fd != -1)\n        {\n          char b[1];\n          (void) TEMP_FAILURE_RETRY (read (opt_userns_block_fd, b, 1));\n          close (opt_userns_block_fd);\n        }\n\n      /* Let child run now that the uid maps are set up */\n      val = 1;\n      res = write (child_wait_fd, &val, 8);\n      /* Ignore res, if e.g. the child died and closed child_wait_fd we don't want to error out here */\n      close (child_wait_fd);\n\n      return monitor_child (event_fd, pid, setup_finished_pipe[0]);\n    }\n\n  /* Child, in sandbox, privileged in the parent or in the user namespace (if --unshare-user).\n   *\n   * Note that for user namespaces we run as euid 0 during clone(), so\n   * the child user namespace is owned by euid 0., This means that the\n   * regular user namespace parent (with uid != 0) doesn't have any\n   * capabilities in it, which is nice as we can't exploit those. In\n   * particular the parent user namespace doesn't have CAP_PTRACE\n   * which would otherwise allow the parent to hijack of the child\n   * after this point.\n   *\n   * Unfortunately this also means you can't ptrace the final\n   * sandboxed process from outside the sandbox either.\n   */\n\n  if (opt_info_fd != -1)\n    close (opt_info_fd);\n\n  if (opt_json_status_fd != -1)\n    close (opt_json_status_fd);\n\n  /* Wait for the parent to init uid/gid maps and drop caps */\n  res = read (child_wait_fd, &val, 8);\n  close (child_wait_fd);\n\n  /* At this point we can completely drop root uid, but retain the\n   * required permitted caps. This allow us to do full setup as\n   * the user uid, which makes e.g. fuse access work.\n   */\n  switch_to_user_with_privs ();\n\n  if (opt_unshare_net)\n    loopback_setup (); /* Will exit if unsuccessful */\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n  if (!is_privileged && opt_unshare_user && opt_userns_block_fd == -1)\n    {\n      /* In the unprivileged case we have to write the uid/gid maps in\n       * the child, because we have no caps in the parent */\n\n      if (opt_needs_devpts)\n        {\n          /* This is a bit hacky, but we need to first map the real uid/gid to\n             0, otherwise we can't mount the devpts filesystem because root is\n             not mapped. Later we will create another child user namespace and\n             map back to the real uid */\n          ns_uid = 0;\n          ns_gid = 0;\n        }\n\n      write_uid_gid_map (ns_uid, real_uid,\n                         ns_gid, real_gid,\n                         -1, TRUE, FALSE);\n    }\n\n  old_umask = umask (0);\n\n  /* Need to do this before the chroot, but after we're the real uid */\n  resolve_symlinks_in_ops ();\n\n  /* Mark everything as slave, so that we still\n   * receive mounts from the real root, but don't\n   * propagate mounts to the real root. */\n  if (mount (NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0)\n    die_with_error (\"Failed to make / slave\");\n\n  /* Create a tmpfs which we will use as / in the namespace */\n  if (mount (\"tmpfs\", base_path, \"tmpfs\", MS_NODEV | MS_NOSUID, NULL) != 0)\n    die_with_error (\"Failed to mount tmpfs\");\n\n  old_cwd = get_current_dir_name ();\n\n  /* Chdir to the new root tmpfs mount. This will be the CWD during\n     the entire setup. Access old or new root via \"oldroot\" and \"newroot\". */\n  if (chdir (base_path) != 0)\n    die_with_error (\"chdir base_path\");\n\n   /* We create a subdir \"$base_path/newroot\" for the new root, that\n    * way we can pivot_root to base_path, and put the old root at\n    * \"$base_path/oldroot\". This avoids problems accessing the oldroot\n   * dir if the user requested to bind mount something over / */\n \n   if (mkdir (\"newroot\", 0755))\n     die_with_error (\"Creating newroot failed\");\n\n  if (mount (\"newroot\", \"newroot\", NULL, MS_MGC_VAL | MS_BIND | MS_REC, NULL) < 0)\n    die_with_error (\"setting up newroot bind\");\n\n  if (mkdir (\"oldroot\", 0755))\n    die_with_error (\"Creating oldroot failed\");\n\n  if (pivot_root (base_path, \"oldroot\"))\n    die_with_error (\"pivot_root\");\n\n  if (chdir (\"/\") != 0)\n    die_with_error (\"chdir / (base path)\");\n\n  if (is_privileged)\n    {\n      pid_t child;\n      int privsep_sockets[2];\n\n      if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, privsep_sockets) != 0)\n        die_with_error (\"Can't create privsep socket\");\n\n      child = fork ();\n      if (child == -1)\n        die_with_error (\"Can't fork unprivileged helper\");\n\n      if (child == 0)\n        {\n          /* Unprivileged setup process */\n          drop_privs (FALSE);\n          close (privsep_sockets[0]);\n          setup_newroot (opt_unshare_pid, privsep_sockets[1]);\n          exit (0);\n        }\n      else\n        {\n          int status;\n          uint32_t buffer[2048];  /* 8k, but is int32 to guarantee nice alignment */\n          uint32_t op, flags;\n          const char *arg1, *arg2;\n          cleanup_fd int unpriv_socket = -1;\n\n          unpriv_socket = privsep_sockets[0];\n          close (privsep_sockets[1]);\n\n          do\n            {\n              op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer),\n                                     &flags, &arg1, &arg2);\n              privileged_op (-1, op, flags, arg1, arg2);\n              if (write (unpriv_socket, buffer, 1) != 1)\n                die (\"Can't write to op_socket\");\n            }\n          while (op != PRIV_SEP_OP_DONE);\n\n          waitpid (child, &status, 0);\n          /* Continue post setup */\n        }\n    }\n  else\n    {\n      setup_newroot (opt_unshare_pid, -1);\n    }\n\n  close_ops_fd ();\n\n  /* The old root better be rprivate or we will send unmount events to the parent namespace */\n  if (mount (\"oldroot\", \"oldroot\", NULL, MS_REC | MS_PRIVATE, NULL) != 0)\n    die_with_error (\"Failed to make old root rprivate\");\n\n  if (umount2 (\"oldroot\", MNT_DETACH))\n    die_with_error (\"unmount old root\");\n\n  /* This is our second pivot. It's like we're a Silicon Valley startup flush\n   * with cash but short on ideas!\n   *\n   * We're aiming to make /newroot the real root, and get rid of /oldroot. To do\n   * that we need a temporary place to store it before we can unmount it.\n   */\n  { cleanup_fd int oldrootfd = open (\"/\", O_DIRECTORY | O_RDONLY);\n    if (oldrootfd < 0)\n      die_with_error (\"can't open /\");\n    if (chdir (\"/newroot\") != 0)\n      die_with_error (\"chdir /newroot\");\n    /* While the documentation claims that put_old must be underneath\n     * new_root, it is perfectly fine to use the same directory as the\n     * kernel checks only if old_root is accessible from new_root.\n     *\n     * Both runc and LXC are using this \"alternative\" method for\n     * setting up the root of the container:\n     *\n     * https://github.com/opencontainers/runc/blob/master/libcontainer/rootfs_linux.go#L671\n     * https://github.com/lxc/lxc/blob/master/src/lxc/conf.c#L1121\n     */\n    if (pivot_root (\".\", \".\") != 0)\n      die_with_error (\"pivot_root(/newroot)\");\n    if (fchdir (oldrootfd) < 0)\n      die_with_error (\"fchdir to oldroot\");\n    if (umount2 (\".\", MNT_DETACH) < 0)\n      die_with_error (\"umount old root\");\n    if (chdir (\"/\") != 0)\n      die_with_error (\"chdir /\");\n  }\n\n  if (opt_unshare_user &&\n      (ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid) &&\n      opt_userns_block_fd == -1)\n    {\n      /* Now that devpts is mounted and we've no need for mount\n         permissions we can create a new userspace and map our uid\n         1:1 */\n\n      if (unshare (CLONE_NEWUSER))\n        die_with_error (\"unshare user ns\");\n\n      write_uid_gid_map (opt_sandbox_uid, ns_uid,\n                         opt_sandbox_gid, ns_gid,\n                         -1, FALSE, FALSE);\n    }\n\n  /* All privileged ops are done now, so drop caps we don't need */\n  drop_privs (!is_privileged);\n\n  if (opt_block_fd != -1)\n    {\n      char b[1];\n      (void) TEMP_FAILURE_RETRY (read (opt_block_fd, b, 1));\n      close (opt_block_fd);\n    }\n\n  if (opt_seccomp_fd != -1)\n    {\n      seccomp_data = load_file_data (opt_seccomp_fd, &seccomp_len);\n      if (seccomp_data == NULL)\n        die_with_error (\"Can't read seccomp data\");\n\n      if (seccomp_len % 8 != 0)\n        die (\"Invalid seccomp data, must be multiple of 8\");\n\n      seccomp_prog.len = seccomp_len / 8;\n      seccomp_prog.filter = (struct sock_filter *) seccomp_data;\n\n      close (opt_seccomp_fd);\n    }\n\n  umask (old_umask);\n\n  new_cwd = \"/\";\n  if (opt_chdir_path)\n    {\n      if (chdir (opt_chdir_path))\n        die_with_error (\"Can't chdir to %s\", opt_chdir_path);\n      new_cwd = opt_chdir_path;\n    }\n  else if (chdir (old_cwd) == 0)\n    {\n      /* If the old cwd is mapped in the sandbox, go there */\n      new_cwd = old_cwd;\n    }\n  else\n    {\n      /* If the old cwd is not mapped, go to home */\n      const char *home = getenv (\"HOME\");\n      if (home != NULL &&\n          chdir (home) == 0)\n        new_cwd = home;\n    }\n  xsetenv (\"PWD\", new_cwd, 1);\n  free (old_cwd);\n\n  if (opt_new_session &&\n      setsid () == (pid_t) -1)\n    die_with_error (\"setsid\");\n\n  if (label_exec (opt_exec_label) == -1)\n    die_with_error (\"label_exec %s\", argv[0]);\n\n  __debug__ ((\"forking for child\\n\"));\n\n  if (!opt_as_pid_1 && (opt_unshare_pid || lock_files != NULL || opt_sync_fd != -1))\n    {\n      /* We have to have a pid 1 in the pid namespace, because\n       * otherwise we'll get a bunch of zombies as nothing reaps\n       * them. Alternatively if we're using sync_fd or lock_files we\n       * need some process to own these.\n       */\n\n      pid = fork ();\n      if (pid == -1)\n        die_with_error (\"Can't fork for pid 1\");\n\n      if (pid != 0)\n        {\n          drop_all_caps (FALSE);\n\n          /* Close fds in pid 1, except stdio and optionally event_fd\n             (for syncing pid 2 lifetime with monitor_child) and\n             opt_sync_fd (for syncing sandbox lifetime with outside\n             process).\n             Any other fds will been passed on to the child though. */\n          {\n            int dont_close[3];\n            int j = 0;\n            if (event_fd != -1)\n              dont_close[j++] = event_fd;\n            if (opt_sync_fd != -1)\n              dont_close[j++] = opt_sync_fd;\n            dont_close[j++] = -1;\n            fdwalk (proc_fd, close_extra_fds, dont_close);\n          }\n\n          return do_init (event_fd, pid, seccomp_data != NULL ? &seccomp_prog : NULL);\n        }\n    }\n\n  __debug__ ((\"launch executable %s\\n\", argv[0]));\n\n  if (proc_fd != -1)\n    close (proc_fd);\n\n  /* If we are using --as-pid-1 leak the sync fd into the sandbox.\n     --sync-fd will still work unless the container process doesn't close this file.  */\n  if (!opt_as_pid_1)\n    {\n      if (opt_sync_fd != -1)\n        close (opt_sync_fd);\n    }\n\n  /* We want sigchild in the child */\n  unblock_sigchild ();\n\n  /* Optionally bind our lifecycle */\n  handle_die_with_parent ();\n\n  if (!is_privileged)\n    set_ambient_capabilities ();\n\n  /* Should be the last thing before execve() so that filters don't\n   * need to handle anything above */\n  if (seccomp_data != NULL &&\n      prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &seccomp_prog) != 0)\n    die_with_error (\"prctl(PR_SET_SECCOMP)\");\n\n  if (setup_finished_pipe[1] != -1)\n    {\n      char data = 0;\n      res = write_to_fd (setup_finished_pipe[1], &data, 1);\n      /* Ignore res, if e.g. the parent died and closed setup_finished_pipe[0]\n         we don't want to error out here */\n    }\n\n  if (execvp (argv[0], argv) == -1)\n    {\n      if (setup_finished_pipe[1] != -1)\n        {\n          int saved_errno = errno;\n          char data = 0;\n          res = write_to_fd (setup_finished_pipe[1], &data, 1);\n          errno = saved_errno;\n          /* Ignore res, if e.g. the parent died and closed setup_finished_pipe[0]\n             we don't want to error out here */\n        }\n      die_with_error (\"execvp %s\", argv[0]);\n    }\n\n  return 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143247,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "main (int    argc,\n       char **argv)\n {\n   mode_t old_umask;\n  const char *base_path = NULL;\n   int clone_flags;\n   char *old_cwd = NULL;\n   pid_t pid;\n  int event_fd = -1;\n  int child_wait_fd = -1;\n  int setup_finished_pipe[] = {-1, -1};\n  const char *new_cwd;\n  uid_t ns_uid;\n  gid_t ns_gid;\n  struct stat sbuf;\n  uint64_t val;\n  int res UNUSED;\n  cleanup_free char *seccomp_data = NULL;\n  size_t seccomp_len;\n  struct sock_fprog seccomp_prog;\n  cleanup_free char *args_data = NULL;\n\n  /* Handle --version early on before we try to acquire/drop\n   * any capabilities so it works in a build environment;\n   * right now flatpak's build runs bubblewrap --version.\n   * https://github.com/projectatomic/bubblewrap/issues/185\n   */\n  if (argc == 2 && (strcmp (argv[1], \"--version\") == 0))\n    print_version_and_exit ();\n\n  real_uid = getuid ();\n  real_gid = getgid ();\n\n  /* Get the (optional) privileges we need */\n  acquire_privs ();\n\n  /* Never gain any more privs during exec */\n  if (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0)\n    die_with_error (\"prctl(PR_SET_NO_NEW_CAPS) failed\");\n\n  /* The initial code is run with high permissions\n     (i.e. CAP_SYS_ADMIN), so take lots of care. */\n\n  read_overflowids ();\n\n  argv0 = argv[0];\n\n  if (isatty (1))\n    host_tty_dev = ttyname (1);\n\n  argv++;\n  argc--;\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  parse_args (&argc, (const char ***) &argv);\n\n  /* suck the args into a cleanup_free variable to control their lifecycle */\n  args_data = opt_args_data;\n  opt_args_data = NULL;\n\n  if ((requested_caps[0] || requested_caps[1]) && is_privileged)\n    die (\"--cap-add in setuid mode can be used only by root\");\n\n  if (opt_userns_block_fd != -1 && !opt_unshare_user)\n    die (\"--userns-block-fd requires --unshare-user\");\n\n  if (opt_userns_block_fd != -1 && opt_info_fd == -1)\n    die (\"--userns-block-fd requires --info-fd\");\n\n  /* We have to do this if we weren't installed setuid (and we're not\n   * root), so let's just DWIM */\n  if (!is_privileged && getuid () != 0)\n    opt_unshare_user = TRUE;\n\n#ifdef ENABLE_REQUIRE_USERNS\n  /* In this build option, we require userns. */\n  if (is_privileged && getuid () != 0)\n    opt_unshare_user = TRUE;\n#endif\n\n  if (opt_unshare_user_try &&\n      stat (\"/proc/self/ns/user\", &sbuf) == 0)\n    {\n      bool disabled = FALSE;\n\n      /* RHEL7 has a kernel module parameter that lets you enable user namespaces */\n      if (stat (\"/sys/module/user_namespace/parameters/enable\", &sbuf) == 0)\n        {\n          cleanup_free char *enable = NULL;\n          enable = load_file_at (AT_FDCWD, \"/sys/module/user_namespace/parameters/enable\");\n          if (enable != NULL && enable[0] == 'N')\n            disabled = TRUE;\n        }\n\n      /* Check for max_user_namespaces */\n      if (stat (\"/proc/sys/user/max_user_namespaces\", &sbuf) == 0)\n        {\n          cleanup_free char *max_user_ns = NULL;\n          max_user_ns = load_file_at (AT_FDCWD, \"/proc/sys/user/max_user_namespaces\");\n          if (max_user_ns != NULL && strcmp(max_user_ns, \"0\\n\") == 0)\n            disabled = TRUE;\n        }\n\n      /* Debian lets you disable *unprivileged* user namespaces. However this is not\n         a problem if we're privileged, and if we're not opt_unshare_user is TRUE\n         already, and there is not much we can do, its just a non-working setup. */\n\n      if (!disabled)\n        opt_unshare_user = TRUE;\n    }\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  __debug__ ((\"Creating root mount point\\n\"));\n\n  if (opt_sandbox_uid == -1)\n    opt_sandbox_uid = real_uid;\n  if (opt_sandbox_gid == -1)\n    opt_sandbox_gid = real_gid;\n\n  if (!opt_unshare_user && opt_sandbox_uid != real_uid)\n    die (\"Specifying --uid requires --unshare-user\");\n\n  if (!opt_unshare_user && opt_sandbox_gid != real_gid)\n    die (\"Specifying --gid requires --unshare-user\");\n\n  if (!opt_unshare_uts && opt_sandbox_hostname != NULL)\n    die (\"Specifying --hostname requires --unshare-uts\");\n\n  if (opt_as_pid_1 && !opt_unshare_pid)\n    die (\"Specifying --as-pid-1 requires --unshare-pid\");\n\n  if (opt_as_pid_1 && lock_files != NULL)\n    die (\"Specifying --as-pid-1 and --lock-file is not permitted\");\n\n  /* We need to read stuff from proc during the pivot_root dance, etc.\n     Lets keep a fd to it open */\n  proc_fd = open (\"/proc\", O_PATH);\n  if (proc_fd == -1)\n     die_with_error (\"Can't open /proc\");\n \n   /* We need *some* mountpoint where we can mount the root tmpfs.\n   * Because we use pivot_root, it won't appear to be mounted from\n   * the perspective of the sandboxed process, so we can use anywhere\n   * that is sure to exist, that is sure to not be a symlink controlled\n   * by someone malicious, and that we won't immediately need to\n   * access ourselves. */\n  base_path = \"/tmp\";\n \n   __debug__ ((\"creating new namespace\\n\"));\n \n  if (opt_unshare_pid && !opt_as_pid_1)\n    {\n      event_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK);\n      if (event_fd == -1)\n        die_with_error (\"eventfd()\");\n    }\n\n  /* We block sigchild here so that we can use signalfd in the monitor. */\n  block_sigchild ();\n\n  clone_flags = SIGCHLD | CLONE_NEWNS;\n  if (opt_unshare_user)\n    clone_flags |= CLONE_NEWUSER;\n  if (opt_unshare_pid)\n    clone_flags |= CLONE_NEWPID;\n  if (opt_unshare_net)\n    clone_flags |= CLONE_NEWNET;\n  if (opt_unshare_ipc)\n    clone_flags |= CLONE_NEWIPC;\n  if (opt_unshare_uts)\n    clone_flags |= CLONE_NEWUTS;\n  if (opt_unshare_cgroup)\n    {\n      if (stat (\"/proc/self/ns/cgroup\", &sbuf))\n        {\n          if (errno == ENOENT)\n            die (\"Cannot create new cgroup namespace because the kernel does not support it\");\n          else\n            die_with_error (\"stat on /proc/self/ns/cgroup failed\");\n        }\n      clone_flags |= CLONE_NEWCGROUP;\n    }\n  if (opt_unshare_cgroup_try)\n    if (!stat (\"/proc/self/ns/cgroup\", &sbuf))\n      clone_flags |= CLONE_NEWCGROUP;\n\n  child_wait_fd = eventfd (0, EFD_CLOEXEC);\n  if (child_wait_fd == -1)\n    die_with_error (\"eventfd()\");\n\n  /* Track whether pre-exec setup finished if we're reporting process exit */\n  if (opt_json_status_fd != -1)\n    {\n      int ret;\n      ret = pipe2 (setup_finished_pipe, O_CLOEXEC);\n      if (ret == -1)\n        die_with_error (\"pipe2()\");\n    }\n\n  pid = raw_clone (clone_flags, NULL);\n  if (pid == -1)\n    {\n      if (opt_unshare_user)\n        {\n          if (errno == EINVAL)\n            die (\"Creating new namespace failed, likely because the kernel does not support user namespaces.  bwrap must be installed setuid on such systems.\");\n          else if (errno == EPERM && !is_privileged)\n            die (\"No permissions to creating new namespace, likely because the kernel does not allow non-privileged user namespaces. On e.g. debian this can be enabled with 'sysctl kernel.unprivileged_userns_clone=1'.\");\n        }\n\n      die_with_error (\"Creating new namespace failed\");\n    }\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n\n  if (pid != 0)\n    {\n      /* Parent, outside sandbox, privileged (initially) */\n\n      if (is_privileged && opt_unshare_user && opt_userns_block_fd == -1)\n        {\n          /* We're running as euid 0, but the uid we want to map is\n           * not 0. This means we're not allowed to write this from\n           * the child user namespace, so we do it from the parent.\n           *\n           * Also, we map uid/gid 0 in the namespace (to overflowuid)\n           * if opt_needs_devpts is true, because otherwise the mount\n           * of devpts fails due to root not being mapped.\n           */\n          write_uid_gid_map (ns_uid, real_uid,\n                             ns_gid, real_gid,\n                             pid, TRUE, opt_needs_devpts);\n        }\n\n      /* Initial launched process, wait for exec:ed command to exit */\n\n      /* We don't need any privileges in the launcher, drop them immediately. */\n      drop_privs (FALSE);\n\n      /* Optionally bind our lifecycle to that of the parent */\n      handle_die_with_parent ();\n\n      if (opt_info_fd != -1)\n        {\n          cleanup_free char *output = xasprintf (\"{\\n    \\\"child-pid\\\": %i\\n}\\n\", pid);\n          dump_info (opt_info_fd, output, TRUE);\n          close (opt_info_fd);\n        }\n      if (opt_json_status_fd != -1)\n        {\n          cleanup_free char *output = xasprintf (\"{ \\\"child-pid\\\": %i }\\n\", pid);\n          dump_info (opt_json_status_fd, output, TRUE);\n        }\n\n      if (opt_userns_block_fd != -1)\n        {\n          char b[1];\n          (void) TEMP_FAILURE_RETRY (read (opt_userns_block_fd, b, 1));\n          close (opt_userns_block_fd);\n        }\n\n      /* Let child run now that the uid maps are set up */\n      val = 1;\n      res = write (child_wait_fd, &val, 8);\n      /* Ignore res, if e.g. the child died and closed child_wait_fd we don't want to error out here */\n      close (child_wait_fd);\n\n      return monitor_child (event_fd, pid, setup_finished_pipe[0]);\n    }\n\n  /* Child, in sandbox, privileged in the parent or in the user namespace (if --unshare-user).\n   *\n   * Note that for user namespaces we run as euid 0 during clone(), so\n   * the child user namespace is owned by euid 0., This means that the\n   * regular user namespace parent (with uid != 0) doesn't have any\n   * capabilities in it, which is nice as we can't exploit those. In\n   * particular the parent user namespace doesn't have CAP_PTRACE\n   * which would otherwise allow the parent to hijack of the child\n   * after this point.\n   *\n   * Unfortunately this also means you can't ptrace the final\n   * sandboxed process from outside the sandbox either.\n   */\n\n  if (opt_info_fd != -1)\n    close (opt_info_fd);\n\n  if (opt_json_status_fd != -1)\n    close (opt_json_status_fd);\n\n  /* Wait for the parent to init uid/gid maps and drop caps */\n  res = read (child_wait_fd, &val, 8);\n  close (child_wait_fd);\n\n  /* At this point we can completely drop root uid, but retain the\n   * required permitted caps. This allow us to do full setup as\n   * the user uid, which makes e.g. fuse access work.\n   */\n  switch_to_user_with_privs ();\n\n  if (opt_unshare_net)\n    loopback_setup (); /* Will exit if unsuccessful */\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n  if (!is_privileged && opt_unshare_user && opt_userns_block_fd == -1)\n    {\n      /* In the unprivileged case we have to write the uid/gid maps in\n       * the child, because we have no caps in the parent */\n\n      if (opt_needs_devpts)\n        {\n          /* This is a bit hacky, but we need to first map the real uid/gid to\n             0, otherwise we can't mount the devpts filesystem because root is\n             not mapped. Later we will create another child user namespace and\n             map back to the real uid */\n          ns_uid = 0;\n          ns_gid = 0;\n        }\n\n      write_uid_gid_map (ns_uid, real_uid,\n                         ns_gid, real_gid,\n                         -1, TRUE, FALSE);\n    }\n\n  old_umask = umask (0);\n\n  /* Need to do this before the chroot, but after we're the real uid */\n  resolve_symlinks_in_ops ();\n\n  /* Mark everything as slave, so that we still\n   * receive mounts from the real root, but don't\n   * propagate mounts to the real root. */\n  if (mount (NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0)\n    die_with_error (\"Failed to make / slave\");\n\n  /* Create a tmpfs which we will use as / in the namespace */\n  if (mount (\"tmpfs\", base_path, \"tmpfs\", MS_NODEV | MS_NOSUID, NULL) != 0)\n    die_with_error (\"Failed to mount tmpfs\");\n\n  old_cwd = get_current_dir_name ();\n\n  /* Chdir to the new root tmpfs mount. This will be the CWD during\n     the entire setup. Access old or new root via \"oldroot\" and \"newroot\". */\n  if (chdir (base_path) != 0)\n    die_with_error (\"chdir base_path\");\n\n   /* We create a subdir \"$base_path/newroot\" for the new root, that\n    * way we can pivot_root to base_path, and put the old root at\n    * \"$base_path/oldroot\". This avoids problems accessing the oldroot\n   * dir if the user requested to bind mount something over / (or\n   * over /tmp, now that we use that for base_path). */\n \n   if (mkdir (\"newroot\", 0755))\n     die_with_error (\"Creating newroot failed\");\n\n  if (mount (\"newroot\", \"newroot\", NULL, MS_MGC_VAL | MS_BIND | MS_REC, NULL) < 0)\n    die_with_error (\"setting up newroot bind\");\n\n  if (mkdir (\"oldroot\", 0755))\n    die_with_error (\"Creating oldroot failed\");\n\n  if (pivot_root (base_path, \"oldroot\"))\n    die_with_error (\"pivot_root\");\n\n  if (chdir (\"/\") != 0)\n    die_with_error (\"chdir / (base path)\");\n\n  if (is_privileged)\n    {\n      pid_t child;\n      int privsep_sockets[2];\n\n      if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, privsep_sockets) != 0)\n        die_with_error (\"Can't create privsep socket\");\n\n      child = fork ();\n      if (child == -1)\n        die_with_error (\"Can't fork unprivileged helper\");\n\n      if (child == 0)\n        {\n          /* Unprivileged setup process */\n          drop_privs (FALSE);\n          close (privsep_sockets[0]);\n          setup_newroot (opt_unshare_pid, privsep_sockets[1]);\n          exit (0);\n        }\n      else\n        {\n          int status;\n          uint32_t buffer[2048];  /* 8k, but is int32 to guarantee nice alignment */\n          uint32_t op, flags;\n          const char *arg1, *arg2;\n          cleanup_fd int unpriv_socket = -1;\n\n          unpriv_socket = privsep_sockets[0];\n          close (privsep_sockets[1]);\n\n          do\n            {\n              op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer),\n                                     &flags, &arg1, &arg2);\n              privileged_op (-1, op, flags, arg1, arg2);\n              if (write (unpriv_socket, buffer, 1) != 1)\n                die (\"Can't write to op_socket\");\n            }\n          while (op != PRIV_SEP_OP_DONE);\n\n          waitpid (child, &status, 0);\n          /* Continue post setup */\n        }\n    }\n  else\n    {\n      setup_newroot (opt_unshare_pid, -1);\n    }\n\n  close_ops_fd ();\n\n  /* The old root better be rprivate or we will send unmount events to the parent namespace */\n  if (mount (\"oldroot\", \"oldroot\", NULL, MS_REC | MS_PRIVATE, NULL) != 0)\n    die_with_error (\"Failed to make old root rprivate\");\n\n  if (umount2 (\"oldroot\", MNT_DETACH))\n    die_with_error (\"unmount old root\");\n\n  /* This is our second pivot. It's like we're a Silicon Valley startup flush\n   * with cash but short on ideas!\n   *\n   * We're aiming to make /newroot the real root, and get rid of /oldroot. To do\n   * that we need a temporary place to store it before we can unmount it.\n   */\n  { cleanup_fd int oldrootfd = open (\"/\", O_DIRECTORY | O_RDONLY);\n    if (oldrootfd < 0)\n      die_with_error (\"can't open /\");\n    if (chdir (\"/newroot\") != 0)\n      die_with_error (\"chdir /newroot\");\n    /* While the documentation claims that put_old must be underneath\n     * new_root, it is perfectly fine to use the same directory as the\n     * kernel checks only if old_root is accessible from new_root.\n     *\n     * Both runc and LXC are using this \"alternative\" method for\n     * setting up the root of the container:\n     *\n     * https://github.com/opencontainers/runc/blob/master/libcontainer/rootfs_linux.go#L671\n     * https://github.com/lxc/lxc/blob/master/src/lxc/conf.c#L1121\n     */\n    if (pivot_root (\".\", \".\") != 0)\n      die_with_error (\"pivot_root(/newroot)\");\n    if (fchdir (oldrootfd) < 0)\n      die_with_error (\"fchdir to oldroot\");\n    if (umount2 (\".\", MNT_DETACH) < 0)\n      die_with_error (\"umount old root\");\n    if (chdir (\"/\") != 0)\n      die_with_error (\"chdir /\");\n  }\n\n  if (opt_unshare_user &&\n      (ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid) &&\n      opt_userns_block_fd == -1)\n    {\n      /* Now that devpts is mounted and we've no need for mount\n         permissions we can create a new userspace and map our uid\n         1:1 */\n\n      if (unshare (CLONE_NEWUSER))\n        die_with_error (\"unshare user ns\");\n\n      write_uid_gid_map (opt_sandbox_uid, ns_uid,\n                         opt_sandbox_gid, ns_gid,\n                         -1, FALSE, FALSE);\n    }\n\n  /* All privileged ops are done now, so drop caps we don't need */\n  drop_privs (!is_privileged);\n\n  if (opt_block_fd != -1)\n    {\n      char b[1];\n      (void) TEMP_FAILURE_RETRY (read (opt_block_fd, b, 1));\n      close (opt_block_fd);\n    }\n\n  if (opt_seccomp_fd != -1)\n    {\n      seccomp_data = load_file_data (opt_seccomp_fd, &seccomp_len);\n      if (seccomp_data == NULL)\n        die_with_error (\"Can't read seccomp data\");\n\n      if (seccomp_len % 8 != 0)\n        die (\"Invalid seccomp data, must be multiple of 8\");\n\n      seccomp_prog.len = seccomp_len / 8;\n      seccomp_prog.filter = (struct sock_filter *) seccomp_data;\n\n      close (opt_seccomp_fd);\n    }\n\n  umask (old_umask);\n\n  new_cwd = \"/\";\n  if (opt_chdir_path)\n    {\n      if (chdir (opt_chdir_path))\n        die_with_error (\"Can't chdir to %s\", opt_chdir_path);\n      new_cwd = opt_chdir_path;\n    }\n  else if (chdir (old_cwd) == 0)\n    {\n      /* If the old cwd is mapped in the sandbox, go there */\n      new_cwd = old_cwd;\n    }\n  else\n    {\n      /* If the old cwd is not mapped, go to home */\n      const char *home = getenv (\"HOME\");\n      if (home != NULL &&\n          chdir (home) == 0)\n        new_cwd = home;\n    }\n  xsetenv (\"PWD\", new_cwd, 1);\n  free (old_cwd);\n\n  if (opt_new_session &&\n      setsid () == (pid_t) -1)\n    die_with_error (\"setsid\");\n\n  if (label_exec (opt_exec_label) == -1)\n    die_with_error (\"label_exec %s\", argv[0]);\n\n  __debug__ ((\"forking for child\\n\"));\n\n  if (!opt_as_pid_1 && (opt_unshare_pid || lock_files != NULL || opt_sync_fd != -1))\n    {\n      /* We have to have a pid 1 in the pid namespace, because\n       * otherwise we'll get a bunch of zombies as nothing reaps\n       * them. Alternatively if we're using sync_fd or lock_files we\n       * need some process to own these.\n       */\n\n      pid = fork ();\n      if (pid == -1)\n        die_with_error (\"Can't fork for pid 1\");\n\n      if (pid != 0)\n        {\n          drop_all_caps (FALSE);\n\n          /* Close fds in pid 1, except stdio and optionally event_fd\n             (for syncing pid 2 lifetime with monitor_child) and\n             opt_sync_fd (for syncing sandbox lifetime with outside\n             process).\n             Any other fds will been passed on to the child though. */\n          {\n            int dont_close[3];\n            int j = 0;\n            if (event_fd != -1)\n              dont_close[j++] = event_fd;\n            if (opt_sync_fd != -1)\n              dont_close[j++] = opt_sync_fd;\n            dont_close[j++] = -1;\n            fdwalk (proc_fd, close_extra_fds, dont_close);\n          }\n\n          return do_init (event_fd, pid, seccomp_data != NULL ? &seccomp_prog : NULL);\n        }\n    }\n\n  __debug__ ((\"launch executable %s\\n\", argv[0]));\n\n  if (proc_fd != -1)\n    close (proc_fd);\n\n  /* If we are using --as-pid-1 leak the sync fd into the sandbox.\n     --sync-fd will still work unless the container process doesn't close this file.  */\n  if (!opt_as_pid_1)\n    {\n      if (opt_sync_fd != -1)\n        close (opt_sync_fd);\n    }\n\n  /* We want sigchild in the child */\n  unblock_sigchild ();\n\n  /* Optionally bind our lifecycle */\n  handle_die_with_parent ();\n\n  if (!is_privileged)\n    set_ambient_capabilities ();\n\n  /* Should be the last thing before execve() so that filters don't\n   * need to handle anything above */\n  if (seccomp_data != NULL &&\n      prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &seccomp_prog) != 0)\n    die_with_error (\"prctl(PR_SET_SECCOMP)\");\n\n  if (setup_finished_pipe[1] != -1)\n    {\n      char data = 0;\n      res = write_to_fd (setup_finished_pipe[1], &data, 1);\n      /* Ignore res, if e.g. the parent died and closed setup_finished_pipe[0]\n         we don't want to error out here */\n    }\n\n  if (execvp (argv[0], argv) == -1)\n    {\n      if (setup_finished_pipe[1] != -1)\n        {\n          int saved_errno = errno;\n          char data = 0;\n          res = write_to_fd (setup_finished_pipe[1], &data, 1);\n          errno = saved_errno;\n          /* Ignore res, if e.g. the parent died and closed setup_finished_pipe[0]\n             we don't want to error out here */\n        }\n      die_with_error (\"execvp %s\", argv[0]);\n    }\n\n  return 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143248,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int treeRead(struct READER *reader, struct DATAOBJECT *data) {\n\n\tint i, j, err, olen, elements, size, x, y, z, b, e, dy, dz, sx, sy, sz, dzy,\n\t\tszy;\n\tchar *input, *output;\n\n\tuint8_t node_type, node_level;\n\tuint16_t entries_used;\n\tuint32_t size_of_chunk;\n\tuint32_t filter_mask;\n\tuint64_t address_of_left_sibling, address_of_right_sibling, start[4],\n\t\tchild_pointer, key, store;\n\n\tchar buf[4];\n\n\tUNUSED(node_level);\n\tUNUSED(address_of_right_sibling);\n\tUNUSED(address_of_left_sibling);\n\tUNUSED(key);\n\n\tif (data->ds.dimensionality > 3) {\n\t\tlog(\"TREE dimensions > 3\");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t}\n\n\t/* read signature */\n\tif (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"TREE\", 4)) {\n\t\tlog(\"cannot read signature of TREE\\n\");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t} log(\"%08lX %.4s\\n\", (uint64_t )ftell(reader->fhd) - 4, buf);\n\n\tnode_type = (uint8_t)fgetc(reader->fhd);\n\tnode_level = (uint8_t)fgetc(reader->fhd);\n\tentries_used = (uint16_t)readValue(reader, 2);\n\tif(entries_used>0x1000)\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\taddress_of_left_sibling = readValue(reader,\n\t\t\t\t\t    reader->superblock.size_of_offsets);\n\taddress_of_right_sibling = readValue(reader,\n\t\t\t\t\t     reader->superblock.size_of_offsets);\n\n\telements = 1;\n\tfor (j = 0; j < data->ds.dimensionality; j++)\n\t\telements *= data->datalayout_chunk[j];\n\tdy = data->datalayout_chunk[1];\n\tdz = data->datalayout_chunk[2];\n\tsx = data->ds.dimension_size[0];\n\tsy = data->ds.dimension_size[1];\n\tsz = data->ds.dimension_size[2];\n\tdzy = dz * dy;\n\tszy = sz * sy;\n\tsize = data->datalayout_chunk[data->ds.dimensionality];\n\n\tlog(\"elements %d size %d\\n\",elements,size);\n\n\tif (!(output = malloc(elements * size))) {\n\t\treturn MYSOFA_NO_MEMORY;\n\t}\n\n\tfor (e = 0; e < entries_used * 2; e++) {\n\t\tif (node_type == 0) {\n\t\t\tkey = readValue(reader, reader->superblock.size_of_lengths);\n\t\t} else {\n\t\t\tsize_of_chunk = (uint32_t)readValue(reader, 4);\n\t\t\tfilter_mask = (uint32_t)readValue(reader, 4);\n\t\t\tif (filter_mask) {\n\t\t\t\tlog(\"TREE all filters must be enabled\\n\");\n\t\t\t\tfree(output);\n\t\t\t\treturn MYSOFA_INVALID_FORMAT;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < data->ds.dimensionality; j++) {\n\t\t\t\tstart[j] = readValue(reader, 8);\n\t\t\t\tlog(\"start %d %lu\\n\",j,start[j]);\n\t\t\t}\n\n\t\t\tif (readValue(reader, 8)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchild_pointer = readValue(reader,\n\t\t\t\t\t\t  reader->superblock.size_of_offsets);\n\t\t\tlog(\" data at %lX len %u\\n\", child_pointer, size_of_chunk);\n\n\t\t\t/* read data */\n\t\t\tstore = ftell(reader->fhd);\n\t\t\tif (fseek(reader->fhd, child_pointer, SEEK_SET)<0) {\n\t\t\t\tfree(output);\n\t\t\t\treturn errno;\n\t\t\t}\n\n\t\t\tif (!(input = malloc(size_of_chunk))) {\n\t\t\t\tfree(output);\n\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\t}\n\t\t\tif (fread(input, 1, size_of_chunk, reader->fhd) != size_of_chunk) {\n\t\t\t\tfree(output);\n\t\t\t\tfree(input);\n\t\t\t\treturn MYSOFA_INVALID_FORMAT;\n\t\t\t}\n\n\t\t\tolen = elements * size;\n\t\t\terr = gunzip(size_of_chunk, input, &olen, output);\n\t\t\tfree(input);\n\n\t\t\tlog(\"   gunzip %d %d %d\\n\",err, olen, elements*size);\n\t\t\tif (err || olen != elements * size) {\n\t\t\t\tfree(output);\n\t\t\t\treturn MYSOFA_INVALID_FORMAT;\n\t\t\t}\n\n\t\t\tswitch (data->ds.dimensionality) {\n\t\t\tcase 1:\n \t\t\t\tfor (i = 0; i < olen; i++) {\n \t\t\t\t\tb = i / elements;\n \t\t\t\t\tx = i % elements + start[0];\n\t\t\t\t\tif (x < sx) {\n\t\t\t\t\t\tj = x * size + b;\n \t\t\t\t\t\t((char*)data->data)[j] = output[i];\n \t\t\t\t\t}\n \t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tfor (i = 0; i < olen; i++) {\n\t\t\t\t\tb = i / elements;\n \t\t\t\t\tx = i % elements;\n \t\t\t\t\ty = x % dy + start[1];\n \t\t\t\t\tx = x / dy + start[0];\n\t\t\t\t\tif (y < sy && x < sx) {\n\t\t\t\t\t\tj = ((x * sy + y) * size) + b;\n \t\t\t\t\t\t((char*)data->data)[j] = output[i];\n \t\t\t\t\t}\n \t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfor (i = 0; i < olen; i++) {\n\t\t\t\t\tb = i / elements;\n\t\t\t\t\tx = i % elements;\n \t\t\t\t\tz = x % dz + start[2];\n \t\t\t\t\ty = (x / dz) % dy + start[1];\n \t\t\t\t\tx = (x / dzy) + start[0];\n\t\t\t\t\tif (z < sz && y < sy && x < sx) {\n\t\t\t\t\t\tj = (x * szy + y * sz + z) * size + b;\n \t\t\t\t\t\t((char*)data->data)[j] = output[i];\n \t\t\t\t\t}\n \t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlog(\"invalid dim\\n\");\n\t\t\t\treturn MYSOFA_INTERNAL_ERROR;\n\t\t\t}\n\n\t\t\tif(fseek(reader->fhd, store, SEEK_SET)<0) {\n\t\t\t\tfree(output);\n\t\t\t\treturn errno;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(output);\n\tif(fseek(reader->fhd, 4, SEEK_CUR)<0) /* skip checksum */\n\t\treturn errno;\n\n\treturn MYSOFA_OK;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143283,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int treeRead(struct READER *reader, struct DATAOBJECT *data) {\n\n\tint i, j, err, olen, elements, size, x, y, z, b, e, dy, dz, sx, sy, sz, dzy,\n\t\tszy;\n\tchar *input, *output;\n\n\tuint8_t node_type, node_level;\n\tuint16_t entries_used;\n\tuint32_t size_of_chunk;\n\tuint32_t filter_mask;\n\tuint64_t address_of_left_sibling, address_of_right_sibling, start[4],\n\t\tchild_pointer, key, store;\n\n\tchar buf[4];\n\n\tUNUSED(node_level);\n\tUNUSED(address_of_right_sibling);\n\tUNUSED(address_of_left_sibling);\n\tUNUSED(key);\n\n\tif (data->ds.dimensionality > 3) {\n\t\tlog(\"TREE dimensions > 3\");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t}\n\n\t/* read signature */\n\tif (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"TREE\", 4)) {\n\t\tlog(\"cannot read signature of TREE\\n\");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t} log(\"%08lX %.4s\\n\", (uint64_t )ftell(reader->fhd) - 4, buf);\n\n\tnode_type = (uint8_t)fgetc(reader->fhd);\n\tnode_level = (uint8_t)fgetc(reader->fhd);\n\tentries_used = (uint16_t)readValue(reader, 2);\n\tif(entries_used>0x1000)\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\taddress_of_left_sibling = readValue(reader,\n\t\t\t\t\t    reader->superblock.size_of_offsets);\n\taddress_of_right_sibling = readValue(reader,\n\t\t\t\t\t     reader->superblock.size_of_offsets);\n\n\telements = 1;\n\tfor (j = 0; j < data->ds.dimensionality; j++)\n\t\telements *= data->datalayout_chunk[j];\n\tdy = data->datalayout_chunk[1];\n\tdz = data->datalayout_chunk[2];\n\tsx = data->ds.dimension_size[0];\n\tsy = data->ds.dimension_size[1];\n\tsz = data->ds.dimension_size[2];\n\tdzy = dz * dy;\n\tszy = sz * sy;\n\tsize = data->datalayout_chunk[data->ds.dimensionality];\n\n\tlog(\"elements %d size %d\\n\",elements,size);\n\n\tif (!(output = malloc(elements * size))) {\n\t\treturn MYSOFA_NO_MEMORY;\n\t}\n\n\tfor (e = 0; e < entries_used * 2; e++) {\n\t\tif (node_type == 0) {\n\t\t\tkey = readValue(reader, reader->superblock.size_of_lengths);\n\t\t} else {\n\t\t\tsize_of_chunk = (uint32_t)readValue(reader, 4);\n\t\t\tfilter_mask = (uint32_t)readValue(reader, 4);\n\t\t\tif (filter_mask) {\n\t\t\t\tlog(\"TREE all filters must be enabled\\n\");\n\t\t\t\tfree(output);\n\t\t\t\treturn MYSOFA_INVALID_FORMAT;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < data->ds.dimensionality; j++) {\n\t\t\t\tstart[j] = readValue(reader, 8);\n\t\t\t\tlog(\"start %d %lu\\n\",j,start[j]);\n\t\t\t}\n\n\t\t\tif (readValue(reader, 8)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchild_pointer = readValue(reader,\n\t\t\t\t\t\t  reader->superblock.size_of_offsets);\n\t\t\tlog(\" data at %lX len %u\\n\", child_pointer, size_of_chunk);\n\n\t\t\t/* read data */\n\t\t\tstore = ftell(reader->fhd);\n\t\t\tif (fseek(reader->fhd, child_pointer, SEEK_SET)<0) {\n\t\t\t\tfree(output);\n\t\t\t\treturn errno;\n\t\t\t}\n\n\t\t\tif (!(input = malloc(size_of_chunk))) {\n\t\t\t\tfree(output);\n\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\t}\n\t\t\tif (fread(input, 1, size_of_chunk, reader->fhd) != size_of_chunk) {\n\t\t\t\tfree(output);\n\t\t\t\tfree(input);\n\t\t\t\treturn MYSOFA_INVALID_FORMAT;\n\t\t\t}\n\n\t\t\tolen = elements * size;\n\t\t\terr = gunzip(size_of_chunk, input, &olen, output);\n\t\t\tfree(input);\n\n\t\t\tlog(\"   gunzip %d %d %d\\n\",err, olen, elements*size);\n\t\t\tif (err || olen != elements * size) {\n\t\t\t\tfree(output);\n\t\t\t\treturn MYSOFA_INVALID_FORMAT;\n\t\t\t}\n\n\t\t\tswitch (data->ds.dimensionality) {\n\t\t\tcase 1:\n \t\t\t\tfor (i = 0; i < olen; i++) {\n \t\t\t\t\tb = i / elements;\n \t\t\t\t\tx = i % elements + start[0];\n\t\t\t\t\tj = x * size + b;\n\t\t\t\t\tif (j>=0 && j < elements * size) {\n \t\t\t\t\t\t((char*)data->data)[j] = output[i];\n \t\t\t\t\t}\n \t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tfor (i = 0; i < olen; i++) {\n\t\t\t\t\tb = i / elements;\n \t\t\t\t\tx = i % elements;\n \t\t\t\t\ty = x % dy + start[1];\n \t\t\t\t\tx = x / dy + start[0];\n\t\t\t\t\tj = ((x * sy + y) * size) + b;\n\t\t\t\t\tif (j>=0 && j < elements * size) {\n \t\t\t\t\t\t((char*)data->data)[j] = output[i];\n \t\t\t\t\t}\n \t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfor (i = 0; i < olen; i++) {\n\t\t\t\t\tb = i / elements;\n\t\t\t\t\tx = i % elements;\n \t\t\t\t\tz = x % dz + start[2];\n \t\t\t\t\ty = (x / dz) % dy + start[1];\n \t\t\t\t\tx = (x / dzy) + start[0];\n\t\t\t\t\tj = (x * szy + y * sz + z) * size + b;\n\t\t\t\t\tif (j>=0 && j < elements * size) {\n \t\t\t\t\t\t((char*)data->data)[j] = output[i];\n \t\t\t\t\t}\n \t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlog(\"invalid dim\\n\");\n\t\t\t\treturn MYSOFA_INTERNAL_ERROR;\n\t\t\t}\n\n\t\t\tif(fseek(reader->fhd, store, SEEK_SET)<0) {\n\t\t\t\tfree(output);\n\t\t\t\treturn errno;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(output);\n\tif(fseek(reader->fhd, 4, SEEK_CUR)<0) /* skip checksum */\n\t\treturn errno;\n\n\treturn MYSOFA_OK;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143284,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static opj_bool pi_next_cprl(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n\n    for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n        int resno;\n        comp = &pi->comps[pi->compno];\n        pi->dx = 0;\n        pi->dy = 0;\n        for (resno = 0; resno < comp->numresolutions; resno++) {\n            int dx, dy;\n            res = &comp->resolutions[resno];\n            dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));\n            dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));\n            pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);\n            pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);\n        }\n        if (!pi->tp_on) {\n            pi->poc.ty0 = pi->ty0;\n            pi->poc.tx0 = pi->tx0;\n            pi->poc.ty1 = pi->ty1;\n            pi->poc.tx1 = pi->tx1;\n        }\n        for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1;\n                pi->y += pi->dy - (pi->y % pi->dy)) {\n            for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;\n                    pi->x += pi->dx - (pi->x % pi->dx)) {\n                for (pi->resno = pi->poc.resno0;\n                        pi->resno < int_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {\n                    int levelno;\n                    int trx0, try0;\n                    int trx1, try1;\n                    int rpx, rpy;\n                    int prci, prcj;\n                    res = &comp->resolutions[pi->resno];\n                    levelno = comp->numresolutions - 1 - pi->resno;\n                    trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);\n                    try0 = int_ceildiv(pi->ty0, comp->dy << levelno);\n                    trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);\n                    try1 = int_ceildiv(pi->ty1, comp->dy << levelno);\n                    rpx = res->pdx + levelno;\n                    rpy = res->pdy + levelno;\n\n                    /* To avoid divisions by zero / undefined behaviour on shift */\n                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||\n                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {\n                        continue;\n                    }\n\n                    if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                            ((try0 << levelno) % (1 << rpy))))) {\n                        continue;\n                    }\n                    if (!((pi->x % (comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&\n                            ((trx0 << levelno) % (1 << rpx))))) {\n                        continue;\n                    }\n\n                    if ((res->pw == 0) || (res->ph == 0)) {\n                        continue;\n                    }\n\n                    if ((trx0 == trx1) || (try0 == try1)) {\n                        continue;\n                    }\n\n                    prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx)\n                           - int_floordivpow2(trx0, res->pdx);\n                    prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy)\n                           - int_floordivpow2(try0, res->pdy);\n                    pi->precno = prci + prcj * res->pw;\n                     for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n                         index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                                 pi->step_c + pi->precno * pi->step_p;\n                         if (!pi->include[index]) {\n                             pi->include[index] = 1;\n                             return OPJ_TRUE;\n                        }\nLABEL_SKIP:\n                        ;\n                    }\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143313,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static opj_bool pi_next_cprl(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n\n    for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n        int resno;\n        comp = &pi->comps[pi->compno];\n        pi->dx = 0;\n        pi->dy = 0;\n        for (resno = 0; resno < comp->numresolutions; resno++) {\n            int dx, dy;\n            res = &comp->resolutions[resno];\n            dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));\n            dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));\n            pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);\n            pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);\n        }\n        if (!pi->tp_on) {\n            pi->poc.ty0 = pi->ty0;\n            pi->poc.tx0 = pi->tx0;\n            pi->poc.ty1 = pi->ty1;\n            pi->poc.tx1 = pi->tx1;\n        }\n        for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1;\n                pi->y += pi->dy - (pi->y % pi->dy)) {\n            for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;\n                    pi->x += pi->dx - (pi->x % pi->dx)) {\n                for (pi->resno = pi->poc.resno0;\n                        pi->resno < int_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {\n                    int levelno;\n                    int trx0, try0;\n                    int trx1, try1;\n                    int rpx, rpy;\n                    int prci, prcj;\n                    res = &comp->resolutions[pi->resno];\n                    levelno = comp->numresolutions - 1 - pi->resno;\n                    trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);\n                    try0 = int_ceildiv(pi->ty0, comp->dy << levelno);\n                    trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);\n                    try1 = int_ceildiv(pi->ty1, comp->dy << levelno);\n                    rpx = res->pdx + levelno;\n                    rpy = res->pdy + levelno;\n\n                    /* To avoid divisions by zero / undefined behaviour on shift */\n                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||\n                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {\n                        continue;\n                    }\n\n                    if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                            ((try0 << levelno) % (1 << rpy))))) {\n                        continue;\n                    }\n                    if (!((pi->x % (comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&\n                            ((trx0 << levelno) % (1 << rpx))))) {\n                        continue;\n                    }\n\n                    if ((res->pw == 0) || (res->ph == 0)) {\n                        continue;\n                    }\n\n                    if ((trx0 == trx1) || (try0 == try1)) {\n                        continue;\n                    }\n\n                    prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx)\n                           - int_floordivpow2(trx0, res->pdx);\n                    prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy)\n                           - int_floordivpow2(try0, res->pdy);\n                    pi->precno = prci + prcj * res->pw;\n                     for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n                         index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                                 pi->step_c + pi->precno * pi->step_p;\n                        /* Avoids index out of bounds access with include*/\n                        if (index >= pi->include_size) {\n                            opj_pi_emit_error(pi, \"Invalid access to pi->include\");\n                            return OPJ_FALSE;\n                        }\n                         if (!pi->include[index]) {\n                             pi->include[index] = 1;\n                             return OPJ_TRUE;\n                        }\nLABEL_SKIP:\n                        ;\n                    }\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143314,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " static opj_bool pi_next_lrcp(opj_pi_iterator_t * pi)\n {\n     opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        res = &comp->resolutions[pi->resno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n\n    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n        for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1;\n                pi->resno++) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                if (pi->resno >= comp->numresolutions) {\n                    continue;\n                }\n                res = &comp->resolutions[pi->resno];\n                if (!pi->tp_on) {\n                    pi->poc.precno1 = res->pw * res->ph;\n                }\n                 for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n                     index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                             pi->step_c + pi->precno * pi->step_p;\n                     if (!pi->include[index]) {\n                         pi->include[index] = 1;\n                         return OPJ_TRUE;\n                    }\nLABEL_SKIP:\n                    ;\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143315,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " static opj_bool pi_next_lrcp(opj_pi_iterator_t * pi)\n {\n     opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        res = &comp->resolutions[pi->resno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n\n    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n        for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1;\n                pi->resno++) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                if (pi->resno >= comp->numresolutions) {\n                    continue;\n                }\n                res = &comp->resolutions[pi->resno];\n                if (!pi->tp_on) {\n                    pi->poc.precno1 = res->pw * res->ph;\n                }\n                 for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n                     index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                             pi->step_c + pi->precno * pi->step_p;\n                    /* Avoids index out of bounds access with include*/\n                    if (index >= pi->include_size) {\n                        opj_pi_emit_error(pi, \"Invalid access to pi->include\");\n                        return OPJ_FALSE;\n                    }\n                     if (!pi->include[index]) {\n                         pi->include[index] = 1;\n                         return OPJ_TRUE;\n                    }\nLABEL_SKIP:\n                    ;\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143316,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static opj_bool pi_next_pcrl(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        goto LABEL_SKIP;\n    } else {\n        int compno, resno;\n        pi->first = 0;\n        pi->dx = 0;\n        pi->dy = 0;\n        for (compno = 0; compno < pi->numcomps; compno++) {\n            comp = &pi->comps[compno];\n            for (resno = 0; resno < comp->numresolutions; resno++) {\n                int dx, dy;\n                res = &comp->resolutions[resno];\n                dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));\n                dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));\n                pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);\n                pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);\n            }\n        }\n    }\n    if (!pi->tp_on) {\n        pi->poc.ty0 = pi->ty0;\n        pi->poc.tx0 = pi->tx0;\n        pi->poc.ty1 = pi->ty1;\n        pi->poc.tx1 = pi->tx1;\n    }\n    for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1;\n            pi->y += pi->dy - (pi->y % pi->dy)) {\n        for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;\n                pi->x += pi->dx - (pi->x % pi->dx)) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                for (pi->resno = pi->poc.resno0;\n                        pi->resno < int_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {\n                    int levelno;\n                    int trx0, try0;\n                    int trx1, try1;\n                    int rpx, rpy;\n                    int prci, prcj;\n                    res = &comp->resolutions[pi->resno];\n                    levelno = comp->numresolutions - 1 - pi->resno;\n                    trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);\n                    try0 = int_ceildiv(pi->ty0, comp->dy << levelno);\n                    trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);\n                    try1 = int_ceildiv(pi->ty1, comp->dy << levelno);\n                    rpx = res->pdx + levelno;\n                    rpy = res->pdy + levelno;\n\n                    /* To avoid divisions by zero / undefined behaviour on shift */\n                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||\n                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {\n                        continue;\n                    }\n\n                    if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                            ((try0 << levelno) % (1 << rpy))))) {\n                        continue;\n                    }\n                    if (!((pi->x % (comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&\n                            ((trx0 << levelno) % (1 << rpx))))) {\n                        continue;\n                    }\n\n                    if ((res->pw == 0) || (res->ph == 0)) {\n                        continue;\n                    }\n\n                    if ((trx0 == trx1) || (try0 == try1)) {\n                        continue;\n                    }\n\n                    prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx)\n                           - int_floordivpow2(trx0, res->pdx);\n                    prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy)\n                           - int_floordivpow2(try0, res->pdy);\n                    pi->precno = prci + prcj * res->pw;\n                     for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n                         index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                                 pi->step_c + pi->precno * pi->step_p;\n                         if (!pi->include[index]) {\n                             pi->include[index] = 1;\n                             return OPJ_TRUE;\n                        }\nLABEL_SKIP:\n                        ;\n                    }\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143317,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static opj_bool pi_next_pcrl(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        goto LABEL_SKIP;\n    } else {\n        int compno, resno;\n        pi->first = 0;\n        pi->dx = 0;\n        pi->dy = 0;\n        for (compno = 0; compno < pi->numcomps; compno++) {\n            comp = &pi->comps[compno];\n            for (resno = 0; resno < comp->numresolutions; resno++) {\n                int dx, dy;\n                res = &comp->resolutions[resno];\n                dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));\n                dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));\n                pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);\n                pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);\n            }\n        }\n    }\n    if (!pi->tp_on) {\n        pi->poc.ty0 = pi->ty0;\n        pi->poc.tx0 = pi->tx0;\n        pi->poc.ty1 = pi->ty1;\n        pi->poc.tx1 = pi->tx1;\n    }\n    for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1;\n            pi->y += pi->dy - (pi->y % pi->dy)) {\n        for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;\n                pi->x += pi->dx - (pi->x % pi->dx)) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                for (pi->resno = pi->poc.resno0;\n                        pi->resno < int_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {\n                    int levelno;\n                    int trx0, try0;\n                    int trx1, try1;\n                    int rpx, rpy;\n                    int prci, prcj;\n                    res = &comp->resolutions[pi->resno];\n                    levelno = comp->numresolutions - 1 - pi->resno;\n                    trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);\n                    try0 = int_ceildiv(pi->ty0, comp->dy << levelno);\n                    trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);\n                    try1 = int_ceildiv(pi->ty1, comp->dy << levelno);\n                    rpx = res->pdx + levelno;\n                    rpy = res->pdy + levelno;\n\n                    /* To avoid divisions by zero / undefined behaviour on shift */\n                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||\n                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {\n                        continue;\n                    }\n\n                    if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                            ((try0 << levelno) % (1 << rpy))))) {\n                        continue;\n                    }\n                    if (!((pi->x % (comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&\n                            ((trx0 << levelno) % (1 << rpx))))) {\n                        continue;\n                    }\n\n                    if ((res->pw == 0) || (res->ph == 0)) {\n                        continue;\n                    }\n\n                    if ((trx0 == trx1) || (try0 == try1)) {\n                        continue;\n                    }\n\n                    prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx)\n                           - int_floordivpow2(trx0, res->pdx);\n                    prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy)\n                           - int_floordivpow2(try0, res->pdy);\n                    pi->precno = prci + prcj * res->pw;\n                     for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n                         index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                                 pi->step_c + pi->precno * pi->step_p;\n                        /* Avoids index out of bounds access with include*/\n                        if (index >= pi->include_size) {\n                            opj_pi_emit_error(pi, \"Invalid access to pi->include\");\n                            return OPJ_FALSE;\n                        }\n                         if (!pi->include[index]) {\n                             pi->include[index] = 1;\n                             return OPJ_TRUE;\n                        }\nLABEL_SKIP:\n                        ;\n                    }\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143318,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static opj_bool pi_next_rlcp(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        res = &comp->resolutions[pi->resno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n\n    for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n        for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                if (pi->resno >= comp->numresolutions) {\n                    continue;\n                }\n                res = &comp->resolutions[pi->resno];\n                if (!pi->tp_on) {\n                    pi->poc.precno1 = res->pw * res->ph;\n                }\n                 for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n                     index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                             pi->step_c + pi->precno * pi->step_p;\n                     if (!pi->include[index]) {\n                         pi->include[index] = 1;\n                         return OPJ_TRUE;\n                    }\nLABEL_SKIP:\n                    ;\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143319,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static opj_bool pi_next_rlcp(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        res = &comp->resolutions[pi->resno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n\n    for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n        for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                if (pi->resno >= comp->numresolutions) {\n                    continue;\n                }\n                res = &comp->resolutions[pi->resno];\n                if (!pi->tp_on) {\n                    pi->poc.precno1 = res->pw * res->ph;\n                }\n                 for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n                     index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                             pi->step_c + pi->precno * pi->step_p;\n                    /* Avoids index out of bounds access with include*/\n                    if (index >= pi->include_size) {\n                        opj_pi_emit_error(pi, \"Invalid access to pi->include\");\n                        return OPJ_FALSE;\n                    }\n                     if (!pi->include[index]) {\n                         pi->include[index] = 1;\n                         return OPJ_TRUE;\n                    }\nLABEL_SKIP:\n                    ;\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143320,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static opj_bool pi_next_rpcl(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n\n    if (!pi->first) {\n        goto LABEL_SKIP;\n    } else {\n        int compno, resno;\n        pi->first = 0;\n        pi->dx = 0;\n        pi->dy = 0;\n        for (compno = 0; compno < pi->numcomps; compno++) {\n            comp = &pi->comps[compno];\n            for (resno = 0; resno < comp->numresolutions; resno++) {\n                int dx, dy;\n                res = &comp->resolutions[resno];\n                dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));\n                dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));\n                pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);\n                pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);\n            }\n        }\n    }\n    if (!pi->tp_on) {\n        pi->poc.ty0 = pi->ty0;\n        pi->poc.tx0 = pi->tx0;\n        pi->poc.ty1 = pi->ty1;\n        pi->poc.tx1 = pi->tx1;\n    }\n    for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n        for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1;\n                pi->y += pi->dy - (pi->y % pi->dy)) {\n            for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;\n                    pi->x += pi->dx - (pi->x % pi->dx)) {\n                for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                    int levelno;\n                    int trx0, try0;\n                    int trx1, try1;\n                    int rpx, rpy;\n                    int prci, prcj;\n                    comp = &pi->comps[pi->compno];\n                    if (pi->resno >= comp->numresolutions) {\n                        continue;\n                    }\n                    res = &comp->resolutions[pi->resno];\n                    levelno = comp->numresolutions - 1 - pi->resno;\n                    trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);\n                    try0 = int_ceildiv(pi->ty0, comp->dy << levelno);\n                    trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);\n                    try1 = int_ceildiv(pi->ty1, comp->dy << levelno);\n                    rpx = res->pdx + levelno;\n                    rpy = res->pdy + levelno;\n\n                    /* To avoid divisions by zero / undefined behaviour on shift */\n                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||\n                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {\n                        continue;\n                    }\n\n                    if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                            ((try0 << levelno) % (1 << rpy))))) {\n                        continue;\n                    }\n                    if (!((pi->x % (comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&\n                            ((trx0 << levelno) % (1 << rpx))))) {\n                        continue;\n                    }\n\n                    if ((res->pw == 0) || (res->ph == 0)) {\n                        continue;\n                    }\n\n                    if ((trx0 == trx1) || (try0 == try1)) {\n                        continue;\n                    }\n\n                    prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx)\n                           - int_floordivpow2(trx0, res->pdx);\n                    prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy)\n                           - int_floordivpow2(try0, res->pdy);\n                    pi->precno = prci + prcj * res->pw;\n                     for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n                         index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                                 pi->step_c + pi->precno * pi->step_p;\n                         if (!pi->include[index]) {\n                             pi->include[index] = 1;\n                             return OPJ_TRUE;\n                        }\nLABEL_SKIP:\n                        ;\n                    }\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143321,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static opj_bool pi_next_rpcl(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n\n    if (!pi->first) {\n        goto LABEL_SKIP;\n    } else {\n        int compno, resno;\n        pi->first = 0;\n        pi->dx = 0;\n        pi->dy = 0;\n        for (compno = 0; compno < pi->numcomps; compno++) {\n            comp = &pi->comps[compno];\n            for (resno = 0; resno < comp->numresolutions; resno++) {\n                int dx, dy;\n                res = &comp->resolutions[resno];\n                dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));\n                dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));\n                pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);\n                pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);\n            }\n        }\n    }\n    if (!pi->tp_on) {\n        pi->poc.ty0 = pi->ty0;\n        pi->poc.tx0 = pi->tx0;\n        pi->poc.ty1 = pi->ty1;\n        pi->poc.tx1 = pi->tx1;\n    }\n    for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n        for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1;\n                pi->y += pi->dy - (pi->y % pi->dy)) {\n            for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;\n                    pi->x += pi->dx - (pi->x % pi->dx)) {\n                for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                    int levelno;\n                    int trx0, try0;\n                    int trx1, try1;\n                    int rpx, rpy;\n                    int prci, prcj;\n                    comp = &pi->comps[pi->compno];\n                    if (pi->resno >= comp->numresolutions) {\n                        continue;\n                    }\n                    res = &comp->resolutions[pi->resno];\n                    levelno = comp->numresolutions - 1 - pi->resno;\n                    trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);\n                    try0 = int_ceildiv(pi->ty0, comp->dy << levelno);\n                    trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);\n                    try1 = int_ceildiv(pi->ty1, comp->dy << levelno);\n                    rpx = res->pdx + levelno;\n                    rpy = res->pdy + levelno;\n\n                    /* To avoid divisions by zero / undefined behaviour on shift */\n                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||\n                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {\n                        continue;\n                    }\n\n                    if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                            ((try0 << levelno) % (1 << rpy))))) {\n                        continue;\n                    }\n                    if (!((pi->x % (comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&\n                            ((trx0 << levelno) % (1 << rpx))))) {\n                        continue;\n                    }\n\n                    if ((res->pw == 0) || (res->ph == 0)) {\n                        continue;\n                    }\n\n                    if ((trx0 == trx1) || (try0 == try1)) {\n                        continue;\n                    }\n\n                    prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx)\n                           - int_floordivpow2(trx0, res->pdx);\n                    prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy)\n                           - int_floordivpow2(try0, res->pdy);\n                    pi->precno = prci + prcj * res->pw;\n                     for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n                         index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                                 pi->step_c + pi->precno * pi->step_p;\n                        /* Avoids index out of bounds access with include*/\n                        if (index >= pi->include_size) {\n                            opj_pi_emit_error(pi, \"Invalid access to pi->include\");\n                            return OPJ_FALSE;\n                        }\n                         if (!pi->include[index]) {\n                             pi->include[index] = 1;\n                             return OPJ_TRUE;\n                        }\nLABEL_SKIP:\n                        ;\n                    }\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143322,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int vmx_update_pi_irte(struct kvm *kvm, unsigned int host_irq,\n\t\t\t      uint32_t guest_irq, bool set)\n{\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tstruct kvm_irq_routing_table *irq_rt;\n \tstruct kvm_lapic_irq irq;\n \tstruct kvm_vcpu *vcpu;\n \tstruct vcpu_data vcpu_info;\n\tint idx, ret = -EINVAL;\n \n \tif (!kvm_arch_has_assigned_device(kvm) ||\n \t\t!irq_remapping_cap(IRQ_POSTING_CAP) ||\n\t\t!kvm_vcpu_apicv_active(kvm->vcpus[0]))\n\t\treturn 0;\n \n \tidx = srcu_read_lock(&kvm->irq_srcu);\n \tirq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);\n\tBUG_ON(guest_irq >= irq_rt->nr_rt_entries);\n \n \thlist_for_each_entry(e, &irq_rt->map[guest_irq], link) {\n \t\tif (e->type != KVM_IRQ_ROUTING_MSI)\n\t\t\tcontinue;\n\t\t/*\n\t\t * VT-d PI cannot support posting multicast/broadcast\n\t\t * interrupts to a vCPU, we still use interrupt remapping\n\t\t * for these kind of interrupts.\n\t\t *\n\t\t * For lowest-priority interrupts, we only support\n\t\t * those with single CPU as the destination, e.g. user\n\t\t * configures the interrupts via /proc/irq or uses\n\t\t * irqbalance to make the interrupts single-CPU.\n\t\t *\n\t\t * We will support full lowest-priority interrupt later.\n\t\t */\n\n\t\tkvm_set_msi_irq(kvm, e, &irq);\n\t\tif (!kvm_intr_is_single_vcpu(kvm, &irq, &vcpu)) {\n\t\t\t/*\n\t\t\t * Make sure the IRTE is in remapped mode if\n\t\t\t * we don't handle it in posted mode.\n\t\t\t */\n\t\t\tret = irq_set_vcpu_affinity(host_irq, NULL);\n\t\t\tif (ret < 0) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t   \"failed to back to remapped mode, irq: %u\\n\",\n\t\t\t\t   host_irq);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tvcpu_info.pi_desc_addr = __pa(vcpu_to_pi_desc(vcpu));\n\t\tvcpu_info.vector = irq.vector;\n\n\t\ttrace_kvm_pi_irte_update(vcpu->vcpu_id, host_irq, e->gsi,\n\t\t\t\tvcpu_info.vector, vcpu_info.pi_desc_addr, set);\n\n\t\tif (set)\n\t\t\tret = irq_set_vcpu_affinity(host_irq, &vcpu_info);\n\t\telse {\n\t\t\t/* suppress notification event before unposting */\n\t\t\tpi_set_sn(vcpu_to_pi_desc(vcpu));\n\t\t\tret = irq_set_vcpu_affinity(host_irq, NULL);\n\t\t\tpi_clear_sn(vcpu_to_pi_desc(vcpu));\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tprintk(KERN_INFO \"%s: failed to update PI IRTE\\n\",\n\t\t\t\t\t__func__);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\nout:\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n\treturn ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143437,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int vmx_update_pi_irte(struct kvm *kvm, unsigned int host_irq,\n\t\t\t      uint32_t guest_irq, bool set)\n{\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tstruct kvm_irq_routing_table *irq_rt;\n \tstruct kvm_lapic_irq irq;\n \tstruct kvm_vcpu *vcpu;\n \tstruct vcpu_data vcpu_info;\n\tint idx, ret = 0;\n \n \tif (!kvm_arch_has_assigned_device(kvm) ||\n \t\t!irq_remapping_cap(IRQ_POSTING_CAP) ||\n\t\t!kvm_vcpu_apicv_active(kvm->vcpus[0]))\n\t\treturn 0;\n \n \tidx = srcu_read_lock(&kvm->irq_srcu);\n \tirq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);\n\tif (guest_irq >= irq_rt->nr_rt_entries ||\n\t    hlist_empty(&irq_rt->map[guest_irq])) {\n\t\tpr_warn_once(\"no route for guest_irq %u/%u (broken user space?)\\n\",\n\t\t\t     guest_irq, irq_rt->nr_rt_entries);\n\t\tgoto out;\n\t}\n \n \thlist_for_each_entry(e, &irq_rt->map[guest_irq], link) {\n \t\tif (e->type != KVM_IRQ_ROUTING_MSI)\n\t\t\tcontinue;\n\t\t/*\n\t\t * VT-d PI cannot support posting multicast/broadcast\n\t\t * interrupts to a vCPU, we still use interrupt remapping\n\t\t * for these kind of interrupts.\n\t\t *\n\t\t * For lowest-priority interrupts, we only support\n\t\t * those with single CPU as the destination, e.g. user\n\t\t * configures the interrupts via /proc/irq or uses\n\t\t * irqbalance to make the interrupts single-CPU.\n\t\t *\n\t\t * We will support full lowest-priority interrupt later.\n\t\t */\n\n\t\tkvm_set_msi_irq(kvm, e, &irq);\n\t\tif (!kvm_intr_is_single_vcpu(kvm, &irq, &vcpu)) {\n\t\t\t/*\n\t\t\t * Make sure the IRTE is in remapped mode if\n\t\t\t * we don't handle it in posted mode.\n\t\t\t */\n\t\t\tret = irq_set_vcpu_affinity(host_irq, NULL);\n\t\t\tif (ret < 0) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t   \"failed to back to remapped mode, irq: %u\\n\",\n\t\t\t\t   host_irq);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tvcpu_info.pi_desc_addr = __pa(vcpu_to_pi_desc(vcpu));\n\t\tvcpu_info.vector = irq.vector;\n\n\t\ttrace_kvm_pi_irte_update(vcpu->vcpu_id, host_irq, e->gsi,\n\t\t\t\tvcpu_info.vector, vcpu_info.pi_desc_addr, set);\n\n\t\tif (set)\n\t\t\tret = irq_set_vcpu_affinity(host_irq, &vcpu_info);\n\t\telse {\n\t\t\t/* suppress notification event before unposting */\n\t\t\tpi_set_sn(vcpu_to_pi_desc(vcpu));\n\t\t\tret = irq_set_vcpu_affinity(host_irq, NULL);\n\t\t\tpi_clear_sn(vcpu_to_pi_desc(vcpu));\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tprintk(KERN_INFO \"%s: failed to update PI IRTE\\n\",\n\t\t\t\t\t__func__);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\nout:\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143438,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void cmdloop(void)\n{\n    int c;\n    int usinguid, havepartition, havenamespace, recursive;\n    static struct buf tag, cmd, arg1, arg2, arg3;\n    char *p, shut[MAX_MAILBOX_PATH+1], cmdname[100];\n    const char *err;\n    const char * commandmintimer;\n    double commandmintimerd = 0.0;\n    struct sync_reserve_list *reserve_list =\n        sync_reserve_list_create(SYNC_MESSAGE_LIST_HASH_SIZE);\n    struct applepushserviceargs applepushserviceargs;\n\n    prot_printf(imapd_out, \"* OK [CAPABILITY \");\n    capa_response(CAPA_PREAUTH);\n    prot_printf(imapd_out, \"]\");\n    if (config_serverinfo) prot_printf(imapd_out, \" %s\", config_servername);\n    if (config_serverinfo == IMAP_ENUM_SERVERINFO_ON) {\n        prot_printf(imapd_out, \" Cyrus IMAP %s\", cyrus_version());\n    }\n    prot_printf(imapd_out, \" server ready\\r\\n\");\n\n    /* clear cancelled flag if present before the next command */\n    cmd_cancelled();\n\n    motd_file();\n\n    /* Get command timer logging paramater. This string\n     * is a time in seconds. Any command that takes >=\n     * this time to execute is logged */\n    commandmintimer = config_getstring(IMAPOPT_COMMANDMINTIMER);\n    cmdtime_settimer(commandmintimer ? 1 : 0);\n    if (commandmintimer) {\n      commandmintimerd = atof(commandmintimer);\n    }\n\n    for (;;) {\n        /* Release any held index */\n        index_release(imapd_index);\n\n        /* Flush any buffered output */\n        prot_flush(imapd_out);\n        if (backend_current) prot_flush(backend_current->out);\n\n        /* command no longer running */\n        proc_register(config_ident, imapd_clienthost, imapd_userid, index_mboxname(imapd_index), NULL);\n\n        /* Check for shutdown file */\n        if ( !imapd_userisadmin && imapd_userid &&\n             (shutdown_file(shut, sizeof(shut)) ||\n              userdeny(imapd_userid, config_ident, shut, sizeof(shut)))) {\n            for (p = shut; *p == '['; p++); /* can't have [ be first char */\n            prot_printf(imapd_out, \"* BYE [ALERT] %s\\r\\n\", p);\n            telemetry_rusage(imapd_userid);\n            shut_down(0);\n        }\n\n        signals_poll();\n\n        if (!proxy_check_input(protin, imapd_in, imapd_out,\n                               backend_current ? backend_current->in : NULL,\n                               NULL, 0)) {\n            /* No input from client */\n            continue;\n        }\n\n        /* Parse tag */\n        c = getword(imapd_in, &tag);\n        if (c == EOF) {\n            if ((err = prot_error(imapd_in))!=NULL\n                && strcmp(err, PROT_EOF_STRING)) {\n                syslog(LOG_WARNING, \"%s, closing connection\", err);\n                prot_printf(imapd_out, \"* BYE %s\\r\\n\", err);\n            }\n            goto done;\n        }\n        if (c != ' ' || !imparse_isatom(tag.s) || (tag.s[0] == '*' && !tag.s[1])) {\n            prot_printf(imapd_out, \"* BAD Invalid tag\\r\\n\");\n            eatline(imapd_in, c);\n            continue;\n        }\n\n        /* Parse command name */\n        c = getword(imapd_in, &cmd);\n        if (!cmd.s[0]) {\n            prot_printf(imapd_out, \"%s BAD Null command\\r\\n\", tag.s);\n            eatline(imapd_in, c);\n            continue;\n        }\n        lcase(cmd.s);\n        xstrncpy(cmdname, cmd.s, 99);\n        cmd.s[0] = toupper((unsigned char) cmd.s[0]);\n\n        if (config_getswitch(IMAPOPT_CHATTY))\n            syslog(LOG_NOTICE, \"command: %s %s\", tag.s, cmd.s);\n\n        proc_register(config_ident, imapd_clienthost, imapd_userid, index_mboxname(imapd_index), cmd.s);\n\n        /* if we need to force a kick, do so */\n        if (referral_kick) {\n            kick_mupdate();\n            referral_kick = 0;\n        }\n\n        if (plaintextloginalert) {\n            prot_printf(imapd_out, \"* OK [ALERT] %s\\r\\n\",\n                        plaintextloginalert);\n            plaintextloginalert = NULL;\n        }\n\n        /* Only Authenticate/Enable/Login/Logout/Noop/Capability/Id/Starttls\n           allowed when not logged in */\n        if (!imapd_userid && !strchr(\"AELNCIS\", cmd.s[0])) goto nologin;\n\n        /* Start command timer */\n        cmdtime_starttimer();\n\n        /* note that about half the commands (the common ones that don't\n           hit the mailboxes file) now close the mailboxes file just in\n           case it was open. */\n        switch (cmd.s[0]) {\n        case 'A':\n            if (!strcmp(cmd.s, \"Authenticate\")) {\n                int haveinitresp = 0;\n\n                if (c != ' ') goto missingargs;\n                c = getword(imapd_in, &arg1);\n                if (!imparse_isatom(arg1.s)) {\n                    prot_printf(imapd_out, \"%s BAD Invalid authenticate mechanism\\r\\n\", tag.s);\n                    eatline(imapd_in, c);\n                    continue;\n                }\n                if (c == ' ') {\n                    haveinitresp = 1;\n                    c = getword(imapd_in, &arg2);\n                    if (c == EOF) goto missingargs;\n                }\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                if (imapd_userid) {\n                    prot_printf(imapd_out, \"%s BAD Already authenticated\\r\\n\", tag.s);\n                    continue;\n                }\n                cmd_authenticate(tag.s, arg1.s, haveinitresp ? arg2.s : NULL);\n\n                snmp_increment(AUTHENTICATE_COUNT, 1);\n            }\n            else if (!imapd_userid) goto nologin;\n            else if (!strcmp(cmd.s, \"Append\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n\n                cmd_append(tag.s, arg1.s, NULL);\n\n                snmp_increment(APPEND_COUNT, 1);\n            }\n            else goto badcmd;\n            break;\n\n        case 'C':\n            if (!strcmp(cmd.s, \"Capability\")) {\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_capability(tag.s);\n\n                snmp_increment(CAPABILITY_COUNT, 1);\n            }\n            else if (!imapd_userid) goto nologin;\n#ifdef HAVE_ZLIB\n            else if (!strcmp(cmd.s, \"Compress\")) {\n                if (c != ' ') goto missingargs;\n                c = getword(imapd_in, &arg1);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                cmd_compress(tag.s, arg1.s);\n\n                snmp_increment(COMPRESS_COUNT, 1);\n            }\n#endif /* HAVE_ZLIB */\n            else if (!strcmp(cmd.s, \"Check\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                cmd_noop(tag.s, cmd.s);\n\n                snmp_increment(CHECK_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Copy\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                usinguid = 0;\n                if (c != ' ') goto missingargs;\n            copy:\n                c = getword(imapd_in, &arg1);\n                if (c == '\\r') goto missingargs;\n                if (c != ' ' || !imparse_issequence(arg1.s)) goto badsequence;\n                c = getastring(imapd_in, imapd_out, &arg2);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                cmd_copy(tag.s, arg1.s, arg2.s, usinguid, /*ismove*/0);\n\n                snmp_increment(COPY_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Create\")) {\n                struct dlist *extargs = NULL;\n\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                if (c == ' ') {\n                    c = parsecreateargs(&extargs);\n                    if (c == EOF) goto badpartition;\n                }\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_create(tag.s, arg1.s, extargs, 0);\n                dlist_free(&extargs);\n\n                snmp_increment(CREATE_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Close\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                cmd_close(tag.s, cmd.s);\n\n                snmp_increment(CLOSE_COUNT, 1);\n            }\n            else goto badcmd;\n            break;\n\n        case 'D':\n            if (!strcmp(cmd.s, \"Delete\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_delete(tag.s, arg1.s, 0, 0);\n\n                snmp_increment(DELETE_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Deleteacl\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg2);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_setacl(tag.s, arg1.s, arg2.s, NULL);\n\n                snmp_increment(DELETEACL_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Dump\")) {\n                int uid_start = 0;\n\n                if(c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if(c == ' ') {\n                    c = getastring(imapd_in, imapd_out, &arg2);\n                    if(!imparse_isnumber(arg2.s)) goto extraargs;\n                    uid_start = atoi(arg2.s);\n                }\n\n                if(c == '\\r') c = prot_getc(imapd_in);\n                if(c != '\\n') goto extraargs;\n\n                cmd_dump(tag.s, arg1.s, uid_start);\n            /*  snmp_increment(DUMP_COUNT, 1);*/\n            }\n            else goto badcmd;\n            break;\n\n        case 'E':\n            if (!imapd_userid) goto nologin;\n            else if (!strcmp(cmd.s, \"Enable\")) {\n                if (c != ' ') goto missingargs;\n\n                cmd_enable(tag.s);\n            }\n            else if (!strcmp(cmd.s, \"Expunge\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                cmd_expunge(tag.s, 0);\n\n                snmp_increment(EXPUNGE_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Examine\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                prot_ungetc(c, imapd_in);\n\n                cmd_select(tag.s, cmd.s, arg1.s);\n\n                snmp_increment(EXAMINE_COUNT, 1);\n            }\n            else goto badcmd;\n            break;\n\n        case 'F':\n            if (!strcmp(cmd.s, \"Fetch\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                usinguid = 0;\n                if (c != ' ') goto missingargs;\n            fetch:\n                c = getword(imapd_in, &arg1);\n                if (c == '\\r') goto missingargs;\n                if (c != ' ' || !imparse_issequence(arg1.s)) goto badsequence;\n\n                cmd_fetch(tag.s, arg1.s, usinguid);\n\n                snmp_increment(FETCH_COUNT, 1);\n            }\n            else goto badcmd;\n            break;\n\n        case 'G':\n            if (!strcmp(cmd.s, \"Getacl\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_getacl(tag.s, arg1.s);\n\n                snmp_increment(GETACL_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Getannotation\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n\n                cmd_getannotation(tag.s, arg1.s);\n\n                snmp_increment(GETANNOTATION_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Getmetadata\")) {\n                if (c != ' ') goto missingargs;\n\n                cmd_getmetadata(tag.s);\n\n                snmp_increment(GETANNOTATION_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Getquota\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_getquota(tag.s, arg1.s);\n\n                snmp_increment(GETQUOTA_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Getquotaroot\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_getquotaroot(tag.s, arg1.s);\n\n                snmp_increment(GETQUOTAROOT_COUNT, 1);\n            }\n#ifdef HAVE_SSL\n            else if (!strcmp(cmd.s, \"Genurlauth\")) {\n                if (c != ' ') goto missingargs;\n\n                cmd_genurlauth(tag.s);\n            /*  snmp_increment(GENURLAUTH_COUNT, 1);*/\n            }\n#endif\n            else goto badcmd;\n            break;\n\n        case 'I':\n            if (!strcmp(cmd.s, \"Id\")) {\n                if (c != ' ') goto missingargs;\n                cmd_id(tag.s);\n\n                snmp_increment(ID_COUNT, 1);\n            }\n            else if (!imapd_userid) goto nologin;\n            else if (!strcmp(cmd.s, \"Idle\") && idle_enabled()) {\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_idle(tag.s);\n\n                snmp_increment(IDLE_COUNT, 1);\n            }\n            else goto badcmd;\n            break;\n\n        case 'L':\n            if (!strcmp(cmd.s, \"Login\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if(c != ' ') goto missingargs;\n\n                cmd_login(tag.s, arg1.s);\n\n                snmp_increment(LOGIN_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Logout\")) {\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                snmp_increment(LOGOUT_COUNT, 1);\n\n                /* force any responses from our selected backend */\n                if (backend_current) imapd_check(NULL, 0);\n\n                prot_printf(imapd_out, \"* BYE %s\\r\\n\",\n                            error_message(IMAP_BYE_LOGOUT));\n                prot_printf(imapd_out, \"%s OK %s\\r\\n\", tag.s,\n                            error_message(IMAP_OK_COMPLETED));\n\n                if (imapd_userid && *imapd_userid) {\n                    telemetry_rusage(imapd_userid);\n                }\n\n                goto done;\n            }\n            else if (!imapd_userid) goto nologin;\n            else if (!strcmp(cmd.s, \"List\")) {\n                struct listargs listargs;\n\n                if (c != ' ') goto missingargs;\n\n                memset(&listargs, 0, sizeof(struct listargs));\n                listargs.ret = LIST_RET_CHILDREN;\n                getlistargs(tag.s, &listargs);\n                if (listargs.pat.count) cmd_list(tag.s, &listargs);\n\n                snmp_increment(LIST_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Lsub\")) {\n                struct listargs listargs;\n\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg2);\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                memset(&listargs, 0, sizeof(struct listargs));\n                listargs.cmd = LIST_CMD_LSUB;\n                listargs.sel = LIST_SEL_SUBSCRIBED;\n                if (!strcasecmpsafe(imapd_magicplus, \"+dav\"))\n                    listargs.sel |= LIST_SEL_DAV;\n                listargs.ref = arg1.s;\n                strarray_append(&listargs.pat, arg2.s);\n\n                cmd_list(tag.s, &listargs);\n\n                snmp_increment(LSUB_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Listrights\")) {\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg2);\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_listrights(tag.s, arg1.s, arg2.s);\n\n                snmp_increment(LISTRIGHTS_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Localappend\")) {\n                /* create a local-only mailbox */\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg2);\n                if (c != ' ') goto missingargs;\n\n                cmd_append(tag.s, arg1.s, *arg2.s ? arg2.s : NULL);\n\n                snmp_increment(APPEND_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Localcreate\")) {\n                /* create a local-only mailbox */\n                struct dlist *extargs = NULL;\n\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                if (c == ' ') {\n                    c = parsecreateargs(&extargs);\n                    if (c == EOF) goto badpartition;\n                }\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_create(tag.s, arg1.s, extargs, 1);\n                dlist_free(&extargs);\n\n                /* xxxx snmp_increment(CREATE_COUNT, 1); */\n            }\n            else if (!strcmp(cmd.s, \"Localdelete\")) {\n                /* delete a mailbox locally only */\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_delete(tag.s, arg1.s, 1, 1);\n\n                /* xxxx snmp_increment(DELETE_COUNT, 1); */\n            }\n            else goto badcmd;\n            break;\n\n        case 'M':\n            if (!strcmp(cmd.s, \"Myrights\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_myrights(tag.s, arg1.s);\n\n                /* xxxx snmp_increment(MYRIGHTS_COUNT, 1); */\n            }\n            else if (!strcmp(cmd.s, \"Mupdatepush\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if(c == EOF) goto missingargs;\n                if(c == '\\r') c = prot_getc(imapd_in);\n                if(c != '\\n') goto extraargs;\n                cmd_mupdatepush(tag.s, arg1.s);\n\n                /* xxxx snmp_increment(MUPDATEPUSH_COUNT, 1); */\n            }\n            else if (!strcmp(cmd.s, \"Move\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                usinguid = 0;\n                if (c != ' ') goto missingargs;\n            move:\n                c = getword(imapd_in, &arg1);\n                if (c == '\\r') goto missingargs;\n                if (c != ' ' || !imparse_issequence(arg1.s)) goto badsequence;\n                c = getastring(imapd_in, imapd_out, &arg2);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                cmd_copy(tag.s, arg1.s, arg2.s, usinguid, /*ismove*/1);\n\n                snmp_increment(COPY_COUNT, 1);\n            } else goto badcmd;\n            break;\n\n        case 'N':\n            if (!strcmp(cmd.s, \"Noop\")) {\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                cmd_noop(tag.s, cmd.s);\n\n                /* xxxx snmp_increment(NOOP_COUNT, 1); */\n            }\n            else if (!imapd_userid) goto nologin;\n            else if (!strcmp(cmd.s, \"Namespace\")) {\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_namespace(tag.s);\n\n                /* xxxx snmp_increment(NAMESPACE_COUNT, 1); */\n            }\n            else goto badcmd;\n            break;\n\n        case 'R':\n            if (!strcmp(cmd.s, \"Rename\")) {\n                havepartition = 0;\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg2);\n                if (c == EOF) goto missingargs;\n                if (c == ' ') {\n                    havepartition = 1;\n                    c = getword(imapd_in, &arg3);\n                    if (!imparse_isatom(arg3.s)) goto badpartition;\n                }\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_rename(tag.s, arg1.s, arg2.s, havepartition ? arg3.s : 0);\n\n                /* xxxx snmp_increment(RENAME_COUNT, 1); */\n            } else if(!strcmp(cmd.s, \"Reconstruct\")) {\n                recursive = 0;\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if(c == ' ') {\n                    /* Optional RECURSEIVE argument */\n                    c = getword(imapd_in, &arg2);\n                    if(!imparse_isatom(arg2.s))\n                        goto extraargs;\n                    else if(!strcasecmp(arg2.s, \"RECURSIVE\"))\n                        recursive = 1;\n                    else\n                        goto extraargs;\n                }\n                if(c == '\\r') c = prot_getc(imapd_in);\n                if(c != '\\n') goto extraargs;\n                cmd_reconstruct(tag.s, arg1.s, recursive);\n\n                /* snmp_increment(RECONSTRUCT_COUNT, 1); */\n            }\n            else if (!strcmp(cmd.s, \"Rlist\")) {\n                struct listargs listargs;\n\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg2);\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                memset(&listargs, 0, sizeof(struct listargs));\n                listargs.sel = LIST_SEL_REMOTE;\n                listargs.ret = LIST_RET_CHILDREN;\n                listargs.ref = arg1.s;\n                strarray_append(&listargs.pat, arg2.s);\n\n                cmd_list(tag.s, &listargs);\n\n/*              snmp_increment(LIST_COUNT, 1); */\n            }\n            else if (!strcmp(cmd.s, \"Rlsub\")) {\n                struct listargs listargs;\n\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg2);\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                memset(&listargs, 0, sizeof(struct listargs));\n                listargs.cmd = LIST_CMD_LSUB;\n                listargs.sel = LIST_SEL_REMOTE | LIST_SEL_SUBSCRIBED;\n                listargs.ref = arg1.s;\n                strarray_append(&listargs.pat, arg2.s);\n\n                cmd_list(tag.s, &listargs);\n\n/*              snmp_increment(LSUB_COUNT, 1); */\n            }\n#ifdef HAVE_SSL\n            else if (!strcmp(cmd.s, \"Resetkey\")) {\n                int have_mbox = 0, have_mech = 0;\n\n                if (c == ' ') {\n                    have_mbox = 1;\n                    c = getastring(imapd_in, imapd_out, &arg1);\n                    if (c == EOF) goto missingargs;\n                    if (c == ' ') {\n                        have_mech = 1;\n                        c = getword(imapd_in, &arg2);\n                    }\n                }\n\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_resetkey(tag.s, have_mbox ? arg1.s : 0,\n                             have_mech ? arg2.s : 0);\n            /*  snmp_increment(RESETKEY_COUNT, 1);*/\n            }\n#endif\n            else goto badcmd;\n            break;\n\n        case 'S':\n            if (!strcmp(cmd.s, \"Starttls\")) {\n                if (!tls_enabled()) {\n                    /* we don't support starttls */\n                    goto badcmd;\n                }\n\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                /* XXX  discard any input pipelined after STARTTLS */\n                prot_flush(imapd_in);\n\n                /* if we've already done SASL fail */\n                if (imapd_userid != NULL) {\n                    prot_printf(imapd_out,\n               \"%s BAD Can't Starttls after authentication\\r\\n\", tag.s);\n                    continue;\n                }\n\n                /* if we've already done COMPRESS fail */\n                if (imapd_compress_done == 1) {\n                    prot_printf(imapd_out,\n               \"%s BAD Can't Starttls after Compress\\r\\n\", tag.s);\n                    continue;\n                }\n\n                /* check if already did a successful tls */\n                if (imapd_starttls_done == 1) {\n                    prot_printf(imapd_out,\n                                \"%s BAD Already did a successful Starttls\\r\\n\",\n                                tag.s);\n                    continue;\n                }\n                cmd_starttls(tag.s, 0);\n\n                snmp_increment(STARTTLS_COUNT, 1);\n                continue;\n            }\n            if (!imapd_userid) {\n                goto nologin;\n            } else if (!strcmp(cmd.s, \"Store\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                usinguid = 0;\n                if (c != ' ') goto missingargs;\n            store:\n                c = getword(imapd_in, &arg1);\n                if (c != ' ' || !imparse_issequence(arg1.s)) goto badsequence;\n\n                cmd_store(tag.s, arg1.s, usinguid);\n\n                snmp_increment(STORE_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Select\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                prot_ungetc(c, imapd_in);\n\n                cmd_select(tag.s, cmd.s, arg1.s);\n\n                snmp_increment(SELECT_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Search\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                usinguid = 0;\n                if (c != ' ') goto missingargs;\n            search:\n\n                cmd_search(tag.s, usinguid);\n\n                snmp_increment(SEARCH_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Subscribe\")) {\n                if (c != ' ') goto missingargs;\n                havenamespace = 0;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == ' ') {\n                    havenamespace = 1;\n                    c = getastring(imapd_in, imapd_out, &arg2);\n                }\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                if (havenamespace) {\n                    cmd_changesub(tag.s, arg1.s, arg2.s, 1);\n                }\n                else {\n                    cmd_changesub(tag.s, (char *)0, arg1.s, 1);\n                }\n                snmp_increment(SUBSCRIBE_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Setacl\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg2);\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg3);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_setacl(tag.s, arg1.s, arg2.s, arg3.s);\n\n                snmp_increment(SETACL_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Setannotation\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n\n                cmd_setannotation(tag.s, arg1.s);\n\n                snmp_increment(SETANNOTATION_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Setmetadata\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n\n                cmd_setmetadata(tag.s, arg1.s);\n\n                snmp_increment(SETANNOTATION_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Setquota\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n                cmd_setquota(tag.s, arg1.s);\n\n                snmp_increment(SETQUOTA_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Sort\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                usinguid = 0;\n                if (c != ' ') goto missingargs;\n            sort:\n                cmd_sort(tag.s, usinguid);\n\n                snmp_increment(SORT_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Status\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n                cmd_status(tag.s, arg1.s);\n\n                snmp_increment(STATUS_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Scan\")) {\n                struct listargs listargs;\n\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg2);\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg3);\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                memset(&listargs, 0, sizeof(struct listargs));\n                listargs.ref = arg1.s;\n                strarray_append(&listargs.pat, arg2.s);\n                listargs.scan = arg3.s;\n\n                cmd_list(tag.s, &listargs);\n\n                 snmp_increment(SCAN_COUNT, 1);\n             }\n             else if (!strcmp(cmd.s, \"Syncapply\")) {\n                 struct dlist *kl = sync_parseline(imapd_in);\n \n                 if (kl) {\n                    cmd_syncapply(tag.s, kl, reserve_list);\n                    dlist_free(&kl);\n                }\n                 else goto extraargs;\n             }\n             else if (!strcmp(cmd.s, \"Syncget\")) {\n                 struct dlist *kl = sync_parseline(imapd_in);\n \n                 if (kl) {\n                    cmd_syncget(tag.s, kl);\n                    dlist_free(&kl);\n                }\n                 else goto extraargs;\n             }\n             else if (!strcmp(cmd.s, \"Syncrestart\")) {\n                 if (c == '\\r') c = prot_getc(imapd_in);\n                 if (c != '\\n') goto extraargs;\n \n                 /* just clear the GUID cache */\n                 cmd_syncrestart(tag.s, &reserve_list, 1);\n             }\n             else if (!strcmp(cmd.s, \"Syncrestore\")) {\n                 struct dlist *kl = sync_parseline(imapd_in);\n \n                 if (kl) {\n                    cmd_syncrestore(tag.s, kl, reserve_list);\n                    dlist_free(&kl);\n                }\n                else goto extraargs;\n            }\n            else goto badcmd;\n            break;\n\n        case 'T':\n            if (!strcmp(cmd.s, \"Thread\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                usinguid = 0;\n                if (c != ' ') goto missingargs;\n            thread:\n                cmd_thread(tag.s, usinguid);\n\n                snmp_increment(THREAD_COUNT, 1);\n            }\n            else goto badcmd;\n            break;\n\n        case 'U':\n            if (!strcmp(cmd.s, \"Uid\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                usinguid = 1;\n                if (c != ' ') goto missingargs;\n                c = getword(imapd_in, &arg1);\n                if (c != ' ') goto missingargs;\n                lcase(arg1.s);\n                xstrncpy(cmdname, arg1.s, 99);\n                if (!strcmp(arg1.s, \"fetch\")) {\n                    goto fetch;\n                }\n                else if (!strcmp(arg1.s, \"store\")) {\n                    goto store;\n                }\n                else if (!strcmp(arg1.s, \"search\")) {\n                    goto search;\n                }\n                else if (!strcmp(arg1.s, \"sort\")) {\n                    goto sort;\n                }\n                else if (!strcmp(arg1.s, \"thread\")) {\n                    goto thread;\n                }\n                else if (!strcmp(arg1.s, \"copy\")) {\n                    goto copy;\n                }\n                else if (!strcmp(arg1.s, \"move\")) {\n                    goto move;\n                }\n                else if (!strcmp(arg1.s, \"xmove\")) {\n                    goto move;\n                }\n                else if (!strcmp(arg1.s, \"expunge\")) {\n                    c = getword(imapd_in, &arg1);\n                    if (!imparse_issequence(arg1.s)) goto badsequence;\n                    if (c == '\\r') c = prot_getc(imapd_in);\n                    if (c != '\\n') goto extraargs;\n                    cmd_expunge(tag.s, arg1.s);\n\n                    snmp_increment(EXPUNGE_COUNT, 1);\n                }\n                else if (!strcmp(arg1.s, \"xrunannotator\")) {\n                    goto xrunannotator;\n                }\n                else {\n                    prot_printf(imapd_out, \"%s BAD Unrecognized UID subcommand\\r\\n\", tag.s);\n                    eatline(imapd_in, c);\n                }\n            }\n            else if (!strcmp(cmd.s, \"Unsubscribe\")) {\n                if (c != ' ') goto missingargs;\n                havenamespace = 0;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == ' ') {\n                    havenamespace = 1;\n                    c = getastring(imapd_in, imapd_out, &arg2);\n                }\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                if (havenamespace) {\n                    cmd_changesub(tag.s, arg1.s, arg2.s, 0);\n                }\n                else {\n                    cmd_changesub(tag.s, (char *)0, arg1.s, 0);\n                }\n\n                snmp_increment(UNSUBSCRIBE_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Unselect\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                cmd_close(tag.s, cmd.s);\n\n                snmp_increment(UNSELECT_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Undump\")) {\n                if(c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n\n                /* we want to get a list at this point */\n                if(c != ' ') goto missingargs;\n\n                cmd_undump(tag.s, arg1.s);\n            /*  snmp_increment(UNDUMP_COUNT, 1);*/\n            }\n#ifdef HAVE_SSL\n            else if (!strcmp(cmd.s, \"Urlfetch\")) {\n                if (c != ' ') goto missingargs;\n\n                cmd_urlfetch(tag.s);\n            /*  snmp_increment(URLFETCH_COUNT, 1);*/\n            }\n#endif\n            else goto badcmd;\n            break;\n\n        case 'X':\n            if (!strcmp(cmd.s, \"Xbackup\")) {\n                int havechannel = 0;\n\n                if (!config_getswitch(IMAPOPT_XBACKUP_ENABLED))\n                    goto badcmd;\n\n                /* user */\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n\n                /* channel */\n                if (c == ' ') {\n                    havechannel = 1;\n                    c = getword(imapd_in, &arg2);\n                    if (c == EOF) goto missingargs;\n                }\n\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                cmd_xbackup(tag.s, arg1.s, havechannel ? arg2.s : NULL);\n\n            }\n            else if (!strcmp(cmd.s, \"Xconvfetch\")) {\n                cmd_xconvfetch(tag.s);\n\n            }\n            else if (!strcmp(cmd.s, \"Xconvmultisort\")) {\n                if (c != ' ') goto missingargs;\n                if (!imapd_index && !backend_current) goto nomailbox;\n                cmd_xconvmultisort(tag.s);\n\n            }\n            else if (!strcmp(cmd.s, \"Xconvsort\")) {\n                if (c != ' ') goto missingargs;\n                if (!imapd_index && !backend_current) goto nomailbox;\n                cmd_xconvsort(tag.s, 0);\n\n            }\n            else if (!strcmp(cmd.s, \"Xconvupdates\")) {\n                if (c != ' ') goto missingargs;\n                if (!imapd_index && !backend_current) goto nomailbox;\n                cmd_xconvsort(tag.s, 1);\n\n            }\n            else if (!strcmp(cmd.s, \"Xfer\")) {\n                int havepartition = 0;\n\n                /* Mailbox */\n                if(c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n\n                /* Dest Server */\n                if(c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg2);\n\n                if(c == ' ') {\n                    /* Dest Partition */\n                    c = getastring(imapd_in, imapd_out, &arg3);\n                    if (!imparse_isatom(arg3.s)) goto badpartition;\n                    havepartition = 1;\n                }\n\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                cmd_xfer(tag.s, arg1.s, arg2.s,\n                         (havepartition ? arg3.s : NULL));\n            /*  snmp_increment(XFER_COUNT, 1);*/\n            }\n            else if (!strcmp(cmd.s, \"Xconvmeta\")) {\n                cmd_xconvmeta(tag.s);\n            }\n            else if (!strcmp(cmd.s, \"Xlist\")) {\n                struct listargs listargs;\n\n                if (c != ' ') goto missingargs;\n\n                memset(&listargs, 0, sizeof(struct listargs));\n                listargs.cmd = LIST_CMD_XLIST;\n                listargs.ret = LIST_RET_CHILDREN | LIST_RET_SPECIALUSE;\n                getlistargs(tag.s, &listargs);\n                if (listargs.pat.count) cmd_list(tag.s, &listargs);\n\n                snmp_increment(LIST_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Xmove\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                usinguid = 0;\n                if (c != ' ') goto missingargs;\n                goto move;\n            }\n            else if (!strcmp(cmd.s, \"Xrunannotator\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                usinguid = 0;\n                if (c != ' ') goto missingargs;\n            xrunannotator:\n                c = getword(imapd_in, &arg1);\n                if (!arg1.len || !imparse_issequence(arg1.s)) goto badsequence;\n                cmd_xrunannotator(tag.s, arg1.s, usinguid);\n            }\n            else if (!strcmp(cmd.s, \"Xsnippets\")) {\n                if (c != ' ') goto missingargs;\n                if (!imapd_index && !backend_current) goto nomailbox;\n                cmd_xsnippets(tag.s);\n\n            }\n            else if (!strcmp(cmd.s, \"Xstats\")) {\n                cmd_xstats(tag.s, c);\n            }\n            else if (!strcmp(cmd.s, \"Xwarmup\")) {\n                /* XWARMUP doesn't need a mailbox to be selected */\n                if (c != ' ') goto missingargs;\n                cmd_xwarmup(tag.s);\n            }\n            else if (!strcmp(cmd.s, \"Xkillmy\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_xkillmy(tag.s, arg1.s);\n            }\n            else if (!strcmp(cmd.s, \"Xforever\")) {\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_xforever(tag.s);\n            }\n            else if (!strcmp(cmd.s, \"Xmeid\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_xmeid(tag.s, arg1.s);\n            }\n\n            else if (apns_enabled && !strcmp(cmd.s, \"Xapplepushservice\")) {\n                if (c != ' ') goto missingargs;\n\n                memset(&applepushserviceargs, 0, sizeof(struct applepushserviceargs));\n\n                do {\n                    c = getastring(imapd_in, imapd_out, &arg1);\n                    if (c == EOF) goto aps_missingargs;\n\n                    if (!strcmp(arg1.s, \"mailboxes\")) {\n                        c = prot_getc(imapd_in);\n                        if (c != '(')\n                            goto aps_missingargs;\n\n                        c = prot_getc(imapd_in);\n                        if (c != ')') {\n                            prot_ungetc(c, imapd_in);\n                            do {\n                                c = getastring(imapd_in, imapd_out, &arg2);\n                                if (c == EOF) break;\n                                strarray_push(&applepushserviceargs.mailboxes, arg2.s);\n                            } while (c == ' ');\n                        }\n\n                        if (c != ')')\n                            goto aps_missingargs;\n                        c = prot_getc(imapd_in);\n                    }\n\n                    else {\n                        c = getastring(imapd_in, imapd_out, &arg2);\n\n                        if (!strcmp(arg1.s, \"aps-version\")) {\n                            if (!imparse_isnumber(arg2.s)) goto aps_extraargs;\n                            applepushserviceargs.aps_version = atoi(arg2.s);\n                        }\n                        else if (!strcmp(arg1.s, \"aps-account-id\"))\n                            buf_copy(&applepushserviceargs.aps_account_id, &arg2);\n                        else if (!strcmp(arg1.s, \"aps-device-token\"))\n                            buf_copy(&applepushserviceargs.aps_device_token, &arg2);\n                        else if (!strcmp(arg1.s, \"aps-subtopic\"))\n                            buf_copy(&applepushserviceargs.aps_subtopic, &arg2);\n                        else\n                            goto aps_extraargs;\n                    }\n                } while (c == ' ');\n\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto aps_extraargs;\n\n                cmd_xapplepushservice(tag.s, &applepushserviceargs);\n            }\n\n            else goto badcmd;\n            break;\n\n        default:\n        badcmd:\n            prot_printf(imapd_out, \"%s BAD Unrecognized command\\r\\n\", tag.s);\n            eatline(imapd_in, c);\n        }\n\n        /* End command timer - don't log \"idle\" commands */\n        if (commandmintimer && strcmp(\"idle\", cmdname)) {\n            double cmdtime, nettime;\n            const char *mboxname = index_mboxname(imapd_index);\n            if (!mboxname) mboxname = \"<none>\";\n            cmdtime_endtimer(&cmdtime, &nettime);\n            if (cmdtime >= commandmintimerd) {\n                syslog(LOG_NOTICE, \"cmdtimer: '%s' '%s' '%s' '%f' '%f' '%f'\",\n                    imapd_userid ? imapd_userid : \"<none>\", cmdname, mboxname,\n                    cmdtime, nettime, cmdtime + nettime);\n            }\n        }\n        continue;\n\n    nologin:\n        prot_printf(imapd_out, \"%s BAD Please login first\\r\\n\", tag.s);\n        eatline(imapd_in, c);\n        continue;\n\n    nomailbox:\n        prot_printf(imapd_out,\n                    \"%s BAD Please select a mailbox first\\r\\n\", tag.s);\n        eatline(imapd_in, c);\n        continue;\n\n    aps_missingargs:\n        buf_free(&applepushserviceargs.aps_account_id);\n        buf_free(&applepushserviceargs.aps_device_token);\n        buf_free(&applepushserviceargs.aps_subtopic);\n        strarray_fini(&applepushserviceargs.mailboxes);\n\n    missingargs:\n        prot_printf(imapd_out,\n                    \"%s BAD Missing required argument to %s\\r\\n\", tag.s, cmd.s);\n        eatline(imapd_in, c);\n        continue;\n\n    aps_extraargs:\n        buf_free(&applepushserviceargs.aps_account_id);\n        buf_free(&applepushserviceargs.aps_device_token);\n        buf_free(&applepushserviceargs.aps_subtopic);\n        strarray_fini(&applepushserviceargs.mailboxes);\n\n    extraargs:\n        prot_printf(imapd_out,\n                    \"%s BAD Unexpected extra arguments to %s\\r\\n\", tag.s, cmd.s);\n        eatline(imapd_in, c);\n        continue;\n\n    badsequence:\n        prot_printf(imapd_out,\n                    \"%s BAD Invalid sequence in %s\\r\\n\", tag.s, cmd.s);\n        eatline(imapd_in, c);\n        continue;\n\n    badpartition:\n        prot_printf(imapd_out,\n                    \"%s BAD Invalid partition name in %s\\r\\n\", tag.s, cmd.s);\n        eatline(imapd_in, c);\n        continue;\n    }\n\ndone:\n    cmd_syncrestart(NULL, &reserve_list, 0);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143455,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void cmdloop(void)\n{\n    int c;\n    int usinguid, havepartition, havenamespace, recursive;\n    static struct buf tag, cmd, arg1, arg2, arg3;\n    char *p, shut[MAX_MAILBOX_PATH+1], cmdname[100];\n    const char *err;\n    const char * commandmintimer;\n    double commandmintimerd = 0.0;\n    struct sync_reserve_list *reserve_list =\n        sync_reserve_list_create(SYNC_MESSAGE_LIST_HASH_SIZE);\n    struct applepushserviceargs applepushserviceargs;\n\n    prot_printf(imapd_out, \"* OK [CAPABILITY \");\n    capa_response(CAPA_PREAUTH);\n    prot_printf(imapd_out, \"]\");\n    if (config_serverinfo) prot_printf(imapd_out, \" %s\", config_servername);\n    if (config_serverinfo == IMAP_ENUM_SERVERINFO_ON) {\n        prot_printf(imapd_out, \" Cyrus IMAP %s\", cyrus_version());\n    }\n    prot_printf(imapd_out, \" server ready\\r\\n\");\n\n    /* clear cancelled flag if present before the next command */\n    cmd_cancelled();\n\n    motd_file();\n\n    /* Get command timer logging paramater. This string\n     * is a time in seconds. Any command that takes >=\n     * this time to execute is logged */\n    commandmintimer = config_getstring(IMAPOPT_COMMANDMINTIMER);\n    cmdtime_settimer(commandmintimer ? 1 : 0);\n    if (commandmintimer) {\n      commandmintimerd = atof(commandmintimer);\n    }\n\n    for (;;) {\n        /* Release any held index */\n        index_release(imapd_index);\n\n        /* Flush any buffered output */\n        prot_flush(imapd_out);\n        if (backend_current) prot_flush(backend_current->out);\n\n        /* command no longer running */\n        proc_register(config_ident, imapd_clienthost, imapd_userid, index_mboxname(imapd_index), NULL);\n\n        /* Check for shutdown file */\n        if ( !imapd_userisadmin && imapd_userid &&\n             (shutdown_file(shut, sizeof(shut)) ||\n              userdeny(imapd_userid, config_ident, shut, sizeof(shut)))) {\n            for (p = shut; *p == '['; p++); /* can't have [ be first char */\n            prot_printf(imapd_out, \"* BYE [ALERT] %s\\r\\n\", p);\n            telemetry_rusage(imapd_userid);\n            shut_down(0);\n        }\n\n        signals_poll();\n\n        if (!proxy_check_input(protin, imapd_in, imapd_out,\n                               backend_current ? backend_current->in : NULL,\n                               NULL, 0)) {\n            /* No input from client */\n            continue;\n        }\n\n        /* Parse tag */\n        c = getword(imapd_in, &tag);\n        if (c == EOF) {\n            if ((err = prot_error(imapd_in))!=NULL\n                && strcmp(err, PROT_EOF_STRING)) {\n                syslog(LOG_WARNING, \"%s, closing connection\", err);\n                prot_printf(imapd_out, \"* BYE %s\\r\\n\", err);\n            }\n            goto done;\n        }\n        if (c != ' ' || !imparse_isatom(tag.s) || (tag.s[0] == '*' && !tag.s[1])) {\n            prot_printf(imapd_out, \"* BAD Invalid tag\\r\\n\");\n            eatline(imapd_in, c);\n            continue;\n        }\n\n        /* Parse command name */\n        c = getword(imapd_in, &cmd);\n        if (!cmd.s[0]) {\n            prot_printf(imapd_out, \"%s BAD Null command\\r\\n\", tag.s);\n            eatline(imapd_in, c);\n            continue;\n        }\n        lcase(cmd.s);\n        xstrncpy(cmdname, cmd.s, 99);\n        cmd.s[0] = toupper((unsigned char) cmd.s[0]);\n\n        if (config_getswitch(IMAPOPT_CHATTY))\n            syslog(LOG_NOTICE, \"command: %s %s\", tag.s, cmd.s);\n\n        proc_register(config_ident, imapd_clienthost, imapd_userid, index_mboxname(imapd_index), cmd.s);\n\n        /* if we need to force a kick, do so */\n        if (referral_kick) {\n            kick_mupdate();\n            referral_kick = 0;\n        }\n\n        if (plaintextloginalert) {\n            prot_printf(imapd_out, \"* OK [ALERT] %s\\r\\n\",\n                        plaintextloginalert);\n            plaintextloginalert = NULL;\n        }\n\n        /* Only Authenticate/Enable/Login/Logout/Noop/Capability/Id/Starttls\n           allowed when not logged in */\n        if (!imapd_userid && !strchr(\"AELNCIS\", cmd.s[0])) goto nologin;\n\n        /* Start command timer */\n        cmdtime_starttimer();\n\n        /* note that about half the commands (the common ones that don't\n           hit the mailboxes file) now close the mailboxes file just in\n           case it was open. */\n        switch (cmd.s[0]) {\n        case 'A':\n            if (!strcmp(cmd.s, \"Authenticate\")) {\n                int haveinitresp = 0;\n\n                if (c != ' ') goto missingargs;\n                c = getword(imapd_in, &arg1);\n                if (!imparse_isatom(arg1.s)) {\n                    prot_printf(imapd_out, \"%s BAD Invalid authenticate mechanism\\r\\n\", tag.s);\n                    eatline(imapd_in, c);\n                    continue;\n                }\n                if (c == ' ') {\n                    haveinitresp = 1;\n                    c = getword(imapd_in, &arg2);\n                    if (c == EOF) goto missingargs;\n                }\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                if (imapd_userid) {\n                    prot_printf(imapd_out, \"%s BAD Already authenticated\\r\\n\", tag.s);\n                    continue;\n                }\n                cmd_authenticate(tag.s, arg1.s, haveinitresp ? arg2.s : NULL);\n\n                snmp_increment(AUTHENTICATE_COUNT, 1);\n            }\n            else if (!imapd_userid) goto nologin;\n            else if (!strcmp(cmd.s, \"Append\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n\n                cmd_append(tag.s, arg1.s, NULL);\n\n                snmp_increment(APPEND_COUNT, 1);\n            }\n            else goto badcmd;\n            break;\n\n        case 'C':\n            if (!strcmp(cmd.s, \"Capability\")) {\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_capability(tag.s);\n\n                snmp_increment(CAPABILITY_COUNT, 1);\n            }\n            else if (!imapd_userid) goto nologin;\n#ifdef HAVE_ZLIB\n            else if (!strcmp(cmd.s, \"Compress\")) {\n                if (c != ' ') goto missingargs;\n                c = getword(imapd_in, &arg1);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                cmd_compress(tag.s, arg1.s);\n\n                snmp_increment(COMPRESS_COUNT, 1);\n            }\n#endif /* HAVE_ZLIB */\n            else if (!strcmp(cmd.s, \"Check\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                cmd_noop(tag.s, cmd.s);\n\n                snmp_increment(CHECK_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Copy\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                usinguid = 0;\n                if (c != ' ') goto missingargs;\n            copy:\n                c = getword(imapd_in, &arg1);\n                if (c == '\\r') goto missingargs;\n                if (c != ' ' || !imparse_issequence(arg1.s)) goto badsequence;\n                c = getastring(imapd_in, imapd_out, &arg2);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                cmd_copy(tag.s, arg1.s, arg2.s, usinguid, /*ismove*/0);\n\n                snmp_increment(COPY_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Create\")) {\n                struct dlist *extargs = NULL;\n\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                if (c == ' ') {\n                    c = parsecreateargs(&extargs);\n                    if (c == EOF) goto badpartition;\n                }\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_create(tag.s, arg1.s, extargs, 0);\n                dlist_free(&extargs);\n\n                snmp_increment(CREATE_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Close\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                cmd_close(tag.s, cmd.s);\n\n                snmp_increment(CLOSE_COUNT, 1);\n            }\n            else goto badcmd;\n            break;\n\n        case 'D':\n            if (!strcmp(cmd.s, \"Delete\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_delete(tag.s, arg1.s, 0, 0);\n\n                snmp_increment(DELETE_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Deleteacl\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg2);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_setacl(tag.s, arg1.s, arg2.s, NULL);\n\n                snmp_increment(DELETEACL_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Dump\")) {\n                int uid_start = 0;\n\n                if(c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if(c == ' ') {\n                    c = getastring(imapd_in, imapd_out, &arg2);\n                    if(!imparse_isnumber(arg2.s)) goto extraargs;\n                    uid_start = atoi(arg2.s);\n                }\n\n                if(c == '\\r') c = prot_getc(imapd_in);\n                if(c != '\\n') goto extraargs;\n\n                cmd_dump(tag.s, arg1.s, uid_start);\n            /*  snmp_increment(DUMP_COUNT, 1);*/\n            }\n            else goto badcmd;\n            break;\n\n        case 'E':\n            if (!imapd_userid) goto nologin;\n            else if (!strcmp(cmd.s, \"Enable\")) {\n                if (c != ' ') goto missingargs;\n\n                cmd_enable(tag.s);\n            }\n            else if (!strcmp(cmd.s, \"Expunge\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                cmd_expunge(tag.s, 0);\n\n                snmp_increment(EXPUNGE_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Examine\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                prot_ungetc(c, imapd_in);\n\n                cmd_select(tag.s, cmd.s, arg1.s);\n\n                snmp_increment(EXAMINE_COUNT, 1);\n            }\n            else goto badcmd;\n            break;\n\n        case 'F':\n            if (!strcmp(cmd.s, \"Fetch\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                usinguid = 0;\n                if (c != ' ') goto missingargs;\n            fetch:\n                c = getword(imapd_in, &arg1);\n                if (c == '\\r') goto missingargs;\n                if (c != ' ' || !imparse_issequence(arg1.s)) goto badsequence;\n\n                cmd_fetch(tag.s, arg1.s, usinguid);\n\n                snmp_increment(FETCH_COUNT, 1);\n            }\n            else goto badcmd;\n            break;\n\n        case 'G':\n            if (!strcmp(cmd.s, \"Getacl\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_getacl(tag.s, arg1.s);\n\n                snmp_increment(GETACL_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Getannotation\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n\n                cmd_getannotation(tag.s, arg1.s);\n\n                snmp_increment(GETANNOTATION_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Getmetadata\")) {\n                if (c != ' ') goto missingargs;\n\n                cmd_getmetadata(tag.s);\n\n                snmp_increment(GETANNOTATION_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Getquota\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_getquota(tag.s, arg1.s);\n\n                snmp_increment(GETQUOTA_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Getquotaroot\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_getquotaroot(tag.s, arg1.s);\n\n                snmp_increment(GETQUOTAROOT_COUNT, 1);\n            }\n#ifdef HAVE_SSL\n            else if (!strcmp(cmd.s, \"Genurlauth\")) {\n                if (c != ' ') goto missingargs;\n\n                cmd_genurlauth(tag.s);\n            /*  snmp_increment(GENURLAUTH_COUNT, 1);*/\n            }\n#endif\n            else goto badcmd;\n            break;\n\n        case 'I':\n            if (!strcmp(cmd.s, \"Id\")) {\n                if (c != ' ') goto missingargs;\n                cmd_id(tag.s);\n\n                snmp_increment(ID_COUNT, 1);\n            }\n            else if (!imapd_userid) goto nologin;\n            else if (!strcmp(cmd.s, \"Idle\") && idle_enabled()) {\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_idle(tag.s);\n\n                snmp_increment(IDLE_COUNT, 1);\n            }\n            else goto badcmd;\n            break;\n\n        case 'L':\n            if (!strcmp(cmd.s, \"Login\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if(c != ' ') goto missingargs;\n\n                cmd_login(tag.s, arg1.s);\n\n                snmp_increment(LOGIN_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Logout\")) {\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                snmp_increment(LOGOUT_COUNT, 1);\n\n                /* force any responses from our selected backend */\n                if (backend_current) imapd_check(NULL, 0);\n\n                prot_printf(imapd_out, \"* BYE %s\\r\\n\",\n                            error_message(IMAP_BYE_LOGOUT));\n                prot_printf(imapd_out, \"%s OK %s\\r\\n\", tag.s,\n                            error_message(IMAP_OK_COMPLETED));\n\n                if (imapd_userid && *imapd_userid) {\n                    telemetry_rusage(imapd_userid);\n                }\n\n                goto done;\n            }\n            else if (!imapd_userid) goto nologin;\n            else if (!strcmp(cmd.s, \"List\")) {\n                struct listargs listargs;\n\n                if (c != ' ') goto missingargs;\n\n                memset(&listargs, 0, sizeof(struct listargs));\n                listargs.ret = LIST_RET_CHILDREN;\n                getlistargs(tag.s, &listargs);\n                if (listargs.pat.count) cmd_list(tag.s, &listargs);\n\n                snmp_increment(LIST_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Lsub\")) {\n                struct listargs listargs;\n\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg2);\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                memset(&listargs, 0, sizeof(struct listargs));\n                listargs.cmd = LIST_CMD_LSUB;\n                listargs.sel = LIST_SEL_SUBSCRIBED;\n                if (!strcasecmpsafe(imapd_magicplus, \"+dav\"))\n                    listargs.sel |= LIST_SEL_DAV;\n                listargs.ref = arg1.s;\n                strarray_append(&listargs.pat, arg2.s);\n\n                cmd_list(tag.s, &listargs);\n\n                snmp_increment(LSUB_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Listrights\")) {\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg2);\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_listrights(tag.s, arg1.s, arg2.s);\n\n                snmp_increment(LISTRIGHTS_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Localappend\")) {\n                /* create a local-only mailbox */\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg2);\n                if (c != ' ') goto missingargs;\n\n                cmd_append(tag.s, arg1.s, *arg2.s ? arg2.s : NULL);\n\n                snmp_increment(APPEND_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Localcreate\")) {\n                /* create a local-only mailbox */\n                struct dlist *extargs = NULL;\n\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                if (c == ' ') {\n                    c = parsecreateargs(&extargs);\n                    if (c == EOF) goto badpartition;\n                }\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_create(tag.s, arg1.s, extargs, 1);\n                dlist_free(&extargs);\n\n                /* xxxx snmp_increment(CREATE_COUNT, 1); */\n            }\n            else if (!strcmp(cmd.s, \"Localdelete\")) {\n                /* delete a mailbox locally only */\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_delete(tag.s, arg1.s, 1, 1);\n\n                /* xxxx snmp_increment(DELETE_COUNT, 1); */\n            }\n            else goto badcmd;\n            break;\n\n        case 'M':\n            if (!strcmp(cmd.s, \"Myrights\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_myrights(tag.s, arg1.s);\n\n                /* xxxx snmp_increment(MYRIGHTS_COUNT, 1); */\n            }\n            else if (!strcmp(cmd.s, \"Mupdatepush\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if(c == EOF) goto missingargs;\n                if(c == '\\r') c = prot_getc(imapd_in);\n                if(c != '\\n') goto extraargs;\n                cmd_mupdatepush(tag.s, arg1.s);\n\n                /* xxxx snmp_increment(MUPDATEPUSH_COUNT, 1); */\n            }\n            else if (!strcmp(cmd.s, \"Move\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                usinguid = 0;\n                if (c != ' ') goto missingargs;\n            move:\n                c = getword(imapd_in, &arg1);\n                if (c == '\\r') goto missingargs;\n                if (c != ' ' || !imparse_issequence(arg1.s)) goto badsequence;\n                c = getastring(imapd_in, imapd_out, &arg2);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                cmd_copy(tag.s, arg1.s, arg2.s, usinguid, /*ismove*/1);\n\n                snmp_increment(COPY_COUNT, 1);\n            } else goto badcmd;\n            break;\n\n        case 'N':\n            if (!strcmp(cmd.s, \"Noop\")) {\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                cmd_noop(tag.s, cmd.s);\n\n                /* xxxx snmp_increment(NOOP_COUNT, 1); */\n            }\n            else if (!imapd_userid) goto nologin;\n            else if (!strcmp(cmd.s, \"Namespace\")) {\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_namespace(tag.s);\n\n                /* xxxx snmp_increment(NAMESPACE_COUNT, 1); */\n            }\n            else goto badcmd;\n            break;\n\n        case 'R':\n            if (!strcmp(cmd.s, \"Rename\")) {\n                havepartition = 0;\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg2);\n                if (c == EOF) goto missingargs;\n                if (c == ' ') {\n                    havepartition = 1;\n                    c = getword(imapd_in, &arg3);\n                    if (!imparse_isatom(arg3.s)) goto badpartition;\n                }\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_rename(tag.s, arg1.s, arg2.s, havepartition ? arg3.s : 0);\n\n                /* xxxx snmp_increment(RENAME_COUNT, 1); */\n            } else if(!strcmp(cmd.s, \"Reconstruct\")) {\n                recursive = 0;\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if(c == ' ') {\n                    /* Optional RECURSEIVE argument */\n                    c = getword(imapd_in, &arg2);\n                    if(!imparse_isatom(arg2.s))\n                        goto extraargs;\n                    else if(!strcasecmp(arg2.s, \"RECURSIVE\"))\n                        recursive = 1;\n                    else\n                        goto extraargs;\n                }\n                if(c == '\\r') c = prot_getc(imapd_in);\n                if(c != '\\n') goto extraargs;\n                cmd_reconstruct(tag.s, arg1.s, recursive);\n\n                /* snmp_increment(RECONSTRUCT_COUNT, 1); */\n            }\n            else if (!strcmp(cmd.s, \"Rlist\")) {\n                struct listargs listargs;\n\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg2);\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                memset(&listargs, 0, sizeof(struct listargs));\n                listargs.sel = LIST_SEL_REMOTE;\n                listargs.ret = LIST_RET_CHILDREN;\n                listargs.ref = arg1.s;\n                strarray_append(&listargs.pat, arg2.s);\n\n                cmd_list(tag.s, &listargs);\n\n/*              snmp_increment(LIST_COUNT, 1); */\n            }\n            else if (!strcmp(cmd.s, \"Rlsub\")) {\n                struct listargs listargs;\n\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg2);\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                memset(&listargs, 0, sizeof(struct listargs));\n                listargs.cmd = LIST_CMD_LSUB;\n                listargs.sel = LIST_SEL_REMOTE | LIST_SEL_SUBSCRIBED;\n                listargs.ref = arg1.s;\n                strarray_append(&listargs.pat, arg2.s);\n\n                cmd_list(tag.s, &listargs);\n\n/*              snmp_increment(LSUB_COUNT, 1); */\n            }\n#ifdef HAVE_SSL\n            else if (!strcmp(cmd.s, \"Resetkey\")) {\n                int have_mbox = 0, have_mech = 0;\n\n                if (c == ' ') {\n                    have_mbox = 1;\n                    c = getastring(imapd_in, imapd_out, &arg1);\n                    if (c == EOF) goto missingargs;\n                    if (c == ' ') {\n                        have_mech = 1;\n                        c = getword(imapd_in, &arg2);\n                    }\n                }\n\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_resetkey(tag.s, have_mbox ? arg1.s : 0,\n                             have_mech ? arg2.s : 0);\n            /*  snmp_increment(RESETKEY_COUNT, 1);*/\n            }\n#endif\n            else goto badcmd;\n            break;\n\n        case 'S':\n            if (!strcmp(cmd.s, \"Starttls\")) {\n                if (!tls_enabled()) {\n                    /* we don't support starttls */\n                    goto badcmd;\n                }\n\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                /* XXX  discard any input pipelined after STARTTLS */\n                prot_flush(imapd_in);\n\n                /* if we've already done SASL fail */\n                if (imapd_userid != NULL) {\n                    prot_printf(imapd_out,\n               \"%s BAD Can't Starttls after authentication\\r\\n\", tag.s);\n                    continue;\n                }\n\n                /* if we've already done COMPRESS fail */\n                if (imapd_compress_done == 1) {\n                    prot_printf(imapd_out,\n               \"%s BAD Can't Starttls after Compress\\r\\n\", tag.s);\n                    continue;\n                }\n\n                /* check if already did a successful tls */\n                if (imapd_starttls_done == 1) {\n                    prot_printf(imapd_out,\n                                \"%s BAD Already did a successful Starttls\\r\\n\",\n                                tag.s);\n                    continue;\n                }\n                cmd_starttls(tag.s, 0);\n\n                snmp_increment(STARTTLS_COUNT, 1);\n                continue;\n            }\n            if (!imapd_userid) {\n                goto nologin;\n            } else if (!strcmp(cmd.s, \"Store\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                usinguid = 0;\n                if (c != ' ') goto missingargs;\n            store:\n                c = getword(imapd_in, &arg1);\n                if (c != ' ' || !imparse_issequence(arg1.s)) goto badsequence;\n\n                cmd_store(tag.s, arg1.s, usinguid);\n\n                snmp_increment(STORE_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Select\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                prot_ungetc(c, imapd_in);\n\n                cmd_select(tag.s, cmd.s, arg1.s);\n\n                snmp_increment(SELECT_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Search\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                usinguid = 0;\n                if (c != ' ') goto missingargs;\n            search:\n\n                cmd_search(tag.s, usinguid);\n\n                snmp_increment(SEARCH_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Subscribe\")) {\n                if (c != ' ') goto missingargs;\n                havenamespace = 0;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == ' ') {\n                    havenamespace = 1;\n                    c = getastring(imapd_in, imapd_out, &arg2);\n                }\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                if (havenamespace) {\n                    cmd_changesub(tag.s, arg1.s, arg2.s, 1);\n                }\n                else {\n                    cmd_changesub(tag.s, (char *)0, arg1.s, 1);\n                }\n                snmp_increment(SUBSCRIBE_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Setacl\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg2);\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg3);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_setacl(tag.s, arg1.s, arg2.s, arg3.s);\n\n                snmp_increment(SETACL_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Setannotation\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n\n                cmd_setannotation(tag.s, arg1.s);\n\n                snmp_increment(SETANNOTATION_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Setmetadata\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n\n                cmd_setmetadata(tag.s, arg1.s);\n\n                snmp_increment(SETANNOTATION_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Setquota\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n                cmd_setquota(tag.s, arg1.s);\n\n                snmp_increment(SETQUOTA_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Sort\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                usinguid = 0;\n                if (c != ' ') goto missingargs;\n            sort:\n                cmd_sort(tag.s, usinguid);\n\n                snmp_increment(SORT_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Status\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n                cmd_status(tag.s, arg1.s);\n\n                snmp_increment(STATUS_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Scan\")) {\n                struct listargs listargs;\n\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg2);\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg3);\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                memset(&listargs, 0, sizeof(struct listargs));\n                listargs.ref = arg1.s;\n                strarray_append(&listargs.pat, arg2.s);\n                listargs.scan = arg3.s;\n\n                cmd_list(tag.s, &listargs);\n\n                 snmp_increment(SCAN_COUNT, 1);\n             }\n             else if (!strcmp(cmd.s, \"Syncapply\")) {\n                if (!imapd_userisadmin) goto badcmd;\n\n                 struct dlist *kl = sync_parseline(imapd_in);\n \n                 if (kl) {\n                    cmd_syncapply(tag.s, kl, reserve_list);\n                    dlist_free(&kl);\n                }\n                 else goto extraargs;\n             }\n             else if (!strcmp(cmd.s, \"Syncget\")) {\n                if (!imapd_userisadmin) goto badcmd;\n\n                 struct dlist *kl = sync_parseline(imapd_in);\n \n                 if (kl) {\n                    cmd_syncget(tag.s, kl);\n                    dlist_free(&kl);\n                }\n                 else goto extraargs;\n             }\n             else if (!strcmp(cmd.s, \"Syncrestart\")) {\n                if (!imapd_userisadmin) goto badcmd;\n\n                 if (c == '\\r') c = prot_getc(imapd_in);\n                 if (c != '\\n') goto extraargs;\n \n                 /* just clear the GUID cache */\n                 cmd_syncrestart(tag.s, &reserve_list, 1);\n             }\n             else if (!strcmp(cmd.s, \"Syncrestore\")) {\n                if (!imapd_userisadmin) goto badcmd;\n\n                 struct dlist *kl = sync_parseline(imapd_in);\n \n                 if (kl) {\n                    cmd_syncrestore(tag.s, kl, reserve_list);\n                    dlist_free(&kl);\n                }\n                else goto extraargs;\n            }\n            else goto badcmd;\n            break;\n\n        case 'T':\n            if (!strcmp(cmd.s, \"Thread\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                usinguid = 0;\n                if (c != ' ') goto missingargs;\n            thread:\n                cmd_thread(tag.s, usinguid);\n\n                snmp_increment(THREAD_COUNT, 1);\n            }\n            else goto badcmd;\n            break;\n\n        case 'U':\n            if (!strcmp(cmd.s, \"Uid\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                usinguid = 1;\n                if (c != ' ') goto missingargs;\n                c = getword(imapd_in, &arg1);\n                if (c != ' ') goto missingargs;\n                lcase(arg1.s);\n                xstrncpy(cmdname, arg1.s, 99);\n                if (!strcmp(arg1.s, \"fetch\")) {\n                    goto fetch;\n                }\n                else if (!strcmp(arg1.s, \"store\")) {\n                    goto store;\n                }\n                else if (!strcmp(arg1.s, \"search\")) {\n                    goto search;\n                }\n                else if (!strcmp(arg1.s, \"sort\")) {\n                    goto sort;\n                }\n                else if (!strcmp(arg1.s, \"thread\")) {\n                    goto thread;\n                }\n                else if (!strcmp(arg1.s, \"copy\")) {\n                    goto copy;\n                }\n                else if (!strcmp(arg1.s, \"move\")) {\n                    goto move;\n                }\n                else if (!strcmp(arg1.s, \"xmove\")) {\n                    goto move;\n                }\n                else if (!strcmp(arg1.s, \"expunge\")) {\n                    c = getword(imapd_in, &arg1);\n                    if (!imparse_issequence(arg1.s)) goto badsequence;\n                    if (c == '\\r') c = prot_getc(imapd_in);\n                    if (c != '\\n') goto extraargs;\n                    cmd_expunge(tag.s, arg1.s);\n\n                    snmp_increment(EXPUNGE_COUNT, 1);\n                }\n                else if (!strcmp(arg1.s, \"xrunannotator\")) {\n                    goto xrunannotator;\n                }\n                else {\n                    prot_printf(imapd_out, \"%s BAD Unrecognized UID subcommand\\r\\n\", tag.s);\n                    eatline(imapd_in, c);\n                }\n            }\n            else if (!strcmp(cmd.s, \"Unsubscribe\")) {\n                if (c != ' ') goto missingargs;\n                havenamespace = 0;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == ' ') {\n                    havenamespace = 1;\n                    c = getastring(imapd_in, imapd_out, &arg2);\n                }\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                if (havenamespace) {\n                    cmd_changesub(tag.s, arg1.s, arg2.s, 0);\n                }\n                else {\n                    cmd_changesub(tag.s, (char *)0, arg1.s, 0);\n                }\n\n                snmp_increment(UNSUBSCRIBE_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Unselect\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                cmd_close(tag.s, cmd.s);\n\n                snmp_increment(UNSELECT_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Undump\")) {\n                if(c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n\n                /* we want to get a list at this point */\n                if(c != ' ') goto missingargs;\n\n                cmd_undump(tag.s, arg1.s);\n            /*  snmp_increment(UNDUMP_COUNT, 1);*/\n            }\n#ifdef HAVE_SSL\n            else if (!strcmp(cmd.s, \"Urlfetch\")) {\n                if (c != ' ') goto missingargs;\n\n                cmd_urlfetch(tag.s);\n            /*  snmp_increment(URLFETCH_COUNT, 1);*/\n            }\n#endif\n            else goto badcmd;\n            break;\n\n        case 'X':\n            if (!strcmp(cmd.s, \"Xbackup\")) {\n                int havechannel = 0;\n\n                if (!config_getswitch(IMAPOPT_XBACKUP_ENABLED))\n                    goto badcmd;\n\n                /* user */\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n\n                /* channel */\n                if (c == ' ') {\n                    havechannel = 1;\n                    c = getword(imapd_in, &arg2);\n                    if (c == EOF) goto missingargs;\n                }\n\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                cmd_xbackup(tag.s, arg1.s, havechannel ? arg2.s : NULL);\n\n            }\n            else if (!strcmp(cmd.s, \"Xconvfetch\")) {\n                cmd_xconvfetch(tag.s);\n\n            }\n            else if (!strcmp(cmd.s, \"Xconvmultisort\")) {\n                if (c != ' ') goto missingargs;\n                if (!imapd_index && !backend_current) goto nomailbox;\n                cmd_xconvmultisort(tag.s);\n\n            }\n            else if (!strcmp(cmd.s, \"Xconvsort\")) {\n                if (c != ' ') goto missingargs;\n                if (!imapd_index && !backend_current) goto nomailbox;\n                cmd_xconvsort(tag.s, 0);\n\n            }\n            else if (!strcmp(cmd.s, \"Xconvupdates\")) {\n                if (c != ' ') goto missingargs;\n                if (!imapd_index && !backend_current) goto nomailbox;\n                cmd_xconvsort(tag.s, 1);\n\n            }\n            else if (!strcmp(cmd.s, \"Xfer\")) {\n                int havepartition = 0;\n\n                /* Mailbox */\n                if(c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n\n                /* Dest Server */\n                if(c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg2);\n\n                if(c == ' ') {\n                    /* Dest Partition */\n                    c = getastring(imapd_in, imapd_out, &arg3);\n                    if (!imparse_isatom(arg3.s)) goto badpartition;\n                    havepartition = 1;\n                }\n\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n\n                cmd_xfer(tag.s, arg1.s, arg2.s,\n                         (havepartition ? arg3.s : NULL));\n            /*  snmp_increment(XFER_COUNT, 1);*/\n            }\n            else if (!strcmp(cmd.s, \"Xconvmeta\")) {\n                cmd_xconvmeta(tag.s);\n            }\n            else if (!strcmp(cmd.s, \"Xlist\")) {\n                struct listargs listargs;\n\n                if (c != ' ') goto missingargs;\n\n                memset(&listargs, 0, sizeof(struct listargs));\n                listargs.cmd = LIST_CMD_XLIST;\n                listargs.ret = LIST_RET_CHILDREN | LIST_RET_SPECIALUSE;\n                getlistargs(tag.s, &listargs);\n                if (listargs.pat.count) cmd_list(tag.s, &listargs);\n\n                snmp_increment(LIST_COUNT, 1);\n            }\n            else if (!strcmp(cmd.s, \"Xmove\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                usinguid = 0;\n                if (c != ' ') goto missingargs;\n                goto move;\n            }\n            else if (!strcmp(cmd.s, \"Xrunannotator\")) {\n                if (!imapd_index && !backend_current) goto nomailbox;\n                usinguid = 0;\n                if (c != ' ') goto missingargs;\n            xrunannotator:\n                c = getword(imapd_in, &arg1);\n                if (!arg1.len || !imparse_issequence(arg1.s)) goto badsequence;\n                cmd_xrunannotator(tag.s, arg1.s, usinguid);\n            }\n            else if (!strcmp(cmd.s, \"Xsnippets\")) {\n                if (c != ' ') goto missingargs;\n                if (!imapd_index && !backend_current) goto nomailbox;\n                cmd_xsnippets(tag.s);\n\n            }\n            else if (!strcmp(cmd.s, \"Xstats\")) {\n                cmd_xstats(tag.s, c);\n            }\n            else if (!strcmp(cmd.s, \"Xwarmup\")) {\n                /* XWARMUP doesn't need a mailbox to be selected */\n                if (c != ' ') goto missingargs;\n                cmd_xwarmup(tag.s);\n            }\n            else if (!strcmp(cmd.s, \"Xkillmy\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_xkillmy(tag.s, arg1.s);\n            }\n            else if (!strcmp(cmd.s, \"Xforever\")) {\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_xforever(tag.s);\n            }\n            else if (!strcmp(cmd.s, \"Xmeid\")) {\n                if (c != ' ') goto missingargs;\n                c = getastring(imapd_in, imapd_out, &arg1);\n                if (c == EOF) goto missingargs;\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto extraargs;\n                cmd_xmeid(tag.s, arg1.s);\n            }\n\n            else if (apns_enabled && !strcmp(cmd.s, \"Xapplepushservice\")) {\n                if (c != ' ') goto missingargs;\n\n                memset(&applepushserviceargs, 0, sizeof(struct applepushserviceargs));\n\n                do {\n                    c = getastring(imapd_in, imapd_out, &arg1);\n                    if (c == EOF) goto aps_missingargs;\n\n                    if (!strcmp(arg1.s, \"mailboxes\")) {\n                        c = prot_getc(imapd_in);\n                        if (c != '(')\n                            goto aps_missingargs;\n\n                        c = prot_getc(imapd_in);\n                        if (c != ')') {\n                            prot_ungetc(c, imapd_in);\n                            do {\n                                c = getastring(imapd_in, imapd_out, &arg2);\n                                if (c == EOF) break;\n                                strarray_push(&applepushserviceargs.mailboxes, arg2.s);\n                            } while (c == ' ');\n                        }\n\n                        if (c != ')')\n                            goto aps_missingargs;\n                        c = prot_getc(imapd_in);\n                    }\n\n                    else {\n                        c = getastring(imapd_in, imapd_out, &arg2);\n\n                        if (!strcmp(arg1.s, \"aps-version\")) {\n                            if (!imparse_isnumber(arg2.s)) goto aps_extraargs;\n                            applepushserviceargs.aps_version = atoi(arg2.s);\n                        }\n                        else if (!strcmp(arg1.s, \"aps-account-id\"))\n                            buf_copy(&applepushserviceargs.aps_account_id, &arg2);\n                        else if (!strcmp(arg1.s, \"aps-device-token\"))\n                            buf_copy(&applepushserviceargs.aps_device_token, &arg2);\n                        else if (!strcmp(arg1.s, \"aps-subtopic\"))\n                            buf_copy(&applepushserviceargs.aps_subtopic, &arg2);\n                        else\n                            goto aps_extraargs;\n                    }\n                } while (c == ' ');\n\n                if (c == '\\r') c = prot_getc(imapd_in);\n                if (c != '\\n') goto aps_extraargs;\n\n                cmd_xapplepushservice(tag.s, &applepushserviceargs);\n            }\n\n            else goto badcmd;\n            break;\n\n        default:\n        badcmd:\n            prot_printf(imapd_out, \"%s BAD Unrecognized command\\r\\n\", tag.s);\n            eatline(imapd_in, c);\n        }\n\n        /* End command timer - don't log \"idle\" commands */\n        if (commandmintimer && strcmp(\"idle\", cmdname)) {\n            double cmdtime, nettime;\n            const char *mboxname = index_mboxname(imapd_index);\n            if (!mboxname) mboxname = \"<none>\";\n            cmdtime_endtimer(&cmdtime, &nettime);\n            if (cmdtime >= commandmintimerd) {\n                syslog(LOG_NOTICE, \"cmdtimer: '%s' '%s' '%s' '%f' '%f' '%f'\",\n                    imapd_userid ? imapd_userid : \"<none>\", cmdname, mboxname,\n                    cmdtime, nettime, cmdtime + nettime);\n            }\n        }\n        continue;\n\n    nologin:\n        prot_printf(imapd_out, \"%s BAD Please login first\\r\\n\", tag.s);\n        eatline(imapd_in, c);\n        continue;\n\n    nomailbox:\n        prot_printf(imapd_out,\n                    \"%s BAD Please select a mailbox first\\r\\n\", tag.s);\n        eatline(imapd_in, c);\n        continue;\n\n    aps_missingargs:\n        buf_free(&applepushserviceargs.aps_account_id);\n        buf_free(&applepushserviceargs.aps_device_token);\n        buf_free(&applepushserviceargs.aps_subtopic);\n        strarray_fini(&applepushserviceargs.mailboxes);\n\n    missingargs:\n        prot_printf(imapd_out,\n                    \"%s BAD Missing required argument to %s\\r\\n\", tag.s, cmd.s);\n        eatline(imapd_in, c);\n        continue;\n\n    aps_extraargs:\n        buf_free(&applepushserviceargs.aps_account_id);\n        buf_free(&applepushserviceargs.aps_device_token);\n        buf_free(&applepushserviceargs.aps_subtopic);\n        strarray_fini(&applepushserviceargs.mailboxes);\n\n    extraargs:\n        prot_printf(imapd_out,\n                    \"%s BAD Unexpected extra arguments to %s\\r\\n\", tag.s, cmd.s);\n        eatline(imapd_in, c);\n        continue;\n\n    badsequence:\n        prot_printf(imapd_out,\n                    \"%s BAD Invalid sequence in %s\\r\\n\", tag.s, cmd.s);\n        eatline(imapd_in, c);\n        continue;\n\n    badpartition:\n        prot_printf(imapd_out,\n                    \"%s BAD Invalid partition name in %s\\r\\n\", tag.s, cmd.s);\n        eatline(imapd_in, c);\n        continue;\n    }\n\ndone:\n    cmd_syncrestart(NULL, &reserve_list, 0);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143456,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "ModuleExport size_t RegisterMPCImage(void)\n{\n  MagickInfo\n    *entry;\n\n   entry=SetMagickInfo(\"CACHE\");\n   entry->description=ConstantString(\"Magick Persistent Cache image format\");\n   entry->module=ConstantString(\"MPC\");\n  entry->seekable_stream=MagickTrue;\n   entry->stealth=MagickTrue;\n   (void) RegisterMagickInfo(entry);\n   entry=SetMagickInfo(\"MPC\");\n  entry->decoder=(DecodeImageHandler *) ReadMPCImage;\n  entry->encoder=(EncodeImageHandler *) WriteMPCImage;\n  entry->magick=(IsImageFormatHandler *) IsMPC;\n  entry->description=ConstantString(\"Magick Persistent Cache image format\");\n  entry->seekable_stream=MagickTrue;\n  entry->module=ConstantString(\"MPC\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143461,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "ModuleExport size_t RegisterMPCImage(void)\n{\n  MagickInfo\n    *entry;\n\n   entry=SetMagickInfo(\"CACHE\");\n   entry->description=ConstantString(\"Magick Persistent Cache image format\");\n   entry->module=ConstantString(\"MPC\");\n   entry->stealth=MagickTrue;\n   (void) RegisterMagickInfo(entry);\n   entry=SetMagickInfo(\"MPC\");\n  entry->decoder=(DecodeImageHandler *) ReadMPCImage;\n  entry->encoder=(EncodeImageHandler *) WriteMPCImage;\n  entry->magick=(IsImageFormatHandler *) IsMPC;\n  entry->description=ConstantString(\"Magick Persistent Cache image format\");\n  entry->seekable_stream=MagickTrue;\n  entry->module=ConstantString(\"MPC\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143462,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n{\n\t__u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr;\n\tstruct kvm_regs *regs = vcpu_gp_regs(vcpu);\n\tint nr_regs = sizeof(*regs) / sizeof(__u32);\n\t__uint128_t tmp;\n\tvoid *valp = &tmp;\n\tu64 off;\n\tint err = 0;\n\n\t/* Our ID is an index into the kvm_regs struct. */\n\toff = core_reg_offset_from_id(reg->id);\n\tif (off >= nr_regs ||\n\t    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)\n\t\treturn -ENOENT;\n\n\tif (validate_core_offset(reg))\n\t\treturn -EINVAL;\n\n\tif (KVM_REG_SIZE(reg->id) > sizeof(tmp))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(valp, uaddr, KVM_REG_SIZE(reg->id))) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n \t}\n \n \tif (off == KVM_REG_ARM_CORE_REG(regs.pstate)) {\n\t\tu32 mode = (*(u32 *)valp) & PSR_AA32_MODE_MASK;\n \t\tswitch (mode) {\n \t\tcase PSR_AA32_MODE_USR:\n \t\tcase PSR_AA32_MODE_FIQ:\n \t\tcase PSR_AA32_MODE_IRQ:\n \t\tcase PSR_AA32_MODE_SVC:\n \t\tcase PSR_AA32_MODE_ABT:\n \t\tcase PSR_AA32_MODE_UND:\n \t\tcase PSR_MODE_EL0t:\n \t\tcase PSR_MODE_EL1t:\n \t\tcase PSR_MODE_EL1h:\n \t\t\tbreak;\n \t\tdefault:\n \t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemcpy((u32 *)regs + off, valp, KVM_REG_SIZE(reg->id));\nout:\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143499,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n{\n\t__u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr;\n\tstruct kvm_regs *regs = vcpu_gp_regs(vcpu);\n\tint nr_regs = sizeof(*regs) / sizeof(__u32);\n\t__uint128_t tmp;\n\tvoid *valp = &tmp;\n\tu64 off;\n\tint err = 0;\n\n\t/* Our ID is an index into the kvm_regs struct. */\n\toff = core_reg_offset_from_id(reg->id);\n\tif (off >= nr_regs ||\n\t    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)\n\t\treturn -ENOENT;\n\n\tif (validate_core_offset(reg))\n\t\treturn -EINVAL;\n\n\tif (KVM_REG_SIZE(reg->id) > sizeof(tmp))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(valp, uaddr, KVM_REG_SIZE(reg->id))) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n \t}\n \n \tif (off == KVM_REG_ARM_CORE_REG(regs.pstate)) {\n\t\tu64 mode = (*(u64 *)valp) & PSR_AA32_MODE_MASK;\n \t\tswitch (mode) {\n \t\tcase PSR_AA32_MODE_USR:\n\t\t\tif (!system_supports_32bit_el0())\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n \t\tcase PSR_AA32_MODE_FIQ:\n \t\tcase PSR_AA32_MODE_IRQ:\n \t\tcase PSR_AA32_MODE_SVC:\n \t\tcase PSR_AA32_MODE_ABT:\n \t\tcase PSR_AA32_MODE_UND:\n\t\t\tif (!vcpu_el1_is_32bit(vcpu))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n \t\tcase PSR_MODE_EL0t:\n \t\tcase PSR_MODE_EL1t:\n \t\tcase PSR_MODE_EL1h:\n\t\t\tif (vcpu_el1_is_32bit(vcpu))\n\t\t\t\treturn -EINVAL;\n \t\t\tbreak;\n \t\tdefault:\n \t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemcpy((u32 *)regs + off, valp, KVM_REG_SIZE(reg->id));\nout:\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143500,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \"disallowed submodule name: %s\",\n\t\t\t\t    name);\n\tif (!strcmp(key, \"url\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n \t\t\t\t    FSCK_MSG_GITMODULES_URL,\n \t\t\t\t    \"disallowed submodule url: %s\",\n \t\t\t\t    value);\n \tfree(name);\n \n \treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143501,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \"disallowed submodule name: %s\",\n\t\t\t\t    name);\n\tif (!strcmp(key, \"url\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n \t\t\t\t    FSCK_MSG_GITMODULES_URL,\n \t\t\t\t    \"disallowed submodule url: %s\",\n \t\t\t\t    value);\n\tif (!strcmp(key, \"path\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_PATH,\n\t\t\t\t    \"disallowed submodule path: %s\",\n\t\t\t\t    value);\n \tfree(name);\n \n \treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143502,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowDCMException(exception,message) \\\n{ \\\n  if (info.scale != (Quantum *) NULL) \\\n    info.scale=(Quantum *) RelinquishMagickMemory(info.scale); \\\n  if (data != (unsigned char *) NULL) \\\n    data=(unsigned char *) RelinquishMagickMemory(data); \\\n  if (graymap != (int *) NULL) \\\n    graymap=(int *) RelinquishMagickMemory(graymap); \\\n  if (bluemap != (int *) NULL) \\\n    bluemap=(int *) RelinquishMagickMemory(bluemap); \\\n  if (greenmap != (int *) NULL) \\\n    greenmap=(int *) RelinquishMagickMemory(greenmap); \\\n  if (redmap != (int *) NULL) \\\n    redmap=(int *) RelinquishMagickMemory(redmap); \\\n  if (stream_info->offsets != (ssize_t *) NULL) \\\n    stream_info->offsets=(ssize_t *) RelinquishMagickMemory( \\\n      stream_info->offsets); \\\n  if (stream_info != (DCMStreamInfo *) NULL) \\\n    stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    explicit_vr[MagickPathExtent],\n    implicit_vr[MagickPathExtent],\n    magick[MagickPathExtent],\n    photometric[MagickPathExtent];\n\n  DCMInfo\n    info;\n\n  DCMStreamInfo\n    *stream_info;\n\n  Image\n    *image;\n\n  int\n    *bluemap,\n    datum,\n    *greenmap,\n    *graymap,\n    *redmap;\n\n  MagickBooleanType\n    explicit_file,\n    explicit_retry,\n    use_explicit;\n\n  MagickOffsetType\n    offset;\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    colors,\n    height,\n    length,\n    number_scenes,\n    quantum,\n    status,\n    width;\n\n  ssize_t\n    count,\n    scene;\n\n  unsigned char\n    *data;\n\n  unsigned short\n    group,\n    element;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=8UL;\n  image->endian=LSBEndian;\n  /*\n    Read DCM preamble.\n  */\n  (void) memset(&info,0,sizeof(info));\n  data=(unsigned char *) NULL;\n  graymap=(int *) NULL;\n  redmap=(int *) NULL;\n  greenmap=(int *) NULL;\n  bluemap=(int *) NULL;\n  stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));\n  if (stream_info == (DCMStreamInfo *) NULL)\n    ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memset(stream_info,0,sizeof(*stream_info));\n  count=ReadBlob(image,128,(unsigned char *) magick);\n  if (count != 128)\n    ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  if ((count != 4) || (LocaleNCompare(magick,\"DICM\",4) != 0))\n    {\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  /*\n    Read DCM Medical image.\n  */\n  (void) CopyMagickString(photometric,\"MONOCHROME1 \",MagickPathExtent);\n  info.bits_allocated=8;\n  info.bytes_per_pixel=1;\n  info.depth=8;\n  info.mask=0xffff;\n  info.max_value=255UL;\n  info.samples_per_pixel=1;\n  info.signed_data=(~0UL);\n  info.rescale_slope=1.0;\n  data=(unsigned char *) NULL;\n  element=0;\n  explicit_vr[2]='\\0';\n  explicit_file=MagickFalse;\n  colors=0;\n  redmap=(int *) NULL;\n  greenmap=(int *) NULL;\n  bluemap=(int *) NULL;\n  graymap=(int *) NULL;\n  height=0;\n  number_scenes=1;\n  use_explicit=MagickFalse;\n  explicit_retry = MagickFalse;\n  width=0;\n  while (TellBlob(image) < (MagickOffsetType) GetBlobSize(image))\n  {\n    for (group=0; (group != 0x7FE0) || (element != 0x0010) ; )\n    {\n      /*\n        Read a group.\n      */\n      image->offset=(ssize_t) TellBlob(image);\n      group=ReadBlobLSBShort(image);\n      element=ReadBlobLSBShort(image);\n      if ((group == 0xfffc) && (element == 0xfffc))\n        break;\n      if ((group != 0x0002) && (image->endian == MSBEndian))\n        {\n          group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));\n          element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));\n        }\n      quantum=0;\n      /*\n        Find corresponding VR for this group and element.\n      */\n      for (i=0; dicom_info[i].group < 0xffff; i++)\n        if ((group == dicom_info[i].group) &&\n            (element == dicom_info[i].element))\n          break;\n      (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);\n      count=ReadBlob(image,2,(unsigned char *) explicit_vr);\n      if (count != 2)\n        ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n      /*\n        Check for \"explicitness\", but meta-file headers always explicit.\n      */\n      if ((explicit_file == MagickFalse) && (group != 0x0002))\n        explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&\n          (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?\n          MagickTrue : MagickFalse;\n      use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||\n        (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;\n      if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,\"xs\",2) == 0))\n        (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);\n      if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,\"!!\",2) == 0))\n        {\n          offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);\n          if (offset < 0)\n            ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n          quantum=4;\n        }\n      else\n        {\n          /*\n            Assume explicit type.\n          */\n          quantum=2;\n          if ((strncmp(explicit_vr,\"OB\",2) == 0) ||\n              (strncmp(explicit_vr,\"UN\",2) == 0) ||\n              (strncmp(explicit_vr,\"OW\",2) == 0) ||\n              (strncmp(explicit_vr,\"SQ\",2) == 0))\n            {\n              (void) ReadBlobLSBShort(image);\n              quantum=4;\n            }\n        }\n      datum=0;\n      if (quantum == 4)\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedLong(image);\n          else\n            datum=ReadBlobSignedLong(image);\n        }\n      else\n        if (quantum == 2)\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedShort(image);\n            else\n              datum=ReadBlobSignedShort(image);\n          }\n      quantum=0;\n      length=1;\n      if (datum != 0)\n        {\n          if ((strncmp(implicit_vr,\"OW\",2) == 0) ||\n              (strncmp(implicit_vr,\"SS\",2) == 0) ||\n              (strncmp(implicit_vr,\"US\",2) == 0))\n            quantum=2;\n          else\n            if ((strncmp(implicit_vr,\"FL\",2) == 0) ||\n                (strncmp(implicit_vr,\"OF\",2) == 0) ||\n                (strncmp(implicit_vr,\"SL\",2) == 0) ||\n                (strncmp(implicit_vr,\"UL\",2) == 0))\n              quantum=4;\n            else\n              if (strncmp(implicit_vr,\"FD\",2) == 0)\n                quantum=8;\n              else\n                quantum=1;\n          if (datum != ~0)\n            length=(size_t) datum/quantum;\n          else\n            {\n              /*\n                Sequence and item of undefined length.\n              */\n              quantum=0;\n              length=0;\n            }\n        }\n      if (image_info->verbose != MagickFalse)\n        {\n          /*\n            Display Dicom info.\n          */\n          if (use_explicit == MagickFalse)\n            explicit_vr[0]='\\0';\n          for (i=0; dicom_info[i].description != (char *) NULL; i++)\n            if ((group == dicom_info[i].group) &&\n                (element == dicom_info[i].element))\n              break;\n          (void) FormatLocaleFile(stdout,\"0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)\",\n            (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,\n            (unsigned long) group,(unsigned long) element);\n          if (dicom_info[i].description != (char *) NULL)\n            (void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);\n          (void) FormatLocaleFile(stdout,\": \");\n        }\n      if ((group == 0x7FE0) && (element == 0x0010))\n        {\n          if (image_info->verbose != MagickFalse)\n            (void) FormatLocaleFile(stdout,\"\\n\");\n          break;\n        }\n      /*\n        Allocate space and read an array.\n      */\n      data=(unsigned char *) NULL;\n      if ((length == 1) && (quantum == 1))\n        datum=ReadBlobByte(image);\n      else\n        if ((length == 1) && (quantum == 2))\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedShort(image);\n            else\n              datum=ReadBlobSignedShort(image);\n          }\n        else\n          if ((length == 1) && (quantum == 4))\n            {\n              if (group == 0x0002)\n                datum=ReadBlobLSBSignedLong(image);\n              else\n                datum=ReadBlobSignedLong(image);\n            }\n          else\n            if ((quantum != 0) && (length != 0))\n              {\n                if (length > (size_t) GetBlobSize(image))\n                  ThrowDCMException(CorruptImageError,\n                    \"InsufficientImageDataInFile\");\n                if (~length >= 1)\n                  data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*\n                    sizeof(*data));\n                if (data == (unsigned char *) NULL)\n                  ThrowDCMException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n                count=ReadBlob(image,(size_t) quantum*length,data);\n                if (count != (ssize_t) (quantum*length))\n                  {\n                    if (image_info->verbose != MagickFalse)\n                      (void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"\n                        \"length=%d group=%d\\n\",(int) count,(int) quantum,(int)\n                        length,(int) group);\n                     ThrowDCMException(CorruptImageError,\n                       \"InsufficientImageDataInFile\");\n                  }\n                data[length*quantum]='\\0';\n              }\n      if ((((unsigned int) group << 16) | element) == 0xFFFEE0DD)\n        {\n          if (data != (unsigned char *) NULL)\n            data=(unsigned char *) RelinquishMagickMemory(data);\n          continue;\n        }\n      switch (group)\n      {\n        case 0x0002:\n        {\n          switch (element)\n          {\n            case 0x0010:\n            {\n              char\n                transfer_syntax[MagickPathExtent];\n\n              /*\n                Transfer Syntax.\n              */\n              if ((datum == 0) && (explicit_retry == MagickFalse))\n                {\n                  explicit_retry=MagickTrue;\n                  (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);\n                  group=0;\n                  element=0;\n                  if (image_info->verbose != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\n                      \"Corrupted image - trying explicit format\\n\");\n                  break;\n                }\n              *transfer_syntax='\\0';\n              if (data != (unsigned char *) NULL)\n                (void) CopyMagickString(transfer_syntax,(char *) data,\n                  MagickPathExtent);\n              if (image_info->verbose != MagickFalse)\n                (void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",\n                  (const char *) transfer_syntax);\n              if (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)\n                {\n                  int\n                    subtype,\n                    type;\n\n                  type=1;\n                  subtype=0;\n                  if (strlen(transfer_syntax) > 17)\n                    {\n                      count=(ssize_t) sscanf(transfer_syntax+17,\".%d.%d\",&type,\n                        &subtype);\n                      if (count < 1)\n                        ThrowDCMException(CorruptImageError,\n                          \"ImproperImageHeader\");\n                    }\n                  switch (type)\n                  {\n                    case 1:\n                    {\n                      image->endian=LSBEndian;\n                      break;\n                    }\n                    case 2:\n                    {\n                      image->endian=MSBEndian;\n                      break;\n                    }\n                    case 4:\n                    {\n                      if ((subtype >= 80) && (subtype <= 81))\n                        image->compression=JPEGCompression;\n                      else\n                        if ((subtype >= 90) && (subtype <= 93))\n                          image->compression=JPEG2000Compression;\n                        else\n                          image->compression=JPEGCompression;\n                      break;\n                    }\n                    case 5:\n                    {\n                      image->compression=RLECompression;\n                      break;\n                    }\n                  }\n                }\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        case 0x0028:\n        {\n          switch (element)\n          {\n            case 0x0002:\n            {\n              /*\n                Samples per pixel.\n              */\n              info.samples_per_pixel=(size_t) datum;\n              if ((info.samples_per_pixel == 0) || (info.samples_per_pixel > 4))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n              break;\n            }\n            case 0x0004:\n            {\n              /*\n                Photometric interpretation.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)\n                photometric[i]=(char) data[i];\n              photometric[i]='\\0';\n              info.polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?\n                MagickTrue : MagickFalse;\n              break;\n            }\n            case 0x0006:\n            {\n              /*\n                Planar configuration.\n              */\n              if (datum == 1)\n                image->interlace=PlaneInterlace;\n              break;\n            }\n            case 0x0008:\n            {\n              /*\n                Number of frames.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              number_scenes=StringToUnsignedLong((char *) data);\n              break;\n            }\n            case 0x0010:\n            {\n              /*\n                Image rows.\n              */\n              height=(size_t) datum;\n              break;\n            }\n            case 0x0011:\n            {\n              /*\n                Image columns.\n              */\n              width=(size_t) datum;\n              break;\n            }\n            case 0x0100:\n            {\n              /*\n                Bits allocated.\n              */\n              info.bits_allocated=(size_t) datum;\n              info.bytes_per_pixel=1;\n              if (datum > 8)\n                info.bytes_per_pixel=2;\n              info.depth=info.bits_allocated;\n              if ((info.depth == 0) || (info.depth > 32))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n              info.max_value=(1UL << info.bits_allocated)-1;\n              image->depth=info.depth;\n              break;\n            }\n            case 0x0101:\n            {\n              /*\n                Bits stored.\n              */\n              info.significant_bits=(size_t) datum;\n              info.bytes_per_pixel=1;\n              if (info.significant_bits > 8)\n                info.bytes_per_pixel=2;\n              info.depth=info.significant_bits;\n              if ((info.depth == 0) || (info.depth > 16))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n              info.max_value=(1UL << info.significant_bits)-1;\n              info.mask=(size_t) GetQuantumRange(info.significant_bits);\n              image->depth=info.depth;\n              break;\n            }\n            case 0x0102:\n            {\n              /*\n                High bit.\n              */\n              break;\n            }\n            case 0x0103:\n            {\n              /*\n                Pixel representation.\n              */\n              info.signed_data=(size_t) datum;\n              break;\n            }\n            case 0x1050:\n            {\n              /*\n                Visible pixel range: center.\n              */\n              if (data != (unsigned char *) NULL)\n                info.window_center=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1051:\n            {\n              /*\n                Visible pixel range: width.\n              */\n              if (data != (unsigned char *) NULL)\n                info.window_width=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1052:\n            {\n              /*\n                Rescale intercept\n              */\n              if (data != (unsigned char *) NULL)\n                info.rescale_intercept=StringToDouble((char *) data,\n                  (char **) NULL);\n              break;\n            }\n            case 0x1053:\n            {\n              /*\n                Rescale slope\n              */\n              if (data != (unsigned char *) NULL)\n                info.rescale_slope=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1200:\n            case 0x3006:\n            {\n              /*\n                Populate graymap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/info.bytes_per_pixel);\n              datum=(int) colors;\n              if (graymap != (int *) NULL)\n                graymap=(int *) RelinquishMagickMemory(graymap);\n              graymap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*graymap));\n              if (graymap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(graymap,0,MagickMax(colors,65536)*\n                sizeof(*graymap));\n              for (i=0; i < (ssize_t) colors; i++)\n                if (info.bytes_per_pixel == 1)\n                  graymap[i]=(int) data[i];\n                else\n                  graymap[i]=(int) ((short *) data)[i];\n              break;\n            }\n            case 0x1201:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate redmap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/2);\n              datum=(int) colors;\n              if (redmap != (int *) NULL)\n                redmap=(int *) RelinquishMagickMemory(redmap);\n              redmap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*redmap));\n              if (redmap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(redmap,0,MagickMax(colors,65536)*\n                sizeof(*redmap));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                redmap[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            case 0x1202:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate greenmap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/2);\n              datum=(int) colors;\n              if (greenmap != (int *) NULL)\n                greenmap=(int *) RelinquishMagickMemory(greenmap);\n              greenmap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*greenmap));\n              if (greenmap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(greenmap,0,MagickMax(colors,65536)*\n                sizeof(*greenmap));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                greenmap[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            case 0x1203:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate bluemap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/2);\n              datum=(int) colors;\n              if (bluemap != (int *) NULL)\n                bluemap=(int *) RelinquishMagickMemory(bluemap);\n              bluemap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*bluemap));\n              if (bluemap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(bluemap,0,MagickMax(colors,65536)*\n                sizeof(*bluemap));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                bluemap[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        case 0x2050:\n        {\n          switch (element)\n          {\n            case 0x0020:\n            {\n              if ((data != (unsigned char *) NULL) &&\n                  (strncmp((char *) data,\"INVERSE\",7) == 0))\n                info.polarity=MagickTrue;\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        default:\n          break;\n      }\n      if (data != (unsigned char *) NULL)\n        {\n          char\n            *attribute;\n\n          for (i=0; dicom_info[i].description != (char *) NULL; i++)\n            if ((group == dicom_info[i].group) &&\n                (element == dicom_info[i].element))\n              break;\n          if (dicom_info[i].description != (char *) NULL)\n            {\n              attribute=AcquireString(\"dcm:\");\n              (void) ConcatenateString(&attribute,dicom_info[i].description);\n              for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n                if (isprint((int) data[i]) == MagickFalse)\n                  break;\n              if ((i == (ssize_t) length) || (length > 4))\n                {\n                  (void) SubstituteString(&attribute,\" \",\"\");\n                  (void) SetImageProperty(image,attribute,(char *) data,\n                    exception);\n                }\n              attribute=DestroyString(attribute);\n            }\n        }\n      if (image_info->verbose != MagickFalse)\n        {\n          if (data == (unsigned char *) NULL)\n            (void) FormatLocaleFile(stdout,\"%d\\n\",datum);\n          else\n            {\n              /*\n                Display group data.\n              */\n              for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n                if (isprint((int) data[i]) == MagickFalse)\n                  break;\n              if ((i != (ssize_t) length) && (length <= 4))\n                {\n                  ssize_t\n                    j;\n\n                  datum=0;\n                  for (j=(ssize_t) length-1; j >= 0; j--)\n                    datum=(256*datum+data[j]);\n                  (void) FormatLocaleFile(stdout,\"%d\",datum);\n                }\n              else\n                for (i=0; i < (ssize_t) length; i++)\n                  if (isprint((int) data[i]) != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\"%c\",data[i]);\n                  else\n                    (void) FormatLocaleFile(stdout,\"%c\",'.');\n              (void) FormatLocaleFile(stdout,\"\\n\");\n            }\n        }\n      if (data != (unsigned char *) NULL)\n        data=(unsigned char *) RelinquishMagickMemory(data);\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n    }\n    if ((group == 0xfffc) && (element == 0xfffc))\n      {\n        Image\n          *last;\n\n        last=RemoveLastImageFromList(&image);\n        if (last != (Image *) NULL)\n          last=DestroyImage(last);\n        break;\n      }\n    if ((width == 0) || (height == 0))\n      ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    if (info.signed_data == 0xffff)\n      info.signed_data=(size_t) (info.significant_bits == 16 ? 1 : 0);\n    if ((image->compression == JPEGCompression) ||\n        (image->compression == JPEG2000Compression))\n      {\n        Image\n          *images;\n\n        ImageInfo\n          *read_info;\n\n        int\n          c;\n\n        /*\n          Read offset table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        (void) (((ssize_t) ReadBlobLSBShort(image) << 16) |\n          ReadBlobLSBShort(image));\n        length=(size_t) ReadBlobLSBLong(image);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\n        stream_info->offset_count=length >> 2;\n        if (stream_info->offset_count != 0)\n          {\n            if (stream_info->offsets != (ssize_t *) NULL)\n              stream_info->offsets=(ssize_t *) RelinquishMagickMemory(\n                stream_info->offsets);\n            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n              stream_info->offset_count,sizeof(*stream_info->offsets));\n            if (stream_info->offsets == (ssize_t *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n            offset=TellBlob(image);\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]+=offset;\n          }\n        /*\n          Handle non-native image formats.\n        */\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        images=NewImageList();\n        for (scene=0; scene < (ssize_t) number_scenes; scene++)\n        {\n          char\n            filename[MagickPathExtent];\n\n          const char\n            *property;\n\n          FILE\n            *file;\n\n          Image\n            *jpeg_image;\n\n          int\n            unique_file;\n\n          unsigned int\n            tag;\n\n           tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n             ReadBlobLSBShort(image);\n           length=(size_t) ReadBlobLSBLong(image);\n           if (tag == 0xFFFEE0DD)\n             break; /* sequence delimiter tag */\n           if (tag != 0xFFFEE000)\n            {\n              read_info=DestroyImageInfo(read_info);\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n            }\n          file=(FILE *) NULL;\n          unique_file=AcquireUniqueFileResource(filename);\n          if (unique_file != -1)\n            file=fdopen(unique_file,\"wb\");\n          if (file == (FILE *) NULL)\n            {\n              (void) RelinquishUniqueFileResource(filename);\n              ThrowFileException(exception,FileOpenError,\n                \"UnableToCreateTemporaryFile\",filename);\n              break;\n            }\n          for (c=EOF; length != 0; length--)\n          {\n            c=ReadBlobByte(image);\n            if (c == EOF)\n              {\n                ThrowFileException(exception,CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n                break;\n              }\n            if (fputc(c,file) != c)\n              break;\n          }\n          (void) fclose(file);\n          if (c == EOF)\n            break;\n          (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n            \"jpeg:%s\",filename);\n          if (image->compression == JPEG2000Compression)\n            (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n              \"j2k:%s\",filename);\n          jpeg_image=ReadImage(read_info,exception);\n          if (jpeg_image != (Image *) NULL)\n            {\n              ResetImagePropertyIterator(image);\n              property=GetNextImageProperty(image);\n              while (property != (const char *) NULL)\n              {\n                (void) SetImageProperty(jpeg_image,property,\n                  GetImageProperty(image,property,exception),exception);\n                property=GetNextImageProperty(image);\n              }\n              AppendImageToList(&images,jpeg_image);\n            }\n          (void) RelinquishUniqueFileResource(filename);\n        }\n        read_info=DestroyImageInfo(read_info);\n        if (stream_info->offsets != (ssize_t *) NULL)\n          stream_info->offsets=(ssize_t *)\n            RelinquishMagickMemory(stream_info->offsets);\n        stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n        if (info.scale != (Quantum *) NULL)\n          info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n        if (graymap != (int *) NULL)\n          graymap=(int *) RelinquishMagickMemory(graymap);\n        if (bluemap != (int *) NULL)\n          bluemap=(int *) RelinquishMagickMemory(bluemap);\n        if (greenmap != (int *) NULL)\n          greenmap=(int *) RelinquishMagickMemory(greenmap);\n        if (redmap != (int *) NULL)\n          redmap=(int *) RelinquishMagickMemory(redmap);\n        image=DestroyImageList(image);\n        return(GetFirstImageInList(images));\n      }\n    if (info.depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))\n      {\n        QuantumAny\n          range;\n\n        /*\n          Compute pixel scaling table.\n        */\n        length=(size_t) (GetQuantumRange(info.depth)+1);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\n        if (info.scale != (Quantum *) NULL)\n          info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n        info.scale=(Quantum *) AcquireQuantumMemory(MagickMax(length,256),\n          sizeof(*info.scale));\n        if (info.scale == (Quantum *) NULL)\n          ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(info.scale,0,MagickMax(length,256)*\n          sizeof(*info.scale));\n        range=GetQuantumRange(info.depth);\n        for (i=0; i <= (ssize_t) GetQuantumRange(info.depth); i++)\n          info.scale[i]=ScaleAnyToQuantum((size_t) i,range);\n      }\n    if (image->compression == RLECompression)\n      {\n        unsigned int\n          tag;\n\n        /*\n          Read RLE offset table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n        }\n        tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n          ReadBlobLSBShort(image);\n        (void) tag;\n        length=(size_t) ReadBlobLSBLong(image);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\n        stream_info->offset_count=length >> 2;\n        if (stream_info->offset_count != 0)\n          {\n            if (stream_info->offsets != (ssize_t *) NULL)\n              stream_info->offsets=(ssize_t *)\n                RelinquishMagickMemory(stream_info->offsets);\n            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n              stream_info->offset_count,sizeof(*stream_info->offsets));\n            if (stream_info->offsets == (ssize_t *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            {\n              stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n              if (EOFBlob(image) != MagickFalse)\n                break;\n            }\n            offset=TellBlob(image)+8;\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]+=offset;\n          }\n      }\n    for (scene=0; scene < (ssize_t) number_scenes; scene++)\n    {\n      image->columns=(size_t) width;\n      image->rows=(size_t) height;\n      image->depth=info.depth;\n      status=SetImageExtent(image,image->columns,image->rows,exception);\n      if (status == MagickFalse)\n        break;\n      image->colorspace=RGBColorspace;\n      (void) SetImageBackgroundColor(image,exception);\n      if ((image->colormap == (PixelInfo *) NULL) &&\n          (info.samples_per_pixel == 1))\n        {\n          int\n            index;\n\n          size_t\n            one;\n\n          one=1;\n          if (colors == 0)\n            colors=one << info.depth;\n          if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n            ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n          if (redmap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=redmap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].red=(MagickRealType) index;\n            }\n          if (greenmap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=greenmap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].green=(MagickRealType) index;\n            }\n          if (bluemap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=bluemap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].blue=(MagickRealType) index;\n            }\n          if (graymap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=graymap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].red=(MagickRealType) index;\n              image->colormap[i].green=(MagickRealType) index;\n              image->colormap[i].blue=(MagickRealType) index;\n            }\n        }\n      if (image->compression == RLECompression)\n        {\n          unsigned int\n            tag;\n\n          /*\n            Read RLE segment table.\n          */\n          for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          {\n            int\n              c;\n\n            c=ReadBlobByte(image);\n            if (c == EOF)\n              break;\n          }\n          tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n            ReadBlobLSBShort(image);\n          stream_info->remaining=(size_t) ReadBlobLSBLong(image);\n          if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||\n              (EOFBlob(image) != MagickFalse))\n            {\n              if (stream_info->offsets != (ssize_t *) NULL)\n                stream_info->offsets=(ssize_t *)\n                  RelinquishMagickMemory(stream_info->offsets);\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n            }\n          stream_info->count=0;\n          stream_info->segment_count=ReadBlobLSBLong(image);\n          for (i=0; i < 15; i++)\n            stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          stream_info->remaining-=64;\n          if (stream_info->segment_count > 1)\n            {\n              info.bytes_per_pixel=1;\n              info.depth=8;\n              if (stream_info->offset_count > 0)\n                (void) SeekBlob(image,(MagickOffsetType)\n                  stream_info->offsets[0]+stream_info->segments[0],SEEK_SET);\n            }\n        }\n      if ((info.samples_per_pixel > 1) && (image->interlace == PlaneInterlace))\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *q;\n\n          ssize_t\n            y;\n\n          /*\n            Convert Planar RGB DCM Medical image to pixel packets.\n          */\n          for (i=0; i < (ssize_t) info.samples_per_pixel; i++)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                switch ((int) i)\n                {\n                  case 0:\n                  {\n                    SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 1:\n                  {\n                    SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 2:\n                  {\n                    SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 3:\n                  {\n                    SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  default:\n                    break;\n                }\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        }\n      else\n        {\n          const char\n            *option;\n\n          /*\n            Convert DCM Medical image to pixel packets.\n          */\n          option=GetImageOption(image_info,\"dcm:display-range\");\n          if (option != (const char *) NULL)\n            {\n              if (LocaleCompare(option,\"reset\") == 0)\n                info.window_width=0;\n            }\n          option=GetImageOption(image_info,\"dcm:window\");\n          if (option != (char *) NULL)\n            {\n              GeometryInfo\n                geometry_info;\n\n              MagickStatusType\n                flags;\n\n              flags=ParseGeometry(option,&geometry_info);\n              if (flags & RhoValue)\n                info.window_center=geometry_info.rho;\n              if (flags & SigmaValue)\n                info.window_width=geometry_info.sigma;\n              info.rescale=MagickTrue;\n            }\n          option=GetImageOption(image_info,\"dcm:rescale\");\n          if (option != (char *) NULL)\n            info.rescale=IsStringTrue(option);\n          if ((info.window_center != 0) && (info.window_width == 0))\n            info.window_width=info.window_center;\n          status=ReadDCMPixels(image,&info,stream_info,MagickTrue,exception);\n          if ((status != MagickFalse) && (stream_info->segment_count > 1))\n            {\n              if (stream_info->offset_count > 0)\n                (void) SeekBlob(image,(MagickOffsetType)\n                  stream_info->offsets[0]+stream_info->segments[1],SEEK_SET);\n              (void) ReadDCMPixels(image,&info,stream_info,MagickFalse,\n                exception);\n            }\n        }\n      if (SetImageGray(image,exception) != MagickFalse)\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n      /*\n        Proceed to next image.\n      */\n      if (image_info->number_scenes != 0)\n        if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n          break;\n      if (scene < (ssize_t) (number_scenes-1))\n        {\n          /*\n            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image,exception);\n          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n              status=MagickFalse;\n              break;\n            }\n          image=SyncNextImageInList(image);\n          status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n            GetBlobSize(image));\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (TellBlob(image) < (MagickOffsetType) GetBlobSize(image))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n     }\n  }\n  /*\n    Free resources.\n  */\n  if (stream_info->offsets != (ssize_t *) NULL)\n    stream_info->offsets=(ssize_t *)\n      RelinquishMagickMemory(stream_info->offsets);\n  stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (info.scale != (Quantum *) NULL)\n    info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n  if (graymap != (int *) NULL)\n    graymap=(int *) RelinquishMagickMemory(graymap);\n  if (bluemap != (int *) NULL)\n    bluemap=(int *) RelinquishMagickMemory(bluemap);\n  if (greenmap != (int *) NULL)\n    greenmap=(int *) RelinquishMagickMemory(greenmap);\n  if (redmap != (int *) NULL)\n    redmap=(int *) RelinquishMagickMemory(redmap);\n  if (image == (Image *) NULL)\n    return(image);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143503,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowDCMException(exception,message) \\\n{ \\\n  if (info.scale != (Quantum *) NULL) \\\n    info.scale=(Quantum *) RelinquishMagickMemory(info.scale); \\\n  if (data != (unsigned char *) NULL) \\\n    data=(unsigned char *) RelinquishMagickMemory(data); \\\n  if (graymap != (int *) NULL) \\\n    graymap=(int *) RelinquishMagickMemory(graymap); \\\n  if (bluemap != (int *) NULL) \\\n    bluemap=(int *) RelinquishMagickMemory(bluemap); \\\n  if (greenmap != (int *) NULL) \\\n    greenmap=(int *) RelinquishMagickMemory(greenmap); \\\n  if (redmap != (int *) NULL) \\\n    redmap=(int *) RelinquishMagickMemory(redmap); \\\n  if (stream_info->offsets != (ssize_t *) NULL) \\\n    stream_info->offsets=(ssize_t *) RelinquishMagickMemory( \\\n      stream_info->offsets); \\\n  if (stream_info != (DCMStreamInfo *) NULL) \\\n    stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    explicit_vr[MagickPathExtent],\n    implicit_vr[MagickPathExtent],\n    magick[MagickPathExtent],\n    photometric[MagickPathExtent];\n\n  DCMInfo\n    info;\n\n  DCMStreamInfo\n    *stream_info;\n\n  Image\n    *image;\n\n  int\n    *bluemap,\n    datum,\n    *greenmap,\n    *graymap,\n    *redmap;\n\n  MagickBooleanType\n    explicit_file,\n    explicit_retry,\n    use_explicit;\n\n  MagickOffsetType\n    offset;\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    colors,\n    height,\n    length,\n    number_scenes,\n    quantum,\n    status,\n    width;\n\n  ssize_t\n    count,\n    scene;\n\n  unsigned char\n    *data;\n\n  unsigned short\n    group,\n    element;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=8UL;\n  image->endian=LSBEndian;\n  /*\n    Read DCM preamble.\n  */\n  (void) memset(&info,0,sizeof(info));\n  data=(unsigned char *) NULL;\n  graymap=(int *) NULL;\n  redmap=(int *) NULL;\n  greenmap=(int *) NULL;\n  bluemap=(int *) NULL;\n  stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));\n  if (stream_info == (DCMStreamInfo *) NULL)\n    ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memset(stream_info,0,sizeof(*stream_info));\n  count=ReadBlob(image,128,(unsigned char *) magick);\n  if (count != 128)\n    ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  if ((count != 4) || (LocaleNCompare(magick,\"DICM\",4) != 0))\n    {\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  /*\n    Read DCM Medical image.\n  */\n  (void) CopyMagickString(photometric,\"MONOCHROME1 \",MagickPathExtent);\n  info.bits_allocated=8;\n  info.bytes_per_pixel=1;\n  info.depth=8;\n  info.mask=0xffff;\n  info.max_value=255UL;\n  info.samples_per_pixel=1;\n  info.signed_data=(~0UL);\n  info.rescale_slope=1.0;\n  data=(unsigned char *) NULL;\n  element=0;\n  explicit_vr[2]='\\0';\n  explicit_file=MagickFalse;\n  colors=0;\n  redmap=(int *) NULL;\n  greenmap=(int *) NULL;\n  bluemap=(int *) NULL;\n  graymap=(int *) NULL;\n  height=0;\n  number_scenes=1;\n  use_explicit=MagickFalse;\n  explicit_retry = MagickFalse;\n  width=0;\n  while (TellBlob(image) < (MagickOffsetType) GetBlobSize(image))\n  {\n    for (group=0; (group != 0x7FE0) || (element != 0x0010) ; )\n    {\n      /*\n        Read a group.\n      */\n      image->offset=(ssize_t) TellBlob(image);\n      group=ReadBlobLSBShort(image);\n      element=ReadBlobLSBShort(image);\n      if ((group == 0xfffc) && (element == 0xfffc))\n        break;\n      if ((group != 0x0002) && (image->endian == MSBEndian))\n        {\n          group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));\n          element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));\n        }\n      quantum=0;\n      /*\n        Find corresponding VR for this group and element.\n      */\n      for (i=0; dicom_info[i].group < 0xffff; i++)\n        if ((group == dicom_info[i].group) &&\n            (element == dicom_info[i].element))\n          break;\n      (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);\n      count=ReadBlob(image,2,(unsigned char *) explicit_vr);\n      if (count != 2)\n        ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n      /*\n        Check for \"explicitness\", but meta-file headers always explicit.\n      */\n      if ((explicit_file == MagickFalse) && (group != 0x0002))\n        explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&\n          (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?\n          MagickTrue : MagickFalse;\n      use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||\n        (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;\n      if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,\"xs\",2) == 0))\n        (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);\n      if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,\"!!\",2) == 0))\n        {\n          offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);\n          if (offset < 0)\n            ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n          quantum=4;\n        }\n      else\n        {\n          /*\n            Assume explicit type.\n          */\n          quantum=2;\n          if ((strncmp(explicit_vr,\"OB\",2) == 0) ||\n              (strncmp(explicit_vr,\"UN\",2) == 0) ||\n              (strncmp(explicit_vr,\"OW\",2) == 0) ||\n              (strncmp(explicit_vr,\"SQ\",2) == 0))\n            {\n              (void) ReadBlobLSBShort(image);\n              quantum=4;\n            }\n        }\n      datum=0;\n      if (quantum == 4)\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedLong(image);\n          else\n            datum=ReadBlobSignedLong(image);\n        }\n      else\n        if (quantum == 2)\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedShort(image);\n            else\n              datum=ReadBlobSignedShort(image);\n          }\n      quantum=0;\n      length=1;\n      if (datum != 0)\n        {\n          if ((strncmp(implicit_vr,\"OW\",2) == 0) ||\n              (strncmp(implicit_vr,\"SS\",2) == 0) ||\n              (strncmp(implicit_vr,\"US\",2) == 0))\n            quantum=2;\n          else\n            if ((strncmp(implicit_vr,\"FL\",2) == 0) ||\n                (strncmp(implicit_vr,\"OF\",2) == 0) ||\n                (strncmp(implicit_vr,\"SL\",2) == 0) ||\n                (strncmp(implicit_vr,\"UL\",2) == 0))\n              quantum=4;\n            else\n              if (strncmp(implicit_vr,\"FD\",2) == 0)\n                quantum=8;\n              else\n                quantum=1;\n          if (datum != ~0)\n            length=(size_t) datum/quantum;\n          else\n            {\n              /*\n                Sequence and item of undefined length.\n              */\n              quantum=0;\n              length=0;\n            }\n        }\n      if (image_info->verbose != MagickFalse)\n        {\n          /*\n            Display Dicom info.\n          */\n          if (use_explicit == MagickFalse)\n            explicit_vr[0]='\\0';\n          for (i=0; dicom_info[i].description != (char *) NULL; i++)\n            if ((group == dicom_info[i].group) &&\n                (element == dicom_info[i].element))\n              break;\n          (void) FormatLocaleFile(stdout,\"0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)\",\n            (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,\n            (unsigned long) group,(unsigned long) element);\n          if (dicom_info[i].description != (char *) NULL)\n            (void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);\n          (void) FormatLocaleFile(stdout,\": \");\n        }\n      if ((group == 0x7FE0) && (element == 0x0010))\n        {\n          if (image_info->verbose != MagickFalse)\n            (void) FormatLocaleFile(stdout,\"\\n\");\n          break;\n        }\n      /*\n        Allocate space and read an array.\n      */\n      data=(unsigned char *) NULL;\n      if ((length == 1) && (quantum == 1))\n        datum=ReadBlobByte(image);\n      else\n        if ((length == 1) && (quantum == 2))\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedShort(image);\n            else\n              datum=ReadBlobSignedShort(image);\n          }\n        else\n          if ((length == 1) && (quantum == 4))\n            {\n              if (group == 0x0002)\n                datum=ReadBlobLSBSignedLong(image);\n              else\n                datum=ReadBlobSignedLong(image);\n            }\n          else\n            if ((quantum != 0) && (length != 0))\n              {\n                if (length > (size_t) GetBlobSize(image))\n                  ThrowDCMException(CorruptImageError,\n                    \"InsufficientImageDataInFile\");\n                if (~length >= 1)\n                  data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*\n                    sizeof(*data));\n                if (data == (unsigned char *) NULL)\n                  ThrowDCMException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n                count=ReadBlob(image,(size_t) quantum*length,data);\n                if (count != (ssize_t) (quantum*length))\n                  {\n                    if (image_info->verbose != MagickFalse)\n                      (void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"\n                        \"length=%d group=%d\\n\",(int) count,(int) quantum,(int)\n                        length,(int) group);\n                     ThrowDCMException(CorruptImageError,\n                       \"InsufficientImageDataInFile\");\n                  }\n                data[length*quantum]='\\0';\n              }\n      if ((((unsigned int) group << 16) | element) == 0xFFFEE0DD)\n        {\n          if (data != (unsigned char *) NULL)\n            data=(unsigned char *) RelinquishMagickMemory(data);\n          continue;\n        }\n      switch (group)\n      {\n        case 0x0002:\n        {\n          switch (element)\n          {\n            case 0x0010:\n            {\n              char\n                transfer_syntax[MagickPathExtent];\n\n              /*\n                Transfer Syntax.\n              */\n              if ((datum == 0) && (explicit_retry == MagickFalse))\n                {\n                  explicit_retry=MagickTrue;\n                  (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);\n                  group=0;\n                  element=0;\n                  if (image_info->verbose != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\n                      \"Corrupted image - trying explicit format\\n\");\n                  break;\n                }\n              *transfer_syntax='\\0';\n              if (data != (unsigned char *) NULL)\n                (void) CopyMagickString(transfer_syntax,(char *) data,\n                  MagickPathExtent);\n              if (image_info->verbose != MagickFalse)\n                (void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",\n                  (const char *) transfer_syntax);\n              if (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)\n                {\n                  int\n                    subtype,\n                    type;\n\n                  type=1;\n                  subtype=0;\n                  if (strlen(transfer_syntax) > 17)\n                    {\n                      count=(ssize_t) sscanf(transfer_syntax+17,\".%d.%d\",&type,\n                        &subtype);\n                      if (count < 1)\n                        ThrowDCMException(CorruptImageError,\n                          \"ImproperImageHeader\");\n                    }\n                  switch (type)\n                  {\n                    case 1:\n                    {\n                      image->endian=LSBEndian;\n                      break;\n                    }\n                    case 2:\n                    {\n                      image->endian=MSBEndian;\n                      break;\n                    }\n                    case 4:\n                    {\n                      if ((subtype >= 80) && (subtype <= 81))\n                        image->compression=JPEGCompression;\n                      else\n                        if ((subtype >= 90) && (subtype <= 93))\n                          image->compression=JPEG2000Compression;\n                        else\n                          image->compression=JPEGCompression;\n                      break;\n                    }\n                    case 5:\n                    {\n                      image->compression=RLECompression;\n                      break;\n                    }\n                  }\n                }\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        case 0x0028:\n        {\n          switch (element)\n          {\n            case 0x0002:\n            {\n              /*\n                Samples per pixel.\n              */\n              info.samples_per_pixel=(size_t) datum;\n              if ((info.samples_per_pixel == 0) || (info.samples_per_pixel > 4))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n              break;\n            }\n            case 0x0004:\n            {\n              /*\n                Photometric interpretation.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)\n                photometric[i]=(char) data[i];\n              photometric[i]='\\0';\n              info.polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?\n                MagickTrue : MagickFalse;\n              break;\n            }\n            case 0x0006:\n            {\n              /*\n                Planar configuration.\n              */\n              if (datum == 1)\n                image->interlace=PlaneInterlace;\n              break;\n            }\n            case 0x0008:\n            {\n              /*\n                Number of frames.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              number_scenes=StringToUnsignedLong((char *) data);\n              break;\n            }\n            case 0x0010:\n            {\n              /*\n                Image rows.\n              */\n              height=(size_t) datum;\n              break;\n            }\n            case 0x0011:\n            {\n              /*\n                Image columns.\n              */\n              width=(size_t) datum;\n              break;\n            }\n            case 0x0100:\n            {\n              /*\n                Bits allocated.\n              */\n              info.bits_allocated=(size_t) datum;\n              info.bytes_per_pixel=1;\n              if (datum > 8)\n                info.bytes_per_pixel=2;\n              info.depth=info.bits_allocated;\n              if ((info.depth == 0) || (info.depth > 32))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n              info.max_value=(1UL << info.bits_allocated)-1;\n              image->depth=info.depth;\n              break;\n            }\n            case 0x0101:\n            {\n              /*\n                Bits stored.\n              */\n              info.significant_bits=(size_t) datum;\n              info.bytes_per_pixel=1;\n              if (info.significant_bits > 8)\n                info.bytes_per_pixel=2;\n              info.depth=info.significant_bits;\n              if ((info.depth == 0) || (info.depth > 16))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n              info.max_value=(1UL << info.significant_bits)-1;\n              info.mask=(size_t) GetQuantumRange(info.significant_bits);\n              image->depth=info.depth;\n              break;\n            }\n            case 0x0102:\n            {\n              /*\n                High bit.\n              */\n              break;\n            }\n            case 0x0103:\n            {\n              /*\n                Pixel representation.\n              */\n              info.signed_data=(size_t) datum;\n              break;\n            }\n            case 0x1050:\n            {\n              /*\n                Visible pixel range: center.\n              */\n              if (data != (unsigned char *) NULL)\n                info.window_center=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1051:\n            {\n              /*\n                Visible pixel range: width.\n              */\n              if (data != (unsigned char *) NULL)\n                info.window_width=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1052:\n            {\n              /*\n                Rescale intercept\n              */\n              if (data != (unsigned char *) NULL)\n                info.rescale_intercept=StringToDouble((char *) data,\n                  (char **) NULL);\n              break;\n            }\n            case 0x1053:\n            {\n              /*\n                Rescale slope\n              */\n              if (data != (unsigned char *) NULL)\n                info.rescale_slope=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1200:\n            case 0x3006:\n            {\n              /*\n                Populate graymap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/info.bytes_per_pixel);\n              datum=(int) colors;\n              if (graymap != (int *) NULL)\n                graymap=(int *) RelinquishMagickMemory(graymap);\n              graymap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*graymap));\n              if (graymap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(graymap,0,MagickMax(colors,65536)*\n                sizeof(*graymap));\n              for (i=0; i < (ssize_t) colors; i++)\n                if (info.bytes_per_pixel == 1)\n                  graymap[i]=(int) data[i];\n                else\n                  graymap[i]=(int) ((short *) data)[i];\n              break;\n            }\n            case 0x1201:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate redmap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/2);\n              datum=(int) colors;\n              if (redmap != (int *) NULL)\n                redmap=(int *) RelinquishMagickMemory(redmap);\n              redmap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*redmap));\n              if (redmap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(redmap,0,MagickMax(colors,65536)*\n                sizeof(*redmap));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                redmap[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            case 0x1202:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate greenmap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/2);\n              datum=(int) colors;\n              if (greenmap != (int *) NULL)\n                greenmap=(int *) RelinquishMagickMemory(greenmap);\n              greenmap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*greenmap));\n              if (greenmap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(greenmap,0,MagickMax(colors,65536)*\n                sizeof(*greenmap));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                greenmap[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            case 0x1203:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate bluemap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/2);\n              datum=(int) colors;\n              if (bluemap != (int *) NULL)\n                bluemap=(int *) RelinquishMagickMemory(bluemap);\n              bluemap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*bluemap));\n              if (bluemap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(bluemap,0,MagickMax(colors,65536)*\n                sizeof(*bluemap));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                bluemap[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        case 0x2050:\n        {\n          switch (element)\n          {\n            case 0x0020:\n            {\n              if ((data != (unsigned char *) NULL) &&\n                  (strncmp((char *) data,\"INVERSE\",7) == 0))\n                info.polarity=MagickTrue;\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        default:\n          break;\n      }\n      if (data != (unsigned char *) NULL)\n        {\n          char\n            *attribute;\n\n          for (i=0; dicom_info[i].description != (char *) NULL; i++)\n            if ((group == dicom_info[i].group) &&\n                (element == dicom_info[i].element))\n              break;\n          if (dicom_info[i].description != (char *) NULL)\n            {\n              attribute=AcquireString(\"dcm:\");\n              (void) ConcatenateString(&attribute,dicom_info[i].description);\n              for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n                if (isprint((int) data[i]) == MagickFalse)\n                  break;\n              if ((i == (ssize_t) length) || (length > 4))\n                {\n                  (void) SubstituteString(&attribute,\" \",\"\");\n                  (void) SetImageProperty(image,attribute,(char *) data,\n                    exception);\n                }\n              attribute=DestroyString(attribute);\n            }\n        }\n      if (image_info->verbose != MagickFalse)\n        {\n          if (data == (unsigned char *) NULL)\n            (void) FormatLocaleFile(stdout,\"%d\\n\",datum);\n          else\n            {\n              /*\n                Display group data.\n              */\n              for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n                if (isprint((int) data[i]) == MagickFalse)\n                  break;\n              if ((i != (ssize_t) length) && (length <= 4))\n                {\n                  ssize_t\n                    j;\n\n                  datum=0;\n                  for (j=(ssize_t) length-1; j >= 0; j--)\n                    datum=(256*datum+data[j]);\n                  (void) FormatLocaleFile(stdout,\"%d\",datum);\n                }\n              else\n                for (i=0; i < (ssize_t) length; i++)\n                  if (isprint((int) data[i]) != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\"%c\",data[i]);\n                  else\n                    (void) FormatLocaleFile(stdout,\"%c\",'.');\n              (void) FormatLocaleFile(stdout,\"\\n\");\n            }\n        }\n      if (data != (unsigned char *) NULL)\n        data=(unsigned char *) RelinquishMagickMemory(data);\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n    }\n    if ((group == 0xfffc) && (element == 0xfffc))\n      {\n        Image\n          *last;\n\n        last=RemoveLastImageFromList(&image);\n        if (last != (Image *) NULL)\n          last=DestroyImage(last);\n        break;\n      }\n    if ((width == 0) || (height == 0))\n      ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    if (info.signed_data == 0xffff)\n      info.signed_data=(size_t) (info.significant_bits == 16 ? 1 : 0);\n    if ((image->compression == JPEGCompression) ||\n        (image->compression == JPEG2000Compression))\n      {\n        Image\n          *images;\n\n        ImageInfo\n          *read_info;\n\n        int\n          c;\n\n        /*\n          Read offset table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        (void) (((ssize_t) ReadBlobLSBShort(image) << 16) |\n          ReadBlobLSBShort(image));\n        length=(size_t) ReadBlobLSBLong(image);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\n        stream_info->offset_count=length >> 2;\n        if (stream_info->offset_count != 0)\n          {\n            if (stream_info->offsets != (ssize_t *) NULL)\n              stream_info->offsets=(ssize_t *) RelinquishMagickMemory(\n                stream_info->offsets);\n            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n              stream_info->offset_count,sizeof(*stream_info->offsets));\n            if (stream_info->offsets == (ssize_t *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n            offset=TellBlob(image);\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]+=offset;\n          }\n        /*\n          Handle non-native image formats.\n        */\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        images=NewImageList();\n        for (scene=0; scene < (ssize_t) number_scenes; scene++)\n        {\n          char\n            filename[MagickPathExtent];\n\n          const char\n            *property;\n\n          FILE\n            *file;\n\n          Image\n            *jpeg_image;\n\n          int\n            unique_file;\n\n          unsigned int\n            tag;\n\n           tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n             ReadBlobLSBShort(image);\n           length=(size_t) ReadBlobLSBLong(image);\n          if (length > (size_t) GetBlobSize(image))\n            ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\n           if (tag == 0xFFFEE0DD)\n             break; /* sequence delimiter tag */\n           if (tag != 0xFFFEE000)\n            {\n              read_info=DestroyImageInfo(read_info);\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n            }\n          file=(FILE *) NULL;\n          unique_file=AcquireUniqueFileResource(filename);\n          if (unique_file != -1)\n            file=fdopen(unique_file,\"wb\");\n          if (file == (FILE *) NULL)\n            {\n              (void) RelinquishUniqueFileResource(filename);\n              ThrowFileException(exception,FileOpenError,\n                \"UnableToCreateTemporaryFile\",filename);\n              break;\n            }\n          for (c=EOF; length != 0; length--)\n          {\n            c=ReadBlobByte(image);\n            if (c == EOF)\n              {\n                ThrowFileException(exception,CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n                break;\n              }\n            if (fputc(c,file) != c)\n              break;\n          }\n          (void) fclose(file);\n          if (c == EOF)\n            break;\n          (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n            \"jpeg:%s\",filename);\n          if (image->compression == JPEG2000Compression)\n            (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n              \"j2k:%s\",filename);\n          jpeg_image=ReadImage(read_info,exception);\n          if (jpeg_image != (Image *) NULL)\n            {\n              ResetImagePropertyIterator(image);\n              property=GetNextImageProperty(image);\n              while (property != (const char *) NULL)\n              {\n                (void) SetImageProperty(jpeg_image,property,\n                  GetImageProperty(image,property,exception),exception);\n                property=GetNextImageProperty(image);\n              }\n              AppendImageToList(&images,jpeg_image);\n            }\n          (void) RelinquishUniqueFileResource(filename);\n        }\n        read_info=DestroyImageInfo(read_info);\n        if (stream_info->offsets != (ssize_t *) NULL)\n          stream_info->offsets=(ssize_t *)\n            RelinquishMagickMemory(stream_info->offsets);\n        stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n        if (info.scale != (Quantum *) NULL)\n          info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n        if (graymap != (int *) NULL)\n          graymap=(int *) RelinquishMagickMemory(graymap);\n        if (bluemap != (int *) NULL)\n          bluemap=(int *) RelinquishMagickMemory(bluemap);\n        if (greenmap != (int *) NULL)\n          greenmap=(int *) RelinquishMagickMemory(greenmap);\n        if (redmap != (int *) NULL)\n          redmap=(int *) RelinquishMagickMemory(redmap);\n        image=DestroyImageList(image);\n        return(GetFirstImageInList(images));\n      }\n    if (info.depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))\n      {\n        QuantumAny\n          range;\n\n        /*\n          Compute pixel scaling table.\n        */\n        length=(size_t) (GetQuantumRange(info.depth)+1);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\n        if (info.scale != (Quantum *) NULL)\n          info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n        info.scale=(Quantum *) AcquireQuantumMemory(MagickMax(length,256),\n          sizeof(*info.scale));\n        if (info.scale == (Quantum *) NULL)\n          ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(info.scale,0,MagickMax(length,256)*\n          sizeof(*info.scale));\n        range=GetQuantumRange(info.depth);\n        for (i=0; i <= (ssize_t) GetQuantumRange(info.depth); i++)\n          info.scale[i]=ScaleAnyToQuantum((size_t) i,range);\n      }\n    if (image->compression == RLECompression)\n      {\n        unsigned int\n          tag;\n\n        /*\n          Read RLE offset table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n        }\n        tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n          ReadBlobLSBShort(image);\n        (void) tag;\n        length=(size_t) ReadBlobLSBLong(image);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\n        stream_info->offset_count=length >> 2;\n        if (stream_info->offset_count != 0)\n          {\n            if (stream_info->offsets != (ssize_t *) NULL)\n              stream_info->offsets=(ssize_t *)\n                RelinquishMagickMemory(stream_info->offsets);\n            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n              stream_info->offset_count,sizeof(*stream_info->offsets));\n            if (stream_info->offsets == (ssize_t *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            {\n              stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n              if (EOFBlob(image) != MagickFalse)\n                break;\n            }\n            offset=TellBlob(image)+8;\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]+=offset;\n          }\n      }\n    for (scene=0; scene < (ssize_t) number_scenes; scene++)\n    {\n      image->columns=(size_t) width;\n      image->rows=(size_t) height;\n      image->depth=info.depth;\n      status=SetImageExtent(image,image->columns,image->rows,exception);\n      if (status == MagickFalse)\n        break;\n      image->colorspace=RGBColorspace;\n      (void) SetImageBackgroundColor(image,exception);\n      if ((image->colormap == (PixelInfo *) NULL) &&\n          (info.samples_per_pixel == 1))\n        {\n          int\n            index;\n\n          size_t\n            one;\n\n          one=1;\n          if (colors == 0)\n            colors=one << info.depth;\n          if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n            ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n          if (redmap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=redmap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].red=(MagickRealType) index;\n            }\n          if (greenmap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=greenmap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].green=(MagickRealType) index;\n            }\n          if (bluemap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=bluemap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].blue=(MagickRealType) index;\n            }\n          if (graymap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=graymap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].red=(MagickRealType) index;\n              image->colormap[i].green=(MagickRealType) index;\n              image->colormap[i].blue=(MagickRealType) index;\n            }\n        }\n      if (image->compression == RLECompression)\n        {\n          unsigned int\n            tag;\n\n          /*\n            Read RLE segment table.\n          */\n          for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          {\n            int\n              c;\n\n            c=ReadBlobByte(image);\n            if (c == EOF)\n              break;\n          }\n          tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n            ReadBlobLSBShort(image);\n          stream_info->remaining=(size_t) ReadBlobLSBLong(image);\n          if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||\n              (EOFBlob(image) != MagickFalse))\n            {\n              if (stream_info->offsets != (ssize_t *) NULL)\n                stream_info->offsets=(ssize_t *)\n                  RelinquishMagickMemory(stream_info->offsets);\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n            }\n          stream_info->count=0;\n          stream_info->segment_count=ReadBlobLSBLong(image);\n          for (i=0; i < 15; i++)\n            stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          stream_info->remaining-=64;\n          if (stream_info->segment_count > 1)\n            {\n              info.bytes_per_pixel=1;\n              info.depth=8;\n              if (stream_info->offset_count > 0)\n                (void) SeekBlob(image,(MagickOffsetType)\n                  stream_info->offsets[0]+stream_info->segments[0],SEEK_SET);\n            }\n        }\n      if ((info.samples_per_pixel > 1) && (image->interlace == PlaneInterlace))\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *q;\n\n          ssize_t\n            y;\n\n          /*\n            Convert Planar RGB DCM Medical image to pixel packets.\n          */\n          for (i=0; i < (ssize_t) info.samples_per_pixel; i++)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                switch ((int) i)\n                {\n                  case 0:\n                  {\n                    SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 1:\n                  {\n                    SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 2:\n                  {\n                    SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 3:\n                  {\n                    SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  default:\n                    break;\n                }\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        }\n      else\n        {\n          const char\n            *option;\n\n          /*\n            Convert DCM Medical image to pixel packets.\n          */\n          option=GetImageOption(image_info,\"dcm:display-range\");\n          if (option != (const char *) NULL)\n            {\n              if (LocaleCompare(option,\"reset\") == 0)\n                info.window_width=0;\n            }\n          option=GetImageOption(image_info,\"dcm:window\");\n          if (option != (char *) NULL)\n            {\n              GeometryInfo\n                geometry_info;\n\n              MagickStatusType\n                flags;\n\n              flags=ParseGeometry(option,&geometry_info);\n              if (flags & RhoValue)\n                info.window_center=geometry_info.rho;\n              if (flags & SigmaValue)\n                info.window_width=geometry_info.sigma;\n              info.rescale=MagickTrue;\n            }\n          option=GetImageOption(image_info,\"dcm:rescale\");\n          if (option != (char *) NULL)\n            info.rescale=IsStringTrue(option);\n          if ((info.window_center != 0) && (info.window_width == 0))\n            info.window_width=info.window_center;\n          status=ReadDCMPixels(image,&info,stream_info,MagickTrue,exception);\n          if ((status != MagickFalse) && (stream_info->segment_count > 1))\n            {\n              if (stream_info->offset_count > 0)\n                (void) SeekBlob(image,(MagickOffsetType)\n                  stream_info->offsets[0]+stream_info->segments[1],SEEK_SET);\n              (void) ReadDCMPixels(image,&info,stream_info,MagickFalse,\n                exception);\n            }\n        }\n      if (SetImageGray(image,exception) != MagickFalse)\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n      /*\n        Proceed to next image.\n      */\n      if (image_info->number_scenes != 0)\n        if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n          break;\n      if (scene < (ssize_t) (number_scenes-1))\n        {\n          /*\n            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image,exception);\n          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n              status=MagickFalse;\n              break;\n            }\n          image=SyncNextImageInList(image);\n          status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n            GetBlobSize(image));\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (TellBlob(image) < (MagickOffsetType) GetBlobSize(image))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n     }\n  }\n  /*\n    Free resources.\n  */\n  if (stream_info->offsets != (ssize_t *) NULL)\n    stream_info->offsets=(ssize_t *)\n      RelinquishMagickMemory(stream_info->offsets);\n  stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (info.scale != (Quantum *) NULL)\n    info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n  if (graymap != (int *) NULL)\n    graymap=(int *) RelinquishMagickMemory(graymap);\n  if (bluemap != (int *) NULL)\n    bluemap=(int *) RelinquishMagickMemory(bluemap);\n  if (greenmap != (int *) NULL)\n    greenmap=(int *) RelinquishMagickMemory(greenmap);\n  if (redmap != (int *) NULL)\n    redmap=(int *) RelinquishMagickMemory(redmap);\n  if (image == (Image *) NULL)\n    return(image);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143504,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "AppProto AppLayerProtoDetectGetProto(AppLayerProtoDetectThreadCtx *tctx,\n                                     Flow *f,\n                                     uint8_t *buf, uint32_t buflen,\n                                     uint8_t ipproto, uint8_t direction)\n{\n    SCEnter();\n    SCLogDebug(\"buflen %u for %s direction\", buflen,\n             (direction & STREAM_TOSERVER) ? \"toserver\" : \"toclient\");\n \n     AppProto alproto = ALPROTO_UNKNOWN;\n \n     if (!FLOW_IS_PM_DONE(f, direction)) {\n         AppProto pm_results[ALPROTO_MAX];\n        uint16_t pm_matches = AppLayerProtoDetectPMGetProto(tctx, f,\n                                                   buf, buflen,\n                                                   direction,\n                                                   ipproto,\n                                                    pm_results);\n         if (pm_matches > 0) {\n             alproto = pm_results[0];\n            goto end;\n         }\n     }\n \n    if (!FLOW_IS_PP_DONE(f, direction)) {\n        alproto = AppLayerProtoDetectPPGetProto(f, buf, buflen,\n                                                ipproto, direction);\n        if (alproto != ALPROTO_UNKNOWN)\n            goto end;\n    }\n\n    /* Look if flow can be found in expectation list */\n    if (!FLOW_IS_PE_DONE(f, direction)) {\n        alproto = AppLayerProtoDetectPEGetProto(f, ipproto, direction);\n     }\n \n  end:\n     SCReturnUInt(alproto);\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143511,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "AppProto AppLayerProtoDetectGetProto(AppLayerProtoDetectThreadCtx *tctx,\n                                     Flow *f,\n                                     uint8_t *buf, uint32_t buflen,\n                                     uint8_t ipproto, uint8_t direction)\n{\n    SCEnter();\n    SCLogDebug(\"buflen %u for %s direction\", buflen,\n             (direction & STREAM_TOSERVER) ? \"toserver\" : \"toclient\");\n \n     AppProto alproto = ALPROTO_UNKNOWN;\n    AppProto pm_alproto = ALPROTO_UNKNOWN;\n \n     if (!FLOW_IS_PM_DONE(f, direction)) {\n         AppProto pm_results[ALPROTO_MAX];\n        uint16_t pm_matches = AppLayerProtoDetectPMGetProto(tctx, f,\n                                                   buf, buflen,\n                                                   direction,\n                                                   ipproto,\n                                                    pm_results);\n         if (pm_matches > 0) {\n             alproto = pm_results[0];\n\n            /* HACK: if detected protocol is dcerpc/udp, we run PP as well\n             * to avoid misdetecting DNS as DCERPC. */\n            if (!(ipproto == IPPROTO_UDP && alproto == ALPROTO_DCERPC))\n                goto end;\n\n            pm_alproto = alproto;\n\n            /* fall through */\n         }\n     }\n \n    if (!FLOW_IS_PP_DONE(f, direction)) {\n        alproto = AppLayerProtoDetectPPGetProto(f, buf, buflen,\n                                                ipproto, direction);\n        if (alproto != ALPROTO_UNKNOWN)\n            goto end;\n    }\n\n    /* Look if flow can be found in expectation list */\n    if (!FLOW_IS_PE_DONE(f, direction)) {\n        alproto = AppLayerProtoDetectPEGetProto(f, ipproto, direction);\n     }\n \n  end:\n    if (alproto == ALPROTO_UNKNOWN)\n        alproto = pm_alproto;\n\n     SCReturnUInt(alproto);\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143512,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "GURL URLFixerUpper::FixupRelativeFile(const FilePath& base_dir,\n                                      const FilePath& text) {\n  FilePath old_cur_directory;\n  if (!base_dir.empty()) {\n    file_util::GetCurrentDirectory(&old_cur_directory);\n    file_util::SetCurrentDirectory(base_dir);\n  }\n\n  FilePath::StringType trimmed;\n   PrepareStringForFileOps(text, &trimmed);\n \n   bool is_file = true;\n   FilePath full_path;\n  if (!ValidPathForFile(trimmed, &full_path)) {\n#if defined(OS_WIN)\n    std::wstring unescaped = UTF8ToWide(UnescapeURLComponent(\n        WideToUTF8(trimmed),\n        UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS));\n#elif defined(OS_POSIX)\n    std::string unescaped = UnescapeURLComponent(\n        trimmed,\n        UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS);\n#endif\n\n    if (!ValidPathForFile(unescaped, &full_path))\n      is_file = false;\n  }\n\n  if (!base_dir.empty())\n    file_util::SetCurrentDirectory(old_cur_directory);\n\n  if (is_file) {\n    GURL file_url = net::FilePathToFileURL(full_path);\n    if (file_url.is_valid())\n      return GURL(UTF16ToUTF8(net::FormatUrl(file_url, std::string(),\n          net::kFormatUrlOmitUsernamePassword, UnescapeRule::NORMAL, NULL,\n          NULL, NULL)));\n  }\n\n#if defined(OS_WIN)\n  std::string text_utf8 = WideToUTF8(text.value());\n#elif defined(OS_POSIX)\n  std::string text_utf8 = text.value();\n#endif\n  return FixupURL(text_utf8, std::string());\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143531,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "GURL URLFixerUpper::FixupRelativeFile(const FilePath& base_dir,\n                                      const FilePath& text) {\n  FilePath old_cur_directory;\n  if (!base_dir.empty()) {\n    file_util::GetCurrentDirectory(&old_cur_directory);\n    file_util::SetCurrentDirectory(base_dir);\n  }\n\n  FilePath::StringType trimmed;\n   PrepareStringForFileOps(text, &trimmed);\n \n   bool is_file = true;\n  // Avoid recognizing definite non-file URLs as file paths.\n  GURL gurl(trimmed);\n  if (gurl.is_valid() && gurl.IsStandard())\n    is_file = false;\n   FilePath full_path;\n  if (is_file && !ValidPathForFile(trimmed, &full_path)) {\n#if defined(OS_WIN)\n    std::wstring unescaped = UTF8ToWide(UnescapeURLComponent(\n        WideToUTF8(trimmed),\n        UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS));\n#elif defined(OS_POSIX)\n    std::string unescaped = UnescapeURLComponent(\n        trimmed,\n        UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS);\n#endif\n\n    if (!ValidPathForFile(unescaped, &full_path))\n      is_file = false;\n  }\n\n  if (!base_dir.empty())\n    file_util::SetCurrentDirectory(old_cur_directory);\n\n  if (is_file) {\n    GURL file_url = net::FilePathToFileURL(full_path);\n    if (file_url.is_valid())\n      return GURL(UTF16ToUTF8(net::FormatUrl(file_url, std::string(),\n          net::kFormatUrlOmitUsernamePassword, UnescapeRule::NORMAL, NULL,\n          NULL, NULL)));\n  }\n\n#if defined(OS_WIN)\n  std::string text_utf8 = WideToUTF8(text.value());\n#elif defined(OS_POSIX)\n  std::string text_utf8 = text.value();\n#endif\n  return FixupURL(text_utf8, std::string());\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143532,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool Extension::InitFromValue(const DictionaryValue& source, int flags,\n                              std::string* error) {\n  URLPattern::ParseOption parse_strictness =\n      (flags & STRICT_ERROR_CHECKS ? URLPattern::PARSE_STRICT\n                                   : URLPattern::PARSE_LENIENT);\n\n  if (source.HasKey(keys::kPublicKey)) {\n    std::string public_key_bytes;\n    if (!source.GetString(keys::kPublicKey,\n                          &public_key_) ||\n        !ParsePEMKeyBytes(public_key_,\n                          &public_key_bytes) ||\n        !GenerateId(public_key_bytes, &id_)) {\n      *error = errors::kInvalidKey;\n      return false;\n    }\n  } else if (flags & REQUIRE_KEY) {\n    *error = errors::kInvalidKey;\n    return false;\n  } else {\n    id_ = Extension::GenerateIdForPath(path());\n    if (id_.empty()) {\n      NOTREACHED() << \"Could not create ID from path.\";\n      return false;\n    }\n  }\n\n  manifest_value_.reset(source.DeepCopy());\n\n  extension_url_ = Extension::GetBaseURLFromExtensionId(id());\n\n  std::string version_str;\n  if (!source.GetString(keys::kVersion, &version_str)) {\n    *error = errors::kInvalidVersion;\n    return false;\n  }\n  version_.reset(Version::GetVersionFromString(version_str));\n  if (!version_.get() ||\n      version_->components().size() > 4) {\n    *error = errors::kInvalidVersion;\n    return false;\n  }\n\n  string16 localized_name;\n  if (!source.GetString(keys::kName, &localized_name)) {\n    *error = errors::kInvalidName;\n    return false;\n  }\n  base::i18n::AdjustStringForLocaleDirection(&localized_name);\n  name_ = UTF16ToUTF8(localized_name);\n\n  if (source.HasKey(keys::kDescription)) {\n    if (!source.GetString(keys::kDescription,\n                          &description_)) {\n      *error = errors::kInvalidDescription;\n      return false;\n    }\n  }\n\n  if (source.HasKey(keys::kHomepageURL)) {\n    std::string tmp;\n    if (!source.GetString(keys::kHomepageURL, &tmp)) {\n      *error = ExtensionErrorUtils::FormatErrorMessage(\n          errors::kInvalidHomepageURL, \"\");\n       return false;\n     }\n     homepage_url_ = GURL(tmp);\n    if (!homepage_url_.is_valid()) {\n       *error = ExtensionErrorUtils::FormatErrorMessage(\n           errors::kInvalidHomepageURL, tmp);\n       return false;\n    }\n  }\n\n  if (source.HasKey(keys::kUpdateURL)) {\n    std::string tmp;\n    if (!source.GetString(keys::kUpdateURL, &tmp)) {\n      *error = ExtensionErrorUtils::FormatErrorMessage(\n          errors::kInvalidUpdateURL, \"\");\n      return false;\n    }\n    update_url_ = GURL(tmp);\n    if (!update_url_.is_valid() ||\n        update_url_.has_ref()) {\n      *error = ExtensionErrorUtils::FormatErrorMessage(\n          errors::kInvalidUpdateURL, tmp);\n      return false;\n    }\n  }\n\n  if (source.HasKey(keys::kMinimumChromeVersion)) {\n    std::string minimum_version_string;\n    if (!source.GetString(keys::kMinimumChromeVersion,\n                          &minimum_version_string)) {\n      *error = errors::kInvalidMinimumChromeVersion;\n      return false;\n    }\n\n    scoped_ptr<Version> minimum_version(\n        Version::GetVersionFromString(minimum_version_string));\n    if (!minimum_version.get()) {\n      *error = errors::kInvalidMinimumChromeVersion;\n      return false;\n    }\n\n    chrome::VersionInfo current_version_info;\n    if (!current_version_info.is_valid()) {\n      NOTREACHED();\n      return false;\n    }\n\n    scoped_ptr<Version> current_version(\n        Version::GetVersionFromString(current_version_info.Version()));\n    if (!current_version.get()) {\n      DCHECK(false);\n      return false;\n    }\n\n    if (current_version->CompareTo(*minimum_version) < 0) {\n      *error = ExtensionErrorUtils::FormatErrorMessage(\n          errors::kChromeVersionTooLow,\n          l10n_util::GetStringUTF8(IDS_PRODUCT_NAME),\n          minimum_version_string);\n      return false;\n    }\n  }\n\n  source.GetBoolean(keys::kConvertedFromUserScript,\n                    &converted_from_user_script_);\n\n  if (source.HasKey(keys::kIcons)) {\n    DictionaryValue* icons_value = NULL;\n    if (!source.GetDictionary(keys::kIcons, &icons_value)) {\n      *error = errors::kInvalidIcons;\n      return false;\n    }\n\n    for (size_t i = 0; i < arraysize(kIconSizes); ++i) {\n      std::string key = base::IntToString(kIconSizes[i]);\n      if (icons_value->HasKey(key)) {\n        std::string icon_path;\n        if (!icons_value->GetString(key, &icon_path)) {\n          *error = ExtensionErrorUtils::FormatErrorMessage(\n              errors::kInvalidIconPath, key);\n          return false;\n        }\n\n        if (!icon_path.empty() && icon_path[0] == '/')\n          icon_path = icon_path.substr(1);\n\n        if (icon_path.empty()) {\n          *error = ExtensionErrorUtils::FormatErrorMessage(\n              errors::kInvalidIconPath, key);\n          return false;\n        }\n\n        icons_.Add(kIconSizes[i], icon_path);\n      }\n    }\n  }\n\n  is_theme_ = false;\n  if (source.HasKey(keys::kTheme)) {\n    if (ContainsNonThemeKeys(source)) {\n      *error = errors::kThemesCannotContainExtensions;\n      return false;\n    }\n\n    DictionaryValue* theme_value = NULL;\n    if (!source.GetDictionary(keys::kTheme, &theme_value)) {\n      *error = errors::kInvalidTheme;\n      return false;\n    }\n    is_theme_ = true;\n\n    DictionaryValue* images_value = NULL;\n    if (theme_value->GetDictionary(keys::kThemeImages, &images_value)) {\n      for (DictionaryValue::key_iterator iter = images_value->begin_keys();\n           iter != images_value->end_keys(); ++iter) {\n        std::string val;\n        if (!images_value->GetString(*iter, &val)) {\n          *error = errors::kInvalidThemeImages;\n          return false;\n        }\n      }\n      theme_images_.reset(images_value->DeepCopy());\n    }\n\n    DictionaryValue* colors_value = NULL;\n    if (theme_value->GetDictionary(keys::kThemeColors, &colors_value)) {\n      for (DictionaryValue::key_iterator iter = colors_value->begin_keys();\n           iter != colors_value->end_keys(); ++iter) {\n        ListValue* color_list = NULL;\n        double alpha = 0.0;\n        int color = 0;\n        if (!colors_value->GetListWithoutPathExpansion(*iter, &color_list) ||\n            ((color_list->GetSize() != 3) &&\n             ((color_list->GetSize() != 4) ||\n              !color_list->GetDouble(3, &alpha))) ||\n            !color_list->GetInteger(0, &color) ||\n            !color_list->GetInteger(1, &color) ||\n            !color_list->GetInteger(2, &color)) {\n          *error = errors::kInvalidThemeColors;\n          return false;\n        }\n      }\n      theme_colors_.reset(colors_value->DeepCopy());\n    }\n\n    DictionaryValue* tints_value = NULL;\n    if (theme_value->GetDictionary(keys::kThemeTints, &tints_value)) {\n      for (DictionaryValue::key_iterator iter = tints_value->begin_keys();\n           iter != tints_value->end_keys(); ++iter) {\n        ListValue* tint_list = NULL;\n        double v = 0.0;\n        if (!tints_value->GetListWithoutPathExpansion(*iter, &tint_list) ||\n            tint_list->GetSize() != 3 ||\n            !tint_list->GetDouble(0, &v) ||\n            !tint_list->GetDouble(1, &v) ||\n            !tint_list->GetDouble(2, &v)) {\n          *error = errors::kInvalidThemeTints;\n          return false;\n        }\n      }\n      theme_tints_.reset(tints_value->DeepCopy());\n    }\n\n    DictionaryValue* display_properties_value = NULL;\n    if (theme_value->GetDictionary(keys::kThemeDisplayProperties,\n        &display_properties_value)) {\n      theme_display_properties_.reset(\n          display_properties_value->DeepCopy());\n    }\n\n    return true;\n  }\n\n  if (source.HasKey(keys::kPlugins)) {\n    ListValue* list_value = NULL;\n    if (!source.GetList(keys::kPlugins, &list_value)) {\n      *error = errors::kInvalidPlugins;\n      return false;\n    }\n\n    for (size_t i = 0; i < list_value->GetSize(); ++i) {\n      DictionaryValue* plugin_value = NULL;\n      std::string path_str;\n      bool is_public = false;\n\n      if (!list_value->GetDictionary(i, &plugin_value)) {\n        *error = errors::kInvalidPlugins;\n        return false;\n      }\n\n      if (!plugin_value->GetString(keys::kPluginsPath, &path_str)) {\n        *error = ExtensionErrorUtils::FormatErrorMessage(\n            errors::kInvalidPluginsPath, base::IntToString(i));\n        return false;\n      }\n\n      if (plugin_value->HasKey(keys::kPluginsPublic)) {\n        if (!plugin_value->GetBoolean(keys::kPluginsPublic, &is_public)) {\n          *error = ExtensionErrorUtils::FormatErrorMessage(\n              errors::kInvalidPluginsPublic, base::IntToString(i));\n          return false;\n        }\n      }\n\n#if !defined(OS_CHROMEOS)\n      plugins_.push_back(PluginInfo());\n      plugins_.back().path = path().AppendASCII(path_str);\n      plugins_.back().is_public = is_public;\n#endif\n    }\n  }\n\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kEnableExperimentalExtensionApis) &&\n      source.HasKey(keys::kNaClModules)) {\n    ListValue* list_value = NULL;\n    if (!source.GetList(keys::kNaClModules, &list_value)) {\n      *error = errors::kInvalidNaClModules;\n      return false;\n    }\n\n    for (size_t i = 0; i < list_value->GetSize(); ++i) {\n      DictionaryValue* module_value = NULL;\n      std::string path_str;\n      std::string mime_type;\n\n      if (!list_value->GetDictionary(i, &module_value)) {\n        *error = errors::kInvalidNaClModules;\n        return false;\n      }\n\n      if (!module_value->GetString(keys::kNaClModulesPath, &path_str)) {\n        *error = ExtensionErrorUtils::FormatErrorMessage(\n            errors::kInvalidNaClModulesPath, base::IntToString(i));\n        return false;\n      }\n\n      if (!module_value->GetString(keys::kNaClModulesMIMEType, &mime_type)) {\n        *error = ExtensionErrorUtils::FormatErrorMessage(\n            errors::kInvalidNaClModulesMIMEType, base::IntToString(i));\n        return false;\n      }\n\n      nacl_modules_.push_back(NaClModuleInfo());\n      nacl_modules_.back().url = GetResourceURL(path_str);\n      nacl_modules_.back().mime_type = mime_type;\n    }\n  }\n\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kEnableExperimentalExtensionApis) &&\n      source.HasKey(keys::kToolstrips)) {\n    ListValue* list_value = NULL;\n    if (!source.GetList(keys::kToolstrips, &list_value)) {\n      *error = errors::kInvalidToolstrips;\n      return false;\n    }\n\n    for (size_t i = 0; i < list_value->GetSize(); ++i) {\n      GURL toolstrip;\n      DictionaryValue* toolstrip_value = NULL;\n      std::string toolstrip_path;\n      if (list_value->GetString(i, &toolstrip_path)) {\n        toolstrip = GetResourceURL(toolstrip_path);\n      } else if (list_value->GetDictionary(i, &toolstrip_value)) {\n        if (!toolstrip_value->GetString(keys::kToolstripPath,\n                                        &toolstrip_path)) {\n          *error = ExtensionErrorUtils::FormatErrorMessage(\n              errors::kInvalidToolstrip, base::IntToString(i));\n          return false;\n        }\n        toolstrip = GetResourceURL(toolstrip_path);\n      } else {\n        *error = ExtensionErrorUtils::FormatErrorMessage(\n            errors::kInvalidToolstrip, base::IntToString(i));\n        return false;\n      }\n      toolstrips_.push_back(toolstrip);\n    }\n  }\n\n  if (source.HasKey(keys::kContentScripts)) {\n    ListValue* list_value;\n    if (!source.GetList(keys::kContentScripts, &list_value)) {\n      *error = errors::kInvalidContentScriptsList;\n      return false;\n    }\n\n    for (size_t i = 0; i < list_value->GetSize(); ++i) {\n      DictionaryValue* content_script = NULL;\n      if (!list_value->GetDictionary(i, &content_script)) {\n        *error = ExtensionErrorUtils::FormatErrorMessage(\n            errors::kInvalidContentScript, base::IntToString(i));\n        return false;\n      }\n\n      UserScript script;\n      if (!LoadUserScriptHelper(content_script, i, flags, error, &script))\n        return false;  // Failed to parse script context definition.\n      script.set_extension_id(id());\n      if (converted_from_user_script_) {\n        script.set_emulate_greasemonkey(true);\n        script.set_match_all_frames(true);  // Greasemonkey matches all frames.\n      }\n      content_scripts_.push_back(script);\n    }\n  }\n\n  DictionaryValue* page_action_value = NULL;\n\n  if (source.HasKey(keys::kPageActions)) {\n    ListValue* list_value = NULL;\n    if (!source.GetList(keys::kPageActions, &list_value)) {\n      *error = errors::kInvalidPageActionsList;\n      return false;\n    }\n\n    size_t list_value_length = list_value->GetSize();\n\n    if (list_value_length == 0u) {\n    } else if (list_value_length == 1u) {\n      if (!list_value->GetDictionary(0, &page_action_value)) {\n        *error = errors::kInvalidPageAction;\n        return false;\n      }\n    } else {  // list_value_length > 1u.\n      *error = errors::kInvalidPageActionsListSize;\n      return false;\n    }\n  } else if (source.HasKey(keys::kPageAction)) {\n    if (!source.GetDictionary(keys::kPageAction, &page_action_value)) {\n      *error = errors::kInvalidPageAction;\n      return false;\n    }\n  }\n\n  if (page_action_value) {\n    page_action_.reset(\n        LoadExtensionActionHelper(page_action_value, error));\n    if (!page_action_.get())\n      return false;  // Failed to parse page action definition.\n  }\n\n  if (source.HasKey(keys::kBrowserAction)) {\n    DictionaryValue* browser_action_value = NULL;\n    if (!source.GetDictionary(keys::kBrowserAction, &browser_action_value)) {\n      *error = errors::kInvalidBrowserAction;\n      return false;\n    }\n\n    browser_action_.reset(\n        LoadExtensionActionHelper(browser_action_value, error));\n    if (!browser_action_.get())\n      return false;  // Failed to parse browser action definition.\n  }\n\n  if (source.HasKey(keys::kFileBrowserHandlers)) {\n    ListValue* file_browser_handlers_value = NULL;\n    if (!source.GetList(keys::kFileBrowserHandlers,\n                              &file_browser_handlers_value)) {\n      *error = errors::kInvalidFileBrowserHandler;\n      return false;\n    }\n\n    file_browser_handlers_.reset(\n        LoadFileBrowserHandlers(file_browser_handlers_value, error));\n    if (!file_browser_handlers_.get())\n      return false;  // Failed to parse file browser actions definition.\n  }\n\n  if (!LoadIsApp(manifest_value_.get(), error) ||\n      !LoadExtent(manifest_value_.get(), keys::kWebURLs,\n                  &extent_,\n                  errors::kInvalidWebURLs, errors::kInvalidWebURL,\n                  parse_strictness, error) ||\n      !EnsureNotHybridApp(manifest_value_.get(), error) ||\n      !LoadLaunchURL(manifest_value_.get(), error) ||\n      !LoadLaunchContainer(manifest_value_.get(), error) ||\n      !LoadAppIsolation(manifest_value_.get(), error)) {\n    return false;\n  }\n\n  if (source.HasKey(keys::kOptionsPage)) {\n    std::string options_str;\n    if (!source.GetString(keys::kOptionsPage, &options_str)) {\n      *error = errors::kInvalidOptionsPage;\n      return false;\n    }\n\n    if (is_hosted_app()) {\n      GURL options_url(options_str);\n      if (!options_url.is_valid() ||\n          !(options_url.SchemeIs(\"http\") || options_url.SchemeIs(\"https\"))) {\n        *error = errors::kInvalidOptionsPageInHostedApp;\n        return false;\n      }\n      options_url_ = options_url;\n    } else {\n      GURL absolute(options_str);\n      if (absolute.is_valid()) {\n        *error = errors::kInvalidOptionsPageExpectUrlInPackage;\n        return false;\n      }\n      options_url_ = GetResourceURL(options_str);\n      if (!options_url_.is_valid()) {\n        *error = errors::kInvalidOptionsPage;\n        return false;\n      }\n    }\n  }\n\n  if (source.HasKey(keys::kPermissions)) {\n    ListValue* permissions = NULL;\n    if (!source.GetList(keys::kPermissions, &permissions)) {\n      *error = ExtensionErrorUtils::FormatErrorMessage(\n          errors::kInvalidPermissions, \"\");\n      return false;\n    }\n\n    for (size_t i = 0; i < permissions->GetSize(); ++i) {\n      std::string permission_str;\n      if (!permissions->GetString(i, &permission_str)) {\n        *error = ExtensionErrorUtils::FormatErrorMessage(\n            errors::kInvalidPermission, base::IntToString(i));\n        return false;\n      }\n\n      if (!IsComponentOnlyPermission(permission_str)\n#ifndef NDEBUG\n           && !CommandLine::ForCurrentProcess()->HasSwitch(\n                 switches::kExposePrivateExtensionApi)\n#endif\n          ) {\n        continue;\n      }\n\n      if (permission_str == kOldUnlimitedStoragePermission)\n        permission_str = kUnlimitedStoragePermission;\n\n      if (web_extent().is_empty() || location() == Extension::COMPONENT) {\n        if (IsAPIPermission(permission_str)) {\n          if (permission_str == Extension::kExperimentalPermission &&\n              !CommandLine::ForCurrentProcess()->HasSwitch(\n                switches::kEnableExperimentalExtensionApis) &&\n              location() != Extension::COMPONENT) {\n            *error = errors::kExperimentalFlagRequired;\n            return false;\n          }\n          api_permissions_.insert(permission_str);\n          continue;\n        }\n      } else {\n        if (IsHostedAppPermission(permission_str)) {\n          api_permissions_.insert(permission_str);\n          continue;\n        }\n      }\n\n      URLPattern pattern = URLPattern(CanExecuteScriptEverywhere() ?\n          URLPattern::SCHEME_ALL : kValidHostPermissionSchemes);\n\n      URLPattern::ParseResult parse_result = pattern.Parse(permission_str,\n                                                           parse_strictness);\n      if (parse_result == URLPattern::PARSE_SUCCESS) {\n        if (!CanSpecifyHostPermission(pattern)) {\n          *error = ExtensionErrorUtils::FormatErrorMessage(\n              errors::kInvalidPermissionScheme, base::IntToString(i));\n          return false;\n        }\n\n        pattern.SetPath(\"/*\");\n\n        if (pattern.MatchesScheme(chrome::kFileScheme) &&\n            !CanExecuteScriptEverywhere()) {\n          wants_file_access_ = true;\n          if (!(flags & ALLOW_FILE_ACCESS))\n            pattern.set_valid_schemes(\n                pattern.valid_schemes() & ~URLPattern::SCHEME_FILE);\n        }\n\n        host_permissions_.push_back(pattern);\n      }\n\n    }\n  }\n\n  if (source.HasKey(keys::kBackground)) {\n    std::string background_str;\n    if (!source.GetString(keys::kBackground, &background_str)) {\n      *error = errors::kInvalidBackground;\n      return false;\n    }\n\n    if (is_hosted_app()) {\n      if (api_permissions_.find(kBackgroundPermission) ==\n          api_permissions_.end()) {\n        *error = errors::kBackgroundPermissionNeeded;\n        return false;\n      }\n      GURL bg_page(background_str);\n      if (!bg_page.is_valid()) {\n        *error = errors::kInvalidBackgroundInHostedApp;\n        return false;\n      }\n\n      if (!(bg_page.SchemeIs(\"https\") ||\n           (CommandLine::ForCurrentProcess()->HasSwitch(\n                switches::kAllowHTTPBackgroundPage) &&\n            bg_page.SchemeIs(\"http\")))) {\n        *error = errors::kInvalidBackgroundInHostedApp;\n        return false;\n      }\n      background_url_ = bg_page;\n    } else {\n      background_url_ = GetResourceURL(background_str);\n    }\n  }\n\n  if (source.HasKey(keys::kDefaultLocale)) {\n    if (!source.GetString(keys::kDefaultLocale, &default_locale_) ||\n        !l10n_util::IsValidLocaleSyntax(default_locale_)) {\n      *error = errors::kInvalidDefaultLocale;\n      return false;\n    }\n  }\n\n  if (source.HasKey(keys::kChromeURLOverrides)) {\n    DictionaryValue* overrides = NULL;\n    if (!source.GetDictionary(keys::kChromeURLOverrides, &overrides)) {\n      *error = errors::kInvalidChromeURLOverrides;\n      return false;\n    }\n\n    for (DictionaryValue::key_iterator iter = overrides->begin_keys();\n         iter != overrides->end_keys(); ++iter) {\n      std::string page = *iter;\n      std::string val;\n      if ((page != chrome::kChromeUINewTabHost &&\n#if defined(TOUCH_UI)\n           page != chrome::kChromeUIKeyboardHost &&\n#endif\n#if defined(OS_CHROMEOS)\n           page != chrome::kChromeUIActivationMessageHost &&\n#endif\n           page != chrome::kChromeUIBookmarksHost &&\n           page != chrome::kChromeUIHistoryHost) ||\n          !overrides->GetStringWithoutPathExpansion(*iter, &val)) {\n        *error = errors::kInvalidChromeURLOverrides;\n        return false;\n      }\n      chrome_url_overrides_[page] = GetResourceURL(val);\n    }\n\n    if (overrides->size() > 1) {\n      *error = errors::kMultipleOverrides;\n      return false;\n    }\n  }\n\n  if (source.HasKey(keys::kOmnibox)) {\n    if (!source.GetString(keys::kOmniboxKeyword, &omnibox_keyword_) ||\n        omnibox_keyword_.empty()) {\n      *error = errors::kInvalidOmniboxKeyword;\n      return false;\n    }\n  }\n\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kEnableExperimentalExtensionApis) &&\n      source.HasKey(keys::kContentSecurityPolicy)) {\n    std::string content_security_policy;\n    if (!source.GetString(keys::kContentSecurityPolicy,\n                          &content_security_policy)) {\n      *error = errors::kInvalidContentSecurityPolicy;\n      return false;\n    }\n    const char kBadCSPCharacters[] = {'\\r', '\\n', '\\0'};\n    if (content_security_policy.find_first_of(kBadCSPCharacters, 0,\n                                              arraysize(kBadCSPCharacters)) !=\n        std::string::npos) {\n      *error = errors::kInvalidContentSecurityPolicy;\n      return false;\n    }\n    content_security_policy_ = content_security_policy;\n  }\n\n  if (source.HasKey(keys::kDevToolsPage)) {\n    std::string devtools_str;\n    if (!source.GetString(keys::kDevToolsPage, &devtools_str)) {\n      *error = errors::kInvalidDevToolsPage;\n      return false;\n    }\n    if (!HasApiPermission(Extension::kExperimentalPermission)) {\n      *error = errors::kDevToolsExperimental;\n      return false;\n    }\n    devtools_url_ = GetResourceURL(devtools_str);\n  }\n\n  if (source.HasKey(keys::kSidebar)) {\n    DictionaryValue* sidebar_value = NULL;\n    if (!source.GetDictionary(keys::kSidebar, &sidebar_value)) {\n      *error = errors::kInvalidSidebar;\n      return false;\n    }\n    if (!HasApiPermission(Extension::kExperimentalPermission)) {\n      *error = errors::kSidebarExperimental;\n      return false;\n    }\n    sidebar_defaults_.reset(LoadExtensionSidebarDefaults(sidebar_value, error));\n    if (!sidebar_defaults_.get())\n      return false;  // Failed to parse sidebar definition.\n  }\n\n  if (source.HasKey(keys::kTts)) {\n    DictionaryValue* tts_dict = NULL;\n    if (!source.GetDictionary(keys::kTts, &tts_dict)) {\n      *error = errors::kInvalidTts;\n      return false;\n    }\n\n    if (tts_dict->HasKey(keys::kTtsVoices)) {\n      ListValue* tts_voices = NULL;\n      if (!tts_dict->GetList(keys::kTtsVoices, &tts_voices)) {\n        *error = errors::kInvalidTtsVoices;\n        return false;\n      }\n\n      for (size_t i = 0; i < tts_voices->GetSize(); i++) {\n        DictionaryValue* one_tts_voice = NULL;\n        if (!tts_voices->GetDictionary(i, &one_tts_voice)) {\n          *error = errors::kInvalidTtsVoices;\n          return false;\n        }\n\n        TtsVoice voice_data;\n        if (one_tts_voice->HasKey(keys::kTtsVoicesVoiceName)) {\n          if (!one_tts_voice->GetString(\n                  keys::kTtsVoicesVoiceName, &voice_data.voice_name)) {\n            *error = errors::kInvalidTtsVoicesVoiceName;\n            return false;\n          }\n        }\n        if (one_tts_voice->HasKey(keys::kTtsVoicesLocale)) {\n          if (!one_tts_voice->GetString(\n                  keys::kTtsVoicesLocale, &voice_data.locale) ||\n              !l10n_util::IsValidLocaleSyntax(voice_data.locale)) {\n            *error = errors::kInvalidTtsVoicesLocale;\n            return false;\n          }\n        }\n        if (one_tts_voice->HasKey(keys::kTtsVoicesGender)) {\n          if (!one_tts_voice->GetString(\n                  keys::kTtsVoicesGender, &voice_data.gender) ||\n              (voice_data.gender != keys::kTtsGenderMale &&\n               voice_data.gender != keys::kTtsGenderFemale)) {\n            *error = errors::kInvalidTtsVoicesGender;\n            return false;\n          }\n        }\n\n        tts_voices_.push_back(voice_data);\n      }\n    }\n  }\n\n  incognito_split_mode_ = is_app();\n  if (source.HasKey(keys::kIncognito)) {\n    std::string value;\n    if (!source.GetString(keys::kIncognito, &value)) {\n      *error = errors::kInvalidIncognitoBehavior;\n      return false;\n    }\n    if (value == values::kIncognitoSpanning) {\n      incognito_split_mode_ = false;\n    } else if (value == values::kIncognitoSplit) {\n      incognito_split_mode_ = true;\n    } else {\n      *error = errors::kInvalidIncognitoBehavior;\n      return false;\n    }\n  }\n\n  if (HasMultipleUISurfaces()) {\n    *error = errors::kOneUISurfaceOnly;\n    return false;\n  }\n\n  InitEffectiveHostPermissions();\n\n  DCHECK(source.Equals(manifest_value_.get()));\n\n  return true;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143535,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool Extension::InitFromValue(const DictionaryValue& source, int flags,\n                              std::string* error) {\n  URLPattern::ParseOption parse_strictness =\n      (flags & STRICT_ERROR_CHECKS ? URLPattern::PARSE_STRICT\n                                   : URLPattern::PARSE_LENIENT);\n\n  if (source.HasKey(keys::kPublicKey)) {\n    std::string public_key_bytes;\n    if (!source.GetString(keys::kPublicKey,\n                          &public_key_) ||\n        !ParsePEMKeyBytes(public_key_,\n                          &public_key_bytes) ||\n        !GenerateId(public_key_bytes, &id_)) {\n      *error = errors::kInvalidKey;\n      return false;\n    }\n  } else if (flags & REQUIRE_KEY) {\n    *error = errors::kInvalidKey;\n    return false;\n  } else {\n    id_ = Extension::GenerateIdForPath(path());\n    if (id_.empty()) {\n      NOTREACHED() << \"Could not create ID from path.\";\n      return false;\n    }\n  }\n\n  manifest_value_.reset(source.DeepCopy());\n\n  extension_url_ = Extension::GetBaseURLFromExtensionId(id());\n\n  std::string version_str;\n  if (!source.GetString(keys::kVersion, &version_str)) {\n    *error = errors::kInvalidVersion;\n    return false;\n  }\n  version_.reset(Version::GetVersionFromString(version_str));\n  if (!version_.get() ||\n      version_->components().size() > 4) {\n    *error = errors::kInvalidVersion;\n    return false;\n  }\n\n  string16 localized_name;\n  if (!source.GetString(keys::kName, &localized_name)) {\n    *error = errors::kInvalidName;\n    return false;\n  }\n  base::i18n::AdjustStringForLocaleDirection(&localized_name);\n  name_ = UTF16ToUTF8(localized_name);\n\n  if (source.HasKey(keys::kDescription)) {\n    if (!source.GetString(keys::kDescription,\n                          &description_)) {\n      *error = errors::kInvalidDescription;\n      return false;\n    }\n  }\n\n  if (source.HasKey(keys::kHomepageURL)) {\n    std::string tmp;\n    if (!source.GetString(keys::kHomepageURL, &tmp)) {\n      *error = ExtensionErrorUtils::FormatErrorMessage(\n          errors::kInvalidHomepageURL, \"\");\n       return false;\n     }\n     homepage_url_ = GURL(tmp);\n    if (!homepage_url_.is_valid() ||\n        (!homepage_url_.SchemeIs(\"http\") &&\n            !homepage_url_.SchemeIs(\"https\"))) {\n       *error = ExtensionErrorUtils::FormatErrorMessage(\n           errors::kInvalidHomepageURL, tmp);\n       return false;\n    }\n  }\n\n  if (source.HasKey(keys::kUpdateURL)) {\n    std::string tmp;\n    if (!source.GetString(keys::kUpdateURL, &tmp)) {\n      *error = ExtensionErrorUtils::FormatErrorMessage(\n          errors::kInvalidUpdateURL, \"\");\n      return false;\n    }\n    update_url_ = GURL(tmp);\n    if (!update_url_.is_valid() ||\n        update_url_.has_ref()) {\n      *error = ExtensionErrorUtils::FormatErrorMessage(\n          errors::kInvalidUpdateURL, tmp);\n      return false;\n    }\n  }\n\n  if (source.HasKey(keys::kMinimumChromeVersion)) {\n    std::string minimum_version_string;\n    if (!source.GetString(keys::kMinimumChromeVersion,\n                          &minimum_version_string)) {\n      *error = errors::kInvalidMinimumChromeVersion;\n      return false;\n    }\n\n    scoped_ptr<Version> minimum_version(\n        Version::GetVersionFromString(minimum_version_string));\n    if (!minimum_version.get()) {\n      *error = errors::kInvalidMinimumChromeVersion;\n      return false;\n    }\n\n    chrome::VersionInfo current_version_info;\n    if (!current_version_info.is_valid()) {\n      NOTREACHED();\n      return false;\n    }\n\n    scoped_ptr<Version> current_version(\n        Version::GetVersionFromString(current_version_info.Version()));\n    if (!current_version.get()) {\n      DCHECK(false);\n      return false;\n    }\n\n    if (current_version->CompareTo(*minimum_version) < 0) {\n      *error = ExtensionErrorUtils::FormatErrorMessage(\n          errors::kChromeVersionTooLow,\n          l10n_util::GetStringUTF8(IDS_PRODUCT_NAME),\n          minimum_version_string);\n      return false;\n    }\n  }\n\n  source.GetBoolean(keys::kConvertedFromUserScript,\n                    &converted_from_user_script_);\n\n  if (source.HasKey(keys::kIcons)) {\n    DictionaryValue* icons_value = NULL;\n    if (!source.GetDictionary(keys::kIcons, &icons_value)) {\n      *error = errors::kInvalidIcons;\n      return false;\n    }\n\n    for (size_t i = 0; i < arraysize(kIconSizes); ++i) {\n      std::string key = base::IntToString(kIconSizes[i]);\n      if (icons_value->HasKey(key)) {\n        std::string icon_path;\n        if (!icons_value->GetString(key, &icon_path)) {\n          *error = ExtensionErrorUtils::FormatErrorMessage(\n              errors::kInvalidIconPath, key);\n          return false;\n        }\n\n        if (!icon_path.empty() && icon_path[0] == '/')\n          icon_path = icon_path.substr(1);\n\n        if (icon_path.empty()) {\n          *error = ExtensionErrorUtils::FormatErrorMessage(\n              errors::kInvalidIconPath, key);\n          return false;\n        }\n\n        icons_.Add(kIconSizes[i], icon_path);\n      }\n    }\n  }\n\n  is_theme_ = false;\n  if (source.HasKey(keys::kTheme)) {\n    if (ContainsNonThemeKeys(source)) {\n      *error = errors::kThemesCannotContainExtensions;\n      return false;\n    }\n\n    DictionaryValue* theme_value = NULL;\n    if (!source.GetDictionary(keys::kTheme, &theme_value)) {\n      *error = errors::kInvalidTheme;\n      return false;\n    }\n    is_theme_ = true;\n\n    DictionaryValue* images_value = NULL;\n    if (theme_value->GetDictionary(keys::kThemeImages, &images_value)) {\n      for (DictionaryValue::key_iterator iter = images_value->begin_keys();\n           iter != images_value->end_keys(); ++iter) {\n        std::string val;\n        if (!images_value->GetString(*iter, &val)) {\n          *error = errors::kInvalidThemeImages;\n          return false;\n        }\n      }\n      theme_images_.reset(images_value->DeepCopy());\n    }\n\n    DictionaryValue* colors_value = NULL;\n    if (theme_value->GetDictionary(keys::kThemeColors, &colors_value)) {\n      for (DictionaryValue::key_iterator iter = colors_value->begin_keys();\n           iter != colors_value->end_keys(); ++iter) {\n        ListValue* color_list = NULL;\n        double alpha = 0.0;\n        int color = 0;\n        if (!colors_value->GetListWithoutPathExpansion(*iter, &color_list) ||\n            ((color_list->GetSize() != 3) &&\n             ((color_list->GetSize() != 4) ||\n              !color_list->GetDouble(3, &alpha))) ||\n            !color_list->GetInteger(0, &color) ||\n            !color_list->GetInteger(1, &color) ||\n            !color_list->GetInteger(2, &color)) {\n          *error = errors::kInvalidThemeColors;\n          return false;\n        }\n      }\n      theme_colors_.reset(colors_value->DeepCopy());\n    }\n\n    DictionaryValue* tints_value = NULL;\n    if (theme_value->GetDictionary(keys::kThemeTints, &tints_value)) {\n      for (DictionaryValue::key_iterator iter = tints_value->begin_keys();\n           iter != tints_value->end_keys(); ++iter) {\n        ListValue* tint_list = NULL;\n        double v = 0.0;\n        if (!tints_value->GetListWithoutPathExpansion(*iter, &tint_list) ||\n            tint_list->GetSize() != 3 ||\n            !tint_list->GetDouble(0, &v) ||\n            !tint_list->GetDouble(1, &v) ||\n            !tint_list->GetDouble(2, &v)) {\n          *error = errors::kInvalidThemeTints;\n          return false;\n        }\n      }\n      theme_tints_.reset(tints_value->DeepCopy());\n    }\n\n    DictionaryValue* display_properties_value = NULL;\n    if (theme_value->GetDictionary(keys::kThemeDisplayProperties,\n        &display_properties_value)) {\n      theme_display_properties_.reset(\n          display_properties_value->DeepCopy());\n    }\n\n    return true;\n  }\n\n  if (source.HasKey(keys::kPlugins)) {\n    ListValue* list_value = NULL;\n    if (!source.GetList(keys::kPlugins, &list_value)) {\n      *error = errors::kInvalidPlugins;\n      return false;\n    }\n\n    for (size_t i = 0; i < list_value->GetSize(); ++i) {\n      DictionaryValue* plugin_value = NULL;\n      std::string path_str;\n      bool is_public = false;\n\n      if (!list_value->GetDictionary(i, &plugin_value)) {\n        *error = errors::kInvalidPlugins;\n        return false;\n      }\n\n      if (!plugin_value->GetString(keys::kPluginsPath, &path_str)) {\n        *error = ExtensionErrorUtils::FormatErrorMessage(\n            errors::kInvalidPluginsPath, base::IntToString(i));\n        return false;\n      }\n\n      if (plugin_value->HasKey(keys::kPluginsPublic)) {\n        if (!plugin_value->GetBoolean(keys::kPluginsPublic, &is_public)) {\n          *error = ExtensionErrorUtils::FormatErrorMessage(\n              errors::kInvalidPluginsPublic, base::IntToString(i));\n          return false;\n        }\n      }\n\n#if !defined(OS_CHROMEOS)\n      plugins_.push_back(PluginInfo());\n      plugins_.back().path = path().AppendASCII(path_str);\n      plugins_.back().is_public = is_public;\n#endif\n    }\n  }\n\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kEnableExperimentalExtensionApis) &&\n      source.HasKey(keys::kNaClModules)) {\n    ListValue* list_value = NULL;\n    if (!source.GetList(keys::kNaClModules, &list_value)) {\n      *error = errors::kInvalidNaClModules;\n      return false;\n    }\n\n    for (size_t i = 0; i < list_value->GetSize(); ++i) {\n      DictionaryValue* module_value = NULL;\n      std::string path_str;\n      std::string mime_type;\n\n      if (!list_value->GetDictionary(i, &module_value)) {\n        *error = errors::kInvalidNaClModules;\n        return false;\n      }\n\n      if (!module_value->GetString(keys::kNaClModulesPath, &path_str)) {\n        *error = ExtensionErrorUtils::FormatErrorMessage(\n            errors::kInvalidNaClModulesPath, base::IntToString(i));\n        return false;\n      }\n\n      if (!module_value->GetString(keys::kNaClModulesMIMEType, &mime_type)) {\n        *error = ExtensionErrorUtils::FormatErrorMessage(\n            errors::kInvalidNaClModulesMIMEType, base::IntToString(i));\n        return false;\n      }\n\n      nacl_modules_.push_back(NaClModuleInfo());\n      nacl_modules_.back().url = GetResourceURL(path_str);\n      nacl_modules_.back().mime_type = mime_type;\n    }\n  }\n\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kEnableExperimentalExtensionApis) &&\n      source.HasKey(keys::kToolstrips)) {\n    ListValue* list_value = NULL;\n    if (!source.GetList(keys::kToolstrips, &list_value)) {\n      *error = errors::kInvalidToolstrips;\n      return false;\n    }\n\n    for (size_t i = 0; i < list_value->GetSize(); ++i) {\n      GURL toolstrip;\n      DictionaryValue* toolstrip_value = NULL;\n      std::string toolstrip_path;\n      if (list_value->GetString(i, &toolstrip_path)) {\n        toolstrip = GetResourceURL(toolstrip_path);\n      } else if (list_value->GetDictionary(i, &toolstrip_value)) {\n        if (!toolstrip_value->GetString(keys::kToolstripPath,\n                                        &toolstrip_path)) {\n          *error = ExtensionErrorUtils::FormatErrorMessage(\n              errors::kInvalidToolstrip, base::IntToString(i));\n          return false;\n        }\n        toolstrip = GetResourceURL(toolstrip_path);\n      } else {\n        *error = ExtensionErrorUtils::FormatErrorMessage(\n            errors::kInvalidToolstrip, base::IntToString(i));\n        return false;\n      }\n      toolstrips_.push_back(toolstrip);\n    }\n  }\n\n  if (source.HasKey(keys::kContentScripts)) {\n    ListValue* list_value;\n    if (!source.GetList(keys::kContentScripts, &list_value)) {\n      *error = errors::kInvalidContentScriptsList;\n      return false;\n    }\n\n    for (size_t i = 0; i < list_value->GetSize(); ++i) {\n      DictionaryValue* content_script = NULL;\n      if (!list_value->GetDictionary(i, &content_script)) {\n        *error = ExtensionErrorUtils::FormatErrorMessage(\n            errors::kInvalidContentScript, base::IntToString(i));\n        return false;\n      }\n\n      UserScript script;\n      if (!LoadUserScriptHelper(content_script, i, flags, error, &script))\n        return false;  // Failed to parse script context definition.\n      script.set_extension_id(id());\n      if (converted_from_user_script_) {\n        script.set_emulate_greasemonkey(true);\n        script.set_match_all_frames(true);  // Greasemonkey matches all frames.\n      }\n      content_scripts_.push_back(script);\n    }\n  }\n\n  DictionaryValue* page_action_value = NULL;\n\n  if (source.HasKey(keys::kPageActions)) {\n    ListValue* list_value = NULL;\n    if (!source.GetList(keys::kPageActions, &list_value)) {\n      *error = errors::kInvalidPageActionsList;\n      return false;\n    }\n\n    size_t list_value_length = list_value->GetSize();\n\n    if (list_value_length == 0u) {\n    } else if (list_value_length == 1u) {\n      if (!list_value->GetDictionary(0, &page_action_value)) {\n        *error = errors::kInvalidPageAction;\n        return false;\n      }\n    } else {  // list_value_length > 1u.\n      *error = errors::kInvalidPageActionsListSize;\n      return false;\n    }\n  } else if (source.HasKey(keys::kPageAction)) {\n    if (!source.GetDictionary(keys::kPageAction, &page_action_value)) {\n      *error = errors::kInvalidPageAction;\n      return false;\n    }\n  }\n\n  if (page_action_value) {\n    page_action_.reset(\n        LoadExtensionActionHelper(page_action_value, error));\n    if (!page_action_.get())\n      return false;  // Failed to parse page action definition.\n  }\n\n  if (source.HasKey(keys::kBrowserAction)) {\n    DictionaryValue* browser_action_value = NULL;\n    if (!source.GetDictionary(keys::kBrowserAction, &browser_action_value)) {\n      *error = errors::kInvalidBrowserAction;\n      return false;\n    }\n\n    browser_action_.reset(\n        LoadExtensionActionHelper(browser_action_value, error));\n    if (!browser_action_.get())\n      return false;  // Failed to parse browser action definition.\n  }\n\n  if (source.HasKey(keys::kFileBrowserHandlers)) {\n    ListValue* file_browser_handlers_value = NULL;\n    if (!source.GetList(keys::kFileBrowserHandlers,\n                              &file_browser_handlers_value)) {\n      *error = errors::kInvalidFileBrowserHandler;\n      return false;\n    }\n\n    file_browser_handlers_.reset(\n        LoadFileBrowserHandlers(file_browser_handlers_value, error));\n    if (!file_browser_handlers_.get())\n      return false;  // Failed to parse file browser actions definition.\n  }\n\n  if (!LoadIsApp(manifest_value_.get(), error) ||\n      !LoadExtent(manifest_value_.get(), keys::kWebURLs,\n                  &extent_,\n                  errors::kInvalidWebURLs, errors::kInvalidWebURL,\n                  parse_strictness, error) ||\n      !EnsureNotHybridApp(manifest_value_.get(), error) ||\n      !LoadLaunchURL(manifest_value_.get(), error) ||\n      !LoadLaunchContainer(manifest_value_.get(), error) ||\n      !LoadAppIsolation(manifest_value_.get(), error)) {\n    return false;\n  }\n\n  if (source.HasKey(keys::kOptionsPage)) {\n    std::string options_str;\n    if (!source.GetString(keys::kOptionsPage, &options_str)) {\n      *error = errors::kInvalidOptionsPage;\n      return false;\n    }\n\n    if (is_hosted_app()) {\n      GURL options_url(options_str);\n      if (!options_url.is_valid() ||\n          !(options_url.SchemeIs(\"http\") || options_url.SchemeIs(\"https\"))) {\n        *error = errors::kInvalidOptionsPageInHostedApp;\n        return false;\n      }\n      options_url_ = options_url;\n    } else {\n      GURL absolute(options_str);\n      if (absolute.is_valid()) {\n        *error = errors::kInvalidOptionsPageExpectUrlInPackage;\n        return false;\n      }\n      options_url_ = GetResourceURL(options_str);\n      if (!options_url_.is_valid()) {\n        *error = errors::kInvalidOptionsPage;\n        return false;\n      }\n    }\n  }\n\n  if (source.HasKey(keys::kPermissions)) {\n    ListValue* permissions = NULL;\n    if (!source.GetList(keys::kPermissions, &permissions)) {\n      *error = ExtensionErrorUtils::FormatErrorMessage(\n          errors::kInvalidPermissions, \"\");\n      return false;\n    }\n\n    for (size_t i = 0; i < permissions->GetSize(); ++i) {\n      std::string permission_str;\n      if (!permissions->GetString(i, &permission_str)) {\n        *error = ExtensionErrorUtils::FormatErrorMessage(\n            errors::kInvalidPermission, base::IntToString(i));\n        return false;\n      }\n\n      if (!IsComponentOnlyPermission(permission_str)\n#ifndef NDEBUG\n           && !CommandLine::ForCurrentProcess()->HasSwitch(\n                 switches::kExposePrivateExtensionApi)\n#endif\n          ) {\n        continue;\n      }\n\n      if (permission_str == kOldUnlimitedStoragePermission)\n        permission_str = kUnlimitedStoragePermission;\n\n      if (web_extent().is_empty() || location() == Extension::COMPONENT) {\n        if (IsAPIPermission(permission_str)) {\n          if (permission_str == Extension::kExperimentalPermission &&\n              !CommandLine::ForCurrentProcess()->HasSwitch(\n                switches::kEnableExperimentalExtensionApis) &&\n              location() != Extension::COMPONENT) {\n            *error = errors::kExperimentalFlagRequired;\n            return false;\n          }\n          api_permissions_.insert(permission_str);\n          continue;\n        }\n      } else {\n        if (IsHostedAppPermission(permission_str)) {\n          api_permissions_.insert(permission_str);\n          continue;\n        }\n      }\n\n      URLPattern pattern = URLPattern(CanExecuteScriptEverywhere() ?\n          URLPattern::SCHEME_ALL : kValidHostPermissionSchemes);\n\n      URLPattern::ParseResult parse_result = pattern.Parse(permission_str,\n                                                           parse_strictness);\n      if (parse_result == URLPattern::PARSE_SUCCESS) {\n        if (!CanSpecifyHostPermission(pattern)) {\n          *error = ExtensionErrorUtils::FormatErrorMessage(\n              errors::kInvalidPermissionScheme, base::IntToString(i));\n          return false;\n        }\n\n        pattern.SetPath(\"/*\");\n\n        if (pattern.MatchesScheme(chrome::kFileScheme) &&\n            !CanExecuteScriptEverywhere()) {\n          wants_file_access_ = true;\n          if (!(flags & ALLOW_FILE_ACCESS))\n            pattern.set_valid_schemes(\n                pattern.valid_schemes() & ~URLPattern::SCHEME_FILE);\n        }\n\n        host_permissions_.push_back(pattern);\n      }\n\n    }\n  }\n\n  if (source.HasKey(keys::kBackground)) {\n    std::string background_str;\n    if (!source.GetString(keys::kBackground, &background_str)) {\n      *error = errors::kInvalidBackground;\n      return false;\n    }\n\n    if (is_hosted_app()) {\n      if (api_permissions_.find(kBackgroundPermission) ==\n          api_permissions_.end()) {\n        *error = errors::kBackgroundPermissionNeeded;\n        return false;\n      }\n      GURL bg_page(background_str);\n      if (!bg_page.is_valid()) {\n        *error = errors::kInvalidBackgroundInHostedApp;\n        return false;\n      }\n\n      if (!(bg_page.SchemeIs(\"https\") ||\n           (CommandLine::ForCurrentProcess()->HasSwitch(\n                switches::kAllowHTTPBackgroundPage) &&\n            bg_page.SchemeIs(\"http\")))) {\n        *error = errors::kInvalidBackgroundInHostedApp;\n        return false;\n      }\n      background_url_ = bg_page;\n    } else {\n      background_url_ = GetResourceURL(background_str);\n    }\n  }\n\n  if (source.HasKey(keys::kDefaultLocale)) {\n    if (!source.GetString(keys::kDefaultLocale, &default_locale_) ||\n        !l10n_util::IsValidLocaleSyntax(default_locale_)) {\n      *error = errors::kInvalidDefaultLocale;\n      return false;\n    }\n  }\n\n  if (source.HasKey(keys::kChromeURLOverrides)) {\n    DictionaryValue* overrides = NULL;\n    if (!source.GetDictionary(keys::kChromeURLOverrides, &overrides)) {\n      *error = errors::kInvalidChromeURLOverrides;\n      return false;\n    }\n\n    for (DictionaryValue::key_iterator iter = overrides->begin_keys();\n         iter != overrides->end_keys(); ++iter) {\n      std::string page = *iter;\n      std::string val;\n      if ((page != chrome::kChromeUINewTabHost &&\n#if defined(TOUCH_UI)\n           page != chrome::kChromeUIKeyboardHost &&\n#endif\n#if defined(OS_CHROMEOS)\n           page != chrome::kChromeUIActivationMessageHost &&\n#endif\n           page != chrome::kChromeUIBookmarksHost &&\n           page != chrome::kChromeUIHistoryHost) ||\n          !overrides->GetStringWithoutPathExpansion(*iter, &val)) {\n        *error = errors::kInvalidChromeURLOverrides;\n        return false;\n      }\n      chrome_url_overrides_[page] = GetResourceURL(val);\n    }\n\n    if (overrides->size() > 1) {\n      *error = errors::kMultipleOverrides;\n      return false;\n    }\n  }\n\n  if (source.HasKey(keys::kOmnibox)) {\n    if (!source.GetString(keys::kOmniboxKeyword, &omnibox_keyword_) ||\n        omnibox_keyword_.empty()) {\n      *error = errors::kInvalidOmniboxKeyword;\n      return false;\n    }\n  }\n\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kEnableExperimentalExtensionApis) &&\n      source.HasKey(keys::kContentSecurityPolicy)) {\n    std::string content_security_policy;\n    if (!source.GetString(keys::kContentSecurityPolicy,\n                          &content_security_policy)) {\n      *error = errors::kInvalidContentSecurityPolicy;\n      return false;\n    }\n    const char kBadCSPCharacters[] = {'\\r', '\\n', '\\0'};\n    if (content_security_policy.find_first_of(kBadCSPCharacters, 0,\n                                              arraysize(kBadCSPCharacters)) !=\n        std::string::npos) {\n      *error = errors::kInvalidContentSecurityPolicy;\n      return false;\n    }\n    content_security_policy_ = content_security_policy;\n  }\n\n  if (source.HasKey(keys::kDevToolsPage)) {\n    std::string devtools_str;\n    if (!source.GetString(keys::kDevToolsPage, &devtools_str)) {\n      *error = errors::kInvalidDevToolsPage;\n      return false;\n    }\n    if (!HasApiPermission(Extension::kExperimentalPermission)) {\n      *error = errors::kDevToolsExperimental;\n      return false;\n    }\n    devtools_url_ = GetResourceURL(devtools_str);\n  }\n\n  if (source.HasKey(keys::kSidebar)) {\n    DictionaryValue* sidebar_value = NULL;\n    if (!source.GetDictionary(keys::kSidebar, &sidebar_value)) {\n      *error = errors::kInvalidSidebar;\n      return false;\n    }\n    if (!HasApiPermission(Extension::kExperimentalPermission)) {\n      *error = errors::kSidebarExperimental;\n      return false;\n    }\n    sidebar_defaults_.reset(LoadExtensionSidebarDefaults(sidebar_value, error));\n    if (!sidebar_defaults_.get())\n      return false;  // Failed to parse sidebar definition.\n  }\n\n  if (source.HasKey(keys::kTts)) {\n    DictionaryValue* tts_dict = NULL;\n    if (!source.GetDictionary(keys::kTts, &tts_dict)) {\n      *error = errors::kInvalidTts;\n      return false;\n    }\n\n    if (tts_dict->HasKey(keys::kTtsVoices)) {\n      ListValue* tts_voices = NULL;\n      if (!tts_dict->GetList(keys::kTtsVoices, &tts_voices)) {\n        *error = errors::kInvalidTtsVoices;\n        return false;\n      }\n\n      for (size_t i = 0; i < tts_voices->GetSize(); i++) {\n        DictionaryValue* one_tts_voice = NULL;\n        if (!tts_voices->GetDictionary(i, &one_tts_voice)) {\n          *error = errors::kInvalidTtsVoices;\n          return false;\n        }\n\n        TtsVoice voice_data;\n        if (one_tts_voice->HasKey(keys::kTtsVoicesVoiceName)) {\n          if (!one_tts_voice->GetString(\n                  keys::kTtsVoicesVoiceName, &voice_data.voice_name)) {\n            *error = errors::kInvalidTtsVoicesVoiceName;\n            return false;\n          }\n        }\n        if (one_tts_voice->HasKey(keys::kTtsVoicesLocale)) {\n          if (!one_tts_voice->GetString(\n                  keys::kTtsVoicesLocale, &voice_data.locale) ||\n              !l10n_util::IsValidLocaleSyntax(voice_data.locale)) {\n            *error = errors::kInvalidTtsVoicesLocale;\n            return false;\n          }\n        }\n        if (one_tts_voice->HasKey(keys::kTtsVoicesGender)) {\n          if (!one_tts_voice->GetString(\n                  keys::kTtsVoicesGender, &voice_data.gender) ||\n              (voice_data.gender != keys::kTtsGenderMale &&\n               voice_data.gender != keys::kTtsGenderFemale)) {\n            *error = errors::kInvalidTtsVoicesGender;\n            return false;\n          }\n        }\n\n        tts_voices_.push_back(voice_data);\n      }\n    }\n  }\n\n  incognito_split_mode_ = is_app();\n  if (source.HasKey(keys::kIncognito)) {\n    std::string value;\n    if (!source.GetString(keys::kIncognito, &value)) {\n      *error = errors::kInvalidIncognitoBehavior;\n      return false;\n    }\n    if (value == values::kIncognitoSpanning) {\n      incognito_split_mode_ = false;\n    } else if (value == values::kIncognitoSplit) {\n      incognito_split_mode_ = true;\n    } else {\n      *error = errors::kInvalidIncognitoBehavior;\n      return false;\n    }\n  }\n\n  if (HasMultipleUISurfaces()) {\n    *error = errors::kOneUISurfaceOnly;\n    return false;\n  }\n\n  InitEffectiveHostPermissions();\n\n  DCHECK(source.Equals(manifest_value_.get()));\n\n  return true;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143536,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "LayoutUnit RenderBox::availableLogicalHeightUsing(const Length& h) const\n{\n    if (h.isFixed())\n        return computeContentBoxLogicalHeight(h.value());\n\n    if (isRenderView())\n        return isHorizontalWritingMode() ? toRenderView(this)->frameView()->visibleHeight() : toRenderView(this)->frameView()->visibleWidth();\n\n     if (isTableCell() && (h.isAuto() || h.isPercent()))\n         return overrideHeight() - borderAndPaddingLogicalWidth();\n \n    if (h.isPercent())\n       return computeContentBoxLogicalHeight(h.calcValue(containingBlock()->availableLogicalHeight()));\n \n    if (isRenderBlock() && isPositioned() && style()->height().isAuto() && !(style()->top().isAuto() || style()->bottom().isAuto())) {\n        RenderBlock* block = const_cast<RenderBlock*>(toRenderBlock(this));\n        LayoutUnit oldHeight = block->logicalHeight();\n        block->computeLogicalHeight();\n        LayoutUnit newHeight = block->computeContentBoxLogicalHeight(block->contentLogicalHeight());\n        block->setLogicalHeight(oldHeight);\n        return computeContentBoxLogicalHeight(newHeight);\n    }\n\n    return containingBlock()->availableLogicalHeight();\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143537,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "LayoutUnit RenderBox::availableLogicalHeightUsing(const Length& h) const\n{\n    if (h.isFixed())\n        return computeContentBoxLogicalHeight(h.value());\n\n    if (isRenderView())\n        return isHorizontalWritingMode() ? toRenderView(this)->frameView()->visibleHeight() : toRenderView(this)->frameView()->visibleWidth();\n\n     if (isTableCell() && (h.isAuto() || h.isPercent()))\n         return overrideHeight() - borderAndPaddingLogicalWidth();\n \n    if (h.isPercent()) {\n        LayoutUnit availableHeight;\n        // https://bugs.webkit.org/show_bug.cgi?id=64046\n        // For absolutely positioned elements whose containing block is based on a block-level element,\n        // the percentage is calculated with respect to the height of the padding box of that element\n        if (isPositioned())\n            availableHeight = containingBlockLogicalHeightForPositioned(containingBlock());\n        else\n            availableHeight = containingBlock()->availableLogicalHeight();\n        return computeContentBoxLogicalHeight(h.calcValue(availableHeight));\n    }\n \n    if (isRenderBlock() && isPositioned() && style()->height().isAuto() && !(style()->top().isAuto() || style()->bottom().isAuto())) {\n        RenderBlock* block = const_cast<RenderBlock*>(toRenderBlock(this));\n        LayoutUnit oldHeight = block->logicalHeight();\n        block->computeLogicalHeight();\n        LayoutUnit newHeight = block->computeContentBoxLogicalHeight(block->contentLogicalHeight());\n        block->setLogicalHeight(oldHeight);\n        return computeContentBoxLogicalHeight(newHeight);\n    }\n\n    return containingBlock()->availableLogicalHeight();\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143538,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void SignatureUtil::CheckSignature(\n    const FilePath& file_path,\n    ClientDownloadRequest_SignatureInfo* signature_info) {\n  VLOG(2) << \"Checking signature for \" << file_path.value();\n\n  WINTRUST_FILE_INFO file_info;\n  file_info.cbStruct = sizeof(file_info);\n  file_info.pcwszFilePath = file_path.value().c_str();\n  file_info.hFile = NULL;\n  file_info.pgKnownSubject = NULL;\n\n  WINTRUST_DATA wintrust_data;\n  wintrust_data.cbStruct = sizeof(wintrust_data);\n  wintrust_data.pPolicyCallbackData = NULL;\n  wintrust_data.pSIPClientData = NULL;\n  wintrust_data.dwUIChoice = WTD_UI_NONE;\n  wintrust_data.fdwRevocationChecks = WTD_REVOKE_NONE;\n  wintrust_data.dwUnionChoice = WTD_CHOICE_FILE;\n  wintrust_data.pFile = &file_info;\n  wintrust_data.dwStateAction = WTD_STATEACTION_VERIFY;\n  wintrust_data.hWVTStateData = NULL;\n  wintrust_data.pwszURLReference = NULL;\n  wintrust_data.dwProvFlags = WTD_CACHE_ONLY_URL_RETRIEVAL;\n  wintrust_data.dwUIContext = WTD_UICONTEXT_EXECUTE;\n\n  GUID policy_guid = WINTRUST_ACTION_GENERIC_VERIFY_V2;\n\n  LONG result = WinVerifyTrust(static_cast<HWND>(INVALID_HANDLE_VALUE),\n                               &policy_guid,\n                               &wintrust_data);\n\n  CRYPT_PROVIDER_DATA* prov_data = WTHelperProvDataFromStateData(\n      wintrust_data.hWVTStateData);\n  if (prov_data) {\n    if (prov_data->csSigners > 0) {\n      signature_info->set_trusted(result == ERROR_SUCCESS);\n    }\n     for (DWORD i = 0; i < prov_data->csSigners; ++i) {\n       const CERT_CHAIN_CONTEXT* cert_chain_context =\n           prov_data->pasSigners[i].pChainContext;\n       for (DWORD j = 0; j < cert_chain_context->cChain; ++j) {\n         CERT_SIMPLE_CHAIN* simple_chain = cert_chain_context->rgpChain[j];\n         ClientDownloadRequest_CertificateChain* chain =\n             signature_info->add_certificate_chain();\n         for (DWORD k = 0; k < simple_chain->cElement; ++k) {\n           CERT_CHAIN_ELEMENT* element = simple_chain->rgpElement[k];\n           chain->add_element()->set_certificate(\n              element->pCertContext->pbCertEncoded,\n              element->pCertContext->cbCertEncoded);\n        }\n      }\n    }\n\n    wintrust_data.dwStateAction = WTD_STATEACTION_CLOSE;\n    WinVerifyTrust(static_cast<HWND>(INVALID_HANDLE_VALUE),\n                   &policy_guid, &wintrust_data);\n  }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143549,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void SignatureUtil::CheckSignature(\n    const FilePath& file_path,\n    ClientDownloadRequest_SignatureInfo* signature_info) {\n  VLOG(2) << \"Checking signature for \" << file_path.value();\n\n  WINTRUST_FILE_INFO file_info;\n  file_info.cbStruct = sizeof(file_info);\n  file_info.pcwszFilePath = file_path.value().c_str();\n  file_info.hFile = NULL;\n  file_info.pgKnownSubject = NULL;\n\n  WINTRUST_DATA wintrust_data;\n  wintrust_data.cbStruct = sizeof(wintrust_data);\n  wintrust_data.pPolicyCallbackData = NULL;\n  wintrust_data.pSIPClientData = NULL;\n  wintrust_data.dwUIChoice = WTD_UI_NONE;\n  wintrust_data.fdwRevocationChecks = WTD_REVOKE_NONE;\n  wintrust_data.dwUnionChoice = WTD_CHOICE_FILE;\n  wintrust_data.pFile = &file_info;\n  wintrust_data.dwStateAction = WTD_STATEACTION_VERIFY;\n  wintrust_data.hWVTStateData = NULL;\n  wintrust_data.pwszURLReference = NULL;\n  wintrust_data.dwProvFlags = WTD_CACHE_ONLY_URL_RETRIEVAL;\n  wintrust_data.dwUIContext = WTD_UICONTEXT_EXECUTE;\n\n  GUID policy_guid = WINTRUST_ACTION_GENERIC_VERIFY_V2;\n\n  LONG result = WinVerifyTrust(static_cast<HWND>(INVALID_HANDLE_VALUE),\n                               &policy_guid,\n                               &wintrust_data);\n\n  CRYPT_PROVIDER_DATA* prov_data = WTHelperProvDataFromStateData(\n      wintrust_data.hWVTStateData);\n  if (prov_data) {\n    if (prov_data->csSigners > 0) {\n      signature_info->set_trusted(result == ERROR_SUCCESS);\n    }\n     for (DWORD i = 0; i < prov_data->csSigners; ++i) {\n       const CERT_CHAIN_CONTEXT* cert_chain_context =\n           prov_data->pasSigners[i].pChainContext;\n      if (!cert_chain_context)\n        break;\n       for (DWORD j = 0; j < cert_chain_context->cChain; ++j) {\n         CERT_SIMPLE_CHAIN* simple_chain = cert_chain_context->rgpChain[j];\n         ClientDownloadRequest_CertificateChain* chain =\n             signature_info->add_certificate_chain();\n        if (!simple_chain)\n          break;\n         for (DWORD k = 0; k < simple_chain->cElement; ++k) {\n           CERT_CHAIN_ELEMENT* element = simple_chain->rgpElement[k];\n           chain->add_element()->set_certificate(\n              element->pCertContext->pbCertEncoded,\n              element->pCertContext->cbCertEncoded);\n        }\n      }\n    }\n\n    wintrust_data.dwStateAction = WTD_STATEACTION_CLOSE;\n    WinVerifyTrust(static_cast<HWND>(INVALID_HANDLE_VALUE),\n                   &policy_guid, &wintrust_data);\n  }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143550,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void RenderLayerCompositor::frameViewDidScroll()\n{\n    FrameView* frameView = m_renderView->frameView();\n    IntPoint scrollPosition = frameView->scrollPosition();\n\n    if (!m_scrollLayer)\n        return;\n\n    bool scrollingCoordinatorHandlesOffset = false;\n    if (ScrollingCoordinator* scrollingCoordinator = this->scrollingCoordinator()) {\n        if (Settings* settings = m_renderView->document().settings()) {\n            if (isMainFrame() || settings->compositedScrollingForFramesEnabled())\n                scrollingCoordinatorHandlesOffset = scrollingCoordinator->scrollableAreaScrollLayerDidChange(frameView);\n        }\n    }\n\n    if (scrollingCoordinatorHandlesOffset)\n        m_scrollLayer->setPosition(-frameView->minimumScrollPosition());\n    else\n        m_scrollLayer->setPosition(-scrollPosition);\n\n\n    blink::Platform::current()->histogramEnumeration(\"Renderer.AcceleratedFixedRootBackground\",\n        ScrolledMainFrameBucket,\n        AcceleratedFixedRootBackgroundHistogramMax);\n\n     if (!m_renderView->rootBackgroundIsEntirelyFixed())\n         return;\n \n     blink::Platform::current()->histogramEnumeration(\"Renderer.AcceleratedFixedRootBackground\",\n         !!fixedRootBackgroundLayer()\n             ? ScrolledMainFrameWithAcceleratedFixedRootBackground\n            : ScrolledMainFrameWithUnacceleratedFixedRootBackground,\n        AcceleratedFixedRootBackgroundHistogramMax);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143577,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void RenderLayerCompositor::frameViewDidScroll()\n{\n    FrameView* frameView = m_renderView->frameView();\n    IntPoint scrollPosition = frameView->scrollPosition();\n\n    if (!m_scrollLayer)\n        return;\n\n    bool scrollingCoordinatorHandlesOffset = false;\n    if (ScrollingCoordinator* scrollingCoordinator = this->scrollingCoordinator()) {\n        if (Settings* settings = m_renderView->document().settings()) {\n            if (isMainFrame() || settings->compositedScrollingForFramesEnabled())\n                scrollingCoordinatorHandlesOffset = scrollingCoordinator->scrollableAreaScrollLayerDidChange(frameView);\n        }\n    }\n\n    if (scrollingCoordinatorHandlesOffset)\n        m_scrollLayer->setPosition(-frameView->minimumScrollPosition());\n    else\n        m_scrollLayer->setPosition(-scrollPosition);\n\n\n    blink::Platform::current()->histogramEnumeration(\"Renderer.AcceleratedFixedRootBackground\",\n        ScrolledMainFrameBucket,\n        AcceleratedFixedRootBackgroundHistogramMax);\n\n     if (!m_renderView->rootBackgroundIsEntirelyFixed())\n         return;\n \n    // FIXME: fixedRootBackgroundLayer calls compositingState, which is not necessarily up to date here on mac.\n    // See crbug.com/343179.\n    DisableCompositingQueryAsserts disabler;\n\n     blink::Platform::current()->histogramEnumeration(\"Renderer.AcceleratedFixedRootBackground\",\n         !!fixedRootBackgroundLayer()\n             ? ScrolledMainFrameWithAcceleratedFixedRootBackground\n            : ScrolledMainFrameWithUnacceleratedFixedRootBackground,\n        AcceleratedFixedRootBackgroundHistogramMax);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143578,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void WebPreferences::Apply(WebView* web_view) const {\n  WebSettings* settings = web_view->settings();\n  ApplyFontsFromMap(standard_font_family_map, setStandardFontFamilyWrapper,\n                    settings);\n  ApplyFontsFromMap(fixed_font_family_map, setFixedFontFamilyWrapper, settings);\n  ApplyFontsFromMap(serif_font_family_map, setSerifFontFamilyWrapper, settings);\n  ApplyFontsFromMap(sans_serif_font_family_map, setSansSerifFontFamilyWrapper,\n                    settings);\n  ApplyFontsFromMap(cursive_font_family_map, setCursiveFontFamilyWrapper,\n                    settings);\n  ApplyFontsFromMap(fantasy_font_family_map, setFantasyFontFamilyWrapper,\n                    settings);\n  ApplyFontsFromMap(pictograph_font_family_map, setPictographFontFamilyWrapper,\n                    settings);\n  settings->setDefaultFontSize(default_font_size);\n  settings->setDefaultFixedFontSize(default_fixed_font_size);\n  settings->setMinimumFontSize(minimum_font_size);\n  settings->setMinimumLogicalFontSize(minimum_logical_font_size);\n  settings->setDefaultTextEncodingName(ASCIIToUTF16(default_encoding));\n  settings->setApplyDefaultDeviceScaleFactorInCompositor(\n      apply_default_device_scale_factor_in_compositor);\n  settings->setApplyPageScaleFactorInCompositor(\n      apply_page_scale_factor_in_compositor);\n  settings->setPerTilePaintingEnabled(per_tile_painting_enabled);\n  settings->setAcceleratedAnimationEnabled(accelerated_animation_enabled);\n  settings->setJavaScriptEnabled(javascript_enabled);\n  settings->setWebSecurityEnabled(web_security_enabled);\n  settings->setJavaScriptCanOpenWindowsAutomatically(\n      javascript_can_open_windows_automatically);\n  settings->setLoadsImagesAutomatically(loads_images_automatically);\n  settings->setImagesEnabled(images_enabled);\n  settings->setPluginsEnabled(plugins_enabled);\n  settings->setDOMPasteAllowed(dom_paste_enabled);\n  settings->setDeveloperExtrasEnabled(developer_extras_enabled);\n  settings->setNeedsSiteSpecificQuirks(site_specific_quirks_enabled);\n  settings->setShrinksStandaloneImagesToFit(shrinks_standalone_images_to_fit);\n  settings->setUsesEncodingDetector(uses_universal_detector);\n  settings->setTextAreasAreResizable(text_areas_are_resizable);\n  settings->setAllowScriptsToCloseWindows(allow_scripts_to_close_windows);\n  if (user_style_sheet_enabled)\n    settings->setUserStyleSheetLocation(user_style_sheet_location);\n  else\n    settings->setUserStyleSheetLocation(WebURL());\n  settings->setAuthorAndUserStylesEnabled(author_and_user_styles_enabled);\n  settings->setUsesPageCache(uses_page_cache);\n  settings->setPageCacheSupportsPlugins(page_cache_supports_plugins);\n  settings->setDownloadableBinaryFontsEnabled(remote_fonts_enabled);\n  settings->setJavaScriptCanAccessClipboard(javascript_can_access_clipboard);\n  settings->setXSSAuditorEnabled(xss_auditor_enabled);\n  settings->setDNSPrefetchingEnabled(dns_prefetching_enabled);\n  settings->setLocalStorageEnabled(local_storage_enabled);\n  settings->setSyncXHRInDocumentsEnabled(sync_xhr_in_documents_enabled);\n  WebRuntimeFeatures::enableDatabase(databases_enabled);\n  settings->setOfflineWebApplicationCacheEnabled(application_cache_enabled);\n  settings->setCaretBrowsingEnabled(caret_browsing_enabled);\n  settings->setHyperlinkAuditingEnabled(hyperlink_auditing_enabled);\n  settings->setCookieEnabled(cookie_enabled);\n\n  settings->setEditableLinkBehaviorNeverLive();\n\n  settings->setFrameFlatteningEnabled(frame_flattening_enabled);\n\n  settings->setFontRenderingModeNormal();\n  settings->setJavaEnabled(java_enabled);\n\n  settings->setAllowUniversalAccessFromFileURLs(\n      allow_universal_access_from_file_urls);\n  settings->setAllowFileAccessFromFileURLs(allow_file_access_from_file_urls);\n\n  settings->setTextDirectionSubmenuInclusionBehaviorNeverIncluded();\n\n  settings->setWebAudioEnabled(webaudio_enabled);\n\n  settings->setExperimentalWebGLEnabled(experimental_webgl_enabled);\n\n  settings->setOpenGLMultisamplingEnabled(gl_multisampling_enabled);\n\n  settings->setPrivilegedWebGLExtensionsEnabled(\n      privileged_webgl_extensions_enabled);\n\n  settings->setWebGLErrorsToConsoleEnabled(webgl_errors_to_console_enabled);\n\n  settings->setShowDebugBorders(show_composited_layer_borders);\n\n  settings->setShowFPSCounter(show_fps_counter);\n\n  settings->setAcceleratedCompositingForOverflowScrollEnabled(\n      accelerated_compositing_for_overflow_scroll_enabled);\n\n  settings->setAcceleratedCompositingForScrollableFramesEnabled(\n      accelerated_compositing_for_scrollable_frames_enabled);\n\n  settings->setCompositedScrollingForFramesEnabled(\n      composited_scrolling_for_frames_enabled);\n\n  settings->setShowPlatformLayerTree(show_composited_layer_tree);\n\n  settings->setShowPaintRects(show_paint_rects);\n\n  settings->setRenderVSyncEnabled(render_vsync_enabled);\n\n  settings->setAcceleratedCompositingEnabled(accelerated_compositing_enabled);\n\n  settings->setAcceleratedCompositingForFixedPositionEnabled(\n      fixed_position_compositing_enabled);\n\n  settings->setAccelerated2dCanvasEnabled(accelerated_2d_canvas_enabled);\n\n  settings->setDeferred2dCanvasEnabled(deferred_2d_canvas_enabled);\n\n  settings->setAntialiased2dCanvasEnabled(!antialiased_2d_canvas_disabled);\n\n  settings->setAcceleratedPaintingEnabled(accelerated_painting_enabled);\n\n  settings->setAcceleratedFiltersEnabled(accelerated_filters_enabled);\n\n  settings->setGestureTapHighlightEnabled(gesture_tap_highlight_enabled);\n\n  settings->setAcceleratedCompositingFor3DTransformsEnabled(\n      accelerated_compositing_for_3d_transforms_enabled);\n  settings->setAcceleratedCompositingForVideoEnabled(\n      accelerated_compositing_for_video_enabled);\n  settings->setAcceleratedCompositingForAnimationEnabled(\n      accelerated_compositing_for_animation_enabled);\n\n  settings->setAcceleratedCompositingForPluginsEnabled(\n      accelerated_compositing_for_plugins_enabled);\n\n  settings->setAcceleratedCompositingForCanvasEnabled(\n      experimental_webgl_enabled || accelerated_2d_canvas_enabled);\n\n  settings->setMemoryInfoEnabled(memory_info_enabled);\n\n  settings->setAsynchronousSpellCheckingEnabled(\n      asynchronous_spell_checking_enabled);\n  settings->setUnifiedTextCheckerEnabled(unified_textchecker_enabled);\n\n  for (WebInspectorPreferences::const_iterator it = inspector_settings.begin();\n       it != inspector_settings.end(); ++it)\n    web_view->setInspectorSetting(WebString::fromUTF8(it->first),\n                                  WebString::fromUTF8(it->second));\n\n  web_view->setTabsToLinks(tabs_to_links);\n\n  settings->setInteractiveFormValidationEnabled(true);\n\n  settings->setFullScreenEnabled(fullscreen_enabled);\n  settings->setAllowDisplayOfInsecureContent(allow_displaying_insecure_content);\n  settings->setAllowRunningOfInsecureContent(allow_running_insecure_content);\n  settings->setPasswordEchoEnabled(password_echo_enabled);\n  settings->setShouldPrintBackgrounds(should_print_backgrounds);\n  settings->setEnableScrollAnimator(enable_scroll_animator);\n  settings->setVisualWordMovementEnabled(visual_word_movement_enabled);\n\n  settings->setCSSStickyPositionEnabled(css_sticky_position_enabled);\n  settings->setExperimentalCSSCustomFilterEnabled(css_shaders_enabled);\n  settings->setExperimentalCSSVariablesEnabled(css_variables_enabled);\n  settings->setExperimentalCSSGridLayoutEnabled(css_grid_layout_enabled);\n\n  WebRuntimeFeatures::enableTouch(touch_enabled);\n  settings->setDeviceSupportsTouch(device_supports_touch);\n  settings->setDeviceSupportsMouse(device_supports_mouse);\n  settings->setEnableTouchAdjustment(touch_adjustment_enabled);\n\n  settings->setDefaultTileSize(\n      WebSize(default_tile_width, default_tile_height));\n  settings->setMaxUntiledLayerSize(\n      WebSize(max_untiled_layer_width, max_untiled_layer_height));\n\n  settings->setFixedPositionCreatesStackingContext(\n      fixed_position_creates_stacking_context);\n\n   settings->setDeferredImageDecodingEnabled(deferred_image_decoding_enabled);\n   settings->setShouldRespectImageOrientation(should_respect_image_orientation);\n \n   settings->setEditingBehavior(\n       static_cast<WebSettings::EditingBehavior>(editing_behavior));\n \n  settings->setSupportsMultipleWindows(supports_multiple_windows);\n\n  settings->setViewportEnabled(viewport_enabled);\n\n#if defined(OS_ANDROID)\n  settings->setAllowCustomScrollbarInMainFrame(false);\n  settings->setTextAutosizingEnabled(text_autosizing_enabled);\n  settings->setTextAutosizingFontScaleFactor(font_scale_factor);\n  web_view->setIgnoreViewportTagMaximumScale(force_enable_zoom);\n  settings->setAutoZoomFocusedNodeToLegibleScale(true);\n  settings->setDoubleTapToZoomEnabled(true);\n  settings->setMediaPlaybackRequiresUserGesture(\n      user_gesture_required_for_media_playback);\n#endif\n\n  WebNetworkStateNotifier::setOnLine(is_online);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143587,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void WebPreferences::Apply(WebView* web_view) const {\n  WebSettings* settings = web_view->settings();\n  ApplyFontsFromMap(standard_font_family_map, setStandardFontFamilyWrapper,\n                    settings);\n  ApplyFontsFromMap(fixed_font_family_map, setFixedFontFamilyWrapper, settings);\n  ApplyFontsFromMap(serif_font_family_map, setSerifFontFamilyWrapper, settings);\n  ApplyFontsFromMap(sans_serif_font_family_map, setSansSerifFontFamilyWrapper,\n                    settings);\n  ApplyFontsFromMap(cursive_font_family_map, setCursiveFontFamilyWrapper,\n                    settings);\n  ApplyFontsFromMap(fantasy_font_family_map, setFantasyFontFamilyWrapper,\n                    settings);\n  ApplyFontsFromMap(pictograph_font_family_map, setPictographFontFamilyWrapper,\n                    settings);\n  settings->setDefaultFontSize(default_font_size);\n  settings->setDefaultFixedFontSize(default_fixed_font_size);\n  settings->setMinimumFontSize(minimum_font_size);\n  settings->setMinimumLogicalFontSize(minimum_logical_font_size);\n  settings->setDefaultTextEncodingName(ASCIIToUTF16(default_encoding));\n  settings->setApplyDefaultDeviceScaleFactorInCompositor(\n      apply_default_device_scale_factor_in_compositor);\n  settings->setApplyPageScaleFactorInCompositor(\n      apply_page_scale_factor_in_compositor);\n  settings->setPerTilePaintingEnabled(per_tile_painting_enabled);\n  settings->setAcceleratedAnimationEnabled(accelerated_animation_enabled);\n  settings->setJavaScriptEnabled(javascript_enabled);\n  settings->setWebSecurityEnabled(web_security_enabled);\n  settings->setJavaScriptCanOpenWindowsAutomatically(\n      javascript_can_open_windows_automatically);\n  settings->setLoadsImagesAutomatically(loads_images_automatically);\n  settings->setImagesEnabled(images_enabled);\n  settings->setPluginsEnabled(plugins_enabled);\n  settings->setDOMPasteAllowed(dom_paste_enabled);\n  settings->setDeveloperExtrasEnabled(developer_extras_enabled);\n  settings->setNeedsSiteSpecificQuirks(site_specific_quirks_enabled);\n  settings->setShrinksStandaloneImagesToFit(shrinks_standalone_images_to_fit);\n  settings->setUsesEncodingDetector(uses_universal_detector);\n  settings->setTextAreasAreResizable(text_areas_are_resizable);\n  settings->setAllowScriptsToCloseWindows(allow_scripts_to_close_windows);\n  if (user_style_sheet_enabled)\n    settings->setUserStyleSheetLocation(user_style_sheet_location);\n  else\n    settings->setUserStyleSheetLocation(WebURL());\n  settings->setAuthorAndUserStylesEnabled(author_and_user_styles_enabled);\n  settings->setUsesPageCache(uses_page_cache);\n  settings->setPageCacheSupportsPlugins(page_cache_supports_plugins);\n  settings->setDownloadableBinaryFontsEnabled(remote_fonts_enabled);\n  settings->setJavaScriptCanAccessClipboard(javascript_can_access_clipboard);\n  settings->setXSSAuditorEnabled(xss_auditor_enabled);\n  settings->setDNSPrefetchingEnabled(dns_prefetching_enabled);\n  settings->setLocalStorageEnabled(local_storage_enabled);\n  settings->setSyncXHRInDocumentsEnabled(sync_xhr_in_documents_enabled);\n  WebRuntimeFeatures::enableDatabase(databases_enabled);\n  settings->setOfflineWebApplicationCacheEnabled(application_cache_enabled);\n  settings->setCaretBrowsingEnabled(caret_browsing_enabled);\n  settings->setHyperlinkAuditingEnabled(hyperlink_auditing_enabled);\n  settings->setCookieEnabled(cookie_enabled);\n\n  settings->setEditableLinkBehaviorNeverLive();\n\n  settings->setFrameFlatteningEnabled(frame_flattening_enabled);\n\n  settings->setFontRenderingModeNormal();\n  settings->setJavaEnabled(java_enabled);\n\n  settings->setAllowUniversalAccessFromFileURLs(\n      allow_universal_access_from_file_urls);\n  settings->setAllowFileAccessFromFileURLs(allow_file_access_from_file_urls);\n\n  settings->setTextDirectionSubmenuInclusionBehaviorNeverIncluded();\n\n  settings->setWebAudioEnabled(webaudio_enabled);\n\n  settings->setExperimentalWebGLEnabled(experimental_webgl_enabled);\n\n  settings->setOpenGLMultisamplingEnabled(gl_multisampling_enabled);\n\n  settings->setPrivilegedWebGLExtensionsEnabled(\n      privileged_webgl_extensions_enabled);\n\n  settings->setWebGLErrorsToConsoleEnabled(webgl_errors_to_console_enabled);\n\n  settings->setShowDebugBorders(show_composited_layer_borders);\n\n  settings->setShowFPSCounter(show_fps_counter);\n\n  settings->setAcceleratedCompositingForOverflowScrollEnabled(\n      accelerated_compositing_for_overflow_scroll_enabled);\n\n  settings->setAcceleratedCompositingForScrollableFramesEnabled(\n      accelerated_compositing_for_scrollable_frames_enabled);\n\n  settings->setCompositedScrollingForFramesEnabled(\n      composited_scrolling_for_frames_enabled);\n\n  settings->setShowPlatformLayerTree(show_composited_layer_tree);\n\n  settings->setShowPaintRects(show_paint_rects);\n\n  settings->setRenderVSyncEnabled(render_vsync_enabled);\n\n  settings->setAcceleratedCompositingEnabled(accelerated_compositing_enabled);\n\n  settings->setAcceleratedCompositingForFixedPositionEnabled(\n      fixed_position_compositing_enabled);\n\n  settings->setAccelerated2dCanvasEnabled(accelerated_2d_canvas_enabled);\n\n  settings->setDeferred2dCanvasEnabled(deferred_2d_canvas_enabled);\n\n  settings->setAntialiased2dCanvasEnabled(!antialiased_2d_canvas_disabled);\n\n  settings->setAcceleratedPaintingEnabled(accelerated_painting_enabled);\n\n  settings->setAcceleratedFiltersEnabled(accelerated_filters_enabled);\n\n  settings->setGestureTapHighlightEnabled(gesture_tap_highlight_enabled);\n\n  settings->setAcceleratedCompositingFor3DTransformsEnabled(\n      accelerated_compositing_for_3d_transforms_enabled);\n  settings->setAcceleratedCompositingForVideoEnabled(\n      accelerated_compositing_for_video_enabled);\n  settings->setAcceleratedCompositingForAnimationEnabled(\n      accelerated_compositing_for_animation_enabled);\n\n  settings->setAcceleratedCompositingForPluginsEnabled(\n      accelerated_compositing_for_plugins_enabled);\n\n  settings->setAcceleratedCompositingForCanvasEnabled(\n      experimental_webgl_enabled || accelerated_2d_canvas_enabled);\n\n  settings->setMemoryInfoEnabled(memory_info_enabled);\n\n  settings->setAsynchronousSpellCheckingEnabled(\n      asynchronous_spell_checking_enabled);\n  settings->setUnifiedTextCheckerEnabled(unified_textchecker_enabled);\n\n  for (WebInspectorPreferences::const_iterator it = inspector_settings.begin();\n       it != inspector_settings.end(); ++it)\n    web_view->setInspectorSetting(WebString::fromUTF8(it->first),\n                                  WebString::fromUTF8(it->second));\n\n  web_view->setTabsToLinks(tabs_to_links);\n\n  settings->setInteractiveFormValidationEnabled(true);\n\n  settings->setFullScreenEnabled(fullscreen_enabled);\n  settings->setAllowDisplayOfInsecureContent(allow_displaying_insecure_content);\n  settings->setAllowRunningOfInsecureContent(allow_running_insecure_content);\n  settings->setPasswordEchoEnabled(password_echo_enabled);\n  settings->setShouldPrintBackgrounds(should_print_backgrounds);\n  settings->setEnableScrollAnimator(enable_scroll_animator);\n  settings->setVisualWordMovementEnabled(visual_word_movement_enabled);\n\n  settings->setCSSStickyPositionEnabled(css_sticky_position_enabled);\n  settings->setExperimentalCSSCustomFilterEnabled(css_shaders_enabled);\n  settings->setExperimentalCSSVariablesEnabled(css_variables_enabled);\n  settings->setExperimentalCSSGridLayoutEnabled(css_grid_layout_enabled);\n\n  WebRuntimeFeatures::enableTouch(touch_enabled);\n  settings->setDeviceSupportsTouch(device_supports_touch);\n  settings->setDeviceSupportsMouse(device_supports_mouse);\n  settings->setEnableTouchAdjustment(touch_adjustment_enabled);\n\n  settings->setDefaultTileSize(\n      WebSize(default_tile_width, default_tile_height));\n  settings->setMaxUntiledLayerSize(\n      WebSize(max_untiled_layer_width, max_untiled_layer_height));\n\n  settings->setFixedPositionCreatesStackingContext(\n      fixed_position_creates_stacking_context);\n\n   settings->setDeferredImageDecodingEnabled(deferred_image_decoding_enabled);\n   settings->setShouldRespectImageOrientation(should_respect_image_orientation);\n \n  settings->setUnsafePluginPastingEnabled(false);\n   settings->setEditingBehavior(\n       static_cast<WebSettings::EditingBehavior>(editing_behavior));\n \n  settings->setSupportsMultipleWindows(supports_multiple_windows);\n\n  settings->setViewportEnabled(viewport_enabled);\n\n#if defined(OS_ANDROID)\n  settings->setAllowCustomScrollbarInMainFrame(false);\n  settings->setTextAutosizingEnabled(text_autosizing_enabled);\n  settings->setTextAutosizingFontScaleFactor(font_scale_factor);\n  web_view->setIgnoreViewportTagMaximumScale(force_enable_zoom);\n  settings->setAutoZoomFocusedNodeToLegibleScale(true);\n  settings->setDoubleTapToZoomEnabled(true);\n  settings->setMediaPlaybackRequiresUserGesture(\n      user_gesture_required_for_media_playback);\n#endif\n\n  WebNetworkStateNotifier::setOnLine(is_online);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143588,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " void LayerWebKitThread::setNeedsCommit()\n {\n     if (m_owner)\n        m_owner->notifySyncRequired();\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143593,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " void LayerWebKitThread::setNeedsCommit()\n {\n    // Call notifyFlushRequired(), which in this implementation plumbs through to\n     if (m_owner)\n        m_owner->notifyFlushRequired();\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143594,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " void WebPageSerializerImpl::openTagToString(Element* element,\n                                             SerializeDomParam* param)\n {\n    bool needSkip;\n    StringBuilder result;\n    result.append(preActionBeforeSerializeOpenTag(element, param, &needSkip));\n    if (needSkip)\n        return;\n    result.append('<');\n    result.append(element->nodeName().lower());\n    AttributeCollection attributes = element->attributes();\n    AttributeCollection::iterator end = attributes.end();\n    for (AttributeCollection::iterator it = attributes.begin(); it != end; ++it) {\n        result.append(' ');\n        result.append(it->name().toString());\n        result.appendLiteral(\"=\\\"\");\n        if (!it->value().isEmpty()) {\n            const String& attrValue = it->value();\n\n            const QualifiedName& attrName = it->name();\n             if (element->hasLegalLinkAttribute(attrName)) {\n                 if (attrValue.startsWith(\"javascript:\", TextCaseInsensitive)) {\n                    result.append(attrValue);\n                 } else {\n                     WebLocalFrameImpl* subFrame = WebLocalFrameImpl::fromFrameOwnerElement(element);\n                    String completeURL = subFrame ? subFrame->frame()->document()->url() :\n                                                    param->document->completeURL(attrValue);\n                    if (m_localLinks.contains(completeURL)) {\n                        if (!param->directoryName.isEmpty()) {\n                            result.appendLiteral(\"./\");\n                             result.append(param->directoryName);\n                             result.append('/');\n                         }\n                        result.append(m_localLinks.get(completeURL));\n                     } else {\n                        result.append(completeURL);\n                     }\n                 }\n             } else {\n                if (param->isHTMLDocument)\n                    result.append(m_htmlEntities.convertEntitiesInString(attrValue));\n                else\n                    result.append(m_xmlEntities.convertEntitiesInString(attrValue));\n            }\n        }\n        result.append('\\\"');\n    }\n\n    String addedContents = postActionAfterSerializeOpenTag(element, param);\n    if (element->hasChildren() || param->haveAddedContentsBeforeEnd)\n        result.append('>');\n    result.append(addedContents);\n    saveHTMLContentToBuffer(result.toString(), param);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143609,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " void WebPageSerializerImpl::openTagToString(Element* element,\n                                             SerializeDomParam* param)\n {\n    bool needSkip;\n    StringBuilder result;\n    result.append(preActionBeforeSerializeOpenTag(element, param, &needSkip));\n    if (needSkip)\n        return;\n    result.append('<');\n    result.append(element->nodeName().lower());\n    AttributeCollection attributes = element->attributes();\n    AttributeCollection::iterator end = attributes.end();\n    for (AttributeCollection::iterator it = attributes.begin(); it != end; ++it) {\n        result.append(' ');\n        result.append(it->name().toString());\n        result.appendLiteral(\"=\\\"\");\n        if (!it->value().isEmpty()) {\n            const String& attrValue = it->value();\n\n            const QualifiedName& attrName = it->name();\n             if (element->hasLegalLinkAttribute(attrName)) {\n                 if (attrValue.startsWith(\"javascript:\", TextCaseInsensitive)) {\n                    result.append(m_htmlEntities.convertEntitiesInString(attrValue));\n                 } else {\n                     WebLocalFrameImpl* subFrame = WebLocalFrameImpl::fromFrameOwnerElement(element);\n                    String completeURL = subFrame ? subFrame->frame()->document()->url() :\n                                                    param->document->completeURL(attrValue);\n                    if (m_localLinks.contains(completeURL)) {\n                        if (!param->directoryName.isEmpty()) {\n                            result.appendLiteral(\"./\");\n                             result.append(param->directoryName);\n                             result.append('/');\n                         }\n                        result.append(m_htmlEntities.convertEntitiesInString(m_localLinks.get(completeURL)));\n                     } else {\n                        result.append(m_htmlEntities.convertEntitiesInString(completeURL));\n                     }\n                 }\n             } else {\n                if (param->isHTMLDocument)\n                    result.append(m_htmlEntities.convertEntitiesInString(attrValue));\n                else\n                    result.append(m_xmlEntities.convertEntitiesInString(attrValue));\n            }\n        }\n        result.append('\\\"');\n    }\n\n    String addedContents = postActionAfterSerializeOpenTag(element, param);\n    if (element->hasChildren() || param->haveAddedContentsBeforeEnd)\n        result.append('>');\n    result.append(addedContents);\n    saveHTMLContentToBuffer(result.toString(), param);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143610,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int FindStartOffsetOfFileInZipFile(const char* zip_file, const char* filename) {\n  FileDescriptor fd;\n  if (!fd.OpenReadOnly(zip_file)) {\n    LOG_ERRNO(\"%s: open failed trying to open zip file %s\\n\",\n              __FUNCTION__, zip_file);\n    return CRAZY_OFFSET_FAILED;\n  }\n\n  struct stat stat_buf;\n  if (stat(zip_file, &stat_buf) == -1) {\n    LOG_ERRNO(\"%s: stat failed trying to stat zip file %s\\n\",\n              __FUNCTION__, zip_file);\n    return CRAZY_OFFSET_FAILED;\n  }\n\n  if (stat_buf.st_size > kMaxZipFileLength) {\n    LOG(\"%s: The size %ld of %s is too large to map\\n\",\n        __FUNCTION__, stat_buf.st_size, zip_file);\n    return CRAZY_OFFSET_FAILED;\n  }\n\n  void* mem = fd.Map(NULL, stat_buf.st_size, PROT_READ, MAP_PRIVATE, 0);\n  if (mem == MAP_FAILED) {\n    LOG_ERRNO(\"%s: mmap failed trying to mmap zip file %s\\n\",\n              __FUNCTION__, zip_file);\n    return CRAZY_OFFSET_FAILED;\n  }\n   ScopedMMap scoped_mmap(mem, stat_buf.st_size);\n \n   uint8_t* mem_bytes = static_cast<uint8_t*>(mem);\n  int off;\n  for (off = stat_buf.st_size - sizeof(kEndOfCentralDirectoryMarker);\n       off >= 0; --off) {\n     if (ReadUInt32(mem_bytes, off) == kEndOfCentralDirectoryMarker) {\n       break;\n     }\n  }\n  if (off == -1) {\n    LOG(\"%s: Failed to find end of central directory in %s\\n\",\n        __FUNCTION__, zip_file);\n    return CRAZY_OFFSET_FAILED;\n  }\n\n\n  uint32_t length_of_central_dir = ReadUInt32(\n      mem_bytes, off + kOffsetOfCentralDirLengthInEndOfCentralDirectory);\n  uint32_t start_of_central_dir = ReadUInt32(\n      mem_bytes, off + kOffsetOfStartOfCentralDirInEndOfCentralDirectory);\n\n  if (start_of_central_dir > off) {\n    LOG(\"%s: Found out of range offset %u for start of directory in %s\\n\",\n        __FUNCTION__, start_of_central_dir, zip_file);\n    return CRAZY_OFFSET_FAILED;\n  }\n\n  uint32_t end_of_central_dir = start_of_central_dir + length_of_central_dir;\n  if (end_of_central_dir > off) {\n    LOG(\"%s: Found out of range offset %u for end of directory in %s\\n\",\n        __FUNCTION__, end_of_central_dir, zip_file);\n    return CRAZY_OFFSET_FAILED;\n  }\n\n  uint32_t num_entries = ReadUInt16(\n      mem_bytes, off + kOffsetNumOfEntriesInEndOfCentralDirectory);\n\n  off = start_of_central_dir;\n  const int target_len = strlen(filename);\n  int n = 0;\n  for (; n < num_entries && off < end_of_central_dir; ++n) {\n    uint32_t marker = ReadUInt32(mem_bytes, off);\n    if (marker != kCentralDirHeaderMarker) {\n      LOG(\"%s: Failed to find central directory header marker in %s. \"\n          \"Found 0x%x but expected 0x%x\\n\", __FUNCTION__,\n          zip_file, marker, kCentralDirHeaderMarker);\n      return CRAZY_OFFSET_FAILED;\n    }\n    uint32_t file_name_length =\n        ReadUInt16(mem_bytes, off + kOffsetFilenameLengthInCentralDirectory);\n    uint32_t extra_field_length =\n        ReadUInt16(mem_bytes, off + kOffsetExtraFieldLengthInCentralDirectory);\n    uint32_t comment_field_length =\n        ReadUInt16(mem_bytes, off + kOffsetCommentLengthInCentralDirectory);\n    uint32_t header_length = kOffsetFilenameInCentralDirectory +\n        file_name_length + extra_field_length + comment_field_length;\n\n    uint32_t local_header_offset =\n        ReadUInt32(mem_bytes, off + kOffsetLocalHeaderOffsetInCentralDirectory);\n\n    uint8_t* filename_bytes =\n        mem_bytes + off + kOffsetFilenameInCentralDirectory;\n\n    if (file_name_length == target_len &&\n        memcmp(filename_bytes, filename, target_len) == 0) {\n      uint32_t marker = ReadUInt32(mem_bytes, local_header_offset);\n      if (marker != kLocalHeaderMarker) {\n        LOG(\"%s: Failed to find local file header marker in %s. \"\n            \"Found 0x%x but expected 0x%x\\n\", __FUNCTION__,\n            zip_file, marker, kLocalHeaderMarker);\n        return CRAZY_OFFSET_FAILED;\n      }\n\n      uint32_t compression_method =\n          ReadUInt16(\n              mem_bytes,\n              local_header_offset + kOffsetCompressionMethodInLocalHeader);\n      if (compression_method != kCompressionMethodStored) {\n        LOG(\"%s: %s is compressed within %s. \"\n            \"Found compression method %u but expected %u\\n\", __FUNCTION__,\n            filename, zip_file, compression_method, kCompressionMethodStored);\n        return CRAZY_OFFSET_FAILED;\n      }\n\n      uint32_t file_name_length =\n          ReadUInt16(\n              mem_bytes,\n              local_header_offset + kOffsetFilenameLengthInLocalHeader);\n      uint32_t extra_field_length =\n          ReadUInt16(\n              mem_bytes,\n              local_header_offset + kOffsetExtraFieldLengthInLocalHeader);\n      uint32_t header_length =\n          kOffsetFilenameInLocalHeader + file_name_length + extra_field_length;\n\n      return local_header_offset + header_length;\n    }\n\n    off += header_length;\n  }\n\n  if (n < num_entries) {\n    LOG(\"%s: Did not find all the expected entries in the central directory. \"\n        \"Found %d but expected %d\\n\", __FUNCTION__, n, num_entries);\n  }\n\n  if (off < end_of_central_dir) {\n    LOG(\"%s: There are %d extra bytes at the end of the central directory.\\n\",\n        __FUNCTION__, end_of_central_dir - off);\n  }\n\n  LOG(\"%s: Did not find %s in %s\\n\", __FUNCTION__, filename, zip_file);\n  return CRAZY_OFFSET_FAILED;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143611,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int FindStartOffsetOfFileInZipFile(const char* zip_file, const char* filename) {\n  FileDescriptor fd;\n  if (!fd.OpenReadOnly(zip_file)) {\n    LOG_ERRNO(\"%s: open failed trying to open zip file %s\\n\",\n              __FUNCTION__, zip_file);\n    return CRAZY_OFFSET_FAILED;\n  }\n\n  struct stat stat_buf;\n  if (stat(zip_file, &stat_buf) == -1) {\n    LOG_ERRNO(\"%s: stat failed trying to stat zip file %s\\n\",\n              __FUNCTION__, zip_file);\n    return CRAZY_OFFSET_FAILED;\n  }\n\n  if (stat_buf.st_size > kMaxZipFileLength) {\n    LOG(\"%s: The size %ld of %s is too large to map\\n\",\n        __FUNCTION__, stat_buf.st_size, zip_file);\n    return CRAZY_OFFSET_FAILED;\n  }\n\n  void* mem = fd.Map(NULL, stat_buf.st_size, PROT_READ, MAP_PRIVATE, 0);\n  if (mem == MAP_FAILED) {\n    LOG_ERRNO(\"%s: mmap failed trying to mmap zip file %s\\n\",\n              __FUNCTION__, zip_file);\n    return CRAZY_OFFSET_FAILED;\n  }\n   ScopedMMap scoped_mmap(mem, stat_buf.st_size);\n \n  // central directory marker. The earliest occurrence we accept is\n  // size of end of central directory bytes back from from the end of the\n  // file.\n   uint8_t* mem_bytes = static_cast<uint8_t*>(mem);\n  int off = stat_buf.st_size - kEndOfCentralDirectoryRecordSize;\n  for (; off >= 0; --off) {\n     if (ReadUInt32(mem_bytes, off) == kEndOfCentralDirectoryMarker) {\n       break;\n     }\n  }\n  if (off == -1) {\n    LOG(\"%s: Failed to find end of central directory in %s\\n\",\n        __FUNCTION__, zip_file);\n    return CRAZY_OFFSET_FAILED;\n  }\n\n\n  uint32_t length_of_central_dir = ReadUInt32(\n      mem_bytes, off + kOffsetOfCentralDirLengthInEndOfCentralDirectory);\n  uint32_t start_of_central_dir = ReadUInt32(\n      mem_bytes, off + kOffsetOfStartOfCentralDirInEndOfCentralDirectory);\n\n  if (start_of_central_dir > off) {\n    LOG(\"%s: Found out of range offset %u for start of directory in %s\\n\",\n        __FUNCTION__, start_of_central_dir, zip_file);\n    return CRAZY_OFFSET_FAILED;\n  }\n\n  uint32_t end_of_central_dir = start_of_central_dir + length_of_central_dir;\n  if (end_of_central_dir > off) {\n    LOG(\"%s: Found out of range offset %u for end of directory in %s\\n\",\n        __FUNCTION__, end_of_central_dir, zip_file);\n    return CRAZY_OFFSET_FAILED;\n  }\n\n  uint32_t num_entries = ReadUInt16(\n      mem_bytes, off + kOffsetNumOfEntriesInEndOfCentralDirectory);\n\n  off = start_of_central_dir;\n  const int target_len = strlen(filename);\n  int n = 0;\n  for (; n < num_entries && off < end_of_central_dir; ++n) {\n    uint32_t marker = ReadUInt32(mem_bytes, off);\n    if (marker != kCentralDirHeaderMarker) {\n      LOG(\"%s: Failed to find central directory header marker in %s. \"\n          \"Found 0x%x but expected 0x%x\\n\", __FUNCTION__,\n          zip_file, marker, kCentralDirHeaderMarker);\n      return CRAZY_OFFSET_FAILED;\n    }\n    uint32_t file_name_length =\n        ReadUInt16(mem_bytes, off + kOffsetFilenameLengthInCentralDirectory);\n    uint32_t extra_field_length =\n        ReadUInt16(mem_bytes, off + kOffsetExtraFieldLengthInCentralDirectory);\n    uint32_t comment_field_length =\n        ReadUInt16(mem_bytes, off + kOffsetCommentLengthInCentralDirectory);\n    uint32_t header_length = kOffsetFilenameInCentralDirectory +\n        file_name_length + extra_field_length + comment_field_length;\n\n    uint32_t local_header_offset =\n        ReadUInt32(mem_bytes, off + kOffsetLocalHeaderOffsetInCentralDirectory);\n\n    uint8_t* filename_bytes =\n        mem_bytes + off + kOffsetFilenameInCentralDirectory;\n\n    if (file_name_length == target_len &&\n        memcmp(filename_bytes, filename, target_len) == 0) {\n      uint32_t marker = ReadUInt32(mem_bytes, local_header_offset);\n      if (marker != kLocalHeaderMarker) {\n        LOG(\"%s: Failed to find local file header marker in %s. \"\n            \"Found 0x%x but expected 0x%x\\n\", __FUNCTION__,\n            zip_file, marker, kLocalHeaderMarker);\n        return CRAZY_OFFSET_FAILED;\n      }\n\n      uint32_t compression_method =\n          ReadUInt16(\n              mem_bytes,\n              local_header_offset + kOffsetCompressionMethodInLocalHeader);\n      if (compression_method != kCompressionMethodStored) {\n        LOG(\"%s: %s is compressed within %s. \"\n            \"Found compression method %u but expected %u\\n\", __FUNCTION__,\n            filename, zip_file, compression_method, kCompressionMethodStored);\n        return CRAZY_OFFSET_FAILED;\n      }\n\n      uint32_t file_name_length =\n          ReadUInt16(\n              mem_bytes,\n              local_header_offset + kOffsetFilenameLengthInLocalHeader);\n      uint32_t extra_field_length =\n          ReadUInt16(\n              mem_bytes,\n              local_header_offset + kOffsetExtraFieldLengthInLocalHeader);\n      uint32_t header_length =\n          kOffsetFilenameInLocalHeader + file_name_length + extra_field_length;\n\n      return local_header_offset + header_length;\n    }\n\n    off += header_length;\n  }\n\n  if (n < num_entries) {\n    LOG(\"%s: Did not find all the expected entries in the central directory. \"\n        \"Found %d but expected %d\\n\", __FUNCTION__, n, num_entries);\n  }\n\n  if (off < end_of_central_dir) {\n    LOG(\"%s: There are %d extra bytes at the end of the central directory.\\n\",\n        __FUNCTION__, end_of_central_dir - off);\n  }\n\n  LOG(\"%s: Did not find %s in %s\\n\", __FUNCTION__, filename, zip_file);\n  return CRAZY_OFFSET_FAILED;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143612,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool OutOfProcessInstance::Init(uint32_t argc,\n                                 const char* argn[],\n                                 const char* argv[]) {\n   pp::Var document_url_var = pp::URLUtil_Dev::Get()->GetDocumentURL(this);\n  std::string document_url = document_url_var.is_string() ?\n      document_url_var.AsString() : std::string();\n   std::string extension_url = std::string(kChromeExtension);\n  bool in_extension =\n      !document_url.compare(0, extension_url.size(), extension_url);\n  if (in_extension) {\n    for (uint32_t i = 0; i < argc; ++i) {\n      if (strcmp(argn[i], \"full-frame\") == 0) {\n        full_ = true;\n        break;\n      }\n     }\n   }\n \n  if (full_)\n    SetPluginToHandleFindRequests();\n\n  pp::VarDictionary translated_strings;\n  translated_strings.Set(kType, kJSSetTranslatedStringsType);\n  translated_strings.Set(kJSGetPasswordString,\n      GetLocalizedString(PP_RESOURCESTRING_PDFGETPASSWORD));\n  translated_strings.Set(kJSLoadingString,\n      GetLocalizedString(PP_RESOURCESTRING_PDFLOADING));\n  translated_strings.Set(kJSLoadFailedString,\n      GetLocalizedString(PP_RESOURCESTRING_PDFLOAD_FAILED));\n  PostMessage(translated_strings);\n\n  text_input_.reset(new pp::TextInput_Dev(this));\n\n  const char* stream_url = nullptr;\n  const char* original_url = nullptr;\n  const char* headers = nullptr;\n  bool is_material = false;\n  for (uint32_t i = 0; i < argc; ++i) {\n    if (strcmp(argn[i], \"src\") == 0)\n      original_url = argv[i];\n    else if (strcmp(argn[i], \"stream-url\") == 0)\n      stream_url = argv[i];\n    else if (strcmp(argn[i], \"headers\") == 0)\n      headers = argv[i];\n    else if (strcmp(argn[i], \"is-material\") == 0)\n      is_material = true;\n    else if (strcmp(argn[i], \"top-toolbar-height\") == 0)\n      base::StringToInt(argv[i], &top_toolbar_height_);\n  }\n\n  if (is_material)\n    background_color_ = kBackgroundColorMaterial;\n  else\n    background_color_ = kBackgroundColor;\n\n  if (!original_url)\n    return false;\n\n  if (!stream_url)\n    stream_url = original_url;\n\n  if (IsPrintPreviewUrl(original_url))\n    return true;\n\n  LoadUrl(stream_url);\n  url_ = original_url;\n  return engine_->New(original_url, headers);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143615,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool OutOfProcessInstance::Init(uint32_t argc,\n                                 const char* argn[],\n                                 const char* argv[]) {\n  // the plugin to be loaded in the extension and print preview to avoid\n  // exposing sensitive APIs directly to external websites.\n   pp::Var document_url_var = pp::URLUtil_Dev::Get()->GetDocumentURL(this);\n  if (!document_url_var.is_string())\n    return false;\n  std::string document_url = document_url_var.AsString();\n   std::string extension_url = std::string(kChromeExtension);\n  std::string print_preview_url = std::string(kChromePrint);\n  if (!base::StringPiece(document_url).starts_with(kChromeExtension) &&\n      !base::StringPiece(document_url).starts_with(kChromePrint)) {\n    return false;\n  }\n\n  // Check if the plugin is full frame. This is passed in from JS.\n  for (uint32_t i = 0; i < argc; ++i) {\n    if (strcmp(argn[i], \"full-frame\") == 0) {\n      full_ = true;\n      break;\n     }\n   }\n \n  if (full_)\n    SetPluginToHandleFindRequests();\n\n  pp::VarDictionary translated_strings;\n  translated_strings.Set(kType, kJSSetTranslatedStringsType);\n  translated_strings.Set(kJSGetPasswordString,\n      GetLocalizedString(PP_RESOURCESTRING_PDFGETPASSWORD));\n  translated_strings.Set(kJSLoadingString,\n      GetLocalizedString(PP_RESOURCESTRING_PDFLOADING));\n  translated_strings.Set(kJSLoadFailedString,\n      GetLocalizedString(PP_RESOURCESTRING_PDFLOAD_FAILED));\n  PostMessage(translated_strings);\n\n  text_input_.reset(new pp::TextInput_Dev(this));\n\n  const char* stream_url = nullptr;\n  const char* original_url = nullptr;\n  const char* headers = nullptr;\n  bool is_material = false;\n  for (uint32_t i = 0; i < argc; ++i) {\n    if (strcmp(argn[i], \"src\") == 0)\n      original_url = argv[i];\n    else if (strcmp(argn[i], \"stream-url\") == 0)\n      stream_url = argv[i];\n    else if (strcmp(argn[i], \"headers\") == 0)\n      headers = argv[i];\n    else if (strcmp(argn[i], \"is-material\") == 0)\n      is_material = true;\n    else if (strcmp(argn[i], \"top-toolbar-height\") == 0)\n      base::StringToInt(argv[i], &top_toolbar_height_);\n  }\n\n  if (is_material)\n    background_color_ = kBackgroundColorMaterial;\n  else\n    background_color_ = kBackgroundColor;\n\n  if (!original_url)\n    return false;\n\n  if (!stream_url)\n    stream_url = original_url;\n\n  if (IsPrintPreviewUrl(original_url))\n    return true;\n\n  LoadUrl(stream_url);\n  url_ = original_url;\n  return engine_->New(original_url, headers);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143616,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void RemoveActionCallback(const ActionCallback& callback) {\n  DCHECK(g_task_runner.Get());\n   DCHECK(g_task_runner.Get()->BelongsToCurrentThread());\n   std::vector<ActionCallback>* callbacks = g_callbacks.Pointer();\n   for (size_t i = 0; i < callbacks->size(); ++i) {\n    if ((*callbacks)[i].Equals(callback)) {\n       callbacks->erase(callbacks->begin() + i);\n       return;\n     }\n  }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143629,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void RemoveActionCallback(const ActionCallback& callback) {\n  DCHECK(g_task_runner.Get());\n   DCHECK(g_task_runner.Get()->BelongsToCurrentThread());\n   std::vector<ActionCallback>* callbacks = g_callbacks.Pointer();\n   for (size_t i = 0; i < callbacks->size(); ++i) {\n    if ((*callbacks)[i] == callback) {\n       callbacks->erase(callbacks->begin() + i);\n       return;\n     }\n  }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143630,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void NavigationRequest::OnStartChecksComplete(\n    NavigationThrottle::ThrottleCheckResult result) {\n  DCHECK(result.action() != NavigationThrottle::DEFER);\n  DCHECK(result.action() != NavigationThrottle::BLOCK_RESPONSE);\n\n  if (on_start_checks_complete_closure_)\n    on_start_checks_complete_closure_.Run();\n  if (result.action() == NavigationThrottle::CANCEL_AND_IGNORE ||\n      result.action() == NavigationThrottle::CANCEL ||\n      result.action() == NavigationThrottle::BLOCK_REQUEST ||\n      result.action() == NavigationThrottle::BLOCK_REQUEST_AND_COLLAPSE) {\n#if DCHECK_IS_ON()\n    if (result.action() == NavigationThrottle::BLOCK_REQUEST) {\n      DCHECK(result.net_error_code() == net::ERR_BLOCKED_BY_CLIENT ||\n             result.net_error_code() == net::ERR_BLOCKED_BY_ADMINISTRATOR);\n    }\n    else if (result.action() == NavigationThrottle::CANCEL_AND_IGNORE) {\n      DCHECK_EQ(result.net_error_code(), net::ERR_ABORTED);\n    }\n#endif\n\n    bool collapse_frame =\n        result.action() == NavigationThrottle::BLOCK_REQUEST_AND_COLLAPSE;\n\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(\n            &NavigationRequest::OnRequestFailedInternal,\n            weak_factory_.GetWeakPtr(),\n            network::URLLoaderCompletionStatus(result.net_error_code()),\n            true /* skip_throttles */, result.error_page_content(),\n            collapse_frame));\n\n    return;\n  }\n\n  DCHECK_NE(AssociatedSiteInstanceType::NONE, associated_site_instance_type_);\n  RenderFrameHostImpl* navigating_frame_host =\n      associated_site_instance_type_ == AssociatedSiteInstanceType::SPECULATIVE\n          ? frame_tree_node_->render_manager()->speculative_frame_host()\n          : frame_tree_node_->current_frame_host();\n  DCHECK(navigating_frame_host);\n\n  navigation_handle_->SetExpectedProcess(navigating_frame_host->GetProcess());\n\n  BrowserContext* browser_context =\n      frame_tree_node_->navigator()->GetController()->GetBrowserContext();\n  StoragePartition* partition = BrowserContext::GetStoragePartition(\n      browser_context, navigating_frame_host->GetSiteInstance());\n  DCHECK(partition);\n\n  DCHECK(!loader_);\n\n  bool can_create_service_worker =\n      (frame_tree_node_->pending_frame_policy().sandbox_flags &\n       blink::WebSandboxFlags::kOrigin) != blink::WebSandboxFlags::kOrigin;\n  request_params_.should_create_service_worker = can_create_service_worker;\n  if (can_create_service_worker) {\n    ServiceWorkerContextWrapper* service_worker_context =\n        static_cast<ServiceWorkerContextWrapper*>(\n            partition->GetServiceWorkerContext());\n    navigation_handle_->InitServiceWorkerHandle(service_worker_context);\n  }\n\n  if (IsSchemeSupportedForAppCache(common_params_.url)) {\n    if (navigating_frame_host->GetRenderViewHost()\n            ->GetWebkitPreferences()\n            .application_cache_enabled) {\n      navigation_handle_->InitAppCacheHandle(\n          static_cast<ChromeAppCacheService*>(partition->GetAppCacheService()));\n    }\n  }\n\n  request_params_.navigation_timing.fetch_start = base::TimeTicks::Now();\n\n  GURL base_url;\n#if defined(OS_ANDROID)\n  NavigationEntry* last_committed_entry =\n      frame_tree_node_->navigator()->GetController()->GetLastCommittedEntry();\n  if (last_committed_entry)\n    base_url = last_committed_entry->GetBaseURLForDataURL();\n#endif\n  const GURL& top_document_url =\n      !base_url.is_empty()\n          ? base_url\n           : frame_tree_node_->frame_tree()->root()->current_url();\n \n  const FrameTreeNode* current = frame_tree_node_->parent();\n  bool ancestors_are_same_site = true;\n  while (current && ancestors_are_same_site) {\n    if (!net::registry_controlled_domains::SameDomainOrHost(\n            top_document_url, current->current_url(),\n            net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES)) {\n      ancestors_are_same_site = false;\n     }\n     current = current->parent();\n   }\n   const GURL& site_for_cookies =\n      ancestors_are_same_site\n           ? (frame_tree_node_->IsMainFrame() ? common_params_.url\n                                              : top_document_url)\n          : GURL::EmptyGURL();\n   bool parent_is_main_frame = !frame_tree_node_->parent()\n                                   ? false\n                                   : frame_tree_node_->parent()->IsMainFrame();\n\n  std::unique_ptr<NavigationUIData> navigation_ui_data;\n  if (navigation_handle_->GetNavigationUIData())\n    navigation_ui_data = navigation_handle_->GetNavigationUIData()->Clone();\n\n  bool is_for_guests_only =\n      navigation_handle_->GetStartingSiteInstance()->GetSiteURL().\n          SchemeIs(kGuestScheme);\n\n  bool report_raw_headers = false;\n  RenderFrameDevToolsAgentHost::ApplyOverrides(\n      frame_tree_node_, begin_params_.get(), &report_raw_headers);\n  RenderFrameDevToolsAgentHost::OnNavigationRequestWillBeSent(*this);\n\n  loader_ = NavigationURLLoader::Create(\n      browser_context->GetResourceContext(), partition,\n      std::make_unique<NavigationRequestInfo>(\n          common_params_, begin_params_.Clone(), site_for_cookies,\n          frame_tree_node_->IsMainFrame(), parent_is_main_frame,\n          IsSecureFrame(frame_tree_node_->parent()),\n          frame_tree_node_->frame_tree_node_id(), is_for_guests_only,\n          report_raw_headers,\n          navigating_frame_host->GetVisibilityState() ==\n              blink::mojom::PageVisibilityState::kPrerender,\n          upgrade_if_insecure_,\n          blob_url_loader_factory_ ? blob_url_loader_factory_->Clone()\n                                   : nullptr,\n          devtools_navigation_token(),\n          frame_tree_node_->devtools_frame_token()),\n      std::move(navigation_ui_data),\n      navigation_handle_->service_worker_handle(),\n      navigation_handle_->appcache_handle(), this);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143641,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void NavigationRequest::OnStartChecksComplete(\n    NavigationThrottle::ThrottleCheckResult result) {\n  DCHECK(result.action() != NavigationThrottle::DEFER);\n  DCHECK(result.action() != NavigationThrottle::BLOCK_RESPONSE);\n\n  if (on_start_checks_complete_closure_)\n    on_start_checks_complete_closure_.Run();\n  if (result.action() == NavigationThrottle::CANCEL_AND_IGNORE ||\n      result.action() == NavigationThrottle::CANCEL ||\n      result.action() == NavigationThrottle::BLOCK_REQUEST ||\n      result.action() == NavigationThrottle::BLOCK_REQUEST_AND_COLLAPSE) {\n#if DCHECK_IS_ON()\n    if (result.action() == NavigationThrottle::BLOCK_REQUEST) {\n      DCHECK(result.net_error_code() == net::ERR_BLOCKED_BY_CLIENT ||\n             result.net_error_code() == net::ERR_BLOCKED_BY_ADMINISTRATOR);\n    }\n    else if (result.action() == NavigationThrottle::CANCEL_AND_IGNORE) {\n      DCHECK_EQ(result.net_error_code(), net::ERR_ABORTED);\n    }\n#endif\n\n    bool collapse_frame =\n        result.action() == NavigationThrottle::BLOCK_REQUEST_AND_COLLAPSE;\n\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(\n            &NavigationRequest::OnRequestFailedInternal,\n            weak_factory_.GetWeakPtr(),\n            network::URLLoaderCompletionStatus(result.net_error_code()),\n            true /* skip_throttles */, result.error_page_content(),\n            collapse_frame));\n\n    return;\n  }\n\n  DCHECK_NE(AssociatedSiteInstanceType::NONE, associated_site_instance_type_);\n  RenderFrameHostImpl* navigating_frame_host =\n      associated_site_instance_type_ == AssociatedSiteInstanceType::SPECULATIVE\n          ? frame_tree_node_->render_manager()->speculative_frame_host()\n          : frame_tree_node_->current_frame_host();\n  DCHECK(navigating_frame_host);\n\n  navigation_handle_->SetExpectedProcess(navigating_frame_host->GetProcess());\n\n  BrowserContext* browser_context =\n      frame_tree_node_->navigator()->GetController()->GetBrowserContext();\n  StoragePartition* partition = BrowserContext::GetStoragePartition(\n      browser_context, navigating_frame_host->GetSiteInstance());\n  DCHECK(partition);\n\n  DCHECK(!loader_);\n\n  bool can_create_service_worker =\n      (frame_tree_node_->pending_frame_policy().sandbox_flags &\n       blink::WebSandboxFlags::kOrigin) != blink::WebSandboxFlags::kOrigin;\n  request_params_.should_create_service_worker = can_create_service_worker;\n  if (can_create_service_worker) {\n    ServiceWorkerContextWrapper* service_worker_context =\n        static_cast<ServiceWorkerContextWrapper*>(\n            partition->GetServiceWorkerContext());\n    navigation_handle_->InitServiceWorkerHandle(service_worker_context);\n  }\n\n  if (IsSchemeSupportedForAppCache(common_params_.url)) {\n    if (navigating_frame_host->GetRenderViewHost()\n            ->GetWebkitPreferences()\n            .application_cache_enabled) {\n      navigation_handle_->InitAppCacheHandle(\n          static_cast<ChromeAppCacheService*>(partition->GetAppCacheService()));\n    }\n  }\n\n  request_params_.navigation_timing.fetch_start = base::TimeTicks::Now();\n\n  GURL base_url;\n#if defined(OS_ANDROID)\n  NavigationEntry* last_committed_entry =\n      frame_tree_node_->navigator()->GetController()->GetLastCommittedEntry();\n  if (last_committed_entry)\n    base_url = last_committed_entry->GetBaseURLForDataURL();\n#endif\n  const GURL& top_document_url =\n      !base_url.is_empty()\n          ? base_url\n           : frame_tree_node_->frame_tree()->root()->current_url();\n \n  // not, the |site_for_cookies| is set to an opaque URL.\n  const FrameTreeNode* current = frame_tree_node_->parent();\n  bool ancestors_are_same_site = true;\n  while (current && ancestors_are_same_site) {\n    if (!net::registry_controlled_domains::SameDomainOrHost(\n            top_document_url, current->current_url(),\n            net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES)) {\n      ancestors_are_same_site = false;\n     }\n     current = current->parent();\n   }\n\n   const GURL& site_for_cookies =\n      (ancestors_are_same_site || !base_url.is_empty())\n           ? (frame_tree_node_->IsMainFrame() ? common_params_.url\n                                              : top_document_url)\n          : GURL(\"data:,\");\n   bool parent_is_main_frame = !frame_tree_node_->parent()\n                                   ? false\n                                   : frame_tree_node_->parent()->IsMainFrame();\n\n  std::unique_ptr<NavigationUIData> navigation_ui_data;\n  if (navigation_handle_->GetNavigationUIData())\n    navigation_ui_data = navigation_handle_->GetNavigationUIData()->Clone();\n\n  bool is_for_guests_only =\n      navigation_handle_->GetStartingSiteInstance()->GetSiteURL().\n          SchemeIs(kGuestScheme);\n\n  bool report_raw_headers = false;\n  RenderFrameDevToolsAgentHost::ApplyOverrides(\n      frame_tree_node_, begin_params_.get(), &report_raw_headers);\n  RenderFrameDevToolsAgentHost::OnNavigationRequestWillBeSent(*this);\n\n  loader_ = NavigationURLLoader::Create(\n      browser_context->GetResourceContext(), partition,\n      std::make_unique<NavigationRequestInfo>(\n          common_params_, begin_params_.Clone(), site_for_cookies,\n          frame_tree_node_->IsMainFrame(), parent_is_main_frame,\n          IsSecureFrame(frame_tree_node_->parent()),\n          frame_tree_node_->frame_tree_node_id(), is_for_guests_only,\n          report_raw_headers,\n          navigating_frame_host->GetVisibilityState() ==\n              blink::mojom::PageVisibilityState::kPrerender,\n          upgrade_if_insecure_,\n          blob_url_loader_factory_ ? blob_url_loader_factory_->Clone()\n                                   : nullptr,\n          devtools_navigation_token(),\n          frame_tree_node_->devtools_frame_token()),\n      std::move(navigation_ui_data),\n      navigation_handle_->service_worker_handle(),\n      navigation_handle_->appcache_handle(), this);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143642,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "V4L2JpegEncodeAccelerator::JobRecord::JobRecord(\n    scoped_refptr<VideoFrame> input_frame,\n    scoped_refptr<VideoFrame> output_frame,\n    int quality,\n    int32_t task_id,\n    BitstreamBuffer* exif_buffer)\n    : input_frame(input_frame),\n       output_frame(output_frame),\n       quality(quality),\n       task_id(task_id),\n      output_shm(base::SharedMemoryHandle(), 0, true),  // dummy\n       exif_shm(nullptr) {\n   if (exif_buffer) {\n     exif_shm.reset(new UnalignedSharedMemory(exif_buffer->TakeRegion(),\n                                             exif_buffer->size(), false));\n    exif_offset = exif_buffer->offset();\n  }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143647,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "V4L2JpegEncodeAccelerator::JobRecord::JobRecord(\n    scoped_refptr<VideoFrame> input_frame,\n    scoped_refptr<VideoFrame> output_frame,\n    int quality,\n    int32_t task_id,\n    BitstreamBuffer* exif_buffer)\n    : input_frame(input_frame),\n       output_frame(output_frame),\n       quality(quality),\n       task_id(task_id),\n      output_shm(base::subtle::PlatformSharedMemoryRegion(), 0, true),  // dummy\n       exif_shm(nullptr) {\n   if (exif_buffer) {\n     exif_shm.reset(new UnalignedSharedMemory(exif_buffer->TakeRegion(),\n                                             exif_buffer->size(), false));\n    exif_offset = exif_buffer->offset();\n  }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143648,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,\n                                             bool is_tld_ascii) {\n  UErrorCode status = U_ZERO_ERROR;\n  int32_t result =\n      uspoof_check(checker_, label.data(),\n                   base::checked_cast<int32_t>(label.size()), NULL, &status);\n  if (U_FAILURE(status) || (result & USPOOF_ALL_CHECKS))\n    return false;\n\n  icu::UnicodeString label_string(FALSE, label.data(),\n                                  base::checked_cast<int32_t>(label.size()));\n\n  if (deviation_characters_.containsSome(label_string))\n    return false;\n\n  result &= USPOOF_RESTRICTION_LEVEL_MASK;\n  if (result == USPOOF_ASCII)\n    return true;\n  if (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&\n      kana_letters_exceptions_.containsNone(label_string) &&\n      combining_diacritics_exceptions_.containsNone(label_string)) {\n    return !is_tld_ascii || !IsMadeOfLatinAlikeCyrillic(label_string);\n  }\n\n  if (non_ascii_latin_letters_.containsSome(label_string) &&\n      !lgc_letters_n_ascii_.containsAll(label_string))\n    return false;\n\n  if (!tls_index.initialized())\n    tls_index.Initialize(&OnThreadTermination);\n  icu::RegexMatcher* dangerous_pattern =\n      reinterpret_cast<icu::RegexMatcher*>(tls_index.Get());\n  if (!dangerous_pattern) {\n     dangerous_pattern = new icu::RegexMatcher(\n         icu::UnicodeString(\n             R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}])\"\n            R\"([\\u30ce\\u30f3\\u30bd\\u30be])\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}]|)\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}]\\u30fc|^\\u30fc|)\"\n            R\"([^\\p{scx=kana}][\\u30fd\\u30fe]|^[\\u30fd\\u30fe]|)\"\n            R\"(^[\\p{scx=kana}]+[\\u3078-\\u307a][\\p{scx=kana}]+$|)\"\n            R\"(^[\\p{scx=hira}]+[\\u30d8-\\u30da][\\p{scx=hira}]+$|)\"\n            R\"([a-z]\\u30fb|\\u30fb[a-z]|)\"\n            R\"(^[\\u0585\\u0581]+[a-z]|[a-z][\\u0585\\u0581]+$|)\"\n            R\"([a-z][\\u0585\\u0581]+[a-z]|)\"\n            R\"(^[og]+[\\p{scx=armn}]|[\\p{scx=armn}][og]+$|)\"\n             R\"([\\p{scx=armn}][og]+[\\p{scx=armn}]|)\"\n             R\"([\\p{sc=cans}].*[a-z]|[a-z].*[\\p{sc=cans}]|)\"\n             R\"([\\p{sc=tfng}].*[a-z]|[a-z].*[\\p{sc=tfng}]|)\"\n            R\"([^\\p{scx=latn}\\p{scx=grek}\\p{scx=cyrl}][\\u0300-\\u0339])\",\n             -1, US_INV),\n         0, status);\n     tls_index.Set(dangerous_pattern);\n  }\n  dangerous_pattern->reset(label_string);\n  return !dangerous_pattern->find();\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143649,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,\n                                             bool is_tld_ascii) {\n  UErrorCode status = U_ZERO_ERROR;\n  int32_t result =\n      uspoof_check(checker_, label.data(),\n                   base::checked_cast<int32_t>(label.size()), NULL, &status);\n  if (U_FAILURE(status) || (result & USPOOF_ALL_CHECKS))\n    return false;\n\n  icu::UnicodeString label_string(FALSE, label.data(),\n                                  base::checked_cast<int32_t>(label.size()));\n\n  if (deviation_characters_.containsSome(label_string))\n    return false;\n\n  result &= USPOOF_RESTRICTION_LEVEL_MASK;\n  if (result == USPOOF_ASCII)\n    return true;\n  if (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&\n      kana_letters_exceptions_.containsNone(label_string) &&\n      combining_diacritics_exceptions_.containsNone(label_string)) {\n    return !is_tld_ascii || !IsMadeOfLatinAlikeCyrillic(label_string);\n  }\n\n  if (non_ascii_latin_letters_.containsSome(label_string) &&\n      !lgc_letters_n_ascii_.containsAll(label_string))\n    return false;\n\n  if (!tls_index.initialized())\n    tls_index.Initialize(&OnThreadTermination);\n  icu::RegexMatcher* dangerous_pattern =\n      reinterpret_cast<icu::RegexMatcher*>(tls_index.Get());\n  if (!dangerous_pattern) {\n    // - Disallow Arabic non-spacing marks after non-Arabic characters.\n    // - Disallow Hebrew non-spacing marks after non-Hebrew characters.\n     dangerous_pattern = new icu::RegexMatcher(\n         icu::UnicodeString(\n             R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}])\"\n            R\"([\\u30ce\\u30f3\\u30bd\\u30be])\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}]|)\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}]\\u30fc|^\\u30fc|)\"\n            R\"([^\\p{scx=kana}][\\u30fd\\u30fe]|^[\\u30fd\\u30fe]|)\"\n            R\"(^[\\p{scx=kana}]+[\\u3078-\\u307a][\\p{scx=kana}]+$|)\"\n            R\"(^[\\p{scx=hira}]+[\\u30d8-\\u30da][\\p{scx=hira}]+$|)\"\n            R\"([a-z]\\u30fb|\\u30fb[a-z]|)\"\n            R\"(^[\\u0585\\u0581]+[a-z]|[a-z][\\u0585\\u0581]+$|)\"\n            R\"([a-z][\\u0585\\u0581]+[a-z]|)\"\n            R\"(^[og]+[\\p{scx=armn}]|[\\p{scx=armn}][og]+$|)\"\n             R\"([\\p{scx=armn}][og]+[\\p{scx=armn}]|)\"\n             R\"([\\p{sc=cans}].*[a-z]|[a-z].*[\\p{sc=cans}]|)\"\n             R\"([\\p{sc=tfng}].*[a-z]|[a-z].*[\\p{sc=tfng}]|)\"\n            R\"([^\\p{scx=latn}\\p{scx=grek}\\p{scx=cyrl}][\\u0300-\\u0339]|)\"\n            R\"([^\\p{scx=arab}][\\u064b-\\u0655\\u0670]|)\"\n            R\"([^\\p{scx=hebr}]\\u05b4)\",\n             -1, US_INV),\n         0, status);\n     tls_index.Set(dangerous_pattern);\n  }\n  dangerous_pattern->reset(label_string);\n  return !dangerous_pattern->find();\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143650,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "scoped_refptr<VideoFrame> CloneVideoFrameWithLayout(\n    const VideoFrame* const src_frame,\n    const VideoFrameLayout& dst_layout) {\n  LOG_ASSERT(src_frame->IsMappable());\n  LOG_ASSERT(src_frame->format() == dst_layout.format());\n  auto dst_frame = VideoFrame::CreateFrameWithLayout(\n      dst_layout, src_frame->visible_rect(), src_frame->natural_size(),\n      src_frame->timestamp(), false /* zero_initialize_memory*/);\n  if (!dst_frame) {\n    LOG(ERROR) << \"Failed to create VideoFrame\";\n    return nullptr;\n  }\n\n  const size_t num_planes = VideoFrame::NumPlanes(dst_layout.format());\n   LOG_ASSERT(dst_layout.planes().size() == num_planes);\n   LOG_ASSERT(src_frame->layout().planes().size() == num_planes);\n   for (size_t i = 0; i < num_planes; ++i) {\n     libyuv::CopyPlane(\n         src_frame->data(i), src_frame->layout().planes()[i].stride,\n         dst_frame->data(i), dst_frame->layout().planes()[i].stride,\n        VideoFrame::Columns(i, dst_frame->format(),\n                            dst_frame->natural_size().width()),\n        VideoFrame::Rows(i, dst_frame->format(),\n                         dst_frame->natural_size().height()));\n   }\n \n   return dst_frame;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143655,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "scoped_refptr<VideoFrame> CloneVideoFrameWithLayout(\n    const VideoFrame* const src_frame,\n    const VideoFrameLayout& dst_layout) {\n  LOG_ASSERT(src_frame->IsMappable());\n  LOG_ASSERT(src_frame->format() == dst_layout.format());\n  auto dst_frame = VideoFrame::CreateFrameWithLayout(\n      dst_layout, src_frame->visible_rect(), src_frame->natural_size(),\n      src_frame->timestamp(), false /* zero_initialize_memory*/);\n  if (!dst_frame) {\n    LOG(ERROR) << \"Failed to create VideoFrame\";\n    return nullptr;\n  }\n\n  const size_t num_planes = VideoFrame::NumPlanes(dst_layout.format());\n   LOG_ASSERT(dst_layout.planes().size() == num_planes);\n   LOG_ASSERT(src_frame->layout().planes().size() == num_planes);\n   for (size_t i = 0; i < num_planes; ++i) {\n    // |width| in libyuv::CopyPlane() is in bytes, not pixels.\n    gfx::Size plane_size = VideoFrame::PlaneSize(dst_frame->format(), i,\n                                                 dst_frame->natural_size());\n     libyuv::CopyPlane(\n         src_frame->data(i), src_frame->layout().planes()[i].stride,\n         dst_frame->data(i), dst_frame->layout().planes()[i].stride,\n        plane_size.width(), plane_size.height());\n   }\n \n   return dst_frame;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143656,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool NavigatorImpl::NavigateToEntry(\n    FrameTreeNode* frame_tree_node,\n    const FrameNavigationEntry& frame_entry,\n    const NavigationEntryImpl& entry,\n    ReloadType reload_type,\n    bool is_same_document_history_load,\n    bool is_history_navigation_in_new_child,\n    bool is_pending_entry,\n    const scoped_refptr<ResourceRequestBodyImpl>& post_body) {\n  TRACE_EVENT0(\"browser,navigation\", \"NavigatorImpl::NavigateToEntry\");\n\n  GURL dest_url = frame_entry.url();\n  Referrer dest_referrer = frame_entry.referrer();\n  if (reload_type == ReloadType::ORIGINAL_REQUEST_URL &&\n      entry.GetOriginalRequestURL().is_valid() && !entry.GetHasPostData()) {\n    dest_url = entry.GetOriginalRequestURL();\n     dest_referrer = Referrer();\n   }\n \n   if (!dest_url.is_valid() && !dest_url.is_empty()) {\n     LOG(WARNING) << \"Refusing to load invalid URL: \"\n                 << dest_url.possibly_invalid_spec();\n    return false;\n  }\n\n  if (dest_url.spec().size() > url::kMaxURLChars) {\n    LOG(WARNING) << \"Refusing to load URL as it exceeds \" << url::kMaxURLChars\n                 << \" characters.\";\n    return false;\n  }\n\n  base::TimeTicks navigation_start = base::TimeTicks::Now();\n  TRACE_EVENT_INSTANT_WITH_TIMESTAMP0(\n      \"navigation,rail\", \"NavigationTiming navigationStart\",\n      TRACE_EVENT_SCOPE_GLOBAL, navigation_start);\n\n  LoFiState lofi_state = LOFI_UNSPECIFIED;\n  if (!frame_tree_node->IsMainFrame()) {\n    lofi_state = frame_tree_node->frame_tree()\n                     ->root()\n                     ->current_frame_host()\n                     ->last_navigation_lofi_state();\n  } else if (reload_type == ReloadType::DISABLE_LOFI_MODE) {\n    lofi_state = LOFI_OFF;\n  }\n\n  if (IsBrowserSideNavigationEnabled()) {\n    navigation_data_.reset(new NavigationMetricsData(navigation_start, dest_url,\n                                                     entry.restore_type()));\n    RequestNavigation(frame_tree_node, dest_url, dest_referrer, frame_entry,\n                      entry, reload_type, lofi_state,\n                      is_same_document_history_load,\n                      is_history_navigation_in_new_child, navigation_start);\n    if (frame_tree_node->IsMainFrame() &&\n        frame_tree_node->navigation_request()) {\n      TRACE_EVENT_ASYNC_BEGIN_WITH_TIMESTAMP1(\n          \"navigation\", \"Navigation timeToNetworkStack\",\n          frame_tree_node->navigation_request()->navigation_handle(),\n          navigation_start,\n          \"FrameTreeNode id\", frame_tree_node->frame_tree_node_id());\n    }\n\n  } else {\n    RenderFrameHostImpl* dest_render_frame_host =\n        frame_tree_node->render_manager()->Navigate(\n            dest_url, frame_entry, entry, reload_type != ReloadType::NONE);\n    if (!dest_render_frame_host)\n      return false;  // Unable to create the desired RenderFrameHost.\n\n    if (is_pending_entry)\n      CHECK_EQ(controller_->GetPendingEntry(), &entry);\n\n    CheckWebUIRendererDoesNotDisplayNormalURL(dest_render_frame_host, dest_url);\n\n    bool is_transfer = entry.transferred_global_request_id().child_id != -1;\n    if (is_transfer)\n      dest_render_frame_host->set_is_loading(true);\n\n    if (is_pending_entry && controller_->GetPendingEntryIndex() != -1)\n      DCHECK(frame_entry.page_state().IsValid());\n\n    bool is_transfer_to_same =\n        is_transfer &&\n        entry.transferred_global_request_id().child_id ==\n            dest_render_frame_host->GetProcess()->GetID();\n    if (!is_transfer_to_same) {\n      navigation_data_.reset(new NavigationMetricsData(\n          navigation_start, dest_url, entry.restore_type()));\n      FrameMsg_Navigate_Type::Value navigation_type = GetNavigationType(\n          controller_->GetBrowserContext(), entry, reload_type);\n      dest_render_frame_host->Navigate(\n          entry.ConstructCommonNavigationParams(\n              frame_entry, post_body, dest_url, dest_referrer, navigation_type,\n              lofi_state, navigation_start),\n          entry.ConstructStartNavigationParams(),\n          entry.ConstructRequestNavigationParams(\n              frame_entry, is_same_document_history_load,\n              is_history_navigation_in_new_child,\n              entry.GetSubframeUniqueNames(frame_tree_node),\n              frame_tree_node->has_committed_real_load(),\n              controller_->GetPendingEntryIndex() == -1,\n              controller_->GetIndexOfEntry(&entry),\n              controller_->GetLastCommittedEntryIndex(),\n              controller_->GetEntryCount()));\n    }\n  }\n\n  if (is_pending_entry)\n    CHECK_EQ(controller_->GetPendingEntry(), &entry);\n\n  if (controller_->GetPendingEntryIndex() == -1 &&\n      dest_url.SchemeIs(url::kJavaScriptScheme)) {\n    return false;\n  }\n\n  if (delegate_ && is_pending_entry)\n    delegate_->DidStartNavigationToPendingEntry(dest_url, reload_type);\n\n  return true;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143669,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool NavigatorImpl::NavigateToEntry(\n    FrameTreeNode* frame_tree_node,\n    const FrameNavigationEntry& frame_entry,\n    const NavigationEntryImpl& entry,\n    ReloadType reload_type,\n    bool is_same_document_history_load,\n    bool is_history_navigation_in_new_child,\n    bool is_pending_entry,\n    const scoped_refptr<ResourceRequestBodyImpl>& post_body) {\n  TRACE_EVENT0(\"browser,navigation\", \"NavigatorImpl::NavigateToEntry\");\n\n  GURL dest_url = frame_entry.url();\n  Referrer dest_referrer = frame_entry.referrer();\n  if (reload_type == ReloadType::ORIGINAL_REQUEST_URL &&\n      entry.GetOriginalRequestURL().is_valid() && !entry.GetHasPostData()) {\n    dest_url = entry.GetOriginalRequestURL();\n     dest_referrer = Referrer();\n   }\n \n  // Don't attempt to navigate if the virtual URL is non-empty and invalid.\n  if (frame_tree_node->IsMainFrame()) {\n    const GURL& virtual_url = entry.GetVirtualURL();\n    if (!virtual_url.is_valid() && !virtual_url.is_empty()) {\n      LOG(WARNING) << \"Refusing to load for invalid virtual URL: \"\n                   << virtual_url.possibly_invalid_spec();\n      return false;\n    }\n  }\n\n   if (!dest_url.is_valid() && !dest_url.is_empty()) {\n     LOG(WARNING) << \"Refusing to load invalid URL: \"\n                 << dest_url.possibly_invalid_spec();\n    return false;\n  }\n\n  if (dest_url.spec().size() > url::kMaxURLChars) {\n    LOG(WARNING) << \"Refusing to load URL as it exceeds \" << url::kMaxURLChars\n                 << \" characters.\";\n    return false;\n  }\n\n  base::TimeTicks navigation_start = base::TimeTicks::Now();\n  TRACE_EVENT_INSTANT_WITH_TIMESTAMP0(\n      \"navigation,rail\", \"NavigationTiming navigationStart\",\n      TRACE_EVENT_SCOPE_GLOBAL, navigation_start);\n\n  LoFiState lofi_state = LOFI_UNSPECIFIED;\n  if (!frame_tree_node->IsMainFrame()) {\n    lofi_state = frame_tree_node->frame_tree()\n                     ->root()\n                     ->current_frame_host()\n                     ->last_navigation_lofi_state();\n  } else if (reload_type == ReloadType::DISABLE_LOFI_MODE) {\n    lofi_state = LOFI_OFF;\n  }\n\n  if (IsBrowserSideNavigationEnabled()) {\n    navigation_data_.reset(new NavigationMetricsData(navigation_start, dest_url,\n                                                     entry.restore_type()));\n    RequestNavigation(frame_tree_node, dest_url, dest_referrer, frame_entry,\n                      entry, reload_type, lofi_state,\n                      is_same_document_history_load,\n                      is_history_navigation_in_new_child, navigation_start);\n    if (frame_tree_node->IsMainFrame() &&\n        frame_tree_node->navigation_request()) {\n      TRACE_EVENT_ASYNC_BEGIN_WITH_TIMESTAMP1(\n          \"navigation\", \"Navigation timeToNetworkStack\",\n          frame_tree_node->navigation_request()->navigation_handle(),\n          navigation_start,\n          \"FrameTreeNode id\", frame_tree_node->frame_tree_node_id());\n    }\n\n  } else {\n    RenderFrameHostImpl* dest_render_frame_host =\n        frame_tree_node->render_manager()->Navigate(\n            dest_url, frame_entry, entry, reload_type != ReloadType::NONE);\n    if (!dest_render_frame_host)\n      return false;  // Unable to create the desired RenderFrameHost.\n\n    if (is_pending_entry)\n      CHECK_EQ(controller_->GetPendingEntry(), &entry);\n\n    CheckWebUIRendererDoesNotDisplayNormalURL(dest_render_frame_host, dest_url);\n\n    bool is_transfer = entry.transferred_global_request_id().child_id != -1;\n    if (is_transfer)\n      dest_render_frame_host->set_is_loading(true);\n\n    if (is_pending_entry && controller_->GetPendingEntryIndex() != -1)\n      DCHECK(frame_entry.page_state().IsValid());\n\n    bool is_transfer_to_same =\n        is_transfer &&\n        entry.transferred_global_request_id().child_id ==\n            dest_render_frame_host->GetProcess()->GetID();\n    if (!is_transfer_to_same) {\n      navigation_data_.reset(new NavigationMetricsData(\n          navigation_start, dest_url, entry.restore_type()));\n      FrameMsg_Navigate_Type::Value navigation_type = GetNavigationType(\n          controller_->GetBrowserContext(), entry, reload_type);\n      dest_render_frame_host->Navigate(\n          entry.ConstructCommonNavigationParams(\n              frame_entry, post_body, dest_url, dest_referrer, navigation_type,\n              lofi_state, navigation_start),\n          entry.ConstructStartNavigationParams(),\n          entry.ConstructRequestNavigationParams(\n              frame_entry, is_same_document_history_load,\n              is_history_navigation_in_new_child,\n              entry.GetSubframeUniqueNames(frame_tree_node),\n              frame_tree_node->has_committed_real_load(),\n              controller_->GetPendingEntryIndex() == -1,\n              controller_->GetIndexOfEntry(&entry),\n              controller_->GetLastCommittedEntryIndex(),\n              controller_->GetEntryCount()));\n    }\n  }\n\n  if (is_pending_entry)\n    CHECK_EQ(controller_->GetPendingEntry(), &entry);\n\n  if (controller_->GetPendingEntryIndex() == -1 &&\n      dest_url.SchemeIs(url::kJavaScriptScheme)) {\n    return false;\n  }\n\n  if (delegate_ && is_pending_entry)\n    delegate_->DidStartNavigationToPendingEntry(dest_url, reload_type);\n\n  return true;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143670,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " Response PageHandler::SetDownloadBehavior(const std::string& behavior,\n                                           Maybe<std::string> download_path) {\n   WebContentsImpl* web_contents = GetWebContents();\n   if (!web_contents)\n     return Response::InternalError();\n\n  if (behavior == Page::SetDownloadBehavior::BehaviorEnum::Allow &&\n      !download_path.isJust())\n    return Response::Error(\"downloadPath not provided\");\n\n  if (behavior == Page::SetDownloadBehavior::BehaviorEnum::Default) {\n    DevToolsDownloadManagerHelper::RemoveFromWebContents(web_contents);\n    download_manager_delegate_ = nullptr;\n    return Response::OK();\n  }\n\n  content::BrowserContext* browser_context = web_contents->GetBrowserContext();\n  DCHECK(browser_context);\n  content::DownloadManager* download_manager =\n      content::BrowserContext::GetDownloadManager(browser_context);\n  download_manager_delegate_ =\n      DevToolsDownloadManagerDelegate::TakeOver(download_manager);\n\n  DevToolsDownloadManagerHelper::CreateForWebContents(web_contents);\n  DevToolsDownloadManagerHelper* download_helper =\n      DevToolsDownloadManagerHelper::FromWebContents(web_contents);\n\n  download_helper->SetDownloadBehavior(\n      DevToolsDownloadManagerHelper::DownloadBehavior::DENY);\n  if (behavior == Page::SetDownloadBehavior::BehaviorEnum::Allow) {\n    download_helper->SetDownloadBehavior(\n        DevToolsDownloadManagerHelper::DownloadBehavior::ALLOW);\n    download_helper->SetDownloadPath(download_path.fromJust());\n  }\n\n  return Response::OK();\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143679,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " Response PageHandler::SetDownloadBehavior(const std::string& behavior,\n                                           Maybe<std::string> download_path) {\n  if (!allow_set_download_behavior_)\n    return Response::Error(\"Not allowed.\");\n\n   WebContentsImpl* web_contents = GetWebContents();\n   if (!web_contents)\n     return Response::InternalError();\n\n  if (behavior == Page::SetDownloadBehavior::BehaviorEnum::Allow &&\n      !download_path.isJust())\n    return Response::Error(\"downloadPath not provided\");\n\n  if (behavior == Page::SetDownloadBehavior::BehaviorEnum::Default) {\n    DevToolsDownloadManagerHelper::RemoveFromWebContents(web_contents);\n    download_manager_delegate_ = nullptr;\n    return Response::OK();\n  }\n\n  content::BrowserContext* browser_context = web_contents->GetBrowserContext();\n  DCHECK(browser_context);\n  content::DownloadManager* download_manager =\n      content::BrowserContext::GetDownloadManager(browser_context);\n  download_manager_delegate_ =\n      DevToolsDownloadManagerDelegate::TakeOver(download_manager);\n\n  DevToolsDownloadManagerHelper::CreateForWebContents(web_contents);\n  DevToolsDownloadManagerHelper* download_helper =\n      DevToolsDownloadManagerHelper::FromWebContents(web_contents);\n\n  download_helper->SetDownloadBehavior(\n      DevToolsDownloadManagerHelper::DownloadBehavior::DENY);\n  if (behavior == Page::SetDownloadBehavior::BehaviorEnum::Allow) {\n    download_helper->SetDownloadBehavior(\n        DevToolsDownloadManagerHelper::DownloadBehavior::ALLOW);\n    download_helper->SetDownloadPath(download_path.fromJust());\n  }\n\n  return Response::OK();\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143680,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "  void OnReadAllMetadata(\n      const SessionStore::SessionInfo& session_info,\n      SessionStore::FactoryCompletionCallback callback,\n      std::unique_ptr<ModelTypeStore> store,\n       std::unique_ptr<ModelTypeStore::RecordList> record_list,\n       const base::Optional<syncer::ModelError>& error,\n       std::unique_ptr<syncer::MetadataBatch> metadata_batch) {\n     if (error) {\n       std::move(callback).Run(error, /*store=*/nullptr,\n                               /*metadata_batch=*/nullptr);\n      return;\n    }\n\n    std::map<std::string, sync_pb::SessionSpecifics> initial_data;\n    for (ModelTypeStore::Record& record : *record_list) {\n      const std::string& storage_key = record.id;\n      SessionSpecifics specifics;\n      if (storage_key.empty() ||\n          !specifics.ParseFromString(std::move(record.value))) {\n        DVLOG(1) << \"Ignoring corrupt database entry with key: \" << storage_key;\n        continue;\n      }\n      initial_data[storage_key].Swap(&specifics);\n    }\n\n    auto session_store = std::make_unique<SessionStore>(\n        sessions_client_, session_info, std::move(store),\n        std::move(initial_data), metadata_batch->GetAllMetadata(),\n        restored_foreign_tab_callback_);\n\n    std::move(callback).Run(/*error=*/base::nullopt, std::move(session_store),\n                            std::move(metadata_batch));\n  }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143681,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "  void OnReadAllMetadata(\n      const SessionStore::SessionInfo& session_info,\n      SessionStore::FactoryCompletionCallback callback,\n      std::unique_ptr<ModelTypeStore> store,\n       std::unique_ptr<ModelTypeStore::RecordList> record_list,\n       const base::Optional<syncer::ModelError>& error,\n       std::unique_ptr<syncer::MetadataBatch> metadata_batch) {\n    // Remove after fixing https://crbug.com/902203.\n    TRACE_EVENT0(\"browser\", \"FactoryImpl::OnReadAllMetadata\");\n     if (error) {\n       std::move(callback).Run(error, /*store=*/nullptr,\n                               /*metadata_batch=*/nullptr);\n      return;\n    }\n\n    std::map<std::string, sync_pb::SessionSpecifics> initial_data;\n    for (ModelTypeStore::Record& record : *record_list) {\n      const std::string& storage_key = record.id;\n      SessionSpecifics specifics;\n      if (storage_key.empty() ||\n          !specifics.ParseFromString(std::move(record.value))) {\n        DVLOG(1) << \"Ignoring corrupt database entry with key: \" << storage_key;\n        continue;\n      }\n      initial_data[storage_key].Swap(&specifics);\n    }\n\n    auto session_store = std::make_unique<SessionStore>(\n        sessions_client_, session_info, std::move(store),\n        std::move(initial_data), metadata_batch->GetAllMetadata(),\n        restored_foreign_tab_callback_);\n\n    std::move(callback).Run(/*error=*/base::nullopt, std::move(session_store),\n                            std::move(metadata_batch));\n  }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143682,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void NavigatorImpl::DiscardPendingEntryIfNeeded(int expected_pending_entry_id) {\n  NavigationEntry* pending_entry = controller_->GetPendingEntry();\n  bool pending_matches_fail_msg =\n      pending_entry &&\n      expected_pending_entry_id == pending_entry->GetUniqueID();\n  if (!pending_matches_fail_msg)\n    return;\n\n  bool should_preserve_entry = controller_->IsUnmodifiedBlankTab() ||\n                               delegate_->ShouldPreserveAbortedURLs();\n   if (pending_entry != controller_->GetVisibleEntry() ||\n       !should_preserve_entry) {\n     controller_->DiscardPendingEntry(true);\n\n    controller_->delegate()->NotifyNavigationStateChanged(INVALIDATE_TYPE_URL);\n  }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143683,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void NavigatorImpl::DiscardPendingEntryIfNeeded(int expected_pending_entry_id) {\n  NavigationEntry* pending_entry = controller_->GetPendingEntry();\n  bool pending_matches_fail_msg =\n      pending_entry &&\n      expected_pending_entry_id == pending_entry->GetUniqueID();\n  if (!pending_matches_fail_msg)\n    return;\n\n  // Do not leave the pending entry visible if it has an invalid URL, since this\n  // might be formatted in an unexpected or unsafe way.\n  // TODO(creis): Block navigations to invalid URLs in https://crbug.com/850824.\n  //\n  bool should_preserve_entry = pending_entry->GetURL().is_valid() &&\n                               (controller_->IsUnmodifiedBlankTab() ||\n                                delegate_->ShouldPreserveAbortedURLs());\n   if (pending_entry != controller_->GetVisibleEntry() ||\n       !should_preserve_entry) {\n     controller_->DiscardPendingEntry(true);\n\n    controller_->delegate()->NotifyNavigationStateChanged(INVALIDATE_TYPE_URL);\n  }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143684,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void NavigationRequest::OnStartChecksComplete(\n    NavigationThrottle::ThrottleCheckResult result) {\n  DCHECK(result.action() != NavigationThrottle::DEFER);\n  DCHECK(result.action() != NavigationThrottle::BLOCK_RESPONSE);\n\n  if (on_start_checks_complete_closure_)\n    on_start_checks_complete_closure_.Run();\n  if (result.action() == NavigationThrottle::CANCEL_AND_IGNORE ||\n      result.action() == NavigationThrottle::CANCEL ||\n      result.action() == NavigationThrottle::BLOCK_REQUEST ||\n      result.action() == NavigationThrottle::BLOCK_REQUEST_AND_COLLAPSE) {\n#if DCHECK_IS_ON()\n    if (result.action() == NavigationThrottle::BLOCK_REQUEST) {\n      DCHECK(result.net_error_code() == net::ERR_BLOCKED_BY_CLIENT ||\n             result.net_error_code() == net::ERR_BLOCKED_BY_ADMINISTRATOR);\n    }\n    else if (result.action() == NavigationThrottle::CANCEL_AND_IGNORE) {\n      DCHECK_EQ(result.net_error_code(), net::ERR_ABORTED);\n    }\n#endif\n\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(&NavigationRequest::OnRequestFailedInternal,\n                       weak_factory_.GetWeakPtr(), false,\n                       result.net_error_code(), base::nullopt, true,\n                       result.error_page_content()));\n\n    return;\n  }\n\n  DCHECK_NE(AssociatedSiteInstanceType::NONE, associated_site_instance_type_);\n  RenderFrameHostImpl* navigating_frame_host =\n      associated_site_instance_type_ == AssociatedSiteInstanceType::SPECULATIVE\n          ? frame_tree_node_->render_manager()->speculative_frame_host()\n          : frame_tree_node_->current_frame_host();\n  DCHECK(navigating_frame_host);\n\n  navigation_handle_->SetExpectedProcess(navigating_frame_host->GetProcess());\n\n  BrowserContext* browser_context =\n      frame_tree_node_->navigator()->GetController()->GetBrowserContext();\n  StoragePartition* partition = BrowserContext::GetStoragePartition(\n      browser_context, navigating_frame_host->GetSiteInstance());\n  DCHECK(partition);\n\n  bool can_create_service_worker =\n      (frame_tree_node_->pending_frame_policy().sandbox_flags &\n       blink::WebSandboxFlags::kOrigin) != blink::WebSandboxFlags::kOrigin;\n  request_params_.should_create_service_worker = can_create_service_worker;\n  if (can_create_service_worker) {\n    ServiceWorkerContextWrapper* service_worker_context =\n        static_cast<ServiceWorkerContextWrapper*>(\n            partition->GetServiceWorkerContext());\n    navigation_handle_->InitServiceWorkerHandle(service_worker_context);\n  }\n\n  if (IsSchemeSupportedForAppCache(common_params_.url)) {\n    if (navigating_frame_host->GetRenderViewHost()\n            ->GetWebkitPreferences()\n            .application_cache_enabled) {\n      navigation_handle_->InitAppCacheHandle(\n          static_cast<ChromeAppCacheService*>(partition->GetAppCacheService()));\n    }\n  }\n\n  request_params_.navigation_timing.fetch_start = base::TimeTicks::Now();\n\n  GURL base_url;\n#if defined(OS_ANDROID)\n  NavigationEntry* last_committed_entry =\n      frame_tree_node_->navigator()->GetController()->GetLastCommittedEntry();\n  if (last_committed_entry)\n    base_url = last_committed_entry->GetBaseURLForDataURL();\n#endif\n  const GURL& top_document_url =\n       !base_url.is_empty()\n           ? base_url\n           : frame_tree_node_->frame_tree()->root()->current_url();\n   const GURL& site_for_cookies =\n      frame_tree_node_->IsMainFrame() ? common_params_.url : top_document_url;\n   bool parent_is_main_frame = !frame_tree_node_->parent()\n                                   ? false\n                                   : frame_tree_node_->parent()->IsMainFrame();\n\n  std::unique_ptr<NavigationUIData> navigation_ui_data;\n  if (navigation_handle_->GetNavigationUIData())\n    navigation_ui_data = navigation_handle_->GetNavigationUIData()->Clone();\n\n  bool is_for_guests_only =\n      navigation_handle_->GetStartingSiteInstance()->GetSiteURL().\n          SchemeIs(kGuestScheme);\n\n  bool report_raw_headers = false;\n  RenderFrameDevToolsAgentHost::ApplyOverrides(\n      frame_tree_node_, begin_params_.get(), &report_raw_headers);\n  RenderFrameDevToolsAgentHost::OnNavigationRequestWillBeSent(*this);\n\n  loader_ = NavigationURLLoader::Create(\n      browser_context->GetResourceContext(), partition,\n      std::make_unique<NavigationRequestInfo>(\n          common_params_, begin_params_.Clone(), site_for_cookies,\n          frame_tree_node_->IsMainFrame(), parent_is_main_frame,\n          IsSecureFrame(frame_tree_node_->parent()),\n          frame_tree_node_->frame_tree_node_id(), is_for_guests_only,\n          report_raw_headers,\n          navigating_frame_host->GetVisibilityState() ==\n              blink::mojom::PageVisibilityState::kPrerender,\n          blob_url_loader_factory_ ? blob_url_loader_factory_->Clone()\n                                   : nullptr),\n      std::move(navigation_ui_data),\n      navigation_handle_->service_worker_handle(),\n      navigation_handle_->appcache_handle(), this);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143687,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void NavigationRequest::OnStartChecksComplete(\n    NavigationThrottle::ThrottleCheckResult result) {\n  DCHECK(result.action() != NavigationThrottle::DEFER);\n  DCHECK(result.action() != NavigationThrottle::BLOCK_RESPONSE);\n\n  if (on_start_checks_complete_closure_)\n    on_start_checks_complete_closure_.Run();\n  if (result.action() == NavigationThrottle::CANCEL_AND_IGNORE ||\n      result.action() == NavigationThrottle::CANCEL ||\n      result.action() == NavigationThrottle::BLOCK_REQUEST ||\n      result.action() == NavigationThrottle::BLOCK_REQUEST_AND_COLLAPSE) {\n#if DCHECK_IS_ON()\n    if (result.action() == NavigationThrottle::BLOCK_REQUEST) {\n      DCHECK(result.net_error_code() == net::ERR_BLOCKED_BY_CLIENT ||\n             result.net_error_code() == net::ERR_BLOCKED_BY_ADMINISTRATOR);\n    }\n    else if (result.action() == NavigationThrottle::CANCEL_AND_IGNORE) {\n      DCHECK_EQ(result.net_error_code(), net::ERR_ABORTED);\n    }\n#endif\n\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(&NavigationRequest::OnRequestFailedInternal,\n                       weak_factory_.GetWeakPtr(), false,\n                       result.net_error_code(), base::nullopt, true,\n                       result.error_page_content()));\n\n    return;\n  }\n\n  DCHECK_NE(AssociatedSiteInstanceType::NONE, associated_site_instance_type_);\n  RenderFrameHostImpl* navigating_frame_host =\n      associated_site_instance_type_ == AssociatedSiteInstanceType::SPECULATIVE\n          ? frame_tree_node_->render_manager()->speculative_frame_host()\n          : frame_tree_node_->current_frame_host();\n  DCHECK(navigating_frame_host);\n\n  navigation_handle_->SetExpectedProcess(navigating_frame_host->GetProcess());\n\n  BrowserContext* browser_context =\n      frame_tree_node_->navigator()->GetController()->GetBrowserContext();\n  StoragePartition* partition = BrowserContext::GetStoragePartition(\n      browser_context, navigating_frame_host->GetSiteInstance());\n  DCHECK(partition);\n\n  bool can_create_service_worker =\n      (frame_tree_node_->pending_frame_policy().sandbox_flags &\n       blink::WebSandboxFlags::kOrigin) != blink::WebSandboxFlags::kOrigin;\n  request_params_.should_create_service_worker = can_create_service_worker;\n  if (can_create_service_worker) {\n    ServiceWorkerContextWrapper* service_worker_context =\n        static_cast<ServiceWorkerContextWrapper*>(\n            partition->GetServiceWorkerContext());\n    navigation_handle_->InitServiceWorkerHandle(service_worker_context);\n  }\n\n  if (IsSchemeSupportedForAppCache(common_params_.url)) {\n    if (navigating_frame_host->GetRenderViewHost()\n            ->GetWebkitPreferences()\n            .application_cache_enabled) {\n      navigation_handle_->InitAppCacheHandle(\n          static_cast<ChromeAppCacheService*>(partition->GetAppCacheService()));\n    }\n  }\n\n  request_params_.navigation_timing.fetch_start = base::TimeTicks::Now();\n\n  GURL base_url;\n#if defined(OS_ANDROID)\n  NavigationEntry* last_committed_entry =\n      frame_tree_node_->navigator()->GetController()->GetLastCommittedEntry();\n  if (last_committed_entry)\n    base_url = last_committed_entry->GetBaseURLForDataURL();\n#endif\n  const GURL& top_document_url =\n       !base_url.is_empty()\n           ? base_url\n           : frame_tree_node_->frame_tree()->root()->current_url();\n\n  // Walk the ancestor chain to determine whether all frames are same-site. If\n  // not, the |site_for_cookies| is set to an empty URL.\n  //\n  // 'Document::SiteForCookies()' in Blink, which special-cases extension\n  // URLs and a few other sharp edges.\n  const FrameTreeNode* current = frame_tree_node_->parent();\n  bool ancestors_are_same_site = true;\n  while (current && ancestors_are_same_site) {\n    if (!net::registry_controlled_domains::SameDomainOrHost(\n            top_document_url, current->current_url(),\n            net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES)) {\n      ancestors_are_same_site = false;\n    }\n    current = current->parent();\n  }\n   const GURL& site_for_cookies =\n      ancestors_are_same_site\n          ? (frame_tree_node_->IsMainFrame() ? common_params_.url\n                                             : top_document_url)\n          : GURL::EmptyGURL();\n   bool parent_is_main_frame = !frame_tree_node_->parent()\n                                   ? false\n                                   : frame_tree_node_->parent()->IsMainFrame();\n\n  std::unique_ptr<NavigationUIData> navigation_ui_data;\n  if (navigation_handle_->GetNavigationUIData())\n    navigation_ui_data = navigation_handle_->GetNavigationUIData()->Clone();\n\n  bool is_for_guests_only =\n      navigation_handle_->GetStartingSiteInstance()->GetSiteURL().\n          SchemeIs(kGuestScheme);\n\n  bool report_raw_headers = false;\n  RenderFrameDevToolsAgentHost::ApplyOverrides(\n      frame_tree_node_, begin_params_.get(), &report_raw_headers);\n  RenderFrameDevToolsAgentHost::OnNavigationRequestWillBeSent(*this);\n\n  loader_ = NavigationURLLoader::Create(\n      browser_context->GetResourceContext(), partition,\n      std::make_unique<NavigationRequestInfo>(\n          common_params_, begin_params_.Clone(), site_for_cookies,\n          frame_tree_node_->IsMainFrame(), parent_is_main_frame,\n          IsSecureFrame(frame_tree_node_->parent()),\n          frame_tree_node_->frame_tree_node_id(), is_for_guests_only,\n          report_raw_headers,\n          navigating_frame_host->GetVisibilityState() ==\n              blink::mojom::PageVisibilityState::kPrerender,\n          blob_url_loader_factory_ ? blob_url_loader_factory_->Clone()\n                                   : nullptr),\n      std::move(navigation_ui_data),\n      navigation_handle_->service_worker_handle(),\n      navigation_handle_->appcache_handle(), this);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143688,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void IDNSpoofChecker::SetAllowedUnicodeSet(UErrorCode* status) {\n  if (U_FAILURE(*status))\n    return;\n\n  const icu::UnicodeSet* recommended_set =\n      uspoof_getRecommendedUnicodeSet(status);\n  icu::UnicodeSet allowed_set;\n  allowed_set.addAll(*recommended_set);\n  const icu::UnicodeSet* inclusion_set = uspoof_getInclusionUnicodeSet(status);\n  allowed_set.addAll(*inclusion_set);\n\n  allowed_set.remove(0x338u);\n\n  allowed_set.remove(0x58au);  // Armenian Hyphen\n  allowed_set.remove(0x2010u);\n  allowed_set.remove(0x2019u);  // Right Single Quotation Mark\n  allowed_set.remove(0x2027u);\n  allowed_set.remove(0x30a0u);  // Katakana-Hiragana Double Hyphen\n\n   allowed_set.remove(0x2bbu);  // Modifier Letter Turned Comma\n   allowed_set.remove(0x2bcu);  // Modifier Letter Apostrophe\n \n#if defined(OS_MACOSX)\n\n  allowed_set.remove(0x0620u);\n\n  allowed_set.remove(0x0F8Cu);\n  allowed_set.remove(0x0F8Du);\n  allowed_set.remove(0x0F8Eu);\n  allowed_set.remove(0x0F8Fu);\n#endif\n\n  allowed_set.remove(0x01CDu, 0x01DCu);  // Latin Ext B; Pinyin\n  allowed_set.remove(0x1C80u, 0x1C8Fu);  // Cyrillic Extended-C\n  allowed_set.remove(0x1E00u, 0x1E9Bu);  // Latin Extended Additional\n  allowed_set.remove(0x1F00u, 0x1FFFu);  // Greek Extended\n  allowed_set.remove(0xA640u, 0xA69Fu);  // Cyrillic Extended-B\n  allowed_set.remove(0xA720u, 0xA7FFu);  // Latin Extended-D\n\n  uspoof_setAllowedUnicodeSet(checker_, &allowed_set, status);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143689,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void IDNSpoofChecker::SetAllowedUnicodeSet(UErrorCode* status) {\n  if (U_FAILURE(*status))\n    return;\n\n  const icu::UnicodeSet* recommended_set =\n      uspoof_getRecommendedUnicodeSet(status);\n  icu::UnicodeSet allowed_set;\n  allowed_set.addAll(*recommended_set);\n  const icu::UnicodeSet* inclusion_set = uspoof_getInclusionUnicodeSet(status);\n  allowed_set.addAll(*inclusion_set);\n\n  allowed_set.remove(0x338u);\n\n  allowed_set.remove(0x58au);  // Armenian Hyphen\n  allowed_set.remove(0x2010u);\n  allowed_set.remove(0x2019u);  // Right Single Quotation Mark\n  allowed_set.remove(0x2027u);\n  allowed_set.remove(0x30a0u);  // Katakana-Hiragana Double Hyphen\n\n   allowed_set.remove(0x2bbu);  // Modifier Letter Turned Comma\n   allowed_set.remove(0x2bcu);  // Modifier Letter Apostrophe\n\n  // Block modifier letter voicing.\n  allowed_set.remove(0x2ecu);\n\n \n#if defined(OS_MACOSX)\n\n  allowed_set.remove(0x0620u);\n\n  allowed_set.remove(0x0F8Cu);\n  allowed_set.remove(0x0F8Du);\n  allowed_set.remove(0x0F8Eu);\n  allowed_set.remove(0x0F8Fu);\n#endif\n\n  allowed_set.remove(0x01CDu, 0x01DCu);  // Latin Ext B; Pinyin\n  allowed_set.remove(0x1C80u, 0x1C8Fu);  // Cyrillic Extended-C\n  allowed_set.remove(0x1E00u, 0x1E9Bu);  // Latin Extended Additional\n  allowed_set.remove(0x1F00u, 0x1FFFu);  // Greek Extended\n  allowed_set.remove(0xA640u, 0xA69Fu);  // Cyrillic Extended-B\n  allowed_set.remove(0xA720u, 0xA7FFu);  // Latin Extended-D\n\n  uspoof_setAllowedUnicodeSet(checker_, &allowed_set, status);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143690,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n      icu::UnicodeString::fromUTF8(\n          \"[\u00e6\u04d5] > ae; [\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u050b\u0527\u0529] > h;\"\n          \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f\u0525\u0e01] > n; \u0153 > ce;\"\n          \"[\u0167\u0442\u04ad\u050f] > t; [\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1e\u0e1f\u0e9e\u0e9f] > w;\"\n           \"[\u043c\u04ce] > m; [\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; [\u0493\u04fb] > f;\"\n           \"[\u04ab\u1004] > c; \u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n           \"\u0503  > d; [\u050d\u100c] > g; [\u0d1f\u0e23\u0ea3\u0eae] > s; \u1042 > j;\"\n          \"[\u0437\u0499\u04e1\u10d5\u1012] > 3; [\u0e1a\u0e9a] > u\"),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143691,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n  //   - {U+0437 (\u0437), U+0499 (\u0499), U+04E1 (\u04e1), U+1012 (\u1012), U+10D5 (\u10d5),\n  //      U+10DE (\u10de)} => 3\n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n      icu::UnicodeString::fromUTF8(\n          \"[\u00e6\u04d5] > ae; [\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u050b\u0527\u0529] > h;\"\n          \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f\u0525\u0e01] > n; \u0153 > ce;\"\n          \"[\u0167\u0442\u04ad\u050f] > t; [\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1e\u0e1f\u0e9e\u0e9f] > w;\"\n           \"[\u043c\u04ce] > m; [\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; [\u0493\u04fb] > f;\"\n           \"[\u04ab\u1004] > c; \u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n           \"\u0503  > d; [\u050d\u100c] > g; [\u0d1f\u0e23\u0ea3\u0eae] > s; \u1042 > j;\"\n          \"[\u0437\u0499\u04e1\u1012\u10d5\u10de] > 3; [\u0e1a\u0e9a] > u\"),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143692,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n      icu::UnicodeString::fromUTF8(\n          \"[\u00e6\u04d5] > ae; [\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u050b\u0527\u0529] > h;\"\n          \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f\u0525\u0e01] > n; \u0153 > ce;\"\n          \"[\u0167\u0442\u04ad\u050f] > t; [\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1e\u0e1f\u0e9e\u0e9f] > w;\"\n           \"[\u043c\u04ce] > m; [\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; [\u0493\u04fb] > f;\"\n           \"[\u04ab\u1004] > c; \u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n           \"\u0503  > d; [\u050d\u100c] > g; [\u0d1f\u0e23\u0ea3\u0eae] > s; \u1042 > j;\"\n          \"[\u0437\u0499\u04e1\u1012\u10d5\u10de] > 3; [\u0e1a\u0e9a] > u\"),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143693,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n  //   - {U+0437 (\u0437), U+0499 (\u0499), U+04E1 (\u04e1), U+0909 (\u0909), U+0993 (\u0993),\n  //      U+1012 (\u1012), U+10D5 (\u10d5), U+10DE (\u10de)} => 3\n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n      icu::UnicodeString::fromUTF8(\n          \"[\u00e6\u04d5] > ae; [\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u050b\u0527\u0529] > h;\"\n          \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f\u0525\u0e01] > n; \u0153 > ce;\"\n          \"[\u0167\u0442\u04ad\u050f] > t; [\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1e\u0e1f\u0e9e\u0e9f] > w;\"\n           \"[\u043c\u04ce] > m; [\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; [\u0493\u04fb] > f;\"\n           \"[\u04ab\u1004] > c; \u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n           \"\u0503  > d; [\u050d\u100c] > g; [\u0d1f\u0e23\u0ea3\u0eae] > s; \u1042 > j;\"\n          \"[\u0437\u0499\u04e1\u0909\u0993\u1012\u10d5\u10de] > 3; [\u0e1a\u0e9a] > u\"),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143694,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " void AppCacheGroup::RemoveCache(AppCache* cache) {\n   DCHECK(cache->associated_hosts().empty());\n   if (cache == newest_complete_cache_) {\n    CancelUpdate();\n     AppCache* tmp_cache = newest_complete_cache_;\n     newest_complete_cache_ = nullptr;\n     tmp_cache->set_owning_group(nullptr);  // may cause this group to be deleted\n   } else {\n     scoped_refptr<AppCacheGroup> protect(this);\n\n    Caches::iterator it =\n        std::find(old_caches_.begin(), old_caches_.end(), cache);\n    if (it != old_caches_.end()) {\n      AppCache* tmp_cache = *it;\n      old_caches_.erase(it);\n      tmp_cache->set_owning_group(nullptr);  // may cause group to be released\n    }\n\n    if (!is_obsolete() && old_caches_.empty() &&\n        !newly_deletable_response_ids_.empty()) {\n      storage_->DeleteResponses(manifest_url_, newly_deletable_response_ids_);\n      newly_deletable_response_ids_.clear();\n    }\n  }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143695,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " void AppCacheGroup::RemoveCache(AppCache* cache) {\n   DCHECK(cache->associated_hosts().empty());\n   if (cache == newest_complete_cache_) {\n     AppCache* tmp_cache = newest_complete_cache_;\n     newest_complete_cache_ = nullptr;\n    CancelUpdate();\n     tmp_cache->set_owning_group(nullptr);  // may cause this group to be deleted\n   } else {\n     scoped_refptr<AppCacheGroup> protect(this);\n\n    Caches::iterator it =\n        std::find(old_caches_.begin(), old_caches_.end(), cache);\n    if (it != old_caches_.end()) {\n      AppCache* tmp_cache = *it;\n      old_caches_.erase(it);\n      tmp_cache->set_owning_group(nullptr);  // may cause group to be released\n    }\n\n    if (!is_obsolete() && old_caches_.empty() &&\n        !newly_deletable_response_ids_.empty()) {\n      storage_->DeleteResponses(manifest_url_, newly_deletable_response_ids_);\n      newly_deletable_response_ids_.clear();\n    }\n  }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143696,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n  extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n       icu::UnicodeString::fromUTF8(\n           \"[\u00e6\u04d5] > ae; [\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u050b\u0527\u0529] > h;\"\n          \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f\u0525] > n; \u0153 > ce;\"\n           \"[\u0167\u0442\u04ad\u050f] > t; [\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1e\u0e1f\u0e9e\u0e9f] > w;\"\n           \"[\u043c\u04ce] > m; [\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; [\u0493\u04fb] > f;\"\n           \"[\u04ab\u1004] > c; \u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n          \"\u0503  > d; [\u050d\u100c] > g; [\u0d1f\u0e23\u0ea3\u0eae] > s; \u1042 > j;\"\n          \"[\u0437\u0499\u04e1\u10d5\u1012] > 3; [\u0e1a\u0e9a] > u\"),\n      UTRANS_FORWARD, parse_error, status));\n  DCHECK(U_SUCCESS(status))\n      << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143697,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n  //   - {U+014B (\u014b), U+043F (\u043f), U+0525 (\u0525), U+0E01 (\u0e01)} => n\n  extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n       icu::UnicodeString::fromUTF8(\n           \"[\u00e6\u04d5] > ae; [\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u050b\u0527\u0529] > h;\"\n          \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f\u0525\u0e01] > n; \u0153 > ce;\"\n           \"[\u0167\u0442\u04ad\u050f] > t; [\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1e\u0e1f\u0e9e\u0e9f] > w;\"\n           \"[\u043c\u04ce] > m; [\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; [\u0493\u04fb] > f;\"\n           \"[\u04ab\u1004] > c; \u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n          \"\u0503  > d; [\u050d\u100c] > g; [\u0d1f\u0e23\u0ea3\u0eae] > s; \u1042 > j;\"\n          \"[\u0437\u0499\u04e1\u10d5\u1012] > 3; [\u0e1a\u0e9a] > u\"),\n      UTRANS_FORWARD, parse_error, status));\n  DCHECK(U_SUCCESS(status))\n      << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143698,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void Browser::SetWebContentsBlocked(content::WebContents* web_contents,\n                                    bool blocked) {\n  int index = tab_strip_model_->GetIndexOfWebContents(web_contents);\n  if (index == TabStripModel::kNoTab) {\n     return;\n   }\n   tab_strip_model_->SetTabBlocked(index, blocked);\n \n   bool browser_active = BrowserList::GetInstance()->GetLastActive() == this;\n  bool contents_is_active =\n      tab_strip_model_->GetActiveWebContents() == web_contents;\n  if (!blocked && contents_is_active && browser_active)\n    web_contents->Focus();\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143699,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void Browser::SetWebContentsBlocked(content::WebContents* web_contents,\n                                    bool blocked) {\n  int index = tab_strip_model_->GetIndexOfWebContents(web_contents);\n  if (index == TabStripModel::kNoTab) {\n     return;\n   }\n\n  // For security, if the WebContents is in fullscreen, have it drop fullscreen.\n  // This gives the user the context they need in order to make informed\n  // decisions.\n  if (web_contents->IsFullscreenForCurrentTab())\n    web_contents->ExitFullscreen(true);\n\n   tab_strip_model_->SetTabBlocked(index, blocked);\n \n   bool browser_active = BrowserList::GetInstance()->GetLastActive() == this;\n  bool contents_is_active =\n      tab_strip_model_->GetActiveWebContents() == web_contents;\n  if (!blocked && contents_is_active && browser_active)\n    web_contents->Focus();\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143700,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool DownloadItemImpl::CanOpenDownload() {\n   const bool is_complete = GetState() == DownloadItem::COMPLETE;\n   return (!IsDone() || is_complete) && !IsTemporary() &&\n         !file_externally_removed_;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143703,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool DownloadItemImpl::CanOpenDownload() {\n   const bool is_complete = GetState() == DownloadItem::COMPLETE;\n   return (!IsDone() || is_complete) && !IsTemporary() &&\n         !file_externally_removed_ &&\n         delegate_->IsMostRecentDownloadItemAtFilePath(this);\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143704,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "RenderFrameHostImpl* RenderFrameHostManager::GetFrameHostForNavigation(\n    const NavigationRequest& request) {\n  DCHECK(!request.common_params().url.SchemeIs(url::kJavaScriptScheme))\n      << \"Don't call this method for JavaScript URLs as those create a \"\n         \"temporary  NavigationRequest and we don't want to reset an ongoing \"\n         \"navigation's speculative RFH.\";\n\n  RenderFrameHostImpl* navigation_rfh = nullptr;\n\n  SiteInstance* current_site_instance = render_frame_host_->GetSiteInstance();\n  scoped_refptr<SiteInstance> dest_site_instance =\n      GetSiteInstanceForNavigationRequest(request);\n\n  bool use_current_rfh = current_site_instance == dest_site_instance;\n\n  bool notify_webui_of_rf_creation = false;\n  if (use_current_rfh) {\n     if (speculative_render_frame_host_) {\n      if (speculative_render_frame_host_->navigation_handle()) {\n         frame_tree_node_->navigator()->DiscardPendingEntryIfNeeded(\n             speculative_render_frame_host_->navigation_handle()\n                 ->pending_nav_entry_id());\n      }\n      DiscardUnusedFrame(UnsetSpeculativeRenderFrameHost());\n    }\n\n    if (frame_tree_node_->IsMainFrame()) {\n      UpdatePendingWebUIOnCurrentFrameHost(request.common_params().url,\n                                           request.bindings());\n    }\n\n    navigation_rfh = render_frame_host_.get();\n\n    DCHECK(!speculative_render_frame_host_);\n  } else {\n\n    if (!speculative_render_frame_host_ ||\n        speculative_render_frame_host_->GetSiteInstance() !=\n            dest_site_instance.get()) {\n      CleanUpNavigation();\n      bool success = CreateSpeculativeRenderFrameHost(current_site_instance,\n                                                      dest_site_instance.get());\n      DCHECK(success);\n    }\n    DCHECK(speculative_render_frame_host_);\n\n    if (frame_tree_node_->IsMainFrame()) {\n      bool changed_web_ui = speculative_render_frame_host_->UpdatePendingWebUI(\n          request.common_params().url, request.bindings());\n      speculative_render_frame_host_->CommitPendingWebUI();\n      DCHECK_EQ(GetNavigatingWebUI(), speculative_render_frame_host_->web_ui());\n      notify_webui_of_rf_creation =\n          changed_web_ui && speculative_render_frame_host_->web_ui();\n    }\n    navigation_rfh = speculative_render_frame_host_.get();\n\n    if (!render_frame_host_->IsRenderFrameLive()) {\n      if (GetRenderFrameProxyHost(dest_site_instance.get())) {\n        navigation_rfh->Send(\n            new FrameMsg_SwapIn(navigation_rfh->GetRoutingID()));\n      }\n      CommitPending();\n\n      if (notify_webui_of_rf_creation && render_frame_host_->web_ui()) {\n        render_frame_host_->web_ui()->RenderFrameCreated(\n            render_frame_host_.get());\n        notify_webui_of_rf_creation = false;\n      }\n    }\n  }\n  DCHECK(navigation_rfh &&\n         (navigation_rfh == render_frame_host_.get() ||\n          navigation_rfh == speculative_render_frame_host_.get()));\n\n  if (!navigation_rfh->IsRenderFrameLive()) {\n    if (!ReinitializeRenderFrame(navigation_rfh))\n      return nullptr;\n\n    notify_webui_of_rf_creation = true;\n\n    if (navigation_rfh == render_frame_host_.get()) {\n      EnsureRenderFrameHostVisibilityConsistent();\n      EnsureRenderFrameHostPageFocusConsistent();\n      delegate_->NotifyMainFrameSwappedFromRenderManager(\n          nullptr, render_frame_host_->render_view_host());\n    }\n  }\n\n  if (notify_webui_of_rf_creation && GetNavigatingWebUI() &&\n      frame_tree_node_->IsMainFrame()) {\n    GetNavigatingWebUI()->RenderFrameCreated(navigation_rfh);\n  }\n\n  return navigation_rfh;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143705,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "RenderFrameHostImpl* RenderFrameHostManager::GetFrameHostForNavigation(\n    const NavigationRequest& request) {\n  DCHECK(!request.common_params().url.SchemeIs(url::kJavaScriptScheme))\n      << \"Don't call this method for JavaScript URLs as those create a \"\n         \"temporary  NavigationRequest and we don't want to reset an ongoing \"\n         \"navigation's speculative RFH.\";\n\n  RenderFrameHostImpl* navigation_rfh = nullptr;\n\n  SiteInstance* current_site_instance = render_frame_host_->GetSiteInstance();\n  scoped_refptr<SiteInstance> dest_site_instance =\n      GetSiteInstanceForNavigationRequest(request);\n\n  bool use_current_rfh = current_site_instance == dest_site_instance;\n\n  bool notify_webui_of_rf_creation = false;\n  if (use_current_rfh) {\n     if (speculative_render_frame_host_) {\n      // NavigationEntry stopped if needed. This is the case if the new\n      // navigation was started from BeginNavigation. If the navigation was\n      // started through the NavigationController, the NavigationController has\n      // already updated its state properly, and doesn't need to be notified.\n      if (speculative_render_frame_host_->navigation_handle() &&\n          request.from_begin_navigation()) {\n         frame_tree_node_->navigator()->DiscardPendingEntryIfNeeded(\n             speculative_render_frame_host_->navigation_handle()\n                 ->pending_nav_entry_id());\n      }\n      DiscardUnusedFrame(UnsetSpeculativeRenderFrameHost());\n    }\n\n    if (frame_tree_node_->IsMainFrame()) {\n      UpdatePendingWebUIOnCurrentFrameHost(request.common_params().url,\n                                           request.bindings());\n    }\n\n    navigation_rfh = render_frame_host_.get();\n\n    DCHECK(!speculative_render_frame_host_);\n  } else {\n\n    if (!speculative_render_frame_host_ ||\n        speculative_render_frame_host_->GetSiteInstance() !=\n            dest_site_instance.get()) {\n      CleanUpNavigation();\n      bool success = CreateSpeculativeRenderFrameHost(current_site_instance,\n                                                      dest_site_instance.get());\n      DCHECK(success);\n    }\n    DCHECK(speculative_render_frame_host_);\n\n    if (frame_tree_node_->IsMainFrame()) {\n      bool changed_web_ui = speculative_render_frame_host_->UpdatePendingWebUI(\n          request.common_params().url, request.bindings());\n      speculative_render_frame_host_->CommitPendingWebUI();\n      DCHECK_EQ(GetNavigatingWebUI(), speculative_render_frame_host_->web_ui());\n      notify_webui_of_rf_creation =\n          changed_web_ui && speculative_render_frame_host_->web_ui();\n    }\n    navigation_rfh = speculative_render_frame_host_.get();\n\n    if (!render_frame_host_->IsRenderFrameLive()) {\n      if (GetRenderFrameProxyHost(dest_site_instance.get())) {\n        navigation_rfh->Send(\n            new FrameMsg_SwapIn(navigation_rfh->GetRoutingID()));\n      }\n      CommitPending();\n\n      if (notify_webui_of_rf_creation && render_frame_host_->web_ui()) {\n        render_frame_host_->web_ui()->RenderFrameCreated(\n            render_frame_host_.get());\n        notify_webui_of_rf_creation = false;\n      }\n    }\n  }\n  DCHECK(navigation_rfh &&\n         (navigation_rfh == render_frame_host_.get() ||\n          navigation_rfh == speculative_render_frame_host_.get()));\n\n  if (!navigation_rfh->IsRenderFrameLive()) {\n    if (!ReinitializeRenderFrame(navigation_rfh))\n      return nullptr;\n\n    notify_webui_of_rf_creation = true;\n\n    if (navigation_rfh == render_frame_host_.get()) {\n      EnsureRenderFrameHostVisibilityConsistent();\n      EnsureRenderFrameHostPageFocusConsistent();\n      delegate_->NotifyMainFrameSwappedFromRenderManager(\n          nullptr, render_frame_host_->render_view_host());\n    }\n  }\n\n  if (notify_webui_of_rf_creation && GetNavigatingWebUI() &&\n      frame_tree_node_->IsMainFrame()) {\n    GetNavigatingWebUI()->RenderFrameCreated(navigation_rfh);\n  }\n\n  return navigation_rfh;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143706,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "GURL SanitizeFrontendURL(const GURL& url,\n                         const std::string& scheme,\n                         const std::string& host,\n                         const std::string& path,\n                         bool allow_query_and_fragment) {\n  std::vector<std::string> query_parts;\n  std::string fragment;\n  if (allow_query_and_fragment) {\n    for (net::QueryIterator it(url); !it.IsAtEnd(); it.Advance()) {\n      std::string value = SanitizeFrontendQueryParam(it.GetKey(),\n          it.GetValue());\n      if (!value.empty()) {\n        query_parts.push_back(\n             base::StringPrintf(\"%s=%s\", it.GetKey().c_str(), value.c_str()));\n       }\n     }\n    if (url.has_ref())\n       fragment = '#' + url.ref();\n   }\n   std::string query =\n      query_parts.empty() ? \"\" : \"?\" + base::JoinString(query_parts, \"&\");\n  std::string constructed =\n      base::StringPrintf(\"%s://%s%s%s%s\", scheme.c_str(), host.c_str(),\n                         path.c_str(), query.c_str(), fragment.c_str());\n  GURL result = GURL(constructed);\n  if (!result.is_valid())\n    return GURL();\n  return result;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143707,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "GURL SanitizeFrontendURL(const GURL& url,\n                         const std::string& scheme,\n                         const std::string& host,\n                         const std::string& path,\n                         bool allow_query_and_fragment) {\n  std::vector<std::string> query_parts;\n  std::string fragment;\n  if (allow_query_and_fragment) {\n    for (net::QueryIterator it(url); !it.IsAtEnd(); it.Advance()) {\n      std::string value = SanitizeFrontendQueryParam(it.GetKey(),\n          it.GetValue());\n      if (!value.empty()) {\n        query_parts.push_back(\n             base::StringPrintf(\"%s=%s\", it.GetKey().c_str(), value.c_str()));\n       }\n     }\n    if (url.has_ref() && url.ref_piece().find('\\'') == base::StringPiece::npos)\n       fragment = '#' + url.ref();\n   }\n   std::string query =\n      query_parts.empty() ? \"\" : \"?\" + base::JoinString(query_parts, \"&\");\n  std::string constructed =\n      base::StringPrintf(\"%s://%s%s%s%s\", scheme.c_str(), host.c_str(),\n                         path.c_str(), query.c_str(), fragment.c_str());\n  GURL result = GURL(constructed);\n  if (!result.is_valid())\n    return GURL();\n  return result;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143708,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool WebGLRenderingContextBase::ValidateHTMLImageElement(\n    const SecurityOrigin* security_origin,\n    const char* function_name,\n    HTMLImageElement* image,\n    ExceptionState& exception_state) {\n  if (!image || !image->CachedImage()) {\n    SynthesizeGLError(GL_INVALID_VALUE, function_name, \"no image\");\n    return false;\n  }\n  const KURL& url = image->CachedImage()->GetResponse().Url();\n  if (url.IsNull() || url.IsEmpty() || !url.IsValid()) {\n    SynthesizeGLError(GL_INVALID_VALUE, function_name, \"invalid image\");\n    return false;\n   }\n \n   if (WouldTaintOrigin(image, security_origin)) {\n    exception_state.ThrowSecurityError(\"The cross-origin image at \" +\n                                       url.ElidedString() +\n                                       \" may not be loaded.\");\n     return false;\n   }\n   return true;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143709,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool WebGLRenderingContextBase::ValidateHTMLImageElement(\n    const SecurityOrigin* security_origin,\n    const char* function_name,\n    HTMLImageElement* image,\n    ExceptionState& exception_state) {\n  if (!image || !image->CachedImage()) {\n    SynthesizeGLError(GL_INVALID_VALUE, function_name, \"no image\");\n    return false;\n  }\n  const KURL& url = image->CachedImage()->GetResponse().Url();\n  if (url.IsNull() || url.IsEmpty() || !url.IsValid()) {\n    SynthesizeGLError(GL_INVALID_VALUE, function_name, \"invalid image\");\n    return false;\n   }\n \n   if (WouldTaintOrigin(image, security_origin)) {\n    exception_state.ThrowSecurityError(\n        \"The image element contains cross-origin data, and may not be loaded.\");\n     return false;\n   }\n   return true;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143710,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,\n                                             bool is_tld_ascii) {\n  UErrorCode status = U_ZERO_ERROR;\n  int32_t result =\n      uspoof_check(checker_, label.data(),\n                   base::checked_cast<int32_t>(label.size()), nullptr, &status);\n  if (U_FAILURE(status) || (result & USPOOF_ALL_CHECKS))\n    return false;\n\n  icu::UnicodeString label_string(FALSE, label.data(),\n                                  base::checked_cast<int32_t>(label.size()));\n\n  if (deviation_characters_.containsSome(label_string))\n    return false;\n\n  result &= USPOOF_RESTRICTION_LEVEL_MASK;\n  if (result == USPOOF_ASCII)\n    return true;\n  if (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&\n      kana_letters_exceptions_.containsNone(label_string) &&\n      combining_diacritics_exceptions_.containsNone(label_string)) {\n    return !is_tld_ascii || !IsMadeOfLatinAlikeCyrillic(label_string);\n  }\n\n  if (non_ascii_latin_letters_.containsSome(label_string) &&\n      !lgc_letters_n_ascii_.containsAll(label_string))\n    return false;\n\n  if (!tls_index.initialized())\n    tls_index.Initialize(&OnThreadTermination);\n  icu::RegexMatcher* dangerous_pattern =\n      reinterpret_cast<icu::RegexMatcher*>(tls_index.Get());\n  if (!dangerous_pattern) {\n     dangerous_pattern = new icu::RegexMatcher(\n        icu::UnicodeString(\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}])\"\n            R\"([\\u30ce\\u30f3\\u30bd\\u30be])\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}]|)\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}]\\u30fc|^\\u30fc|)\"\n            R\"([^\\p{scx=kana}][\\u30fd\\u30fe]|^[\\u30fd\\u30fe]|)\"\n            R\"(^[\\p{scx=kana}]+[\\u3078-\\u307a][\\p{scx=kana}]+$|)\"\n             R\"(^[\\p{scx=hira}]+[\\u30d8-\\u30da][\\p{scx=hira}]+$|)\"\n             R\"([a-z]\\u30fb|\\u30fb[a-z]|)\"\n             R\"([^\\p{scx=latn}\\p{scx=grek}\\p{scx=cyrl}][\\u0300-\\u0339]|)\"\n            R\"([ijl\\u0131]\\u0307)\",\n             -1, US_INV),\n         0, status);\n     tls_index.Set(dangerous_pattern);\n  }\n  dangerous_pattern->reset(label_string);\n  return !dangerous_pattern->find();\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143711,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,\n                                             bool is_tld_ascii) {\n  UErrorCode status = U_ZERO_ERROR;\n  int32_t result =\n      uspoof_check(checker_, label.data(),\n                   base::checked_cast<int32_t>(label.size()), nullptr, &status);\n  if (U_FAILURE(status) || (result & USPOOF_ALL_CHECKS))\n    return false;\n\n  icu::UnicodeString label_string(FALSE, label.data(),\n                                  base::checked_cast<int32_t>(label.size()));\n\n  if (deviation_characters_.containsSome(label_string))\n    return false;\n\n  result &= USPOOF_RESTRICTION_LEVEL_MASK;\n  if (result == USPOOF_ASCII)\n    return true;\n  if (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&\n      kana_letters_exceptions_.containsNone(label_string) &&\n      combining_diacritics_exceptions_.containsNone(label_string)) {\n    return !is_tld_ascii || !IsMadeOfLatinAlikeCyrillic(label_string);\n  }\n\n  if (non_ascii_latin_letters_.containsSome(label_string) &&\n      !lgc_letters_n_ascii_.containsAll(label_string))\n    return false;\n\n  if (!tls_index.initialized())\n    tls_index.Initialize(&OnThreadTermination);\n  icu::RegexMatcher* dangerous_pattern =\n      reinterpret_cast<icu::RegexMatcher*>(tls_index.Get());\n  if (!dangerous_pattern) {\n    // - Disallow dotless i (U+0131) followed by a combining mark.\n     dangerous_pattern = new icu::RegexMatcher(\n        icu::UnicodeString(\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}])\"\n            R\"([\\u30ce\\u30f3\\u30bd\\u30be])\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}]|)\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}]\\u30fc|^\\u30fc|)\"\n            R\"([^\\p{scx=kana}][\\u30fd\\u30fe]|^[\\u30fd\\u30fe]|)\"\n            R\"(^[\\p{scx=kana}]+[\\u3078-\\u307a][\\p{scx=kana}]+$|)\"\n             R\"(^[\\p{scx=hira}]+[\\u30d8-\\u30da][\\p{scx=hira}]+$|)\"\n             R\"([a-z]\\u30fb|\\u30fb[a-z]|)\"\n             R\"([^\\p{scx=latn}\\p{scx=grek}\\p{scx=cyrl}][\\u0300-\\u0339]|)\"\n            R\"(\\u0131[\\u0300-\\u0339]|)\"\n            R\"([ijl]\\u0307)\",\n             -1, US_INV),\n         0, status);\n     tls_index.Set(dangerous_pattern);\n  }\n  dangerous_pattern->reset(label_string);\n  return !dangerous_pattern->find();\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143712,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " int PDFiumEngine::GetVisiblePageIndex(FPDF_PAGE page) {\n  for (int page_index : visible_pages_) {\n     if (pages_[page_index]->GetPage() == page)\n       return page_index;\n   }\n  return -1;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143721,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " int PDFiumEngine::GetVisiblePageIndex(FPDF_PAGE page) {\n  // Copy visible_pages_ since it can change as a result of loading the page in\n  // GetPage(). See https://crbug.com/822091.\n  std::vector<int> visible_pages_copy(visible_pages_);\n  for (int page_index : visible_pages_copy) {\n     if (pages_[page_index]->GetPage() == page)\n       return page_index;\n   }\n  return -1;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143722,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " void ServerWrapper::OnHttpRequest(int connection_id,\n                                   const net::HttpServerRequestInfo& info) {\n   server_->SetSendBufferSize(connection_id, kSendBufferSizeForDevTools);\n \n   if (base::StartsWith(info.path, \"/json\", base::CompareCase::SENSITIVE)) {\n    BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n                            base::BindOnce(&DevToolsHttpHandler::OnJsonRequest,\n                                           handler_, connection_id, info));\n    return;\n  }\n\n  if (info.path.empty() || info.path == \"/\") {\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(&DevToolsHttpHandler::OnDiscoveryPageRequest, handler_,\n                       connection_id));\n    return;\n  }\n\n  if (!base::StartsWith(info.path, \"/devtools/\",\n                        base::CompareCase::SENSITIVE)) {\n    server_->Send404(connection_id, kDevtoolsHttpHandlerTrafficAnnotation);\n    return;\n  }\n\n  std::string filename = PathWithoutParams(info.path.substr(10));\n  std::string mime_type = GetMimeType(filename);\n\n  if (!debug_frontend_dir_.empty()) {\n    base::FilePath path = debug_frontend_dir_.AppendASCII(filename);\n    std::string data;\n    base::ReadFileToString(path, &data);\n    server_->Send200(connection_id, data, mime_type,\n                     kDevtoolsHttpHandlerTrafficAnnotation);\n    return;\n  }\n\n  if (bundles_resources_) {\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(&DevToolsHttpHandler::OnFrontendResourceRequest,\n                       handler_, connection_id, filename));\n    return;\n  }\n  server_->Send404(connection_id, kDevtoolsHttpHandlerTrafficAnnotation);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143723,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " void ServerWrapper::OnHttpRequest(int connection_id,\n                                   const net::HttpServerRequestInfo& info) {\n  if (!RequestIsSafeToServe(info)) {\n    Send500(connection_id,\n            \"Host header is specified and is not an IP address or localhost.\");\n    return;\n  }\n\n   server_->SetSendBufferSize(connection_id, kSendBufferSizeForDevTools);\n \n   if (base::StartsWith(info.path, \"/json\", base::CompareCase::SENSITIVE)) {\n    BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n                            base::BindOnce(&DevToolsHttpHandler::OnJsonRequest,\n                                           handler_, connection_id, info));\n    return;\n  }\n\n  if (info.path.empty() || info.path == \"/\") {\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(&DevToolsHttpHandler::OnDiscoveryPageRequest, handler_,\n                       connection_id));\n    return;\n  }\n\n  if (!base::StartsWith(info.path, \"/devtools/\",\n                        base::CompareCase::SENSITIVE)) {\n    server_->Send404(connection_id, kDevtoolsHttpHandlerTrafficAnnotation);\n    return;\n  }\n\n  std::string filename = PathWithoutParams(info.path.substr(10));\n  std::string mime_type = GetMimeType(filename);\n\n  if (!debug_frontend_dir_.empty()) {\n    base::FilePath path = debug_frontend_dir_.AppendASCII(filename);\n    std::string data;\n    base::ReadFileToString(path, &data);\n    server_->Send200(connection_id, data, mime_type,\n                     kDevtoolsHttpHandlerTrafficAnnotation);\n    return;\n  }\n\n  if (bundles_resources_) {\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(&DevToolsHttpHandler::OnFrontendResourceRequest,\n                       handler_, connection_id, filename));\n    return;\n  }\n  server_->Send404(connection_id, kDevtoolsHttpHandlerTrafficAnnotation);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143724,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n      icu::UnicodeString::fromUTF8(\"[\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u0527\u0529] > h;\"\n                                    \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f] > n; [\u0167\u0442\u04ad] > t;\"\n                                   \"[\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449] > w; [\u043c\u04ce] > m;\"\n                                    \"[\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; \u0493 > f; [\u04ab\u1004] > c;\"\n                                    \"\u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n #if defined(OS_WIN)\n                                    \"\u04cf > i;\"\n #else\n                                    \"\u04cf > l;\"\n #endif\n                                   \"\u0503  > d; [\u050d\u100c] > g; \u0d1f > s; \u1042 > j\"),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143725,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n  //      U+04C8 (\u04c8), U+04CA (\u04ca), U+0527 (\u0527), U+0529 (\u0529)} => h\n  //   - {U+03C9 (\u03c9), U+0448 (\u0448), U+0449 (\u0449), U+0E1F (\u0e1f)} => w\n  //   - {U+0D1F (\u0d1f), U+0E23 (\u0e23)} => s\n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n      icu::UnicodeString::fromUTF8(\"[\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u0527\u0529] > h;\"\n                                    \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f] > n; [\u0167\u0442\u04ad] > t;\"\n                                   \"[\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1f] > w; [\u043c\u04ce] > m;\"\n                                    \"[\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; \u0493 > f; [\u04ab\u1004] > c;\"\n                                    \"\u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n #if defined(OS_WIN)\n                                    \"\u04cf > i;\"\n #else\n                                    \"\u04cf > l;\"\n #endif\n                                   \"\u0503  > d; [\u050d\u100c] > g; [\u0d1f\u0e23] > s; \u1042 > j\"),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143726,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " bool NavigateToUrlWithEdge(const base::string16& url) {\n   base::string16 protocol_url = L\"microsoft-edge:\" + url;\n   SHELLEXECUTEINFO info = { sizeof(info) };\n  info.fMask = SEE_MASK_NOASYNC | SEE_MASK_FLAG_NO_UI;\n   info.lpVerb = L\"open\";\n   info.lpFile = protocol_url.c_str();\n   info.nShow = SW_SHOWNORMAL;\n  if (::ShellExecuteEx(&info))\n    return true;\n  PLOG(ERROR) << \"Failed to launch Edge for uninstall survey\";\n  return false;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143727,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " bool NavigateToUrlWithEdge(const base::string16& url) {\n   base::string16 protocol_url = L\"microsoft-edge:\" + url;\n   SHELLEXECUTEINFO info = { sizeof(info) };\n  info.fMask = SEE_MASK_NOASYNC;\n   info.lpVerb = L\"open\";\n   info.lpFile = protocol_url.c_str();\n   info.nShow = SW_SHOWNORMAL;\n  if (::ShellExecuteEx(&info))\n    return true;\n  PLOG(ERROR) << \"Failed to launch Edge for uninstall survey\";\n  return false;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143728,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n       UTRANS_FORWARD, parse_error, status));\n \n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n      icu::UnicodeString::fromUTF8(\n          \"\u04cf > l; [\u043a\u0138\u03ba] > k; \u043f > n; [\u0185\u044c] > b; \u0432 > b; \u043c > m; \u043d > h; \"\n          \"\u0442 > t; [\u0448\u0449] > w; \u0d1f > s;\"),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143739,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n       UTRANS_FORWARD, parse_error, status));\n \n  //   - {U+00FE (\u00fe), U+03FC (\u03fc), U+048F (\u048f)} => p\n  //   - {U+0127 (\u0127), U+043D (\u043d), U+045B (\u045b), U+04A3 (\u04a3), U+04A5 (\u04a5),\n  //      U+04C8 (\u04c8), U+0527 (\u0527), U+0529 (\u0529)} => h\n  //   - {U+0138 (\u0138), U+03BA (\u03ba), U+043A (\u043a), U+049B (\u049b), U+049D (\u049d),\n  //      U+049F (\u049f), U+04A1(\u04a1), U+04C4 (\u04c4), U+051F (\u051f)} => k\n  //   - {U+0167 (\u0167), U+0442 (\u0442), U+04AD (\u04ad)} => t\n  //   - {U+0185 (\u0185), U+044C (\u044c), U+048D (\u048d), U+0432 (\u0432)} => b\n  //   - {U+03C9 (\u03c9), U+0448 (\u0448), U+0449 (\u0449)} => w\n  //   - {U+043C (\u043c), U+04CE (\u04ce)} => m\n  //   - U+0491 (\u0491) => r\n  //   - U+0493 (\u0493) => f\n  //   - U+04AB (\u04ab) => c\n  //   - U+04B1 (\u04b1) => y\n  //   - U+03C7 (\u03c7), U+04B3 (\u04b3), U+04FD (\u04fd), U+04FF (\u04ff) => x\n  //   - U+04BD (\u04bd), U+04BF (\u04bf) => e\n  //   - U+04CF (\u04cf) => l\n  //   - U+0503 (\u0503) => d\n  //   - U+050D (\u050d) => g\n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n      icu::UnicodeString::fromUTF8(\"[\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u0527\u0529] > h;\"\n                                   \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u0167\u0442\u04ad] > t;\"\n                                   \"[\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449] > w; [\u043c\u04ce] > m;\"\n                                   \"\u043f > n; \u045b > h; \u0491 > r; \u0493 > f; \u04ab > c;\"\n                                   \"\u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x; [\u04bd\u04bf] > e; \u04cf > l;\"\n                                   \"\u0503  > d; \u050d > g; \u0d1f > s\"),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143740,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,\n                                             bool is_tld_ascii) {\n  UErrorCode status = U_ZERO_ERROR;\n  int32_t result =\n      uspoof_check(checker_, label.data(),\n                   base::checked_cast<int32_t>(label.size()), NULL, &status);\n  if (U_FAILURE(status) || (result & USPOOF_ALL_CHECKS))\n    return false;\n\n  icu::UnicodeString label_string(FALSE, label.data(),\n                                  base::checked_cast<int32_t>(label.size()));\n\n  if (deviation_characters_.containsSome(label_string))\n    return false;\n\n  result &= USPOOF_RESTRICTION_LEVEL_MASK;\n  if (result == USPOOF_ASCII)\n    return true;\n  if (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&\n      kana_letters_exceptions_.containsNone(label_string) &&\n      combining_diacritics_exceptions_.containsNone(label_string)) {\n    return !is_tld_ascii || !IsMadeOfLatinAlikeCyrillic(label_string);\n  }\n\n  if (non_ascii_latin_letters_.containsSome(label_string) &&\n      !lgc_letters_n_ascii_.containsAll(label_string))\n    return false;\n\n  if (!tls_index.initialized())\n    tls_index.Initialize(&OnThreadTermination);\n  icu::RegexMatcher* dangerous_pattern =\n      reinterpret_cast<icu::RegexMatcher*>(tls_index.Get());\n  if (!dangerous_pattern) {\n     dangerous_pattern = new icu::RegexMatcher(\n         icu::UnicodeString(\n             R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}])\"\n            R\"([\\u30ce\\u30f3\\u30bd\\u30be])\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}]|)\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}]\\u30fc|^\\u30fc|)\"\n            R\"([^\\p{scx=kana}][\\u30fd\\u30fe]|^[\\u30fd\\u30fe]|)\"\n            R\"(^[\\p{scx=kana}]+[\\u3078-\\u307a][\\p{scx=kana}]+$|)\"\n            R\"(^[\\p{scx=hira}]+[\\u30d8-\\u30da][\\p{scx=hira}]+$|)\"\n            R\"([a-z]\\u30fb|\\u30fb[a-z]|)\"\n            R\"(^[\\u0585\\u0581]+[a-z]|[a-z][\\u0585\\u0581]+$|)\"\n            R\"([a-z][\\u0585\\u0581]+[a-z]|)\"\n            R\"(^[og]+[\\p{scx=armn}]|[\\p{scx=armn}][og]+$|)\"\n            R\"([\\p{scx=armn}][og]+[\\p{scx=armn}]|)\"\n            R\"([\\p{sc=cans}].*[a-z]|[a-z].*[\\p{sc=cans}]|)\"\n             R\"([\\p{sc=tfng}].*[a-z]|[a-z].*[\\p{sc=tfng}]|)\"\n             R\"([^\\p{scx=latn}\\p{scx=grek}\\p{scx=cyrl}][\\u0300-\\u0339]|)\"\n             R\"([^\\p{scx=arab}][\\u064b-\\u0655\\u0670]|)\"\n            R\"([^\\p{scx=hebr}]\\u05b4)\",\n             -1, US_INV),\n         0, status);\n     tls_index.Set(dangerous_pattern);\n  }\n  dangerous_pattern->reset(label_string);\n  return !dangerous_pattern->find();\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143751,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,\n                                             bool is_tld_ascii) {\n  UErrorCode status = U_ZERO_ERROR;\n  int32_t result =\n      uspoof_check(checker_, label.data(),\n                   base::checked_cast<int32_t>(label.size()), NULL, &status);\n  if (U_FAILURE(status) || (result & USPOOF_ALL_CHECKS))\n    return false;\n\n  icu::UnicodeString label_string(FALSE, label.data(),\n                                  base::checked_cast<int32_t>(label.size()));\n\n  if (deviation_characters_.containsSome(label_string))\n    return false;\n\n  result &= USPOOF_RESTRICTION_LEVEL_MASK;\n  if (result == USPOOF_ASCII)\n    return true;\n  if (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&\n      kana_letters_exceptions_.containsNone(label_string) &&\n      combining_diacritics_exceptions_.containsNone(label_string)) {\n    return !is_tld_ascii || !IsMadeOfLatinAlikeCyrillic(label_string);\n  }\n\n  if (non_ascii_latin_letters_.containsSome(label_string) &&\n      !lgc_letters_n_ascii_.containsAll(label_string))\n    return false;\n\n  if (!tls_index.initialized())\n    tls_index.Initialize(&OnThreadTermination);\n  icu::RegexMatcher* dangerous_pattern =\n      reinterpret_cast<icu::RegexMatcher*>(tls_index.Get());\n  if (!dangerous_pattern) {\n    // - Disallow U+0307 (dot above) after 'i', 'j', 'l' or dotless i (U+0131).\n    //   Dotless j (U+0237) is not in the allowed set to begin with.\n     dangerous_pattern = new icu::RegexMatcher(\n         icu::UnicodeString(\n             R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}])\"\n            R\"([\\u30ce\\u30f3\\u30bd\\u30be])\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}]|)\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}]\\u30fc|^\\u30fc|)\"\n            R\"([^\\p{scx=kana}][\\u30fd\\u30fe]|^[\\u30fd\\u30fe]|)\"\n            R\"(^[\\p{scx=kana}]+[\\u3078-\\u307a][\\p{scx=kana}]+$|)\"\n            R\"(^[\\p{scx=hira}]+[\\u30d8-\\u30da][\\p{scx=hira}]+$|)\"\n            R\"([a-z]\\u30fb|\\u30fb[a-z]|)\"\n            R\"(^[\\u0585\\u0581]+[a-z]|[a-z][\\u0585\\u0581]+$|)\"\n            R\"([a-z][\\u0585\\u0581]+[a-z]|)\"\n            R\"(^[og]+[\\p{scx=armn}]|[\\p{scx=armn}][og]+$|)\"\n            R\"([\\p{scx=armn}][og]+[\\p{scx=armn}]|)\"\n            R\"([\\p{sc=cans}].*[a-z]|[a-z].*[\\p{sc=cans}]|)\"\n             R\"([\\p{sc=tfng}].*[a-z]|[a-z].*[\\p{sc=tfng}]|)\"\n             R\"([^\\p{scx=latn}\\p{scx=grek}\\p{scx=cyrl}][\\u0300-\\u0339]|)\"\n             R\"([^\\p{scx=arab}][\\u064b-\\u0655\\u0670]|)\"\n            R\"([^\\p{scx=hebr}]\\u05b4|)\"\n            R\"([ijl\\u0131]\\u0307)\",\n             -1, US_INV),\n         0, status);\n     tls_index.Set(dangerous_pattern);\n  }\n  dangerous_pattern->reset(label_string);\n  return !dangerous_pattern->find();\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143752,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "std::set<std::string> GetDistinctHosts(const URLPatternSet& host_patterns,\n                                       bool include_rcd,\n                                       bool exclude_file_scheme) {\n  typedef base::StringPairs HostVector;\n  HostVector hosts_best_rcd;\n  for (const URLPattern& pattern : host_patterns) {\n    if (exclude_file_scheme && pattern.scheme() == url::kFileScheme)\n       continue;\n \n     std::string host = pattern.host();\n \n     if (pattern.match_subdomains())\n      host = \"*.\" + host;\n\n\n    std::string rcd;\n    size_t reg_len =\n        net::registry_controlled_domains::PermissiveGetHostRegistryLength(\n            host, net::registry_controlled_domains::EXCLUDE_UNKNOWN_REGISTRIES,\n            net::registry_controlled_domains::EXCLUDE_PRIVATE_REGISTRIES);\n    if (reg_len && reg_len != std::string::npos) {\n      if (include_rcd)  // else leave rcd empty\n        rcd = host.substr(host.size() - reg_len);\n      host = host.substr(0, host.size() - reg_len);\n    }\n\n    HostVector::iterator it = hosts_best_rcd.begin();\n    for (; it != hosts_best_rcd.end(); ++it) {\n      if (it->first == host)\n        break;\n    }\n    if (it != hosts_best_rcd.end()) {\n      if (include_rcd && RcdBetterThan(rcd, it->second))\n        it->second = rcd;\n    } else {  // Previously unseen host, append it.\n      hosts_best_rcd.push_back(std::make_pair(host, rcd));\n    }\n  }\n\n  std::set<std::string> distinct_hosts;\n  for (const auto& host_rcd : hosts_best_rcd)\n    distinct_hosts.insert(host_rcd.first + host_rcd.second);\n  return distinct_hosts;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143755,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "std::set<std::string> GetDistinctHosts(const URLPatternSet& host_patterns,\n                                       bool include_rcd,\n                                       bool exclude_file_scheme) {\n  typedef base::StringPairs HostVector;\n  HostVector hosts_best_rcd;\n  for (const URLPattern& pattern : host_patterns) {\n    if (exclude_file_scheme && pattern.scheme() == url::kFileScheme)\n       continue;\n \n     std::string host = pattern.host();\n    if (!host.empty()) {\n      // Convert the host into a secure format. For example, an IDN domain is\n      // converted to punycode.\n      host = base::UTF16ToUTF8(url_formatter::FormatUrlForSecurityDisplay(\n          GURL(base::StringPrintf(\"%s%s%s\", url::kHttpScheme,\n                                  url::kStandardSchemeSeparator, host.c_str())),\n          url_formatter::SchemeDisplay::OMIT_HTTP_AND_HTTPS));\n    }\n \n     if (pattern.match_subdomains())\n      host = \"*.\" + host;\n\n\n    std::string rcd;\n    size_t reg_len =\n        net::registry_controlled_domains::PermissiveGetHostRegistryLength(\n            host, net::registry_controlled_domains::EXCLUDE_UNKNOWN_REGISTRIES,\n            net::registry_controlled_domains::EXCLUDE_PRIVATE_REGISTRIES);\n    if (reg_len && reg_len != std::string::npos) {\n      if (include_rcd)  // else leave rcd empty\n        rcd = host.substr(host.size() - reg_len);\n      host = host.substr(0, host.size() - reg_len);\n    }\n\n    HostVector::iterator it = hosts_best_rcd.begin();\n    for (; it != hosts_best_rcd.end(); ++it) {\n      if (it->first == host)\n        break;\n    }\n    if (it != hosts_best_rcd.end()) {\n      if (include_rcd && RcdBetterThan(rcd, it->second))\n        it->second = rcd;\n    } else {  // Previously unseen host, append it.\n      hosts_best_rcd.push_back(std::make_pair(host, rcd));\n    }\n  }\n\n  std::set<std::string> distinct_hosts;\n  for (const auto& host_rcd : hosts_best_rcd)\n    distinct_hosts.insert(host_rcd.first + host_rcd.second);\n  return distinct_hosts;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143756,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "UseCounterPageLoadMetricsObserver::GetAllowedUkmFeatures() {\n  static base::NoDestructor<UseCounterPageLoadMetricsObserver::UkmFeatureList>\n      opt_in_features(std::initializer_list<WebFeature>({\n          WebFeature::kNavigatorVibrate,\n          WebFeature::kNavigatorVibrateSubFrame,\n          WebFeature::kTouchEventPreventedNoTouchAction,\n          WebFeature::kTouchEventPreventedForcedDocumentPassiveNoTouchAction,\n          WebFeature::kDataUriHasOctothorpe,\n          WebFeature::kApplicationCacheManifestSelectInsecureOrigin,\n          WebFeature::kApplicationCacheManifestSelectSecureOrigin,\n          WebFeature::kMixedContentAudio,\n          WebFeature::kMixedContentImage,\n          WebFeature::kMixedContentVideo,\n          WebFeature::kMixedContentPlugin,\n          WebFeature::kOpenerNavigationWithoutGesture,\n          WebFeature::kUsbRequestDevice,\n          WebFeature::kXMLHttpRequestSynchronous,\n          WebFeature::kPaymentHandler,\n          WebFeature::kPaymentRequestShowWithoutGesture,\n          WebFeature::kHTMLImports,\n          WebFeature::kHTMLImportsHasStyleSheets,\n          WebFeature::kElementCreateShadowRoot,\n          WebFeature::kDocumentRegisterElement,\n          WebFeature::kCredentialManagerCreatePublicKeyCredential,\n          WebFeature::kCredentialManagerGetPublicKeyCredential,\n          WebFeature::kCredentialManagerMakePublicKeyCredentialSuccess,\n          WebFeature::kCredentialManagerGetPublicKeyCredentialSuccess,\n          WebFeature::kV8AudioContext_Constructor,\n          WebFeature::kElementAttachShadow,\n          WebFeature::kElementAttachShadowOpen,\n          WebFeature::kElementAttachShadowClosed,\n          WebFeature::kCustomElementRegistryDefine,\n          WebFeature::kTextToSpeech_Speak,\n          WebFeature::kTextToSpeech_SpeakDisallowedByAutoplay,\n          WebFeature::kCSSEnvironmentVariable,\n          WebFeature::kCSSEnvironmentVariable_SafeAreaInsetTop,\n          WebFeature::kCSSEnvironmentVariable_SafeAreaInsetLeft,\n          WebFeature::kCSSEnvironmentVariable_SafeAreaInsetRight,\n          WebFeature::kCSSEnvironmentVariable_SafeAreaInsetBottom,\n          WebFeature::kMediaControlsDisplayCutoutGesture,\n          WebFeature::kPolymerV1Detected,\n          WebFeature::kPolymerV2Detected,\n          WebFeature::kFullscreenSecureOrigin,\n          WebFeature::kFullscreenInsecureOrigin,\n          WebFeature::kPrefixedVideoEnterFullscreen,\n          WebFeature::kPrefixedVideoExitFullscreen,\n          WebFeature::kPrefixedVideoEnterFullScreen,\n          WebFeature::kPrefixedVideoExitFullScreen,\n          WebFeature::kDocumentLevelPassiveDefaultEventListenerPreventedWheel,\n          WebFeature::kDocumentDomainBlockedCrossOriginAccess,\n          WebFeature::kDocumentDomainEnabledCrossOriginAccess,\n          WebFeature::kSuppressHistoryEntryWithoutUserGesture,\n          WebFeature::kCursorImageGT32x32,\n          WebFeature::kCursorImageLE32x32,\n          WebFeature::kHistoryPushState,\n          WebFeature::kHistoryReplaceState,\n          WebFeature::kCursorImageGT64x64,\n          WebFeature::kAdClick,\n          WebFeature::kUpdateWithoutShippingOptionOnShippingAddressChange,\n          WebFeature::kUpdateWithoutShippingOptionOnShippingOptionChange,\n          WebFeature::kSignedExchangeInnerResponseInMainFrame,\n          WebFeature::kSignedExchangeInnerResponseInSubFrame,\n          WebFeature::kWebShareShare,\n          WebFeature::kHTMLAnchorElementDownloadInSandboxWithUserGesture,\n          WebFeature::kHTMLAnchorElementDownloadInSandboxWithoutUserGesture,\n          WebFeature::kNavigationDownloadInSandboxWithUserGesture,\n          WebFeature::kNavigationDownloadInSandboxWithoutUserGesture,\n          WebFeature::kDownloadInAdFrameWithUserGesture,\n           WebFeature::kDownloadInAdFrameWithoutUserGesture,\n           WebFeature::kOpenWebDatabase,\n           WebFeature::kV8MediaCapabilities_DecodingInfo_Method,\n       }));\n   return *opt_in_features;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143763,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "UseCounterPageLoadMetricsObserver::GetAllowedUkmFeatures() {\n  static base::NoDestructor<UseCounterPageLoadMetricsObserver::UkmFeatureList>\n      opt_in_features(std::initializer_list<WebFeature>({\n          WebFeature::kNavigatorVibrate,\n          WebFeature::kNavigatorVibrateSubFrame,\n          WebFeature::kTouchEventPreventedNoTouchAction,\n          WebFeature::kTouchEventPreventedForcedDocumentPassiveNoTouchAction,\n          WebFeature::kDataUriHasOctothorpe,\n          WebFeature::kApplicationCacheManifestSelectInsecureOrigin,\n          WebFeature::kApplicationCacheManifestSelectSecureOrigin,\n          WebFeature::kMixedContentAudio,\n          WebFeature::kMixedContentImage,\n          WebFeature::kMixedContentVideo,\n          WebFeature::kMixedContentPlugin,\n          WebFeature::kOpenerNavigationWithoutGesture,\n          WebFeature::kUsbRequestDevice,\n          WebFeature::kXMLHttpRequestSynchronous,\n          WebFeature::kPaymentHandler,\n          WebFeature::kPaymentRequestShowWithoutGesture,\n          WebFeature::kHTMLImports,\n          WebFeature::kHTMLImportsHasStyleSheets,\n          WebFeature::kElementCreateShadowRoot,\n          WebFeature::kDocumentRegisterElement,\n          WebFeature::kCredentialManagerCreatePublicKeyCredential,\n          WebFeature::kCredentialManagerGetPublicKeyCredential,\n          WebFeature::kCredentialManagerMakePublicKeyCredentialSuccess,\n          WebFeature::kCredentialManagerGetPublicKeyCredentialSuccess,\n          WebFeature::kV8AudioContext_Constructor,\n          WebFeature::kElementAttachShadow,\n          WebFeature::kElementAttachShadowOpen,\n          WebFeature::kElementAttachShadowClosed,\n          WebFeature::kCustomElementRegistryDefine,\n          WebFeature::kTextToSpeech_Speak,\n          WebFeature::kTextToSpeech_SpeakDisallowedByAutoplay,\n          WebFeature::kCSSEnvironmentVariable,\n          WebFeature::kCSSEnvironmentVariable_SafeAreaInsetTop,\n          WebFeature::kCSSEnvironmentVariable_SafeAreaInsetLeft,\n          WebFeature::kCSSEnvironmentVariable_SafeAreaInsetRight,\n          WebFeature::kCSSEnvironmentVariable_SafeAreaInsetBottom,\n          WebFeature::kMediaControlsDisplayCutoutGesture,\n          WebFeature::kPolymerV1Detected,\n          WebFeature::kPolymerV2Detected,\n          WebFeature::kFullscreenSecureOrigin,\n          WebFeature::kFullscreenInsecureOrigin,\n          WebFeature::kPrefixedVideoEnterFullscreen,\n          WebFeature::kPrefixedVideoExitFullscreen,\n          WebFeature::kPrefixedVideoEnterFullScreen,\n          WebFeature::kPrefixedVideoExitFullScreen,\n          WebFeature::kDocumentLevelPassiveDefaultEventListenerPreventedWheel,\n          WebFeature::kDocumentDomainBlockedCrossOriginAccess,\n          WebFeature::kDocumentDomainEnabledCrossOriginAccess,\n          WebFeature::kSuppressHistoryEntryWithoutUserGesture,\n          WebFeature::kCursorImageGT32x32,\n          WebFeature::kCursorImageLE32x32,\n          WebFeature::kHistoryPushState,\n          WebFeature::kHistoryReplaceState,\n          WebFeature::kCursorImageGT64x64,\n          WebFeature::kAdClick,\n          WebFeature::kUpdateWithoutShippingOptionOnShippingAddressChange,\n          WebFeature::kUpdateWithoutShippingOptionOnShippingOptionChange,\n          WebFeature::kSignedExchangeInnerResponseInMainFrame,\n          WebFeature::kSignedExchangeInnerResponseInSubFrame,\n          WebFeature::kWebShareShare,\n          WebFeature::kHTMLAnchorElementDownloadInSandboxWithUserGesture,\n          WebFeature::kHTMLAnchorElementDownloadInSandboxWithoutUserGesture,\n          WebFeature::kNavigationDownloadInSandboxWithUserGesture,\n          WebFeature::kNavigationDownloadInSandboxWithoutUserGesture,\n          WebFeature::kDownloadInAdFrameWithUserGesture,\n           WebFeature::kDownloadInAdFrameWithoutUserGesture,\n           WebFeature::kOpenWebDatabase,\n           WebFeature::kV8MediaCapabilities_DecodingInfo_Method,\n          WebFeature::kOpenerNavigationDownloadCrossOriginNoGesture,\n       }));\n   return *opt_in_features;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143764,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void Location::SetLocation(const String& url,\n                           LocalDOMWindow* current_window,\n                           LocalDOMWindow* entered_window,\n                           ExceptionState* exception_state,\n                           SetLocationPolicy set_location_policy) {\n  if (!IsAttached())\n    return;\n\n  if (!current_window->GetFrame())\n    return;\n\n  Document* entered_document = entered_window->document();\n  if (!entered_document)\n    return;\n\n  KURL completed_url = entered_document->CompleteURL(url);\n  if (completed_url.IsNull())\n    return;\n\n  if (!current_window->GetFrame()->CanNavigate(*dom_window_->GetFrame(),\n                                               completed_url)) {\n    if (exception_state) {\n      exception_state->ThrowSecurityError(\n          \"The current window does not have permission to navigate the target \"\n          \"frame to '\" +\n          url + \"'.\");\n    }\n    return;\n  }\n  if (exception_state && !completed_url.IsValid()) {\n    exception_state->ThrowDOMException(DOMExceptionCode::kSyntaxError,\n                                       \"'\" + url + \"' is not a valid URL.\");\n    return;\n  }\n\n   if (dom_window_->IsInsecureScriptAccess(*current_window, completed_url))\n     return;\n \n   V8DOMActivityLogger* activity_logger =\n       V8DOMActivityLogger::CurrentActivityLoggerIfIsolatedWorld();\n   if (activity_logger) {\n    Vector<String> argv;\n    argv.push_back(\"LocalDOMWindow\");\n    argv.push_back(\"url\");\n    argv.push_back(entered_document->Url());\n    argv.push_back(completed_url);\n    activity_logger->LogEvent(\"blinkSetAttribute\", argv.size(), argv.data());\n  }\n  WebFrameLoadType frame_load_type = WebFrameLoadType::kStandard;\n  if (set_location_policy == SetLocationPolicy::kReplaceThisFrame)\n    frame_load_type = WebFrameLoadType::kReplaceCurrentItem;\n  dom_window_->GetFrame()->ScheduleNavigation(*current_window->document(),\n                                              completed_url, frame_load_type,\n                                              UserGestureStatus::kNone);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143765,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void Location::SetLocation(const String& url,\n                           LocalDOMWindow* current_window,\n                           LocalDOMWindow* entered_window,\n                           ExceptionState* exception_state,\n                           SetLocationPolicy set_location_policy) {\n  if (!IsAttached())\n    return;\n\n  if (!current_window->GetFrame())\n    return;\n\n  Document* entered_document = entered_window->document();\n  if (!entered_document)\n    return;\n\n  KURL completed_url = entered_document->CompleteURL(url);\n  if (completed_url.IsNull())\n    return;\n\n  if (!current_window->GetFrame()->CanNavigate(*dom_window_->GetFrame(),\n                                               completed_url)) {\n    if (exception_state) {\n      exception_state->ThrowSecurityError(\n          \"The current window does not have permission to navigate the target \"\n          \"frame to '\" +\n          url + \"'.\");\n    }\n    return;\n  }\n  if (exception_state && !completed_url.IsValid()) {\n    exception_state->ThrowDOMException(DOMExceptionCode::kSyntaxError,\n                                       \"'\" + url + \"' is not a valid URL.\");\n    return;\n  }\n\n   if (dom_window_->IsInsecureScriptAccess(*current_window, completed_url))\n     return;\n \n  // Check the source browsing context's CSP to fulfill the CSP check\n  // requirement of https://html.spec.whatwg.org/#navigate for javascript URLs.\n  // Although the spec states we should perform this check on task execution,\n  // we do this prior to dispatch since the parent frame's CSP may be\n  // inaccessible if the target frame is out of process.\n  Document* current_document = current_window->document();\n  if (current_document && completed_url.ProtocolIsJavaScript() &&\n      !ContentSecurityPolicy::ShouldBypassMainWorld(current_document)) {\n    String script_source = DecodeURLEscapeSequences(completed_url.GetString());\n    if (!current_document->GetContentSecurityPolicy()->AllowJavaScriptURLs(\n            nullptr, script_source, current_document->Url(), OrdinalNumber())) {\n      return;\n    }\n  }\n\n   V8DOMActivityLogger* activity_logger =\n       V8DOMActivityLogger::CurrentActivityLoggerIfIsolatedWorld();\n   if (activity_logger) {\n    Vector<String> argv;\n    argv.push_back(\"LocalDOMWindow\");\n    argv.push_back(\"url\");\n    argv.push_back(entered_document->Url());\n    argv.push_back(completed_url);\n    activity_logger->LogEvent(\"blinkSetAttribute\", argv.size(), argv.data());\n  }\n  WebFrameLoadType frame_load_type = WebFrameLoadType::kStandard;\n  if (set_location_policy == SetLocationPolicy::kReplaceThisFrame)\n    frame_load_type = WebFrameLoadType::kReplaceCurrentItem;\n  dom_window_->GetFrame()->ScheduleNavigation(*current_window->document(),\n                                              completed_url, frame_load_type,\n                                              UserGestureStatus::kNone);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143766,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "ExtensionInstallDialogView::ExtensionInstallDialogView(\n    Profile* profile,\n    content::PageNavigator* navigator,\n    const ExtensionInstallPrompt::DoneCallback& done_callback,\n    std::unique_ptr<ExtensionInstallPrompt::Prompt> prompt)\n    : profile_(profile),\n      navigator_(navigator),\n      done_callback_(done_callback),\n       prompt_(std::move(prompt)),\n       container_(NULL),\n       scroll_view_(NULL),\n      handled_result_(false) {\n   InitView();\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143777,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "ExtensionInstallDialogView::ExtensionInstallDialogView(\n    Profile* profile,\n    content::PageNavigator* navigator,\n    const ExtensionInstallPrompt::DoneCallback& done_callback,\n    std::unique_ptr<ExtensionInstallPrompt::Prompt> prompt)\n    : profile_(profile),\n      navigator_(navigator),\n      done_callback_(done_callback),\n       prompt_(std::move(prompt)),\n       container_(NULL),\n       scroll_view_(NULL),\n      handled_result_(false),\n      install_button_enabled_(false) {\n   InitView();\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143778,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool RenderFrameDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n  if (session->restricted() && !IsFrameHostAllowedForRestrictedSessions())\n    return false;\n  session->SetRenderer(frame_host_ ? frame_host_->GetProcess()->GetID()\n                                   : ChildProcessHost::kInvalidUniqueID,\n                       frame_host_);\n\n  protocol::EmulationHandler* emulation_handler =\n      new protocol::EmulationHandler();\n  session->AddHandler(base::WrapUnique(new protocol::BrowserHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::DOMHandler()));\n  session->AddHandler(base::WrapUnique(emulation_handler));\n  session->AddHandler(base::WrapUnique(new protocol::InputHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::IOHandler(\n      GetIOContext())));\n  session->AddHandler(base::WrapUnique(new protocol::MemoryHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(GetId())));\n   session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));\n   session->AddHandler(base::WrapUnique(new protocol::ServiceWorkerHandler()));\n   session->AddHandler(base::WrapUnique(new protocol::StorageHandler()));\n  session->AddHandler(\n      base::WrapUnique(new protocol::TargetHandler(false /* browser_only */)));\n   session->AddHandler(base::WrapUnique(new protocol::TracingHandler(\n       protocol::TracingHandler::Renderer,\n       frame_tree_node_ ? frame_tree_node_->frame_tree_node_id() : 0,\n      GetIOContext())));\n  session->AddHandler(\n      base::WrapUnique(new protocol::PageHandler(emulation_handler)));\n  session->AddHandler(base::WrapUnique(new protocol::SecurityHandler()));\n\n  if (EnsureAgent())\n    session->AttachToAgent(agent_ptr_);\n\n  if (sessions().size() == 1) {\n    if (!base::FeatureList::IsEnabled(features::kVizDisplayCompositor) &&\n        !base::FeatureList::IsEnabled(\n            features::kUseVideoCaptureApiForDevToolsSnapshots)) {\n      frame_trace_recorder_.reset(new DevToolsFrameTraceRecorder());\n    }\n    GrantPolicy();\n#if defined(OS_ANDROID)\n    GetWakeLock()->RequestWakeLock();\n#endif\n  }\n  return true;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143797,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool RenderFrameDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n  if (session->restricted() && !IsFrameHostAllowedForRestrictedSessions())\n    return false;\n  session->SetRenderer(frame_host_ ? frame_host_->GetProcess()->GetID()\n                                   : ChildProcessHost::kInvalidUniqueID,\n                       frame_host_);\n\n  protocol::EmulationHandler* emulation_handler =\n      new protocol::EmulationHandler();\n  session->AddHandler(base::WrapUnique(new protocol::BrowserHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::DOMHandler()));\n  session->AddHandler(base::WrapUnique(emulation_handler));\n  session->AddHandler(base::WrapUnique(new protocol::InputHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::IOHandler(\n      GetIOContext())));\n  session->AddHandler(base::WrapUnique(new protocol::MemoryHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(GetId())));\n   session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));\n   session->AddHandler(base::WrapUnique(new protocol::ServiceWorkerHandler()));\n   session->AddHandler(base::WrapUnique(new protocol::StorageHandler()));\n  if (!session->restricted()) {\n    session->AddHandler(base::WrapUnique(\n        new protocol::TargetHandler(false /* browser_only */)));\n  }\n   session->AddHandler(base::WrapUnique(new protocol::TracingHandler(\n       protocol::TracingHandler::Renderer,\n       frame_tree_node_ ? frame_tree_node_->frame_tree_node_id() : 0,\n      GetIOContext())));\n  session->AddHandler(\n      base::WrapUnique(new protocol::PageHandler(emulation_handler)));\n  session->AddHandler(base::WrapUnique(new protocol::SecurityHandler()));\n\n  if (EnsureAgent())\n    session->AttachToAgent(agent_ptr_);\n\n  if (sessions().size() == 1) {\n    if (!base::FeatureList::IsEnabled(features::kVizDisplayCompositor) &&\n        !base::FeatureList::IsEnabled(\n            features::kUseVideoCaptureApiForDevToolsSnapshots)) {\n      frame_trace_recorder_.reset(new DevToolsFrameTraceRecorder());\n    }\n    GrantPolicy();\n#if defined(OS_ANDROID)\n    GetWakeLock()->RequestWakeLock();\n#endif\n  }\n  return true;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143798,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "ExtensionNavigationThrottle::WillStartOrRedirectRequest() {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  content::WebContents* web_contents = navigation_handle()->GetWebContents();\n  ExtensionRegistry* registry =\n      ExtensionRegistry::Get(web_contents->GetBrowserContext());\n\n  const GURL& url = navigation_handle()->GetURL();\n  bool url_has_extension_scheme = url.SchemeIs(kExtensionScheme);\n  url::Origin target_origin = url::Origin::Create(url);\n  const Extension* target_extension = nullptr;\n  if (url_has_extension_scheme) {\n    target_extension =\n        registry->enabled_extensions().GetExtensionOrAppByURL(url);\n  } else if (target_origin.scheme() == kExtensionScheme) {\n    DCHECK(url.SchemeIsFileSystem() || url.SchemeIsBlob());\n    target_extension =\n        registry->enabled_extensions().GetByID(target_origin.host());\n  } else {\n    return content::NavigationThrottle::PROCEED;\n  }\n\n  if (!target_extension) {\n    return content::NavigationThrottle::BLOCK_REQUEST;\n  }\n\n  if (target_extension->is_hosted_app()) {\n    base::StringPiece resource_root_relative_path =\n        url.path_piece().empty() ? base::StringPiece()\n                                 : url.path_piece().substr(1);\n    if (!IconsInfo::GetIcons(target_extension)\n             .ContainsPath(resource_root_relative_path)) {\n      return content::NavigationThrottle::BLOCK_REQUEST;\n     }\n   }\n \n  if (navigation_handle()->IsInMainFrame()) {\n    bool current_frame_is_extension_process =\n        !!registry->enabled_extensions().GetExtensionOrAppByURL(\n            navigation_handle()->GetStartingSiteInstance()->GetSiteURL());\n    if (!url_has_extension_scheme && !current_frame_is_extension_process) {\n      if (target_origin.scheme() == kExtensionScheme &&\n          navigation_handle()->GetSuggestedFilename().has_value()) {\n        return content::NavigationThrottle::PROCEED;\n      }\n      bool has_webview_permission =\n          target_extension->permissions_data()->HasAPIPermission(\n              APIPermission::kWebView);\n      if (!has_webview_permission)\n        return content::NavigationThrottle::CANCEL;\n     }\n \n     guest_view::GuestViewBase* guest =\n         guest_view::GuestViewBase::FromWebContents(web_contents);\n     if (url_has_extension_scheme && guest) {\n      const std::string& owner_extension_id = guest->owner_host();\n      const Extension* owner_extension =\n          registry->enabled_extensions().GetByID(owner_extension_id);\n\n      std::string partition_domain;\n      std::string partition_id;\n      bool in_memory = false;\n      bool is_guest = WebViewGuest::GetGuestPartitionConfigForSite(\n          navigation_handle()->GetStartingSiteInstance()->GetSiteURL(),\n          &partition_domain, &partition_id, &in_memory);\n\n      bool allowed = true;\n      url_request_util::AllowCrossRendererResourceLoadHelper(\n          is_guest, target_extension, owner_extension, partition_id, url.path(),\n          navigation_handle()->GetPageTransition(), &allowed);\n      if (!allowed)\n        return content::NavigationThrottle::BLOCK_REQUEST;\n    }\n\n    return content::NavigationThrottle::PROCEED;\n  }\n\n  content::RenderFrameHost* parent = navigation_handle()->GetParentFrame();\n\n  bool external_ancestor = false;\n  for (auto* ancestor = parent; ancestor; ancestor = ancestor->GetParent()) {\n    if (ancestor->GetLastCommittedOrigin() == target_origin)\n      continue;\n    if (url::Origin::Create(ancestor->GetLastCommittedURL()) == target_origin)\n      continue;\n    if (ancestor->GetLastCommittedURL().SchemeIs(\n            content::kChromeDevToolsScheme))\n      continue;\n\n    external_ancestor = true;\n    break;\n  }\n\n  if (external_ancestor) {\n    if (!url_has_extension_scheme)\n      return content::NavigationThrottle::CANCEL;\n\n    if (!WebAccessibleResourcesInfo::IsResourceWebAccessible(target_extension,\n                                                             url.path()))\n      return content::NavigationThrottle::BLOCK_REQUEST;\n\n    if (target_extension->is_platform_app())\n      return content::NavigationThrottle::CANCEL;\n\n    const Extension* parent_extension =\n        registry->enabled_extensions().GetExtensionOrAppByURL(\n            parent->GetSiteInstance()->GetSiteURL());\n    if (parent_extension && parent_extension->is_platform_app())\n      return content::NavigationThrottle::BLOCK_REQUEST;\n  }\n\n  return content::NavigationThrottle::PROCEED;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143801,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "ExtensionNavigationThrottle::WillStartOrRedirectRequest() {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  content::WebContents* web_contents = navigation_handle()->GetWebContents();\n  ExtensionRegistry* registry =\n      ExtensionRegistry::Get(web_contents->GetBrowserContext());\n\n  const GURL& url = navigation_handle()->GetURL();\n  bool url_has_extension_scheme = url.SchemeIs(kExtensionScheme);\n  url::Origin target_origin = url::Origin::Create(url);\n  const Extension* target_extension = nullptr;\n  if (url_has_extension_scheme) {\n    target_extension =\n        registry->enabled_extensions().GetExtensionOrAppByURL(url);\n  } else if (target_origin.scheme() == kExtensionScheme) {\n    DCHECK(url.SchemeIsFileSystem() || url.SchemeIsBlob());\n    target_extension =\n        registry->enabled_extensions().GetByID(target_origin.host());\n  } else {\n    return content::NavigationThrottle::PROCEED;\n  }\n\n  if (!target_extension) {\n    return content::NavigationThrottle::BLOCK_REQUEST;\n  }\n\n  if (target_extension->is_hosted_app()) {\n    base::StringPiece resource_root_relative_path =\n        url.path_piece().empty() ? base::StringPiece()\n                                 : url.path_piece().substr(1);\n    if (!IconsInfo::GetIcons(target_extension)\n             .ContainsPath(resource_root_relative_path)) {\n      return content::NavigationThrottle::BLOCK_REQUEST;\n     }\n   }\n \n  // Block all navigations to blob: or filesystem: URLs with extension\n  // origin from non-extension processes.  See https://crbug.com/645028 and\n  // https://crbug.com/836858.\n  bool current_frame_is_extension_process =\n      !!registry->enabled_extensions().GetExtensionOrAppByURL(\n          navigation_handle()->GetStartingSiteInstance()->GetSiteURL());\n\n  if (!url_has_extension_scheme && !current_frame_is_extension_process) {\n    // Relax this restriction for navigations that will result in downloads.\n    // See https://crbug.com/714373.\n    if (target_origin.scheme() == kExtensionScheme &&\n        navigation_handle()->GetSuggestedFilename().has_value()) {\n      return content::NavigationThrottle::PROCEED;\n     }\n \n    // Relax this restriction for apps that use <webview>.  See\n    // https://crbug.com/652077.\n    bool has_webview_permission =\n        target_extension->permissions_data()->HasAPIPermission(\n            APIPermission::kWebView);\n    if (!has_webview_permission)\n      return content::NavigationThrottle::CANCEL;\n  }\n\n  if (navigation_handle()->IsInMainFrame()) {\n     guest_view::GuestViewBase* guest =\n         guest_view::GuestViewBase::FromWebContents(web_contents);\n     if (url_has_extension_scheme && guest) {\n      const std::string& owner_extension_id = guest->owner_host();\n      const Extension* owner_extension =\n          registry->enabled_extensions().GetByID(owner_extension_id);\n\n      std::string partition_domain;\n      std::string partition_id;\n      bool in_memory = false;\n      bool is_guest = WebViewGuest::GetGuestPartitionConfigForSite(\n          navigation_handle()->GetStartingSiteInstance()->GetSiteURL(),\n          &partition_domain, &partition_id, &in_memory);\n\n      bool allowed = true;\n      url_request_util::AllowCrossRendererResourceLoadHelper(\n          is_guest, target_extension, owner_extension, partition_id, url.path(),\n          navigation_handle()->GetPageTransition(), &allowed);\n      if (!allowed)\n        return content::NavigationThrottle::BLOCK_REQUEST;\n    }\n\n    return content::NavigationThrottle::PROCEED;\n  }\n\n  content::RenderFrameHost* parent = navigation_handle()->GetParentFrame();\n\n  bool external_ancestor = false;\n  for (auto* ancestor = parent; ancestor; ancestor = ancestor->GetParent()) {\n    if (ancestor->GetLastCommittedOrigin() == target_origin)\n      continue;\n    if (url::Origin::Create(ancestor->GetLastCommittedURL()) == target_origin)\n      continue;\n    if (ancestor->GetLastCommittedURL().SchemeIs(\n            content::kChromeDevToolsScheme))\n      continue;\n\n    external_ancestor = true;\n    break;\n  }\n\n  if (external_ancestor) {\n    if (!url_has_extension_scheme)\n      return content::NavigationThrottle::CANCEL;\n\n    if (!WebAccessibleResourcesInfo::IsResourceWebAccessible(target_extension,\n                                                             url.path()))\n      return content::NavigationThrottle::BLOCK_REQUEST;\n\n    if (target_extension->is_platform_app())\n      return content::NavigationThrottle::CANCEL;\n\n    const Extension* parent_extension =\n        registry->enabled_extensions().GetExtensionOrAppByURL(\n            parent->GetSiteInstance()->GetSiteURL());\n    if (parent_extension && parent_extension->is_platform_app())\n      return content::NavigationThrottle::BLOCK_REQUEST;\n  }\n\n  return content::NavigationThrottle::PROCEED;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143802,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n int new_mi_size;\n\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n if (cm->alloc_mi(cm, new_mi_size))\n goto fail;\n }\n\n if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    free_seg_map(cm);\n if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols))\n goto fail;\n }\n\n if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n 2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n sizeof(*cm->above_context));\n if (!cm->above_context) goto fail;\n\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n }\n\n\n   return 0;\n \n  fail:\n   vp9_free_context_buffers(cm);\n   return 1;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143813,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n int new_mi_size;\n\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n if (cm->alloc_mi(cm, new_mi_size))\n goto fail;\n }\n\n if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    free_seg_map(cm);\n if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols))\n goto fail;\n }\n\n if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n 2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n sizeof(*cm->above_context));\n if (!cm->above_context) goto fail;\n\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n }\n\n\n   return 0;\n \n  fail:\n  vp9_set_mb_mi(cm, 0, 0);\n   vp9_free_context_buffers(cm);\n   return 1;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143814,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void SoftAAC2::onQueueFilled(OMX_U32 /* portIndex */) {\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n    UCHAR* inBuffer[FILEREAD_MAX_LAYERS];\n    UINT inBufferLength[FILEREAD_MAX_LAYERS] = {0};\n    UINT bytesValid[FILEREAD_MAX_LAYERS] = {0};\n\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n while ((!inQueue.empty() || mEndOfInput) && !outQueue.empty()) {\n if (!inQueue.empty()) {\n            INT_PCM tmpOutBuffer[2048 * MAX_CHANNEL_COUNT];\n BufferInfo *inInfo = *inQueue.begin();\n            OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n\n            mEndOfInput = (inHeader->nFlags & OMX_BUFFERFLAG_EOS) != 0;\n\n if (mInputBufferCount == 0 && !(inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG)) {\n                ALOGE(\"first buffer should have OMX_BUFFERFLAG_CODECCONFIG set\");\n                inHeader->nFlags |= OMX_BUFFERFLAG_CODECCONFIG;\n }\n if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) != 0) {\n BufferInfo *inInfo = *inQueue.begin();\n                OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n\n                inBuffer[0] = inHeader->pBuffer + inHeader->nOffset;\n                inBufferLength[0] = inHeader->nFilledLen;\n\n                AAC_DECODER_ERROR decoderErr =\n                    aacDecoder_ConfigRaw(mAACDecoder,\n                                         inBuffer,\n                                         inBufferLength);\n\n if (decoderErr != AAC_DEC_OK) {\n                    ALOGW(\"aacDecoder_ConfigRaw decoderErr = 0x%4.4x\", decoderErr);\n                    mSignalledError = true;\n                    notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n return;\n }\n\n                mInputBufferCount++;\n                mOutputBufferCount++; // fake increase of outputBufferCount to keep the counters aligned\n\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                mLastInHeader = NULL;\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n\n                configureDownmix();\n if (mStreamInfo->sampleRate && mStreamInfo->numChannels) {\n                    ALOGI(\"Initially configuring decoder: %d Hz, %d channels\",\n                        mStreamInfo->sampleRate,\n                        mStreamInfo->numChannels);\n\n                    notify(OMX_EventPortSettingsChanged, 1, 0, NULL);\n                    mOutputPortSettingsChange = AWAITING_DISABLED;\n }\n return;\n }\n\n if (inHeader->nFilledLen == 0) {\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                mLastInHeader = NULL;\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n continue;\n }\n\n if (mIsADTS) {\n size_t adtsHeaderSize = 0;\n\n const uint8_t *adtsHeader = inHeader->pBuffer + inHeader->nOffset;\n\n bool signalError = false;\n if (inHeader->nFilledLen < 7) {\n                    ALOGE(\"Audio data too short to contain even the ADTS header. \"\n \"Got %d bytes.\", inHeader->nFilledLen);\n                    hexdump(adtsHeader, inHeader->nFilledLen);\n                    signalError = true;\n } else {\n bool protectionAbsent = (adtsHeader[1] & 1);\n\n unsigned aac_frame_length =\n ((adtsHeader[3] & 3) << 11)\n | (adtsHeader[4] << 3)\n | (adtsHeader[5] >> 5);\n\n if (inHeader->nFilledLen < aac_frame_length) {\n                        ALOGE(\"Not enough audio data for the complete frame. \"\n \"Got %d bytes, frame size according to the ADTS \"\n \"header is %u bytes.\",\n                                inHeader->nFilledLen, aac_frame_length);\n                        hexdump(adtsHeader, inHeader->nFilledLen);\n\n                         signalError = true;\n                     } else {\n                         adtsHeaderSize = (protectionAbsent ? 7 : 9);\n \n                        inBuffer[0] = (UCHAR *)adtsHeader + adtsHeaderSize;\n                        inBufferLength[0] = aac_frame_length - adtsHeaderSize;\n                        inHeader->nOffset += adtsHeaderSize;\n                        inHeader->nFilledLen -= adtsHeaderSize;\n                     }\n                 }\n \n if (signalError) {\n                    mSignalledError = true;\n                    notify(OMX_EventError, OMX_ErrorStreamCorrupt, ERROR_MALFORMED, NULL);\n return;\n }\n\n                mBufferSizes.add(inBufferLength[0]);\n if (mLastInHeader != inHeader) {\n                    mBufferTimestamps.add(inHeader->nTimeStamp);\n                    mLastInHeader = inHeader;\n } else {\n int64_t currentTime = mBufferTimestamps.top();\n                    currentTime += mStreamInfo->aacSamplesPerFrame *\n 1000000ll / mStreamInfo->aacSampleRate;\n                    mBufferTimestamps.add(currentTime);\n }\n } else {\n                inBuffer[0] = inHeader->pBuffer + inHeader->nOffset;\n                inBufferLength[0] = inHeader->nFilledLen;\n                mLastInHeader = inHeader;\n                mBufferTimestamps.add(inHeader->nTimeStamp);\n                mBufferSizes.add(inHeader->nFilledLen);\n }\n\n            bytesValid[0] = inBufferLength[0];\n\n            INT prevSampleRate = mStreamInfo->sampleRate;\n            INT prevNumChannels = mStreamInfo->numChannels;\n\n            aacDecoder_Fill(mAACDecoder,\n                            inBuffer,\n                            inBufferLength,\n                            bytesValid);\n\n            mDrcWrap.submitStreamData(mStreamInfo);\n            mDrcWrap.update();\n\n            UINT inBufferUsedLength = inBufferLength[0] - bytesValid[0];\n            inHeader->nFilledLen -= inBufferUsedLength;\n            inHeader->nOffset += inBufferUsedLength;\n\n            AAC_DECODER_ERROR decoderErr;\n int numLoops = 0;\n do {\n if (outputDelayRingBufferSpaceLeft() <\n (mStreamInfo->frameSize * mStreamInfo->numChannels)) {\n                    ALOGV(\"skipping decode: not enough space left in ringbuffer\");\n break;\n }\n\n int numConsumed = mStreamInfo->numTotalBytes;\n                decoderErr = aacDecoder_DecodeFrame(mAACDecoder,\n                                           tmpOutBuffer,\n 2048 * MAX_CHANNEL_COUNT,\n 0 /* flags */);\n\n                numConsumed = mStreamInfo->numTotalBytes - numConsumed;\n                numLoops++;\n\n if (decoderErr == AAC_DEC_NOT_ENOUGH_BITS) {\n break;\n }\n                mDecodedSizes.add(numConsumed);\n\n if (decoderErr != AAC_DEC_OK) {\n                    ALOGW(\"aacDecoder_DecodeFrame decoderErr = 0x%4.4x\", decoderErr);\n }\n\n if (bytesValid[0] != 0) {\n                    ALOGE(\"bytesValid[0] != 0 should never happen\");\n                    mSignalledError = true;\n                    notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n }\n\n size_t numOutBytes =\n                    mStreamInfo->frameSize * sizeof(int16_t) * mStreamInfo->numChannels;\n\n if (decoderErr == AAC_DEC_OK) {\n if (!outputDelayRingBufferPutSamples(tmpOutBuffer,\n                            mStreamInfo->frameSize * mStreamInfo->numChannels)) {\n                        mSignalledError = true;\n                        notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n return;\n }\n } else {\n                    ALOGW(\"AAC decoder returned error 0x%4.4x, substituting silence\", decoderErr);\n\n                    memset(tmpOutBuffer, 0, numOutBytes); // TODO: check for overflow\n\n if (!outputDelayRingBufferPutSamples(tmpOutBuffer,\n                            mStreamInfo->frameSize * mStreamInfo->numChannels)) {\n                        mSignalledError = true;\n                        notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n return;\n }\n\n if (inHeader) {\n                        inHeader->nFilledLen = 0;\n }\n\n                    aacDecoder_SetParam(mAACDecoder, AAC_TPDEC_CLEAR_BUFFER, 1);\n\n                    mBufferSizes.pop();\n int n = 0;\n for (int i = 0; i < numLoops; i++) {\n                        n += mDecodedSizes.itemAt(mDecodedSizes.size() - numLoops + i);\n }\n                    mBufferSizes.add(n);\n\n }\n\n /*\n                 * AAC+/eAAC+ streams can be signalled in two ways: either explicitly\n                 * or implicitly, according to MPEG4 spec. AAC+/eAAC+ is a dual\n                 * rate system and the sampling rate in the final output is actually\n                 * doubled compared with the core AAC decoder sampling rate.\n                 *\n                 * Explicit signalling is done by explicitly defining SBR audio object\n                 * type in the bitstream. Implicit signalling is done by embedding\n                 * SBR content in AAC extension payload specific to SBR, and hence\n                 * requires an AAC decoder to perform pre-checks on actual audio frames.\n                 *\n                 * Thus, we could not say for sure whether a stream is\n                 * AAC+/eAAC+ until the first data frame is decoded.\n                 */\n if (mInputBufferCount <= 2 || mOutputBufferCount > 1) { // TODO: <= 1\n if (mStreamInfo->sampleRate != prevSampleRate ||\n                        mStreamInfo->numChannels != prevNumChannels) {\n                        ALOGI(\"Reconfiguring decoder: %d->%d Hz, %d->%d channels\",\n                              prevSampleRate, mStreamInfo->sampleRate,\n                              prevNumChannels, mStreamInfo->numChannels);\n\n                        notify(OMX_EventPortSettingsChanged, 1, 0, NULL);\n                        mOutputPortSettingsChange = AWAITING_DISABLED;\n\n if (inHeader && inHeader->nFilledLen == 0) {\n                            inInfo->mOwnedByUs = false;\n                            mInputBufferCount++;\n                            inQueue.erase(inQueue.begin());\n                            mLastInHeader = NULL;\n                            inInfo = NULL;\n                            notifyEmptyBufferDone(inHeader);\n                            inHeader = NULL;\n }\n return;\n }\n } else if (!mStreamInfo->sampleRate || !mStreamInfo->numChannels) {\n                    ALOGW(\"Invalid AAC stream\");\n                    mSignalledError = true;\n                    notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n return;\n }\n if (inHeader && inHeader->nFilledLen == 0) {\n                    inInfo->mOwnedByUs = false;\n                    mInputBufferCount++;\n                    inQueue.erase(inQueue.begin());\n                    mLastInHeader = NULL;\n                    inInfo = NULL;\n                    notifyEmptyBufferDone(inHeader);\n                    inHeader = NULL;\n } else {\n                    ALOGV(\"inHeader->nFilledLen = %d\", inHeader ? inHeader->nFilledLen : 0);\n }\n } while (decoderErr == AAC_DEC_OK);\n }\n\n int32_t outputDelay = mStreamInfo->outputDelay * mStreamInfo->numChannels;\n\n if (!mEndOfInput && mOutputDelayCompensated < outputDelay) {\n int32_t toCompensate = outputDelay - mOutputDelayCompensated;\n int32_t discard = outputDelayRingBufferSamplesAvailable();\n if (discard > toCompensate) {\n                discard = toCompensate;\n }\n int32_t discarded = outputDelayRingBufferGetSamples(0, discard);\n            mOutputDelayCompensated += discarded;\n continue;\n }\n\n if (mEndOfInput) {\n while (mOutputDelayCompensated > 0) {\n                INT_PCM tmpOutBuffer[2048 * MAX_CHANNEL_COUNT];\n \n                 mDrcWrap.submitStreamData(mStreamInfo);\n                 mDrcWrap.update();\n\n                AAC_DECODER_ERROR decoderErr =\n                    aacDecoder_DecodeFrame(mAACDecoder,\n                                           tmpOutBuffer,\n 2048 * MAX_CHANNEL_COUNT,\n                                           AACDEC_FLUSH);\n if (decoderErr != AAC_DEC_OK) {\n                    ALOGW(\"aacDecoder_DecodeFrame decoderErr = 0x%4.4x\", decoderErr);\n }\n\n int32_t tmpOutBufferSamples = mStreamInfo->frameSize * mStreamInfo->numChannels;\n if (tmpOutBufferSamples > mOutputDelayCompensated) {\n                    tmpOutBufferSamples = mOutputDelayCompensated;\n }\n                outputDelayRingBufferPutSamples(tmpOutBuffer, tmpOutBufferSamples);\n                mOutputDelayCompensated -= tmpOutBufferSamples;\n }\n }\n\n while (!outQueue.empty()\n && outputDelayRingBufferSamplesAvailable()\n >= mStreamInfo->frameSize * mStreamInfo->numChannels) {\n BufferInfo *outInfo = *outQueue.begin();\n            OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n\n if (outHeader->nOffset != 0) {\n                ALOGE(\"outHeader->nOffset != 0 is not handled\");\n                mSignalledError = true;\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n }\n\n            INT_PCM *outBuffer =\n reinterpret_cast<INT_PCM *>(outHeader->pBuffer + outHeader->nOffset);\n int samplesize = mStreamInfo->numChannels * sizeof(int16_t);\n if (outHeader->nOffset\n + mStreamInfo->frameSize * samplesize\n > outHeader->nAllocLen) {\n                ALOGE(\"buffer overflow\");\n                mSignalledError = true;\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n\n }\n\n int available = outputDelayRingBufferSamplesAvailable();\n int numSamples = outHeader->nAllocLen / sizeof(int16_t);\n if (numSamples > available) {\n                numSamples = available;\n }\n int64_t currentTime = 0;\n if (available) {\n\n int numFrames = numSamples / (mStreamInfo->frameSize * mStreamInfo->numChannels);\n                numSamples = numFrames * (mStreamInfo->frameSize * mStreamInfo->numChannels);\n\n                ALOGV(\"%d samples available (%d), or %d frames\",\n                        numSamples, available, numFrames);\n int64_t *nextTimeStamp = &mBufferTimestamps.editItemAt(0);\n                currentTime = *nextTimeStamp;\n int32_t *currentBufLeft = &mBufferSizes.editItemAt(0);\n for (int i = 0; i < numFrames; i++) {\n int32_t decodedSize = mDecodedSizes.itemAt(0);\n                    mDecodedSizes.removeAt(0);\n                    ALOGV(\"decoded %d of %d\", decodedSize, *currentBufLeft);\n if (*currentBufLeft > decodedSize) {\n *currentBufLeft -= decodedSize;\n *nextTimeStamp += mStreamInfo->aacSamplesPerFrame *\n 1000000ll / mStreamInfo->aacSampleRate;\n                        ALOGV(\"adjusted nextTimeStamp/size to %lld/%d\",\n (long long) *nextTimeStamp, *currentBufLeft);\n } else {\n if (mBufferTimestamps.size() > 0) {\n                            mBufferTimestamps.removeAt(0);\n                            nextTimeStamp = &mBufferTimestamps.editItemAt(0);\n                            mBufferSizes.removeAt(0);\n                            currentBufLeft = &mBufferSizes.editItemAt(0);\n                            ALOGV(\"moved to next time/size: %lld/%d\",\n (long long) *nextTimeStamp, *currentBufLeft);\n }\n                        numFrames = i + 1;\n                        numSamples = numFrames * mStreamInfo->frameSize * mStreamInfo->numChannels;\n break;\n }\n }\n\n                ALOGV(\"getting %d from ringbuffer\", numSamples);\n int32_t ns = outputDelayRingBufferGetSamples(outBuffer, numSamples);\n if (ns != numSamples) {\n                    ALOGE(\"not a complete frame of samples available\");\n                    mSignalledError = true;\n                    notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n }\n }\n\n            outHeader->nFilledLen = numSamples * sizeof(int16_t);\n\n if (mEndOfInput && !outQueue.empty() && outputDelayRingBufferSamplesAvailable() == 0) {\n                outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n                mEndOfOutput = true;\n } else {\n                outHeader->nFlags = 0;\n }\n\n            outHeader->nTimeStamp = currentTime;\n\n            mOutputBufferCount++;\n            outInfo->mOwnedByUs = false;\n            outQueue.erase(outQueue.begin());\n            outInfo = NULL;\n            ALOGV(\"out timestamp %lld / %d\", outHeader->nTimeStamp, outHeader->nFilledLen);\n            notifyFillBufferDone(outHeader);\n            outHeader = NULL;\n }\n\n if (mEndOfInput) {\n int ringBufAvail = outputDelayRingBufferSamplesAvailable();\n if (!outQueue.empty()\n && ringBufAvail < mStreamInfo->frameSize * mStreamInfo->numChannels) {\n if (!mEndOfOutput) {\n                    mEndOfOutput = true;\n BufferInfo *outInfo = *outQueue.begin();\n                    OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n\n                    INT_PCM *outBuffer = reinterpret_cast<INT_PCM *>(outHeader->pBuffer\n + outHeader->nOffset);\n int32_t ns = outputDelayRingBufferGetSamples(outBuffer, ringBufAvail);\n if (ns < 0) {\n                        ns = 0;\n }\n                    outHeader->nFilledLen = ns;\n                    outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n                    outHeader->nTimeStamp = mBufferTimestamps.itemAt(0);\n                    mBufferTimestamps.clear();\n                    mBufferSizes.clear();\n                    mDecodedSizes.clear();\n\n                    mOutputBufferCount++;\n                    outInfo->mOwnedByUs = false;\n                    outQueue.erase(outQueue.begin());\n                    outInfo = NULL;\n                    notifyFillBufferDone(outHeader);\n                    outHeader = NULL;\n }\n break; // if outQueue not empty but no more output\n }\n }\n }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143831,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void SoftAAC2::onQueueFilled(OMX_U32 /* portIndex */) {\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n    UCHAR* inBuffer[FILEREAD_MAX_LAYERS];\n    UINT inBufferLength[FILEREAD_MAX_LAYERS] = {0};\n    UINT bytesValid[FILEREAD_MAX_LAYERS] = {0};\n\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n while ((!inQueue.empty() || mEndOfInput) && !outQueue.empty()) {\n if (!inQueue.empty()) {\n            INT_PCM tmpOutBuffer[2048 * MAX_CHANNEL_COUNT];\n BufferInfo *inInfo = *inQueue.begin();\n            OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n\n            mEndOfInput = (inHeader->nFlags & OMX_BUFFERFLAG_EOS) != 0;\n\n if (mInputBufferCount == 0 && !(inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG)) {\n                ALOGE(\"first buffer should have OMX_BUFFERFLAG_CODECCONFIG set\");\n                inHeader->nFlags |= OMX_BUFFERFLAG_CODECCONFIG;\n }\n if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) != 0) {\n BufferInfo *inInfo = *inQueue.begin();\n                OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n\n                inBuffer[0] = inHeader->pBuffer + inHeader->nOffset;\n                inBufferLength[0] = inHeader->nFilledLen;\n\n                AAC_DECODER_ERROR decoderErr =\n                    aacDecoder_ConfigRaw(mAACDecoder,\n                                         inBuffer,\n                                         inBufferLength);\n\n if (decoderErr != AAC_DEC_OK) {\n                    ALOGW(\"aacDecoder_ConfigRaw decoderErr = 0x%4.4x\", decoderErr);\n                    mSignalledError = true;\n                    notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n return;\n }\n\n                mInputBufferCount++;\n                mOutputBufferCount++; // fake increase of outputBufferCount to keep the counters aligned\n\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                mLastInHeader = NULL;\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n\n                configureDownmix();\n if (mStreamInfo->sampleRate && mStreamInfo->numChannels) {\n                    ALOGI(\"Initially configuring decoder: %d Hz, %d channels\",\n                        mStreamInfo->sampleRate,\n                        mStreamInfo->numChannels);\n\n                    notify(OMX_EventPortSettingsChanged, 1, 0, NULL);\n                    mOutputPortSettingsChange = AWAITING_DISABLED;\n }\n return;\n }\n\n if (inHeader->nFilledLen == 0) {\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                mLastInHeader = NULL;\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n continue;\n }\n\n if (mIsADTS) {\n size_t adtsHeaderSize = 0;\n\n const uint8_t *adtsHeader = inHeader->pBuffer + inHeader->nOffset;\n\n bool signalError = false;\n if (inHeader->nFilledLen < 7) {\n                    ALOGE(\"Audio data too short to contain even the ADTS header. \"\n \"Got %d bytes.\", inHeader->nFilledLen);\n                    hexdump(adtsHeader, inHeader->nFilledLen);\n                    signalError = true;\n } else {\n bool protectionAbsent = (adtsHeader[1] & 1);\n\n unsigned aac_frame_length =\n ((adtsHeader[3] & 3) << 11)\n | (adtsHeader[4] << 3)\n | (adtsHeader[5] >> 5);\n\n if (inHeader->nFilledLen < aac_frame_length) {\n                        ALOGE(\"Not enough audio data for the complete frame. \"\n \"Got %d bytes, frame size according to the ADTS \"\n \"header is %u bytes.\",\n                                inHeader->nFilledLen, aac_frame_length);\n                        hexdump(adtsHeader, inHeader->nFilledLen);\n\n                         signalError = true;\n                     } else {\n                         adtsHeaderSize = (protectionAbsent ? 7 : 9);\n                        if (aac_frame_length < adtsHeaderSize) {\n                            signalError = true;\n                        } else {\n                            inBuffer[0] = (UCHAR *)adtsHeader + adtsHeaderSize;\n                            inBufferLength[0] = aac_frame_length - adtsHeaderSize;\n \n                            inHeader->nOffset += adtsHeaderSize;\n                            inHeader->nFilledLen -= adtsHeaderSize;\n                        }\n                     }\n                 }\n \n if (signalError) {\n                    mSignalledError = true;\n                    notify(OMX_EventError, OMX_ErrorStreamCorrupt, ERROR_MALFORMED, NULL);\n return;\n }\n\n                mBufferSizes.add(inBufferLength[0]);\n if (mLastInHeader != inHeader) {\n                    mBufferTimestamps.add(inHeader->nTimeStamp);\n                    mLastInHeader = inHeader;\n } else {\n int64_t currentTime = mBufferTimestamps.top();\n                    currentTime += mStreamInfo->aacSamplesPerFrame *\n 1000000ll / mStreamInfo->aacSampleRate;\n                    mBufferTimestamps.add(currentTime);\n }\n } else {\n                inBuffer[0] = inHeader->pBuffer + inHeader->nOffset;\n                inBufferLength[0] = inHeader->nFilledLen;\n                mLastInHeader = inHeader;\n                mBufferTimestamps.add(inHeader->nTimeStamp);\n                mBufferSizes.add(inHeader->nFilledLen);\n }\n\n            bytesValid[0] = inBufferLength[0];\n\n            INT prevSampleRate = mStreamInfo->sampleRate;\n            INT prevNumChannels = mStreamInfo->numChannels;\n\n            aacDecoder_Fill(mAACDecoder,\n                            inBuffer,\n                            inBufferLength,\n                            bytesValid);\n\n            mDrcWrap.submitStreamData(mStreamInfo);\n            mDrcWrap.update();\n\n            UINT inBufferUsedLength = inBufferLength[0] - bytesValid[0];\n            inHeader->nFilledLen -= inBufferUsedLength;\n            inHeader->nOffset += inBufferUsedLength;\n\n            AAC_DECODER_ERROR decoderErr;\n int numLoops = 0;\n do {\n if (outputDelayRingBufferSpaceLeft() <\n (mStreamInfo->frameSize * mStreamInfo->numChannels)) {\n                    ALOGV(\"skipping decode: not enough space left in ringbuffer\");\n break;\n }\n\n int numConsumed = mStreamInfo->numTotalBytes;\n                decoderErr = aacDecoder_DecodeFrame(mAACDecoder,\n                                           tmpOutBuffer,\n 2048 * MAX_CHANNEL_COUNT,\n 0 /* flags */);\n\n                numConsumed = mStreamInfo->numTotalBytes - numConsumed;\n                numLoops++;\n\n if (decoderErr == AAC_DEC_NOT_ENOUGH_BITS) {\n break;\n }\n                mDecodedSizes.add(numConsumed);\n\n if (decoderErr != AAC_DEC_OK) {\n                    ALOGW(\"aacDecoder_DecodeFrame decoderErr = 0x%4.4x\", decoderErr);\n }\n\n if (bytesValid[0] != 0) {\n                    ALOGE(\"bytesValid[0] != 0 should never happen\");\n                    mSignalledError = true;\n                    notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n }\n\n size_t numOutBytes =\n                    mStreamInfo->frameSize * sizeof(int16_t) * mStreamInfo->numChannels;\n\n if (decoderErr == AAC_DEC_OK) {\n if (!outputDelayRingBufferPutSamples(tmpOutBuffer,\n                            mStreamInfo->frameSize * mStreamInfo->numChannels)) {\n                        mSignalledError = true;\n                        notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n return;\n }\n } else {\n                    ALOGW(\"AAC decoder returned error 0x%4.4x, substituting silence\", decoderErr);\n\n                    memset(tmpOutBuffer, 0, numOutBytes); // TODO: check for overflow\n\n if (!outputDelayRingBufferPutSamples(tmpOutBuffer,\n                            mStreamInfo->frameSize * mStreamInfo->numChannels)) {\n                        mSignalledError = true;\n                        notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n return;\n }\n\n if (inHeader) {\n                        inHeader->nFilledLen = 0;\n }\n\n                    aacDecoder_SetParam(mAACDecoder, AAC_TPDEC_CLEAR_BUFFER, 1);\n\n                    mBufferSizes.pop();\n int n = 0;\n for (int i = 0; i < numLoops; i++) {\n                        n += mDecodedSizes.itemAt(mDecodedSizes.size() - numLoops + i);\n }\n                    mBufferSizes.add(n);\n\n }\n\n /*\n                 * AAC+/eAAC+ streams can be signalled in two ways: either explicitly\n                 * or implicitly, according to MPEG4 spec. AAC+/eAAC+ is a dual\n                 * rate system and the sampling rate in the final output is actually\n                 * doubled compared with the core AAC decoder sampling rate.\n                 *\n                 * Explicit signalling is done by explicitly defining SBR audio object\n                 * type in the bitstream. Implicit signalling is done by embedding\n                 * SBR content in AAC extension payload specific to SBR, and hence\n                 * requires an AAC decoder to perform pre-checks on actual audio frames.\n                 *\n                 * Thus, we could not say for sure whether a stream is\n                 * AAC+/eAAC+ until the first data frame is decoded.\n                 */\n if (mInputBufferCount <= 2 || mOutputBufferCount > 1) { // TODO: <= 1\n if (mStreamInfo->sampleRate != prevSampleRate ||\n                        mStreamInfo->numChannels != prevNumChannels) {\n                        ALOGI(\"Reconfiguring decoder: %d->%d Hz, %d->%d channels\",\n                              prevSampleRate, mStreamInfo->sampleRate,\n                              prevNumChannels, mStreamInfo->numChannels);\n\n                        notify(OMX_EventPortSettingsChanged, 1, 0, NULL);\n                        mOutputPortSettingsChange = AWAITING_DISABLED;\n\n if (inHeader && inHeader->nFilledLen == 0) {\n                            inInfo->mOwnedByUs = false;\n                            mInputBufferCount++;\n                            inQueue.erase(inQueue.begin());\n                            mLastInHeader = NULL;\n                            inInfo = NULL;\n                            notifyEmptyBufferDone(inHeader);\n                            inHeader = NULL;\n }\n return;\n }\n } else if (!mStreamInfo->sampleRate || !mStreamInfo->numChannels) {\n                    ALOGW(\"Invalid AAC stream\");\n                    mSignalledError = true;\n                    notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n return;\n }\n if (inHeader && inHeader->nFilledLen == 0) {\n                    inInfo->mOwnedByUs = false;\n                    mInputBufferCount++;\n                    inQueue.erase(inQueue.begin());\n                    mLastInHeader = NULL;\n                    inInfo = NULL;\n                    notifyEmptyBufferDone(inHeader);\n                    inHeader = NULL;\n } else {\n                    ALOGV(\"inHeader->nFilledLen = %d\", inHeader ? inHeader->nFilledLen : 0);\n }\n } while (decoderErr == AAC_DEC_OK);\n }\n\n int32_t outputDelay = mStreamInfo->outputDelay * mStreamInfo->numChannels;\n\n if (!mEndOfInput && mOutputDelayCompensated < outputDelay) {\n int32_t toCompensate = outputDelay - mOutputDelayCompensated;\n int32_t discard = outputDelayRingBufferSamplesAvailable();\n if (discard > toCompensate) {\n                discard = toCompensate;\n }\n int32_t discarded = outputDelayRingBufferGetSamples(0, discard);\n            mOutputDelayCompensated += discarded;\n continue;\n }\n\n if (mEndOfInput) {\n while (mOutputDelayCompensated > 0) {\n                INT_PCM tmpOutBuffer[2048 * MAX_CHANNEL_COUNT];\n \n                 mDrcWrap.submitStreamData(mStreamInfo);\n                 mDrcWrap.update();\n\n                AAC_DECODER_ERROR decoderErr =\n                    aacDecoder_DecodeFrame(mAACDecoder,\n                                           tmpOutBuffer,\n 2048 * MAX_CHANNEL_COUNT,\n                                           AACDEC_FLUSH);\n if (decoderErr != AAC_DEC_OK) {\n                    ALOGW(\"aacDecoder_DecodeFrame decoderErr = 0x%4.4x\", decoderErr);\n }\n\n int32_t tmpOutBufferSamples = mStreamInfo->frameSize * mStreamInfo->numChannels;\n if (tmpOutBufferSamples > mOutputDelayCompensated) {\n                    tmpOutBufferSamples = mOutputDelayCompensated;\n }\n                outputDelayRingBufferPutSamples(tmpOutBuffer, tmpOutBufferSamples);\n                mOutputDelayCompensated -= tmpOutBufferSamples;\n }\n }\n\n while (!outQueue.empty()\n && outputDelayRingBufferSamplesAvailable()\n >= mStreamInfo->frameSize * mStreamInfo->numChannels) {\n BufferInfo *outInfo = *outQueue.begin();\n            OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n\n if (outHeader->nOffset != 0) {\n                ALOGE(\"outHeader->nOffset != 0 is not handled\");\n                mSignalledError = true;\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n }\n\n            INT_PCM *outBuffer =\n reinterpret_cast<INT_PCM *>(outHeader->pBuffer + outHeader->nOffset);\n int samplesize = mStreamInfo->numChannels * sizeof(int16_t);\n if (outHeader->nOffset\n + mStreamInfo->frameSize * samplesize\n > outHeader->nAllocLen) {\n                ALOGE(\"buffer overflow\");\n                mSignalledError = true;\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n\n }\n\n int available = outputDelayRingBufferSamplesAvailable();\n int numSamples = outHeader->nAllocLen / sizeof(int16_t);\n if (numSamples > available) {\n                numSamples = available;\n }\n int64_t currentTime = 0;\n if (available) {\n\n int numFrames = numSamples / (mStreamInfo->frameSize * mStreamInfo->numChannels);\n                numSamples = numFrames * (mStreamInfo->frameSize * mStreamInfo->numChannels);\n\n                ALOGV(\"%d samples available (%d), or %d frames\",\n                        numSamples, available, numFrames);\n int64_t *nextTimeStamp = &mBufferTimestamps.editItemAt(0);\n                currentTime = *nextTimeStamp;\n int32_t *currentBufLeft = &mBufferSizes.editItemAt(0);\n for (int i = 0; i < numFrames; i++) {\n int32_t decodedSize = mDecodedSizes.itemAt(0);\n                    mDecodedSizes.removeAt(0);\n                    ALOGV(\"decoded %d of %d\", decodedSize, *currentBufLeft);\n if (*currentBufLeft > decodedSize) {\n *currentBufLeft -= decodedSize;\n *nextTimeStamp += mStreamInfo->aacSamplesPerFrame *\n 1000000ll / mStreamInfo->aacSampleRate;\n                        ALOGV(\"adjusted nextTimeStamp/size to %lld/%d\",\n (long long) *nextTimeStamp, *currentBufLeft);\n } else {\n if (mBufferTimestamps.size() > 0) {\n                            mBufferTimestamps.removeAt(0);\n                            nextTimeStamp = &mBufferTimestamps.editItemAt(0);\n                            mBufferSizes.removeAt(0);\n                            currentBufLeft = &mBufferSizes.editItemAt(0);\n                            ALOGV(\"moved to next time/size: %lld/%d\",\n (long long) *nextTimeStamp, *currentBufLeft);\n }\n                        numFrames = i + 1;\n                        numSamples = numFrames * mStreamInfo->frameSize * mStreamInfo->numChannels;\n break;\n }\n }\n\n                ALOGV(\"getting %d from ringbuffer\", numSamples);\n int32_t ns = outputDelayRingBufferGetSamples(outBuffer, numSamples);\n if (ns != numSamples) {\n                    ALOGE(\"not a complete frame of samples available\");\n                    mSignalledError = true;\n                    notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n }\n }\n\n            outHeader->nFilledLen = numSamples * sizeof(int16_t);\n\n if (mEndOfInput && !outQueue.empty() && outputDelayRingBufferSamplesAvailable() == 0) {\n                outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n                mEndOfOutput = true;\n } else {\n                outHeader->nFlags = 0;\n }\n\n            outHeader->nTimeStamp = currentTime;\n\n            mOutputBufferCount++;\n            outInfo->mOwnedByUs = false;\n            outQueue.erase(outQueue.begin());\n            outInfo = NULL;\n            ALOGV(\"out timestamp %lld / %d\", outHeader->nTimeStamp, outHeader->nFilledLen);\n            notifyFillBufferDone(outHeader);\n            outHeader = NULL;\n }\n\n if (mEndOfInput) {\n int ringBufAvail = outputDelayRingBufferSamplesAvailable();\n if (!outQueue.empty()\n && ringBufAvail < mStreamInfo->frameSize * mStreamInfo->numChannels) {\n if (!mEndOfOutput) {\n                    mEndOfOutput = true;\n BufferInfo *outInfo = *outQueue.begin();\n                    OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n\n                    INT_PCM *outBuffer = reinterpret_cast<INT_PCM *>(outHeader->pBuffer\n + outHeader->nOffset);\n int32_t ns = outputDelayRingBufferGetSamples(outBuffer, ringBufAvail);\n if (ns < 0) {\n                        ns = 0;\n }\n                    outHeader->nFilledLen = ns;\n                    outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n                    outHeader->nTimeStamp = mBufferTimestamps.itemAt(0);\n                    mBufferTimestamps.clear();\n                    mBufferSizes.clear();\n                    mDecodedSizes.clear();\n\n                    mOutputBufferCount++;\n                    outInfo->mOwnedByUs = false;\n                    outQueue.erase(outQueue.begin());\n                    outInfo = NULL;\n                    notifyFillBufferDone(outHeader);\n                    outHeader = NULL;\n }\n break; // if outQueue not empty but no more output\n }\n }\n }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143832,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "sp<IMemory> MetadataRetrieverClient::getFrameAtTime(int64_t timeUs, int option)\n{\n    ALOGV(\"getFrameAtTime: time(%lld us) option(%d)\", timeUs, option);\n Mutex::Autolock lock(mLock);\n Mutex::Autolock glock(sLock);\n    mThumbnail.clear();\n if (mRetriever == NULL) {\n        ALOGE(\"retriever is not initialized\");\n return NULL;\n }\n VideoFrame *frame = mRetriever->getFrameAtTime(timeUs, option);\n if (frame == NULL) {\n        ALOGE(\"failed to capture a video frame\");\n return NULL;\n }\n size_t size = sizeof(VideoFrame) + frame->mSize;\n    sp<MemoryHeapBase> heap = new MemoryHeapBase(size, 0, \"MetadataRetrieverClient\");\n if (heap == NULL) {\n        ALOGE(\"failed to create MemoryDealer\");\n delete frame;\n return NULL;\n }\n    mThumbnail = new MemoryBase(heap, 0, size);\n if (mThumbnail == NULL) {\n        ALOGE(\"not enough memory for VideoFrame size=%u\", size);\n delete frame;\n return NULL;\n }\n VideoFrame *frameCopy = static_cast<VideoFrame *>(mThumbnail->pointer());\n    frameCopy->mWidth = frame->mWidth;\n    frameCopy->mHeight = frame->mHeight;\n    frameCopy->mDisplayWidth = frame->mDisplayWidth;\n    frameCopy->mDisplayHeight = frame->mDisplayHeight;\n    frameCopy->mSize = frame->mSize;\n    frameCopy->mRotationAngle = frame->mRotationAngle;\n\n     ALOGV(\"rotation: %d\", frameCopy->mRotationAngle);\n     frameCopy->mData = (uint8_t *)frameCopy + sizeof(VideoFrame);\n     memcpy(frameCopy->mData, frame->mData, frame->mSize);\n     delete frame;  // Fix memory leakage\n     return mThumbnail;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143841,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "sp<IMemory> MetadataRetrieverClient::getFrameAtTime(int64_t timeUs, int option)\n{\n    ALOGV(\"getFrameAtTime: time(%lld us) option(%d)\", timeUs, option);\n Mutex::Autolock lock(mLock);\n Mutex::Autolock glock(sLock);\n    mThumbnail.clear();\n if (mRetriever == NULL) {\n        ALOGE(\"retriever is not initialized\");\n return NULL;\n }\n VideoFrame *frame = mRetriever->getFrameAtTime(timeUs, option);\n if (frame == NULL) {\n        ALOGE(\"failed to capture a video frame\");\n return NULL;\n }\n size_t size = sizeof(VideoFrame) + frame->mSize;\n    sp<MemoryHeapBase> heap = new MemoryHeapBase(size, 0, \"MetadataRetrieverClient\");\n if (heap == NULL) {\n        ALOGE(\"failed to create MemoryDealer\");\n delete frame;\n return NULL;\n }\n    mThumbnail = new MemoryBase(heap, 0, size);\n if (mThumbnail == NULL) {\n        ALOGE(\"not enough memory for VideoFrame size=%u\", size);\n delete frame;\n return NULL;\n }\n VideoFrame *frameCopy = static_cast<VideoFrame *>(mThumbnail->pointer());\n    frameCopy->mWidth = frame->mWidth;\n    frameCopy->mHeight = frame->mHeight;\n    frameCopy->mDisplayWidth = frame->mDisplayWidth;\n    frameCopy->mDisplayHeight = frame->mDisplayHeight;\n    frameCopy->mSize = frame->mSize;\n    frameCopy->mRotationAngle = frame->mRotationAngle;\n\n     ALOGV(\"rotation: %d\", frameCopy->mRotationAngle);\n     frameCopy->mData = (uint8_t *)frameCopy + sizeof(VideoFrame);\n     memcpy(frameCopy->mData, frame->mData, frame->mSize);\n    frameCopy->mData = 0;\n     delete frame;  // Fix memory leakage\n     return mThumbnail;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143842,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " static void print_maps(struct pid_info_t* info)\n {\n     FILE *maps;\n     size_t offset;\n     char device[10];\n     long int inode;\n    char file[PATH_MAX];\n \n     strlcat(info->path, \"maps\", sizeof(info->path));\n \n    maps = fopen(info->path, \"r\");\n\n     if (!maps)\n         goto out;\n \n    while (fscanf(maps, \"%*x-%*x %*s %zx %s %ld %s\\n\", &offset, device, &inode,\n            file) == 4) {\n         if (inode == 0 || !strcmp(device, \"00:00\"))\n             continue;\n\n        printf(\"%-9s %5d %10s %4s %9s %18s %9zd %10ld %s\\n\",\n                info->cmdline, info->pid, info->user, \"mem\",\n \"???\", device, offset, inode, file);\n }\n\n    fclose(maps);\n\nout:\n    info->path[info->parent_length] = '\\0';\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143845,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " static void print_maps(struct pid_info_t* info)\n {\n     FILE *maps;\n\n     size_t offset;\n     char device[10];\n     long int inode;\n    char file[1024];\n \n     strlcat(info->path, \"maps\", sizeof(info->path));\n \n    maps = fopen(info->path, \"r\");\n\n     if (!maps)\n         goto out;\n \n    while (fscanf(maps, \"%*x-%*x %*s %zx %5s %ld %1023s\\n\",\n                  &offset, device, &inode, file) == 4) {\n         if (inode == 0 || !strcmp(device, \"00:00\"))\n             continue;\n\n        printf(\"%-9s %5d %10s %4s %9s %18s %9zd %10ld %s\\n\",\n                info->cmdline, info->pid, info->user, \"mem\",\n \"???\", device, offset, inode, file);\n }\n\n    fclose(maps);\n\nout:\n    info->path[info->parent_length] = '\\0';\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143846,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " int res_inverse(vorbis_dsp_state *vd,vorbis_info_residue *info,\n\t\togg_int32_t **in,int *nonzero,int ch){\n \n   int i,j,k,s,used=0;\n   codec_setup_info     *ci=(codec_setup_info *)vd->vi->codec_setup;\n  codebook *phrasebook=ci->book_param+info->groupbook;\n int samples_per_partition=info->grouping;\n int partitions_per_word=phrasebook->dim;\n int pcmend=ci->blocksizes[vd->W];\n\n if(info->type<2){\n int max=pcmend>>1;\n int end=(info->end<max?info->end:max);\n int n=end-info->begin;\n\n if(n>0){\n int partvals=n/samples_per_partition;\n\n       int partwords=(partvals+partitions_per_word-1)/partitions_per_word;\n \n       for(i=0;i<ch;i++)\n\tif(nonzero[i])\n\t  in[used++]=in[i];\n       ch=used;\n \n       if(used){\n \n\tchar **partword=(char **)alloca(ch*sizeof(*partword));\n\tfor(j=0;j<ch;j++)\n\t  partword[j]=(char *)alloca(partwords*partitions_per_word*\n\t\t\t\t     sizeof(*partword[j]));\n \n\tfor(s=0;s<info->stages;s++){\n \n\t  for(i=0;i<partvals;){\n\t    if(s==0){\n\t      /* fetch the partition word for each channel */\n \n\t      partword[0][i+partitions_per_word-1]=1;\n\t      for(k=partitions_per_word-2;k>=0;k--)\n\t\tpartword[0][i+k]=partword[0][i+k+1]*info->partitions;\n \n\t      for(j=1;j<ch;j++)\n\t\tfor(k=partitions_per_word-1;k>=0;k--)\n\t\t  partword[j][i+k]=partword[j-1][i+k];\n \n\t      for(j=0;j<ch;j++){\n\t\tint temp=vorbis_book_decode(phrasebook,&vd->opb);\n\t\tif(temp==-1)goto eopbreak;\n \n\t\t/* this can be done quickly in assembly due to the quotient\n\t\t   always being at most six bits */\n\t\tfor(k=0;k<partitions_per_word;k++){\n\t\t  ogg_uint32_t div=partword[j][i+k];\n\t\t  partword[j][i+k]=temp/div;\n\t\t  temp-=partword[j][i+k]*div;\n\t\t}\n \n\t      }\n\t    }\n \n\t    /* now we decode residual values for the partitions */\n\t    for(k=0;k<partitions_per_word && i<partvals;k++,i++)\n\t      for(j=0;j<ch;j++){\n\t\tlong offset=info->begin+i*samples_per_partition;\n\t\tif(info->stagemasks[(int)partword[j][i]]&(1<<s)){\n\t\t  codebook *stagebook=ci->book_param+\n\t\t    info->stagebooks[(partword[j][i]<<3)+s];\n\t\t  if(info->type){\n\t\t    if(vorbis_book_decodev_add(stagebook,in[j]+offset,&vd->opb,\n\t\t\t\t\t       samples_per_partition,-8)==-1)\n\t\t      goto eopbreak;\n\t\t  }else{\n\t\t    if(vorbis_book_decodevs_add(stagebook,in[j]+offset,&vd->opb,\n\t\t\t\t\t\tsamples_per_partition,-8)==-1)\n\t\t      goto eopbreak;\n\t\t  }\n\t\t}\n\t      }\n\t  }\n\t}\n       }\n     }\n   }else{\n int max=(pcmend*ch)>>1;\n int end=(info->end<max?info->end:max);\n int n=end-info->begin;\n\n if(n>0){\n int partvals=n/samples_per_partition;\n\n       int partwords=(partvals+partitions_per_word-1)/partitions_per_word;\n \n       char *partword=\n\t(char *)alloca(partwords*partitions_per_word*sizeof(*partword));\n       int beginoff=info->begin/ch;\n \n       for(i=0;i<ch;i++)if(nonzero[i])break;\n if(i==ch)return(0); /* no nonzero vectors */\n\n      samples_per_partition/=ch;\n\n for(s=0;s<info->stages;s++){\n for(i=0;i<partvals;){\n\n if(s==0){\n int temp;\n\t    partword[i+partitions_per_word-1]=1;\n for(k=partitions_per_word-2;k>=0;k--)\n\t      partword[i+k]=partword[i+k+1]*info->partitions;\n\n /* fetch the partition word */\n\t    temp=vorbis_book_decode(phrasebook,&vd->opb);\n if(temp==-1)goto eopbreak;\n\n /* this can be done quickly in assembly due to the quotient\n\t       always being at most six bits */\n for(k=0;k<partitions_per_word;k++){\n ogg_uint32_t div=partword[i+k];\n\t      partword[i+k]=temp/div;\n\t      temp-=partword[i+k]*div;\n }\n }\n\n /* now we decode residual values for the partitions */\n for(k=0;k<partitions_per_word && i<partvals;k++,i++)\n if(info->stagemasks[(int)partword[i]]&(1<<s)){\n\t      codebook *stagebook=ci->book_param+\n\t\tinfo->stagebooks[(partword[i]<<3)+s];\n if(vorbis_book_decodevv_add(stagebook,in,\n\t\t\t\t\t  i*samples_per_partition+beginoff,ch,\n &vd->opb,\n\t\t\t\t\t  samples_per_partition,-8)==-1)\n goto eopbreak;\n }\n }\n }\n }\n }\n eopbreak:\n\n return 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143847,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " int res_inverse(vorbis_dsp_state *vd,vorbis_info_residue *info,\n                ogg_int32_t **in,int *nonzero,int ch){\n \n   int i,j,k,s,used=0;\n   codec_setup_info     *ci=(codec_setup_info *)vd->vi->codec_setup;\n  codebook *phrasebook=ci->book_param+info->groupbook;\n int samples_per_partition=info->grouping;\n int partitions_per_word=phrasebook->dim;\n int pcmend=ci->blocksizes[vd->W];\n\n if(info->type<2){\n int max=pcmend>>1;\n int end=(info->end<max?info->end:max);\n int n=end-info->begin;\n\n if(n>0){\n int partvals=n/samples_per_partition;\n\n       int partwords=(partvals+partitions_per_word-1)/partitions_per_word;\n \n       for(i=0;i<ch;i++)\n        if(nonzero[i])\n          in[used++]=in[i];\n       ch=used;\n \n       if(used){\n \n        char **partword=(char **)alloca(ch*sizeof(*partword));\n        for(j=0;j<ch;j++)\n          partword[j]=(char *)alloca(partwords*partitions_per_word*\n                                     sizeof(*partword[j]));\n \n        for(s=0;s<info->stages;s++){\n \n          for(i=0;i<partvals;){\n            if(s==0){\n              /* fetch the partition word for each channel */\n \n              partword[0][i+partitions_per_word-1]=1;\n              for(k=partitions_per_word-2;k>=0;k--)\n                partword[0][i+k]=partword[0][i+k+1]*info->partitions;\n \n              for(j=1;j<ch;j++)\n                for(k=partitions_per_word-1;k>=0;k--)\n                  partword[j][i+k]=partword[j-1][i+k];\n \n              for(j=0;j<ch;j++){\n                int temp=vorbis_book_decode(phrasebook,&vd->opb);\n                if(temp==-1)goto eopbreak;\n \n                /* this can be done quickly in assembly due to the quotient\n                   always being at most six bits */\n                for(k=0;k<partitions_per_word;k++){\n                  ogg_uint32_t div=partword[j][i+k];\n                  partword[j][i+k]=temp/div;\n                  temp-=partword[j][i+k]*div;\n                }\n \n              }\n            }\n \n            /* now we decode residual values for the partitions */\n            for(k=0;k<partitions_per_word && i<partvals;k++,i++)\n              for(j=0;j<ch;j++){\n                long offset=info->begin+i*samples_per_partition;\n                int idx = (int)partword[j][i];\n                if(idx < info->partitions && info->stagemasks[idx]&(1<<s)){\n                  codebook *stagebook=ci->book_param+\n                    info->stagebooks[(partword[j][i]<<3)+s];\n                  if(info->type){\n                    if(vorbis_book_decodev_add(stagebook,in[j]+offset,&vd->opb,\n                                               samples_per_partition,-8)==-1)\n                      goto eopbreak;\n                  }else{\n                    if(vorbis_book_decodevs_add(stagebook,in[j]+offset,&vd->opb,\n                                                samples_per_partition,-8)==-1)\n                      goto eopbreak;\n                  }\n                }\n              }\n          }\n        }\n       }\n     }\n   }else{\n int max=(pcmend*ch)>>1;\n int end=(info->end<max?info->end:max);\n int n=end-info->begin;\n\n if(n>0){\n int partvals=n/samples_per_partition;\n\n       int partwords=(partvals+partitions_per_word-1)/partitions_per_word;\n \n       char *partword=\n        (char *)alloca(partwords*partitions_per_word*sizeof(*partword));\n       int beginoff=info->begin/ch;\n \n       for(i=0;i<ch;i++)if(nonzero[i])break;\n if(i==ch)return(0); /* no nonzero vectors */\n\n      samples_per_partition/=ch;\n\n for(s=0;s<info->stages;s++){\n for(i=0;i<partvals;){\n\n if(s==0){\n int temp;\n\t    partword[i+partitions_per_word-1]=1;\n for(k=partitions_per_word-2;k>=0;k--)\n\t      partword[i+k]=partword[i+k+1]*info->partitions;\n\n /* fetch the partition word */\n\t    temp=vorbis_book_decode(phrasebook,&vd->opb);\n if(temp==-1)goto eopbreak;\n\n /* this can be done quickly in assembly due to the quotient\n\t       always being at most six bits */\n for(k=0;k<partitions_per_word;k++){\n ogg_uint32_t div=partword[i+k];\n\t      partword[i+k]=temp/div;\n\t      temp-=partword[i+k]*div;\n }\n }\n\n /* now we decode residual values for the partitions */\n for(k=0;k<partitions_per_word && i<partvals;k++,i++)\n if(info->stagemasks[(int)partword[i]]&(1<<s)){\n\t      codebook *stagebook=ci->book_param+\n\t\tinfo->stagebooks[(partword[i]<<3)+s];\n if(vorbis_book_decodevv_add(stagebook,in,\n\t\t\t\t\t  i*samples_per_partition+beginoff,ch,\n &vd->opb,\n\t\t\t\t\t  samples_per_partition,-8)==-1)\n goto eopbreak;\n }\n }\n }\n }\n }\n eopbreak:\n\n return 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143848,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void SoftMP3::onQueueFilled(OMX_U32 /* portIndex */) {\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n while ((!inQueue.empty() || (mSawInputEos && !mSignalledOutputEos)) && !outQueue.empty()) {\n BufferInfo *inInfo = NULL;\n        OMX_BUFFERHEADERTYPE *inHeader = NULL;\n if (!inQueue.empty()) {\n            inInfo = *inQueue.begin();\n            inHeader = inInfo->mHeader;\n }\n\n BufferInfo *outInfo = *outQueue.begin();\n        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n        outHeader->nFlags = 0;\n\n if (inHeader) {\n if (inHeader->nOffset == 0 && inHeader->nFilledLen) {\n                mAnchorTimeUs = inHeader->nTimeStamp;\n                mNumFramesOutput = 0;\n }\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n                mSawInputEos = true;\n }\n\n            mConfig->pInputBuffer =\n                inHeader->pBuffer + inHeader->nOffset;\n\n            mConfig->inputBufferCurrentLength = inHeader->nFilledLen;\n } else {\n            mConfig->pInputBuffer = NULL;\n            mConfig->inputBufferCurrentLength = 0;\n }\n        mConfig->inputBufferMaxLength = 0;\n\n         mConfig->inputBufferUsedLength = 0;\n \n         mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);\n \n         mConfig->pOutputBuffer =\n             reinterpret_cast<int16_t *>(outHeader->pBuffer);\n\n        ERROR_CODE decoderErr;\n if ((decoderErr = pvmp3_framedecoder(mConfig, mDecoderBuf))\n != NO_DECODING_ERROR) {\n            ALOGV(\"mp3 decoder returned error %d\", decoderErr);\n\n if (decoderErr != NO_ENOUGH_MAIN_DATA_ERROR\n && decoderErr != SIDE_INFO_ERROR) {\n                ALOGE(\"mp3 decoder returned error %d\", decoderErr);\n\n                notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n                mSignalledError = true;\n return;\n }\n\n if (mConfig->outputFrameSize == 0) {\n                mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);\n }\n\n if (decoderErr == NO_ENOUGH_MAIN_DATA_ERROR && mSawInputEos) {\n if (!mIsFirst) {\n                    outHeader->nOffset = 0;\n                    outHeader->nFilledLen = kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);\n\n                    memset(outHeader->pBuffer, 0, outHeader->nFilledLen);\n }\n                outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n                mSignalledOutputEos = true;\n } else {\n\n                ALOGV_IF(mIsFirst, \"insufficient data for first frame, sending silence\");\n                memset(outHeader->pBuffer,\n 0,\n                       mConfig->outputFrameSize * sizeof(int16_t));\n\n if (inHeader) {\n                    mConfig->inputBufferUsedLength = inHeader->nFilledLen;\n }\n }\n } else if (mConfig->samplingRate != mSamplingRate\n || mConfig->num_channels != mNumChannels) {\n            mSamplingRate = mConfig->samplingRate;\n            mNumChannels = mConfig->num_channels;\n\n            notify(OMX_EventPortSettingsChanged, 1, 0, NULL);\n            mOutputPortSettingsChange = AWAITING_DISABLED;\n return;\n }\n\n if (mIsFirst) {\n            mIsFirst = false;\n            outHeader->nOffset =\n                kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);\n\n            outHeader->nFilledLen =\n                mConfig->outputFrameSize * sizeof(int16_t) - outHeader->nOffset;\n } else if (!mSignalledOutputEos) {\n            outHeader->nOffset = 0;\n            outHeader->nFilledLen = mConfig->outputFrameSize * sizeof(int16_t);\n }\n\n        outHeader->nTimeStamp =\n            mAnchorTimeUs + (mNumFramesOutput * 1000000ll) / mSamplingRate;\n\n if (inHeader) {\n            CHECK_GE(inHeader->nFilledLen, mConfig->inputBufferUsedLength);\n\n            inHeader->nOffset += mConfig->inputBufferUsedLength;\n            inHeader->nFilledLen -= mConfig->inputBufferUsedLength;\n\n\n if (inHeader->nFilledLen == 0) {\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n }\n }\n\n        mNumFramesOutput += mConfig->outputFrameSize / mNumChannels;\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143855,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void SoftMP3::onQueueFilled(OMX_U32 /* portIndex */) {\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n while ((!inQueue.empty() || (mSawInputEos && !mSignalledOutputEos)) && !outQueue.empty()) {\n BufferInfo *inInfo = NULL;\n        OMX_BUFFERHEADERTYPE *inHeader = NULL;\n if (!inQueue.empty()) {\n            inInfo = *inQueue.begin();\n            inHeader = inInfo->mHeader;\n }\n\n BufferInfo *outInfo = *outQueue.begin();\n        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n        outHeader->nFlags = 0;\n\n if (inHeader) {\n if (inHeader->nOffset == 0 && inHeader->nFilledLen) {\n                mAnchorTimeUs = inHeader->nTimeStamp;\n                mNumFramesOutput = 0;\n }\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n                mSawInputEos = true;\n }\n\n            mConfig->pInputBuffer =\n                inHeader->pBuffer + inHeader->nOffset;\n\n            mConfig->inputBufferCurrentLength = inHeader->nFilledLen;\n } else {\n            mConfig->pInputBuffer = NULL;\n            mConfig->inputBufferCurrentLength = 0;\n }\n        mConfig->inputBufferMaxLength = 0;\n\n         mConfig->inputBufferUsedLength = 0;\n \n         mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);\n        if ((int32)outHeader->nAllocLen < mConfig->outputFrameSize) {\n            ALOGE(\"input buffer too small: got %lu, expected %u\",\n                outHeader->nAllocLen, mConfig->outputFrameSize);\n            android_errorWriteLog(0x534e4554, \"27793371\");\n            notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);\n            mSignalledError = true;\n            return;\n        }\n \n         mConfig->pOutputBuffer =\n             reinterpret_cast<int16_t *>(outHeader->pBuffer);\n\n        ERROR_CODE decoderErr;\n if ((decoderErr = pvmp3_framedecoder(mConfig, mDecoderBuf))\n != NO_DECODING_ERROR) {\n            ALOGV(\"mp3 decoder returned error %d\", decoderErr);\n\n if (decoderErr != NO_ENOUGH_MAIN_DATA_ERROR\n && decoderErr != SIDE_INFO_ERROR) {\n                ALOGE(\"mp3 decoder returned error %d\", decoderErr);\n\n                notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n                mSignalledError = true;\n return;\n }\n\n if (mConfig->outputFrameSize == 0) {\n                mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);\n }\n\n if (decoderErr == NO_ENOUGH_MAIN_DATA_ERROR && mSawInputEos) {\n if (!mIsFirst) {\n                    outHeader->nOffset = 0;\n                    outHeader->nFilledLen = kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);\n\n                    memset(outHeader->pBuffer, 0, outHeader->nFilledLen);\n }\n                outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n                mSignalledOutputEos = true;\n } else {\n\n                ALOGV_IF(mIsFirst, \"insufficient data for first frame, sending silence\");\n                memset(outHeader->pBuffer,\n 0,\n                       mConfig->outputFrameSize * sizeof(int16_t));\n\n if (inHeader) {\n                    mConfig->inputBufferUsedLength = inHeader->nFilledLen;\n }\n }\n } else if (mConfig->samplingRate != mSamplingRate\n || mConfig->num_channels != mNumChannels) {\n            mSamplingRate = mConfig->samplingRate;\n            mNumChannels = mConfig->num_channels;\n\n            notify(OMX_EventPortSettingsChanged, 1, 0, NULL);\n            mOutputPortSettingsChange = AWAITING_DISABLED;\n return;\n }\n\n if (mIsFirst) {\n            mIsFirst = false;\n            outHeader->nOffset =\n                kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);\n\n            outHeader->nFilledLen =\n                mConfig->outputFrameSize * sizeof(int16_t) - outHeader->nOffset;\n } else if (!mSignalledOutputEos) {\n            outHeader->nOffset = 0;\n            outHeader->nFilledLen = mConfig->outputFrameSize * sizeof(int16_t);\n }\n\n        outHeader->nTimeStamp =\n            mAnchorTimeUs + (mNumFramesOutput * 1000000ll) / mSamplingRate;\n\n if (inHeader) {\n            CHECK_GE(inHeader->nFilledLen, mConfig->inputBufferUsedLength);\n\n            inHeader->nOffset += mConfig->inputBufferUsedLength;\n            inHeader->nFilledLen -= mConfig->inputBufferUsedLength;\n\n\n if (inHeader->nFilledLen == 0) {\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n }\n }\n\n        mNumFramesOutput += mConfig->outputFrameSize / mNumChannels;\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143856,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "status_t MPEG4Source::fragmentedRead(\n MediaBuffer **out, const ReadOptions *options) {\n\n    ALOGV(\"MPEG4Source::fragmentedRead\");\n\n    CHECK(mStarted);\n\n *out = NULL;\n\n int64_t targetSampleTimeUs = -1;\n\n int64_t seekTimeUs;\n ReadOptions::SeekMode mode;\n if (options && options->getSeekTo(&seekTimeUs, &mode)) {\n\n int numSidxEntries = mSegments.size();\n if (numSidxEntries != 0) {\n int64_t totalTime = 0;\n off64_t totalOffset = mFirstMoofOffset;\n for (int i = 0; i < numSidxEntries; i++) {\n const SidxEntry *se = &mSegments[i];\n if (totalTime + se->mDurationUs > seekTimeUs) {\n if ((mode == ReadOptions::SEEK_NEXT_SYNC) ||\n (mode == ReadOptions::SEEK_CLOSEST_SYNC &&\n (seekTimeUs - totalTime) > (totalTime + se->mDurationUs - seekTimeUs))) {\n                        totalTime += se->mDurationUs;\n                        totalOffset += se->mSize;\n }\n break;\n }\n                totalTime += se->mDurationUs;\n                totalOffset += se->mSize;\n }\n        mCurrentMoofOffset = totalOffset;\n        mCurrentSamples.clear();\n        mCurrentSampleIndex = 0;\n        parseChunk(&totalOffset);\n        mCurrentTime = totalTime * mTimescale / 1000000ll;\n }\n\n if (mBuffer != NULL) {\n            mBuffer->release();\n            mBuffer = NULL;\n }\n\n }\n\n off64_t offset = 0;\n size_t size;\n uint32_t cts = 0;\n bool isSyncSample = false;\n bool newBuffer = false;\n if (mBuffer == NULL) {\n        newBuffer = true;\n\n if (mCurrentSampleIndex >= mCurrentSamples.size()) {\n Sample lastSample = mCurrentSamples[mCurrentSamples.size() - 1];\n off64_t nextMoof = mNextMoofOffset; // lastSample.offset + lastSample.size;\n            mCurrentMoofOffset = nextMoof;\n            mCurrentSamples.clear();\n            mCurrentSampleIndex = 0;\n            parseChunk(&nextMoof);\n if (mCurrentSampleIndex >= mCurrentSamples.size()) {\n return ERROR_END_OF_STREAM;\n }\n }\n\n const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex];\n        offset = smpl->offset;\n        size = smpl->size;\n        cts = mCurrentTime;\n        mCurrentTime += smpl->duration;\n        isSyncSample = (mCurrentSampleIndex == 0); // XXX\n\n status_t err = mGroup->acquire_buffer(&mBuffer);\n\n if (err != OK) {\n            CHECK(mBuffer == NULL);\n            ALOGV(\"acquire_buffer returned %d\", err);\n return err;\n }\n if (size > mBuffer->size()) {\n            ALOGE(\"buffer too small: %zu > %zu\", size, mBuffer->size());\n return ERROR_BUFFER_TOO_SMALL;\n }\n }\n\n const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex];\n const sp<MetaData> bufmeta = mBuffer->meta_data();\n    bufmeta->clear();\n if (smpl->encryptedsizes.size()) {\n        bufmeta->setData(kKeyPlainSizes, 0,\n                smpl->clearsizes.array(), smpl->clearsizes.size() * 4);\n        bufmeta->setData(kKeyEncryptedSizes, 0,\n                smpl->encryptedsizes.array(), smpl->encryptedsizes.size() * 4);\n        bufmeta->setData(kKeyCryptoIV, 0, smpl->iv, 16); // use 16 or the actual size?\n        bufmeta->setInt32(kKeyCryptoDefaultIVSize, mDefaultIVSize);\n        bufmeta->setInt32(kKeyCryptoMode, mCryptoMode);\n        bufmeta->setData(kKeyCryptoKey, 0, mCryptoKey, 16);\n }\n\n if (!mIsAVC || mWantsNALFragments) {\n if (newBuffer) {\n if (!isInRange((size_t)0u, mBuffer->size(), size)) {\n                mBuffer->release();\n                mBuffer = NULL;\n\n                ALOGE(\"fragmentedRead ERROR_MALFORMED size %zu\", size);\n return ERROR_MALFORMED;\n }\n\n ssize_t num_bytes_read =\n                mDataSource->readAt(offset, (uint8_t *)mBuffer->data(), size);\n\n if (num_bytes_read < (ssize_t)size) {\n                mBuffer->release();\n                mBuffer = NULL;\n\n                ALOGE(\"i/o error\");\n return ERROR_IO;\n }\n\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, size);\n            mBuffer->meta_data()->setInt64(\n                    kKeyTime, ((int64_t)cts * 1000000) / mTimescale);\n\n if (targetSampleTimeUs >= 0) {\n                mBuffer->meta_data()->setInt64(\n                        kKeyTargetTime, targetSampleTimeUs);\n }\n\n if (isSyncSample) {\n                mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n }\n\n ++mCurrentSampleIndex;\n }\n\n if (!mIsAVC) {\n *out = mBuffer;\n            mBuffer = NULL;\n\n return OK;\n }\n\n\n        CHECK(mBuffer->range_length() >= mNALLengthSize);\n\n const uint8_t *src =\n (const uint8_t *)mBuffer->data() + mBuffer->range_offset();\n\n size_t nal_size = parseNALSize(src);\n if (mNALLengthSize > SIZE_MAX - nal_size) {\n            ALOGE(\"b/24441553, b/24445122\");\n }\n\n if (mBuffer->range_length() - mNALLengthSize < nal_size) {\n            ALOGE(\"incomplete NAL unit.\");\n\n            mBuffer->release();\n            mBuffer = NULL;\n\n return ERROR_MALFORMED;\n }\n\n MediaBuffer *clone = mBuffer->clone();\n        CHECK(clone != NULL);\n        clone->set_range(mBuffer->range_offset() + mNALLengthSize, nal_size);\n\n        CHECK(mBuffer != NULL);\n        mBuffer->set_range(\n                mBuffer->range_offset() + mNALLengthSize + nal_size,\n                mBuffer->range_length() - mNALLengthSize - nal_size);\n\n if (mBuffer->range_length() == 0) {\n            mBuffer->release();\n            mBuffer = NULL;\n }\n\n *out = clone;\n\n return OK;\n } else {\n        ALOGV(\"whole NAL\");\n ssize_t num_bytes_read = 0;\n int32_t drm = 0;\n bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0);\n void *data = NULL;\n bool isMalFormed = false;\n if (usesDRM) {\n if (mBuffer == NULL || !isInRange((size_t)0u, mBuffer->size(), size)) {\n                isMalFormed = true;\n } else {\n                data = mBuffer->data();\n }\n } else {\n int32_t max_size;\n if (mFormat == NULL\n || !mFormat->findInt32(kKeyMaxInputSize, &max_size)\n || !isInRange((size_t)0u, (size_t)max_size, size)) {\n                isMalFormed = true;\n } else {\n                data = mSrcBuffer;\n }\n }\n\n if (isMalFormed || data == NULL) {\n            ALOGE(\"isMalFormed size %zu\", size);\n if (mBuffer != NULL) {\n                mBuffer->release();\n                mBuffer = NULL;\n }\n return ERROR_MALFORMED;\n }\n        num_bytes_read = mDataSource->readAt(offset, data, size);\n\n if (num_bytes_read < (ssize_t)size) {\n            mBuffer->release();\n            mBuffer = NULL;\n\n            ALOGE(\"i/o error\");\n return ERROR_IO;\n }\n\n if (usesDRM) {\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, size);\n\n } else {\n uint8_t *dstData = (uint8_t *)mBuffer->data();\n size_t srcOffset = 0;\n size_t dstOffset = 0;\n\n while (srcOffset < size) {\n                isMalFormed = !isInRange((size_t)0u, size, srcOffset, mNALLengthSize);\n size_t nalLength = 0;\n if (!isMalFormed) {\n                    nalLength = parseNALSize(&mSrcBuffer[srcOffset]);\n                    srcOffset += mNALLengthSize;\n                    isMalFormed = !isInRange((size_t)0u, size, srcOffset, nalLength)\n || !isInRange((size_t)0u, mBuffer->size(), dstOffset, (size_t)4u)\n || !isInRange((size_t)0u, mBuffer->size(), dstOffset + 4, nalLength);\n }\n\n if (isMalFormed) {\n                    ALOGE(\"Video is malformed; nalLength %zu\", nalLength);\n                    mBuffer->release();\n                    mBuffer = NULL;\n return ERROR_MALFORMED;\n }\n\n if (nalLength == 0) {\n\n                     continue;\n                 }\n \n                CHECK(dstOffset + 4 <= mBuffer->size());\n \n                 dstData[dstOffset++] = 0;\n                 dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 1;\n                memcpy(&dstData[dstOffset], &mSrcBuffer[srcOffset], nalLength);\n                srcOffset += nalLength;\n                dstOffset += nalLength;\n }\n            CHECK_EQ(srcOffset, size);\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, dstOffset);\n }\n\n        mBuffer->meta_data()->setInt64(\n                kKeyTime, ((int64_t)cts * 1000000) / mTimescale);\n\n if (targetSampleTimeUs >= 0) {\n            mBuffer->meta_data()->setInt64(\n                    kKeyTargetTime, targetSampleTimeUs);\n }\n\n if (isSyncSample) {\n            mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n }\n\n ++mCurrentSampleIndex;\n\n *out = mBuffer;\n        mBuffer = NULL;\n\n return OK;\n }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143869,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "status_t MPEG4Source::fragmentedRead(\n MediaBuffer **out, const ReadOptions *options) {\n\n    ALOGV(\"MPEG4Source::fragmentedRead\");\n\n    CHECK(mStarted);\n\n *out = NULL;\n\n int64_t targetSampleTimeUs = -1;\n\n int64_t seekTimeUs;\n ReadOptions::SeekMode mode;\n if (options && options->getSeekTo(&seekTimeUs, &mode)) {\n\n int numSidxEntries = mSegments.size();\n if (numSidxEntries != 0) {\n int64_t totalTime = 0;\n off64_t totalOffset = mFirstMoofOffset;\n for (int i = 0; i < numSidxEntries; i++) {\n const SidxEntry *se = &mSegments[i];\n if (totalTime + se->mDurationUs > seekTimeUs) {\n if ((mode == ReadOptions::SEEK_NEXT_SYNC) ||\n (mode == ReadOptions::SEEK_CLOSEST_SYNC &&\n (seekTimeUs - totalTime) > (totalTime + se->mDurationUs - seekTimeUs))) {\n                        totalTime += se->mDurationUs;\n                        totalOffset += se->mSize;\n }\n break;\n }\n                totalTime += se->mDurationUs;\n                totalOffset += se->mSize;\n }\n        mCurrentMoofOffset = totalOffset;\n        mCurrentSamples.clear();\n        mCurrentSampleIndex = 0;\n        parseChunk(&totalOffset);\n        mCurrentTime = totalTime * mTimescale / 1000000ll;\n }\n\n if (mBuffer != NULL) {\n            mBuffer->release();\n            mBuffer = NULL;\n }\n\n }\n\n off64_t offset = 0;\n size_t size;\n uint32_t cts = 0;\n bool isSyncSample = false;\n bool newBuffer = false;\n if (mBuffer == NULL) {\n        newBuffer = true;\n\n if (mCurrentSampleIndex >= mCurrentSamples.size()) {\n Sample lastSample = mCurrentSamples[mCurrentSamples.size() - 1];\n off64_t nextMoof = mNextMoofOffset; // lastSample.offset + lastSample.size;\n            mCurrentMoofOffset = nextMoof;\n            mCurrentSamples.clear();\n            mCurrentSampleIndex = 0;\n            parseChunk(&nextMoof);\n if (mCurrentSampleIndex >= mCurrentSamples.size()) {\n return ERROR_END_OF_STREAM;\n }\n }\n\n const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex];\n        offset = smpl->offset;\n        size = smpl->size;\n        cts = mCurrentTime;\n        mCurrentTime += smpl->duration;\n        isSyncSample = (mCurrentSampleIndex == 0); // XXX\n\n status_t err = mGroup->acquire_buffer(&mBuffer);\n\n if (err != OK) {\n            CHECK(mBuffer == NULL);\n            ALOGV(\"acquire_buffer returned %d\", err);\n return err;\n }\n if (size > mBuffer->size()) {\n            ALOGE(\"buffer too small: %zu > %zu\", size, mBuffer->size());\n return ERROR_BUFFER_TOO_SMALL;\n }\n }\n\n const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex];\n const sp<MetaData> bufmeta = mBuffer->meta_data();\n    bufmeta->clear();\n if (smpl->encryptedsizes.size()) {\n        bufmeta->setData(kKeyPlainSizes, 0,\n                smpl->clearsizes.array(), smpl->clearsizes.size() * 4);\n        bufmeta->setData(kKeyEncryptedSizes, 0,\n                smpl->encryptedsizes.array(), smpl->encryptedsizes.size() * 4);\n        bufmeta->setData(kKeyCryptoIV, 0, smpl->iv, 16); // use 16 or the actual size?\n        bufmeta->setInt32(kKeyCryptoDefaultIVSize, mDefaultIVSize);\n        bufmeta->setInt32(kKeyCryptoMode, mCryptoMode);\n        bufmeta->setData(kKeyCryptoKey, 0, mCryptoKey, 16);\n }\n\n if (!mIsAVC || mWantsNALFragments) {\n if (newBuffer) {\n if (!isInRange((size_t)0u, mBuffer->size(), size)) {\n                mBuffer->release();\n                mBuffer = NULL;\n\n                ALOGE(\"fragmentedRead ERROR_MALFORMED size %zu\", size);\n return ERROR_MALFORMED;\n }\n\n ssize_t num_bytes_read =\n                mDataSource->readAt(offset, (uint8_t *)mBuffer->data(), size);\n\n if (num_bytes_read < (ssize_t)size) {\n                mBuffer->release();\n                mBuffer = NULL;\n\n                ALOGE(\"i/o error\");\n return ERROR_IO;\n }\n\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, size);\n            mBuffer->meta_data()->setInt64(\n                    kKeyTime, ((int64_t)cts * 1000000) / mTimescale);\n\n if (targetSampleTimeUs >= 0) {\n                mBuffer->meta_data()->setInt64(\n                        kKeyTargetTime, targetSampleTimeUs);\n }\n\n if (isSyncSample) {\n                mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n }\n\n ++mCurrentSampleIndex;\n }\n\n if (!mIsAVC) {\n *out = mBuffer;\n            mBuffer = NULL;\n\n return OK;\n }\n\n\n        CHECK(mBuffer->range_length() >= mNALLengthSize);\n\n const uint8_t *src =\n (const uint8_t *)mBuffer->data() + mBuffer->range_offset();\n\n size_t nal_size = parseNALSize(src);\n if (mNALLengthSize > SIZE_MAX - nal_size) {\n            ALOGE(\"b/24441553, b/24445122\");\n }\n\n if (mBuffer->range_length() - mNALLengthSize < nal_size) {\n            ALOGE(\"incomplete NAL unit.\");\n\n            mBuffer->release();\n            mBuffer = NULL;\n\n return ERROR_MALFORMED;\n }\n\n MediaBuffer *clone = mBuffer->clone();\n        CHECK(clone != NULL);\n        clone->set_range(mBuffer->range_offset() + mNALLengthSize, nal_size);\n\n        CHECK(mBuffer != NULL);\n        mBuffer->set_range(\n                mBuffer->range_offset() + mNALLengthSize + nal_size,\n                mBuffer->range_length() - mNALLengthSize - nal_size);\n\n if (mBuffer->range_length() == 0) {\n            mBuffer->release();\n            mBuffer = NULL;\n }\n\n *out = clone;\n\n return OK;\n } else {\n        ALOGV(\"whole NAL\");\n ssize_t num_bytes_read = 0;\n int32_t drm = 0;\n bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0);\n void *data = NULL;\n bool isMalFormed = false;\n if (usesDRM) {\n if (mBuffer == NULL || !isInRange((size_t)0u, mBuffer->size(), size)) {\n                isMalFormed = true;\n } else {\n                data = mBuffer->data();\n }\n } else {\n int32_t max_size;\n if (mFormat == NULL\n || !mFormat->findInt32(kKeyMaxInputSize, &max_size)\n || !isInRange((size_t)0u, (size_t)max_size, size)) {\n                isMalFormed = true;\n } else {\n                data = mSrcBuffer;\n }\n }\n\n if (isMalFormed || data == NULL) {\n            ALOGE(\"isMalFormed size %zu\", size);\n if (mBuffer != NULL) {\n                mBuffer->release();\n                mBuffer = NULL;\n }\n return ERROR_MALFORMED;\n }\n        num_bytes_read = mDataSource->readAt(offset, data, size);\n\n if (num_bytes_read < (ssize_t)size) {\n            mBuffer->release();\n            mBuffer = NULL;\n\n            ALOGE(\"i/o error\");\n return ERROR_IO;\n }\n\n if (usesDRM) {\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, size);\n\n } else {\n uint8_t *dstData = (uint8_t *)mBuffer->data();\n size_t srcOffset = 0;\n size_t dstOffset = 0;\n\n while (srcOffset < size) {\n                isMalFormed = !isInRange((size_t)0u, size, srcOffset, mNALLengthSize);\n size_t nalLength = 0;\n if (!isMalFormed) {\n                    nalLength = parseNALSize(&mSrcBuffer[srcOffset]);\n                    srcOffset += mNALLengthSize;\n                    isMalFormed = !isInRange((size_t)0u, size, srcOffset, nalLength)\n || !isInRange((size_t)0u, mBuffer->size(), dstOffset, (size_t)4u)\n || !isInRange((size_t)0u, mBuffer->size(), dstOffset + 4, nalLength);\n }\n\n if (isMalFormed) {\n                    ALOGE(\"Video is malformed; nalLength %zu\", nalLength);\n                    mBuffer->release();\n                    mBuffer = NULL;\n return ERROR_MALFORMED;\n }\n\n if (nalLength == 0) {\n\n                     continue;\n                 }\n \n                if (dstOffset > SIZE_MAX - 4 ||\n                        dstOffset + 4 > SIZE_MAX - nalLength ||\n                        dstOffset + 4 + nalLength > mBuffer->size()) {\n                    ALOGE(\"b/26365349 : %zu %zu\", dstOffset, mBuffer->size());\n                    android_errorWriteLog(0x534e4554, \"26365349\");\n                    mBuffer->release();\n                    mBuffer = NULL;\n                    return ERROR_MALFORMED;\n                }\n \n                 dstData[dstOffset++] = 0;\n                 dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 1;\n                memcpy(&dstData[dstOffset], &mSrcBuffer[srcOffset], nalLength);\n                srcOffset += nalLength;\n                dstOffset += nalLength;\n }\n            CHECK_EQ(srcOffset, size);\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, dstOffset);\n }\n\n        mBuffer->meta_data()->setInt64(\n                kKeyTime, ((int64_t)cts * 1000000) / mTimescale);\n\n if (targetSampleTimeUs >= 0) {\n            mBuffer->meta_data()->setInt64(\n                    kKeyTargetTime, targetSampleTimeUs);\n }\n\n if (isSyncSample) {\n            mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n }\n\n ++mCurrentSampleIndex;\n\n *out = mBuffer;\n        mBuffer = NULL;\n\n return OK;\n }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143870,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "long FrameSequenceState_gif::drawFrame(int frameNr,\n Color8888* outputPtr, int outputPixelStride, int previousFrameNr) {\n\n GifFileType* gif = mFrameSequence.getGif();\n if (!gif) {\n        ALOGD(\"Cannot drawFrame, mGif is NULL\");\n return -1;\n }\n\n#if GIF_DEBUG\n    ALOGD(\"      drawFrame on %p nr %d on addr %p, previous frame nr %d\",\n this, frameNr, outputPtr, previousFrameNr);\n#endif\n\n const int height = mFrameSequence.getHeight();\n const int width = mFrameSequence.getWidth();\n\n GraphicsControlBlock gcb;\n\n int start = max(previousFrameNr + 1, 0);\n\n for (int i = max(start - 1, 0); i < frameNr; i++) {\n int neededPreservedFrame = mFrameSequence.getRestoringFrame(i);\n if (neededPreservedFrame >= 0 && (mPreserveBufferFrame != neededPreservedFrame)) {\n#if GIF_DEBUG\n            ALOGD(\"frame %d needs frame %d preserved, but %d is currently, so drawing from scratch\",\n                    i, neededPreservedFrame, mPreserveBufferFrame);\n#endif\n            start = 0;\n }\n }\n\n for (int i = start; i <= frameNr; i++) {\n DGifSavedExtensionToGCB(gif, i, &gcb);\n const SavedImage& frame = gif->SavedImages[i];\n\n#if GIF_DEBUG\n bool frameOpaque = gcb.TransparentColor == NO_TRANSPARENT_COLOR;\n        ALOGD(\"producing frame %d, drawing frame %d (opaque %d, disp %d, del %d)\",\n                frameNr, i, frameOpaque, gcb.DisposalMode, gcb.DelayTime);\n#endif\n if (i == 0) {\n Color8888 bgColor = mFrameSequence.getBackgroundColor();\n for (int y = 0; y < height; y++) {\n for (int x = 0; x < width; x++) {\n                    outputPtr[y * outputPixelStride + x] = bgColor;\n }\n }\n } else {\n GraphicsControlBlock prevGcb;\n DGifSavedExtensionToGCB(gif, i - 1, &prevGcb);\n const SavedImage& prevFrame = gif->SavedImages[i - 1];\n bool prevFrameDisposed = willBeCleared(prevGcb);\n\n bool newFrameOpaque = gcb.TransparentColor == NO_TRANSPARENT_COLOR;\n bool prevFrameCompletelyCovered = newFrameOpaque\n && checkIfCover(frame.ImageDesc, prevFrame.ImageDesc);\n\n if (prevFrameDisposed && !prevFrameCompletelyCovered) {\n switch (prevGcb.DisposalMode) {\n case DISPOSE_BACKGROUND: {\n Color8888* dst = outputPtr + prevFrame.ImageDesc.Left +\n                            prevFrame.ImageDesc.Top * outputPixelStride;\n\n GifWord copyWidth, copyHeight;\n                    getCopySize(prevFrame.ImageDesc, width, height, copyWidth, copyHeight);\n for (; copyHeight > 0; copyHeight--) {\n                        setLineColor(dst, TRANSPARENT, copyWidth);\n                        dst += outputPixelStride;\n }\n } break;\n case DISPOSE_PREVIOUS: {\n                    restorePreserveBuffer(outputPtr, outputPixelStride);\n } break;\n }\n }\n\n if (mFrameSequence.getPreservedFrame(i - 1)) {\n                savePreserveBuffer(outputPtr, outputPixelStride, i - 1);\n }\n }\n\n bool willBeCleared = gcb.DisposalMode == DISPOSE_BACKGROUND\n || gcb.DisposalMode == DISPOSE_PREVIOUS;\n if (i == frameNr || !willBeCleared) {\n const ColorMapObject* cmap = gif->SColorMap;\n if (frame.ImageDesc.ColorMap) {\n\n                 cmap = frame.ImageDesc.ColorMap;\n             }\n \n            if (cmap == NULL || cmap->ColorCount != (1 << cmap->BitsPerPixel)) {\n                ALOGW(\"Warning: potentially corrupt color map\");\n            }\n            const unsigned char* src = (unsigned char*)frame.RasterBits;\n            Color8888* dst = outputPtr + frame.ImageDesc.Left +\n                    frame.ImageDesc.Top * outputPixelStride;\n            GifWord copyWidth, copyHeight;\n            getCopySize(frame.ImageDesc, width, height, copyWidth, copyHeight);\n            for (; copyHeight > 0; copyHeight--) {\n                copyLine(dst, src, cmap, gcb.TransparentColor, copyWidth);\n                src += frame.ImageDesc.Width;\n                dst += outputPixelStride;\n             }\n         }\n     }\n\n const int maxFrame = gif->ImageCount;\n const int lastFrame = (frameNr + maxFrame - 1) % maxFrame;\n DGifSavedExtensionToGCB(gif, lastFrame, &gcb);\n return getDelayMs(gcb);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143929,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "long FrameSequenceState_gif::drawFrame(int frameNr,\n Color8888* outputPtr, int outputPixelStride, int previousFrameNr) {\n\n GifFileType* gif = mFrameSequence.getGif();\n if (!gif) {\n        ALOGD(\"Cannot drawFrame, mGif is NULL\");\n return -1;\n }\n\n#if GIF_DEBUG\n    ALOGD(\"      drawFrame on %p nr %d on addr %p, previous frame nr %d\",\n this, frameNr, outputPtr, previousFrameNr);\n#endif\n\n const int height = mFrameSequence.getHeight();\n const int width = mFrameSequence.getWidth();\n\n GraphicsControlBlock gcb;\n\n int start = max(previousFrameNr + 1, 0);\n\n for (int i = max(start - 1, 0); i < frameNr; i++) {\n int neededPreservedFrame = mFrameSequence.getRestoringFrame(i);\n if (neededPreservedFrame >= 0 && (mPreserveBufferFrame != neededPreservedFrame)) {\n#if GIF_DEBUG\n            ALOGD(\"frame %d needs frame %d preserved, but %d is currently, so drawing from scratch\",\n                    i, neededPreservedFrame, mPreserveBufferFrame);\n#endif\n            start = 0;\n }\n }\n\n for (int i = start; i <= frameNr; i++) {\n DGifSavedExtensionToGCB(gif, i, &gcb);\n const SavedImage& frame = gif->SavedImages[i];\n\n#if GIF_DEBUG\n bool frameOpaque = gcb.TransparentColor == NO_TRANSPARENT_COLOR;\n        ALOGD(\"producing frame %d, drawing frame %d (opaque %d, disp %d, del %d)\",\n                frameNr, i, frameOpaque, gcb.DisposalMode, gcb.DelayTime);\n#endif\n if (i == 0) {\n Color8888 bgColor = mFrameSequence.getBackgroundColor();\n for (int y = 0; y < height; y++) {\n for (int x = 0; x < width; x++) {\n                    outputPtr[y * outputPixelStride + x] = bgColor;\n }\n }\n } else {\n GraphicsControlBlock prevGcb;\n DGifSavedExtensionToGCB(gif, i - 1, &prevGcb);\n const SavedImage& prevFrame = gif->SavedImages[i - 1];\n bool prevFrameDisposed = willBeCleared(prevGcb);\n\n bool newFrameOpaque = gcb.TransparentColor == NO_TRANSPARENT_COLOR;\n bool prevFrameCompletelyCovered = newFrameOpaque\n && checkIfCover(frame.ImageDesc, prevFrame.ImageDesc);\n\n if (prevFrameDisposed && !prevFrameCompletelyCovered) {\n switch (prevGcb.DisposalMode) {\n case DISPOSE_BACKGROUND: {\n Color8888* dst = outputPtr + prevFrame.ImageDesc.Left +\n                            prevFrame.ImageDesc.Top * outputPixelStride;\n\n GifWord copyWidth, copyHeight;\n                    getCopySize(prevFrame.ImageDesc, width, height, copyWidth, copyHeight);\n for (; copyHeight > 0; copyHeight--) {\n                        setLineColor(dst, TRANSPARENT, copyWidth);\n                        dst += outputPixelStride;\n }\n } break;\n case DISPOSE_PREVIOUS: {\n                    restorePreserveBuffer(outputPtr, outputPixelStride);\n } break;\n }\n }\n\n if (mFrameSequence.getPreservedFrame(i - 1)) {\n                savePreserveBuffer(outputPtr, outputPixelStride, i - 1);\n }\n }\n\n bool willBeCleared = gcb.DisposalMode == DISPOSE_BACKGROUND\n || gcb.DisposalMode == DISPOSE_PREVIOUS;\n if (i == frameNr || !willBeCleared) {\n const ColorMapObject* cmap = gif->SColorMap;\n if (frame.ImageDesc.ColorMap) {\n\n                 cmap = frame.ImageDesc.ColorMap;\n             }\n \n            // If a cmap is missing, the frame can't be decoded, so we skip it.\n            if (cmap) {\n                const unsigned char* src = (unsigned char*)frame.RasterBits;\n                Color8888* dst = outputPtr + frame.ImageDesc.Left +\n                        frame.ImageDesc.Top * outputPixelStride;\n                GifWord copyWidth, copyHeight;\n                getCopySize(frame.ImageDesc, width, height, copyWidth, copyHeight);\n                for (; copyHeight > 0; copyHeight--) {\n                    copyLine(dst, src, cmap, gcb.TransparentColor, copyWidth);\n                    src += frame.ImageDesc.Width;\n                    dst += outputPixelStride;\n                }\n             }\n         }\n     }\n\n const int maxFrame = gif->ImageCount;\n const int lastFrame = (frameNr + maxFrame - 1) % maxFrame;\n DGifSavedExtensionToGCB(gif, lastFrame, &gcb);\n return getDelayMs(gcb);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143930,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static vpx_image_t *img_alloc_helper(vpx_image_t *img, vpx_img_fmt_t fmt,\n unsigned int d_w, unsigned int d_h,\n unsigned int buf_align,\n unsigned int stride_align,\n unsigned char *img_data) {\n unsigned int h, w, s, xcs, ycs, bps;\n unsigned int stride_in_bytes;\n int align;\n\n /* Treat align==0 like align==1 */\n if (!buf_align) buf_align = 1;\n\n /* Validate alignment (must be power of 2) */\n if (buf_align & (buf_align - 1)) goto fail;\n\n /* Treat align==0 like align==1 */\n if (!stride_align) stride_align = 1;\n\n /* Validate alignment (must be power of 2) */\n if (stride_align & (stride_align - 1)) goto fail;\n\n /* Get sample size for this format */\n switch (fmt) {\n case VPX_IMG_FMT_RGB32:\n case VPX_IMG_FMT_RGB32_LE:\n case VPX_IMG_FMT_ARGB:\n case VPX_IMG_FMT_ARGB_LE: bps = 32; break;\n case VPX_IMG_FMT_RGB24:\n case VPX_IMG_FMT_BGR24: bps = 24; break;\n case VPX_IMG_FMT_RGB565:\n case VPX_IMG_FMT_RGB565_LE:\n case VPX_IMG_FMT_RGB555:\n case VPX_IMG_FMT_RGB555_LE:\n case VPX_IMG_FMT_UYVY:\n case VPX_IMG_FMT_YUY2:\n case VPX_IMG_FMT_YVYU: bps = 16; break;\n case VPX_IMG_FMT_I420:\n case VPX_IMG_FMT_YV12:\n case VPX_IMG_FMT_VPXI420:\n case VPX_IMG_FMT_VPXYV12: bps = 12; break;\n case VPX_IMG_FMT_I422:\n case VPX_IMG_FMT_I440: bps = 16; break;\n case VPX_IMG_FMT_I444: bps = 24; break;\n case VPX_IMG_FMT_I42016: bps = 24; break;\n case VPX_IMG_FMT_I42216:\n case VPX_IMG_FMT_I44016: bps = 32; break;\n case VPX_IMG_FMT_I44416: bps = 48; break;\n default: bps = 16; break;\n }\n\n /* Get chroma shift values for this format */\n switch (fmt) {\n case VPX_IMG_FMT_I420:\n case VPX_IMG_FMT_YV12:\n case VPX_IMG_FMT_VPXI420:\n case VPX_IMG_FMT_VPXYV12:\n case VPX_IMG_FMT_I422:\n case VPX_IMG_FMT_I42016:\n case VPX_IMG_FMT_I42216: xcs = 1; break;\n default: xcs = 0; break;\n }\n\n switch (fmt) {\n case VPX_IMG_FMT_I420:\n case VPX_IMG_FMT_I440:\n case VPX_IMG_FMT_YV12:\n case VPX_IMG_FMT_VPXI420:\n case VPX_IMG_FMT_VPXYV12:\n case VPX_IMG_FMT_I42016:\n case VPX_IMG_FMT_I44016: ycs = 1; break;\n\n     default: ycs = 0; break;\n   }\n \n  /* Calculate storage sizes given the chroma subsampling */\n  align = (1 << xcs) - 1;\n  w = (d_w + align) & ~align;\n  align = (1 << ycs) - 1;\n  h = (d_h + align) & ~align;\n   s = (fmt & VPX_IMG_FMT_PLANAR) ? w : bps * w / 8;\n   s = (s + stride_align - 1) & ~(stride_align - 1);\n   stride_in_bytes = (fmt & VPX_IMG_FMT_HIGHBITDEPTH) ? s * 2 : s;\n\n /* Allocate the new image */\n if (!img) {\n    img = (vpx_image_t *)calloc(1, sizeof(vpx_image_t));\n\n if (!img) goto fail;\n\n    img->self_allocd = 1;\n } else {\n    memset(img, 0, sizeof(vpx_image_t));\n }\n\n\n   img->img_data = img_data;\n \n   if (!img_data) {\n    const uint64_t alloc_size = (fmt & VPX_IMG_FMT_PLANAR)\n                                    ? (uint64_t)h * s * bps / 8\n                                    : (uint64_t)h * s;\n \n     if (alloc_size != (size_t)alloc_size) goto fail;\n \n    img->img_data = (uint8_t *)vpx_memalign(buf_align, (size_t)alloc_size);\n    img->img_data_owner = 1;\n }\n\n if (!img->img_data) goto fail;\n\n  img->fmt = fmt;\n  img->bit_depth = (fmt & VPX_IMG_FMT_HIGHBITDEPTH) ? 16 : 8;\n  img->w = w;\n  img->h = h;\n  img->x_chroma_shift = xcs;\n  img->y_chroma_shift = ycs;\n  img->bps = bps;\n\n /* Calculate strides */\n  img->stride[VPX_PLANE_Y] = img->stride[VPX_PLANE_ALPHA] = stride_in_bytes;\n  img->stride[VPX_PLANE_U] = img->stride[VPX_PLANE_V] = stride_in_bytes >> xcs;\n\n /* Default viewport to entire image */\n if (!vpx_img_set_rect(img, 0, 0, d_w, d_h)) return img;\n\nfail:\n  vpx_img_free(img);\n return NULL;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143931,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static vpx_image_t *img_alloc_helper(vpx_image_t *img, vpx_img_fmt_t fmt,\n unsigned int d_w, unsigned int d_h,\n unsigned int buf_align,\n unsigned int stride_align,\n unsigned char *img_data) {\n unsigned int h, w, s, xcs, ycs, bps;\n unsigned int stride_in_bytes;\n int align;\n\n /* Treat align==0 like align==1 */\n if (!buf_align) buf_align = 1;\n\n /* Validate alignment (must be power of 2) */\n if (buf_align & (buf_align - 1)) goto fail;\n\n /* Treat align==0 like align==1 */\n if (!stride_align) stride_align = 1;\n\n /* Validate alignment (must be power of 2) */\n if (stride_align & (stride_align - 1)) goto fail;\n\n /* Get sample size for this format */\n switch (fmt) {\n case VPX_IMG_FMT_RGB32:\n case VPX_IMG_FMT_RGB32_LE:\n case VPX_IMG_FMT_ARGB:\n case VPX_IMG_FMT_ARGB_LE: bps = 32; break;\n case VPX_IMG_FMT_RGB24:\n case VPX_IMG_FMT_BGR24: bps = 24; break;\n case VPX_IMG_FMT_RGB565:\n case VPX_IMG_FMT_RGB565_LE:\n case VPX_IMG_FMT_RGB555:\n case VPX_IMG_FMT_RGB555_LE:\n case VPX_IMG_FMT_UYVY:\n case VPX_IMG_FMT_YUY2:\n case VPX_IMG_FMT_YVYU: bps = 16; break;\n case VPX_IMG_FMT_I420:\n case VPX_IMG_FMT_YV12:\n case VPX_IMG_FMT_VPXI420:\n case VPX_IMG_FMT_VPXYV12: bps = 12; break;\n case VPX_IMG_FMT_I422:\n case VPX_IMG_FMT_I440: bps = 16; break;\n case VPX_IMG_FMT_I444: bps = 24; break;\n case VPX_IMG_FMT_I42016: bps = 24; break;\n case VPX_IMG_FMT_I42216:\n case VPX_IMG_FMT_I44016: bps = 32; break;\n case VPX_IMG_FMT_I44416: bps = 48; break;\n default: bps = 16; break;\n }\n\n /* Get chroma shift values for this format */\n switch (fmt) {\n case VPX_IMG_FMT_I420:\n case VPX_IMG_FMT_YV12:\n case VPX_IMG_FMT_VPXI420:\n case VPX_IMG_FMT_VPXYV12:\n case VPX_IMG_FMT_I422:\n case VPX_IMG_FMT_I42016:\n case VPX_IMG_FMT_I42216: xcs = 1; break;\n default: xcs = 0; break;\n }\n\n switch (fmt) {\n case VPX_IMG_FMT_I420:\n case VPX_IMG_FMT_I440:\n case VPX_IMG_FMT_YV12:\n case VPX_IMG_FMT_VPXI420:\n case VPX_IMG_FMT_VPXYV12:\n case VPX_IMG_FMT_I42016:\n case VPX_IMG_FMT_I44016: ycs = 1; break;\n\n     default: ycs = 0; break;\n   }\n \n  /* Calculate storage sizes. If the buffer was allocated externally, the width\n   * and height shouldn't be adjusted. */\n  w = d_w;\n  h = d_h;\n   s = (fmt & VPX_IMG_FMT_PLANAR) ? w : bps * w / 8;\n   s = (s + stride_align - 1) & ~(stride_align - 1);\n   stride_in_bytes = (fmt & VPX_IMG_FMT_HIGHBITDEPTH) ? s * 2 : s;\n\n /* Allocate the new image */\n if (!img) {\n    img = (vpx_image_t *)calloc(1, sizeof(vpx_image_t));\n\n if (!img) goto fail;\n\n    img->self_allocd = 1;\n } else {\n    memset(img, 0, sizeof(vpx_image_t));\n }\n\n\n   img->img_data = img_data;\n \n   if (!img_data) {\n    uint64_t alloc_size;\n    /* Calculate storage sizes given the chroma subsampling */\n    align = (1 << xcs) - 1;\n    w = (d_w + align) & ~align;\n    align = (1 << ycs) - 1;\n    h = (d_h + align) & ~align;\n\n    s = (fmt & VPX_IMG_FMT_PLANAR) ? w : bps * w / 8;\n    s = (s + stride_align - 1) & ~(stride_align - 1);\n    stride_in_bytes = (fmt & VPX_IMG_FMT_HIGHBITDEPTH) ? s * 2 : s;\n    alloc_size = (fmt & VPX_IMG_FMT_PLANAR) ? (uint64_t)h * s * bps / 8\n                                            : (uint64_t)h * s;\n \n     if (alloc_size != (size_t)alloc_size) goto fail;\n \n    img->img_data = (uint8_t *)vpx_memalign(buf_align, (size_t)alloc_size);\n    img->img_data_owner = 1;\n }\n\n if (!img->img_data) goto fail;\n\n  img->fmt = fmt;\n  img->bit_depth = (fmt & VPX_IMG_FMT_HIGHBITDEPTH) ? 16 : 8;\n  img->w = w;\n  img->h = h;\n  img->x_chroma_shift = xcs;\n  img->y_chroma_shift = ycs;\n  img->bps = bps;\n\n /* Calculate strides */\n  img->stride[VPX_PLANE_Y] = img->stride[VPX_PLANE_ALPHA] = stride_in_bytes;\n  img->stride[VPX_PLANE_U] = img->stride[VPX_PLANE_V] = stride_in_bytes >> xcs;\n\n /* Default viewport to entire image */\n if (!vpx_img_set_rect(img, 0, 0, d_w, d_h)) return img;\n\nfail:\n  vpx_img_free(img);\n return NULL;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143932,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static jboolean enableNative(JNIEnv* env, jobject obj) {\n     ALOGV(\"%s:\",__FUNCTION__);\n \n     jboolean result = JNI_FALSE;\n     if (!sBluetoothInterface) return result;\n    int ret = sBluetoothInterface->enable();\n     result = (ret == BT_STATUS_SUCCESS || ret == BT_STATUS_DONE) ? JNI_TRUE : JNI_FALSE;\n     return result;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143953,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static jboolean cancelDiscoveryNative(JNIEnv* env, jobject obj) {\n    ALOGV(\"%s:\",__FUNCTION__);\n\n    jboolean result = JNI_FALSE;\n if (!sBluetoothInterface) return result;\n\n int ret = sBluetoothInterface->cancel_discovery();\n    result = (ret == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;\n return result;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143954,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "long ParseElementHeader(IMkvReader* pReader, long long& pos,\n long long stop, long long& id,\n long long& size) {\n if (stop >= 0 && pos >= stop)\n return E_FILE_FORMAT_INVALID;\n\n long len;\n\n  id = ReadID(pReader, pos, len);\n\n if (id < 0)\n return E_FILE_FORMAT_INVALID;\n\n  pos += len; // consume id\n\n if (stop >= 0 && pos >= stop)\n return E_FILE_FORMAT_INVALID;\n\n  size = ReadUInt(pReader, pos, len);\n\n if (size < 0 || len < 1 || len > 8) {\n return E_FILE_FORMAT_INVALID;\n }\n\n const unsigned long long rollover_check =\n static_cast<unsigned long long>(pos) + len;\n if (rollover_check > LONG_LONG_MAX)\n return E_FILE_FORMAT_INVALID;\n\n  pos += len; // consume length of size\n\n \n \n  if (stop >= 0 && pos >= stop)\n     return E_FILE_FORMAT_INVALID;\n \n   return 0;  // success\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143961,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "long ParseElementHeader(IMkvReader* pReader, long long& pos,\n long long stop, long long& id,\n long long& size) {\n if (stop >= 0 && pos >= stop)\n return E_FILE_FORMAT_INVALID;\n\n long len;\n\n  id = ReadID(pReader, pos, len);\n\n if (id < 0)\n return E_FILE_FORMAT_INVALID;\n\n  pos += len; // consume id\n\n if (stop >= 0 && pos >= stop)\n return E_FILE_FORMAT_INVALID;\n\n  size = ReadUInt(pReader, pos, len);\n\n if (size < 0 || len < 1 || len > 8) {\n return E_FILE_FORMAT_INVALID;\n }\n\n const unsigned long long rollover_check =\n static_cast<unsigned long long>(pos) + len;\n if (rollover_check > LONG_LONG_MAX)\n return E_FILE_FORMAT_INVALID;\n\n  pos += len; // consume length of size\n\n \n \n  if (stop >= 0 && pos > stop)\n     return E_FILE_FORMAT_INVALID;\n \n   return 0;  // success\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143962,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "uint8_t smb2cli_session_security_mode(struct smbXcli_session *session)\n{\n\tstruct smbXcli_conn *conn = session->conn;\n\tuint8_t security_mode = 0;\n\n\tif (conn == NULL) {\n\t\treturn security_mode;\n\t}\n\n\tsecurity_mode = SMB2_NEGOTIATE_SIGNING_ENABLED;\n        if (conn->mandatory_signing) {\n                security_mode |= SMB2_NEGOTIATE_SIGNING_REQUIRED;\n        }\n \n        return security_mode;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143971,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "uint8_t smb2cli_session_security_mode(struct smbXcli_session *session)\n{\n\tstruct smbXcli_conn *conn = session->conn;\n\tuint8_t security_mode = 0;\n\n\tif (conn == NULL) {\n\t\treturn security_mode;\n\t}\n\n\tsecurity_mode = SMB2_NEGOTIATE_SIGNING_ENABLED;\n        if (conn->mandatory_signing) {\n                security_mode |= SMB2_NEGOTIATE_SIGNING_REQUIRED;\n        }\n       if (session->smb2->should_sign) {\n               security_mode |= SMB2_NEGOTIATE_SIGNING_REQUIRED;\n       }\n \n        return security_mode;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143972,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "SMBC_server_internal(TALLOC_CTX *ctx,\n            SMBCCTX *context,\n            bool connect_if_not_found,\n            const char *server,\n            uint16_t port,\n            const char *share,\n            char **pp_workgroup,\n            char **pp_username,\n            char **pp_password,\n\t    bool *in_cache)\n{\n\tSMBCSRV *srv=NULL;\n\tchar *workgroup = NULL;\n\tstruct cli_state *c = NULL;\n\tconst char *server_n = server;\n        int is_ipc = (share != NULL && strcmp(share, \"IPC$\") == 0);\n\tuint32_t fs_attrs = 0;\n        const char *username_used;\n \tNTSTATUS status;\n        char *newserver, *newshare;\n        int flags = 0;\n        struct smbXcli_tcon *tcon = NULL;\n \n        ZERO_STRUCT(c);\n        *in_cache = false;\n\tif (server[0] == 0) {\n\t\terrno = EPERM;\n\t\treturn NULL;\n\t}\n\n        /* Look for a cached connection */\n        srv = SMBC_find_server(ctx, context, server, share,\n                               pp_workgroup, pp_username, pp_password);\n\n        /*\n         * If we found a connection and we're only allowed one share per\n         * server...\n         */\n        if (srv &&\n\t    share != NULL && *share != '\\0' &&\n            smbc_getOptionOneSharePerServer(context)) {\n\n                /*\n                 * ... then if there's no current connection to the share,\n                 * connect to it.  SMBC_find_server(), or rather the function\n                 * pointed to by context->get_cached_srv_fn which\n                 * was called by SMBC_find_server(), will have issued a tree\n                 * disconnect if the requested share is not the same as the\n                 * one that was already connected.\n                 */\n\n\t\t/*\n\t\t * Use srv->cli->desthost and srv->cli->share instead of\n\t\t * server and share below to connect to the actual share,\n\t\t * i.e., a normal share or a referred share from\n\t\t * 'msdfs proxy' share.\n\t\t */\n                if (!cli_state_has_tcon(srv->cli)) {\n                        /* Ensure we have accurate auth info */\n\t\t\tSMBC_call_auth_fn(ctx, context,\n\t\t\t\t\t  smbXcli_conn_remote_name(srv->cli->conn),\n\t\t\t\t\t  srv->cli->share,\n                                          pp_workgroup,\n                                          pp_username,\n                                          pp_password);\n\n\t\t\tif (!*pp_workgroup || !*pp_username || !*pp_password) {\n\t\t\t\terrno = ENOMEM;\n\t\t\t\tcli_shutdown(srv->cli);\n\t\t\t\tsrv->cli = NULL;\n\t\t\t\tsmbc_getFunctionRemoveCachedServer(context)(context,\n                                                                            srv);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We don't need to renegotiate encryption\n\t\t\t * here as the encryption context is not per\n\t\t\t * tid.\n\t\t\t */\n\n\t\t\tstatus = cli_tree_connect(srv->cli,\n\t\t\t\t\t\t  srv->cli->share,\n\t\t\t\t\t\t  \"?????\",\n\t\t\t\t\t\t  *pp_password,\n\t\t\t\t\t\t  strlen(*pp_password)+1);\n\t\t\tif (!NT_STATUS_IS_OK(status)) {\n                                errno = map_errno_from_nt_status(status);\n                                cli_shutdown(srv->cli);\n\t\t\t\tsrv->cli = NULL;\n                                smbc_getFunctionRemoveCachedServer(context)(context,\n                                                                            srv);\n                                srv = NULL;\n                        }\n\n                        /* Determine if this share supports case sensitivity */\n                        if (is_ipc) {\n                                DEBUG(4,\n                                      (\"IPC$ so ignore case sensitivity\\n\"));\n                                status = NT_STATUS_OK;\n                        } else {\n                                status = cli_get_fs_attr_info(c, &fs_attrs);\n                        }\n\n                        if (!NT_STATUS_IS_OK(status)) {\n                                DEBUG(4, (\"Could not retrieve \"\n                                          \"case sensitivity flag: %s.\\n\",\n                                          nt_errstr(status)));\n\n                                /*\n                                 * We can't determine the case sensitivity of\n                                 * the share. We have no choice but to use the\n                                 * user-specified case sensitivity setting.\n                                 */\n                                if (smbc_getOptionCaseSensitive(context)) {\n                                        cli_set_case_sensitive(c, True);\n                                } else {\n                                        cli_set_case_sensitive(c, False);\n                                }\n                        } else if (!is_ipc) {\n                                DEBUG(4,\n                                      (\"Case sensitive: %s\\n\",\n                                       (fs_attrs & FILE_CASE_SENSITIVE_SEARCH\n                                        ? \"True\"\n                                        : \"False\")));\n                                cli_set_case_sensitive(\n                                        c,\n                                        (fs_attrs & FILE_CASE_SENSITIVE_SEARCH\n                                         ? True\n                                         : False));\n                        }\n\n                        /*\n                         * Regenerate the dev value since it's based on both\n                         * server and share\n                         */\n                        if (srv) {\n\t\t\t\tconst char *remote_name =\n\t\t\t\t\tsmbXcli_conn_remote_name(srv->cli->conn);\n\n\t\t\t\tsrv->dev = (dev_t)(str_checksum(remote_name) ^\n                                                   str_checksum(srv->cli->share));\n                        }\n                }\n        }\n\n        /* If we have a connection... */\n        if (srv) {\n\n                /* ... then we're done here.  Give 'em what they came for. */\n\t\t*in_cache = true;\n                goto done;\n        }\n\n        /* If we're not asked to connect when a connection doesn't exist... */\n        if (! connect_if_not_found) {\n                /* ... then we're done here. */\n                return NULL;\n        }\n\n\tif (!*pp_workgroup || !*pp_username || !*pp_password) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tDEBUG(4,(\"SMBC_server: server_n=[%s] server=[%s]\\n\", server_n, server));\n\n\tDEBUG(4,(\" -> server_n=[%s] server=[%s]\\n\", server_n, server));\n\n\tstatus = NT_STATUS_UNSUCCESSFUL;\n\n\tif (smbc_getOptionUseKerberos(context)) {\n\t\tflags |= CLI_FULL_CONNECTION_USE_KERBEROS;\n\t}\n\n\tif (smbc_getOptionFallbackAfterKerberos(context)) {\n\t\tflags |= CLI_FULL_CONNECTION_FALLBACK_AFTER_KERBEROS;\n\t}\n\n\tif (smbc_getOptionUseCCache(context)) {\n\t\tflags |= CLI_FULL_CONNECTION_USE_CCACHE;\n\t}\n\n\tif (smbc_getOptionUseNTHash(context)) {\n\t\tflags |= CLI_FULL_CONNECTION_USE_NT_HASH;\n                flags |= CLI_FULL_CONNECTION_USE_NT_HASH;\n        }\n \n        if (port == 0) {\n                if (share == NULL || *share == '\\0' || is_ipc) {\n                        /*\n\t\t}\n                         */\n                        status = cli_connect_nb(server_n, NULL, NBT_SMB_PORT, 0x20,\n                                        smbc_getNetbiosName(context),\n                                       SMB_SIGNING_DEFAULT, flags, &c);\n                }\n        }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143973,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "SMBC_server_internal(TALLOC_CTX *ctx,\n            SMBCCTX *context,\n            bool connect_if_not_found,\n            const char *server,\n            uint16_t port,\n            const char *share,\n            char **pp_workgroup,\n            char **pp_username,\n            char **pp_password,\n\t    bool *in_cache)\n{\n\tSMBCSRV *srv=NULL;\n\tchar *workgroup = NULL;\n\tstruct cli_state *c = NULL;\n\tconst char *server_n = server;\n        int is_ipc = (share != NULL && strcmp(share, \"IPC$\") == 0);\n\tuint32_t fs_attrs = 0;\n        const char *username_used;\n \tNTSTATUS status;\n        char *newserver, *newshare;\n        int flags = 0;\n        struct smbXcli_tcon *tcon = NULL;\n       int signing_state = SMB_SIGNING_DEFAULT;\n \n        ZERO_STRUCT(c);\n        *in_cache = false;\n\tif (server[0] == 0) {\n\t\terrno = EPERM;\n\t\treturn NULL;\n\t}\n\n        /* Look for a cached connection */\n        srv = SMBC_find_server(ctx, context, server, share,\n                               pp_workgroup, pp_username, pp_password);\n\n        /*\n         * If we found a connection and we're only allowed one share per\n         * server...\n         */\n        if (srv &&\n\t    share != NULL && *share != '\\0' &&\n            smbc_getOptionOneSharePerServer(context)) {\n\n                /*\n                 * ... then if there's no current connection to the share,\n                 * connect to it.  SMBC_find_server(), or rather the function\n                 * pointed to by context->get_cached_srv_fn which\n                 * was called by SMBC_find_server(), will have issued a tree\n                 * disconnect if the requested share is not the same as the\n                 * one that was already connected.\n                 */\n\n\t\t/*\n\t\t * Use srv->cli->desthost and srv->cli->share instead of\n\t\t * server and share below to connect to the actual share,\n\t\t * i.e., a normal share or a referred share from\n\t\t * 'msdfs proxy' share.\n\t\t */\n                if (!cli_state_has_tcon(srv->cli)) {\n                        /* Ensure we have accurate auth info */\n\t\t\tSMBC_call_auth_fn(ctx, context,\n\t\t\t\t\t  smbXcli_conn_remote_name(srv->cli->conn),\n\t\t\t\t\t  srv->cli->share,\n                                          pp_workgroup,\n                                          pp_username,\n                                          pp_password);\n\n\t\t\tif (!*pp_workgroup || !*pp_username || !*pp_password) {\n\t\t\t\terrno = ENOMEM;\n\t\t\t\tcli_shutdown(srv->cli);\n\t\t\t\tsrv->cli = NULL;\n\t\t\t\tsmbc_getFunctionRemoveCachedServer(context)(context,\n                                                                            srv);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We don't need to renegotiate encryption\n\t\t\t * here as the encryption context is not per\n\t\t\t * tid.\n\t\t\t */\n\n\t\t\tstatus = cli_tree_connect(srv->cli,\n\t\t\t\t\t\t  srv->cli->share,\n\t\t\t\t\t\t  \"?????\",\n\t\t\t\t\t\t  *pp_password,\n\t\t\t\t\t\t  strlen(*pp_password)+1);\n\t\t\tif (!NT_STATUS_IS_OK(status)) {\n                                errno = map_errno_from_nt_status(status);\n                                cli_shutdown(srv->cli);\n\t\t\t\tsrv->cli = NULL;\n                                smbc_getFunctionRemoveCachedServer(context)(context,\n                                                                            srv);\n                                srv = NULL;\n                        }\n\n                        /* Determine if this share supports case sensitivity */\n                        if (is_ipc) {\n                                DEBUG(4,\n                                      (\"IPC$ so ignore case sensitivity\\n\"));\n                                status = NT_STATUS_OK;\n                        } else {\n                                status = cli_get_fs_attr_info(c, &fs_attrs);\n                        }\n\n                        if (!NT_STATUS_IS_OK(status)) {\n                                DEBUG(4, (\"Could not retrieve \"\n                                          \"case sensitivity flag: %s.\\n\",\n                                          nt_errstr(status)));\n\n                                /*\n                                 * We can't determine the case sensitivity of\n                                 * the share. We have no choice but to use the\n                                 * user-specified case sensitivity setting.\n                                 */\n                                if (smbc_getOptionCaseSensitive(context)) {\n                                        cli_set_case_sensitive(c, True);\n                                } else {\n                                        cli_set_case_sensitive(c, False);\n                                }\n                        } else if (!is_ipc) {\n                                DEBUG(4,\n                                      (\"Case sensitive: %s\\n\",\n                                       (fs_attrs & FILE_CASE_SENSITIVE_SEARCH\n                                        ? \"True\"\n                                        : \"False\")));\n                                cli_set_case_sensitive(\n                                        c,\n                                        (fs_attrs & FILE_CASE_SENSITIVE_SEARCH\n                                         ? True\n                                         : False));\n                        }\n\n                        /*\n                         * Regenerate the dev value since it's based on both\n                         * server and share\n                         */\n                        if (srv) {\n\t\t\t\tconst char *remote_name =\n\t\t\t\t\tsmbXcli_conn_remote_name(srv->cli->conn);\n\n\t\t\t\tsrv->dev = (dev_t)(str_checksum(remote_name) ^\n                                                   str_checksum(srv->cli->share));\n                        }\n                }\n        }\n\n        /* If we have a connection... */\n        if (srv) {\n\n                /* ... then we're done here.  Give 'em what they came for. */\n\t\t*in_cache = true;\n                goto done;\n        }\n\n        /* If we're not asked to connect when a connection doesn't exist... */\n        if (! connect_if_not_found) {\n                /* ... then we're done here. */\n                return NULL;\n        }\n\n\tif (!*pp_workgroup || !*pp_username || !*pp_password) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tDEBUG(4,(\"SMBC_server: server_n=[%s] server=[%s]\\n\", server_n, server));\n\n\tDEBUG(4,(\" -> server_n=[%s] server=[%s]\\n\", server_n, server));\n\n\tstatus = NT_STATUS_UNSUCCESSFUL;\n\n\tif (smbc_getOptionUseKerberos(context)) {\n\t\tflags |= CLI_FULL_CONNECTION_USE_KERBEROS;\n\t}\n\n\tif (smbc_getOptionFallbackAfterKerberos(context)) {\n\t\tflags |= CLI_FULL_CONNECTION_FALLBACK_AFTER_KERBEROS;\n\t}\n\n\tif (smbc_getOptionUseCCache(context)) {\n\t\tflags |= CLI_FULL_CONNECTION_USE_CCACHE;\n\t}\n\n\tif (smbc_getOptionUseNTHash(context)) {\n\t\tflags |= CLI_FULL_CONNECTION_USE_NT_HASH;\n                flags |= CLI_FULL_CONNECTION_USE_NT_HASH;\n        }\n \n       if (context->internal->smb_encryption_level != SMBC_ENCRYPTLEVEL_NONE) {\n               signing_state = SMB_SIGNING_REQUIRED;\n       }\n\n        if (port == 0) {\n                if (share == NULL || *share == '\\0' || is_ipc) {\n                        /*\n\t\t}\n                         */\n                        status = cli_connect_nb(server_n, NULL, NBT_SMB_PORT, 0x20,\n                                        smbc_getNetbiosName(context),\n                                       signing_state, flags, &c);\n                }\n        }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143974,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int dv_extract_audio(uint8_t* frame, uint8_t* ppcm[4],\n                            const DVprofile *sys)\n{\n    int size, chan, i, j, d, of, smpls, freq, quant, half_ch;\n    uint16_t lc, rc;\n    const uint8_t* as_pack;\n    uint8_t *pcm, ipcm;\n\n    as_pack = dv_extract_pack(frame, dv_audio_source);\n    if (!as_pack)    /* No audio ? */\n        return 0;\n\n    smpls =  as_pack[1] & 0x3f;       /* samples in this frame - min. samples */\n    freq  = (as_pack[4] >> 3) & 0x07; /* 0 - 48kHz, 1 - 44,1kHz, 2 - 32kHz */\n    quant =  as_pack[4] & 0x07;       /* 0 - 16bit linear, 1 - 12bit nonlinear */\n\n    if (quant > 1)\n        return -1; /* unsupported quantization */\n\n    size = (sys->audio_min_samples[freq] + smpls) * 4; /* 2ch, 2bytes */\n    half_ch = sys->difseg_size / 2;\n\n     /* We work with 720p frames split in half, thus even frames have\n      * channels 0,1 and odd 2,3. */\n     ipcm = (sys->height == 720 && !(frame[1] & 0x0C)) ? 2 : 0;\n    pcm  = ppcm[ipcm++];\n \n     /* for each DIF channel */\n     for (chan = 0; chan < sys->n_difchan; chan++) {\n         /* for each DIF segment */\n         for (i = 0; i < sys->difseg_size; i++) {\n             frame += 6 * 80; /* skip DIF segment header */\n                    break;\n            }\n\n            /* for each AV sequence */\n            for (j = 0; j < 9; j++) {\n                for (d = 8; d < 80; d += 2) {\n                    if (quant == 0) {  /* 16bit quantization */\n                        of = sys->audio_shuffle[i][j] + (d - 8) / 2 * sys->audio_stride;\n                        if (of*2 >= size)\n                            continue;\n\n                        pcm[of*2]   = frame[d+1]; // FIXME: maybe we have to admit\n                        pcm[of*2+1] = frame[d];   //        that DV is a big-endian PCM\n                        if (pcm[of*2+1] == 0x80 && pcm[of*2] == 0x00)\n                            pcm[of*2+1] = 0;\n                    } else {           /* 12bit quantization */\n                        lc = ((uint16_t)frame[d]   << 4) |\n                             ((uint16_t)frame[d+2] >> 4);\n                        rc = ((uint16_t)frame[d+1] << 4) |\n                             ((uint16_t)frame[d+2] & 0x0f);\n                        lc = (lc == 0x800 ? 0 : dv_audio_12to16(lc));\n                        rc = (rc == 0x800 ? 0 : dv_audio_12to16(rc));\n\n                        of = sys->audio_shuffle[i%half_ch][j] + (d - 8) / 3 * sys->audio_stride;\n                        if (of*2 >= size)\n                            continue;\n\n                        pcm[of*2]   = lc & 0xff; // FIXME: maybe we have to admit\n                        pcm[of*2+1] = lc >> 8;   //        that DV is a big-endian PCM\n                        of = sys->audio_shuffle[i%half_ch+half_ch][j] +\n                            (d - 8) / 3 * sys->audio_stride;\n                        pcm[of*2]   = rc & 0xff; // FIXME: maybe we have to admit\n                        pcm[of*2+1] = rc >> 8;   //        that DV is a big-endian PCM\n                        ++d;\n                    }\n                }\n\n                frame += 16 * 80; /* 15 Video DIFs + 1 Audio DIF */\n            }\n        }\n\n                 frame += 16 * 80; /* 15 Video DIFs + 1 Audio DIF */\n             }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144003,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int dv_extract_audio(uint8_t* frame, uint8_t* ppcm[4],\n                            const DVprofile *sys)\n{\n    int size, chan, i, j, d, of, smpls, freq, quant, half_ch;\n    uint16_t lc, rc;\n    const uint8_t* as_pack;\n    uint8_t *pcm, ipcm;\n\n    as_pack = dv_extract_pack(frame, dv_audio_source);\n    if (!as_pack)    /* No audio ? */\n        return 0;\n\n    smpls =  as_pack[1] & 0x3f;       /* samples in this frame - min. samples */\n    freq  = (as_pack[4] >> 3) & 0x07; /* 0 - 48kHz, 1 - 44,1kHz, 2 - 32kHz */\n    quant =  as_pack[4] & 0x07;       /* 0 - 16bit linear, 1 - 12bit nonlinear */\n\n    if (quant > 1)\n        return -1; /* unsupported quantization */\n\n    size = (sys->audio_min_samples[freq] + smpls) * 4; /* 2ch, 2bytes */\n    half_ch = sys->difseg_size / 2;\n\n     /* We work with 720p frames split in half, thus even frames have\n      * channels 0,1 and odd 2,3. */\n     ipcm = (sys->height == 720 && !(frame[1] & 0x0C)) ? 2 : 0;\n \n     /* for each DIF channel */\n     for (chan = 0; chan < sys->n_difchan; chan++) {\n        /* next stereo channel (50Mbps and 100Mbps only) */\n        pcm = ppcm[ipcm++];\n        if (!pcm)\n            break;\n\n         /* for each DIF segment */\n         for (i = 0; i < sys->difseg_size; i++) {\n             frame += 6 * 80; /* skip DIF segment header */\n                    break;\n            }\n\n            /* for each AV sequence */\n            for (j = 0; j < 9; j++) {\n                for (d = 8; d < 80; d += 2) {\n                    if (quant == 0) {  /* 16bit quantization */\n                        of = sys->audio_shuffle[i][j] + (d - 8) / 2 * sys->audio_stride;\n                        if (of*2 >= size)\n                            continue;\n\n                        pcm[of*2]   = frame[d+1]; // FIXME: maybe we have to admit\n                        pcm[of*2+1] = frame[d];   //        that DV is a big-endian PCM\n                        if (pcm[of*2+1] == 0x80 && pcm[of*2] == 0x00)\n                            pcm[of*2+1] = 0;\n                    } else {           /* 12bit quantization */\n                        lc = ((uint16_t)frame[d]   << 4) |\n                             ((uint16_t)frame[d+2] >> 4);\n                        rc = ((uint16_t)frame[d+1] << 4) |\n                             ((uint16_t)frame[d+2] & 0x0f);\n                        lc = (lc == 0x800 ? 0 : dv_audio_12to16(lc));\n                        rc = (rc == 0x800 ? 0 : dv_audio_12to16(rc));\n\n                        of = sys->audio_shuffle[i%half_ch][j] + (d - 8) / 3 * sys->audio_stride;\n                        if (of*2 >= size)\n                            continue;\n\n                        pcm[of*2]   = lc & 0xff; // FIXME: maybe we have to admit\n                        pcm[of*2+1] = lc >> 8;   //        that DV is a big-endian PCM\n                        of = sys->audio_shuffle[i%half_ch+half_ch][j] +\n                            (d - 8) / 3 * sys->audio_stride;\n                        pcm[of*2]   = rc & 0xff; // FIXME: maybe we have to admit\n                        pcm[of*2+1] = rc >> 8;   //        that DV is a big-endian PCM\n                        ++d;\n                    }\n                }\n\n                frame += 16 * 80; /* 15 Video DIFs + 1 Audio DIF */\n            }\n        }\n\n                 frame += 16 * 80; /* 15 Video DIFs + 1 Audio DIF */\n             }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144004,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " int __glXDispSwap_CreateContext(__GLXclientState *cl, GLbyte *pc)\n {\n     xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->context);\n     __GLX_SWAP_INT(&req->visual);\n    return __glXDisp_CreateContext(cl, pc);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144005,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " int __glXDispSwap_CreateContext(__GLXclientState *cl, GLbyte *pc)\n {\n    ClientPtr client = cl->client;\n     xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n    REQUEST_SIZE_MATCH(xGLXCreateContextReq);\n\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->context);\n     __GLX_SWAP_INT(&req->visual);\n    return __glXDisp_CreateContext(cl, pc);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144006,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int tomoyo_mount_acl(struct tomoyo_request_info *r, char *dev_name,\n\t\t\t    struct path *dir, char *type, unsigned long flags)\n{\n\tstruct path path;\n\tstruct file_system_type *fstype = NULL;\n\tconst char *requested_type = NULL;\n\tconst char *requested_dir_name = NULL;\n\tconst char *requested_dev_name = NULL;\n\tstruct tomoyo_path_info rtype;\n\tstruct tomoyo_path_info rdev;\n\tstruct tomoyo_path_info rdir;\n\tint need_dev = 0;\n\tint error = -ENOMEM;\n\n\t/* Get fstype. */\n\trequested_type = tomoyo_encode(type);\n\tif (!requested_type)\n\t\tgoto out;\n\trtype.name = requested_type;\n\ttomoyo_fill_path_info(&rtype);\n\n\t/* Get mount point. */\n\trequested_dir_name = tomoyo_realpath_from_path(dir);\n\tif (!requested_dir_name) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\trdir.name = requested_dir_name;\n\ttomoyo_fill_path_info(&rdir);\n\n\t/* Compare fs name. */\n\tif (!strcmp(type, TOMOYO_MOUNT_REMOUNT_KEYWORD)) {\n\t\t/* dev_name is ignored. */\n\t} else if (!strcmp(type, TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MAKE_SHARED_KEYWORD)) {\n\t\t/* dev_name is ignored. */\n\t} else if (!strcmp(type, TOMOYO_MOUNT_BIND_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MOVE_KEYWORD)) {\n\t\tneed_dev = -1; /* dev_name is a directory */\n\t} else {\n\t\tfstype = get_fs_type(type);\n\t\tif (!fstype) {\n\t\t\terror = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fstype->fs_flags & FS_REQUIRES_DEV)\n\t\t\t/* dev_name is a block device file. */\n\t\t\tneed_dev = 1;\n \t}\n \tif (need_dev) {\n \t\t/* Get mount point or device file. */\n\t\tif (kern_path(dev_name, LOOKUP_FOLLOW, &path)) {\n \t\t\terror = -ENOENT;\n \t\t\tgoto out;\n \t\t}\n\t\trequested_dev_name = tomoyo_realpath_from_path(&path);\n\t\tpath_put(&path);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* Map dev_name to \"<NULL>\" if no dev_name given. */\n\t\tif (!dev_name)\n\t\t\tdev_name = \"<NULL>\";\n\t\trequested_dev_name = tomoyo_encode(dev_name);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trdev.name = requested_dev_name;\n\ttomoyo_fill_path_info(&rdev);\n\tr->param_type = TOMOYO_TYPE_MOUNT_ACL;\n\tr->param.mount.need_dev = need_dev;\n\tr->param.mount.dev = &rdev;\n\tr->param.mount.dir = &rdir;\n\tr->param.mount.type = &rtype;\n\tr->param.mount.flags = flags;\n\tdo {\n\t\ttomoyo_check_acl(r, tomoyo_check_mount_acl);\n\t\terror = tomoyo_audit_mount_log(r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n out:\n\tkfree(requested_dev_name);\n\tkfree(requested_dir_name);\n\tif (fstype)\n\t\tput_filesystem(fstype);\n\tkfree(requested_type);\n\treturn error;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144011,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int tomoyo_mount_acl(struct tomoyo_request_info *r, char *dev_name,\n\t\t\t    struct path *dir, char *type, unsigned long flags)\n{\n\tstruct path path;\n\tstruct file_system_type *fstype = NULL;\n\tconst char *requested_type = NULL;\n\tconst char *requested_dir_name = NULL;\n\tconst char *requested_dev_name = NULL;\n\tstruct tomoyo_path_info rtype;\n\tstruct tomoyo_path_info rdev;\n\tstruct tomoyo_path_info rdir;\n\tint need_dev = 0;\n\tint error = -ENOMEM;\n\n\t/* Get fstype. */\n\trequested_type = tomoyo_encode(type);\n\tif (!requested_type)\n\t\tgoto out;\n\trtype.name = requested_type;\n\ttomoyo_fill_path_info(&rtype);\n\n\t/* Get mount point. */\n\trequested_dir_name = tomoyo_realpath_from_path(dir);\n\tif (!requested_dir_name) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\trdir.name = requested_dir_name;\n\ttomoyo_fill_path_info(&rdir);\n\n\t/* Compare fs name. */\n\tif (!strcmp(type, TOMOYO_MOUNT_REMOUNT_KEYWORD)) {\n\t\t/* dev_name is ignored. */\n\t} else if (!strcmp(type, TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MAKE_SHARED_KEYWORD)) {\n\t\t/* dev_name is ignored. */\n\t} else if (!strcmp(type, TOMOYO_MOUNT_BIND_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MOVE_KEYWORD)) {\n\t\tneed_dev = -1; /* dev_name is a directory */\n\t} else {\n\t\tfstype = get_fs_type(type);\n\t\tif (!fstype) {\n\t\t\terror = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fstype->fs_flags & FS_REQUIRES_DEV)\n\t\t\t/* dev_name is a block device file. */\n\t\t\tneed_dev = 1;\n \t}\n \tif (need_dev) {\n \t\t/* Get mount point or device file. */\n\t\tif (!dev_name || kern_path(dev_name, LOOKUP_FOLLOW, &path)) {\n \t\t\terror = -ENOENT;\n \t\t\tgoto out;\n \t\t}\n\t\trequested_dev_name = tomoyo_realpath_from_path(&path);\n\t\tpath_put(&path);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* Map dev_name to \"<NULL>\" if no dev_name given. */\n\t\tif (!dev_name)\n\t\t\tdev_name = \"<NULL>\";\n\t\trequested_dev_name = tomoyo_encode(dev_name);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trdev.name = requested_dev_name;\n\ttomoyo_fill_path_info(&rdev);\n\tr->param_type = TOMOYO_TYPE_MOUNT_ACL;\n\tr->param.mount.need_dev = need_dev;\n\tr->param.mount.dev = &rdev;\n\tr->param.mount.dir = &rdir;\n\tr->param.mount.type = &rtype;\n\tr->param.mount.flags = flags;\n\tdo {\n\t\ttomoyo_check_acl(r, tomoyo_check_mount_acl);\n\t\terror = tomoyo_audit_mount_log(r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n out:\n\tkfree(requested_dev_name);\n\tkfree(requested_dir_name);\n\tif (fstype)\n\t\tput_filesystem(fstype);\n\tkfree(requested_type);\n\treturn error;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144012,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "__init int intel_pmu_init(void)\n{\n\tunion cpuid10_edx edx;\n\tunion cpuid10_eax eax;\n\tunion cpuid10_ebx ebx;\n\tstruct event_constraint *c;\n\tunsigned int unused;\n\tint version;\n\n\tif (!cpu_has(&boot_cpu_data, X86_FEATURE_ARCH_PERFMON)) {\n\t\tswitch (boot_cpu_data.x86) {\n\t\tcase 0x6:\n\t\t\treturn p6_pmu_init();\n\t\tcase 0xb:\n\t\t\treturn knc_pmu_init();\n\t\tcase 0xf:\n\t\t\treturn p4_pmu_init();\n\t\t}\n\t\treturn -ENODEV;\n\t}\n\n\t/*\n\t * Check whether the Architectural PerfMon supports\n\t * Branch Misses Retired hw_event or not.\n\t */\n\tcpuid(10, &eax.full, &ebx.full, &unused, &edx.full);\n\tif (eax.split.mask_length < ARCH_PERFMON_EVENTS_COUNT)\n\t\treturn -ENODEV;\n\n\tversion = eax.split.version_id;\n\tif (version < 2)\n\t\tx86_pmu = core_pmu;\n\telse\n\t\tx86_pmu = intel_pmu;\n\n\tx86_pmu.version\t\t\t= version;\n\tx86_pmu.num_counters\t\t= eax.split.num_counters;\n\tx86_pmu.cntval_bits\t\t= eax.split.bit_width;\n\tx86_pmu.cntval_mask\t\t= (1ULL << eax.split.bit_width) - 1;\n\n\tx86_pmu.events_maskl\t\t= ebx.full;\n\tx86_pmu.events_mask_len\t\t= eax.split.mask_length;\n\n\tx86_pmu.max_pebs_events\t\t= min_t(unsigned, MAX_PEBS_EVENTS, x86_pmu.num_counters);\n\n\t/*\n\t * Quirk: v2 perfmon does not report fixed-purpose events, so\n\t * assume at least 3 events:\n\t */\n\tif (version > 1)\n\t\tx86_pmu.num_counters_fixed = max((int)edx.split.num_counters_fixed, 3);\n\n\t/*\n\t * v2 and above have a perf capabilities MSR\n\t */\n\tif (version > 1) {\n\t\tu64 capabilities;\n\n\t\trdmsrl(MSR_IA32_PERF_CAPABILITIES, capabilities);\n\t\tx86_pmu.intel_cap.capabilities = capabilities;\n\t}\n\n\tintel_ds_init();\n\n\tx86_add_quirk(intel_arch_events_quirk); /* Install first, so it runs last */\n\n\t/*\n\t * Install the hw-cache-events table:\n\t */\n\tswitch (boot_cpu_data.x86_model) {\n\tcase 14: /* 65 nm core solo/duo, \"Yonah\" */\n\t\tpr_cont(\"Core events, \");\n\t\tbreak;\n\n\tcase 15: /* original 65 nm celeron/pentium/core2/xeon, \"Merom\"/\"Conroe\" */\n\t\tx86_add_quirk(intel_clovertown_quirk);\n\tcase 22: /* single-core 65 nm celeron/core2solo \"Merom-L\"/\"Conroe-L\" */\n\tcase 23: /* current 45 nm celeron/core2/xeon \"Penryn\"/\"Wolfdale\" */\n\tcase 29: /* six-core 45 nm xeon \"Dunnington\" */\n\t\tmemcpy(hw_cache_event_ids, core2_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\n\t\tintel_pmu_lbr_init_core();\n\n\t\tx86_pmu.event_constraints = intel_core2_event_constraints;\n\t\tx86_pmu.pebs_constraints = intel_core2_pebs_event_constraints;\n\t\tpr_cont(\"Core2 events, \");\n\t\tbreak;\n\n\tcase 26: /* 45 nm nehalem, \"Bloomfield\" */\n\tcase 30: /* 45 nm nehalem, \"Lynnfield\" */\n\tcase 46: /* 45 nm nehalem-ex, \"Beckton\" */\n\t\tmemcpy(hw_cache_event_ids, nehalem_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\t\tmemcpy(hw_cache_extra_regs, nehalem_hw_cache_extra_regs,\n\t\t       sizeof(hw_cache_extra_regs));\n\n\t\tintel_pmu_lbr_init_nhm();\n\n\t\tx86_pmu.event_constraints = intel_nehalem_event_constraints;\n\t\tx86_pmu.pebs_constraints = intel_nehalem_pebs_event_constraints;\n\t\tx86_pmu.enable_all = intel_pmu_nhm_enable_all;\n\t\tx86_pmu.extra_regs = intel_nehalem_extra_regs;\n\n\t\t/* UOPS_ISSUED.STALLED_CYCLES */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND] =\n\t\t\tX86_CONFIG(.event=0x0e, .umask=0x01, .inv=1, .cmask=1);\n\t\t/* UOPS_EXECUTED.CORE_ACTIVE_CYCLES,c=1,i=1 */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_BACKEND] =\n\t\t\tX86_CONFIG(.event=0xb1, .umask=0x3f, .inv=1, .cmask=1);\n\n\t\tx86_add_quirk(intel_nehalem_quirk);\n\n\t\tpr_cont(\"Nehalem events, \");\n\t\tbreak;\n\n\tcase 28: /* Atom */\n\tcase 38: /* Lincroft */\n\tcase 39: /* Penwell */\n\tcase 53: /* Cloverview */\n\tcase 54: /* Cedarview */\n\t\tmemcpy(hw_cache_event_ids, atom_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\n\t\tintel_pmu_lbr_init_atom();\n\n\t\tx86_pmu.event_constraints = intel_gen_event_constraints;\n\t\tx86_pmu.pebs_constraints = intel_atom_pebs_event_constraints;\n\t\tpr_cont(\"Atom events, \");\n\t\tbreak;\n\n\tcase 37: /* 32 nm nehalem, \"Clarkdale\" */\n\tcase 44: /* 32 nm nehalem, \"Gulftown\" */\n\tcase 47: /* 32 nm Xeon E7 */\n\t\tmemcpy(hw_cache_event_ids, westmere_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\t\tmemcpy(hw_cache_extra_regs, nehalem_hw_cache_extra_regs,\n\t\t       sizeof(hw_cache_extra_regs));\n\n\t\tintel_pmu_lbr_init_nhm();\n\n\t\tx86_pmu.event_constraints = intel_westmere_event_constraints;\n\t\tx86_pmu.enable_all = intel_pmu_nhm_enable_all;\n\t\tx86_pmu.pebs_constraints = intel_westmere_pebs_event_constraints;\n\t\tx86_pmu.extra_regs = intel_westmere_extra_regs;\n\t\tx86_pmu.er_flags |= ERF_HAS_RSP_1;\n\n\t\t/* UOPS_ISSUED.STALLED_CYCLES */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND] =\n\t\t\tX86_CONFIG(.event=0x0e, .umask=0x01, .inv=1, .cmask=1);\n\t\t/* UOPS_EXECUTED.CORE_ACTIVE_CYCLES,c=1,i=1 */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_BACKEND] =\n\t\t\tX86_CONFIG(.event=0xb1, .umask=0x3f, .inv=1, .cmask=1);\n\n\t\tpr_cont(\"Westmere events, \");\n\t\tbreak;\n\n\tcase 42: /* SandyBridge */\n\tcase 45: /* SandyBridge, \"Romely-EP\" */\n\t\tx86_add_quirk(intel_sandybridge_quirk);\n\t\tmemcpy(hw_cache_event_ids, snb_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\t\tmemcpy(hw_cache_extra_regs, snb_hw_cache_extra_regs,\n\t\t       sizeof(hw_cache_extra_regs));\n\n\t\tintel_pmu_lbr_init_snb();\n\n \t\tx86_pmu.event_constraints = intel_snb_event_constraints;\n \t\tx86_pmu.pebs_constraints = intel_snb_pebs_event_constraints;\n \t\tx86_pmu.pebs_aliases = intel_pebs_aliases_snb;\n\t\tx86_pmu.extra_regs = intel_snb_extra_regs;\n \t\t/* all extra regs are per-cpu when HT is on */\n \t\tx86_pmu.er_flags |= ERF_HAS_RSP_1;\n \t\tx86_pmu.er_flags |= ERF_NO_HT_SHARING;\n\n\t\t/* UOPS_ISSUED.ANY,c=1,i=1 to count stall cycles */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND] =\n\t\t\tX86_CONFIG(.event=0x0e, .umask=0x01, .inv=1, .cmask=1);\n\t\t/* UOPS_DISPATCHED.THREAD,c=1,i=1 to count stall cycles*/\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_BACKEND] =\n\t\t\tX86_CONFIG(.event=0xb1, .umask=0x01, .inv=1, .cmask=1);\n\n\t\tpr_cont(\"SandyBridge events, \");\n\t\tbreak;\n\tcase 58: /* IvyBridge */\n\tcase 62: /* IvyBridge EP */\n\t\tmemcpy(hw_cache_event_ids, snb_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\t\tmemcpy(hw_cache_extra_regs, snb_hw_cache_extra_regs,\n\t\t       sizeof(hw_cache_extra_regs));\n\n\t\tintel_pmu_lbr_init_snb();\n\n \t\tx86_pmu.event_constraints = intel_ivb_event_constraints;\n \t\tx86_pmu.pebs_constraints = intel_ivb_pebs_event_constraints;\n \t\tx86_pmu.pebs_aliases = intel_pebs_aliases_snb;\n\t\tx86_pmu.extra_regs = intel_snb_extra_regs;\n \t\t/* all extra regs are per-cpu when HT is on */\n \t\tx86_pmu.er_flags |= ERF_HAS_RSP_1;\n \t\tx86_pmu.er_flags |= ERF_NO_HT_SHARING;\n\n\t\t/* UOPS_ISSUED.ANY,c=1,i=1 to count stall cycles */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND] =\n\t\t\tX86_CONFIG(.event=0x0e, .umask=0x01, .inv=1, .cmask=1);\n\n\t\tpr_cont(\"IvyBridge events, \");\n\t\tbreak;\n\n\n\tdefault:\n\t\tswitch (x86_pmu.version) {\n\t\tcase 1:\n\t\t\tx86_pmu.event_constraints = intel_v1_event_constraints;\n\t\t\tpr_cont(\"generic architected perfmon v1, \");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * default constraints for v2 and up\n\t\t\t */\n\t\t\tx86_pmu.event_constraints = intel_gen_event_constraints;\n\t\t\tpr_cont(\"generic architected perfmon, \");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (x86_pmu.num_counters > INTEL_PMC_MAX_GENERIC) {\n\t\tWARN(1, KERN_ERR \"hw perf events %d > max(%d), clipping!\",\n\t\t     x86_pmu.num_counters, INTEL_PMC_MAX_GENERIC);\n\t\tx86_pmu.num_counters = INTEL_PMC_MAX_GENERIC;\n\t}\n\tx86_pmu.intel_ctrl = (1 << x86_pmu.num_counters) - 1;\n\n\tif (x86_pmu.num_counters_fixed > INTEL_PMC_MAX_FIXED) {\n\t\tWARN(1, KERN_ERR \"hw perf events fixed %d > max(%d), clipping!\",\n\t\t     x86_pmu.num_counters_fixed, INTEL_PMC_MAX_FIXED);\n\t\tx86_pmu.num_counters_fixed = INTEL_PMC_MAX_FIXED;\n\t}\n\n\tx86_pmu.intel_ctrl |=\n\t\t((1LL << x86_pmu.num_counters_fixed)-1) << INTEL_PMC_IDX_FIXED;\n\n\tif (x86_pmu.event_constraints) {\n\t\t/*\n\t\t * event on fixed counter2 (REF_CYCLES) only works on this\n\t\t * counter, so do not extend mask to generic counters\n\t\t */\n\t\tfor_each_event_constraint(c, x86_pmu.event_constraints) {\n\t\t\tif (c->cmask != X86_RAW_EVENT_MASK\n\t\t\t    || c->idxmsk64 == INTEL_PMC_MSK_FIXED_REF_CYCLES) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tc->idxmsk64 |= (1ULL << x86_pmu.num_counters) - 1;\n\t\t\tc->weight += x86_pmu.num_counters;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144019,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "__init int intel_pmu_init(void)\n{\n\tunion cpuid10_edx edx;\n\tunion cpuid10_eax eax;\n\tunion cpuid10_ebx ebx;\n\tstruct event_constraint *c;\n\tunsigned int unused;\n\tint version;\n\n\tif (!cpu_has(&boot_cpu_data, X86_FEATURE_ARCH_PERFMON)) {\n\t\tswitch (boot_cpu_data.x86) {\n\t\tcase 0x6:\n\t\t\treturn p6_pmu_init();\n\t\tcase 0xb:\n\t\t\treturn knc_pmu_init();\n\t\tcase 0xf:\n\t\t\treturn p4_pmu_init();\n\t\t}\n\t\treturn -ENODEV;\n\t}\n\n\t/*\n\t * Check whether the Architectural PerfMon supports\n\t * Branch Misses Retired hw_event or not.\n\t */\n\tcpuid(10, &eax.full, &ebx.full, &unused, &edx.full);\n\tif (eax.split.mask_length < ARCH_PERFMON_EVENTS_COUNT)\n\t\treturn -ENODEV;\n\n\tversion = eax.split.version_id;\n\tif (version < 2)\n\t\tx86_pmu = core_pmu;\n\telse\n\t\tx86_pmu = intel_pmu;\n\n\tx86_pmu.version\t\t\t= version;\n\tx86_pmu.num_counters\t\t= eax.split.num_counters;\n\tx86_pmu.cntval_bits\t\t= eax.split.bit_width;\n\tx86_pmu.cntval_mask\t\t= (1ULL << eax.split.bit_width) - 1;\n\n\tx86_pmu.events_maskl\t\t= ebx.full;\n\tx86_pmu.events_mask_len\t\t= eax.split.mask_length;\n\n\tx86_pmu.max_pebs_events\t\t= min_t(unsigned, MAX_PEBS_EVENTS, x86_pmu.num_counters);\n\n\t/*\n\t * Quirk: v2 perfmon does not report fixed-purpose events, so\n\t * assume at least 3 events:\n\t */\n\tif (version > 1)\n\t\tx86_pmu.num_counters_fixed = max((int)edx.split.num_counters_fixed, 3);\n\n\t/*\n\t * v2 and above have a perf capabilities MSR\n\t */\n\tif (version > 1) {\n\t\tu64 capabilities;\n\n\t\trdmsrl(MSR_IA32_PERF_CAPABILITIES, capabilities);\n\t\tx86_pmu.intel_cap.capabilities = capabilities;\n\t}\n\n\tintel_ds_init();\n\n\tx86_add_quirk(intel_arch_events_quirk); /* Install first, so it runs last */\n\n\t/*\n\t * Install the hw-cache-events table:\n\t */\n\tswitch (boot_cpu_data.x86_model) {\n\tcase 14: /* 65 nm core solo/duo, \"Yonah\" */\n\t\tpr_cont(\"Core events, \");\n\t\tbreak;\n\n\tcase 15: /* original 65 nm celeron/pentium/core2/xeon, \"Merom\"/\"Conroe\" */\n\t\tx86_add_quirk(intel_clovertown_quirk);\n\tcase 22: /* single-core 65 nm celeron/core2solo \"Merom-L\"/\"Conroe-L\" */\n\tcase 23: /* current 45 nm celeron/core2/xeon \"Penryn\"/\"Wolfdale\" */\n\tcase 29: /* six-core 45 nm xeon \"Dunnington\" */\n\t\tmemcpy(hw_cache_event_ids, core2_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\n\t\tintel_pmu_lbr_init_core();\n\n\t\tx86_pmu.event_constraints = intel_core2_event_constraints;\n\t\tx86_pmu.pebs_constraints = intel_core2_pebs_event_constraints;\n\t\tpr_cont(\"Core2 events, \");\n\t\tbreak;\n\n\tcase 26: /* 45 nm nehalem, \"Bloomfield\" */\n\tcase 30: /* 45 nm nehalem, \"Lynnfield\" */\n\tcase 46: /* 45 nm nehalem-ex, \"Beckton\" */\n\t\tmemcpy(hw_cache_event_ids, nehalem_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\t\tmemcpy(hw_cache_extra_regs, nehalem_hw_cache_extra_regs,\n\t\t       sizeof(hw_cache_extra_regs));\n\n\t\tintel_pmu_lbr_init_nhm();\n\n\t\tx86_pmu.event_constraints = intel_nehalem_event_constraints;\n\t\tx86_pmu.pebs_constraints = intel_nehalem_pebs_event_constraints;\n\t\tx86_pmu.enable_all = intel_pmu_nhm_enable_all;\n\t\tx86_pmu.extra_regs = intel_nehalem_extra_regs;\n\n\t\t/* UOPS_ISSUED.STALLED_CYCLES */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND] =\n\t\t\tX86_CONFIG(.event=0x0e, .umask=0x01, .inv=1, .cmask=1);\n\t\t/* UOPS_EXECUTED.CORE_ACTIVE_CYCLES,c=1,i=1 */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_BACKEND] =\n\t\t\tX86_CONFIG(.event=0xb1, .umask=0x3f, .inv=1, .cmask=1);\n\n\t\tx86_add_quirk(intel_nehalem_quirk);\n\n\t\tpr_cont(\"Nehalem events, \");\n\t\tbreak;\n\n\tcase 28: /* Atom */\n\tcase 38: /* Lincroft */\n\tcase 39: /* Penwell */\n\tcase 53: /* Cloverview */\n\tcase 54: /* Cedarview */\n\t\tmemcpy(hw_cache_event_ids, atom_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\n\t\tintel_pmu_lbr_init_atom();\n\n\t\tx86_pmu.event_constraints = intel_gen_event_constraints;\n\t\tx86_pmu.pebs_constraints = intel_atom_pebs_event_constraints;\n\t\tpr_cont(\"Atom events, \");\n\t\tbreak;\n\n\tcase 37: /* 32 nm nehalem, \"Clarkdale\" */\n\tcase 44: /* 32 nm nehalem, \"Gulftown\" */\n\tcase 47: /* 32 nm Xeon E7 */\n\t\tmemcpy(hw_cache_event_ids, westmere_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\t\tmemcpy(hw_cache_extra_regs, nehalem_hw_cache_extra_regs,\n\t\t       sizeof(hw_cache_extra_regs));\n\n\t\tintel_pmu_lbr_init_nhm();\n\n\t\tx86_pmu.event_constraints = intel_westmere_event_constraints;\n\t\tx86_pmu.enable_all = intel_pmu_nhm_enable_all;\n\t\tx86_pmu.pebs_constraints = intel_westmere_pebs_event_constraints;\n\t\tx86_pmu.extra_regs = intel_westmere_extra_regs;\n\t\tx86_pmu.er_flags |= ERF_HAS_RSP_1;\n\n\t\t/* UOPS_ISSUED.STALLED_CYCLES */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND] =\n\t\t\tX86_CONFIG(.event=0x0e, .umask=0x01, .inv=1, .cmask=1);\n\t\t/* UOPS_EXECUTED.CORE_ACTIVE_CYCLES,c=1,i=1 */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_BACKEND] =\n\t\t\tX86_CONFIG(.event=0xb1, .umask=0x3f, .inv=1, .cmask=1);\n\n\t\tpr_cont(\"Westmere events, \");\n\t\tbreak;\n\n\tcase 42: /* SandyBridge */\n\tcase 45: /* SandyBridge, \"Romely-EP\" */\n\t\tx86_add_quirk(intel_sandybridge_quirk);\n\t\tmemcpy(hw_cache_event_ids, snb_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\t\tmemcpy(hw_cache_extra_regs, snb_hw_cache_extra_regs,\n\t\t       sizeof(hw_cache_extra_regs));\n\n\t\tintel_pmu_lbr_init_snb();\n\n \t\tx86_pmu.event_constraints = intel_snb_event_constraints;\n \t\tx86_pmu.pebs_constraints = intel_snb_pebs_event_constraints;\n \t\tx86_pmu.pebs_aliases = intel_pebs_aliases_snb;\n\t\tif (boot_cpu_data.x86_model == 45)\n\t\t\tx86_pmu.extra_regs = intel_snbep_extra_regs;\n\t\telse\n\t\t\tx86_pmu.extra_regs = intel_snb_extra_regs;\n \t\t/* all extra regs are per-cpu when HT is on */\n \t\tx86_pmu.er_flags |= ERF_HAS_RSP_1;\n \t\tx86_pmu.er_flags |= ERF_NO_HT_SHARING;\n\n\t\t/* UOPS_ISSUED.ANY,c=1,i=1 to count stall cycles */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND] =\n\t\t\tX86_CONFIG(.event=0x0e, .umask=0x01, .inv=1, .cmask=1);\n\t\t/* UOPS_DISPATCHED.THREAD,c=1,i=1 to count stall cycles*/\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_BACKEND] =\n\t\t\tX86_CONFIG(.event=0xb1, .umask=0x01, .inv=1, .cmask=1);\n\n\t\tpr_cont(\"SandyBridge events, \");\n\t\tbreak;\n\tcase 58: /* IvyBridge */\n\tcase 62: /* IvyBridge EP */\n\t\tmemcpy(hw_cache_event_ids, snb_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\t\tmemcpy(hw_cache_extra_regs, snb_hw_cache_extra_regs,\n\t\t       sizeof(hw_cache_extra_regs));\n\n\t\tintel_pmu_lbr_init_snb();\n\n \t\tx86_pmu.event_constraints = intel_ivb_event_constraints;\n \t\tx86_pmu.pebs_constraints = intel_ivb_pebs_event_constraints;\n \t\tx86_pmu.pebs_aliases = intel_pebs_aliases_snb;\n\t\tif (boot_cpu_data.x86_model == 62)\n\t\t\tx86_pmu.extra_regs = intel_snbep_extra_regs;\n\t\telse\n\t\t\tx86_pmu.extra_regs = intel_snb_extra_regs;\n \t\t/* all extra regs are per-cpu when HT is on */\n \t\tx86_pmu.er_flags |= ERF_HAS_RSP_1;\n \t\tx86_pmu.er_flags |= ERF_NO_HT_SHARING;\n\n\t\t/* UOPS_ISSUED.ANY,c=1,i=1 to count stall cycles */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND] =\n\t\t\tX86_CONFIG(.event=0x0e, .umask=0x01, .inv=1, .cmask=1);\n\n\t\tpr_cont(\"IvyBridge events, \");\n\t\tbreak;\n\n\n\tdefault:\n\t\tswitch (x86_pmu.version) {\n\t\tcase 1:\n\t\t\tx86_pmu.event_constraints = intel_v1_event_constraints;\n\t\t\tpr_cont(\"generic architected perfmon v1, \");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * default constraints for v2 and up\n\t\t\t */\n\t\t\tx86_pmu.event_constraints = intel_gen_event_constraints;\n\t\t\tpr_cont(\"generic architected perfmon, \");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (x86_pmu.num_counters > INTEL_PMC_MAX_GENERIC) {\n\t\tWARN(1, KERN_ERR \"hw perf events %d > max(%d), clipping!\",\n\t\t     x86_pmu.num_counters, INTEL_PMC_MAX_GENERIC);\n\t\tx86_pmu.num_counters = INTEL_PMC_MAX_GENERIC;\n\t}\n\tx86_pmu.intel_ctrl = (1 << x86_pmu.num_counters) - 1;\n\n\tif (x86_pmu.num_counters_fixed > INTEL_PMC_MAX_FIXED) {\n\t\tWARN(1, KERN_ERR \"hw perf events fixed %d > max(%d), clipping!\",\n\t\t     x86_pmu.num_counters_fixed, INTEL_PMC_MAX_FIXED);\n\t\tx86_pmu.num_counters_fixed = INTEL_PMC_MAX_FIXED;\n\t}\n\n\tx86_pmu.intel_ctrl |=\n\t\t((1LL << x86_pmu.num_counters_fixed)-1) << INTEL_PMC_IDX_FIXED;\n\n\tif (x86_pmu.event_constraints) {\n\t\t/*\n\t\t * event on fixed counter2 (REF_CYCLES) only works on this\n\t\t * counter, so do not extend mask to generic counters\n\t\t */\n\t\tfor_each_event_constraint(c, x86_pmu.event_constraints) {\n\t\t\tif (c->cmask != X86_RAW_EVENT_MASK\n\t\t\t    || c->idxmsk64 == INTEL_PMC_MSK_FIXED_REF_CYCLES) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tc->idxmsk64 |= (1ULL << x86_pmu.num_counters) - 1;\n\t\t\tc->weight += x86_pmu.num_counters;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144020,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tint err;\n\tstruct sock_diag_req *req = nlmsg_data(nlh);\n\tconst struct sock_diag_handler *hndl;\n\n \tif (nlmsg_len(nlh) < sizeof(*req))\n \t\treturn -EINVAL;\n \n \thndl = sock_diag_lock_handler(req->sdiag_family);\n \tif (hndl == NULL)\n \t\terr = -ENOENT;\n\telse\n\t\terr = hndl->dump(skb, nlh);\n\tsock_diag_unlock_handler(hndl);\n\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144021,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tint err;\n\tstruct sock_diag_req *req = nlmsg_data(nlh);\n\tconst struct sock_diag_handler *hndl;\n\n \tif (nlmsg_len(nlh) < sizeof(*req))\n \t\treturn -EINVAL;\n \n\tif (req->sdiag_family >= AF_MAX)\n\t\treturn -EINVAL;\n\n \thndl = sock_diag_lock_handler(req->sdiag_family);\n \tif (hndl == NULL)\n \t\terr = -ENOENT;\n\telse\n\t\terr = hndl->dump(skb, nlh);\n\tsock_diag_unlock_handler(hndl);\n\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144022,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tchar *scontext2, *str = NULL;\n \tstruct context context;\n \tint rc = 0;\n \n \tif (!ss_initialized) {\n \t\tint i;\n \n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tif (!strcmp(initial_sid_to_string[i], scontext)) {\n\t\t\t\t*sid = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\treturn 0;\n\t}\n\t*sid = SECSID_NULL;\n\n\t/* Copy the string so that we can modify the copy as we parse it. */\n\tscontext2 = kmalloc(scontext_len + 1, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\tmemcpy(scontext2, scontext, scontext_len);\n\tscontext2[scontext_len] = 0;\n\n\tif (force) {\n\t\t/* Save another copy for storing in uninterpreted form */\n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\n\tread_lock(&policy_rwlock);\n\trc = string_to_context_struct(&policydb, &sidtab, scontext2,\n\t\t\t\t      scontext_len, &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = scontext_len;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(&sidtab, &context, sid);\n\tcontext_destroy(&context);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144025,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tchar *scontext2, *str = NULL;\n \tstruct context context;\n \tint rc = 0;\n \n\t/* An empty security context is never valid. */\n\tif (!scontext_len)\n\t\treturn -EINVAL;\n\n \tif (!ss_initialized) {\n \t\tint i;\n \n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tif (!strcmp(initial_sid_to_string[i], scontext)) {\n\t\t\t\t*sid = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\treturn 0;\n\t}\n\t*sid = SECSID_NULL;\n\n\t/* Copy the string so that we can modify the copy as we parse it. */\n\tscontext2 = kmalloc(scontext_len + 1, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\tmemcpy(scontext2, scontext, scontext_len);\n\tscontext2[scontext_len] = 0;\n\n\tif (force) {\n\t\t/* Save another copy for storing in uninterpreted form */\n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\n\tread_lock(&policy_rwlock);\n\trc = string_to_context_struct(&policydb, &sidtab, scontext2,\n\t\t\t\t      scontext_len, &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = scontext_len;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(&sidtab, &context, sid);\n\tcontext_destroy(&context);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144026,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "sctp_disposition_t sctp_sf_do_5_1D_ce(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const sctp_subtype_t type, void *arg,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_association *new_asoc;\n\tsctp_init_chunk_t *peer_init;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_ulpevent *ev, *ai_ev = NULL;\n\tint error = 0;\n\tstruct sctp_chunk *err_chk_p;\n\tstruct sock *sk;\n\n\t/* If the packet is an OOTB packet which is temporarily on the\n\t * control endpoint, respond with an ABORT.\n\t */\n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the COOKIE_ECHO chunk has a valid length.\n\t * In this case, we check that we have enough for at least a\n\t * chunk header.  More detailed verification is done\n\t * in sctp_unpack_cookie().\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* If the endpoint is not listening or if the number of associations\n\t * on the TCP-style socket exceed the max backlog, respond with an\n\t * ABORT.\n\t */\n\tsk = ep->base.sk;\n\tif (!sctp_sstate(sk, LISTENING) ||\n\t    (sctp_style(sk, TCP) && sk_acceptq_is_full(sk)))\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* \"Decode\" the chunk.  We have no optional parameters so we\n\t * are in good shape.\n\t */\n\tchunk->subh.cookie_hdr =\n\t\t(struct sctp_signed_cookie *)chunk->skb->data;\n\tif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\n\t\t\t\t\t sizeof(sctp_chunkhdr_t)))\n\t\tgoto nomem;\n\n\t/* 5.1 D) Upon reception of the COOKIE ECHO chunk, Endpoint\n\t * \"Z\" will reply with a COOKIE ACK chunk after building a TCB\n\t * and moving to the ESTABLISHED state.\n\t */\n\tnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\n\t\t\t\t      &err_chk_p);\n\n\t/* FIXME:\n\t * If the re-build failed, what is the proper error path\n\t * from here?\n\t *\n\t * [We should abort the association. --piggy]\n\t */\n\tif (!new_asoc) {\n\t\t/* FIXME: Several errors are possible.  A bad cookie should\n\t\t * be silently discarded, but think about logging it too.\n\t\t */\n\t\tswitch (error) {\n\t\tcase -SCTP_IERROR_NOMEM:\n\t\t\tgoto nomem;\n\n\t\tcase -SCTP_IERROR_STALE_COOKIE:\n\t\t\tsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\n\t\t\t\t\t\t   err_chk_p);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\tcase -SCTP_IERROR_BAD_SIG:\n\t\tdefault:\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\n\t/* Delay state machine commands until later.\n\t *\n\t * Re-build the bind address for the association is done in\n\t * the sctp_unpack_cookie() already.\n\t */\n\t/* This is a brand-new association, so these are not yet side\n\t * effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\n\tif (!sctp_process_init(new_asoc, chunk,\n\t\t\t       &chunk->subh.cookie_hdr->c.peer_addr,\n\t\t\t       peer_init, GFP_ATOMIC))\n\t\tgoto nomem_init;\n\n\t/* SCTP-AUTH:  Now that we've populate required fields in\n\t * sctp_process_init, set up the assocaition shared keys as\n\t * necessary so that we can potentially authenticate the ACK\n\t */\n\terror = sctp_auth_asoc_init_active_key(new_asoc, GFP_ATOMIC);\n\tif (error)\n\t\tgoto nomem_init;\n\n\t/* SCTP-AUTH:  auth_chunk pointer is only set when the cookie-echo\n\t * is supposed to be authenticated and we have to do delayed\n\t * authentication.  We've just recreated the association using\n\t * the information in the cookie and now it's much easier to\n\t * do the authentication.\n\t */\n\tif (chunk->auth_chunk) {\n \t\tstruct sctp_chunk auth;\n \t\tsctp_ierror_t ret;\n \n \t\t/* set-up our fake chunk so that we can process it */\n \t\tauth.skb = chunk->auth_chunk;\n \t\tauth.asoc = chunk->asoc;\n\t\tauth.sctp_hdr = chunk->sctp_hdr;\n\t\tauth.chunk_hdr = (sctp_chunkhdr_t *)skb_push(chunk->auth_chunk,\n\t\t\t\t\t    sizeof(sctp_chunkhdr_t));\n\t\tskb_pull(chunk->auth_chunk, sizeof(sctp_chunkhdr_t));\n\t\tauth.transport = chunk->transport;\n\n\t\tret = sctp_sf_authenticate(net, ep, new_asoc, type, &auth);\n\n\t\t/* We can now safely free the auth_chunk clone */\n\t\tkfree_skb(chunk->auth_chunk);\n\n\t\tif (ret != SCTP_IERROR_NO_ERROR) {\n\t\t\tsctp_association_free(new_asoc);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem_init;\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * D) IMPLEMENTATION NOTE: An implementation may choose to\n\t * send the Communication Up notification to the SCTP user\n\t * upon reception of a valid COOKIE ECHO chunk.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(new_asoc, 0, SCTP_COMM_UP, 0,\n\t\t\t\t\t     new_asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     new_asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem_ev;\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t */\n\tif (new_asoc->peer.adaptation_ind) {\n\t\tai_ev = sctp_ulpevent_make_adaptation_indication(new_asoc,\n\t\t\t\t\t\t\t    GFP_ATOMIC);\n\t\tif (!ai_ev)\n\t\t\tgoto nomem_aiev;\n\t}\n\n\t/* Add all the state machine commands now since we've created\n\t * everything.  This way we don't introduce memory corruptions\n\t * during side-effect processing and correclty count established\n\t * associations.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_PASSIVEESTABS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\n\tif (new_asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* This will send the COOKIE ACK */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/* Queue the ASSOC_CHANGE event */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Send up the Adaptation Layer Indication event */\n\tif (ai_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ai_ev));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem_aiev:\n\tsctp_ulpevent_free(ev);\nnomem_ev:\n\tsctp_chunk_free(repl);\nnomem_init:\n\tsctp_association_free(new_asoc);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144033,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "sctp_disposition_t sctp_sf_do_5_1D_ce(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const sctp_subtype_t type, void *arg,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_association *new_asoc;\n\tsctp_init_chunk_t *peer_init;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_ulpevent *ev, *ai_ev = NULL;\n\tint error = 0;\n\tstruct sctp_chunk *err_chk_p;\n\tstruct sock *sk;\n\n\t/* If the packet is an OOTB packet which is temporarily on the\n\t * control endpoint, respond with an ABORT.\n\t */\n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the COOKIE_ECHO chunk has a valid length.\n\t * In this case, we check that we have enough for at least a\n\t * chunk header.  More detailed verification is done\n\t * in sctp_unpack_cookie().\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* If the endpoint is not listening or if the number of associations\n\t * on the TCP-style socket exceed the max backlog, respond with an\n\t * ABORT.\n\t */\n\tsk = ep->base.sk;\n\tif (!sctp_sstate(sk, LISTENING) ||\n\t    (sctp_style(sk, TCP) && sk_acceptq_is_full(sk)))\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* \"Decode\" the chunk.  We have no optional parameters so we\n\t * are in good shape.\n\t */\n\tchunk->subh.cookie_hdr =\n\t\t(struct sctp_signed_cookie *)chunk->skb->data;\n\tif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\n\t\t\t\t\t sizeof(sctp_chunkhdr_t)))\n\t\tgoto nomem;\n\n\t/* 5.1 D) Upon reception of the COOKIE ECHO chunk, Endpoint\n\t * \"Z\" will reply with a COOKIE ACK chunk after building a TCB\n\t * and moving to the ESTABLISHED state.\n\t */\n\tnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\n\t\t\t\t      &err_chk_p);\n\n\t/* FIXME:\n\t * If the re-build failed, what is the proper error path\n\t * from here?\n\t *\n\t * [We should abort the association. --piggy]\n\t */\n\tif (!new_asoc) {\n\t\t/* FIXME: Several errors are possible.  A bad cookie should\n\t\t * be silently discarded, but think about logging it too.\n\t\t */\n\t\tswitch (error) {\n\t\tcase -SCTP_IERROR_NOMEM:\n\t\t\tgoto nomem;\n\n\t\tcase -SCTP_IERROR_STALE_COOKIE:\n\t\t\tsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\n\t\t\t\t\t\t   err_chk_p);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\tcase -SCTP_IERROR_BAD_SIG:\n\t\tdefault:\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\n\t/* Delay state machine commands until later.\n\t *\n\t * Re-build the bind address for the association is done in\n\t * the sctp_unpack_cookie() already.\n\t */\n\t/* This is a brand-new association, so these are not yet side\n\t * effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\n\tif (!sctp_process_init(new_asoc, chunk,\n\t\t\t       &chunk->subh.cookie_hdr->c.peer_addr,\n\t\t\t       peer_init, GFP_ATOMIC))\n\t\tgoto nomem_init;\n\n\t/* SCTP-AUTH:  Now that we've populate required fields in\n\t * sctp_process_init, set up the assocaition shared keys as\n\t * necessary so that we can potentially authenticate the ACK\n\t */\n\terror = sctp_auth_asoc_init_active_key(new_asoc, GFP_ATOMIC);\n\tif (error)\n\t\tgoto nomem_init;\n\n\t/* SCTP-AUTH:  auth_chunk pointer is only set when the cookie-echo\n\t * is supposed to be authenticated and we have to do delayed\n\t * authentication.  We've just recreated the association using\n\t * the information in the cookie and now it's much easier to\n\t * do the authentication.\n\t */\n\tif (chunk->auth_chunk) {\n \t\tstruct sctp_chunk auth;\n \t\tsctp_ierror_t ret;\n \n\t\t/* Make sure that we and the peer are AUTH capable */\n\t\tif (!net->sctp.auth_enable || !new_asoc->peer.auth_capable) {\n\t\t\tkfree_skb(chunk->auth_chunk);\n\t\t\tsctp_association_free(new_asoc);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\n \t\t/* set-up our fake chunk so that we can process it */\n \t\tauth.skb = chunk->auth_chunk;\n \t\tauth.asoc = chunk->asoc;\n\t\tauth.sctp_hdr = chunk->sctp_hdr;\n\t\tauth.chunk_hdr = (sctp_chunkhdr_t *)skb_push(chunk->auth_chunk,\n\t\t\t\t\t    sizeof(sctp_chunkhdr_t));\n\t\tskb_pull(chunk->auth_chunk, sizeof(sctp_chunkhdr_t));\n\t\tauth.transport = chunk->transport;\n\n\t\tret = sctp_sf_authenticate(net, ep, new_asoc, type, &auth);\n\n\t\t/* We can now safely free the auth_chunk clone */\n\t\tkfree_skb(chunk->auth_chunk);\n\n\t\tif (ret != SCTP_IERROR_NO_ERROR) {\n\t\t\tsctp_association_free(new_asoc);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem_init;\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * D) IMPLEMENTATION NOTE: An implementation may choose to\n\t * send the Communication Up notification to the SCTP user\n\t * upon reception of a valid COOKIE ECHO chunk.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(new_asoc, 0, SCTP_COMM_UP, 0,\n\t\t\t\t\t     new_asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     new_asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem_ev;\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t */\n\tif (new_asoc->peer.adaptation_ind) {\n\t\tai_ev = sctp_ulpevent_make_adaptation_indication(new_asoc,\n\t\t\t\t\t\t\t    GFP_ATOMIC);\n\t\tif (!ai_ev)\n\t\t\tgoto nomem_aiev;\n\t}\n\n\t/* Add all the state machine commands now since we've created\n\t * everything.  This way we don't introduce memory corruptions\n\t * during side-effect processing and correclty count established\n\t * associations.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_PASSIVEESTABS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\n\tif (new_asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* This will send the COOKIE ACK */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/* Queue the ASSOC_CHANGE event */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Send up the Adaptation Layer Indication event */\n\tif (ai_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ai_ev));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem_aiev:\n\tsctp_ulpevent_free(ev);\nnomem_ev:\n\tsctp_chunk_free(repl);\nnomem_init:\n\tsctp_association_free(new_asoc);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144034,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int mpi_powm(MPI res, MPI base, MPI exp, MPI mod)\n{\n\tmpi_ptr_t mp_marker = NULL, bp_marker = NULL, ep_marker = NULL;\n\tmpi_ptr_t xp_marker = NULL;\n\tmpi_ptr_t tspace = NULL;\n\tmpi_ptr_t rp, ep, mp, bp;\n\tmpi_size_t esize, msize, bsize, rsize;\n\tint esign, msign, bsign, rsign;\n\tmpi_size_t size;\n\tint mod_shift_cnt;\n\tint negative_result;\n\tint assign_rp = 0;\n\tmpi_size_t tsize = 0;\t/* to avoid compiler warning */\n\t/* fixme: we should check that the warning is void */\n\tint rc = -ENOMEM;\n\n\tesize = exp->nlimbs;\n\tmsize = mod->nlimbs;\n\tsize = 2 * msize;\n\tesign = exp->sign;\n\tmsign = mod->sign;\n\n\trp = res->d;\n\tep = exp->d;\n\n\tif (!msize)\n\t\treturn -EINVAL;\n\n \tif (!esize) {\n \t\t/* Exponent is zero, result is 1 mod MOD, i.e., 1 or 0\n \t\t * depending on if MOD equals 1.  */\n\t\trp[0] = 1;\n \t\tres->nlimbs = (msize == 1 && mod->d[0] == 1) ? 0 : 1;\n \t\tres->sign = 0;\n \t\tgoto leave;\n \t}\n\n\t/* Normalize MOD (i.e. make its most significant bit set) as required by\n\t * mpn_divrem.  This will make the intermediate values in the calculation\n\t * slightly larger, but the correct result is obtained after a final\n\t * reduction using the original MOD value.  */\n\tmp = mp_marker = mpi_alloc_limb_space(msize);\n\tif (!mp)\n\t\tgoto enomem;\n\tmod_shift_cnt = count_leading_zeros(mod->d[msize - 1]);\n\tif (mod_shift_cnt)\n\t\tmpihelp_lshift(mp, mod->d, msize, mod_shift_cnt);\n\telse\n\t\tMPN_COPY(mp, mod->d, msize);\n\n\tbsize = base->nlimbs;\n\tbsign = base->sign;\n\tif (bsize > msize) {\t/* The base is larger than the module. Reduce it. */\n\t\t/* Allocate (BSIZE + 1) with space for remainder and quotient.\n\t\t * (The quotient is (bsize - msize + 1) limbs.)  */\n\t\tbp = bp_marker = mpi_alloc_limb_space(bsize + 1);\n\t\tif (!bp)\n\t\t\tgoto enomem;\n\t\tMPN_COPY(bp, base->d, bsize);\n\t\t/* We don't care about the quotient, store it above the remainder,\n\t\t * at BP + MSIZE.  */\n\t\tmpihelp_divrem(bp + msize, 0, bp, bsize, mp, msize);\n\t\tbsize = msize;\n\t\t/* Canonicalize the base, since we are going to multiply with it\n\t\t * quite a few times.  */\n\t\tMPN_NORMALIZE(bp, bsize);\n\t} else\n\t\tbp = base->d;\n\n\tif (!bsize) {\n\t\tres->nlimbs = 0;\n\t\tres->sign = 0;\n\t\tgoto leave;\n\t}\n\n\tif (res->alloced < size) {\n\t\t/* We have to allocate more space for RES.  If any of the input\n\t\t * parameters are identical to RES, defer deallocation of the old\n\t\t * space.  */\n\t\tif (rp == ep || rp == mp || rp == bp) {\n\t\t\trp = mpi_alloc_limb_space(size);\n\t\t\tif (!rp)\n\t\t\t\tgoto enomem;\n\t\t\tassign_rp = 1;\n\t\t} else {\n\t\t\tif (mpi_resize(res, size) < 0)\n\t\t\t\tgoto enomem;\n\t\t\trp = res->d;\n\t\t}\n\t} else {\t\t/* Make BASE, EXP and MOD not overlap with RES.  */\n\t\tif (rp == bp) {\n\t\t\t/* RES and BASE are identical.  Allocate temp. space for BASE.  */\n\t\t\tBUG_ON(bp_marker);\n\t\t\tbp = bp_marker = mpi_alloc_limb_space(bsize);\n\t\t\tif (!bp)\n\t\t\t\tgoto enomem;\n\t\t\tMPN_COPY(bp, rp, bsize);\n\t\t}\n\t\tif (rp == ep) {\n\t\t\t/* RES and EXP are identical.  Allocate temp. space for EXP.  */\n\t\t\tep = ep_marker = mpi_alloc_limb_space(esize);\n\t\t\tif (!ep)\n\t\t\t\tgoto enomem;\n\t\t\tMPN_COPY(ep, rp, esize);\n\t\t}\n\t\tif (rp == mp) {\n\t\t\t/* RES and MOD are identical.  Allocate temporary space for MOD. */\n\t\t\tBUG_ON(mp_marker);\n\t\t\tmp = mp_marker = mpi_alloc_limb_space(msize);\n\t\t\tif (!mp)\n\t\t\t\tgoto enomem;\n\t\t\tMPN_COPY(mp, rp, msize);\n\t\t}\n\t}\n\n\tMPN_COPY(rp, bp, bsize);\n\trsize = bsize;\n\trsign = bsign;\n\n\t{\n\t\tmpi_size_t i;\n\t\tmpi_ptr_t xp;\n\t\tint c;\n\t\tmpi_limb_t e;\n\t\tmpi_limb_t carry_limb;\n\t\tstruct karatsuba_ctx karactx;\n\n\t\txp = xp_marker = mpi_alloc_limb_space(2 * (msize + 1));\n\t\tif (!xp)\n\t\t\tgoto enomem;\n\n\t\tmemset(&karactx, 0, sizeof karactx);\n\t\tnegative_result = (ep[0] & 1) && base->sign;\n\n\t\ti = esize - 1;\n\t\te = ep[i];\n\t\tc = count_leading_zeros(e);\n\t\te = (e << c) << 1;\t/* shift the exp bits to the left, lose msb */\n\t\tc = BITS_PER_MPI_LIMB - 1 - c;\n\n\t\t/* Main loop.\n\t\t *\n\t\t * Make the result be pointed to alternately by XP and RP.  This\n\t\t * helps us avoid block copying, which would otherwise be necessary\n\t\t * with the overlap restrictions of mpihelp_divmod. With 50% probability\n\t\t * the result after this loop will be in the area originally pointed\n\t\t * by RP (==RES->d), and with 50% probability in the area originally\n\t\t * pointed to by XP.\n\t\t */\n\n\t\tfor (;;) {\n\t\t\twhile (c) {\n\t\t\t\tmpi_ptr_t tp;\n\t\t\t\tmpi_size_t xsize;\n\n\t\t\t\t/*if (mpihelp_mul_n(xp, rp, rp, rsize) < 0) goto enomem */\n\t\t\t\tif (rsize < KARATSUBA_THRESHOLD)\n\t\t\t\t\tmpih_sqr_n_basecase(xp, rp, rsize);\n\t\t\t\telse {\n\t\t\t\t\tif (!tspace) {\n\t\t\t\t\t\ttsize = 2 * rsize;\n\t\t\t\t\t\ttspace =\n\t\t\t\t\t\t    mpi_alloc_limb_space(tsize);\n\t\t\t\t\t\tif (!tspace)\n\t\t\t\t\t\t\tgoto enomem;\n\t\t\t\t\t} else if (tsize < (2 * rsize)) {\n\t\t\t\t\t\tmpi_free_limb_space(tspace);\n\t\t\t\t\t\ttsize = 2 * rsize;\n\t\t\t\t\t\ttspace =\n\t\t\t\t\t\t    mpi_alloc_limb_space(tsize);\n\t\t\t\t\t\tif (!tspace)\n\t\t\t\t\t\t\tgoto enomem;\n\t\t\t\t\t}\n\t\t\t\t\tmpih_sqr_n(xp, rp, rsize, tspace);\n\t\t\t\t}\n\n\t\t\t\txsize = 2 * rsize;\n\t\t\t\tif (xsize > msize) {\n\t\t\t\t\tmpihelp_divrem(xp + msize, 0, xp, xsize,\n\t\t\t\t\t\t       mp, msize);\n\t\t\t\t\txsize = msize;\n\t\t\t\t}\n\n\t\t\t\ttp = rp;\n\t\t\t\trp = xp;\n\t\t\t\txp = tp;\n\t\t\t\trsize = xsize;\n\n\t\t\t\tif ((mpi_limb_signed_t) e < 0) {\n\t\t\t\t\t/*mpihelp_mul( xp, rp, rsize, bp, bsize ); */\n\t\t\t\t\tif (bsize < KARATSUBA_THRESHOLD) {\n\t\t\t\t\t\tmpi_limb_t tmp;\n\t\t\t\t\t\tif (mpihelp_mul\n\t\t\t\t\t\t    (xp, rp, rsize, bp, bsize,\n\t\t\t\t\t\t     &tmp) < 0)\n\t\t\t\t\t\t\tgoto enomem;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (mpihelp_mul_karatsuba_case\n\t\t\t\t\t\t    (xp, rp, rsize, bp, bsize,\n\t\t\t\t\t\t     &karactx) < 0)\n\t\t\t\t\t\t\tgoto enomem;\n\t\t\t\t\t}\n\n\t\t\t\t\txsize = rsize + bsize;\n\t\t\t\t\tif (xsize > msize) {\n\t\t\t\t\t\tmpihelp_divrem(xp + msize, 0,\n\t\t\t\t\t\t\t       xp, xsize, mp,\n\t\t\t\t\t\t\t       msize);\n\t\t\t\t\t\txsize = msize;\n\t\t\t\t\t}\n\n\t\t\t\t\ttp = rp;\n\t\t\t\t\trp = xp;\n\t\t\t\t\txp = tp;\n\t\t\t\t\trsize = xsize;\n\t\t\t\t}\n\t\t\t\te <<= 1;\n\t\t\t\tc--;\n\t\t\t}\n\n\t\t\ti--;\n\t\t\tif (i < 0)\n\t\t\t\tbreak;\n\t\t\te = ep[i];\n\t\t\tc = BITS_PER_MPI_LIMB;\n\t\t}\n\n\t\t/* We shifted MOD, the modulo reduction argument, left MOD_SHIFT_CNT\n\t\t * steps.  Adjust the result by reducing it with the original MOD.\n\t\t *\n\t\t * Also make sure the result is put in RES->d (where it already\n\t\t * might be, see above).\n\t\t */\n\t\tif (mod_shift_cnt) {\n\t\t\tcarry_limb =\n\t\t\t    mpihelp_lshift(res->d, rp, rsize, mod_shift_cnt);\n\t\t\trp = res->d;\n\t\t\tif (carry_limb) {\n\t\t\t\trp[rsize] = carry_limb;\n\t\t\t\trsize++;\n\t\t\t}\n\t\t} else {\n\t\t\tMPN_COPY(res->d, rp, rsize);\n\t\t\trp = res->d;\n\t\t}\n\n\t\tif (rsize >= msize) {\n\t\t\tmpihelp_divrem(rp + msize, 0, rp, rsize, mp, msize);\n\t\t\trsize = msize;\n\t\t}\n\n\t\t/* Remove any leading zero words from the result.  */\n\t\tif (mod_shift_cnt)\n\t\t\tmpihelp_rshift(rp, rp, rsize, mod_shift_cnt);\n\t\tMPN_NORMALIZE(rp, rsize);\n\n\t\tmpihelp_release_karatsuba_ctx(&karactx);\n\t}\n\n\tif (negative_result && rsize) {\n\t\tif (mod_shift_cnt)\n\t\t\tmpihelp_rshift(mp, mp, msize, mod_shift_cnt);\n\t\tmpihelp_sub(rp, mp, msize, rp, rsize);\n\t\trsize = msize;\n\t\trsign = msign;\n\t\tMPN_NORMALIZE(rp, rsize);\n\t}\n\tres->nlimbs = rsize;\n\tres->sign = rsign;\n\nleave:\n\trc = 0;\nenomem:\n\tif (assign_rp)\n\t\tmpi_assign_limb_space(res, rp, size);\n\tif (mp_marker)\n\t\tmpi_free_limb_space(mp_marker);\n\tif (bp_marker)\n\t\tmpi_free_limb_space(bp_marker);\n\tif (ep_marker)\n\t\tmpi_free_limb_space(ep_marker);\n\tif (xp_marker)\n\t\tmpi_free_limb_space(xp_marker);\n\tif (tspace)\n\t\tmpi_free_limb_space(tspace);\n\treturn rc;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144051,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int mpi_powm(MPI res, MPI base, MPI exp, MPI mod)\n{\n\tmpi_ptr_t mp_marker = NULL, bp_marker = NULL, ep_marker = NULL;\n\tmpi_ptr_t xp_marker = NULL;\n\tmpi_ptr_t tspace = NULL;\n\tmpi_ptr_t rp, ep, mp, bp;\n\tmpi_size_t esize, msize, bsize, rsize;\n\tint esign, msign, bsign, rsign;\n\tmpi_size_t size;\n\tint mod_shift_cnt;\n\tint negative_result;\n\tint assign_rp = 0;\n\tmpi_size_t tsize = 0;\t/* to avoid compiler warning */\n\t/* fixme: we should check that the warning is void */\n\tint rc = -ENOMEM;\n\n\tesize = exp->nlimbs;\n\tmsize = mod->nlimbs;\n\tsize = 2 * msize;\n\tesign = exp->sign;\n\tmsign = mod->sign;\n\n\trp = res->d;\n\tep = exp->d;\n\n\tif (!msize)\n\t\treturn -EINVAL;\n\n \tif (!esize) {\n \t\t/* Exponent is zero, result is 1 mod MOD, i.e., 1 or 0\n \t\t * depending on if MOD equals 1.  */\n \t\tres->nlimbs = (msize == 1 && mod->d[0] == 1) ? 0 : 1;\n\t\tif (res->nlimbs) {\n\t\t\tif (mpi_resize(res, 1) < 0)\n\t\t\t\tgoto enomem;\n\t\t\trp = res->d;\n\t\t\trp[0] = 1;\n\t\t}\n \t\tres->sign = 0;\n \t\tgoto leave;\n \t}\n\n\t/* Normalize MOD (i.e. make its most significant bit set) as required by\n\t * mpn_divrem.  This will make the intermediate values in the calculation\n\t * slightly larger, but the correct result is obtained after a final\n\t * reduction using the original MOD value.  */\n\tmp = mp_marker = mpi_alloc_limb_space(msize);\n\tif (!mp)\n\t\tgoto enomem;\n\tmod_shift_cnt = count_leading_zeros(mod->d[msize - 1]);\n\tif (mod_shift_cnt)\n\t\tmpihelp_lshift(mp, mod->d, msize, mod_shift_cnt);\n\telse\n\t\tMPN_COPY(mp, mod->d, msize);\n\n\tbsize = base->nlimbs;\n\tbsign = base->sign;\n\tif (bsize > msize) {\t/* The base is larger than the module. Reduce it. */\n\t\t/* Allocate (BSIZE + 1) with space for remainder and quotient.\n\t\t * (The quotient is (bsize - msize + 1) limbs.)  */\n\t\tbp = bp_marker = mpi_alloc_limb_space(bsize + 1);\n\t\tif (!bp)\n\t\t\tgoto enomem;\n\t\tMPN_COPY(bp, base->d, bsize);\n\t\t/* We don't care about the quotient, store it above the remainder,\n\t\t * at BP + MSIZE.  */\n\t\tmpihelp_divrem(bp + msize, 0, bp, bsize, mp, msize);\n\t\tbsize = msize;\n\t\t/* Canonicalize the base, since we are going to multiply with it\n\t\t * quite a few times.  */\n\t\tMPN_NORMALIZE(bp, bsize);\n\t} else\n\t\tbp = base->d;\n\n\tif (!bsize) {\n\t\tres->nlimbs = 0;\n\t\tres->sign = 0;\n\t\tgoto leave;\n\t}\n\n\tif (res->alloced < size) {\n\t\t/* We have to allocate more space for RES.  If any of the input\n\t\t * parameters are identical to RES, defer deallocation of the old\n\t\t * space.  */\n\t\tif (rp == ep || rp == mp || rp == bp) {\n\t\t\trp = mpi_alloc_limb_space(size);\n\t\t\tif (!rp)\n\t\t\t\tgoto enomem;\n\t\t\tassign_rp = 1;\n\t\t} else {\n\t\t\tif (mpi_resize(res, size) < 0)\n\t\t\t\tgoto enomem;\n\t\t\trp = res->d;\n\t\t}\n\t} else {\t\t/* Make BASE, EXP and MOD not overlap with RES.  */\n\t\tif (rp == bp) {\n\t\t\t/* RES and BASE are identical.  Allocate temp. space for BASE.  */\n\t\t\tBUG_ON(bp_marker);\n\t\t\tbp = bp_marker = mpi_alloc_limb_space(bsize);\n\t\t\tif (!bp)\n\t\t\t\tgoto enomem;\n\t\t\tMPN_COPY(bp, rp, bsize);\n\t\t}\n\t\tif (rp == ep) {\n\t\t\t/* RES and EXP are identical.  Allocate temp. space for EXP.  */\n\t\t\tep = ep_marker = mpi_alloc_limb_space(esize);\n\t\t\tif (!ep)\n\t\t\t\tgoto enomem;\n\t\t\tMPN_COPY(ep, rp, esize);\n\t\t}\n\t\tif (rp == mp) {\n\t\t\t/* RES and MOD are identical.  Allocate temporary space for MOD. */\n\t\t\tBUG_ON(mp_marker);\n\t\t\tmp = mp_marker = mpi_alloc_limb_space(msize);\n\t\t\tif (!mp)\n\t\t\t\tgoto enomem;\n\t\t\tMPN_COPY(mp, rp, msize);\n\t\t}\n\t}\n\n\tMPN_COPY(rp, bp, bsize);\n\trsize = bsize;\n\trsign = bsign;\n\n\t{\n\t\tmpi_size_t i;\n\t\tmpi_ptr_t xp;\n\t\tint c;\n\t\tmpi_limb_t e;\n\t\tmpi_limb_t carry_limb;\n\t\tstruct karatsuba_ctx karactx;\n\n\t\txp = xp_marker = mpi_alloc_limb_space(2 * (msize + 1));\n\t\tif (!xp)\n\t\t\tgoto enomem;\n\n\t\tmemset(&karactx, 0, sizeof karactx);\n\t\tnegative_result = (ep[0] & 1) && base->sign;\n\n\t\ti = esize - 1;\n\t\te = ep[i];\n\t\tc = count_leading_zeros(e);\n\t\te = (e << c) << 1;\t/* shift the exp bits to the left, lose msb */\n\t\tc = BITS_PER_MPI_LIMB - 1 - c;\n\n\t\t/* Main loop.\n\t\t *\n\t\t * Make the result be pointed to alternately by XP and RP.  This\n\t\t * helps us avoid block copying, which would otherwise be necessary\n\t\t * with the overlap restrictions of mpihelp_divmod. With 50% probability\n\t\t * the result after this loop will be in the area originally pointed\n\t\t * by RP (==RES->d), and with 50% probability in the area originally\n\t\t * pointed to by XP.\n\t\t */\n\n\t\tfor (;;) {\n\t\t\twhile (c) {\n\t\t\t\tmpi_ptr_t tp;\n\t\t\t\tmpi_size_t xsize;\n\n\t\t\t\t/*if (mpihelp_mul_n(xp, rp, rp, rsize) < 0) goto enomem */\n\t\t\t\tif (rsize < KARATSUBA_THRESHOLD)\n\t\t\t\t\tmpih_sqr_n_basecase(xp, rp, rsize);\n\t\t\t\telse {\n\t\t\t\t\tif (!tspace) {\n\t\t\t\t\t\ttsize = 2 * rsize;\n\t\t\t\t\t\ttspace =\n\t\t\t\t\t\t    mpi_alloc_limb_space(tsize);\n\t\t\t\t\t\tif (!tspace)\n\t\t\t\t\t\t\tgoto enomem;\n\t\t\t\t\t} else if (tsize < (2 * rsize)) {\n\t\t\t\t\t\tmpi_free_limb_space(tspace);\n\t\t\t\t\t\ttsize = 2 * rsize;\n\t\t\t\t\t\ttspace =\n\t\t\t\t\t\t    mpi_alloc_limb_space(tsize);\n\t\t\t\t\t\tif (!tspace)\n\t\t\t\t\t\t\tgoto enomem;\n\t\t\t\t\t}\n\t\t\t\t\tmpih_sqr_n(xp, rp, rsize, tspace);\n\t\t\t\t}\n\n\t\t\t\txsize = 2 * rsize;\n\t\t\t\tif (xsize > msize) {\n\t\t\t\t\tmpihelp_divrem(xp + msize, 0, xp, xsize,\n\t\t\t\t\t\t       mp, msize);\n\t\t\t\t\txsize = msize;\n\t\t\t\t}\n\n\t\t\t\ttp = rp;\n\t\t\t\trp = xp;\n\t\t\t\txp = tp;\n\t\t\t\trsize = xsize;\n\n\t\t\t\tif ((mpi_limb_signed_t) e < 0) {\n\t\t\t\t\t/*mpihelp_mul( xp, rp, rsize, bp, bsize ); */\n\t\t\t\t\tif (bsize < KARATSUBA_THRESHOLD) {\n\t\t\t\t\t\tmpi_limb_t tmp;\n\t\t\t\t\t\tif (mpihelp_mul\n\t\t\t\t\t\t    (xp, rp, rsize, bp, bsize,\n\t\t\t\t\t\t     &tmp) < 0)\n\t\t\t\t\t\t\tgoto enomem;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (mpihelp_mul_karatsuba_case\n\t\t\t\t\t\t    (xp, rp, rsize, bp, bsize,\n\t\t\t\t\t\t     &karactx) < 0)\n\t\t\t\t\t\t\tgoto enomem;\n\t\t\t\t\t}\n\n\t\t\t\t\txsize = rsize + bsize;\n\t\t\t\t\tif (xsize > msize) {\n\t\t\t\t\t\tmpihelp_divrem(xp + msize, 0,\n\t\t\t\t\t\t\t       xp, xsize, mp,\n\t\t\t\t\t\t\t       msize);\n\t\t\t\t\t\txsize = msize;\n\t\t\t\t\t}\n\n\t\t\t\t\ttp = rp;\n\t\t\t\t\trp = xp;\n\t\t\t\t\txp = tp;\n\t\t\t\t\trsize = xsize;\n\t\t\t\t}\n\t\t\t\te <<= 1;\n\t\t\t\tc--;\n\t\t\t}\n\n\t\t\ti--;\n\t\t\tif (i < 0)\n\t\t\t\tbreak;\n\t\t\te = ep[i];\n\t\t\tc = BITS_PER_MPI_LIMB;\n\t\t}\n\n\t\t/* We shifted MOD, the modulo reduction argument, left MOD_SHIFT_CNT\n\t\t * steps.  Adjust the result by reducing it with the original MOD.\n\t\t *\n\t\t * Also make sure the result is put in RES->d (where it already\n\t\t * might be, see above).\n\t\t */\n\t\tif (mod_shift_cnt) {\n\t\t\tcarry_limb =\n\t\t\t    mpihelp_lshift(res->d, rp, rsize, mod_shift_cnt);\n\t\t\trp = res->d;\n\t\t\tif (carry_limb) {\n\t\t\t\trp[rsize] = carry_limb;\n\t\t\t\trsize++;\n\t\t\t}\n\t\t} else {\n\t\t\tMPN_COPY(res->d, rp, rsize);\n\t\t\trp = res->d;\n\t\t}\n\n\t\tif (rsize >= msize) {\n\t\t\tmpihelp_divrem(rp + msize, 0, rp, rsize, mp, msize);\n\t\t\trsize = msize;\n\t\t}\n\n\t\t/* Remove any leading zero words from the result.  */\n\t\tif (mod_shift_cnt)\n\t\t\tmpihelp_rshift(rp, rp, rsize, mod_shift_cnt);\n\t\tMPN_NORMALIZE(rp, rsize);\n\n\t\tmpihelp_release_karatsuba_ctx(&karactx);\n\t}\n\n\tif (negative_result && rsize) {\n\t\tif (mod_shift_cnt)\n\t\t\tmpihelp_rshift(mp, mp, msize, mod_shift_cnt);\n\t\tmpihelp_sub(rp, mp, msize, rp, rsize);\n\t\trsize = msize;\n\t\trsign = msign;\n\t\tMPN_NORMALIZE(rp, rsize);\n\t}\n\tres->nlimbs = rsize;\n\tres->sign = rsign;\n\nleave:\n\trc = 0;\nenomem:\n\tif (assign_rp)\n\t\tmpi_assign_limb_space(res, rp, size);\n\tif (mp_marker)\n\t\tmpi_free_limb_space(mp_marker);\n\tif (bp_marker)\n\t\tmpi_free_limb_space(bp_marker);\n\tif (ep_marker)\n\t\tmpi_free_limb_space(ep_marker);\n\tif (xp_marker)\n\t\tmpi_free_limb_space(xp_marker);\n\tif (tspace)\n\t\tmpi_free_limb_space(tspace);\n\treturn rc;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144052,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static MagickBooleanType WriteTGAImage(const ImageInfo *image_info,Image *image)\n{\n  CompressionType\n     compression;\n \n   const char\n     *value;\n \n   const double\n    midpoint = QuantumRange/2.0;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    range;\n\n  register const IndexPacket\n    *indexes;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    count,\n    y;\n\n  TGAInfo\n    tga_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize TGA raster file header.\n  */\n  if ((image->columns > 65535L) || (image->rows > 65535L))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  compression=image->compression;\n  if (image_info->compression != UndefinedCompression)\n     compression=image_info->compression;\n   range=GetQuantumRange(5UL);\n   tga_info.id_length=0;\n  value=GetImageProperty(image,\"comment\");\n  if (value != (const char *) NULL)\n    tga_info.id_length=(unsigned char) MagickMin(strlen(value),255);\n   tga_info.colormap_type=0;\n   tga_info.colormap_index=0;\n   tga_info.colormap_length=0;\n  tga_info.colormap_size=0;\n  tga_info.x_origin=0;\n  tga_info.y_origin=0;\n  tga_info.width=(unsigned short) image->columns;\n  tga_info.height=(unsigned short) image->rows;\n  tga_info.bits_per_pixel=8;\n  tga_info.attributes=0;\n  if ((image_info->type != TrueColorType) &&\n      (image_info->type != TrueColorMatteType) &&\n      (image_info->type != PaletteType) &&\n      (image->matte == MagickFalse) &&\n      (SetImageGray(image,&image->exception) != MagickFalse))\n    tga_info.image_type=compression == RLECompression ? TGARLEMonochrome :\n      TGAMonochrome;\n  else\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        /*\n          Full color TGA raster.\n        */\n        tga_info.image_type=compression == RLECompression ? TGARLERGB : TGARGB;\n        if (image_info->depth == 5)\n          {\n            tga_info.bits_per_pixel=16;\n            if (image->matte != MagickFalse)\n              tga_info.attributes=1;  /* # of alpha bits */\n          }\n        else\n          {\n            tga_info.bits_per_pixel=24;\n            if (image->matte != MagickFalse)\n              {\n                tga_info.bits_per_pixel=32;\n                tga_info.attributes=8;  /* # of alpha bits */\n              }\n          }\n      }\n    else\n      {\n        /*\n          Colormapped TGA raster.\n        */\n        tga_info.image_type=compression == RLECompression ? TGARLEColormap :\n          TGAColormap;\n        tga_info.colormap_type=1;\n        tga_info.colormap_length=(unsigned short) image->colors;\n        if (image_info->depth == 5)\n          tga_info.colormap_size=16;\n        else\n          tga_info.colormap_size=24;\n      }\n  value=GetImageArtifact(image,\"tga:image-origin\");\n  if (value != (const char *) NULL)\n    {\n      OrientationType\n        origin;\n\n      origin=(OrientationType) ParseCommandOption(MagickOrientationOptions,\n        MagickFalse,value);\n      if (origin == BottomRightOrientation || origin == TopRightOrientation)\n        tga_info.attributes|=(1UL << 4);\n      if (origin == TopLeftOrientation || origin == TopRightOrientation)\n        tga_info.attributes|=(1UL << 5);\n    }\n  /*\n    Write TGA header.\n  */\n  (void) WriteBlobByte(image,tga_info.id_length);\n  (void) WriteBlobByte(image,tga_info.colormap_type);\n  (void) WriteBlobByte(image,(unsigned char) tga_info.image_type);\n  (void) WriteBlobLSBShort(image,tga_info.colormap_index);\n  (void) WriteBlobLSBShort(image,tga_info.colormap_length);\n  (void) WriteBlobByte(image,tga_info.colormap_size);\n  (void) WriteBlobLSBShort(image,tga_info.x_origin);\n  (void) WriteBlobLSBShort(image,tga_info.y_origin);\n  (void) WriteBlobLSBShort(image,tga_info.width);\n  (void) WriteBlobLSBShort(image,tga_info.height);\n   (void) WriteBlobByte(image,tga_info.bits_per_pixel);\n   (void) WriteBlobByte(image,tga_info.attributes);\n   if (tga_info.id_length != 0)\n    (void) WriteBlob(image,tga_info.id_length,(unsigned char *) value);\n   if (tga_info.colormap_type != 0)\n     {\n       unsigned char\n        green,\n        *targa_colormap;\n\n      /*\n        Dump colormap to file (blue, green, red byte order).\n      */\n      targa_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n        tga_info.colormap_length,(tga_info.colormap_size/8)*sizeof(\n        *targa_colormap));\n      if (targa_colormap == (unsigned char *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      q=targa_colormap;\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        if (image_info->depth == 5)\n          {\n            green=(unsigned char) ScaleQuantumToAny(image->colormap[i].green,\n              range);\n            *q++=((unsigned char) ScaleQuantumToAny(image->colormap[i].blue,\n              range)) | ((green & 0x07) << 5);\n            *q++=(((image->matte != MagickFalse) && (\n              (double) image->colormap[i].opacity < midpoint)) ? 0x80 : 0) |\n              ((unsigned char) ScaleQuantumToAny(image->colormap[i].red,\n              range) << 2) | ((green & 0x18) >> 3);\n          }\n        else\n          {\n            *q++=ScaleQuantumToChar(image->colormap[i].blue);\n            *q++=ScaleQuantumToChar(image->colormap[i].green);\n            *q++=ScaleQuantumToChar(image->colormap[i].red);\n          }\n      }\n      (void) WriteBlob(image,(size_t) ((tga_info.colormap_size/8)*\n        tga_info.colormap_length),targa_colormap);\n      targa_colormap=(unsigned char *) RelinquishMagickMemory(targa_colormap);\n    }\n  /*\n    Convert MIFF to TGA raster pixels.\n  */\n  for (y=(ssize_t) (image->rows-1); y >= 0; y--)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    indexes=GetVirtualIndexQueue(image);\n    if (compression == RLECompression)\n      {\n        x=0;\n        count=0;\n        while (x < (ssize_t) image->columns)\n        {\n          i=1;\n          while ((i < 128) && (count + i < 128) &&\n                 ((x + i) < (ssize_t) image->columns))\n          {\n            if (tga_info.image_type == TGARLEColormap)\n              {\n                if (GetPixelIndex(indexes+i) != GetPixelIndex(indexes+(i-1)))\n                  break;\n              }\n            else\n              if (tga_info.image_type == TGARLEMonochrome)\n                {\n                  if (GetPixelLuma(image,p+i) != GetPixelLuma(image,p+(i-1)))\n                    break;\n                }\n              else\n                {\n                  if ((GetPixelBlue(p+i) != GetPixelBlue(p+(i-1))) ||\n                      (GetPixelGreen(p+i) != GetPixelGreen(p+(i-1))) ||\n                      (GetPixelRed(p+i) != GetPixelRed(p+(i-1))))\n                    break;\n                  if ((image->matte != MagickFalse) &&\n                      (GetPixelAlpha(p+i) != GetPixelAlpha(p+(i-1))))\n                    break;\n                }\n            i++;\n          }\n          if (i < 3)\n            {\n              count+=i;\n              p+=i;\n              indexes+=i;\n            }\n          if ((i >= 3) || (count == 128) ||\n              ((x + i) == (ssize_t) image->columns))\n            {\n              if (count > 0)\n                {\n                  (void) WriteBlobByte(image,(unsigned char) (--count));\n                  while (count >= 0)\n                  {\n                    WriteTGAPixel(image,tga_info.image_type,indexes-(count+1),\n                      p-(count+1),range,midpoint);\n                    count--;\n                  }\n                  count=0;\n                }\n            }\n          if (i >= 3)\n            {\n              (void) WriteBlobByte(image,(unsigned char) ((i-1) | 0x80));\n              WriteTGAPixel(image,tga_info.image_type,indexes,p,range,midpoint);\n              p+=i;\n              indexes+=i;\n            }\n          x+=i;\n        }\n      }\n    else\n      {\n        for (x=0; x < (ssize_t) image->columns; x++)\n          WriteTGAPixel(image,tga_info.image_type,indexes+x,p++,range,midpoint);\n      }\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144109,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static MagickBooleanType WriteTGAImage(const ImageInfo *image_info,Image *image)\n{\n  CompressionType\n     compression;\n \n   const char\n    *comment,\n     *value;\n \n   const double\n    midpoint = QuantumRange/2.0;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    range;\n\n  register const IndexPacket\n    *indexes;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    count,\n    y;\n\n  TGAInfo\n    tga_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize TGA raster file header.\n  */\n  if ((image->columns > 65535L) || (image->rows > 65535L))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  compression=image->compression;\n  if (image_info->compression != UndefinedCompression)\n     compression=image_info->compression;\n   range=GetQuantumRange(5UL);\n   tga_info.id_length=0;\n  comment=GetImageProperty(image,\"comment\");\n  if (comment != (const char *) NULL)\n    tga_info.id_length=(unsigned char) MagickMin(strlen(comment),255);\n   tga_info.colormap_type=0;\n   tga_info.colormap_index=0;\n   tga_info.colormap_length=0;\n  tga_info.colormap_size=0;\n  tga_info.x_origin=0;\n  tga_info.y_origin=0;\n  tga_info.width=(unsigned short) image->columns;\n  tga_info.height=(unsigned short) image->rows;\n  tga_info.bits_per_pixel=8;\n  tga_info.attributes=0;\n  if ((image_info->type != TrueColorType) &&\n      (image_info->type != TrueColorMatteType) &&\n      (image_info->type != PaletteType) &&\n      (image->matte == MagickFalse) &&\n      (SetImageGray(image,&image->exception) != MagickFalse))\n    tga_info.image_type=compression == RLECompression ? TGARLEMonochrome :\n      TGAMonochrome;\n  else\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        /*\n          Full color TGA raster.\n        */\n        tga_info.image_type=compression == RLECompression ? TGARLERGB : TGARGB;\n        if (image_info->depth == 5)\n          {\n            tga_info.bits_per_pixel=16;\n            if (image->matte != MagickFalse)\n              tga_info.attributes=1;  /* # of alpha bits */\n          }\n        else\n          {\n            tga_info.bits_per_pixel=24;\n            if (image->matte != MagickFalse)\n              {\n                tga_info.bits_per_pixel=32;\n                tga_info.attributes=8;  /* # of alpha bits */\n              }\n          }\n      }\n    else\n      {\n        /*\n          Colormapped TGA raster.\n        */\n        tga_info.image_type=compression == RLECompression ? TGARLEColormap :\n          TGAColormap;\n        tga_info.colormap_type=1;\n        tga_info.colormap_length=(unsigned short) image->colors;\n        if (image_info->depth == 5)\n          tga_info.colormap_size=16;\n        else\n          tga_info.colormap_size=24;\n      }\n  value=GetImageArtifact(image,\"tga:image-origin\");\n  if (value != (const char *) NULL)\n    {\n      OrientationType\n        origin;\n\n      origin=(OrientationType) ParseCommandOption(MagickOrientationOptions,\n        MagickFalse,value);\n      if (origin == BottomRightOrientation || origin == TopRightOrientation)\n        tga_info.attributes|=(1UL << 4);\n      if (origin == TopLeftOrientation || origin == TopRightOrientation)\n        tga_info.attributes|=(1UL << 5);\n    }\n  /*\n    Write TGA header.\n  */\n  (void) WriteBlobByte(image,tga_info.id_length);\n  (void) WriteBlobByte(image,tga_info.colormap_type);\n  (void) WriteBlobByte(image,(unsigned char) tga_info.image_type);\n  (void) WriteBlobLSBShort(image,tga_info.colormap_index);\n  (void) WriteBlobLSBShort(image,tga_info.colormap_length);\n  (void) WriteBlobByte(image,tga_info.colormap_size);\n  (void) WriteBlobLSBShort(image,tga_info.x_origin);\n  (void) WriteBlobLSBShort(image,tga_info.y_origin);\n  (void) WriteBlobLSBShort(image,tga_info.width);\n  (void) WriteBlobLSBShort(image,tga_info.height);\n   (void) WriteBlobByte(image,tga_info.bits_per_pixel);\n   (void) WriteBlobByte(image,tga_info.attributes);\n   if (tga_info.id_length != 0)\n    (void) WriteBlob(image,tga_info.id_length,(unsigned char *) comment);\n   if (tga_info.colormap_type != 0)\n     {\n       unsigned char\n        green,\n        *targa_colormap;\n\n      /*\n        Dump colormap to file (blue, green, red byte order).\n      */\n      targa_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n        tga_info.colormap_length,(tga_info.colormap_size/8)*sizeof(\n        *targa_colormap));\n      if (targa_colormap == (unsigned char *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      q=targa_colormap;\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        if (image_info->depth == 5)\n          {\n            green=(unsigned char) ScaleQuantumToAny(image->colormap[i].green,\n              range);\n            *q++=((unsigned char) ScaleQuantumToAny(image->colormap[i].blue,\n              range)) | ((green & 0x07) << 5);\n            *q++=(((image->matte != MagickFalse) && (\n              (double) image->colormap[i].opacity < midpoint)) ? 0x80 : 0) |\n              ((unsigned char) ScaleQuantumToAny(image->colormap[i].red,\n              range) << 2) | ((green & 0x18) >> 3);\n          }\n        else\n          {\n            *q++=ScaleQuantumToChar(image->colormap[i].blue);\n            *q++=ScaleQuantumToChar(image->colormap[i].green);\n            *q++=ScaleQuantumToChar(image->colormap[i].red);\n          }\n      }\n      (void) WriteBlob(image,(size_t) ((tga_info.colormap_size/8)*\n        tga_info.colormap_length),targa_colormap);\n      targa_colormap=(unsigned char *) RelinquishMagickMemory(targa_colormap);\n    }\n  /*\n    Convert MIFF to TGA raster pixels.\n  */\n  for (y=(ssize_t) (image->rows-1); y >= 0; y--)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    indexes=GetVirtualIndexQueue(image);\n    if (compression == RLECompression)\n      {\n        x=0;\n        count=0;\n        while (x < (ssize_t) image->columns)\n        {\n          i=1;\n          while ((i < 128) && (count + i < 128) &&\n                 ((x + i) < (ssize_t) image->columns))\n          {\n            if (tga_info.image_type == TGARLEColormap)\n              {\n                if (GetPixelIndex(indexes+i) != GetPixelIndex(indexes+(i-1)))\n                  break;\n              }\n            else\n              if (tga_info.image_type == TGARLEMonochrome)\n                {\n                  if (GetPixelLuma(image,p+i) != GetPixelLuma(image,p+(i-1)))\n                    break;\n                }\n              else\n                {\n                  if ((GetPixelBlue(p+i) != GetPixelBlue(p+(i-1))) ||\n                      (GetPixelGreen(p+i) != GetPixelGreen(p+(i-1))) ||\n                      (GetPixelRed(p+i) != GetPixelRed(p+(i-1))))\n                    break;\n                  if ((image->matte != MagickFalse) &&\n                      (GetPixelAlpha(p+i) != GetPixelAlpha(p+(i-1))))\n                    break;\n                }\n            i++;\n          }\n          if (i < 3)\n            {\n              count+=i;\n              p+=i;\n              indexes+=i;\n            }\n          if ((i >= 3) || (count == 128) ||\n              ((x + i) == (ssize_t) image->columns))\n            {\n              if (count > 0)\n                {\n                  (void) WriteBlobByte(image,(unsigned char) (--count));\n                  while (count >= 0)\n                  {\n                    WriteTGAPixel(image,tga_info.image_type,indexes-(count+1),\n                      p-(count+1),range,midpoint);\n                    count--;\n                  }\n                  count=0;\n                }\n            }\n          if (i >= 3)\n            {\n              (void) WriteBlobByte(image,(unsigned char) ((i-1) | 0x80));\n              WriteTGAPixel(image,tga_info.image_type,indexes,p,range,midpoint);\n              p+=i;\n              indexes+=i;\n            }\n          x+=i;\n        }\n      }\n    else\n      {\n        for (x=0; x < (ssize_t) image->columns; x++)\n          WriteTGAPixel(image,tga_info.image_type,indexes+x,p++,range,midpoint);\n      }\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144110,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int nntp_fetch_headers(struct Context *ctx, void *hc, anum_t first,\n                              anum_t last, int restore)\n{\n  struct NntpData *nntp_data = ctx->data;\n  struct FetchCtx fc;\n  struct Header *hdr = NULL;\n  char buf[HUGE_STRING];\n  int rc = 0;\n  int oldmsgcount = ctx->msgcount;\n  anum_t current;\n  anum_t first_over = first;\n#ifdef USE_HCACHE\n  void *hdata = NULL;\n#endif\n\n  /* if empty group or nothing to do */\n  if (!last || first > last)\n    return 0;\n\n  /* init fetch context */\n  fc.ctx = ctx;\n  fc.first = first;\n   fc.last = last;\n   fc.restore = restore;\n   fc.messages = mutt_mem_calloc(last - first + 1, sizeof(unsigned char));\n #ifdef USE_HCACHE\n   fc.hc = hc;\n #endif\n\n  /* fetch list of articles */\n  if (NntpListgroup && nntp_data->nserv->hasLISTGROUP && !nntp_data->deleted)\n  {\n    if (!ctx->quiet)\n      mutt_message(_(\"Fetching list of articles...\"));\n    if (nntp_data->nserv->hasLISTGROUPrange)\n      snprintf(buf, sizeof(buf), \"LISTGROUP %s %u-%u\\r\\n\", nntp_data->group, first, last);\n    else\n      snprintf(buf, sizeof(buf), \"LISTGROUP %s\\r\\n\", nntp_data->group);\n    rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_numbers, &fc);\n    if (rc > 0)\n    {\n      mutt_error(\"LISTGROUP: %s\", buf);\n    }\n    if (rc == 0)\n    {\n      for (current = first; current <= last && rc == 0; current++)\n      {\n        if (fc.messages[current - first])\n          continue;\n\n        snprintf(buf, sizeof(buf), \"%u\", current);\n        if (nntp_data->bcache)\n        {\n          mutt_debug(2, \"#1 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n\n#ifdef USE_HCACHE\n        if (fc.hc)\n        {\n          mutt_debug(2, \"mutt_hcache_delete %s\\n\", buf);\n          mutt_hcache_delete(fc.hc, buf, strlen(buf));\n        }\n#endif\n      }\n    }\n  }\n  else\n  {\n    for (current = first; current <= last; current++)\n      fc.messages[current - first] = 1;\n  }\n\n  /* fetching header from cache or server, or fallback to fetch overview */\n  if (!ctx->quiet)\n  {\n    mutt_progress_init(&fc.progress, _(\"Fetching message headers...\"),\n                       MUTT_PROGRESS_MSG, ReadInc, last - first + 1);\n  }\n  for (current = first; current <= last && rc == 0; current++)\n  {\n    if (!ctx->quiet)\n      mutt_progress_update(&fc.progress, current - first + 1, -1);\n\n#ifdef USE_HCACHE\n    snprintf(buf, sizeof(buf), \"%u\", current);\n#endif\n\n    /* delete header from cache that does not exist on server */\n    if (!fc.messages[current - first])\n      continue;\n\n    /* allocate memory for headers */\n    if (ctx->msgcount >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n\n#ifdef USE_HCACHE\n    /* try to fetch header from cache */\n    hdata = mutt_hcache_fetch(fc.hc, buf, strlen(buf));\n    if (hdata)\n    {\n      mutt_debug(2, \"mutt_hcache_fetch %s\\n\", buf);\n      ctx->hdrs[ctx->msgcount] = hdr = mutt_hcache_restore(hdata);\n      mutt_hcache_free(fc.hc, &hdata);\n      hdr->data = 0;\n\n      /* skip header marked as deleted in cache */\n      if (hdr->deleted && !restore)\n      {\n        mutt_header_free(&hdr);\n        if (nntp_data->bcache)\n        {\n          mutt_debug(2, \"#2 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n        continue;\n      }\n\n      hdr->read = false;\n      hdr->old = false;\n    }\n    else\n#endif\n\n        /* don't try to fetch header from removed newsgroup */\n        if (nntp_data->deleted)\n      continue;\n\n    /* fallback to fetch overview */\n    else if (nntp_data->nserv->hasOVER || nntp_data->nserv->hasXOVER)\n    {\n      if (NntpListgroup && nntp_data->nserv->hasLISTGROUP)\n        break;\n      else\n        continue;\n    }\n\n    /* fetch header from server */\n    else\n    {\n      FILE *fp = mutt_file_mkstemp();\n      if (!fp)\n      {\n        mutt_perror(\"mutt_file_mkstemp() failed!\");\n        rc = -1;\n        break;\n      }\n\n      snprintf(buf, sizeof(buf), \"HEAD %u\\r\\n\", current);\n      rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_tempfile, fp);\n      if (rc)\n      {\n        mutt_file_fclose(&fp);\n        if (rc < 0)\n          break;\n\n        /* invalid response */\n        if (mutt_str_strncmp(\"423\", buf, 3) != 0)\n        {\n          mutt_error(\"HEAD: %s\", buf);\n          break;\n        }\n\n        /* no such article */\n        if (nntp_data->bcache)\n        {\n          snprintf(buf, sizeof(buf), \"%u\", current);\n          mutt_debug(2, \"#3 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n        rc = 0;\n        continue;\n      }\n\n      /* parse header */\n      hdr = ctx->hdrs[ctx->msgcount] = mutt_header_new();\n      hdr->env = mutt_rfc822_read_header(fp, hdr, 0, 0);\n      hdr->received = hdr->date_sent;\n      mutt_file_fclose(&fp);\n    }\n\n    /* save header in context */\n    hdr->index = ctx->msgcount++;\n    hdr->read = false;\n    hdr->old = false;\n    hdr->deleted = false;\n    hdr->data = mutt_mem_calloc(1, sizeof(struct NntpHeaderData));\n    NHDR(hdr)->article_num = current;\n    if (restore)\n      hdr->changed = true;\n    else\n    {\n      nntp_article_status(ctx, hdr, NULL, NHDR(hdr)->article_num);\n      if (!hdr->read)\n        nntp_parse_xref(ctx, hdr);\n    }\n    if (current > nntp_data->last_loaded)\n      nntp_data->last_loaded = current;\n    first_over = current + 1;\n  }\n\n  if (!NntpListgroup || !nntp_data->nserv->hasLISTGROUP)\n    current = first_over;\n\n  /* fetch overview information */\n  if (current <= last && rc == 0 && !nntp_data->deleted)\n  {\n    char *cmd = nntp_data->nserv->hasOVER ? \"OVER\" : \"XOVER\";\n    snprintf(buf, sizeof(buf), \"%s %u-%u\\r\\n\", cmd, current, last);\n    rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, parse_overview_line, &fc);\n    if (rc > 0)\n    {\n      mutt_error(\"%s: %s\", cmd, buf);\n    }\n  }\n\n  if (ctx->msgcount > oldmsgcount)\n    mx_update_context(ctx, ctx->msgcount - oldmsgcount);\n\n  FREE(&fc.messages);\n  if (rc != 0)\n    return -1;\n  mutt_clear_error();\n  return 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144153,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int nntp_fetch_headers(struct Context *ctx, void *hc, anum_t first,\n                              anum_t last, int restore)\n{\n  struct NntpData *nntp_data = ctx->data;\n  struct FetchCtx fc;\n  struct Header *hdr = NULL;\n  char buf[HUGE_STRING];\n  int rc = 0;\n  int oldmsgcount = ctx->msgcount;\n  anum_t current;\n  anum_t first_over = first;\n#ifdef USE_HCACHE\n  void *hdata = NULL;\n#endif\n\n  /* if empty group or nothing to do */\n  if (!last || first > last)\n    return 0;\n\n  /* init fetch context */\n  fc.ctx = ctx;\n  fc.first = first;\n   fc.last = last;\n   fc.restore = restore;\n   fc.messages = mutt_mem_calloc(last - first + 1, sizeof(unsigned char));\n  if (fc.messages == NULL)\n\t  return -1;\n #ifdef USE_HCACHE\n   fc.hc = hc;\n #endif\n\n  /* fetch list of articles */\n  if (NntpListgroup && nntp_data->nserv->hasLISTGROUP && !nntp_data->deleted)\n  {\n    if (!ctx->quiet)\n      mutt_message(_(\"Fetching list of articles...\"));\n    if (nntp_data->nserv->hasLISTGROUPrange)\n      snprintf(buf, sizeof(buf), \"LISTGROUP %s %u-%u\\r\\n\", nntp_data->group, first, last);\n    else\n      snprintf(buf, sizeof(buf), \"LISTGROUP %s\\r\\n\", nntp_data->group);\n    rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_numbers, &fc);\n    if (rc > 0)\n    {\n      mutt_error(\"LISTGROUP: %s\", buf);\n    }\n    if (rc == 0)\n    {\n      for (current = first; current <= last && rc == 0; current++)\n      {\n        if (fc.messages[current - first])\n          continue;\n\n        snprintf(buf, sizeof(buf), \"%u\", current);\n        if (nntp_data->bcache)\n        {\n          mutt_debug(2, \"#1 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n\n#ifdef USE_HCACHE\n        if (fc.hc)\n        {\n          mutt_debug(2, \"mutt_hcache_delete %s\\n\", buf);\n          mutt_hcache_delete(fc.hc, buf, strlen(buf));\n        }\n#endif\n      }\n    }\n  }\n  else\n  {\n    for (current = first; current <= last; current++)\n      fc.messages[current - first] = 1;\n  }\n\n  /* fetching header from cache or server, or fallback to fetch overview */\n  if (!ctx->quiet)\n  {\n    mutt_progress_init(&fc.progress, _(\"Fetching message headers...\"),\n                       MUTT_PROGRESS_MSG, ReadInc, last - first + 1);\n  }\n  for (current = first; current <= last && rc == 0; current++)\n  {\n    if (!ctx->quiet)\n      mutt_progress_update(&fc.progress, current - first + 1, -1);\n\n#ifdef USE_HCACHE\n    snprintf(buf, sizeof(buf), \"%u\", current);\n#endif\n\n    /* delete header from cache that does not exist on server */\n    if (!fc.messages[current - first])\n      continue;\n\n    /* allocate memory for headers */\n    if (ctx->msgcount >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n\n#ifdef USE_HCACHE\n    /* try to fetch header from cache */\n    hdata = mutt_hcache_fetch(fc.hc, buf, strlen(buf));\n    if (hdata)\n    {\n      mutt_debug(2, \"mutt_hcache_fetch %s\\n\", buf);\n      ctx->hdrs[ctx->msgcount] = hdr = mutt_hcache_restore(hdata);\n      mutt_hcache_free(fc.hc, &hdata);\n      hdr->data = 0;\n\n      /* skip header marked as deleted in cache */\n      if (hdr->deleted && !restore)\n      {\n        mutt_header_free(&hdr);\n        if (nntp_data->bcache)\n        {\n          mutt_debug(2, \"#2 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n        continue;\n      }\n\n      hdr->read = false;\n      hdr->old = false;\n    }\n    else\n#endif\n\n        /* don't try to fetch header from removed newsgroup */\n        if (nntp_data->deleted)\n      continue;\n\n    /* fallback to fetch overview */\n    else if (nntp_data->nserv->hasOVER || nntp_data->nserv->hasXOVER)\n    {\n      if (NntpListgroup && nntp_data->nserv->hasLISTGROUP)\n        break;\n      else\n        continue;\n    }\n\n    /* fetch header from server */\n    else\n    {\n      FILE *fp = mutt_file_mkstemp();\n      if (!fp)\n      {\n        mutt_perror(\"mutt_file_mkstemp() failed!\");\n        rc = -1;\n        break;\n      }\n\n      snprintf(buf, sizeof(buf), \"HEAD %u\\r\\n\", current);\n      rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_tempfile, fp);\n      if (rc)\n      {\n        mutt_file_fclose(&fp);\n        if (rc < 0)\n          break;\n\n        /* invalid response */\n        if (mutt_str_strncmp(\"423\", buf, 3) != 0)\n        {\n          mutt_error(\"HEAD: %s\", buf);\n          break;\n        }\n\n        /* no such article */\n        if (nntp_data->bcache)\n        {\n          snprintf(buf, sizeof(buf), \"%u\", current);\n          mutt_debug(2, \"#3 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n        rc = 0;\n        continue;\n      }\n\n      /* parse header */\n      hdr = ctx->hdrs[ctx->msgcount] = mutt_header_new();\n      hdr->env = mutt_rfc822_read_header(fp, hdr, 0, 0);\n      hdr->received = hdr->date_sent;\n      mutt_file_fclose(&fp);\n    }\n\n    /* save header in context */\n    hdr->index = ctx->msgcount++;\n    hdr->read = false;\n    hdr->old = false;\n    hdr->deleted = false;\n    hdr->data = mutt_mem_calloc(1, sizeof(struct NntpHeaderData));\n    NHDR(hdr)->article_num = current;\n    if (restore)\n      hdr->changed = true;\n    else\n    {\n      nntp_article_status(ctx, hdr, NULL, NHDR(hdr)->article_num);\n      if (!hdr->read)\n        nntp_parse_xref(ctx, hdr);\n    }\n    if (current > nntp_data->last_loaded)\n      nntp_data->last_loaded = current;\n    first_over = current + 1;\n  }\n\n  if (!NntpListgroup || !nntp_data->nserv->hasLISTGROUP)\n    current = first_over;\n\n  /* fetch overview information */\n  if (current <= last && rc == 0 && !nntp_data->deleted)\n  {\n    char *cmd = nntp_data->nserv->hasOVER ? \"OVER\" : \"XOVER\";\n    snprintf(buf, sizeof(buf), \"%s %u-%u\\r\\n\", cmd, current, last);\n    rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, parse_overview_line, &fc);\n    if (rc > 0)\n    {\n      mutt_error(\"%s: %s\", cmd, buf);\n    }\n  }\n\n  if (ctx->msgcount > oldmsgcount)\n    mx_update_context(ctx, ctx->msgcount - oldmsgcount);\n\n  FREE(&fc.messages);\n  if (rc != 0)\n    return -1;\n  mutt_clear_error();\n  return 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144154,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\n\t/* Pierre: crop everything sounds bad */\n\tif (threshold > 100.0) {\n \t\treturn NULL;\n \t}\n \n \t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n \t * for the true color and palette images\n \t * new formats will simply work with ptr\n\t */\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\n\t/* Pierre\n\t * Nothing to do > bye\n\t * Duplicate the image?\n\t */\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t}\n\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\n\treturn gdImageCrop(im, &crop);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144193,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\n\t/* Pierre: crop everything sounds bad */\n\tif (threshold > 100.0) {\n \t\treturn NULL;\n \t}\n \n\tif (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {\n\t\treturn NULL;\n\t}\n\n \t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n \t * for the true color and palette images\n \t * new formats will simply work with ptr\n\t */\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\n\t/* Pierre\n\t * Nothing to do > bye\n\t * Duplicate the image?\n\t */\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t}\n\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\n\treturn gdImageCrop(im, &crop);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144194,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,\n     char *line, int *err, gchar **err_info)\n {\n \tint\t\tsec;\n \tint\t\tdsec;\n \tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\n \tchar\t\tdirection[2];\n\tguint\t\tpkt_len;\n \tchar\t\tcap_src[13];\n \tchar\t\tcap_dst[13];\n \tguint8\t\t*pd;\n \tgchar\t\t*p;\n \tint\t\tn, i = 0;\n\tguint\t\toffset = 0;\n \tgchar\t\tdststr[13];\n \n \tphdr->rec_type = REC_TYPE_PACKET;\n \tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n \n\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9u:%12s->%12s/\",\n \t\t   &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {\n \t\t*err = WTAP_ERR_BAD_FILE;\n \t\t*err_info = g_strdup(\"netscreen: Can't parse packet-header\");\n \t\treturn -1;\n \t}\n \tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n \t\t/*\n \t\t * Probably a corrupt capture file; don't blow up trying\n\t\t * to allocate space for an immensely-large packet.\n\t\t */\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"netscreen: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n\t\treturn FALSE;\n\t}\n\n\t/*\n\t * If direction[0] is 'o', the direction is NETSCREEN_EGRESS,\n\t * otherwise it's NETSCREEN_INGRESS.\n\t */\n\n\tphdr->ts.secs  = sec;\n\tphdr->ts.nsecs = dsec * 100000000;\n\tphdr->len = pkt_len;\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(buf, pkt_len);\n\tpd = ws_buffer_start_ptr(buf);\n\n\twhile(1) {\n\n\t\t/* The last packet is not delimited by an empty line, but by EOF\n\t\t * So accept EOF as a valid delimiter too\n\t\t */\n\t\tif (file_gets(line, NETSCREEN_LINE_LENGTH, fh) == NULL) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Skip blanks.\n\t\t * The number of blanks is not fixed - for wireless\n\t\t * interfaces, there may be 14 extra spaces before\n\t\t * the hex data.\n\t\t */\n\t\tfor (p = &line[0]; g_ascii_isspace(*p); p++)\n\t\t\t;\n\t\t/* packets are delimited with empty lines */\n\t\tif (*p == '\\0') {\n\t\t\tbreak;\n\t\t}\n\n\t\tn = parse_single_hex_dump_line(p, pd, offset);\n\n\t\t/* the smallest packet has a length of 6 bytes, if\n\t\t * the first hex-data is less then check whether\n\t\t * it is a info-line and act accordingly\n\t\t */\n\t\tif (offset == 0 && n < 6) {\n\t\t\tif (info_line(line)) {\n\t\t\t\tif (++i <= NETSCREEN_MAX_INFOLINES) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t*err_info = g_strdup(\"netscreen: cannot parse hex-data\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\n\t\t/* If there is no more data and the line was not empty,\n\t\t * then there must be an error in the file\n\t\t */\n\t\tif (n == -1) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"netscreen: cannot parse hex-data\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/* Adjust the offset to the data that was just added to the buffer */\n\t\toffset += n;\n\n\t\t/* If there was more hex-data than was announced in the len=x\n\t\t * header, then then there must be an error in the file\n\t\t */\n\t\tif (offset > pkt_len) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"netscreen: too much hex-data\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/*\n\t * Determine the encapsulation type, based on the\n\t * first 4 characters of the interface name\n\t *\n\t * XXX\tconvert this to a 'case' structure when adding more\n\t *\t(non-ethernet) interfacetypes\n\t */\n\tif (strncmp(cap_int, \"adsl\", 4) == 0) {\n\t\t/* The ADSL interface can be bridged with or without\n\t\t * PPP encapsulation. Check whether the first six bytes\n\t\t * of the hex data are the same as the destination mac\n\t\t * address in the header. If they are, assume ethernet\n\t\t * LinkLayer or else PPP\n\t\t */\n\t\tg_snprintf(dststr, 13, \"%02x%02x%02x%02x%02x%02x\",\n\t\t   pd[0], pd[1], pd[2], pd[3], pd[4], pd[5]);\n\t\tif (strncmp(dststr, cap_dst, 12) == 0)\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\t\telse\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_PPP;\n\t\t}\n\telse if (strncmp(cap_int, \"seri\", 4) == 0)\n\t\tphdr->pkt_encap = WTAP_ENCAP_PPP;\n\telse\n\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\n\tphdr->caplen = offset;\n\n\treturn TRUE;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144195,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,\n     char *line, int *err, gchar **err_info)\n {\n\tint\t\tpkt_len;\n \tint\t\tsec;\n \tint\t\tdsec;\n \tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\n \tchar\t\tdirection[2];\n \tchar\t\tcap_src[13];\n \tchar\t\tcap_dst[13];\n \tguint8\t\t*pd;\n \tgchar\t\t*p;\n \tint\t\tn, i = 0;\n\tint\t\toffset = 0;\n \tgchar\t\tdststr[13];\n \n \tphdr->rec_type = REC_TYPE_PACKET;\n \tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n \n\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9d:%12s->%12s/\",\n \t\t   &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {\n \t\t*err = WTAP_ERR_BAD_FILE;\n \t\t*err_info = g_strdup(\"netscreen: Can't parse packet-header\");\n \t\treturn -1;\n \t}\n\tif (pkt_len < 0) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"netscreen: packet header has a negative packet length\");\n\t\treturn FALSE;\n\t}\n \tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n \t\t/*\n \t\t * Probably a corrupt capture file; don't blow up trying\n\t\t * to allocate space for an immensely-large packet.\n\t\t */\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"netscreen: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n\t\treturn FALSE;\n\t}\n\n\t/*\n\t * If direction[0] is 'o', the direction is NETSCREEN_EGRESS,\n\t * otherwise it's NETSCREEN_INGRESS.\n\t */\n\n\tphdr->ts.secs  = sec;\n\tphdr->ts.nsecs = dsec * 100000000;\n\tphdr->len = pkt_len;\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(buf, pkt_len);\n\tpd = ws_buffer_start_ptr(buf);\n\n\twhile(1) {\n\n\t\t/* The last packet is not delimited by an empty line, but by EOF\n\t\t * So accept EOF as a valid delimiter too\n\t\t */\n\t\tif (file_gets(line, NETSCREEN_LINE_LENGTH, fh) == NULL) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Skip blanks.\n\t\t * The number of blanks is not fixed - for wireless\n\t\t * interfaces, there may be 14 extra spaces before\n\t\t * the hex data.\n\t\t */\n\t\tfor (p = &line[0]; g_ascii_isspace(*p); p++)\n\t\t\t;\n\t\t/* packets are delimited with empty lines */\n\t\tif (*p == '\\0') {\n\t\t\tbreak;\n\t\t}\n\n\t\tn = parse_single_hex_dump_line(p, pd, offset);\n\n\t\t/* the smallest packet has a length of 6 bytes, if\n\t\t * the first hex-data is less then check whether\n\t\t * it is a info-line and act accordingly\n\t\t */\n\t\tif (offset == 0 && n < 6) {\n\t\t\tif (info_line(line)) {\n\t\t\t\tif (++i <= NETSCREEN_MAX_INFOLINES) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t*err_info = g_strdup(\"netscreen: cannot parse hex-data\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\n\t\t/* If there is no more data and the line was not empty,\n\t\t * then there must be an error in the file\n\t\t */\n\t\tif (n == -1) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"netscreen: cannot parse hex-data\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/* Adjust the offset to the data that was just added to the buffer */\n\t\toffset += n;\n\n\t\t/* If there was more hex-data than was announced in the len=x\n\t\t * header, then then there must be an error in the file\n\t\t */\n\t\tif (offset > pkt_len) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"netscreen: too much hex-data\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/*\n\t * Determine the encapsulation type, based on the\n\t * first 4 characters of the interface name\n\t *\n\t * XXX\tconvert this to a 'case' structure when adding more\n\t *\t(non-ethernet) interfacetypes\n\t */\n\tif (strncmp(cap_int, \"adsl\", 4) == 0) {\n\t\t/* The ADSL interface can be bridged with or without\n\t\t * PPP encapsulation. Check whether the first six bytes\n\t\t * of the hex data are the same as the destination mac\n\t\t * address in the header. If they are, assume ethernet\n\t\t * LinkLayer or else PPP\n\t\t */\n\t\tg_snprintf(dststr, 13, \"%02x%02x%02x%02x%02x%02x\",\n\t\t   pd[0], pd[1], pd[2], pd[3], pd[4], pd[5]);\n\t\tif (strncmp(dststr, cap_dst, 12) == 0)\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\t\telse\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_PPP;\n\t\t}\n\telse if (strncmp(cap_int, \"seri\", 4) == 0)\n\t\tphdr->pkt_encap = WTAP_ENCAP_PPP;\n\telse\n\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\n\tphdr->caplen = offset;\n\n\treturn TRUE;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144196,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " void BeginInstallWithManifestFunction::OnParseSuccess(\n     const SkBitmap& icon, DictionaryValue* parsed_manifest) {\n  CHECK(parsed_manifest);\n  icon_ = icon;\n  parsed_manifest_.reset(parsed_manifest);\n\n  std::string init_errors;\n  dummy_extension_ = Extension::Create(\n      FilePath(),\n      Extension::INTERNAL,\n      *static_cast<DictionaryValue*>(parsed_manifest_.get()),\n      Extension::NO_FLAGS,\n      &init_errors);\n  if (!dummy_extension_.get()) {\n    OnParseFailure(MANIFEST_ERROR, std::string(kInvalidManifestError));\n    return;\n  }\n   if (icon_.empty())\n     icon_ = Extension::GetDefaultIcon(dummy_extension_->is_app());\n \n   ShowExtensionInstallDialog(profile(),\n                              this,\n                              dummy_extension_.get(),\n                             &icon_,\n                             dummy_extension_->GetPermissionMessageStrings(),\n                             ExtensionInstallUI::INSTALL_PROMPT);\n\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144211,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " void BeginInstallWithManifestFunction::OnParseSuccess(\n     const SkBitmap& icon, DictionaryValue* parsed_manifest) {\n  CHECK(parsed_manifest);\n  icon_ = icon;\n  parsed_manifest_.reset(parsed_manifest);\n\n  std::string init_errors;\n  dummy_extension_ = Extension::Create(\n      FilePath(),\n      Extension::INTERNAL,\n      *static_cast<DictionaryValue*>(parsed_manifest_.get()),\n      Extension::NO_FLAGS,\n      &init_errors);\n  if (!dummy_extension_.get()) {\n    OnParseFailure(MANIFEST_ERROR, std::string(kInvalidManifestError));\n    return;\n  }\n   if (icon_.empty())\n     icon_ = Extension::GetDefaultIcon(dummy_extension_->is_app());\n \n  // In tests, we may have setup to proceed or abort without putting up the real\n  // confirmation dialog.\n  if (auto_confirm_for_tests != DO_NOT_SKIP) {\n    if (auto_confirm_for_tests == PROCEED)\n      this->InstallUIProceed();\n    else\n      this->InstallUIAbort();\n    return;\n  }\n\n   ShowExtensionInstallDialog(profile(),\n                              this,\n                              dummy_extension_.get(),\n                             &icon_,\n                             dummy_extension_->GetPermissionMessageStrings(),\n                             ExtensionInstallUI::INSTALL_PROMPT);\n\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144212,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void TabSpecificContentSettings::OnContentBlocked(\n    ContentSettingsType type,\n     const std::string& resource_identifier) {\n   DCHECK(type != CONTENT_SETTINGS_TYPE_GEOLOCATION)\n       << \"Geolocation settings handled by OnGeolocationPermissionSet\";\n   content_accessed_[type] = true;\n  std::string identifier;\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n      switches::kEnableResourceContentSettings)) {\n    identifier = resource_identifier;\n  }\n  if (!identifier.empty())\n    AddBlockedResource(type, identifier);\n\n#if defined (OS_ANDROID)\n  if (type == CONTENT_SETTINGS_TYPE_POPUPS) {\n    content_blocked_[type] = false;\n    content_blockage_indicated_to_user_[type] = false;\n  }\n#endif\n\n  if (!content_blocked_[type]) {\n    content_blocked_[type] = true;\n    content::NotificationService::current()->Notify(\n        chrome::NOTIFICATION_WEB_CONTENT_SETTINGS_CHANGED,\n        content::Source<WebContents>(web_contents()),\n        content::NotificationService::NoDetails());\n  }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144219,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void TabSpecificContentSettings::OnContentBlocked(\n    ContentSettingsType type,\n     const std::string& resource_identifier) {\n   DCHECK(type != CONTENT_SETTINGS_TYPE_GEOLOCATION)\n       << \"Geolocation settings handled by OnGeolocationPermissionSet\";\n  if (type < 0 || type >= CONTENT_SETTINGS_NUM_TYPES)\n    return;\n   content_accessed_[type] = true;\n  std::string identifier;\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n      switches::kEnableResourceContentSettings)) {\n    identifier = resource_identifier;\n  }\n  if (!identifier.empty())\n    AddBlockedResource(type, identifier);\n\n#if defined (OS_ANDROID)\n  if (type == CONTENT_SETTINGS_TYPE_POPUPS) {\n    content_blocked_[type] = false;\n    content_blockage_indicated_to_user_[type] = false;\n  }\n#endif\n\n  if (!content_blocked_[type]) {\n    content_blocked_[type] = true;\n    content::NotificationService::current()->Notify(\n        chrome::NOTIFICATION_WEB_CONTENT_SETTINGS_CHANGED,\n        content::Source<WebContents>(web_contents()),\n        content::NotificationService::NoDetails());\n  }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144220,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void Document::open()\n{\n    ASSERT(!importLoader());\n\n    if (m_frame) {\n        if (ScriptableDocumentParser* parser = scriptableDocumentParser()) {\n            if (parser->isParsing()) {\n                if (parser->isExecutingScript())\n                    return;\n\n                if (!parser->wasCreatedByScript() && parser->hasInsertionPoint())\n                    return;\n            }\n        }\n\n        if (m_frame->loader().provisionalDocumentLoader())\n            m_frame->loader().stopAllLoaders();\n    }\n\n    removeAllEventListenersRecursively();\n    implicitOpen(ForceSynchronousParsing);\n    if (ScriptableDocumentParser* parser = scriptableDocumentParser())\n        parser->setWasCreatedByScript(true);\n \n     if (m_frame)\n         m_frame->loader().didExplicitOpen();\n    if (m_loadEventProgress != LoadEventInProgress && m_loadEventProgress != UnloadEventInProgress)\n         m_loadEventProgress = LoadEventNotRun;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144229,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void Document::open()\n{\n    ASSERT(!importLoader());\n\n    if (m_frame) {\n        if (ScriptableDocumentParser* parser = scriptableDocumentParser()) {\n            if (parser->isParsing()) {\n                if (parser->isExecutingScript())\n                    return;\n\n                if (!parser->wasCreatedByScript() && parser->hasInsertionPoint())\n                    return;\n            }\n        }\n\n        if (m_frame->loader().provisionalDocumentLoader())\n            m_frame->loader().stopAllLoaders();\n    }\n\n    removeAllEventListenersRecursively();\n    implicitOpen(ForceSynchronousParsing);\n    if (ScriptableDocumentParser* parser = scriptableDocumentParser())\n        parser->setWasCreatedByScript(true);\n \n     if (m_frame)\n         m_frame->loader().didExplicitOpen();\n    if (m_loadEventProgress != LoadEventInProgress && pageDismissalEventBeingDispatched() == NoDismissal)\n         m_loadEventProgress = LoadEventNotRun;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144230,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "const service_manager::Manifest& GetChromeContentBrowserOverlayManifest() {\n  static base::NoDestructor<service_manager::Manifest> manifest {\n    service_manager::ManifestBuilder()\n        .ExposeCapability(\"gpu\",\n                          service_manager::Manifest::InterfaceList<\n                              metrics::mojom::CallStackProfileCollector>())\n        .ExposeCapability(\"renderer\",\n                          service_manager::Manifest::InterfaceList<\n                              chrome::mojom::AvailableOfflineContentProvider,\n                              chrome::mojom::CacheStatsRecorder,\n                              chrome::mojom::NetBenchmarking,\n                              data_reduction_proxy::mojom::DataReductionProxy,\n                              metrics::mojom::CallStackProfileCollector,\n#if defined(OS_WIN)\n                              mojom::ModuleEventSink,\n#endif\n                              rappor::mojom::RapporRecorder,\n                              safe_browsing::mojom::SafeBrowsing>())\n        .RequireCapability(\"ash\", \"system_ui\")\n        .RequireCapability(\"ash\", \"test\")\n        .RequireCapability(\"ash\", \"display\")\n        .RequireCapability(\"assistant\", \"assistant\")\n        .RequireCapability(\"assistant_audio_decoder\", \"assistant:audio_decoder\")\n        .RequireCapability(\"chrome\", \"input_device_controller\")\n        .RequireCapability(\"chrome_printing\", \"converter\")\n        .RequireCapability(\"cups_ipp_parser\", \"ipp_parser\")\n        .RequireCapability(\"device\", \"device:fingerprint\")\n        .RequireCapability(\"device\", \"device:geolocation_config\")\n        .RequireCapability(\"device\", \"device:geolocation_control\")\n        .RequireCapability(\"device\", \"device:ip_geolocator\")\n        .RequireCapability(\"ime\", \"input_engine\")\n        .RequireCapability(\"mirroring\", \"mirroring\")\n        .RequireCapability(\"nacl_broker\", \"browser\")\n        .RequireCapability(\"nacl_loader\", \"browser\")\n        .RequireCapability(\"noop\", \"noop\")\n        .RequireCapability(\"patch\", \"patch_file\")\n        .RequireCapability(\"preferences\", \"pref_client\")\n        .RequireCapability(\"preferences\", \"pref_control\")\n        .RequireCapability(\"profile_import\", \"import\")\n        .RequireCapability(\"removable_storage_writer\",\n                           \"removable_storage_writer\")\n        .RequireCapability(\"secure_channel\", \"secure_channel\")\n        .RequireCapability(\"ui\", \"ime_registrar\")\n        .RequireCapability(\"ui\", \"input_device_controller\")\n        .RequireCapability(\"ui\", \"window_manager\")\n        .RequireCapability(\"unzip\", \"unzip_file\")\n        .RequireCapability(\"util_win\", \"util_win\")\n        .RequireCapability(\"xr_device_service\", \"xr_device_provider\")\n        .RequireCapability(\"xr_device_service\", \"xr_device_test_hook\")\n#if defined(OS_CHROMEOS)\n        .RequireCapability(\"multidevice_setup\", \"multidevice_setup\")\n#endif\n        .ExposeInterfaceFilterCapability_Deprecated(\n            \"navigation:frame\", \"renderer\",\n            service_manager::Manifest::InterfaceList<\n                autofill::mojom::AutofillDriver,\n                autofill::mojom::PasswordManagerDriver,\n                chrome::mojom::OfflinePageAutoFetcher,\n#if defined(OS_CHROMEOS)\n                 chromeos_camera::mojom::CameraAppHelper,\n                 chromeos::cellular_setup::mojom::CellularSetup,\n                 chromeos::crostini_installer::mojom::PageHandlerFactory,\n                chromeos::crostini_upgrader::mojom::PageHandlerFactory,\n                 chromeos::ime::mojom::InputEngineManager,\n                 chromeos::machine_learning::mojom::PageHandler,\n                 chromeos::media_perception::mojom::MediaPerception,\n                chromeos::multidevice_setup::mojom::MultiDeviceSetup,\n                chromeos::multidevice_setup::mojom::PrivilegedHostDeviceSetter,\n                chromeos::network_config::mojom::CrosNetworkConfig,\n                cros::mojom::CameraAppDeviceProvider,\n#endif\n                contextual_search::mojom::ContextualSearchJsApiService,\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n                extensions::KeepAlive,\n#endif\n                media::mojom::MediaEngagementScoreDetailsProvider,\n                media_router::mojom::MediaRouter,\n                page_load_metrics::mojom::PageLoadMetrics,\n                translate::mojom::ContentTranslateDriver,\n\n                downloads::mojom::PageHandlerFactory,\n                feed_internals::mojom::PageHandler,\n                new_tab_page::mojom::PageHandlerFactory,\n#if defined(OS_ANDROID)\n                explore_sites_internals::mojom::PageHandler,\n#else\n                app_management::mojom::PageHandlerFactory,\n#endif\n#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \\\n    defined(OS_CHROMEOS)\n                discards::mojom::DetailsProvider, discards::mojom::GraphDump,\n#endif\n#if defined(OS_CHROMEOS)\n                add_supervision::mojom::AddSupervisionHandler,\n#endif\n                mojom::BluetoothInternalsHandler,\n                mojom::InterventionsInternalsPageHandler,\n                mojom::OmniboxPageHandler, mojom::ResetPasswordHandler,\n                mojom::SiteEngagementDetailsProvider,\n                mojom::UsbInternalsPageHandler,\n                snippets_internals::mojom::PageHandlerFactory>())\n        .PackageService(prefs::GetManifest())\n#if defined(OS_CHROMEOS)\n        .PackageService(chromeos::multidevice_setup::GetManifest())\n#endif  // defined(OS_CHROMEOS)\n        .Build()\n  };\n  return *manifest;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144235,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "const service_manager::Manifest& GetChromeContentBrowserOverlayManifest() {\n  static base::NoDestructor<service_manager::Manifest> manifest {\n    service_manager::ManifestBuilder()\n        .ExposeCapability(\"gpu\",\n                          service_manager::Manifest::InterfaceList<\n                              metrics::mojom::CallStackProfileCollector>())\n        .ExposeCapability(\"renderer\",\n                          service_manager::Manifest::InterfaceList<\n                              chrome::mojom::AvailableOfflineContentProvider,\n                              chrome::mojom::CacheStatsRecorder,\n                              chrome::mojom::NetBenchmarking,\n                              data_reduction_proxy::mojom::DataReductionProxy,\n                              metrics::mojom::CallStackProfileCollector,\n#if defined(OS_WIN)\n                              mojom::ModuleEventSink,\n#endif\n                              rappor::mojom::RapporRecorder,\n                              safe_browsing::mojom::SafeBrowsing>())\n        .RequireCapability(\"ash\", \"system_ui\")\n        .RequireCapability(\"ash\", \"test\")\n        .RequireCapability(\"ash\", \"display\")\n        .RequireCapability(\"assistant\", \"assistant\")\n        .RequireCapability(\"assistant_audio_decoder\", \"assistant:audio_decoder\")\n        .RequireCapability(\"chrome\", \"input_device_controller\")\n        .RequireCapability(\"chrome_printing\", \"converter\")\n        .RequireCapability(\"cups_ipp_parser\", \"ipp_parser\")\n        .RequireCapability(\"device\", \"device:fingerprint\")\n        .RequireCapability(\"device\", \"device:geolocation_config\")\n        .RequireCapability(\"device\", \"device:geolocation_control\")\n        .RequireCapability(\"device\", \"device:ip_geolocator\")\n        .RequireCapability(\"ime\", \"input_engine\")\n        .RequireCapability(\"mirroring\", \"mirroring\")\n        .RequireCapability(\"nacl_broker\", \"browser\")\n        .RequireCapability(\"nacl_loader\", \"browser\")\n        .RequireCapability(\"noop\", \"noop\")\n        .RequireCapability(\"patch\", \"patch_file\")\n        .RequireCapability(\"preferences\", \"pref_client\")\n        .RequireCapability(\"preferences\", \"pref_control\")\n        .RequireCapability(\"profile_import\", \"import\")\n        .RequireCapability(\"removable_storage_writer\",\n                           \"removable_storage_writer\")\n        .RequireCapability(\"secure_channel\", \"secure_channel\")\n        .RequireCapability(\"ui\", \"ime_registrar\")\n        .RequireCapability(\"ui\", \"input_device_controller\")\n        .RequireCapability(\"ui\", \"window_manager\")\n        .RequireCapability(\"unzip\", \"unzip_file\")\n        .RequireCapability(\"util_win\", \"util_win\")\n        .RequireCapability(\"xr_device_service\", \"xr_device_provider\")\n        .RequireCapability(\"xr_device_service\", \"xr_device_test_hook\")\n#if defined(OS_CHROMEOS)\n        .RequireCapability(\"multidevice_setup\", \"multidevice_setup\")\n#endif\n        .ExposeInterfaceFilterCapability_Deprecated(\n            \"navigation:frame\", \"renderer\",\n            service_manager::Manifest::InterfaceList<\n                autofill::mojom::AutofillDriver,\n                autofill::mojom::PasswordManagerDriver,\n                chrome::mojom::OfflinePageAutoFetcher,\n#if defined(OS_CHROMEOS)\n                 chromeos_camera::mojom::CameraAppHelper,\n                 chromeos::cellular_setup::mojom::CellularSetup,\n                 chromeos::crostini_installer::mojom::PageHandlerFactory,\n                 chromeos::ime::mojom::InputEngineManager,\n                 chromeos::machine_learning::mojom::PageHandler,\n                 chromeos::media_perception::mojom::MediaPerception,\n                chromeos::multidevice_setup::mojom::MultiDeviceSetup,\n                chromeos::multidevice_setup::mojom::PrivilegedHostDeviceSetter,\n                chromeos::network_config::mojom::CrosNetworkConfig,\n                cros::mojom::CameraAppDeviceProvider,\n#endif\n                contextual_search::mojom::ContextualSearchJsApiService,\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n                extensions::KeepAlive,\n#endif\n                media::mojom::MediaEngagementScoreDetailsProvider,\n                media_router::mojom::MediaRouter,\n                page_load_metrics::mojom::PageLoadMetrics,\n                translate::mojom::ContentTranslateDriver,\n\n                downloads::mojom::PageHandlerFactory,\n                feed_internals::mojom::PageHandler,\n                new_tab_page::mojom::PageHandlerFactory,\n#if defined(OS_ANDROID)\n                explore_sites_internals::mojom::PageHandler,\n#else\n                app_management::mojom::PageHandlerFactory,\n#endif\n#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \\\n    defined(OS_CHROMEOS)\n                discards::mojom::DetailsProvider, discards::mojom::GraphDump,\n#endif\n#if defined(OS_CHROMEOS)\n                add_supervision::mojom::AddSupervisionHandler,\n#endif\n                mojom::BluetoothInternalsHandler,\n                mojom::InterventionsInternalsPageHandler,\n                mojom::OmniboxPageHandler, mojom::ResetPasswordHandler,\n                mojom::SiteEngagementDetailsProvider,\n                mojom::UsbInternalsPageHandler,\n                snippets_internals::mojom::PageHandlerFactory>())\n        .PackageService(prefs::GetManifest())\n#if defined(OS_CHROMEOS)\n        .PackageService(chromeos::multidevice_setup::GetManifest())\n#endif  // defined(OS_CHROMEOS)\n        .Build()\n  };\n  return *manifest;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144236,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,\n                                             bool is_tld_ascii) {\n  UErrorCode status = U_ZERO_ERROR;\n  int32_t result =\n      uspoof_check(checker_, label.data(),\n                   base::checked_cast<int32_t>(label.size()), NULL, &status);\n  if (U_FAILURE(status) || (result & USPOOF_ALL_CHECKS))\n    return false;\n\n  icu::UnicodeString label_string(FALSE, label.data(),\n                                  base::checked_cast<int32_t>(label.size()));\n\n  if (deviation_characters_.containsSome(label_string))\n    return false;\n\n  result &= USPOOF_RESTRICTION_LEVEL_MASK;\n  if (result == USPOOF_ASCII)\n    return true;\n  if (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&\n      kana_letters_exceptions_.containsNone(label_string) &&\n      combining_diacritics_exceptions_.containsNone(label_string)) {\n    return !is_tld_ascii || !IsMadeOfLatinAlikeCyrillic(label_string);\n  }\n\n  if (non_ascii_latin_letters_.containsSome(label_string) &&\n      !lgc_letters_n_ascii_.containsAll(label_string))\n    return false;\n\n  if (!tls_index.initialized())\n    tls_index.Initialize(&OnThreadTermination);\n  icu::RegexMatcher* dangerous_pattern =\n      reinterpret_cast<icu::RegexMatcher*>(tls_index.Get());\n  if (!dangerous_pattern) {\n    dangerous_pattern = new icu::RegexMatcher(\n        icu::UnicodeString(\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}])\"\n            R\"([\\u30ce\\u30f3\\u30bd\\u30be])\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}]|)\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}]\\u30fc|^\\u30fc|)\"\n            R\"([^\\p{scx=kana}][\\u30fd\\u30fe]|^[\\u30fd\\u30fe]|)\"\n            R\"(^[\\p{scx=kana}]+[\\u3078-\\u307a][\\p{scx=kana}]+$|)\"\n            R\"(^[\\p{scx=hira}]+[\\u30d8-\\u30da][\\p{scx=hira}]+$|)\"\n            R\"([a-z]\\u30fb|\\u30fb[a-z]|)\"\n            R\"(^[\\u0585\\u0581]+[a-z]|[a-z][\\u0585\\u0581]+$|)\"\n            R\"([a-z][\\u0585\\u0581]+[a-z]|)\"\n             R\"(^[og]+[\\p{scx=armn}]|[\\p{scx=armn}][og]+$|)\"\n             R\"([\\p{scx=armn}][og]+[\\p{scx=armn}]|)\"\n             R\"([\\p{sc=cans}].*[a-z]|[a-z].*[\\p{sc=cans}]|)\"\n             R\"([^\\p{scx=latn}\\p{scx=grek}\\p{scx=cyrl}][\\u0300-\\u0339])\",\n             -1, US_INV),\n         0, status);\n    tls_index.Set(dangerous_pattern);\n  }\n  dangerous_pattern->reset(label_string);\n  return !dangerous_pattern->find();\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144237,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,\n                                             bool is_tld_ascii) {\n  UErrorCode status = U_ZERO_ERROR;\n  int32_t result =\n      uspoof_check(checker_, label.data(),\n                   base::checked_cast<int32_t>(label.size()), NULL, &status);\n  if (U_FAILURE(status) || (result & USPOOF_ALL_CHECKS))\n    return false;\n\n  icu::UnicodeString label_string(FALSE, label.data(),\n                                  base::checked_cast<int32_t>(label.size()));\n\n  if (deviation_characters_.containsSome(label_string))\n    return false;\n\n  result &= USPOOF_RESTRICTION_LEVEL_MASK;\n  if (result == USPOOF_ASCII)\n    return true;\n  if (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&\n      kana_letters_exceptions_.containsNone(label_string) &&\n      combining_diacritics_exceptions_.containsNone(label_string)) {\n    return !is_tld_ascii || !IsMadeOfLatinAlikeCyrillic(label_string);\n  }\n\n  if (non_ascii_latin_letters_.containsSome(label_string) &&\n      !lgc_letters_n_ascii_.containsAll(label_string))\n    return false;\n\n  if (!tls_index.initialized())\n    tls_index.Initialize(&OnThreadTermination);\n  icu::RegexMatcher* dangerous_pattern =\n      reinterpret_cast<icu::RegexMatcher*>(tls_index.Get());\n  if (!dangerous_pattern) {\n    // - Disalow mixing of Latin and Tifinagh.\n    dangerous_pattern = new icu::RegexMatcher(\n        icu::UnicodeString(\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}])\"\n            R\"([\\u30ce\\u30f3\\u30bd\\u30be])\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}]|)\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}]\\u30fc|^\\u30fc|)\"\n            R\"([^\\p{scx=kana}][\\u30fd\\u30fe]|^[\\u30fd\\u30fe]|)\"\n            R\"(^[\\p{scx=kana}]+[\\u3078-\\u307a][\\p{scx=kana}]+$|)\"\n            R\"(^[\\p{scx=hira}]+[\\u30d8-\\u30da][\\p{scx=hira}]+$|)\"\n            R\"([a-z]\\u30fb|\\u30fb[a-z]|)\"\n            R\"(^[\\u0585\\u0581]+[a-z]|[a-z][\\u0585\\u0581]+$|)\"\n            R\"([a-z][\\u0585\\u0581]+[a-z]|)\"\n             R\"(^[og]+[\\p{scx=armn}]|[\\p{scx=armn}][og]+$|)\"\n             R\"([\\p{scx=armn}][og]+[\\p{scx=armn}]|)\"\n             R\"([\\p{sc=cans}].*[a-z]|[a-z].*[\\p{sc=cans}]|)\"\n            R\"([\\p{sc=tfng}].*[a-z]|[a-z].*[\\p{sc=tfng}]|)\"\n             R\"([^\\p{scx=latn}\\p{scx=grek}\\p{scx=cyrl}][\\u0300-\\u0339])\",\n             -1, US_INV),\n         0, status);\n    tls_index.Set(dangerous_pattern);\n  }\n  dangerous_pattern->reset(label_string);\n  return !dangerous_pattern->find();\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144238,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void RenderWidgetHostImpl::DidNavigate(uint32_t next_source_id) {\n  current_content_source_id_ = next_source_id;\n  did_receive_first_frame_after_navigation_ = false;\n\n  if (enable_surface_synchronization_) {\n     visual_properties_ack_pending_ = false;\n    viz::LocalSurfaceId old_surface_id = view_->GetLocalSurfaceId();\n     if (view_)\n       view_->DidNavigate();\n    viz::LocalSurfaceId new_surface_id = view_->GetLocalSurfaceId();\n    if (old_surface_id == new_surface_id)\n      return;\n   } else {\n    if (last_received_content_source_id_ >= current_content_source_id_)\n      return;\n  }\n\n  if (!new_content_rendering_timeout_)\n    return;\n\n  new_content_rendering_timeout_->Start(new_content_rendering_delay_);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144239,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void RenderWidgetHostImpl::DidNavigate(uint32_t next_source_id) {\n  current_content_source_id_ = next_source_id;\n  did_receive_first_frame_after_navigation_ = false;\n\n  if (enable_surface_synchronization_) {\n     visual_properties_ack_pending_ = false;\n     if (view_)\n       view_->DidNavigate();\n   } else {\n    if (last_received_content_source_id_ >= current_content_source_id_)\n      return;\n  }\n\n  if (!new_content_rendering_timeout_)\n    return;\n\n  new_content_rendering_timeout_->Start(new_content_rendering_delay_);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144240,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void MimeHandlerViewContainer::OnReady() {\n  if (!render_frame() || !is_embedded_)\n    return;\n\n  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();\n\n  blink::WebAssociatedURLLoaderOptions options;\n  DCHECK(!loader_);\n  loader_.reset(frame->CreateAssociatedURLLoader(options));\n\n   blink::WebURLRequest request(original_url_);\n   request.SetRequestContext(blink::WebURLRequest::kRequestContextObject);\n   loader_->LoadAsynchronously(request, this);\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144241,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void MimeHandlerViewContainer::OnReady() {\n  if (!render_frame() || !is_embedded_)\n    return;\n\n  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();\n\n  blink::WebAssociatedURLLoaderOptions options;\n  DCHECK(!loader_);\n  loader_.reset(frame->CreateAssociatedURLLoader(options));\n\n   blink::WebURLRequest request(original_url_);\n   request.SetRequestContext(blink::WebURLRequest::kRequestContextObject);\n  // The plugin resource request should skip service workers since \"plug-ins\n  // may get their security origins from their own urls\".\n  // https://w3c.github.io/ServiceWorker/#implementer-concerns\n  request.SetServiceWorkerMode(blink::WebURLRequest::ServiceWorkerMode::kNone);\n   loader_->LoadAsynchronously(request, this);\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144242,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void ImageLoader::DoUpdateFromElement(BypassMainWorldBehavior bypass_behavior,\n                                      UpdateFromElementBehavior update_behavior,\n                                      const KURL& url,\n                                      ReferrerPolicy referrer_policy,\n                                      UpdateType update_type) {\n  pending_task_.reset();\n  std::unique_ptr<IncrementLoadEventDelayCount> load_delay_counter;\n  load_delay_counter.swap(delay_until_do_update_from_element_);\n\n  Document& document = element_->GetDocument();\n  if (!document.IsActive())\n    return;\n\n  AtomicString image_source_url = element_->ImageSourceURL();\n  ImageResourceContent* new_image_content = nullptr;\n  if (!url.IsNull() && !url.IsEmpty()) {\n    ResourceLoaderOptions resource_loader_options;\n    resource_loader_options.initiator_info.name = GetElement()->localName();\n    ResourceRequest resource_request(url);\n    if (update_behavior == kUpdateForcedReload) {\n      resource_request.SetCacheMode(mojom::FetchCacheMode::kBypassCache);\n      resource_request.SetPreviewsState(WebURLRequest::kPreviewsNoTransform);\n    }\n\n    if (referrer_policy != kReferrerPolicyDefault) {\n      resource_request.SetHTTPReferrer(SecurityPolicy::GenerateReferrer(\n           referrer_policy, url, document.OutgoingReferrer()));\n     }\n \n     if (IsHTMLPictureElement(GetElement()->parentNode()) ||\n        !GetElement()->FastGetAttribute(HTMLNames::srcsetAttr).IsNull())\n       resource_request.SetRequestContext(\n           WebURLRequest::kRequestContextImageSet);\n \n     bool page_is_being_dismissed =\n         document.PageDismissalEventBeingDispatched() != Document::kNoDismissal;\n    if (page_is_being_dismissed) {\n      resource_request.SetHTTPHeaderField(HTTPNames::Cache_Control,\n                                          \"max-age=0\");\n      resource_request.SetKeepalive(true);\n      resource_request.SetRequestContext(WebURLRequest::kRequestContextPing);\n    }\n\n    FetchParameters params(resource_request, resource_loader_options);\n    ConfigureRequest(params, bypass_behavior, *element_,\n                     document.GetClientHintsPreferences());\n\n    if (update_behavior != kUpdateForcedReload && document.GetFrame())\n      document.GetFrame()->MaybeAllowImagePlaceholder(params);\n\n    new_image_content = ImageResourceContent::Fetch(params, document.Fetcher());\n\n    if (page_is_being_dismissed)\n      new_image_content = nullptr;\n\n    ClearFailedLoadURL();\n  } else {\n    if (!image_source_url.IsNull()) {\n      DispatchErrorEvent();\n    }\n    NoImageResourceToLoad();\n  }\n\n  ImageResourceContent* old_image_content = image_content_.Get();\n  if (old_image_content != new_image_content)\n    RejectPendingDecodes(update_type);\n\n  if (update_behavior == kUpdateSizeChanged && element_->GetLayoutObject() &&\n      element_->GetLayoutObject()->IsImage() &&\n      new_image_content == old_image_content) {\n    ToLayoutImage(element_->GetLayoutObject())->IntrinsicSizeChanged();\n  } else {\n    if (pending_load_event_.IsActive())\n      pending_load_event_.Cancel();\n\n    if (pending_error_event_.IsActive() && new_image_content)\n      pending_error_event_.Cancel();\n\n    UpdateImageState(new_image_content);\n\n    UpdateLayoutObject();\n    if (new_image_content) {\n      new_image_content->AddObserver(this);\n    }\n    if (old_image_content) {\n      old_image_content->RemoveObserver(this);\n    }\n  }\n\n  if (LayoutImageResource* image_resource = GetLayoutImageResource())\n    image_resource->ResetAnimation();\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144243,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void ImageLoader::DoUpdateFromElement(BypassMainWorldBehavior bypass_behavior,\n                                      UpdateFromElementBehavior update_behavior,\n                                      const KURL& url,\n                                      ReferrerPolicy referrer_policy,\n                                      UpdateType update_type) {\n  pending_task_.reset();\n  std::unique_ptr<IncrementLoadEventDelayCount> load_delay_counter;\n  load_delay_counter.swap(delay_until_do_update_from_element_);\n\n  Document& document = element_->GetDocument();\n  if (!document.IsActive())\n    return;\n\n  AtomicString image_source_url = element_->ImageSourceURL();\n  ImageResourceContent* new_image_content = nullptr;\n  if (!url.IsNull() && !url.IsEmpty()) {\n    ResourceLoaderOptions resource_loader_options;\n    resource_loader_options.initiator_info.name = GetElement()->localName();\n    ResourceRequest resource_request(url);\n    if (update_behavior == kUpdateForcedReload) {\n      resource_request.SetCacheMode(mojom::FetchCacheMode::kBypassCache);\n      resource_request.SetPreviewsState(WebURLRequest::kPreviewsNoTransform);\n    }\n\n    if (referrer_policy != kReferrerPolicyDefault) {\n      resource_request.SetHTTPReferrer(SecurityPolicy::GenerateReferrer(\n           referrer_policy, url, document.OutgoingReferrer()));\n     }\n \n    // Correct the RequestContext if necessary.\n     if (IsHTMLPictureElement(GetElement()->parentNode()) ||\n        !GetElement()->FastGetAttribute(HTMLNames::srcsetAttr).IsNull()) {\n       resource_request.SetRequestContext(\n           WebURLRequest::kRequestContextImageSet);\n    } else if (IsHTMLObjectElement(GetElement())) {\n      resource_request.SetRequestContext(WebURLRequest::kRequestContextObject);\n    } else if (IsHTMLEmbedElement(GetElement())) {\n      resource_request.SetRequestContext(WebURLRequest::kRequestContextEmbed);\n    }\n \n     bool page_is_being_dismissed =\n         document.PageDismissalEventBeingDispatched() != Document::kNoDismissal;\n    if (page_is_being_dismissed) {\n      resource_request.SetHTTPHeaderField(HTTPNames::Cache_Control,\n                                          \"max-age=0\");\n      resource_request.SetKeepalive(true);\n      resource_request.SetRequestContext(WebURLRequest::kRequestContextPing);\n    }\n\n    FetchParameters params(resource_request, resource_loader_options);\n    ConfigureRequest(params, bypass_behavior, *element_,\n                     document.GetClientHintsPreferences());\n\n    if (update_behavior != kUpdateForcedReload && document.GetFrame())\n      document.GetFrame()->MaybeAllowImagePlaceholder(params);\n\n    new_image_content = ImageResourceContent::Fetch(params, document.Fetcher());\n\n    if (page_is_being_dismissed)\n      new_image_content = nullptr;\n\n    ClearFailedLoadURL();\n  } else {\n    if (!image_source_url.IsNull()) {\n      DispatchErrorEvent();\n    }\n    NoImageResourceToLoad();\n  }\n\n  ImageResourceContent* old_image_content = image_content_.Get();\n  if (old_image_content != new_image_content)\n    RejectPendingDecodes(update_type);\n\n  if (update_behavior == kUpdateSizeChanged && element_->GetLayoutObject() &&\n      element_->GetLayoutObject()->IsImage() &&\n      new_image_content == old_image_content) {\n    ToLayoutImage(element_->GetLayoutObject())->IntrinsicSizeChanged();\n  } else {\n    if (pending_load_event_.IsActive())\n      pending_load_event_.Cancel();\n\n    if (pending_error_event_.IsActive() && new_image_content)\n      pending_error_event_.Cancel();\n\n    UpdateImageState(new_image_content);\n\n    UpdateLayoutObject();\n    if (new_image_content) {\n      new_image_content->AddObserver(this);\n    }\n    if (old_image_content) {\n      old_image_content->RemoveObserver(this);\n    }\n  }\n\n  if (LayoutImageResource* image_resource = GetLayoutImageResource())\n    image_resource->ResetAnimation();\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144244,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void NavigationRequest::OnRequestRedirected(\n    const net::RedirectInfo& redirect_info,\n    const scoped_refptr<network::ResourceResponse>& response) {\n  response_ = response;\n  ssl_info_ = response->head.ssl_info;\n#if defined(OS_ANDROID)\n  base::WeakPtr<NavigationRequest> this_ptr(weak_factory_.GetWeakPtr());\n\n  bool should_override_url_loading = false;\n  if (!GetContentClient()->browser()->ShouldOverrideUrlLoading(\n          frame_tree_node_->frame_tree_node_id(), browser_initiated_,\n          redirect_info.new_url, redirect_info.new_method,\n          false, true, frame_tree_node_->IsMainFrame(),\n          common_params_.transition, &should_override_url_loading)) {\n    return;\n  }\n\n  if (!this_ptr)\n    return;\n\n  if (should_override_url_loading) {\n    navigation_handle_->set_net_error_code(net::ERR_ABORTED);\n    common_params_.url = redirect_info.new_url;\n    common_params_.method = redirect_info.new_method;\n    navigation_handle_->UpdateStateFollowingRedirect(\n        GURL(redirect_info.new_referrer),\n        base::Bind(&NavigationRequest::OnRedirectChecksComplete,\n                   base::Unretained(this)));\n    frame_tree_node_->ResetNavigationRequest(false, true);\n    return;\n  }\n#endif\n  if (!ChildProcessSecurityPolicyImpl::GetInstance()->CanRedirectToURL(\n           redirect_info.new_url)) {\n     DVLOG(1) << \"Denied redirect for \"\n              << redirect_info.new_url.possibly_invalid_spec();\n    navigation_handle_->set_net_error_code(net::ERR_UNSAFE_REDIRECT);\n    frame_tree_node_->ResetNavigationRequest(false, true);\n     return;\n   }\n \n  if (!browser_initiated_ && source_site_instance() &&\n      !ChildProcessSecurityPolicyImpl::GetInstance()->CanRequestURL(\n          source_site_instance()->GetProcess()->GetID(),\n           redirect_info.new_url)) {\n     DVLOG(1) << \"Denied unauthorized redirect for \"\n              << redirect_info.new_url.possibly_invalid_spec();\n    navigation_handle_->set_net_error_code(net::ERR_UNSAFE_REDIRECT);\n    frame_tree_node_->ResetNavigationRequest(false, true);\n     return;\n   }\n \n  if (redirect_info.new_method != \"POST\")\n    common_params_.post_data = nullptr;\n\n  if (commit_params_.navigation_timing.redirect_start.is_null()) {\n    commit_params_.navigation_timing.redirect_start =\n        commit_params_.navigation_timing.fetch_start;\n  }\n  commit_params_.navigation_timing.redirect_end = base::TimeTicks::Now();\n  commit_params_.navigation_timing.fetch_start = base::TimeTicks::Now();\n\n  commit_params_.redirect_response.push_back(response->head);\n  commit_params_.redirect_infos.push_back(redirect_info);\n\n  if (commit_params_.origin_to_commit)\n    commit_params_.origin_to_commit.reset();\n\n  commit_params_.redirects.push_back(common_params_.url);\n  common_params_.url = redirect_info.new_url;\n  common_params_.method = redirect_info.new_method;\n  common_params_.referrer.url = GURL(redirect_info.new_referrer);\n  common_params_.referrer =\n      Referrer::SanitizeForRequest(common_params_.url, common_params_.referrer);\n\n  net::Error net_error =\n      CheckContentSecurityPolicy(true /* has_followed_redirect */,\n                                 redirect_info.insecure_scheme_was_upgraded,\n                                 false /* is_response_check */);\n  if (net_error != net::OK) {\n    OnRequestFailedInternal(\n        network::URLLoaderCompletionStatus(net_error), false /*skip_throttles*/,\n        base::nullopt /*error_page_content*/, false /*collapse_frame*/);\n\n    return;\n  }\n\n  if (CheckCredentialedSubresource() ==\n          CredentialedSubresourceCheckResult::BLOCK_REQUEST ||\n      CheckLegacyProtocolInSubresource() ==\n          LegacyProtocolInSubresourceCheckResult::BLOCK_REQUEST) {\n    OnRequestFailedInternal(\n        network::URLLoaderCompletionStatus(net::ERR_ABORTED),\n        false /*skip_throttles*/, base::nullopt /*error_page_content*/,\n        false /*collapse_frame*/);\n\n    return;\n  }\n\n  scoped_refptr<SiteInstance> site_instance =\n      frame_tree_node_->render_manager()->GetSiteInstanceForNavigationRequest(\n          *this);\n  speculative_site_instance_ =\n      site_instance->HasProcess() ? site_instance : nullptr;\n\n  if (!site_instance->HasProcess()) {\n    RenderProcessHostImpl::NotifySpareManagerAboutRecentlyUsedBrowserContext(\n        site_instance->GetBrowserContext());\n  }\n\n  common_params_.previews_state =\n      GetContentClient()->browser()->DetermineAllowedPreviews(\n          common_params_.previews_state, navigation_handle_.get(),\n          common_params_.url);\n\n  RenderProcessHost* expected_process =\n      site_instance->HasProcess() ? site_instance->GetProcess() : nullptr;\n\n  navigation_handle_->WillRedirectRequest(\n      common_params_.referrer.url, expected_process,\n      base::Bind(&NavigationRequest::OnRedirectChecksComplete,\n                 base::Unretained(this)));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144249,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void NavigationRequest::OnRequestRedirected(\n    const net::RedirectInfo& redirect_info,\n    const scoped_refptr<network::ResourceResponse>& response) {\n  response_ = response;\n  ssl_info_ = response->head.ssl_info;\n#if defined(OS_ANDROID)\n  base::WeakPtr<NavigationRequest> this_ptr(weak_factory_.GetWeakPtr());\n\n  bool should_override_url_loading = false;\n  if (!GetContentClient()->browser()->ShouldOverrideUrlLoading(\n          frame_tree_node_->frame_tree_node_id(), browser_initiated_,\n          redirect_info.new_url, redirect_info.new_method,\n          false, true, frame_tree_node_->IsMainFrame(),\n          common_params_.transition, &should_override_url_loading)) {\n    return;\n  }\n\n  if (!this_ptr)\n    return;\n\n  if (should_override_url_loading) {\n    navigation_handle_->set_net_error_code(net::ERR_ABORTED);\n    common_params_.url = redirect_info.new_url;\n    common_params_.method = redirect_info.new_method;\n    navigation_handle_->UpdateStateFollowingRedirect(\n        GURL(redirect_info.new_referrer),\n        base::Bind(&NavigationRequest::OnRedirectChecksComplete,\n                   base::Unretained(this)));\n    frame_tree_node_->ResetNavigationRequest(false, true);\n    return;\n  }\n#endif\n  if (!ChildProcessSecurityPolicyImpl::GetInstance()->CanRedirectToURL(\n           redirect_info.new_url)) {\n     DVLOG(1) << \"Denied redirect for \"\n              << redirect_info.new_url.possibly_invalid_spec();\n    // Show an error page rather than leaving the previous page in place.\n    OnRequestFailedInternal(\n        network::URLLoaderCompletionStatus(net::ERR_UNSAFE_REDIRECT),\n        false /* skip_throttles */, base::nullopt /* error_page_content */,\n        false /* collapse_frame */);\n    // DO NOT ADD CODE after this. The previous call to OnRequestFailedInternal\n    // has destroyed the NavigationRequest.\n     return;\n   }\n \n  if (!browser_initiated_ && source_site_instance() &&\n      !ChildProcessSecurityPolicyImpl::GetInstance()->CanRequestURL(\n          source_site_instance()->GetProcess()->GetID(),\n           redirect_info.new_url)) {\n     DVLOG(1) << \"Denied unauthorized redirect for \"\n              << redirect_info.new_url.possibly_invalid_spec();\n    // Show an error page rather than leaving the previous page in place.\n    OnRequestFailedInternal(\n        network::URLLoaderCompletionStatus(net::ERR_UNSAFE_REDIRECT),\n        false /* skip_throttles */, base::nullopt /* error_page_content */,\n        false /* collapse_frame */);\n    // DO NOT ADD CODE after this. The previous call to OnRequestFailedInternal\n    // has destroyed the NavigationRequest.\n     return;\n   }\n \n  if (redirect_info.new_method != \"POST\")\n    common_params_.post_data = nullptr;\n\n  if (commit_params_.navigation_timing.redirect_start.is_null()) {\n    commit_params_.navigation_timing.redirect_start =\n        commit_params_.navigation_timing.fetch_start;\n  }\n  commit_params_.navigation_timing.redirect_end = base::TimeTicks::Now();\n  commit_params_.navigation_timing.fetch_start = base::TimeTicks::Now();\n\n  commit_params_.redirect_response.push_back(response->head);\n  commit_params_.redirect_infos.push_back(redirect_info);\n\n  if (commit_params_.origin_to_commit)\n    commit_params_.origin_to_commit.reset();\n\n  commit_params_.redirects.push_back(common_params_.url);\n  common_params_.url = redirect_info.new_url;\n  common_params_.method = redirect_info.new_method;\n  common_params_.referrer.url = GURL(redirect_info.new_referrer);\n  common_params_.referrer =\n      Referrer::SanitizeForRequest(common_params_.url, common_params_.referrer);\n\n  net::Error net_error =\n      CheckContentSecurityPolicy(true /* has_followed_redirect */,\n                                 redirect_info.insecure_scheme_was_upgraded,\n                                 false /* is_response_check */);\n  if (net_error != net::OK) {\n    OnRequestFailedInternal(\n        network::URLLoaderCompletionStatus(net_error), false /*skip_throttles*/,\n        base::nullopt /*error_page_content*/, false /*collapse_frame*/);\n\n    return;\n  }\n\n  if (CheckCredentialedSubresource() ==\n          CredentialedSubresourceCheckResult::BLOCK_REQUEST ||\n      CheckLegacyProtocolInSubresource() ==\n          LegacyProtocolInSubresourceCheckResult::BLOCK_REQUEST) {\n    OnRequestFailedInternal(\n        network::URLLoaderCompletionStatus(net::ERR_ABORTED),\n        false /*skip_throttles*/, base::nullopt /*error_page_content*/,\n        false /*collapse_frame*/);\n\n    return;\n  }\n\n  scoped_refptr<SiteInstance> site_instance =\n      frame_tree_node_->render_manager()->GetSiteInstanceForNavigationRequest(\n          *this);\n  speculative_site_instance_ =\n      site_instance->HasProcess() ? site_instance : nullptr;\n\n  if (!site_instance->HasProcess()) {\n    RenderProcessHostImpl::NotifySpareManagerAboutRecentlyUsedBrowserContext(\n        site_instance->GetBrowserContext());\n  }\n\n  common_params_.previews_state =\n      GetContentClient()->browser()->DetermineAllowedPreviews(\n          common_params_.previews_state, navigation_handle_.get(),\n          common_params_.url);\n\n  RenderProcessHost* expected_process =\n      site_instance->HasProcess() ? site_instance->GetProcess() : nullptr;\n\n  navigation_handle_->WillRedirectRequest(\n      common_params_.referrer.url, expected_process,\n      base::Bind(&NavigationRequest::OnRedirectChecksComplete,\n                 base::Unretained(this)));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144250,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u0517\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n       icu::UnicodeString::fromUTF8(\n          \"[\u00e6\u04d5] > ae; [\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u050b\u0527\u0529] > h;\"\n          \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f\u0525\u0e01] > n; \u0153 > ce;\"\n          \"[\u0167\u0442\u04ad\u050f] > t; [\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1e\u0e1f\u0e9e\u0e9f] > w;\"\n           \"[\u043c\u04ce] > m; [\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; [\u0493\u04fb] > f;\"\n           \"[\u04ab\u1004] > c; \u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n           \"\u0503  > d; [\u050d\u100c] > g; [\u0d1f\u0e23\u0ea3\u0eae] > s; \u1042 > j;\"\n          \"[\u0437\u0499\u04e1\u0909\u0993\u1012\u10d5\u10de] > 3; [\u0e1a\u0e9a] > u\"),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144251,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u0517\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n  //   - {U+0966 (\u0966), U+09E6 (\u09e6), U+0A66 (\u0a66), U+0AE6 (\u0ae6), U+0B30 (\u0b20),\n  //      U+0B66 (\u0b66), U+0CE6 (\u0ce6)} => o,\n  //   - {U+09ED (\u09ed), U+0A67 (\u0a67), U+0AE7 (\u0ae7)} => q,\n  //   - {U+0E1A (\u0e1a), U+0E9A (\u0e9a)} => u\n  //   - {U+0968 (\u0968), U+09E8 (\u09e8), U+0A68 (\u0a68), U+0A68 (\u0a68), U+0AE8 (\u0ae8),\n  //      U+0ce9 (\u0ce9), U+0ced (\u0ced)} => 2,\n  //      U+0A69 (\u0a69), U+0AE9 (\u0ae9), U+0C69 (\u0c69),\n  //   - {U+0A6B (\u0a6b)} => 4,\n  //   - {U+09EA (\u09ea), U+0A6A (\u0a6a), U+0b6b (\u0b6b)} => 8,\n  //   - {U+0AED (\u0aed), U+0b68 (\u0b68), U+0C68 (\u0c68)} => 9,\n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n       icu::UnicodeString::fromUTF8(\n          \"[\u00e6\u04d5] > ae; [\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u050b\u0527\u0529] > h;\"\n          \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f\u0525\u0e01] > n; \u0153 > ce;\"\n          \"[\u0167\u0442\u04ad\u050f] > t; [\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1e\u0e1f\u0e9e\u0e9f] > w;\"\n           \"[\u043c\u04ce] > m; [\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; [\u0493\u04fb] > f;\"\n           \"[\u04ab\u1004] > c; \u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n           \"\u0503  > d; [\u050d\u100c] > g; [\u0d1f\u0e23\u0ea3\u0eae] > s; \u1042 > j;\"\n          \"[\u0966\u09e6\u0a66\u0ae6\u0b20\u0b66\u0ce6] > o;\"\n          \"[\u09ed\u0a67\u0ae7] > q;\"\n          \"[\u0e1a\u0e9a] > u;\"\n          \"[\u0968\u09e8\u0a68\u0a68\u0ae8\u0ce9\u0ced] > 2;\"\n          \"[\u0437\u0499\u04e1\u0909\u0993\u0a69\u0ae9\u0c69\u1012\u10d5\u10de] > 3;\"\n          \"[\u0a6b] > 4;\"\n          \"[\u09ea\u0a6a\u0b6b] > 8;\"\n          \"[\u0aed\u0b68\u0c68] > 9;\"\n      ),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144252,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool BrowserCommandController::ExecuteCommandWithDisposition(\n    int id, WindowOpenDisposition disposition) {\n  if (!SupportsCommand(id) || !IsCommandEnabled(id))\n    return false;\n\n  if (browser_->tab_strip_model()->active_index() == TabStripModel::kNoTab)\n    return true;\n\n  DCHECK(command_updater_.IsCommandEnabled(id)) << \"Invalid/disabled command \"\n                                                << id;\n\n  switch (id) {\n    case IDC_BACK:\n      GoBack(browser_, disposition);\n      break;\n    case IDC_FORWARD:\n      GoForward(browser_, disposition);\n      break;\n    case IDC_RELOAD:\n      Reload(browser_, disposition);\n      break;\n    case IDC_RELOAD_CLEARING_CACHE:\n      ClearCache(browser_);\n      FALLTHROUGH;\n    case IDC_RELOAD_BYPASSING_CACHE:\n      ReloadBypassingCache(browser_, disposition);\n      break;\n    case IDC_HOME:\n      Home(browser_, disposition);\n      break;\n    case IDC_OPEN_CURRENT_URL:\n      OpenCurrentURL(browser_);\n      break;\n    case IDC_STOP:\n      Stop(browser_);\n      break;\n\n    case IDC_NEW_WINDOW:\n      NewWindow(browser_);\n      break;\n    case IDC_NEW_INCOGNITO_WINDOW:\n      NewIncognitoWindow(profile());\n      break;\n    case IDC_CLOSE_WINDOW:\n      base::RecordAction(base::UserMetricsAction(\"CloseWindowByKey\"));\n      CloseWindow(browser_);\n      break;\n    case IDC_NEW_TAB: {\n      NewTab(browser_);\n#if BUILDFLAG(ENABLE_DESKTOP_IN_PRODUCT_HELP)\n      auto* new_tab_tracker =\n          feature_engagement::NewTabTrackerFactory::GetInstance()\n              ->GetForProfile(profile());\n\n      new_tab_tracker->OnNewTabOpened();\n      new_tab_tracker->CloseBubble();\n#endif\n      break;\n    }\n    case IDC_CLOSE_TAB:\n      base::RecordAction(base::UserMetricsAction(\"CloseTabByKey\"));\n      CloseTab(browser_);\n      break;\n    case IDC_SELECT_NEXT_TAB:\n      base::RecordAction(base::UserMetricsAction(\"Accel_SelectNextTab\"));\n      SelectNextTab(browser_);\n      break;\n    case IDC_SELECT_PREVIOUS_TAB:\n      base::RecordAction(base::UserMetricsAction(\"Accel_SelectPreviousTab\"));\n      SelectPreviousTab(browser_);\n      break;\n    case IDC_MOVE_TAB_NEXT:\n      MoveTabNext(browser_);\n      break;\n    case IDC_MOVE_TAB_PREVIOUS:\n      MoveTabPrevious(browser_);\n      break;\n    case IDC_SELECT_TAB_0:\n    case IDC_SELECT_TAB_1:\n    case IDC_SELECT_TAB_2:\n    case IDC_SELECT_TAB_3:\n    case IDC_SELECT_TAB_4:\n    case IDC_SELECT_TAB_5:\n    case IDC_SELECT_TAB_6:\n    case IDC_SELECT_TAB_7:\n      base::RecordAction(base::UserMetricsAction(\"Accel_SelectNumberedTab\"));\n      SelectNumberedTab(browser_, id - IDC_SELECT_TAB_0);\n      break;\n    case IDC_SELECT_LAST_TAB:\n      base::RecordAction(base::UserMetricsAction(\"Accel_SelectNumberedTab\"));\n      SelectLastTab(browser_);\n      break;\n    case IDC_DUPLICATE_TAB:\n      DuplicateTab(browser_);\n      break;\n    case IDC_RESTORE_TAB:\n      RestoreTab(browser_);\n      break;\n    case IDC_SHOW_AS_TAB:\n      ConvertPopupToTabbedBrowser(browser_);\n      break;\n    case IDC_FULLSCREEN:\n      chrome::ToggleFullscreenMode(browser_);\n      break;\n    case IDC_OPEN_IN_PWA_WINDOW:\n      base::RecordAction(base::UserMetricsAction(\"OpenActiveTabInPwaWindow\"));\n      ReparentSecureActiveTabIntoPwaWindow(browser_);\n      break;\n\n#if defined(OS_CHROMEOS)\n    case IDC_VISIT_DESKTOP_OF_LRU_USER_2:\n    case IDC_VISIT_DESKTOP_OF_LRU_USER_3:\n      ExecuteVisitDesktopCommand(id, window()->GetNativeWindow());\n      break;\n#endif\n\n#if defined(OS_LINUX) && !defined(OS_CHROMEOS)\n    case IDC_MINIMIZE_WINDOW:\n      browser_->window()->Minimize();\n      break;\n    case IDC_MAXIMIZE_WINDOW:\n      browser_->window()->Maximize();\n      break;\n    case IDC_RESTORE_WINDOW:\n      browser_->window()->Restore();\n      break;\n    case IDC_USE_SYSTEM_TITLE_BAR: {\n      PrefService* prefs = profile()->GetPrefs();\n      prefs->SetBoolean(prefs::kUseCustomChromeFrame,\n                        !prefs->GetBoolean(prefs::kUseCustomChromeFrame));\n      break;\n    }\n#endif\n\n#if defined(OS_MACOSX)\n    case IDC_TOGGLE_FULLSCREEN_TOOLBAR:\n       chrome::ToggleFullscreenToolbar(browser_);\n       break;\n     case IDC_TOGGLE_JAVASCRIPT_APPLE_EVENTS: {\n      PrefService* prefs = profile()->GetPrefs();\n      prefs->SetBoolean(prefs::kAllowJavascriptAppleEvents,\n                        !prefs->GetBoolean(prefs::kAllowJavascriptAppleEvents));\n       break;\n     }\n #endif\n    case IDC_EXIT:\n      Exit();\n      break;\n\n    case IDC_SAVE_PAGE:\n      SavePage(browser_);\n      break;\n    case IDC_BOOKMARK_PAGE:\n#if BUILDFLAG(ENABLE_DESKTOP_IN_PRODUCT_HELP)\n      feature_engagement::BookmarkTrackerFactory::GetInstance()\n          ->GetForProfile(profile())\n          ->OnBookmarkAdded();\n#endif\n      BookmarkCurrentPageAllowingExtensionOverrides(browser_);\n      break;\n    case IDC_BOOKMARK_ALL_TABS:\n#if BUILDFLAG(ENABLE_DESKTOP_IN_PRODUCT_HELP)\n      feature_engagement::BookmarkTrackerFactory::GetInstance()\n          ->GetForProfile(profile())\n          ->OnBookmarkAdded();\n#endif\n      BookmarkAllTabs(browser_);\n      break;\n    case IDC_VIEW_SOURCE:\n      browser_->tab_strip_model()\n          ->GetActiveWebContents()\n          ->GetMainFrame()\n          ->ViewSource();\n      break;\n    case IDC_EMAIL_PAGE_LOCATION:\n      EmailPageLocation(browser_);\n      break;\n    case IDC_PRINT:\n      Print(browser_);\n      break;\n\n#if BUILDFLAG(ENABLE_PRINTING)\n    case IDC_BASIC_PRINT:\n      base::RecordAction(base::UserMetricsAction(\"Accel_Advanced_Print\"));\n      BasicPrint(browser_);\n      break;\n#endif  // ENABLE_PRINTING\n\n    case IDC_SAVE_CREDIT_CARD_FOR_PAGE:\n      SaveCreditCard(browser_);\n      break;\n    case IDC_MIGRATE_LOCAL_CREDIT_CARD_FOR_PAGE:\n      MigrateLocalCards(browser_);\n      break;\n    case IDC_TRANSLATE_PAGE:\n      Translate(browser_);\n      break;\n    case IDC_MANAGE_PASSWORDS_FOR_PAGE:\n      ManagePasswordsForPage(browser_);\n      break;\n\n    case IDC_CUT:\n    case IDC_COPY:\n    case IDC_PASTE:\n      CutCopyPaste(browser_, id);\n      break;\n\n    case IDC_FIND:\n      Find(browser_);\n      break;\n    case IDC_FIND_NEXT:\n      FindNext(browser_);\n      break;\n    case IDC_FIND_PREVIOUS:\n      FindPrevious(browser_);\n      break;\n\n    case IDC_ZOOM_PLUS:\n      Zoom(browser_, content::PAGE_ZOOM_IN);\n      break;\n    case IDC_ZOOM_NORMAL:\n      Zoom(browser_, content::PAGE_ZOOM_RESET);\n      break;\n    case IDC_ZOOM_MINUS:\n      Zoom(browser_, content::PAGE_ZOOM_OUT);\n      break;\n\n    case IDC_FOCUS_TOOLBAR:\n      base::RecordAction(base::UserMetricsAction(\"Accel_Focus_Toolbar\"));\n      FocusToolbar(browser_);\n      break;\n    case IDC_FOCUS_LOCATION:\n      base::RecordAction(base::UserMetricsAction(\"Accel_Focus_Location\"));\n      FocusLocationBar(browser_);\n      break;\n    case IDC_FOCUS_SEARCH:\n      base::RecordAction(base::UserMetricsAction(\"Accel_Focus_Search\"));\n      FocusSearch(browser_);\n      break;\n    case IDC_FOCUS_MENU_BAR:\n      FocusAppMenu(browser_);\n      break;\n    case IDC_FOCUS_BOOKMARKS:\n      base::RecordAction(base::UserMetricsAction(\"Accel_Focus_Bookmarks\"));\n      FocusBookmarksToolbar(browser_);\n      break;\n    case IDC_FOCUS_INACTIVE_POPUP_FOR_ACCESSIBILITY:\n      FocusInactivePopupForAccessibility(browser_);\n      break;\n    case IDC_FOCUS_NEXT_PANE:\n      FocusNextPane(browser_);\n      break;\n    case IDC_FOCUS_PREVIOUS_PANE:\n      FocusPreviousPane(browser_);\n      break;\n\n    case IDC_OPEN_FILE:\n      browser_->OpenFile();\n      break;\n    case IDC_CREATE_SHORTCUT:\n      CreateBookmarkAppFromCurrentWebContents(browser_,\n                                              true /* force_shortcut_app */);\n      break;\n    case IDC_INSTALL_PWA:\n      CreateBookmarkAppFromCurrentWebContents(browser_,\n                                              false /* force_shortcut_app */);\n      break;\n    case IDC_DEV_TOOLS:\n      ToggleDevToolsWindow(browser_, DevToolsToggleAction::Show());\n      break;\n    case IDC_DEV_TOOLS_CONSOLE:\n      ToggleDevToolsWindow(browser_, DevToolsToggleAction::ShowConsolePanel());\n      break;\n    case IDC_DEV_TOOLS_DEVICES:\n      InspectUI::InspectDevices(browser_);\n      break;\n    case IDC_DEV_TOOLS_INSPECT:\n      ToggleDevToolsWindow(browser_, DevToolsToggleAction::Inspect());\n      break;\n    case IDC_DEV_TOOLS_TOGGLE:\n      ToggleDevToolsWindow(browser_, DevToolsToggleAction::Toggle());\n      break;\n    case IDC_TASK_MANAGER:\n      OpenTaskManager(browser_);\n      break;\n#if defined(OS_CHROMEOS)\n    case IDC_TAKE_SCREENSHOT:\n      TakeScreenshot();\n      break;\n#endif\n#if defined(GOOGLE_CHROME_BUILD)\n    case IDC_FEEDBACK:\n      OpenFeedbackDialog(browser_, kFeedbackSourceBrowserCommand);\n      break;\n#endif\n    case IDC_SHOW_BOOKMARK_BAR:\n      ToggleBookmarkBar(browser_);\n      break;\n    case IDC_PROFILING_ENABLED:\n      Profiling::Toggle();\n      break;\n\n    case IDC_SHOW_BOOKMARK_MANAGER:\n      ShowBookmarkManager(browser_);\n      break;\n    case IDC_SHOW_APP_MENU:\n      base::RecordAction(base::UserMetricsAction(\"Accel_Show_App_Menu\"));\n      ShowAppMenu(browser_);\n      break;\n    case IDC_SHOW_AVATAR_MENU:\n      ShowAvatarMenu(browser_);\n      break;\n    case IDC_SHOW_HISTORY:\n      ShowHistory(browser_);\n      break;\n    case IDC_SHOW_DOWNLOADS:\n      ShowDownloads(browser_);\n      break;\n    case IDC_MANAGE_EXTENSIONS:\n      ShowExtensions(browser_, std::string());\n      break;\n    case IDC_OPTIONS:\n      ShowSettings(browser_);\n      break;\n    case IDC_EDIT_SEARCH_ENGINES:\n      ShowSearchEngineSettings(browser_);\n      break;\n    case IDC_VIEW_PASSWORDS:\n      ShowPasswordManager(browser_);\n      break;\n    case IDC_CLEAR_BROWSING_DATA:\n      ShowClearBrowsingDataDialog(browser_);\n      break;\n    case IDC_IMPORT_SETTINGS:\n      ShowImportDialog(browser_);\n      break;\n    case IDC_TOGGLE_REQUEST_TABLET_SITE:\n      ToggleRequestTabletSite(browser_);\n      break;\n    case IDC_ABOUT:\n      ShowAboutChrome(browser_);\n      break;\n    case IDC_UPGRADE_DIALOG:\n      OpenUpdateChromeDialog(browser_);\n      break;\n    case IDC_HELP_PAGE_VIA_KEYBOARD:\n      ShowHelp(browser_, HELP_SOURCE_KEYBOARD);\n      break;\n    case IDC_HELP_PAGE_VIA_MENU:\n      ShowHelp(browser_, HELP_SOURCE_MENU);\n      break;\n    case IDC_SHOW_BETA_FORUM:\n      ShowBetaForum(browser_);\n      break;\n    case IDC_SHOW_SIGNIN:\n      ShowBrowserSigninOrSettings(\n          browser_, signin_metrics::AccessPoint::ACCESS_POINT_MENU);\n      break;\n    case IDC_DISTILL_PAGE:\n      DistillCurrentPage(browser_);\n      break;\n    case IDC_ROUTE_MEDIA:\n      RouteMedia(browser_);\n      break;\n    case IDC_WINDOW_MUTE_SITE:\n      MuteSite(browser_);\n      break;\n    case IDC_WINDOW_PIN_TAB:\n      PinTab(browser_);\n      break;\n\n    case IDC_COPY_URL:\n      CopyURL(browser_);\n      break;\n    case IDC_OPEN_IN_CHROME:\n      OpenInChrome(browser_);\n      break;\n    case IDC_SITE_SETTINGS:\n      ShowSiteSettings(\n          browser_,\n          browser_->tab_strip_model()->GetActiveWebContents()->GetVisibleURL());\n      break;\n    case IDC_HOSTED_APP_MENU_APP_INFO:\n      ShowPageInfoDialog(browser_->tab_strip_model()->GetActiveWebContents(),\n                         bubble_anchor_util::kAppMenuButton);\n      break;\n\n    default:\n      LOG(WARNING) << \"Received Unimplemented Command: \" << id;\n      break;\n  }\n\n  return true;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144253,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "bool BrowserCommandController::ExecuteCommandWithDisposition(\n    int id, WindowOpenDisposition disposition) {\n  if (!SupportsCommand(id) || !IsCommandEnabled(id))\n    return false;\n\n  if (browser_->tab_strip_model()->active_index() == TabStripModel::kNoTab)\n    return true;\n\n  DCHECK(command_updater_.IsCommandEnabled(id)) << \"Invalid/disabled command \"\n                                                << id;\n\n  switch (id) {\n    case IDC_BACK:\n      GoBack(browser_, disposition);\n      break;\n    case IDC_FORWARD:\n      GoForward(browser_, disposition);\n      break;\n    case IDC_RELOAD:\n      Reload(browser_, disposition);\n      break;\n    case IDC_RELOAD_CLEARING_CACHE:\n      ClearCache(browser_);\n      FALLTHROUGH;\n    case IDC_RELOAD_BYPASSING_CACHE:\n      ReloadBypassingCache(browser_, disposition);\n      break;\n    case IDC_HOME:\n      Home(browser_, disposition);\n      break;\n    case IDC_OPEN_CURRENT_URL:\n      OpenCurrentURL(browser_);\n      break;\n    case IDC_STOP:\n      Stop(browser_);\n      break;\n\n    case IDC_NEW_WINDOW:\n      NewWindow(browser_);\n      break;\n    case IDC_NEW_INCOGNITO_WINDOW:\n      NewIncognitoWindow(profile());\n      break;\n    case IDC_CLOSE_WINDOW:\n      base::RecordAction(base::UserMetricsAction(\"CloseWindowByKey\"));\n      CloseWindow(browser_);\n      break;\n    case IDC_NEW_TAB: {\n      NewTab(browser_);\n#if BUILDFLAG(ENABLE_DESKTOP_IN_PRODUCT_HELP)\n      auto* new_tab_tracker =\n          feature_engagement::NewTabTrackerFactory::GetInstance()\n              ->GetForProfile(profile());\n\n      new_tab_tracker->OnNewTabOpened();\n      new_tab_tracker->CloseBubble();\n#endif\n      break;\n    }\n    case IDC_CLOSE_TAB:\n      base::RecordAction(base::UserMetricsAction(\"CloseTabByKey\"));\n      CloseTab(browser_);\n      break;\n    case IDC_SELECT_NEXT_TAB:\n      base::RecordAction(base::UserMetricsAction(\"Accel_SelectNextTab\"));\n      SelectNextTab(browser_);\n      break;\n    case IDC_SELECT_PREVIOUS_TAB:\n      base::RecordAction(base::UserMetricsAction(\"Accel_SelectPreviousTab\"));\n      SelectPreviousTab(browser_);\n      break;\n    case IDC_MOVE_TAB_NEXT:\n      MoveTabNext(browser_);\n      break;\n    case IDC_MOVE_TAB_PREVIOUS:\n      MoveTabPrevious(browser_);\n      break;\n    case IDC_SELECT_TAB_0:\n    case IDC_SELECT_TAB_1:\n    case IDC_SELECT_TAB_2:\n    case IDC_SELECT_TAB_3:\n    case IDC_SELECT_TAB_4:\n    case IDC_SELECT_TAB_5:\n    case IDC_SELECT_TAB_6:\n    case IDC_SELECT_TAB_7:\n      base::RecordAction(base::UserMetricsAction(\"Accel_SelectNumberedTab\"));\n      SelectNumberedTab(browser_, id - IDC_SELECT_TAB_0);\n      break;\n    case IDC_SELECT_LAST_TAB:\n      base::RecordAction(base::UserMetricsAction(\"Accel_SelectNumberedTab\"));\n      SelectLastTab(browser_);\n      break;\n    case IDC_DUPLICATE_TAB:\n      DuplicateTab(browser_);\n      break;\n    case IDC_RESTORE_TAB:\n      RestoreTab(browser_);\n      break;\n    case IDC_SHOW_AS_TAB:\n      ConvertPopupToTabbedBrowser(browser_);\n      break;\n    case IDC_FULLSCREEN:\n      chrome::ToggleFullscreenMode(browser_);\n      break;\n    case IDC_OPEN_IN_PWA_WINDOW:\n      base::RecordAction(base::UserMetricsAction(\"OpenActiveTabInPwaWindow\"));\n      ReparentSecureActiveTabIntoPwaWindow(browser_);\n      break;\n\n#if defined(OS_CHROMEOS)\n    case IDC_VISIT_DESKTOP_OF_LRU_USER_2:\n    case IDC_VISIT_DESKTOP_OF_LRU_USER_3:\n      ExecuteVisitDesktopCommand(id, window()->GetNativeWindow());\n      break;\n#endif\n\n#if defined(OS_LINUX) && !defined(OS_CHROMEOS)\n    case IDC_MINIMIZE_WINDOW:\n      browser_->window()->Minimize();\n      break;\n    case IDC_MAXIMIZE_WINDOW:\n      browser_->window()->Maximize();\n      break;\n    case IDC_RESTORE_WINDOW:\n      browser_->window()->Restore();\n      break;\n    case IDC_USE_SYSTEM_TITLE_BAR: {\n      PrefService* prefs = profile()->GetPrefs();\n      prefs->SetBoolean(prefs::kUseCustomChromeFrame,\n                        !prefs->GetBoolean(prefs::kUseCustomChromeFrame));\n      break;\n    }\n#endif\n\n#if defined(OS_MACOSX)\n    case IDC_TOGGLE_FULLSCREEN_TOOLBAR:\n       chrome::ToggleFullscreenToolbar(browser_);\n       break;\n     case IDC_TOGGLE_JAVASCRIPT_APPLE_EVENTS: {\n      chrome::ToggleJavaScriptFromAppleEventsAllowed(browser_);\n       break;\n     }\n #endif\n    case IDC_EXIT:\n      Exit();\n      break;\n\n    case IDC_SAVE_PAGE:\n      SavePage(browser_);\n      break;\n    case IDC_BOOKMARK_PAGE:\n#if BUILDFLAG(ENABLE_DESKTOP_IN_PRODUCT_HELP)\n      feature_engagement::BookmarkTrackerFactory::GetInstance()\n          ->GetForProfile(profile())\n          ->OnBookmarkAdded();\n#endif\n      BookmarkCurrentPageAllowingExtensionOverrides(browser_);\n      break;\n    case IDC_BOOKMARK_ALL_TABS:\n#if BUILDFLAG(ENABLE_DESKTOP_IN_PRODUCT_HELP)\n      feature_engagement::BookmarkTrackerFactory::GetInstance()\n          ->GetForProfile(profile())\n          ->OnBookmarkAdded();\n#endif\n      BookmarkAllTabs(browser_);\n      break;\n    case IDC_VIEW_SOURCE:\n      browser_->tab_strip_model()\n          ->GetActiveWebContents()\n          ->GetMainFrame()\n          ->ViewSource();\n      break;\n    case IDC_EMAIL_PAGE_LOCATION:\n      EmailPageLocation(browser_);\n      break;\n    case IDC_PRINT:\n      Print(browser_);\n      break;\n\n#if BUILDFLAG(ENABLE_PRINTING)\n    case IDC_BASIC_PRINT:\n      base::RecordAction(base::UserMetricsAction(\"Accel_Advanced_Print\"));\n      BasicPrint(browser_);\n      break;\n#endif  // ENABLE_PRINTING\n\n    case IDC_SAVE_CREDIT_CARD_FOR_PAGE:\n      SaveCreditCard(browser_);\n      break;\n    case IDC_MIGRATE_LOCAL_CREDIT_CARD_FOR_PAGE:\n      MigrateLocalCards(browser_);\n      break;\n    case IDC_TRANSLATE_PAGE:\n      Translate(browser_);\n      break;\n    case IDC_MANAGE_PASSWORDS_FOR_PAGE:\n      ManagePasswordsForPage(browser_);\n      break;\n\n    case IDC_CUT:\n    case IDC_COPY:\n    case IDC_PASTE:\n      CutCopyPaste(browser_, id);\n      break;\n\n    case IDC_FIND:\n      Find(browser_);\n      break;\n    case IDC_FIND_NEXT:\n      FindNext(browser_);\n      break;\n    case IDC_FIND_PREVIOUS:\n      FindPrevious(browser_);\n      break;\n\n    case IDC_ZOOM_PLUS:\n      Zoom(browser_, content::PAGE_ZOOM_IN);\n      break;\n    case IDC_ZOOM_NORMAL:\n      Zoom(browser_, content::PAGE_ZOOM_RESET);\n      break;\n    case IDC_ZOOM_MINUS:\n      Zoom(browser_, content::PAGE_ZOOM_OUT);\n      break;\n\n    case IDC_FOCUS_TOOLBAR:\n      base::RecordAction(base::UserMetricsAction(\"Accel_Focus_Toolbar\"));\n      FocusToolbar(browser_);\n      break;\n    case IDC_FOCUS_LOCATION:\n      base::RecordAction(base::UserMetricsAction(\"Accel_Focus_Location\"));\n      FocusLocationBar(browser_);\n      break;\n    case IDC_FOCUS_SEARCH:\n      base::RecordAction(base::UserMetricsAction(\"Accel_Focus_Search\"));\n      FocusSearch(browser_);\n      break;\n    case IDC_FOCUS_MENU_BAR:\n      FocusAppMenu(browser_);\n      break;\n    case IDC_FOCUS_BOOKMARKS:\n      base::RecordAction(base::UserMetricsAction(\"Accel_Focus_Bookmarks\"));\n      FocusBookmarksToolbar(browser_);\n      break;\n    case IDC_FOCUS_INACTIVE_POPUP_FOR_ACCESSIBILITY:\n      FocusInactivePopupForAccessibility(browser_);\n      break;\n    case IDC_FOCUS_NEXT_PANE:\n      FocusNextPane(browser_);\n      break;\n    case IDC_FOCUS_PREVIOUS_PANE:\n      FocusPreviousPane(browser_);\n      break;\n\n    case IDC_OPEN_FILE:\n      browser_->OpenFile();\n      break;\n    case IDC_CREATE_SHORTCUT:\n      CreateBookmarkAppFromCurrentWebContents(browser_,\n                                              true /* force_shortcut_app */);\n      break;\n    case IDC_INSTALL_PWA:\n      CreateBookmarkAppFromCurrentWebContents(browser_,\n                                              false /* force_shortcut_app */);\n      break;\n    case IDC_DEV_TOOLS:\n      ToggleDevToolsWindow(browser_, DevToolsToggleAction::Show());\n      break;\n    case IDC_DEV_TOOLS_CONSOLE:\n      ToggleDevToolsWindow(browser_, DevToolsToggleAction::ShowConsolePanel());\n      break;\n    case IDC_DEV_TOOLS_DEVICES:\n      InspectUI::InspectDevices(browser_);\n      break;\n    case IDC_DEV_TOOLS_INSPECT:\n      ToggleDevToolsWindow(browser_, DevToolsToggleAction::Inspect());\n      break;\n    case IDC_DEV_TOOLS_TOGGLE:\n      ToggleDevToolsWindow(browser_, DevToolsToggleAction::Toggle());\n      break;\n    case IDC_TASK_MANAGER:\n      OpenTaskManager(browser_);\n      break;\n#if defined(OS_CHROMEOS)\n    case IDC_TAKE_SCREENSHOT:\n      TakeScreenshot();\n      break;\n#endif\n#if defined(GOOGLE_CHROME_BUILD)\n    case IDC_FEEDBACK:\n      OpenFeedbackDialog(browser_, kFeedbackSourceBrowserCommand);\n      break;\n#endif\n    case IDC_SHOW_BOOKMARK_BAR:\n      ToggleBookmarkBar(browser_);\n      break;\n    case IDC_PROFILING_ENABLED:\n      Profiling::Toggle();\n      break;\n\n    case IDC_SHOW_BOOKMARK_MANAGER:\n      ShowBookmarkManager(browser_);\n      break;\n    case IDC_SHOW_APP_MENU:\n      base::RecordAction(base::UserMetricsAction(\"Accel_Show_App_Menu\"));\n      ShowAppMenu(browser_);\n      break;\n    case IDC_SHOW_AVATAR_MENU:\n      ShowAvatarMenu(browser_);\n      break;\n    case IDC_SHOW_HISTORY:\n      ShowHistory(browser_);\n      break;\n    case IDC_SHOW_DOWNLOADS:\n      ShowDownloads(browser_);\n      break;\n    case IDC_MANAGE_EXTENSIONS:\n      ShowExtensions(browser_, std::string());\n      break;\n    case IDC_OPTIONS:\n      ShowSettings(browser_);\n      break;\n    case IDC_EDIT_SEARCH_ENGINES:\n      ShowSearchEngineSettings(browser_);\n      break;\n    case IDC_VIEW_PASSWORDS:\n      ShowPasswordManager(browser_);\n      break;\n    case IDC_CLEAR_BROWSING_DATA:\n      ShowClearBrowsingDataDialog(browser_);\n      break;\n    case IDC_IMPORT_SETTINGS:\n      ShowImportDialog(browser_);\n      break;\n    case IDC_TOGGLE_REQUEST_TABLET_SITE:\n      ToggleRequestTabletSite(browser_);\n      break;\n    case IDC_ABOUT:\n      ShowAboutChrome(browser_);\n      break;\n    case IDC_UPGRADE_DIALOG:\n      OpenUpdateChromeDialog(browser_);\n      break;\n    case IDC_HELP_PAGE_VIA_KEYBOARD:\n      ShowHelp(browser_, HELP_SOURCE_KEYBOARD);\n      break;\n    case IDC_HELP_PAGE_VIA_MENU:\n      ShowHelp(browser_, HELP_SOURCE_MENU);\n      break;\n    case IDC_SHOW_BETA_FORUM:\n      ShowBetaForum(browser_);\n      break;\n    case IDC_SHOW_SIGNIN:\n      ShowBrowserSigninOrSettings(\n          browser_, signin_metrics::AccessPoint::ACCESS_POINT_MENU);\n      break;\n    case IDC_DISTILL_PAGE:\n      DistillCurrentPage(browser_);\n      break;\n    case IDC_ROUTE_MEDIA:\n      RouteMedia(browser_);\n      break;\n    case IDC_WINDOW_MUTE_SITE:\n      MuteSite(browser_);\n      break;\n    case IDC_WINDOW_PIN_TAB:\n      PinTab(browser_);\n      break;\n\n    case IDC_COPY_URL:\n      CopyURL(browser_);\n      break;\n    case IDC_OPEN_IN_CHROME:\n      OpenInChrome(browser_);\n      break;\n    case IDC_SITE_SETTINGS:\n      ShowSiteSettings(\n          browser_,\n          browser_->tab_strip_model()->GetActiveWebContents()->GetVisibleURL());\n      break;\n    case IDC_HOSTED_APP_MENU_APP_INFO:\n      ShowPageInfoDialog(browser_->tab_strip_model()->GetActiveWebContents(),\n                         bubble_anchor_util::kAppMenuButton);\n      break;\n\n    default:\n      LOG(WARNING) << \"Received Unimplemented Command: \" << id;\n      break;\n  }\n\n  return true;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144254,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "WORD32 ih264d_process_intra_mb(dec_struct_t * ps_dec,\n dec_mb_info_t * ps_cur_mb_info,\n                               UWORD8 u1_mb_num)\n{\n    UWORD8 u1_mb_type = ps_cur_mb_info->u1_mb_type;\n    UWORD8 uc_temp = ps_cur_mb_info->u1_mb_ngbr_availablity;\n    UWORD8 u1_top_available = BOOLEAN(uc_temp & TOP_MB_AVAILABLE_MASK);\n    UWORD8 u1_left_available = BOOLEAN(uc_temp & LEFT_MB_AVAILABLE_MASK);\n    UWORD8 u1_use_top_right_mb = BOOLEAN(uc_temp & TOP_RIGHT_MB_AVAILABLE_MASK);\n    UWORD8 u1_use_top_left_mb = BOOLEAN(uc_temp & TOP_LEFT_MB_AVAILABLE_MASK);\n    UWORD8 uc_useTopMB = u1_top_available;\n    UWORD16 u2_use_left_mb = u1_left_available;\n    UWORD16 u2_use_left_mb_pack;\n    UWORD8 *pu1_luma_pred_buffer;\n /* CHANGED CODE */\n    UWORD8 *pu1_luma_rec_buffer;\n    UWORD8 *puc_top;\n\n mb_neigbour_params_t *ps_left_mb;\n mb_neigbour_params_t *ps_top_mb;\n mb_neigbour_params_t *ps_top_right_mb;\n mb_neigbour_params_t *ps_curmb;\n\n    UWORD16 u2_mbx = ps_cur_mb_info->u2_mbx;\n    UWORD32 ui_pred_width, ui_rec_width;\n    WORD16 *pi2_y_coeff;\n    UWORD8 u1_mbaff, u1_topmb, u1_mb_field_decoding_flag;\n    UWORD32 u4_num_pmbair;\n    UWORD16 ui2_luma_csbp = ps_cur_mb_info->u2_luma_csbp;\n    UWORD8 *pu1_yleft, *pu1_ytop_left;\n /* Chroma variables*/\n    UWORD8 *pu1_top_u;\n    UWORD8 *pu1_uleft;\n    UWORD8 *pu1_u_top_left;\n /* CHANGED CODE */\n    UWORD8 *pu1_mb_cb_rei1_buffer, *pu1_mb_cr_rei1_buffer;\n    UWORD32 u4_recwidth_cr;\n /* CHANGED CODE */\n tfr_ctxt_t *ps_frame_buf = ps_dec->ps_frame_buf_ip_recon;\n    UWORD32 u4_luma_dc_only_csbp = 0;\n    UWORD32 u4_luma_dc_only_cbp = 0;\n\n    UWORD8 *pu1_prev_intra4x4_pred_mode_data = (UWORD8 *)ps_dec->pv_proc_tu_coeff_data; //Pointer to keep track of intra4x4_pred_mode data in pv_proc_tu_coeff_data buffer\n    u1_mbaff = ps_dec->ps_cur_slice->u1_mbaff_frame_flag;\n    u1_topmb = ps_cur_mb_info->u1_topmb;\n    u4_num_pmbair = (u1_mb_num >> u1_mbaff);\n\n\n /*--------------------------------------------------------------------*/\n /* Find the current MB's mb params                                    */\n /*--------------------------------------------------------------------*/\n    u1_mb_field_decoding_flag = ps_cur_mb_info->u1_mb_field_decodingflag;\n\n    ps_curmb = ps_cur_mb_info->ps_curmb;\n    ps_top_mb = ps_cur_mb_info->ps_top_mb;\n    ps_left_mb = ps_cur_mb_info->ps_left_mb;\n    ps_top_right_mb = ps_cur_mb_info->ps_top_right_mb;\n\n /*--------------------------------------------------------------------*/\n /* Check whether neighbouring MB is Inter MB and                      */\n /* constrained intra pred is 1.                                       */\n /*--------------------------------------------------------------------*/\n    u2_use_left_mb_pack = (u2_use_left_mb << 8) + u2_use_left_mb;\n\n if(ps_dec->ps_cur_pps->u1_constrained_intra_pred_flag)\n {\n        UWORD8 u1_left = (UWORD8)u2_use_left_mb;\n\n        uc_useTopMB = uc_useTopMB\n && ((ps_top_mb->u1_mb_type != P_MB)\n && (ps_top_mb->u1_mb_type != B_MB));\n        u2_use_left_mb = u2_use_left_mb\n && ((ps_left_mb->u1_mb_type != P_MB)\n && (ps_left_mb->u1_mb_type != B_MB));\n\n        u2_use_left_mb_pack = (u2_use_left_mb << 8) + u2_use_left_mb;\n if(u1_mbaff)\n {\n if(u1_mb_field_decoding_flag ^ ps_left_mb->u1_mb_fld)\n {\n                u1_left = u1_left\n && (((ps_left_mb + 1)->u1_mb_type != P_MB)\n && ((ps_left_mb + 1)->u1_mb_type\n != B_MB));\n                u2_use_left_mb = u2_use_left_mb && u1_left;\n if(u1_mb_field_decoding_flag)\n                    u2_use_left_mb_pack = (u1_left << 8)\n + (u2_use_left_mb_pack & 0xff);\n else\n                    u2_use_left_mb_pack = (u2_use_left_mb << 8)\n + (u2_use_left_mb);\n }\n }\n        u1_use_top_right_mb =\n                        u1_use_top_right_mb\n && ((ps_top_right_mb->u1_mb_type != P_MB)\n && (ps_top_right_mb->u1_mb_type\n != B_MB));\n\n        u1_use_top_left_mb =\n                        u1_use_top_left_mb\n && ((ps_cur_mb_info->u1_topleft_mbtype != P_MB)\n && (ps_cur_mb_info->u1_topleft_mbtype\n != B_MB));\n }\n\n /*********************Common pointer calculations *************************/\n /* CHANGED CODE */\n    pu1_luma_pred_buffer = ps_dec->pu1_y;\n    pu1_luma_rec_buffer = ps_frame_buf->pu1_dest_y + (u4_num_pmbair << 4);\n    pu1_mb_cb_rei1_buffer = ps_frame_buf->pu1_dest_u\n + (u4_num_pmbair << 3) * YUV420SP_FACTOR;\n    pu1_mb_cr_rei1_buffer = ps_frame_buf->pu1_dest_v + (u4_num_pmbair << 3);\n    ui_pred_width = MB_SIZE;\n    ui_rec_width = ps_dec->u2_frm_wd_y << u1_mb_field_decoding_flag;\n    u4_recwidth_cr = ps_dec->u2_frm_wd_uv << u1_mb_field_decoding_flag;\n /************* Current and top luma pointer *****************/\n\n if(u1_mbaff)\n {\n if(u1_topmb == 0)\n {\n            pu1_luma_rec_buffer += (\n                            u1_mb_field_decoding_flag ?\n (ui_rec_width >> 1) :\n (ui_rec_width << 4));\n            pu1_mb_cb_rei1_buffer += (\n                            u1_mb_field_decoding_flag ?\n (u4_recwidth_cr >> 1) :\n (u4_recwidth_cr << 3));\n            pu1_mb_cr_rei1_buffer += (\n                            u1_mb_field_decoding_flag ?\n (u4_recwidth_cr >> 1) :\n (u4_recwidth_cr << 3));\n }\n }\n\n /* CHANGED CODE */\n if(ps_dec->u4_use_intrapred_line_copy == 1)\n {\n        puc_top = ps_dec->pu1_prev_y_intra_pred_line + (ps_cur_mb_info->u2_mbx << 4);\n        pu1_top_u = ps_dec->pu1_prev_u_intra_pred_line\n + (ps_cur_mb_info->u2_mbx << 3) * YUV420SP_FACTOR;\n }\n else\n {\n        puc_top = pu1_luma_rec_buffer - ui_rec_width;\n        pu1_top_u = pu1_mb_cb_rei1_buffer - u4_recwidth_cr;\n }\n /* CHANGED CODE */\n\n /************* Left pointer *****************/\n    pu1_yleft = pu1_luma_rec_buffer - 1;\n    pu1_uleft = pu1_mb_cb_rei1_buffer - 1 * YUV420SP_FACTOR;\n\n /**************Top Left pointer calculation**********/\n    pu1_ytop_left = puc_top - 1;\n    pu1_u_top_left = pu1_top_u - 1 * YUV420SP_FACTOR;\n\n /* CHANGED CODE */\n    PROFILE_DISABLE_INTRA_PRED()\n {\n        pu1_prev_intra4x4_pred_mode_data = (UWORD8 *)ps_dec->pv_proc_tu_coeff_data;\n if(u1_mb_type == I_4x4_MB && ps_cur_mb_info->u1_tran_form8x8 == 0)\n {\n            ps_dec->pv_proc_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_proc_tu_coeff_data + 32);\n\n }\n else if (u1_mb_type == I_4x4_MB && ps_cur_mb_info->u1_tran_form8x8 == 1)\n {\n            ps_dec->pv_proc_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_proc_tu_coeff_data + 8);\n }\n }\n if(!ps_cur_mb_info->u1_tran_form8x8)\n {\n        u4_luma_dc_only_csbp = ih264d_unpack_luma_coeff4x4_mb(ps_dec,\n                                       ps_cur_mb_info,\n 1);\n }\n else\n {\n if(!ps_dec->ps_cur_pps->u1_entropy_coding_mode)\n {\n            u4_luma_dc_only_cbp = ih264d_unpack_luma_coeff4x4_mb(ps_dec,\n                                           ps_cur_mb_info,\n 1);\n }\n else\n {\n            u4_luma_dc_only_cbp = ih264d_unpack_luma_coeff8x8_mb(ps_dec,\n                                           ps_cur_mb_info);\n }\n }\n\n    pi2_y_coeff = ps_dec->pi2_coeff_data;\n\n if(u1_mb_type != I_4x4_MB)\n {\n        UWORD8 u1_intrapred_mode = MB_TYPE_TO_INTRA_16x16_MODE(u1_mb_type);\n /*--------------------------------------------------------------------*/\n /* 16x16 IntraPrediction                                              */\n /*--------------------------------------------------------------------*/\n {\n            UWORD8 u1_packed_modes = (u1_top_available << 1)\n + u1_left_available;\n            UWORD8 u1_err_code =\n (u1_intrapred_mode & 1) ?\n                                            u1_intrapred_mode :\n (u1_intrapred_mode ^ 2);\n\n if((u1_err_code & u1_packed_modes) ^ u1_err_code)\n {\n                u1_intrapred_mode = 0;\n                ps_dec->i4_error_code = ERROR_INTRAPRED;\n }\n }\n {\n            UWORD8 au1_ngbr_pels[33];\n /* Get neighbour pixels */\n /* left pels */\n if(u2_use_left_mb)\n {\n                WORD32 i;\n for(i = 0; i < 16; i++)\n                    au1_ngbr_pels[16 - 1 - i] = pu1_yleft[i * ui_rec_width];\n }\n else\n {\n                memset(au1_ngbr_pels, 0, 16);\n }\n\n /* top left pels */\n            au1_ngbr_pels[16] = *pu1_ytop_left;\n\n /* top pels */\n if(uc_useTopMB)\n {\n                memcpy(au1_ngbr_pels + 16 + 1, puc_top, 16);\n }\n else\n {\n                memset(au1_ngbr_pels + 16 + 1, 0, 16);\n }\n            PROFILE_DISABLE_INTRA_PRED()\n            ps_dec->apf_intra_pred_luma_16x16[u1_intrapred_mode](\n                            au1_ngbr_pels, pu1_luma_rec_buffer, 1, ui_rec_width,\n ((uc_useTopMB << 2) | u2_use_left_mb));\n }\n {\n            UWORD32 i;\n            WORD16 ai2_tmp[16];\n for(i = 0; i < 16; i++)\n {\n                WORD16 *pi2_level = pi2_y_coeff + (i << 4);\n                UWORD8 *pu1_pred_sblk = pu1_luma_rec_buffer\n + ((i & 0x3) * BLK_SIZE)\n + (i >> 2) * (ui_rec_width << 2);\n                PROFILE_DISABLE_IQ_IT_RECON()\n {\n if(CHECKBIT(ps_cur_mb_info->u2_luma_csbp, i))\n {\n                        ps_dec->pf_iquant_itrans_recon_luma_4x4(\n                                        pi2_level,\n                                        pu1_pred_sblk,\n                                        pu1_pred_sblk,\n                                        ui_rec_width,\n                                        ui_rec_width,\n                                        gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],\n (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],\n                                        ps_cur_mb_info->u1_qp_div6, ai2_tmp, 1,\n                                        pi2_level);\n }\n else if((CHECKBIT(u4_luma_dc_only_csbp, i)) && pi2_level[0] != 0)\n {\n                        ps_dec->pf_iquant_itrans_recon_luma_4x4_dc(\n                                        pi2_level,\n                                        pu1_pred_sblk,\n                                        pu1_pred_sblk,\n                                        ui_rec_width,\n                                        ui_rec_width,\n                                        gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],\n (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],\n                                        ps_cur_mb_info->u1_qp_div6, ai2_tmp, 1,\n                                        pi2_level);\n }\n }\n }\n }\n }\n else if(!ps_cur_mb_info->u1_tran_form8x8)\n {\n        UWORD8 u1_is_left_sub_block, u1_is_top_sub_block = uc_useTopMB;\n        UWORD8 u1_sub_blk_x, u1_sub_blk_y, u1_sub_mb_num;\n        WORD8 i1_top_pred_mode;\n        WORD8 i1_left_pred_mode;\n        UWORD8 *pu1_top, *pu1_left, *pu1_top_left, *pu1_top_right;\n        WORD8 *pi1_cur_pred_mode, *pi1_left_pred_mode, *pc_topPredMode;\n        UWORD16 ui2_left_pred_buf_width = 0xffff;\n        WORD8 i1_intra_pred;\n        UWORD8 *pu1_prev_intra4x4_pred_mode_flag = pu1_prev_intra4x4_pred_mode_data;\n        UWORD8 *pu1_rem_intra4x4_pred_mode = pu1_prev_intra4x4_pred_mode_data + 16;\n        WORD16 *pi2_y_coeff1;\n        UWORD8 u1_cur_sub_block;\n        UWORD16 ui2_top_rt_mask;\n\n /*--------------------------------------------------------------------*/\n /* 4x4 IntraPrediction                                                */\n /*--------------------------------------------------------------------*/\n /* Calculation of Top Right subblock mask                             */\n /*                                                                    */\n /* (a) Set it to default mask                                         */\n /*     [It has 0 for sublocks which will never have top-right sub block] */\n /*                                                                    */\n /* (b) If top MB is not available                                     */\n /*      Clear the bits of the first row sub blocks                    */\n /*                                                                    */\n /* (c) Set/Clear bit for top-right sublock of MB                      */\n /*      [5 sub-block in decoding order] based on TOP RIGHT MB availablity */\n /*--------------------------------------------------------------------*/\n\n        pu1_top = puc_top;\n\n        ui2_top_rt_mask = (u1_use_top_right_mb << 3) | (0x5750);\n if(uc_useTopMB)\n            ui2_top_rt_mask |= 0x7;\n\n /*Top Related initialisations*/\n\n\n        pi1_cur_pred_mode = ps_cur_mb_info->ps_curmb->pi1_intrapredmodes;\n        pc_topPredMode = ps_cur_mb_info->ps_top_mb->pi1_intrapredmodes;\n /*--------------------------------------\n         if(u1_mbaff)\n         {\n\n         pi1_cur_pred_mode += (u2_mbx << 2);\n         pc_topPredMode = pi1_cur_pred_mode + ps_cur_mb_info->i1_offset;\n         pi1_cur_pred_mode += (u1_topmb) ? 0: 4;\n         }*/\n\n if(u1_top_available)\n {\n if(ps_top_mb->u1_mb_type == I_4x4_MB)\n *(WORD32*)pi1_cur_pred_mode = *(WORD32*)pc_topPredMode;\n else\n *(WORD32*)pi1_cur_pred_mode =\n (uc_useTopMB) ? DC_DC_DC_DC : NOT_VALID;\n }\n else\n *(WORD32*)pi1_cur_pred_mode = NOT_VALID;\n /* CHANGED CODE */\n\n /* CHANGED CODE */\n\n /*Left Related initialisations*/\n        pi1_left_pred_mode = ps_dec->pi1_left_pred_mode;\n if(!u1_mbaff)\n {\n\n if(u1_left_available)\n {\n\n if(ps_left_mb->u1_mb_type != I_4x4_MB)\n *(WORD32*)pi1_left_pred_mode =\n (u2_use_left_mb_pack) ?\n                                    DC_DC_DC_DC :\n                                                            NOT_VALID;\n\n }\n else\n {\n\n *(WORD32*)pi1_left_pred_mode = NOT_VALID;\n }\n\n }\n else\n {\n            UWORD8 u1_curMbfld = ps_cur_mb_info->u1_mb_field_decodingflag;\n            UWORD8 u1_leftMbfld = ps_left_mb->u1_mb_fld;\n\n if(u1_curMbfld ^ u1_leftMbfld)\n {\n\n if(u1_topmb\n | ((u1_topmb == 0)\n && ((ps_curmb - 1)->u1_mb_type\n != I_4x4_MB)))\n {\n if(u1_left_available)\n {\n if(ps_left_mb->u1_mb_type != I_4x4_MB)\n {\n if(CHECKBIT(u2_use_left_mb_pack,0) == 0)\n *(WORD32*)pi1_left_pred_mode = NOT_VALID;\n else\n *(WORD32*)pi1_left_pred_mode = DC_DC_DC_DC;\n }\n }\n else\n *(WORD32*)pi1_left_pred_mode = NOT_VALID;\n\n if(u1_curMbfld)\n {\n if(u1_left_available)\n {\n if((ps_left_mb + 1)->u1_mb_type != I_4x4_MB)\n {\n if(u2_use_left_mb_pack >> 8)\n *(WORD32*)(pi1_left_pred_mode + 4) =\n                                                    DC_DC_DC_DC;\n else\n *(WORD32*)(pi1_left_pred_mode + 4) =\n                                                    NOT_VALID;\n }\n }\n else\n *(WORD32*)(pi1_left_pred_mode + 4) = NOT_VALID;\n                        pi1_left_pred_mode[1] = pi1_left_pred_mode[2];\n                        pi1_left_pred_mode[2] = pi1_left_pred_mode[4];\n                        pi1_left_pred_mode[3] = pi1_left_pred_mode[6];\n *(WORD32*)(pi1_left_pred_mode + 4) =\n *(WORD32*)pi1_left_pred_mode;\n }\n else\n {\n\n                        pi1_left_pred_mode[7] = pi1_left_pred_mode[3];\n                        pi1_left_pred_mode[6] = pi1_left_pred_mode[3];\n                        pi1_left_pred_mode[5] = pi1_left_pred_mode[2];\n                        pi1_left_pred_mode[4] = pi1_left_pred_mode[2];\n                        pi1_left_pred_mode[3] = pi1_left_pred_mode[1];\n                        pi1_left_pred_mode[2] = pi1_left_pred_mode[1];\n                        pi1_left_pred_mode[1] = pi1_left_pred_mode[0];\n }\n }\n                pi1_left_pred_mode += (u1_topmb) ? 0 : 4;\n }\n else\n {\n\n                pi1_left_pred_mode += (u1_topmb) ? 0 : 4;\n if(u1_left_available)\n {\n\n if(ps_left_mb->u1_mb_type != I_4x4_MB)\n *(WORD32*)pi1_left_pred_mode =\n (u2_use_left_mb_pack) ?\n                                        DC_DC_DC_DC :\n                                                                NOT_VALID;\n }\n else\n *(WORD32*)pi1_left_pred_mode = NOT_VALID;\n }\n }\n /* One time pointer initialisations*/\n        pi2_y_coeff1 = pi2_y_coeff;\n        pu1_top_left = pu1_ytop_left;\n\n /* Scan the sub-blocks in Raster Scan Order */\n for(u1_sub_mb_num = 0; u1_sub_mb_num < 16; u1_sub_mb_num++)\n {\n            UWORD8 au1_ngbr_pels[13];\n\n            u1_sub_blk_x = u1_sub_mb_num & 0x3;\n            u1_sub_blk_y = u1_sub_mb_num >> 2;\n            i1_top_pred_mode = pi1_cur_pred_mode[u1_sub_blk_x];\n            i1_left_pred_mode = pi1_left_pred_mode[u1_sub_blk_y];\n            u1_use_top_right_mb = (!!CHECKBIT(ui2_top_rt_mask, u1_sub_mb_num));\n\n /*********** left subblock availability**********/\n if(u1_sub_blk_x)\n                u1_is_left_sub_block = 1;\n else\n                u1_is_left_sub_block =\n (u1_sub_blk_y < 2) ?\n (CHECKBIT(u2_use_left_mb_pack,\n 0)) :\n (u2_use_left_mb_pack >> 8);\n\n /* CHANGED CODE */\n if(u1_sub_blk_y)\n                u1_is_top_sub_block = 1;\n\n /* CHANGED CODE */\n /***************** Top *********************/\n if(ps_dec->u4_use_intrapred_line_copy == 1)\n {\n\n if(u1_sub_blk_y)\n                    pu1_top = pu1_luma_rec_buffer - ui_rec_width;\n else\n                    pu1_top = puc_top + (u1_sub_blk_x << 2);\n }\n else\n {\n                pu1_top = pu1_luma_rec_buffer - ui_rec_width;\n }\n /***************** Top Right *********************/\n            pu1_top_right = pu1_top + 4;\n /***************** Top Left *********************/\n            pu1_top_left = pu1_top - 1;\n /***************** Left *********************/\n            pu1_left = pu1_luma_rec_buffer - 1;\n /* CHANGED CODE */\n\n /*---------------------------------------------------------------*/\n /* Calculation of Intra prediction mode                          */\n /*---------------------------------------------------------------*/\n            i1_intra_pred = ((i1_left_pred_mode < 0) | (i1_top_pred_mode < 0)) ?\n                            DC : MIN(i1_left_pred_mode, i1_top_pred_mode);\n {\n                UWORD8 u1_packed_modes = (u1_is_top_sub_block << 1)\n + u1_is_left_sub_block;\n                UWORD8 *pu1_intra_err_codes =\n (UWORD8 *)gau1_ih264d_intra_pred_err_code;\n                UWORD8 uc_b2b0 = ((u1_sub_mb_num & 4) >> 1) | (u1_sub_mb_num & 1);\n                UWORD8 uc_b3b1 = ((u1_sub_mb_num & 8) >> 2)\n | ((u1_sub_mb_num & 2) >> 1);\n\n                u1_cur_sub_block = (uc_b3b1 << 2) + uc_b2b0;\n                PROFILE_DISABLE_INTRA_PRED()\n if(!pu1_prev_intra4x4_pred_mode_flag[u1_cur_sub_block])\n {\n                    i1_intra_pred =\n                                    pu1_rem_intra4x4_pred_mode[u1_cur_sub_block]\n\n                                                     + (pu1_rem_intra4x4_pred_mode[u1_cur_sub_block]\n                                                                     >= i1_intra_pred);\n                 }\n                 {\n                     UWORD8 u1_err_code = pu1_intra_err_codes[i1_intra_pred];\n \n if((u1_err_code & u1_packed_modes) ^ u1_err_code)\n {\n                        i1_intra_pred = 0;\n                        ps_dec->i4_error_code = ERROR_INTRAPRED;\n }\n\n }\n }\n {\n /* Get neighbour pixels */\n /* left pels */\n if(u1_is_left_sub_block)\n {\n                    WORD32 i;\n for(i = 0; i < 4; i++)\n                        au1_ngbr_pels[4 - 1 - i] = pu1_left[i * ui_rec_width];\n }\n else\n {\n                    memset(au1_ngbr_pels, 0, 4);\n }\n\n /* top left pels */\n                au1_ngbr_pels[4] = *pu1_top_left;\n\n /* top pels */\n if(u1_is_top_sub_block)\n {\n                    memcpy(au1_ngbr_pels + 4 + 1, pu1_top, 4);\n }\n else\n {\n                    memset(au1_ngbr_pels + 4 + 1, 0, 4);\n }\n\n /* top right pels */\n if(u1_use_top_right_mb)\n {\n                    memcpy(au1_ngbr_pels + 4 * 2 + 1, pu1_top_right, 4);\n }\n else if(u1_is_top_sub_block)\n {\n                    memset(au1_ngbr_pels + 4 * 2 + 1, au1_ngbr_pels[4 * 2], 4);\n }\n }\n            PROFILE_DISABLE_INTRA_PRED()\n            ps_dec->apf_intra_pred_luma_4x4[i1_intra_pred](\n                            au1_ngbr_pels, pu1_luma_rec_buffer, 1,\n                            ui_rec_width,\n ((u1_is_top_sub_block << 2) | u1_is_left_sub_block));\n\n /* CHANGED CODE */\n if(CHECKBIT(ui2_luma_csbp, u1_sub_mb_num))\n {\n                WORD16 ai2_tmp[16];\n                PROFILE_DISABLE_IQ_IT_RECON()\n {\n if(CHECKBIT(u4_luma_dc_only_csbp, u1_sub_mb_num))\n {\n                        ps_dec->pf_iquant_itrans_recon_luma_4x4_dc(\n                                        pi2_y_coeff1,\n                                        pu1_luma_rec_buffer,\n                                        pu1_luma_rec_buffer,\n                                        ui_rec_width,\n                                        ui_rec_width,\n                                        gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],\n (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],\n                                        ps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,\n                                        NULL);\n }\n else\n {\n                        ps_dec->pf_iquant_itrans_recon_luma_4x4(\n                                        pi2_y_coeff1,\n                                        pu1_luma_rec_buffer,\n                                        pu1_luma_rec_buffer,\n                                        ui_rec_width,\n                                        ui_rec_width,\n                                        gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],\n (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],\n                                        ps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,\n                                        NULL);\n }\n }\n\n }\n\n /*---------------------------------------------------------------*/\n /* Update sub block number                                       */\n /*---------------------------------------------------------------*/\n            pi2_y_coeff1 += 16;\n            pu1_luma_rec_buffer +=\n (u1_sub_blk_x == 3) ? (ui_rec_width << 2) - 12 : 4;\n            pu1_luma_pred_buffer +=\n (u1_sub_blk_x == 3) ? (ui_pred_width << 2) - 12 : 4;\n /* CHANGED CODE */\n            pi1_cur_pred_mode[u1_sub_blk_x] = i1_intra_pred;\n            pi1_left_pred_mode[u1_sub_blk_y] = i1_intra_pred;\n }\n }\n else if((u1_mb_type == I_4x4_MB) && (ps_cur_mb_info->u1_tran_form8x8 == 1))\n {\n        UWORD8 u1_is_left_sub_block, u1_is_top_sub_block = uc_useTopMB;\n        UWORD8 u1_sub_blk_x, u1_sub_blk_y, u1_sub_mb_num;\n        WORD8 i1_top_pred_mode;\n        WORD8 i1_left_pred_mode;\n        UWORD8 *pu1_top, *pu1_left, *pu1_top_left;\n        WORD8 *pi1_cur_pred_mode, *pi1_left_pred_mode, *pc_topPredMode;\n        UWORD16 ui2_left_pred_buf_width = 0xffff;\n        WORD8 i1_intra_pred;\n        UWORD8 *pu1_prev_intra4x4_pred_mode_flag = pu1_prev_intra4x4_pred_mode_data;\n        UWORD8 *pu1_rem_intra4x4_pred_mode = pu1_prev_intra4x4_pred_mode_data + 4;\n        WORD16 *pi2_y_coeff1;\n        UWORD16 ui2_top_rt_mask;\n        UWORD32 u4_4x4_left_offset = 0;\n\n /*--------------------------------------------------------------------*/\n /* 8x8 IntraPrediction                                                */\n /*--------------------------------------------------------------------*/\n /* Calculation of Top Right subblock mask                             */\n /*                                                                    */\n /* (a) Set it to default mask                                         */\n /*  [It has 0 for sublocks which will never have top-right sub block] */\n /*                                                                    */\n /* (b) If top MB is not available                                     */\n /*      Clear the bits of the first row sub blocks                    */\n /*                                                                    */\n /* (c) Set/Clear bit for top-right sublock of MB                      */\n /*  [5 sub-block in decoding order] based on TOP RIGHT MB availablity */\n /*                                                                    */\n /* ui2_top_rt_mask: marks availibility of top right(neighbour)         */\n /* in the 8x8 Block ordering                                          */\n /*                                                                    */\n /*      tr0   tr1                                                     */\n /*   0    1   tr3                                                     */\n /*   2    3                                                           */\n /*                                                                    */\n /*  Top rights for 0 is in top MB                                     */\n /*  top right of 1 will be in top right MB                            */\n /*  top right of 3 in right MB and hence not available                */\n /*  This corresponds to ui2_top_rt_mask  having default value 0x4      */\n /*--------------------------------------------------------------------*/\n\n        ui2_top_rt_mask = (u1_use_top_right_mb << 1) | (0x4);\n\n if(uc_useTopMB)\n {\n            ui2_top_rt_mask |= 0x1;\n }\n\n /* Top Related initialisations */\n        pi1_cur_pred_mode = ps_cur_mb_info->ps_curmb->pi1_intrapredmodes;\n        pc_topPredMode = ps_cur_mb_info->ps_top_mb->pi1_intrapredmodes;\n /*\n         if(u1_mbaff)\n         {\n         pi1_cur_pred_mode += (u2_mbx << 2);\n         pc_topPredMode = pi1_cur_pred_mode + ps_cur_mb_info->i1_offset;\n         pi1_cur_pred_mode += (u1_topmb) ? 0: 4;\n         }\n         */\n if(u1_top_available)\n {\n if(ps_top_mb->u1_mb_type == I_4x4_MB)\n {\n *(WORD32*)pi1_cur_pred_mode = *(WORD32*)pc_topPredMode;\n }\n else\n {\n *(WORD32*)pi1_cur_pred_mode =\n (uc_useTopMB) ? DC_DC_DC_DC : NOT_VALID;\n }\n }\n else\n {\n *(WORD32*)pi1_cur_pred_mode = NOT_VALID;\n }\n\n        pu1_top = puc_top - 8;\n\n /*Left Related initialisations*/\n        pi1_left_pred_mode = ps_dec->pi1_left_pred_mode;\n\n if(!u1_mbaff)\n {\n if(u1_left_available)\n {\n if(ps_left_mb->u1_mb_type != I_4x4_MB)\n {\n *(WORD32*)pi1_left_pred_mode =\n (u2_use_left_mb_pack) ?\n                                    DC_DC_DC_DC :\n                                                            NOT_VALID;\n }\n }\n else\n {\n *(WORD32*)pi1_left_pred_mode = NOT_VALID;\n }\n }\n else\n {\n            UWORD8 u1_curMbfld = ps_cur_mb_info->u1_mb_field_decodingflag;\n\n            UWORD8 u1_leftMbfld = ps_left_mb->u1_mb_fld;\n\n if((!u1_curMbfld) && (u1_leftMbfld))\n {\n                u4_4x4_left_offset = 1;\n }\n\n if(u1_curMbfld ^ u1_leftMbfld)\n {\n\n if(u1_topmb\n | ((u1_topmb == 0)\n && ((ps_curmb - 1)->u1_mb_type\n != I_4x4_MB)))\n\n {\n if(u1_left_available)\n {\n if(ps_left_mb->u1_mb_type != I_4x4_MB)\n {\n if(CHECKBIT(u2_use_left_mb_pack,0) == 0)\n {\n *(WORD32*)pi1_left_pred_mode = NOT_VALID;\n }\n else\n {\n *(WORD32*)pi1_left_pred_mode = DC_DC_DC_DC;\n }\n }\n }\n else\n {\n *(WORD32*)pi1_left_pred_mode = NOT_VALID;\n }\n\n if(u1_curMbfld)\n {\n if(u1_left_available)\n {\n if((ps_left_mb + 1)->u1_mb_type != I_4x4_MB)\n {\n if(u2_use_left_mb_pack >> 8)\n {\n *(WORD32*)(pi1_left_pred_mode + 4) =\n                                                    DC_DC_DC_DC;\n }\n else\n {\n *(WORD32*)(pi1_left_pred_mode + 4) =\n                                                    NOT_VALID;\n }\n }\n }\n else\n {\n *(WORD32*)(pi1_left_pred_mode + 4) = NOT_VALID;\n }\n\n                        pi1_left_pred_mode[1] = pi1_left_pred_mode[2];\n                        pi1_left_pred_mode[2] = pi1_left_pred_mode[4];\n                        pi1_left_pred_mode[3] = pi1_left_pred_mode[6];\n *(WORD32*)(pi1_left_pred_mode + 4) =\n *(WORD32*)pi1_left_pred_mode;\n }\n else\n {\n                        pi1_left_pred_mode[7] = pi1_left_pred_mode[3];\n                        pi1_left_pred_mode[6] = pi1_left_pred_mode[3];\n                        pi1_left_pred_mode[5] = pi1_left_pred_mode[2];\n                        pi1_left_pred_mode[4] = pi1_left_pred_mode[2];\n                        pi1_left_pred_mode[3] = pi1_left_pred_mode[1];\n                        pi1_left_pred_mode[2] = pi1_left_pred_mode[1];\n                        pi1_left_pred_mode[1] = pi1_left_pred_mode[0];\n }\n }\n                pi1_left_pred_mode += (u1_topmb) ? 0 : 4;\n }\n else\n {\n                pi1_left_pred_mode += (u1_topmb) ? 0 : 4;\n\n if(u1_left_available)\n {\n if(ps_left_mb->u1_mb_type != I_4x4_MB)\n {\n *(WORD32*)pi1_left_pred_mode =\n (u2_use_left_mb_pack) ?\n                                        DC_DC_DC_DC :\n                                                                NOT_VALID;\n }\n }\n else\n {\n *(WORD32*)pi1_left_pred_mode = NOT_VALID;\n }\n }\n }\n\n /* One time pointer initialisations*/\n        pi2_y_coeff1 = pi2_y_coeff;\n\n if(u1_use_top_left_mb)\n {\n            pu1_top_left = pu1_ytop_left;\n }\n else\n {\n            pu1_top_left = NULL;\n }\n\n /* Scan the sub-blocks in Raster Scan Order */\n for(u1_sub_mb_num = 0; u1_sub_mb_num < 4; u1_sub_mb_num++)\n {\n            u1_sub_blk_x = (u1_sub_mb_num & 0x1);\n            u1_sub_blk_y = (u1_sub_mb_num >> 1);\n            i1_top_pred_mode = pi1_cur_pred_mode[u1_sub_blk_x << 1];\n            i1_left_pred_mode = pi1_left_pred_mode[u1_sub_blk_y << 1];\n\n if(2 == u1_sub_mb_num)\n {\n                i1_left_pred_mode = pi1_left_pred_mode[(u1_sub_blk_y << 1)\n + u4_4x4_left_offset];\n }\n\n            u1_use_top_right_mb = (!!CHECKBIT(ui2_top_rt_mask, u1_sub_mb_num));\n\n /*********** left subblock availability**********/\n if(u1_sub_blk_x)\n {\n                u1_is_left_sub_block = 1;\n }\n else\n {\n                u1_is_left_sub_block =\n (u1_sub_blk_y < 1) ?\n (CHECKBIT(u2_use_left_mb_pack,\n 0)) :\n (u2_use_left_mb_pack >> 8);\n }\n\n /***************** Top *********************/\n if(u1_sub_blk_y)\n {\n                u1_is_top_sub_block = 1;\n                pu1_top = /*pu1_luma_pred_buffer*/pu1_luma_rec_buffer - ui_rec_width;\n }\n else\n {\n                pu1_top += 8;\n }\n\n /***************** Left *********************/\n if((u1_sub_blk_x) | (u4_num_pmbair != 0))\n {\n                pu1_left = /*pu1_luma_pred_buffer*/pu1_luma_rec_buffer - 1;\n                ui2_left_pred_buf_width = ui_rec_width;\n }\n else\n {\n                pu1_left = pu1_yleft;\n                pu1_yleft += (ui_rec_width << 3);\n                ui2_left_pred_buf_width = ui_rec_width;\n }\n\n /***************** Top Left *********************/\n if(u1_sub_mb_num)\n {\n                pu1_top_left = (u1_sub_blk_x) ?\n                                pu1_top - 1 : pu1_left - ui_rec_width;\n\n if((u1_sub_blk_x && (!u1_is_top_sub_block))\n || ((!u1_sub_blk_x) && (!u1_is_left_sub_block)))\n {\n                    pu1_top_left = NULL;\n }\n }\n\n /*---------------------------------------------------------------*/\n /* Calculation of Intra prediction mode                          */\n /*---------------------------------------------------------------*/\n            i1_intra_pred = ((i1_left_pred_mode < 0) | (i1_top_pred_mode < 0)) ?\n                            DC : MIN(i1_left_pred_mode, i1_top_pred_mode);\n {\n                UWORD8 u1_packed_modes = (u1_is_top_sub_block << 1)\n + u1_is_left_sub_block;\n                UWORD8 *pu1_intra_err_codes =\n (UWORD8 *)gau1_ih264d_intra_pred_err_code;\n\n /********************************************************************/\n /* Same intra4x4_pred_mode array is filled with intra4x4_pred_mode  */\n /* for a MB with 8x8 intrapredicition                               */\n /********************************************************************/\n                PROFILE_DISABLE_INTRA_PRED()\n if(!pu1_prev_intra4x4_pred_mode_flag[u1_sub_mb_num])\n {\n                    i1_intra_pred = pu1_rem_intra4x4_pred_mode[u1_sub_mb_num]\n\n                                     + (pu1_rem_intra4x4_pred_mode[u1_sub_mb_num]\n                                                     >= i1_intra_pred);\n                 }\n                 {\n                     UWORD8 u1_err_code = pu1_intra_err_codes[i1_intra_pred];\n \n if((u1_err_code & u1_packed_modes) ^ u1_err_code)\n {\n                        i1_intra_pred = 0;\n                        ps_dec->i4_error_code = ERROR_INTRAPRED;\n }\n }\n }\n\n {\n                UWORD8 au1_ngbr_pels[25];\n                WORD32 ngbr_avail;\n                ngbr_avail = u1_is_left_sub_block << 0;\n                ngbr_avail |= u1_is_top_sub_block << 2;\n\n if(pu1_top_left)\n                    ngbr_avail |= 1 << 1;\n\n                ngbr_avail |= u1_use_top_right_mb << 3;\n                PROFILE_DISABLE_INTRA_PRED()\n {\n                    ps_dec->pf_intra_pred_ref_filtering(pu1_left, pu1_top_left,\n                                                        pu1_top, au1_ngbr_pels,\n                                                        ui2_left_pred_buf_width,\n                                                        ngbr_avail);\n\n                    ps_dec->apf_intra_pred_luma_8x8[i1_intra_pred](\n                                    au1_ngbr_pels, pu1_luma_rec_buffer, 1,\n                                    ui_rec_width,\n ((u1_is_top_sub_block << 2) | u1_is_left_sub_block));\n }\n }\n\n /* Inverse Transform and Reconstruction */\n if(CHECKBIT(ps_cur_mb_info->u1_cbp, u1_sub_mb_num))\n {\n                WORD16 *pi2_scale_matrix_ptr;\n                WORD16 ai2_tmp[64];\n\n                pi2_scale_matrix_ptr =\n                                ps_dec->s_high_profile.i2_scalinglist8x8[0];\n                PROFILE_DISABLE_IQ_IT_RECON()\n {\n if(CHECKBIT(u4_luma_dc_only_cbp, u1_sub_mb_num))\n {\n                        ps_dec->pf_iquant_itrans_recon_luma_8x8_dc(\n                                        pi2_y_coeff1,\n                                        pu1_luma_rec_buffer,\n                                        pu1_luma_rec_buffer,\n                                        ui_rec_width,\n                                        ui_rec_width,\n                                        gau1_ih264d_dequant8x8_cavlc[ps_cur_mb_info->u1_qp_rem6],\n (UWORD16 *)pi2_scale_matrix_ptr,\n                                        ps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,\n                                        NULL);\n }\n else\n {\n                        ps_dec->pf_iquant_itrans_recon_luma_8x8(\n                                        pi2_y_coeff1,\n                                        pu1_luma_rec_buffer,\n                                        pu1_luma_rec_buffer,\n                                        ui_rec_width,\n                                        ui_rec_width,\n                                        gau1_ih264d_dequant8x8_cavlc[ps_cur_mb_info->u1_qp_rem6],\n (UWORD16 *)pi2_scale_matrix_ptr,\n                                        ps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,\n                                        NULL);\n }\n }\n\n }\n\n /*---------------------------------------------------------------*/\n /* Update sub block number                                       */\n /*---------------------------------------------------------------*/\n            pi2_y_coeff1 += 64;\n\n            pu1_luma_rec_buffer +=\n (u1_sub_blk_x == 1) ?\n (ui_rec_width << 3) - (8 * 1) : 8;\n\n /*---------------------------------------------------------------*/\n /* Pred mode filled in terms of 4x4 block so replicated in 2     */\n /* locations.                                                    */\n /*---------------------------------------------------------------*/\n            pi1_cur_pred_mode[u1_sub_blk_x << 1] = i1_intra_pred;\n            pi1_cur_pred_mode[(u1_sub_blk_x << 1) + 1] = i1_intra_pred;\n            pi1_left_pred_mode[u1_sub_blk_y << 1] = i1_intra_pred;\n            pi1_left_pred_mode[(u1_sub_blk_y << 1) + 1] = i1_intra_pred;\n }\n }\n /* Decode Chroma Block */\n    ih264d_unpack_chroma_coeff4x4_mb(ps_dec,\n                                     ps_cur_mb_info);\n /*--------------------------------------------------------------------*/\n /* Chroma Blocks decoding                                             */\n /*--------------------------------------------------------------------*/\n {\n        UWORD8 u1_intra_chrom_pred_mode;\n        UWORD8 u1_chroma_cbp = (UWORD8)(ps_cur_mb_info->u1_cbp >> 4);\n\n /*--------------------------------------------------------------------*/\n /* Perform Chroma intra prediction                                    */\n /*--------------------------------------------------------------------*/\n\n        u1_intra_chrom_pred_mode = CHROMA_TO_LUMA_INTRA_MODE(\n                        ps_cur_mb_info->u1_chroma_pred_mode);\n\n {\n            UWORD8 u1_packed_modes = (u1_top_available << 1)\n + u1_left_available;\n            UWORD8 u1_err_code =\n (u1_intra_chrom_pred_mode & 1) ?\n                                            u1_intra_chrom_pred_mode :\n (u1_intra_chrom_pred_mode ^ 2);\n if((u1_err_code & u1_packed_modes) ^ u1_err_code)\n {\n                u1_intra_chrom_pred_mode = 0;\n                ps_dec->i4_error_code = ERROR_INTRAPRED;\n }\n }\n\n /* CHANGED CODE */\n if(u1_chroma_cbp != CBPC_ALLZERO)\n {\n            UWORD16 u2_chroma_csbp =\n (u1_chroma_cbp == CBPC_ACZERO) ?\n 0 : ps_cur_mb_info->u2_chroma_csbp;\n            UWORD32 u4_scale_u;\n            UWORD32 u4_scale_v;\n\n {\n                UWORD16 au2_ngbr_pels[33];\n                UWORD8 *pu1_ngbr_pels = (UWORD8 *)au2_ngbr_pels;\n                UWORD16 *pu2_left_uv;\n                UWORD16 *pu2_topleft_uv;\n                WORD32 use_left1 = (u2_use_left_mb_pack & 0x0ff);\n                WORD32 use_left2 = (u2_use_left_mb_pack & 0xff00) >> 8;\n\n                pu2_left_uv = (UWORD16 *)pu1_uleft;\n                pu2_topleft_uv = (UWORD16 *)pu1_u_top_left;\n /* Get neighbour pixels */\n /* left pels */\n if(u2_use_left_mb_pack)\n {\n                    WORD32 i;\n if(use_left1)\n {\n for(i = 0; i < 4; i++)\n                            au2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i\n * u4_recwidth_cr / YUV420SP_FACTOR];\n }\n else\n {\n                        memset(au2_ngbr_pels + 4, 0, 4 * sizeof(UWORD16));\n }\n\n if(use_left2)\n {\n for(i = 4; i < 8; i++)\n                            au2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i\n * u4_recwidth_cr / YUV420SP_FACTOR];\n }\n else\n {\n                        memset(au2_ngbr_pels, 0, 4 * sizeof(UWORD16));\n }\n }\n else\n {\n                    memset(au2_ngbr_pels, 0, 8 * sizeof(UWORD16));\n }\n\n /* top left pels */\n                au2_ngbr_pels[8] = *pu2_topleft_uv;\n\n /* top pels */\n if(uc_useTopMB)\n {\n                    memcpy(au2_ngbr_pels + 8 + 1, pu1_top_u,\n 8 * sizeof(UWORD16));\n }\n else\n {\n                    memset(au2_ngbr_pels + 8 + 1, 0, 8 * sizeof(UWORD16));\n }\n\n                PROFILE_DISABLE_INTRA_PRED()\n                ps_dec->apf_intra_pred_chroma[u1_intra_chrom_pred_mode](\n                                pu1_ngbr_pels,\n                                pu1_mb_cb_rei1_buffer,\n 1,\n                                u4_recwidth_cr,\n ((uc_useTopMB << 2) | (use_left2 << 4)\n | use_left1));\n }\n            u4_scale_u = ps_cur_mb_info->u1_qpc_div6;\n            u4_scale_v = ps_cur_mb_info->u1_qpcr_div6;\n            pi2_y_coeff = ps_dec->pi2_coeff_data;\n\n {\n                UWORD32 i;\n                WORD16 ai2_tmp[16];\n for(i = 0; i < 4; i++)\n {\n                    WORD16 *pi2_level = pi2_y_coeff + (i << 4);\n                    UWORD8 *pu1_pred_sblk = pu1_mb_cb_rei1_buffer\n + ((i & 0x1) * BLK_SIZE * YUV420SP_FACTOR)\n + (i >> 1) * (u4_recwidth_cr << 2);\n                    PROFILE_DISABLE_IQ_IT_RECON()\n {\n if(CHECKBIT(u2_chroma_csbp, i))\n {\n                            ps_dec->pf_iquant_itrans_recon_chroma_4x4(\n                                            pi2_level,\n                                            pu1_pred_sblk,\n                                            pu1_pred_sblk,\n                                            u4_recwidth_cr,\n                                            u4_recwidth_cr,\n                                            gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpc_rem6],\n (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[1],\n                                            u4_scale_u, ai2_tmp, pi2_level);\n }\n else if(pi2_level[0] != 0)\n {\n                            ps_dec->pf_iquant_itrans_recon_chroma_4x4_dc(\n                                            pi2_level,\n                                            pu1_pred_sblk,\n                                            pu1_pred_sblk,\n                                            u4_recwidth_cr,\n                                            u4_recwidth_cr,\n                                            gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpc_rem6],\n (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[1],\n                                            u4_scale_u, ai2_tmp, pi2_level);\n }\n }\n\n }\n }\n\n            pi2_y_coeff += MB_CHROM_SIZE;\n            u2_chroma_csbp = u2_chroma_csbp >> 4;\n {\n                UWORD32 i;\n                WORD16 ai2_tmp[16];\n for(i = 0; i < 4; i++)\n {\n                    WORD16 *pi2_level = pi2_y_coeff + (i << 4);\n                    UWORD8 *pu1_pred_sblk = pu1_mb_cb_rei1_buffer + 1\n + ((i & 0x1) * BLK_SIZE * YUV420SP_FACTOR)\n + (i >> 1) * (u4_recwidth_cr << 2);\n                    PROFILE_DISABLE_IQ_IT_RECON()\n {\n if(CHECKBIT(u2_chroma_csbp, i))\n {\n                            ps_dec->pf_iquant_itrans_recon_chroma_4x4(\n                                            pi2_level,\n                                            pu1_pred_sblk,\n                                            pu1_pred_sblk,\n                                            u4_recwidth_cr,\n                                            u4_recwidth_cr,\n                                            gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpcr_rem6],\n (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[2],\n                                            u4_scale_v, ai2_tmp, pi2_level);\n }\n else if(pi2_level[0] != 0)\n {\n                            ps_dec->pf_iquant_itrans_recon_chroma_4x4_dc(\n                                            pi2_level,\n                                            pu1_pred_sblk,\n                                            pu1_pred_sblk,\n                                            u4_recwidth_cr,\n                                            u4_recwidth_cr,\n                                            gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpcr_rem6],\n (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[2],\n                                            u4_scale_v, ai2_tmp, pi2_level);\n }\n }\n }\n }\n\n }\n else\n {\n /* If no inverse transform is needed, pass recon buffer pointer */\n /* to Intraprediction module instead of pred buffer pointer     */\n {\n                UWORD16 au2_ngbr_pels[33];\n                UWORD8 *pu1_ngbr_pels = (UWORD8 *)au2_ngbr_pels;\n                UWORD16 *pu2_left_uv;\n                UWORD16 *pu2_topleft_uv;\n                WORD32 use_left1 = (u2_use_left_mb_pack & 0x0ff);\n                WORD32 use_left2 = (u2_use_left_mb_pack & 0xff00) >> 8;\n\n                pu2_topleft_uv = (UWORD16 *)pu1_u_top_left;\n                pu2_left_uv = (UWORD16 *)pu1_uleft;\n\n /* Get neighbour pixels */\n /* left pels */\n if(u2_use_left_mb_pack)\n {\n                    WORD32 i;\n if(use_left1)\n {\n for(i = 0; i < 4; i++)\n                            au2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i\n * u4_recwidth_cr / YUV420SP_FACTOR];\n }\n else\n {\n                        memset(au2_ngbr_pels + 4, 0, 4 * sizeof(UWORD16));\n }\n\n if(use_left2)\n {\n for(i = 4; i < 8; i++)\n                            au2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i\n * u4_recwidth_cr / YUV420SP_FACTOR];\n }\n else\n {\n                        memset(au2_ngbr_pels, 0, 4 * sizeof(UWORD16));\n }\n\n }\n else\n {\n                    memset(au2_ngbr_pels, 0, 8 * sizeof(UWORD16));\n }\n\n /* top left pels */\n                au2_ngbr_pels[8] = *pu2_topleft_uv;\n\n /* top pels */\n if(uc_useTopMB)\n {\n                    memcpy(au2_ngbr_pels + 8 + 1, pu1_top_u,\n 8 * sizeof(UWORD16));\n }\n else\n {\n                    memset(au2_ngbr_pels + 8 + 1, 0, 8 * sizeof(UWORD16));\n }\n\n                PROFILE_DISABLE_INTRA_PRED()\n                ps_dec->apf_intra_pred_chroma[u1_intra_chrom_pred_mode](\n                                pu1_ngbr_pels,\n                                pu1_mb_cb_rei1_buffer,\n 1,\n                                u4_recwidth_cr,\n ((uc_useTopMB << 2) | (use_left2 << 4)\n | use_left1));\n }\n\n }\n\n }\n return OK;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144257,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "WORD32 ih264d_process_intra_mb(dec_struct_t * ps_dec,\n dec_mb_info_t * ps_cur_mb_info,\n                               UWORD8 u1_mb_num)\n{\n    UWORD8 u1_mb_type = ps_cur_mb_info->u1_mb_type;\n    UWORD8 uc_temp = ps_cur_mb_info->u1_mb_ngbr_availablity;\n    UWORD8 u1_top_available = BOOLEAN(uc_temp & TOP_MB_AVAILABLE_MASK);\n    UWORD8 u1_left_available = BOOLEAN(uc_temp & LEFT_MB_AVAILABLE_MASK);\n    UWORD8 u1_use_top_right_mb = BOOLEAN(uc_temp & TOP_RIGHT_MB_AVAILABLE_MASK);\n    UWORD8 u1_use_top_left_mb = BOOLEAN(uc_temp & TOP_LEFT_MB_AVAILABLE_MASK);\n    UWORD8 uc_useTopMB = u1_top_available;\n    UWORD16 u2_use_left_mb = u1_left_available;\n    UWORD16 u2_use_left_mb_pack;\n    UWORD8 *pu1_luma_pred_buffer;\n /* CHANGED CODE */\n    UWORD8 *pu1_luma_rec_buffer;\n    UWORD8 *puc_top;\n\n mb_neigbour_params_t *ps_left_mb;\n mb_neigbour_params_t *ps_top_mb;\n mb_neigbour_params_t *ps_top_right_mb;\n mb_neigbour_params_t *ps_curmb;\n\n    UWORD16 u2_mbx = ps_cur_mb_info->u2_mbx;\n    UWORD32 ui_pred_width, ui_rec_width;\n    WORD16 *pi2_y_coeff;\n    UWORD8 u1_mbaff, u1_topmb, u1_mb_field_decoding_flag;\n    UWORD32 u4_num_pmbair;\n    UWORD16 ui2_luma_csbp = ps_cur_mb_info->u2_luma_csbp;\n    UWORD8 *pu1_yleft, *pu1_ytop_left;\n /* Chroma variables*/\n    UWORD8 *pu1_top_u;\n    UWORD8 *pu1_uleft;\n    UWORD8 *pu1_u_top_left;\n /* CHANGED CODE */\n    UWORD8 *pu1_mb_cb_rei1_buffer, *pu1_mb_cr_rei1_buffer;\n    UWORD32 u4_recwidth_cr;\n /* CHANGED CODE */\n tfr_ctxt_t *ps_frame_buf = ps_dec->ps_frame_buf_ip_recon;\n    UWORD32 u4_luma_dc_only_csbp = 0;\n    UWORD32 u4_luma_dc_only_cbp = 0;\n\n    UWORD8 *pu1_prev_intra4x4_pred_mode_data = (UWORD8 *)ps_dec->pv_proc_tu_coeff_data; //Pointer to keep track of intra4x4_pred_mode data in pv_proc_tu_coeff_data buffer\n    u1_mbaff = ps_dec->ps_cur_slice->u1_mbaff_frame_flag;\n    u1_topmb = ps_cur_mb_info->u1_topmb;\n    u4_num_pmbair = (u1_mb_num >> u1_mbaff);\n\n\n /*--------------------------------------------------------------------*/\n /* Find the current MB's mb params                                    */\n /*--------------------------------------------------------------------*/\n    u1_mb_field_decoding_flag = ps_cur_mb_info->u1_mb_field_decodingflag;\n\n    ps_curmb = ps_cur_mb_info->ps_curmb;\n    ps_top_mb = ps_cur_mb_info->ps_top_mb;\n    ps_left_mb = ps_cur_mb_info->ps_left_mb;\n    ps_top_right_mb = ps_cur_mb_info->ps_top_right_mb;\n\n /*--------------------------------------------------------------------*/\n /* Check whether neighbouring MB is Inter MB and                      */\n /* constrained intra pred is 1.                                       */\n /*--------------------------------------------------------------------*/\n    u2_use_left_mb_pack = (u2_use_left_mb << 8) + u2_use_left_mb;\n\n if(ps_dec->ps_cur_pps->u1_constrained_intra_pred_flag)\n {\n        UWORD8 u1_left = (UWORD8)u2_use_left_mb;\n\n        uc_useTopMB = uc_useTopMB\n && ((ps_top_mb->u1_mb_type != P_MB)\n && (ps_top_mb->u1_mb_type != B_MB));\n        u2_use_left_mb = u2_use_left_mb\n && ((ps_left_mb->u1_mb_type != P_MB)\n && (ps_left_mb->u1_mb_type != B_MB));\n\n        u2_use_left_mb_pack = (u2_use_left_mb << 8) + u2_use_left_mb;\n if(u1_mbaff)\n {\n if(u1_mb_field_decoding_flag ^ ps_left_mb->u1_mb_fld)\n {\n                u1_left = u1_left\n && (((ps_left_mb + 1)->u1_mb_type != P_MB)\n && ((ps_left_mb + 1)->u1_mb_type\n != B_MB));\n                u2_use_left_mb = u2_use_left_mb && u1_left;\n if(u1_mb_field_decoding_flag)\n                    u2_use_left_mb_pack = (u1_left << 8)\n + (u2_use_left_mb_pack & 0xff);\n else\n                    u2_use_left_mb_pack = (u2_use_left_mb << 8)\n + (u2_use_left_mb);\n }\n }\n        u1_use_top_right_mb =\n                        u1_use_top_right_mb\n && ((ps_top_right_mb->u1_mb_type != P_MB)\n && (ps_top_right_mb->u1_mb_type\n != B_MB));\n\n        u1_use_top_left_mb =\n                        u1_use_top_left_mb\n && ((ps_cur_mb_info->u1_topleft_mbtype != P_MB)\n && (ps_cur_mb_info->u1_topleft_mbtype\n != B_MB));\n }\n\n /*********************Common pointer calculations *************************/\n /* CHANGED CODE */\n    pu1_luma_pred_buffer = ps_dec->pu1_y;\n    pu1_luma_rec_buffer = ps_frame_buf->pu1_dest_y + (u4_num_pmbair << 4);\n    pu1_mb_cb_rei1_buffer = ps_frame_buf->pu1_dest_u\n + (u4_num_pmbair << 3) * YUV420SP_FACTOR;\n    pu1_mb_cr_rei1_buffer = ps_frame_buf->pu1_dest_v + (u4_num_pmbair << 3);\n    ui_pred_width = MB_SIZE;\n    ui_rec_width = ps_dec->u2_frm_wd_y << u1_mb_field_decoding_flag;\n    u4_recwidth_cr = ps_dec->u2_frm_wd_uv << u1_mb_field_decoding_flag;\n /************* Current and top luma pointer *****************/\n\n if(u1_mbaff)\n {\n if(u1_topmb == 0)\n {\n            pu1_luma_rec_buffer += (\n                            u1_mb_field_decoding_flag ?\n (ui_rec_width >> 1) :\n (ui_rec_width << 4));\n            pu1_mb_cb_rei1_buffer += (\n                            u1_mb_field_decoding_flag ?\n (u4_recwidth_cr >> 1) :\n (u4_recwidth_cr << 3));\n            pu1_mb_cr_rei1_buffer += (\n                            u1_mb_field_decoding_flag ?\n (u4_recwidth_cr >> 1) :\n (u4_recwidth_cr << 3));\n }\n }\n\n /* CHANGED CODE */\n if(ps_dec->u4_use_intrapred_line_copy == 1)\n {\n        puc_top = ps_dec->pu1_prev_y_intra_pred_line + (ps_cur_mb_info->u2_mbx << 4);\n        pu1_top_u = ps_dec->pu1_prev_u_intra_pred_line\n + (ps_cur_mb_info->u2_mbx << 3) * YUV420SP_FACTOR;\n }\n else\n {\n        puc_top = pu1_luma_rec_buffer - ui_rec_width;\n        pu1_top_u = pu1_mb_cb_rei1_buffer - u4_recwidth_cr;\n }\n /* CHANGED CODE */\n\n /************* Left pointer *****************/\n    pu1_yleft = pu1_luma_rec_buffer - 1;\n    pu1_uleft = pu1_mb_cb_rei1_buffer - 1 * YUV420SP_FACTOR;\n\n /**************Top Left pointer calculation**********/\n    pu1_ytop_left = puc_top - 1;\n    pu1_u_top_left = pu1_top_u - 1 * YUV420SP_FACTOR;\n\n /* CHANGED CODE */\n    PROFILE_DISABLE_INTRA_PRED()\n {\n        pu1_prev_intra4x4_pred_mode_data = (UWORD8 *)ps_dec->pv_proc_tu_coeff_data;\n if(u1_mb_type == I_4x4_MB && ps_cur_mb_info->u1_tran_form8x8 == 0)\n {\n            ps_dec->pv_proc_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_proc_tu_coeff_data + 32);\n\n }\n else if (u1_mb_type == I_4x4_MB && ps_cur_mb_info->u1_tran_form8x8 == 1)\n {\n            ps_dec->pv_proc_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_proc_tu_coeff_data + 8);\n }\n }\n if(!ps_cur_mb_info->u1_tran_form8x8)\n {\n        u4_luma_dc_only_csbp = ih264d_unpack_luma_coeff4x4_mb(ps_dec,\n                                       ps_cur_mb_info,\n 1);\n }\n else\n {\n if(!ps_dec->ps_cur_pps->u1_entropy_coding_mode)\n {\n            u4_luma_dc_only_cbp = ih264d_unpack_luma_coeff4x4_mb(ps_dec,\n                                           ps_cur_mb_info,\n 1);\n }\n else\n {\n            u4_luma_dc_only_cbp = ih264d_unpack_luma_coeff8x8_mb(ps_dec,\n                                           ps_cur_mb_info);\n }\n }\n\n    pi2_y_coeff = ps_dec->pi2_coeff_data;\n\n if(u1_mb_type != I_4x4_MB)\n {\n        UWORD8 u1_intrapred_mode = MB_TYPE_TO_INTRA_16x16_MODE(u1_mb_type);\n /*--------------------------------------------------------------------*/\n /* 16x16 IntraPrediction                                              */\n /*--------------------------------------------------------------------*/\n {\n            UWORD8 u1_packed_modes = (u1_top_available << 1)\n + u1_left_available;\n            UWORD8 u1_err_code =\n (u1_intrapred_mode & 1) ?\n                                            u1_intrapred_mode :\n (u1_intrapred_mode ^ 2);\n\n if((u1_err_code & u1_packed_modes) ^ u1_err_code)\n {\n                u1_intrapred_mode = 0;\n                ps_dec->i4_error_code = ERROR_INTRAPRED;\n }\n }\n {\n            UWORD8 au1_ngbr_pels[33];\n /* Get neighbour pixels */\n /* left pels */\n if(u2_use_left_mb)\n {\n                WORD32 i;\n for(i = 0; i < 16; i++)\n                    au1_ngbr_pels[16 - 1 - i] = pu1_yleft[i * ui_rec_width];\n }\n else\n {\n                memset(au1_ngbr_pels, 0, 16);\n }\n\n /* top left pels */\n            au1_ngbr_pels[16] = *pu1_ytop_left;\n\n /* top pels */\n if(uc_useTopMB)\n {\n                memcpy(au1_ngbr_pels + 16 + 1, puc_top, 16);\n }\n else\n {\n                memset(au1_ngbr_pels + 16 + 1, 0, 16);\n }\n            PROFILE_DISABLE_INTRA_PRED()\n            ps_dec->apf_intra_pred_luma_16x16[u1_intrapred_mode](\n                            au1_ngbr_pels, pu1_luma_rec_buffer, 1, ui_rec_width,\n ((uc_useTopMB << 2) | u2_use_left_mb));\n }\n {\n            UWORD32 i;\n            WORD16 ai2_tmp[16];\n for(i = 0; i < 16; i++)\n {\n                WORD16 *pi2_level = pi2_y_coeff + (i << 4);\n                UWORD8 *pu1_pred_sblk = pu1_luma_rec_buffer\n + ((i & 0x3) * BLK_SIZE)\n + (i >> 2) * (ui_rec_width << 2);\n                PROFILE_DISABLE_IQ_IT_RECON()\n {\n if(CHECKBIT(ps_cur_mb_info->u2_luma_csbp, i))\n {\n                        ps_dec->pf_iquant_itrans_recon_luma_4x4(\n                                        pi2_level,\n                                        pu1_pred_sblk,\n                                        pu1_pred_sblk,\n                                        ui_rec_width,\n                                        ui_rec_width,\n                                        gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],\n (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],\n                                        ps_cur_mb_info->u1_qp_div6, ai2_tmp, 1,\n                                        pi2_level);\n }\n else if((CHECKBIT(u4_luma_dc_only_csbp, i)) && pi2_level[0] != 0)\n {\n                        ps_dec->pf_iquant_itrans_recon_luma_4x4_dc(\n                                        pi2_level,\n                                        pu1_pred_sblk,\n                                        pu1_pred_sblk,\n                                        ui_rec_width,\n                                        ui_rec_width,\n                                        gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],\n (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],\n                                        ps_cur_mb_info->u1_qp_div6, ai2_tmp, 1,\n                                        pi2_level);\n }\n }\n }\n }\n }\n else if(!ps_cur_mb_info->u1_tran_form8x8)\n {\n        UWORD8 u1_is_left_sub_block, u1_is_top_sub_block = uc_useTopMB;\n        UWORD8 u1_sub_blk_x, u1_sub_blk_y, u1_sub_mb_num;\n        WORD8 i1_top_pred_mode;\n        WORD8 i1_left_pred_mode;\n        UWORD8 *pu1_top, *pu1_left, *pu1_top_left, *pu1_top_right;\n        WORD8 *pi1_cur_pred_mode, *pi1_left_pred_mode, *pc_topPredMode;\n        UWORD16 ui2_left_pred_buf_width = 0xffff;\n        WORD8 i1_intra_pred;\n        UWORD8 *pu1_prev_intra4x4_pred_mode_flag = pu1_prev_intra4x4_pred_mode_data;\n        UWORD8 *pu1_rem_intra4x4_pred_mode = pu1_prev_intra4x4_pred_mode_data + 16;\n        WORD16 *pi2_y_coeff1;\n        UWORD8 u1_cur_sub_block;\n        UWORD16 ui2_top_rt_mask;\n\n /*--------------------------------------------------------------------*/\n /* 4x4 IntraPrediction                                                */\n /*--------------------------------------------------------------------*/\n /* Calculation of Top Right subblock mask                             */\n /*                                                                    */\n /* (a) Set it to default mask                                         */\n /*     [It has 0 for sublocks which will never have top-right sub block] */\n /*                                                                    */\n /* (b) If top MB is not available                                     */\n /*      Clear the bits of the first row sub blocks                    */\n /*                                                                    */\n /* (c) Set/Clear bit for top-right sublock of MB                      */\n /*      [5 sub-block in decoding order] based on TOP RIGHT MB availablity */\n /*--------------------------------------------------------------------*/\n\n        pu1_top = puc_top;\n\n        ui2_top_rt_mask = (u1_use_top_right_mb << 3) | (0x5750);\n if(uc_useTopMB)\n            ui2_top_rt_mask |= 0x7;\n\n /*Top Related initialisations*/\n\n\n        pi1_cur_pred_mode = ps_cur_mb_info->ps_curmb->pi1_intrapredmodes;\n        pc_topPredMode = ps_cur_mb_info->ps_top_mb->pi1_intrapredmodes;\n /*--------------------------------------\n         if(u1_mbaff)\n         {\n\n         pi1_cur_pred_mode += (u2_mbx << 2);\n         pc_topPredMode = pi1_cur_pred_mode + ps_cur_mb_info->i1_offset;\n         pi1_cur_pred_mode += (u1_topmb) ? 0: 4;\n         }*/\n\n if(u1_top_available)\n {\n if(ps_top_mb->u1_mb_type == I_4x4_MB)\n *(WORD32*)pi1_cur_pred_mode = *(WORD32*)pc_topPredMode;\n else\n *(WORD32*)pi1_cur_pred_mode =\n (uc_useTopMB) ? DC_DC_DC_DC : NOT_VALID;\n }\n else\n *(WORD32*)pi1_cur_pred_mode = NOT_VALID;\n /* CHANGED CODE */\n\n /* CHANGED CODE */\n\n /*Left Related initialisations*/\n        pi1_left_pred_mode = ps_dec->pi1_left_pred_mode;\n if(!u1_mbaff)\n {\n\n if(u1_left_available)\n {\n\n if(ps_left_mb->u1_mb_type != I_4x4_MB)\n *(WORD32*)pi1_left_pred_mode =\n (u2_use_left_mb_pack) ?\n                                    DC_DC_DC_DC :\n                                                            NOT_VALID;\n\n }\n else\n {\n\n *(WORD32*)pi1_left_pred_mode = NOT_VALID;\n }\n\n }\n else\n {\n            UWORD8 u1_curMbfld = ps_cur_mb_info->u1_mb_field_decodingflag;\n            UWORD8 u1_leftMbfld = ps_left_mb->u1_mb_fld;\n\n if(u1_curMbfld ^ u1_leftMbfld)\n {\n\n if(u1_topmb\n | ((u1_topmb == 0)\n && ((ps_curmb - 1)->u1_mb_type\n != I_4x4_MB)))\n {\n if(u1_left_available)\n {\n if(ps_left_mb->u1_mb_type != I_4x4_MB)\n {\n if(CHECKBIT(u2_use_left_mb_pack,0) == 0)\n *(WORD32*)pi1_left_pred_mode = NOT_VALID;\n else\n *(WORD32*)pi1_left_pred_mode = DC_DC_DC_DC;\n }\n }\n else\n *(WORD32*)pi1_left_pred_mode = NOT_VALID;\n\n if(u1_curMbfld)\n {\n if(u1_left_available)\n {\n if((ps_left_mb + 1)->u1_mb_type != I_4x4_MB)\n {\n if(u2_use_left_mb_pack >> 8)\n *(WORD32*)(pi1_left_pred_mode + 4) =\n                                                    DC_DC_DC_DC;\n else\n *(WORD32*)(pi1_left_pred_mode + 4) =\n                                                    NOT_VALID;\n }\n }\n else\n *(WORD32*)(pi1_left_pred_mode + 4) = NOT_VALID;\n                        pi1_left_pred_mode[1] = pi1_left_pred_mode[2];\n                        pi1_left_pred_mode[2] = pi1_left_pred_mode[4];\n                        pi1_left_pred_mode[3] = pi1_left_pred_mode[6];\n *(WORD32*)(pi1_left_pred_mode + 4) =\n *(WORD32*)pi1_left_pred_mode;\n }\n else\n {\n\n                        pi1_left_pred_mode[7] = pi1_left_pred_mode[3];\n                        pi1_left_pred_mode[6] = pi1_left_pred_mode[3];\n                        pi1_left_pred_mode[5] = pi1_left_pred_mode[2];\n                        pi1_left_pred_mode[4] = pi1_left_pred_mode[2];\n                        pi1_left_pred_mode[3] = pi1_left_pred_mode[1];\n                        pi1_left_pred_mode[2] = pi1_left_pred_mode[1];\n                        pi1_left_pred_mode[1] = pi1_left_pred_mode[0];\n }\n }\n                pi1_left_pred_mode += (u1_topmb) ? 0 : 4;\n }\n else\n {\n\n                pi1_left_pred_mode += (u1_topmb) ? 0 : 4;\n if(u1_left_available)\n {\n\n if(ps_left_mb->u1_mb_type != I_4x4_MB)\n *(WORD32*)pi1_left_pred_mode =\n (u2_use_left_mb_pack) ?\n                                        DC_DC_DC_DC :\n                                                                NOT_VALID;\n }\n else\n *(WORD32*)pi1_left_pred_mode = NOT_VALID;\n }\n }\n /* One time pointer initialisations*/\n        pi2_y_coeff1 = pi2_y_coeff;\n        pu1_top_left = pu1_ytop_left;\n\n /* Scan the sub-blocks in Raster Scan Order */\n for(u1_sub_mb_num = 0; u1_sub_mb_num < 16; u1_sub_mb_num++)\n {\n            UWORD8 au1_ngbr_pels[13];\n\n            u1_sub_blk_x = u1_sub_mb_num & 0x3;\n            u1_sub_blk_y = u1_sub_mb_num >> 2;\n            i1_top_pred_mode = pi1_cur_pred_mode[u1_sub_blk_x];\n            i1_left_pred_mode = pi1_left_pred_mode[u1_sub_blk_y];\n            u1_use_top_right_mb = (!!CHECKBIT(ui2_top_rt_mask, u1_sub_mb_num));\n\n /*********** left subblock availability**********/\n if(u1_sub_blk_x)\n                u1_is_left_sub_block = 1;\n else\n                u1_is_left_sub_block =\n (u1_sub_blk_y < 2) ?\n (CHECKBIT(u2_use_left_mb_pack,\n 0)) :\n (u2_use_left_mb_pack >> 8);\n\n /* CHANGED CODE */\n if(u1_sub_blk_y)\n                u1_is_top_sub_block = 1;\n\n /* CHANGED CODE */\n /***************** Top *********************/\n if(ps_dec->u4_use_intrapred_line_copy == 1)\n {\n\n if(u1_sub_blk_y)\n                    pu1_top = pu1_luma_rec_buffer - ui_rec_width;\n else\n                    pu1_top = puc_top + (u1_sub_blk_x << 2);\n }\n else\n {\n                pu1_top = pu1_luma_rec_buffer - ui_rec_width;\n }\n /***************** Top Right *********************/\n            pu1_top_right = pu1_top + 4;\n /***************** Top Left *********************/\n            pu1_top_left = pu1_top - 1;\n /***************** Left *********************/\n            pu1_left = pu1_luma_rec_buffer - 1;\n /* CHANGED CODE */\n\n /*---------------------------------------------------------------*/\n /* Calculation of Intra prediction mode                          */\n /*---------------------------------------------------------------*/\n            i1_intra_pred = ((i1_left_pred_mode < 0) | (i1_top_pred_mode < 0)) ?\n                            DC : MIN(i1_left_pred_mode, i1_top_pred_mode);\n {\n                UWORD8 u1_packed_modes = (u1_is_top_sub_block << 1)\n + u1_is_left_sub_block;\n                UWORD8 *pu1_intra_err_codes =\n (UWORD8 *)gau1_ih264d_intra_pred_err_code;\n                UWORD8 uc_b2b0 = ((u1_sub_mb_num & 4) >> 1) | (u1_sub_mb_num & 1);\n                UWORD8 uc_b3b1 = ((u1_sub_mb_num & 8) >> 2)\n | ((u1_sub_mb_num & 2) >> 1);\n\n                u1_cur_sub_block = (uc_b3b1 << 2) + uc_b2b0;\n                PROFILE_DISABLE_INTRA_PRED()\n if(!pu1_prev_intra4x4_pred_mode_flag[u1_cur_sub_block])\n {\n                    i1_intra_pred =\n                                    pu1_rem_intra4x4_pred_mode[u1_cur_sub_block]\n\n                                                     + (pu1_rem_intra4x4_pred_mode[u1_cur_sub_block]\n                                                                     >= i1_intra_pred);\n                 }\n                i1_intra_pred = CLIP3(0, 8, i1_intra_pred);\n                 {\n                     UWORD8 u1_err_code = pu1_intra_err_codes[i1_intra_pred];\n \n if((u1_err_code & u1_packed_modes) ^ u1_err_code)\n {\n                        i1_intra_pred = 0;\n                        ps_dec->i4_error_code = ERROR_INTRAPRED;\n }\n\n }\n }\n {\n /* Get neighbour pixels */\n /* left pels */\n if(u1_is_left_sub_block)\n {\n                    WORD32 i;\n for(i = 0; i < 4; i++)\n                        au1_ngbr_pels[4 - 1 - i] = pu1_left[i * ui_rec_width];\n }\n else\n {\n                    memset(au1_ngbr_pels, 0, 4);\n }\n\n /* top left pels */\n                au1_ngbr_pels[4] = *pu1_top_left;\n\n /* top pels */\n if(u1_is_top_sub_block)\n {\n                    memcpy(au1_ngbr_pels + 4 + 1, pu1_top, 4);\n }\n else\n {\n                    memset(au1_ngbr_pels + 4 + 1, 0, 4);\n }\n\n /* top right pels */\n if(u1_use_top_right_mb)\n {\n                    memcpy(au1_ngbr_pels + 4 * 2 + 1, pu1_top_right, 4);\n }\n else if(u1_is_top_sub_block)\n {\n                    memset(au1_ngbr_pels + 4 * 2 + 1, au1_ngbr_pels[4 * 2], 4);\n }\n }\n            PROFILE_DISABLE_INTRA_PRED()\n            ps_dec->apf_intra_pred_luma_4x4[i1_intra_pred](\n                            au1_ngbr_pels, pu1_luma_rec_buffer, 1,\n                            ui_rec_width,\n ((u1_is_top_sub_block << 2) | u1_is_left_sub_block));\n\n /* CHANGED CODE */\n if(CHECKBIT(ui2_luma_csbp, u1_sub_mb_num))\n {\n                WORD16 ai2_tmp[16];\n                PROFILE_DISABLE_IQ_IT_RECON()\n {\n if(CHECKBIT(u4_luma_dc_only_csbp, u1_sub_mb_num))\n {\n                        ps_dec->pf_iquant_itrans_recon_luma_4x4_dc(\n                                        pi2_y_coeff1,\n                                        pu1_luma_rec_buffer,\n                                        pu1_luma_rec_buffer,\n                                        ui_rec_width,\n                                        ui_rec_width,\n                                        gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],\n (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],\n                                        ps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,\n                                        NULL);\n }\n else\n {\n                        ps_dec->pf_iquant_itrans_recon_luma_4x4(\n                                        pi2_y_coeff1,\n                                        pu1_luma_rec_buffer,\n                                        pu1_luma_rec_buffer,\n                                        ui_rec_width,\n                                        ui_rec_width,\n                                        gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],\n (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],\n                                        ps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,\n                                        NULL);\n }\n }\n\n }\n\n /*---------------------------------------------------------------*/\n /* Update sub block number                                       */\n /*---------------------------------------------------------------*/\n            pi2_y_coeff1 += 16;\n            pu1_luma_rec_buffer +=\n (u1_sub_blk_x == 3) ? (ui_rec_width << 2) - 12 : 4;\n            pu1_luma_pred_buffer +=\n (u1_sub_blk_x == 3) ? (ui_pred_width << 2) - 12 : 4;\n /* CHANGED CODE */\n            pi1_cur_pred_mode[u1_sub_blk_x] = i1_intra_pred;\n            pi1_left_pred_mode[u1_sub_blk_y] = i1_intra_pred;\n }\n }\n else if((u1_mb_type == I_4x4_MB) && (ps_cur_mb_info->u1_tran_form8x8 == 1))\n {\n        UWORD8 u1_is_left_sub_block, u1_is_top_sub_block = uc_useTopMB;\n        UWORD8 u1_sub_blk_x, u1_sub_blk_y, u1_sub_mb_num;\n        WORD8 i1_top_pred_mode;\n        WORD8 i1_left_pred_mode;\n        UWORD8 *pu1_top, *pu1_left, *pu1_top_left;\n        WORD8 *pi1_cur_pred_mode, *pi1_left_pred_mode, *pc_topPredMode;\n        UWORD16 ui2_left_pred_buf_width = 0xffff;\n        WORD8 i1_intra_pred;\n        UWORD8 *pu1_prev_intra4x4_pred_mode_flag = pu1_prev_intra4x4_pred_mode_data;\n        UWORD8 *pu1_rem_intra4x4_pred_mode = pu1_prev_intra4x4_pred_mode_data + 4;\n        WORD16 *pi2_y_coeff1;\n        UWORD16 ui2_top_rt_mask;\n        UWORD32 u4_4x4_left_offset = 0;\n\n /*--------------------------------------------------------------------*/\n /* 8x8 IntraPrediction                                                */\n /*--------------------------------------------------------------------*/\n /* Calculation of Top Right subblock mask                             */\n /*                                                                    */\n /* (a) Set it to default mask                                         */\n /*  [It has 0 for sublocks which will never have top-right sub block] */\n /*                                                                    */\n /* (b) If top MB is not available                                     */\n /*      Clear the bits of the first row sub blocks                    */\n /*                                                                    */\n /* (c) Set/Clear bit for top-right sublock of MB                      */\n /*  [5 sub-block in decoding order] based on TOP RIGHT MB availablity */\n /*                                                                    */\n /* ui2_top_rt_mask: marks availibility of top right(neighbour)         */\n /* in the 8x8 Block ordering                                          */\n /*                                                                    */\n /*      tr0   tr1                                                     */\n /*   0    1   tr3                                                     */\n /*   2    3                                                           */\n /*                                                                    */\n /*  Top rights for 0 is in top MB                                     */\n /*  top right of 1 will be in top right MB                            */\n /*  top right of 3 in right MB and hence not available                */\n /*  This corresponds to ui2_top_rt_mask  having default value 0x4      */\n /*--------------------------------------------------------------------*/\n\n        ui2_top_rt_mask = (u1_use_top_right_mb << 1) | (0x4);\n\n if(uc_useTopMB)\n {\n            ui2_top_rt_mask |= 0x1;\n }\n\n /* Top Related initialisations */\n        pi1_cur_pred_mode = ps_cur_mb_info->ps_curmb->pi1_intrapredmodes;\n        pc_topPredMode = ps_cur_mb_info->ps_top_mb->pi1_intrapredmodes;\n /*\n         if(u1_mbaff)\n         {\n         pi1_cur_pred_mode += (u2_mbx << 2);\n         pc_topPredMode = pi1_cur_pred_mode + ps_cur_mb_info->i1_offset;\n         pi1_cur_pred_mode += (u1_topmb) ? 0: 4;\n         }\n         */\n if(u1_top_available)\n {\n if(ps_top_mb->u1_mb_type == I_4x4_MB)\n {\n *(WORD32*)pi1_cur_pred_mode = *(WORD32*)pc_topPredMode;\n }\n else\n {\n *(WORD32*)pi1_cur_pred_mode =\n (uc_useTopMB) ? DC_DC_DC_DC : NOT_VALID;\n }\n }\n else\n {\n *(WORD32*)pi1_cur_pred_mode = NOT_VALID;\n }\n\n        pu1_top = puc_top - 8;\n\n /*Left Related initialisations*/\n        pi1_left_pred_mode = ps_dec->pi1_left_pred_mode;\n\n if(!u1_mbaff)\n {\n if(u1_left_available)\n {\n if(ps_left_mb->u1_mb_type != I_4x4_MB)\n {\n *(WORD32*)pi1_left_pred_mode =\n (u2_use_left_mb_pack) ?\n                                    DC_DC_DC_DC :\n                                                            NOT_VALID;\n }\n }\n else\n {\n *(WORD32*)pi1_left_pred_mode = NOT_VALID;\n }\n }\n else\n {\n            UWORD8 u1_curMbfld = ps_cur_mb_info->u1_mb_field_decodingflag;\n\n            UWORD8 u1_leftMbfld = ps_left_mb->u1_mb_fld;\n\n if((!u1_curMbfld) && (u1_leftMbfld))\n {\n                u4_4x4_left_offset = 1;\n }\n\n if(u1_curMbfld ^ u1_leftMbfld)\n {\n\n if(u1_topmb\n | ((u1_topmb == 0)\n && ((ps_curmb - 1)->u1_mb_type\n != I_4x4_MB)))\n\n {\n if(u1_left_available)\n {\n if(ps_left_mb->u1_mb_type != I_4x4_MB)\n {\n if(CHECKBIT(u2_use_left_mb_pack,0) == 0)\n {\n *(WORD32*)pi1_left_pred_mode = NOT_VALID;\n }\n else\n {\n *(WORD32*)pi1_left_pred_mode = DC_DC_DC_DC;\n }\n }\n }\n else\n {\n *(WORD32*)pi1_left_pred_mode = NOT_VALID;\n }\n\n if(u1_curMbfld)\n {\n if(u1_left_available)\n {\n if((ps_left_mb + 1)->u1_mb_type != I_4x4_MB)\n {\n if(u2_use_left_mb_pack >> 8)\n {\n *(WORD32*)(pi1_left_pred_mode + 4) =\n                                                    DC_DC_DC_DC;\n }\n else\n {\n *(WORD32*)(pi1_left_pred_mode + 4) =\n                                                    NOT_VALID;\n }\n }\n }\n else\n {\n *(WORD32*)(pi1_left_pred_mode + 4) = NOT_VALID;\n }\n\n                        pi1_left_pred_mode[1] = pi1_left_pred_mode[2];\n                        pi1_left_pred_mode[2] = pi1_left_pred_mode[4];\n                        pi1_left_pred_mode[3] = pi1_left_pred_mode[6];\n *(WORD32*)(pi1_left_pred_mode + 4) =\n *(WORD32*)pi1_left_pred_mode;\n }\n else\n {\n                        pi1_left_pred_mode[7] = pi1_left_pred_mode[3];\n                        pi1_left_pred_mode[6] = pi1_left_pred_mode[3];\n                        pi1_left_pred_mode[5] = pi1_left_pred_mode[2];\n                        pi1_left_pred_mode[4] = pi1_left_pred_mode[2];\n                        pi1_left_pred_mode[3] = pi1_left_pred_mode[1];\n                        pi1_left_pred_mode[2] = pi1_left_pred_mode[1];\n                        pi1_left_pred_mode[1] = pi1_left_pred_mode[0];\n }\n }\n                pi1_left_pred_mode += (u1_topmb) ? 0 : 4;\n }\n else\n {\n                pi1_left_pred_mode += (u1_topmb) ? 0 : 4;\n\n if(u1_left_available)\n {\n if(ps_left_mb->u1_mb_type != I_4x4_MB)\n {\n *(WORD32*)pi1_left_pred_mode =\n (u2_use_left_mb_pack) ?\n                                        DC_DC_DC_DC :\n                                                                NOT_VALID;\n }\n }\n else\n {\n *(WORD32*)pi1_left_pred_mode = NOT_VALID;\n }\n }\n }\n\n /* One time pointer initialisations*/\n        pi2_y_coeff1 = pi2_y_coeff;\n\n if(u1_use_top_left_mb)\n {\n            pu1_top_left = pu1_ytop_left;\n }\n else\n {\n            pu1_top_left = NULL;\n }\n\n /* Scan the sub-blocks in Raster Scan Order */\n for(u1_sub_mb_num = 0; u1_sub_mb_num < 4; u1_sub_mb_num++)\n {\n            u1_sub_blk_x = (u1_sub_mb_num & 0x1);\n            u1_sub_blk_y = (u1_sub_mb_num >> 1);\n            i1_top_pred_mode = pi1_cur_pred_mode[u1_sub_blk_x << 1];\n            i1_left_pred_mode = pi1_left_pred_mode[u1_sub_blk_y << 1];\n\n if(2 == u1_sub_mb_num)\n {\n                i1_left_pred_mode = pi1_left_pred_mode[(u1_sub_blk_y << 1)\n + u4_4x4_left_offset];\n }\n\n            u1_use_top_right_mb = (!!CHECKBIT(ui2_top_rt_mask, u1_sub_mb_num));\n\n /*********** left subblock availability**********/\n if(u1_sub_blk_x)\n {\n                u1_is_left_sub_block = 1;\n }\n else\n {\n                u1_is_left_sub_block =\n (u1_sub_blk_y < 1) ?\n (CHECKBIT(u2_use_left_mb_pack,\n 0)) :\n (u2_use_left_mb_pack >> 8);\n }\n\n /***************** Top *********************/\n if(u1_sub_blk_y)\n {\n                u1_is_top_sub_block = 1;\n                pu1_top = /*pu1_luma_pred_buffer*/pu1_luma_rec_buffer - ui_rec_width;\n }\n else\n {\n                pu1_top += 8;\n }\n\n /***************** Left *********************/\n if((u1_sub_blk_x) | (u4_num_pmbair != 0))\n {\n                pu1_left = /*pu1_luma_pred_buffer*/pu1_luma_rec_buffer - 1;\n                ui2_left_pred_buf_width = ui_rec_width;\n }\n else\n {\n                pu1_left = pu1_yleft;\n                pu1_yleft += (ui_rec_width << 3);\n                ui2_left_pred_buf_width = ui_rec_width;\n }\n\n /***************** Top Left *********************/\n if(u1_sub_mb_num)\n {\n                pu1_top_left = (u1_sub_blk_x) ?\n                                pu1_top - 1 : pu1_left - ui_rec_width;\n\n if((u1_sub_blk_x && (!u1_is_top_sub_block))\n || ((!u1_sub_blk_x) && (!u1_is_left_sub_block)))\n {\n                    pu1_top_left = NULL;\n }\n }\n\n /*---------------------------------------------------------------*/\n /* Calculation of Intra prediction mode                          */\n /*---------------------------------------------------------------*/\n            i1_intra_pred = ((i1_left_pred_mode < 0) | (i1_top_pred_mode < 0)) ?\n                            DC : MIN(i1_left_pred_mode, i1_top_pred_mode);\n {\n                UWORD8 u1_packed_modes = (u1_is_top_sub_block << 1)\n + u1_is_left_sub_block;\n                UWORD8 *pu1_intra_err_codes =\n (UWORD8 *)gau1_ih264d_intra_pred_err_code;\n\n /********************************************************************/\n /* Same intra4x4_pred_mode array is filled with intra4x4_pred_mode  */\n /* for a MB with 8x8 intrapredicition                               */\n /********************************************************************/\n                PROFILE_DISABLE_INTRA_PRED()\n if(!pu1_prev_intra4x4_pred_mode_flag[u1_sub_mb_num])\n {\n                    i1_intra_pred = pu1_rem_intra4x4_pred_mode[u1_sub_mb_num]\n\n                                     + (pu1_rem_intra4x4_pred_mode[u1_sub_mb_num]\n                                                     >= i1_intra_pred);\n                 }\n                i1_intra_pred = CLIP3(0, 8, i1_intra_pred);\n                 {\n                     UWORD8 u1_err_code = pu1_intra_err_codes[i1_intra_pred];\n \n if((u1_err_code & u1_packed_modes) ^ u1_err_code)\n {\n                        i1_intra_pred = 0;\n                        ps_dec->i4_error_code = ERROR_INTRAPRED;\n }\n }\n }\n\n {\n                UWORD8 au1_ngbr_pels[25];\n                WORD32 ngbr_avail;\n                ngbr_avail = u1_is_left_sub_block << 0;\n                ngbr_avail |= u1_is_top_sub_block << 2;\n\n if(pu1_top_left)\n                    ngbr_avail |= 1 << 1;\n\n                ngbr_avail |= u1_use_top_right_mb << 3;\n                PROFILE_DISABLE_INTRA_PRED()\n {\n                    ps_dec->pf_intra_pred_ref_filtering(pu1_left, pu1_top_left,\n                                                        pu1_top, au1_ngbr_pels,\n                                                        ui2_left_pred_buf_width,\n                                                        ngbr_avail);\n\n                    ps_dec->apf_intra_pred_luma_8x8[i1_intra_pred](\n                                    au1_ngbr_pels, pu1_luma_rec_buffer, 1,\n                                    ui_rec_width,\n ((u1_is_top_sub_block << 2) | u1_is_left_sub_block));\n }\n }\n\n /* Inverse Transform and Reconstruction */\n if(CHECKBIT(ps_cur_mb_info->u1_cbp, u1_sub_mb_num))\n {\n                WORD16 *pi2_scale_matrix_ptr;\n                WORD16 ai2_tmp[64];\n\n                pi2_scale_matrix_ptr =\n                                ps_dec->s_high_profile.i2_scalinglist8x8[0];\n                PROFILE_DISABLE_IQ_IT_RECON()\n {\n if(CHECKBIT(u4_luma_dc_only_cbp, u1_sub_mb_num))\n {\n                        ps_dec->pf_iquant_itrans_recon_luma_8x8_dc(\n                                        pi2_y_coeff1,\n                                        pu1_luma_rec_buffer,\n                                        pu1_luma_rec_buffer,\n                                        ui_rec_width,\n                                        ui_rec_width,\n                                        gau1_ih264d_dequant8x8_cavlc[ps_cur_mb_info->u1_qp_rem6],\n (UWORD16 *)pi2_scale_matrix_ptr,\n                                        ps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,\n                                        NULL);\n }\n else\n {\n                        ps_dec->pf_iquant_itrans_recon_luma_8x8(\n                                        pi2_y_coeff1,\n                                        pu1_luma_rec_buffer,\n                                        pu1_luma_rec_buffer,\n                                        ui_rec_width,\n                                        ui_rec_width,\n                                        gau1_ih264d_dequant8x8_cavlc[ps_cur_mb_info->u1_qp_rem6],\n (UWORD16 *)pi2_scale_matrix_ptr,\n                                        ps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,\n                                        NULL);\n }\n }\n\n }\n\n /*---------------------------------------------------------------*/\n /* Update sub block number                                       */\n /*---------------------------------------------------------------*/\n            pi2_y_coeff1 += 64;\n\n            pu1_luma_rec_buffer +=\n (u1_sub_blk_x == 1) ?\n (ui_rec_width << 3) - (8 * 1) : 8;\n\n /*---------------------------------------------------------------*/\n /* Pred mode filled in terms of 4x4 block so replicated in 2     */\n /* locations.                                                    */\n /*---------------------------------------------------------------*/\n            pi1_cur_pred_mode[u1_sub_blk_x << 1] = i1_intra_pred;\n            pi1_cur_pred_mode[(u1_sub_blk_x << 1) + 1] = i1_intra_pred;\n            pi1_left_pred_mode[u1_sub_blk_y << 1] = i1_intra_pred;\n            pi1_left_pred_mode[(u1_sub_blk_y << 1) + 1] = i1_intra_pred;\n }\n }\n /* Decode Chroma Block */\n    ih264d_unpack_chroma_coeff4x4_mb(ps_dec,\n                                     ps_cur_mb_info);\n /*--------------------------------------------------------------------*/\n /* Chroma Blocks decoding                                             */\n /*--------------------------------------------------------------------*/\n {\n        UWORD8 u1_intra_chrom_pred_mode;\n        UWORD8 u1_chroma_cbp = (UWORD8)(ps_cur_mb_info->u1_cbp >> 4);\n\n /*--------------------------------------------------------------------*/\n /* Perform Chroma intra prediction                                    */\n /*--------------------------------------------------------------------*/\n\n        u1_intra_chrom_pred_mode = CHROMA_TO_LUMA_INTRA_MODE(\n                        ps_cur_mb_info->u1_chroma_pred_mode);\n\n {\n            UWORD8 u1_packed_modes = (u1_top_available << 1)\n + u1_left_available;\n            UWORD8 u1_err_code =\n (u1_intra_chrom_pred_mode & 1) ?\n                                            u1_intra_chrom_pred_mode :\n (u1_intra_chrom_pred_mode ^ 2);\n if((u1_err_code & u1_packed_modes) ^ u1_err_code)\n {\n                u1_intra_chrom_pred_mode = 0;\n                ps_dec->i4_error_code = ERROR_INTRAPRED;\n }\n }\n\n /* CHANGED CODE */\n if(u1_chroma_cbp != CBPC_ALLZERO)\n {\n            UWORD16 u2_chroma_csbp =\n (u1_chroma_cbp == CBPC_ACZERO) ?\n 0 : ps_cur_mb_info->u2_chroma_csbp;\n            UWORD32 u4_scale_u;\n            UWORD32 u4_scale_v;\n\n {\n                UWORD16 au2_ngbr_pels[33];\n                UWORD8 *pu1_ngbr_pels = (UWORD8 *)au2_ngbr_pels;\n                UWORD16 *pu2_left_uv;\n                UWORD16 *pu2_topleft_uv;\n                WORD32 use_left1 = (u2_use_left_mb_pack & 0x0ff);\n                WORD32 use_left2 = (u2_use_left_mb_pack & 0xff00) >> 8;\n\n                pu2_left_uv = (UWORD16 *)pu1_uleft;\n                pu2_topleft_uv = (UWORD16 *)pu1_u_top_left;\n /* Get neighbour pixels */\n /* left pels */\n if(u2_use_left_mb_pack)\n {\n                    WORD32 i;\n if(use_left1)\n {\n for(i = 0; i < 4; i++)\n                            au2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i\n * u4_recwidth_cr / YUV420SP_FACTOR];\n }\n else\n {\n                        memset(au2_ngbr_pels + 4, 0, 4 * sizeof(UWORD16));\n }\n\n if(use_left2)\n {\n for(i = 4; i < 8; i++)\n                            au2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i\n * u4_recwidth_cr / YUV420SP_FACTOR];\n }\n else\n {\n                        memset(au2_ngbr_pels, 0, 4 * sizeof(UWORD16));\n }\n }\n else\n {\n                    memset(au2_ngbr_pels, 0, 8 * sizeof(UWORD16));\n }\n\n /* top left pels */\n                au2_ngbr_pels[8] = *pu2_topleft_uv;\n\n /* top pels */\n if(uc_useTopMB)\n {\n                    memcpy(au2_ngbr_pels + 8 + 1, pu1_top_u,\n 8 * sizeof(UWORD16));\n }\n else\n {\n                    memset(au2_ngbr_pels + 8 + 1, 0, 8 * sizeof(UWORD16));\n }\n\n                PROFILE_DISABLE_INTRA_PRED()\n                ps_dec->apf_intra_pred_chroma[u1_intra_chrom_pred_mode](\n                                pu1_ngbr_pels,\n                                pu1_mb_cb_rei1_buffer,\n 1,\n                                u4_recwidth_cr,\n ((uc_useTopMB << 2) | (use_left2 << 4)\n | use_left1));\n }\n            u4_scale_u = ps_cur_mb_info->u1_qpc_div6;\n            u4_scale_v = ps_cur_mb_info->u1_qpcr_div6;\n            pi2_y_coeff = ps_dec->pi2_coeff_data;\n\n {\n                UWORD32 i;\n                WORD16 ai2_tmp[16];\n for(i = 0; i < 4; i++)\n {\n                    WORD16 *pi2_level = pi2_y_coeff + (i << 4);\n                    UWORD8 *pu1_pred_sblk = pu1_mb_cb_rei1_buffer\n + ((i & 0x1) * BLK_SIZE * YUV420SP_FACTOR)\n + (i >> 1) * (u4_recwidth_cr << 2);\n                    PROFILE_DISABLE_IQ_IT_RECON()\n {\n if(CHECKBIT(u2_chroma_csbp, i))\n {\n                            ps_dec->pf_iquant_itrans_recon_chroma_4x4(\n                                            pi2_level,\n                                            pu1_pred_sblk,\n                                            pu1_pred_sblk,\n                                            u4_recwidth_cr,\n                                            u4_recwidth_cr,\n                                            gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpc_rem6],\n (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[1],\n                                            u4_scale_u, ai2_tmp, pi2_level);\n }\n else if(pi2_level[0] != 0)\n {\n                            ps_dec->pf_iquant_itrans_recon_chroma_4x4_dc(\n                                            pi2_level,\n                                            pu1_pred_sblk,\n                                            pu1_pred_sblk,\n                                            u4_recwidth_cr,\n                                            u4_recwidth_cr,\n                                            gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpc_rem6],\n (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[1],\n                                            u4_scale_u, ai2_tmp, pi2_level);\n }\n }\n\n }\n }\n\n            pi2_y_coeff += MB_CHROM_SIZE;\n            u2_chroma_csbp = u2_chroma_csbp >> 4;\n {\n                UWORD32 i;\n                WORD16 ai2_tmp[16];\n for(i = 0; i < 4; i++)\n {\n                    WORD16 *pi2_level = pi2_y_coeff + (i << 4);\n                    UWORD8 *pu1_pred_sblk = pu1_mb_cb_rei1_buffer + 1\n + ((i & 0x1) * BLK_SIZE * YUV420SP_FACTOR)\n + (i >> 1) * (u4_recwidth_cr << 2);\n                    PROFILE_DISABLE_IQ_IT_RECON()\n {\n if(CHECKBIT(u2_chroma_csbp, i))\n {\n                            ps_dec->pf_iquant_itrans_recon_chroma_4x4(\n                                            pi2_level,\n                                            pu1_pred_sblk,\n                                            pu1_pred_sblk,\n                                            u4_recwidth_cr,\n                                            u4_recwidth_cr,\n                                            gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpcr_rem6],\n (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[2],\n                                            u4_scale_v, ai2_tmp, pi2_level);\n }\n else if(pi2_level[0] != 0)\n {\n                            ps_dec->pf_iquant_itrans_recon_chroma_4x4_dc(\n                                            pi2_level,\n                                            pu1_pred_sblk,\n                                            pu1_pred_sblk,\n                                            u4_recwidth_cr,\n                                            u4_recwidth_cr,\n                                            gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpcr_rem6],\n (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[2],\n                                            u4_scale_v, ai2_tmp, pi2_level);\n }\n }\n }\n }\n\n }\n else\n {\n /* If no inverse transform is needed, pass recon buffer pointer */\n /* to Intraprediction module instead of pred buffer pointer     */\n {\n                UWORD16 au2_ngbr_pels[33];\n                UWORD8 *pu1_ngbr_pels = (UWORD8 *)au2_ngbr_pels;\n                UWORD16 *pu2_left_uv;\n                UWORD16 *pu2_topleft_uv;\n                WORD32 use_left1 = (u2_use_left_mb_pack & 0x0ff);\n                WORD32 use_left2 = (u2_use_left_mb_pack & 0xff00) >> 8;\n\n                pu2_topleft_uv = (UWORD16 *)pu1_u_top_left;\n                pu2_left_uv = (UWORD16 *)pu1_uleft;\n\n /* Get neighbour pixels */\n /* left pels */\n if(u2_use_left_mb_pack)\n {\n                    WORD32 i;\n if(use_left1)\n {\n for(i = 0; i < 4; i++)\n                            au2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i\n * u4_recwidth_cr / YUV420SP_FACTOR];\n }\n else\n {\n                        memset(au2_ngbr_pels + 4, 0, 4 * sizeof(UWORD16));\n }\n\n if(use_left2)\n {\n for(i = 4; i < 8; i++)\n                            au2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i\n * u4_recwidth_cr / YUV420SP_FACTOR];\n }\n else\n {\n                        memset(au2_ngbr_pels, 0, 4 * sizeof(UWORD16));\n }\n\n }\n else\n {\n                    memset(au2_ngbr_pels, 0, 8 * sizeof(UWORD16));\n }\n\n /* top left pels */\n                au2_ngbr_pels[8] = *pu2_topleft_uv;\n\n /* top pels */\n if(uc_useTopMB)\n {\n                    memcpy(au2_ngbr_pels + 8 + 1, pu1_top_u,\n 8 * sizeof(UWORD16));\n }\n else\n {\n                    memset(au2_ngbr_pels + 8 + 1, 0, 8 * sizeof(UWORD16));\n }\n\n                PROFILE_DISABLE_INTRA_PRED()\n                ps_dec->apf_intra_pred_chroma[u1_intra_chrom_pred_mode](\n                                pu1_ngbr_pels,\n                                pu1_mb_cb_rei1_buffer,\n 1,\n                                u4_recwidth_cr,\n ((uc_useTopMB << 2) | (use_left2 << 4)\n | use_left1));\n }\n\n }\n\n }\n return OK;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144258,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "size_t mptsas_config_ioc_0(MPTSASState *s, uint8_t **data, int address)\n{\n    PCIDeviceClass *pcic = PCI_DEVICE_GET_CLASS(s);\n\n     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_IOC, 0x01,\n                               \"*l*lwwb*b*b*blww\",\n                               pcic->vendor_id, pcic->device_id, pcic->revision,\n                              pcic->subsystem_vendor_id,\n                               pcic->subsystem_id);\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144325,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "size_t mptsas_config_ioc_0(MPTSASState *s, uint8_t **data, int address)\n{\n    PCIDeviceClass *pcic = PCI_DEVICE_GET_CLASS(s);\n\n     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_IOC, 0x01,\n                               \"*l*lwwb*b*b*blww\",\n                               pcic->vendor_id, pcic->device_id, pcic->revision,\n                              pcic->class_id, pcic->subsystem_vendor_id,\n                               pcic->subsystem_id);\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144326,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "size_t mptsas_config_manufacturing_1(MPTSASState *s, uint8_t **data, int address)\n {\n     /* VPD - all zeros */\n     return MPTSAS_CONFIG_PACK(1, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,\n                              \"s256\");\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144327,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "size_t mptsas_config_manufacturing_1(MPTSASState *s, uint8_t **data, int address)\n {\n     /* VPD - all zeros */\n     return MPTSAS_CONFIG_PACK(1, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,\n                              \"*s256\");\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144328,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "uint64_t esp_reg_read(ESPState *s, uint32_t saddr)\n{\n    uint32_t old_val;\n\n     trace_esp_mem_readb(saddr, s->rregs[saddr]);\n     switch (saddr) {\n     case ESP_FIFO:\n        if (s->ti_size > 0) {\n             s->ti_size--;\n            if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n                /* Data out.  */\n                qemu_log_mask(LOG_UNIMP,\n                              \"esp: PIO data read not implemented\\n\");\n                s->rregs[ESP_FIFO] = 0;\n            } else {\n                s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];\n            }\n             esp_raise_irq(s);\n         }\n        if (s->ti_size == 0) {\n             s->ti_rptr = 0;\n             s->ti_wptr = 0;\n         }\n            s->ti_wptr = 0;\n        }\n        break;\n    case ESP_RINTR:\n        /* Clear sequence step, interrupt register and all status bits\n           except TC */\n        old_val = s->rregs[ESP_RINTR];\n        s->rregs[ESP_RINTR] = 0;\n        s->rregs[ESP_RSTAT] &= ~STAT_TC;\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n        esp_lower_irq(s);\n\n        return old_val;\n    case ESP_TCHI:\n        /* Return the unique id if the value has never been written */\n        if (!s->tchi_written) {\n            return s->chip_id;\n        }\n    default:\n        break;\n    }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144351,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "uint64_t esp_reg_read(ESPState *s, uint32_t saddr)\n{\n    uint32_t old_val;\n\n     trace_esp_mem_readb(saddr, s->rregs[saddr]);\n     switch (saddr) {\n     case ESP_FIFO:\n        if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n            /* Data out.  */\n            qemu_log_mask(LOG_UNIMP, \"esp: PIO data read not implemented\\n\");\n            s->rregs[ESP_FIFO] = 0;\n            esp_raise_irq(s);\n        } else if (s->ti_rptr < s->ti_wptr) {\n             s->ti_size--;\n            s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];\n             esp_raise_irq(s);\n         }\n        if (s->ti_rptr == s->ti_wptr) {\n             s->ti_rptr = 0;\n             s->ti_wptr = 0;\n         }\n            s->ti_wptr = 0;\n        }\n        break;\n    case ESP_RINTR:\n        /* Clear sequence step, interrupt register and all status bits\n           except TC */\n        old_val = s->rregs[ESP_RINTR];\n        s->rregs[ESP_RINTR] = 0;\n        s->rregs[ESP_RSTAT] &= ~STAT_TC;\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n        esp_lower_irq(s);\n\n        return old_val;\n    case ESP_TCHI:\n        /* Return the unique id if the value has never been written */\n        if (!s->tchi_written) {\n            return s->chip_id;\n        }\n    default:\n        break;\n    }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144352,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void mptsas_fetch_request(MPTSASState *s)\n{\n    PCIDevice *pci = (PCIDevice *) s;\n    char req[MPTSAS_MAX_REQUEST_SIZE];\n    MPIRequestHeader *hdr = (MPIRequestHeader *)req;\n     hwaddr addr;\n     int size;\n \n    if (s->state != MPI_IOC_STATE_OPERATIONAL) {\n        mptsas_set_fault(s, MPI_IOCSTATUS_INVALID_STATE);\n        return;\n    }\n     /* Read the message header from the guest first. */\n     addr = s->host_mfa_high_addr | MPTSAS_FIFO_GET(s, request_post);\n     pci_dma_read(pci, addr, req, sizeof(hdr));\n    }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144353,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void mptsas_fetch_request(MPTSASState *s)\n{\n    PCIDevice *pci = (PCIDevice *) s;\n    char req[MPTSAS_MAX_REQUEST_SIZE];\n    MPIRequestHeader *hdr = (MPIRequestHeader *)req;\n     hwaddr addr;\n     int size;\n \n     /* Read the message header from the guest first. */\n     addr = s->host_mfa_high_addr | MPTSAS_FIFO_GET(s, request_post);\n     pci_dma_read(pci, addr, req, sizeof(hdr));\n    }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144354,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " static void ehci_advance_state(EHCIState *ehci, int async)\n {\n     EHCIQueue *q = NULL;\n     int again;\n \n     do {\n        case EST_WAITLISTHEAD:\n            again = ehci_state_waitlisthead(ehci, async);\n            break;\n\n        case EST_FETCHENTRY:\n            again = ehci_state_fetchentry(ehci, async);\n            break;\n\n        case EST_FETCHQH:\n            q = ehci_state_fetchqh(ehci, async);\n            if (q != NULL) {\n                assert(q->async == async);\n                again = 1;\n            } else {\n                again = 0;\n            }\n            break;\n\n \n         case EST_FETCHITD:\n             again = ehci_state_fetchitd(ehci, async);\n             break;\n \n         case EST_FETCHSITD:\n             again = ehci_state_fetchsitd(ehci, async);\n             break;\n \n         case EST_ADVANCEQUEUE:\n\n        case EST_FETCHQTD:\n            assert(q != NULL);\n            again = ehci_state_fetchqtd(q);\n            break;\n\n        case EST_HORIZONTALQH:\n            assert(q != NULL);\n            again = ehci_state_horizqh(q);\n            break;\n\n        case EST_EXECUTE:\n            assert(q != NULL);\n            again = ehci_state_execute(q);\n            if (async) {\n                ehci->async_stepdown = 0;\n            }\n            break;\n\n        case EST_EXECUTING:\n            assert(q != NULL);\n            if (async) {\n                ehci->async_stepdown = 0;\n            }\n            again = ehci_state_executing(q);\n            break;\n\n        case EST_WRITEBACK:\n            assert(q != NULL);\n            again = ehci_state_writeback(q);\n            if (!async) {\n                ehci->periodic_sched_active = PERIODIC_ACTIVE;\n            }\n            break;\n\n        default:\n            fprintf(stderr, \"Bad state!\\n\");\n            again = -1;\n            g_assert_not_reached();\n            break;\n        }\n\n             break;\n         }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144357,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " static void ehci_advance_state(EHCIState *ehci, int async)\n {\n     EHCIQueue *q = NULL;\n    int itd_count = 0;\n     int again;\n \n     do {\n        case EST_WAITLISTHEAD:\n            again = ehci_state_waitlisthead(ehci, async);\n            break;\n\n        case EST_FETCHENTRY:\n            again = ehci_state_fetchentry(ehci, async);\n            break;\n\n        case EST_FETCHQH:\n            q = ehci_state_fetchqh(ehci, async);\n            if (q != NULL) {\n                assert(q->async == async);\n                again = 1;\n            } else {\n                again = 0;\n            }\n            break;\n\n \n         case EST_FETCHITD:\n             again = ehci_state_fetchitd(ehci, async);\n            itd_count++;\n             break;\n \n         case EST_FETCHSITD:\n             again = ehci_state_fetchsitd(ehci, async);\n            itd_count++;\n             break;\n \n         case EST_ADVANCEQUEUE:\n\n        case EST_FETCHQTD:\n            assert(q != NULL);\n            again = ehci_state_fetchqtd(q);\n            break;\n\n        case EST_HORIZONTALQH:\n            assert(q != NULL);\n            again = ehci_state_horizqh(q);\n            break;\n\n        case EST_EXECUTE:\n            assert(q != NULL);\n            again = ehci_state_execute(q);\n            if (async) {\n                ehci->async_stepdown = 0;\n            }\n            break;\n\n        case EST_EXECUTING:\n            assert(q != NULL);\n            if (async) {\n                ehci->async_stepdown = 0;\n            }\n            again = ehci_state_executing(q);\n            break;\n\n        case EST_WRITEBACK:\n            assert(q != NULL);\n            again = ehci_state_writeback(q);\n            if (!async) {\n                ehci->periodic_sched_active = PERIODIC_ACTIVE;\n            }\n            break;\n\n        default:\n            fprintf(stderr, \"Bad state!\\n\");\n            again = -1;\n            g_assert_not_reached();\n            break;\n        }\n\n             break;\n         }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144358,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int make_http_soap_request(zval        *this_ptr,\n                           zend_string *buf,\n                           char        *location,\n                           char        *soapaction,\n                           int          soap_version,\n                           zval        *return_value)\n{\n\tzend_string *request;\n\tsmart_str soap_headers = {0};\n\tsmart_str soap_headers_z = {0};\n\tint err;\n\tphp_url *phpurl = NULL;\n\tphp_stream *stream;\n\tzval *trace, *tmp;\n\tint use_proxy = 0;\n\tint use_ssl;\n\tzend_string *http_body;\n\tchar *content_type, *http_version, *cookie_itt;\n\tint http_close;\n\tzend_string *http_headers;\n\tchar *connection;\n\tint http_1_1;\n\tint http_status;\n\tint content_type_xml = 0;\n\tzend_long redirect_max = 20;\n\tchar *content_encoding;\n\tchar *http_msg = NULL;\n\tzend_bool old_allow_url_fopen;\n\tphp_stream_context *context = NULL;\n\tzend_bool has_authorization = 0;\n\tzend_bool has_proxy_authorization = 0;\n\tzend_bool has_cookies = 0;\n\n\tif (this_ptr == NULL || Z_TYPE_P(this_ptr) != IS_OBJECT) {\n\t\treturn FALSE;\n\t}\n\n\trequest = buf;\n\t/* Compress request */\n\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"compression\", sizeof(\"compression\")-1)) != NULL && Z_TYPE_P(tmp) == IS_LONG) {\n\t\tint level = Z_LVAL_P(tmp) & 0x0f;\n\t\tint kind  = Z_LVAL_P(tmp) & SOAP_COMPRESSION_DEFLATE;\n\n\t\tif (level > 9) {level = 9;}\n\n\t  if ((Z_LVAL_P(tmp) & SOAP_COMPRESSION_ACCEPT) != 0) {\n\t\t\tsmart_str_append_const(&soap_headers_z,\"Accept-Encoding: gzip, deflate\\r\\n\");\n\t  }\n\t  if (level > 0) {\n\t\t\tzval func;\n\t\t\tzval retval;\n\t\t\tzval params[3];\n\t\t\tint n;\n\n\t\t\tZVAL_STR_COPY(&params[0], buf);\n\t\t\tZVAL_LONG(&params[1], level);\n\t\t\tif (kind == SOAP_COMPRESSION_DEFLATE) {\n\t\t\t\tn = 2;\n\t\t\t\tZVAL_STRING(&func, \"gzcompress\");\n\t\t\t\tsmart_str_append_const(&soap_headers_z,\"Content-Encoding: deflate\\r\\n\");\n\t\t\t} else {\n\t\t\t\tn = 3;\n\t\t\t\tZVAL_STRING(&func, \"gzencode\");\n\t\t\t\tsmart_str_append_const(&soap_headers_z,\"Content-Encoding: gzip\\r\\n\");\n\t\t\t\tZVAL_LONG(&params[2], 0x1f);\n\t\t\t}\n\t\t\tif (call_user_function(CG(function_table), (zval*)NULL, &func, &retval, n, params) == SUCCESS &&\n\t\t\t    Z_TYPE(retval) == IS_STRING) {\n\t\t\t\tzval_ptr_dtor(&params[0]);\n\t\t\t\tzval_ptr_dtor(&func);\n\t\t\t\trequest = Z_STR(retval);\n\t\t\t} else {\n\t\t\t\tzval_ptr_dtor(&params[0]);\n\t\t\t\tzval_ptr_dtor(&func);\n\t\t\t\tif (request != buf) {\n\t\t\t\t\tzend_string_release(request);\n\t\t\t\t}\n\t\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t  }\n\t}\n\n\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1)) != NULL) {\n\t\tphp_stream_from_zval_no_verify(stream,tmp);\n\t\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1)) != NULL && Z_TYPE_P(tmp) == IS_LONG) {\n\t\t\tuse_proxy = Z_LVAL_P(tmp);\n\t\t}\n\t} else {\n\t\tstream = NULL;\n\t}\n\n\tif (location != NULL && location[0] != '\\000') {\n\t\tphpurl = php_url_parse(location);\n\t}\n\n\tif (NULL != (tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr),\n\t\t\t\"_stream_context\", sizeof(\"_stream_context\")-1))) {\n\t\tcontext = php_stream_context_from_zval(tmp, 0);\n\t}\n\n\tif (context &&\n\t\t(tmp = php_stream_context_get_option(context, \"http\", \"max_redirects\")) != NULL) {\n\t\tif (Z_TYPE_P(tmp) != IS_STRING || !is_numeric_string(Z_STRVAL_P(tmp), Z_STRLEN_P(tmp), &redirect_max, NULL, 1)) {\n\t\t\tif (Z_TYPE_P(tmp) == IS_LONG)\n\t\t\t\tredirect_max = Z_LVAL_P(tmp);\n\t\t}\n\t}\n\ntry_again:\n\tif (phpurl == NULL || phpurl->host == NULL) {\n\t  if (phpurl != NULL) {php_url_free(phpurl);}\n\t\tif (request != buf) {\n\t\t\tzend_string_release(request);\n\t\t}\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Unable to parse URL\", NULL, NULL);\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\tuse_ssl = 0;\n\tif (phpurl->scheme != NULL && strcmp(phpurl->scheme, \"https\") == 0) {\n\t\tuse_ssl = 1;\n\t} else if (phpurl->scheme == NULL || strcmp(phpurl->scheme, \"http\") != 0) {\n\t\tphp_url_free(phpurl);\n\t\tif (request != buf) {\n\t\t\tzend_string_release(request);\n\t\t}\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Unknown protocol. Only http and https are allowed.\", NULL, NULL);\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tif (use_ssl && php_stream_locate_url_wrapper(\"https://\", NULL, STREAM_LOCATE_WRAPPERS_ONLY) == NULL) {\n\t\tphp_url_free(phpurl);\n\t\tif (request != buf) {\n\t\t\tzend_string_release(request);\n\t\t}\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"SSL support is not available in this build\", NULL, NULL);\n\t\tPG(allow_url_fopen) = old_allow_url_fopen;\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\tif (phpurl->port == 0) {\n\t\tphpurl->port = use_ssl ? 443 : 80;\n\t}\n\n\t/* Check if request to the same host */\n\tif (stream != NULL) {\n\t  php_url *orig;\n\t\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"httpurl\", sizeof(\"httpurl\")-1)) != NULL &&\n\t\t    (orig = (php_url *) zend_fetch_resource_ex(tmp, \"httpurl\", le_url)) != NULL &&\n\t\t    ((use_proxy && !use_ssl) ||\n\t\t     (((use_ssl && orig->scheme != NULL && strcmp(orig->scheme, \"https\") == 0) ||\n\t\t      (!use_ssl && orig->scheme == NULL) ||\n\t\t      (!use_ssl && strcmp(orig->scheme, \"https\") != 0)) &&\n\t\t     strcmp(orig->host, phpurl->host) == 0 &&\n\t\t     orig->port == phpurl->port))) {\n    } else {\n\t\t\tphp_stream_close(stream);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpurl\", sizeof(\"httpurl\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\t\tstream = NULL;\n\t\t\tuse_proxy = 0;\n    }\n\t}\n\n\t/* Check if keep-alive connection is still opened */\n\tif (stream != NULL && php_stream_eof(stream)) {\n\t\tphp_stream_close(stream);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpurl\", sizeof(\"httpurl\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\tstream = NULL;\n\t\tuse_proxy = 0;\n\t}\n\n\tif (!stream) {\n\t\tstream = http_connect(this_ptr, phpurl, use_ssl, context, &use_proxy);\n\t\tif (stream) {\n\t\t\tphp_stream_auto_cleanup(stream);\n\t\t\tadd_property_resource(this_ptr, \"httpsocket\", stream->res);\n\t\t\tGC_REFCOUNT(stream->res)++;\n\t\t\tadd_property_long(this_ptr, \"_use_proxy\", use_proxy);\n\t\t} else {\n\t\t\tphp_url_free(phpurl);\n\t\t\tif (request != buf) {\n\t\t\t\tzend_string_release(request);\n\t\t\t}\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Could not connect to host\", NULL, NULL);\n\t\t\tPG(allow_url_fopen) = old_allow_url_fopen;\n\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\tPG(allow_url_fopen) = old_allow_url_fopen;\n\n\tif (stream) {\n\t\tzval *cookies, *login, *password;\n\t\tzend_resource *ret = zend_register_resource(phpurl, le_url);\n\n\t\tadd_property_resource(this_ptr, \"httpurl\", ret);\n\t\tGC_REFCOUNT(ret)++;\n\t\t/*zend_list_addref(ret);*/\n\n\t\tif (context &&\n\t\t    (tmp = php_stream_context_get_option(context, \"http\", \"protocol_version\")) != NULL &&\n\t\t    Z_TYPE_P(tmp) == IS_DOUBLE &&\n\t\t    Z_DVAL_P(tmp) == 1.0) {\n\t\t\thttp_1_1 = 0;\n\t\t} else {\n\t\t\thttp_1_1 = 1;\n\t\t}\n\n\t\tsmart_str_append_const(&soap_headers, \"POST \");\n\t\tif (use_proxy && !use_ssl) {\n\t\t\tsmart_str_appends(&soap_headers, phpurl->scheme);\n\t\t\tsmart_str_append_const(&soap_headers, \"://\");\n\t\t\tsmart_str_appends(&soap_headers, phpurl->host);\n\t\t\tsmart_str_appendc(&soap_headers, ':');\n\t\t\tsmart_str_append_unsigned(&soap_headers, phpurl->port);\n\t\t}\n\t\tif (phpurl->path) {\n\t\t\tsmart_str_appends(&soap_headers, phpurl->path);\n\t\t} else {\n\t\t\tsmart_str_appendc(&soap_headers, '/');\n\t\t}\n\t\tif (phpurl->query) {\n\t\t\tsmart_str_appendc(&soap_headers, '?');\n\t\t\tsmart_str_appends(&soap_headers, phpurl->query);\n\t\t}\n\t\tif (phpurl->fragment) {\n\t\t\tsmart_str_appendc(&soap_headers, '#');\n\t\t\tsmart_str_appends(&soap_headers, phpurl->fragment);\n\t\t}\n\t\tif (http_1_1) {\n\t\t\tsmart_str_append_const(&soap_headers, \" HTTP/1.1\\r\\n\");\n\t\t} else {\n\t\t\tsmart_str_append_const(&soap_headers, \" HTTP/1.0\\r\\n\");\n\t\t}\n\t\tsmart_str_append_const(&soap_headers, \"Host: \");\n\t\tsmart_str_appends(&soap_headers, phpurl->host);\n\t\tif (phpurl->port != (use_ssl?443:80)) {\n\t\t\tsmart_str_appendc(&soap_headers, ':');\n\t\t\tsmart_str_append_unsigned(&soap_headers, phpurl->port);\n\t\t}\n\t\tif (!http_1_1 ||\n\t\t\t((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_keep_alive\", sizeof(\"_keep_alive\")-1)) != NULL &&\n\t\t\t (Z_TYPE_P(tmp) == IS_FALSE || (Z_TYPE_P(tmp) == IS_LONG && Z_LVAL_P(tmp) == 0)))) {\n\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\"\n\t\t\t\t\"Connection: close\\r\\n\");\n\t\t} else {\n\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\"\n\t\t\t\t\"Connection: Keep-Alive\\r\\n\");\n\t\t}\n\t\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_user_agent\", sizeof(\"_user_agent\")-1)) != NULL &&\n\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\tif (Z_STRLEN_P(tmp) > 0) {\n\t\t\t\tsmart_str_append_const(&soap_headers, \"User-Agent: \");\n\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t\t}\n\t\t} else if (context &&\n\t\t           (tmp = php_stream_context_get_option(context, \"http\", \"user_agent\")) != NULL &&\n\t\t           Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\tif (Z_STRLEN_P(tmp) > 0) {\n\t\t\t\tsmart_str_append_const(&soap_headers, \"User-Agent: \");\n\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t\t}\n\t\t} else if (FG(user_agent)) {\n\t\t\tsmart_str_append_const(&soap_headers, \"User-Agent: \");\n\t\t\tsmart_str_appends(&soap_headers, FG(user_agent));\n\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t} else {\n\t\t\tsmart_str_append_const(&soap_headers, \"User-Agent: PHP-SOAP/\"PHP_VERSION\"\\r\\n\");\n\t\t}\n\n\t\tsmart_str_append_smart_str(&soap_headers, &soap_headers_z);\n\n\t\tif (soap_version == SOAP_1_2) {\n\t\t\tsmart_str_append_const(&soap_headers,\"Content-Type: application/soap+xml; charset=utf-8\");\n\t\t\tif (soapaction) {\n\t\t\t\tsmart_str_append_const(&soap_headers,\"; action=\\\"\");\n\t\t\t\tsmart_str_appends(&soap_headers, soapaction);\n\t\t\t\tsmart_str_append_const(&soap_headers,\"\\\"\");\n\t\t\t}\n\t\t\tsmart_str_append_const(&soap_headers,\"\\r\\n\");\n\t\t} else {\n\t\t\tsmart_str_append_const(&soap_headers,\"Content-Type: text/xml; charset=utf-8\\r\\n\");\n\t\t\tif (soapaction) {\n\t\t\t\tsmart_str_append_const(&soap_headers, \"SOAPAction: \\\"\");\n\t\t\t\tsmart_str_appends(&soap_headers, soapaction);\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\"\\r\\n\");\n\t\t\t}\n\t\t}\n\t\tsmart_str_append_const(&soap_headers,\"Content-Length: \");\n\t\tsmart_str_append_long(&soap_headers, request->len);\n\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\n\t\t/* HTTP Authentication */\n\t\tif ((login = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_login\", sizeof(\"_login\")-1)) != NULL &&\n\t\t    Z_TYPE_P(login) == IS_STRING) {\n\t\t\tzval *digest;\n\n\t\t\thas_authorization = 1;\n\t\t\tif ((digest = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_digest\", sizeof(\"_digest\")-1)) != NULL) {\n\t\t\t\tif (Z_TYPE_P(digest) == IS_ARRAY) {\n\t\t\t\t\tchar          HA1[33], HA2[33], response[33], cnonce[33], nc[9];\n\t\t\t\t\tPHP_MD5_CTX   md5ctx;\n\t\t\t\t\tunsigned char hash[16];\n\n\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\tsnprintf(cnonce, sizeof(cnonce), ZEND_LONG_FMT, php_rand());\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)cnonce, strlen(cnonce));\n\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\tmake_digest(cnonce, hash);\n\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"nc\", sizeof(\"nc\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_LONG) {\n\t\t\t\t\t\tZ_LVAL_P(tmp)++;\n\t\t\t\t\t\tsnprintf(nc, sizeof(nc), \"%08ld\", Z_LVAL_P(tmp));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tadd_assoc_long(digest, \"nc\", 1);\n\t\t\t\t\t\tstrcpy(nc, \"00000001\");\n\t\t\t\t\t}\n\n\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(login), Z_STRLEN_P(login));\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"realm\", sizeof(\"realm\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\tif ((password = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_password\", sizeof(\"_password\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(password) == IS_STRING) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(password), Z_STRLEN_P(password));\n\t\t\t\t\t}\n\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\tmake_digest(HA1, hash);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"algorithm\", sizeof(\"algorithm\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING &&\n\t\t\t\t\t    Z_STRLEN_P(tmp) == sizeof(\"md5-sess\")-1 &&\n\t\t\t\t\t    stricmp(Z_STRVAL_P(tmp), \"md5-sess\") == 0) {\n\t\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)HA1, 32);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"nonce\", sizeof(\"nonce\")-1)) != NULL &&\n\t\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)cnonce, 8);\n\t\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\t\tmake_digest(HA1, hash);\n\t\t\t\t\t}\n\n\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\"POST:\", sizeof(\"POST:\")-1);\n\t\t\t\t\tif (phpurl->path) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)phpurl->path, strlen(phpurl->path));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\"/\", 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (phpurl->query) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\"?\", 1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)phpurl->query, strlen(phpurl->query));\n\t\t\t\t\t}\n\n\t\t\t\t\t/* TODO: Support for qop=\"auth-int\" */\n/*\n\t\t\t\t\tif (zend_hash_find(Z_ARRVAL_PP(digest), \"qop\", sizeof(\"qop\"), (void **)&tmp) == SUCCESS &&\n\t\t\t\t\t    Z_TYPE_PP(tmp) == IS_STRING &&\n\t\t\t\t\t    Z_STRLEN_PP(tmp) == sizeof(\"auth-int\")-1 &&\n\t\t\t\t\t    stricmp(Z_STRVAL_PP(tmp), \"auth-int\") == 0) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, \":\", 1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, HEntity, HASHHEXLEN);\n\t\t\t\t\t}\n*/\n\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\tmake_digest(HA2, hash);\n\n\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)HA1, 32);\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"nonce\", sizeof(\"nonce\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"qop\", sizeof(\"qop\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)nc, 8);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)cnonce, 8);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t\t/* TODO: Support for qop=\"auth-int\" */\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\"auth\", sizeof(\"auth\")-1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t}\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)HA2, 32);\n\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\tmake_digest(response, hash);\n\n\t\t\t\t\tsmart_str_append_const(&soap_headers, \"Authorization: Digest username=\\\"\");\n\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(login), Z_STRLEN_P(login));\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"realm\", sizeof(\"realm\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", realm=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"nonce\", sizeof(\"nonce\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", nonce=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", uri=\\\"\");\n\t\t\t\t\tif (phpurl->path) {\n\t\t\t\t\t\tsmart_str_appends(&soap_headers, phpurl->path);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsmart_str_appendc(&soap_headers, '/');\n\t\t\t\t\t}\n\t\t\t\t\tif (phpurl->query) {\n\t\t\t\t\t\tsmart_str_appendc(&soap_headers, '?');\n\t\t\t\t\t\tsmart_str_appends(&soap_headers, phpurl->query);\n\t\t\t\t\t}\n\t\t\t\t\tif (phpurl->fragment) {\n\t\t\t\t\t\tsmart_str_appendc(&soap_headers, '#');\n\t\t\t\t\t\tsmart_str_appends(&soap_headers, phpurl->fragment);\n\t\t\t\t\t}\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"qop\", sizeof(\"qop\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t/* TODO: Support for qop=\"auth-int\" */\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", qop=\\\"auth\");\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", nc=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, nc, 8);\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", cnonce=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, cnonce, 8);\n\t\t\t\t\t}\n\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", response=\\\"\");\n\t\t\t\t\tsmart_str_appendl(&soap_headers, response, 32);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"opaque\", sizeof(\"opaque\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", opaque=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"algorithm\", sizeof(\"algorithm\")-1)) != NULL &&\n\t\t\t\t\t\tZ_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", algorithm=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\"\\r\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tzend_string *buf;\n\n\t\t\t\tsmart_str auth = {0};\n\t\t\t\tsmart_str_appendl(&auth, Z_STRVAL_P(login), Z_STRLEN_P(login));\n\t\t\t\tsmart_str_appendc(&auth, ':');\n\t\t\t\tif ((password = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_password\", sizeof(\"_password\")-1)) != NULL &&\n\t\t\t\t    Z_TYPE_P(password) == IS_STRING) {\n\t\t\t\t\tsmart_str_appendl(&auth, Z_STRVAL_P(password), Z_STRLEN_P(password));\n\t\t\t\t}\n\t\t\t\tsmart_str_0(&auth);\n\t\t\t\tbuf = php_base64_encode((unsigned char*)ZSTR_VAL(auth.s), ZSTR_LEN(auth.s));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"Authorization: Basic \");\n\t\t\t\tsmart_str_appendl(&soap_headers, (char*)ZSTR_VAL(buf), ZSTR_LEN(buf));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t\t\tzend_string_release(buf);\n\t\t\t\tsmart_str_free(&auth);\n\t\t\t}\n\t\t}\n\n\t\t/* Proxy HTTP Authentication */\n\t\tif (use_proxy && !use_ssl) {\n\t\t\thas_proxy_authorization = proxy_authentication(this_ptr, &soap_headers);\n\t\t}\n\n\t\t/* Send cookies along with request */\n\t\tif ((cookies = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_cookies\", sizeof(\"_cookies\")-1)) != NULL &&\n\t\t    Z_TYPE_P(cookies) == IS_ARRAY) {\n\t\t\tzval *data;\n\t\t\tzend_string *key;\n\t\t\tint i, n;\n\n\t\t\thas_cookies = 1;\n\t\t\tn = zend_hash_num_elements(Z_ARRVAL_P(cookies));\n\t\t\tif (n > 0) {\n\t\t\t\tzend_hash_internal_pointer_reset(Z_ARRVAL_P(cookies));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"Cookie: \");\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tzend_ulong numindx;\n\t\t\t\t\tint res = zend_hash_get_current_key(Z_ARRVAL_P(cookies), &key, &numindx);\n\t\t\t\t\tdata = zend_hash_get_current_data(Z_ARRVAL_P(cookies));\n\t\t\t\t\t\n\t\t\t\t\tif (res == HASH_KEY_IS_STRING && Z_TYPE_P(data) == IS_ARRAY) {\n\t\t\t\t\t  zval *value;\n\n\t\t\t\t\t\tif ((value = zend_hash_index_find(Z_ARRVAL_P(data), 0)) != NULL &&\n                                                    Z_TYPE_P(value) == IS_STRING) {\n                                                  zval *tmp;\n                                                  if (((tmp = zend_hash_index_find(Z_ARRVAL_P(data), 1)) == NULL ||\n                                                       strncmp(phpurl->path?phpurl->path:\"/\",Z_STRVAL_P(tmp),Z_STRLEN_P(tmp)) == 0) &&\n                                                      ((tmp = zend_hash_index_find(Z_ARRVAL_P(data), 2)) == NULL ||\n                                                       in_domain(phpurl->host,Z_STRVAL_P(tmp))) &&\n                                                      (use_ssl || (tmp = zend_hash_index_find(Z_ARRVAL_P(data), 3)) == NULL)) {\n                                                                smart_str_append(&soap_headers, key);\n\t\t\t\t\t\t\t\tsmart_str_appendc(&soap_headers, ';');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_move_forward(Z_ARRVAL_P(cookies));\n\t\t\t\t}\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t\t}\n\t\t}\n\n\t\thttp_context_headers(context, has_authorization, has_proxy_authorization, has_cookies, &soap_headers);\n\n\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\tsmart_str_0(&soap_headers);\n\t\tif ((trace = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"trace\", sizeof(\"trace\")-1)) != NULL &&\n\t\t    (Z_TYPE_P(trace) == IS_TRUE || (Z_TYPE_P(trace) == IS_LONG && Z_LVAL_P(trace) != 0))) {\n\t\t\tadd_property_stringl(this_ptr, \"__last_request_headers\", ZSTR_VAL(soap_headers.s), ZSTR_LEN(soap_headers.s));\n\t\t}\n\t\tsmart_str_appendl(&soap_headers, request->val, request->len);\n\t\tsmart_str_0(&soap_headers);\n\n\t\terr = php_stream_write(stream, ZSTR_VAL(soap_headers.s), ZSTR_LEN(soap_headers.s));\n\t\tif (err != ZSTR_LEN(soap_headers.s)) {\n\t\t\tif (request != buf) {\n\t\t\t\tzend_string_release(request);\n\t\t\t}\n\t\t\tphp_stream_close(stream);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpurl\", sizeof(\"httpurl\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Failed Sending HTTP SOAP request\", NULL, NULL);\n\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\treturn FALSE;\n\t\t}\n\t\tsmart_str_free(&soap_headers);\n\t} else {\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Failed to create stream??\", NULL, NULL);\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\tif (!return_value) {\n\t\tphp_stream_close(stream);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn TRUE;\n\t}\n\n\tdo {\n\t\thttp_headers = get_http_headers(stream);\n\t\tif (!http_headers) {\n\t\t\tif (request != buf) {\n\t\t\t\tzend_string_release(request);\n\t\t\t}\n\t\t\tphp_stream_close(stream);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Error Fetching http headers\", NULL, NULL);\n\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif ((trace = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"trace\", sizeof(\"trace\")-1)) != NULL &&\n\t\t    (Z_TYPE_P(trace) == IS_TRUE || (Z_TYPE_P(trace) == IS_LONG && Z_LVAL_P(trace) != 0))) {\n\t\t\tadd_property_str(this_ptr, \"__last_response_headers\", zend_string_copy(http_headers));\n\t\t}\n\n\t\t/* Check to see what HTTP status was sent */\n\t\thttp_1_1 = 0;\n\t\thttp_status = 0;\n\t\thttp_version = get_http_header_value(ZSTR_VAL(http_headers), \"HTTP/\");\n\t\tif (http_version) {\n\t\t\tchar *tmp;\n\n\t\t\tif (!strncmp(http_version,\"1.1\", 3)) {\n\t\t\t\thttp_1_1 = 1;\n\t\t\t}\n\n\t\t\ttmp = strstr(http_version,\" \");\n\t\t\tif (tmp != NULL) {\n\t\t\t\ttmp++;\n\t\t\t\thttp_status = atoi(tmp);\n\t\t\t}\n\t\t\ttmp = strstr(tmp,\" \");\n\t\t\tif (tmp != NULL) {\n\t\t\t\ttmp++;\n\t\t\t\tif (http_msg) {\n\t\t\t\t\tefree(http_msg);\n\t\t\t\t}\n\t\t\t\thttp_msg = estrdup(tmp);\n\t\t\t}\n\t\t\tefree(http_version);\n\n\t\t\t/* Try and get headers again */\n\t\t\tif (http_status == 100) {\n\t\t\t\tzend_string_release(http_headers);\n\t\t\t}\n\t\t}\n\t} while (http_status == 100);\n\n\t/* Grab and send back every cookie */\n\n\t/* Not going to worry about Path: because\n\t   we shouldn't be changing urls so path dont\n\t   matter too much\n\t*/\n\tcookie_itt = strstr(ZSTR_VAL(http_headers), \"Set-Cookie: \");\n\twhile (cookie_itt) {\n\t\tchar *cookie;\n\t\tchar *eqpos, *sempos;\n\t\tzval *cookies;\n\n\t\tif ((cookies = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_cookies\", sizeof(\"_cookies\")-1)) == NULL ||\n\t\t    Z_TYPE_P(cookies) != IS_ARRAY) {\n\t\t\tzval tmp_cookies;\n\t\t\tarray_init(&tmp_cookies);\n\t\t\tcookies = zend_hash_str_update(Z_OBJPROP_P(this_ptr), \"_cookies\", sizeof(\"_cookies\")-1, &tmp_cookies);\n\t\t}\n\n\t\tcookie = get_http_header_value(cookie_itt,\"Set-Cookie: \");\n\n\t\teqpos = strstr(cookie, \"=\");\n\t\tsempos = strstr(cookie, \";\");\n\t\tif (eqpos != NULL && (sempos == NULL || sempos > eqpos)) {\n\t\t\tsmart_str name = {0};\n\t\t\tint cookie_len;\n\t\t\tzval zcookie;\n\n\t\t\tif (sempos != NULL) {\n\t\t\t\tcookie_len = sempos-(eqpos+1);\n\t\t\t} else {\n\t\t\t\tcookie_len = strlen(cookie)-(eqpos-cookie)-1;\n\t\t\t}\n\n\t\t\tsmart_str_appendl(&name, cookie, eqpos - cookie);\n\t\t\tsmart_str_0(&name);\n\n\t\t\tarray_init(&zcookie);\n\t\t\tadd_index_stringl(&zcookie, 0, eqpos + 1, cookie_len);\n\n\t\t\tif (sempos != NULL) {\n\t\t\t\tchar *options = cookie + cookie_len+1;\n\t\t\t\twhile (*options) {\n\t\t\t\t\twhile (*options == ' ') {options++;}\n\t\t\t\t\tsempos = strstr(options, \";\");\n\t\t\t\t\tif (strstr(options,\"path=\") == options) {\n\t\t\t\t\t\teqpos = options + sizeof(\"path=\")-1;\n\t\t\t\t\t\tadd_index_stringl(&zcookie, 1, eqpos, sempos?(sempos-eqpos):strlen(eqpos));\n\t\t\t\t\t} else if (strstr(options,\"domain=\") == options) {\n\t\t\t\t\t\teqpos = options + sizeof(\"domain=\")-1;\n\t\t\t\t\t\tadd_index_stringl(&zcookie, 2, eqpos, sempos?(sempos-eqpos):strlen(eqpos));\n\t\t\t\t\t} else if (strstr(options,\"secure\") == options) {\n\t\t\t\t\t\tadd_index_bool(&zcookie, 3, 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (sempos != NULL) {\n\t\t\t\t\t\toptions = sempos+1;\n\t\t\t\t\t} else {\n\t\t\t\t\t  break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!zend_hash_index_exists(Z_ARRVAL(zcookie), 1)) {\n\t\t\t\tchar *t = phpurl->path?phpurl->path:\"/\";\n\t\t\t\tchar *c = strrchr(t, '/');\n\t\t\t\tif (c) {\n\t\t\t\t\tadd_index_stringl(&zcookie, 1, t, c-t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!zend_hash_index_exists(Z_ARRVAL(zcookie), 2)) {\n\t\t\t\tadd_index_string(&zcookie, 2, phpurl->host);\n\t\t\t}\n\n\t\t\tzend_symtable_update(Z_ARRVAL_P(cookies), name.s, &zcookie);\n\t\t\tsmart_str_free(&name);\n\t\t}\n\n\t\tcookie_itt = strstr(cookie_itt + sizeof(\"Set-Cookie: \"), \"Set-Cookie: \");\n\t\tefree(cookie);\n\t}\n\n\t/* See if the server requested a close */\n\tif (http_1_1) {\n\t\thttp_close = FALSE;\n\t\tif (use_proxy && !use_ssl) {\n\t\t\tconnection = get_http_header_value(ZSTR_VAL(http_headers), \"Proxy-Connection: \");\n\t\t\tif (connection) {\n\t\t\t\tif (strncasecmp(connection, \"close\", sizeof(\"close\")-1) == 0) {\n\t\t\t\t\thttp_close = TRUE;\n\t\t\t\t}\n\t\t\t\tefree(connection);\n\t\t\t}\n\t\t}\n\t\tif (http_close == FALSE) {\n\t\t\tconnection = get_http_header_value(ZSTR_VAL(http_headers), \"Connection: \");\n\t\t\tif (connection) {\n\t\t\t\tif (strncasecmp(connection, \"close\", sizeof(\"close\")-1) == 0) {\n\t\t\t\t\thttp_close = TRUE;\n\t\t\t\t}\n\t\t\t\tefree(connection);\n\t\t\t}\n\t\t}\n\t} else {\n\t\thttp_close = TRUE;\n\t\tif (use_proxy && !use_ssl) {\n\t\t\tconnection = get_http_header_value(ZSTR_VAL(http_headers), \"Proxy-Connection: \");\n\t\t\tif (connection) {\n\t\t\t\tif (strncasecmp(connection, \"Keep-Alive\", sizeof(\"Keep-Alive\")-1) == 0) {\n\t\t\t\t\thttp_close = FALSE;\n\t\t\t\t}\n\t\t\t\tefree(connection);\n\t\t\t}\n\t\t}\n\t\tif (http_close == TRUE) {\n\t\t\tconnection = get_http_header_value(ZSTR_VAL(http_headers), \"Connection: \");\n\t\t\tif (connection) {\n\t\t\t\tif (strncasecmp(connection, \"Keep-Alive\", sizeof(\"Keep-Alive\")-1) == 0) {\n\t\t\t\t\thttp_close = FALSE;\n\t\t\t\t}\n\t\t\t\tefree(connection);\n\t\t\t}\n\t\t}\n\t}\n\n\n\thttp_body = get_http_body(stream, http_close, ZSTR_VAL(http_headers));\n\tif (!http_body) {\n\t\tif (request != buf) {\n\t\t\tzend_string_release(request);\n\t\t}\n\t\tphp_stream_close(stream);\n\t\tzend_string_release(http_headers);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Error Fetching http body, No Content-Length, connection closed or chunked data\", NULL, NULL);\n\t\tif (http_msg) {\n\t\t\tefree(http_msg);\n\t\t}\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\tif (request != buf) {\n\t\tzend_string_release(request);\n\t}\n\n\tif (http_close) {\n\t\tphp_stream_close(stream);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\tstream = NULL;\n\t}\n\n\t/* Process HTTP status codes */\n\tif (http_status >= 300 && http_status < 400) {\n\t\tchar *loc;\n\n\t\tif ((loc = get_http_header_value(ZSTR_VAL(http_headers), \"Location: \")) != NULL) {\n\t\t\tphp_url *new_url  = php_url_parse(loc);\n\n\t\t\tif (new_url != NULL) {\n\t\t\t\tzend_string_release(http_headers);\n\t\t\t\tzend_string_release(http_body);\n\t\t\t\tefree(loc);\n\t\t\t\tif (new_url->scheme == NULL && new_url->path != NULL) {\n\t\t\t\t\tnew_url->scheme = phpurl->scheme ? estrdup(phpurl->scheme) : NULL;\n\t\t\t\t\tnew_url->host = phpurl->host ? estrdup(phpurl->host) : NULL;\n\t\t\t\t\tnew_url->port = phpurl->port;\n\t\t\t\t\tif (new_url->path && new_url->path[0] != '/') {\n\t\t\t\t\t\tif (phpurl->path) {\n\t\t\t\t\t\t\tchar *t = phpurl->path;\n\t\t\t\t\t\t\tchar *p = strrchr(t, '/');\n\t\t\t\t\t\t\tif (p) {\n\t\t\t\t\t\t\t\tchar *s = emalloc((p - t) + strlen(new_url->path) + 2);\n\t\t\t\t\t\t\t\tstrncpy(s, t, (p - t) + 1);\n\t\t\t\t\t\t\t\ts[(p - t) + 1] = 0;\n\t\t\t\t\t\t\t\tstrcat(s, new_url->path);\n\t\t\t\t\t\t\t\tefree(new_url->path);\n\t\t\t\t\t\t\t\tnew_url->path = s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchar *s = emalloc(strlen(new_url->path) + 2);\n\t\t\t\t\t\t\ts[0] = '/'; s[1] = 0;\n\t\t\t\t\t\t\tstrcat(s, new_url->path);\n\t\t\t\t\t\t\tefree(new_url->path);\n\t\t\t\t\t\t\tnew_url->path = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tphpurl = new_url;\n\n\t\t\t\tif (--redirect_max < 1) {\n\t\t\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Redirection limit reached, aborting\", NULL, NULL);\n\t\t\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t}\n\t} else if (http_status == 401) {\n\t\t/* Digest authentication */\n\t\tzval *digest, *login, *password;\n\t\tchar *auth = get_http_header_value(ZSTR_VAL(http_headers), \"WWW-Authenticate: \");\n\n\t\tif (auth &&\n\t\t\t\tstrstr(auth, \"Digest\") == auth &&\n\t\t    ((digest = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_digest\", sizeof(\"_digest\")-1)) == NULL ||\n\t\t     Z_TYPE_P(digest) != IS_ARRAY) &&\n\t\t    (login = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_login\", sizeof(\"_login\")-1)) != NULL &&\n\t\t    Z_TYPE_P(login) == IS_STRING &&\n\t\t    (password = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_password\", sizeof(\"_password\")-1)) != NULL &&\n\t\t    Z_TYPE_P(password) == IS_STRING) {\n\t\t\tchar *s;\n\t\t\tzval digest;\n\n\t\t\tZVAL_UNDEF(&digest);\n\t\t\ts = auth + sizeof(\"Digest\")-1;\n\t\t\twhile (*s != '\\0') {\n\t\t\t\tchar *name, *val;\n\t\t\t\twhile (*s == ' ') ++s;\n\t\t\t\tname = s;\n\t\t\t\twhile (*s != '\\0' && *s != '=') ++s;\n\t\t\t\tif (*s == '=') {\n\t\t\t\t\t*s = '\\0';\n\t\t\t\t\t++s;\n\t\t\t\t\tif (*s == '\"') {\n\t\t\t\t\t\t++s;\n\t\t\t\t\t\tval = s;\n\t\t\t\t\t\twhile (*s != '\\0' && *s != '\"') ++s;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tval = s;\n\t\t\t\t\t\twhile (*s != '\\0' && *s != ' ' && *s != ',') ++s;\n\t\t\t\t\t}\n\t\t\t\t\tif (*s != '\\0') {\n\t\t\t\t\t\tif (*s != ',') {\n\t\t\t\t\t\t\t*s = '\\0';\n\t\t\t\t\t\t\t++s;\n\t\t\t\t\t\t\twhile (*s != '\\0' && *s != ',') ++s;\n\t\t\t\t\t\t\tif (*s != '\\0') ++s;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t*s = '\\0';\n\t\t\t\t\t\t\t++s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Z_TYPE(digest) == IS_UNDEF) {\n\t\t\t\t\t\tarray_init(&digest);\n\t\t\t\t\t}\n\t\t\t\t\tadd_assoc_string(&digest, name, val);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Z_TYPE(digest) != IS_UNDEF) {\n\t\t\t\tphp_url *new_url  = emalloc(sizeof(php_url));\n\n\t\t\t\tZ_DELREF(digest);\n\t\t\t\tadd_property_zval_ex(this_ptr, \"_digest\", sizeof(\"_digest\")-1, &digest);\n\n\t\t\t\t*new_url = *phpurl;\n\t\t\t\tif (phpurl->scheme) phpurl->scheme = estrdup(phpurl->scheme);\n\t\t\t\tif (phpurl->user) phpurl->user = estrdup(phpurl->user);\n\t\t\t\tif (phpurl->pass) phpurl->pass = estrdup(phpurl->pass);\n\t\t\t\tif (phpurl->host) phpurl->host = estrdup(phpurl->host);\n\t\t\t\tif (phpurl->path) phpurl->path = estrdup(phpurl->path);\n\t\t\t\tif (phpurl->query) phpurl->query = estrdup(phpurl->query);\n\t\t\t\tif (phpurl->fragment) phpurl->fragment = estrdup(phpurl->fragment);\n\t\t\t\tphpurl = new_url;\n\n\t\t\t\tefree(auth);\n\t\t\t\tzend_string_release(http_headers);\n\t\t\t\tzend_string_release(http_body);\n\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t}\n\t\tif (auth) efree(auth);\n\t}\n\tsmart_str_free(&soap_headers_z);\n\n\t/* Check and see if the server even sent a xml document */\n\tcontent_type = get_http_header_value(ZSTR_VAL(http_headers), \"Content-Type: \");\n\tif (content_type) {\n\t\tchar *pos = NULL;\n\t\tint cmplen;\n\t\tpos = strstr(content_type,\";\");\n\t\tif (pos != NULL) {\n\t\t\tcmplen = pos - content_type;\n\t\t} else {\n\t\t\tcmplen = strlen(content_type);\n\t\t}\n\t\tif (strncmp(content_type, \"text/xml\", cmplen) == 0 ||\n\t\t    strncmp(content_type, \"application/soap+xml\", cmplen) == 0) {\n\t\t\tcontent_type_xml = 1;\n/*\n\t\t\tif (strncmp(http_body, \"<?xml\", 5)) {\n\t\t\t\tzval *err;\n\t\t\t\tMAKE_STD_ZVAL(err);\n\t\t\t\tZVAL_STRINGL(err, http_body, http_body_size, 1);\n\t\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Didn't receive an xml document\", NULL, err);\n\t\t\t\tefree(content_type);\n\t\t\t\tzend_string_release(http_headers);\n\t\t\t\tefree(http_body);\n\t\t\t\treturn FALSE;\n\t\t\t}\n*/\n\t\t}\n\t\tefree(content_type);\n\t}\n\n\t/* Decompress response */\n\tcontent_encoding = get_http_header_value(ZSTR_VAL(http_headers), \"Content-Encoding: \");\n\tif (content_encoding) {\n\t\tzval func;\n\t\tzval retval;\n\t\tzval params[1];\n\n\t\tif ((strcmp(content_encoding,\"gzip\") == 0 ||\n\t\t     strcmp(content_encoding,\"x-gzip\") == 0) &&\n\t\t     zend_hash_str_exists(EG(function_table), \"gzinflate\", sizeof(\"gzinflate\")-1)) {\n\t\t\tZVAL_STRING(&func, \"gzinflate\");\n\t\t\tZVAL_STRINGL(&params[0], http_body->val+10, http_body->len-10);\n\t\t} else if (strcmp(content_encoding,\"deflate\") == 0 &&\n\t\t           zend_hash_str_exists(EG(function_table), \"gzuncompress\", sizeof(\"gzuncompress\")-1)) {\n\t\t\tZVAL_STRING(&func, \"gzuncompress\");\n\t\t\tZVAL_STR_COPY(&params[0], http_body);\n\t\t} else {\n\t\t\tefree(content_encoding);\n\t\t\tzend_string_release(http_headers);\n\t\t\tzend_string_release(http_body);\n\t\t\tif (http_msg) {\n\t\t\t\tefree(http_msg);\n\t\t\t}\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Unknown Content-Encoding\", NULL, NULL);\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (call_user_function(CG(function_table), (zval*)NULL, &func, &retval, 1, params) == SUCCESS &&\n\t\t    Z_TYPE(retval) == IS_STRING) {\n\t\t\tzval_ptr_dtor(&params[0]);\n\t\t\tzval_ptr_dtor(&func);\n\t\t\tzend_string_release(http_body);\n\t\t\tZVAL_COPY_VALUE(return_value, &retval);\n\t\t} else {\n\t\t\tzval_ptr_dtor(&params[0]);\n\t\t\tzval_ptr_dtor(&func);\n\t\t\tefree(content_encoding);\n\t\t\tzend_string_release(http_headers);\n\t\t\tzend_string_release(http_body);\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Can't uncompress compressed response\", NULL, NULL);\n\t\t\tif (http_msg) {\n\t\t\t\tefree(http_msg);\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\t\tefree(content_encoding);\n\t} else {\n\t\tZVAL_STR(return_value, http_body);\n\t}\n\n\tzend_string_release(http_headers);\n\n\tif (http_status >= 400) {\n\t\tint error = 0;\n\n\t\tif (Z_STRLEN_P(return_value) == 0) {\n\t\t\terror = 1;\n\t\t} else if (Z_STRLEN_P(return_value) > 0) {\n\t\t\tif (!content_type_xml) {\n\t\t\t\tchar *s = Z_STRVAL_P(return_value);\n\n\t\t\t\twhile (*s != '\\0' && *s < ' ') {\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t\tif (strncmp(s, \"<?xml\", 5)) {\n\t\t\t\t\terror = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (error) {\n\t\t\tzval_ptr_dtor(return_value);\n\t\t\tZVAL_UNDEF(return_value);\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", http_msg, NULL, NULL);\n\t\t\tefree(http_msg);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif (http_msg) {\n\t\tefree(http_msg);\n\t}\n\n\treturn TRUE;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144361,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int make_http_soap_request(zval        *this_ptr,\n                           zend_string *buf,\n                           char        *location,\n                           char        *soapaction,\n                           int          soap_version,\n                           zval        *return_value)\n{\n\tzend_string *request;\n\tsmart_str soap_headers = {0};\n\tsmart_str soap_headers_z = {0};\n\tint err;\n\tphp_url *phpurl = NULL;\n\tphp_stream *stream;\n\tzval *trace, *tmp;\n\tint use_proxy = 0;\n\tint use_ssl;\n\tzend_string *http_body;\n\tchar *content_type, *http_version, *cookie_itt;\n\tint http_close;\n\tzend_string *http_headers;\n\tchar *connection;\n\tint http_1_1;\n\tint http_status;\n\tint content_type_xml = 0;\n\tzend_long redirect_max = 20;\n\tchar *content_encoding;\n\tchar *http_msg = NULL;\n\tzend_bool old_allow_url_fopen;\n\tphp_stream_context *context = NULL;\n\tzend_bool has_authorization = 0;\n\tzend_bool has_proxy_authorization = 0;\n\tzend_bool has_cookies = 0;\n\n\tif (this_ptr == NULL || Z_TYPE_P(this_ptr) != IS_OBJECT) {\n\t\treturn FALSE;\n\t}\n\n\trequest = buf;\n\t/* Compress request */\n\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"compression\", sizeof(\"compression\")-1)) != NULL && Z_TYPE_P(tmp) == IS_LONG) {\n\t\tint level = Z_LVAL_P(tmp) & 0x0f;\n\t\tint kind  = Z_LVAL_P(tmp) & SOAP_COMPRESSION_DEFLATE;\n\n\t\tif (level > 9) {level = 9;}\n\n\t  if ((Z_LVAL_P(tmp) & SOAP_COMPRESSION_ACCEPT) != 0) {\n\t\t\tsmart_str_append_const(&soap_headers_z,\"Accept-Encoding: gzip, deflate\\r\\n\");\n\t  }\n\t  if (level > 0) {\n\t\t\tzval func;\n\t\t\tzval retval;\n\t\t\tzval params[3];\n\t\t\tint n;\n\n\t\t\tZVAL_STR_COPY(&params[0], buf);\n\t\t\tZVAL_LONG(&params[1], level);\n\t\t\tif (kind == SOAP_COMPRESSION_DEFLATE) {\n\t\t\t\tn = 2;\n\t\t\t\tZVAL_STRING(&func, \"gzcompress\");\n\t\t\t\tsmart_str_append_const(&soap_headers_z,\"Content-Encoding: deflate\\r\\n\");\n\t\t\t} else {\n\t\t\t\tn = 3;\n\t\t\t\tZVAL_STRING(&func, \"gzencode\");\n\t\t\t\tsmart_str_append_const(&soap_headers_z,\"Content-Encoding: gzip\\r\\n\");\n\t\t\t\tZVAL_LONG(&params[2], 0x1f);\n\t\t\t}\n\t\t\tif (call_user_function(CG(function_table), (zval*)NULL, &func, &retval, n, params) == SUCCESS &&\n\t\t\t    Z_TYPE(retval) == IS_STRING) {\n\t\t\t\tzval_ptr_dtor(&params[0]);\n\t\t\t\tzval_ptr_dtor(&func);\n\t\t\t\trequest = Z_STR(retval);\n\t\t\t} else {\n\t\t\t\tzval_ptr_dtor(&params[0]);\n\t\t\t\tzval_ptr_dtor(&func);\n\t\t\t\tif (request != buf) {\n\t\t\t\t\tzend_string_release(request);\n\t\t\t\t}\n\t\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t  }\n\t}\n\n\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1)) != NULL) {\n\t\tphp_stream_from_zval_no_verify(stream,tmp);\n\t\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1)) != NULL && Z_TYPE_P(tmp) == IS_LONG) {\n\t\t\tuse_proxy = Z_LVAL_P(tmp);\n\t\t}\n\t} else {\n\t\tstream = NULL;\n\t}\n\n\tif (location != NULL && location[0] != '\\000') {\n\t\tphpurl = php_url_parse(location);\n\t}\n\n\tif (NULL != (tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr),\n\t\t\t\"_stream_context\", sizeof(\"_stream_context\")-1))) {\n\t\tcontext = php_stream_context_from_zval(tmp, 0);\n\t}\n\n\tif (context &&\n\t\t(tmp = php_stream_context_get_option(context, \"http\", \"max_redirects\")) != NULL) {\n\t\tif (Z_TYPE_P(tmp) != IS_STRING || !is_numeric_string(Z_STRVAL_P(tmp), Z_STRLEN_P(tmp), &redirect_max, NULL, 1)) {\n\t\t\tif (Z_TYPE_P(tmp) == IS_LONG)\n\t\t\t\tredirect_max = Z_LVAL_P(tmp);\n\t\t}\n\t}\n\ntry_again:\n\tif (phpurl == NULL || phpurl->host == NULL) {\n\t  if (phpurl != NULL) {php_url_free(phpurl);}\n\t\tif (request != buf) {\n\t\t\tzend_string_release(request);\n\t\t}\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Unable to parse URL\", NULL, NULL);\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\tuse_ssl = 0;\n\tif (phpurl->scheme != NULL && strcmp(phpurl->scheme, \"https\") == 0) {\n\t\tuse_ssl = 1;\n\t} else if (phpurl->scheme == NULL || strcmp(phpurl->scheme, \"http\") != 0) {\n\t\tphp_url_free(phpurl);\n\t\tif (request != buf) {\n\t\t\tzend_string_release(request);\n\t\t}\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Unknown protocol. Only http and https are allowed.\", NULL, NULL);\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tif (use_ssl && php_stream_locate_url_wrapper(\"https://\", NULL, STREAM_LOCATE_WRAPPERS_ONLY) == NULL) {\n\t\tphp_url_free(phpurl);\n\t\tif (request != buf) {\n\t\t\tzend_string_release(request);\n\t\t}\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"SSL support is not available in this build\", NULL, NULL);\n\t\tPG(allow_url_fopen) = old_allow_url_fopen;\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\tif (phpurl->port == 0) {\n\t\tphpurl->port = use_ssl ? 443 : 80;\n\t}\n\n\t/* Check if request to the same host */\n\tif (stream != NULL) {\n\t  php_url *orig;\n\t\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"httpurl\", sizeof(\"httpurl\")-1)) != NULL &&\n\t\t    (orig = (php_url *) zend_fetch_resource_ex(tmp, \"httpurl\", le_url)) != NULL &&\n\t\t    ((use_proxy && !use_ssl) ||\n\t\t     (((use_ssl && orig->scheme != NULL && strcmp(orig->scheme, \"https\") == 0) ||\n\t\t      (!use_ssl && orig->scheme == NULL) ||\n\t\t      (!use_ssl && strcmp(orig->scheme, \"https\") != 0)) &&\n\t\t     strcmp(orig->host, phpurl->host) == 0 &&\n\t\t     orig->port == phpurl->port))) {\n    } else {\n\t\t\tphp_stream_close(stream);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpurl\", sizeof(\"httpurl\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\t\tstream = NULL;\n\t\t\tuse_proxy = 0;\n    }\n\t}\n\n\t/* Check if keep-alive connection is still opened */\n\tif (stream != NULL && php_stream_eof(stream)) {\n\t\tphp_stream_close(stream);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpurl\", sizeof(\"httpurl\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\tstream = NULL;\n\t\tuse_proxy = 0;\n\t}\n\n\tif (!stream) {\n\t\tstream = http_connect(this_ptr, phpurl, use_ssl, context, &use_proxy);\n\t\tif (stream) {\n\t\t\tphp_stream_auto_cleanup(stream);\n\t\t\tadd_property_resource(this_ptr, \"httpsocket\", stream->res);\n\t\t\tGC_REFCOUNT(stream->res)++;\n\t\t\tadd_property_long(this_ptr, \"_use_proxy\", use_proxy);\n\t\t} else {\n\t\t\tphp_url_free(phpurl);\n\t\t\tif (request != buf) {\n\t\t\t\tzend_string_release(request);\n\t\t\t}\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Could not connect to host\", NULL, NULL);\n\t\t\tPG(allow_url_fopen) = old_allow_url_fopen;\n\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\tPG(allow_url_fopen) = old_allow_url_fopen;\n\n\tif (stream) {\n\t\tzval *cookies, *login, *password;\n\t\tzend_resource *ret = zend_register_resource(phpurl, le_url);\n\n\t\tadd_property_resource(this_ptr, \"httpurl\", ret);\n\t\tGC_REFCOUNT(ret)++;\n\t\t/*zend_list_addref(ret);*/\n\n\t\tif (context &&\n\t\t    (tmp = php_stream_context_get_option(context, \"http\", \"protocol_version\")) != NULL &&\n\t\t    Z_TYPE_P(tmp) == IS_DOUBLE &&\n\t\t    Z_DVAL_P(tmp) == 1.0) {\n\t\t\thttp_1_1 = 0;\n\t\t} else {\n\t\t\thttp_1_1 = 1;\n\t\t}\n\n\t\tsmart_str_append_const(&soap_headers, \"POST \");\n\t\tif (use_proxy && !use_ssl) {\n\t\t\tsmart_str_appends(&soap_headers, phpurl->scheme);\n\t\t\tsmart_str_append_const(&soap_headers, \"://\");\n\t\t\tsmart_str_appends(&soap_headers, phpurl->host);\n\t\t\tsmart_str_appendc(&soap_headers, ':');\n\t\t\tsmart_str_append_unsigned(&soap_headers, phpurl->port);\n\t\t}\n\t\tif (phpurl->path) {\n\t\t\tsmart_str_appends(&soap_headers, phpurl->path);\n\t\t} else {\n\t\t\tsmart_str_appendc(&soap_headers, '/');\n\t\t}\n\t\tif (phpurl->query) {\n\t\t\tsmart_str_appendc(&soap_headers, '?');\n\t\t\tsmart_str_appends(&soap_headers, phpurl->query);\n\t\t}\n\t\tif (phpurl->fragment) {\n\t\t\tsmart_str_appendc(&soap_headers, '#');\n\t\t\tsmart_str_appends(&soap_headers, phpurl->fragment);\n\t\t}\n\t\tif (http_1_1) {\n\t\t\tsmart_str_append_const(&soap_headers, \" HTTP/1.1\\r\\n\");\n\t\t} else {\n\t\t\tsmart_str_append_const(&soap_headers, \" HTTP/1.0\\r\\n\");\n\t\t}\n\t\tsmart_str_append_const(&soap_headers, \"Host: \");\n\t\tsmart_str_appends(&soap_headers, phpurl->host);\n\t\tif (phpurl->port != (use_ssl?443:80)) {\n\t\t\tsmart_str_appendc(&soap_headers, ':');\n\t\t\tsmart_str_append_unsigned(&soap_headers, phpurl->port);\n\t\t}\n\t\tif (!http_1_1 ||\n\t\t\t((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_keep_alive\", sizeof(\"_keep_alive\")-1)) != NULL &&\n\t\t\t (Z_TYPE_P(tmp) == IS_FALSE || (Z_TYPE_P(tmp) == IS_LONG && Z_LVAL_P(tmp) == 0)))) {\n\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\"\n\t\t\t\t\"Connection: close\\r\\n\");\n\t\t} else {\n\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\"\n\t\t\t\t\"Connection: Keep-Alive\\r\\n\");\n\t\t}\n\t\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_user_agent\", sizeof(\"_user_agent\")-1)) != NULL &&\n\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\tif (Z_STRLEN_P(tmp) > 0) {\n\t\t\t\tsmart_str_append_const(&soap_headers, \"User-Agent: \");\n\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t\t}\n\t\t} else if (context &&\n\t\t           (tmp = php_stream_context_get_option(context, \"http\", \"user_agent\")) != NULL &&\n\t\t           Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\tif (Z_STRLEN_P(tmp) > 0) {\n\t\t\t\tsmart_str_append_const(&soap_headers, \"User-Agent: \");\n\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t\t}\n\t\t} else if (FG(user_agent)) {\n\t\t\tsmart_str_append_const(&soap_headers, \"User-Agent: \");\n\t\t\tsmart_str_appends(&soap_headers, FG(user_agent));\n\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t} else {\n\t\t\tsmart_str_append_const(&soap_headers, \"User-Agent: PHP-SOAP/\"PHP_VERSION\"\\r\\n\");\n\t\t}\n\n\t\tsmart_str_append_smart_str(&soap_headers, &soap_headers_z);\n\n\t\tif (soap_version == SOAP_1_2) {\n\t\t\tsmart_str_append_const(&soap_headers,\"Content-Type: application/soap+xml; charset=utf-8\");\n\t\t\tif (soapaction) {\n\t\t\t\tsmart_str_append_const(&soap_headers,\"; action=\\\"\");\n\t\t\t\tsmart_str_appends(&soap_headers, soapaction);\n\t\t\t\tsmart_str_append_const(&soap_headers,\"\\\"\");\n\t\t\t}\n\t\t\tsmart_str_append_const(&soap_headers,\"\\r\\n\");\n\t\t} else {\n\t\t\tsmart_str_append_const(&soap_headers,\"Content-Type: text/xml; charset=utf-8\\r\\n\");\n\t\t\tif (soapaction) {\n\t\t\t\tsmart_str_append_const(&soap_headers, \"SOAPAction: \\\"\");\n\t\t\t\tsmart_str_appends(&soap_headers, soapaction);\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\"\\r\\n\");\n\t\t\t}\n\t\t}\n\t\tsmart_str_append_const(&soap_headers,\"Content-Length: \");\n\t\tsmart_str_append_long(&soap_headers, request->len);\n\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\n\t\t/* HTTP Authentication */\n\t\tif ((login = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_login\", sizeof(\"_login\")-1)) != NULL &&\n\t\t    Z_TYPE_P(login) == IS_STRING) {\n\t\t\tzval *digest;\n\n\t\t\thas_authorization = 1;\n\t\t\tif ((digest = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_digest\", sizeof(\"_digest\")-1)) != NULL) {\n\t\t\t\tif (Z_TYPE_P(digest) == IS_ARRAY) {\n\t\t\t\t\tchar          HA1[33], HA2[33], response[33], cnonce[33], nc[9];\n\t\t\t\t\tPHP_MD5_CTX   md5ctx;\n\t\t\t\t\tunsigned char hash[16];\n\n\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\tsnprintf(cnonce, sizeof(cnonce), ZEND_LONG_FMT, php_rand());\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)cnonce, strlen(cnonce));\n\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\tmake_digest(cnonce, hash);\n\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"nc\", sizeof(\"nc\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_LONG) {\n\t\t\t\t\t\tZ_LVAL_P(tmp)++;\n\t\t\t\t\t\tsnprintf(nc, sizeof(nc), \"%08ld\", Z_LVAL_P(tmp));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tadd_assoc_long(digest, \"nc\", 1);\n\t\t\t\t\t\tstrcpy(nc, \"00000001\");\n\t\t\t\t\t}\n\n\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(login), Z_STRLEN_P(login));\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"realm\", sizeof(\"realm\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\tif ((password = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_password\", sizeof(\"_password\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(password) == IS_STRING) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(password), Z_STRLEN_P(password));\n\t\t\t\t\t}\n\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\tmake_digest(HA1, hash);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"algorithm\", sizeof(\"algorithm\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING &&\n\t\t\t\t\t    Z_STRLEN_P(tmp) == sizeof(\"md5-sess\")-1 &&\n\t\t\t\t\t    stricmp(Z_STRVAL_P(tmp), \"md5-sess\") == 0) {\n\t\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)HA1, 32);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"nonce\", sizeof(\"nonce\")-1)) != NULL &&\n\t\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)cnonce, 8);\n\t\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\t\tmake_digest(HA1, hash);\n\t\t\t\t\t}\n\n\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\"POST:\", sizeof(\"POST:\")-1);\n\t\t\t\t\tif (phpurl->path) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)phpurl->path, strlen(phpurl->path));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\"/\", 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (phpurl->query) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\"?\", 1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)phpurl->query, strlen(phpurl->query));\n\t\t\t\t\t}\n\n\t\t\t\t\t/* TODO: Support for qop=\"auth-int\" */\n/*\n\t\t\t\t\tif (zend_hash_find(Z_ARRVAL_PP(digest), \"qop\", sizeof(\"qop\"), (void **)&tmp) == SUCCESS &&\n\t\t\t\t\t    Z_TYPE_PP(tmp) == IS_STRING &&\n\t\t\t\t\t    Z_STRLEN_PP(tmp) == sizeof(\"auth-int\")-1 &&\n\t\t\t\t\t    stricmp(Z_STRVAL_PP(tmp), \"auth-int\") == 0) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, \":\", 1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, HEntity, HASHHEXLEN);\n\t\t\t\t\t}\n*/\n\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\tmake_digest(HA2, hash);\n\n\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)HA1, 32);\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"nonce\", sizeof(\"nonce\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"qop\", sizeof(\"qop\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)nc, 8);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)cnonce, 8);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t\t/* TODO: Support for qop=\"auth-int\" */\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\"auth\", sizeof(\"auth\")-1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t}\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)HA2, 32);\n\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\tmake_digest(response, hash);\n\n\t\t\t\t\tsmart_str_append_const(&soap_headers, \"Authorization: Digest username=\\\"\");\n\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(login), Z_STRLEN_P(login));\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"realm\", sizeof(\"realm\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", realm=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"nonce\", sizeof(\"nonce\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", nonce=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", uri=\\\"\");\n\t\t\t\t\tif (phpurl->path) {\n\t\t\t\t\t\tsmart_str_appends(&soap_headers, phpurl->path);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsmart_str_appendc(&soap_headers, '/');\n\t\t\t\t\t}\n\t\t\t\t\tif (phpurl->query) {\n\t\t\t\t\t\tsmart_str_appendc(&soap_headers, '?');\n\t\t\t\t\t\tsmart_str_appends(&soap_headers, phpurl->query);\n\t\t\t\t\t}\n\t\t\t\t\tif (phpurl->fragment) {\n\t\t\t\t\t\tsmart_str_appendc(&soap_headers, '#');\n\t\t\t\t\t\tsmart_str_appends(&soap_headers, phpurl->fragment);\n\t\t\t\t\t}\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"qop\", sizeof(\"qop\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t/* TODO: Support for qop=\"auth-int\" */\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", qop=\\\"auth\");\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", nc=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, nc, 8);\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", cnonce=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, cnonce, 8);\n\t\t\t\t\t}\n\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", response=\\\"\");\n\t\t\t\t\tsmart_str_appendl(&soap_headers, response, 32);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"opaque\", sizeof(\"opaque\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", opaque=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"algorithm\", sizeof(\"algorithm\")-1)) != NULL &&\n\t\t\t\t\t\tZ_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", algorithm=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\"\\r\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tzend_string *buf;\n\n\t\t\t\tsmart_str auth = {0};\n\t\t\t\tsmart_str_appendl(&auth, Z_STRVAL_P(login), Z_STRLEN_P(login));\n\t\t\t\tsmart_str_appendc(&auth, ':');\n\t\t\t\tif ((password = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_password\", sizeof(\"_password\")-1)) != NULL &&\n\t\t\t\t    Z_TYPE_P(password) == IS_STRING) {\n\t\t\t\t\tsmart_str_appendl(&auth, Z_STRVAL_P(password), Z_STRLEN_P(password));\n\t\t\t\t}\n\t\t\t\tsmart_str_0(&auth);\n\t\t\t\tbuf = php_base64_encode((unsigned char*)ZSTR_VAL(auth.s), ZSTR_LEN(auth.s));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"Authorization: Basic \");\n\t\t\t\tsmart_str_appendl(&soap_headers, (char*)ZSTR_VAL(buf), ZSTR_LEN(buf));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t\t\tzend_string_release(buf);\n\t\t\t\tsmart_str_free(&auth);\n\t\t\t}\n\t\t}\n\n\t\t/* Proxy HTTP Authentication */\n\t\tif (use_proxy && !use_ssl) {\n\t\t\thas_proxy_authorization = proxy_authentication(this_ptr, &soap_headers);\n\t\t}\n\n\t\t/* Send cookies along with request */\n\t\tif ((cookies = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_cookies\", sizeof(\"_cookies\")-1)) != NULL &&\n\t\t    Z_TYPE_P(cookies) == IS_ARRAY) {\n\t\t\tzval *data;\n\t\t\tzend_string *key;\n\t\t\tint i, n;\n\n\t\t\thas_cookies = 1;\n\t\t\tn = zend_hash_num_elements(Z_ARRVAL_P(cookies));\n\t\t\tif (n > 0) {\n\t\t\t\tzend_hash_internal_pointer_reset(Z_ARRVAL_P(cookies));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"Cookie: \");\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tzend_ulong numindx;\n\t\t\t\t\tint res = zend_hash_get_current_key(Z_ARRVAL_P(cookies), &key, &numindx);\n\t\t\t\t\tdata = zend_hash_get_current_data(Z_ARRVAL_P(cookies));\n\t\t\t\t\t\n\t\t\t\t\tif (res == HASH_KEY_IS_STRING && Z_TYPE_P(data) == IS_ARRAY) {\n\t\t\t\t\t  zval *value;\n\n\t\t\t\t\t\tif ((value = zend_hash_index_find(Z_ARRVAL_P(data), 0)) != NULL &&\n                                                    Z_TYPE_P(value) == IS_STRING) {\n                                                  zval *tmp;\n                                                  if (((tmp = zend_hash_index_find(Z_ARRVAL_P(data), 1)) == NULL ||\n                                                          Z_TYPE_P(tmp) != IS_STRING ||\n                                                       strncmp(phpurl->path?phpurl->path:\"/\",Z_STRVAL_P(tmp),Z_STRLEN_P(tmp)) == 0) &&\n                                                      ((tmp = zend_hash_index_find(Z_ARRVAL_P(data), 2)) == NULL ||\n                                                          Z_TYPE_P(tmp) != IS_STRING ||\n                                                       in_domain(phpurl->host,Z_STRVAL_P(tmp))) &&\n                                                      (use_ssl || (tmp = zend_hash_index_find(Z_ARRVAL_P(data), 3)) == NULL)) {\n                                                                smart_str_append(&soap_headers, key);\n\t\t\t\t\t\t\t\tsmart_str_appendc(&soap_headers, ';');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_move_forward(Z_ARRVAL_P(cookies));\n\t\t\t\t}\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t\t}\n\t\t}\n\n\t\thttp_context_headers(context, has_authorization, has_proxy_authorization, has_cookies, &soap_headers);\n\n\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\tsmart_str_0(&soap_headers);\n\t\tif ((trace = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"trace\", sizeof(\"trace\")-1)) != NULL &&\n\t\t    (Z_TYPE_P(trace) == IS_TRUE || (Z_TYPE_P(trace) == IS_LONG && Z_LVAL_P(trace) != 0))) {\n\t\t\tadd_property_stringl(this_ptr, \"__last_request_headers\", ZSTR_VAL(soap_headers.s), ZSTR_LEN(soap_headers.s));\n\t\t}\n\t\tsmart_str_appendl(&soap_headers, request->val, request->len);\n\t\tsmart_str_0(&soap_headers);\n\n\t\terr = php_stream_write(stream, ZSTR_VAL(soap_headers.s), ZSTR_LEN(soap_headers.s));\n\t\tif (err != ZSTR_LEN(soap_headers.s)) {\n\t\t\tif (request != buf) {\n\t\t\t\tzend_string_release(request);\n\t\t\t}\n\t\t\tphp_stream_close(stream);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpurl\", sizeof(\"httpurl\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Failed Sending HTTP SOAP request\", NULL, NULL);\n\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\treturn FALSE;\n\t\t}\n\t\tsmart_str_free(&soap_headers);\n\t} else {\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Failed to create stream??\", NULL, NULL);\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\tif (!return_value) {\n\t\tphp_stream_close(stream);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn TRUE;\n\t}\n\n\tdo {\n\t\thttp_headers = get_http_headers(stream);\n\t\tif (!http_headers) {\n\t\t\tif (request != buf) {\n\t\t\t\tzend_string_release(request);\n\t\t\t}\n\t\t\tphp_stream_close(stream);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Error Fetching http headers\", NULL, NULL);\n\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif ((trace = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"trace\", sizeof(\"trace\")-1)) != NULL &&\n\t\t    (Z_TYPE_P(trace) == IS_TRUE || (Z_TYPE_P(trace) == IS_LONG && Z_LVAL_P(trace) != 0))) {\n\t\t\tadd_property_str(this_ptr, \"__last_response_headers\", zend_string_copy(http_headers));\n\t\t}\n\n\t\t/* Check to see what HTTP status was sent */\n\t\thttp_1_1 = 0;\n\t\thttp_status = 0;\n\t\thttp_version = get_http_header_value(ZSTR_VAL(http_headers), \"HTTP/\");\n\t\tif (http_version) {\n\t\t\tchar *tmp;\n\n\t\t\tif (!strncmp(http_version,\"1.1\", 3)) {\n\t\t\t\thttp_1_1 = 1;\n\t\t\t}\n\n\t\t\ttmp = strstr(http_version,\" \");\n\t\t\tif (tmp != NULL) {\n\t\t\t\ttmp++;\n\t\t\t\thttp_status = atoi(tmp);\n\t\t\t}\n\t\t\ttmp = strstr(tmp,\" \");\n\t\t\tif (tmp != NULL) {\n\t\t\t\ttmp++;\n\t\t\t\tif (http_msg) {\n\t\t\t\t\tefree(http_msg);\n\t\t\t\t}\n\t\t\t\thttp_msg = estrdup(tmp);\n\t\t\t}\n\t\t\tefree(http_version);\n\n\t\t\t/* Try and get headers again */\n\t\t\tif (http_status == 100) {\n\t\t\t\tzend_string_release(http_headers);\n\t\t\t}\n\t\t}\n\t} while (http_status == 100);\n\n\t/* Grab and send back every cookie */\n\n\t/* Not going to worry about Path: because\n\t   we shouldn't be changing urls so path dont\n\t   matter too much\n\t*/\n\tcookie_itt = strstr(ZSTR_VAL(http_headers), \"Set-Cookie: \");\n\twhile (cookie_itt) {\n\t\tchar *cookie;\n\t\tchar *eqpos, *sempos;\n\t\tzval *cookies;\n\n\t\tif ((cookies = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_cookies\", sizeof(\"_cookies\")-1)) == NULL ||\n\t\t    Z_TYPE_P(cookies) != IS_ARRAY) {\n\t\t\tzval tmp_cookies;\n\t\t\tarray_init(&tmp_cookies);\n\t\t\tcookies = zend_hash_str_update(Z_OBJPROP_P(this_ptr), \"_cookies\", sizeof(\"_cookies\")-1, &tmp_cookies);\n\t\t}\n\n\t\tcookie = get_http_header_value(cookie_itt,\"Set-Cookie: \");\n\n\t\teqpos = strstr(cookie, \"=\");\n\t\tsempos = strstr(cookie, \";\");\n\t\tif (eqpos != NULL && (sempos == NULL || sempos > eqpos)) {\n\t\t\tsmart_str name = {0};\n\t\t\tint cookie_len;\n\t\t\tzval zcookie;\n\n\t\t\tif (sempos != NULL) {\n\t\t\t\tcookie_len = sempos-(eqpos+1);\n\t\t\t} else {\n\t\t\t\tcookie_len = strlen(cookie)-(eqpos-cookie)-1;\n\t\t\t}\n\n\t\t\tsmart_str_appendl(&name, cookie, eqpos - cookie);\n\t\t\tsmart_str_0(&name);\n\n\t\t\tarray_init(&zcookie);\n\t\t\tadd_index_stringl(&zcookie, 0, eqpos + 1, cookie_len);\n\n\t\t\tif (sempos != NULL) {\n\t\t\t\tchar *options = cookie + cookie_len+1;\n\t\t\t\twhile (*options) {\n\t\t\t\t\twhile (*options == ' ') {options++;}\n\t\t\t\t\tsempos = strstr(options, \";\");\n\t\t\t\t\tif (strstr(options,\"path=\") == options) {\n\t\t\t\t\t\teqpos = options + sizeof(\"path=\")-1;\n\t\t\t\t\t\tadd_index_stringl(&zcookie, 1, eqpos, sempos?(sempos-eqpos):strlen(eqpos));\n\t\t\t\t\t} else if (strstr(options,\"domain=\") == options) {\n\t\t\t\t\t\teqpos = options + sizeof(\"domain=\")-1;\n\t\t\t\t\t\tadd_index_stringl(&zcookie, 2, eqpos, sempos?(sempos-eqpos):strlen(eqpos));\n\t\t\t\t\t} else if (strstr(options,\"secure\") == options) {\n\t\t\t\t\t\tadd_index_bool(&zcookie, 3, 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (sempos != NULL) {\n\t\t\t\t\t\toptions = sempos+1;\n\t\t\t\t\t} else {\n\t\t\t\t\t  break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!zend_hash_index_exists(Z_ARRVAL(zcookie), 1)) {\n\t\t\t\tchar *t = phpurl->path?phpurl->path:\"/\";\n\t\t\t\tchar *c = strrchr(t, '/');\n\t\t\t\tif (c) {\n\t\t\t\t\tadd_index_stringl(&zcookie, 1, t, c-t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!zend_hash_index_exists(Z_ARRVAL(zcookie), 2)) {\n\t\t\t\tadd_index_string(&zcookie, 2, phpurl->host);\n\t\t\t}\n\n\t\t\tzend_symtable_update(Z_ARRVAL_P(cookies), name.s, &zcookie);\n\t\t\tsmart_str_free(&name);\n\t\t}\n\n\t\tcookie_itt = strstr(cookie_itt + sizeof(\"Set-Cookie: \"), \"Set-Cookie: \");\n\t\tefree(cookie);\n\t}\n\n\t/* See if the server requested a close */\n\tif (http_1_1) {\n\t\thttp_close = FALSE;\n\t\tif (use_proxy && !use_ssl) {\n\t\t\tconnection = get_http_header_value(ZSTR_VAL(http_headers), \"Proxy-Connection: \");\n\t\t\tif (connection) {\n\t\t\t\tif (strncasecmp(connection, \"close\", sizeof(\"close\")-1) == 0) {\n\t\t\t\t\thttp_close = TRUE;\n\t\t\t\t}\n\t\t\t\tefree(connection);\n\t\t\t}\n\t\t}\n\t\tif (http_close == FALSE) {\n\t\t\tconnection = get_http_header_value(ZSTR_VAL(http_headers), \"Connection: \");\n\t\t\tif (connection) {\n\t\t\t\tif (strncasecmp(connection, \"close\", sizeof(\"close\")-1) == 0) {\n\t\t\t\t\thttp_close = TRUE;\n\t\t\t\t}\n\t\t\t\tefree(connection);\n\t\t\t}\n\t\t}\n\t} else {\n\t\thttp_close = TRUE;\n\t\tif (use_proxy && !use_ssl) {\n\t\t\tconnection = get_http_header_value(ZSTR_VAL(http_headers), \"Proxy-Connection: \");\n\t\t\tif (connection) {\n\t\t\t\tif (strncasecmp(connection, \"Keep-Alive\", sizeof(\"Keep-Alive\")-1) == 0) {\n\t\t\t\t\thttp_close = FALSE;\n\t\t\t\t}\n\t\t\t\tefree(connection);\n\t\t\t}\n\t\t}\n\t\tif (http_close == TRUE) {\n\t\t\tconnection = get_http_header_value(ZSTR_VAL(http_headers), \"Connection: \");\n\t\t\tif (connection) {\n\t\t\t\tif (strncasecmp(connection, \"Keep-Alive\", sizeof(\"Keep-Alive\")-1) == 0) {\n\t\t\t\t\thttp_close = FALSE;\n\t\t\t\t}\n\t\t\t\tefree(connection);\n\t\t\t}\n\t\t}\n\t}\n\n\n\thttp_body = get_http_body(stream, http_close, ZSTR_VAL(http_headers));\n\tif (!http_body) {\n\t\tif (request != buf) {\n\t\t\tzend_string_release(request);\n\t\t}\n\t\tphp_stream_close(stream);\n\t\tzend_string_release(http_headers);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Error Fetching http body, No Content-Length, connection closed or chunked data\", NULL, NULL);\n\t\tif (http_msg) {\n\t\t\tefree(http_msg);\n\t\t}\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\tif (request != buf) {\n\t\tzend_string_release(request);\n\t}\n\n\tif (http_close) {\n\t\tphp_stream_close(stream);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\tstream = NULL;\n\t}\n\n\t/* Process HTTP status codes */\n\tif (http_status >= 300 && http_status < 400) {\n\t\tchar *loc;\n\n\t\tif ((loc = get_http_header_value(ZSTR_VAL(http_headers), \"Location: \")) != NULL) {\n\t\t\tphp_url *new_url  = php_url_parse(loc);\n\n\t\t\tif (new_url != NULL) {\n\t\t\t\tzend_string_release(http_headers);\n\t\t\t\tzend_string_release(http_body);\n\t\t\t\tefree(loc);\n\t\t\t\tif (new_url->scheme == NULL && new_url->path != NULL) {\n\t\t\t\t\tnew_url->scheme = phpurl->scheme ? estrdup(phpurl->scheme) : NULL;\n\t\t\t\t\tnew_url->host = phpurl->host ? estrdup(phpurl->host) : NULL;\n\t\t\t\t\tnew_url->port = phpurl->port;\n\t\t\t\t\tif (new_url->path && new_url->path[0] != '/') {\n\t\t\t\t\t\tif (phpurl->path) {\n\t\t\t\t\t\t\tchar *t = phpurl->path;\n\t\t\t\t\t\t\tchar *p = strrchr(t, '/');\n\t\t\t\t\t\t\tif (p) {\n\t\t\t\t\t\t\t\tchar *s = emalloc((p - t) + strlen(new_url->path) + 2);\n\t\t\t\t\t\t\t\tstrncpy(s, t, (p - t) + 1);\n\t\t\t\t\t\t\t\ts[(p - t) + 1] = 0;\n\t\t\t\t\t\t\t\tstrcat(s, new_url->path);\n\t\t\t\t\t\t\t\tefree(new_url->path);\n\t\t\t\t\t\t\t\tnew_url->path = s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchar *s = emalloc(strlen(new_url->path) + 2);\n\t\t\t\t\t\t\ts[0] = '/'; s[1] = 0;\n\t\t\t\t\t\t\tstrcat(s, new_url->path);\n\t\t\t\t\t\t\tefree(new_url->path);\n\t\t\t\t\t\t\tnew_url->path = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tphpurl = new_url;\n\n\t\t\t\tif (--redirect_max < 1) {\n\t\t\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Redirection limit reached, aborting\", NULL, NULL);\n\t\t\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t}\n\t} else if (http_status == 401) {\n\t\t/* Digest authentication */\n\t\tzval *digest, *login, *password;\n\t\tchar *auth = get_http_header_value(ZSTR_VAL(http_headers), \"WWW-Authenticate: \");\n\n\t\tif (auth &&\n\t\t\t\tstrstr(auth, \"Digest\") == auth &&\n\t\t    ((digest = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_digest\", sizeof(\"_digest\")-1)) == NULL ||\n\t\t     Z_TYPE_P(digest) != IS_ARRAY) &&\n\t\t    (login = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_login\", sizeof(\"_login\")-1)) != NULL &&\n\t\t    Z_TYPE_P(login) == IS_STRING &&\n\t\t    (password = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_password\", sizeof(\"_password\")-1)) != NULL &&\n\t\t    Z_TYPE_P(password) == IS_STRING) {\n\t\t\tchar *s;\n\t\t\tzval digest;\n\n\t\t\tZVAL_UNDEF(&digest);\n\t\t\ts = auth + sizeof(\"Digest\")-1;\n\t\t\twhile (*s != '\\0') {\n\t\t\t\tchar *name, *val;\n\t\t\t\twhile (*s == ' ') ++s;\n\t\t\t\tname = s;\n\t\t\t\twhile (*s != '\\0' && *s != '=') ++s;\n\t\t\t\tif (*s == '=') {\n\t\t\t\t\t*s = '\\0';\n\t\t\t\t\t++s;\n\t\t\t\t\tif (*s == '\"') {\n\t\t\t\t\t\t++s;\n\t\t\t\t\t\tval = s;\n\t\t\t\t\t\twhile (*s != '\\0' && *s != '\"') ++s;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tval = s;\n\t\t\t\t\t\twhile (*s != '\\0' && *s != ' ' && *s != ',') ++s;\n\t\t\t\t\t}\n\t\t\t\t\tif (*s != '\\0') {\n\t\t\t\t\t\tif (*s != ',') {\n\t\t\t\t\t\t\t*s = '\\0';\n\t\t\t\t\t\t\t++s;\n\t\t\t\t\t\t\twhile (*s != '\\0' && *s != ',') ++s;\n\t\t\t\t\t\t\tif (*s != '\\0') ++s;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t*s = '\\0';\n\t\t\t\t\t\t\t++s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Z_TYPE(digest) == IS_UNDEF) {\n\t\t\t\t\t\tarray_init(&digest);\n\t\t\t\t\t}\n\t\t\t\t\tadd_assoc_string(&digest, name, val);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Z_TYPE(digest) != IS_UNDEF) {\n\t\t\t\tphp_url *new_url  = emalloc(sizeof(php_url));\n\n\t\t\t\tZ_DELREF(digest);\n\t\t\t\tadd_property_zval_ex(this_ptr, \"_digest\", sizeof(\"_digest\")-1, &digest);\n\n\t\t\t\t*new_url = *phpurl;\n\t\t\t\tif (phpurl->scheme) phpurl->scheme = estrdup(phpurl->scheme);\n\t\t\t\tif (phpurl->user) phpurl->user = estrdup(phpurl->user);\n\t\t\t\tif (phpurl->pass) phpurl->pass = estrdup(phpurl->pass);\n\t\t\t\tif (phpurl->host) phpurl->host = estrdup(phpurl->host);\n\t\t\t\tif (phpurl->path) phpurl->path = estrdup(phpurl->path);\n\t\t\t\tif (phpurl->query) phpurl->query = estrdup(phpurl->query);\n\t\t\t\tif (phpurl->fragment) phpurl->fragment = estrdup(phpurl->fragment);\n\t\t\t\tphpurl = new_url;\n\n\t\t\t\tefree(auth);\n\t\t\t\tzend_string_release(http_headers);\n\t\t\t\tzend_string_release(http_body);\n\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t}\n\t\tif (auth) efree(auth);\n\t}\n\tsmart_str_free(&soap_headers_z);\n\n\t/* Check and see if the server even sent a xml document */\n\tcontent_type = get_http_header_value(ZSTR_VAL(http_headers), \"Content-Type: \");\n\tif (content_type) {\n\t\tchar *pos = NULL;\n\t\tint cmplen;\n\t\tpos = strstr(content_type,\";\");\n\t\tif (pos != NULL) {\n\t\t\tcmplen = pos - content_type;\n\t\t} else {\n\t\t\tcmplen = strlen(content_type);\n\t\t}\n\t\tif (strncmp(content_type, \"text/xml\", cmplen) == 0 ||\n\t\t    strncmp(content_type, \"application/soap+xml\", cmplen) == 0) {\n\t\t\tcontent_type_xml = 1;\n/*\n\t\t\tif (strncmp(http_body, \"<?xml\", 5)) {\n\t\t\t\tzval *err;\n\t\t\t\tMAKE_STD_ZVAL(err);\n\t\t\t\tZVAL_STRINGL(err, http_body, http_body_size, 1);\n\t\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Didn't receive an xml document\", NULL, err);\n\t\t\t\tefree(content_type);\n\t\t\t\tzend_string_release(http_headers);\n\t\t\t\tefree(http_body);\n\t\t\t\treturn FALSE;\n\t\t\t}\n*/\n\t\t}\n\t\tefree(content_type);\n\t}\n\n\t/* Decompress response */\n\tcontent_encoding = get_http_header_value(ZSTR_VAL(http_headers), \"Content-Encoding: \");\n\tif (content_encoding) {\n\t\tzval func;\n\t\tzval retval;\n\t\tzval params[1];\n\n\t\tif ((strcmp(content_encoding,\"gzip\") == 0 ||\n\t\t     strcmp(content_encoding,\"x-gzip\") == 0) &&\n\t\t     zend_hash_str_exists(EG(function_table), \"gzinflate\", sizeof(\"gzinflate\")-1)) {\n\t\t\tZVAL_STRING(&func, \"gzinflate\");\n\t\t\tZVAL_STRINGL(&params[0], http_body->val+10, http_body->len-10);\n\t\t} else if (strcmp(content_encoding,\"deflate\") == 0 &&\n\t\t           zend_hash_str_exists(EG(function_table), \"gzuncompress\", sizeof(\"gzuncompress\")-1)) {\n\t\t\tZVAL_STRING(&func, \"gzuncompress\");\n\t\t\tZVAL_STR_COPY(&params[0], http_body);\n\t\t} else {\n\t\t\tefree(content_encoding);\n\t\t\tzend_string_release(http_headers);\n\t\t\tzend_string_release(http_body);\n\t\t\tif (http_msg) {\n\t\t\t\tefree(http_msg);\n\t\t\t}\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Unknown Content-Encoding\", NULL, NULL);\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (call_user_function(CG(function_table), (zval*)NULL, &func, &retval, 1, params) == SUCCESS &&\n\t\t    Z_TYPE(retval) == IS_STRING) {\n\t\t\tzval_ptr_dtor(&params[0]);\n\t\t\tzval_ptr_dtor(&func);\n\t\t\tzend_string_release(http_body);\n\t\t\tZVAL_COPY_VALUE(return_value, &retval);\n\t\t} else {\n\t\t\tzval_ptr_dtor(&params[0]);\n\t\t\tzval_ptr_dtor(&func);\n\t\t\tefree(content_encoding);\n\t\t\tzend_string_release(http_headers);\n\t\t\tzend_string_release(http_body);\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Can't uncompress compressed response\", NULL, NULL);\n\t\t\tif (http_msg) {\n\t\t\t\tefree(http_msg);\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\t\tefree(content_encoding);\n\t} else {\n\t\tZVAL_STR(return_value, http_body);\n\t}\n\n\tzend_string_release(http_headers);\n\n\tif (http_status >= 400) {\n\t\tint error = 0;\n\n\t\tif (Z_STRLEN_P(return_value) == 0) {\n\t\t\terror = 1;\n\t\t} else if (Z_STRLEN_P(return_value) > 0) {\n\t\t\tif (!content_type_xml) {\n\t\t\t\tchar *s = Z_STRVAL_P(return_value);\n\n\t\t\t\twhile (*s != '\\0' && *s < ' ') {\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t\tif (strncmp(s, \"<?xml\", 5)) {\n\t\t\t\t\terror = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (error) {\n\t\t\tzval_ptr_dtor(return_value);\n\t\t\tZVAL_UNDEF(return_value);\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", http_msg, NULL, NULL);\n\t\t\tefree(http_msg);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif (http_msg) {\n\t\tefree(http_msg);\n\t}\n\n\treturn TRUE;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144362,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int ne2000_buffer_full(NE2000State *s)\n {\n     int avail, index, boundary;\n \n     index = s->curpag << 8;\n     boundary = s->boundary << 8;\n     if (index < boundary)\n        return 1;\n    return 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144367,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int ne2000_buffer_full(NE2000State *s)\n {\n     int avail, index, boundary;\n \n    if (s->stop <= s->start) {\n        return 1;\n    }\n\n     index = s->curpag << 8;\n     boundary = s->boundary << 8;\n     if (index < boundary)\n        return 1;\n    return 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144368,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int ehci_process_itd(EHCIState *ehci,\n                            EHCIitd *itd,\n                            uint32_t addr)\n {\n     USBDevice *dev;\n     USBEndpoint *ep;\n    uint32_t i, len, pid, dir, devaddr, endp;\n     uint32_t pg, off, ptr1, ptr2, max, mult;\n \n     ehci->periodic_sched_active = PERIODIC_ACTIVE;\n\n    dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);\n    devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);\n    endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);\n    max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);\n    mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);\n\n    for(i = 0; i < 8; i++) {\n        if (itd->transact[i] & ITD_XACT_ACTIVE) {\n            pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);\n            off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;\n            ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);\n            ptr2 = (itd->bufptr[pg+1] & ITD_BUFPTR_MASK);\n            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);\n\n            if (len > max * mult) {\n                len = max * mult;\n            }\n\n            if (len > BUFF_SIZE) {\n                return -1;\n            }\n\n            qemu_sglist_init(&ehci->isgl, ehci->device, 2, ehci->as);\n            if (off + len > 4096) {\n                /* transfer crosses page border */\n                uint32_t len2 = off + len - 4096;\n                uint32_t len1 = len - len2;\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);\n                qemu_sglist_add(&ehci->isgl, ptr2, len2);\n            } else {\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len);\n            }\n\n            pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;\n\n            dev = ehci_find_device(ehci, devaddr);\n            ep = usb_ep_get(dev, pid, endp);\n            if (ep && ep->type == USB_ENDPOINT_XFER_ISOC) {\n                usb_packet_setup(&ehci->ipacket, pid, ep, 0, addr, false,\n                                 (itd->transact[i] & ITD_XACT_IOC) != 0);\n                usb_packet_map(&ehci->ipacket, &ehci->isgl);\n                usb_handle_packet(dev, &ehci->ipacket);\n                usb_packet_unmap(&ehci->ipacket, &ehci->isgl);\n            } else {\n                DPRINTF(\"ISOCH: attempt to addess non-iso endpoint\\n\");\n                ehci->ipacket.status = USB_RET_NAK;\n                ehci->ipacket.actual_length = 0;\n            }\n            qemu_sglist_destroy(&ehci->isgl);\n\n            switch (ehci->ipacket.status) {\n            case USB_RET_SUCCESS:\n                break;\n            default:\n                fprintf(stderr, \"Unexpected iso usb result: %d\\n\",\n                        ehci->ipacket.status);\n                /* Fall through */\n            case USB_RET_IOERROR:\n            case USB_RET_NODEV:\n                /* 3.3.2: XACTERR is only allowed on IN transactions */\n                if (dir) {\n                    itd->transact[i] |= ITD_XACT_XACTERR;\n                    ehci_raise_irq(ehci, USBSTS_ERRINT);\n                }\n                break;\n            case USB_RET_BABBLE:\n                itd->transact[i] |= ITD_XACT_BABBLE;\n                ehci_raise_irq(ehci, USBSTS_ERRINT);\n                break;\n            case USB_RET_NAK:\n                /* no data for us, so do a zero-length transfer */\n                ehci->ipacket.actual_length = 0;\n                break;\n            }\n            if (!dir) {\n                set_field(&itd->transact[i], len - ehci->ipacket.actual_length,\n                          ITD_XACT_LENGTH); /* OUT */\n            } else {\n                set_field(&itd->transact[i], ehci->ipacket.actual_length,\n                          ITD_XACT_LENGTH); /* IN */\n            }\n            if (itd->transact[i] & ITD_XACT_IOC) {\n                 ehci_raise_irq(ehci, USBSTS_INT);\n             }\n             itd->transact[i] &= ~ITD_XACT_ACTIVE;\n         }\n     }\n    return 0;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144373,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int ehci_process_itd(EHCIState *ehci,\n                            EHCIitd *itd,\n                            uint32_t addr)\n {\n     USBDevice *dev;\n     USBEndpoint *ep;\n    uint32_t i, len, pid, dir, devaddr, endp, xfers = 0;\n     uint32_t pg, off, ptr1, ptr2, max, mult;\n \n     ehci->periodic_sched_active = PERIODIC_ACTIVE;\n\n    dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);\n    devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);\n    endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);\n    max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);\n    mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);\n\n    for(i = 0; i < 8; i++) {\n        if (itd->transact[i] & ITD_XACT_ACTIVE) {\n            pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);\n            off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;\n            ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);\n            ptr2 = (itd->bufptr[pg+1] & ITD_BUFPTR_MASK);\n            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);\n\n            if (len > max * mult) {\n                len = max * mult;\n            }\n\n            if (len > BUFF_SIZE) {\n                return -1;\n            }\n\n            qemu_sglist_init(&ehci->isgl, ehci->device, 2, ehci->as);\n            if (off + len > 4096) {\n                /* transfer crosses page border */\n                uint32_t len2 = off + len - 4096;\n                uint32_t len1 = len - len2;\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);\n                qemu_sglist_add(&ehci->isgl, ptr2, len2);\n            } else {\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len);\n            }\n\n            pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;\n\n            dev = ehci_find_device(ehci, devaddr);\n            ep = usb_ep_get(dev, pid, endp);\n            if (ep && ep->type == USB_ENDPOINT_XFER_ISOC) {\n                usb_packet_setup(&ehci->ipacket, pid, ep, 0, addr, false,\n                                 (itd->transact[i] & ITD_XACT_IOC) != 0);\n                usb_packet_map(&ehci->ipacket, &ehci->isgl);\n                usb_handle_packet(dev, &ehci->ipacket);\n                usb_packet_unmap(&ehci->ipacket, &ehci->isgl);\n            } else {\n                DPRINTF(\"ISOCH: attempt to addess non-iso endpoint\\n\");\n                ehci->ipacket.status = USB_RET_NAK;\n                ehci->ipacket.actual_length = 0;\n            }\n            qemu_sglist_destroy(&ehci->isgl);\n\n            switch (ehci->ipacket.status) {\n            case USB_RET_SUCCESS:\n                break;\n            default:\n                fprintf(stderr, \"Unexpected iso usb result: %d\\n\",\n                        ehci->ipacket.status);\n                /* Fall through */\n            case USB_RET_IOERROR:\n            case USB_RET_NODEV:\n                /* 3.3.2: XACTERR is only allowed on IN transactions */\n                if (dir) {\n                    itd->transact[i] |= ITD_XACT_XACTERR;\n                    ehci_raise_irq(ehci, USBSTS_ERRINT);\n                }\n                break;\n            case USB_RET_BABBLE:\n                itd->transact[i] |= ITD_XACT_BABBLE;\n                ehci_raise_irq(ehci, USBSTS_ERRINT);\n                break;\n            case USB_RET_NAK:\n                /* no data for us, so do a zero-length transfer */\n                ehci->ipacket.actual_length = 0;\n                break;\n            }\n            if (!dir) {\n                set_field(&itd->transact[i], len - ehci->ipacket.actual_length,\n                          ITD_XACT_LENGTH); /* OUT */\n            } else {\n                set_field(&itd->transact[i], ehci->ipacket.actual_length,\n                          ITD_XACT_LENGTH); /* IN */\n            }\n            if (itd->transact[i] & ITD_XACT_IOC) {\n                 ehci_raise_irq(ehci, USBSTS_INT);\n             }\n             itd->transact[i] &= ~ITD_XACT_ACTIVE;\n            xfers++;\n         }\n     }\n    return xfers ? 0 : -1;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144374,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "PHP_METHOD(Phar, webPhar)\n{\n\tzval *mimeoverride = NULL, *rewrite = NULL;\n\tchar *alias = NULL, *error, *index_php = NULL, *f404 = NULL, *ru = NULL;\n\tint alias_len = 0, ret, f404_len = 0, free_pathinfo = 0, ru_len = 0;\n\tchar *fname, *path_info, *mime_type = NULL, *entry, *pt;\n\tconst char *basename;\n\tint fname_len, entry_len, code, index_php_len = 0, not_cgi;\n\tphar_archive_data *phar = NULL;\n\tphar_entry_info *info = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|s!s!saz\", &alias, &alias_len, &index_php, &index_php_len, &f404, &f404_len, &mimeoverride, &rewrite) == FAILURE) {\n\t\treturn;\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\tfname = (char*)zend_get_executed_filename(TSRMLS_C);\n\tfname_len = strlen(fname);\n\n\tif (phar_open_executed_filename(alias, alias_len, &error TSRMLS_CC) != SUCCESS) {\n\t\tif (error) {\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);\n\t\t\tefree(error);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* retrieve requested file within phar */\n\tif (!(SG(request_info).request_method && SG(request_info).request_uri && (!strcmp(SG(request_info).request_method, \"GET\") || !strcmp(SG(request_info).request_method, \"POST\")))) {\n\t\treturn;\n\t}\n\n#ifdef PHP_WIN32\n\tfname = estrndup(fname, fname_len);\n\tphar_unixify_path_separators(fname, fname_len);\n#endif\n\tbasename = zend_memrchr(fname, '/', fname_len);\n\n\tif (!basename) {\n\t\tbasename = fname;\n\t} else {\n\t\t++basename;\n\t}\n\n\tif ((strlen(sapi_module.name) == sizeof(\"cgi-fcgi\")-1 && !strncmp(sapi_module.name, \"cgi-fcgi\", sizeof(\"cgi-fcgi\")-1))\n\t\t|| (strlen(sapi_module.name) == sizeof(\"fpm-fcgi\")-1 && !strncmp(sapi_module.name, \"fpm-fcgi\", sizeof(\"fpm-fcgi\")-1))\n\t\t|| (strlen(sapi_module.name) == sizeof(\"cgi\")-1 && !strncmp(sapi_module.name, \"cgi\", sizeof(\"cgi\")-1))) {\n\n\t\tif (PG(http_globals)[TRACK_VARS_SERVER]) {\n\t\t\tHashTable *_server = Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_SERVER]);\n\t\t\tzval **z_script_name, **z_path_info;\n\n\t\t\tif (SUCCESS != zend_hash_find(_server, \"SCRIPT_NAME\", sizeof(\"SCRIPT_NAME\"), (void**)&z_script_name) ||\n\t\t\t\tIS_STRING != Z_TYPE_PP(z_script_name) ||\n\t\t\t\t!strstr(Z_STRVAL_PP(z_script_name), basename)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (SUCCESS == zend_hash_find(_server, \"PATH_INFO\", sizeof(\"PATH_INFO\"), (void**)&z_path_info) &&\n\t\t\t\tIS_STRING == Z_TYPE_PP(z_path_info)) {\n\t\t\t\tentry_len = Z_STRLEN_PP(z_path_info);\n\t\t\t\tentry = estrndup(Z_STRVAL_PP(z_path_info), entry_len);\n\t\t\t\tpath_info = emalloc(Z_STRLEN_PP(z_script_name) + entry_len + 1);\n\t\t\t\tmemcpy(path_info, Z_STRVAL_PP(z_script_name), Z_STRLEN_PP(z_script_name));\n\t\t\t\tmemcpy(path_info + Z_STRLEN_PP(z_script_name), entry, entry_len + 1);\n\t\t\t\tfree_pathinfo = 1;\n\t\t\t} else {\n\t\t\t\tentry_len = 0;\n\t\t\t\tentry = estrndup(\"\", 0);\n\t\t\t\tpath_info = Z_STRVAL_PP(z_script_name);\n\t\t\t}\n\n\t\t\tpt = estrndup(Z_STRVAL_PP(z_script_name), Z_STRLEN_PP(z_script_name));\n\n\t\t} else {\n\t\t\tchar *testit;\n\n\t\t\ttestit = sapi_getenv(\"SCRIPT_NAME\", sizeof(\"SCRIPT_NAME\")-1 TSRMLS_CC);\n\t\t\tif (!(pt = strstr(testit, basename))) {\n\t\t\t\tefree(testit);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpath_info = sapi_getenv(\"PATH_INFO\", sizeof(\"PATH_INFO\")-1 TSRMLS_CC);\n\n\t\t\tif (path_info) {\n\t\t\t\tentry = path_info;\n\t\t\t\tentry_len = strlen(entry);\n\t\t\t\tspprintf(&path_info, 0, \"%s%s\", testit, path_info);\n\t\t\t\tfree_pathinfo = 1;\n\t\t\t} else {\n\t\t\t\tpath_info = testit;\n\t\t\t\tfree_pathinfo = 1;\n\t\t\t\tentry = estrndup(\"\", 0);\n\t\t\t\tentry_len = 0;\n\t\t\t}\n\n\t\t\tpt = estrndup(testit, (pt - testit) + (fname_len - (basename - fname)));\n\t\t}\n\t\tnot_cgi = 0;\n\t} else {\n\t\tpath_info = SG(request_info).request_uri;\n\n\t\tif (!(pt = strstr(path_info, basename))) {\n\t\t\t/* this can happen with rewrite rules - and we have no idea what to do then, so return */\n\t\t\treturn;\n\t\t}\n\n\t\tentry_len = strlen(path_info);\n\t\tentry_len -= (pt - path_info) + (fname_len - (basename - fname));\n\t\tentry = estrndup(pt + (fname_len - (basename - fname)), entry_len);\n\n\t\tpt = estrndup(path_info, (pt - path_info) + (fname_len - (basename - fname)));\n\t\tnot_cgi = 1;\n\t}\n\n\tif (rewrite) {\n\t\tzend_fcall_info fci;\n\t\tzend_fcall_info_cache fcc;\n\t\tzval *params, *retval_ptr, **zp[1];\n\n\t\tMAKE_STD_ZVAL(params);\n\t\tZVAL_STRINGL(params, entry, entry_len, 1);\n\t\tzp[0] = &params;\n\n#if PHP_VERSION_ID < 50300\n\t\tif (FAILURE == zend_fcall_info_init(rewrite, &fci, &fcc TSRMLS_CC)) {\n#else\n\t\tif (FAILURE == zend_fcall_info_init(rewrite, 0, &fci, &fcc, NULL, NULL TSRMLS_CC)) {\n#endif\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar error: invalid rewrite callback\");\n\n\t\t\tif (free_pathinfo) {\n\t\t\t\tefree(path_info);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tfci.param_count = 1;\n\t\tfci.params = zp;\n#if PHP_VERSION_ID < 50300\n\t\t++(params->refcount);\n#else\n\t\tZ_ADDREF_P(params);\n#endif\n\t\tfci.retval_ptr_ptr = &retval_ptr;\n\n\t\tif (FAILURE == zend_call_function(&fci, &fcc TSRMLS_CC)) {\n\t\t\tif (!EG(exception)) {\n\t\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar error: failed to call rewrite callback\");\n\t\t\t}\n\n\t\t\tif (free_pathinfo) {\n\t\t\t\tefree(path_info);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (!fci.retval_ptr_ptr || !retval_ptr) {\n\t\t\tif (free_pathinfo) {\n\t\t\t\tefree(path_info);\n\t\t\t}\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar error: rewrite callback must return a string or false\");\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (Z_TYPE_P(retval_ptr)) {\n#if PHP_VERSION_ID >= 60000\n\t\t\tcase IS_UNICODE:\n\t\t\t\tzval_unicode_to_string(retval_ptr TSRMLS_CC);\n\t\t\t\t/* break intentionally omitted */\n#endif\n\t\t\tcase IS_STRING:\n\t\t\t\tefree(entry);\n\n\t\t\t\tif (fci.retval_ptr_ptr != &retval_ptr) {\n\t\t\t\t\tentry = estrndup(Z_STRVAL_PP(fci.retval_ptr_ptr), Z_STRLEN_PP(fci.retval_ptr_ptr));\n\t\t\t\t\tentry_len = Z_STRLEN_PP(fci.retval_ptr_ptr);\n\t\t\t\t} else {\n\t\t\t\t\tentry = Z_STRVAL_P(retval_ptr);\n\t\t\t\t\tentry_len = Z_STRLEN_P(retval_ptr);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase IS_BOOL:\n\t\t\t\tphar_do_403(entry, entry_len TSRMLS_CC);\n\n\t\t\t\tif (free_pathinfo) {\n\t\t\t\t\tefree(path_info);\n\t\t\t\t}\n\n\t\t\t\tzend_bailout();\n\t\t\t\treturn;\n\t\t\tdefault:\n\t\t\t\tefree(retval_ptr);\n\n\t\t\t\tif (free_pathinfo) {\n\t\t\t\t\tefree(path_info);\n\t\t\t\t}\n\n\t\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar error: rewrite callback must return a string or false\");\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\tif (entry_len) {\n\t\tphar_postprocess_ru_web(fname, fname_len, &entry, &entry_len, &ru, &ru_len TSRMLS_CC);\n\t}\n\n\tif (!entry_len || (entry_len == 1 && entry[0] == '/')) {\n\t\tefree(entry);\n\t\t/* direct request */\n\t\tif (index_php_len) {\n\t\t\tentry = index_php;\n\t\t\tentry_len = index_php_len;\n\t\t\tif (entry[0] != '/') {\n\t\t\t\tspprintf(&entry, 0, \"/%s\", index_php);\n\t\t\t\t++entry_len;\n\t\t\t}\n\t\t} else {\n\t\t\t/* assume \"index.php\" is starting point */\n\t\t\tentry = estrndup(\"/index.php\", sizeof(\"/index.php\"));\n\t\t\tentry_len = sizeof(\"/index.php\")-1;\n\t\t}\n\n\t\tif (FAILURE == phar_get_archive(&phar, fname, fname_len, NULL, 0, NULL TSRMLS_CC) ||\n\t\t\t(info = phar_get_entry_info(phar, entry, entry_len, NULL, 0 TSRMLS_CC)) == NULL) {\n\t\t\tphar_do_404(phar, fname, fname_len, f404, f404_len, entry, entry_len TSRMLS_CC);\n\n\t\t\tif (free_pathinfo) {\n\t\t\t\tefree(path_info);\n\t\t\t}\n\n\t\t\tzend_bailout();\n\t\t} else {\n\t\t\tchar *tmp = NULL, sa = '\\0';\n\t\t\tsapi_header_line ctr = {0};\n\t\t\tctr.response_code = 301;\n\t\t\tctr.line_len = sizeof(\"HTTP/1.1 301 Moved Permanently\")-1;\n\t\t\tctr.line = \"HTTP/1.1 301 Moved Permanently\";\n\t\t\tsapi_header_op(SAPI_HEADER_REPLACE, &ctr TSRMLS_CC);\n\n\t\t\tif (not_cgi) {\n\t\t\t\ttmp = strstr(path_info, basename) + fname_len;\n\t\t\t\tsa = *tmp;\n\t\t\t\t*tmp = '\\0';\n\t\t\t}\n\n\t\t\tctr.response_code = 0;\n\n\t\t\tif (path_info[strlen(path_info)-1] == '/') {\n\t\t\t\tctr.line_len = spprintf(&(ctr.line), 4096, \"Location: %s%s\", path_info, entry + 1);\n\t\t\t} else {\n\t\t\t\tctr.line_len = spprintf(&(ctr.line), 4096, \"Location: %s%s\", path_info, entry);\n\t\t\t}\n\n\t\t\tif (not_cgi) {\n\t\t\t\t*tmp = sa;\n\t\t\t}\n\n\t\t\tif (free_pathinfo) {\n\t\t\t\tefree(path_info);\n\t\t\t}\n\n\t\t\tsapi_header_op(SAPI_HEADER_REPLACE, &ctr TSRMLS_CC);\n\t\t\tsapi_send_headers(TSRMLS_C);\n\t\t\tefree(ctr.line);\n\t\t\tzend_bailout();\n\t\t}\n\t}\n\n\tif (FAILURE == phar_get_archive(&phar, fname, fname_len, NULL, 0, NULL TSRMLS_CC) ||\n\t\t(info = phar_get_entry_info(phar, entry, entry_len, NULL, 0 TSRMLS_CC)) == NULL) {\n\t\tphar_do_404(phar, fname, fname_len, f404, f404_len, entry, entry_len TSRMLS_CC);\n#ifdef PHP_WIN32\n\t\tefree(fname);\n#endif\n\t\tzend_bailout();\n\t}\n\n\tif (mimeoverride && zend_hash_num_elements(Z_ARRVAL_P(mimeoverride))) {\n\t\tconst char *ext = zend_memrchr(entry, '.', entry_len);\n\t\tzval **val;\n\n\t\tif (ext) {\n\t\t\t++ext;\n\n\t\t\tif (SUCCESS == zend_hash_find(Z_ARRVAL_P(mimeoverride), ext, strlen(ext)+1, (void **) &val)) {\n\t\t\t\tswitch (Z_TYPE_PP(val)) {\n\t\t\t\t\tcase IS_LONG:\n\t\t\t\t\t\tif (Z_LVAL_PP(val) == PHAR_MIME_PHP || Z_LVAL_PP(val) == PHAR_MIME_PHPS) {\n\t\t\t\t\t\t\tmime_type = \"\";\n\t\t\t\t\t\t\tcode = Z_LVAL_PP(val);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Unknown mime type specifier used, only Phar::PHP, Phar::PHPS and a mime type string are allowed\");\n#ifdef PHP_WIN32\n\t\t\t\t\t\t\tefree(fname);\n#endif\n\t\t\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase IS_STRING:\n\t\t\t\t\t\tmime_type = Z_STRVAL_PP(val);\n\t\t\t\t\t\tcode = PHAR_MIME_OTHER;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Unknown mime type specifier used (not a string or int), only Phar::PHP, Phar::PHPS and a mime type string are allowed\");\n#ifdef PHP_WIN32\n\t\t\t\t\t\tefree(fname);\n#endif\n\t\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!mime_type) {\n\t\tcode = phar_file_type(&PHAR_G(mime_types), entry, &mime_type TSRMLS_CC);\n\t}\n\tret = phar_file_action(phar, info, mime_type, code, entry, entry_len, fname, pt, ru, ru_len TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ proto void Phar::mungServer(array munglist)\n * Defines a list of up to 4 $_SERVER variables that should be modified for execution\n * to mask the presence of the phar archive.  This should be used in conjunction with\n * Phar::webPhar(), and has no effect otherwise\n * SCRIPT_NAME, PHP_SELF, REQUEST_URI and SCRIPT_FILENAME\n */\nPHP_METHOD(Phar, mungServer)\n{\n\tzval *mungvalues;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"a\", &mungvalues) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!zend_hash_num_elements(Z_ARRVAL_P(mungvalues))) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"No values passed to Phar::mungServer(), expecting an array of any of these strings: PHP_SELF, REQUEST_URI, SCRIPT_FILENAME, SCRIPT_NAME\");\n\t\treturn;\n\t}\n\n\tif (zend_hash_num_elements(Z_ARRVAL_P(mungvalues)) > 4) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Too many values passed to Phar::mungServer(), expecting an array of any of these strings: PHP_SELF, REQUEST_URI, SCRIPT_FILENAME, SCRIPT_NAME\");\n\t\treturn;\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\n\tfor (zend_hash_internal_pointer_reset(Z_ARRVAL_P(mungvalues)); SUCCESS == zend_hash_has_more_elements(Z_ARRVAL_P(mungvalues)); zend_hash_move_forward(Z_ARRVAL_P(mungvalues))) {\n\t\tzval **data = NULL;\n\n\t\tif (SUCCESS != zend_hash_get_current_data(Z_ARRVAL_P(mungvalues), (void **) &data)) {\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"unable to retrieve array value in Phar::mungServer()\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (Z_TYPE_PP(data) != IS_STRING) {\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Non-string value passed to Phar::mungServer(), expecting an array of any of these strings: PHP_SELF, REQUEST_URI, SCRIPT_FILENAME, SCRIPT_NAME\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (Z_STRLEN_PP(data) == sizeof(\"PHP_SELF\")-1 && !strncmp(Z_STRVAL_PP(data), \"PHP_SELF\", sizeof(\"PHP_SELF\")-1)) {\n\t\t\tPHAR_GLOBALS->phar_SERVER_mung_list |= PHAR_MUNG_PHP_SELF;\n\t\t}\n\n\t\tif (Z_STRLEN_PP(data) == sizeof(\"REQUEST_URI\")-1) {\n\t\t\tif (!strncmp(Z_STRVAL_PP(data), \"REQUEST_URI\", sizeof(\"REQUEST_URI\")-1)) {\n\t\t\t\tPHAR_GLOBALS->phar_SERVER_mung_list |= PHAR_MUNG_REQUEST_URI;\n\t\t\t}\n\t\t\tif (!strncmp(Z_STRVAL_PP(data), \"SCRIPT_NAME\", sizeof(\"SCRIPT_NAME\")-1)) {\n\t\t\t\tPHAR_GLOBALS->phar_SERVER_mung_list |= PHAR_MUNG_SCRIPT_NAME;\n\t\t\t}\n\t\t}\n\n\t\tif (Z_STRLEN_PP(data) == sizeof(\"SCRIPT_FILENAME\")-1 && !strncmp(Z_STRVAL_PP(data), \"SCRIPT_FILENAME\", sizeof(\"SCRIPT_FILENAME\")-1)) {\n\t\t\tPHAR_GLOBALS->phar_SERVER_mung_list |= PHAR_MUNG_SCRIPT_FILENAME;\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ proto void Phar::interceptFileFuncs()\n * instructs phar to intercept fopen, file_get_contents, opendir, and all of the stat-related functions\n * and return stat on files within the phar for relative paths\n *\n * Once called, this cannot be reversed, and continue until the end of the request.\n *\n * This allows legacy scripts to be pharred unmodified\n */\nPHP_METHOD(Phar, interceptFileFuncs)\n{\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tphar_intercept_functions(TSRMLS_C);\n}\n/* }}} */\n\n/* {{{ proto array Phar::createDefaultStub([string indexfile[, string webindexfile]])\n * Return a stub that can be used to run a phar-based archive without the phar extension\n * indexfile is the CLI startup filename, which defaults to \"index.php\", webindexfile\n * is the web startup filename, and also defaults to \"index.php\"\n */\nPHP_METHOD(Phar, createDefaultStub)\n{\n\tchar *index = NULL, *webindex = NULL, *stub, *error;\n\tint index_len = 0, webindex_len = 0;\n\tsize_t stub_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|ss\", &index, &index_len, &webindex, &webindex_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tstub = phar_create_default_stub(index, webindex, &stub_len, &error TSRMLS_CC);\n\n\tif (error) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);\n\t\tefree(error);\n\t\treturn;\n\t}\n\tRETURN_STRINGL(stub, stub_len, 0);\n}\n/* }}} */\n\n/* {{{ proto mixed Phar::mapPhar([string alias, [int dataoffset]])\n * Reads the currently executed file (a phar) and registers its manifest */\nPHP_METHOD(Phar, mapPhar)\n{\n\tchar *alias = NULL, *error;\n\tint alias_len = 0;\n\tlong dataoffset = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|s!l\", &alias, &alias_len, &dataoffset) == FAILURE) {\n\t\treturn;\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\n\tRETVAL_BOOL(phar_open_executed_filename(alias, alias_len, &error TSRMLS_CC) == SUCCESS);\n\n\tif (error) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);\n\t\tefree(error);\n\t}\n} /* }}} */\n\n/* {{{ proto mixed Phar::loadPhar(string filename [, string alias])\n * Loads any phar archive with an alias */\nPHP_METHOD(Phar, loadPhar)\n{\n\tchar *fname, *alias = NULL, *error;\n\tint fname_len, alias_len = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|s!\", &fname, &fname_len, &alias, &alias_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\n\tRETVAL_BOOL(phar_open_from_filename(fname, fname_len, alias, alias_len, REPORT_ERRORS, NULL, &error TSRMLS_CC) == SUCCESS);\n\n\tif (error) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);\n\t\tefree(error);\n\t}\n} /* }}} */\n\n/* {{{ proto string Phar::apiVersion()\n * Returns the api version */\nPHP_METHOD(Phar, apiVersion)\n{\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_STRINGL(PHP_PHAR_API_VERSION, sizeof(PHP_PHAR_API_VERSION)-1, 1);\n}\n/* }}}*/\n\n/* {{{ proto bool Phar::canCompress([int method])\n * Returns whether phar extension supports compression using zlib/bzip2 */\nPHP_METHOD(Phar, canCompress)\n{\n\tlong method = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &method) == FAILURE) {\n\t\treturn;\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\tswitch (method) {\n\tcase PHAR_ENT_COMPRESSED_GZ:\n\t\tif (PHAR_G(has_zlib)) {\n\t\t\tRETURN_TRUE;\n\t\t} else {\n\t\t\tRETURN_FALSE;\n\t\t}\n\tcase PHAR_ENT_COMPRESSED_BZ2:\n\t\tif (PHAR_G(has_bz2)) {\n\t\t\tRETURN_TRUE;\n\t\t} else {\n\t\t\tRETURN_FALSE;\n\t\t}\n\tdefault:\n\t\tif (PHAR_G(has_zlib) || PHAR_G(has_bz2)) {\n\t\t\tRETURN_TRUE;\n\t\t} else {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool Phar::canWrite()\n * Returns whether phar extension supports writing and creating phars */\nPHP_METHOD(Phar, canWrite)\n{\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_BOOL(!PHAR_G(readonly));\n}\n/* }}} */\n\n/* {{{ proto bool Phar::isValidPharFilename(string filename[, bool executable = true])\n * Returns whether the given filename is a valid phar filename */\nPHP_METHOD(Phar, isValidPharFilename)\n{\n\tchar *fname;\n\tconst char *ext_str;\n\tint fname_len, ext_len, is_executable;\n\tzend_bool executable = 1;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|b\", &fname, &fname_len, &executable) == FAILURE) {\n\t\treturn;\n\t}\n\n\tis_executable = executable;\n\tRETVAL_BOOL(phar_detect_phar_fname_ext(fname, fname_len, &ext_str, &ext_len, is_executable, 2, 1 TSRMLS_CC) == SUCCESS);\n}\n/* }}} */\n\n#if HAVE_SPL\n/**\n * from spl_directory\n */\nstatic void phar_spl_foreign_dtor(spl_filesystem_object *object TSRMLS_DC) /* {{{ */\n{\n\tphar_archive_data *phar = (phar_archive_data *) object->oth;\n\n\tif (!phar->is_persistent) {\n\t\tphar_archive_delref(phar TSRMLS_CC);\n\t}\n\n\tobject->oth = NULL;\n}\n/* }}} */\n\n/**\n * from spl_directory\n */\nstatic void phar_spl_foreign_clone(spl_filesystem_object *src, spl_filesystem_object *dst TSRMLS_DC) /* {{{ */\n{\n\tphar_archive_data *phar_data = (phar_archive_data *) dst->oth;\n\n\tif (!phar_data->is_persistent) {\n\t\t++(phar_data->refcount);\n\t}\n}\n/* }}} */\n\nstatic spl_other_handler phar_spl_foreign_handler = {\n\tphar_spl_foreign_dtor,\n\tphar_spl_foreign_clone\n};\n#endif /* HAVE_SPL */\n\n/* {{{ proto void Phar::__construct(string fname [, int flags [, string alias]])\n * Construct a Phar archive object\n *\n * proto void PharData::__construct(string fname [[, int flags [, string alias]], int file format = Phar::TAR])\n * Construct a PharData archive object\n *\n * This function is used as the constructor for both the Phar and PharData\n * classes, hence the two prototypes above.\n */\nPHP_METHOD(Phar, __construct)\n{\n#if !HAVE_SPL\n\tzend_throw_exception_ex(zend_exception_get_default(TSRMLS_C), 0 TSRMLS_CC, \"Cannot instantiate Phar object without SPL extension\");\n#else\n\tchar *fname, *alias = NULL, *error, *arch = NULL, *entry = NULL, *save_fname;\n\tint fname_len, alias_len = 0, arch_len, entry_len, is_data;\n#if PHP_VERSION_ID < 50300\n\tlong flags = 0;\n#else\n\tlong flags = SPL_FILE_DIR_SKIPDOTS|SPL_FILE_DIR_UNIXPATHS;\n#endif\n\tlong format = 0;\n\tphar_archive_object *phar_obj;\n\tphar_archive_data   *phar_data;\n\tzval *zobj = getThis(), arg1, arg2;\n\n\tphar_obj = (phar_archive_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tis_data = instanceof_function(Z_OBJCE_P(zobj), phar_ce_data TSRMLS_CC);\n\n\tif (is_data) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|ls!l\", &fname, &fname_len, &flags, &alias, &alias_len, &format) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|ls!\", &fname, &fname_len, &flags, &alias, &alias_len) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (phar_obj->arc.archive) {\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Cannot call constructor twice\");\n\t\treturn;\n\t}\n\n\tsave_fname = fname;\n\tif (SUCCESS == phar_split_fname(fname, fname_len, &arch, &arch_len, &entry, &entry_len, !is_data, 2 TSRMLS_CC)) {\n\t\t/* use arch (the basename for the archive) for fname instead of fname */\n\t\t/* this allows support for RecursiveDirectoryIterator of subdirectories */\n#ifdef PHP_WIN32\n\t\tphar_unixify_path_separators(arch, arch_len);\n#endif\n\t\tfname = arch;\n\t\tfname_len = arch_len;\n#ifdef PHP_WIN32\n\t} else {\n\t\tarch = estrndup(fname, fname_len);\n\t\tarch_len = fname_len;\n\t\tfname = arch;\n\t\tphar_unixify_path_separators(arch, arch_len);\n#endif\n\t}\n\n\tif (phar_open_or_create_filename(fname, fname_len, alias, alias_len, is_data, REPORT_ERRORS, &phar_data, &error TSRMLS_CC) == FAILURE) {\n\n\t\tif (fname == arch && fname != save_fname) {\n\t\t\tefree(arch);\n\t\t\tfname = save_fname;\n\t\t}\n\n\t\tif (entry) {\n\t\t\tefree(entry);\n\t\t}\n\n\t\tif (error) {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\t\"%s\", error);\n\t\t\tefree(error);\n\t\t} else {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\t\"Phar creation or opening failed\");\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (is_data && phar_data->is_tar && phar_data->is_brandnew && format == PHAR_FORMAT_ZIP) {\n\t\tphar_data->is_zip = 1;\n\t\tphar_data->is_tar = 0;\n\t}\n\n\tif (fname == arch) {\n\t\tefree(arch);\n\t\tfname = save_fname;\n\t}\n\n\tif ((is_data && !phar_data->is_data) || (!is_data && phar_data->is_data)) {\n\t\tif (is_data) {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\t\"PharData class can only be used for non-executable tar and zip archives\");\n\t\t} else {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\t\"Phar class can only be used for executable tar and zip archives\");\n\t\t}\n\t\tefree(entry);\n\t\treturn;\n\t}\n\n\tis_data = phar_data->is_data;\n\n\tif (!phar_data->is_persistent) {\n\t\t++(phar_data->refcount);\n\t}\n\n\tphar_obj->arc.archive = phar_data;\n\tphar_obj->spl.oth_handler = &phar_spl_foreign_handler;\n\n\tif (entry) {\n\t\tfname_len = spprintf(&fname, 0, \"phar://%s%s\", phar_data->fname, entry);\n\t\tefree(entry);\n\t} else {\n\t\tfname_len = spprintf(&fname, 0, \"phar://%s\", phar_data->fname);\n\t}\n\n\tINIT_PZVAL(&arg1);\n\tZVAL_STRINGL(&arg1, fname, fname_len, 0);\n        INIT_PZVAL(&arg2);\n        ZVAL_LONG(&arg2, flags);\n \n       zend_call_method_with_2_params(&zobj, Z_OBJCE_P(zobj), \n                &spl_ce_RecursiveDirectoryIterator->constructor, \"__construct\", NULL, &arg1, &arg2);\n \n        if (!phar_data->is_persistent) {\n\t\tphar_obj->arc.archive->is_data = is_data;\n\t} else if (!EG(exception)) {\n\t\t/* register this guy so we can modify if necessary */\n\t\tzend_hash_add(&PHAR_GLOBALS->phar_persist_map, (const char *) phar_obj->arc.archive, sizeof(phar_obj->arc.archive), (void *) &phar_obj, sizeof(phar_archive_object **), NULL);\n\t}\n\n\tphar_obj->spl.info_class = phar_ce_entry;\n\tefree(fname);\n#endif /* HAVE_SPL */\n}\n/* }}} */\n\n/* {{{ proto array Phar::getSupportedSignatures()\n * Return array of supported signature types\n */\nPHP_METHOD(Phar, getSupportedSignatures)\n{\n        if (zend_parse_parameters_none() == FAILURE) {\n                return;\n        }\n        array_init(return_value);\n \n        add_next_index_stringl(return_value, \"MD5\", 3, 1);\n\tadd_next_index_stringl(return_value, \"SHA-1\", 5, 1);\n#ifdef PHAR_HASH_OK\n\tadd_next_index_stringl(return_value, \"SHA-256\", 7, 1);\n\tadd_next_index_stringl(return_value, \"SHA-512\", 7, 1);\n#endif\n#if PHAR_HAVE_OPENSSL\n\tadd_next_index_stringl(return_value, \"OpenSSL\", 7, 1);\n#else\n\tif (zend_hash_exists(&module_registry, \"openssl\", sizeof(\"openssl\"))) {\n\t\tadd_next_index_stringl(return_value, \"OpenSSL\", 7, 1);\n\t}\n#endif\n}\n/* }}} */\n\n/* {{{ proto array Phar::getSupportedCompression()\n * Return array of supported comparession algorithms\n */\nPHP_METHOD(Phar, getSupportedCompression)\n{\n        if (zend_parse_parameters_none() == FAILURE) {\n                return;\n        }\n        array_init(return_value);\n        phar_request_initialize(TSRMLS_C);\n \n\tif (PHAR_G(has_zlib)) {\n\t\tadd_next_index_stringl(return_value, \"GZ\", 2, 1);\n\t}\n\n\tif (PHAR_G(has_bz2)) {\n\t\tadd_next_index_stringl(return_value, \"BZIP2\", 5, 1);\n\t}\n}\n/* }}} */\n\n/* {{{ proto array Phar::unlinkArchive(string archive)\n * Completely remove a phar archive from memory and disk\n */\nPHP_METHOD(Phar, unlinkArchive)\n{\n\tchar *fname, *error, *zname, *arch, *entry;\n\tint fname_len, zname_len, arch_len, entry_len;\n\tphar_archive_data *phar;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &fname, &fname_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!fname_len) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Unknown phar archive \\\"\\\"\");\n\t\treturn;\n\t}\n\n\tif (FAILURE == phar_open_from_filename(fname, fname_len, NULL, 0, REPORT_ERRORS, &phar, &error TSRMLS_CC)) {\n\t\tif (error) {\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Unknown phar archive \\\"%s\\\": %s\", fname, error);\n\t\t\tefree(error);\n\t\t} else {\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Unknown phar archive \\\"%s\\\"\", fname);\n\t\t}\n\t\treturn;\n\t}\n\n\tzname = (char*)zend_get_executed_filename(TSRMLS_C);\n\tzname_len = strlen(zname);\n\n\tif (zname_len > 7 && !memcmp(zname, \"phar://\", 7) && SUCCESS == phar_split_fname(zname, zname_len, &arch, &arch_len, &entry, &entry_len, 2, 0 TSRMLS_CC)) {\n\t\tif (arch_len == fname_len && !memcmp(arch, fname, arch_len)) {\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar archive \\\"%s\\\" cannot be unlinked from within itself\", fname);\n\t\t\tefree(arch);\n\t\t\tefree(entry);\n\t\t\treturn;\n\t\t}\n\t\tefree(arch);\n\t\tefree(entry);\n\t}\n\n\tif (phar->is_persistent) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar archive \\\"%s\\\" is in phar.cache_list, cannot unlinkArchive()\", fname);\n\t\treturn;\n\t}\n\n\tif (phar->refcount) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar archive \\\"%s\\\" has open file handles or objects.  fclose() all file handles, and unset() all objects prior to calling unlinkArchive()\", fname);\n\t\treturn;\n\t}\n\n\tfname = estrndup(phar->fname, phar->fname_len);\n\n\t/* invalidate phar cache */\n\tPHAR_G(last_phar) = NULL;\n\tPHAR_G(last_phar_name) = PHAR_G(last_alias) = NULL;\n\n\tphar_archive_delref(phar TSRMLS_CC);\n\tunlink(fname);\n\tefree(fname);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n#if HAVE_SPL\n\n#define PHAR_ARCHIVE_OBJECT() \\\n\tphar_archive_object *phar_obj = (phar_archive_object*)zend_object_store_get_object(getThis() TSRMLS_CC); \\\n\tif (!phar_obj->arc.archive) { \\\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \\\n\t\t\t\"Cannot call method on an uninitialized Phar object\"); \\\n\t\treturn; \\\n\t}\n\n/* {{{ proto void Phar::__destruct()\n * if persistent, remove from the cache\n */\nPHP_METHOD(Phar, __destruct)\n{\n\tphar_archive_object *phar_obj = (phar_archive_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (phar_obj->arc.archive && phar_obj->arc.archive->is_persistent) {\n\t\tzend_hash_del(&PHAR_GLOBALS->phar_persist_map, (const char *) phar_obj->arc.archive, sizeof(phar_obj->arc.archive));\n\t}\n}\n/* }}} */\n\nstruct _phar_t {\n\tphar_archive_object *p;\n\tzend_class_entry *c;\n\tchar *b;\n\tuint l;\n\tzval *ret;\n\tint count;\n\tphp_stream *fp;\n};\n\nstatic int phar_build(zend_object_iterator *iter, void *puser TSRMLS_DC) /* {{{ */\n{\n\tzval **value;\n\tzend_uchar key_type;\n\tzend_bool close_fp = 1;\n\tulong int_key;\n\tstruct _phar_t *p_obj = (struct _phar_t*) puser;\n\tuint str_key_len, base_len = p_obj->l, fname_len;\n\tphar_entry_data *data;\n\tphp_stream *fp;\n\tsize_t contents_len;\n\tchar *fname, *error = NULL, *base = p_obj->b, *opened, *save = NULL, *temp = NULL;\n\tphar_zstr key;\n\tchar *str_key;\n\tzend_class_entry *ce = p_obj->c;\n\tphar_archive_object *phar_obj = p_obj->p;\n\tchar *str = \"[stream]\";\n\n\titer->funcs->get_current_data(iter, &value TSRMLS_CC);\n\n\tif (EG(exception)) {\n\t\treturn ZEND_HASH_APPLY_STOP;\n\t}\n\n\tif (!value) {\n\t\t/* failure in get_current_data */\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned no value\", ce->name);\n\t\treturn ZEND_HASH_APPLY_STOP;\n\t}\n\n\tswitch (Z_TYPE_PP(value)) {\n#if PHP_VERSION_ID >= 60000\n\t\tcase IS_UNICODE:\n\t\t\tzval_unicode_to_string(*(value) TSRMLS_CC);\n\t\t\t/* break intentionally omitted */\n#endif\n\t\tcase IS_STRING:\n\t\t\tbreak;\n\t\tcase IS_RESOURCE:\n\t\t\tphp_stream_from_zval_no_verify(fp, value);\n\n\t\t\tif (!fp) {\n\t\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Iterator %v returned an invalid stream handle\", ce->name);\n\t\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t\t}\n\n\t\t\tif (iter->funcs->get_current_key) {\n\t\t\t\tkey_type = iter->funcs->get_current_key(iter, &key, &str_key_len, &int_key TSRMLS_CC);\n\n\t\t\t\tif (EG(exception)) {\n\t\t\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t\t\t}\n\n\t\t\t\tif (key_type == HASH_KEY_IS_LONG) {\n\t\t\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned an invalid key (must return a string)\", ce->name);\n\t\t\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t\t\t}\n\n\t\t\t\tif (key_type > 9) { /* IS_UNICODE == 10 */\n#if PHP_VERSION_ID < 60000\n/* this can never happen, but fixes a compile warning */\n\t\t\t\t\tspprintf(&str_key, 0, \"%s\", key);\n#else\n\t\t\t\t\tspprintf(&str_key, 0, \"%v\", key);\n\t\t\t\t\tezfree(key);\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tPHAR_STR(key, str_key);\n\t\t\t\t}\n\n\t\t\t\tsave = str_key;\n\n\t\t\t\tif (str_key[str_key_len - 1] == '\\0') {\n\t\t\t\t\tstr_key_len--;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned an invalid key (must return a string)\", ce->name);\n\t\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t\t}\n\n\t\t\tclose_fp = 0;\n\t\t\topened = (char *) estrndup(str, sizeof(\"[stream]\") - 1);\n\t\t\tgoto after_open_fp;\n\t\tcase IS_OBJECT:\n\t\t\tif (instanceof_function(Z_OBJCE_PP(value), spl_ce_SplFileInfo TSRMLS_CC)) {\n\t\t\t\tchar *test = NULL;\n\t\t\t\tzval dummy;\n\t\t\t\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(*value TSRMLS_CC);\n\n\t\t\t\tif (!base_len) {\n\t\t\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Iterator %v returns an SplFileInfo object, so base directory must be specified\", ce->name);\n\t\t\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t\t\t}\n\n\t\t\t\tswitch (intern->type) {\n\t\t\t\t\tcase SPL_FS_DIR:\n#if PHP_VERSION_ID >= 60000\n\t\t\t\t\t\ttest = spl_filesystem_object_get_path(intern, NULL, NULL TSRMLS_CC).s;\n#elif PHP_VERSION_ID >= 50300\n\t\t\t\t\t\ttest = spl_filesystem_object_get_path(intern, NULL TSRMLS_CC);\n#else\n\t\t\t\t\t\ttest = intern->path;\n#endif\n\t\t\t\t\t\tfname_len = spprintf(&fname, 0, \"%s%c%s\", test, DEFAULT_SLASH, intern->u.dir.entry.d_name);\n\t\t\t\t\t\tphp_stat(fname, fname_len, FS_IS_DIR, &dummy TSRMLS_CC);\n\n\t\t\t\t\t\tif (Z_BVAL(dummy)) {\n\t\t\t\t\t\t\t/* ignore directories */\n\t\t\t\t\t\t\tefree(fname);\n\t\t\t\t\t\t\treturn ZEND_HASH_APPLY_KEEP;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttest = expand_filepath(fname, NULL TSRMLS_CC);\n\t\t\t\t\t\tefree(fname);\n\n\t\t\t\t\t\tif (test) {\n\t\t\t\t\t\t\tfname = test;\n\t\t\t\t\t\t\tfname_len = strlen(fname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Could not resolve file path\");\n\t\t\t\t\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsave = fname;\n\t\t\t\t\t\tgoto phar_spl_fileinfo;\n\t\t\t\t\tcase SPL_FS_INFO:\n\t\t\t\t\tcase SPL_FS_FILE:\n#if PHP_VERSION_ID >= 60000\n\t\t\t\t\t\tif (intern->file_name_type == IS_UNICODE) {\n\t\t\t\t\t\t\tzval zv;\n\n\t\t\t\t\t\t\tINIT_ZVAL(zv);\n\t\t\t\t\t\t\tZ_UNIVAL(zv) = intern->file_name;\n\t\t\t\t\t\t\tZ_UNILEN(zv) = intern->file_name_len;\n\t\t\t\t\t\t\tZ_TYPE(zv) = IS_UNICODE;\n\n\t\t\t\t\t\t\tzval_copy_ctor(&zv);\n\t\t\t\t\t\t\tzval_unicode_to_string(&zv TSRMLS_CC);\n\t\t\t\t\t\t\tfname = expand_filepath(Z_STRVAL(zv), NULL TSRMLS_CC);\n\t\t\t\t\t\t\tezfree(Z_UNIVAL(zv));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfname = expand_filepath(intern->file_name.s, NULL TSRMLS_CC);\n\t\t\t\t\t\t}\n#else\n\t\t\t\t\t\tfname = expand_filepath(intern->file_name, NULL TSRMLS_CC);\n#endif\n\t\t\t\t\t\tif (!fname) {\n\t\t\t\t\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Could not resolve file path\");\n\t\t\t\t\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfname_len = strlen(fname);\n\t\t\t\t\t\tsave = fname;\n\t\t\t\t\t\tgoto phar_spl_fileinfo;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* fall-through */\n\t\tdefault:\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned an invalid value (must return a string)\", ce->name);\n\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t}\n\n\tfname = Z_STRVAL_PP(value);\n\tfname_len = Z_STRLEN_PP(value);\n\nphar_spl_fileinfo:\n\tif (base_len) {\n\t\ttemp = expand_filepath(base, NULL TSRMLS_CC);\n\t\tif (!temp) {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Could not resolve file path\");\n\t\t\tif (save) {\n\t\t\t\tefree(save);\n                        }\n                        return ZEND_HASH_APPLY_STOP;\n                }\n                base = temp;\n                base_len = strlen(base);\n \n\t\tif (strstr(fname, base)) {\n\t\t\tstr_key_len = fname_len - base_len;\n\n\t\t\tif (str_key_len <= 0) {\n\t\t\t\tif (save) {\n\t\t\t\t\tefree(save);\n\t\t\t\t\tefree(temp);\n\t\t\t\t}\n\t\t\t\treturn ZEND_HASH_APPLY_KEEP;\n\t\t\t}\n\n\t\t\tstr_key = fname + base_len;\n\n\t\t\tif (*str_key == '/' || *str_key == '\\\\') {\n\t\t\t\tstr_key++;\n\t\t\t\tstr_key_len--;\n\t\t\t}\n\n\t\t} else {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned a path \\\"%s\\\" that is not in the base directory \\\"%s\\\"\", ce->name, fname, base);\n\n\t\t\tif (save) {\n\t\t\t\tefree(save);\n\t\t\t\tefree(temp);\n\t\t\t}\n\n\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t}\n\t} else {\n\t\tif (iter->funcs->get_current_key) {\n\t\t\tkey_type = iter->funcs->get_current_key(iter, &key, &str_key_len, &int_key TSRMLS_CC);\n\n\t\t\tif (EG(exception)) {\n\t\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t\t}\n\n\t\t\tif (key_type == HASH_KEY_IS_LONG) {\n\t\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned an invalid key (must return a string)\", ce->name);\n\t\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t\t}\n\n\t\t\tif (key_type > 9) { /* IS_UNICODE == 10 */\n#if PHP_VERSION_ID < 60000\n/* this can never happen, but fixes a compile warning */\n\t\t\t\tspprintf(&str_key, 0, \"%s\", key);\n#else\n\t\t\t\tspprintf(&str_key, 0, \"%v\", key);\n\t\t\t\tezfree(key);\n#endif\n\t\t\t} else {\n\t\t\t\tPHAR_STR(key, str_key);\n\t\t\t}\n\n\t\t\tsave = str_key;\n\n\t\t\tif (str_key[str_key_len - 1] == '\\0') str_key_len--;\n\t\t} else {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned an invalid key (must return a string)\", ce->name);\n\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t}\n\t}\n#if PHP_API_VERSION < 20100412\n\tif (PG(safe_mode) && (!php_checkuid(fname, NULL, CHECKUID_ALLOW_ONLY_FILE))) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned a path \\\"%s\\\" that safe mode prevents opening\", ce->name, fname);\n\n\t\tif (save) {\n\t\t\tefree(save);\n\t\t}\n\n\t\tif (temp) {\n\t\t\tefree(temp);\n\t\t}\n\n\t\treturn ZEND_HASH_APPLY_STOP;\n\t}\n#endif\n\n\tif (php_check_open_basedir(fname TSRMLS_CC)) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned a path \\\"%s\\\" that open_basedir prevents opening\", ce->name, fname);\n\n\t\tif (save) {\n\t\t\tefree(save);\n\t\t}\n\n\t\tif (temp) {\n\t\t\tefree(temp);\n\t\t}\n\n\t\treturn ZEND_HASH_APPLY_STOP;\n\t}\n\n\t/* try to open source file, then create internal phar file and copy contents */\n\tfp = php_stream_open_wrapper(fname, \"rb\", STREAM_MUST_SEEK|0, &opened);\n\n\tif (!fp) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned a file that could not be opened \\\"%s\\\"\", ce->name, fname);\n\n\t\tif (save) {\n\t\t\tefree(save);\n\t\t}\n\n\t\tif (temp) {\n\t\t\tefree(temp);\n\t\t}\n\n\t\treturn ZEND_HASH_APPLY_STOP;\n\t}\nafter_open_fp:\n\tif (str_key_len >= sizeof(\".phar\")-1 && !memcmp(str_key, \".phar\", sizeof(\".phar\")-1)) {\n\t\t/* silently skip any files that would be added to the magic .phar directory */\n\t\tif (save) {\n\t\t\tefree(save);\n\t\t}\n\n\t\tif (temp) {\n\t\t\tefree(temp);\n\t\t}\n\n\t\tif (opened) {\n\t\t\tefree(opened);\n\t\t}\n\n\t\tif (close_fp) {\n\t\t\tphp_stream_close(fp);\n\t\t}\n\n\t\treturn ZEND_HASH_APPLY_KEEP;\n\t}\n\n\tif (!(data = phar_get_or_create_entry_data(phar_obj->arc.archive->fname, phar_obj->arc.archive->fname_len, str_key, str_key_len, \"w+b\", 0, &error, 1 TSRMLS_CC))) {\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Entry %s cannot be created: %s\", str_key, error);\n\t\tefree(error);\n\n\t\tif (save) {\n\t\t\tefree(save);\n\t\t}\n\n\t\tif (opened) {\n\t\t\tefree(opened);\n\t\t}\n\n\t\tif (temp) {\n\t\t\tefree(temp);\n\t\t}\n\n\t\tif (close_fp) {\n\t\t\tphp_stream_close(fp);\n\t\t}\n\n\t\treturn ZEND_HASH_APPLY_STOP;\n\n\t} else {\n\t\tif (error) {\n\t\t\tefree(error);\n\t\t}\n\t\t/* convert to PHAR_UFP */\n\t\tif (data->internal_file->fp_type == PHAR_MOD) {\n\t\t\tphp_stream_close(data->internal_file->fp);\n\t\t}\n\n\t\tdata->internal_file->fp = NULL;\n\t\tdata->internal_file->fp_type = PHAR_UFP;\n\t\tdata->internal_file->offset_abs = data->internal_file->offset = php_stream_tell(p_obj->fp);\n\t\tdata->fp = NULL;\n\t\tphar_stream_copy_to_stream(fp, p_obj->fp, PHP_STREAM_COPY_ALL, &contents_len);\n\t\tdata->internal_file->uncompressed_filesize = data->internal_file->compressed_filesize =\n\t\t\tphp_stream_tell(p_obj->fp) - data->internal_file->offset;\n\t}\n\n\tif (close_fp) {\n\t\tphp_stream_close(fp);\n\t}\n\n\tadd_assoc_string(p_obj->ret, str_key, opened, 0);\n\n\tif (save) {\n\t\tefree(save);\n\t}\n\n\tif (temp) {\n\t\tefree(temp);\n\t}\n\n\tdata->internal_file->compressed_filesize = data->internal_file->uncompressed_filesize = contents_len;\n\tphar_entry_delref(data TSRMLS_CC);\n\n\treturn ZEND_HASH_APPLY_KEEP;\n}\n/* }}} */\n\n /* {{{ proto array Phar::buildFromDirectory(string base_dir[, string regex])\n  * Construct a phar archive from an existing directory, recursively.\n  * Optional second parameter is a regular expression for filtering directory contents.\n * \n  * Return value is an array mapping phar index to actual files added.\n  */\n PHP_METHOD(Phar, buildFromDirectory)\n{\n\tchar *dir, *error, *regex = NULL;\n\tint dir_len, regex_len = 0;\n\tzend_bool apply_reg = 0;\n\tzval arg, arg2, *iter, *iteriter, *regexiter = NULL;\n\tstruct _phar_t pass;\n\n\tPHAR_ARCHIVE_OBJECT();\n\n\tif (PHAR_G(readonly) && !phar_obj->arc.archive->is_data) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\"Cannot write to archive - write operations restricted by INI setting\");\n\t\treturn;\n\t}\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|s\", &dir, &dir_len, &regex, &regex_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tMAKE_STD_ZVAL(iter);\n\n\tif (SUCCESS != object_init_ex(iter, spl_ce_RecursiveDirectoryIterator)) {\n\t\tzval_ptr_dtor(&iter);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to instantiate directory iterator for %s\", phar_obj->arc.archive->fname);\n\t\tRETURN_FALSE;\n\t}\n\n\tINIT_PZVAL(&arg);\n\tZVAL_STRINGL(&arg, dir, dir_len, 0);\n\tINIT_PZVAL(&arg2);\n#if PHP_VERSION_ID < 50300\n\tZVAL_LONG(&arg2, 0);\n#else\n        ZVAL_LONG(&arg2, SPL_FILE_DIR_SKIPDOTS|SPL_FILE_DIR_UNIXPATHS);\n #endif\n \n       zend_call_method_with_2_params(&iter, spl_ce_RecursiveDirectoryIterator, \n                        &spl_ce_RecursiveDirectoryIterator->constructor, \"__construct\", NULL, &arg, &arg2);\n \n        if (EG(exception)) {\n\t\tzval_ptr_dtor(&iter);\n\t\tRETURN_FALSE;\n\t}\n\n\tMAKE_STD_ZVAL(iteriter);\n\n\tif (SUCCESS != object_init_ex(iteriter, spl_ce_RecursiveIteratorIterator)) {\n\t\tzval_ptr_dtor(&iter);\n\t\tzval_ptr_dtor(&iteriter);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to instantiate directory iterator for %s\", phar_obj->arc.archive->fname);\n                RETURN_FALSE;\n        }\n \n       zend_call_method_with_1_params(&iteriter, spl_ce_RecursiveIteratorIterator, \n                        &spl_ce_RecursiveIteratorIterator->constructor, \"__construct\", NULL, iter);\n \n        if (EG(exception)) {\n\t\tzval_ptr_dtor(&iter);\n\t\tzval_ptr_dtor(&iteriter);\n\t\tRETURN_FALSE;\n\t}\n\n\tzval_ptr_dtor(&iter);\n\n\tif (regex_len > 0) {\n\t\tapply_reg = 1;\n\t\tMAKE_STD_ZVAL(regexiter);\n\n\t\tif (SUCCESS != object_init_ex(regexiter, spl_ce_RegexIterator)) {\n\t\t\tzval_ptr_dtor(&iteriter);\n\t\t\tzval_dtor(regexiter);\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to instantiate regex iterator for %s\", phar_obj->arc.archive->fname);\n\t\t\tRETURN_FALSE;\n\t\t}\n\n                INIT_PZVAL(&arg2);\n                ZVAL_STRINGL(&arg2, regex, regex_len, 0);\n \n               zend_call_method_with_2_params(&regexiter, spl_ce_RegexIterator, \n                        &spl_ce_RegexIterator->constructor, \"__construct\", NULL, iteriter, &arg2);\n        }\n \n\tarray_init(return_value);\n\n\tpass.c = apply_reg ? Z_OBJCE_P(regexiter) : Z_OBJCE_P(iteriter);\n\tpass.p = phar_obj;\n\tpass.b = dir;\n\tpass.l = dir_len;\n\tpass.count = 0;\n\tpass.ret = return_value;\n\tpass.fp = php_stream_fopen_tmpfile();\n\tif (pass.fp == NULL) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar \\\"%s\\\" unable to create temporary file\", phar_obj->arc.archive->fname);\n\t\treturn;\n\t}\n\n\tif (phar_obj->arc.archive->is_persistent && FAILURE == phar_copy_on_write(&(phar_obj->arc.archive) TSRMLS_CC)) {\n\t\tzval_ptr_dtor(&iteriter);\n\t\tif (apply_reg) {\n\t\t\tzval_ptr_dtor(&regexiter);\n\t\t}\n\t\tphp_stream_close(pass.fp);\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar \\\"%s\\\" is persistent, unable to copy on write\", phar_obj->arc.archive->fname);\n\t\treturn;\n\t}\n\n\tif (SUCCESS == spl_iterator_apply((apply_reg ? regexiter : iteriter), (spl_iterator_apply_func_t) phar_build, (void *) &pass TSRMLS_CC)) {\n\t\tzval_ptr_dtor(&iteriter);\n\n\t\tif (apply_reg) {\n\t\t\tzval_ptr_dtor(&regexiter);\n\t\t}\n\n\t\tphar_obj->arc.archive->ufp = pass.fp;\n\t\tphar_flush(phar_obj->arc.archive, 0, 0, 0, &error TSRMLS_CC);\n\n\t\tif (error) {\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);\n\t\t\tefree(error);\n\t\t}\n\n\t} else {\n\t\tzval_ptr_dtor(&iteriter);\n\t\tif (apply_reg) {\n\t\t\tzval_ptr_dtor(&regexiter);\n\t\t}\n\t\tphp_stream_close(pass.fp);\n\t}\n}\n/* }}} */\n\n/* {{{ proto array Phar::buildFromIterator(Iterator iter[, string base_directory])\n * Construct a phar archive from an iterator.  The iterator must return a series of strings\n * that are full paths to files that should be added to the phar.  The iterator key should\n * be the path that the file will have within the phar archive.\n *\n * If base directory is specified, then the key will be ignored, and instead the portion of\n * the current value minus the base directory will be used\n *\n * Returned is an array mapping phar index to actual file added\n */\nPHP_METHOD(Phar, buildFromIterator)\n{\n\tzval *obj;\n\tchar *error;\n\tuint base_len = 0;\n\tchar *base = NULL;\n\tstruct _phar_t pass;\n\n\tPHAR_ARCHIVE_OBJECT();\n\n\tif (PHAR_G(readonly) && !phar_obj->arc.archive->is_data) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\"Cannot write out phar archive, phar is read-only\");\n\t\treturn;\n\t}\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"O|s\", &obj, zend_ce_traversable, &base, &base_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (phar_obj->arc.archive->is_persistent && FAILURE == phar_copy_on_write(&(phar_obj->arc.archive) TSRMLS_CC)) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar \\\"%s\\\" is persistent, unable to copy on write\", phar_obj->arc.archive->fname);\n\t\treturn;\n\t}\n\n\tarray_init(return_value);\n\n\tpass.c = Z_OBJCE_P(obj);\n\tpass.p = phar_obj;\n\tpass.b = base;\n\tpass.l = base_len;\n\tpass.ret = return_value;\n\tpass.count = 0;\n\tpass.fp = php_stream_fopen_tmpfile();\n\tif (pass.fp == NULL) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar \\\"%s\\\": unable to create temporary file\", phar_obj->arc.archive->fname);\n\t\treturn;\n\t}\n\n\tif (SUCCESS == spl_iterator_apply(obj, (spl_iterator_apply_func_t) phar_build, (void *) &pass TSRMLS_CC)) {\n\t\tphar_obj->arc.archive->ufp = pass.fp;\n\t\tphar_flush(phar_obj->arc.archive, 0, 0, 0, &error TSRMLS_CC);\n\t\tif (error) {\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);\n\t\t\tefree(error);\n\t\t}\n\t} else {\n\t\tphp_stream_close(pass.fp);\n\t}\n}\n/* }}} */\n\n/* {{{ proto int Phar::count()\n * Returns the number of entries in the Phar archive\n */\n PHP_METHOD(Phar, count)\n {\n        PHAR_ARCHIVE_OBJECT();\n        if (zend_parse_parameters_none() == FAILURE) {\n                return;\n        }\n\n\tRETURN_LONG(zend_hash_num_elements(&phar_obj->arc.archive->manifest));\n}\n/* }}} */\n\n/* {{{ proto bool Phar::isFileFormat(int format)\n * Returns true if the phar archive is based on the tar/zip/phar file format depending\n * on whether Phar::TAR, Phar::ZIP or Phar::PHAR was passed in\n */\nPHP_METHOD(Phar, isFileFormat)\n{\n\tlong type;\n\tPHAR_ARCHIVE_OBJECT();\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &type) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tswitch (type) {\n\t\tcase PHAR_FORMAT_TAR:\n\t\t\tRETURN_BOOL(phar_obj->arc.archive->is_tar);\n\t\tcase PHAR_FORMAT_ZIP:\n\t\t\tRETURN_BOOL(phar_obj->arc.archive->is_zip);\n\t\tcase PHAR_FORMAT_PHAR:\n\t\t\tRETURN_BOOL(!phar_obj->arc.archive->is_tar && !phar_obj->arc.archive->is_zip);\n\t\tdefault:\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Unknown file format specified\");\n\t}\n}\n/* }}} */\n\nstatic int phar_copy_file_contents(phar_entry_info *entry, php_stream *fp TSRMLS_DC) /* {{{ */\n{\n\tchar *error;\n\toff_t offset;\n\tphar_entry_info *link;\n\n\tif (FAILURE == phar_open_entry_fp(entry, &error, 1 TSRMLS_CC)) {\n\t\tif (error) {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\t\"Cannot convert phar archive \\\"%s\\\", unable to open entry \\\"%s\\\" contents: %s\", entry->phar->fname, entry->filename, error);\n\t\t\tefree(error);\n\t\t} else {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\t\"Cannot convert phar archive \\\"%s\\\", unable to open entry \\\"%s\\\" contents\", entry->phar->fname, entry->filename);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\t/* copy old contents in entirety */\n\tphar_seek_efp(entry, 0, SEEK_SET, 0, 1 TSRMLS_CC);\n\toffset = php_stream_tell(fp);\n\tlink = phar_get_link_source(entry TSRMLS_CC);\n\n\tif (!link) {\n\t\tlink = entry;\n\t}\n\n\tif (SUCCESS != phar_stream_copy_to_stream(phar_get_efp(link, 0 TSRMLS_CC), fp, link->uncompressed_filesize, NULL)) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\"Cannot convert phar archive \\\"%s\\\", unable to copy entry \\\"%s\\\" contents\", entry->phar->fname, entry->filename);\n\t\treturn FAILURE;\n\t}\n\n\tif (entry->fp_type == PHAR_MOD) {\n\t\t/* save for potential restore on error */\n\t\tentry->cfp = entry->fp;\n\t\tentry->fp = NULL;\n\t}\n\n\t/* set new location of file contents */\n\tentry->fp_type = PHAR_FP;\n\tentry->offset = offset;\n\treturn SUCCESS;\n}\n/* }}} */\n\nstatic zval *phar_rename_archive(phar_archive_data *phar, char *ext, zend_bool compress TSRMLS_DC) /* {{{ */\n{\n\tconst char *oldname = NULL;\n\tchar *oldpath = NULL;\n\tchar *basename = NULL, *basepath = NULL;\n\tchar *newname = NULL, *newpath = NULL;\n\tzval *ret, arg1;\n\tzend_class_entry *ce;\n\tchar *error;\n\tconst char *pcr_error;\n\tint ext_len = ext ? strlen(ext) : 0;\n\tint oldname_len;\n\tphar_archive_data **pphar = NULL;\n\tphp_stream_statbuf ssb;\n\n\tif (!ext) {\n\t\tif (phar->is_zip) {\n\n\t\t\tif (phar->is_data) {\n\t\t\t\text = \"zip\";\n\t\t\t} else {\n\t\t\t\text = \"phar.zip\";\n\t\t\t}\n\n\t\t} else if (phar->is_tar) {\n\n\t\t\tswitch (phar->flags) {\n\t\t\t\tcase PHAR_FILE_COMPRESSED_GZ:\n\t\t\t\t\tif (phar->is_data) {\n\t\t\t\t\t\text = \"tar.gz\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\text = \"phar.tar.gz\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase PHAR_FILE_COMPRESSED_BZ2:\n\t\t\t\t\tif (phar->is_data) {\n\t\t\t\t\t\text = \"tar.bz2\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\text = \"phar.tar.bz2\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (phar->is_data) {\n\t\t\t\t\t\text = \"tar\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\text = \"phar.tar\";\n\t\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\n\t\t\tswitch (phar->flags) {\n\t\t\t\tcase PHAR_FILE_COMPRESSED_GZ:\n\t\t\t\t\text = \"phar.gz\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase PHAR_FILE_COMPRESSED_BZ2:\n\t\t\t\t\text = \"phar.bz2\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\text = \"phar\";\n\t\t\t}\n\t\t}\n\t} else if (phar_path_check(&ext, &ext_len, &pcr_error) > pcr_is_ok) {\n\n\t\tif (phar->is_data) {\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"data phar converted from \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n\t\t} else {\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"phar converted from \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (ext[0] == '.') {\n\t\t++ext;\n\t}\n\n\toldpath = estrndup(phar->fname, phar->fname_len);\n\toldname = zend_memrchr(phar->fname, '/', phar->fname_len);\n\t++oldname;\n\toldname_len = strlen(oldname);\n\n\tbasename = estrndup(oldname, oldname_len);\n        spprintf(&newname, 0, \"%s.%s\", strtok(basename, \".\"), ext);\n        efree(basename);\n \n \n        basepath = estrndup(oldpath, (strlen(oldpath) - oldname_len));\n        phar->fname_len = spprintf(&newpath, 0, \"%s%s\", basepath, newname);\n\tphar->fname = newpath;\n\tphar->ext = newpath + phar->fname_len - strlen(ext) - 1;\n\tefree(basepath);\n\tefree(newname);\n\n\tif (PHAR_G(manifest_cached) && SUCCESS == zend_hash_find(&cached_phars, newpath, phar->fname_len, (void **) &pphar)) {\n\t\tefree(oldpath);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to add newly converted phar \\\"%s\\\" to the list of phars, new phar name is in phar.cache_list\", phar->fname);\n\t\treturn NULL;\n\t}\n\n\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_fname_map), newpath, phar->fname_len, (void **) &pphar)) {\n\t\tif ((*pphar)->fname_len == phar->fname_len && !memcmp((*pphar)->fname, phar->fname, phar->fname_len)) {\n\t\t\tif (!zend_hash_num_elements(&phar->manifest)) {\n\t\t\t\t(*pphar)->is_tar = phar->is_tar;\n\t\t\t\t(*pphar)->is_zip = phar->is_zip;\n\t\t\t\t(*pphar)->is_data = phar->is_data;\n\t\t\t\t(*pphar)->flags = phar->flags;\n\t\t\t\t(*pphar)->fp = phar->fp;\n\t\t\t\tphar->fp = NULL;\n\t\t\t\tphar_destroy_phar_data(phar TSRMLS_CC);\n\t\t\t\tphar = *pphar;\n\t\t\t\tphar->refcount++;\n\t\t\t\tnewpath = oldpath;\n\t\t\t\tgoto its_ok;\n\t\t\t}\n\t\t}\n\n\t\tefree(oldpath);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to add newly converted phar \\\"%s\\\" to the list of phars, a phar with that name already exists\", phar->fname);\n\t\treturn NULL;\n\t}\nits_ok:\n\tif (SUCCESS == php_stream_stat_path(newpath, &ssb)) {\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"phar \\\"%s\\\" exists and must be unlinked prior to conversion\", newpath);\n\t\tefree(oldpath);\n\t\treturn NULL;\n\t}\n\tif (!phar->is_data) {\n\t\tif (SUCCESS != phar_detect_phar_fname_ext(newpath, phar->fname_len, (const char **) &(phar->ext), &(phar->ext_len), 1, 1, 1 TSRMLS_CC)) {\n\t\t\tefree(oldpath);\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"phar \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (phar->alias) {\n\t\t\tif (phar->is_temporary_alias) {\n\t\t\t\tphar->alias = NULL;\n\t\t\t\tphar->alias_len = 0;\n\t\t\t} else {\n\t\t\t\tphar->alias = estrndup(newpath, strlen(newpath));\n\t\t\t\tphar->alias_len = strlen(newpath);\n\t\t\t\tphar->is_temporary_alias = 1;\n\t\t\t\tzend_hash_update(&(PHAR_GLOBALS->phar_alias_map), newpath, phar->fname_len, (void*)&phar, sizeof(phar_archive_data*), NULL);\n\t\t\t}\n\t\t}\n\n\t} else {\n\n\t\tif (SUCCESS != phar_detect_phar_fname_ext(newpath, phar->fname_len, (const char **) &(phar->ext), &(phar->ext_len), 0, 1, 1 TSRMLS_CC)) {\n\t\t\tefree(oldpath);\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"data phar \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tphar->alias = NULL;\n\t\tphar->alias_len = 0;\n\t}\n\n\tif ((!pphar || phar == *pphar) && SUCCESS != zend_hash_update(&(PHAR_GLOBALS->phar_fname_map), newpath, phar->fname_len, (void*)&phar, sizeof(phar_archive_data*), NULL)) {\n\t\tefree(oldpath);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to add newly converted phar \\\"%s\\\" to the list of phars\", phar->fname);\n\t\treturn NULL;\n\t}\n\n\tphar_flush(phar, 0, 0, 1, &error TSRMLS_CC);\n\n\tif (error) {\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"%s\", error);\n\t\tefree(error);\n\t\tefree(oldpath);\n\t\treturn NULL;\n\t}\n\n\tefree(oldpath);\n\n\tif (phar->is_data) {\n\t\tce = phar_ce_data;\n\t} else {\n\t\tce = phar_ce_archive;\n\t}\n\n\tMAKE_STD_ZVAL(ret);\n\n\tif (SUCCESS != object_init_ex(ret, ce)) {\n\t\tzval_dtor(ret);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to instantiate phar object when converting archive \\\"%s\\\"\", phar->fname);\n\t\treturn NULL;\n\t}\n\n\tINIT_PZVAL(&arg1);\n\tZVAL_STRINGL(&arg1, phar->fname, phar->fname_len, 0);\n\n\tzend_call_method_with_1_params(&ret, ce, &ce->constructor, \"__construct\", NULL, &arg1);\n\treturn ret;\n}\n/* }}} */\n\nstatic zval *phar_convert_to_other(phar_archive_data *source, int convert, char *ext, php_uint32 flags TSRMLS_DC) /* {{{ */\n{\n\tphar_archive_data *phar;\n\tphar_entry_info *entry, newentry;\n\tzval *ret;\n\n\t/* invalidate phar cache */\n\tPHAR_G(last_phar) = NULL;\n\tPHAR_G(last_phar_name) = PHAR_G(last_alias) = NULL;\n\n\tphar = (phar_archive_data *) ecalloc(1, sizeof(phar_archive_data));\n\t/* set whole-archive compression and type from parameter */\n\tphar->flags = flags;\n\tphar->is_data = source->is_data;\n\n\tswitch (convert) {\n\t\tcase PHAR_FORMAT_TAR:\n\t\t\tphar->is_tar = 1;\n\t\t\tbreak;\n\t\tcase PHAR_FORMAT_ZIP:\n\t\t\tphar->is_zip = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphar->is_data = 0;\n\t\t\tbreak;\n\t}\n\n\tzend_hash_init(&(phar->manifest), sizeof(phar_entry_info),\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, 0);\n\tzend_hash_init(&phar->mounted_dirs, sizeof(char *),\n\t\tzend_get_hash_value, NULL, 0);\n\tzend_hash_init(&phar->virtual_dirs, sizeof(char *),\n\t\tzend_get_hash_value, NULL, 0);\n\n\tphar->fp = php_stream_fopen_tmpfile();\n\tif (phar->fp == NULL) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"unable to create temporary file\");\n\t\treturn NULL;\n\t}\n\tphar->fname = source->fname;\n\tphar->fname_len = source->fname_len;\n\tphar->is_temporary_alias = source->is_temporary_alias;\n\tphar->alias = source->alias;\n\n\tif (source->metadata) {\n\t\tzval *t;\n\n\t\tt = source->metadata;\n\t\tALLOC_ZVAL(phar->metadata);\n\t\t*phar->metadata = *t;\n\t\tzval_copy_ctor(phar->metadata);\n#if PHP_VERSION_ID < 50300\n\t\tphar->metadata->refcount = 1;\n#else\n\t\tZ_SET_REFCOUNT_P(phar->metadata, 1);\n#endif\n\n\t\tphar->metadata_len = 0;\n\t}\n\n\t/* first copy each file's uncompressed contents to a temporary file and set per-file flags */\n\tfor (zend_hash_internal_pointer_reset(&source->manifest); SUCCESS == zend_hash_has_more_elements(&source->manifest); zend_hash_move_forward(&source->manifest)) {\n\n\t\tif (FAILURE == zend_hash_get_current_data(&source->manifest, (void **) &entry)) {\n\t\t\tzend_hash_destroy(&(phar->manifest));\n\t\t\tphp_stream_close(phar->fp);\n\t\t\tefree(phar);\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\t\"Cannot convert phar archive \\\"%s\\\"\", source->fname);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tnewentry = *entry;\n\n\t\tif (newentry.link) {\n\t\t\tnewentry.link = estrdup(newentry.link);\n\t\t\tgoto no_copy;\n\t\t}\n\n\t\tif (newentry.tmp) {\n\t\t\tnewentry.tmp = estrdup(newentry.tmp);\n\t\t\tgoto no_copy;\n\t\t}\n\n\t\tnewentry.metadata_str.c = 0;\n\n\t\tif (FAILURE == phar_copy_file_contents(&newentry, phar->fp TSRMLS_CC)) {\n\t\t\tzend_hash_destroy(&(phar->manifest));\n\t\t\tphp_stream_close(phar->fp);\n\t\t\tefree(phar);\n\t\t\t/* exception already thrown */\n\t\t\treturn NULL;\n\t\t}\nno_copy:\n\t\tnewentry.filename = estrndup(newentry.filename, newentry.filename_len);\n\n\t\tif (newentry.metadata) {\n\t\t\tzval *t;\n\n\t\t\tt = newentry.metadata;\n\t\t\tALLOC_ZVAL(newentry.metadata);\n\t\t\t*newentry.metadata = *t;\n\t\t\tzval_copy_ctor(newentry.metadata);\n#if PHP_VERSION_ID < 50300\n\t\t\tnewentry.metadata->refcount = 1;\n#else\n\t\t\tZ_SET_REFCOUNT_P(newentry.metadata, 1);\n#endif\n\n\t\t\tnewentry.metadata_str.c = NULL;\n\t\t\tnewentry.metadata_str.len = 0;\n\t\t}\n\n\t\tnewentry.is_zip = phar->is_zip;\n\t\tnewentry.is_tar = phar->is_tar;\n\n\t\tif (newentry.is_tar) {\n\t\t\tnewentry.tar_type = (entry->is_dir ? TAR_DIR : TAR_FILE);\n\t\t}\n\n\t\tnewentry.is_modified = 1;\n\t\tnewentry.phar = phar;\n\t\tnewentry.old_flags = newentry.flags & ~PHAR_ENT_COMPRESSION_MASK; /* remove compression from old_flags */\n\t\tphar_set_inode(&newentry TSRMLS_CC);\n\t\tzend_hash_add(&(phar->manifest), newentry.filename, newentry.filename_len, (void*)&newentry, sizeof(phar_entry_info), NULL);\n\t\tphar_add_virtual_dirs(phar, newentry.filename, newentry.filename_len TSRMLS_CC);\n\t}\n\n\tif ((ret = phar_rename_archive(phar, ext, 0 TSRMLS_CC))) {\n\t\treturn ret;\n\t} else {\n                zend_hash_destroy(&(phar->manifest));\n                zend_hash_destroy(&(phar->mounted_dirs));\n                zend_hash_destroy(&(phar->virtual_dirs));\n               php_stream_close(phar->fp);\n                efree(phar->fname);\n                efree(phar);\n                return NULL;\n/* }}} */\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144379,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "PHP_METHOD(Phar, webPhar)\n{\n\tzval *mimeoverride = NULL, *rewrite = NULL;\n\tchar *alias = NULL, *error, *index_php = NULL, *f404 = NULL, *ru = NULL;\n\tint alias_len = 0, ret, f404_len = 0, free_pathinfo = 0, ru_len = 0;\n\tchar *fname, *path_info, *mime_type = NULL, *entry, *pt;\n\tconst char *basename;\n\tint fname_len, entry_len, code, index_php_len = 0, not_cgi;\n\tphar_archive_data *phar = NULL;\n\tphar_entry_info *info = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|s!s!saz\", &alias, &alias_len, &index_php, &index_php_len, &f404, &f404_len, &mimeoverride, &rewrite) == FAILURE) {\n\t\treturn;\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\tfname = (char*)zend_get_executed_filename(TSRMLS_C);\n\tfname_len = strlen(fname);\n\n\tif (phar_open_executed_filename(alias, alias_len, &error TSRMLS_CC) != SUCCESS) {\n\t\tif (error) {\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);\n\t\t\tefree(error);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* retrieve requested file within phar */\n\tif (!(SG(request_info).request_method && SG(request_info).request_uri && (!strcmp(SG(request_info).request_method, \"GET\") || !strcmp(SG(request_info).request_method, \"POST\")))) {\n\t\treturn;\n\t}\n\n#ifdef PHP_WIN32\n\tfname = estrndup(fname, fname_len);\n\tphar_unixify_path_separators(fname, fname_len);\n#endif\n\tbasename = zend_memrchr(fname, '/', fname_len);\n\n\tif (!basename) {\n\t\tbasename = fname;\n\t} else {\n\t\t++basename;\n\t}\n\n\tif ((strlen(sapi_module.name) == sizeof(\"cgi-fcgi\")-1 && !strncmp(sapi_module.name, \"cgi-fcgi\", sizeof(\"cgi-fcgi\")-1))\n\t\t|| (strlen(sapi_module.name) == sizeof(\"fpm-fcgi\")-1 && !strncmp(sapi_module.name, \"fpm-fcgi\", sizeof(\"fpm-fcgi\")-1))\n\t\t|| (strlen(sapi_module.name) == sizeof(\"cgi\")-1 && !strncmp(sapi_module.name, \"cgi\", sizeof(\"cgi\")-1))) {\n\n\t\tif (PG(http_globals)[TRACK_VARS_SERVER]) {\n\t\t\tHashTable *_server = Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_SERVER]);\n\t\t\tzval **z_script_name, **z_path_info;\n\n\t\t\tif (SUCCESS != zend_hash_find(_server, \"SCRIPT_NAME\", sizeof(\"SCRIPT_NAME\"), (void**)&z_script_name) ||\n\t\t\t\tIS_STRING != Z_TYPE_PP(z_script_name) ||\n\t\t\t\t!strstr(Z_STRVAL_PP(z_script_name), basename)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (SUCCESS == zend_hash_find(_server, \"PATH_INFO\", sizeof(\"PATH_INFO\"), (void**)&z_path_info) &&\n\t\t\t\tIS_STRING == Z_TYPE_PP(z_path_info)) {\n\t\t\t\tentry_len = Z_STRLEN_PP(z_path_info);\n\t\t\t\tentry = estrndup(Z_STRVAL_PP(z_path_info), entry_len);\n\t\t\t\tpath_info = emalloc(Z_STRLEN_PP(z_script_name) + entry_len + 1);\n\t\t\t\tmemcpy(path_info, Z_STRVAL_PP(z_script_name), Z_STRLEN_PP(z_script_name));\n\t\t\t\tmemcpy(path_info + Z_STRLEN_PP(z_script_name), entry, entry_len + 1);\n\t\t\t\tfree_pathinfo = 1;\n\t\t\t} else {\n\t\t\t\tentry_len = 0;\n\t\t\t\tentry = estrndup(\"\", 0);\n\t\t\t\tpath_info = Z_STRVAL_PP(z_script_name);\n\t\t\t}\n\n\t\t\tpt = estrndup(Z_STRVAL_PP(z_script_name), Z_STRLEN_PP(z_script_name));\n\n\t\t} else {\n\t\t\tchar *testit;\n\n\t\t\ttestit = sapi_getenv(\"SCRIPT_NAME\", sizeof(\"SCRIPT_NAME\")-1 TSRMLS_CC);\n\t\t\tif (!(pt = strstr(testit, basename))) {\n\t\t\t\tefree(testit);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpath_info = sapi_getenv(\"PATH_INFO\", sizeof(\"PATH_INFO\")-1 TSRMLS_CC);\n\n\t\t\tif (path_info) {\n\t\t\t\tentry = path_info;\n\t\t\t\tentry_len = strlen(entry);\n\t\t\t\tspprintf(&path_info, 0, \"%s%s\", testit, path_info);\n\t\t\t\tfree_pathinfo = 1;\n\t\t\t} else {\n\t\t\t\tpath_info = testit;\n\t\t\t\tfree_pathinfo = 1;\n\t\t\t\tentry = estrndup(\"\", 0);\n\t\t\t\tentry_len = 0;\n\t\t\t}\n\n\t\t\tpt = estrndup(testit, (pt - testit) + (fname_len - (basename - fname)));\n\t\t}\n\t\tnot_cgi = 0;\n\t} else {\n\t\tpath_info = SG(request_info).request_uri;\n\n\t\tif (!(pt = strstr(path_info, basename))) {\n\t\t\t/* this can happen with rewrite rules - and we have no idea what to do then, so return */\n\t\t\treturn;\n\t\t}\n\n\t\tentry_len = strlen(path_info);\n\t\tentry_len -= (pt - path_info) + (fname_len - (basename - fname));\n\t\tentry = estrndup(pt + (fname_len - (basename - fname)), entry_len);\n\n\t\tpt = estrndup(path_info, (pt - path_info) + (fname_len - (basename - fname)));\n\t\tnot_cgi = 1;\n\t}\n\n\tif (rewrite) {\n\t\tzend_fcall_info fci;\n\t\tzend_fcall_info_cache fcc;\n\t\tzval *params, *retval_ptr, **zp[1];\n\n\t\tMAKE_STD_ZVAL(params);\n\t\tZVAL_STRINGL(params, entry, entry_len, 1);\n\t\tzp[0] = &params;\n\n#if PHP_VERSION_ID < 50300\n\t\tif (FAILURE == zend_fcall_info_init(rewrite, &fci, &fcc TSRMLS_CC)) {\n#else\n\t\tif (FAILURE == zend_fcall_info_init(rewrite, 0, &fci, &fcc, NULL, NULL TSRMLS_CC)) {\n#endif\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar error: invalid rewrite callback\");\n\n\t\t\tif (free_pathinfo) {\n\t\t\t\tefree(path_info);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tfci.param_count = 1;\n\t\tfci.params = zp;\n#if PHP_VERSION_ID < 50300\n\t\t++(params->refcount);\n#else\n\t\tZ_ADDREF_P(params);\n#endif\n\t\tfci.retval_ptr_ptr = &retval_ptr;\n\n\t\tif (FAILURE == zend_call_function(&fci, &fcc TSRMLS_CC)) {\n\t\t\tif (!EG(exception)) {\n\t\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar error: failed to call rewrite callback\");\n\t\t\t}\n\n\t\t\tif (free_pathinfo) {\n\t\t\t\tefree(path_info);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (!fci.retval_ptr_ptr || !retval_ptr) {\n\t\t\tif (free_pathinfo) {\n\t\t\t\tefree(path_info);\n\t\t\t}\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar error: rewrite callback must return a string or false\");\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (Z_TYPE_P(retval_ptr)) {\n#if PHP_VERSION_ID >= 60000\n\t\t\tcase IS_UNICODE:\n\t\t\t\tzval_unicode_to_string(retval_ptr TSRMLS_CC);\n\t\t\t\t/* break intentionally omitted */\n#endif\n\t\t\tcase IS_STRING:\n\t\t\t\tefree(entry);\n\n\t\t\t\tif (fci.retval_ptr_ptr != &retval_ptr) {\n\t\t\t\t\tentry = estrndup(Z_STRVAL_PP(fci.retval_ptr_ptr), Z_STRLEN_PP(fci.retval_ptr_ptr));\n\t\t\t\t\tentry_len = Z_STRLEN_PP(fci.retval_ptr_ptr);\n\t\t\t\t} else {\n\t\t\t\t\tentry = Z_STRVAL_P(retval_ptr);\n\t\t\t\t\tentry_len = Z_STRLEN_P(retval_ptr);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase IS_BOOL:\n\t\t\t\tphar_do_403(entry, entry_len TSRMLS_CC);\n\n\t\t\t\tif (free_pathinfo) {\n\t\t\t\t\tefree(path_info);\n\t\t\t\t}\n\n\t\t\t\tzend_bailout();\n\t\t\t\treturn;\n\t\t\tdefault:\n\t\t\t\tefree(retval_ptr);\n\n\t\t\t\tif (free_pathinfo) {\n\t\t\t\t\tefree(path_info);\n\t\t\t\t}\n\n\t\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar error: rewrite callback must return a string or false\");\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\tif (entry_len) {\n\t\tphar_postprocess_ru_web(fname, fname_len, &entry, &entry_len, &ru, &ru_len TSRMLS_CC);\n\t}\n\n\tif (!entry_len || (entry_len == 1 && entry[0] == '/')) {\n\t\tefree(entry);\n\t\t/* direct request */\n\t\tif (index_php_len) {\n\t\t\tentry = index_php;\n\t\t\tentry_len = index_php_len;\n\t\t\tif (entry[0] != '/') {\n\t\t\t\tspprintf(&entry, 0, \"/%s\", index_php);\n\t\t\t\t++entry_len;\n\t\t\t}\n\t\t} else {\n\t\t\t/* assume \"index.php\" is starting point */\n\t\t\tentry = estrndup(\"/index.php\", sizeof(\"/index.php\"));\n\t\t\tentry_len = sizeof(\"/index.php\")-1;\n\t\t}\n\n\t\tif (FAILURE == phar_get_archive(&phar, fname, fname_len, NULL, 0, NULL TSRMLS_CC) ||\n\t\t\t(info = phar_get_entry_info(phar, entry, entry_len, NULL, 0 TSRMLS_CC)) == NULL) {\n\t\t\tphar_do_404(phar, fname, fname_len, f404, f404_len, entry, entry_len TSRMLS_CC);\n\n\t\t\tif (free_pathinfo) {\n\t\t\t\tefree(path_info);\n\t\t\t}\n\n\t\t\tzend_bailout();\n\t\t} else {\n\t\t\tchar *tmp = NULL, sa = '\\0';\n\t\t\tsapi_header_line ctr = {0};\n\t\t\tctr.response_code = 301;\n\t\t\tctr.line_len = sizeof(\"HTTP/1.1 301 Moved Permanently\")-1;\n\t\t\tctr.line = \"HTTP/1.1 301 Moved Permanently\";\n\t\t\tsapi_header_op(SAPI_HEADER_REPLACE, &ctr TSRMLS_CC);\n\n\t\t\tif (not_cgi) {\n\t\t\t\ttmp = strstr(path_info, basename) + fname_len;\n\t\t\t\tsa = *tmp;\n\t\t\t\t*tmp = '\\0';\n\t\t\t}\n\n\t\t\tctr.response_code = 0;\n\n\t\t\tif (path_info[strlen(path_info)-1] == '/') {\n\t\t\t\tctr.line_len = spprintf(&(ctr.line), 4096, \"Location: %s%s\", path_info, entry + 1);\n\t\t\t} else {\n\t\t\t\tctr.line_len = spprintf(&(ctr.line), 4096, \"Location: %s%s\", path_info, entry);\n\t\t\t}\n\n\t\t\tif (not_cgi) {\n\t\t\t\t*tmp = sa;\n\t\t\t}\n\n\t\t\tif (free_pathinfo) {\n\t\t\t\tefree(path_info);\n\t\t\t}\n\n\t\t\tsapi_header_op(SAPI_HEADER_REPLACE, &ctr TSRMLS_CC);\n\t\t\tsapi_send_headers(TSRMLS_C);\n\t\t\tefree(ctr.line);\n\t\t\tzend_bailout();\n\t\t}\n\t}\n\n\tif (FAILURE == phar_get_archive(&phar, fname, fname_len, NULL, 0, NULL TSRMLS_CC) ||\n\t\t(info = phar_get_entry_info(phar, entry, entry_len, NULL, 0 TSRMLS_CC)) == NULL) {\n\t\tphar_do_404(phar, fname, fname_len, f404, f404_len, entry, entry_len TSRMLS_CC);\n#ifdef PHP_WIN32\n\t\tefree(fname);\n#endif\n\t\tzend_bailout();\n\t}\n\n\tif (mimeoverride && zend_hash_num_elements(Z_ARRVAL_P(mimeoverride))) {\n\t\tconst char *ext = zend_memrchr(entry, '.', entry_len);\n\t\tzval **val;\n\n\t\tif (ext) {\n\t\t\t++ext;\n\n\t\t\tif (SUCCESS == zend_hash_find(Z_ARRVAL_P(mimeoverride), ext, strlen(ext)+1, (void **) &val)) {\n\t\t\t\tswitch (Z_TYPE_PP(val)) {\n\t\t\t\t\tcase IS_LONG:\n\t\t\t\t\t\tif (Z_LVAL_PP(val) == PHAR_MIME_PHP || Z_LVAL_PP(val) == PHAR_MIME_PHPS) {\n\t\t\t\t\t\t\tmime_type = \"\";\n\t\t\t\t\t\t\tcode = Z_LVAL_PP(val);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Unknown mime type specifier used, only Phar::PHP, Phar::PHPS and a mime type string are allowed\");\n#ifdef PHP_WIN32\n\t\t\t\t\t\t\tefree(fname);\n#endif\n\t\t\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase IS_STRING:\n\t\t\t\t\t\tmime_type = Z_STRVAL_PP(val);\n\t\t\t\t\t\tcode = PHAR_MIME_OTHER;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Unknown mime type specifier used (not a string or int), only Phar::PHP, Phar::PHPS and a mime type string are allowed\");\n#ifdef PHP_WIN32\n\t\t\t\t\t\tefree(fname);\n#endif\n\t\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!mime_type) {\n\t\tcode = phar_file_type(&PHAR_G(mime_types), entry, &mime_type TSRMLS_CC);\n\t}\n\tret = phar_file_action(phar, info, mime_type, code, entry, entry_len, fname, pt, ru, ru_len TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ proto void Phar::mungServer(array munglist)\n * Defines a list of up to 4 $_SERVER variables that should be modified for execution\n * to mask the presence of the phar archive.  This should be used in conjunction with\n * Phar::webPhar(), and has no effect otherwise\n * SCRIPT_NAME, PHP_SELF, REQUEST_URI and SCRIPT_FILENAME\n */\nPHP_METHOD(Phar, mungServer)\n{\n\tzval *mungvalues;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"a\", &mungvalues) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!zend_hash_num_elements(Z_ARRVAL_P(mungvalues))) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"No values passed to Phar::mungServer(), expecting an array of any of these strings: PHP_SELF, REQUEST_URI, SCRIPT_FILENAME, SCRIPT_NAME\");\n\t\treturn;\n\t}\n\n\tif (zend_hash_num_elements(Z_ARRVAL_P(mungvalues)) > 4) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Too many values passed to Phar::mungServer(), expecting an array of any of these strings: PHP_SELF, REQUEST_URI, SCRIPT_FILENAME, SCRIPT_NAME\");\n\t\treturn;\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\n\tfor (zend_hash_internal_pointer_reset(Z_ARRVAL_P(mungvalues)); SUCCESS == zend_hash_has_more_elements(Z_ARRVAL_P(mungvalues)); zend_hash_move_forward(Z_ARRVAL_P(mungvalues))) {\n\t\tzval **data = NULL;\n\n\t\tif (SUCCESS != zend_hash_get_current_data(Z_ARRVAL_P(mungvalues), (void **) &data)) {\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"unable to retrieve array value in Phar::mungServer()\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (Z_TYPE_PP(data) != IS_STRING) {\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Non-string value passed to Phar::mungServer(), expecting an array of any of these strings: PHP_SELF, REQUEST_URI, SCRIPT_FILENAME, SCRIPT_NAME\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (Z_STRLEN_PP(data) == sizeof(\"PHP_SELF\")-1 && !strncmp(Z_STRVAL_PP(data), \"PHP_SELF\", sizeof(\"PHP_SELF\")-1)) {\n\t\t\tPHAR_GLOBALS->phar_SERVER_mung_list |= PHAR_MUNG_PHP_SELF;\n\t\t}\n\n\t\tif (Z_STRLEN_PP(data) == sizeof(\"REQUEST_URI\")-1) {\n\t\t\tif (!strncmp(Z_STRVAL_PP(data), \"REQUEST_URI\", sizeof(\"REQUEST_URI\")-1)) {\n\t\t\t\tPHAR_GLOBALS->phar_SERVER_mung_list |= PHAR_MUNG_REQUEST_URI;\n\t\t\t}\n\t\t\tif (!strncmp(Z_STRVAL_PP(data), \"SCRIPT_NAME\", sizeof(\"SCRIPT_NAME\")-1)) {\n\t\t\t\tPHAR_GLOBALS->phar_SERVER_mung_list |= PHAR_MUNG_SCRIPT_NAME;\n\t\t\t}\n\t\t}\n\n\t\tif (Z_STRLEN_PP(data) == sizeof(\"SCRIPT_FILENAME\")-1 && !strncmp(Z_STRVAL_PP(data), \"SCRIPT_FILENAME\", sizeof(\"SCRIPT_FILENAME\")-1)) {\n\t\t\tPHAR_GLOBALS->phar_SERVER_mung_list |= PHAR_MUNG_SCRIPT_FILENAME;\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ proto void Phar::interceptFileFuncs()\n * instructs phar to intercept fopen, file_get_contents, opendir, and all of the stat-related functions\n * and return stat on files within the phar for relative paths\n *\n * Once called, this cannot be reversed, and continue until the end of the request.\n *\n * This allows legacy scripts to be pharred unmodified\n */\nPHP_METHOD(Phar, interceptFileFuncs)\n{\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tphar_intercept_functions(TSRMLS_C);\n}\n/* }}} */\n\n/* {{{ proto array Phar::createDefaultStub([string indexfile[, string webindexfile]])\n * Return a stub that can be used to run a phar-based archive without the phar extension\n * indexfile is the CLI startup filename, which defaults to \"index.php\", webindexfile\n * is the web startup filename, and also defaults to \"index.php\"\n */\nPHP_METHOD(Phar, createDefaultStub)\n{\n\tchar *index = NULL, *webindex = NULL, *stub, *error;\n\tint index_len = 0, webindex_len = 0;\n\tsize_t stub_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|ss\", &index, &index_len, &webindex, &webindex_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tstub = phar_create_default_stub(index, webindex, &stub_len, &error TSRMLS_CC);\n\n\tif (error) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);\n\t\tefree(error);\n\t\treturn;\n\t}\n\tRETURN_STRINGL(stub, stub_len, 0);\n}\n/* }}} */\n\n/* {{{ proto mixed Phar::mapPhar([string alias, [int dataoffset]])\n * Reads the currently executed file (a phar) and registers its manifest */\nPHP_METHOD(Phar, mapPhar)\n{\n\tchar *alias = NULL, *error;\n\tint alias_len = 0;\n\tlong dataoffset = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|s!l\", &alias, &alias_len, &dataoffset) == FAILURE) {\n\t\treturn;\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\n\tRETVAL_BOOL(phar_open_executed_filename(alias, alias_len, &error TSRMLS_CC) == SUCCESS);\n\n\tif (error) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);\n\t\tefree(error);\n\t}\n} /* }}} */\n\n/* {{{ proto mixed Phar::loadPhar(string filename [, string alias])\n * Loads any phar archive with an alias */\nPHP_METHOD(Phar, loadPhar)\n{\n\tchar *fname, *alias = NULL, *error;\n\tint fname_len, alias_len = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|s!\", &fname, &fname_len, &alias, &alias_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\n\tRETVAL_BOOL(phar_open_from_filename(fname, fname_len, alias, alias_len, REPORT_ERRORS, NULL, &error TSRMLS_CC) == SUCCESS);\n\n\tif (error) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);\n\t\tefree(error);\n\t}\n} /* }}} */\n\n/* {{{ proto string Phar::apiVersion()\n * Returns the api version */\nPHP_METHOD(Phar, apiVersion)\n{\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_STRINGL(PHP_PHAR_API_VERSION, sizeof(PHP_PHAR_API_VERSION)-1, 1);\n}\n/* }}}*/\n\n/* {{{ proto bool Phar::canCompress([int method])\n * Returns whether phar extension supports compression using zlib/bzip2 */\nPHP_METHOD(Phar, canCompress)\n{\n\tlong method = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &method) == FAILURE) {\n\t\treturn;\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\tswitch (method) {\n\tcase PHAR_ENT_COMPRESSED_GZ:\n\t\tif (PHAR_G(has_zlib)) {\n\t\t\tRETURN_TRUE;\n\t\t} else {\n\t\t\tRETURN_FALSE;\n\t\t}\n\tcase PHAR_ENT_COMPRESSED_BZ2:\n\t\tif (PHAR_G(has_bz2)) {\n\t\t\tRETURN_TRUE;\n\t\t} else {\n\t\t\tRETURN_FALSE;\n\t\t}\n\tdefault:\n\t\tif (PHAR_G(has_zlib) || PHAR_G(has_bz2)) {\n\t\t\tRETURN_TRUE;\n\t\t} else {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool Phar::canWrite()\n * Returns whether phar extension supports writing and creating phars */\nPHP_METHOD(Phar, canWrite)\n{\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_BOOL(!PHAR_G(readonly));\n}\n/* }}} */\n\n/* {{{ proto bool Phar::isValidPharFilename(string filename[, bool executable = true])\n * Returns whether the given filename is a valid phar filename */\nPHP_METHOD(Phar, isValidPharFilename)\n{\n\tchar *fname;\n\tconst char *ext_str;\n\tint fname_len, ext_len, is_executable;\n\tzend_bool executable = 1;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|b\", &fname, &fname_len, &executable) == FAILURE) {\n\t\treturn;\n\t}\n\n\tis_executable = executable;\n\tRETVAL_BOOL(phar_detect_phar_fname_ext(fname, fname_len, &ext_str, &ext_len, is_executable, 2, 1 TSRMLS_CC) == SUCCESS);\n}\n/* }}} */\n\n#if HAVE_SPL\n/**\n * from spl_directory\n */\nstatic void phar_spl_foreign_dtor(spl_filesystem_object *object TSRMLS_DC) /* {{{ */\n{\n\tphar_archive_data *phar = (phar_archive_data *) object->oth;\n\n\tif (!phar->is_persistent) {\n\t\tphar_archive_delref(phar TSRMLS_CC);\n\t}\n\n\tobject->oth = NULL;\n}\n/* }}} */\n\n/**\n * from spl_directory\n */\nstatic void phar_spl_foreign_clone(spl_filesystem_object *src, spl_filesystem_object *dst TSRMLS_DC) /* {{{ */\n{\n\tphar_archive_data *phar_data = (phar_archive_data *) dst->oth;\n\n\tif (!phar_data->is_persistent) {\n\t\t++(phar_data->refcount);\n\t}\n}\n/* }}} */\n\nstatic spl_other_handler phar_spl_foreign_handler = {\n\tphar_spl_foreign_dtor,\n\tphar_spl_foreign_clone\n};\n#endif /* HAVE_SPL */\n\n/* {{{ proto void Phar::__construct(string fname [, int flags [, string alias]])\n * Construct a Phar archive object\n *\n * proto void PharData::__construct(string fname [[, int flags [, string alias]], int file format = Phar::TAR])\n * Construct a PharData archive object\n *\n * This function is used as the constructor for both the Phar and PharData\n * classes, hence the two prototypes above.\n */\nPHP_METHOD(Phar, __construct)\n{\n#if !HAVE_SPL\n\tzend_throw_exception_ex(zend_exception_get_default(TSRMLS_C), 0 TSRMLS_CC, \"Cannot instantiate Phar object without SPL extension\");\n#else\n\tchar *fname, *alias = NULL, *error, *arch = NULL, *entry = NULL, *save_fname;\n\tint fname_len, alias_len = 0, arch_len, entry_len, is_data;\n#if PHP_VERSION_ID < 50300\n\tlong flags = 0;\n#else\n\tlong flags = SPL_FILE_DIR_SKIPDOTS|SPL_FILE_DIR_UNIXPATHS;\n#endif\n\tlong format = 0;\n\tphar_archive_object *phar_obj;\n\tphar_archive_data   *phar_data;\n\tzval *zobj = getThis(), arg1, arg2;\n\n\tphar_obj = (phar_archive_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tis_data = instanceof_function(Z_OBJCE_P(zobj), phar_ce_data TSRMLS_CC);\n\n\tif (is_data) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|ls!l\", &fname, &fname_len, &flags, &alias, &alias_len, &format) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|ls!\", &fname, &fname_len, &flags, &alias, &alias_len) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (phar_obj->arc.archive) {\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Cannot call constructor twice\");\n\t\treturn;\n\t}\n\n\tsave_fname = fname;\n\tif (SUCCESS == phar_split_fname(fname, fname_len, &arch, &arch_len, &entry, &entry_len, !is_data, 2 TSRMLS_CC)) {\n\t\t/* use arch (the basename for the archive) for fname instead of fname */\n\t\t/* this allows support for RecursiveDirectoryIterator of subdirectories */\n#ifdef PHP_WIN32\n\t\tphar_unixify_path_separators(arch, arch_len);\n#endif\n\t\tfname = arch;\n\t\tfname_len = arch_len;\n#ifdef PHP_WIN32\n\t} else {\n\t\tarch = estrndup(fname, fname_len);\n\t\tarch_len = fname_len;\n\t\tfname = arch;\n\t\tphar_unixify_path_separators(arch, arch_len);\n#endif\n\t}\n\n\tif (phar_open_or_create_filename(fname, fname_len, alias, alias_len, is_data, REPORT_ERRORS, &phar_data, &error TSRMLS_CC) == FAILURE) {\n\n\t\tif (fname == arch && fname != save_fname) {\n\t\t\tefree(arch);\n\t\t\tfname = save_fname;\n\t\t}\n\n\t\tif (entry) {\n\t\t\tefree(entry);\n\t\t}\n\n\t\tif (error) {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\t\"%s\", error);\n\t\t\tefree(error);\n\t\t} else {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\t\"Phar creation or opening failed\");\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (is_data && phar_data->is_tar && phar_data->is_brandnew && format == PHAR_FORMAT_ZIP) {\n\t\tphar_data->is_zip = 1;\n\t\tphar_data->is_tar = 0;\n\t}\n\n\tif (fname == arch) {\n\t\tefree(arch);\n\t\tfname = save_fname;\n\t}\n\n\tif ((is_data && !phar_data->is_data) || (!is_data && phar_data->is_data)) {\n\t\tif (is_data) {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\t\"PharData class can only be used for non-executable tar and zip archives\");\n\t\t} else {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\t\"Phar class can only be used for executable tar and zip archives\");\n\t\t}\n\t\tefree(entry);\n\t\treturn;\n\t}\n\n\tis_data = phar_data->is_data;\n\n\tif (!phar_data->is_persistent) {\n\t\t++(phar_data->refcount);\n\t}\n\n\tphar_obj->arc.archive = phar_data;\n\tphar_obj->spl.oth_handler = &phar_spl_foreign_handler;\n\n\tif (entry) {\n\t\tfname_len = spprintf(&fname, 0, \"phar://%s%s\", phar_data->fname, entry);\n\t\tefree(entry);\n\t} else {\n\t\tfname_len = spprintf(&fname, 0, \"phar://%s\", phar_data->fname);\n\t}\n\n\tINIT_PZVAL(&arg1);\n\tZVAL_STRINGL(&arg1, fname, fname_len, 0);\n        INIT_PZVAL(&arg2);\n        ZVAL_LONG(&arg2, flags);\n \n       zend_call_method_with_2_params(&zobj, Z_OBJCE_P(zobj),\n                &spl_ce_RecursiveDirectoryIterator->constructor, \"__construct\", NULL, &arg1, &arg2);\n \n        if (!phar_data->is_persistent) {\n\t\tphar_obj->arc.archive->is_data = is_data;\n\t} else if (!EG(exception)) {\n\t\t/* register this guy so we can modify if necessary */\n\t\tzend_hash_add(&PHAR_GLOBALS->phar_persist_map, (const char *) phar_obj->arc.archive, sizeof(phar_obj->arc.archive), (void *) &phar_obj, sizeof(phar_archive_object **), NULL);\n\t}\n\n\tphar_obj->spl.info_class = phar_ce_entry;\n\tefree(fname);\n#endif /* HAVE_SPL */\n}\n/* }}} */\n\n/* {{{ proto array Phar::getSupportedSignatures()\n * Return array of supported signature types\n */\nPHP_METHOD(Phar, getSupportedSignatures)\n{\n        if (zend_parse_parameters_none() == FAILURE) {\n                return;\n        }\n\n        array_init(return_value);\n \n        add_next_index_stringl(return_value, \"MD5\", 3, 1);\n\tadd_next_index_stringl(return_value, \"SHA-1\", 5, 1);\n#ifdef PHAR_HASH_OK\n\tadd_next_index_stringl(return_value, \"SHA-256\", 7, 1);\n\tadd_next_index_stringl(return_value, \"SHA-512\", 7, 1);\n#endif\n#if PHAR_HAVE_OPENSSL\n\tadd_next_index_stringl(return_value, \"OpenSSL\", 7, 1);\n#else\n\tif (zend_hash_exists(&module_registry, \"openssl\", sizeof(\"openssl\"))) {\n\t\tadd_next_index_stringl(return_value, \"OpenSSL\", 7, 1);\n\t}\n#endif\n}\n/* }}} */\n\n/* {{{ proto array Phar::getSupportedCompression()\n * Return array of supported comparession algorithms\n */\nPHP_METHOD(Phar, getSupportedCompression)\n{\n        if (zend_parse_parameters_none() == FAILURE) {\n                return;\n        }\n\n        array_init(return_value);\n        phar_request_initialize(TSRMLS_C);\n \n\tif (PHAR_G(has_zlib)) {\n\t\tadd_next_index_stringl(return_value, \"GZ\", 2, 1);\n\t}\n\n\tif (PHAR_G(has_bz2)) {\n\t\tadd_next_index_stringl(return_value, \"BZIP2\", 5, 1);\n\t}\n}\n/* }}} */\n\n/* {{{ proto array Phar::unlinkArchive(string archive)\n * Completely remove a phar archive from memory and disk\n */\nPHP_METHOD(Phar, unlinkArchive)\n{\n\tchar *fname, *error, *zname, *arch, *entry;\n\tint fname_len, zname_len, arch_len, entry_len;\n\tphar_archive_data *phar;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &fname, &fname_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!fname_len) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Unknown phar archive \\\"\\\"\");\n\t\treturn;\n\t}\n\n\tif (FAILURE == phar_open_from_filename(fname, fname_len, NULL, 0, REPORT_ERRORS, &phar, &error TSRMLS_CC)) {\n\t\tif (error) {\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Unknown phar archive \\\"%s\\\": %s\", fname, error);\n\t\t\tefree(error);\n\t\t} else {\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Unknown phar archive \\\"%s\\\"\", fname);\n\t\t}\n\t\treturn;\n\t}\n\n\tzname = (char*)zend_get_executed_filename(TSRMLS_C);\n\tzname_len = strlen(zname);\n\n\tif (zname_len > 7 && !memcmp(zname, \"phar://\", 7) && SUCCESS == phar_split_fname(zname, zname_len, &arch, &arch_len, &entry, &entry_len, 2, 0 TSRMLS_CC)) {\n\t\tif (arch_len == fname_len && !memcmp(arch, fname, arch_len)) {\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar archive \\\"%s\\\" cannot be unlinked from within itself\", fname);\n\t\t\tefree(arch);\n\t\t\tefree(entry);\n\t\t\treturn;\n\t\t}\n\t\tefree(arch);\n\t\tefree(entry);\n\t}\n\n\tif (phar->is_persistent) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar archive \\\"%s\\\" is in phar.cache_list, cannot unlinkArchive()\", fname);\n\t\treturn;\n\t}\n\n\tif (phar->refcount) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar archive \\\"%s\\\" has open file handles or objects.  fclose() all file handles, and unset() all objects prior to calling unlinkArchive()\", fname);\n\t\treturn;\n\t}\n\n\tfname = estrndup(phar->fname, phar->fname_len);\n\n\t/* invalidate phar cache */\n\tPHAR_G(last_phar) = NULL;\n\tPHAR_G(last_phar_name) = PHAR_G(last_alias) = NULL;\n\n\tphar_archive_delref(phar TSRMLS_CC);\n\tunlink(fname);\n\tefree(fname);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n#if HAVE_SPL\n\n#define PHAR_ARCHIVE_OBJECT() \\\n\tphar_archive_object *phar_obj = (phar_archive_object*)zend_object_store_get_object(getThis() TSRMLS_CC); \\\n\tif (!phar_obj->arc.archive) { \\\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \\\n\t\t\t\"Cannot call method on an uninitialized Phar object\"); \\\n\t\treturn; \\\n\t}\n\n/* {{{ proto void Phar::__destruct()\n * if persistent, remove from the cache\n */\nPHP_METHOD(Phar, __destruct)\n{\n\tphar_archive_object *phar_obj = (phar_archive_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (phar_obj->arc.archive && phar_obj->arc.archive->is_persistent) {\n\t\tzend_hash_del(&PHAR_GLOBALS->phar_persist_map, (const char *) phar_obj->arc.archive, sizeof(phar_obj->arc.archive));\n\t}\n}\n/* }}} */\n\nstruct _phar_t {\n\tphar_archive_object *p;\n\tzend_class_entry *c;\n\tchar *b;\n\tuint l;\n\tzval *ret;\n\tint count;\n\tphp_stream *fp;\n};\n\nstatic int phar_build(zend_object_iterator *iter, void *puser TSRMLS_DC) /* {{{ */\n{\n\tzval **value;\n\tzend_uchar key_type;\n\tzend_bool close_fp = 1;\n\tulong int_key;\n\tstruct _phar_t *p_obj = (struct _phar_t*) puser;\n\tuint str_key_len, base_len = p_obj->l, fname_len;\n\tphar_entry_data *data;\n\tphp_stream *fp;\n\tsize_t contents_len;\n\tchar *fname, *error = NULL, *base = p_obj->b, *opened, *save = NULL, *temp = NULL;\n\tphar_zstr key;\n\tchar *str_key;\n\tzend_class_entry *ce = p_obj->c;\n\tphar_archive_object *phar_obj = p_obj->p;\n\tchar *str = \"[stream]\";\n\n\titer->funcs->get_current_data(iter, &value TSRMLS_CC);\n\n\tif (EG(exception)) {\n\t\treturn ZEND_HASH_APPLY_STOP;\n\t}\n\n\tif (!value) {\n\t\t/* failure in get_current_data */\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned no value\", ce->name);\n\t\treturn ZEND_HASH_APPLY_STOP;\n\t}\n\n\tswitch (Z_TYPE_PP(value)) {\n#if PHP_VERSION_ID >= 60000\n\t\tcase IS_UNICODE:\n\t\t\tzval_unicode_to_string(*(value) TSRMLS_CC);\n\t\t\t/* break intentionally omitted */\n#endif\n\t\tcase IS_STRING:\n\t\t\tbreak;\n\t\tcase IS_RESOURCE:\n\t\t\tphp_stream_from_zval_no_verify(fp, value);\n\n\t\t\tif (!fp) {\n\t\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Iterator %v returned an invalid stream handle\", ce->name);\n\t\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t\t}\n\n\t\t\tif (iter->funcs->get_current_key) {\n\t\t\t\tkey_type = iter->funcs->get_current_key(iter, &key, &str_key_len, &int_key TSRMLS_CC);\n\n\t\t\t\tif (EG(exception)) {\n\t\t\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t\t\t}\n\n\t\t\t\tif (key_type == HASH_KEY_IS_LONG) {\n\t\t\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned an invalid key (must return a string)\", ce->name);\n\t\t\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t\t\t}\n\n\t\t\t\tif (key_type > 9) { /* IS_UNICODE == 10 */\n#if PHP_VERSION_ID < 60000\n/* this can never happen, but fixes a compile warning */\n\t\t\t\t\tspprintf(&str_key, 0, \"%s\", key);\n#else\n\t\t\t\t\tspprintf(&str_key, 0, \"%v\", key);\n\t\t\t\t\tezfree(key);\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tPHAR_STR(key, str_key);\n\t\t\t\t}\n\n\t\t\t\tsave = str_key;\n\n\t\t\t\tif (str_key[str_key_len - 1] == '\\0') {\n\t\t\t\t\tstr_key_len--;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned an invalid key (must return a string)\", ce->name);\n\t\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t\t}\n\n\t\t\tclose_fp = 0;\n\t\t\topened = (char *) estrndup(str, sizeof(\"[stream]\") - 1);\n\t\t\tgoto after_open_fp;\n\t\tcase IS_OBJECT:\n\t\t\tif (instanceof_function(Z_OBJCE_PP(value), spl_ce_SplFileInfo TSRMLS_CC)) {\n\t\t\t\tchar *test = NULL;\n\t\t\t\tzval dummy;\n\t\t\t\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(*value TSRMLS_CC);\n\n\t\t\t\tif (!base_len) {\n\t\t\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Iterator %v returns an SplFileInfo object, so base directory must be specified\", ce->name);\n\t\t\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t\t\t}\n\n\t\t\t\tswitch (intern->type) {\n\t\t\t\t\tcase SPL_FS_DIR:\n#if PHP_VERSION_ID >= 60000\n\t\t\t\t\t\ttest = spl_filesystem_object_get_path(intern, NULL, NULL TSRMLS_CC).s;\n#elif PHP_VERSION_ID >= 50300\n\t\t\t\t\t\ttest = spl_filesystem_object_get_path(intern, NULL TSRMLS_CC);\n#else\n\t\t\t\t\t\ttest = intern->path;\n#endif\n\t\t\t\t\t\tfname_len = spprintf(&fname, 0, \"%s%c%s\", test, DEFAULT_SLASH, intern->u.dir.entry.d_name);\n\t\t\t\t\t\tphp_stat(fname, fname_len, FS_IS_DIR, &dummy TSRMLS_CC);\n\n\t\t\t\t\t\tif (Z_BVAL(dummy)) {\n\t\t\t\t\t\t\t/* ignore directories */\n\t\t\t\t\t\t\tefree(fname);\n\t\t\t\t\t\t\treturn ZEND_HASH_APPLY_KEEP;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttest = expand_filepath(fname, NULL TSRMLS_CC);\n\t\t\t\t\t\tefree(fname);\n\n\t\t\t\t\t\tif (test) {\n\t\t\t\t\t\t\tfname = test;\n\t\t\t\t\t\t\tfname_len = strlen(fname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Could not resolve file path\");\n\t\t\t\t\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsave = fname;\n\t\t\t\t\t\tgoto phar_spl_fileinfo;\n\t\t\t\t\tcase SPL_FS_INFO:\n\t\t\t\t\tcase SPL_FS_FILE:\n#if PHP_VERSION_ID >= 60000\n\t\t\t\t\t\tif (intern->file_name_type == IS_UNICODE) {\n\t\t\t\t\t\t\tzval zv;\n\n\t\t\t\t\t\t\tINIT_ZVAL(zv);\n\t\t\t\t\t\t\tZ_UNIVAL(zv) = intern->file_name;\n\t\t\t\t\t\t\tZ_UNILEN(zv) = intern->file_name_len;\n\t\t\t\t\t\t\tZ_TYPE(zv) = IS_UNICODE;\n\n\t\t\t\t\t\t\tzval_copy_ctor(&zv);\n\t\t\t\t\t\t\tzval_unicode_to_string(&zv TSRMLS_CC);\n\t\t\t\t\t\t\tfname = expand_filepath(Z_STRVAL(zv), NULL TSRMLS_CC);\n\t\t\t\t\t\t\tezfree(Z_UNIVAL(zv));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfname = expand_filepath(intern->file_name.s, NULL TSRMLS_CC);\n\t\t\t\t\t\t}\n#else\n\t\t\t\t\t\tfname = expand_filepath(intern->file_name, NULL TSRMLS_CC);\n#endif\n\t\t\t\t\t\tif (!fname) {\n\t\t\t\t\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Could not resolve file path\");\n\t\t\t\t\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfname_len = strlen(fname);\n\t\t\t\t\t\tsave = fname;\n\t\t\t\t\t\tgoto phar_spl_fileinfo;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* fall-through */\n\t\tdefault:\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned an invalid value (must return a string)\", ce->name);\n\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t}\n\n\tfname = Z_STRVAL_PP(value);\n\tfname_len = Z_STRLEN_PP(value);\n\nphar_spl_fileinfo:\n\tif (base_len) {\n\t\ttemp = expand_filepath(base, NULL TSRMLS_CC);\n\t\tif (!temp) {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Could not resolve file path\");\n\t\t\tif (save) {\n\t\t\t\tefree(save);\n                        }\n                        return ZEND_HASH_APPLY_STOP;\n                }\n\n                base = temp;\n                base_len = strlen(base);\n \n\t\tif (strstr(fname, base)) {\n\t\t\tstr_key_len = fname_len - base_len;\n\n\t\t\tif (str_key_len <= 0) {\n\t\t\t\tif (save) {\n\t\t\t\t\tefree(save);\n\t\t\t\t\tefree(temp);\n\t\t\t\t}\n\t\t\t\treturn ZEND_HASH_APPLY_KEEP;\n\t\t\t}\n\n\t\t\tstr_key = fname + base_len;\n\n\t\t\tif (*str_key == '/' || *str_key == '\\\\') {\n\t\t\t\tstr_key++;\n\t\t\t\tstr_key_len--;\n\t\t\t}\n\n\t\t} else {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned a path \\\"%s\\\" that is not in the base directory \\\"%s\\\"\", ce->name, fname, base);\n\n\t\t\tif (save) {\n\t\t\t\tefree(save);\n\t\t\t\tefree(temp);\n\t\t\t}\n\n\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t}\n\t} else {\n\t\tif (iter->funcs->get_current_key) {\n\t\t\tkey_type = iter->funcs->get_current_key(iter, &key, &str_key_len, &int_key TSRMLS_CC);\n\n\t\t\tif (EG(exception)) {\n\t\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t\t}\n\n\t\t\tif (key_type == HASH_KEY_IS_LONG) {\n\t\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned an invalid key (must return a string)\", ce->name);\n\t\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t\t}\n\n\t\t\tif (key_type > 9) { /* IS_UNICODE == 10 */\n#if PHP_VERSION_ID < 60000\n/* this can never happen, but fixes a compile warning */\n\t\t\t\tspprintf(&str_key, 0, \"%s\", key);\n#else\n\t\t\t\tspprintf(&str_key, 0, \"%v\", key);\n\t\t\t\tezfree(key);\n#endif\n\t\t\t} else {\n\t\t\t\tPHAR_STR(key, str_key);\n\t\t\t}\n\n\t\t\tsave = str_key;\n\n\t\t\tif (str_key[str_key_len - 1] == '\\0') str_key_len--;\n\t\t} else {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned an invalid key (must return a string)\", ce->name);\n\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t}\n\t}\n#if PHP_API_VERSION < 20100412\n\tif (PG(safe_mode) && (!php_checkuid(fname, NULL, CHECKUID_ALLOW_ONLY_FILE))) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned a path \\\"%s\\\" that safe mode prevents opening\", ce->name, fname);\n\n\t\tif (save) {\n\t\t\tefree(save);\n\t\t}\n\n\t\tif (temp) {\n\t\t\tefree(temp);\n\t\t}\n\n\t\treturn ZEND_HASH_APPLY_STOP;\n\t}\n#endif\n\n\tif (php_check_open_basedir(fname TSRMLS_CC)) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned a path \\\"%s\\\" that open_basedir prevents opening\", ce->name, fname);\n\n\t\tif (save) {\n\t\t\tefree(save);\n\t\t}\n\n\t\tif (temp) {\n\t\t\tefree(temp);\n\t\t}\n\n\t\treturn ZEND_HASH_APPLY_STOP;\n\t}\n\n\t/* try to open source file, then create internal phar file and copy contents */\n\tfp = php_stream_open_wrapper(fname, \"rb\", STREAM_MUST_SEEK|0, &opened);\n\n\tif (!fp) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned a file that could not be opened \\\"%s\\\"\", ce->name, fname);\n\n\t\tif (save) {\n\t\t\tefree(save);\n\t\t}\n\n\t\tif (temp) {\n\t\t\tefree(temp);\n\t\t}\n\n\t\treturn ZEND_HASH_APPLY_STOP;\n\t}\nafter_open_fp:\n\tif (str_key_len >= sizeof(\".phar\")-1 && !memcmp(str_key, \".phar\", sizeof(\".phar\")-1)) {\n\t\t/* silently skip any files that would be added to the magic .phar directory */\n\t\tif (save) {\n\t\t\tefree(save);\n\t\t}\n\n\t\tif (temp) {\n\t\t\tefree(temp);\n\t\t}\n\n\t\tif (opened) {\n\t\t\tefree(opened);\n\t\t}\n\n\t\tif (close_fp) {\n\t\t\tphp_stream_close(fp);\n\t\t}\n\n\t\treturn ZEND_HASH_APPLY_KEEP;\n\t}\n\n\tif (!(data = phar_get_or_create_entry_data(phar_obj->arc.archive->fname, phar_obj->arc.archive->fname_len, str_key, str_key_len, \"w+b\", 0, &error, 1 TSRMLS_CC))) {\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Entry %s cannot be created: %s\", str_key, error);\n\t\tefree(error);\n\n\t\tif (save) {\n\t\t\tefree(save);\n\t\t}\n\n\t\tif (opened) {\n\t\t\tefree(opened);\n\t\t}\n\n\t\tif (temp) {\n\t\t\tefree(temp);\n\t\t}\n\n\t\tif (close_fp) {\n\t\t\tphp_stream_close(fp);\n\t\t}\n\n\t\treturn ZEND_HASH_APPLY_STOP;\n\n\t} else {\n\t\tif (error) {\n\t\t\tefree(error);\n\t\t}\n\t\t/* convert to PHAR_UFP */\n\t\tif (data->internal_file->fp_type == PHAR_MOD) {\n\t\t\tphp_stream_close(data->internal_file->fp);\n\t\t}\n\n\t\tdata->internal_file->fp = NULL;\n\t\tdata->internal_file->fp_type = PHAR_UFP;\n\t\tdata->internal_file->offset_abs = data->internal_file->offset = php_stream_tell(p_obj->fp);\n\t\tdata->fp = NULL;\n\t\tphar_stream_copy_to_stream(fp, p_obj->fp, PHP_STREAM_COPY_ALL, &contents_len);\n\t\tdata->internal_file->uncompressed_filesize = data->internal_file->compressed_filesize =\n\t\t\tphp_stream_tell(p_obj->fp) - data->internal_file->offset;\n\t}\n\n\tif (close_fp) {\n\t\tphp_stream_close(fp);\n\t}\n\n\tadd_assoc_string(p_obj->ret, str_key, opened, 0);\n\n\tif (save) {\n\t\tefree(save);\n\t}\n\n\tif (temp) {\n\t\tefree(temp);\n\t}\n\n\tdata->internal_file->compressed_filesize = data->internal_file->uncompressed_filesize = contents_len;\n\tphar_entry_delref(data TSRMLS_CC);\n\n\treturn ZEND_HASH_APPLY_KEEP;\n}\n/* }}} */\n\n /* {{{ proto array Phar::buildFromDirectory(string base_dir[, string regex])\n  * Construct a phar archive from an existing directory, recursively.\n  * Optional second parameter is a regular expression for filtering directory contents.\n *\n  * Return value is an array mapping phar index to actual files added.\n  */\n PHP_METHOD(Phar, buildFromDirectory)\n{\n\tchar *dir, *error, *regex = NULL;\n\tint dir_len, regex_len = 0;\n\tzend_bool apply_reg = 0;\n\tzval arg, arg2, *iter, *iteriter, *regexiter = NULL;\n\tstruct _phar_t pass;\n\n\tPHAR_ARCHIVE_OBJECT();\n\n\tif (PHAR_G(readonly) && !phar_obj->arc.archive->is_data) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\"Cannot write to archive - write operations restricted by INI setting\");\n\t\treturn;\n\t}\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|s\", &dir, &dir_len, &regex, &regex_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tMAKE_STD_ZVAL(iter);\n\n\tif (SUCCESS != object_init_ex(iter, spl_ce_RecursiveDirectoryIterator)) {\n\t\tzval_ptr_dtor(&iter);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to instantiate directory iterator for %s\", phar_obj->arc.archive->fname);\n\t\tRETURN_FALSE;\n\t}\n\n\tINIT_PZVAL(&arg);\n\tZVAL_STRINGL(&arg, dir, dir_len, 0);\n\tINIT_PZVAL(&arg2);\n#if PHP_VERSION_ID < 50300\n\tZVAL_LONG(&arg2, 0);\n#else\n        ZVAL_LONG(&arg2, SPL_FILE_DIR_SKIPDOTS|SPL_FILE_DIR_UNIXPATHS);\n #endif\n \n       zend_call_method_with_2_params(&iter, spl_ce_RecursiveDirectoryIterator,\n                        &spl_ce_RecursiveDirectoryIterator->constructor, \"__construct\", NULL, &arg, &arg2);\n \n        if (EG(exception)) {\n\t\tzval_ptr_dtor(&iter);\n\t\tRETURN_FALSE;\n\t}\n\n\tMAKE_STD_ZVAL(iteriter);\n\n\tif (SUCCESS != object_init_ex(iteriter, spl_ce_RecursiveIteratorIterator)) {\n\t\tzval_ptr_dtor(&iter);\n\t\tzval_ptr_dtor(&iteriter);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to instantiate directory iterator for %s\", phar_obj->arc.archive->fname);\n                RETURN_FALSE;\n        }\n \n       zend_call_method_with_1_params(&iteriter, spl_ce_RecursiveIteratorIterator,\n                        &spl_ce_RecursiveIteratorIterator->constructor, \"__construct\", NULL, iter);\n \n        if (EG(exception)) {\n\t\tzval_ptr_dtor(&iter);\n\t\tzval_ptr_dtor(&iteriter);\n\t\tRETURN_FALSE;\n\t}\n\n\tzval_ptr_dtor(&iter);\n\n\tif (regex_len > 0) {\n\t\tapply_reg = 1;\n\t\tMAKE_STD_ZVAL(regexiter);\n\n\t\tif (SUCCESS != object_init_ex(regexiter, spl_ce_RegexIterator)) {\n\t\t\tzval_ptr_dtor(&iteriter);\n\t\t\tzval_dtor(regexiter);\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to instantiate regex iterator for %s\", phar_obj->arc.archive->fname);\n\t\t\tRETURN_FALSE;\n\t\t}\n\n                INIT_PZVAL(&arg2);\n                ZVAL_STRINGL(&arg2, regex, regex_len, 0);\n \n               zend_call_method_with_2_params(&regexiter, spl_ce_RegexIterator,\n                        &spl_ce_RegexIterator->constructor, \"__construct\", NULL, iteriter, &arg2);\n        }\n \n\tarray_init(return_value);\n\n\tpass.c = apply_reg ? Z_OBJCE_P(regexiter) : Z_OBJCE_P(iteriter);\n\tpass.p = phar_obj;\n\tpass.b = dir;\n\tpass.l = dir_len;\n\tpass.count = 0;\n\tpass.ret = return_value;\n\tpass.fp = php_stream_fopen_tmpfile();\n\tif (pass.fp == NULL) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar \\\"%s\\\" unable to create temporary file\", phar_obj->arc.archive->fname);\n\t\treturn;\n\t}\n\n\tif (phar_obj->arc.archive->is_persistent && FAILURE == phar_copy_on_write(&(phar_obj->arc.archive) TSRMLS_CC)) {\n\t\tzval_ptr_dtor(&iteriter);\n\t\tif (apply_reg) {\n\t\t\tzval_ptr_dtor(&regexiter);\n\t\t}\n\t\tphp_stream_close(pass.fp);\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar \\\"%s\\\" is persistent, unable to copy on write\", phar_obj->arc.archive->fname);\n\t\treturn;\n\t}\n\n\tif (SUCCESS == spl_iterator_apply((apply_reg ? regexiter : iteriter), (spl_iterator_apply_func_t) phar_build, (void *) &pass TSRMLS_CC)) {\n\t\tzval_ptr_dtor(&iteriter);\n\n\t\tif (apply_reg) {\n\t\t\tzval_ptr_dtor(&regexiter);\n\t\t}\n\n\t\tphar_obj->arc.archive->ufp = pass.fp;\n\t\tphar_flush(phar_obj->arc.archive, 0, 0, 0, &error TSRMLS_CC);\n\n\t\tif (error) {\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);\n\t\t\tefree(error);\n\t\t}\n\n\t} else {\n\t\tzval_ptr_dtor(&iteriter);\n\t\tif (apply_reg) {\n\t\t\tzval_ptr_dtor(&regexiter);\n\t\t}\n\t\tphp_stream_close(pass.fp);\n\t}\n}\n/* }}} */\n\n/* {{{ proto array Phar::buildFromIterator(Iterator iter[, string base_directory])\n * Construct a phar archive from an iterator.  The iterator must return a series of strings\n * that are full paths to files that should be added to the phar.  The iterator key should\n * be the path that the file will have within the phar archive.\n *\n * If base directory is specified, then the key will be ignored, and instead the portion of\n * the current value minus the base directory will be used\n *\n * Returned is an array mapping phar index to actual file added\n */\nPHP_METHOD(Phar, buildFromIterator)\n{\n\tzval *obj;\n\tchar *error;\n\tuint base_len = 0;\n\tchar *base = NULL;\n\tstruct _phar_t pass;\n\n\tPHAR_ARCHIVE_OBJECT();\n\n\tif (PHAR_G(readonly) && !phar_obj->arc.archive->is_data) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\"Cannot write out phar archive, phar is read-only\");\n\t\treturn;\n\t}\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"O|s\", &obj, zend_ce_traversable, &base, &base_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (phar_obj->arc.archive->is_persistent && FAILURE == phar_copy_on_write(&(phar_obj->arc.archive) TSRMLS_CC)) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar \\\"%s\\\" is persistent, unable to copy on write\", phar_obj->arc.archive->fname);\n\t\treturn;\n\t}\n\n\tarray_init(return_value);\n\n\tpass.c = Z_OBJCE_P(obj);\n\tpass.p = phar_obj;\n\tpass.b = base;\n\tpass.l = base_len;\n\tpass.ret = return_value;\n\tpass.count = 0;\n\tpass.fp = php_stream_fopen_tmpfile();\n\tif (pass.fp == NULL) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar \\\"%s\\\": unable to create temporary file\", phar_obj->arc.archive->fname);\n\t\treturn;\n\t}\n\n\tif (SUCCESS == spl_iterator_apply(obj, (spl_iterator_apply_func_t) phar_build, (void *) &pass TSRMLS_CC)) {\n\t\tphar_obj->arc.archive->ufp = pass.fp;\n\t\tphar_flush(phar_obj->arc.archive, 0, 0, 0, &error TSRMLS_CC);\n\t\tif (error) {\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);\n\t\t\tefree(error);\n\t\t}\n\t} else {\n\t\tphp_stream_close(pass.fp);\n\t}\n}\n/* }}} */\n\n/* {{{ proto int Phar::count()\n * Returns the number of entries in the Phar archive\n */\n PHP_METHOD(Phar, count)\n {\n        PHAR_ARCHIVE_OBJECT();\n\n        if (zend_parse_parameters_none() == FAILURE) {\n                return;\n        }\n\n\tRETURN_LONG(zend_hash_num_elements(&phar_obj->arc.archive->manifest));\n}\n/* }}} */\n\n/* {{{ proto bool Phar::isFileFormat(int format)\n * Returns true if the phar archive is based on the tar/zip/phar file format depending\n * on whether Phar::TAR, Phar::ZIP or Phar::PHAR was passed in\n */\nPHP_METHOD(Phar, isFileFormat)\n{\n\tlong type;\n\tPHAR_ARCHIVE_OBJECT();\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &type) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tswitch (type) {\n\t\tcase PHAR_FORMAT_TAR:\n\t\t\tRETURN_BOOL(phar_obj->arc.archive->is_tar);\n\t\tcase PHAR_FORMAT_ZIP:\n\t\t\tRETURN_BOOL(phar_obj->arc.archive->is_zip);\n\t\tcase PHAR_FORMAT_PHAR:\n\t\t\tRETURN_BOOL(!phar_obj->arc.archive->is_tar && !phar_obj->arc.archive->is_zip);\n\t\tdefault:\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Unknown file format specified\");\n\t}\n}\n/* }}} */\n\nstatic int phar_copy_file_contents(phar_entry_info *entry, php_stream *fp TSRMLS_DC) /* {{{ */\n{\n\tchar *error;\n\toff_t offset;\n\tphar_entry_info *link;\n\n\tif (FAILURE == phar_open_entry_fp(entry, &error, 1 TSRMLS_CC)) {\n\t\tif (error) {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\t\"Cannot convert phar archive \\\"%s\\\", unable to open entry \\\"%s\\\" contents: %s\", entry->phar->fname, entry->filename, error);\n\t\t\tefree(error);\n\t\t} else {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\t\"Cannot convert phar archive \\\"%s\\\", unable to open entry \\\"%s\\\" contents\", entry->phar->fname, entry->filename);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\t/* copy old contents in entirety */\n\tphar_seek_efp(entry, 0, SEEK_SET, 0, 1 TSRMLS_CC);\n\toffset = php_stream_tell(fp);\n\tlink = phar_get_link_source(entry TSRMLS_CC);\n\n\tif (!link) {\n\t\tlink = entry;\n\t}\n\n\tif (SUCCESS != phar_stream_copy_to_stream(phar_get_efp(link, 0 TSRMLS_CC), fp, link->uncompressed_filesize, NULL)) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\"Cannot convert phar archive \\\"%s\\\", unable to copy entry \\\"%s\\\" contents\", entry->phar->fname, entry->filename);\n\t\treturn FAILURE;\n\t}\n\n\tif (entry->fp_type == PHAR_MOD) {\n\t\t/* save for potential restore on error */\n\t\tentry->cfp = entry->fp;\n\t\tentry->fp = NULL;\n\t}\n\n\t/* set new location of file contents */\n\tentry->fp_type = PHAR_FP;\n\tentry->offset = offset;\n\treturn SUCCESS;\n}\n/* }}} */\n\nstatic zval *phar_rename_archive(phar_archive_data *phar, char *ext, zend_bool compress TSRMLS_DC) /* {{{ */\n{\n\tconst char *oldname = NULL;\n\tchar *oldpath = NULL;\n\tchar *basename = NULL, *basepath = NULL;\n\tchar *newname = NULL, *newpath = NULL;\n\tzval *ret, arg1;\n\tzend_class_entry *ce;\n\tchar *error;\n\tconst char *pcr_error;\n\tint ext_len = ext ? strlen(ext) : 0;\n\tint oldname_len;\n\tphar_archive_data **pphar = NULL;\n\tphp_stream_statbuf ssb;\n\n\tif (!ext) {\n\t\tif (phar->is_zip) {\n\n\t\t\tif (phar->is_data) {\n\t\t\t\text = \"zip\";\n\t\t\t} else {\n\t\t\t\text = \"phar.zip\";\n\t\t\t}\n\n\t\t} else if (phar->is_tar) {\n\n\t\t\tswitch (phar->flags) {\n\t\t\t\tcase PHAR_FILE_COMPRESSED_GZ:\n\t\t\t\t\tif (phar->is_data) {\n\t\t\t\t\t\text = \"tar.gz\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\text = \"phar.tar.gz\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase PHAR_FILE_COMPRESSED_BZ2:\n\t\t\t\t\tif (phar->is_data) {\n\t\t\t\t\t\text = \"tar.bz2\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\text = \"phar.tar.bz2\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (phar->is_data) {\n\t\t\t\t\t\text = \"tar\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\text = \"phar.tar\";\n\t\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\n\t\t\tswitch (phar->flags) {\n\t\t\t\tcase PHAR_FILE_COMPRESSED_GZ:\n\t\t\t\t\text = \"phar.gz\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase PHAR_FILE_COMPRESSED_BZ2:\n\t\t\t\t\text = \"phar.bz2\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\text = \"phar\";\n\t\t\t}\n\t\t}\n\t} else if (phar_path_check(&ext, &ext_len, &pcr_error) > pcr_is_ok) {\n\n\t\tif (phar->is_data) {\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"data phar converted from \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n\t\t} else {\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"phar converted from \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (ext[0] == '.') {\n\t\t++ext;\n\t}\n\n\toldpath = estrndup(phar->fname, phar->fname_len);\n\toldname = zend_memrchr(phar->fname, '/', phar->fname_len);\n\t++oldname;\n\toldname_len = strlen(oldname);\n\n\tbasename = estrndup(oldname, oldname_len);\n        spprintf(&newname, 0, \"%s.%s\", strtok(basename, \".\"), ext);\n        efree(basename);\n \n\n \n        basepath = estrndup(oldpath, (strlen(oldpath) - oldname_len));\n        phar->fname_len = spprintf(&newpath, 0, \"%s%s\", basepath, newname);\n\tphar->fname = newpath;\n\tphar->ext = newpath + phar->fname_len - strlen(ext) - 1;\n\tefree(basepath);\n\tefree(newname);\n\n\tif (PHAR_G(manifest_cached) && SUCCESS == zend_hash_find(&cached_phars, newpath, phar->fname_len, (void **) &pphar)) {\n\t\tefree(oldpath);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to add newly converted phar \\\"%s\\\" to the list of phars, new phar name is in phar.cache_list\", phar->fname);\n\t\treturn NULL;\n\t}\n\n\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_fname_map), newpath, phar->fname_len, (void **) &pphar)) {\n\t\tif ((*pphar)->fname_len == phar->fname_len && !memcmp((*pphar)->fname, phar->fname, phar->fname_len)) {\n\t\t\tif (!zend_hash_num_elements(&phar->manifest)) {\n\t\t\t\t(*pphar)->is_tar = phar->is_tar;\n\t\t\t\t(*pphar)->is_zip = phar->is_zip;\n\t\t\t\t(*pphar)->is_data = phar->is_data;\n\t\t\t\t(*pphar)->flags = phar->flags;\n\t\t\t\t(*pphar)->fp = phar->fp;\n\t\t\t\tphar->fp = NULL;\n\t\t\t\tphar_destroy_phar_data(phar TSRMLS_CC);\n\t\t\t\tphar = *pphar;\n\t\t\t\tphar->refcount++;\n\t\t\t\tnewpath = oldpath;\n\t\t\t\tgoto its_ok;\n\t\t\t}\n\t\t}\n\n\t\tefree(oldpath);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to add newly converted phar \\\"%s\\\" to the list of phars, a phar with that name already exists\", phar->fname);\n\t\treturn NULL;\n\t}\nits_ok:\n\tif (SUCCESS == php_stream_stat_path(newpath, &ssb)) {\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"phar \\\"%s\\\" exists and must be unlinked prior to conversion\", newpath);\n\t\tefree(oldpath);\n\t\treturn NULL;\n\t}\n\tif (!phar->is_data) {\n\t\tif (SUCCESS != phar_detect_phar_fname_ext(newpath, phar->fname_len, (const char **) &(phar->ext), &(phar->ext_len), 1, 1, 1 TSRMLS_CC)) {\n\t\t\tefree(oldpath);\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"phar \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (phar->alias) {\n\t\t\tif (phar->is_temporary_alias) {\n\t\t\t\tphar->alias = NULL;\n\t\t\t\tphar->alias_len = 0;\n\t\t\t} else {\n\t\t\t\tphar->alias = estrndup(newpath, strlen(newpath));\n\t\t\t\tphar->alias_len = strlen(newpath);\n\t\t\t\tphar->is_temporary_alias = 1;\n\t\t\t\tzend_hash_update(&(PHAR_GLOBALS->phar_alias_map), newpath, phar->fname_len, (void*)&phar, sizeof(phar_archive_data*), NULL);\n\t\t\t}\n\t\t}\n\n\t} else {\n\n\t\tif (SUCCESS != phar_detect_phar_fname_ext(newpath, phar->fname_len, (const char **) &(phar->ext), &(phar->ext_len), 0, 1, 1 TSRMLS_CC)) {\n\t\t\tefree(oldpath);\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"data phar \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tphar->alias = NULL;\n\t\tphar->alias_len = 0;\n\t}\n\n\tif ((!pphar || phar == *pphar) && SUCCESS != zend_hash_update(&(PHAR_GLOBALS->phar_fname_map), newpath, phar->fname_len, (void*)&phar, sizeof(phar_archive_data*), NULL)) {\n\t\tefree(oldpath);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to add newly converted phar \\\"%s\\\" to the list of phars\", phar->fname);\n\t\treturn NULL;\n\t}\n\n\tphar_flush(phar, 0, 0, 1, &error TSRMLS_CC);\n\n\tif (error) {\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"%s\", error);\n\t\tefree(error);\n\t\tefree(oldpath);\n\t\treturn NULL;\n\t}\n\n\tefree(oldpath);\n\n\tif (phar->is_data) {\n\t\tce = phar_ce_data;\n\t} else {\n\t\tce = phar_ce_archive;\n\t}\n\n\tMAKE_STD_ZVAL(ret);\n\n\tif (SUCCESS != object_init_ex(ret, ce)) {\n\t\tzval_dtor(ret);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to instantiate phar object when converting archive \\\"%s\\\"\", phar->fname);\n\t\treturn NULL;\n\t}\n\n\tINIT_PZVAL(&arg1);\n\tZVAL_STRINGL(&arg1, phar->fname, phar->fname_len, 0);\n\n\tzend_call_method_with_1_params(&ret, ce, &ce->constructor, \"__construct\", NULL, &arg1);\n\treturn ret;\n}\n/* }}} */\n\nstatic zval *phar_convert_to_other(phar_archive_data *source, int convert, char *ext, php_uint32 flags TSRMLS_DC) /* {{{ */\n{\n\tphar_archive_data *phar;\n\tphar_entry_info *entry, newentry;\n\tzval *ret;\n\n\t/* invalidate phar cache */\n\tPHAR_G(last_phar) = NULL;\n\tPHAR_G(last_phar_name) = PHAR_G(last_alias) = NULL;\n\n\tphar = (phar_archive_data *) ecalloc(1, sizeof(phar_archive_data));\n\t/* set whole-archive compression and type from parameter */\n\tphar->flags = flags;\n\tphar->is_data = source->is_data;\n\n\tswitch (convert) {\n\t\tcase PHAR_FORMAT_TAR:\n\t\t\tphar->is_tar = 1;\n\t\t\tbreak;\n\t\tcase PHAR_FORMAT_ZIP:\n\t\t\tphar->is_zip = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphar->is_data = 0;\n\t\t\tbreak;\n\t}\n\n\tzend_hash_init(&(phar->manifest), sizeof(phar_entry_info),\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, 0);\n\tzend_hash_init(&phar->mounted_dirs, sizeof(char *),\n\t\tzend_get_hash_value, NULL, 0);\n\tzend_hash_init(&phar->virtual_dirs, sizeof(char *),\n\t\tzend_get_hash_value, NULL, 0);\n\n\tphar->fp = php_stream_fopen_tmpfile();\n\tif (phar->fp == NULL) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"unable to create temporary file\");\n\t\treturn NULL;\n\t}\n\tphar->fname = source->fname;\n\tphar->fname_len = source->fname_len;\n\tphar->is_temporary_alias = source->is_temporary_alias;\n\tphar->alias = source->alias;\n\n\tif (source->metadata) {\n\t\tzval *t;\n\n\t\tt = source->metadata;\n\t\tALLOC_ZVAL(phar->metadata);\n\t\t*phar->metadata = *t;\n\t\tzval_copy_ctor(phar->metadata);\n#if PHP_VERSION_ID < 50300\n\t\tphar->metadata->refcount = 1;\n#else\n\t\tZ_SET_REFCOUNT_P(phar->metadata, 1);\n#endif\n\n\t\tphar->metadata_len = 0;\n\t}\n\n\t/* first copy each file's uncompressed contents to a temporary file and set per-file flags */\n\tfor (zend_hash_internal_pointer_reset(&source->manifest); SUCCESS == zend_hash_has_more_elements(&source->manifest); zend_hash_move_forward(&source->manifest)) {\n\n\t\tif (FAILURE == zend_hash_get_current_data(&source->manifest, (void **) &entry)) {\n\t\t\tzend_hash_destroy(&(phar->manifest));\n\t\t\tphp_stream_close(phar->fp);\n\t\t\tefree(phar);\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\t\"Cannot convert phar archive \\\"%s\\\"\", source->fname);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tnewentry = *entry;\n\n\t\tif (newentry.link) {\n\t\t\tnewentry.link = estrdup(newentry.link);\n\t\t\tgoto no_copy;\n\t\t}\n\n\t\tif (newentry.tmp) {\n\t\t\tnewentry.tmp = estrdup(newentry.tmp);\n\t\t\tgoto no_copy;\n\t\t}\n\n\t\tnewentry.metadata_str.c = 0;\n\n\t\tif (FAILURE == phar_copy_file_contents(&newentry, phar->fp TSRMLS_CC)) {\n\t\t\tzend_hash_destroy(&(phar->manifest));\n\t\t\tphp_stream_close(phar->fp);\n\t\t\tefree(phar);\n\t\t\t/* exception already thrown */\n\t\t\treturn NULL;\n\t\t}\nno_copy:\n\t\tnewentry.filename = estrndup(newentry.filename, newentry.filename_len);\n\n\t\tif (newentry.metadata) {\n\t\t\tzval *t;\n\n\t\t\tt = newentry.metadata;\n\t\t\tALLOC_ZVAL(newentry.metadata);\n\t\t\t*newentry.metadata = *t;\n\t\t\tzval_copy_ctor(newentry.metadata);\n#if PHP_VERSION_ID < 50300\n\t\t\tnewentry.metadata->refcount = 1;\n#else\n\t\t\tZ_SET_REFCOUNT_P(newentry.metadata, 1);\n#endif\n\n\t\t\tnewentry.metadata_str.c = NULL;\n\t\t\tnewentry.metadata_str.len = 0;\n\t\t}\n\n\t\tnewentry.is_zip = phar->is_zip;\n\t\tnewentry.is_tar = phar->is_tar;\n\n\t\tif (newentry.is_tar) {\n\t\t\tnewentry.tar_type = (entry->is_dir ? TAR_DIR : TAR_FILE);\n\t\t}\n\n\t\tnewentry.is_modified = 1;\n\t\tnewentry.phar = phar;\n\t\tnewentry.old_flags = newentry.flags & ~PHAR_ENT_COMPRESSION_MASK; /* remove compression from old_flags */\n\t\tphar_set_inode(&newentry TSRMLS_CC);\n\t\tzend_hash_add(&(phar->manifest), newentry.filename, newentry.filename_len, (void*)&newentry, sizeof(phar_entry_info), NULL);\n\t\tphar_add_virtual_dirs(phar, newentry.filename, newentry.filename_len TSRMLS_CC);\n\t}\n\n\tif ((ret = phar_rename_archive(phar, ext, 0 TSRMLS_CC))) {\n\t\treturn ret;\n\t} else {\n                zend_hash_destroy(&(phar->manifest));\n                zend_hash_destroy(&(phar->mounted_dirs));\n                zend_hash_destroy(&(phar->virtual_dirs));\n               if (phar->fp) {\n                       php_stream_close(phar->fp);\n               }\n                efree(phar->fname);\n                efree(phar);\n                return NULL;\n/* }}} */\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144380,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int vmxnet3_post_load(void *opaque, int version_id)\n{\n    VMXNET3State *s = opaque;\n    PCIDevice *d = PCI_DEVICE(s);\n\n    vmxnet_tx_pkt_init(&s->tx_pkt, s->max_tx_frags, s->peer_has_vhdr);\n    vmxnet_rx_pkt_init(&s->rx_pkt, s->peer_has_vhdr);\n\n    if (s->msix_used) {\n        if  (!vmxnet3_use_msix_vectors(s, VMXNET3_MAX_INTRS)) {\n            VMW_WRPRN(\"Failed to re-use MSI-X vectors\");\n            msix_uninit(d, &s->msix_bar, &s->msix_bar);\n            s->msix_used = false;\n            return -1;\n         }\n     }\n \n     return 0;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144387,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int vmxnet3_post_load(void *opaque, int version_id)\n{\n    VMXNET3State *s = opaque;\n    PCIDevice *d = PCI_DEVICE(s);\n\n    vmxnet_tx_pkt_init(&s->tx_pkt, s->max_tx_frags, s->peer_has_vhdr);\n    vmxnet_rx_pkt_init(&s->rx_pkt, s->peer_has_vhdr);\n\n    if (s->msix_used) {\n        if  (!vmxnet3_use_msix_vectors(s, VMXNET3_MAX_INTRS)) {\n            VMW_WRPRN(\"Failed to re-use MSI-X vectors\");\n            msix_uninit(d, &s->msix_bar, &s->msix_bar);\n            s->msix_used = false;\n            return -1;\n         }\n     }\n \n    vmxnet3_validate_interrupts(s);\n\n     return 0;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144388,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "stf_status ikev2parent_inI1outR1(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tlset_t policy = POLICY_IKEV2_ALLOW;\n\tstruct connection *c = find_host_connection(&md->iface->ip_addr,\n\t\t\t\t\t\t    md->iface->port,\n\t\t\t\t\t\t    &md->sender,\n\t\t\t\t\t\t    md->sender_port,\n\t\t\t\t\t\t    POLICY_IKEV2_ALLOW);\n\n\t/* retrieve st->st_gi */\n\n#if 0\n\tif (c == NULL) {\n\t\t/*\n\t\t * make up a policy from the thing that was proposed, and see\n\t\t * if we can find a connection with that policy.\n\t\t */\n\n\t\tpb_stream pre_sa_pbs = sa_pd->pbs;\n\t\tpolicy = preparse_isakmp_sa_body(&pre_sa_pbs);\n\t\tc = find_host_connection(&md->iface->ip_addr, pluto_port,\n\t\t\t\t\t (ip_address*)NULL, md->sender_port,\n\t\t\t\t\t policy);\n\n\t}\n#endif\n\n\tif (c == NULL) {\n\n\t\t/* See if a wildcarded connection can be found.\n\t\t * We cannot pick the right connection, so we're making a guess.\n\t\t * All Road Warrior connections are fair game:\n\t\t * we pick the first we come across (if any).\n\t\t * If we don't find any, we pick the first opportunistic\n\t\t * with the smallest subnet that includes the peer.\n\t\t * There is, of course, no necessary relationship between\n\t\t * an Initiator's address and that of its client,\n\t\t * but Food Groups kind of assumes one.\n\t\t */\n\t\t{\n\t\t\tstruct connection *d;\n\t\t\td = find_host_connection(&md->iface->ip_addr,\n\t\t\t\t\t\t pluto_port,\n\t\t\t\t\t\t (ip_address*)NULL,\n\t\t\t\t\t\t md->sender_port, policy);\n\n\t\t\tfor (; d != NULL; d = d->hp_next) {\n\t\t\t\tif (d->kind == CK_GROUP) {\n\t\t\t\t\t/* ignore */\n\t\t\t\t} else {\n\t\t\t\t\tif (d->kind == CK_TEMPLATE &&\n\t\t\t\t\t    !(d->policy & POLICY_OPPO)) {\n\t\t\t\t\t\t/* must be Road Warrior: we have a winner */\n\t\t\t\t\t\tc = d;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Opportunistic or Shunt: pick tightest match */\n\t\t\t\t\tif (addrinsubnet(&md->sender,\n\t\t\t\t\t\t\t &d->spd.that.client)\n\t\t\t\t\t    &&\n\t\t\t\t\t    (c == NULL ||\n\t\t\t\t\t     !subnetinsubnet(&c->spd.that.\n\t\t\t\t\t\t\t     client,\n\t\t\t\t\t\t\t     &d->spd.that.\n\t\t\t\t\t\t\t     client)))\n\t\t\t\t\t\tc = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c == NULL) {\n\t\t\tloglog(RC_LOG_SERIOUS, \"initial parent SA message received on %s:%u\"\n\t\t\t       \" but no connection has been authorized%s%s\",\n\t\t\t       ip_str(\n\t\t\t\t       &md->iface->ip_addr),\n\t\t\t       ntohs(portof(&md->iface->ip_addr)),\n\t\t\t       (policy != LEMPTY) ? \" with policy=\" : \"\",\n\t\t\t       (policy !=\n\t\t\t\tLEMPTY) ? bitnamesof(sa_policy_bit_names,\n\t\t\t\t\t\t     policy) : \"\");\n\t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;\n\t\t}\n\t\tif (c->kind != CK_TEMPLATE) {\n\t\t\tloglog(RC_LOG_SERIOUS, \"initial parent SA message received on %s:%u\"\n\t\t\t       \" but \\\"%s\\\" forbids connection\",\n\t\t\t       ip_str(\n\t\t\t\t       &md->iface->ip_addr), pluto_port,\n\t\t\t       c->name);\n\t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;\n\t\t}\n\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\n\t} else {\n\t\t/* we found a non-wildcard conn. double check if it needs instantiation anyway (eg vnet=) */\n\t\t/* vnet=/vhost= should have set CK_TEMPLATE on connection loading */\n\t\tif ((c->kind == CK_TEMPLATE) && c->spd.that.virt) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \"local endpoint has virt (vnet/vhost) set without wildcards - needs instantiation\"));\n\t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\t\t} else if ((c->kind == CK_TEMPLATE) &&\n\t\t\t   (c->policy & POLICY_IKEV2_ALLOW_NARROWING)) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \"local endpoint has narrowing=yes - needs instantiation\"));\n\t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\t\t}\n\t}\n\n\tDBG_log(\"found connection: %s\\n\", c ? c->name : \"<none>\");\n\n\tif (!st) {\n\t\tst = new_state();\n\t\t/* set up new state */\n\t\tmemcpy(st->st_icookie, md->hdr.isa_icookie, COOKIE_SIZE);\n\t\t/* initialize_new_state expects valid icookie/rcookie values, so create it now */\n\t\tget_cookie(FALSE, st->st_rcookie, COOKIE_SIZE, &md->sender);\n\t\tinitialize_new_state(st, c, policy, 0, NULL_FD,\n\t\t\t\t     pcim_stranger_crypto);\n\t\tst->st_ikev2 = TRUE;\n\t\tchange_state(st, STATE_PARENT_R1);\n\t\tst->st_msgid_lastack = INVALID_MSGID;\n\t\tst->st_msgid_nextuse = 0;\n\n\t\tmd->st = st;\n\t\tmd->from_state = STATE_IKEv2_BASE;\n\t}\n\n\t/* check,as a responder, are we under dos attack or not\n\t * if yes go to 6 message exchange mode. it is a config option for now.\n\t * TBD set force_busy dynamically\n\t * Paul: Can we check for STF_TOOMUCHCRYPTO ?\n\t */\n\tif (force_busy == TRUE) {\n\t\tu_char dcookie[SHA1_DIGEST_SIZE];\n\t\tchunk_t dc;\n\t\tikev2_get_dcookie( dcookie, st->st_ni, &md->sender,\n\t\t\t\t   st->st_icookie);\n\t\tdc.ptr = dcookie;\n\t\tdc.len = SHA1_DIGEST_SIZE;\n\n\t\t/* check if I1 packet contian KE and a v2N payload with type COOKIE */\n\t\tif ( md->chain[ISAKMP_NEXT_v2KE] &&\n\t\t     md->chain[ISAKMP_NEXT_v2N] &&\n\t\t     (md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type ==\n\t\t      v2N_COOKIE)) {\n\t\t\tu_int8_t spisize;\n\t\t\tconst pb_stream *dc_pbs;\n\t\t\tchunk_t blob;\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\"received a DOS cookie in I1 verify it\"));\n\t\t\t/* we received dcookie we send earlier verify it */\n\t\t\tspisize =\n\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.\n\t\t\t\tisan_spisize;\n\t\t\tdc_pbs = &md->chain[ISAKMP_NEXT_v2N]->pbs;\n\t\t\tblob.ptr = dc_pbs->cur + spisize;\n\t\t\tblob.len = pbs_left(dc_pbs) - spisize;\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_dump_chunk(\"dcookie received in I1 Packet\",\n\t\t\t\t\t   blob);\n\t\t\t    DBG_dump(\"dcookie computed\", dcookie,\n\t\t\t\t     SHA1_DIGEST_SIZE));\n\n\t\t\tif (memcmp(blob.ptr, dcookie, SHA1_DIGEST_SIZE) != 0) {\n\t\t\t\tlibreswan_log(\n\t\t\t\t\t\"mismatch in DOS v2N_COOKIE,send a new one\");\n\t\t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);\n\t\t\t\treturn STF_FAIL + v2N_INVALID_IKE_SPI;\n\t\t\t}\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\"dcookie received match with computed one\"));\n\t\t} else {\n\t\t\t/* we are under DOS attack I1 contains no DOS COOKIE */\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\n\t\t\t\t    \"busy mode on. receieved I1 without a valid dcookie\");\n\t\t\t    DBG_log(\"send a dcookie and forget this state\"));\n\t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);\n\t\t\treturn STF_FAIL;\n\t\t}\n\t} else {\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\"will not send/process a dcookie\"));\n\n\t}\n\n\t/*\n\t * We have to agree to the DH group before we actually know who\n\t * we are talking to.   If we support the group, we use it.\n\t *\n\t * It is really too hard here to go through all the possible policies\n\t * that might permit this group.  If we think we are being DOS'ed\n\t * then we should demand a cookie.\n \t */\n \t{\n \t\tstruct ikev2_ke *ke;\n \t\tke = &md->chain[ISAKMP_NEXT_v2KE]->payload.v2ke;\n \n \t\tst->st_oakley.group = lookup_group(ke->isak_group);\n \t\tif (st->st_oakley.group == NULL) {\n\t\t\tchar fromname[ADDRTOT_BUF];\n\t\t\taddrtot(&md->sender, 0, fromname, ADDRTOT_BUF);\n \t\t\tlibreswan_log(\n \t\t\t\t\"rejecting I1 from %s:%u, invalid DH group=%u\",\n \t\t\t\tfromname, md->sender_port,\n \t\t\t\tke->isak_group);\n\t\t\treturn v2N_INVALID_KE_PAYLOAD;\n \t\t}\n \t}\n \n\t/* now. we need to go calculate the nonce, and the KE */\n\t{\n\t\tstruct ke_continuation *ke = alloc_thing(\n\t\t\tstruct ke_continuation,\n\t\t\t\"ikev2_inI1outR1 KE\");\n\t\tstf_status e;\n\n\t\tke->md = md;\n\t\tset_suspended(st, ke->md);\n\n\t\tif (!st->st_sec_in_use) {\n\t\t\tpcrc_init(&ke->ke_pcrc);\n\t\t\tke->ke_pcrc.pcrc_func =\n\t\t\t\tikev2_parent_inI1outR1_continue;\n\t\t\te = build_ke(&ke->ke_pcrc, st, st->st_oakley.group,\n\t\t\t\t     pcim_stranger_crypto);\n\t\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\t\tdelete_state(st);\n\t\t\t}\n\t\t} else {\n\t\t\te =\n\t\t\t\tikev2_parent_inI1outR1_tail((struct\n\t\t\t\t\t\t\t     pluto_crypto_req_cont\n\t\t\t\t\t\t\t     *)ke,\n\t\t\t\t\t\t\t    NULL);\n\t\t}\n\n\t\treset_globals();\n\n\t\treturn e;\n\t}\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144417,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "stf_status ikev2parent_inI1outR1(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tlset_t policy = POLICY_IKEV2_ALLOW;\n\tstruct connection *c = find_host_connection(&md->iface->ip_addr,\n\t\t\t\t\t\t    md->iface->port,\n\t\t\t\t\t\t    &md->sender,\n\t\t\t\t\t\t    md->sender_port,\n\t\t\t\t\t\t    POLICY_IKEV2_ALLOW);\n\n\t/* retrieve st->st_gi */\n\n#if 0\n\tif (c == NULL) {\n\t\t/*\n\t\t * make up a policy from the thing that was proposed, and see\n\t\t * if we can find a connection with that policy.\n\t\t */\n\n\t\tpb_stream pre_sa_pbs = sa_pd->pbs;\n\t\tpolicy = preparse_isakmp_sa_body(&pre_sa_pbs);\n\t\tc = find_host_connection(&md->iface->ip_addr, pluto_port,\n\t\t\t\t\t (ip_address*)NULL, md->sender_port,\n\t\t\t\t\t policy);\n\n\t}\n#endif\n\n\tif (c == NULL) {\n\n\t\t/* See if a wildcarded connection can be found.\n\t\t * We cannot pick the right connection, so we're making a guess.\n\t\t * All Road Warrior connections are fair game:\n\t\t * we pick the first we come across (if any).\n\t\t * If we don't find any, we pick the first opportunistic\n\t\t * with the smallest subnet that includes the peer.\n\t\t * There is, of course, no necessary relationship between\n\t\t * an Initiator's address and that of its client,\n\t\t * but Food Groups kind of assumes one.\n\t\t */\n\t\t{\n\t\t\tstruct connection *d;\n\t\t\td = find_host_connection(&md->iface->ip_addr,\n\t\t\t\t\t\t pluto_port,\n\t\t\t\t\t\t (ip_address*)NULL,\n\t\t\t\t\t\t md->sender_port, policy);\n\n\t\t\tfor (; d != NULL; d = d->hp_next) {\n\t\t\t\tif (d->kind == CK_GROUP) {\n\t\t\t\t\t/* ignore */\n\t\t\t\t} else {\n\t\t\t\t\tif (d->kind == CK_TEMPLATE &&\n\t\t\t\t\t    !(d->policy & POLICY_OPPO)) {\n\t\t\t\t\t\t/* must be Road Warrior: we have a winner */\n\t\t\t\t\t\tc = d;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Opportunistic or Shunt: pick tightest match */\n\t\t\t\t\tif (addrinsubnet(&md->sender,\n\t\t\t\t\t\t\t &d->spd.that.client)\n\t\t\t\t\t    &&\n\t\t\t\t\t    (c == NULL ||\n\t\t\t\t\t     !subnetinsubnet(&c->spd.that.\n\t\t\t\t\t\t\t     client,\n\t\t\t\t\t\t\t     &d->spd.that.\n\t\t\t\t\t\t\t     client)))\n\t\t\t\t\t\tc = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c == NULL) {\n\t\t\tloglog(RC_LOG_SERIOUS, \"initial parent SA message received on %s:%u\"\n\t\t\t       \" but no connection has been authorized%s%s\",\n\t\t\t       ip_str(\n\t\t\t\t       &md->iface->ip_addr),\n\t\t\t       ntohs(portof(&md->iface->ip_addr)),\n\t\t\t       (policy != LEMPTY) ? \" with policy=\" : \"\",\n\t\t\t       (policy !=\n\t\t\t\tLEMPTY) ? bitnamesof(sa_policy_bit_names,\n\t\t\t\t\t\t     policy) : \"\");\n\t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;\n\t\t}\n\t\tif (c->kind != CK_TEMPLATE) {\n\t\t\tloglog(RC_LOG_SERIOUS, \"initial parent SA message received on %s:%u\"\n\t\t\t       \" but \\\"%s\\\" forbids connection\",\n\t\t\t       ip_str(\n\t\t\t\t       &md->iface->ip_addr), pluto_port,\n\t\t\t       c->name);\n\t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;\n\t\t}\n\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\n\t} else {\n\t\t/* we found a non-wildcard conn. double check if it needs instantiation anyway (eg vnet=) */\n\t\t/* vnet=/vhost= should have set CK_TEMPLATE on connection loading */\n\t\tif ((c->kind == CK_TEMPLATE) && c->spd.that.virt) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \"local endpoint has virt (vnet/vhost) set without wildcards - needs instantiation\"));\n\t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\t\t} else if ((c->kind == CK_TEMPLATE) &&\n\t\t\t   (c->policy & POLICY_IKEV2_ALLOW_NARROWING)) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \"local endpoint has narrowing=yes - needs instantiation\"));\n\t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\t\t}\n\t}\n\n\tDBG_log(\"found connection: %s\\n\", c ? c->name : \"<none>\");\n\n\tif (!st) {\n\t\tst = new_state();\n\t\t/* set up new state */\n\t\tmemcpy(st->st_icookie, md->hdr.isa_icookie, COOKIE_SIZE);\n\t\t/* initialize_new_state expects valid icookie/rcookie values, so create it now */\n\t\tget_cookie(FALSE, st->st_rcookie, COOKIE_SIZE, &md->sender);\n\t\tinitialize_new_state(st, c, policy, 0, NULL_FD,\n\t\t\t\t     pcim_stranger_crypto);\n\t\tst->st_ikev2 = TRUE;\n\t\tchange_state(st, STATE_PARENT_R1);\n\t\tst->st_msgid_lastack = INVALID_MSGID;\n\t\tst->st_msgid_nextuse = 0;\n\n\t\tmd->st = st;\n\t\tmd->from_state = STATE_IKEv2_BASE;\n\t}\n\n\t/* check,as a responder, are we under dos attack or not\n\t * if yes go to 6 message exchange mode. it is a config option for now.\n\t * TBD set force_busy dynamically\n\t * Paul: Can we check for STF_TOOMUCHCRYPTO ?\n\t */\n\tif (force_busy == TRUE) {\n\t\tu_char dcookie[SHA1_DIGEST_SIZE];\n\t\tchunk_t dc;\n\t\tikev2_get_dcookie( dcookie, st->st_ni, &md->sender,\n\t\t\t\t   st->st_icookie);\n\t\tdc.ptr = dcookie;\n\t\tdc.len = SHA1_DIGEST_SIZE;\n\n\t\t/* check if I1 packet contian KE and a v2N payload with type COOKIE */\n\t\tif ( md->chain[ISAKMP_NEXT_v2KE] &&\n\t\t     md->chain[ISAKMP_NEXT_v2N] &&\n\t\t     (md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type ==\n\t\t      v2N_COOKIE)) {\n\t\t\tu_int8_t spisize;\n\t\t\tconst pb_stream *dc_pbs;\n\t\t\tchunk_t blob;\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\"received a DOS cookie in I1 verify it\"));\n\t\t\t/* we received dcookie we send earlier verify it */\n\t\t\tspisize =\n\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.\n\t\t\t\tisan_spisize;\n\t\t\tdc_pbs = &md->chain[ISAKMP_NEXT_v2N]->pbs;\n\t\t\tblob.ptr = dc_pbs->cur + spisize;\n\t\t\tblob.len = pbs_left(dc_pbs) - spisize;\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_dump_chunk(\"dcookie received in I1 Packet\",\n\t\t\t\t\t   blob);\n\t\t\t    DBG_dump(\"dcookie computed\", dcookie,\n\t\t\t\t     SHA1_DIGEST_SIZE));\n\n\t\t\tif (memcmp(blob.ptr, dcookie, SHA1_DIGEST_SIZE) != 0) {\n\t\t\t\tlibreswan_log(\n\t\t\t\t\t\"mismatch in DOS v2N_COOKIE,send a new one\");\n\t\t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);\n\t\t\t\treturn STF_FAIL + v2N_INVALID_IKE_SPI;\n\t\t\t}\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\"dcookie received match with computed one\"));\n\t\t} else {\n\t\t\t/* we are under DOS attack I1 contains no DOS COOKIE */\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\n\t\t\t\t    \"busy mode on. receieved I1 without a valid dcookie\");\n\t\t\t    DBG_log(\"send a dcookie and forget this state\"));\n\t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);\n\t\t\treturn STF_FAIL;\n\t\t}\n\t} else {\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\"will not send/process a dcookie\"));\n\n\t}\n\n\t/*\n\t * We have to agree to the DH group before we actually know who\n\t * we are talking to.   If we support the group, we use it.\n\t *\n\t * It is really too hard here to go through all the possible policies\n\t * that might permit this group.  If we think we are being DOS'ed\n\t * then we should demand a cookie.\n \t */\n \t{\n \t\tstruct ikev2_ke *ke;\n\t\tchar fromname[ADDRTOT_BUF];\n\t\taddrtot(&md->sender, 0, fromname, ADDRTOT_BUF);\n\n\t\tif (!md->chain[ISAKMP_NEXT_v2KE]) {\n\t\t\t/* is this a notify? If so, log it */\n\t\t\tif(md->chain[ISAKMP_NEXT_v2N]) {\n\t\t\t\tlibreswan_log(\"Received Notify(%d): %s\",\n\t\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type,\n\t\t\t\t\tenum_name(&ikev2_notify_names,\n\t\t\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type));\n\t\t\t}\n\t\t\tlibreswan_log(\n\t\t\t\t\"rejecting I1 from %s:%u, no KE payload present\",\n\t\t\t\tfromname, md->sender_port);\n\t\t\treturn STF_FAIL + v2N_INVALID_KE_PAYLOAD;\n\t\t}\n \t\tke = &md->chain[ISAKMP_NEXT_v2KE]->payload.v2ke;\n \n \t\tst->st_oakley.group = lookup_group(ke->isak_group);\n \t\tif (st->st_oakley.group == NULL) {\n \t\t\tlibreswan_log(\n \t\t\t\t\"rejecting I1 from %s:%u, invalid DH group=%u\",\n \t\t\t\tfromname, md->sender_port,\n \t\t\t\tke->isak_group);\n\t\t\treturn STF_FAIL + v2N_INVALID_KE_PAYLOAD;\n \t\t}\n \t}\n \n\t/* now. we need to go calculate the nonce, and the KE */\n\t{\n\t\tstruct ke_continuation *ke = alloc_thing(\n\t\t\tstruct ke_continuation,\n\t\t\t\"ikev2_inI1outR1 KE\");\n\t\tstf_status e;\n\n\t\tke->md = md;\n\t\tset_suspended(st, ke->md);\n\n\t\tif (!st->st_sec_in_use) {\n\t\t\tpcrc_init(&ke->ke_pcrc);\n\t\t\tke->ke_pcrc.pcrc_func =\n\t\t\t\tikev2_parent_inI1outR1_continue;\n\t\t\te = build_ke(&ke->ke_pcrc, st, st->st_oakley.group,\n\t\t\t\t     pcim_stranger_crypto);\n\t\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\t\tdelete_state(st);\n\t\t\t}\n\t\t} else {\n\t\t\te =\n\t\t\t\tikev2_parent_inI1outR1_tail((struct\n\t\t\t\t\t\t\t     pluto_crypto_req_cont\n\t\t\t\t\t\t\t     *)ke,\n\t\t\t\t\t\t\t    NULL);\n\t\t}\n\n\t\treset_globals();\n\n\t\treturn e;\n\t}\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144418,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "yyparse (void *YYPARSE_PARAM)\n#else\nint\nyyparse (YYPARSE_PARAM)\n    void *YYPARSE_PARAM;\n#endif\n#else /* ! YYPARSE_PARAM */\n#if (defined __STDC__ || defined __C99__FUNC__ \\\n     || defined __cplusplus || defined _MSC_VER)\nint\nyyparse (void)\n#else\nint\nyyparse ()\n\n#endif\n#endif\n{\n\n\n    int yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       `yyss': related to states.\n       `yyvs': related to semantic values.\n\n       Refer to the stacks thru separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yytype_int16 yyssa[YYINITDEPTH];\n    yytype_int16 *yyss;\n    yytype_int16 *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYSIZE_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yytoken = 0;\n  yyss = yyssa;\n  yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n\n  /* Initialize stack pointers.\n     Waste one element of value and location stack\n     so that they stay on the same level as the state stack.\n     The wasted elements are never initialized.  */\n  yyssp = yyss;\n  yyvsp = yyvs;\n\n  goto yysetstate;\n\n/*------------------------------------------------------------.\n| yynewstate -- Push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\n yynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n yysetstate:\n  *yyssp = yystate;\n\n  if (yyss + yystacksize - 1 <= yyssp)\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYSIZE_T yysize = yyssp - yyss + 1;\n\n#ifdef yyoverflow\n      {\n\t/* Give user a chance to reallocate the stack.  Use copies of\n\t   these so that the &'s don't force the real ones into\n\t   memory.  */\n\tYYSTYPE *yyvs1 = yyvs;\n\tyytype_int16 *yyss1 = yyss;\n\n\t/* Each stack pointer address is followed by the size of the\n\t   data in use in that stack, in bytes.  This used to be a\n\t   conditional around just the two extra args, but that might\n\t   be undefined if yyoverflow is a macro.  */\n\tyyoverflow (YY_(\"memory exhausted\"),\n\t\t    &yyss1, yysize * sizeof (*yyssp),\n\t\t    &yyvs1, yysize * sizeof (*yyvsp),\n\t\t    &yystacksize);\n\n\tyyss = yyss1;\n\tyyvs = yyvs1;\n      }\n#else /* no yyoverflow */\n# ifndef YYSTACK_RELOCATE\n      goto yyexhaustedlab;\n# else\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n\tgoto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n\tyystacksize = YYMAXDEPTH;\n\n      {\n\tyytype_int16 *yyss1 = yyss;\n\tunion yyalloc *yyptr =\n\t  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\n\tif (! yyptr)\n\t  goto yyexhaustedlab;\n\tYYSTACK_RELOCATE (yyss_alloc, yyss);\n\tYYSTACK_RELOCATE (yyvs_alloc, yyvs);\n#  undef YYSTACK_RELOCATE\n\tif (yyss1 != yyssa)\n\t  YYSTACK_FREE (yyss1);\n      }\n# endif\n#endif /* no yyoverflow */\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n\t\t  (unsigned long int) yystacksize));\n\n      if (yyss + yystacksize - 1 <= yyssp)\n\tYYABORT;\n    }\n\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yyn == YYPACT_NINF)\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = YYLEX;\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yyn == 0 || yyn == YYTABLE_NINF)\n\tgoto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n\n  yystate = yyn;\n  *++yyvsp = yylval;\n\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- Do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     `$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n        case 5:\n\n/* Line 1455 of yacc.c  */\n#line 320 \"ntp_parser.y\"\n    {\n\t\t\t/* I will need to incorporate much more fine grained\n\t\t\t * error messages. The following should suffice for\n\t\t\t * the time being.\n\t\t\t */\n\t\t\tmsyslog(LOG_ERR, \n\t\t\t\t\"syntax error in %s line %d, column %d\",\n\t\t\t\tip_file->fname,\n\t\t\t\tip_file->err_line_no,\n\t\t\t\tip_file->err_col_no);\n\t\t}\n    break;\n\n  case 19:\n\n/* Line 1455 of yacc.c  */\n#line 354 \"ntp_parser.y\"\n    {\n\t\t\tstruct peer_node *my_node =  create_peer_node((yyvsp[(1) - (3)].Integer), (yyvsp[(2) - (3)].Address_node), (yyvsp[(3) - (3)].Queue));\n\t\t\tif (my_node)\n\t\t\t\tenqueue(cfgt.peers, my_node);\n\t\t}\n    break;\n\n  case 20:\n\n/* Line 1455 of yacc.c  */\n#line 360 \"ntp_parser.y\"\n    {\n\t\t\tstruct peer_node *my_node = create_peer_node((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Address_node), NULL);\n\t\t\tif (my_node)\n\t\t\t\tenqueue(cfgt.peers, my_node);\n\t\t}\n    break;\n\n  case 27:\n\n/* Line 1455 of yacc.c  */\n#line 377 \"ntp_parser.y\"\n    { (yyval.Address_node) = create_address_node((yyvsp[(2) - (2)].String), AF_INET); }\n    break;\n\n  case 28:\n\n/* Line 1455 of yacc.c  */\n#line 378 \"ntp_parser.y\"\n    { (yyval.Address_node) = create_address_node((yyvsp[(2) - (2)].String), AF_INET6); }\n    break;\n\n  case 29:\n\n/* Line 1455 of yacc.c  */\n#line 382 \"ntp_parser.y\"\n    { (yyval.Address_node) = create_address_node((yyvsp[(1) - (1)].String), 0); }\n    break;\n\n  case 30:\n\n/* Line 1455 of yacc.c  */\n#line 386 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val)); }\n    break;\n\n  case 31:\n\n/* Line 1455 of yacc.c  */\n#line 387 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val)); }\n    break;\n\n  case 32:\n\n/* Line 1455 of yacc.c  */\n#line 391 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 33:\n\n/* Line 1455 of yacc.c  */\n#line 392 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 34:\n\n/* Line 1455 of yacc.c  */\n#line 393 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 35:\n\n/* Line 1455 of yacc.c  */\n#line 394 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 36:\n\n/* Line 1455 of yacc.c  */\n#line 395 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 37:\n\n/* Line 1455 of yacc.c  */\n#line 396 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 38:\n\n/* Line 1455 of yacc.c  */\n#line 397 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 39:\n\n/* Line 1455 of yacc.c  */\n#line 398 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 40:\n\n/* Line 1455 of yacc.c  */\n#line 399 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 41:\n\n/* Line 1455 of yacc.c  */\n#line 400 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 42:\n\n/* Line 1455 of yacc.c  */\n#line 401 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 43:\n\n/* Line 1455 of yacc.c  */\n#line 402 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 44:\n\n/* Line 1455 of yacc.c  */\n#line 403 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 45:\n\n/* Line 1455 of yacc.c  */\n#line 404 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 46:\n\n/* Line 1455 of yacc.c  */\n#line 405 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 47:\n\n/* Line 1455 of yacc.c  */\n#line 415 \"ntp_parser.y\"\n    {\n\t\t\tstruct unpeer_node *my_node = create_unpeer_node((yyvsp[(2) - (2)].Address_node));\n\t\t\tif (my_node)\n\t\t\t\tenqueue(cfgt.unpeers, my_node);\n\t\t}\n    break;\n\n  case 50:\n\n/* Line 1455 of yacc.c  */\n#line 434 \"ntp_parser.y\"\n    { cfgt.broadcastclient = 1; }\n    break;\n\n  case 51:\n\n/* Line 1455 of yacc.c  */\n#line 436 \"ntp_parser.y\"\n    { append_queue(cfgt.manycastserver, (yyvsp[(2) - (2)].Queue)); }\n    break;\n\n  case 52:\n\n/* Line 1455 of yacc.c  */\n#line 438 \"ntp_parser.y\"\n    { append_queue(cfgt.multicastclient, (yyvsp[(2) - (2)].Queue)); }\n    break;\n\n  case 53:\n\n/* Line 1455 of yacc.c  */\n#line 449 \"ntp_parser.y\"\n    { enqueue(cfgt.vars, create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer))); }\n    break;\n\n  case 54:\n\n/* Line 1455 of yacc.c  */\n#line 451 \"ntp_parser.y\"\n    { cfgt.auth.control_key = (yyvsp[(2) - (2)].Integer); }\n    break;\n\n  case 55:\n\n/* Line 1455 of yacc.c  */\n#line 453 \"ntp_parser.y\"\n    { \n\t\t\tcfgt.auth.cryptosw++;\n\t\t\tappend_queue(cfgt.auth.crypto_cmd_list, (yyvsp[(2) - (2)].Queue));\n\t\t}\n    break;\n\n  case 56:\n\n/* Line 1455 of yacc.c  */\n#line 458 \"ntp_parser.y\"\n    { cfgt.auth.keys = (yyvsp[(2) - (2)].String); }\n    break;\n\n  case 57:\n\n/* Line 1455 of yacc.c  */\n#line 460 \"ntp_parser.y\"\n    { cfgt.auth.keysdir = (yyvsp[(2) - (2)].String); }\n    break;\n\n  case 58:\n\n/* Line 1455 of yacc.c  */\n#line 462 \"ntp_parser.y\"\n    { cfgt.auth.request_key = (yyvsp[(2) - (2)].Integer); }\n    break;\n\n  case 59:\n\n/* Line 1455 of yacc.c  */\n#line 464 \"ntp_parser.y\"\n    { cfgt.auth.revoke = (yyvsp[(2) - (2)].Integer); }\n    break;\n\n  case 60:\n\n/* Line 1455 of yacc.c  */\n#line 466 \"ntp_parser.y\"\n    { cfgt.auth.trusted_key_list = (yyvsp[(2) - (2)].Queue); }\n    break;\n\n  case 61:\n\n/* Line 1455 of yacc.c  */\n#line 468 \"ntp_parser.y\"\n    { cfgt.auth.ntp_signd_socket = (yyvsp[(2) - (2)].String); }\n    break;\n\n  case 63:\n\n/* Line 1455 of yacc.c  */\n#line 474 \"ntp_parser.y\"\n    { (yyval.Queue) = create_queue(); }\n    break;\n\n  case 64:\n\n/* Line 1455 of yacc.c  */\n#line 479 \"ntp_parser.y\"\n    { \n\t\t\tif ((yyvsp[(2) - (2)].Attr_val) != NULL)\n\t\t\t\t(yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val));\n\t\t\telse\n\t\t\t\t(yyval.Queue) = (yyvsp[(1) - (2)].Queue);\n\t\t}\n    break;\n\n  case 65:\n\n/* Line 1455 of yacc.c  */\n#line 486 \"ntp_parser.y\"\n    {\n\t\t\tif ((yyvsp[(1) - (1)].Attr_val) != NULL)\n\t\t\t\t(yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val));\n\t\t\telse\n\t\t\t\t(yyval.Queue) = create_queue();\n\t\t}\n    break;\n\n  case 66:\n\n/* Line 1455 of yacc.c  */\n#line 496 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String)); }\n    break;\n\n  case 67:\n\n/* Line 1455 of yacc.c  */\n#line 498 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String)); }\n    break;\n\n  case 68:\n\n/* Line 1455 of yacc.c  */\n#line 500 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String)); }\n    break;\n\n  case 69:\n\n/* Line 1455 of yacc.c  */\n#line 502 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String)); }\n    break;\n\n  case 70:\n\n/* Line 1455 of yacc.c  */\n#line 504 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String)); }\n    break;\n\n  case 71:\n\n/* Line 1455 of yacc.c  */\n#line 506 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String)); }\n    break;\n\n  case 72:\n\n/* Line 1455 of yacc.c  */\n#line 508 \"ntp_parser.y\"\n    {\n\t\t\t(yyval.Attr_val) = NULL;\n\t\t\tcfgt.auth.revoke = (yyvsp[(2) - (2)].Integer);\n\t\t\tmsyslog(LOG_WARNING,\n\t\t\t\t\"'crypto revoke %d' is deprecated, \"\n\t\t\t\t\"please use 'revoke %d' instead.\",\n\t\t\t\tcfgt.auth.revoke, cfgt.auth.revoke);\n\t\t}\n    break;\n\n  case 73:\n\n/* Line 1455 of yacc.c  */\n#line 525 \"ntp_parser.y\"\n    { append_queue(cfgt.orphan_cmds,(yyvsp[(2) - (2)].Queue)); }\n    break;\n\n  case 74:\n\n/* Line 1455 of yacc.c  */\n#line 529 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val)); }\n    break;\n\n  case 75:\n\n/* Line 1455 of yacc.c  */\n#line 530 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val)); }\n    break;\n\n  case 76:\n\n/* Line 1455 of yacc.c  */\n#line 535 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (double)(yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 77:\n\n/* Line 1455 of yacc.c  */\n#line 537 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (double)(yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 78:\n\n/* Line 1455 of yacc.c  */\n#line 539 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (double)(yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 79:\n\n/* Line 1455 of yacc.c  */\n#line 541 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (double)(yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 80:\n\n/* Line 1455 of yacc.c  */\n#line 543 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (double)(yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 81:\n\n/* Line 1455 of yacc.c  */\n#line 545 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 82:\n\n/* Line 1455 of yacc.c  */\n#line 547 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 83:\n\n/* Line 1455 of yacc.c  */\n#line 549 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 84:\n\n/* Line 1455 of yacc.c  */\n#line 551 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 85:\n\n/* Line 1455 of yacc.c  */\n#line 553 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (double)(yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 86:\n\n/* Line 1455 of yacc.c  */\n#line 555 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (double)(yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 87:\n\n/* Line 1455 of yacc.c  */\n#line 565 \"ntp_parser.y\"\n    { append_queue(cfgt.stats_list, (yyvsp[(2) - (2)].Queue)); }\n    break;\n\n  case 88:\n\n/* Line 1455 of yacc.c  */\n#line 567 \"ntp_parser.y\"\n    {\n\t\t\tif (input_from_file)\n\t\t\t\tcfgt.stats_dir = (yyvsp[(2) - (2)].String);\n\t\t\telse {\n\t\t\t\tfree((yyvsp[(2) - (2)].String));\n\t\t\t\tyyerror(\"statsdir remote configuration ignored\");\n\t\t\t}\n\t\t}\n    break;\n\n  case 89:\n\n/* Line 1455 of yacc.c  */\n#line 576 \"ntp_parser.y\"\n    {\n\t\t\tenqueue(cfgt.filegen_opts,\n\t\t\t\tcreate_filegen_node((yyvsp[(2) - (3)].Integer), (yyvsp[(3) - (3)].Queue)));\n\t\t}\n    break;\n\n  case 90:\n\n/* Line 1455 of yacc.c  */\n#line 583 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), create_ival((yyvsp[(2) - (2)].Integer))); }\n    break;\n\n  case 91:\n\n/* Line 1455 of yacc.c  */\n#line 584 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue_in_new_queue(create_ival((yyvsp[(1) - (1)].Integer))); }\n    break;\n\n  case 100:\n\n/* Line 1455 of yacc.c  */\n#line 600 \"ntp_parser.y\"\n    {\n\t\t\tif ((yyvsp[(2) - (2)].Attr_val) != NULL)\n\t\t\t\t(yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val));\n\t\t\telse\n\t\t\t\t(yyval.Queue) = (yyvsp[(1) - (2)].Queue);\n\t\t}\n    break;\n\n  case 101:\n\n/* Line 1455 of yacc.c  */\n#line 607 \"ntp_parser.y\"\n    {\n\t\t\tif ((yyvsp[(1) - (1)].Attr_val) != NULL)\n\t\t\t\t(yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val));\n\t\t\telse\n\t\t\t\t(yyval.Queue) = create_queue();\n\t\t}\n    break;\n\n  case 102:\n\n/* Line 1455 of yacc.c  */\n#line 617 \"ntp_parser.y\"\n    {\n\t\t\tif (input_from_file)\n\t\t\t\t(yyval.Attr_val) = create_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String));\n\t\t\telse {\n\t\t\t\t(yyval.Attr_val) = NULL;\n\t\t\t\tfree((yyvsp[(2) - (2)].String));\n\t\t\t\tyyerror(\"filegen file remote configuration ignored\");\n\t\t\t}\n\t\t}\n    break;\n\n  case 103:\n\n/* Line 1455 of yacc.c  */\n#line 627 \"ntp_parser.y\"\n    {\n\t\t\tif (input_from_file)\n\t\t\t\t(yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer));\n\t\t\telse {\n\t\t\t\t(yyval.Attr_val) = NULL;\n\t\t\t\tyyerror(\"filegen type remote configuration ignored\");\n\t\t\t}\n\t\t}\n    break;\n\n  case 104:\n\n/* Line 1455 of yacc.c  */\n#line 636 \"ntp_parser.y\"\n    {\n\t\t\tif (input_from_file)\n\t\t\t\t(yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer));\n\t\t\telse {\n\t\t\t\t(yyval.Attr_val) = NULL;\n\t\t\t\tyyerror(\"filegen link remote configuration ignored\");\n\t\t\t}\n\t\t}\n    break;\n\n  case 105:\n\n/* Line 1455 of yacc.c  */\n#line 645 \"ntp_parser.y\"\n    {\n\t\t\tif (input_from_file)\n\t\t\t\t(yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer));\n\t\t\telse {\n\t\t\t\t(yyval.Attr_val) = NULL;\n\t\t\t\tyyerror(\"filegen nolink remote configuration ignored\");\n\t\t\t}\n\t\t}\n    break;\n\n  case 106:\n\n/* Line 1455 of yacc.c  */\n#line 653 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 107:\n\n/* Line 1455 of yacc.c  */\n#line 654 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 115:\n\n/* Line 1455 of yacc.c  */\n#line 674 \"ntp_parser.y\"\n    {\n\t\t\tappend_queue(cfgt.discard_opts, (yyvsp[(2) - (2)].Queue));\n\t\t}\n    break;\n\n  case 116:\n\n/* Line 1455 of yacc.c  */\n#line 678 \"ntp_parser.y\"\n    {\n\t\t\tappend_queue(cfgt.mru_opts, (yyvsp[(2) - (2)].Queue));\n\t\t}\n    break;\n\n  case 117:\n\n/* Line 1455 of yacc.c  */\n#line 682 \"ntp_parser.y\"\n    {\n\t\t\tenqueue(cfgt.restrict_opts,\n\t\t\t\tcreate_restrict_node((yyvsp[(2) - (3)].Address_node), NULL, (yyvsp[(3) - (3)].Queue), ip_file->line_no));\n\t\t}\n    break;\n\n  case 118:\n\n/* Line 1455 of yacc.c  */\n#line 687 \"ntp_parser.y\"\n    {\n\t\t\tenqueue(cfgt.restrict_opts,\n\t\t\t\tcreate_restrict_node((yyvsp[(2) - (5)].Address_node), (yyvsp[(4) - (5)].Address_node), (yyvsp[(5) - (5)].Queue), ip_file->line_no));\n\t\t}\n    break;\n\n  case 119:\n\n/* Line 1455 of yacc.c  */\n#line 692 \"ntp_parser.y\"\n    {\n\t\t\tenqueue(cfgt.restrict_opts,\n\t\t\t\tcreate_restrict_node(NULL, NULL, (yyvsp[(3) - (3)].Queue), ip_file->line_no));\n\t\t}\n    break;\n\n  case 120:\n\n/* Line 1455 of yacc.c  */\n#line 697 \"ntp_parser.y\"\n    {\n\t\t\tenqueue(cfgt.restrict_opts,\n\t\t\t\tcreate_restrict_node(\n\t\t\t\t\tcreate_address_node(\n\t\t\t\t\t\testrdup(\"0.0.0.0\"), \n\t\t\t\t\t\tAF_INET),\n\t\t\t\t\tcreate_address_node(\n\t\t\t\t\t\testrdup(\"0.0.0.0\"), \n\t\t\t\t\t\tAF_INET),\n\t\t\t\t\t(yyvsp[(4) - (4)].Queue), \n\t\t\t\t\tip_file->line_no));\n\t\t}\n    break;\n\n  case 121:\n\n/* Line 1455 of yacc.c  */\n#line 710 \"ntp_parser.y\"\n    {\n\t\t\tenqueue(cfgt.restrict_opts,\n\t\t\t\tcreate_restrict_node(\n\t\t\t\t\tcreate_address_node(\n\t\t\t\t\t\testrdup(\"::\"), \n\t\t\t\t\t\tAF_INET6),\n\t\t\t\t\tcreate_address_node(\n\t\t\t\t\t\testrdup(\"::\"), \n\t\t\t\t\t\tAF_INET6),\n\t\t\t\t\t(yyvsp[(4) - (4)].Queue), \n\t\t\t\t\tip_file->line_no));\n\t\t}\n    break;\n\n  case 122:\n\n/* Line 1455 of yacc.c  */\n#line 723 \"ntp_parser.y\"\n    {\n\t\t\tenqueue(cfgt.restrict_opts,\n\t\t\t\tcreate_restrict_node(\n\t\t\t\t\tNULL, NULL,\n\t\t\t\t\tenqueue((yyvsp[(3) - (3)].Queue), create_ival((yyvsp[(2) - (3)].Integer))),\n\t\t\t\t\tip_file->line_no));\n\t\t}\n    break;\n\n  case 123:\n\n/* Line 1455 of yacc.c  */\n#line 734 \"ntp_parser.y\"\n    { (yyval.Queue) = create_queue(); }\n    break;\n\n  case 124:\n\n/* Line 1455 of yacc.c  */\n#line 736 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), create_ival((yyvsp[(2) - (2)].Integer))); }\n    break;\n\n  case 139:\n\n/* Line 1455 of yacc.c  */\n#line 758 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val)); }\n    break;\n\n  case 140:\n\n/* Line 1455 of yacc.c  */\n#line 760 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val)); }\n    break;\n\n  case 141:\n\n/* Line 1455 of yacc.c  */\n#line 764 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 142:\n\n/* Line 1455 of yacc.c  */\n#line 765 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 143:\n\n/* Line 1455 of yacc.c  */\n#line 766 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 144:\n\n/* Line 1455 of yacc.c  */\n#line 771 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val)); }\n    break;\n\n  case 145:\n\n/* Line 1455 of yacc.c  */\n#line 773 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val)); }\n    break;\n\n  case 146:\n\n/* Line 1455 of yacc.c  */\n#line 777 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 147:\n\n/* Line 1455 of yacc.c  */\n#line 778 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 148:\n\n/* Line 1455 of yacc.c  */\n#line 779 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 149:\n\n/* Line 1455 of yacc.c  */\n#line 780 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 150:\n\n/* Line 1455 of yacc.c  */\n#line 781 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 151:\n\n/* Line 1455 of yacc.c  */\n#line 782 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 152:\n\n/* Line 1455 of yacc.c  */\n#line 783 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 153:\n\n/* Line 1455 of yacc.c  */\n#line 784 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 154:\n\n/* Line 1455 of yacc.c  */\n#line 793 \"ntp_parser.y\"\n    { enqueue(cfgt.fudge, create_addr_opts_node((yyvsp[(2) - (3)].Address_node), (yyvsp[(3) - (3)].Queue))); }\n    break;\n\n  case 155:\n\n/* Line 1455 of yacc.c  */\n#line 798 \"ntp_parser.y\"\n    { enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val)); }\n    break;\n\n  case 156:\n\n/* Line 1455 of yacc.c  */\n#line 800 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val)); }\n    break;\n\n  case 157:\n\n/* Line 1455 of yacc.c  */\n#line 804 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 158:\n\n/* Line 1455 of yacc.c  */\n#line 805 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 159:\n\n/* Line 1455 of yacc.c  */\n#line 806 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 160:\n\n/* Line 1455 of yacc.c  */\n#line 807 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String)); }\n    break;\n\n  case 161:\n\n/* Line 1455 of yacc.c  */\n#line 808 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 162:\n\n/* Line 1455 of yacc.c  */\n#line 809 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 163:\n\n/* Line 1455 of yacc.c  */\n#line 810 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 164:\n\n/* Line 1455 of yacc.c  */\n#line 811 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 165:\n\n/* Line 1455 of yacc.c  */\n#line 820 \"ntp_parser.y\"\n    { append_queue(cfgt.enable_opts, (yyvsp[(2) - (2)].Queue));  }\n    break;\n\n  case 166:\n\n/* Line 1455 of yacc.c  */\n#line 822 \"ntp_parser.y\"\n    { append_queue(cfgt.disable_opts, (yyvsp[(2) - (2)].Queue));  }\n    break;\n\n  case 167:\n\n/* Line 1455 of yacc.c  */\n#line 827 \"ntp_parser.y\"\n    {\n\t\t\tif ((yyvsp[(2) - (2)].Attr_val) != NULL)\n\t\t\t\t(yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val));\n\t\t\telse\n\t\t\t\t(yyval.Queue) = (yyvsp[(1) - (2)].Queue);\n\t\t}\n    break;\n\n  case 168:\n\n/* Line 1455 of yacc.c  */\n#line 834 \"ntp_parser.y\"\n    {\n\t\t\tif ((yyvsp[(1) - (1)].Attr_val) != NULL)\n\t\t\t\t(yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val));\n\t\t\telse\n\t\t\t\t(yyval.Queue) = create_queue();\n\t\t}\n    break;\n\n  case 169:\n\n/* Line 1455 of yacc.c  */\n#line 843 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 170:\n\n/* Line 1455 of yacc.c  */\n#line 844 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 171:\n\n/* Line 1455 of yacc.c  */\n#line 845 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 172:\n\n/* Line 1455 of yacc.c  */\n#line 846 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 173:\n\n/* Line 1455 of yacc.c  */\n#line 847 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 174:\n\n/* Line 1455 of yacc.c  */\n#line 848 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 175:\n\n/* Line 1455 of yacc.c  */\n#line 850 \"ntp_parser.y\"\n    { \n\t\t\tif (input_from_file)\n\t\t\t\t(yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer));\n\t\t\telse {\n\t\t\t\t(yyval.Attr_val) = NULL;\n\t\t\t\tyyerror(\"enable/disable stats remote configuration ignored\");\n\t\t\t}\n\t\t}\n    break;\n\n  case 176:\n\n/* Line 1455 of yacc.c  */\n#line 865 \"ntp_parser.y\"\n    { append_queue(cfgt.tinker, (yyvsp[(2) - (2)].Queue)); }\n    break;\n\n  case 177:\n\n/* Line 1455 of yacc.c  */\n#line 869 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val)); }\n    break;\n\n  case 178:\n\n/* Line 1455 of yacc.c  */\n#line 870 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val)); }\n    break;\n\n  case 179:\n\n/* Line 1455 of yacc.c  */\n#line 874 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 180:\n\n/* Line 1455 of yacc.c  */\n#line 875 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 181:\n\n/* Line 1455 of yacc.c  */\n#line 876 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 182:\n\n/* Line 1455 of yacc.c  */\n#line 877 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 183:\n\n/* Line 1455 of yacc.c  */\n#line 878 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 184:\n\n/* Line 1455 of yacc.c  */\n#line 879 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 185:\n\n/* Line 1455 of yacc.c  */\n#line 880 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 187:\n\n/* Line 1455 of yacc.c  */\n#line 891 \"ntp_parser.y\"\n    {\n\t\t\tif (curr_include_level >= MAXINCLUDELEVEL) {\n\t\t\t\tfprintf(stderr, \"getconfig: Maximum include file level exceeded.\\n\");\n\t\t\t\tmsyslog(LOG_ERR, \"getconfig: Maximum include file level exceeded.\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfp[curr_include_level + 1] = F_OPEN(FindConfig((yyvsp[(2) - (3)].String)), \"r\");\n\t\t\t\tif (fp[curr_include_level + 1] == NULL) {\n\t\t\t\t\tfprintf(stderr, \"getconfig: Couldn't open <%s>\\n\", FindConfig((yyvsp[(2) - (3)].String)));\n\t\t\t\t\tmsyslog(LOG_ERR, \"getconfig: Couldn't open <%s>\", FindConfig((yyvsp[(2) - (3)].String)));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tip_file = fp[++curr_include_level];\n\t\t\t}\n\t\t}\n    break;\n\n  case 188:\n\n/* Line 1455 of yacc.c  */\n#line 907 \"ntp_parser.y\"\n    {\n\t\t\twhile (curr_include_level != -1)\n\t\t\t\tFCLOSE(fp[curr_include_level--]);\n\t\t}\n    break;\n\n  case 189:\n\n/* Line 1455 of yacc.c  */\n#line 913 \"ntp_parser.y\"\n    { enqueue(cfgt.vars, create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double))); }\n    break;\n\n  case 190:\n\n/* Line 1455 of yacc.c  */\n#line 915 \"ntp_parser.y\"\n    { enqueue(cfgt.vars, create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer))); }\n    break;\n\n  case 191:\n\n/* Line 1455 of yacc.c  */\n#line 917 \"ntp_parser.y\"\n    { enqueue(cfgt.vars, create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double))); }\n    break;\n\n  case 192:\n\n/* Line 1455 of yacc.c  */\n#line 919 \"ntp_parser.y\"\n    { /* Null action, possibly all null parms */ }\n    break;\n\n  case 193:\n\n/* Line 1455 of yacc.c  */\n#line 921 \"ntp_parser.y\"\n    { enqueue(cfgt.vars, create_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String))); }\n    break;\n\n  case 194:\n\n/* Line 1455 of yacc.c  */\n#line 924 \"ntp_parser.y\"\n    { enqueue(cfgt.vars, create_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String))); }\n    break;\n\n  case 195:\n\n/* Line 1455 of yacc.c  */\n#line 926 \"ntp_parser.y\"\n    {\n\t\t\tif (input_from_file)\n\t\t\t\tenqueue(cfgt.vars,\n\t\t\t\t\tcreate_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String)));\n\t\t\telse {\n\t\t\t\tfree((yyvsp[(2) - (2)].String));\n\t\t\t\tyyerror(\"logfile remote configuration ignored\");\n\t\t\t}\n\t\t}\n    break;\n\n  case 196:\n\n/* Line 1455 of yacc.c  */\n#line 937 \"ntp_parser.y\"\n    { append_queue(cfgt.logconfig, (yyvsp[(2) - (2)].Queue)); }\n    break;\n\n  case 197:\n\n/* Line 1455 of yacc.c  */\n#line 939 \"ntp_parser.y\"\n    { append_queue(cfgt.phone, (yyvsp[(2) - (2)].Queue)); }\n    break;\n\n  case 198:\n\n/* Line 1455 of yacc.c  */\n#line 941 \"ntp_parser.y\"\n    {\n\t\t\tif (input_from_file)\n\t\t\t\tenqueue(cfgt.vars,\n\t\t\t\t\tcreate_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String)));\n\t\t\telse {\n\t\t\t\tfree((yyvsp[(2) - (2)].String));\n\t\t\t\tyyerror(\"saveconfigdir remote configuration ignored\");\n\t\t\t}\n\t\t}\n    break;\n\n  case 199:\n\n/* Line 1455 of yacc.c  */\n#line 951 \"ntp_parser.y\"\n    { enqueue(cfgt.setvar, (yyvsp[(2) - (2)].Set_var)); }\n    break;\n\n  case 200:\n\n/* Line 1455 of yacc.c  */\n#line 953 \"ntp_parser.y\"\n    { enqueue(cfgt.trap, create_addr_opts_node((yyvsp[(2) - (2)].Address_node), NULL)); }\n    break;\n\n  case 201:\n\n/* Line 1455 of yacc.c  */\n#line 955 \"ntp_parser.y\"\n    { enqueue(cfgt.trap, create_addr_opts_node((yyvsp[(2) - (3)].Address_node), (yyvsp[(3) - (3)].Queue))); }\n    break;\n\n  case 202:\n\n/* Line 1455 of yacc.c  */\n#line 957 \"ntp_parser.y\"\n    { append_queue(cfgt.ttl, (yyvsp[(2) - (2)].Queue)); }\n    break;\n\n  case 203:\n\n/* Line 1455 of yacc.c  */\n#line 959 \"ntp_parser.y\"\n    { enqueue(cfgt.qos, create_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String))); }\n    break;\n\n  case 204:\n\n/* Line 1455 of yacc.c  */\n#line 964 \"ntp_parser.y\"\n    { enqueue(cfgt.vars, create_attr_sval(T_Driftfile, (yyvsp[(1) - (1)].String))); }\n    break;\n\n  case 205:\n\n/* Line 1455 of yacc.c  */\n#line 966 \"ntp_parser.y\"\n    { enqueue(cfgt.vars, create_attr_dval(T_WanderThreshold, (yyvsp[(2) - (2)].Double)));\n\t\t\t  enqueue(cfgt.vars, create_attr_sval(T_Driftfile, (yyvsp[(1) - (2)].String))); }\n    break;\n\n  case 206:\n\n/* Line 1455 of yacc.c  */\n#line 969 \"ntp_parser.y\"\n    { enqueue(cfgt.vars, create_attr_sval(T_Driftfile, \"\\0\")); }\n    break;\n\n  case 207:\n\n/* Line 1455 of yacc.c  */\n#line 974 \"ntp_parser.y\"\n    { (yyval.Set_var) = create_setvar_node((yyvsp[(1) - (4)].String), (yyvsp[(3) - (4)].String), (yyvsp[(4) - (4)].Integer)); }\n    break;\n\n  case 208:\n\n/* Line 1455 of yacc.c  */\n#line 976 \"ntp_parser.y\"\n    { (yyval.Set_var) = create_setvar_node((yyvsp[(1) - (3)].String), (yyvsp[(3) - (3)].String), 0); }\n    break;\n\n  case 209:\n\n/* Line 1455 of yacc.c  */\n#line 981 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val)); }\n    break;\n\n  case 210:\n\n/* Line 1455 of yacc.c  */\n#line 982 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val)); }\n    break;\n\n  case 211:\n\n/* Line 1455 of yacc.c  */\n#line 986 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 212:\n\n/* Line 1455 of yacc.c  */\n#line 987 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_pval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Address_node)); }\n    break;\n\n  case 213:\n\n/* Line 1455 of yacc.c  */\n#line 991 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val)); }\n    break;\n\n  case 214:\n\n/* Line 1455 of yacc.c  */\n#line 992 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val)); }\n    break;\n\n  case 215:\n\n /* Line 1455 of yacc.c  */\n #line 997 \"ntp_parser.y\"\n     {\n\t\t\tchar prefix = (yyvsp[(1) - (1)].String)[0];\n\t\t\tchar *type = (yyvsp[(1) - (1)].String) + 1;\n \t\t\t\n\t\t\tif (prefix != '+' && prefix != '-' && prefix != '=') {\n\t\t\t\tyyerror(\"Logconfig prefix is not '+', '-' or '='\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\t(yyval.Attr_val) = create_attr_sval(prefix, estrdup(type));\n \t\t\tYYFREE((yyvsp[(1) - (1)].String));\n \t\t}\n     break;\n \n   case 216:\n \n /* Line 1455 of yacc.c  */\n#line 1012 \"ntp_parser.y\"\n     {\n \t\t\tenqueue(cfgt.nic_rules,\n \t\t\t\tcreate_nic_rule_node((yyvsp[(3) - (3)].Integer), NULL, (yyvsp[(2) - (3)].Integer)));\n\t\t}\n    break;\n\n   case 217:\n \n /* Line 1455 of yacc.c  */\n#line 1017 \"ntp_parser.y\"\n     {\n \t\t\tenqueue(cfgt.nic_rules,\n \t\t\t\tcreate_nic_rule_node(0, (yyvsp[(3) - (3)].String), (yyvsp[(2) - (3)].Integer)));\n\t\t}\n    break;\n\n   case 227:\n \n /* Line 1455 of yacc.c  */\n#line 1048 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), create_ival((yyvsp[(2) - (2)].Integer))); }\n     break;\n \n   case 228:\n \n /* Line 1455 of yacc.c  */\n#line 1049 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue(create_ival((yyvsp[(1) - (1)].Integer))); }\n     break;\n \n   case 229:\n \n /* Line 1455 of yacc.c  */\n#line 1054 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val)); }\n     break;\n \n   case 230:\n \n /* Line 1455 of yacc.c  */\n#line 1056 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val)); }\n     break;\n \n   case 231:\n \n /* Line 1455 of yacc.c  */\n#line 1061 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_ival('i', (yyvsp[(1) - (1)].Integer)); }\n     break;\n \n   case 233:\n \n /* Line 1455 of yacc.c  */\n#line 1067 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_shorts('-', (yyvsp[(2) - (5)].Integer), (yyvsp[(4) - (5)].Integer)); }\n     break;\n \n   case 234:\n \n /* Line 1455 of yacc.c  */\n#line 1071 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), create_pval((yyvsp[(2) - (2)].String))); }\n     break;\n \n   case 235:\n \n /* Line 1455 of yacc.c  */\n#line 1072 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue(create_pval((yyvsp[(1) - (1)].String))); }\n     break;\n \n   case 236:\n \n /* Line 1455 of yacc.c  */\n#line 1076 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Address_node)); }\n     break;\n \n   case 237:\n \n /* Line 1455 of yacc.c  */\n#line 1077 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Address_node)); }\n     break;\n \n   case 238:\n \n /* Line 1455 of yacc.c  */\n#line 1082 \"ntp_parser.y\"\n     {\n \t\t\tif ((yyvsp[(1) - (1)].Integer) != 0 && (yyvsp[(1) - (1)].Integer) != 1) {\n \t\t\t\tyyerror(\"Integer value is not boolean (0 or 1). Assuming 1\");\n\t\t\t\t(yyval.Integer) = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\t(yyval.Integer) = (yyvsp[(1) - (1)].Integer);\n\t\t}\n    break;\n\n   case 239:\n \n /* Line 1455 of yacc.c  */\n#line 1090 \"ntp_parser.y\"\n     { (yyval.Integer) = 1; }\n     break;\n \n   case 240:\n \n /* Line 1455 of yacc.c  */\n#line 1091 \"ntp_parser.y\"\n     { (yyval.Integer) = 0; }\n     break;\n \n   case 241:\n \n /* Line 1455 of yacc.c  */\n#line 1095 \"ntp_parser.y\"\n     { (yyval.Double) = (double)(yyvsp[(1) - (1)].Integer); }\n     break;\n \n   case 243:\n \n /* Line 1455 of yacc.c  */\n#line 1106 \"ntp_parser.y\"\n     {\n \t\t\tcfgt.sim_details = create_sim_node((yyvsp[(3) - (5)].Queue), (yyvsp[(4) - (5)].Queue));\n \n\t\t\t/* Reset the old_config_style variable */\n\t\t\told_config_style = 1;\n\t\t}\n    break;\n\n   case 244:\n \n /* Line 1455 of yacc.c  */\n#line 1120 \"ntp_parser.y\"\n     { old_config_style = 0; }\n     break;\n \n   case 245:\n \n /* Line 1455 of yacc.c  */\n#line 1124 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (3)].Queue), (yyvsp[(2) - (3)].Attr_val)); }\n     break;\n \n   case 246:\n \n /* Line 1455 of yacc.c  */\n#line 1125 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (2)].Attr_val)); }\n     break;\n \n   case 247:\n \n /* Line 1455 of yacc.c  */\n#line 1129 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (3)].Integer), (yyvsp[(3) - (3)].Double)); }\n     break;\n \n   case 248:\n \n /* Line 1455 of yacc.c  */\n#line 1130 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (3)].Integer), (yyvsp[(3) - (3)].Double)); }\n     break;\n \n   case 249:\n \n /* Line 1455 of yacc.c  */\n#line 1134 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Sim_server)); }\n     break;\n \n   case 250:\n \n /* Line 1455 of yacc.c  */\n#line 1135 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Sim_server)); }\n     break;\n \n   case 251:\n \n /* Line 1455 of yacc.c  */\n#line 1140 \"ntp_parser.y\"\n     { (yyval.Sim_server) = create_sim_server((yyvsp[(1) - (5)].Address_node), (yyvsp[(3) - (5)].Double), (yyvsp[(4) - (5)].Queue)); }\n     break;\n \n   case 252:\n \n /* Line 1455 of yacc.c  */\n#line 1144 \"ntp_parser.y\"\n     { (yyval.Double) = (yyvsp[(3) - (4)].Double); }\n     break;\n \n   case 253:\n \n /* Line 1455 of yacc.c  */\n#line 1148 \"ntp_parser.y\"\n     { (yyval.Address_node) = (yyvsp[(3) - (3)].Address_node); }\n     break;\n \n   case 254:\n \n /* Line 1455 of yacc.c  */\n#line 1152 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Sim_script)); }\n     break;\n \n   case 255:\n \n /* Line 1455 of yacc.c  */\n#line 1153 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Sim_script)); }\n     break;\n \n   case 256:\n \n /* Line 1455 of yacc.c  */\n#line 1158 \"ntp_parser.y\"\n     { (yyval.Sim_script) = create_sim_script_info((yyvsp[(3) - (6)].Double), (yyvsp[(5) - (6)].Queue)); }\n     break;\n \n   case 257:\n \n /* Line 1455 of yacc.c  */\n#line 1162 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (3)].Queue), (yyvsp[(2) - (3)].Attr_val)); }\n     break;\n \n   case 258:\n \n /* Line 1455 of yacc.c  */\n#line 1163 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (2)].Attr_val)); }\n     break;\n \n   case 259:\n \n /* Line 1455 of yacc.c  */\n#line 1168 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (3)].Integer), (yyvsp[(3) - (3)].Double)); }\n     break;\n \n   case 260:\n \n /* Line 1455 of yacc.c  */\n#line 1170 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (3)].Integer), (yyvsp[(3) - (3)].Double)); }\n     break;\n \n   case 261:\n \n /* Line 1455 of yacc.c  */\n#line 1172 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (3)].Integer), (yyvsp[(3) - (3)].Double)); }\n     break;\n \n   case 262:\n \n /* Line 1455 of yacc.c  */\n#line 1174 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (3)].Integer), (yyvsp[(3) - (3)].Double)); }\n     break;\n \n   case 263:\n \n /* Line 1455 of yacc.c  */\n#line 1176 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (3)].Integer), (yyvsp[(3) - (3)].Double)); }\n     break;\n \n \n \n /* Line 1455 of yacc.c  */\n#line 3826 \"ntp_parser.c\"\n       default: break;\n     }\n   YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now `shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n\n  yyn = yyr1[yyn];\n\n  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;\n  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)\n    yystate = yytable[yystate];\n  else\n    yystate = yydefgoto[yyn - YYNTOKENS];\n\n  goto yynewstate;\n\n\n/*------------------------------------.\n| yyerrlab -- here on detecting error |\n`------------------------------------*/\nyyerrlab:\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (YY_(\"syntax error\"));\n#else\n      {\n\tYYSIZE_T yysize = yysyntax_error (0, yystate, yychar);\n\tif (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)\n\t  {\n\t    YYSIZE_T yyalloc = 2 * yysize;\n\t    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))\n\t      yyalloc = YYSTACK_ALLOC_MAXIMUM;\n\t    if (yymsg != yymsgbuf)\n\t      YYSTACK_FREE (yymsg);\n\t    yymsg = (char *) YYSTACK_ALLOC (yyalloc);\n\t    if (yymsg)\n\t      yymsg_alloc = yyalloc;\n\t    else\n\t      {\n\t\tyymsg = yymsgbuf;\n\t\tyymsg_alloc = sizeof yymsgbuf;\n\t      }\n\t  }\n\n\tif (0 < yysize && yysize <= yymsg_alloc)\n\t  {\n\t    (void) yysyntax_error (yymsg, yystate, yychar);\n\t    yyerror (yymsg);\n\t  }\n\telse\n\t  {\n\t    yyerror (YY_(\"syntax error\"));\n\t    if (yysize != 0)\n\t      goto yyexhaustedlab;\n\t  }\n      }\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n\t error, discard it.  */\n\n      if (yychar <= YYEOF)\n\t{\n\t  /* Return failure if at end of input.  */\n\t  if (yychar == YYEOF)\n\t    YYABORT;\n\t}\n      else\n\t{\n\t  yydestruct (\"Error: discarding\",\n\t\t      yytoken, &yylval);\n\t  yychar = YYEMPTY;\n\t}\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n\n  /* Pacify compilers like GCC when the user code never invokes\n     YYERROR and the label yyerrorlab therefore never appears in user\n     code.  */\n  if (/*CONSTCOND*/ 0)\n     goto yyerrorlab;\n\n  /* Do not reclaim the symbols of the rule which action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;\t/* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (yyn != YYPACT_NINF)\n\t{\n\t  yyn += YYTERROR;\n\t  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n\t    {\n\t      yyn = yytable[yyn];\n\t      if (0 < yyn)\n\t\tbreak;\n\t    }\n\t}\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n\tYYABORT;\n\n\n      yydestruct (\"Error: popping\",\n\t\t  yystos[yystate], yyvsp);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  *++yyvsp = yylval;\n\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n#if !defined(yyoverflow) || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\nyyreturn:\n  if (yychar != YYEMPTY)\n     yydestruct (\"Cleanup: discarding lookahead\",\n\t\t yytoken, &yylval);\n  /* Do not reclaim the symbols of the rule which action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n\t\t  yystos[*yyssp], yyvsp);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n#endif\n  /* Make sure YYID is used.  */\n  return YYID (yyresult);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144429,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "yyparse (void *YYPARSE_PARAM)\n#else\nint\nyyparse (YYPARSE_PARAM)\n    void *YYPARSE_PARAM;\n#endif\n#else /* ! YYPARSE_PARAM */\n#if (defined __STDC__ || defined __C99__FUNC__ \\\n     || defined __cplusplus || defined _MSC_VER)\nint\nyyparse (void)\n#else\nint\nyyparse ()\n\n#endif\n#endif\n{\n\n\n    int yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       `yyss': related to states.\n       `yyvs': related to semantic values.\n\n       Refer to the stacks thru separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yytype_int16 yyssa[YYINITDEPTH];\n    yytype_int16 *yyss;\n    yytype_int16 *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYSIZE_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yytoken = 0;\n  yyss = yyssa;\n  yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n\n  /* Initialize stack pointers.\n     Waste one element of value and location stack\n     so that they stay on the same level as the state stack.\n     The wasted elements are never initialized.  */\n  yyssp = yyss;\n  yyvsp = yyvs;\n\n  goto yysetstate;\n\n/*------------------------------------------------------------.\n| yynewstate -- Push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\n yynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n yysetstate:\n  *yyssp = yystate;\n\n  if (yyss + yystacksize - 1 <= yyssp)\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYSIZE_T yysize = yyssp - yyss + 1;\n\n#ifdef yyoverflow\n      {\n\t/* Give user a chance to reallocate the stack.  Use copies of\n\t   these so that the &'s don't force the real ones into\n\t   memory.  */\n\tYYSTYPE *yyvs1 = yyvs;\n\tyytype_int16 *yyss1 = yyss;\n\n\t/* Each stack pointer address is followed by the size of the\n\t   data in use in that stack, in bytes.  This used to be a\n\t   conditional around just the two extra args, but that might\n\t   be undefined if yyoverflow is a macro.  */\n\tyyoverflow (YY_(\"memory exhausted\"),\n\t\t    &yyss1, yysize * sizeof (*yyssp),\n\t\t    &yyvs1, yysize * sizeof (*yyvsp),\n\t\t    &yystacksize);\n\n\tyyss = yyss1;\n\tyyvs = yyvs1;\n      }\n#else /* no yyoverflow */\n# ifndef YYSTACK_RELOCATE\n      goto yyexhaustedlab;\n# else\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n\tgoto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n\tyystacksize = YYMAXDEPTH;\n\n      {\n\tyytype_int16 *yyss1 = yyss;\n\tunion yyalloc *yyptr =\n\t  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\n\tif (! yyptr)\n\t  goto yyexhaustedlab;\n\tYYSTACK_RELOCATE (yyss_alloc, yyss);\n\tYYSTACK_RELOCATE (yyvs_alloc, yyvs);\n#  undef YYSTACK_RELOCATE\n\tif (yyss1 != yyssa)\n\t  YYSTACK_FREE (yyss1);\n      }\n# endif\n#endif /* no yyoverflow */\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n\t\t  (unsigned long int) yystacksize));\n\n      if (yyss + yystacksize - 1 <= yyssp)\n\tYYABORT;\n    }\n\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yyn == YYPACT_NINF)\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = YYLEX;\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yyn == 0 || yyn == YYTABLE_NINF)\n\tgoto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n\n  yystate = yyn;\n  *++yyvsp = yylval;\n\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- Do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     `$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n        case 5:\n\n/* Line 1455 of yacc.c  */\n#line 320 \"ntp_parser.y\"\n    {\n\t\t\t/* I will need to incorporate much more fine grained\n\t\t\t * error messages. The following should suffice for\n\t\t\t * the time being.\n\t\t\t */\n\t\t\tmsyslog(LOG_ERR, \n\t\t\t\t\"syntax error in %s line %d, column %d\",\n\t\t\t\tip_file->fname,\n\t\t\t\tip_file->err_line_no,\n\t\t\t\tip_file->err_col_no);\n\t\t}\n    break;\n\n  case 19:\n\n/* Line 1455 of yacc.c  */\n#line 354 \"ntp_parser.y\"\n    {\n\t\t\tstruct peer_node *my_node =  create_peer_node((yyvsp[(1) - (3)].Integer), (yyvsp[(2) - (3)].Address_node), (yyvsp[(3) - (3)].Queue));\n\t\t\tif (my_node)\n\t\t\t\tenqueue(cfgt.peers, my_node);\n\t\t}\n    break;\n\n  case 20:\n\n/* Line 1455 of yacc.c  */\n#line 360 \"ntp_parser.y\"\n    {\n\t\t\tstruct peer_node *my_node = create_peer_node((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Address_node), NULL);\n\t\t\tif (my_node)\n\t\t\t\tenqueue(cfgt.peers, my_node);\n\t\t}\n    break;\n\n  case 27:\n\n/* Line 1455 of yacc.c  */\n#line 377 \"ntp_parser.y\"\n    { (yyval.Address_node) = create_address_node((yyvsp[(2) - (2)].String), AF_INET); }\n    break;\n\n  case 28:\n\n/* Line 1455 of yacc.c  */\n#line 378 \"ntp_parser.y\"\n    { (yyval.Address_node) = create_address_node((yyvsp[(2) - (2)].String), AF_INET6); }\n    break;\n\n  case 29:\n\n/* Line 1455 of yacc.c  */\n#line 382 \"ntp_parser.y\"\n    { (yyval.Address_node) = create_address_node((yyvsp[(1) - (1)].String), 0); }\n    break;\n\n  case 30:\n\n/* Line 1455 of yacc.c  */\n#line 386 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val)); }\n    break;\n\n  case 31:\n\n/* Line 1455 of yacc.c  */\n#line 387 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val)); }\n    break;\n\n  case 32:\n\n/* Line 1455 of yacc.c  */\n#line 391 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 33:\n\n/* Line 1455 of yacc.c  */\n#line 392 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 34:\n\n/* Line 1455 of yacc.c  */\n#line 393 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 35:\n\n/* Line 1455 of yacc.c  */\n#line 394 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 36:\n\n/* Line 1455 of yacc.c  */\n#line 395 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 37:\n\n/* Line 1455 of yacc.c  */\n#line 396 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 38:\n\n/* Line 1455 of yacc.c  */\n#line 397 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 39:\n\n/* Line 1455 of yacc.c  */\n#line 398 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 40:\n\n/* Line 1455 of yacc.c  */\n#line 399 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 41:\n\n/* Line 1455 of yacc.c  */\n#line 400 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 42:\n\n/* Line 1455 of yacc.c  */\n#line 401 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 43:\n\n/* Line 1455 of yacc.c  */\n#line 402 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 44:\n\n/* Line 1455 of yacc.c  */\n#line 403 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 45:\n\n/* Line 1455 of yacc.c  */\n#line 404 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 46:\n\n/* Line 1455 of yacc.c  */\n#line 405 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 47:\n\n/* Line 1455 of yacc.c  */\n#line 415 \"ntp_parser.y\"\n    {\n\t\t\tstruct unpeer_node *my_node = create_unpeer_node((yyvsp[(2) - (2)].Address_node));\n\t\t\tif (my_node)\n\t\t\t\tenqueue(cfgt.unpeers, my_node);\n\t\t}\n    break;\n\n  case 50:\n\n/* Line 1455 of yacc.c  */\n#line 434 \"ntp_parser.y\"\n    { cfgt.broadcastclient = 1; }\n    break;\n\n  case 51:\n\n/* Line 1455 of yacc.c  */\n#line 436 \"ntp_parser.y\"\n    { append_queue(cfgt.manycastserver, (yyvsp[(2) - (2)].Queue)); }\n    break;\n\n  case 52:\n\n/* Line 1455 of yacc.c  */\n#line 438 \"ntp_parser.y\"\n    { append_queue(cfgt.multicastclient, (yyvsp[(2) - (2)].Queue)); }\n    break;\n\n  case 53:\n\n/* Line 1455 of yacc.c  */\n#line 449 \"ntp_parser.y\"\n    { enqueue(cfgt.vars, create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer))); }\n    break;\n\n  case 54:\n\n/* Line 1455 of yacc.c  */\n#line 451 \"ntp_parser.y\"\n    { cfgt.auth.control_key = (yyvsp[(2) - (2)].Integer); }\n    break;\n\n  case 55:\n\n/* Line 1455 of yacc.c  */\n#line 453 \"ntp_parser.y\"\n    { \n\t\t\tcfgt.auth.cryptosw++;\n\t\t\tappend_queue(cfgt.auth.crypto_cmd_list, (yyvsp[(2) - (2)].Queue));\n\t\t}\n    break;\n\n  case 56:\n\n/* Line 1455 of yacc.c  */\n#line 458 \"ntp_parser.y\"\n    { cfgt.auth.keys = (yyvsp[(2) - (2)].String); }\n    break;\n\n  case 57:\n\n/* Line 1455 of yacc.c  */\n#line 460 \"ntp_parser.y\"\n    { cfgt.auth.keysdir = (yyvsp[(2) - (2)].String); }\n    break;\n\n  case 58:\n\n/* Line 1455 of yacc.c  */\n#line 462 \"ntp_parser.y\"\n    { cfgt.auth.request_key = (yyvsp[(2) - (2)].Integer); }\n    break;\n\n  case 59:\n\n/* Line 1455 of yacc.c  */\n#line 464 \"ntp_parser.y\"\n    { cfgt.auth.revoke = (yyvsp[(2) - (2)].Integer); }\n    break;\n\n  case 60:\n\n/* Line 1455 of yacc.c  */\n#line 466 \"ntp_parser.y\"\n    { cfgt.auth.trusted_key_list = (yyvsp[(2) - (2)].Queue); }\n    break;\n\n  case 61:\n\n/* Line 1455 of yacc.c  */\n#line 468 \"ntp_parser.y\"\n    { cfgt.auth.ntp_signd_socket = (yyvsp[(2) - (2)].String); }\n    break;\n\n  case 63:\n\n/* Line 1455 of yacc.c  */\n#line 474 \"ntp_parser.y\"\n    { (yyval.Queue) = create_queue(); }\n    break;\n\n  case 64:\n\n/* Line 1455 of yacc.c  */\n#line 479 \"ntp_parser.y\"\n    { \n\t\t\tif ((yyvsp[(2) - (2)].Attr_val) != NULL)\n\t\t\t\t(yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val));\n\t\t\telse\n\t\t\t\t(yyval.Queue) = (yyvsp[(1) - (2)].Queue);\n\t\t}\n    break;\n\n  case 65:\n\n/* Line 1455 of yacc.c  */\n#line 486 \"ntp_parser.y\"\n    {\n\t\t\tif ((yyvsp[(1) - (1)].Attr_val) != NULL)\n\t\t\t\t(yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val));\n\t\t\telse\n\t\t\t\t(yyval.Queue) = create_queue();\n\t\t}\n    break;\n\n  case 66:\n\n/* Line 1455 of yacc.c  */\n#line 496 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String)); }\n    break;\n\n  case 67:\n\n/* Line 1455 of yacc.c  */\n#line 498 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String)); }\n    break;\n\n  case 68:\n\n/* Line 1455 of yacc.c  */\n#line 500 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String)); }\n    break;\n\n  case 69:\n\n/* Line 1455 of yacc.c  */\n#line 502 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String)); }\n    break;\n\n  case 70:\n\n/* Line 1455 of yacc.c  */\n#line 504 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String)); }\n    break;\n\n  case 71:\n\n/* Line 1455 of yacc.c  */\n#line 506 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String)); }\n    break;\n\n  case 72:\n\n/* Line 1455 of yacc.c  */\n#line 508 \"ntp_parser.y\"\n    {\n\t\t\t(yyval.Attr_val) = NULL;\n\t\t\tcfgt.auth.revoke = (yyvsp[(2) - (2)].Integer);\n\t\t\tmsyslog(LOG_WARNING,\n\t\t\t\t\"'crypto revoke %d' is deprecated, \"\n\t\t\t\t\"please use 'revoke %d' instead.\",\n\t\t\t\tcfgt.auth.revoke, cfgt.auth.revoke);\n\t\t}\n    break;\n\n  case 73:\n\n/* Line 1455 of yacc.c  */\n#line 525 \"ntp_parser.y\"\n    { append_queue(cfgt.orphan_cmds,(yyvsp[(2) - (2)].Queue)); }\n    break;\n\n  case 74:\n\n/* Line 1455 of yacc.c  */\n#line 529 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val)); }\n    break;\n\n  case 75:\n\n/* Line 1455 of yacc.c  */\n#line 530 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val)); }\n    break;\n\n  case 76:\n\n/* Line 1455 of yacc.c  */\n#line 535 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (double)(yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 77:\n\n/* Line 1455 of yacc.c  */\n#line 537 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (double)(yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 78:\n\n/* Line 1455 of yacc.c  */\n#line 539 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (double)(yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 79:\n\n/* Line 1455 of yacc.c  */\n#line 541 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (double)(yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 80:\n\n/* Line 1455 of yacc.c  */\n#line 543 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (double)(yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 81:\n\n/* Line 1455 of yacc.c  */\n#line 545 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 82:\n\n/* Line 1455 of yacc.c  */\n#line 547 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 83:\n\n/* Line 1455 of yacc.c  */\n#line 549 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 84:\n\n/* Line 1455 of yacc.c  */\n#line 551 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 85:\n\n/* Line 1455 of yacc.c  */\n#line 553 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (double)(yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 86:\n\n/* Line 1455 of yacc.c  */\n#line 555 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (double)(yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 87:\n\n/* Line 1455 of yacc.c  */\n#line 565 \"ntp_parser.y\"\n    { append_queue(cfgt.stats_list, (yyvsp[(2) - (2)].Queue)); }\n    break;\n\n  case 88:\n\n/* Line 1455 of yacc.c  */\n#line 567 \"ntp_parser.y\"\n    {\n\t\t\tif (input_from_file)\n\t\t\t\tcfgt.stats_dir = (yyvsp[(2) - (2)].String);\n\t\t\telse {\n\t\t\t\tfree((yyvsp[(2) - (2)].String));\n\t\t\t\tyyerror(\"statsdir remote configuration ignored\");\n\t\t\t}\n\t\t}\n    break;\n\n  case 89:\n\n/* Line 1455 of yacc.c  */\n#line 576 \"ntp_parser.y\"\n    {\n\t\t\tenqueue(cfgt.filegen_opts,\n\t\t\t\tcreate_filegen_node((yyvsp[(2) - (3)].Integer), (yyvsp[(3) - (3)].Queue)));\n\t\t}\n    break;\n\n  case 90:\n\n/* Line 1455 of yacc.c  */\n#line 583 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), create_ival((yyvsp[(2) - (2)].Integer))); }\n    break;\n\n  case 91:\n\n/* Line 1455 of yacc.c  */\n#line 584 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue_in_new_queue(create_ival((yyvsp[(1) - (1)].Integer))); }\n    break;\n\n  case 100:\n\n/* Line 1455 of yacc.c  */\n#line 600 \"ntp_parser.y\"\n    {\n\t\t\tif ((yyvsp[(2) - (2)].Attr_val) != NULL)\n\t\t\t\t(yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val));\n\t\t\telse\n\t\t\t\t(yyval.Queue) = (yyvsp[(1) - (2)].Queue);\n\t\t}\n    break;\n\n  case 101:\n\n/* Line 1455 of yacc.c  */\n#line 607 \"ntp_parser.y\"\n    {\n\t\t\tif ((yyvsp[(1) - (1)].Attr_val) != NULL)\n\t\t\t\t(yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val));\n\t\t\telse\n\t\t\t\t(yyval.Queue) = create_queue();\n\t\t}\n    break;\n\n  case 102:\n\n/* Line 1455 of yacc.c  */\n#line 617 \"ntp_parser.y\"\n    {\n\t\t\tif (input_from_file)\n\t\t\t\t(yyval.Attr_val) = create_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String));\n\t\t\telse {\n\t\t\t\t(yyval.Attr_val) = NULL;\n\t\t\t\tfree((yyvsp[(2) - (2)].String));\n\t\t\t\tyyerror(\"filegen file remote configuration ignored\");\n\t\t\t}\n\t\t}\n    break;\n\n  case 103:\n\n/* Line 1455 of yacc.c  */\n#line 627 \"ntp_parser.y\"\n    {\n\t\t\tif (input_from_file)\n\t\t\t\t(yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer));\n\t\t\telse {\n\t\t\t\t(yyval.Attr_val) = NULL;\n\t\t\t\tyyerror(\"filegen type remote configuration ignored\");\n\t\t\t}\n\t\t}\n    break;\n\n  case 104:\n\n/* Line 1455 of yacc.c  */\n#line 636 \"ntp_parser.y\"\n    {\n\t\t\tif (input_from_file)\n\t\t\t\t(yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer));\n\t\t\telse {\n\t\t\t\t(yyval.Attr_val) = NULL;\n\t\t\t\tyyerror(\"filegen link remote configuration ignored\");\n\t\t\t}\n\t\t}\n    break;\n\n  case 105:\n\n/* Line 1455 of yacc.c  */\n#line 645 \"ntp_parser.y\"\n    {\n\t\t\tif (input_from_file)\n\t\t\t\t(yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer));\n\t\t\telse {\n\t\t\t\t(yyval.Attr_val) = NULL;\n\t\t\t\tyyerror(\"filegen nolink remote configuration ignored\");\n\t\t\t}\n\t\t}\n    break;\n\n  case 106:\n\n/* Line 1455 of yacc.c  */\n#line 653 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 107:\n\n/* Line 1455 of yacc.c  */\n#line 654 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 115:\n\n/* Line 1455 of yacc.c  */\n#line 674 \"ntp_parser.y\"\n    {\n\t\t\tappend_queue(cfgt.discard_opts, (yyvsp[(2) - (2)].Queue));\n\t\t}\n    break;\n\n  case 116:\n\n/* Line 1455 of yacc.c  */\n#line 678 \"ntp_parser.y\"\n    {\n\t\t\tappend_queue(cfgt.mru_opts, (yyvsp[(2) - (2)].Queue));\n\t\t}\n    break;\n\n  case 117:\n\n/* Line 1455 of yacc.c  */\n#line 682 \"ntp_parser.y\"\n    {\n\t\t\tenqueue(cfgt.restrict_opts,\n\t\t\t\tcreate_restrict_node((yyvsp[(2) - (3)].Address_node), NULL, (yyvsp[(3) - (3)].Queue), ip_file->line_no));\n\t\t}\n    break;\n\n  case 118:\n\n/* Line 1455 of yacc.c  */\n#line 687 \"ntp_parser.y\"\n    {\n\t\t\tenqueue(cfgt.restrict_opts,\n\t\t\t\tcreate_restrict_node((yyvsp[(2) - (5)].Address_node), (yyvsp[(4) - (5)].Address_node), (yyvsp[(5) - (5)].Queue), ip_file->line_no));\n\t\t}\n    break;\n\n  case 119:\n\n/* Line 1455 of yacc.c  */\n#line 692 \"ntp_parser.y\"\n    {\n\t\t\tenqueue(cfgt.restrict_opts,\n\t\t\t\tcreate_restrict_node(NULL, NULL, (yyvsp[(3) - (3)].Queue), ip_file->line_no));\n\t\t}\n    break;\n\n  case 120:\n\n/* Line 1455 of yacc.c  */\n#line 697 \"ntp_parser.y\"\n    {\n\t\t\tenqueue(cfgt.restrict_opts,\n\t\t\t\tcreate_restrict_node(\n\t\t\t\t\tcreate_address_node(\n\t\t\t\t\t\testrdup(\"0.0.0.0\"), \n\t\t\t\t\t\tAF_INET),\n\t\t\t\t\tcreate_address_node(\n\t\t\t\t\t\testrdup(\"0.0.0.0\"), \n\t\t\t\t\t\tAF_INET),\n\t\t\t\t\t(yyvsp[(4) - (4)].Queue), \n\t\t\t\t\tip_file->line_no));\n\t\t}\n    break;\n\n  case 121:\n\n/* Line 1455 of yacc.c  */\n#line 710 \"ntp_parser.y\"\n    {\n\t\t\tenqueue(cfgt.restrict_opts,\n\t\t\t\tcreate_restrict_node(\n\t\t\t\t\tcreate_address_node(\n\t\t\t\t\t\testrdup(\"::\"), \n\t\t\t\t\t\tAF_INET6),\n\t\t\t\t\tcreate_address_node(\n\t\t\t\t\t\testrdup(\"::\"), \n\t\t\t\t\t\tAF_INET6),\n\t\t\t\t\t(yyvsp[(4) - (4)].Queue), \n\t\t\t\t\tip_file->line_no));\n\t\t}\n    break;\n\n  case 122:\n\n/* Line 1455 of yacc.c  */\n#line 723 \"ntp_parser.y\"\n    {\n\t\t\tenqueue(cfgt.restrict_opts,\n\t\t\t\tcreate_restrict_node(\n\t\t\t\t\tNULL, NULL,\n\t\t\t\t\tenqueue((yyvsp[(3) - (3)].Queue), create_ival((yyvsp[(2) - (3)].Integer))),\n\t\t\t\t\tip_file->line_no));\n\t\t}\n    break;\n\n  case 123:\n\n/* Line 1455 of yacc.c  */\n#line 734 \"ntp_parser.y\"\n    { (yyval.Queue) = create_queue(); }\n    break;\n\n  case 124:\n\n/* Line 1455 of yacc.c  */\n#line 736 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), create_ival((yyvsp[(2) - (2)].Integer))); }\n    break;\n\n  case 139:\n\n/* Line 1455 of yacc.c  */\n#line 758 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val)); }\n    break;\n\n  case 140:\n\n/* Line 1455 of yacc.c  */\n#line 760 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val)); }\n    break;\n\n  case 141:\n\n/* Line 1455 of yacc.c  */\n#line 764 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 142:\n\n/* Line 1455 of yacc.c  */\n#line 765 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 143:\n\n/* Line 1455 of yacc.c  */\n#line 766 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 144:\n\n/* Line 1455 of yacc.c  */\n#line 771 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val)); }\n    break;\n\n  case 145:\n\n/* Line 1455 of yacc.c  */\n#line 773 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val)); }\n    break;\n\n  case 146:\n\n/* Line 1455 of yacc.c  */\n#line 777 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 147:\n\n/* Line 1455 of yacc.c  */\n#line 778 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 148:\n\n/* Line 1455 of yacc.c  */\n#line 779 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 149:\n\n/* Line 1455 of yacc.c  */\n#line 780 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 150:\n\n/* Line 1455 of yacc.c  */\n#line 781 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 151:\n\n/* Line 1455 of yacc.c  */\n#line 782 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 152:\n\n/* Line 1455 of yacc.c  */\n#line 783 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 153:\n\n/* Line 1455 of yacc.c  */\n#line 784 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 154:\n\n/* Line 1455 of yacc.c  */\n#line 793 \"ntp_parser.y\"\n    { enqueue(cfgt.fudge, create_addr_opts_node((yyvsp[(2) - (3)].Address_node), (yyvsp[(3) - (3)].Queue))); }\n    break;\n\n  case 155:\n\n/* Line 1455 of yacc.c  */\n#line 798 \"ntp_parser.y\"\n    { enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val)); }\n    break;\n\n  case 156:\n\n/* Line 1455 of yacc.c  */\n#line 800 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val)); }\n    break;\n\n  case 157:\n\n/* Line 1455 of yacc.c  */\n#line 804 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 158:\n\n/* Line 1455 of yacc.c  */\n#line 805 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 159:\n\n/* Line 1455 of yacc.c  */\n#line 806 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 160:\n\n/* Line 1455 of yacc.c  */\n#line 807 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String)); }\n    break;\n\n  case 161:\n\n/* Line 1455 of yacc.c  */\n#line 808 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 162:\n\n/* Line 1455 of yacc.c  */\n#line 809 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 163:\n\n/* Line 1455 of yacc.c  */\n#line 810 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 164:\n\n/* Line 1455 of yacc.c  */\n#line 811 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 165:\n\n/* Line 1455 of yacc.c  */\n#line 820 \"ntp_parser.y\"\n    { append_queue(cfgt.enable_opts, (yyvsp[(2) - (2)].Queue));  }\n    break;\n\n  case 166:\n\n/* Line 1455 of yacc.c  */\n#line 822 \"ntp_parser.y\"\n    { append_queue(cfgt.disable_opts, (yyvsp[(2) - (2)].Queue));  }\n    break;\n\n  case 167:\n\n/* Line 1455 of yacc.c  */\n#line 827 \"ntp_parser.y\"\n    {\n\t\t\tif ((yyvsp[(2) - (2)].Attr_val) != NULL)\n\t\t\t\t(yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val));\n\t\t\telse\n\t\t\t\t(yyval.Queue) = (yyvsp[(1) - (2)].Queue);\n\t\t}\n    break;\n\n  case 168:\n\n/* Line 1455 of yacc.c  */\n#line 834 \"ntp_parser.y\"\n    {\n\t\t\tif ((yyvsp[(1) - (1)].Attr_val) != NULL)\n\t\t\t\t(yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val));\n\t\t\telse\n\t\t\t\t(yyval.Queue) = create_queue();\n\t\t}\n    break;\n\n  case 169:\n\n/* Line 1455 of yacc.c  */\n#line 843 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 170:\n\n/* Line 1455 of yacc.c  */\n#line 844 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 171:\n\n/* Line 1455 of yacc.c  */\n#line 845 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 172:\n\n/* Line 1455 of yacc.c  */\n#line 846 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 173:\n\n/* Line 1455 of yacc.c  */\n#line 847 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 174:\n\n/* Line 1455 of yacc.c  */\n#line 848 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer)); }\n    break;\n\n  case 175:\n\n/* Line 1455 of yacc.c  */\n#line 850 \"ntp_parser.y\"\n    { \n\t\t\tif (input_from_file)\n\t\t\t\t(yyval.Attr_val) = create_attr_ival(T_Flag, (yyvsp[(1) - (1)].Integer));\n\t\t\telse {\n\t\t\t\t(yyval.Attr_val) = NULL;\n\t\t\t\tyyerror(\"enable/disable stats remote configuration ignored\");\n\t\t\t}\n\t\t}\n    break;\n\n  case 176:\n\n/* Line 1455 of yacc.c  */\n#line 865 \"ntp_parser.y\"\n    { append_queue(cfgt.tinker, (yyvsp[(2) - (2)].Queue)); }\n    break;\n\n  case 177:\n\n/* Line 1455 of yacc.c  */\n#line 869 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val)); }\n    break;\n\n  case 178:\n\n/* Line 1455 of yacc.c  */\n#line 870 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val)); }\n    break;\n\n  case 179:\n\n/* Line 1455 of yacc.c  */\n#line 874 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 180:\n\n/* Line 1455 of yacc.c  */\n#line 875 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 181:\n\n/* Line 1455 of yacc.c  */\n#line 876 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 182:\n\n/* Line 1455 of yacc.c  */\n#line 877 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 183:\n\n/* Line 1455 of yacc.c  */\n#line 878 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 184:\n\n/* Line 1455 of yacc.c  */\n#line 879 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 185:\n\n/* Line 1455 of yacc.c  */\n#line 880 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double)); }\n    break;\n\n  case 187:\n\n/* Line 1455 of yacc.c  */\n#line 891 \"ntp_parser.y\"\n    {\n\t\t\tif (curr_include_level >= MAXINCLUDELEVEL) {\n\t\t\t\tfprintf(stderr, \"getconfig: Maximum include file level exceeded.\\n\");\n\t\t\t\tmsyslog(LOG_ERR, \"getconfig: Maximum include file level exceeded.\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfp[curr_include_level + 1] = F_OPEN(FindConfig((yyvsp[(2) - (3)].String)), \"r\");\n\t\t\t\tif (fp[curr_include_level + 1] == NULL) {\n\t\t\t\t\tfprintf(stderr, \"getconfig: Couldn't open <%s>\\n\", FindConfig((yyvsp[(2) - (3)].String)));\n\t\t\t\t\tmsyslog(LOG_ERR, \"getconfig: Couldn't open <%s>\", FindConfig((yyvsp[(2) - (3)].String)));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tip_file = fp[++curr_include_level];\n\t\t\t}\n\t\t}\n    break;\n\n  case 188:\n\n/* Line 1455 of yacc.c  */\n#line 907 \"ntp_parser.y\"\n    {\n\t\t\twhile (curr_include_level != -1)\n\t\t\t\tFCLOSE(fp[curr_include_level--]);\n\t\t}\n    break;\n\n  case 189:\n\n/* Line 1455 of yacc.c  */\n#line 913 \"ntp_parser.y\"\n    { enqueue(cfgt.vars, create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double))); }\n    break;\n\n  case 190:\n\n/* Line 1455 of yacc.c  */\n#line 915 \"ntp_parser.y\"\n    { enqueue(cfgt.vars, create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer))); }\n    break;\n\n  case 191:\n\n/* Line 1455 of yacc.c  */\n#line 917 \"ntp_parser.y\"\n    { enqueue(cfgt.vars, create_attr_dval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Double))); }\n    break;\n\n  case 192:\n\n/* Line 1455 of yacc.c  */\n#line 919 \"ntp_parser.y\"\n    { /* Null action, possibly all null parms */ }\n    break;\n\n  case 193:\n\n/* Line 1455 of yacc.c  */\n#line 921 \"ntp_parser.y\"\n    { enqueue(cfgt.vars, create_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String))); }\n    break;\n\n  case 194:\n\n/* Line 1455 of yacc.c  */\n#line 924 \"ntp_parser.y\"\n    { enqueue(cfgt.vars, create_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String))); }\n    break;\n\n  case 195:\n\n/* Line 1455 of yacc.c  */\n#line 926 \"ntp_parser.y\"\n    {\n\t\t\tif (input_from_file)\n\t\t\t\tenqueue(cfgt.vars,\n\t\t\t\t\tcreate_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String)));\n\t\t\telse {\n\t\t\t\tfree((yyvsp[(2) - (2)].String));\n\t\t\t\tyyerror(\"logfile remote configuration ignored\");\n\t\t\t}\n\t\t}\n    break;\n\n  case 196:\n\n/* Line 1455 of yacc.c  */\n#line 937 \"ntp_parser.y\"\n    { append_queue(cfgt.logconfig, (yyvsp[(2) - (2)].Queue)); }\n    break;\n\n  case 197:\n\n/* Line 1455 of yacc.c  */\n#line 939 \"ntp_parser.y\"\n    { append_queue(cfgt.phone, (yyvsp[(2) - (2)].Queue)); }\n    break;\n\n  case 198:\n\n/* Line 1455 of yacc.c  */\n#line 941 \"ntp_parser.y\"\n    {\n\t\t\tif (input_from_file)\n\t\t\t\tenqueue(cfgt.vars,\n\t\t\t\t\tcreate_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String)));\n\t\t\telse {\n\t\t\t\tfree((yyvsp[(2) - (2)].String));\n\t\t\t\tyyerror(\"saveconfigdir remote configuration ignored\");\n\t\t\t}\n\t\t}\n    break;\n\n  case 199:\n\n/* Line 1455 of yacc.c  */\n#line 951 \"ntp_parser.y\"\n    { enqueue(cfgt.setvar, (yyvsp[(2) - (2)].Set_var)); }\n    break;\n\n  case 200:\n\n/* Line 1455 of yacc.c  */\n#line 953 \"ntp_parser.y\"\n    { enqueue(cfgt.trap, create_addr_opts_node((yyvsp[(2) - (2)].Address_node), NULL)); }\n    break;\n\n  case 201:\n\n/* Line 1455 of yacc.c  */\n#line 955 \"ntp_parser.y\"\n    { enqueue(cfgt.trap, create_addr_opts_node((yyvsp[(2) - (3)].Address_node), (yyvsp[(3) - (3)].Queue))); }\n    break;\n\n  case 202:\n\n/* Line 1455 of yacc.c  */\n#line 957 \"ntp_parser.y\"\n    { append_queue(cfgt.ttl, (yyvsp[(2) - (2)].Queue)); }\n    break;\n\n  case 203:\n\n/* Line 1455 of yacc.c  */\n#line 959 \"ntp_parser.y\"\n    { enqueue(cfgt.qos, create_attr_sval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].String))); }\n    break;\n\n  case 204:\n\n/* Line 1455 of yacc.c  */\n#line 964 \"ntp_parser.y\"\n    { enqueue(cfgt.vars, create_attr_sval(T_Driftfile, (yyvsp[(1) - (1)].String))); }\n    break;\n\n  case 205:\n\n/* Line 1455 of yacc.c  */\n#line 966 \"ntp_parser.y\"\n    { enqueue(cfgt.vars, create_attr_dval(T_WanderThreshold, (yyvsp[(2) - (2)].Double)));\n\t\t\t  enqueue(cfgt.vars, create_attr_sval(T_Driftfile, (yyvsp[(1) - (2)].String))); }\n    break;\n\n  case 206:\n\n/* Line 1455 of yacc.c  */\n#line 969 \"ntp_parser.y\"\n    { enqueue(cfgt.vars, create_attr_sval(T_Driftfile, \"\\0\")); }\n    break;\n\n  case 207:\n\n/* Line 1455 of yacc.c  */\n#line 974 \"ntp_parser.y\"\n    { (yyval.Set_var) = create_setvar_node((yyvsp[(1) - (4)].String), (yyvsp[(3) - (4)].String), (yyvsp[(4) - (4)].Integer)); }\n    break;\n\n  case 208:\n\n/* Line 1455 of yacc.c  */\n#line 976 \"ntp_parser.y\"\n    { (yyval.Set_var) = create_setvar_node((yyvsp[(1) - (3)].String), (yyvsp[(3) - (3)].String), 0); }\n    break;\n\n  case 209:\n\n/* Line 1455 of yacc.c  */\n#line 981 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val)); }\n    break;\n\n  case 210:\n\n/* Line 1455 of yacc.c  */\n#line 982 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val)); }\n    break;\n\n  case 211:\n\n/* Line 1455 of yacc.c  */\n#line 986 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_ival((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Integer)); }\n    break;\n\n  case 212:\n\n/* Line 1455 of yacc.c  */\n#line 987 \"ntp_parser.y\"\n    { (yyval.Attr_val) = create_attr_pval((yyvsp[(1) - (2)].Integer), (yyvsp[(2) - (2)].Address_node)); }\n    break;\n\n  case 213:\n\n/* Line 1455 of yacc.c  */\n#line 991 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val)); }\n    break;\n\n  case 214:\n\n/* Line 1455 of yacc.c  */\n#line 992 \"ntp_parser.y\"\n    { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val)); }\n    break;\n\n  case 215:\n\n /* Line 1455 of yacc.c  */\n #line 997 \"ntp_parser.y\"\n     {\n\t\t\tchar\tprefix;\n\t\t\tchar *\ttype;\n \t\t\t\n\t\t\tswitch ((yyvsp[(1) - (1)].String)[0]) {\n\t\t\t\n\t\t\tcase '+':\n\t\t\tcase '-':\n\t\t\tcase '=':\n\t\t\t\tprefix = (yyvsp[(1) - (1)].String)[0];\n\t\t\t\ttype = (yyvsp[(1) - (1)].String) + 1;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\tprefix = '=';\n\t\t\t\ttype = (yyvsp[(1) - (1)].String);\n\t\t\t}\t\n\t\t\t\n\t\t\t(yyval.Attr_val) = create_attr_sval(prefix, estrdup(type));\n \t\t\tYYFREE((yyvsp[(1) - (1)].String));\n \t\t}\n     break;\n \n   case 216:\n \n /* Line 1455 of yacc.c  */\n#line 1022 \"ntp_parser.y\"\n     {\n \t\t\tenqueue(cfgt.nic_rules,\n \t\t\t\tcreate_nic_rule_node((yyvsp[(3) - (3)].Integer), NULL, (yyvsp[(2) - (3)].Integer)));\n\t\t}\n    break;\n\n   case 217:\n \n /* Line 1455 of yacc.c  */\n#line 1027 \"ntp_parser.y\"\n     {\n \t\t\tenqueue(cfgt.nic_rules,\n \t\t\t\tcreate_nic_rule_node(0, (yyvsp[(3) - (3)].String), (yyvsp[(2) - (3)].Integer)));\n\t\t}\n    break;\n\n   case 227:\n \n /* Line 1455 of yacc.c  */\n#line 1058 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), create_ival((yyvsp[(2) - (2)].Integer))); }\n     break;\n \n   case 228:\n \n /* Line 1455 of yacc.c  */\n#line 1059 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue(create_ival((yyvsp[(1) - (1)].Integer))); }\n     break;\n \n   case 229:\n \n /* Line 1455 of yacc.c  */\n#line 1064 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val)); }\n     break;\n \n   case 230:\n \n /* Line 1455 of yacc.c  */\n#line 1066 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val)); }\n     break;\n \n   case 231:\n \n /* Line 1455 of yacc.c  */\n#line 1071 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_ival('i', (yyvsp[(1) - (1)].Integer)); }\n     break;\n \n   case 233:\n \n /* Line 1455 of yacc.c  */\n#line 1077 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_shorts('-', (yyvsp[(2) - (5)].Integer), (yyvsp[(4) - (5)].Integer)); }\n     break;\n \n   case 234:\n \n /* Line 1455 of yacc.c  */\n#line 1081 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), create_pval((yyvsp[(2) - (2)].String))); }\n     break;\n \n   case 235:\n \n /* Line 1455 of yacc.c  */\n#line 1082 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue(create_pval((yyvsp[(1) - (1)].String))); }\n     break;\n \n   case 236:\n \n /* Line 1455 of yacc.c  */\n#line 1086 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Address_node)); }\n     break;\n \n   case 237:\n \n /* Line 1455 of yacc.c  */\n#line 1087 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Address_node)); }\n     break;\n \n   case 238:\n \n /* Line 1455 of yacc.c  */\n#line 1092 \"ntp_parser.y\"\n     {\n \t\t\tif ((yyvsp[(1) - (1)].Integer) != 0 && (yyvsp[(1) - (1)].Integer) != 1) {\n \t\t\t\tyyerror(\"Integer value is not boolean (0 or 1). Assuming 1\");\n\t\t\t\t(yyval.Integer) = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\t(yyval.Integer) = (yyvsp[(1) - (1)].Integer);\n\t\t}\n    break;\n\n   case 239:\n \n /* Line 1455 of yacc.c  */\n#line 1100 \"ntp_parser.y\"\n     { (yyval.Integer) = 1; }\n     break;\n \n   case 240:\n \n /* Line 1455 of yacc.c  */\n#line 1101 \"ntp_parser.y\"\n     { (yyval.Integer) = 0; }\n     break;\n \n   case 241:\n \n /* Line 1455 of yacc.c  */\n#line 1105 \"ntp_parser.y\"\n     { (yyval.Double) = (double)(yyvsp[(1) - (1)].Integer); }\n     break;\n \n   case 243:\n \n /* Line 1455 of yacc.c  */\n#line 1116 \"ntp_parser.y\"\n     {\n \t\t\tcfgt.sim_details = create_sim_node((yyvsp[(3) - (5)].Queue), (yyvsp[(4) - (5)].Queue));\n \n\t\t\t/* Reset the old_config_style variable */\n\t\t\told_config_style = 1;\n\t\t}\n    break;\n\n   case 244:\n \n /* Line 1455 of yacc.c  */\n#line 1130 \"ntp_parser.y\"\n     { old_config_style = 0; }\n     break;\n \n   case 245:\n \n /* Line 1455 of yacc.c  */\n#line 1134 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (3)].Queue), (yyvsp[(2) - (3)].Attr_val)); }\n     break;\n \n   case 246:\n \n /* Line 1455 of yacc.c  */\n#line 1135 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (2)].Attr_val)); }\n     break;\n \n   case 247:\n \n /* Line 1455 of yacc.c  */\n#line 1139 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (3)].Integer), (yyvsp[(3) - (3)].Double)); }\n     break;\n \n   case 248:\n \n /* Line 1455 of yacc.c  */\n#line 1140 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (3)].Integer), (yyvsp[(3) - (3)].Double)); }\n     break;\n \n   case 249:\n \n /* Line 1455 of yacc.c  */\n#line 1144 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Sim_server)); }\n     break;\n \n   case 250:\n \n /* Line 1455 of yacc.c  */\n#line 1145 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Sim_server)); }\n     break;\n \n   case 251:\n \n /* Line 1455 of yacc.c  */\n#line 1150 \"ntp_parser.y\"\n     { (yyval.Sim_server) = create_sim_server((yyvsp[(1) - (5)].Address_node), (yyvsp[(3) - (5)].Double), (yyvsp[(4) - (5)].Queue)); }\n     break;\n \n   case 252:\n \n /* Line 1455 of yacc.c  */\n#line 1154 \"ntp_parser.y\"\n     { (yyval.Double) = (yyvsp[(3) - (4)].Double); }\n     break;\n \n   case 253:\n \n /* Line 1455 of yacc.c  */\n#line 1158 \"ntp_parser.y\"\n     { (yyval.Address_node) = (yyvsp[(3) - (3)].Address_node); }\n     break;\n \n   case 254:\n \n /* Line 1455 of yacc.c  */\n#line 1162 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Sim_script)); }\n     break;\n \n   case 255:\n \n /* Line 1455 of yacc.c  */\n#line 1163 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Sim_script)); }\n     break;\n \n   case 256:\n \n /* Line 1455 of yacc.c  */\n#line 1168 \"ntp_parser.y\"\n     { (yyval.Sim_script) = create_sim_script_info((yyvsp[(3) - (6)].Double), (yyvsp[(5) - (6)].Queue)); }\n     break;\n \n   case 257:\n \n /* Line 1455 of yacc.c  */\n#line 1172 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (3)].Queue), (yyvsp[(2) - (3)].Attr_val)); }\n     break;\n \n   case 258:\n \n /* Line 1455 of yacc.c  */\n#line 1173 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (2)].Attr_val)); }\n     break;\n \n   case 259:\n \n /* Line 1455 of yacc.c  */\n#line 1178 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (3)].Integer), (yyvsp[(3) - (3)].Double)); }\n     break;\n \n   case 260:\n \n /* Line 1455 of yacc.c  */\n#line 1180 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (3)].Integer), (yyvsp[(3) - (3)].Double)); }\n     break;\n \n   case 261:\n \n /* Line 1455 of yacc.c  */\n#line 1182 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (3)].Integer), (yyvsp[(3) - (3)].Double)); }\n     break;\n \n   case 262:\n \n /* Line 1455 of yacc.c  */\n#line 1184 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (3)].Integer), (yyvsp[(3) - (3)].Double)); }\n     break;\n \n   case 263:\n \n /* Line 1455 of yacc.c  */\n#line 1186 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (3)].Integer), (yyvsp[(3) - (3)].Double)); }\n     break;\n \n \n \n /* Line 1455 of yacc.c  */\n#line 3836 \"ntp_parser.c\"\n       default: break;\n     }\n   YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now `shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n\n  yyn = yyr1[yyn];\n\n  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;\n  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)\n    yystate = yytable[yystate];\n  else\n    yystate = yydefgoto[yyn - YYNTOKENS];\n\n  goto yynewstate;\n\n\n/*------------------------------------.\n| yyerrlab -- here on detecting error |\n`------------------------------------*/\nyyerrlab:\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (YY_(\"syntax error\"));\n#else\n      {\n\tYYSIZE_T yysize = yysyntax_error (0, yystate, yychar);\n\tif (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)\n\t  {\n\t    YYSIZE_T yyalloc = 2 * yysize;\n\t    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))\n\t      yyalloc = YYSTACK_ALLOC_MAXIMUM;\n\t    if (yymsg != yymsgbuf)\n\t      YYSTACK_FREE (yymsg);\n\t    yymsg = (char *) YYSTACK_ALLOC (yyalloc);\n\t    if (yymsg)\n\t      yymsg_alloc = yyalloc;\n\t    else\n\t      {\n\t\tyymsg = yymsgbuf;\n\t\tyymsg_alloc = sizeof yymsgbuf;\n\t      }\n\t  }\n\n\tif (0 < yysize && yysize <= yymsg_alloc)\n\t  {\n\t    (void) yysyntax_error (yymsg, yystate, yychar);\n\t    yyerror (yymsg);\n\t  }\n\telse\n\t  {\n\t    yyerror (YY_(\"syntax error\"));\n\t    if (yysize != 0)\n\t      goto yyexhaustedlab;\n\t  }\n      }\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n\t error, discard it.  */\n\n      if (yychar <= YYEOF)\n\t{\n\t  /* Return failure if at end of input.  */\n\t  if (yychar == YYEOF)\n\t    YYABORT;\n\t}\n      else\n\t{\n\t  yydestruct (\"Error: discarding\",\n\t\t      yytoken, &yylval);\n\t  yychar = YYEMPTY;\n\t}\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n\n  /* Pacify compilers like GCC when the user code never invokes\n     YYERROR and the label yyerrorlab therefore never appears in user\n     code.  */\n  if (/*CONSTCOND*/ 0)\n     goto yyerrorlab;\n\n  /* Do not reclaim the symbols of the rule which action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;\t/* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (yyn != YYPACT_NINF)\n\t{\n\t  yyn += YYTERROR;\n\t  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n\t    {\n\t      yyn = yytable[yyn];\n\t      if (0 < yyn)\n\t\tbreak;\n\t    }\n\t}\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n\tYYABORT;\n\n\n      yydestruct (\"Error: popping\",\n\t\t  yystos[yystate], yyvsp);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  *++yyvsp = yylval;\n\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n#if !defined(yyoverflow) || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\nyyreturn:\n  if (yychar != YYEMPTY)\n     yydestruct (\"Cleanup: discarding lookahead\",\n\t\t yytoken, &yylval);\n  /* Do not reclaim the symbols of the rule which action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n\t\t  yystos[*yyssp], yyvsp);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n#endif\n  /* Make sure YYID is used.  */\n  return YYID (yyresult);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144430,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int net_get(int s, void *arg, int *len)\n{\n\tstruct net_hdr nh;\n\tint plen;\n\n\tif (net_read_exact(s, &nh, sizeof(nh)) == -1)\n        {\n\t\treturn -1;\n        }\n\n\tplen = ntohl(nh.nh_len);\n \tif (!(plen <= *len))\n \t\tprintf(\"PLEN %d type %d len %d\\n\",\n \t\t\tplen, nh.nh_type, *len);\n\tassert(plen <= *len); /* XXX */\n \n \t*len = plen;\n \tif ((*len) && (net_read_exact(s, arg, *len) == -1))\n        {\n            return -1;\n        }\n\n\treturn nh.nh_type;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144433,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int net_get(int s, void *arg, int *len)\n{\n\tstruct net_hdr nh;\n\tint plen;\n\n\tif (net_read_exact(s, &nh, sizeof(nh)) == -1)\n        {\n\t\treturn -1;\n        }\n\n\tplen = ntohl(nh.nh_len);\n \tif (!(plen <= *len))\n \t\tprintf(\"PLEN %d type %d len %d\\n\",\n \t\t\tplen, nh.nh_type, *len);\n\tassert(plen <= *len && plen > 0); /* XXX */\n \n \t*len = plen;\n \tif ((*len) && (net_read_exact(s, arg, *len) == -1))\n        {\n            return -1;\n        }\n\n\treturn nh.nh_type;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144434,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int handle(int s, unsigned char* data, int len, struct sockaddr_in *s_in)\n{\n\tchar buf[2048];\n\tunsigned short *cmd = (unsigned short *)buf;\n\tint plen;\n\tstruct in_addr *addr = &s_in->sin_addr;\n\tunsigned short *pid = (unsigned short*) data;\n\n\t/* inet check */\n\tif (len == S_HELLO_LEN && memcmp(data, \"sorbo\", 5) == 0) {\n\t\tunsigned short *id = (unsigned short*) (data+5);\n\t\tint x = 2+4+2;\n\n\t\t*cmd = htons(S_CMD_INET_CHECK);\n\t\tmemcpy(cmd+1, addr, 4);\n\t\tmemcpy(cmd+1+2, id, 2);\n\n\t\tprintf(\"Inet check by %s %d\\n\",\n\t\t       inet_ntoa(*addr), ntohs(*id));\n\t\tif (send(s, buf, x, 0) != x)\n\t\t\treturn 1;\n\n\t\treturn 0;\n\t}\n\n \t*cmd++ = htons(S_CMD_PACKET);\n \t*cmd++ = *pid;\n \tplen = len - 2;\n \n \tlast_id = ntohs(*pid);\n \tif (last_id > 20000)\n\t\twrap = 1;\n\tif (wrap && last_id < 100) {\n\t\twrap = 0;\n\t\tmemset(ids, 0, sizeof(ids));\n\t}\n\n\tprintf(\"Got packet %d %d\", last_id, plen);\n\tif (is_dup(last_id)) {\n\t\tprintf(\" (DUP)\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"\\n\");\n\n\t*cmd++ = htons(plen);\n\tmemcpy(cmd, data+2, plen);\n\n\tplen += 2 + 2 + 2;\n\tassert(plen <= (int) sizeof(buf));\n\tif (send(s, buf, plen, 0) != plen)\n\t\treturn 1;\n\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144435,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int handle(int s, unsigned char* data, int len, struct sockaddr_in *s_in)\n{\n\tchar buf[2048];\n\tunsigned short *cmd = (unsigned short *)buf;\n\tint plen;\n\tstruct in_addr *addr = &s_in->sin_addr;\n\tunsigned short *pid = (unsigned short*) data;\n\n\t/* inet check */\n\tif (len == S_HELLO_LEN && memcmp(data, \"sorbo\", 5) == 0) {\n\t\tunsigned short *id = (unsigned short*) (data+5);\n\t\tint x = 2+4+2;\n\n\t\t*cmd = htons(S_CMD_INET_CHECK);\n\t\tmemcpy(cmd+1, addr, 4);\n\t\tmemcpy(cmd+1+2, id, 2);\n\n\t\tprintf(\"Inet check by %s %d\\n\",\n\t\t       inet_ntoa(*addr), ntohs(*id));\n\t\tif (send(s, buf, x, 0) != x)\n\t\t\treturn 1;\n\n\t\treturn 0;\n\t}\n\n \t*cmd++ = htons(S_CMD_PACKET);\n \t*cmd++ = *pid;\n \tplen = len - 2;\n    if (plen < 0)\n        return 0;\n \n \tlast_id = ntohs(*pid);\n \tif (last_id > 20000)\n\t\twrap = 1;\n\tif (wrap && last_id < 100) {\n\t\twrap = 0;\n\t\tmemset(ids, 0, sizeof(ids));\n\t}\n\n\tprintf(\"Got packet %d %d\", last_id, plen);\n\tif (is_dup(last_id)) {\n\t\tprintf(\" (DUP)\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"\\n\");\n\n\t*cmd++ = htons(plen);\n\tmemcpy(cmd, data+2, plen);\n\n\tplen += 2 + 2 + 2;\n\tassert(plen <= (int) sizeof(buf));\n\tif (send(s, buf, plen, 0) != plen)\n\t\treturn 1;\n\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144436,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "gimp_write_and_read_file (Gimp     *gimp,\n                          gboolean  with_unusual_stuff,\n                          gboolean  compat_paths,\n                          gboolean  use_gimp_2_8_features)\n{\n   GimpImage           *image;\n   GimpImage           *loaded_image;\n   GimpPlugInProcedure *proc;\n  gchar               *filename;\n   GFile               *file;\n \n   /* Create the image */\n  image = gimp_create_mainimage (gimp,\n                                 with_unusual_stuff,\n                                 compat_paths,\n                                 use_gimp_2_8_features);\n\n  /* Assert valid state */\n  gimp_assert_mainimage (image,\n                         with_unusual_stuff,\n                         compat_paths,\n                          use_gimp_2_8_features);\n \n   /* Write to file */\n  filename = g_build_filename (g_get_tmp_dir (), \"gimp-test.xcf\", NULL);\n   file = g_file_new_for_path (filename);\n   g_free (filename);\n \n  proc = gimp_plug_in_manager_file_procedure_find (image->gimp->plug_in_manager,\n                                                   GIMP_FILE_PROCEDURE_GROUP_SAVE,\n                                                   file,\n                                                   NULL /*error*/);\n  file_save (gimp,\n             image,\n             NULL /*progress*/,\n             file,\n             proc,\n             GIMP_RUN_NONINTERACTIVE,\n             FALSE /*change_saved_state*/,\n             FALSE /*export_backward*/,\n             FALSE /*export_forward*/,\n             NULL /*error*/);\n\n  /* Load from file */\n  loaded_image = gimp_test_load_image (image->gimp, file);\n\n  /* Assert on the loaded file. If success, it means that there is no\n   * significant information loss when we wrote the image to a file\n   * and loaded it again\n   */\n  gimp_assert_mainimage (loaded_image,\n                         with_unusual_stuff,\n                         compat_paths,\n                         use_gimp_2_8_features);\n\n  g_file_delete (file, NULL, NULL);\n  g_object_unref (file);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144439,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "gimp_write_and_read_file (Gimp     *gimp,\n                          gboolean  with_unusual_stuff,\n                          gboolean  compat_paths,\n                          gboolean  use_gimp_2_8_features)\n{\n   GimpImage           *image;\n   GimpImage           *loaded_image;\n   GimpPlugInProcedure *proc;\n  gchar               *filename = NULL;\n  gint                 file_handle;\n   GFile               *file;\n \n   /* Create the image */\n  image = gimp_create_mainimage (gimp,\n                                 with_unusual_stuff,\n                                 compat_paths,\n                                 use_gimp_2_8_features);\n\n  /* Assert valid state */\n  gimp_assert_mainimage (image,\n                         with_unusual_stuff,\n                         compat_paths,\n                          use_gimp_2_8_features);\n \n   /* Write to file */\n  file_handle = g_file_open_tmp (\"gimp-test-XXXXXX.xcf\", &filename, NULL);\n  g_assert (file_handle != -1);\n  close (file_handle);\n   file = g_file_new_for_path (filename);\n   g_free (filename);\n \n  proc = gimp_plug_in_manager_file_procedure_find (image->gimp->plug_in_manager,\n                                                   GIMP_FILE_PROCEDURE_GROUP_SAVE,\n                                                   file,\n                                                   NULL /*error*/);\n  file_save (gimp,\n             image,\n             NULL /*progress*/,\n             file,\n             proc,\n             GIMP_RUN_NONINTERACTIVE,\n             FALSE /*change_saved_state*/,\n             FALSE /*export_backward*/,\n             FALSE /*export_forward*/,\n             NULL /*error*/);\n\n  /* Load from file */\n  loaded_image = gimp_test_load_image (image->gimp, file);\n\n  /* Assert on the loaded file. If success, it means that there is no\n   * significant information loss when we wrote the image to a file\n   * and loaded it again\n   */\n  gimp_assert_mainimage (loaded_image,\n                         with_unusual_stuff,\n                         compat_paths,\n                         use_gimp_2_8_features);\n\n  g_file_delete (file, NULL, NULL);\n  g_object_unref (file);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144440,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n \t\t\t\t       size_t len)\n {\n \tuaddr_t a;\n \tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n \t\t\t       CORE_MMU_USER_PARAM_SIZE);\n \n\tif (ADD_OVERFLOW(uaddr, len, &a))\n \t\treturn TEE_ERROR_ACCESS_DENIED;\n \n \tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t/*\n\t * Rely on TA private memory test to check if address range is private\n\t * to TA or not.\n\t */\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n \t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n \t\treturn TEE_ERROR_ACCESS_DENIED;\n \n\tfor (a = uaddr; a < (uaddr + len); a += addr_incr) {\n \t\tuint32_t attr;\n \t\tTEE_Result res;\n \n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_SECURE) &&\n\t\t    !(attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144457,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n \t\t\t\t       size_t len)\n {\n \tuaddr_t a;\n\tuaddr_t end_addr = 0;\n \tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n \t\t\t       CORE_MMU_USER_PARAM_SIZE);\n \n\tif (ADD_OVERFLOW(uaddr, len, &end_addr))\n \t\treturn TEE_ERROR_ACCESS_DENIED;\n \n \tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t/*\n\t * Rely on TA private memory test to check if address range is private\n\t * to TA or not.\n\t */\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n \t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n \t\treturn TEE_ERROR_ACCESS_DENIED;\n \n\tfor (a = ROUNDDOWN(uaddr, addr_incr); a < end_addr; a += addr_incr) {\n \t\tuint32_t attr;\n \t\tTEE_Result res;\n \n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_SECURE) &&\n\t\t    !(attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144458,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int DecodeTeredo(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n    if (!g_teredo_enabled)\n        return TM_ECODE_FAILED;\n\n    uint8_t *start = pkt;\n\n    /* Is this packet to short to contain an IPv6 packet ? */\n    if (len < IPV6_HEADER_LEN)\n        return TM_ECODE_FAILED;\n\n    /* Teredo encapsulate IPv6 in UDP and can add some custom message\n     * part before the IPv6 packet. In our case, we just want to get\n     * over an ORIGIN indication. So we just make one offset if needed. */\n    if (start[0] == 0x0) {\n        switch (start[1]) {\n            /* origin indication: compatible with tunnel */\n            case 0x0:\n                /* offset is coherent with len and presence of an IPv6 header */\n                if (len >= TEREDO_ORIG_INDICATION_LENGTH + IPV6_HEADER_LEN)\n                    start += TEREDO_ORIG_INDICATION_LENGTH;\n                else\n                    return TM_ECODE_FAILED;\n                break;\n            /* authentication: negotiation not real tunnel */\n            case 0x1:\n                return TM_ECODE_FAILED;\n            /* this case is not possible in Teredo: not that protocol */\n            default:\n                return TM_ECODE_FAILED;\n        }\n    }\n\n    /* There is no specific field that we can check to prove that the packet\n     * is a Teredo packet. We've zapped here all the possible Teredo header\n     * and we should have an IPv6 packet at the start pointer.\n     * We then can only do two checks before sending the encapsulated packets\n     * to decoding:\n     *  - The packet has a protocol version which is IPv6.\n     *  - The IPv6 length of the packet matches what remains in buffer.\n     */\n    if (IP_GET_RAW_VER(start) == 6) {\n        IPV6Hdr *thdr = (IPV6Hdr *)start;\n        if (len ==  IPV6_HEADER_LEN +\n                IPV6_GET_RAW_PLEN(thdr) + (start - pkt)) {\n            if (pq != NULL) {\n                int blen = len - (start - pkt);\n                /* spawn off tunnel packet */\n                Packet *tp = PacketTunnelPktSetup(tv, dtv, p, start, blen,\n                                                  DECODE_TUNNEL_IPV6, pq);\n                if (tp != NULL) {\n                    PKT_SET_SRC(tp, PKT_SRC_DECODER_TEREDO);\n                    /* add the tp to the packet queue. */\n                    PacketEnqueue(pq,tp);\n                    StatsIncr(tv, dtv->counter_teredo);\n                    return TM_ECODE_OK;\n                }\n            }\n        }\n        return TM_ECODE_FAILED;\n    }\n\n    return TM_ECODE_FAILED;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144487,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int DecodeTeredo(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n    if (!g_teredo_enabled)\n        return TM_ECODE_FAILED;\n\n    uint8_t *start = pkt;\n\n    /* Is this packet to short to contain an IPv6 packet ? */\n    if (len < IPV6_HEADER_LEN)\n        return TM_ECODE_FAILED;\n\n    /* Teredo encapsulate IPv6 in UDP and can add some custom message\n     * part before the IPv6 packet. In our case, we just want to get\n     * over an ORIGIN indication. So we just make one offset if needed. */\n    if (start[0] == 0x0) {\n        switch (start[1]) {\n            /* origin indication: compatible with tunnel */\n            case 0x0:\n                /* offset is coherent with len and presence of an IPv6 header */\n                if (len >= TEREDO_ORIG_INDICATION_LENGTH + IPV6_HEADER_LEN)\n                    start += TEREDO_ORIG_INDICATION_LENGTH;\n                else\n                    return TM_ECODE_FAILED;\n                break;\n            /* authentication: negotiation not real tunnel */\n            case 0x1:\n                return TM_ECODE_FAILED;\n            /* this case is not possible in Teredo: not that protocol */\n            default:\n                return TM_ECODE_FAILED;\n        }\n    }\n\n     /* There is no specific field that we can check to prove that the packet\n      * is a Teredo packet. We've zapped here all the possible Teredo header\n      * and we should have an IPv6 packet at the start pointer.\n     * We then can only do a few checks before sending the encapsulated packets\n      * to decoding:\n      *  - The packet has a protocol version which is IPv6.\n      *  - The IPv6 length of the packet matches what remains in buffer.\n     *  - HLIM is 0. This would technically be valid, but still weird.\n     *  - NH 0 (HOP) and not enough data.\n     *\n     *  If all these conditions are met, the tunnel decoder will be called.\n     *  If the packet gets an invalid event set, it will still be rejected.\n      */\n     if (IP_GET_RAW_VER(start) == 6) {\n         IPV6Hdr *thdr = (IPV6Hdr *)start;\n\n        /* ignore hoplimit 0 packets, most likely an artifact of bad detection */\n        if (IPV6_GET_RAW_HLIM(thdr) == 0)\n            return TM_ECODE_FAILED;\n\n        /* if nh is 0 (HOP) with little data we have a bogus packet */\n        if (IPV6_GET_RAW_NH(thdr) == 0 && IPV6_GET_RAW_PLEN(thdr) < 8)\n            return TM_ECODE_FAILED;\n\n         if (len ==  IPV6_HEADER_LEN +\n                 IPV6_GET_RAW_PLEN(thdr) + (start - pkt)) {\n             if (pq != NULL) {\n                 int blen = len - (start - pkt);\n                 /* spawn off tunnel packet */\n                 Packet *tp = PacketTunnelPktSetup(tv, dtv, p, start, blen,\n                                                  DECODE_TUNNEL_IPV6_TEREDO, pq);\n                 if (tp != NULL) {\n                     PKT_SET_SRC(tp, PKT_SRC_DECODER_TEREDO);\n                     /* add the tp to the packet queue. */\n                    PacketEnqueue(pq,tp);\n                    StatsIncr(tv, dtv->counter_teredo);\n                    return TM_ECODE_OK;\n                }\n            }\n        }\n        return TM_ECODE_FAILED;\n    }\n\n    return TM_ECODE_FAILED;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144488,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n    SCEnter();\n\n    uint8_t *orig_pkt = pkt;\n    uint8_t nh = 0; /* careful, 0 is actually a real type */\n    uint16_t hdrextlen = 0;\n    uint16_t plen;\n    char dstopts = 0;\n    char exthdr_fh_done = 0;\n    int hh = 0;\n    int rh = 0;\n    int eh = 0;\n    int ah = 0;\n\n    nh = IPV6_GET_NH(p);\n    plen = len;\n\n    while(1)\n    {\n        /* No upper layer, but we do have data. Suspicious. */\n        if (nh == IPPROTO_NONE && plen > 0) {\n            ENGINE_SET_EVENT(p, IPV6_DATA_AFTER_NONE_HEADER);\n            SCReturn;\n        }\n\n        if (plen < 2) { /* minimal needed in a hdr */\n            SCReturn;\n        }\n\n        switch(nh)\n        {\n            case IPPROTO_TCP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeTCP(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_UDP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeUDP(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_ICMPV6:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeICMPV6(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_SCTP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeSCTP(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_ROUTING:\n                IPV6_SET_L4PROTO(p,nh);\n                hdrextlen = 8 + (*(pkt+1) * 8);  /* 8 bytes + length in 8 octet units */\n\n                SCLogDebug(\"hdrextlen %\"PRIu8, hdrextlen);\n\n                if (hdrextlen > plen) {\n                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                if (rh) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_RH);\n                    /* skip past this extension so we can continue parsing the rest\n                     * of the packet */\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                rh = 1;\n                IPV6_EXTHDR_SET_RH(p);\n\n                uint8_t ip6rh_type = *(pkt + 2);\n                if (ip6rh_type == 0) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_RH_TYPE_0);\n                }\n                p->ip6eh.rh_type = ip6rh_type;\n\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n\n            case IPPROTO_HOPOPTS:\n            case IPPROTO_DSTOPTS:\n            {\n                IPV6OptHAO hao_s, *hao = &hao_s;\n                IPV6OptRA ra_s, *ra = &ra_s;\n                IPV6OptJumbo jumbo_s, *jumbo = &jumbo_s;\n                uint16_t optslen = 0;\n\n                IPV6_SET_L4PROTO(p,nh);\n                hdrextlen =  (*(pkt+1) + 1) << 3;\n                if (hdrextlen > plen) {\n                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                uint8_t *ptr = pkt + 2; /* +2 to go past nxthdr and len */\n\n                /* point the pointers to right structures\n                 * in Packet. */\n                if (nh == IPPROTO_HOPOPTS) {\n                    if (hh) {\n                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_HH);\n                        /* skip past this extension so we can continue parsing the rest\n                         * of the packet */\n                        nh = *pkt;\n                        pkt += hdrextlen;\n                        plen -= hdrextlen;\n                        break;\n                    }\n\n                    hh = 1;\n\n                    optslen = ((*(pkt + 1) + 1 ) << 3) - 2;\n                }\n                else if (nh == IPPROTO_DSTOPTS)\n                {\n                    if (dstopts == 0) {\n                        optslen = ((*(pkt + 1) + 1 ) << 3) - 2;\n                        dstopts = 1;\n                    } else if (dstopts == 1) {\n                        optslen = ((*(pkt + 1) + 1 ) << 3) - 2;\n                        dstopts = 2;\n                    } else {\n                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_DH);\n                        /* skip past this extension so we can continue parsing the rest\n                         * of the packet */\n                        nh = *pkt;\n                        pkt += hdrextlen;\n                        plen -= hdrextlen;\n                        break;\n                    }\n                }\n\n                if (optslen > plen) {\n                    /* since the packet is long enough (we checked\n                     * plen against hdrlen, the optlen must be malformed. */\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                    /* skip past this extension so we can continue parsing the rest\n                     * of the packet */\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n/** \\todo move into own function to loaded on demand */\n                uint16_t padn_cnt = 0;\n                uint16_t other_cnt = 0;\n                uint16_t offset = 0;\n                while(offset < optslen)\n                {\n                    if (*ptr == IPV6OPT_PAD1)\n                    {\n                        padn_cnt++;\n                        offset++;\n                        ptr++;\n                        continue;\n                    }\n\n                    if (offset + 1 >= optslen) {\n                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                        break;\n                    }\n\n                    /* length field for each opt */\n                    uint8_t ip6_optlen = *(ptr + 1);\n\n                    /* see if the optlen from the packet fits the total optslen */\n                    if ((offset + 1 + ip6_optlen) > optslen) {\n                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                        break;\n                    }\n\n                    if (*ptr == IPV6OPT_PADN) /* PadN */\n                    {\n                        //printf(\"PadN option\\n\");\n                        padn_cnt++;\n\n                        /* a zero padN len would be weird */\n                        if (ip6_optlen == 0)\n                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_ZERO_LEN_PADN);\n                    }\n                    else if (*ptr == IPV6OPT_RA) /* RA */\n                    {\n                        ra->ip6ra_type = *(ptr);\n                        ra->ip6ra_len  = ip6_optlen;\n\n                        if (ip6_optlen < sizeof(ra->ip6ra_value)) {\n                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                            break;\n                        }\n\n                        memcpy(&ra->ip6ra_value, (ptr + 2), sizeof(ra->ip6ra_value));\n                        ra->ip6ra_value = SCNtohs(ra->ip6ra_value);\n                        //printf(\"RA option: type %\" PRIu32 \" len %\" PRIu32 \" value %\" PRIu32 \"\\n\",\n                        //    ra->ip6ra_type, ra->ip6ra_len, ra->ip6ra_value);\n                        other_cnt++;\n                    }\n                    else if (*ptr == IPV6OPT_JUMBO) /* Jumbo */\n                    {\n                        jumbo->ip6j_type = *(ptr);\n                        jumbo->ip6j_len  = ip6_optlen;\n\n                        if (ip6_optlen < sizeof(jumbo->ip6j_payload_len)) {\n                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                            break;\n                        }\n\n                        memcpy(&jumbo->ip6j_payload_len, (ptr+2), sizeof(jumbo->ip6j_payload_len));\n                        jumbo->ip6j_payload_len = SCNtohl(jumbo->ip6j_payload_len);\n                        //printf(\"Jumbo option: type %\" PRIu32 \" len %\" PRIu32 \" payload len %\" PRIu32 \"\\n\",\n                        //    jumbo->ip6j_type, jumbo->ip6j_len, jumbo->ip6j_payload_len);\n                    }\n                    else if (*ptr == IPV6OPT_HAO) /* HAO */\n                    {\n                        hao->ip6hao_type = *(ptr);\n                        hao->ip6hao_len  = ip6_optlen;\n\n                        if (ip6_optlen < sizeof(hao->ip6hao_hoa)) {\n                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                            break;\n                        }\n\n                        memcpy(&hao->ip6hao_hoa, (ptr+2), sizeof(hao->ip6hao_hoa));\n                        //printf(\"HAO option: type %\" PRIu32 \" len %\" PRIu32 \" \",\n                        //    hao->ip6hao_type, hao->ip6hao_len);\n                        //char addr_buf[46];\n                        //PrintInet(AF_INET6, (char *)&(hao->ip6hao_hoa),\n                        //    addr_buf,sizeof(addr_buf));\n                        //printf(\"home addr %s\\n\", addr_buf);\n                        other_cnt++;\n                    } else {\n                        if (nh == IPPROTO_HOPOPTS)\n                            ENGINE_SET_EVENT(p, IPV6_HOPOPTS_UNKNOWN_OPT);\n                        else\n                            ENGINE_SET_EVENT(p, IPV6_DSTOPTS_UNKNOWN_OPT);\n\n                        other_cnt++;\n                    }\n                    uint16_t optlen = (*(ptr + 1) + 2);\n                    ptr += optlen; /* +2 for opt type and opt len fields */\n                    offset += optlen;\n                }\n                /* flag packets that have only padding */\n                if (padn_cnt > 0 && other_cnt == 0) {\n                    if (nh == IPPROTO_HOPOPTS)\n                        ENGINE_SET_EVENT(p, IPV6_HOPOPTS_ONLY_PADDING);\n                    else\n                        ENGINE_SET_EVENT(p, IPV6_DSTOPTS_ONLY_PADDING);\n                }\n\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            }\n\n            case IPPROTO_FRAGMENT:\n            {\n                IPV6_SET_L4PROTO(p,nh);\n                /* store the offset of this extension into the packet\n                 * past the ipv6 header. We use it in defrag for creating\n                 * a defragmented packet without the frag header */\n                if (exthdr_fh_done == 0) {\n                    p->ip6eh.fh_offset = pkt - orig_pkt;\n                    exthdr_fh_done = 1;\n                }\n\n                uint16_t prev_hdrextlen = hdrextlen;\n                hdrextlen = sizeof(IPV6FragHdr);\n                if (hdrextlen > plen) {\n                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                /* for the frag header, the length field is reserved */\n                if (*(pkt + 1) != 0) {\n                    ENGINE_SET_EVENT(p, IPV6_FH_NON_ZERO_RES_FIELD);\n                    /* non fatal, lets try to continue */\n                }\n\n                if (IPV6_EXTHDR_ISSET_FH(p)) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_FH);\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                /* set the header flag first */\n                IPV6_EXTHDR_SET_FH(p);\n\n                /* parse the header and setup the vars */\n                DecodeIPV6FragHeader(p, pkt, hdrextlen, plen, prev_hdrextlen);\n\n                /* if FH has offset 0 and no more fragments are coming, we\n                 * parse this packet further right away, no defrag will be\n                 * needed. It is a useless FH then though, so we do set an\n                 * decoder event. */\n                if (p->ip6eh.fh_more_frags_set == 0 && p->ip6eh.fh_offset == 0) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_USELESS_FH);\n\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                /* the rest is parsed upon reassembly */\n                p->flags |= PKT_IS_FRAGMENT;\n                SCReturn;\n            }\n            case IPPROTO_ESP:\n            {\n                IPV6_SET_L4PROTO(p,nh);\n                hdrextlen = sizeof(IPV6EspHdr);\n                if (hdrextlen > plen) {\n                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                if (eh) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_EH);\n                    SCReturn;\n                }\n\n                eh = 1;\n\n                nh = IPPROTO_NONE;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            }\n            case IPPROTO_AH:\n            {\n                IPV6_SET_L4PROTO(p,nh);\n                /* we need the header as a minimum */\n                hdrextlen = sizeof(IPV6AuthHdr);\n                /* the payload len field is the number of extra 4 byte fields,\n                 * IPV6AuthHdr already contains the first */\n                if (*(pkt+1) > 0)\n                    hdrextlen += ((*(pkt+1) - 1) * 4);\n\n                SCLogDebug(\"hdrextlen %\"PRIu8, hdrextlen);\n\n                if (hdrextlen > plen) {\n                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                IPV6AuthHdr *ahhdr = (IPV6AuthHdr *)pkt;\n                if (ahhdr->ip6ah_reserved != 0x0000) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_AH_RES_NOT_NULL);\n                }\n\n                if (ah) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_AH);\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                ah = 1;\n\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            }\n            case IPPROTO_IPIP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeIPv4inIPv6(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n            /* none, last header */\n            case IPPROTO_NONE:\n                IPV6_SET_L4PROTO(p,nh);\n                SCReturn;\n            case IPPROTO_ICMP:\n                ENGINE_SET_EVENT(p,IPV6_WITH_ICMPV4);\n                SCReturn;\n            /* no parsing yet, just skip it */\n            case IPPROTO_MH:\n            case IPPROTO_HIP:\n            case IPPROTO_SHIM6:\n                hdrextlen = 8 + (*(pkt+1) * 8);  /* 8 bytes + length in 8 octet units */\n                if (hdrextlen > plen) {\n                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            default:\n                ENGINE_SET_EVENT(p, IPV6_UNKNOWN_NEXT_HEADER);\n                IPV6_SET_L4PROTO(p,nh);\n                SCReturn;\n        }\n    }\n\n    SCReturn;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144489,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n     SCEnter();\n \n     uint8_t *orig_pkt = pkt;\n    uint8_t nh = IPV6_GET_NH(p); /* careful, 0 is actually a real type */\n     uint16_t hdrextlen = 0;\n    uint16_t plen = len;\n     char dstopts = 0;\n     char exthdr_fh_done = 0;\n     int hh = 0;\n     int rh = 0;\n     int eh = 0;\n     int ah = 0;\n \n     while(1)\n     {\n        if (nh == IPPROTO_NONE) {\n            if (plen > 0) {\n                /* No upper layer, but we do have data. Suspicious. */\n                ENGINE_SET_EVENT(p, IPV6_DATA_AFTER_NONE_HEADER);\n            }\n             SCReturn;\n         }\n \n         if (plen < 2) { /* minimal needed in a hdr */\n            ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n             SCReturn;\n         }\n \n        switch(nh)\n        {\n            case IPPROTO_TCP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeTCP(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_UDP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeUDP(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_ICMPV6:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeICMPV6(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_SCTP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeSCTP(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_ROUTING:\n                IPV6_SET_L4PROTO(p,nh);\n                hdrextlen = 8 + (*(pkt+1) * 8);  /* 8 bytes + length in 8 octet units */\n\n                 SCLogDebug(\"hdrextlen %\"PRIu8, hdrextlen);\n \n                 if (hdrextlen > plen) {\n                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                     SCReturn;\n                 }\n \n                if (rh) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_RH);\n                    /* skip past this extension so we can continue parsing the rest\n                     * of the packet */\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                rh = 1;\n                IPV6_EXTHDR_SET_RH(p);\n\n                uint8_t ip6rh_type = *(pkt + 2);\n                if (ip6rh_type == 0) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_RH_TYPE_0);\n                }\n                p->ip6eh.rh_type = ip6rh_type;\n\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n\n            case IPPROTO_HOPOPTS:\n            case IPPROTO_DSTOPTS:\n            {\n                IPV6OptHAO hao_s, *hao = &hao_s;\n                IPV6OptRA ra_s, *ra = &ra_s;\n                IPV6OptJumbo jumbo_s, *jumbo = &jumbo_s;\n                uint16_t optslen = 0;\n\n                 IPV6_SET_L4PROTO(p,nh);\n                 hdrextlen =  (*(pkt+1) + 1) << 3;\n                 if (hdrextlen > plen) {\n                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                     SCReturn;\n                 }\n \n                uint8_t *ptr = pkt + 2; /* +2 to go past nxthdr and len */\n\n                /* point the pointers to right structures\n                 * in Packet. */\n                if (nh == IPPROTO_HOPOPTS) {\n                    if (hh) {\n                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_HH);\n                        /* skip past this extension so we can continue parsing the rest\n                         * of the packet */\n                        nh = *pkt;\n                        pkt += hdrextlen;\n                        plen -= hdrextlen;\n                        break;\n                    }\n\n                    hh = 1;\n\n                    optslen = ((*(pkt + 1) + 1 ) << 3) - 2;\n                }\n                else if (nh == IPPROTO_DSTOPTS)\n                {\n                    if (dstopts == 0) {\n                        optslen = ((*(pkt + 1) + 1 ) << 3) - 2;\n                        dstopts = 1;\n                    } else if (dstopts == 1) {\n                        optslen = ((*(pkt + 1) + 1 ) << 3) - 2;\n                        dstopts = 2;\n                    } else {\n                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_DH);\n                        /* skip past this extension so we can continue parsing the rest\n                         * of the packet */\n                        nh = *pkt;\n                        pkt += hdrextlen;\n                        plen -= hdrextlen;\n                        break;\n                    }\n                }\n\n                 if (optslen > plen) {\n                     /* since the packet is long enough (we checked\n                      * plen against hdrlen, the optlen must be malformed. */\n                    ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                     /* skip past this extension so we can continue parsing the rest\n                      * of the packet */\n                     nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n/** \\todo move into own function to loaded on demand */\n                uint16_t padn_cnt = 0;\n                uint16_t other_cnt = 0;\n                uint16_t offset = 0;\n                while(offset < optslen)\n                {\n                    if (*ptr == IPV6OPT_PAD1)\n                    {\n                        padn_cnt++;\n                        offset++;\n                        ptr++;\n                        continue;\n                     }\n \n                     if (offset + 1 >= optslen) {\n                        ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                         break;\n                     }\n \n                    /* length field for each opt */\n                    uint8_t ip6_optlen = *(ptr + 1);\n \n                     /* see if the optlen from the packet fits the total optslen */\n                     if ((offset + 1 + ip6_optlen) > optslen) {\n                        ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                         break;\n                     }\n \n                    if (*ptr == IPV6OPT_PADN) /* PadN */\n                    {\n                        padn_cnt++;\n\n                        /* a zero padN len would be weird */\n                        if (ip6_optlen == 0)\n                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_ZERO_LEN_PADN);\n                    }\n                    else if (*ptr == IPV6OPT_RA) /* RA */\n                    {\n                        ra->ip6ra_type = *(ptr);\n                         ra->ip6ra_len  = ip6_optlen;\n \n                         if (ip6_optlen < sizeof(ra->ip6ra_value)) {\n                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                             break;\n                         }\n \n                        memcpy(&ra->ip6ra_value, (ptr + 2), sizeof(ra->ip6ra_value));\n                        ra->ip6ra_value = SCNtohs(ra->ip6ra_value);\n                        other_cnt++;\n                    }\n                    else if (*ptr == IPV6OPT_JUMBO) /* Jumbo */\n                    {\n                        jumbo->ip6j_type = *(ptr);\n                         jumbo->ip6j_len  = ip6_optlen;\n \n                         if (ip6_optlen < sizeof(jumbo->ip6j_payload_len)) {\n                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                             break;\n                         }\n \n                        memcpy(&jumbo->ip6j_payload_len, (ptr+2), sizeof(jumbo->ip6j_payload_len));\n                        jumbo->ip6j_payload_len = SCNtohl(jumbo->ip6j_payload_len);\n                    }\n                    else if (*ptr == IPV6OPT_HAO) /* HAO */\n                    {\n                        hao->ip6hao_type = *(ptr);\n                         hao->ip6hao_len  = ip6_optlen;\n \n                         if (ip6_optlen < sizeof(hao->ip6hao_hoa)) {\n                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                             break;\n                         }\n \n                        memcpy(&hao->ip6hao_hoa, (ptr+2), sizeof(hao->ip6hao_hoa));\n                        other_cnt++;\n                    } else {\n                        if (nh == IPPROTO_HOPOPTS)\n                            ENGINE_SET_EVENT(p, IPV6_HOPOPTS_UNKNOWN_OPT);\n                        else\n                            ENGINE_SET_EVENT(p, IPV6_DSTOPTS_UNKNOWN_OPT);\n\n                        other_cnt++;\n                    }\n                    uint16_t optlen = (*(ptr + 1) + 2);\n                    ptr += optlen; /* +2 for opt type and opt len fields */\n                    offset += optlen;\n                }\n                /* flag packets that have only padding */\n                if (padn_cnt > 0 && other_cnt == 0) {\n                    if (nh == IPPROTO_HOPOPTS)\n                        ENGINE_SET_EVENT(p, IPV6_HOPOPTS_ONLY_PADDING);\n                    else\n                        ENGINE_SET_EVENT(p, IPV6_DSTOPTS_ONLY_PADDING);\n                }\n\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            }\n\n            case IPPROTO_FRAGMENT:\n            {\n                IPV6_SET_L4PROTO(p,nh);\n                /* store the offset of this extension into the packet\n                 * past the ipv6 header. We use it in defrag for creating\n                 * a defragmented packet without the frag header */\n                if (exthdr_fh_done == 0) {\n                    p->ip6eh.fh_offset = pkt - orig_pkt;\n                    exthdr_fh_done = 1;\n                }\n\n                 uint16_t prev_hdrextlen = hdrextlen;\n                 hdrextlen = sizeof(IPV6FragHdr);\n                 if (hdrextlen > plen) {\n                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                     SCReturn;\n                 }\n \n                /* for the frag header, the length field is reserved */\n                if (*(pkt + 1) != 0) {\n                    ENGINE_SET_EVENT(p, IPV6_FH_NON_ZERO_RES_FIELD);\n                    /* non fatal, lets try to continue */\n                }\n\n                if (IPV6_EXTHDR_ISSET_FH(p)) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_FH);\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                /* set the header flag first */\n                IPV6_EXTHDR_SET_FH(p);\n\n                /* parse the header and setup the vars */\n                DecodeIPV6FragHeader(p, pkt, hdrextlen, plen, prev_hdrextlen);\n\n                /* if FH has offset 0 and no more fragments are coming, we\n                 * parse this packet further right away, no defrag will be\n                 * needed. It is a useless FH then though, so we do set an\n                 * decoder event. */\n                if (p->ip6eh.fh_more_frags_set == 0 && p->ip6eh.fh_offset == 0) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_USELESS_FH);\n\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                /* the rest is parsed upon reassembly */\n                p->flags |= PKT_IS_FRAGMENT;\n                SCReturn;\n            }\n            case IPPROTO_ESP:\n            {\n                 IPV6_SET_L4PROTO(p,nh);\n                 hdrextlen = sizeof(IPV6EspHdr);\n                 if (hdrextlen > plen) {\n                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                     SCReturn;\n                 }\n \n                if (eh) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_EH);\n                    SCReturn;\n                }\n\n                eh = 1;\n\n                nh = IPPROTO_NONE;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            }\n            case IPPROTO_AH:\n            {\n                IPV6_SET_L4PROTO(p,nh);\n                /* we need the header as a minimum */\n                hdrextlen = sizeof(IPV6AuthHdr);\n                /* the payload len field is the number of extra 4 byte fields,\n                 * IPV6AuthHdr already contains the first */\n                if (*(pkt+1) > 0)\n                    hdrextlen += ((*(pkt+1) - 1) * 4);\n\n                 SCLogDebug(\"hdrextlen %\"PRIu8, hdrextlen);\n \n                 if (hdrextlen > plen) {\n                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                     SCReturn;\n                 }\n \n                IPV6AuthHdr *ahhdr = (IPV6AuthHdr *)pkt;\n                if (ahhdr->ip6ah_reserved != 0x0000) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_AH_RES_NOT_NULL);\n                }\n\n                if (ah) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_AH);\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                ah = 1;\n\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            }\n            case IPPROTO_IPIP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeIPv4inIPv6(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n            /* none, last header */\n            case IPPROTO_NONE:\n                IPV6_SET_L4PROTO(p,nh);\n                SCReturn;\n            case IPPROTO_ICMP:\n                ENGINE_SET_EVENT(p,IPV6_WITH_ICMPV4);\n                SCReturn;\n            /* no parsing yet, just skip it */\n            case IPPROTO_MH:\n            case IPPROTO_HIP:\n             case IPPROTO_SHIM6:\n                 hdrextlen = 8 + (*(pkt+1) * 8);  /* 8 bytes + length in 8 octet units */\n                 if (hdrextlen > plen) {\n                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                     SCReturn;\n                 }\n                 nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            default:\n                ENGINE_SET_EVENT(p, IPV6_UNKNOWN_NEXT_HEADER);\n                IPV6_SET_L4PROTO(p,nh);\n                SCReturn;\n        }\n    }\n\n    SCReturn;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144490,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static ssize_t stellaris_enet_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    stellaris_enet_state *s = qemu_get_nic_opaque(nc);\n    int n;\n    uint8_t *p;\n    uint32_t crc;\n\n    if ((s->rctl & SE_RCTL_RXEN) == 0)\n        return -1;\n    if (s->np >= 31) {\n        return 0;\n    }\n\n    DPRINTF(\"Received packet len=%zu\\n\", size);\n    n = s->next_packet + s->np;\n    if (n >= 31)\n        n -= 31;\n    s->np++;\n\n    s->rx[n].len = size + 6;\n    p = s->rx[n].data;\n    *(p++) = (size + 6);\n    *(p++) = (size + 6) >> 8;\n    memcpy (p, buf, size);\n    p += size;\n    crc = crc32(~0, buf, size);\n    *(p++) = crc;\n    *(p++) = crc >> 8;\n    *(p++) = crc >> 16;\n    *(p++) = crc >> 24;\n    /* Clear the remaining bytes in the last word.  */\n    if ((size & 3) != 2) {\n        memset(p, 0, (6 - size) & 3);\n    }\n\n    s->ris |= SE_INT_RX;\n    stellaris_enet_update(s);\n\n    return size;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144545,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static ssize_t stellaris_enet_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    stellaris_enet_state *s = qemu_get_nic_opaque(nc);\n    int n;\n    uint8_t *p;\n    uint32_t crc;\n\n    if ((s->rctl & SE_RCTL_RXEN) == 0)\n        return -1;\n    if (s->np >= 31) {\n        return 0;\n    }\n\n    DPRINTF(\"Received packet len=%zu\\n\", size);\n     n = s->next_packet + s->np;\n     if (n >= 31)\n         n -= 31;\n \n    if (size >= sizeof(s->rx[n].data) - 6) {\n        /* If the packet won't fit into the\n         * emulated 2K RAM, this is reported\n         * as a FIFO overrun error.\n         */\n        s->ris |= SE_INT_FOV;\n        stellaris_enet_update(s);\n        return -1;\n    }\n\n    s->np++;\n     s->rx[n].len = size + 6;\n     p = s->rx[n].data;\n     *(p++) = (size + 6);\n        memset(p, 0, (6 - size) & 3);\n    }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144546,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static inline void *host_from_stream_offset(QEMUFile *f,\n                                            ram_addr_t offset,\n                                            int flags)\n{\n    static RAMBlock *block = NULL;\n    char id[256];\n    uint8_t len;\n\n    if (flags & RAM_SAVE_FLAG_CONTINUE) {\n        if (!block) {\n            error_report(\"Ack, bad migration stream!\");\n            return NULL;\n        }\n\n        return memory_region_get_ram_ptr(block->mr) + offset;\n    }\n\n    len = qemu_get_byte(f);\n    qemu_get_buffer(f, (uint8_t *)id, len);\n    id[len] = 0;\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n        if (!strncmp(id, block->idstr, sizeof(id)))\n            return memory_region_get_ram_ptr(block->mr) + offset;\n    }\n\n    error_report(\"Can't find block %s!\", id);\n    return NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144579,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static inline void *host_from_stream_offset(QEMUFile *f,\n                                            ram_addr_t offset,\n                                            int flags)\n{\n    static RAMBlock *block = NULL;\n    char id[256];\n     uint8_t len;\n \n     if (flags & RAM_SAVE_FLAG_CONTINUE) {\n        if (!block || block->length <= offset) {\n             error_report(\"Ack, bad migration stream!\");\n             return NULL;\n         }\n\n        return memory_region_get_ram_ptr(block->mr) + offset;\n    }\n\n    len = qemu_get_byte(f);\n    qemu_get_buffer(f, (uint8_t *)id, len);\n     id[len] = 0;\n \n     QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n        if (!strncmp(id, block->idstr, sizeof(id)) && block->length > offset) {\n             return memory_region_get_ram_ptr(block->mr) + offset;\n        }\n     }\n \n     error_report(\"Can't find block %s!\", id);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144580,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void FoFiType1::parse() {\n  char *line, *line1, *p, *p2;\n  char buf[256];\n  char c;\n  int n, code, i, j;\n  char *tokptr;\n\n  for (i = 1, line = (char *)file;\n       i <= 100 && line && (!name || !encoding);\n       ++i) {\n\n    // get font name\n    if (!name && !strncmp(line, \"/FontName\", 9)) {\n      strncpy(buf, line, 255);\n      buf[255] = '\\0';\n      if ((p = strchr(buf+9, '/')) &&\n\t  (p = strtok_r(p+1, \" \\t\\n\\r\", &tokptr))) {\n\tname = copyString(p);\n      }\n      line = getNextLine(line);\n\n    // get encoding\n    } else if (!encoding &&\n\t       !strncmp(line, \"/Encoding StandardEncoding def\", 30)) {\n      encoding = fofiType1StandardEncoding;\n    } else if (!encoding &&\n\t       !strncmp(line, \"/Encoding 256 array\", 19)) {\n      encoding = (char **)gmallocn(256, sizeof(char *));\n      for (j = 0; j < 256; ++j) {\n\tencoding[j] = NULL;\n      }\n      for (j = 0, line = getNextLine(line);\n\t   j < 300 && line && (line1 = getNextLine(line));\n\t   ++j, line = line1) {\n\tif ((n = line1 - line) > 255) {\n\t  error(-1, \"FoFiType1::parse a line has more than 255 characters, we don't support this\");\n\t  n = 255;\n\t}\n\tstrncpy(buf, line, n);\n\tbuf[n] = '\\0';\n\tfor (p = buf; *p == ' ' || *p == '\\t'; ++p) ;\n\tif (!strncmp(p, \"dup\", 3)) {\n\t  for (p += 3; *p == ' ' || *p == '\\t'; ++p) ;\n\t  for (p2 = p; *p2 >= '0' && *p2 <= '9'; ++p2) ;\n\t  if (*p2) {\n\t    c = *p2; // store it so we can recover it after atoi\n\t    *p2 = '\\0'; // terminate p so atoi works\n\t    code = atoi(p);\n\t    *p2 = c;\n\t    if (code == 8 && *p2 == '#') {\n\t      code = 0;\n\t      for (++p2; *p2 >= '0' && *p2 <= '7'; ++p2) {\n\t\tcode = code * 8 + (*p2 - '0');\n\t      }\n\t    }\n\t    if (code < 256) {\n\t      for (p = p2; *p == ' ' || *p == '\\t'; ++p) ;\n\t      if (*p == '/') {\n\t\t++p;\n\t\tfor (p2 = p; *p2 && *p2 != ' ' && *p2 != '\\t'; ++p2) ;\n\t\tc = *p2; // store it so we can recover it after copyString\n\t\t*p2 = '\\0'; // terminate p so copyString works\n\t\tencoding[code] = copyString(p);\n\t\t*p2 = c;\n\t\tp = p2;\n\t\tfor (; *p == ' ' || *p == '\\t'; ++p); // eat spaces between string and put\n\t\tif (!strncmp(p, \"put\", 3)) {\n\t\t  // eat put and spaces and newlines after put\n\t\t  for (p += 3; *p == ' ' || *p == '\\t' || *p == '\\n' || *p == '\\r'; ++p);\n\t\t  if (*p)\n\t\t  {\n\t\t    // there is still something after the definition\n\t\t    // there might be another definition in this line\n\t\t    // so move line1 to the end of our parsing\n\t\t    // so we start in the potential next definition in the next loop\n\t\t    line1 = &line[p - buf];\n\t\t  }\n\t\t} else {\n\t\t  error(-1, \"FoFiType1::parse no put after dup\");\n\t\t}\n\t      }\n\t    }\n\t  }\n\t} else {\n\t  if (strtok_r(buf, \" \\t\", &tokptr) &&\n\t      (p = strtok_r(NULL, \" \\t\\n\\r\", &tokptr)) && !strcmp(p, \"def\")) {\n\t    break;\n\t  }\n\t}\n      }\n      //~ check for getinterval/putinterval junk\n\n    } else {\n      line = getNextLine(line);\n    }\n  }\n\n  parsed = gTrue;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144589,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void FoFiType1::parse() {\n  char *line, *line1, *p, *p2;\n  char buf[256];\n  char c;\n  int n, code, i, j;\n  char *tokptr;\n\n  for (i = 1, line = (char *)file;\n       i <= 100 && line && (!name || !encoding);\n       ++i) {\n\n    if (!name && !strncmp(line, \"/FontName\", 9)) {\n      strncpy(buf, line, 255);\n      buf[255] = '\\0';\n      if ((p = strchr(buf+9, '/')) &&\n\t  (p = strtok_r(p+1, \" \\t\\n\\r\", &tokptr))) {\n\tname = copyString(p);\n      }\n      line = getNextLine(line);\n\n    } else if (!encoding &&\n\t       !strncmp(line, \"/Encoding StandardEncoding def\", 30)) {\n      encoding = fofiType1StandardEncoding;\n    } else if (!encoding &&\n\t       !strncmp(line, \"/Encoding 256 array\", 19)) {\n      encoding = (char **)gmallocn(256, sizeof(char *));\n      for (j = 0; j < 256; ++j) {\n\tencoding[j] = NULL;\n      }\n      for (j = 0, line = getNextLine(line);\n\t   j < 300 && line && (line1 = getNextLine(line));\n\t   ++j, line = line1) {\n\tif ((n = line1 - line) > 255) {\n\t  error(-1, \"FoFiType1::parse a line has more than 255 characters, we don't support this\");\n\t  n = 255;\n\t}\n\tstrncpy(buf, line, n);\n\tbuf[n] = '\\0';\n\tfor (p = buf; *p == ' ' || *p == '\\t'; ++p) ;\n\tif (!strncmp(p, \"dup\", 3)) {\n\t  for (p += 3; *p == ' ' || *p == '\\t'; ++p) ;\n\t  for (p2 = p; *p2 >= '0' && *p2 <= '9'; ++p2) ;\n\t  if (*p2) {\n\t    c = *p2; // store it so we can recover it after atoi\n\t    *p2 = '\\0'; // terminate p so atoi works\n\t    code = atoi(p);\n\t    *p2 = c;\n\t    if (code == 8 && *p2 == '#') {\n\t      code = 0;\n\t      for (++p2; *p2 >= '0' && *p2 <= '7'; ++p2) {\n\t\tcode = code * 8 + (*p2 - '0');\n \t\tcode = code * 8 + (*p2 - '0');\n \t      }\n \t    }\n\t    if (likely(code < 256 && code >= 0)) {\n \t      for (p = p2; *p == ' ' || *p == '\\t'; ++p) ;\n \t      if (*p == '/') {\n \t\t++p;\n\t\tc = *p2; // store it so we can recover it after copyString\n\t\t*p2 = '\\0'; // terminate p so copyString works\n\t\tencoding[code] = copyString(p);\n\t\t*p2 = c;\n\t\tp = p2;\n\t\tfor (; *p == ' ' || *p == '\\t'; ++p); // eat spaces between string and put\n\t\tif (!strncmp(p, \"put\", 3)) {\n\t\t  for (p += 3; *p == ' ' || *p == '\\t' || *p == '\\n' || *p == '\\r'; ++p);\n\t\t  if (*p)\n\t\t  {\n\t\t    line1 = &line[p - buf];\n\t\t  }\n\t\t} else {\n\t\t  error(-1, \"FoFiType1::parse no put after dup\");\n\t\t}\n\t      }\n\t    }\n\t  }\n\t} else {\n\t  if (strtok_r(buf, \" \\t\", &tokptr) &&\n\t      (p = strtok_r(NULL, \" \\t\\n\\r\", &tokptr)) && !strcmp(p, \"def\")) {\n\t    break;\n\t  }\n\t}\n      }\n\n    } else {\n      line = getNextLine(line);\n    }\n  }\n\n  parsed = gTrue;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144590,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int dmarc_process() {\n    int sr, origin;             /* used in SPF section */\n    int dmarc_spf_result  = 0;  /* stores spf into dmarc conn ctx */\n    pdkim_signature *sig  = NULL;\n    BOOL has_dmarc_record = TRUE;\n    u_char **ruf; /* forensic report addressees, if called for */\n\n  /* ACLs have \"control=dmarc_disable_verify\" */\n  if (dmarc_disable_verify == TRUE)\n  {\n    dmarc_ar_header = dmarc_auth_results_header(from_header, NULL);\n    return OK;\n  }\n\n  /* Store the header From: sender domain for this part of DMARC.\n   * If there is no from_header struct, then it's likely this message\n   * is locally generated and relying on fixups to add it.  Just skip\n   * the entire DMARC system if we can't find a From: header....or if\n   * there was a previous error.\n   */\n  if (from_header == NULL || dmarc_abort == TRUE)\n    dmarc_abort = TRUE;\n  else\n  {\n    /* I strongly encourage anybody who can make this better to contact me directly!\n     * <cannonball> Is this an insane way to extract the email address from the From: header?\n     * <jgh_hm> it's sure a horrid layer-crossing....\n     * <cannonball> I'm not denying that :-/\n     * <jgh_hm> there may well be no better though\n     */\n    header_from_sender = expand_string(\n                           string_sprintf(\"${domain:${extract{1}{:}{${addresses:%s}}}}\",\n                             from_header->text) );\n    /* The opendmarc library extracts the domain from the email address, but\n     * only try to store it if it's not empty.  Otherwise, skip out of DMARC. */\n    if (strcmp( CCS header_from_sender, \"\") == 0)\n      dmarc_abort = TRUE;\n    libdm_status = (dmarc_abort == TRUE) ?\n\t           DMARC_PARSE_OKAY :\n\t\t   opendmarc_policy_store_from_domain(dmarc_pctx, header_from_sender);\n    if (libdm_status != DMARC_PARSE_OKAY)\n    {\n      log_write(0, LOG_MAIN|LOG_PANIC, \"failure to store header From: in DMARC: %s, header was '%s'\",\n                           opendmarc_policy_status_to_str(libdm_status), from_header->text);\n      dmarc_abort = TRUE;\n    }\n  }\n\n  /* Skip DMARC if connection is SMTP Auth. Temporarily, admin should\n   * instead do this in the ACLs.  */\n  if (dmarc_abort == FALSE && sender_host_authenticated == NULL)\n  {\n    /* Use the envelope sender domain for this part of DMARC */\n    spf_sender_domain = expand_string(US\"$sender_address_domain\");\n    if ( spf_response == NULL )\n    {\n      /* No spf data means null envelope sender so generate a domain name\n       * from the sender_helo_name  */\n      if (spf_sender_domain == NULL)\n      {\n        spf_sender_domain = sender_helo_name;\n        log_write(0, LOG_MAIN, \"DMARC using synthesized SPF sender domain = %s\\n\",\n                               spf_sender_domain);\n        DEBUG(D_receive)\n          debug_printf(\"DMARC using synthesized SPF sender domain = %s\\n\", spf_sender_domain);\n      }\n      dmarc_spf_result = DMARC_POLICY_SPF_OUTCOME_NONE;\n      dmarc_spf_ares_result = ARES_RESULT_UNKNOWN;\n      origin = DMARC_POLICY_SPF_ORIGIN_HELO;\n      spf_human_readable = US\"\";\n    }\n    else\n    {\n      sr = spf_response->result;\n      dmarc_spf_result = (sr == SPF_RESULT_NEUTRAL)  ? DMARC_POLICY_SPF_OUTCOME_NONE :\n                         (sr == SPF_RESULT_PASS)     ? DMARC_POLICY_SPF_OUTCOME_PASS :\n                         (sr == SPF_RESULT_FAIL)     ? DMARC_POLICY_SPF_OUTCOME_FAIL :\n                         (sr == SPF_RESULT_SOFTFAIL) ? DMARC_POLICY_SPF_OUTCOME_TMPFAIL :\n                         DMARC_POLICY_SPF_OUTCOME_NONE;\n      dmarc_spf_ares_result = (sr == SPF_RESULT_NEUTRAL)   ? ARES_RESULT_NEUTRAL :\n                              (sr == SPF_RESULT_PASS)      ? ARES_RESULT_PASS :\n                              (sr == SPF_RESULT_FAIL)      ? ARES_RESULT_FAIL :\n                              (sr == SPF_RESULT_SOFTFAIL)  ? ARES_RESULT_SOFTFAIL :\n                              (sr == SPF_RESULT_NONE)      ? ARES_RESULT_NONE :\n                              (sr == SPF_RESULT_TEMPERROR) ? ARES_RESULT_TEMPERROR :\n                              (sr == SPF_RESULT_PERMERROR) ? ARES_RESULT_PERMERROR :\n                              ARES_RESULT_UNKNOWN;\n      origin = DMARC_POLICY_SPF_ORIGIN_MAILFROM;\n      spf_human_readable = (uschar *)spf_response->header_comment;\n      DEBUG(D_receive)\n        debug_printf(\"DMARC using SPF sender domain = %s\\n\", spf_sender_domain);\n    }\n    if (strcmp( CCS spf_sender_domain, \"\") == 0)\n      dmarc_abort = TRUE;\n    if (dmarc_abort == FALSE)\n    {\n      libdm_status = opendmarc_policy_store_spf(dmarc_pctx, spf_sender_domain,\n                                                dmarc_spf_result, origin, spf_human_readable);\n      if (libdm_status != DMARC_PARSE_OKAY)\n        log_write(0, LOG_MAIN|LOG_PANIC, \"failure to store spf for DMARC: %s\",\n                             opendmarc_policy_status_to_str(libdm_status));\n    }\n\n    /* Now we cycle through the dkim signature results and put into\n     * the opendmarc context, further building the DMARC reply.  */\n    sig = dkim_signatures;\n    dkim_history_buffer = US\"\";\n    while (sig != NULL)\n    {\n      int dkim_result, dkim_ares_result, vs, ves;\n      vs  = sig->verify_status;\n      ves = sig->verify_ext_status;\n      dkim_result = ( vs == PDKIM_VERIFY_PASS ) ? DMARC_POLICY_DKIM_OUTCOME_PASS :\n                    ( vs == PDKIM_VERIFY_FAIL ) ? DMARC_POLICY_DKIM_OUTCOME_FAIL :\n                    ( vs == PDKIM_VERIFY_INVALID ) ? DMARC_POLICY_DKIM_OUTCOME_TMPFAIL :\n                    DMARC_POLICY_DKIM_OUTCOME_NONE;\n      libdm_status = opendmarc_policy_store_dkim(dmarc_pctx, (uschar *)sig->domain,\n        \t                                 dkim_result, US\"\");\n      DEBUG(D_receive)\n        debug_printf(\"DMARC adding DKIM sender domain = %s\\n\", sig->domain);\n      if (libdm_status != DMARC_PARSE_OKAY)\n        log_write(0, LOG_MAIN|LOG_PANIC, \"failure to store dkim (%s) for DMARC: %s\",\n        \t\t     sig->domain, opendmarc_policy_status_to_str(libdm_status));\n\n      dkim_ares_result = ( vs == PDKIM_VERIFY_PASS )    ? ARES_RESULT_PASS :\n        \t              ( vs == PDKIM_VERIFY_FAIL )    ? ARES_RESULT_FAIL :\n        \t              ( vs == PDKIM_VERIFY_NONE )    ? ARES_RESULT_NONE :\n        \t              ( vs == PDKIM_VERIFY_INVALID ) ?\n                           ( ves == PDKIM_VERIFY_INVALID_PUBKEY_UNAVAILABLE ? ARES_RESULT_PERMERROR :\n                             ves == PDKIM_VERIFY_INVALID_BUFFER_SIZE        ? ARES_RESULT_PERMERROR :\n                             ves == PDKIM_VERIFY_INVALID_PUBKEY_PARSING     ? ARES_RESULT_PERMERROR :\n                             ARES_RESULT_UNKNOWN ) :\n                          ARES_RESULT_UNKNOWN;\n      dkim_history_buffer = string_sprintf(\"%sdkim %s %d\\n\", dkim_history_buffer,\n                                                             sig->domain, dkim_ares_result);\n      sig = sig->next;\n    }\n    libdm_status = opendmarc_policy_query_dmarc(dmarc_pctx, US\"\");\n    switch (libdm_status)\n    {\n      case DMARC_DNS_ERROR_NXDOMAIN:\n      case DMARC_DNS_ERROR_NO_RECORD:\n        DEBUG(D_receive)\n          debug_printf(\"DMARC no record found for %s\\n\", header_from_sender);\n        has_dmarc_record = FALSE;\n        break;\n      case DMARC_PARSE_OKAY:\n        DEBUG(D_receive)\n          debug_printf(\"DMARC record found for %s\\n\", header_from_sender);\n        break;\n      case DMARC_PARSE_ERROR_BAD_VALUE:\n        DEBUG(D_receive)\n          debug_printf(\"DMARC record parse error for %s\\n\", header_from_sender);\n        has_dmarc_record = FALSE;\n        break;\n      default:\n        /* everything else, skip dmarc */\n        DEBUG(D_receive)\n          debug_printf(\"DMARC skipping (%d), unsure what to do with %s\",\n                        libdm_status, from_header->text);\n        has_dmarc_record = FALSE;\n        break;\n    }\n    /* Can't use exim's string manipulation functions so allocate memory\n     * for libopendmarc using its max hostname length definition. */\n    uschar *dmarc_domain = (uschar *)calloc(DMARC_MAXHOSTNAMELEN, sizeof(uschar));\n    libdm_status = opendmarc_policy_fetch_utilized_domain(dmarc_pctx, dmarc_domain,\n        \t                                          DMARC_MAXHOSTNAMELEN-1);\n    dmarc_used_domain = string_copy(dmarc_domain);\n    free(dmarc_domain);\n    if (libdm_status != DMARC_PARSE_OKAY)\n    {\n      log_write(0, LOG_MAIN|LOG_PANIC, \"failure to read domainname used for DMARC lookup: %s\",\n                                       opendmarc_policy_status_to_str(libdm_status));\n    }\n    libdm_status = opendmarc_get_policy_to_enforce(dmarc_pctx);\n    dmarc_policy = libdm_status;\n    switch(libdm_status)\n    {\n      case DMARC_POLICY_ABSENT:     /* No DMARC record found */\n        dmarc_status = US\"norecord\";\n        dmarc_pass_fail = US\"none\";\n        dmarc_status_text = US\"No DMARC record\";\n        action = DMARC_RESULT_ACCEPT;\n        break;\n      case DMARC_FROM_DOMAIN_ABSENT:    /* No From: domain */\n        dmarc_status = US\"nofrom\";\n        dmarc_pass_fail = US\"temperror\";\n        dmarc_status_text = US\"No From: domain found\";\n        action = DMARC_RESULT_ACCEPT;\n        break;\n      case DMARC_POLICY_NONE:       /* Accept and report */\n        dmarc_status = US\"none\";\n        dmarc_pass_fail = US\"none\";\n        dmarc_status_text = US\"None, Accept\";\n        action = DMARC_RESULT_ACCEPT;\n        break;\n      case DMARC_POLICY_PASS:       /* Explicit accept */\n        dmarc_status = US\"accept\";\n        dmarc_pass_fail = US\"pass\";\n        dmarc_status_text = US\"Accept\";\n        action = DMARC_RESULT_ACCEPT;\n        break;\n      case DMARC_POLICY_REJECT:       /* Explicit reject */\n        dmarc_status = US\"reject\";\n        dmarc_pass_fail = US\"fail\";\n        dmarc_status_text = US\"Reject\";\n        action = DMARC_RESULT_REJECT;\n        break;\n      case DMARC_POLICY_QUARANTINE:       /* Explicit quarantine */\n        dmarc_status = US\"quarantine\";\n        dmarc_pass_fail = US\"fail\";\n        dmarc_status_text = US\"Quarantine\";\n        action = DMARC_RESULT_QUARANTINE;\n        break;\n      default:\n        dmarc_status = US\"temperror\";\n        dmarc_pass_fail = US\"temperror\";\n        dmarc_status_text = US\"Internal Policy Error\";\n        action = DMARC_RESULT_TEMPFAIL;\n        break;\n    }\n\n    libdm_status = opendmarc_policy_fetch_alignment(dmarc_pctx, &da, &sa);\n    if (libdm_status != DMARC_PARSE_OKAY)\n    {\n      log_write(0, LOG_MAIN|LOG_PANIC, \"failure to read DMARC alignment: %s\",\n                                       opendmarc_policy_status_to_str(libdm_status));\n    }\n\n    if (has_dmarc_record == TRUE)\n    {\n      log_write(0, LOG_MAIN, \"DMARC results: spf_domain=%s dmarc_domain=%s \"\n                             \"spf_align=%s dkim_align=%s enforcement='%s'\",\n                             spf_sender_domain, dmarc_used_domain,\n                             (sa==DMARC_POLICY_SPF_ALIGNMENT_PASS) ?\"yes\":\"no\",\n                             (da==DMARC_POLICY_DKIM_ALIGNMENT_PASS)?\"yes\":\"no\",\n                             dmarc_status_text);\n      history_file_status = dmarc_write_history_file();\n      /* Now get the forensic reporting addresses, if any */\n      ruf = opendmarc_policy_fetch_ruf(dmarc_pctx, NULL, 0, 1);\n      dmarc_send_forensic_report(ruf);\n    }\n  }\n\n  /* set some global variables here */\n  dmarc_ar_header = dmarc_auth_results_header(from_header, NULL);\n\n  /* shut down libopendmarc */\n  if ( dmarc_pctx != NULL )\n    (void) opendmarc_policy_connect_shutdown(dmarc_pctx);\n  if ( dmarc_disable_verify == FALSE )\n    (void) opendmarc_policy_library_shutdown(&dmarc_ctx);\n\n  return OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144599,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int dmarc_process() {\n    int sr, origin;             /* used in SPF section */\n    int dmarc_spf_result  = 0;  /* stores spf into dmarc conn ctx */\n    pdkim_signature *sig  = NULL;\n    BOOL has_dmarc_record = TRUE;\n    u_char **ruf; /* forensic report addressees, if called for */\n\n  /* ACLs have \"control=dmarc_disable_verify\" */\n  if (dmarc_disable_verify == TRUE)\n  {\n    dmarc_ar_header = dmarc_auth_results_header(from_header, NULL);\n    return OK;\n  }\n\n  /* Store the header From: sender domain for this part of DMARC.\n   * If there is no from_header struct, then it's likely this message\n   * is locally generated and relying on fixups to add it.  Just skip\n   * the entire DMARC system if we can't find a From: header....or if\n   * there was a previous error.\n   */\n  if (from_header == NULL || dmarc_abort == TRUE)\n     dmarc_abort = TRUE;\n   else\n   {\n  uschar * errormsg;\n  int dummy, domain;\n  uschar * p;\n  uschar saveend;\n\n  parse_allow_group = TRUE;\n  p = parse_find_address_end(from_header->text, FALSE);\n  saveend = *p; *p = '\\0';\n  if ((header_from_sender = parse_extract_address(from_header->text, &errormsg,\n                              &dummy, &dummy, &domain, FALSE)))\n    header_from_sender += domain;\n  *p = saveend;\n\n  /* The opendmarc library extracts the domain from the email address, but\n   * only try to store it if it's not empty.  Otherwise, skip out of DMARC. */\n  if (!header_from_sender || (strcmp( CCS header_from_sender, \"\") == 0))\n    dmarc_abort = TRUE;\n  libdm_status = dmarc_abort ?\n    DMARC_PARSE_OKAY :\n    opendmarc_policy_store_from_domain(dmarc_pctx, header_from_sender);\n  if (libdm_status != DMARC_PARSE_OKAY)\n     {\n      log_write(0, LOG_MAIN|LOG_PANIC,\n                \"failure to store header From: in DMARC: %s, header was '%s'\",\n                opendmarc_policy_status_to_str(libdm_status), from_header->text);\n       dmarc_abort = TRUE;\n     }\n   }\n    /* Use the envelope sender domain for this part of DMARC */\n    spf_sender_domain = expand_string(US\"$sender_address_domain\");\n    if ( spf_response == NULL )\n    {\n      /* No spf data means null envelope sender so generate a domain name\n       * from the sender_helo_name  */\n      if (spf_sender_domain == NULL)\n      {\n        spf_sender_domain = sender_helo_name;\n        log_write(0, LOG_MAIN, \"DMARC using synthesized SPF sender domain = %s\\n\",\n                               spf_sender_domain);\n        DEBUG(D_receive)\n          debug_printf(\"DMARC using synthesized SPF sender domain = %s\\n\", spf_sender_domain);\n      }\n      dmarc_spf_result = DMARC_POLICY_SPF_OUTCOME_NONE;\n      dmarc_spf_ares_result = ARES_RESULT_UNKNOWN;\n      origin = DMARC_POLICY_SPF_ORIGIN_HELO;\n      spf_human_readable = US\"\";\n    }\n    else\n    {\n      sr = spf_response->result;\n      dmarc_spf_result = (sr == SPF_RESULT_NEUTRAL)  ? DMARC_POLICY_SPF_OUTCOME_NONE :\n                         (sr == SPF_RESULT_PASS)     ? DMARC_POLICY_SPF_OUTCOME_PASS :\n                         (sr == SPF_RESULT_FAIL)     ? DMARC_POLICY_SPF_OUTCOME_FAIL :\n                         (sr == SPF_RESULT_SOFTFAIL) ? DMARC_POLICY_SPF_OUTCOME_TMPFAIL :\n                         DMARC_POLICY_SPF_OUTCOME_NONE;\n      dmarc_spf_ares_result = (sr == SPF_RESULT_NEUTRAL)   ? ARES_RESULT_NEUTRAL :\n                              (sr == SPF_RESULT_PASS)      ? ARES_RESULT_PASS :\n                              (sr == SPF_RESULT_FAIL)      ? ARES_RESULT_FAIL :\n                              (sr == SPF_RESULT_SOFTFAIL)  ? ARES_RESULT_SOFTFAIL :\n                              (sr == SPF_RESULT_NONE)      ? ARES_RESULT_NONE :\n                              (sr == SPF_RESULT_TEMPERROR) ? ARES_RESULT_TEMPERROR :\n                              (sr == SPF_RESULT_PERMERROR) ? ARES_RESULT_PERMERROR :\n                              ARES_RESULT_UNKNOWN;\n      origin = DMARC_POLICY_SPF_ORIGIN_MAILFROM;\n      spf_human_readable = (uschar *)spf_response->header_comment;\n      DEBUG(D_receive)\n        debug_printf(\"DMARC using SPF sender domain = %s\\n\", spf_sender_domain);\n    }\n    if (strcmp( CCS spf_sender_domain, \"\") == 0)\n      dmarc_abort = TRUE;\n    if (dmarc_abort == FALSE)\n    {\n      libdm_status = opendmarc_policy_store_spf(dmarc_pctx, spf_sender_domain,\n                                                dmarc_spf_result, origin, spf_human_readable);\n      if (libdm_status != DMARC_PARSE_OKAY)\n        log_write(0, LOG_MAIN|LOG_PANIC, \"failure to store spf for DMARC: %s\",\n                             opendmarc_policy_status_to_str(libdm_status));\n    }\n\n    /* Now we cycle through the dkim signature results and put into\n     * the opendmarc context, further building the DMARC reply.  */\n    sig = dkim_signatures;\n    dkim_history_buffer = US\"\";\n    while (sig != NULL)\n    {\n      int dkim_result, dkim_ares_result, vs, ves;\n      vs  = sig->verify_status;\n      ves = sig->verify_ext_status;\n      dkim_result = ( vs == PDKIM_VERIFY_PASS ) ? DMARC_POLICY_DKIM_OUTCOME_PASS :\n                    ( vs == PDKIM_VERIFY_FAIL ) ? DMARC_POLICY_DKIM_OUTCOME_FAIL :\n                    ( vs == PDKIM_VERIFY_INVALID ) ? DMARC_POLICY_DKIM_OUTCOME_TMPFAIL :\n                    DMARC_POLICY_DKIM_OUTCOME_NONE;\n      libdm_status = opendmarc_policy_store_dkim(dmarc_pctx, (uschar *)sig->domain,\n        \t                                 dkim_result, US\"\");\n      DEBUG(D_receive)\n        debug_printf(\"DMARC adding DKIM sender domain = %s\\n\", sig->domain);\n      if (libdm_status != DMARC_PARSE_OKAY)\n        log_write(0, LOG_MAIN|LOG_PANIC, \"failure to store dkim (%s) for DMARC: %s\",\n        \t\t     sig->domain, opendmarc_policy_status_to_str(libdm_status));\n\n      dkim_ares_result = ( vs == PDKIM_VERIFY_PASS )    ? ARES_RESULT_PASS :\n        \t              ( vs == PDKIM_VERIFY_FAIL )    ? ARES_RESULT_FAIL :\n        \t              ( vs == PDKIM_VERIFY_NONE )    ? ARES_RESULT_NONE :\n        \t              ( vs == PDKIM_VERIFY_INVALID ) ?\n                           ( ves == PDKIM_VERIFY_INVALID_PUBKEY_UNAVAILABLE ? ARES_RESULT_PERMERROR :\n                             ves == PDKIM_VERIFY_INVALID_BUFFER_SIZE        ? ARES_RESULT_PERMERROR :\n                             ves == PDKIM_VERIFY_INVALID_PUBKEY_PARSING     ? ARES_RESULT_PERMERROR :\n                             ARES_RESULT_UNKNOWN ) :\n                          ARES_RESULT_UNKNOWN;\n      dkim_history_buffer = string_sprintf(\"%sdkim %s %d\\n\", dkim_history_buffer,\n                                                             sig->domain, dkim_ares_result);\n      sig = sig->next;\n    }\n    libdm_status = opendmarc_policy_query_dmarc(dmarc_pctx, US\"\");\n    switch (libdm_status)\n    {\n      case DMARC_DNS_ERROR_NXDOMAIN:\n      case DMARC_DNS_ERROR_NO_RECORD:\n        DEBUG(D_receive)\n          debug_printf(\"DMARC no record found for %s\\n\", header_from_sender);\n        has_dmarc_record = FALSE;\n        break;\n      case DMARC_PARSE_OKAY:\n        DEBUG(D_receive)\n          debug_printf(\"DMARC record found for %s\\n\", header_from_sender);\n        break;\n      case DMARC_PARSE_ERROR_BAD_VALUE:\n        DEBUG(D_receive)\n          debug_printf(\"DMARC record parse error for %s\\n\", header_from_sender);\n        has_dmarc_record = FALSE;\n        break;\n      default:\n        /* everything else, skip dmarc */\n        DEBUG(D_receive)\n          debug_printf(\"DMARC skipping (%d), unsure what to do with %s\",\n                        libdm_status, from_header->text);\n        has_dmarc_record = FALSE;\n        break;\n    }\n    /* Can't use exim's string manipulation functions so allocate memory\n     * for libopendmarc using its max hostname length definition. */\n    uschar *dmarc_domain = (uschar *)calloc(DMARC_MAXHOSTNAMELEN, sizeof(uschar));\n    libdm_status = opendmarc_policy_fetch_utilized_domain(dmarc_pctx, dmarc_domain,\n        \t                                          DMARC_MAXHOSTNAMELEN-1);\n    dmarc_used_domain = string_copy(dmarc_domain);\n    free(dmarc_domain);\n    if (libdm_status != DMARC_PARSE_OKAY)\n    {\n      log_write(0, LOG_MAIN|LOG_PANIC, \"failure to read domainname used for DMARC lookup: %s\",\n                                       opendmarc_policy_status_to_str(libdm_status));\n    }\n    libdm_status = opendmarc_get_policy_to_enforce(dmarc_pctx);\n    dmarc_policy = libdm_status;\n    switch(libdm_status)\n    {\n      case DMARC_POLICY_ABSENT:     /* No DMARC record found */\n        dmarc_status = US\"norecord\";\n        dmarc_pass_fail = US\"none\";\n        dmarc_status_text = US\"No DMARC record\";\n        action = DMARC_RESULT_ACCEPT;\n        break;\n      case DMARC_FROM_DOMAIN_ABSENT:    /* No From: domain */\n        dmarc_status = US\"nofrom\";\n        dmarc_pass_fail = US\"temperror\";\n        dmarc_status_text = US\"No From: domain found\";\n        action = DMARC_RESULT_ACCEPT;\n        break;\n      case DMARC_POLICY_NONE:       /* Accept and report */\n        dmarc_status = US\"none\";\n        dmarc_pass_fail = US\"none\";\n        dmarc_status_text = US\"None, Accept\";\n        action = DMARC_RESULT_ACCEPT;\n        break;\n      case DMARC_POLICY_PASS:       /* Explicit accept */\n        dmarc_status = US\"accept\";\n        dmarc_pass_fail = US\"pass\";\n        dmarc_status_text = US\"Accept\";\n        action = DMARC_RESULT_ACCEPT;\n        break;\n      case DMARC_POLICY_REJECT:       /* Explicit reject */\n        dmarc_status = US\"reject\";\n        dmarc_pass_fail = US\"fail\";\n        dmarc_status_text = US\"Reject\";\n        action = DMARC_RESULT_REJECT;\n        break;\n      case DMARC_POLICY_QUARANTINE:       /* Explicit quarantine */\n        dmarc_status = US\"quarantine\";\n        dmarc_pass_fail = US\"fail\";\n        dmarc_status_text = US\"Quarantine\";\n        action = DMARC_RESULT_QUARANTINE;\n        break;\n      default:\n        dmarc_status = US\"temperror\";\n        dmarc_pass_fail = US\"temperror\";\n        dmarc_status_text = US\"Internal Policy Error\";\n        action = DMARC_RESULT_TEMPFAIL;\n        break;\n    }\n\n    libdm_status = opendmarc_policy_fetch_alignment(dmarc_pctx, &da, &sa);\n    if (libdm_status != DMARC_PARSE_OKAY)\n    {\n      log_write(0, LOG_MAIN|LOG_PANIC, \"failure to read DMARC alignment: %s\",\n                                       opendmarc_policy_status_to_str(libdm_status));\n    }\n\n    if (has_dmarc_record == TRUE)\n    {\n      log_write(0, LOG_MAIN, \"DMARC results: spf_domain=%s dmarc_domain=%s \"\n                             \"spf_align=%s dkim_align=%s enforcement='%s'\",\n                             spf_sender_domain, dmarc_used_domain,\n                             (sa==DMARC_POLICY_SPF_ALIGNMENT_PASS) ?\"yes\":\"no\",\n                             (da==DMARC_POLICY_DKIM_ALIGNMENT_PASS)?\"yes\":\"no\",\n                             dmarc_status_text);\n      history_file_status = dmarc_write_history_file();\n      /* Now get the forensic reporting addresses, if any */\n      ruf = opendmarc_policy_fetch_ruf(dmarc_pctx, NULL, 0, 1);\n      dmarc_send_forensic_report(ruf);\n    }\n  }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144600,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "daemon_msg_findallif_req(uint8 ver, struct daemon_slpars *pars, uint32 plen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tpcap_if_t *alldevs = NULL;\t\t// pointer to the header of the interface chain\n\tpcap_if_t *d;\t\t\t\t// temp pointer needed to scan the interface chain\n\tstruct pcap_addr *address;\t\t// pcap structure that keeps a network address of an interface\n\tstruct rpcap_findalldevs_if *findalldevs_if;// rpcap structure that packet all the data of an interface together\n\tuint16 nif = 0;\t\t\t\t// counts the number of interface listed\n\n\t// Discard the rest of the message; there shouldn't be any payload.\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\t// Network error.\n\t\treturn -1;\n\t}\n\n\t// Retrieve the device list\n\tif (pcap_findalldevs(&alldevs, errmsgbuf) == -1)\n\t\tgoto error;\n\n\tif (alldevs == NULL)\n\t{\n\t\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_NOREMOTEIF,\n\t\t\t\"No interfaces found! Make sure libpcap/WinPcap is properly installed\"\n\t\t\t\" and you have the right to access to the remote device.\",\n\t\t\terrbuf) == -1)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// checks the number of interfaces and it computes the total length of the payload\n\tfor (d = alldevs; d != NULL; d = d->next)\n\t{\n\t\tnif++;\n\n\t\tif (d->description)\n\t\t\tplen+= strlen(d->description);\n\t\tif (d->name)\n\t\t\tplen+= strlen(d->name);\n\n\t\tplen+= sizeof(struct rpcap_findalldevs_if);\n\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tplen+= (sizeof(struct rpcap_sockaddr) * 4);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// RPCAP findalldevs command\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,\n\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf,\n\t    PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_FINDALLIF_REPLY, nif, plen);\n\n\t// send the interface list\n\tfor (d = alldevs; d != NULL; d = d->next)\n\t{\n\t\tuint16 lname, ldescr;\n\n\t\tfindalldevs_if = (struct rpcap_findalldevs_if *) &sendbuf[sendbufidx];\n\n\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_findalldevs_if), NULL,\n\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tmemset(findalldevs_if, 0, sizeof(struct rpcap_findalldevs_if));\n\n\t\tif (d->description) ldescr = (short) strlen(d->description);\n\t\telse ldescr = 0;\n\t\tif (d->name) lname = (short) strlen(d->name);\n\t\telse lname = 0;\n\n\t\tfindalldevs_if->desclen = htons(ldescr);\n\t\tfindalldevs_if->namelen = htons(lname);\n\t\tfindalldevs_if->flags = htonl(d->flags);\n\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tfindalldevs_if->naddr++;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfindalldevs_if->naddr = htons(findalldevs_if->naddr);\n\n\t\tif (sock_bufferize(d->name, lname, sendbuf, &sendbufidx,\n\t\t    RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tif (sock_bufferize(d->description, ldescr, sendbuf, &sendbufidx,\n\t\t    RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\t// send all addresses\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\tstruct rpcap_sockaddr *sockaddr;\n\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->addr, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->netmask, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->broadaddr, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->dstaddr, sockaddr);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// We no longer need the device list. Free it.\n\tpcap_freealldevs(alldevs);\n\n\t// Send a final command that says \"now send it!\"\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerror:\n\tif (alldevs)\n\t\tpcap_freealldevs(alldevs);\n\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_FINDALLIF,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144609,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "daemon_msg_findallif_req(uint8 ver, struct daemon_slpars *pars, uint32 plen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tpcap_if_t *alldevs = NULL;\t\t// pointer to the header of the interface chain\n \tpcap_if_t *d;\t\t\t\t// temp pointer needed to scan the interface chain\n \tstruct pcap_addr *address;\t\t// pcap structure that keeps a network address of an interface\n \tstruct rpcap_findalldevs_if *findalldevs_if;// rpcap structure that packet all the data of an interface together\n\tuint32 replylen;\t\t\t// length of reply payload\n \tuint16 nif = 0;\t\t\t\t// counts the number of interface listed\n \n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\n\tif (pcap_findalldevs(&alldevs, errmsgbuf) == -1)\n\t\tgoto error;\n\n\tif (alldevs == NULL)\n\t{\n\t\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_NOREMOTEIF,\n\t\t\t\"No interfaces found! Make sure libpcap/WinPcap is properly installed\"\n\t\t\t\" and you have the right to access to the remote device.\",\n\t\t\terrbuf) == -1)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\treturn -1;\n\t\t}\n \t\treturn 0;\n \t}\n \n\t// This checks the number of interfaces and computes the total\n\t// length of the payload.\n\treplylen = 0;\n \tfor (d = alldevs; d != NULL; d = d->next)\n \t{\n \t\tnif++;\n \n \t\tif (d->description)\n\t\t\treplylen += strlen(d->description);\n \t\tif (d->name)\n\t\t\treplylen += strlen(d->name);\n \n\t\treplylen += sizeof(struct rpcap_findalldevs_if);\n \n \t\tfor (address = d->addresses; address != NULL; address = address->next)\n \t\t{\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n #ifdef AF_INET6\n \t\t\tcase AF_INET6:\n #endif\n\t\t\t\treplylen += (sizeof(struct rpcap_sockaddr) * 4);\n \t\t\t\tbreak;\n \n \t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,\n\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf,\n\t    PCAP_ERRBUF_SIZE) == -1)\n \t\tgoto error;\n \n \trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_FINDALLIF_REPLY, nif, replylen);\n \n \tfor (d = alldevs; d != NULL; d = d->next)\n\t{\n\t\tuint16 lname, ldescr;\n\n\t\tfindalldevs_if = (struct rpcap_findalldevs_if *) &sendbuf[sendbufidx];\n\n\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_findalldevs_if), NULL,\n\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tmemset(findalldevs_if, 0, sizeof(struct rpcap_findalldevs_if));\n\n\t\tif (d->description) ldescr = (short) strlen(d->description);\n\t\telse ldescr = 0;\n\t\tif (d->name) lname = (short) strlen(d->name);\n\t\telse lname = 0;\n\n\t\tfindalldevs_if->desclen = htons(ldescr);\n\t\tfindalldevs_if->namelen = htons(lname);\n\t\tfindalldevs_if->flags = htonl(d->flags);\n\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tfindalldevs_if->naddr++;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfindalldevs_if->naddr = htons(findalldevs_if->naddr);\n\n\t\tif (sock_bufferize(d->name, lname, sendbuf, &sendbufidx,\n\t\t    RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tif (sock_bufferize(d->description, ldescr, sendbuf, &sendbufidx,\n\t\t    RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\tstruct rpcap_sockaddr *sockaddr;\n\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->addr, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->netmask, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->broadaddr, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->dstaddr, sockaddr);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpcap_freealldevs(alldevs);\n\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerror:\n\tif (alldevs)\n\t\tpcap_freealldevs(alldevs);\n\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_FINDALLIF,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144610,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "ProcRenderAddGlyphs (ClientPtr client)\n{\n    GlyphSetPtr     glyphSet;\n    REQUEST(xRenderAddGlyphsReq);\n    GlyphNewRec\t    glyphsLocal[NLOCALGLYPH];\n    GlyphNewPtr\t    glyphsBase, glyphs, glyph_new;\n    int\t\t    remain, nglyphs;\n    CARD32\t    *gids;\n    xGlyphInfo\t    *gi;\n    CARD8\t    *bits;\n    unsigned int    size;\n    int\t\t    err;\n    int\t\t    i, screen;\n    PicturePtr\t    pSrc = NULL, pDst = NULL;\n    PixmapPtr\t    pSrcPix = NULL, pDstPix = NULL;\n    CARD32\t    component_alpha;\n\n    REQUEST_AT_LEAST_SIZE(xRenderAddGlyphsReq);\n    err = dixLookupResourceByType((pointer *)&glyphSet, stuff->glyphset, GlyphSetType,\n\t\t\t    client, DixAddAccess);\n    if (err != Success)\n    {\n\tclient->errorValue = stuff->glyphset;\n\treturn err;\n    }\n\n    err = BadAlloc;\n    nglyphs = stuff->nglyphs;\n    if (nglyphs > UINT32_MAX / sizeof(GlyphNewRec))\n\t    return BadAlloc;\n\n    component_alpha = NeedsComponent (glyphSet->format->format);\n\n    if (nglyphs <= NLOCALGLYPH) {\n\tmemset (glyphsLocal, 0, sizeof (glyphsLocal));\n\tglyphsBase = glyphsLocal;\n    }\n    else\n    {\n\tglyphsBase = (GlyphNewPtr)calloc(nglyphs, sizeof (GlyphNewRec));\n\tif (!glyphsBase)\n\t    return BadAlloc;\n    }\n\n    remain = (client->req_len << 2) - sizeof (xRenderAddGlyphsReq);\n\n    glyphs = glyphsBase;\n\n    gids = (CARD32 *) (stuff + 1);\n    gi = (xGlyphInfo *) (gids + nglyphs);\n    bits = (CARD8 *) (gi + nglyphs);\n    remain -= (sizeof (CARD32) + sizeof (xGlyphInfo)) * nglyphs;\n    for (i = 0; i < nglyphs; i++)\n    {\n\tsize_t padded_width;\n\tglyph_new = &glyphs[i];\n\n\tpadded_width = PixmapBytePad (gi[i].width,\n\t\t\t\t      glyphSet->format->depth);\n\n\tif (gi[i].height && padded_width > (UINT32_MAX - sizeof(GlyphRec))/gi[i].height)\n\t    break;\n\t\n\tsize = gi[i].height * padded_width;\n\tif (remain < size)\n\t    break;\n\n\terr = HashGlyph (&gi[i], bits, size, glyph_new->sha1);\n\tif (err)\n\t    goto bail;\n\n\tglyph_new->glyph = FindGlyphByHash (glyph_new->sha1,\n\t\t\t\t\t    glyphSet->fdepth);\n\n\tif (glyph_new->glyph && glyph_new->glyph != DeletedGlyph)\n\t{\n\t    glyph_new->found = TRUE;\n\t}\n\telse\n\t{\n\t    GlyphPtr glyph;\n\n\t    glyph_new->found = FALSE;\n\t    glyph_new->glyph = glyph = AllocateGlyph (&gi[i], glyphSet->fdepth);\n\t    if (! glyph)\n\t    {\n\t\terr = BadAlloc;\n\t\tgoto bail;\n\t    }\n\n\t    for (screen = 0; screen < screenInfo.numScreens; screen++)\n\t    {\n\t\tint\t    width = gi[i].width;\n\t\tint\t    height = gi[i].height;\n\t\tint\t    depth = glyphSet->format->depth;\n\t\tScreenPtr   pScreen;\n\t\tint\t    error;\n\n\t\t/* Skip work if it's invisibly small anyway */\n\t\tif (!width || !height)\n\t\t    break;\n\n\t\tpScreen = screenInfo.screens[screen];\n\t\tpSrcPix = GetScratchPixmapHeader (pScreen,\n\t\t\t\t\t\t  width, height,\n\t\t\t\t\t\t  depth, depth,\n\t\t\t\t\t\t  -1, bits);\n\t\tif (! pSrcPix)\n\t\t{\n\t\t    err = BadAlloc;\n\t\t    goto bail;\n\t\t}\n\n\t\tpSrc = CreatePicture (0, &pSrcPix->drawable,\n\t\t\t\t      glyphSet->format, 0, NULL,\n\t\t\t\t      serverClient, &error);\n\t\tif (! pSrc)\n\t\t{\n\t\t    err = BadAlloc;\n\t\t    goto bail;\n\t\t}\n\n\t\tpDstPix = (pScreen->CreatePixmap) (pScreen,\n\t\t\t\t\t\t   width, height, depth,\n\t\t\t\t\t\t   CREATE_PIXMAP_USAGE_GLYPH_PICTURE);\n\n\t\tif (!pDstPix)\n\t\t{\n\t\t    err = BadAlloc;\n\t\t    goto bail;\n\t\t}\n\n\t\tGlyphPicture (glyph)[screen] = pDst =\n\t\t\tCreatePicture (0, &pDstPix->drawable,\n\t\t\t\t       glyphSet->format,\n\t\t\t\t       CPComponentAlpha, &component_alpha,\n\t\t\t\t       serverClient, &error);\n\n\t\t/* The picture takes a reference to the pixmap, so we\n\t\t   drop ours. */\n\t\t(pScreen->DestroyPixmap) (pDstPix);\n\t\tpDstPix = NULL;\n\n\t\tif (! pDst)\n\t\t{\n\t\t    err = BadAlloc;\n\t\t    goto bail;\n\t\t}\n\n\t\tCompositePicture (PictOpSrc,\n\t\t\t\t  pSrc,\n\t\t\t\t  None,\n\t\t\t\t  pDst,\n\t\t\t\t  0, 0,\n\t\t\t\t  0, 0,\n\t\t\t\t  0, 0,\n\t\t\t\t  width, height);\n\n\t\tFreePicture ((pointer) pSrc, 0);\n\t\tpSrc = NULL;\n\t\tFreeScratchPixmapHeader (pSrcPix);\n\t\tpSrcPix = NULL;\n\t    }\n\n\t    memcpy (glyph_new->glyph->sha1, glyph_new->sha1, 20);\n\t}\n\n\tglyph_new->id = gids[i];\n\t\n\tif (size & 3)\n\t    size += 4 - (size & 3);\n\tbits += size;\n\tremain -= size;\n    }\n    if (remain || i < nglyphs)\n    {\n\terr = BadLength;\n\tgoto bail;\n    }\n    if (!ResizeGlyphSet (glyphSet, nglyphs))\n    {\n\terr = BadAlloc;\n\tgoto bail;\n    }\n    for (i = 0; i < nglyphs; i++)\n\tAddGlyph (glyphSet, glyphs[i].glyph, glyphs[i].id);\n\n    if (glyphsBase != glyphsLocal)\n\tfree(glyphsBase);\n    return Success;\nbail:\n    if (pSrc)\n\tFreePicture ((pointer) pSrc, 0);\n    if (pSrcPix)\n\tFreeScratchPixmapHeader (pSrcPix);\n    for (i = 0; i < nglyphs; i++)\n\tif (glyphs[i].glyph && ! glyphs[i].found)\n\t    free(glyphs[i].glyph);\n    if (glyphsBase != glyphsLocal)\n\tfree(glyphsBase);\n    return err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144617,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "ProcRenderAddGlyphs (ClientPtr client)\n{\n    GlyphSetPtr     glyphSet;\n    REQUEST(xRenderAddGlyphsReq);\n    GlyphNewRec\t    glyphsLocal[NLOCALGLYPH];\n    GlyphNewPtr\t    glyphsBase, glyphs, glyph_new;\n    int\t\t    remain, nglyphs;\n    CARD32\t    *gids;\n    xGlyphInfo\t    *gi;\n    CARD8\t    *bits;\n    unsigned int    size;\n    int\t\t    err;\n    int\t\t    i, screen;\n    PicturePtr\t    pSrc = NULL, pDst = NULL;\n    PixmapPtr\t    pSrcPix = NULL, pDstPix = NULL;\n    CARD32\t    component_alpha;\n\n    REQUEST_AT_LEAST_SIZE(xRenderAddGlyphsReq);\n    err = dixLookupResourceByType((pointer *)&glyphSet, stuff->glyphset, GlyphSetType,\n\t\t\t    client, DixAddAccess);\n    if (err != Success)\n    {\n\tclient->errorValue = stuff->glyphset;\n\treturn err;\n    }\n\n    err = BadAlloc;\n    nglyphs = stuff->nglyphs;\n    if (nglyphs > UINT32_MAX / sizeof(GlyphNewRec))\n\t    return BadAlloc;\n\n    component_alpha = NeedsComponent (glyphSet->format->format);\n\n    if (nglyphs <= NLOCALGLYPH) {\n\tmemset (glyphsLocal, 0, sizeof (glyphsLocal));\n\tglyphsBase = glyphsLocal;\n    }\n    else\n    {\n\tglyphsBase = (GlyphNewPtr)calloc(nglyphs, sizeof (GlyphNewRec));\n\tif (!glyphsBase)\n\t    return BadAlloc;\n    }\n\n    remain = (client->req_len << 2) - sizeof (xRenderAddGlyphsReq);\n\n    glyphs = glyphsBase;\n\n    gids = (CARD32 *) (stuff + 1);\n     gi = (xGlyphInfo *) (gids + nglyphs);\n     bits = (CARD8 *) (gi + nglyphs);\n     remain -= (sizeof (CARD32) + sizeof (xGlyphInfo)) * nglyphs;\n\n    /* protect against bad nglyphs */\n    if (gi < stuff || gi > ((CARD32 *)stuff + client->req_len) ||\n        bits < stuff || bits > ((CARD32 *)stuff + client->req_len)) {\n        err = BadLength;\n        goto bail;\n    }\n\n     for (i = 0; i < nglyphs; i++)\n     {\n \tsize_t padded_width;\n\tsize = gi[i].height * padded_width;\n\tif (remain < size)\n\t    break;\n\n\terr = HashGlyph (&gi[i], bits, size, glyph_new->sha1);\n\tif (err)\n\t    goto bail;\n\n\tglyph_new->glyph = FindGlyphByHash (glyph_new->sha1,\n\t\t\t\t\t    glyphSet->fdepth);\n\n\tif (glyph_new->glyph && glyph_new->glyph != DeletedGlyph)\n\t{\n\t    glyph_new->found = TRUE;\n\t}\n\telse\n\t{\n\t    GlyphPtr glyph;\n\n\t    glyph_new->found = FALSE;\n\t    glyph_new->glyph = glyph = AllocateGlyph (&gi[i], glyphSet->fdepth);\n\t    if (! glyph)\n\t    {\n\t\terr = BadAlloc;\n\t\tgoto bail;\n\t    }\n\n\t    for (screen = 0; screen < screenInfo.numScreens; screen++)\n\t    {\n\t\tint\t    width = gi[i].width;\n\t\tint\t    height = gi[i].height;\n\t\tint\t    depth = glyphSet->format->depth;\n\t\tScreenPtr   pScreen;\n\t\tint\t    error;\n\n\t\t/* Skip work if it's invisibly small anyway */\n\t\tif (!width || !height)\n\t\t    break;\n\n\t\tpScreen = screenInfo.screens[screen];\n\t\tpSrcPix = GetScratchPixmapHeader (pScreen,\n\t\t\t\t\t\t  width, height,\n\t\t\t\t\t\t  depth, depth,\n\t\t\t\t\t\t  -1, bits);\n\t\tif (! pSrcPix)\n\t\t{\n\t\t    err = BadAlloc;\n\t\t    goto bail;\n\t\t}\n\n\t\tpSrc = CreatePicture (0, &pSrcPix->drawable,\n\t\t\t\t      glyphSet->format, 0, NULL,\n\t\t\t\t      serverClient, &error);\n\t\tif (! pSrc)\n\t\t{\n\t\t    err = BadAlloc;\n\t\t    goto bail;\n\t\t}\n\n\t\tpDstPix = (pScreen->CreatePixmap) (pScreen,\n\t\t\t\t\t\t   width, height, depth,\n\t\t\t\t\t\t   CREATE_PIXMAP_USAGE_GLYPH_PICTURE);\n\n\t\tif (!pDstPix)\n\t\t{\n\t\t    err = BadAlloc;\n\t\t    goto bail;\n\t\t}\n\n\t\tGlyphPicture (glyph)[screen] = pDst =\n\t\t\tCreatePicture (0, &pDstPix->drawable,\n\t\t\t\t       glyphSet->format,\n\t\t\t\t       CPComponentAlpha, &component_alpha,\n\t\t\t\t       serverClient, &error);\n\n\t\t/* The picture takes a reference to the pixmap, so we\n\t\t   drop ours. */\n\t\t(pScreen->DestroyPixmap) (pDstPix);\n\t\tpDstPix = NULL;\n\n\t\tif (! pDst)\n\t\t{\n\t\t    err = BadAlloc;\n\t\t    goto bail;\n\t\t}\n\n\t\tCompositePicture (PictOpSrc,\n\t\t\t\t  pSrc,\n\t\t\t\t  None,\n\t\t\t\t  pDst,\n\t\t\t\t  0, 0,\n\t\t\t\t  0, 0,\n\t\t\t\t  0, 0,\n\t\t\t\t  width, height);\n\n\t\tFreePicture ((pointer) pSrc, 0);\n\t\tpSrc = NULL;\n\t\tFreeScratchPixmapHeader (pSrcPix);\n\t\tpSrcPix = NULL;\n\t    }\n\n\t    memcpy (glyph_new->glyph->sha1, glyph_new->sha1, 20);\n\t}\n\n\tglyph_new->id = gids[i];\n\t\n\tif (size & 3)\n\t    size += 4 - (size & 3);\n\tbits += size;\n\tremain -= size;\n    }\n    if (remain || i < nglyphs)\n    {\n\terr = BadLength;\n\tgoto bail;\n    }\n    if (!ResizeGlyphSet (glyphSet, nglyphs))\n    {\n\terr = BadAlloc;\n\tgoto bail;\n    }\n    for (i = 0; i < nglyphs; i++)\n\tAddGlyph (glyphSet, glyphs[i].glyph, glyphs[i].id);\n\n    if (glyphsBase != glyphsLocal)\n\tfree(glyphsBase);\n    return Success;\nbail:\n    if (pSrc)\n\tFreePicture ((pointer) pSrc, 0);\n    if (pSrcPix)\n\tFreeScratchPixmapHeader (pSrcPix);\n    for (i = 0; i < nglyphs; i++)\n\tif (glyphs[i].glyph && ! glyphs[i].found)\n\t    free(glyphs[i].glyph);\n    if (glyphsBase != glyphsLocal)\n\tfree(glyphsBase);\n    return err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144618,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void virtqueue_map_desc(unsigned int *p_num_sg, hwaddr *addr, struct iovec *iov,\n                               unsigned int max_num_sg, bool is_write,\n                               hwaddr pa, size_t sz)\n{\n    unsigned num_sg = *p_num_sg;\n    assert(num_sg <= max_num_sg);\n\n    while (sz) {\n        hwaddr len = sz;\n\n        if (num_sg == max_num_sg) {\n            error_report(\"virtio: too many write descriptors in indirect table\");\n            exit(1);\n        }\n\n        iov[num_sg].iov_base = cpu_physical_memory_map(pa, &len, is_write);\n        iov[num_sg].iov_len = len;\n        addr[num_sg] = pa;\n\n        sz -= len;\n        pa += len;\n        num_sg++;\n    }\n    *p_num_sg = num_sg;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144623,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void virtqueue_map_desc(unsigned int *p_num_sg, hwaddr *addr, struct iovec *iov,\n                               unsigned int max_num_sg, bool is_write,\n                               hwaddr pa, size_t sz)\n{\n     unsigned num_sg = *p_num_sg;\n     assert(num_sg <= max_num_sg);\n \n    if (!sz) {\n        error_report(\"virtio: zero sized buffers are not allowed\");\n        exit(1);\n    }\n\n     while (sz) {\n         hwaddr len = sz;\n        iov[num_sg].iov_base = cpu_physical_memory_map(pa, &len, is_write);\n        iov[num_sg].iov_len = len;\n        addr[num_sg] = pa;\n\n        sz -= len;\n        pa += len;\n        num_sg++;\n    }\n    *p_num_sg = num_sg;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144624,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "do_uncompress( compress_filter_context_t *zfx, z_stream *zs,\n\t       IOBUF a, size_t *ret_len )\n{\n    int zrc;\n    int rc=0;\n    size_t n;\n    int nread, count;\n    int refill = !zs->avail_in;\n\n    if( DBG_FILTER )\n\tlog_debug(\"begin inflate: avail_in=%u, avail_out=%u, inbuf=%u\\n\",\n\t\t(unsigned)zs->avail_in, (unsigned)zs->avail_out,\n\t\t(unsigned)zfx->inbufsize );\n    do {\n\tif( zs->avail_in < zfx->inbufsize && refill ) {\n\t    n = zs->avail_in;\n\t    if( !n )\n            zs->next_in = BYTEF_CAST (zfx->inbuf);\n\t    count = zfx->inbufsize - n;\n\t    nread = iobuf_read( a, zfx->inbuf + n, count );\n\t    if( nread == -1 ) nread = 0;\n\t    n += nread;\n\t    /* If we use the undocumented feature to suppress\n\t     * the zlib header, we have to give inflate an\n\t     * extra dummy byte to read */\n\t    if( nread < count && zfx->algo == 1 ) {\n\t\t*(zfx->inbuf + n) = 0xFF; /* is it really needed ? */\n\t\tzfx->algo1hack = 1;\n\t\tn++;\n\t    }\n\t    zs->avail_in = n;\n\t}\n\trefill = 1;\n\tif( DBG_FILTER )\n\t    log_debug(\"enter inflate: avail_in=%u, avail_out=%u\\n\",\n\t\t    (unsigned)zs->avail_in, (unsigned)zs->avail_out);\n\tzrc = inflate ( zs, Z_SYNC_FLUSH );\n\tif( DBG_FILTER )\n\t    log_debug(\"leave inflate: avail_in=%u, avail_out=%u, zrc=%d\\n\",\n\t\t   (unsigned)zs->avail_in, (unsigned)zs->avail_out, zrc);\n\tif( zrc == Z_STREAM_END )\n\t    rc = -1; /* eof */\n\telse if( zrc != Z_OK && zrc != Z_BUF_ERROR ) {\n\t    if( zs->msg )\n\t\tlog_fatal(\"zlib inflate problem: %s\\n\", zs->msg );\n\t    else\n\t\tlog_fatal(\"zlib inflate problem: rc=%d\\n\", zrc );\n\t}\n    } while( zs->avail_out && zrc != Z_STREAM_END && zrc != Z_BUF_ERROR );\n\n    *ret_len = zfx->outbufsize - zs->avail_out;\n    if( DBG_FILTER )\n\tlog_debug(\"do_uncompress: returning %u bytes (%u ignored)\\n\",\n                  (unsigned int)*ret_len, (unsigned int)zs->avail_in );\n    return rc;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144627,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "do_uncompress( compress_filter_context_t *zfx, z_stream *zs,\n               IOBUF a, size_t *ret_len )\n {\n     int zrc;\n    int rc = 0;\n    int leave = 0;\n     size_t n;\n     int nread, count;\n     int refill = !zs->avail_in;\n    if( DBG_FILTER )\n\tlog_debug(\"begin inflate: avail_in=%u, avail_out=%u, inbuf=%u\\n\",\n\t\t(unsigned)zs->avail_in, (unsigned)zs->avail_out,\n\t\t(unsigned)zfx->inbufsize );\n    do {\n\tif( zs->avail_in < zfx->inbufsize && refill ) {\n\t    n = zs->avail_in;\n\t    if( !n )\n            zs->next_in = BYTEF_CAST (zfx->inbuf);\n\t    count = zfx->inbufsize - n;\n\t    nread = iobuf_read( a, zfx->inbuf + n, count );\n            nread = iobuf_read( a, zfx->inbuf + n, count );\n            if( nread == -1 ) nread = 0;\n            n += nread;\n           /* Algo 1 has no zlib header which requires us to to give\n            * inflate an extra dummy byte to read. To be on the safe\n            * side we allow for up to 4 ff bytes.  */\n           if( nread < count && zfx->algo == 1 && zfx->algo1hack < 4) {\n               *(zfx->inbuf + n) = 0xFF;\n               zfx->algo1hack++;\n                n++;\n                leave = 1;\n            }\n            zs->avail_in = n;\n        }\n\t    log_debug(\"enter inflate: avail_in=%u, avail_out=%u\\n\",\n\t\t    (unsigned)zs->avail_in, (unsigned)zs->avail_out);\n\tzrc = inflate ( zs, Z_SYNC_FLUSH );\n\tif( DBG_FILTER )\n\t    log_debug(\"leave inflate: avail_in=%u, avail_out=%u, zrc=%d\\n\",\n\t\t   (unsigned)zs->avail_in, (unsigned)zs->avail_out, zrc);\n\tif( zrc == Z_STREAM_END )\n\t    rc = -1; /* eof */\n\telse if( zrc != Z_OK && zrc != Z_BUF_ERROR ) {\n\t    if( zs->msg )\n\t\tlog_fatal(\"zlib inflate problem: %s\\n\", zs->msg );\n\t    else\n\t\tlog_fatal(\"zlib inflate problem: rc=%d\\n\", zrc );\n            else\n                log_fatal(\"zlib inflate problem: rc=%d\\n\", zrc );\n        }\n    } while (zs->avail_out && zrc != Z_STREAM_END && zrc != Z_BUF_ERROR\n             && !leave);\n \n     *ret_len = zfx->outbufsize - zs->avail_out;\n     if( DBG_FILTER )\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144628,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int aac_send_raw_srb(struct aac_dev* dev, void __user * arg)\n{\n\tstruct fib* srbfib;\n\tint status;\n\tstruct aac_srb *srbcmd = NULL;\n\tstruct user_aac_srb *user_srbcmd = NULL;\n\tstruct user_aac_srb __user *user_srb = arg;\n\tstruct aac_srb_reply __user *user_reply;\n\tstruct aac_srb_reply* reply;\n\tu32 fibsize = 0;\n\tu32 flags = 0;\n\ts32 rcode = 0;\n\tu32 data_dir;\n\tvoid __user *sg_user[32];\n\tvoid *sg_list[32];\n\tu32 sg_indx = 0;\n\tu32 byte_count = 0;\n\tu32 actual_fibsize64, actual_fibsize = 0;\n\tint i;\n\n\n\tif (dev->in_reset) {\n\t\tdprintk((KERN_DEBUG\"aacraid: send raw srb -EBUSY\\n\"));\n\t\treturn -EBUSY;\n\t}\n\tif (!capable(CAP_SYS_ADMIN)){\n\t\tdprintk((KERN_DEBUG\"aacraid: No permission to send raw srb\\n\"));\n\t\treturn -EPERM;\n\t}\n\t/*\n\t *\tAllocate and initialize a Fib then setup a SRB command\n\t */\n\tif (!(srbfib = aac_fib_alloc(dev))) {\n\t\treturn -ENOMEM;\n\t}\n\taac_fib_init(srbfib);\n\t/* raw_srb FIB is not FastResponseCapable */\n\tsrbfib->hw_fib_va->header.XferState &= ~cpu_to_le32(FastResponseCapable);\n\n\tsrbcmd = (struct aac_srb*) fib_data(srbfib);\n\n\tmemset(sg_list, 0, sizeof(sg_list)); /* cleanup may take issue */\n\tif(copy_from_user(&fibsize, &user_srb->count,sizeof(u32))){\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy data size from user\\n\"));\n\t\trcode = -EFAULT;\n\t\tgoto cleanup;\n\t}\n\n\tif (fibsize > (dev->max_fib_size - sizeof(struct aac_fibhdr))) {\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\tuser_srbcmd = kmalloc(fibsize, GFP_KERNEL);\n\tif (!user_srbcmd) {\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not make a copy of the srb\\n\"));\n\t\trcode = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\tif(copy_from_user(user_srbcmd, user_srb,fibsize)){\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy srb from user\\n\"));\n\t\trcode = -EFAULT;\n\t\tgoto cleanup;\n\t}\n\n\tuser_reply = arg+fibsize;\n\n\tflags = user_srbcmd->flags; /* from user in cpu order */\n\t// Fix up srb for endian and force some values\n\n\tsrbcmd->function = cpu_to_le32(SRBF_ExecuteScsi);\t// Force this\n\tsrbcmd->channel\t = cpu_to_le32(user_srbcmd->channel);\n\tsrbcmd->id\t = cpu_to_le32(user_srbcmd->id);\n\tsrbcmd->lun\t = cpu_to_le32(user_srbcmd->lun);\n\tsrbcmd->timeout\t = cpu_to_le32(user_srbcmd->timeout);\n\tsrbcmd->flags\t = cpu_to_le32(flags);\n\tsrbcmd->retry_limit = 0; // Obsolete parameter\n\tsrbcmd->cdb_size = cpu_to_le32(user_srbcmd->cdb_size);\n\tmemcpy(srbcmd->cdb, user_srbcmd->cdb, sizeof(srbcmd->cdb));\n\n\tswitch (flags & (SRB_DataIn | SRB_DataOut)) {\n\tcase SRB_DataOut:\n\t\tdata_dir = DMA_TO_DEVICE;\n\t\tbreak;\n\tcase (SRB_DataIn | SRB_DataOut):\n\t\tdata_dir = DMA_BIDIRECTIONAL;\n\t\tbreak;\n\tcase SRB_DataIn:\n\t\tdata_dir = DMA_FROM_DEVICE;\n\t\tbreak;\n\tdefault:\n\t\tdata_dir = DMA_NONE;\n\t}\n\tif (user_srbcmd->sg.count > ARRAY_SIZE(sg_list)) {\n\t\tdprintk((KERN_DEBUG\"aacraid: too many sg entries %d\\n\",\n\t\t  le32_to_cpu(srbcmd->sg.count)));\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\tactual_fibsize = sizeof(struct aac_srb) - sizeof(struct sgentry) +\n\t\t((user_srbcmd->sg.count & 0xff) * sizeof(struct sgentry));\n\tactual_fibsize64 = actual_fibsize + (user_srbcmd->sg.count & 0xff) *\n\t  (sizeof(struct sgentry64) - sizeof(struct sgentry));\n\t/* User made a mistake - should not continue */\n\tif ((actual_fibsize != fibsize) && (actual_fibsize64 != fibsize)) {\n\t\tdprintk((KERN_DEBUG\"aacraid: Bad Size specified in \"\n\t\t  \"Raw SRB command calculated fibsize=%lu;%lu \"\n\t\t  \"user_srbcmd->sg.count=%d aac_srb=%lu sgentry=%lu;%lu \"\n\t\t  \"issued fibsize=%d\\n\",\n\t\t  actual_fibsize, actual_fibsize64, user_srbcmd->sg.count,\n\t\t  sizeof(struct aac_srb), sizeof(struct sgentry),\n\t\t  sizeof(struct sgentry64), fibsize));\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\tif ((data_dir == DMA_NONE) && user_srbcmd->sg.count) {\n\t\tdprintk((KERN_DEBUG\"aacraid: SG with no direction specified in Raw SRB command\\n\"));\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\tbyte_count = 0;\n\tif (dev->adapter_info.options & AAC_OPT_SGMAP_HOST64) {\n\t\tstruct user_sgmap64* upsg = (struct user_sgmap64*)&user_srbcmd->sg;\n\t\tstruct sgmap64* psg = (struct sgmap64*)&srbcmd->sg;\n\n\t\t/*\n\t\t * This should also catch if user used the 32 bit sgmap\n\t\t */\n\t\tif (actual_fibsize64 == fibsize) {\n\t\t\tactual_fibsize = actual_fibsize64;\n\t\t\tfor (i = 0; i < upsg->count; i++) {\n\t\t\t\tu64 addr;\n\t\t\t\tvoid* p;\n\t\t\t\tif (upsg->sg[i].count >\n\t\t\t\t    ((dev->adapter_info.options &\n\t\t\t\t     AAC_OPT_NEW_COMM) ?\n\t\t\t\t      (dev->scsi_host_ptr->max_sectors << 9) :\n\t\t\t\t      65536)) {\n\t\t\t\t\trcode = -EINVAL;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\t/* Does this really need to be GFP_DMA? */\n\t\t\t\tp = kmalloc(upsg->sg[i].count,GFP_KERNEL|__GFP_DMA);\n\t\t\t\tif(!p) {\n\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\\n\",\n\t\t\t\t\t  upsg->sg[i].count,i,upsg->count));\n\t\t\t\t\trcode = -ENOMEM;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\taddr = (u64)upsg->sg[i].addr[0];\n\t\t\t\taddr += ((u64)upsg->sg[i].addr[1]) << 32;\n\t\t\t\tsg_user[i] = (void __user *)(uintptr_t)addr;\n\t\t\t\tsg_list[i] = p; // save so we can clean up later\n\t\t\t\tsg_indx = i;\n\n\t\t\t\tif (flags & SRB_DataOut) {\n\t\t\t\t\tif(copy_from_user(p,sg_user[i],upsg->sg[i].count)){\n\t\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data from user\\n\"));\n\t\t\t\t\t\trcode = -EFAULT;\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddr = pci_map_single(dev->pdev, p, upsg->sg[i].count, data_dir);\n\n\t\t\t\tpsg->sg[i].addr[0] = cpu_to_le32(addr & 0xffffffff);\n\t\t\t\tpsg->sg[i].addr[1] = cpu_to_le32(addr>>32);\n\t\t\t\tbyte_count += upsg->sg[i].count;\n\t\t\t\tpsg->sg[i].count = cpu_to_le32(upsg->sg[i].count);\n\t\t\t}\n\t\t} else {\n\t\t\tstruct user_sgmap* usg;\n\t\t\tusg = kmalloc(actual_fibsize - sizeof(struct aac_srb)\n\t\t\t  + sizeof(struct sgmap), GFP_KERNEL);\n\t\t\tif (!usg) {\n\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Allocation error in Raw SRB command\\n\"));\n\t\t\t\trcode = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tmemcpy (usg, upsg, actual_fibsize - sizeof(struct aac_srb)\n\t\t\t  + sizeof(struct sgmap));\n\t\t\tactual_fibsize = actual_fibsize64;\n\n\t\t\tfor (i = 0; i < usg->count; i++) {\n\t\t\t\tu64 addr;\n\t\t\t\tvoid* p;\n\t\t\t\tif (usg->sg[i].count >\n\t\t\t\t    ((dev->adapter_info.options &\n\t\t\t\t     AAC_OPT_NEW_COMM) ?\n\t\t\t\t      (dev->scsi_host_ptr->max_sectors << 9) :\n\t\t\t\t      65536)) {\n\t\t\t\t\tkfree(usg);\n\t\t\t\t\trcode = -EINVAL;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\t/* Does this really need to be GFP_DMA? */\n\t\t\t\tp = kmalloc(usg->sg[i].count,GFP_KERNEL|__GFP_DMA);\n\t\t\t\tif(!p) {\n\t\t\t\t\tdprintk((KERN_DEBUG \"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\\n\",\n\t\t\t\t\t  usg->sg[i].count,i,usg->count));\n\t\t\t\t\tkfree(usg);\n\t\t\t\t\trcode = -ENOMEM;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tsg_user[i] = (void __user *)(uintptr_t)usg->sg[i].addr;\n\t\t\t\tsg_list[i] = p; // save so we can clean up later\n\t\t\t\tsg_indx = i;\n\n\t\t\t\tif (flags & SRB_DataOut) {\n\t\t\t\t\tif(copy_from_user(p,sg_user[i],upsg->sg[i].count)){\n\t\t\t\t\t\tkfree (usg);\n\t\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data from user\\n\"));\n\t\t\t\t\t\trcode = -EFAULT;\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddr = pci_map_single(dev->pdev, p, usg->sg[i].count, data_dir);\n\n\t\t\t\tpsg->sg[i].addr[0] = cpu_to_le32(addr & 0xffffffff);\n\t\t\t\tpsg->sg[i].addr[1] = cpu_to_le32(addr>>32);\n\t\t\t\tbyte_count += usg->sg[i].count;\n\t\t\t\tpsg->sg[i].count = cpu_to_le32(usg->sg[i].count);\n\t\t\t}\n\t\t\tkfree (usg);\n\t\t}\n\t\tsrbcmd->count = cpu_to_le32(byte_count);\n\t\tpsg->count = cpu_to_le32(sg_indx+1);\n\t\tstatus = aac_fib_send(ScsiPortCommand64, srbfib, actual_fibsize, FsaNormal, 1, 1,NULL,NULL);\n\t} else {\n\t\tstruct user_sgmap* upsg = &user_srbcmd->sg;\n\t\tstruct sgmap* psg = &srbcmd->sg;\n\n\t\tif (actual_fibsize64 == fibsize) {\n\t\t\tstruct user_sgmap64* usg = (struct user_sgmap64 *)upsg;\n\t\t\tfor (i = 0; i < upsg->count; i++) {\n\t\t\t\tuintptr_t addr;\n\t\t\t\tvoid* p;\n\t\t\t\tif (usg->sg[i].count >\n\t\t\t\t    ((dev->adapter_info.options &\n\t\t\t\t     AAC_OPT_NEW_COMM) ?\n\t\t\t\t      (dev->scsi_host_ptr->max_sectors << 9) :\n\t\t\t\t      65536)) {\n\t\t\t\t\trcode = -EINVAL;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\t/* Does this really need to be GFP_DMA? */\n\t\t\t\tp = kmalloc(usg->sg[i].count,GFP_KERNEL|__GFP_DMA);\n\t\t\t\tif(!p) {\n\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\\n\",\n\t\t\t\t\t  usg->sg[i].count,i,usg->count));\n\t\t\t\t\trcode = -ENOMEM;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\taddr = (u64)usg->sg[i].addr[0];\n\t\t\t\taddr += ((u64)usg->sg[i].addr[1]) << 32;\n\t\t\t\tsg_user[i] = (void __user *)addr;\n\t\t\t\tsg_list[i] = p; // save so we can clean up later\n\t\t\t\tsg_indx = i;\n\n\t\t\t\tif (flags & SRB_DataOut) {\n\t\t\t\t\tif(copy_from_user(p,sg_user[i],usg->sg[i].count)){\n\t\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data from user\\n\"));\n\t\t\t\t\t\trcode = -EFAULT;\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddr = pci_map_single(dev->pdev, p, usg->sg[i].count, data_dir);\n\n\t\t\t\tpsg->sg[i].addr = cpu_to_le32(addr & 0xffffffff);\n\t\t\t\tbyte_count += usg->sg[i].count;\n\t\t\t\tpsg->sg[i].count = cpu_to_le32(usg->sg[i].count);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < upsg->count; i++) {\n\t\t\t\tdma_addr_t addr;\n\t\t\t\tvoid* p;\n\t\t\t\tif (upsg->sg[i].count >\n\t\t\t\t    ((dev->adapter_info.options &\n\t\t\t\t     AAC_OPT_NEW_COMM) ?\n\t\t\t\t      (dev->scsi_host_ptr->max_sectors << 9) :\n\t\t\t\t      65536)) {\n\t\t\t\t\trcode = -EINVAL;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tp = kmalloc(upsg->sg[i].count, GFP_KERNEL);\n\t\t\t\tif (!p) {\n\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\\n\",\n\t\t\t\t\t  upsg->sg[i].count, i, upsg->count));\n\t\t\t\t\trcode = -ENOMEM;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tsg_user[i] = (void __user *)(uintptr_t)upsg->sg[i].addr;\n\t\t\t\tsg_list[i] = p; // save so we can clean up later\n\t\t\t\tsg_indx = i;\n\n\t\t\t\tif (flags & SRB_DataOut) {\n\t\t\t\t\tif(copy_from_user(p, sg_user[i],\n\t\t\t\t\t\t\tupsg->sg[i].count)) {\n\t\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data from user\\n\"));\n\t\t\t\t\t\trcode = -EFAULT;\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddr = pci_map_single(dev->pdev, p,\n\t\t\t\t\tupsg->sg[i].count, data_dir);\n\n\t\t\t\tpsg->sg[i].addr = cpu_to_le32(addr);\n\t\t\t\tbyte_count += upsg->sg[i].count;\n\t\t\t\tpsg->sg[i].count = cpu_to_le32(upsg->sg[i].count);\n\t\t\t}\n\t\t}\n\t\tsrbcmd->count = cpu_to_le32(byte_count);\n\t\tpsg->count = cpu_to_le32(sg_indx+1);\n\t\tstatus = aac_fib_send(ScsiPortCommand, srbfib, actual_fibsize, FsaNormal, 1, 1, NULL, NULL);\n\t}\n\tif (status == -ERESTARTSYS) {\n\t\trcode = -ERESTARTSYS;\n\t\tgoto cleanup;\n\t}\n\n\tif (status != 0){\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not send raw srb fib to hba\\n\"));\n\t\trcode = -ENXIO;\n\t\tgoto cleanup;\n\t}\n\n\tif (flags & SRB_DataIn) {\n\t\tfor(i = 0 ; i <= sg_indx; i++){\n\t\t\tbyte_count = le32_to_cpu(\n\t\t\t  (dev->adapter_info.options & AAC_OPT_SGMAP_HOST64)\n\t\t\t      ? ((struct sgmap64*)&srbcmd->sg)->sg[i].count\n\t\t\t      : srbcmd->sg.sg[i].count);\n\t\t\tif(copy_to_user(sg_user[i], sg_list[i], byte_count)){\n\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data to user\\n\"));\n\t\t\t\trcode = -EFAULT;\n\t\t\t\tgoto cleanup;\n\n\t\t\t}\n\t\t}\n\t}\n\n\treply = (struct aac_srb_reply *) fib_data(srbfib);\n\tif(copy_to_user(user_reply,reply,sizeof(struct aac_srb_reply))){\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy reply to user\\n\"));\n\t\trcode = -EFAULT;\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tkfree(user_srbcmd);\n\tfor(i=0; i <= sg_indx; i++){\n\t\tkfree(sg_list[i]);\n\t}\n\tif (rcode != -ERESTARTSYS) {\n\t\taac_fib_complete(srbfib);\n\t\taac_fib_free(srbfib);\n\t}\n\n\treturn rcode;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144649,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int aac_send_raw_srb(struct aac_dev* dev, void __user * arg)\n{\n\tstruct fib* srbfib;\n\tint status;\n\tstruct aac_srb *srbcmd = NULL;\n\tstruct user_aac_srb *user_srbcmd = NULL;\n\tstruct user_aac_srb __user *user_srb = arg;\n\tstruct aac_srb_reply __user *user_reply;\n\tstruct aac_srb_reply* reply;\n\tu32 fibsize = 0;\n\tu32 flags = 0;\n\ts32 rcode = 0;\n\tu32 data_dir;\n\tvoid __user *sg_user[32];\n\tvoid *sg_list[32];\n\tu32 sg_indx = 0;\n\tu32 byte_count = 0;\n\tu32 actual_fibsize64, actual_fibsize = 0;\n\tint i;\n\n\n\tif (dev->in_reset) {\n\t\tdprintk((KERN_DEBUG\"aacraid: send raw srb -EBUSY\\n\"));\n\t\treturn -EBUSY;\n\t}\n\tif (!capable(CAP_SYS_ADMIN)){\n\t\tdprintk((KERN_DEBUG\"aacraid: No permission to send raw srb\\n\"));\n\t\treturn -EPERM;\n\t}\n\t/*\n\t *\tAllocate and initialize a Fib then setup a SRB command\n\t */\n\tif (!(srbfib = aac_fib_alloc(dev))) {\n\t\treturn -ENOMEM;\n\t}\n\taac_fib_init(srbfib);\n\t/* raw_srb FIB is not FastResponseCapable */\n\tsrbfib->hw_fib_va->header.XferState &= ~cpu_to_le32(FastResponseCapable);\n\n\tsrbcmd = (struct aac_srb*) fib_data(srbfib);\n\n\tmemset(sg_list, 0, sizeof(sg_list)); /* cleanup may take issue */\n\tif(copy_from_user(&fibsize, &user_srb->count,sizeof(u32))){\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy data size from user\\n\"));\n\t\trcode = -EFAULT;\n \t\tgoto cleanup;\n \t}\n \n\tif ((fibsize < (sizeof(struct user_aac_srb) - sizeof(struct user_sgentry))) ||\n\t    (fibsize > (dev->max_fib_size - sizeof(struct aac_fibhdr)))) {\n \t\trcode = -EINVAL;\n \t\tgoto cleanup;\n \t}\n\n\tuser_srbcmd = kmalloc(fibsize, GFP_KERNEL);\n\tif (!user_srbcmd) {\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not make a copy of the srb\\n\"));\n\t\trcode = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\tif(copy_from_user(user_srbcmd, user_srb,fibsize)){\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy srb from user\\n\"));\n\t\trcode = -EFAULT;\n\t\tgoto cleanup;\n\t}\n\n\tuser_reply = arg+fibsize;\n\n\tflags = user_srbcmd->flags; /* from user in cpu order */\n\n\tsrbcmd->function = cpu_to_le32(SRBF_ExecuteScsi);\t// Force this\n\tsrbcmd->channel\t = cpu_to_le32(user_srbcmd->channel);\n\tsrbcmd->id\t = cpu_to_le32(user_srbcmd->id);\n\tsrbcmd->lun\t = cpu_to_le32(user_srbcmd->lun);\n\tsrbcmd->timeout\t = cpu_to_le32(user_srbcmd->timeout);\n\tsrbcmd->flags\t = cpu_to_le32(flags);\n\tsrbcmd->retry_limit = 0; // Obsolete parameter\n\tsrbcmd->cdb_size = cpu_to_le32(user_srbcmd->cdb_size);\n\tmemcpy(srbcmd->cdb, user_srbcmd->cdb, sizeof(srbcmd->cdb));\n\n\tswitch (flags & (SRB_DataIn | SRB_DataOut)) {\n\tcase SRB_DataOut:\n\t\tdata_dir = DMA_TO_DEVICE;\n\t\tbreak;\n\tcase (SRB_DataIn | SRB_DataOut):\n\t\tdata_dir = DMA_BIDIRECTIONAL;\n\t\tbreak;\n\tcase SRB_DataIn:\n\t\tdata_dir = DMA_FROM_DEVICE;\n\t\tbreak;\n\tdefault:\n\t\tdata_dir = DMA_NONE;\n\t}\n\tif (user_srbcmd->sg.count > ARRAY_SIZE(sg_list)) {\n\t\tdprintk((KERN_DEBUG\"aacraid: too many sg entries %d\\n\",\n\t\t  le32_to_cpu(srbcmd->sg.count)));\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\tactual_fibsize = sizeof(struct aac_srb) - sizeof(struct sgentry) +\n\t\t((user_srbcmd->sg.count & 0xff) * sizeof(struct sgentry));\n\tactual_fibsize64 = actual_fibsize + (user_srbcmd->sg.count & 0xff) *\n\t  (sizeof(struct sgentry64) - sizeof(struct sgentry));\n\t/* User made a mistake - should not continue */\n\tif ((actual_fibsize != fibsize) && (actual_fibsize64 != fibsize)) {\n\t\tdprintk((KERN_DEBUG\"aacraid: Bad Size specified in \"\n\t\t  \"Raw SRB command calculated fibsize=%lu;%lu \"\n\t\t  \"user_srbcmd->sg.count=%d aac_srb=%lu sgentry=%lu;%lu \"\n\t\t  \"issued fibsize=%d\\n\",\n\t\t  actual_fibsize, actual_fibsize64, user_srbcmd->sg.count,\n\t\t  sizeof(struct aac_srb), sizeof(struct sgentry),\n\t\t  sizeof(struct sgentry64), fibsize));\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\tif ((data_dir == DMA_NONE) && user_srbcmd->sg.count) {\n\t\tdprintk((KERN_DEBUG\"aacraid: SG with no direction specified in Raw SRB command\\n\"));\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\tbyte_count = 0;\n\tif (dev->adapter_info.options & AAC_OPT_SGMAP_HOST64) {\n\t\tstruct user_sgmap64* upsg = (struct user_sgmap64*)&user_srbcmd->sg;\n\t\tstruct sgmap64* psg = (struct sgmap64*)&srbcmd->sg;\n\n\t\t/*\n\t\t * This should also catch if user used the 32 bit sgmap\n\t\t */\n\t\tif (actual_fibsize64 == fibsize) {\n\t\t\tactual_fibsize = actual_fibsize64;\n\t\t\tfor (i = 0; i < upsg->count; i++) {\n\t\t\t\tu64 addr;\n\t\t\t\tvoid* p;\n\t\t\t\tif (upsg->sg[i].count >\n\t\t\t\t    ((dev->adapter_info.options &\n\t\t\t\t     AAC_OPT_NEW_COMM) ?\n\t\t\t\t      (dev->scsi_host_ptr->max_sectors << 9) :\n\t\t\t\t      65536)) {\n\t\t\t\t\trcode = -EINVAL;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\t/* Does this really need to be GFP_DMA? */\n\t\t\t\tp = kmalloc(upsg->sg[i].count,GFP_KERNEL|__GFP_DMA);\n\t\t\t\tif(!p) {\n\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\\n\",\n\t\t\t\t\t  upsg->sg[i].count,i,upsg->count));\n\t\t\t\t\trcode = -ENOMEM;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\taddr = (u64)upsg->sg[i].addr[0];\n\t\t\t\taddr += ((u64)upsg->sg[i].addr[1]) << 32;\n\t\t\t\tsg_user[i] = (void __user *)(uintptr_t)addr;\n\t\t\t\tsg_list[i] = p; // save so we can clean up later\n\t\t\t\tsg_indx = i;\n\n\t\t\t\tif (flags & SRB_DataOut) {\n\t\t\t\t\tif(copy_from_user(p,sg_user[i],upsg->sg[i].count)){\n\t\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data from user\\n\"));\n\t\t\t\t\t\trcode = -EFAULT;\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddr = pci_map_single(dev->pdev, p, upsg->sg[i].count, data_dir);\n\n\t\t\t\tpsg->sg[i].addr[0] = cpu_to_le32(addr & 0xffffffff);\n\t\t\t\tpsg->sg[i].addr[1] = cpu_to_le32(addr>>32);\n\t\t\t\tbyte_count += upsg->sg[i].count;\n\t\t\t\tpsg->sg[i].count = cpu_to_le32(upsg->sg[i].count);\n\t\t\t}\n\t\t} else {\n\t\t\tstruct user_sgmap* usg;\n\t\t\tusg = kmalloc(actual_fibsize - sizeof(struct aac_srb)\n\t\t\t  + sizeof(struct sgmap), GFP_KERNEL);\n\t\t\tif (!usg) {\n\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Allocation error in Raw SRB command\\n\"));\n\t\t\t\trcode = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tmemcpy (usg, upsg, actual_fibsize - sizeof(struct aac_srb)\n\t\t\t  + sizeof(struct sgmap));\n\t\t\tactual_fibsize = actual_fibsize64;\n\n\t\t\tfor (i = 0; i < usg->count; i++) {\n\t\t\t\tu64 addr;\n\t\t\t\tvoid* p;\n\t\t\t\tif (usg->sg[i].count >\n\t\t\t\t    ((dev->adapter_info.options &\n\t\t\t\t     AAC_OPT_NEW_COMM) ?\n\t\t\t\t      (dev->scsi_host_ptr->max_sectors << 9) :\n\t\t\t\t      65536)) {\n\t\t\t\t\tkfree(usg);\n\t\t\t\t\trcode = -EINVAL;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\t/* Does this really need to be GFP_DMA? */\n\t\t\t\tp = kmalloc(usg->sg[i].count,GFP_KERNEL|__GFP_DMA);\n\t\t\t\tif(!p) {\n\t\t\t\t\tdprintk((KERN_DEBUG \"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\\n\",\n\t\t\t\t\t  usg->sg[i].count,i,usg->count));\n\t\t\t\t\tkfree(usg);\n\t\t\t\t\trcode = -ENOMEM;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tsg_user[i] = (void __user *)(uintptr_t)usg->sg[i].addr;\n\t\t\t\tsg_list[i] = p; // save so we can clean up later\n\t\t\t\tsg_indx = i;\n\n\t\t\t\tif (flags & SRB_DataOut) {\n\t\t\t\t\tif(copy_from_user(p,sg_user[i],upsg->sg[i].count)){\n\t\t\t\t\t\tkfree (usg);\n\t\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data from user\\n\"));\n\t\t\t\t\t\trcode = -EFAULT;\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddr = pci_map_single(dev->pdev, p, usg->sg[i].count, data_dir);\n\n\t\t\t\tpsg->sg[i].addr[0] = cpu_to_le32(addr & 0xffffffff);\n\t\t\t\tpsg->sg[i].addr[1] = cpu_to_le32(addr>>32);\n\t\t\t\tbyte_count += usg->sg[i].count;\n\t\t\t\tpsg->sg[i].count = cpu_to_le32(usg->sg[i].count);\n\t\t\t}\n\t\t\tkfree (usg);\n\t\t}\n\t\tsrbcmd->count = cpu_to_le32(byte_count);\n\t\tpsg->count = cpu_to_le32(sg_indx+1);\n\t\tstatus = aac_fib_send(ScsiPortCommand64, srbfib, actual_fibsize, FsaNormal, 1, 1,NULL,NULL);\n\t} else {\n\t\tstruct user_sgmap* upsg = &user_srbcmd->sg;\n\t\tstruct sgmap* psg = &srbcmd->sg;\n\n\t\tif (actual_fibsize64 == fibsize) {\n\t\t\tstruct user_sgmap64* usg = (struct user_sgmap64 *)upsg;\n\t\t\tfor (i = 0; i < upsg->count; i++) {\n\t\t\t\tuintptr_t addr;\n\t\t\t\tvoid* p;\n\t\t\t\tif (usg->sg[i].count >\n\t\t\t\t    ((dev->adapter_info.options &\n\t\t\t\t     AAC_OPT_NEW_COMM) ?\n\t\t\t\t      (dev->scsi_host_ptr->max_sectors << 9) :\n\t\t\t\t      65536)) {\n\t\t\t\t\trcode = -EINVAL;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\t/* Does this really need to be GFP_DMA? */\n\t\t\t\tp = kmalloc(usg->sg[i].count,GFP_KERNEL|__GFP_DMA);\n\t\t\t\tif(!p) {\n\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\\n\",\n\t\t\t\t\t  usg->sg[i].count,i,usg->count));\n\t\t\t\t\trcode = -ENOMEM;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\taddr = (u64)usg->sg[i].addr[0];\n\t\t\t\taddr += ((u64)usg->sg[i].addr[1]) << 32;\n\t\t\t\tsg_user[i] = (void __user *)addr;\n\t\t\t\tsg_list[i] = p; // save so we can clean up later\n\t\t\t\tsg_indx = i;\n\n\t\t\t\tif (flags & SRB_DataOut) {\n\t\t\t\t\tif(copy_from_user(p,sg_user[i],usg->sg[i].count)){\n\t\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data from user\\n\"));\n\t\t\t\t\t\trcode = -EFAULT;\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddr = pci_map_single(dev->pdev, p, usg->sg[i].count, data_dir);\n\n\t\t\t\tpsg->sg[i].addr = cpu_to_le32(addr & 0xffffffff);\n\t\t\t\tbyte_count += usg->sg[i].count;\n\t\t\t\tpsg->sg[i].count = cpu_to_le32(usg->sg[i].count);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < upsg->count; i++) {\n\t\t\t\tdma_addr_t addr;\n\t\t\t\tvoid* p;\n\t\t\t\tif (upsg->sg[i].count >\n\t\t\t\t    ((dev->adapter_info.options &\n\t\t\t\t     AAC_OPT_NEW_COMM) ?\n\t\t\t\t      (dev->scsi_host_ptr->max_sectors << 9) :\n\t\t\t\t      65536)) {\n\t\t\t\t\trcode = -EINVAL;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tp = kmalloc(upsg->sg[i].count, GFP_KERNEL);\n\t\t\t\tif (!p) {\n\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\\n\",\n\t\t\t\t\t  upsg->sg[i].count, i, upsg->count));\n\t\t\t\t\trcode = -ENOMEM;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tsg_user[i] = (void __user *)(uintptr_t)upsg->sg[i].addr;\n\t\t\t\tsg_list[i] = p; // save so we can clean up later\n\t\t\t\tsg_indx = i;\n\n\t\t\t\tif (flags & SRB_DataOut) {\n\t\t\t\t\tif(copy_from_user(p, sg_user[i],\n\t\t\t\t\t\t\tupsg->sg[i].count)) {\n\t\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data from user\\n\"));\n\t\t\t\t\t\trcode = -EFAULT;\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddr = pci_map_single(dev->pdev, p,\n\t\t\t\t\tupsg->sg[i].count, data_dir);\n\n\t\t\t\tpsg->sg[i].addr = cpu_to_le32(addr);\n\t\t\t\tbyte_count += upsg->sg[i].count;\n\t\t\t\tpsg->sg[i].count = cpu_to_le32(upsg->sg[i].count);\n\t\t\t}\n\t\t}\n\t\tsrbcmd->count = cpu_to_le32(byte_count);\n\t\tpsg->count = cpu_to_le32(sg_indx+1);\n\t\tstatus = aac_fib_send(ScsiPortCommand, srbfib, actual_fibsize, FsaNormal, 1, 1, NULL, NULL);\n\t}\n\tif (status == -ERESTARTSYS) {\n\t\trcode = -ERESTARTSYS;\n\t\tgoto cleanup;\n\t}\n\n\tif (status != 0){\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not send raw srb fib to hba\\n\"));\n\t\trcode = -ENXIO;\n\t\tgoto cleanup;\n\t}\n\n\tif (flags & SRB_DataIn) {\n\t\tfor(i = 0 ; i <= sg_indx; i++){\n\t\t\tbyte_count = le32_to_cpu(\n\t\t\t  (dev->adapter_info.options & AAC_OPT_SGMAP_HOST64)\n\t\t\t      ? ((struct sgmap64*)&srbcmd->sg)->sg[i].count\n\t\t\t      : srbcmd->sg.sg[i].count);\n\t\t\tif(copy_to_user(sg_user[i], sg_list[i], byte_count)){\n\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data to user\\n\"));\n\t\t\t\trcode = -EFAULT;\n\t\t\t\tgoto cleanup;\n\n\t\t\t}\n\t\t}\n\t}\n\n\treply = (struct aac_srb_reply *) fib_data(srbfib);\n\tif(copy_to_user(user_reply,reply,sizeof(struct aac_srb_reply))){\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy reply to user\\n\"));\n\t\trcode = -EFAULT;\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tkfree(user_srbcmd);\n\tfor(i=0; i <= sg_indx; i++){\n\t\tkfree(sg_list[i]);\n\t}\n\tif (rcode != -ERESTARTSYS) {\n\t\taac_fib_complete(srbfib);\n\t\taac_fib_free(srbfib);\n\t}\n\n\treturn rcode;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144650,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void vmxnet3_activate_device(VMXNET3State *s)\n{\n    int i;\n    static const uint32_t VMXNET3_DEF_TX_THRESHOLD = 1;\n    hwaddr qdescr_table_pa;\n    uint64_t pa;\n    uint32_t size;\n\n    /* Verify configuration consistency */\n    if (!vmxnet3_verify_driver_magic(s->drv_shmem)) {\n        VMW_ERPRN(\"Device configuration received from driver is invalid\");\n        return;\n    }\n\n    vmxnet3_adjust_by_guest_type(s);\n    vmxnet3_update_features(s);\n    vmxnet3_update_pm_state(s);\n    vmxnet3_setup_rx_filtering(s);\n    /* Cache fields from shared memory */\n    s->mtu = VMXNET3_READ_DRV_SHARED32(s->drv_shmem, devRead.misc.mtu);\n    VMW_CFPRN(\"MTU is %u\", s->mtu);\n\n    s->max_rx_frags =\n        VMXNET3_READ_DRV_SHARED16(s->drv_shmem, devRead.misc.maxNumRxSG);\n\n    if (s->max_rx_frags == 0) {\n        s->max_rx_frags = 1;\n    }\n\n    VMW_CFPRN(\"Max RX fragments is %u\", s->max_rx_frags);\n\n    s->event_int_idx =\n        VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.intrConf.eventIntrIdx);\n    assert(vmxnet3_verify_intx(s, s->event_int_idx));\n    VMW_CFPRN(\"Events interrupt line is %u\", s->event_int_idx);\n\n    s->auto_int_masking =\n        VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.intrConf.autoMask);\n    VMW_CFPRN(\"Automatic interrupt masking is %d\", (int)s->auto_int_masking);\n\n    s->txq_num =\n        VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.misc.numTxQueues);\n    s->rxq_num =\n        VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.misc.numRxQueues);\n\n    VMW_CFPRN(\"Number of TX/RX queues %u/%u\", s->txq_num, s->rxq_num);\n    assert(s->txq_num <= VMXNET3_DEVICE_MAX_TX_QUEUES);\n\n    qdescr_table_pa =\n        VMXNET3_READ_DRV_SHARED64(s->drv_shmem, devRead.misc.queueDescPA);\n    VMW_CFPRN(\"TX queues descriptors table is at 0x%\" PRIx64, qdescr_table_pa);\n\n    /*\n     * Worst-case scenario is a packet that holds all TX rings space so\n     * we calculate total size of all TX rings for max TX fragments number\n     */\n    s->max_tx_frags = 0;\n\n    /* TX queues */\n    for (i = 0; i < s->txq_num; i++) {\n        hwaddr qdescr_pa =\n            qdescr_table_pa + i * sizeof(struct Vmxnet3_TxQueueDesc);\n\n        /* Read interrupt number for this TX queue */\n        s->txq_descr[i].intr_idx =\n            VMXNET3_READ_TX_QUEUE_DESCR8(qdescr_pa, conf.intrIdx);\n        assert(vmxnet3_verify_intx(s, s->txq_descr[i].intr_idx));\n\n        VMW_CFPRN(\"TX Queue %d interrupt: %d\", i, s->txq_descr[i].intr_idx);\n\n        /* Read rings memory locations for TX queues */\n        pa = VMXNET3_READ_TX_QUEUE_DESCR64(qdescr_pa, conf.txRingBasePA);\n        size = VMXNET3_READ_TX_QUEUE_DESCR32(qdescr_pa, conf.txRingSize);\n\n        vmxnet3_ring_init(&s->txq_descr[i].tx_ring, pa, size,\n                          sizeof(struct Vmxnet3_TxDesc), false);\n        VMXNET3_RING_DUMP(VMW_CFPRN, \"TX\", i, &s->txq_descr[i].tx_ring);\n\n        s->max_tx_frags += size;\n\n        /* TXC ring */\n        pa = VMXNET3_READ_TX_QUEUE_DESCR64(qdescr_pa, conf.compRingBasePA);\n        size = VMXNET3_READ_TX_QUEUE_DESCR32(qdescr_pa, conf.compRingSize);\n        vmxnet3_ring_init(&s->txq_descr[i].comp_ring, pa, size,\n                          sizeof(struct Vmxnet3_TxCompDesc), true);\n        VMXNET3_RING_DUMP(VMW_CFPRN, \"TXC\", i, &s->txq_descr[i].comp_ring);\n\n        s->txq_descr[i].tx_stats_pa =\n            qdescr_pa + offsetof(struct Vmxnet3_TxQueueDesc, stats);\n\n        memset(&s->txq_descr[i].txq_stats, 0,\n               sizeof(s->txq_descr[i].txq_stats));\n\n        /* Fill device-managed parameters for queues */\n        VMXNET3_WRITE_TX_QUEUE_DESCR32(qdescr_pa,\n                                       ctrl.txThreshold,\n                                       VMXNET3_DEF_TX_THRESHOLD);\n    }\n\n    /* Preallocate TX packet wrapper */\n    VMW_CFPRN(\"Max TX fragments is %u\", s->max_tx_frags);\n    vmxnet_tx_pkt_init(&s->tx_pkt, s->max_tx_frags, s->peer_has_vhdr);\n    vmxnet_rx_pkt_init(&s->rx_pkt, s->peer_has_vhdr);\n\n    /* Read rings memory locations for RX queues */\n    for (i = 0; i < s->rxq_num; i++) {\n        int j;\n        hwaddr qd_pa =\n            qdescr_table_pa + s->txq_num * sizeof(struct Vmxnet3_TxQueueDesc) +\n            i * sizeof(struct Vmxnet3_RxQueueDesc);\n\n        /* Read interrupt number for this RX queue */\n        s->rxq_descr[i].intr_idx =\n            VMXNET3_READ_TX_QUEUE_DESCR8(qd_pa, conf.intrIdx);\n        assert(vmxnet3_verify_intx(s, s->rxq_descr[i].intr_idx));\n\n        VMW_CFPRN(\"RX Queue %d interrupt: %d\", i, s->rxq_descr[i].intr_idx);\n\n        /* Read rings memory locations */\n        for (j = 0; j < VMXNET3_RX_RINGS_PER_QUEUE; j++) {\n            /* RX rings */\n            pa = VMXNET3_READ_RX_QUEUE_DESCR64(qd_pa, conf.rxRingBasePA[j]);\n            size = VMXNET3_READ_RX_QUEUE_DESCR32(qd_pa, conf.rxRingSize[j]);\n            vmxnet3_ring_init(&s->rxq_descr[i].rx_ring[j], pa, size,\n                              sizeof(struct Vmxnet3_RxDesc), false);\n            VMW_CFPRN(\"RX queue %d:%d: Base: %\" PRIx64 \", Size: %d\",\n                      i, j, pa, size);\n        }\n\n        /* RXC ring */\n        pa = VMXNET3_READ_RX_QUEUE_DESCR64(qd_pa, conf.compRingBasePA);\n        size = VMXNET3_READ_RX_QUEUE_DESCR32(qd_pa, conf.compRingSize);\n        vmxnet3_ring_init(&s->rxq_descr[i].comp_ring, pa, size,\n                          sizeof(struct Vmxnet3_RxCompDesc), true);\n        VMW_CFPRN(\"RXC queue %d: Base: %\" PRIx64 \", Size: %d\", i, pa, size);\n\n        s->rxq_descr[i].rx_stats_pa =\n            qd_pa + offsetof(struct Vmxnet3_RxQueueDesc, stats);\n        memset(&s->rxq_descr[i].rxq_stats, 0,\n               sizeof(s->rxq_descr[i].rxq_stats));\n    }\n\n    vmxnet3_validate_interrupts(s);\n\n    /* Make sure everything is in place before device activation */\n    smp_wmb();\n\n    vmxnet3_reset_mac(s);\n\n    s->device_active = true;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144661,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": " static void vmxnet3_activate_device(VMXNET3State *s)\n {\n     int i;\n    VMW_CFPRN(\"MTU is %u\", s->mtu);\n\n    s->max_rx_frags =\n        VMXNET3_READ_DRV_SHARED16(s->drv_shmem, devRead.misc.maxNumRxSG);\n\n    if (s->max_rx_frags == 0) {\n        s->max_rx_frags = 1;\n    }\n\n    VMW_CFPRN(\"Max RX fragments is %u\", s->max_rx_frags);\n\n    s->event_int_idx =\n        VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.intrConf.eventIntrIdx);\n    assert(vmxnet3_verify_intx(s, s->event_int_idx));\n    VMW_CFPRN(\"Events interrupt line is %u\", s->event_int_idx);\n\n    s->auto_int_masking =\n        VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.intrConf.autoMask);\n    VMW_CFPRN(\"Automatic interrupt masking is %d\", (int)s->auto_int_masking);\n\n    s->txq_num =\n        VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.misc.numTxQueues);\n    s->rxq_num =\n        VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.misc.numRxQueues);\n\n    VMW_CFPRN(\"Number of TX/RX queues %u/%u\", s->txq_num, s->rxq_num);\n    assert(s->txq_num <= VMXNET3_DEVICE_MAX_TX_QUEUES);\n\n    qdescr_table_pa =\n        VMXNET3_READ_DRV_SHARED64(s->drv_shmem, devRead.misc.queueDescPA);\n    VMW_CFPRN(\"TX queues descriptors table is at 0x%\" PRIx64, qdescr_table_pa);\n\n    /*\n     * Worst-case scenario is a packet that holds all TX rings space so\n     * we calculate total size of all TX rings for max TX fragments number\n     */\n    s->max_tx_frags = 0;\n\n    /* TX queues */\n    for (i = 0; i < s->txq_num; i++) {\n         VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.misc.numRxQueues);\n \n     VMW_CFPRN(\"Number of TX/RX queues %u/%u\", s->txq_num, s->rxq_num);\n    vmxnet3_validate_queues(s);\n \n     qdescr_table_pa =\n         VMXNET3_READ_DRV_SHARED64(s->drv_shmem, devRead.misc.queueDescPA);\n\n        VMW_CFPRN(\"TX Queue %d interrupt: %d\", i, s->txq_descr[i].intr_idx);\n\n        /* Read rings memory locations for TX queues */\n        pa = VMXNET3_READ_TX_QUEUE_DESCR64(qdescr_pa, conf.txRingBasePA);\n        size = VMXNET3_READ_TX_QUEUE_DESCR32(qdescr_pa, conf.txRingSize);\n\n        vmxnet3_ring_init(&s->txq_descr[i].tx_ring, pa, size,\n                          sizeof(struct Vmxnet3_TxDesc), false);\n        VMXNET3_RING_DUMP(VMW_CFPRN, \"TX\", i, &s->txq_descr[i].tx_ring);\n\n        s->max_tx_frags += size;\n\n        /* TXC ring */\n        pa = VMXNET3_READ_TX_QUEUE_DESCR64(qdescr_pa, conf.compRingBasePA);\n        size = VMXNET3_READ_TX_QUEUE_DESCR32(qdescr_pa, conf.compRingSize);\n        vmxnet3_ring_init(&s->txq_descr[i].comp_ring, pa, size,\n                          sizeof(struct Vmxnet3_TxCompDesc), true);\n        VMXNET3_RING_DUMP(VMW_CFPRN, \"TXC\", i, &s->txq_descr[i].comp_ring);\n\n        s->txq_descr[i].tx_stats_pa =\n            qdescr_pa + offsetof(struct Vmxnet3_TxQueueDesc, stats);\n\n        memset(&s->txq_descr[i].txq_stats, 0,\n               sizeof(s->txq_descr[i].txq_stats));\n\n        /* Fill device-managed parameters for queues */\n        VMXNET3_WRITE_TX_QUEUE_DESCR32(qdescr_pa,\n                                       ctrl.txThreshold,\n                                       VMXNET3_DEF_TX_THRESHOLD);\n    }\n\n    /* Preallocate TX packet wrapper */\n    VMW_CFPRN(\"Max TX fragments is %u\", s->max_tx_frags);\n    vmxnet_tx_pkt_init(&s->tx_pkt, s->max_tx_frags, s->peer_has_vhdr);\n    vmxnet_rx_pkt_init(&s->rx_pkt, s->peer_has_vhdr);\n\n    /* Read rings memory locations for RX queues */\n    for (i = 0; i < s->rxq_num; i++) {\n        int j;\n        hwaddr qd_pa =\n            qdescr_table_pa + s->txq_num * sizeof(struct Vmxnet3_TxQueueDesc) +\n            i * sizeof(struct Vmxnet3_RxQueueDesc);\n\n        /* Read interrupt number for this RX queue */\n        s->rxq_descr[i].intr_idx =\n            VMXNET3_READ_TX_QUEUE_DESCR8(qd_pa, conf.intrIdx);\n        assert(vmxnet3_verify_intx(s, s->rxq_descr[i].intr_idx));\n\n        VMW_CFPRN(\"RX Queue %d interrupt: %d\", i, s->rxq_descr[i].intr_idx);\n\n        /* Read rings memory locations */\n        for (j = 0; j < VMXNET3_RX_RINGS_PER_QUEUE; j++) {\n            /* RX rings */\n            pa = VMXNET3_READ_RX_QUEUE_DESCR64(qd_pa, conf.rxRingBasePA[j]);\n            size = VMXNET3_READ_RX_QUEUE_DESCR32(qd_pa, conf.rxRingSize[j]);\n            vmxnet3_ring_init(&s->rxq_descr[i].rx_ring[j], pa, size,\n                              sizeof(struct Vmxnet3_RxDesc), false);\n            VMW_CFPRN(\"RX queue %d:%d: Base: %\" PRIx64 \", Size: %d\",\n                      i, j, pa, size);\n        }\n\n        /* RXC ring */\n        pa = VMXNET3_READ_RX_QUEUE_DESCR64(qd_pa, conf.compRingBasePA);\n        size = VMXNET3_READ_RX_QUEUE_DESCR32(qd_pa, conf.compRingSize);\n        vmxnet3_ring_init(&s->rxq_descr[i].comp_ring, pa, size,\n                          sizeof(struct Vmxnet3_RxCompDesc), true);\n        VMW_CFPRN(\"RXC queue %d: Base: %\" PRIx64 \", Size: %d\", i, pa, size);\n\n        s->rxq_descr[i].rx_stats_pa =\n            qd_pa + offsetof(struct Vmxnet3_RxQueueDesc, stats);\n        memset(&s->rxq_descr[i].rxq_stats, 0,\n               sizeof(s->rxq_descr[i].rxq_stats));\n    }\n\n    vmxnet3_validate_interrupts(s);\n\n    /* Make sure everything is in place before device activation */\n    smp_wmb();\n\n    vmxnet3_reset_mac(s);\n\n    s->device_active = true;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144662,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void WriteTo8BimProfile(Image *image,const char *name,\n  const StringInfo *profile)\n{\n  const unsigned char\n    *datum,\n    *q;\n\n  register const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *profile_8bim;\n\n  ssize_t\n    count;\n\n  unsigned char\n    length_byte;\n\n  unsigned int\n    value;\n\n  unsigned short\n    id,\n    profile_id;\n\n  if (LocaleCompare(name,\"icc\") == 0)\n    profile_id=0x040f;\n  else\n    if (LocaleCompare(name,\"iptc\") == 0)\n      profile_id=0x0404;\n    else\n      if (LocaleCompare(name,\"xmp\") == 0)\n        profile_id=0x0424;\n      else\n        return;\n  profile_8bim=(StringInfo *) GetValueFromSplayTree((SplayTreeInfo *)\n    image->profiles,\"8bim\");\n  if (profile_8bim == (StringInfo *) NULL)\n    return;\n  datum=GetStringInfoDatum(profile_8bim);\n  length=GetStringInfoLength(profile_8bim);\n  for (p=datum; p < (datum+length-16); )\n  {\n    q=p;\n    if (LocaleNCompare((char *) p,\"8BIM\",4) != 0)\n      break;\n    p+=4;\n    p=ReadResourceShort(p,&id);\n    p=ReadResourceByte(p,&length_byte);\n    p+=length_byte;\n    if (((length_byte+1) & 0x01) != 0)\n      p++;\n    if (p > (datum+length-4))\n      break;\n    p=ReadResourceLong(p,&value);\n    count=(ssize_t) value;\n    if ((count & 0x01) != 0)\n      count++;\n    if ((p > (datum+length-count)) || (count > (ssize_t) length))\n      break;\n    if (id != profile_id)\n      p+=count;\n    else\n      {\n        size_t\n          extent,\n          offset;\n\n        ssize_t\n          extract_count;\n\n        StringInfo\n          *extract_profile;\n\n        extract_count=0;\n        extent=(datum+length)-(p+count);\n        if (profile == (StringInfo *) NULL)\n          {\n            offset=(q-datum);\n            extract_profile=AcquireStringInfo(offset+extent);\n            (void) CopyMagickMemory(extract_profile->datum,datum,offset);\n          }\n        else\n          {\n            offset=(p-datum);\n            extract_count=profile->length;\n            if ((extract_count & 0x01) != 0)\n              extract_count++;\n            extract_profile=AcquireStringInfo(offset+extract_count+extent);\n            (void) CopyMagickMemory(extract_profile->datum,datum,offset-4);\n            WriteResourceLong(extract_profile->datum+offset-4,\n              (unsigned int)profile->length);\n            (void) CopyMagickMemory(extract_profile->datum+offset,\n              profile->datum,profile->length);\n          }\n        (void) CopyMagickMemory(extract_profile->datum+offset+extract_count,\n          p+count,extent);\n        (void) AddValueToSplayTree((SplayTreeInfo *) image->profiles,\n          ConstantString(\"8bim\"),CloneStringInfo(extract_profile));\n        extract_profile=DestroyStringInfo(extract_profile);\n        break;\n      }\n  }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144719,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void WriteTo8BimProfile(Image *image,const char *name,\n  const StringInfo *profile)\n{\n  const unsigned char\n    *datum,\n    *q;\n\n  register const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *profile_8bim;\n\n  ssize_t\n    count;\n\n  unsigned char\n    length_byte;\n\n  unsigned int\n    value;\n\n  unsigned short\n    id,\n    profile_id;\n\n  if (LocaleCompare(name,\"icc\") == 0)\n    profile_id=0x040f;\n  else\n    if (LocaleCompare(name,\"iptc\") == 0)\n      profile_id=0x0404;\n    else\n      if (LocaleCompare(name,\"xmp\") == 0)\n        profile_id=0x0424;\n      else\n        return;\n  profile_8bim=(StringInfo *) GetValueFromSplayTree((SplayTreeInfo *)\n    image->profiles,\"8bim\");\n  if (profile_8bim == (StringInfo *) NULL)\n    return;\n  datum=GetStringInfoDatum(profile_8bim);\n  length=GetStringInfoLength(profile_8bim);\n  for (p=datum; p < (datum+length-16); )\n  {\n    q=p;\n    if (LocaleNCompare((char *) p,\"8BIM\",4) != 0)\n      break;\n    p+=4;\n    p=ReadResourceShort(p,&id);\n    p=ReadResourceByte(p,&length_byte);\n    p+=length_byte;\n    if (((length_byte+1) & 0x01) != 0)\n      p++;\n    if (p > (datum+length-4))\n      break;\n    p=ReadResourceLong(p,&value);\n    count=(ssize_t) value;\n    if ((count & 0x01) != 0)\n      count++;\n    if ((count < 0) || (p > (datum+length-count)) ||\n        (count > (ssize_t) length))\n      break;\n    if (id != profile_id)\n      p+=count;\n    else\n      {\n        size_t\n          extent,\n          offset;\n\n        ssize_t\n          extract_count;\n\n        StringInfo\n          *extract_profile;\n\n        extract_count=0;\n        extent=(datum+length)-(p+count);\n        if (profile == (StringInfo *) NULL)\n          {\n            offset=(q-datum);\n            extract_profile=AcquireStringInfo(offset+extent);\n            (void) CopyMagickMemory(extract_profile->datum,datum,offset);\n          }\n        else\n          {\n            offset=(p-datum);\n            extract_count=profile->length;\n            if ((extract_count & 0x01) != 0)\n              extract_count++;\n            extract_profile=AcquireStringInfo(offset+extract_count+extent);\n            (void) CopyMagickMemory(extract_profile->datum,datum,offset-4);\n            WriteResourceLong(extract_profile->datum+offset-4,\n              (unsigned int)profile->length);\n            (void) CopyMagickMemory(extract_profile->datum+offset,\n              profile->datum,profile->length);\n          }\n        (void) CopyMagickMemory(extract_profile->datum+offset+extract_count,\n          p+count,extent);\n        (void) AddValueToSplayTree((SplayTreeInfo *) image->profiles,\n          ConstantString(\"8bim\"),CloneStringInfo(extract_profile));\n        extract_profile=DestroyStringInfo(extract_profile);\n        break;\n      }\n  }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144720,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "status WAVEFile::parseFormat(const Tag &id, uint32_t size)\n{\n\tTrack *track = getTrack();\n\n\tuint16_t formatTag;\n\treadU16(&formatTag);\n\tuint16_t channelCount;\n\treadU16(&channelCount);\n\tuint32_t sampleRate;\n\treadU32(&sampleRate);\n\tuint32_t averageBytesPerSecond;\n\treadU32(&averageBytesPerSecond);\n\tuint16_t blockAlign;\n\treadU16(&blockAlign);\n\n\tif (!channelCount)\n\t{\n\t\t_af_error(AF_BAD_CHANNELS, \"invalid file with 0 channels\");\n\t\treturn AF_FAIL;\n\t}\n\n\ttrack->f.channelCount = channelCount;\n\ttrack->f.sampleRate = sampleRate;\n\ttrack->f.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n\n\t/* Default to uncompressed audio data. */\n\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\ttrack->f.framesPerPacket = 1;\n\n\tswitch (formatTag)\n\t{\n\t\tcase WAVE_FORMAT_PCM:\n\t\t{\n\t\t\tuint16_t bitsPerSample;\n\t\t\treadU16(&bitsPerSample);\n\n\t\t\ttrack->f.sampleWidth = bitsPerSample;\n\n\t\t\tif (bitsPerSample == 0 || bitsPerSample > 32)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\t\t\"bad sample width of %d bits\",\n\t\t\t\t\tbitsPerSample);\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\n\t\t\tif (bitsPerSample <= 8)\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_UNSIGNED;\n\t\t\telse\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MULAW:\n\t\tcase IBM_FORMAT_MULAW:\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ULAW;\n\t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_ALAW:\n\t\tcase IBM_FORMAT_ALAW:\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ALAW;\n\t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_IEEE_FLOAT:\n\t\t{\n\t\t\tuint16_t bitsPerSample;\n\t\t\treadU16(&bitsPerSample);\n\n\t\t\tif (bitsPerSample == 64)\n\t\t\t{\n\t\t\t\ttrack->f.sampleWidth = 64;\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_DOUBLE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttrack->f.sampleWidth = 32;\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_FLOAT;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_ADPCM:\n\t\t{\n\t\t\tuint16_t bitsPerSample, extraByteCount,\n\t\t\t\t\tsamplesPerBlock, numCoefficients;\n\n\t\t\tif (track->f.channelCount != 1 &&\n\t\t\t\ttrack->f.channelCount != 2)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_CHANNELS,\n\t\t\t\t\t\"WAVE file with MS ADPCM compression \"\n\t\t\t\t\t\"must have 1 or 2 channels\");\n\t\t\t}\n\n\t\t\treadU16(&bitsPerSample);\n\t\t\treadU16(&extraByteCount);\n\t\t\treadU16(&samplesPerBlock);\n\t\t\treadU16(&numCoefficients);\n\n\t\t\t/* numCoefficients should be at least 7. */\n\t\t\tassert(numCoefficients >= 7 && numCoefficients <= 255);\n\n\t\t\tm_msadpcmNumCoefficients = numCoefficients;\n\n\t\t\tfor (int i=0; i<m_msadpcmNumCoefficients; i++)\n\t\t\t{\n\t\t\t\treadS16(&m_msadpcmCoefficients[i][0]);\n\t\t\t\treadS16(&m_msadpcmCoefficients[i][1]);\n\t\t\t}\n\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_MS_ADPCM;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\n\t\t\ttrack->f.framesPerPacket = samplesPerBlock;\n\t\t\ttrack->f.bytesPerPacket = blockAlign;\n\n\t\t\t// Create the parameter list.\n\t\t\tAUpvlist pv = AUpvnew(2);\n\t\t\tAUpvsetparam(pv, 0, _AF_MS_ADPCM_NUM_COEFFICIENTS);\n\t\t\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\t\t\tlong l = m_msadpcmNumCoefficients;\n\t\t\tAUpvsetval(pv, 0, &l);\n\n\t\t\tAUpvsetparam(pv, 1, _AF_MS_ADPCM_COEFFICIENTS);\n\t\t\tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n\t\t\tvoid *v = m_msadpcmCoefficients;\n\t\t\tAUpvsetval(pv, 1, &v);\n\n\t\t\ttrack->f.compressionParams = pv;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_DVI_ADPCM:\n\t\t{\n\t\t\tuint16_t bitsPerSample, extraByteCount, samplesPerBlock;\n\n\t\t\treadU16(&bitsPerSample);\n\t\t\treadU16(&extraByteCount);\n\t\t\treadU16(&samplesPerBlock);\n\n\t\t\tif (bitsPerSample != 4)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\t\"IMA ADPCM compression supports only 4 bits per sample\");\n\t\t\t}\n\n\t\t\tint bytesPerBlock = (samplesPerBlock + 14) / 8 * 4 * channelCount;\n\t\t\tif (bytesPerBlock > blockAlign || (samplesPerBlock % 8) != 1)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_CODEC_CONFIG,\n\t\t\t\t\t\"Invalid samples per block for IMA ADPCM compression\");\n\t\t\t}\n\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_IMA;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\n\t\t\tinitIMACompressionParams();\n\n\t\t\ttrack->f.framesPerPacket = samplesPerBlock;\n\t\t\ttrack->f.bytesPerPacket = blockAlign;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_EXTENSIBLE:\n\t\t{\n\t\t\tuint16_t bitsPerSample;\n\t\t\treadU16(&bitsPerSample);\n\t\t\tuint16_t extraByteCount;\n\t\t\treadU16(&extraByteCount);\n\t\t\tuint16_t reserved;\n\t\t\treadU16(&reserved);\n\t\t\tuint32_t channelMask;\n\t\t\treadU32(&channelMask);\n\t\t\tUUID subformat;\n\t\t\treadUUID(&subformat);\n\t\t\tif (subformat == _af_wave_guid_pcm)\n\t\t\t{\n\t\t\t\ttrack->f.sampleWidth = bitsPerSample;\n\n\t\t\t\tif (bitsPerSample == 0 || bitsPerSample > 32)\n\t\t\t\t{\n\t\t\t\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\t\t\t\"bad sample width of %d bits\",\n\t\t\t\t\t\tbitsPerSample);\n\t\t\t\t\treturn AF_FAIL;\n\t\t\t\t}\n\n\t\t\t\t// Use valid bits per sample if bytes per sample is the same.\n\t\t\t\tif (reserved <= bitsPerSample &&\n\t\t\t\t\t(reserved + 7) / 8 == (bitsPerSample + 7) / 8)\n\t\t\t\t\ttrack->f.sampleWidth = reserved;\n\n\t\t\t\tif (bitsPerSample <= 8)\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_UNSIGNED;\n\t\t\t\telse\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\t}\n\t\t\telse if (subformat == _af_wave_guid_ieee_float)\n\t\t\t{\n\t\t\t\tif (bitsPerSample == 64)\n\t\t\t\t{\n\t\t\t\t\ttrack->f.sampleWidth = 64;\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_DOUBLE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttrack->f.sampleWidth = 32;\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_FLOAT;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (subformat == _af_wave_guid_alaw ||\n\t\t\t\tsubformat == _af_wave_guid_ulaw)\n\t\t\t{\n\t\t\t\ttrack->f.compressionType = subformat == _af_wave_guid_alaw ?\n\t\t\t\t\tAF_COMPRESSION_G711_ALAW : AF_COMPRESSION_G711_ULAW;\n\t\t\t\ttrack->f.sampleWidth = 16;\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t\t\ttrack->f.bytesPerPacket = channelCount;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE extensible data format %s is not currently supported\", subformat.name().c_str());\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_YAMAHA_ADPCM:\n\t\tcase WAVE_FORMAT_OKI_ADPCM:\n\t\tcase WAVE_FORMAT_CREATIVE_ADPCM:\n\t\tcase IBM_FORMAT_ADPCM:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE ADPCM data format 0x%x is not currently supported\", formatTag);\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MPEG:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE MPEG data format is not supported\");\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MPEGLAYER3:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE MPEG layer 3 data format is not supported\");\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE file data format 0x%x not currently supported != 0xfffe ? %d, != EXTENSIBLE? %d\", formatTag, formatTag != 0xfffe, formatTag != WAVE_FORMAT_EXTENSIBLE);\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\t}\n\n\tif (track->f.isUncompressed())\n\t\ttrack->f.computeBytesPerPacketPCM();\n\n\t_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth);\n\n\treturn AF_SUCCEED;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144737,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "status WAVEFile::parseFormat(const Tag &id, uint32_t size)\n{\n\tTrack *track = getTrack();\n\n\tuint16_t formatTag;\n\treadU16(&formatTag);\n\tuint16_t channelCount;\n\treadU16(&channelCount);\n\tuint32_t sampleRate;\n\treadU32(&sampleRate);\n\tuint32_t averageBytesPerSecond;\n\treadU32(&averageBytesPerSecond);\n\tuint16_t blockAlign;\n\treadU16(&blockAlign);\n\n\tif (!channelCount)\n\t{\n\t\t_af_error(AF_BAD_CHANNELS, \"invalid file with 0 channels\");\n\t\treturn AF_FAIL;\n\t}\n\n\ttrack->f.channelCount = channelCount;\n\ttrack->f.sampleRate = sampleRate;\n\ttrack->f.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n\n\t/* Default to uncompressed audio data. */\n\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\ttrack->f.framesPerPacket = 1;\n\n\tswitch (formatTag)\n\t{\n\t\tcase WAVE_FORMAT_PCM:\n\t\t{\n\t\t\tuint16_t bitsPerSample;\n\t\t\treadU16(&bitsPerSample);\n\n\t\t\ttrack->f.sampleWidth = bitsPerSample;\n\n\t\t\tif (bitsPerSample == 0 || bitsPerSample > 32)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\t\t\"bad sample width of %d bits\",\n\t\t\t\t\tbitsPerSample);\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\n\t\t\tif (bitsPerSample <= 8)\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_UNSIGNED;\n\t\t\telse\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MULAW:\n\t\tcase IBM_FORMAT_MULAW:\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ULAW;\n\t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_ALAW:\n\t\tcase IBM_FORMAT_ALAW:\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ALAW;\n\t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_IEEE_FLOAT:\n\t\t{\n\t\t\tuint16_t bitsPerSample;\n\t\t\treadU16(&bitsPerSample);\n\n\t\t\tif (bitsPerSample == 64)\n\t\t\t{\n\t\t\t\ttrack->f.sampleWidth = 64;\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_DOUBLE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttrack->f.sampleWidth = 32;\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_FLOAT;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_ADPCM:\n\t\t{\n\t\t\tuint16_t bitsPerSample, extraByteCount,\n\t\t\t\t\tsamplesPerBlock, numCoefficients;\n\n\t\t\tif (track->f.channelCount != 1 &&\n\t\t\t\ttrack->f.channelCount != 2)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_CHANNELS,\n\t\t\t\t\t\"WAVE file with MS ADPCM compression \"\n\t\t\t\t\t\"must have 1 or 2 channels\");\n\t\t\t}\n\n\t\t\treadU16(&bitsPerSample);\n\t\t\treadU16(&extraByteCount);\n\t\t\treadU16(&samplesPerBlock);\n\t\t\treadU16(&numCoefficients);\n\n\t\t\t/* numCoefficients should be at least 7. */\n\t\t\tassert(numCoefficients >= 7 && numCoefficients <= 255);\n\t\t\tif (numCoefficients < 7 || numCoefficients > 255)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_HEADER,\n\t\t\t\t\t\t\"Bad number of coefficients\");\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\n\t\t\tm_msadpcmNumCoefficients = numCoefficients;\n\n\t\t\tfor (int i=0; i<m_msadpcmNumCoefficients; i++)\n\t\t\t{\n\t\t\t\treadS16(&m_msadpcmCoefficients[i][0]);\n\t\t\t\treadS16(&m_msadpcmCoefficients[i][1]);\n\t\t\t}\n\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_MS_ADPCM;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\n\t\t\ttrack->f.framesPerPacket = samplesPerBlock;\n\t\t\ttrack->f.bytesPerPacket = blockAlign;\n\n\t\t\t// Create the parameter list.\n\t\t\tAUpvlist pv = AUpvnew(2);\n\t\t\tAUpvsetparam(pv, 0, _AF_MS_ADPCM_NUM_COEFFICIENTS);\n\t\t\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\t\t\tlong l = m_msadpcmNumCoefficients;\n\t\t\tAUpvsetval(pv, 0, &l);\n\n\t\t\tAUpvsetparam(pv, 1, _AF_MS_ADPCM_COEFFICIENTS);\n\t\t\tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n\t\t\tvoid *v = m_msadpcmCoefficients;\n\t\t\tAUpvsetval(pv, 1, &v);\n\n\t\t\ttrack->f.compressionParams = pv;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_DVI_ADPCM:\n\t\t{\n\t\t\tuint16_t bitsPerSample, extraByteCount, samplesPerBlock;\n\n\t\t\treadU16(&bitsPerSample);\n\t\t\treadU16(&extraByteCount);\n\t\t\treadU16(&samplesPerBlock);\n\n\t\t\tif (bitsPerSample != 4)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\t\"IMA ADPCM compression supports only 4 bits per sample\");\n\t\t\t}\n\n\t\t\tint bytesPerBlock = (samplesPerBlock + 14) / 8 * 4 * channelCount;\n\t\t\tif (bytesPerBlock > blockAlign || (samplesPerBlock % 8) != 1)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_CODEC_CONFIG,\n\t\t\t\t\t\"Invalid samples per block for IMA ADPCM compression\");\n\t\t\t}\n\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_IMA;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\n\t\t\tinitIMACompressionParams();\n\n\t\t\ttrack->f.framesPerPacket = samplesPerBlock;\n\t\t\ttrack->f.bytesPerPacket = blockAlign;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_EXTENSIBLE:\n\t\t{\n\t\t\tuint16_t bitsPerSample;\n\t\t\treadU16(&bitsPerSample);\n\t\t\tuint16_t extraByteCount;\n\t\t\treadU16(&extraByteCount);\n\t\t\tuint16_t reserved;\n\t\t\treadU16(&reserved);\n\t\t\tuint32_t channelMask;\n\t\t\treadU32(&channelMask);\n\t\t\tUUID subformat;\n\t\t\treadUUID(&subformat);\n\t\t\tif (subformat == _af_wave_guid_pcm)\n\t\t\t{\n\t\t\t\ttrack->f.sampleWidth = bitsPerSample;\n\n\t\t\t\tif (bitsPerSample == 0 || bitsPerSample > 32)\n\t\t\t\t{\n\t\t\t\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\t\t\t\"bad sample width of %d bits\",\n\t\t\t\t\t\tbitsPerSample);\n\t\t\t\t\treturn AF_FAIL;\n\t\t\t\t}\n\n\t\t\t\t// Use valid bits per sample if bytes per sample is the same.\n\t\t\t\tif (reserved <= bitsPerSample &&\n\t\t\t\t\t(reserved + 7) / 8 == (bitsPerSample + 7) / 8)\n\t\t\t\t\ttrack->f.sampleWidth = reserved;\n\n\t\t\t\tif (bitsPerSample <= 8)\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_UNSIGNED;\n\t\t\t\telse\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\t}\n\t\t\telse if (subformat == _af_wave_guid_ieee_float)\n\t\t\t{\n\t\t\t\tif (bitsPerSample == 64)\n\t\t\t\t{\n\t\t\t\t\ttrack->f.sampleWidth = 64;\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_DOUBLE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttrack->f.sampleWidth = 32;\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_FLOAT;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (subformat == _af_wave_guid_alaw ||\n\t\t\t\tsubformat == _af_wave_guid_ulaw)\n\t\t\t{\n\t\t\t\ttrack->f.compressionType = subformat == _af_wave_guid_alaw ?\n\t\t\t\t\tAF_COMPRESSION_G711_ALAW : AF_COMPRESSION_G711_ULAW;\n\t\t\t\ttrack->f.sampleWidth = 16;\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t\t\ttrack->f.bytesPerPacket = channelCount;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE extensible data format %s is not currently supported\", subformat.name().c_str());\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_YAMAHA_ADPCM:\n\t\tcase WAVE_FORMAT_OKI_ADPCM:\n\t\tcase WAVE_FORMAT_CREATIVE_ADPCM:\n\t\tcase IBM_FORMAT_ADPCM:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE ADPCM data format 0x%x is not currently supported\", formatTag);\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MPEG:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE MPEG data format is not supported\");\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MPEGLAYER3:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE MPEG layer 3 data format is not supported\");\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE file data format 0x%x not currently supported != 0xfffe ? %d, != EXTENSIBLE? %d\", formatTag, formatTag != 0xfffe, formatTag != WAVE_FORMAT_EXTENSIBLE);\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\t}\n\n\tif (track->f.isUncompressed())\n\t\ttrack->f.computeBytesPerPacketPCM();\n\n\t_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth);\n\n\treturn AF_SUCCEED;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144738,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "tcp_sack_option(struct tcpcb *tp, struct tcphdr *th, u_char *cp, int optlen)\n{\n\tint tmp_olen;\n\tu_char *tmp_cp;\n\tstruct sackhole *cur, *p, *temp;\n\n\tif (!tp->sack_enable)\n\t\treturn;\n\t/* SACK without ACK doesn't make sense. */\n\tif ((th->th_flags & TH_ACK) == 0)\n\t       return;\n\t/* Make sure the ACK on this segment is in [snd_una, snd_max]. */\n\tif (SEQ_LT(th->th_ack, tp->snd_una) ||\n\t    SEQ_GT(th->th_ack, tp->snd_max))\n\t\treturn;\n\t/* Note: TCPOLEN_SACK must be 2*sizeof(tcp_seq) */\n\tif (optlen <= 2 || (optlen - 2) % TCPOLEN_SACK != 0)\n\t\treturn;\n\t/* Note: TCPOLEN_SACK must be 2*sizeof(tcp_seq) */\n\ttmp_cp = cp + 2;\n\ttmp_olen = optlen - 2;\n\ttcpstat_inc(tcps_sack_rcv_opts);\n\tif (tp->snd_numholes < 0)\n\t\ttp->snd_numholes = 0;\n\tif (tp->t_maxseg == 0)\n\t\tpanic(\"tcp_sack_option\"); /* Should never happen */\n\twhile (tmp_olen > 0) {\n\t\tstruct sackblk sack;\n\n\t\tmemcpy(&sack.start, tmp_cp, sizeof(tcp_seq));\n\t\tsack.start = ntohl(sack.start);\n\t\tmemcpy(&sack.end, tmp_cp + sizeof(tcp_seq), sizeof(tcp_seq));\n\t\tsack.end = ntohl(sack.end);\n\t\ttmp_olen -= TCPOLEN_SACK;\n\t\ttmp_cp += TCPOLEN_SACK;\n\t\tif (SEQ_LEQ(sack.end, sack.start))\n\t\t\tcontinue; /* bad SACK fields */\n\t\tif (SEQ_LEQ(sack.end, tp->snd_una))\n\t\t\tcontinue; /* old block */\n\t\tif (SEQ_GT(th->th_ack, tp->snd_una)) {\n\t\t\tif (SEQ_LT(sack.start, th->th_ack))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (SEQ_GT(sack.end, tp->snd_max))\n\t\t\tcontinue;\n\t\tif (tp->snd_holes == NULL) { /* first hole */\n\t\t\ttp->snd_holes = (struct sackhole *)\n\t\t\t    pool_get(&sackhl_pool, PR_NOWAIT);\n\t\t\tif (tp->snd_holes == NULL) {\n\t\t\t\t/* ENOBUFS, so ignore SACKed block for now*/\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcur = tp->snd_holes;\n\t\t\tcur->start = th->th_ack;\n\t\t\tcur->end = sack.start;\n\t\t\tcur->rxmit = cur->start;\n\t\t\tcur->next = NULL;\n\t\t\ttp->snd_numholes = 1;\n\t\t\ttp->rcv_lastsack = sack.end;\n\t\t\t/*\n\t\t\t * dups is at least one.  If more data has been\n\t\t\t * SACKed, it can be greater than one.\n\t\t\t */\n\t\t\tcur->dups = min(tcprexmtthresh,\n\t\t\t    ((sack.end - cur->end)/tp->t_maxseg));\n\t\t\tif (cur->dups < 1)\n\t\t\t\tcur->dups = 1;\n\t\t\tcontinue; /* with next sack block */\n\t\t}\n\t\t/* Go thru list of holes:  p = previous,  cur = current */\n\t\tp = cur = tp->snd_holes;\n\t\twhile (cur) {\n\t\t\tif (SEQ_LEQ(sack.end, cur->start))\n\t\t\t\t/* SACKs data before the current hole */\n\t\t\t\tbreak; /* no use going through more holes */\n\t\t\tif (SEQ_GEQ(sack.start, cur->end)) {\n\t\t\t\t/* SACKs data beyond the current hole */\n\t\t\t\tcur->dups++;\n\t\t\t\tif (((sack.end - cur->end)/tp->t_maxseg) >=\n\t\t\t\t    tcprexmtthresh)\n\t\t\t\t\tcur->dups = tcprexmtthresh;\n\t\t\t\tp = cur;\n\t\t\t\tcur = cur->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (SEQ_LEQ(sack.start, cur->start)) {\n\t\t\t\t/* Data acks at least the beginning of hole */\n\t\t\t\tif (SEQ_GEQ(sack.end, cur->end)) {\n\t\t\t\t\t/* Acks entire hole, so delete hole */\n\t\t\t\t\tif (p != cur) {\n\t\t\t\t\t\tp->next = cur->next;\n\t\t\t\t\t\tpool_put(&sackhl_pool, cur);\n\t\t\t\t\t\tcur = p->next;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcur = cur->next;\n\t\t\t\t\t\tpool_put(&sackhl_pool, p);\n\t\t\t\t\t\tp = cur;\n\t\t\t\t\t\ttp->snd_holes = p;\n\t\t\t\t\t}\n\t\t\t\t\ttp->snd_numholes--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* otherwise, move start of hole forward */\n\t\t\t\tcur->start = sack.end;\n\t\t\t\tcur->rxmit = SEQ_MAX(cur->rxmit, cur->start);\n\t\t\t\tp = cur;\n\t\t\t\tcur = cur->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* move end of hole backward */\n\t\t\tif (SEQ_GEQ(sack.end, cur->end)) {\n\t\t\t\tcur->end = sack.start;\n\t\t\t\tcur->rxmit = SEQ_MIN(cur->rxmit, cur->end);\n\t\t\t\tcur->dups++;\n\t\t\t\tif (((sack.end - cur->end)/tp->t_maxseg) >=\n\t\t\t\t    tcprexmtthresh)\n\t\t\t\t\tcur->dups = tcprexmtthresh;\n\t\t\t\tp = cur;\n\t\t\t\tcur = cur->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (SEQ_LT(cur->start, sack.start) &&\n\t\t\t    SEQ_GT(cur->end, sack.end)) {\n\t\t\t\t/*\n\t\t\t\t * ACKs some data in middle of a hole; need to\n\t\t\t\t * split current hole\n\t\t\t\t */\n\t\t\t\ttemp = (struct sackhole *)\n\t\t\t\t    pool_get(&sackhl_pool, PR_NOWAIT);\n\t\t\t\tif (temp == NULL)\n\t\t\t\t\tgoto done; /* ENOBUFS */\n\t\t\t\ttemp->next = cur->next;\n\t\t\t\ttemp->start = sack.end;\n\t\t\t\ttemp->end = cur->end;\n\t\t\t\ttemp->dups = cur->dups;\n\t\t\t\ttemp->rxmit = SEQ_MAX(cur->rxmit, temp->start);\n\t\t\t\tcur->end = sack.start;\n\t\t\t\tcur->rxmit = SEQ_MIN(cur->rxmit, cur->end);\n\t\t\t\tcur->dups++;\n\t\t\t\tif (((sack.end - cur->end)/tp->t_maxseg) >=\n\t\t\t\t\ttcprexmtthresh)\n\t\t\t\t\tcur->dups = tcprexmtthresh;\n\t\t\t\tcur->next = temp;\n\t\t\t\tp = temp;\n\t\t\t\tcur = p->next;\n\t\t\t\ttp->snd_numholes++;\n\t\t\t}\n\t\t}\n\t\t/* At this point, p points to the last hole on the list */\n\t\tif (SEQ_LT(tp->rcv_lastsack, sack.start)) {\n\t\t\t/*\n\t\t\t * Need to append new hole at end.\n\t\t\t * Last hole is p (and it's not NULL).\n\t\t\t */\n\t\t\ttemp = (struct sackhole *)\n\t\t\t    pool_get(&sackhl_pool, PR_NOWAIT);\n\t\t\tif (temp == NULL)\n\t\t\t\tgoto done; /* ENOBUFS */\n\t\t\ttemp->start = tp->rcv_lastsack;\n\t\t\ttemp->end = sack.start;\n\t\t\ttemp->dups = min(tcprexmtthresh,\n\t\t\t    ((sack.end - sack.start)/tp->t_maxseg));\n\t\t\tif (temp->dups < 1)\n\t\t\t\ttemp->dups = 1;\n\t\t\ttemp->rxmit = temp->start;\n\t\t\ttemp->next = 0;\n\t\t\tp->next = temp;\n\t\t\ttp->rcv_lastsack = sack.end;\n\t\t\ttp->snd_numholes++;\n\t\t}\n\t}\ndone:\n\treturn;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144751,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "tcp_sack_option(struct tcpcb *tp, struct tcphdr *th, u_char *cp, int optlen)\n{\n\tint tmp_olen;\n\tu_char *tmp_cp;\n\tstruct sackhole *cur, *p, *temp;\n\n\tif (!tp->sack_enable)\n\t\treturn;\n\t/* SACK without ACK doesn't make sense. */\n\tif ((th->th_flags & TH_ACK) == 0)\n\t       return;\n\t/* Make sure the ACK on this segment is in [snd_una, snd_max]. */\n\tif (SEQ_LT(th->th_ack, tp->snd_una) ||\n\t    SEQ_GT(th->th_ack, tp->snd_max))\n\t\treturn;\n\t/* Note: TCPOLEN_SACK must be 2*sizeof(tcp_seq) */\n\tif (optlen <= 2 || (optlen - 2) % TCPOLEN_SACK != 0)\n\t\treturn;\n\t/* Note: TCPOLEN_SACK must be 2*sizeof(tcp_seq) */\n\ttmp_cp = cp + 2;\n\ttmp_olen = optlen - 2;\n\ttcpstat_inc(tcps_sack_rcv_opts);\n\tif (tp->snd_numholes < 0)\n\t\ttp->snd_numholes = 0;\n\tif (tp->t_maxseg == 0)\n\t\tpanic(\"tcp_sack_option\"); /* Should never happen */\n\twhile (tmp_olen > 0) {\n\t\tstruct sackblk sack;\n\n\t\tmemcpy(&sack.start, tmp_cp, sizeof(tcp_seq));\n\t\tsack.start = ntohl(sack.start);\n\t\tmemcpy(&sack.end, tmp_cp + sizeof(tcp_seq), sizeof(tcp_seq));\n\t\tsack.end = ntohl(sack.end);\n\t\ttmp_olen -= TCPOLEN_SACK;\n\t\ttmp_cp += TCPOLEN_SACK;\n\t\tif (SEQ_LEQ(sack.end, sack.start))\n\t\t\tcontinue; /* bad SACK fields */\n\t\tif (SEQ_LEQ(sack.end, tp->snd_una))\n\t\t\tcontinue; /* old block */\n\t\tif (SEQ_GT(th->th_ack, tp->snd_una)) {\n\t\t\tif (SEQ_LT(sack.start, th->th_ack))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (SEQ_GT(sack.end, tp->snd_max))\n\t\t\tcontinue;\n\t\tif (tp->snd_holes == NULL) { /* first hole */\n\t\t\ttp->snd_holes = (struct sackhole *)\n\t\t\t    pool_get(&sackhl_pool, PR_NOWAIT);\n\t\t\tif (tp->snd_holes == NULL) {\n\t\t\t\t/* ENOBUFS, so ignore SACKed block for now*/\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcur = tp->snd_holes;\n\t\t\tcur->start = th->th_ack;\n\t\t\tcur->end = sack.start;\n\t\t\tcur->rxmit = cur->start;\n\t\t\tcur->next = NULL;\n\t\t\ttp->snd_numholes = 1;\n\t\t\ttp->rcv_lastsack = sack.end;\n\t\t\t/*\n\t\t\t * dups is at least one.  If more data has been\n\t\t\t * SACKed, it can be greater than one.\n\t\t\t */\n\t\t\tcur->dups = min(tcprexmtthresh,\n\t\t\t    ((sack.end - cur->end)/tp->t_maxseg));\n\t\t\tif (cur->dups < 1)\n\t\t\t\tcur->dups = 1;\n\t\t\tcontinue; /* with next sack block */\n\t\t}\n\t\t/* Go thru list of holes:  p = previous,  cur = current */\n\t\tp = cur = tp->snd_holes;\n\t\twhile (cur) {\n\t\t\tif (SEQ_LEQ(sack.end, cur->start))\n\t\t\t\t/* SACKs data before the current hole */\n\t\t\t\tbreak; /* no use going through more holes */\n\t\t\tif (SEQ_GEQ(sack.start, cur->end)) {\n\t\t\t\t/* SACKs data beyond the current hole */\n\t\t\t\tcur->dups++;\n\t\t\t\tif (((sack.end - cur->end)/tp->t_maxseg) >=\n\t\t\t\t    tcprexmtthresh)\n\t\t\t\t\tcur->dups = tcprexmtthresh;\n\t\t\t\tp = cur;\n\t\t\t\tcur = cur->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (SEQ_LEQ(sack.start, cur->start)) {\n\t\t\t\t/* Data acks at least the beginning of hole */\n\t\t\t\tif (SEQ_GEQ(sack.end, cur->end)) {\n\t\t\t\t\t/* Acks entire hole, so delete hole */\n\t\t\t\t\tif (p != cur) {\n\t\t\t\t\t\tp->next = cur->next;\n\t\t\t\t\t\tpool_put(&sackhl_pool, cur);\n\t\t\t\t\t\tcur = p->next;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcur = cur->next;\n\t\t\t\t\t\tpool_put(&sackhl_pool, p);\n\t\t\t\t\t\tp = cur;\n\t\t\t\t\t\ttp->snd_holes = p;\n\t\t\t\t\t}\n\t\t\t\t\ttp->snd_numholes--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* otherwise, move start of hole forward */\n\t\t\t\tcur->start = sack.end;\n\t\t\t\tcur->rxmit = SEQ_MAX(cur->rxmit, cur->start);\n\t\t\t\tp = cur;\n\t\t\t\tcur = cur->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* move end of hole backward */\n\t\t\tif (SEQ_GEQ(sack.end, cur->end)) {\n\t\t\t\tcur->end = sack.start;\n\t\t\t\tcur->rxmit = SEQ_MIN(cur->rxmit, cur->end);\n\t\t\t\tcur->dups++;\n\t\t\t\tif (((sack.end - cur->end)/tp->t_maxseg) >=\n\t\t\t\t    tcprexmtthresh)\n\t\t\t\t\tcur->dups = tcprexmtthresh;\n\t\t\t\tp = cur;\n\t\t\t\tcur = cur->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (SEQ_LT(cur->start, sack.start) &&\n\t\t\t    SEQ_GT(cur->end, sack.end)) {\n\t\t\t\t/*\n\t\t\t\t * ACKs some data in middle of a hole; need to\n\t\t\t\t * split current hole\n\t\t\t\t */\n\t\t\t\tif (tp->snd_numholes >= TCP_SACKHOLE_LIMIT)\n\t\t\t\t\tgoto done;\n\t\t\t\ttemp = (struct sackhole *)\n\t\t\t\t    pool_get(&sackhl_pool, PR_NOWAIT);\n\t\t\t\tif (temp == NULL)\n\t\t\t\t\tgoto done; /* ENOBUFS */\n\t\t\t\ttemp->next = cur->next;\n\t\t\t\ttemp->start = sack.end;\n\t\t\t\ttemp->end = cur->end;\n\t\t\t\ttemp->dups = cur->dups;\n\t\t\t\ttemp->rxmit = SEQ_MAX(cur->rxmit, temp->start);\n\t\t\t\tcur->end = sack.start;\n\t\t\t\tcur->rxmit = SEQ_MIN(cur->rxmit, cur->end);\n\t\t\t\tcur->dups++;\n\t\t\t\tif (((sack.end - cur->end)/tp->t_maxseg) >=\n\t\t\t\t\ttcprexmtthresh)\n\t\t\t\t\tcur->dups = tcprexmtthresh;\n\t\t\t\tcur->next = temp;\n\t\t\t\tp = temp;\n\t\t\t\tcur = p->next;\n\t\t\t\ttp->snd_numholes++;\n\t\t\t}\n\t\t}\n\t\t/* At this point, p points to the last hole on the list */\n\t\tif (SEQ_LT(tp->rcv_lastsack, sack.start)) {\n\t\t\t/*\n\t\t\t * Need to append new hole at end.\n\t\t\t * Last hole is p (and it's not NULL).\n\t\t\t */\n\t\t\tif (tp->snd_numholes >= TCP_SACKHOLE_LIMIT)\n\t\t\t\tgoto done;\n\t\t\ttemp = (struct sackhole *)\n\t\t\t    pool_get(&sackhl_pool, PR_NOWAIT);\n\t\t\tif (temp == NULL)\n\t\t\t\tgoto done; /* ENOBUFS */\n\t\t\ttemp->start = tp->rcv_lastsack;\n\t\t\ttemp->end = sack.start;\n\t\t\ttemp->dups = min(tcprexmtthresh,\n\t\t\t    ((sack.end - sack.start)/tp->t_maxseg));\n\t\t\tif (temp->dups < 1)\n\t\t\t\ttemp->dups = 1;\n\t\t\ttemp->rxmit = temp->start;\n\t\t\ttemp->next = 0;\n\t\t\tp->next = temp;\n\t\t\ttp->rcv_lastsack = sack.end;\n\t\t\ttp->snd_numholes++;\n\t\t}\n\t}\ndone:\n\treturn;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144752,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void rfc1867PostHandler(Transport* transport,\n                        Array& post,\n                        Array& files,\n                        size_t content_length,\n                        const void*& data, size_t& size,\n                        const std::string boundary) {\n  char *s=nullptr, *start_arr=nullptr;\n  std::string array_index, abuf;\n  char *lbuf=nullptr;\n  int total_bytes=0, cancel_upload=0, is_arr_upload=0, array_len=0;\n  int max_file_size=0, skip_upload=0, anonindex=0, is_anonymous;\n  std::set<std::string> &uploaded_files = s_rfc1867_data->rfc1867UploadedFiles;\n  multipart_buffer *mbuff;\n  int fd=-1;\n  void *event_extra_data = nullptr;\n  unsigned int llen = 0;\n  int upload_count = RuntimeOption::MaxFileUploads;\n\n  /* Initialize the buffer */\n  if (!(mbuff = multipart_buffer_new(transport,\n                                     (const char *)data, size, boundary))) {\n    Logger::Warning(\"Unable to initialize the input buffer\");\n    return;\n  }\n\n  /* Initialize $_FILES[] */\n  s_rfc1867_data->rfc1867ProtectedVariables.clear();\n\n  uploaded_files.clear();\n\n  int (*php_rfc1867_callback)(apc_rfc1867_data *rfc1867ApcData,\n                              unsigned int event, void *event_data,\n                              void **extra) = s_rfc1867_data->rfc1867Callback;\n\n  if (php_rfc1867_callback != nullptr) {\n    multipart_event_start event_start;\n\n    event_start.content_length = content_length;\n    if (php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                             MULTIPART_EVENT_START, &event_start,\n                             &event_extra_data) == FAILURE) {\n      goto fileupload_done;\n    }\n  }\n\n  while (!multipart_buffer_eof(mbuff)) {\n    std::string temp_filename;\n    char buff[FILLUNIT];\n    char *cd=nullptr,*param=nullptr,*filename=nullptr, *tmp=nullptr;\n    size_t blen=0, wlen=0;\n    off_t offset;\n\n    header_list header;\n    if (!multipart_buffer_headers(mbuff, header)) {\n      goto fileupload_done;\n    }\n\n    if ((cd = php_mime_get_hdr_value(header, \"Content-Disposition\"))) {\n      char *pair=nullptr;\n      int end=0;\n\n      while (isspace(*cd)) {\n        ++cd;\n      }\n\n      while (*cd && (pair = php_ap_getword(&cd, ';')))\n      {\n        char *key=nullptr, *word = pair;\n\n        while (isspace(*cd)) {\n          ++cd;\n        }\n\n        if (strchr(pair, '=')) {\n          key = php_ap_getword(&pair, '=');\n\n          if (!strcasecmp(key, \"name\")) {\n            if (param) {\n              free(param);\n            }\n            param = php_ap_getword_conf(&pair);\n          } else if (!strcasecmp(key, \"filename\")) {\n            if (filename) {\n              free(filename);\n            }\n            filename = php_ap_getword_conf(&pair);\n          }\n        }\n        if (key) free(key);\n        free(word);\n      }\n\n      /* Normal form variable, safe to read all data into memory */\n      if (!filename && param) {\n        unsigned int value_len;\n        char *value = multipart_buffer_read_body(mbuff, &value_len);\n        unsigned int new_val_len; /* Dummy variable */\n\n        if (!value) {\n          value = strdup(\"\");\n        }\n\n        new_val_len = value_len;\n        if (php_rfc1867_callback != nullptr) {\n          multipart_event_formdata event_formdata;\n          size_t newlength = new_val_len;\n\n          event_formdata.post_bytes_processed = mbuff->read_post_bytes;\n          event_formdata.name = param;\n          event_formdata.value = &value;\n          event_formdata.length = new_val_len;\n          event_formdata.newlength = &newlength;\n          if (php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                                   MULTIPART_EVENT_FORMDATA, &event_formdata,\n                                   &event_extra_data) == FAILURE) {\n            free(param);\n            free(value);\n            continue;\n          }\n          new_val_len = newlength;\n        }\n\n        String val(value, new_val_len, CopyString);\n        safe_php_register_variable(param, val, post, 0);\n\n        if (!strcasecmp(param, \"MAX_FILE_SIZE\")) {\n          max_file_size = atol(value);\n        }\n\n        free(param);\n        free(value);\n        continue;\n      }\n\n      /* If file_uploads=off, skip the file part */\n      if (!RuntimeOption::EnableFileUploads) {\n        skip_upload = 1;\n      } else if (upload_count <= 0) {\n        Logger::Warning(\n          \"Maximum number of allowable file uploads has been exceeded\"\n        );\n        skip_upload = 1;\n      }\n\n      /* Return with an error if the posted data is garbled */\n      if (!param && !filename) {\n        Logger::Warning(\"File Upload Mime headers garbled\");\n        goto fileupload_done;\n      }\n\n      if (!param) {\n        is_anonymous = 1;\n        param = (char*)malloc(MAX_SIZE_ANONNAME);\n        snprintf(param, MAX_SIZE_ANONNAME, \"%u\", anonindex++);\n      } else {\n        is_anonymous = 0;\n      }\n\n      /* New Rule: never repair potential malicious user input */\n      if (!skip_upload) {\n        tmp = param;\n        long c = 0;\n\n        while (*tmp) {\n          if (*tmp == '[') {\n            c++;\n          } else if (*tmp == ']') {\n            c--;\n            if (tmp[1] && tmp[1] != '[') {\n              skip_upload = 1;\n              break;\n            }\n          }\n          if (c < 0) {\n            skip_upload = 1;\n            break;\n          }\n          tmp++;\n        }\n      }\n\n      total_bytes = cancel_upload = 0;\n\n      if (!skip_upload) {\n        /* Handle file */\n        char path[PATH_MAX];\n\n        // open a temporary file\n        snprintf(path, sizeof(path), \"%s/XXXXXX\",\n                 RuntimeOption::UploadTmpDir.c_str());\n        fd = mkstemp(path);\n        upload_count--;\n        if (fd == -1) {\n          Logger::Warning(\"Unable to open temporary file\");\n          Logger::Warning(\"File upload error - unable to create a \"\n                          \"temporary file\");\n          cancel_upload = UPLOAD_ERROR_E;\n        }\n        temp_filename = path;\n      }\n\n      if (!skip_upload && php_rfc1867_callback != nullptr) {\n        multipart_event_file_start event_file_start;\n\n        event_file_start.post_bytes_processed = mbuff->read_post_bytes;\n        event_file_start.name = param;\n        event_file_start.filename = &filename;\n        if (php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                                 MULTIPART_EVENT_FILE_START,\n                                 &event_file_start,\n                                 &event_extra_data) == FAILURE) {\n          if (!temp_filename.empty()) {\n            if (cancel_upload != UPLOAD_ERROR_E) { /* file creation failed */\n              close(fd);\n              unlink(temp_filename.c_str());\n            }\n          }\n          temp_filename=\"\";\n          free(param);\n          free(filename);\n          continue;\n        }\n      }\n\n\n      if (skip_upload) {\n        free(param);\n        free(filename);\n        continue;\n      }\n\n      if (strlen(filename) == 0) {\n        Logger::Verbose(\"No file uploaded\");\n        cancel_upload = UPLOAD_ERROR_D;\n      }\n\n      offset = 0;\n      end = 0;\n      while (!cancel_upload &&\n             (blen = multipart_buffer_read(mbuff, buff, sizeof(buff), &end)))\n      {\n        if (php_rfc1867_callback != nullptr) {\n          multipart_event_file_data event_file_data;\n\n          event_file_data.post_bytes_processed = mbuff->read_post_bytes;\n          event_file_data.offset = offset;\n          event_file_data.data = buff;\n          event_file_data.length = blen;\n          event_file_data.newlength = &blen;\n          if (php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                                   MULTIPART_EVENT_FILE_DATA,\n                                   &event_file_data,\n                                   &event_extra_data) == FAILURE) {\n            cancel_upload = UPLOAD_ERROR_X;\n            continue;\n          }\n        }\n\n\n        if (VirtualHost::GetUploadMaxFileSize() > 0 &&\n            total_bytes > VirtualHost::GetUploadMaxFileSize()) {\n          Logger::Verbose(\"upload_max_filesize of %\" PRId64 \" bytes exceeded \"\n                          \"- file [%s=%s] not saved\",\n                          VirtualHost::GetUploadMaxFileSize(),\n                          param, filename);\n          cancel_upload = UPLOAD_ERROR_A;\n        } else if (max_file_size && (total_bytes > max_file_size)) {\n          Logger::Verbose(\"MAX_FILE_SIZE of %d bytes exceeded - \"\n                          \"file [%s=%s] not saved\",\n                          max_file_size, param, filename);\n          cancel_upload = UPLOAD_ERROR_B;\n        } else if (blen > 0) {\n\n          wlen = folly::writeFull(fd, buff, blen);\n          if (wlen < blen) {\n            Logger::Verbose(\"Only %zd bytes were written, expected to \"\n                            \"write %zd\", wlen, blen);\n            cancel_upload = UPLOAD_ERROR_F;\n          } else {\n            total_bytes += wlen;\n          }\n\n          offset += wlen;\n        }\n      }\n      if (fd!=-1) { /* may not be initialized if file could not be created */\n        close(fd);\n      }\n      if (!cancel_upload && !end) {\n        Logger::Verbose(\"Missing mime boundary at the end of the data for \"\n                        \"file %s\", strlen(filename) > 0 ? filename : \"\");\n        cancel_upload = UPLOAD_ERROR_C;\n      }\n      if (strlen(filename) > 0 && total_bytes == 0 && !cancel_upload) {\n        Logger::Verbose(\"Uploaded file size 0 - file [%s=%s] not saved\",\n                        param, filename);\n        cancel_upload = 5;\n      }\n\n      if (php_rfc1867_callback != nullptr) {\n        multipart_event_file_end event_file_end;\n\n        event_file_end.post_bytes_processed = mbuff->read_post_bytes;\n        event_file_end.temp_filename = temp_filename.c_str();\n        event_file_end.cancel_upload = cancel_upload;\n        if (php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                                 MULTIPART_EVENT_FILE_END,\n                                 &event_file_end,\n                                 &event_extra_data) == FAILURE) {\n          cancel_upload = UPLOAD_ERROR_X;\n        }\n      }\n\n      if (cancel_upload && cancel_upload != UPLOAD_ERROR_C) {\n        if (!temp_filename.empty()) {\n          if (cancel_upload != UPLOAD_ERROR_E) { /* file creation failed */\n            unlink(temp_filename.c_str());\n          }\n        }\n        temp_filename=\"\";\n      } else {\n        s_rfc1867_data->rfc1867UploadedFiles.insert(temp_filename);\n      }\n\n      /* is_arr_upload is true when name of file upload field\n       * ends in [.*]\n       * start_arr is set to point to 1st [\n       */\n      is_arr_upload = (start_arr = strchr(param,'[')) &&\n                      (param[strlen(param)-1] == ']');\n\n      if (is_arr_upload) {\n        array_len = strlen(start_arr);\n        array_index = std::string(start_arr+1, array_len-2);\n      }\n\n      /* Add $foo_name */\n      if (llen < strlen(param) + MAX_SIZE_OF_INDEX + 1) {\n        llen = strlen(param);\n        lbuf = (char *) realloc(lbuf, llen + MAX_SIZE_OF_INDEX + 1);\n        llen += MAX_SIZE_OF_INDEX + 1;\n      }\n\n      if (is_arr_upload) {\n        abuf = std::string(param, strlen(param)-array_len);\n        snprintf(lbuf, llen, \"%s_name[%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s_name\", param);\n      }\n\n      /* The \\ check should technically be needed for win32 systems only\n       * where it is a valid path separator. However, IE in all it's wisdom\n       * always sends the full path of the file on the user's filesystem,\n       * which means that unless the user does basename() they get a bogus\n       * file name. Until IE's user base drops to nill or problem is fixed\n       * this code must remain enabled for all systems.\n       */\n      s = strrchr(filename, '\\\\');\n      if ((tmp = strrchr(filename, '/')) > s) {\n        s = tmp;\n      }\n\n      Array globals = php_globals_as_array();\n      if (!is_anonymous) {\n        if (s) {\n          String val(s+1, strlen(s+1), CopyString);\n          safe_php_register_variable(lbuf, val, globals, 0);\n        } else {\n          String val(filename, strlen(filename), CopyString);\n          safe_php_register_variable(lbuf, val, globals, 0);\n        }\n      }\n\n      /* Add $foo[name] */\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s[name][%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s[name]\", param);\n      }\n      if (s) {\n        String val(s+1, strlen(s+1), CopyString);\n        safe_php_register_variable(lbuf, val, files, 0);\n      } else {\n        String val(filename, strlen(filename), CopyString);\n        safe_php_register_variable(lbuf, val, files, 0);\n      }\n      free(filename);\n      s = nullptr;\n\n      /* Possible Content-Type: */\n      if ((cancel_upload && cancel_upload != UPLOAD_ERROR_C) ||\n          !(cd = php_mime_get_hdr_value(header, \"Content-Type\"))) {\n        cd = \"\";\n      } else {\n        /* fix for Opera 6.01 */\n        s = strchr(cd, ';');\n        if (s != nullptr) {\n          *s = '\\0';\n        }\n      }\n\n      /* Add $foo_type */\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s_type[%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s_type\", param);\n      }\n      if (!is_anonymous) {\n        String val(cd, strlen(cd), CopyString);\n        safe_php_register_variable(lbuf, val, globals, 0);\n      }\n\n      /* Add $foo[type] */\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s[type][%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s[type]\", param);\n      }\n      String val(cd, strlen(cd), CopyString);\n      safe_php_register_variable(lbuf, val, files, 0);\n\n      /* Restore Content-Type Header */\n      if (s != nullptr) {\n        *s = ';';\n      }\n      s = \"\";\n\n      /* Initialize variables */\n      add_protected_variable(param);\n\n      Variant tempFileName(temp_filename);\n\n      /* if param is of form xxx[.*] this will cut it to xxx */\n      if (!is_anonymous) {\n        safe_php_register_variable(param, tempFileName, globals, 1);\n      }\n\n      /* Add $foo[tmp_name] */\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s[tmp_name][%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s[tmp_name]\", param);\n      }\n      add_protected_variable(lbuf);\n      safe_php_register_variable(lbuf, tempFileName, files, 1);\n\n      Variant file_size, error_type;\n\n      error_type = cancel_upload;\n\n      /* Add $foo[error] */\n      if (cancel_upload) {\n        file_size = 0;\n      } else {\n        file_size = total_bytes;\n      }\n\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s[error][%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s[error]\", param);\n      }\n      safe_php_register_variable(lbuf, error_type, files, 0);\n\n      /* Add $foo_size */\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s_size[%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s_size\", param);\n      }\n      if (!is_anonymous) {\n        safe_php_register_variable(lbuf, file_size, globals, 0);\n      }\n\n      /* Add $foo[size] */\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s[size][%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s[size]\", param);\n      }\n      safe_php_register_variable(lbuf, file_size, files, 0);\n      free(param);\n    }\n  }\nfileupload_done:\n  data = mbuff->post_data;\n  size = mbuff->post_size;\n  if (php_rfc1867_callback != nullptr) {\n    multipart_event_end event_end;\n\n    event_end.post_bytes_processed = mbuff->read_post_bytes;\n    php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                         MULTIPART_EVENT_END, &event_end, &event_extra_data);\n  }\n  if (lbuf) free(lbuf);\n  s_rfc1867_data->rfc1867ProtectedVariables.clear();\n  if (mbuff->boundary_next) free(mbuff->boundary_next);\n  if (mbuff->boundary) free(mbuff->boundary);\n  if (mbuff->buffer) free(mbuff->buffer);\n  if (mbuff) free(mbuff);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144753,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void rfc1867PostHandler(Transport* transport,\n                        Array& post,\n                        Array& files,\n                        size_t content_length,\n                        const void*& data, size_t& size,\n                        const std::string boundary) {\n  char *s=nullptr, *start_arr=nullptr;\n  std::string array_index, abuf;\n  char *lbuf=nullptr;\n  int total_bytes=0, cancel_upload=0, is_arr_upload=0, array_len=0;\n  int max_file_size=0, skip_upload=0, anonindex=0;\n  std::set<std::string> &uploaded_files = s_rfc1867_data->rfc1867UploadedFiles;\n  multipart_buffer *mbuff;\n  int fd=-1;\n  void *event_extra_data = nullptr;\n  unsigned int llen = 0;\n  int upload_count = RuntimeOption::MaxFileUploads;\n\n  /* Initialize the buffer */\n  if (!(mbuff = multipart_buffer_new(transport,\n                                     (const char *)data, size, boundary))) {\n    Logger::Warning(\"Unable to initialize the input buffer\");\n    return;\n  }\n\n  /* Initialize $_FILES[] */\n  s_rfc1867_data->rfc1867ProtectedVariables.clear();\n\n  uploaded_files.clear();\n\n  int (*php_rfc1867_callback)(apc_rfc1867_data *rfc1867ApcData,\n                              unsigned int event, void *event_data,\n                              void **extra) = s_rfc1867_data->rfc1867Callback;\n\n  if (php_rfc1867_callback != nullptr) {\n    multipart_event_start event_start;\n\n    event_start.content_length = content_length;\n    if (php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                             MULTIPART_EVENT_START, &event_start,\n                             &event_extra_data) == FAILURE) {\n      goto fileupload_done;\n    }\n  }\n\n  while (!multipart_buffer_eof(mbuff)) {\n    std::string temp_filename;\n    char buff[FILLUNIT];\n    char *cd=nullptr,*param=nullptr,*filename=nullptr, *tmp=nullptr;\n    size_t blen=0, wlen=0;\n    off_t offset;\n\n    header_list header;\n    if (!multipart_buffer_headers(mbuff, header)) {\n      goto fileupload_done;\n    }\n\n    if ((cd = php_mime_get_hdr_value(header, \"Content-Disposition\"))) {\n      char *pair=nullptr;\n      int end=0;\n\n      while (isspace(*cd)) {\n        ++cd;\n      }\n\n      while (*cd && (pair = php_ap_getword(&cd, ';')))\n      {\n        char *key=nullptr, *word = pair;\n\n        while (isspace(*cd)) {\n          ++cd;\n        }\n\n        if (strchr(pair, '=')) {\n          key = php_ap_getword(&pair, '=');\n\n          if (!strcasecmp(key, \"name\")) {\n            if (param) {\n              free(param);\n            }\n            param = php_ap_getword_conf(&pair);\n          } else if (!strcasecmp(key, \"filename\")) {\n            if (filename) {\n              free(filename);\n            }\n            filename = php_ap_getword_conf(&pair);\n          }\n        }\n        if (key) free(key);\n        free(word);\n      }\n\n      /* Normal form variable, safe to read all data into memory */\n      if (!filename && param) {\n        unsigned int value_len;\n        char *value = multipart_buffer_read_body(mbuff, &value_len);\n        unsigned int new_val_len; /* Dummy variable */\n\n        if (!value) {\n          value = strdup(\"\");\n        }\n\n        new_val_len = value_len;\n        if (php_rfc1867_callback != nullptr) {\n          multipart_event_formdata event_formdata;\n          size_t newlength = new_val_len;\n\n          event_formdata.post_bytes_processed = mbuff->read_post_bytes;\n          event_formdata.name = param;\n          event_formdata.value = &value;\n          event_formdata.length = new_val_len;\n          event_formdata.newlength = &newlength;\n          if (php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                                   MULTIPART_EVENT_FORMDATA, &event_formdata,\n                                   &event_extra_data) == FAILURE) {\n            free(param);\n            free(value);\n            continue;\n          }\n          new_val_len = newlength;\n        }\n\n        String val(value, new_val_len, CopyString);\n        safe_php_register_variable(param, val, post, 0);\n\n        if (!strcasecmp(param, \"MAX_FILE_SIZE\")) {\n          max_file_size = atol(value);\n        }\n\n        free(param);\n        free(value);\n        continue;\n      }\n\n      /* If file_uploads=off, skip the file part */\n      if (!RuntimeOption::EnableFileUploads) {\n        skip_upload = 1;\n      } else if (upload_count <= 0) {\n        Logger::Warning(\n          \"Maximum number of allowable file uploads has been exceeded\"\n        );\n        skip_upload = 1;\n      }\n\n      /* Return with an error if the posted data is garbled */\n      if (!param && !filename) {\n        Logger::Warning(\"File Upload Mime headers garbled\");\n        goto fileupload_done;\n      }\n\n      if (!param) {\n        param = (char*)malloc(MAX_SIZE_ANONNAME);\n        snprintf(param, MAX_SIZE_ANONNAME, \"%u\", anonindex++);\n      }\n\n      /* New Rule: never repair potential malicious user input */\n      if (!skip_upload) {\n        tmp = param;\n        long c = 0;\n\n        while (*tmp) {\n          if (*tmp == '[') {\n            c++;\n          } else if (*tmp == ']') {\n            c--;\n            if (tmp[1] && tmp[1] != '[') {\n              skip_upload = 1;\n              break;\n            }\n          }\n          if (c < 0) {\n            skip_upload = 1;\n            break;\n          }\n          tmp++;\n        }\n      }\n\n      total_bytes = cancel_upload = 0;\n\n      if (!skip_upload) {\n        /* Handle file */\n        char path[PATH_MAX];\n\n        // open a temporary file\n        snprintf(path, sizeof(path), \"%s/XXXXXX\",\n                 RuntimeOption::UploadTmpDir.c_str());\n        fd = mkstemp(path);\n        upload_count--;\n        if (fd == -1) {\n          Logger::Warning(\"Unable to open temporary file\");\n          Logger::Warning(\"File upload error - unable to create a \"\n                          \"temporary file\");\n          cancel_upload = UPLOAD_ERROR_E;\n        }\n        temp_filename = path;\n      }\n\n      if (!skip_upload && php_rfc1867_callback != nullptr) {\n        multipart_event_file_start event_file_start;\n\n        event_file_start.post_bytes_processed = mbuff->read_post_bytes;\n        event_file_start.name = param;\n        event_file_start.filename = &filename;\n        if (php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                                 MULTIPART_EVENT_FILE_START,\n                                 &event_file_start,\n                                 &event_extra_data) == FAILURE) {\n          if (!temp_filename.empty()) {\n            if (cancel_upload != UPLOAD_ERROR_E) { /* file creation failed */\n              close(fd);\n              unlink(temp_filename.c_str());\n            }\n          }\n          temp_filename=\"\";\n          free(param);\n          free(filename);\n          continue;\n        }\n      }\n\n\n      if (skip_upload) {\n        free(param);\n        free(filename);\n        continue;\n      }\n\n      if (strlen(filename) == 0) {\n        Logger::Verbose(\"No file uploaded\");\n        cancel_upload = UPLOAD_ERROR_D;\n      }\n\n      offset = 0;\n      end = 0;\n      while (!cancel_upload &&\n             (blen = multipart_buffer_read(mbuff, buff, sizeof(buff), &end)))\n      {\n        if (php_rfc1867_callback != nullptr) {\n          multipart_event_file_data event_file_data;\n\n          event_file_data.post_bytes_processed = mbuff->read_post_bytes;\n          event_file_data.offset = offset;\n          event_file_data.data = buff;\n          event_file_data.length = blen;\n          event_file_data.newlength = &blen;\n          if (php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                                   MULTIPART_EVENT_FILE_DATA,\n                                   &event_file_data,\n                                   &event_extra_data) == FAILURE) {\n            cancel_upload = UPLOAD_ERROR_X;\n            continue;\n          }\n        }\n\n\n        if (VirtualHost::GetUploadMaxFileSize() > 0 &&\n            total_bytes > VirtualHost::GetUploadMaxFileSize()) {\n          Logger::Verbose(\"upload_max_filesize of %\" PRId64 \" bytes exceeded \"\n                          \"- file [%s=%s] not saved\",\n                          VirtualHost::GetUploadMaxFileSize(),\n                          param, filename);\n          cancel_upload = UPLOAD_ERROR_A;\n        } else if (max_file_size && (total_bytes > max_file_size)) {\n          Logger::Verbose(\"MAX_FILE_SIZE of %d bytes exceeded - \"\n                          \"file [%s=%s] not saved\",\n                          max_file_size, param, filename);\n          cancel_upload = UPLOAD_ERROR_B;\n        } else if (blen > 0) {\n\n          wlen = folly::writeFull(fd, buff, blen);\n          if (wlen < blen) {\n            Logger::Verbose(\"Only %zd bytes were written, expected to \"\n                            \"write %zd\", wlen, blen);\n            cancel_upload = UPLOAD_ERROR_F;\n          } else {\n            total_bytes += wlen;\n          }\n\n          offset += wlen;\n        }\n      }\n      if (fd!=-1) { /* may not be initialized if file could not be created */\n        close(fd);\n      }\n      if (!cancel_upload && !end) {\n        Logger::Verbose(\"Missing mime boundary at the end of the data for \"\n                        \"file %s\", strlen(filename) > 0 ? filename : \"\");\n        cancel_upload = UPLOAD_ERROR_C;\n      }\n      if (strlen(filename) > 0 && total_bytes == 0 && !cancel_upload) {\n        Logger::Verbose(\"Uploaded file size 0 - file [%s=%s] not saved\",\n                        param, filename);\n        cancel_upload = 5;\n      }\n\n      if (php_rfc1867_callback != nullptr) {\n        multipart_event_file_end event_file_end;\n\n        event_file_end.post_bytes_processed = mbuff->read_post_bytes;\n        event_file_end.temp_filename = temp_filename.c_str();\n        event_file_end.cancel_upload = cancel_upload;\n        if (php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                                 MULTIPART_EVENT_FILE_END,\n                                 &event_file_end,\n                                 &event_extra_data) == FAILURE) {\n          cancel_upload = UPLOAD_ERROR_X;\n        }\n      }\n\n      if (cancel_upload && cancel_upload != UPLOAD_ERROR_C) {\n        if (!temp_filename.empty()) {\n          if (cancel_upload != UPLOAD_ERROR_E) { /* file creation failed */\n            unlink(temp_filename.c_str());\n          }\n        }\n        temp_filename=\"\";\n      } else {\n        s_rfc1867_data->rfc1867UploadedFiles.insert(temp_filename);\n      }\n\n      /* is_arr_upload is true when name of file upload field\n       * ends in [.*]\n       * start_arr is set to point to 1st [\n       */\n      is_arr_upload = (start_arr = strchr(param,'[')) &&\n                      (param[strlen(param)-1] == ']');\n\n      if (is_arr_upload) {\n        array_len = strlen(start_arr);\n        array_index = std::string(start_arr+1, array_len-2);\n      }\n\n      /* Add $foo_name */\n      if (llen < strlen(param) + MAX_SIZE_OF_INDEX + 1) {\n        llen = strlen(param);\n        lbuf = (char *) realloc(lbuf, llen + MAX_SIZE_OF_INDEX + 1);\n        llen += MAX_SIZE_OF_INDEX + 1;\n      }\n\n      if (is_arr_upload) {\n        abuf = std::string(param, strlen(param)-array_len);\n        snprintf(lbuf, llen, \"%s_name[%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s_name\", param);\n      }\n\n      /* The \\ check should technically be needed for win32 systems only\n       * where it is a valid path separator. However, IE in all it's wisdom\n       * always sends the full path of the file on the user's filesystem,\n       * which means that unless the user does basename() they get a bogus\n       * file name. Until IE's user base drops to nill or problem is fixed\n       * this code must remain enabled for all systems.\n       */\n      s = strrchr(filename, '\\\\');\n      if ((tmp = strrchr(filename, '/')) > s) {\n        s = tmp;\n      }\n\n      /* Add $foo[name] */\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s[name][%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s[name]\", param);\n      }\n      if (s) {\n        String val(s+1, strlen(s+1), CopyString);\n        safe_php_register_variable(lbuf, val, files, 0);\n      } else {\n        String val(filename, strlen(filename), CopyString);\n        safe_php_register_variable(lbuf, val, files, 0);\n      }\n      free(filename);\n      s = nullptr;\n\n      /* Possible Content-Type: */\n      if ((cancel_upload && cancel_upload != UPLOAD_ERROR_C) ||\n          !(cd = php_mime_get_hdr_value(header, \"Content-Type\"))) {\n        cd = \"\";\n      } else {\n        /* fix for Opera 6.01 */\n        s = strchr(cd, ';');\n        if (s != nullptr) {\n          *s = '\\0';\n        }\n      }\n\n      /* Add $foo[type] */\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s[type][%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s[type]\", param);\n      }\n      String val(cd, strlen(cd), CopyString);\n      safe_php_register_variable(lbuf, val, files, 0);\n\n      /* Restore Content-Type Header */\n      if (s != nullptr) {\n        *s = ';';\n      }\n      s = \"\";\n\n      /* Initialize variables */\n      add_protected_variable(param);\n\n      Variant tempFileName(temp_filename);\n\n      /* Add $foo[tmp_name] */\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s[tmp_name][%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s[tmp_name]\", param);\n      }\n      add_protected_variable(lbuf);\n      safe_php_register_variable(lbuf, tempFileName, files, 1);\n\n      Variant file_size, error_type;\n\n      error_type = cancel_upload;\n\n      /* Add $foo[error] */\n      if (cancel_upload) {\n        file_size = 0;\n      } else {\n        file_size = total_bytes;\n      }\n\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s[error][%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s[error]\", param);\n      }\n      safe_php_register_variable(lbuf, error_type, files, 0);\n\n      /* Add $foo[size] */\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s[size][%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s[size]\", param);\n      }\n      safe_php_register_variable(lbuf, file_size, files, 0);\n      free(param);\n    }\n  }\nfileupload_done:\n  data = mbuff->post_data;\n  size = mbuff->post_size;\n  if (php_rfc1867_callback != nullptr) {\n    multipart_event_end event_end;\n\n    event_end.post_bytes_processed = mbuff->read_post_bytes;\n    php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                         MULTIPART_EVENT_END, &event_end, &event_extra_data);\n  }\n  if (lbuf) free(lbuf);\n  s_rfc1867_data->rfc1867ProtectedVariables.clear();\n  if (mbuff->boundary_next) free(mbuff->boundary_next);\n  if (mbuff->boundary) free(mbuff->boundary);\n  if (mbuff->buffer) free(mbuff->buffer);\n  if (mbuff) free(mbuff);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144754,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static bool php_mb_parse_encoding(const Variant& encoding,\n                                  mbfl_encoding ***return_list,\n                                  int *return_size, bool persistent) {\n  bool ret;\n  if (encoding.isArray()) {\n    ret = php_mb_parse_encoding_array(encoding.toArray(),\n                                      return_list, return_size,\n                                      persistent ? 1 : 0);\n  } else {\n    String enc = encoding.toString();\n    ret = php_mb_parse_encoding_list(enc.data(), enc.size(),\n                                     return_list, return_size,\n                                     persistent ? 1 : 0);\n  }\n  if (!ret) {\n    if (return_list && *return_list) {\n      free(*return_list);\n      *return_list = nullptr;\n    }\n    return_size = 0;\n  }\n  return ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144765,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static bool php_mb_parse_encoding(const Variant& encoding,\n                                  mbfl_encoding ***return_list,\n                                  int *return_size, bool persistent) {\n  bool ret;\n  if (encoding.isArray()) {\n    ret = php_mb_parse_encoding_array(encoding.toArray(),\n                                      return_list, return_size,\n                                      persistent ? 1 : 0);\n  } else {\n    String enc = encoding.toString();\n    ret = php_mb_parse_encoding_list(enc.data(), enc.size(),\n                                     return_list, return_size,\n                                     persistent ? 1 : 0);\n  }\n  if (!ret) {\n    if (return_list && *return_list) {\n      req::free(*return_list);\n      *return_list = nullptr;\n    }\n    return_size = 0;\n  }\n  return ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144766,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "uint32_t skip(Protocol_& prot, TType arg_type) {\n  switch (arg_type) {\n    case T_BOOL: {\n      bool boolv;\n      return prot.readBool(boolv);\n    }\n    case T_BYTE: {\n      int8_t bytev = 0;\n      return prot.readByte(bytev);\n    }\n    case T_I16: {\n      int16_t i16;\n      return prot.readI16(i16);\n    }\n    case T_I32: {\n      int32_t i32;\n      return prot.readI32(i32);\n    }\n    case T_I64: {\n      int64_t i64;\n      return prot.readI64(i64);\n    }\n    case T_DOUBLE: {\n      double dub;\n      return prot.readDouble(dub);\n    }\n    case T_FLOAT: {\n      float flt;\n      return prot.readFloat(flt);\n    }\n    case T_STRING: {\n      std::string str;\n      return prot.readBinary(str);\n    }\n    case T_STRUCT: {\n      uint32_t result = 0;\n      std::string name;\n      int16_t fid;\n      TType ftype;\n      result += prot.readStructBegin(name);\n      while (true) {\n        result += prot.readFieldBegin(name, ftype, fid);\n        if (ftype == T_STOP) {\n          break;\n        }\n        result += skip(prot, ftype);\n        result += prot.readFieldEnd();\n      }\n      result += prot.readStructEnd();\n      return result;\n    }\n    case T_MAP: {\n      uint32_t result = 0;\n      TType keyType;\n      TType valType;\n      uint32_t i, size;\n      bool sizeUnknown;\n      result += prot.readMapBegin(keyType, valType, size, sizeUnknown);\n      if (!sizeUnknown) {\n        for (i = 0; i < size; i++) {\n          result += skip(prot, keyType);\n          result += skip(prot, valType);\n        }\n      } else {\n        while (prot.peekMap()) {\n          result += skip(prot, keyType);\n          result += skip(prot, valType);\n        }\n      }\n      result += prot.readMapEnd();\n      return result;\n    }\n    case T_SET: {\n      uint32_t result = 0;\n      TType elemType;\n      uint32_t i, size;\n      bool sizeUnknown;\n      result += prot.readSetBegin(elemType, size, sizeUnknown);\n      if (!sizeUnknown) {\n        for (i = 0; i < size; i++) {\n          result += skip(prot, elemType);\n        }\n      } else {\n        while (prot.peekSet()) {\n          result += skip(prot, elemType);\n        }\n      }\n      result += prot.readSetEnd();\n      return result;\n    }\n    case T_LIST: {\n      uint32_t result = 0;\n      TType elemType;\n      uint32_t i, size;\n      bool sizeUnknown;\n      result += prot.readListBegin(elemType, size, sizeUnknown);\n      if (!sizeUnknown) {\n        for (i = 0; i < size; i++) {\n          result += skip(prot, elemType);\n        }\n      } else {\n        while (prot.peekList()) {\n          result += skip(prot, elemType);\n        }\n      }\n      result += prot.readListEnd();\n      return result;\n    }\n    default:\n      return 0;\n  }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144914,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "uint32_t skip(Protocol_& prot, TType arg_type) {\n  switch (arg_type) {\n    case T_BOOL: {\n      bool boolv;\n      return prot.readBool(boolv);\n    }\n    case T_BYTE: {\n      int8_t bytev = 0;\n      return prot.readByte(bytev);\n    }\n    case T_I16: {\n      int16_t i16;\n      return prot.readI16(i16);\n    }\n    case T_I32: {\n      int32_t i32;\n      return prot.readI32(i32);\n    }\n    case T_I64: {\n      int64_t i64;\n      return prot.readI64(i64);\n    }\n    case T_DOUBLE: {\n      double dub;\n      return prot.readDouble(dub);\n    }\n    case T_FLOAT: {\n      float flt;\n      return prot.readFloat(flt);\n    }\n    case T_STRING: {\n      std::string str;\n      return prot.readBinary(str);\n    }\n    case T_STRUCT: {\n      uint32_t result = 0;\n      std::string name;\n      int16_t fid;\n      TType ftype;\n      result += prot.readStructBegin(name);\n      while (true) {\n        result += prot.readFieldBegin(name, ftype, fid);\n        if (ftype == T_STOP) {\n          break;\n        }\n        result += skip(prot, ftype);\n        result += prot.readFieldEnd();\n      }\n      result += prot.readStructEnd();\n      return result;\n    }\n    case T_MAP: {\n      uint32_t result = 0;\n      TType keyType;\n      TType valType;\n      uint32_t i, size;\n      bool sizeUnknown;\n      result += prot.readMapBegin(keyType, valType, size, sizeUnknown);\n      if (!sizeUnknown) {\n        for (i = 0; i < size; i++) {\n          result += skip(prot, keyType);\n          result += skip(prot, valType);\n        }\n      } else {\n        while (prot.peekMap()) {\n          result += skip(prot, keyType);\n          result += skip(prot, valType);\n        }\n      }\n      result += prot.readMapEnd();\n      return result;\n    }\n    case T_SET: {\n      uint32_t result = 0;\n      TType elemType;\n      uint32_t i, size;\n      bool sizeUnknown;\n      result += prot.readSetBegin(elemType, size, sizeUnknown);\n      if (!sizeUnknown) {\n        for (i = 0; i < size; i++) {\n          result += skip(prot, elemType);\n        }\n      } else {\n        while (prot.peekSet()) {\n          result += skip(prot, elemType);\n        }\n      }\n      result += prot.readSetEnd();\n      return result;\n    }\n    case T_LIST: {\n      uint32_t result = 0;\n      TType elemType;\n      uint32_t i, size;\n      bool sizeUnknown;\n      result += prot.readListBegin(elemType, size, sizeUnknown);\n      if (!sizeUnknown) {\n        for (i = 0; i < size; i++) {\n          result += skip(prot, elemType);\n        }\n      } else {\n        while (prot.peekList()) {\n          result += skip(prot, elemType);\n        }\n      }\n      result += prot.readListEnd();\n      return result;\n    }\n    default: {\n      TProtocolException::throwInvalidSkipType(arg_type);\n    }\n  }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144915,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void __fastcall TSCPFileSystem::SCPSink(const UnicodeString TargetDir,\r\n  const UnicodeString FileName, const UnicodeString SourceDir,\r\n  const TCopyParamType * CopyParam, bool & Success,\r\n  TFileOperationProgressType * OperationProgress, int Params,\r\n  int Level)\r\n{\r\n  struct\r\n  {\r\n    int SetTime;\r\n    TDateTime Modification;\r\n    TRights RemoteRights;\r\n    int Attrs;\r\n    bool Exists;\r\n  } FileData;\r\n\r\n  bool SkipConfirmed = false;\r\n  bool Initialized = (Level > 0);\r\n\r\n  FileData.SetTime = 0;\r\n\r\n  FSecureShell->SendNull();\r\n\r\n  while (!OperationProgress->Cancel)\r\n  {\r\n    // See (switch ... case 'T':)\r\n    if (FileData.SetTime) FileData.SetTime--;\r\n\r\n    // In case of error occurred before control record arrived.\r\n    // We can finally use full path here, as we get current path in FileName param\r\n    // (we used to set the file into OperationProgress->FileName, but it collided\r\n    // with progress outputting, particularly for scripting)\r\n    UnicodeString FullFileName = FileName;\r\n\r\n    try\r\n    {\r\n      // Receive control record\r\n      UnicodeString Line = FSecureShell->ReceiveLine();\r\n\r\n      if (Line.Length() == 0) FTerminal->FatalError(NULL, LoadStr(SCP_EMPTY_LINE));\r\n\r\n      if (IsLastLine(Line))\r\n      {\r\n        // Remote side finished copying, so remote SCP was closed\r\n        // and we don't need to terminate it manually, see CopyToLocal()\r\n        OperationProgress->SetCancel(csRemoteAbort);\r\n        /* TODO 1 : Show stderror to user? */\r\n        FSecureShell->ClearStdError();\r\n        try\r\n        {\r\n          // coIgnoreWarnings should allow batch transfer to continue when\r\n          // download of one the files fails (user denies overwriting\r\n          // of target local file, no read permissions...)\r\n          ReadCommandOutput(coExpectNoOutput | coRaiseExcept |\r\n            coOnlyReturnCode | coIgnoreWarnings);\r\n          if (!Initialized)\r\n          {\r\n            throw Exception(L\"\");\r\n          }\r\n        }\r\n        catch(Exception & E)\r\n        {\r\n          if (!Initialized && FTerminal->Active)\r\n          {\r\n            FTerminal->TerminalError(&E, LoadStr(SCP_INIT_ERROR));\r\n          }\r\n          else\r\n          {\r\n            throw;\r\n          }\r\n        }\r\n        return;\r\n      }\r\n      else\r\n      {\r\n        Initialized = true;\r\n\r\n        // First character distinguish type of control record\r\n        wchar_t Ctrl = Line[1];\r\n        Line.Delete(1, 1);\r\n\r\n        switch (Ctrl) {\r\n          case 1:\r\n            // Error (already logged by ReceiveLine())\r\n            throw EScpFileSkipped(NULL, FMTLOAD(REMOTE_ERROR, (Line)));\r\n\r\n          case 2:\r\n            // Fatal error, terminate copying\r\n            FTerminal->TerminalError(Line);\r\n            return; // Unreachable\r\n\r\n          case L'E': // Exit\r\n            FSecureShell->SendNull();\r\n            return;\r\n\r\n          case L'T':\r\n            unsigned long MTime, ATime;\r\n            if (swscanf(Line.c_str(), L\"%ld %*d %ld %*d\",  &MTime, &ATime) == 2)\r\n            {\r\n              FileData.Modification = UnixToDateTime(MTime, FTerminal->SessionData->DSTMode);\r\n              FSecureShell->SendNull();\r\n              // File time is only valid until next pass\r\n              FileData.SetTime = 2;\r\n              continue;\r\n            }\r\n              else\r\n            {\r\n              SCPError(LoadStr(SCP_ILLEGAL_TIME_FORMAT), False);\r\n            }\r\n\r\n          case L'C':\r\n          case L'D':\r\n            break; // continue pass switch{}\r\n\r\n          default:\r\n            FTerminal->FatalError(NULL, FMTLOAD(SCP_INVALID_CONTROL_RECORD, (Ctrl, Line)));\r\n        }\r\n\r\n        TFileMasks::TParams MaskParams;\r\n        MaskParams.Modification = FileData.Modification;\r\n\r\n        // We reach this point only if control record was 'C' or 'D'\r\n        try\r\n        {\r\n          FileData.RemoteRights.Octal = CutToChar(Line, L' ', True);\r\n          // do not trim leading spaces of the filename\r\n          __int64 TSize = StrToInt64(CutToChar(Line, L' ', False).TrimRight());\r\n          MaskParams.Size = TSize;\r\n          // Security fix: ensure the file ends up where we asked for it.\r\n          // (accept only filename, not path)\r\n          UnicodeString OnlyFileName = UnixExtractFileName(Line);\r\n          if (Line != OnlyFileName)\r\n          {\r\n            FTerminal->LogEvent(FORMAT(L\"Warning: Remote host set a compound pathname '%s'\", (Line)));\r\n          }\r\n\r\n          FullFileName = SourceDir + OnlyFileName;\r\n          OperationProgress->SetFile(FullFileName);\r\n          OperationProgress->SetTransferSize(TSize);\r\n        }\r\n        catch (Exception &E)\r\n        {\r\n          {\r\n            TSuspendFileOperationProgress Suspend(OperationProgress);\r\n            FTerminal->Log->AddException(&E);\r\n          }\r\n          SCPError(LoadStr(SCP_ILLEGAL_FILE_DESCRIPTOR), false);\r\n        }\r\n\r\n        // last possibility to cancel transfer before it starts\r\n        if (OperationProgress->Cancel)\r\n        {\r\n          throw ESkipFile(NULL, MainInstructions(LoadStr(USER_TERMINATED)));\r\n        }\r\n\r\n        bool Dir = (Ctrl == L'D');\r\n        UnicodeString BaseFileName = FTerminal->GetBaseFileName(FullFileName);\r\n        if (!CopyParam->AllowTransfer(BaseFileName, osRemote, Dir, MaskParams, IsUnixHiddenFile(BaseFileName)))\r\n        {\r\n          FTerminal->LogEvent(FORMAT(L\"File \\\"%s\\\" excluded from transfer\",\r\n            (FullFileName)));\r\n          SkipConfirmed = true;\r\n          SCPError(L\"\", false);\r\n        }\r\n\r\n        if (CopyParam->SkipTransfer(FullFileName, Dir))\r\n        {\r\n          SkipConfirmed = true;\r\n          SCPError(L\"\", false);\r\n          OperationProgress->AddSkippedFileSize(MaskParams.Size);\r\n        }\r\n\r\n        FTerminal->LogFileDetails(FileName, FileData.Modification, MaskParams.Size);\r\n\r\n        UnicodeString DestFileNameOnly =\r\n          FTerminal->ChangeFileName(\r\n            CopyParam, OperationProgress->FileName, osRemote,\r\n            Level == 0);\r\n        UnicodeString DestFileName =\r\n          IncludeTrailingBackslash(TargetDir) + DestFileNameOnly;\r\n\r\n        FileData.Attrs = FileGetAttrFix(ApiPath(DestFileName));\r\n        // If getting attrs fails, we suppose, that file/folder doesn't exists\r\n        FileData.Exists = (FileData.Attrs != -1);\r\n        if (Dir)\r\n        {\r\n          if (FileData.Exists && !(FileData.Attrs & faDirectory))\r\n          {\r\n            SCPError(FMTLOAD(NOT_DIRECTORY_ERROR, (DestFileName)), false);\r\n          }\r\n\r\n          if (!FileData.Exists)\r\n          {\r\n            FILE_OPERATION_LOOP_BEGIN\r\n            {\r\n              THROWOSIFFALSE(ForceDirectories(ApiPath(DestFileName)));\r\n            }\r\n            FILE_OPERATION_LOOP_END(FMTLOAD(CREATE_DIR_ERROR, (DestFileName)));\r\n            /* SCP: can we set the timestamp for directories ? */\r\n          }\r\n          UnicodeString FullFileName = SourceDir + OperationProgress->FileName;\r\n          SCPSink(DestFileName, FullFileName, UnixIncludeTrailingBackslash(FullFileName),\r\n            CopyParam, Success, OperationProgress, Params, Level + 1);\r\n          continue;\r\n        }\r\n        else if (Ctrl == L'C')\r\n        {\r\n          TDownloadSessionAction Action(FTerminal->ActionLog);\r\n          Action.FileName(FTerminal->AbsolutePath(FullFileName, true));\r\n\r\n          try\r\n          {\r\n            HANDLE File = NULL;\r\n            TStream * FileStream = NULL;\r\n\r\n            /* TODO 1 : Turn off read-only attr */\r\n\r\n            try\r\n            {\r\n              try\r\n              {\r\n                if (FileExists(ApiPath(DestFileName)))\r\n                {\r\n                  __int64 MTime;\r\n                  TOverwriteFileParams FileParams;\r\n                  FileParams.SourceSize = OperationProgress->TransferSize;\r\n                  FileParams.SourceTimestamp = FileData.Modification;\r\n                  FTerminal->OpenLocalFile(DestFileName, GENERIC_READ,\r\n                    NULL, NULL, NULL, &MTime, NULL,\r\n                    &FileParams.DestSize);\r\n                  FileParams.DestTimestamp = UnixToDateTime(MTime,\r\n                    FTerminal->SessionData->DSTMode);\r\n\r\n                  unsigned int Answer =\r\n                    ConfirmOverwrite(OperationProgress->FileName, DestFileNameOnly, osLocal,\r\n                      &FileParams, CopyParam, Params, OperationProgress);\r\n\r\n                  switch (Answer)\r\n                  {\r\n                    case qaCancel:\r\n                      OperationProgress->SetCancel(csCancel); // continue on next case\r\n                    case qaNo:\r\n                      SkipConfirmed = true;\r\n                      EXCEPTION;\r\n                  }\r\n                }\r\n\r\n                Action.Destination(DestFileName);\r\n\r\n                if (!FTerminal->CreateLocalFile(DestFileName, OperationProgress,\r\n                       &File, FLAGSET(Params, cpNoConfirmation)))\r\n                {\r\n                  SkipConfirmed = true;\r\n                  EXCEPTION;\r\n                }\r\n\r\n                FileStream = new TSafeHandleStream((THandle)File);\r\n              }\r\n              catch (Exception &E)\r\n              {\r\n                // In this step we can still cancel transfer, so we do it\r\n                SCPError(E.Message, false);\r\n                throw;\r\n              }\r\n\r\n              // We succeeded, so we confirm transfer to remote side\r\n              FSecureShell->SendNull();\r\n              // From now we need to finish file transfer, if not it's fatal error\r\n              OperationProgress->SetTransferringFile(true);\r\n\r\n              // Suppose same data size to transfer as to write\r\n              // (not true with ASCII transfer)\r\n              OperationProgress->SetLocalSize(OperationProgress->TransferSize);\r\n\r\n              // Will we use ASCII of BINARY file transfer?\r\n              OperationProgress->SetAsciiTransfer(\r\n                CopyParam->UseAsciiTransfer(BaseFileName, osRemote, MaskParams));\r\n              if (FTerminal->Configuration->ActualLogProtocol >= 0)\r\n              {\r\n                FTerminal->LogEvent(UnicodeString((OperationProgress->AsciiTransfer ? L\"Ascii\" : L\"Binary\")) +\r\n                  L\" transfer mode selected.\");\r\n              }\r\n\r\n              try\r\n              {\r\n                // Buffer for one block of data\r\n                TFileBuffer BlockBuf;\r\n                bool ConvertToken = false;\r\n\r\n                do\r\n                {\r\n                  BlockBuf.Size = OperationProgress->TransferBlockSize();\r\n                  BlockBuf.Position = 0;\r\n\r\n                  FSecureShell->Receive(reinterpret_cast<unsigned char *>(BlockBuf.Data), BlockBuf.Size);\r\n                  OperationProgress->AddTransferred(BlockBuf.Size);\r\n\r\n                  if (OperationProgress->AsciiTransfer)\r\n                  {\r\n                    unsigned int PrevBlockSize = BlockBuf.Size;\r\n                    BlockBuf.Convert(FTerminal->SessionData->EOLType,\r\n                      FTerminal->Configuration->LocalEOLType, 0, ConvertToken);\r\n                    OperationProgress->SetLocalSize(\r\n                      OperationProgress->LocalSize - PrevBlockSize + BlockBuf.Size);\r\n                  }\r\n\r\n                  // This is crucial, if it fails during file transfer, it's fatal error\r\n                  FILE_OPERATION_LOOP_BEGIN\r\n                  {\r\n                    BlockBuf.WriteToStream(FileStream, BlockBuf.Size);\r\n                  }\r\n                  FILE_OPERATION_LOOP_END_EX(FMTLOAD(WRITE_ERROR, (DestFileName)), folNone);\r\n\r\n                  OperationProgress->AddLocallyUsed(BlockBuf.Size);\r\n\r\n                  if (OperationProgress->Cancel == csCancelTransfer)\r\n                  {\r\n                    throw Exception(MainInstructions(LoadStr(USER_TERMINATED)));\r\n                  }\r\n                }\r\n                while (!OperationProgress->IsLocallyDone() || !\r\n                    OperationProgress->IsTransferDone());\r\n              }\r\n              catch (Exception &E)\r\n              {\r\n                // Every exception during file transfer is fatal\r\n                FTerminal->FatalError(&E,\r\n                  FMTLOAD(COPY_FATAL, (OperationProgress->FileName)));\r\n              }\r\n\r\n              OperationProgress->SetTransferringFile(false);\r\n\r\n              try\r\n              {\r\n                SCPResponse();\r\n                // If one of following exception occurs, we still need\r\n                // to send confirmation to other side\r\n              }\r\n              catch (EScp &E)\r\n              {\r\n                FSecureShell->SendNull();\r\n                throw;\r\n              }\r\n              catch (EScpFileSkipped &E)\r\n              {\r\n                FSecureShell->SendNull();\r\n                throw;\r\n              }\r\n\r\n              FSecureShell->SendNull();\r\n\r\n              if (FileData.SetTime && CopyParam->PreserveTime)\r\n              {\r\n                FTerminal->UpdateTargetTime(File, FileData.Modification, FTerminal->SessionData->DSTMode);\r\n              }\r\n            }\r\n            __finally\r\n            {\r\n              if (File) CloseHandle(File);\r\n              if (FileStream) delete FileStream;\r\n            }\r\n          }\r\n          catch(Exception & E)\r\n          {\r\n            if (SkipConfirmed)\r\n            {\r\n              Action.Cancel();\r\n            }\r\n            else\r\n            {\r\n              FTerminal->RollbackAction(Action, OperationProgress, &E);\r\n            }\r\n            throw;\r\n          }\r\n\r\n          if (FileData.Attrs == -1) FileData.Attrs = faArchive;\r\n          int NewAttrs = CopyParam->LocalFileAttrs(FileData.RemoteRights);\r\n          if ((NewAttrs & FileData.Attrs) != NewAttrs)\r\n          {\r\n            FILE_OPERATION_LOOP_BEGIN\r\n            {\r\n              THROWOSIFFALSE(FileSetAttr(ApiPath(DestFileName), FileData.Attrs | NewAttrs) == 0);\r\n            }\r\n            FILE_OPERATION_LOOP_END(FMTLOAD(CANT_SET_ATTRS, (DestFileName)));\r\n          }\r\n\r\n          FTerminal->LogFileDone(OperationProgress, DestFileName);\r\n        }\r\n      }\r\n    }\r\n    catch (EScpFileSkipped &E)\r\n    {\r\n      if (!SkipConfirmed)\r\n      {\r\n        TSuspendFileOperationProgress Suspend(OperationProgress);\r\n        TQueryParams Params(qpAllowContinueOnError);\r\n        if (FTerminal->QueryUserException(FMTLOAD(COPY_ERROR, (FullFileName)),\r\n              &E, qaOK | qaAbort, &Params, qtError) == qaAbort)\r\n        {\r\n          OperationProgress->SetCancel(csCancel);\r\n        }\r\n        FTerminal->Log->AddException(&E);\r\n      }\r\n      // this was inside above condition, but then transfer was considered\r\n      // successful, even when for example user refused to overwrite file\r\n      Success = false;\r\n    }\r\n    catch (ESkipFile &E)\r\n    {\r\n      SCPSendError(E.Message, false);\r\n      Success = false;\r\n      if (!FTerminal->HandleException(&E)) throw;\r\n    }\r\n  }\r\n}\r",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144924,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void __fastcall TSCPFileSystem::SCPSink(const UnicodeString TargetDir,\r\n  const UnicodeString FileName, const UnicodeString SourceDir,\r\n  const TCopyParamType * CopyParam, bool & Success,\r\n  TFileOperationProgressType * OperationProgress, int Params,\r\n  int Level)\r\n{\r\n  struct\r\n  {\r\n    int SetTime;\r\n    TDateTime Modification;\r\n    TRights RemoteRights;\r\n    int Attrs;\r\n    bool Exists;\r\n  } FileData;\r\n\r\n  bool SkipConfirmed = false;\r\n  bool Initialized = (Level > 0);\r\n\r\n  FileData.SetTime = 0;\r\n\r\n  FSecureShell->SendNull();\r\n\r\n  while (!OperationProgress->Cancel)\r\n  {\r\n    // See (switch ... case 'T':)\r\n    if (FileData.SetTime) FileData.SetTime--;\r\n\r\n    // In case of error occurred before control record arrived.\r\n    // We can finally use full path here, as we get current path in FileName param\r\n    // (we used to set the file into OperationProgress->FileName, but it collided\r\n    // with progress outputting, particularly for scripting)\r\n    UnicodeString FullFileName = FileName;\r\n\r\n    try\r\n    {\r\n      // Receive control record\r\n      UnicodeString Line = FSecureShell->ReceiveLine();\r\n\r\n      if (Line.Length() == 0) FTerminal->FatalError(NULL, LoadStr(SCP_EMPTY_LINE));\r\n\r\n      if (IsLastLine(Line))\r\n      {\r\n        // Remote side finished copying, so remote SCP was closed\r\n        // and we don't need to terminate it manually, see CopyToLocal()\r\n        OperationProgress->SetCancel(csRemoteAbort);\r\n        /* TODO 1 : Show stderror to user? */\r\n        FSecureShell->ClearStdError();\r\n        try\r\n        {\r\n          // coIgnoreWarnings should allow batch transfer to continue when\r\n          // download of one the files fails (user denies overwriting\r\n          // of target local file, no read permissions...)\r\n          ReadCommandOutput(coExpectNoOutput | coRaiseExcept |\r\n            coOnlyReturnCode | coIgnoreWarnings);\r\n          if (!Initialized)\r\n          {\r\n            throw Exception(L\"\");\r\n          }\r\n        }\r\n        catch(Exception & E)\r\n        {\r\n          if (!Initialized && FTerminal->Active)\r\n          {\r\n            FTerminal->TerminalError(&E, LoadStr(SCP_INIT_ERROR));\r\n          }\r\n          else\r\n          {\r\n            throw;\r\n          }\r\n        }\r\n        return;\r\n      }\r\n      else\r\n      {\r\n        Initialized = true;\r\n\r\n        // First character distinguish type of control record\r\n        wchar_t Ctrl = Line[1];\r\n        Line.Delete(1, 1);\r\n\r\n        switch (Ctrl) {\r\n          case 1:\r\n            // Error (already logged by ReceiveLine())\r\n            throw EScpFileSkipped(NULL, FMTLOAD(REMOTE_ERROR, (Line)));\r\n\r\n          case 2:\r\n            // Fatal error, terminate copying\r\n            FTerminal->TerminalError(Line);\r\n            return; // Unreachable\r\n\r\n          case L'E': // Exit\r\n            FSecureShell->SendNull();\r\n            return;\r\n\r\n          case L'T':\r\n            unsigned long MTime, ATime;\r\n            if (swscanf(Line.c_str(), L\"%ld %*d %ld %*d\",  &MTime, &ATime) == 2)\r\n            {\r\n              FileData.Modification = UnixToDateTime(MTime, FTerminal->SessionData->DSTMode);\r\n              FSecureShell->SendNull();\r\n              // File time is only valid until next pass\r\n              FileData.SetTime = 2;\r\n              continue;\r\n            }\r\n              else\r\n            {\r\n              SCPError(LoadStr(SCP_ILLEGAL_TIME_FORMAT), False);\r\n            }\r\n\r\n          case L'C':\r\n          case L'D':\r\n            break; // continue pass switch{}\r\n\r\n          default:\r\n            FTerminal->FatalError(NULL, FMTLOAD(SCP_INVALID_CONTROL_RECORD, (Ctrl, Line)));\r\n        }\r\n\r\n        TFileMasks::TParams MaskParams;\r\n        MaskParams.Modification = FileData.Modification;\r\n\r\n        // We reach this point only if control record was 'C' or 'D'\r\n        try\r\n        {\r\n          FileData.RemoteRights.Octal = CutToChar(Line, L' ', True);\r\n          // do not trim leading spaces of the filename\r\n          __int64 TSize = StrToInt64(CutToChar(Line, L' ', False).TrimRight());\r\n          MaskParams.Size = TSize;\r\n          // Security fix: ensure the file ends up where we asked for it.\r\n          // (accept only filename, not path)\r\n          UnicodeString OnlyFileName = UnixExtractFileName(Line);\r\n          if (Line != OnlyFileName)\r\n          {\r\n            FTerminal->LogEvent(FORMAT(L\"Warning: Remote host set a compound pathname '%s'\", (Line)));\r\n          }\r\n          if ((Level == 0) && (OnlyFileName != UnixExtractFileName(FileName)))\r\n          {\r\n            SCPError(LoadStr(UNREQUESTED_FILE), False);\r\n          }\r\n\r\n          FullFileName = SourceDir + OnlyFileName;\r\n          OperationProgress->SetFile(FullFileName);\r\n          OperationProgress->SetTransferSize(TSize);\r\n        }\r\n        catch (Exception &E)\r\n        {\r\n          {\r\n            TSuspendFileOperationProgress Suspend(OperationProgress);\r\n            FTerminal->Log->AddException(&E);\r\n          }\r\n          SCPError(LoadStr(SCP_ILLEGAL_FILE_DESCRIPTOR), false);\r\n        }\r\n\r\n        // last possibility to cancel transfer before it starts\r\n        if (OperationProgress->Cancel)\r\n        {\r\n          throw ESkipFile(NULL, MainInstructions(LoadStr(USER_TERMINATED)));\r\n        }\r\n\r\n        bool Dir = (Ctrl == L'D');\r\n        UnicodeString BaseFileName = FTerminal->GetBaseFileName(FullFileName);\r\n        if (!CopyParam->AllowTransfer(BaseFileName, osRemote, Dir, MaskParams, IsUnixHiddenFile(BaseFileName)))\r\n        {\r\n          FTerminal->LogEvent(FORMAT(L\"File \\\"%s\\\" excluded from transfer\",\r\n            (FullFileName)));\r\n          SkipConfirmed = true;\r\n          SCPError(L\"\", false);\r\n        }\r\n\r\n        if (CopyParam->SkipTransfer(FullFileName, Dir))\r\n        {\r\n          SkipConfirmed = true;\r\n          SCPError(L\"\", false);\r\n          OperationProgress->AddSkippedFileSize(MaskParams.Size);\r\n        }\r\n\r\n        FTerminal->LogFileDetails(FileName, FileData.Modification, MaskParams.Size);\r\n\r\n        UnicodeString DestFileNameOnly =\r\n          FTerminal->ChangeFileName(\r\n            CopyParam, OperationProgress->FileName, osRemote,\r\n            Level == 0);\r\n        UnicodeString DestFileName =\r\n          IncludeTrailingBackslash(TargetDir) + DestFileNameOnly;\r\n\r\n        FileData.Attrs = FileGetAttrFix(ApiPath(DestFileName));\r\n        // If getting attrs fails, we suppose, that file/folder doesn't exists\r\n        FileData.Exists = (FileData.Attrs != -1);\r\n        if (Dir)\r\n        {\r\n          if (FileData.Exists && !(FileData.Attrs & faDirectory))\r\n          {\r\n            SCPError(FMTLOAD(NOT_DIRECTORY_ERROR, (DestFileName)), false);\r\n          }\r\n\r\n          if (!FileData.Exists)\r\n          {\r\n            FILE_OPERATION_LOOP_BEGIN\r\n            {\r\n              THROWOSIFFALSE(ForceDirectories(ApiPath(DestFileName)));\r\n            }\r\n            FILE_OPERATION_LOOP_END(FMTLOAD(CREATE_DIR_ERROR, (DestFileName)));\r\n            /* SCP: can we set the timestamp for directories ? */\r\n          }\r\n          UnicodeString FullFileName = SourceDir + OperationProgress->FileName;\r\n          SCPSink(DestFileName, FullFileName, UnixIncludeTrailingBackslash(FullFileName),\r\n            CopyParam, Success, OperationProgress, Params, Level + 1);\r\n          continue;\r\n        }\r\n        else if (Ctrl == L'C')\r\n        {\r\n          TDownloadSessionAction Action(FTerminal->ActionLog);\r\n          Action.FileName(FTerminal->AbsolutePath(FullFileName, true));\r\n\r\n          try\r\n          {\r\n            HANDLE File = NULL;\r\n            TStream * FileStream = NULL;\r\n\r\n            /* TODO 1 : Turn off read-only attr */\r\n\r\n            try\r\n            {\r\n              try\r\n              {\r\n                if (FileExists(ApiPath(DestFileName)))\r\n                {\r\n                  __int64 MTime;\r\n                  TOverwriteFileParams FileParams;\r\n                  FileParams.SourceSize = OperationProgress->TransferSize;\r\n                  FileParams.SourceTimestamp = FileData.Modification;\r\n                  FTerminal->OpenLocalFile(DestFileName, GENERIC_READ,\r\n                    NULL, NULL, NULL, &MTime, NULL,\r\n                    &FileParams.DestSize);\r\n                  FileParams.DestTimestamp = UnixToDateTime(MTime,\r\n                    FTerminal->SessionData->DSTMode);\r\n\r\n                  unsigned int Answer =\r\n                    ConfirmOverwrite(OperationProgress->FileName, DestFileNameOnly, osLocal,\r\n                      &FileParams, CopyParam, Params, OperationProgress);\r\n\r\n                  switch (Answer)\r\n                  {\r\n                    case qaCancel:\r\n                      OperationProgress->SetCancel(csCancel); // continue on next case\r\n                    case qaNo:\r\n                      SkipConfirmed = true;\r\n                      EXCEPTION;\r\n                  }\r\n                }\r\n\r\n                Action.Destination(DestFileName);\r\n\r\n                if (!FTerminal->CreateLocalFile(DestFileName, OperationProgress,\r\n                       &File, FLAGSET(Params, cpNoConfirmation)))\r\n                {\r\n                  SkipConfirmed = true;\r\n                  EXCEPTION;\r\n                }\r\n\r\n                FileStream = new TSafeHandleStream((THandle)File);\r\n              }\r\n              catch (Exception &E)\r\n              {\r\n                // In this step we can still cancel transfer, so we do it\r\n                SCPError(E.Message, false);\r\n                throw;\r\n              }\r\n\r\n              // We succeeded, so we confirm transfer to remote side\r\n              FSecureShell->SendNull();\r\n              // From now we need to finish file transfer, if not it's fatal error\r\n              OperationProgress->SetTransferringFile(true);\r\n\r\n              // Suppose same data size to transfer as to write\r\n              // (not true with ASCII transfer)\r\n              OperationProgress->SetLocalSize(OperationProgress->TransferSize);\r\n\r\n              // Will we use ASCII of BINARY file transfer?\r\n              OperationProgress->SetAsciiTransfer(\r\n                CopyParam->UseAsciiTransfer(BaseFileName, osRemote, MaskParams));\r\n              if (FTerminal->Configuration->ActualLogProtocol >= 0)\r\n              {\r\n                FTerminal->LogEvent(UnicodeString((OperationProgress->AsciiTransfer ? L\"Ascii\" : L\"Binary\")) +\r\n                  L\" transfer mode selected.\");\r\n              }\r\n\r\n              try\r\n              {\r\n                // Buffer for one block of data\r\n                TFileBuffer BlockBuf;\r\n                bool ConvertToken = false;\r\n\r\n                do\r\n                {\r\n                  BlockBuf.Size = OperationProgress->TransferBlockSize();\r\n                  BlockBuf.Position = 0;\r\n\r\n                  FSecureShell->Receive(reinterpret_cast<unsigned char *>(BlockBuf.Data), BlockBuf.Size);\r\n                  OperationProgress->AddTransferred(BlockBuf.Size);\r\n\r\n                  if (OperationProgress->AsciiTransfer)\r\n                  {\r\n                    unsigned int PrevBlockSize = BlockBuf.Size;\r\n                    BlockBuf.Convert(FTerminal->SessionData->EOLType,\r\n                      FTerminal->Configuration->LocalEOLType, 0, ConvertToken);\r\n                    OperationProgress->SetLocalSize(\r\n                      OperationProgress->LocalSize - PrevBlockSize + BlockBuf.Size);\r\n                  }\r\n\r\n                  // This is crucial, if it fails during file transfer, it's fatal error\r\n                  FILE_OPERATION_LOOP_BEGIN\r\n                  {\r\n                    BlockBuf.WriteToStream(FileStream, BlockBuf.Size);\r\n                  }\r\n                  FILE_OPERATION_LOOP_END_EX(FMTLOAD(WRITE_ERROR, (DestFileName)), folNone);\r\n\r\n                  OperationProgress->AddLocallyUsed(BlockBuf.Size);\r\n\r\n                  if (OperationProgress->Cancel == csCancelTransfer)\r\n                  {\r\n                    throw Exception(MainInstructions(LoadStr(USER_TERMINATED)));\r\n                  }\r\n                }\r\n                while (!OperationProgress->IsLocallyDone() || !\r\n                    OperationProgress->IsTransferDone());\r\n              }\r\n              catch (Exception &E)\r\n              {\r\n                // Every exception during file transfer is fatal\r\n                FTerminal->FatalError(&E,\r\n                  FMTLOAD(COPY_FATAL, (OperationProgress->FileName)));\r\n              }\r\n\r\n              OperationProgress->SetTransferringFile(false);\r\n\r\n              try\r\n              {\r\n                SCPResponse();\r\n                // If one of following exception occurs, we still need\r\n                // to send confirmation to other side\r\n              }\r\n              catch (EScp &E)\r\n              {\r\n                FSecureShell->SendNull();\r\n                throw;\r\n              }\r\n              catch (EScpFileSkipped &E)\r\n              {\r\n                FSecureShell->SendNull();\r\n                throw;\r\n              }\r\n\r\n              FSecureShell->SendNull();\r\n\r\n              if (FileData.SetTime && CopyParam->PreserveTime)\r\n              {\r\n                FTerminal->UpdateTargetTime(File, FileData.Modification, FTerminal->SessionData->DSTMode);\r\n              }\r\n            }\r\n            __finally\r\n            {\r\n              if (File) CloseHandle(File);\r\n              if (FileStream) delete FileStream;\r\n            }\r\n          }\r\n          catch(Exception & E)\r\n          {\r\n            if (SkipConfirmed)\r\n            {\r\n              Action.Cancel();\r\n            }\r\n            else\r\n            {\r\n              FTerminal->RollbackAction(Action, OperationProgress, &E);\r\n            }\r\n            throw;\r\n          }\r\n\r\n          if (FileData.Attrs == -1) FileData.Attrs = faArchive;\r\n          int NewAttrs = CopyParam->LocalFileAttrs(FileData.RemoteRights);\r\n          if ((NewAttrs & FileData.Attrs) != NewAttrs)\r\n          {\r\n            FILE_OPERATION_LOOP_BEGIN\r\n            {\r\n              THROWOSIFFALSE(FileSetAttr(ApiPath(DestFileName), FileData.Attrs | NewAttrs) == 0);\r\n            }\r\n            FILE_OPERATION_LOOP_END(FMTLOAD(CANT_SET_ATTRS, (DestFileName)));\r\n          }\r\n\r\n          FTerminal->LogFileDone(OperationProgress, DestFileName);\r\n        }\r\n      }\r\n    }\r\n    catch (EScpFileSkipped &E)\r\n    {\r\n      if (!SkipConfirmed)\r\n      {\r\n        TSuspendFileOperationProgress Suspend(OperationProgress);\r\n        TQueryParams Params(qpAllowContinueOnError);\r\n        if (FTerminal->QueryUserException(FMTLOAD(COPY_ERROR, (FullFileName)),\r\n              &E, qaOK | qaAbort, &Params, qtError) == qaAbort)\r\n        {\r\n          OperationProgress->SetCancel(csCancel);\r\n        }\r\n        FTerminal->Log->AddException(&E);\r\n      }\r\n      // this was inside above condition, but then transfer was considered\r\n      // successful, even when for example user refused to overwrite file\r\n      Success = false;\r\n    }\r\n    catch (ESkipFile &E)\r\n    {\r\n      SCPSendError(E.Message, false);\r\n      Success = false;\r\n      if (!FTerminal->HandleException(&E)) throw;\r\n    }\r\n  }\r\n}\r",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144925,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status,\n    cubemap = MagickFalse,\n    volume = MagickFalse;\n\n  CompressionType\n    compression;\n\n  DDSInfo\n    dds_info;\n  \n  DDSDecoder\n    *decoder;\n  \n  PixelTrait\n    alpha_trait;\n  \n  size_t\n    n,\n    num_images;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  \n  /*\n    Initialize image structure.\n  */\n  if (ReadDDSInfo(image, &dds_info) != MagickTrue) {\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  \n  if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP)\n    cubemap = MagickTrue;\n  \n  if (dds_info.ddscaps2 & DDSCAPS2_VOLUME && dds_info.depth > 0)\n    volume = MagickTrue;\n  \n  (void) SeekBlob(image, 128, SEEK_SET);\n\n  /*\n    Determine pixel format\n  */\n  if (dds_info.pixelformat.flags & DDPF_RGB)\n    {\n      compression = NoCompression;\n      if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)\n        {\n          alpha_trait = BlendPixelTrait;\n          decoder = ReadUncompressedRGBA;\n        }\n      else\n        {\n          alpha_trait = UndefinedPixelTrait;\n          decoder = ReadUncompressedRGB;\n        }\n    }\n  else if (dds_info.pixelformat.flags & DDPF_LUMINANCE)\n   {\n      compression = NoCompression;\n      if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)\n        {\n          /* Not sure how to handle this */\n          ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n        }\n      else\n        {\n          alpha_trait = UndefinedPixelTrait;\n          decoder = ReadUncompressedRGB;\n        }\n    }\n  else if (dds_info.pixelformat.flags & DDPF_FOURCC)\n    {\n      switch (dds_info.pixelformat.fourcc)\n      {\n        case FOURCC_DXT1:\n        {\n          alpha_trait = UndefinedPixelTrait;\n          compression = DXT1Compression;\n          decoder = ReadDXT1;\n          break;\n        }\n        case FOURCC_DXT3:\n        {\n          alpha_trait = BlendPixelTrait;\n          compression = DXT3Compression;\n          decoder = ReadDXT3;\n          break;\n        }\n        case FOURCC_DXT5:\n        {\n          alpha_trait = BlendPixelTrait;\n          compression = DXT5Compression;\n          decoder = ReadDXT5;\n          break;\n        }\n        default:\n        {\n          /* Unknown FOURCC */\n          ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n        }\n      }\n    }\n  else\n    {\n      /* Neither compressed nor uncompressed... thus unsupported */\n      ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n    }\n  \n  num_images = 1;\n  if (cubemap)\n    {\n      /*\n        Determine number of faces defined in the cubemap\n      */\n      num_images = 0;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ) num_images++;\n    }\n  \n  if (volume)\n    num_images = dds_info.depth;\n  \n  for (n = 0; n < num_images; n++)\n  {\n    if (n != 0)\n      {\n        /* Start a new image */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          return(DestroyImageList(image));\n        image=SyncNextImageInList(image);\n      }\n    \n    image->alpha_trait=alpha_trait;\n    image->compression = compression;\n    image->columns = dds_info.width;\n    image->rows = dds_info.height;\n    image->storage_class = DirectClass;\n    image->endian = LSBEndian;\n    image->depth = 8;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    if ((decoder)(image, &dds_info, exception) != MagickTrue)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144962,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status,\n    cubemap = MagickFalse,\n    volume = MagickFalse;\n\n  CompressionType\n    compression;\n\n  DDSInfo\n    dds_info;\n  \n  DDSDecoder\n    *decoder;\n  \n  PixelTrait\n    alpha_trait;\n  \n  size_t\n    n,\n    num_images;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  \n  /*\n    Initialize image structure.\n  */\n  if (ReadDDSInfo(image, &dds_info) != MagickTrue)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP)\n    cubemap = MagickTrue;\n\n  if (dds_info.ddscaps2 & DDSCAPS2_VOLUME && dds_info.depth > 0)\n    volume = MagickTrue;\n\n  (void) SeekBlob(image, 128, SEEK_SET);\n\n  /*\n    Determine pixel format\n  */\n  if (dds_info.pixelformat.flags & DDPF_RGB)\n    {\n      compression = NoCompression;\n      if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)\n        {\n          alpha_trait = BlendPixelTrait;\n          decoder = ReadUncompressedRGBA;\n        }\n      else\n        {\n          alpha_trait = UndefinedPixelTrait;\n          decoder = ReadUncompressedRGB;\n        }\n    }\n  else if (dds_info.pixelformat.flags & DDPF_LUMINANCE)\n   {\n      compression = NoCompression;\n      if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)\n        {\n          /* Not sure how to handle this */\n          ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n        }\n      else\n        {\n          alpha_trait = UndefinedPixelTrait;\n          decoder = ReadUncompressedRGB;\n        }\n    }\n  else if (dds_info.pixelformat.flags & DDPF_FOURCC)\n    {\n      switch (dds_info.pixelformat.fourcc)\n      {\n        case FOURCC_DXT1:\n        {\n          alpha_trait = UndefinedPixelTrait;\n          compression = DXT1Compression;\n          decoder = ReadDXT1;\n          break;\n        }\n        case FOURCC_DXT3:\n        {\n          alpha_trait = BlendPixelTrait;\n          compression = DXT3Compression;\n          decoder = ReadDXT3;\n          break;\n        }\n        case FOURCC_DXT5:\n        {\n          alpha_trait = BlendPixelTrait;\n          compression = DXT5Compression;\n          decoder = ReadDXT5;\n          break;\n        }\n        default:\n        {\n          /* Unknown FOURCC */\n          ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n        }\n      }\n    }\n  else\n    {\n      /* Neither compressed nor uncompressed... thus unsupported */\n      ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n    }\n  \n  num_images = 1;\n  if (cubemap)\n    {\n      /*\n        Determine number of faces defined in the cubemap\n      */\n      num_images = 0;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ) num_images++;\n    }\n  \n  if (volume)\n    num_images = dds_info.depth;\n\n  if (num_images < 1)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  for (n = 0; n < num_images; n++)\n  {\n    if (n != 0)\n      {\n        /* Start a new image */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          return(DestroyImageList(image));\n        image=SyncNextImageInList(image);\n      }\n    \n    image->alpha_trait=alpha_trait;\n    image->compression = compression;\n    image->columns = dds_info.width;\n    image->rows = dds_info.height;\n    image->storage_class = DirectClass;\n    image->endian = LSBEndian;\n    image->depth = 8;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    if ((decoder)(image, &dds_info, exception) != MagickTrue)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144963,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& contents = context->input(0);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(contents.shape()),\n                errors::InvalidArgument(\"contents must be scalar, got shape \",\n                                        contents.shape().DebugString()));\n\n    // Start decoding image to get shape details\n    const StringPiece input = contents.scalar<string>()();\n\n    OP_REQUIRES(context, (32 <= input.size()),\n                errors::InvalidArgument(\"Incomplete bmp content, requires at \"\n                                        \"least 32 bytes to find the header \"\n                                        \"size, width, height, and bpp, got \",\n                                        input.size(), \" bytes\"));\n\n    const uint8* img_bytes = reinterpret_cast<const uint8*>(input.data());\n    int32 header_size_ = internal::SubtleMustCopy(\n        *(reinterpret_cast<const int32*>(img_bytes + 10)));\n    const int32 header_size = ByteSwapInt32ForBigEndian(header_size_);\n    int32 width_ = internal::SubtleMustCopy(\n        *(reinterpret_cast<const int32*>(img_bytes + 18)));\n    const int32 width = ByteSwapInt32ForBigEndian(width_);\n    int32 height_ = internal::SubtleMustCopy(\n        *(reinterpret_cast<const int32*>(img_bytes + 22)));\n    const int32 height = ByteSwapInt32ForBigEndian(height_);\n    int32 bpp_ = internal::SubtleMustCopy(\n        *(reinterpret_cast<const int32*>(img_bytes + 28)));\n    const int32 bpp = ByteSwapInt32ForBigEndian(bpp_);\n\n    if (channels_) {\n      OP_REQUIRES(context, (channels_ == bpp / 8),\n                  errors::InvalidArgument(\n                      \"channels attribute \", channels_,\n                      \" does not match bits per pixel from file \", bpp / 8));\n    } else {\n      channels_ = bpp / 8;\n    }\n\n    // Current implementation only supports 1, 3 or 4 channel\n    // bitmaps.\n    OP_REQUIRES(context, (channels_ == 1 || channels_ == 3 || channels_ == 4),\n                errors::InvalidArgument(\n                    \"Number of channels must be 1, 3 or 4, was \", channels_));\n\n    // there may be padding bytes when the width is not a multiple of 4 bytes\n    // 8 * channels == bits per pixel\n    const int row_size = (8 * channels_ * width + 31) / 32 * 4;\n\n    const int last_pixel_offset =\n        header_size + (abs(height) - 1) * row_size + (width - 1) * channels_;\n\n    // [expected file size] = [last pixel offset] + [last pixel size=channels]\n    const int expected_file_size = last_pixel_offset + channels_;\n\n    OP_REQUIRES(\n        context, (expected_file_size <= input.size()),\n        errors::InvalidArgument(\"Incomplete bmp content, requires at least \",\n                                expected_file_size, \" bytes, got \",\n                                input.size(), \" bytes\"));\n\n    // if height is negative, data layout is top down\n    // otherwise, it's bottom up\n    bool top_down = (height < 0);\n\n    // Decode image, allocating tensor once the image size is known\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\n                     0, TensorShape({abs(height), width, channels_}), &output));\n\n    const uint8* bmp_pixels = &img_bytes[header_size];\n\n    Decode(bmp_pixels, row_size, output->flat<uint8>().data(), width,\n           abs(height), channels_, top_down);\n  }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144966,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& contents = context->input(0);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(contents.shape()),\n                errors::InvalidArgument(\"contents must be scalar, got shape \",\n                                        contents.shape().DebugString()));\n\n    // Start decoding image to get shape details\n    const StringPiece input = contents.scalar<string>()();\n\n    OP_REQUIRES(context, (32 <= input.size()),\n                errors::InvalidArgument(\"Incomplete bmp content, requires at \"\n                                        \"least 32 bytes to find the header \"\n                                        \"size, width, height, and bpp, got \",\n                                        input.size(), \" bytes\"));\n\n    const uint8* img_bytes = reinterpret_cast<const uint8*>(input.data());\n    int32 header_size_ = internal::SubtleMustCopy(\n        *(reinterpret_cast<const int32*>(img_bytes + 10)));\n    const int32 header_size = ByteSwapInt32ForBigEndian(header_size_);\n    int32 width_ = internal::SubtleMustCopy(\n        *(reinterpret_cast<const int32*>(img_bytes + 18)));\n    const int32 width = ByteSwapInt32ForBigEndian(width_);\n    int32 height_ = internal::SubtleMustCopy(\n        *(reinterpret_cast<const int32*>(img_bytes + 22)));\n    const int32 height = ByteSwapInt32ForBigEndian(height_);\n    int32 bpp_ = internal::SubtleMustCopy(\n        *(reinterpret_cast<const int32*>(img_bytes + 28)));\n    const int32 bpp = ByteSwapInt32ForBigEndian(bpp_);\n\n    if (channels_) {\n      OP_REQUIRES(context, (channels_ == bpp / 8),\n                  errors::InvalidArgument(\n                      \"channels attribute \", channels_,\n                      \" does not match bits per pixel from file \", bpp / 8));\n    } else {\n      channels_ = bpp / 8;\n    }\n\n    // Current implementation only supports 1, 3 or 4 channel\n    // bitmaps.\n    OP_REQUIRES(context, (channels_ == 1 || channels_ == 3 || channels_ == 4),\n                errors::InvalidArgument(\n                    \"Number of channels must be 1, 3 or 4, was \", channels_));\n\n    OP_REQUIRES(context, width > 0 && header_size >= 0,\n                errors::InvalidArgument(\"Width must be positive\"));\n    OP_REQUIRES(context, header_size >= 0,\n                errors::InvalidArgument(\"header size must be nonnegative\"));\n\n    // The real requirement is < 2^31 minus some headers and channel data,\n    // so rounding down to something that's still ridiculously big.\n    OP_REQUIRES(\n        context,\n        (static_cast<int64>(width) * std::abs(static_cast<int64>(height))) <\n            static_cast<int64>(std::numeric_limits<int32_t>::max() / 8),\n        errors::InvalidArgument(\n            \"Total possible pixel bytes must be less than 2^30\"));\n\n    const int32 abs_height = abs(height);\n\n    // there may be padding bytes when the width is not a multiple of 4 bytes\n    // 8 * channels == bits per pixel\n    const int row_size = (8 * channels_ * width + 31) / 32 * 4;\n\n    const int64 last_pixel_offset = static_cast<int64>(header_size) +\n                                    (abs_height - 1) * row_size +\n                                    (width - 1) * channels_;\n\n    // [expected file size] = [last pixel offset] + [last pixel size=channels]\n    const int64 expected_file_size = last_pixel_offset + channels_;\n\n    OP_REQUIRES(\n        context, (expected_file_size <= input.size()),\n        errors::InvalidArgument(\"Incomplete bmp content, requires at least \",\n                                expected_file_size, \" bytes, got \",\n                                input.size(), \" bytes\"));\n\n    // if height is negative, data layout is top down\n    // otherwise, it's bottom up\n    bool top_down = (height < 0);\n\n    // Decode image, allocating tensor once the image size is known\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\n                     0, TensorShape({abs_height, width, channels_}), &output));\n\n    const uint8* bmp_pixels = &img_bytes[header_size];\n\n    Decode(bmp_pixels, row_size, output->flat<uint8>().data(), width,\n           abs_height, channels_, top_down);\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144967,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "char *Hub::inflate(char *data, size_t &length) {\n    dynamicInflationBuffer.clear();\n\n    inflationStream.next_in = (Bytef *) data;\n    inflationStream.avail_in = length;\n\n    int err;\n    do {\n        inflationStream.next_out = (Bytef *) inflationBuffer;\n        inflationStream.avail_out = LARGE_BUFFER_SIZE;\n        err = ::inflate(&inflationStream, Z_FINISH);\n        if (!inflationStream.avail_in) {\n            break;\n        }\n        dynamicInflationBuffer.append(inflationBuffer, LARGE_BUFFER_SIZE - inflationStream.avail_out);\n    } while (err == Z_BUF_ERROR);\n\n    inflateReset(&inflationStream);\n\n    if (err != Z_BUF_ERROR && err != Z_OK) {\n        length = 0;\n        return nullptr;\n    }\n\n    if (dynamicInflationBuffer.length()) {\n        dynamicInflationBuffer.append(inflationBuffer, LARGE_BUFFER_SIZE - inflationStream.avail_out);\n\n        length = dynamicInflationBuffer.length();\n        return (char *) dynamicInflationBuffer.data();\n    }\n\n    length = LARGE_BUFFER_SIZE - inflationStream.avail_out;\n    return inflationBuffer;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144972,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "char *Hub::inflate(char *data, size_t &length) {\n    dynamicInflationBuffer.clear();\n\n    inflationStream.next_in = (Bytef *) data;\n    inflationStream.avail_in = length;\n\n    int err;\n    do {\n        inflationStream.next_out = (Bytef *) inflationBuffer;\n        inflationStream.avail_out = LARGE_BUFFER_SIZE;\n        err = ::inflate(&inflationStream, Z_FINISH);\n        if (!inflationStream.avail_in) {\n            break;\n        }\n\n        dynamicInflationBuffer.append(inflationBuffer, LARGE_BUFFER_SIZE - inflationStream.avail_out);\n    } while (err == Z_BUF_ERROR && dynamicInflationBuffer.length() <= INFLATE_LESS_THAN_ROUGHLY);\n\n    inflateReset(&inflationStream);\n\n    if ((err != Z_BUF_ERROR && err != Z_OK) || dynamicInflationBuffer.length() > INFLATE_LESS_THAN_ROUGHLY) {\n        length = 0;\n        return nullptr;\n    }\n\n    if (dynamicInflationBuffer.length()) {\n        dynamicInflationBuffer.append(inflationBuffer, LARGE_BUFFER_SIZE - inflationStream.avail_out);\n\n        length = dynamicInflationBuffer.length();\n        return (char *) dynamicInflationBuffer.data();\n    }\n\n    length = LARGE_BUFFER_SIZE - inflationStream.avail_out;\n    return inflationBuffer;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144973,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "    Status CmdAuthenticate::_authenticateX509(const UserName& user, const BSONObj& cmdObj) {\n        if (!getSSLManager()) {\n            return Status(ErrorCodes::ProtocolError,\n                          \"SSL support is required for the MONGODB-X509 mechanism.\");\n        }\n        if(user.getDB() != \"$external\") {\n            return Status(ErrorCodes::ProtocolError,\n                          \"X.509 authentication must always use the $external database.\");\n        }\n\n        ClientBasic *client = ClientBasic::getCurrent();\n        AuthorizationSession* authorizationSession = client->getAuthorizationSession();\n        std::string subjectName = client->port()->getX509SubjectName();\n\n        if (user.getUser() != subjectName) {\n            return Status(ErrorCodes::AuthenticationFailed,\n                          \"There is no x.509 client certificate matching the user.\");\n        }\n        else {\n            std::string srvSubjectName = getSSLManager()->getServerSubjectName();\n            std::string srvClusterId = srvSubjectName.substr(srvSubjectName.find(\",OU=\"));\n            std::string peerClusterId = subjectName.substr(subjectName.find(\",OU=\"));\n\n            fassert(17002, !srvClusterId.empty() && srvClusterId != srvSubjectName);\n\n            // Handle internal cluster member auth, only applies to server-server connections\n            int clusterAuthMode = serverGlobalParams.clusterAuthMode.load(); \n            if (srvClusterId == peerClusterId) {\n                if (clusterAuthMode == ServerGlobalParams::ClusterAuthMode_undefined ||\n                    clusterAuthMode == ServerGlobalParams::ClusterAuthMode_keyFile) {\n                    return Status(ErrorCodes::AuthenticationFailed, \"The provided certificate \" \n                                  \"can only be used for cluster authentication, not client \" \n                                  \"authentication. The current configuration does not allow \" \n                                  \"x.509 cluster authentication, check the --clusterAuthMode flag\");\n                }\n                authorizationSession->grantInternalAuthorization();\n            }\n            // Handle normal client authentication, only applies to client-server connections\n            else {\n                if (_isX509AuthDisabled) {\n                    return Status(ErrorCodes::BadValue,\n                                  _x509AuthenticationDisabledMessage);\n                }\n                Status status = authorizationSession->addAndAuthorizeUser(user);\n                if (!status.isOK()) {\n                    return status;\n                }\n            }\n            return Status::OK();\n        }\n    }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145132,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "    Status CmdAuthenticate::_authenticateX509(const UserName& user, const BSONObj& cmdObj) {\n        if (!getSSLManager()) {\n            return Status(ErrorCodes::ProtocolError,\n                          \"SSL support is required for the MONGODB-X509 mechanism.\");\n        }\n        if(user.getDB() != \"$external\") {\n            return Status(ErrorCodes::ProtocolError,\n                          \"X.509 authentication must always use the $external database.\");\n        }\n\n        ClientBasic *client = ClientBasic::getCurrent();\n        AuthorizationSession* authorizationSession = client->getAuthorizationSession();\n        std::string subjectName = client->port()->getX509SubjectName();\n\n        if (user.getUser() != subjectName) {\n            return Status(ErrorCodes::AuthenticationFailed,\n                          \"There is no x.509 client certificate matching the user.\");\n        }\n        else {\n            std::string srvSubjectName = getSSLManager()->getServerSubjectName();\n            \n            size_t srvClusterIdPos = srvSubjectName.find(\",OU=\");\n            size_t peerClusterIdPos = subjectName.find(\",OU=\");\n\n            std::string srvClusterId = srvClusterIdPos != std::string::npos ? \n                srvSubjectName.substr(srvClusterIdPos) : \"\";\n            std::string peerClusterId = peerClusterIdPos != std::string::npos ? \n                subjectName.substr(peerClusterIdPos) : \"\";\n\n            // Handle internal cluster member auth, only applies to server-server connections\n            int clusterAuthMode = serverGlobalParams.clusterAuthMode.load(); \n            if (srvClusterId == peerClusterId && !srvClusterId.empty()) {\n                if (clusterAuthMode == ServerGlobalParams::ClusterAuthMode_undefined ||\n                    clusterAuthMode == ServerGlobalParams::ClusterAuthMode_keyFile) {\n                    return Status(ErrorCodes::AuthenticationFailed, \"The provided certificate \" \n                                  \"can only be used for cluster authentication, not client \" \n                                  \"authentication. The current configuration does not allow \" \n                                  \"x.509 cluster authentication, check the --clusterAuthMode flag\");\n                }\n                authorizationSession->grantInternalAuthorization();\n            }\n            // Handle normal client authentication, only applies to client-server connections\n            else {\n                if (_isX509AuthDisabled) {\n                    return Status(ErrorCodes::BadValue,\n                                  _x509AuthenticationDisabledMessage);\n                }\n                Status status = authorizationSession->addAndAuthorizeUser(user);\n                if (!status.isOK()) {\n                    return status;\n                }\n            }\n            return Status::OK();\n        }\n    }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145133,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                             const char *name, uint32_t *write_to,\n                             uint32_t range_min, uint32_t range_max)\n{\n    uint32_t value;\n    int position, zeroes, i, j;\n    char bits[65];\n\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n\n    zeroes = i = 0;\n    while (1) {\n        if (get_bits_left(gbc) < zeroes + 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (get_bits1(gbc)) {\n            bits[i++] = '1';\n            break;\n        } else {\n            bits[i++] = '0';\n            ++zeroes;\n        }\n    }\n\n    if (zeroes >= 32) {\n        value = MAX_UINT_BITS(32);\n    } else {\n        value = get_bits_long(gbc, zeroes);\n\n        for (j = 0; j < zeroes; j++)\n            bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';\n\n        value += (1 << zeroes) - 1;\n    }\n\n    if (ctx->trace_enable) {\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name, NULL,\n                                    bits, value);\n    }\n\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n\n    *write_to = value;\n    return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145138,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                             const char *name, uint32_t *write_to,\n                             uint32_t range_min, uint32_t range_max)\n{\n    uint32_t zeroes, bits_value, value;\n    int position;\n\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n\n    zeroes = 0;\n    while (1) {\n        if (get_bits_left(gbc) < 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (get_bits1(gbc))\n            break;\n        ++zeroes;\n    }\n\n    if (zeroes >= 32) {\n        value = MAX_UINT_BITS(32);\n    } else {\n        if (get_bits_left(gbc) < zeroes) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n\n        bits_value = get_bits_long(gbc, zeroes);\n        value = bits_value + (UINT32_C(1) << zeroes) - 1;\n    }\n\n    if (ctx->trace_enable) {\n        char bits[65];\n        int i, j, k;\n\n        if (zeroes >= 32) {\n            while (zeroes > 32) {\n                k = FFMIN(zeroes - 32, 32);\n                for (i = 0; i < k; i++)\n                    bits[i] = '0';\n                bits[i] = 0;\n                ff_cbs_trace_syntax_element(ctx, position, name,\n                                            NULL, bits, 0);\n                zeroes -= k;\n                position += k;\n            }\n        }\n\n        for (i = 0; i < zeroes; i++)\n            bits[i] = '0';\n        bits[i++] = '1';\n\n        if (zeroes < 32) {\n            for (j = 0; j < zeroes; j++)\n                bits[i++] = (bits_value >> (zeroes - j - 1) & 1) ? '1' : '0';\n        }\n\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name,\n                                    NULL, bits, value);\n    }\n\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n\n    *write_to = value;\n    return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145139,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "wf_cliprdr_server_file_contents_request(CliprdrClientContext* context,\n                                        const CLIPRDR_FILE_CONTENTS_REQUEST* fileContentsRequest)\n{\n\tDWORD uSize = 0;\n\tBYTE* pData = NULL;\n\tHRESULT hRet = S_OK;\n\tFORMATETC vFormatEtc;\n\tLPDATAOBJECT pDataObj = NULL;\n\tSTGMEDIUM vStgMedium;\n\tBOOL bIsStreamFile = TRUE;\n\tstatic LPSTREAM pStreamStc = NULL;\n\tstatic UINT32 uStreamIdStc = 0;\n\twfClipboard* clipboard;\n\tUINT rc = ERROR_INTERNAL_ERROR;\n\tUINT sRc;\n\tUINT32 cbRequested;\n\n\tif (!context || !fileContentsRequest)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tclipboard = (wfClipboard*)context->custom;\n\n\tif (!clipboard)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tcbRequested = fileContentsRequest->cbRequested;\n\tif (fileContentsRequest->dwFlags == FILECONTENTS_SIZE)\n\t\tcbRequested = sizeof(UINT64);\n\n\tpData = (BYTE*)calloc(1, cbRequested);\n\n\tif (!pData)\n\t\tgoto error;\n\n\thRet = OleGetClipboard(&pDataObj);\n\n\tif (FAILED(hRet))\n\t{\n\t\tWLog_ERR(TAG, \"filecontents: get ole clipboard failed.\");\n\t\tgoto error;\n\t}\n\n\tZeroMemory(&vFormatEtc, sizeof(FORMATETC));\n\tZeroMemory(&vStgMedium, sizeof(STGMEDIUM));\n\tvFormatEtc.cfFormat = RegisterClipboardFormat(CFSTR_FILECONTENTS);\n\tvFormatEtc.tymed = TYMED_ISTREAM;\n\tvFormatEtc.dwAspect = 1;\n\tvFormatEtc.lindex = fileContentsRequest->listIndex;\n\tvFormatEtc.ptd = NULL;\n\n\tif ((uStreamIdStc != fileContentsRequest->streamId) || !pStreamStc)\n\t{\n\t\tLPENUMFORMATETC pEnumFormatEtc;\n\t\tULONG CeltFetched;\n\t\tFORMATETC vFormatEtc2;\n\n\t\tif (pStreamStc)\n\t\t{\n\t\t\tIStream_Release(pStreamStc);\n\t\t\tpStreamStc = NULL;\n\t\t}\n\n\t\tbIsStreamFile = FALSE;\n\t\thRet = IDataObject_EnumFormatEtc(pDataObj, DATADIR_GET, &pEnumFormatEtc);\n\n\t\tif (hRet == S_OK)\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\thRet = IEnumFORMATETC_Next(pEnumFormatEtc, 1, &vFormatEtc2, &CeltFetched);\n\n\t\t\t\tif (hRet == S_OK)\n\t\t\t\t{\n\t\t\t\t\tif (vFormatEtc2.cfFormat == RegisterClipboardFormat(CFSTR_FILECONTENTS))\n\t\t\t\t\t{\n\t\t\t\t\t\thRet = IDataObject_GetData(pDataObj, &vFormatEtc, &vStgMedium);\n\n\t\t\t\t\t\tif (hRet == S_OK)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpStreamStc = vStgMedium.pstm;\n\t\t\t\t\t\t\tuStreamIdStc = fileContentsRequest->streamId;\n\t\t\t\t\t\t\tbIsStreamFile = TRUE;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (hRet == S_OK);\n\t\t}\n\t}\n\n\tif (bIsStreamFile == TRUE)\n\t{\n\t\tif (fileContentsRequest->dwFlags == FILECONTENTS_SIZE)\n\t\t{\n\t\t\tSTATSTG vStatStg;\n\t\t\tZeroMemory(&vStatStg, sizeof(STATSTG));\n\t\t\thRet = IStream_Stat(pStreamStc, &vStatStg, STATFLAG_NONAME);\n\n\t\t\tif (hRet == S_OK)\n\t\t\t{\n\t\t\t\t*((UINT32*)&pData[0]) = vStatStg.cbSize.LowPart;\n\t\t\t\t*((UINT32*)&pData[4]) = vStatStg.cbSize.HighPart;\n\t\t\t\tuSize = cbRequested;\n\t\t\t}\n\t\t}\n\t\telse if (fileContentsRequest->dwFlags == FILECONTENTS_RANGE)\n\t\t{\n\t\t\tLARGE_INTEGER dlibMove;\n\t\t\tULARGE_INTEGER dlibNewPosition;\n\t\t\tdlibMove.HighPart = fileContentsRequest->nPositionHigh;\n\t\t\tdlibMove.LowPart = fileContentsRequest->nPositionLow;\n\t\t\thRet = IStream_Seek(pStreamStc, dlibMove, STREAM_SEEK_SET, &dlibNewPosition);\n\n\t\t\tif (SUCCEEDED(hRet))\n\t\t\t\thRet = IStream_Read(pStreamStc, pData, cbRequested, (PULONG)&uSize);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (fileContentsRequest->dwFlags == FILECONTENTS_SIZE)\n\t\t{\n\t\t\t*((UINT32*)&pData[0]) =\n\t\t\t    clipboard->fileDescriptor[fileContentsRequest->listIndex]->nFileSizeLow;\n\t\t\t*((UINT32*)&pData[4]) =\n\t\t\t    clipboard->fileDescriptor[fileContentsRequest->listIndex]->nFileSizeHigh;\n\t\t\tuSize = cbRequested;\n\t\t}\n\t\telse if (fileContentsRequest->dwFlags == FILECONTENTS_RANGE)\n\t\t{\n\t\t\tBOOL bRet;\n\t\t\tbRet = wf_cliprdr_get_file_contents(\n\t\t\t    clipboard->file_names[fileContentsRequest->listIndex], pData,\n\t\t\t    fileContentsRequest->nPositionLow, fileContentsRequest->nPositionHigh, cbRequested,\n\t\t\t    &uSize);\n\n\t\t\tif (bRet == FALSE)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"get file contents failed.\");\n\t\t\t\tuSize = 0;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\trc = CHANNEL_RC_OK;\nerror:\n\n\tif (pDataObj)\n\t\tIDataObject_Release(pDataObj);\n\n\tif (uSize == 0)\n\t{\n\t\tfree(pData);\n\t\tpData = NULL;\n\t}\n\n\tsRc =\n\t    cliprdr_send_response_filecontents(clipboard, fileContentsRequest->streamId, uSize, pData);\n\tfree(pData);\n\n\tif (sRc != CHANNEL_RC_OK)\n\t\treturn sRc;\n\n\treturn rc;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145180,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "wf_cliprdr_server_file_contents_request(CliprdrClientContext* context,\n                                        const CLIPRDR_FILE_CONTENTS_REQUEST* fileContentsRequest)\n{\n\tDWORD uSize = 0;\n\tBYTE* pData = NULL;\n\tHRESULT hRet = S_OK;\n\tFORMATETC vFormatEtc;\n\tLPDATAOBJECT pDataObj = NULL;\n\tSTGMEDIUM vStgMedium;\n\tBOOL bIsStreamFile = TRUE;\n\tstatic LPSTREAM pStreamStc = NULL;\n\tstatic UINT32 uStreamIdStc = 0;\n\twfClipboard* clipboard;\n\tUINT rc = ERROR_INTERNAL_ERROR;\n\tUINT sRc;\n\tUINT32 cbRequested;\n\n\tif (!context || !fileContentsRequest)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tclipboard = (wfClipboard*)context->custom;\n\n\tif (!clipboard)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tcbRequested = fileContentsRequest->cbRequested;\n\tif (fileContentsRequest->dwFlags == FILECONTENTS_SIZE)\n\t\tcbRequested = sizeof(UINT64);\n\n\tpData = (BYTE*)calloc(1, cbRequested);\n\n\tif (!pData)\n\t\tgoto error;\n\n\thRet = OleGetClipboard(&pDataObj);\n\n\tif (FAILED(hRet))\n\t{\n\t\tWLog_ERR(TAG, \"filecontents: get ole clipboard failed.\");\n\t\tgoto error;\n\t}\n\n\tZeroMemory(&vFormatEtc, sizeof(FORMATETC));\n\tZeroMemory(&vStgMedium, sizeof(STGMEDIUM));\n\tvFormatEtc.cfFormat = RegisterClipboardFormat(CFSTR_FILECONTENTS);\n\tvFormatEtc.tymed = TYMED_ISTREAM;\n\tvFormatEtc.dwAspect = 1;\n\tvFormatEtc.lindex = fileContentsRequest->listIndex;\n\tvFormatEtc.ptd = NULL;\n\n\tif ((uStreamIdStc != fileContentsRequest->streamId) || !pStreamStc)\n\t{\n\t\tLPENUMFORMATETC pEnumFormatEtc;\n\t\tULONG CeltFetched;\n\t\tFORMATETC vFormatEtc2;\n\n\t\tif (pStreamStc)\n\t\t{\n\t\t\tIStream_Release(pStreamStc);\n\t\t\tpStreamStc = NULL;\n\t\t}\n\n\t\tbIsStreamFile = FALSE;\n\t\thRet = IDataObject_EnumFormatEtc(pDataObj, DATADIR_GET, &pEnumFormatEtc);\n\n\t\tif (hRet == S_OK)\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\thRet = IEnumFORMATETC_Next(pEnumFormatEtc, 1, &vFormatEtc2, &CeltFetched);\n\n\t\t\t\tif (hRet == S_OK)\n\t\t\t\t{\n\t\t\t\t\tif (vFormatEtc2.cfFormat == RegisterClipboardFormat(CFSTR_FILECONTENTS))\n\t\t\t\t\t{\n\t\t\t\t\t\thRet = IDataObject_GetData(pDataObj, &vFormatEtc, &vStgMedium);\n\n\t\t\t\t\t\tif (hRet == S_OK)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpStreamStc = vStgMedium.pstm;\n\t\t\t\t\t\t\tuStreamIdStc = fileContentsRequest->streamId;\n\t\t\t\t\t\t\tbIsStreamFile = TRUE;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (hRet == S_OK);\n\t\t}\n\t}\n\n\tif (bIsStreamFile == TRUE)\n\t{\n\t\tif (fileContentsRequest->dwFlags == FILECONTENTS_SIZE)\n\t\t{\n\t\t\tSTATSTG vStatStg;\n\t\t\tZeroMemory(&vStatStg, sizeof(STATSTG));\n\t\t\thRet = IStream_Stat(pStreamStc, &vStatStg, STATFLAG_NONAME);\n\n\t\t\tif (hRet == S_OK)\n\t\t\t{\n\t\t\t\t*((UINT32*)&pData[0]) = vStatStg.cbSize.LowPart;\n\t\t\t\t*((UINT32*)&pData[4]) = vStatStg.cbSize.HighPart;\n\t\t\t\tuSize = cbRequested;\n\t\t\t}\n\t\t}\n\t\telse if (fileContentsRequest->dwFlags == FILECONTENTS_RANGE)\n\t\t{\n\t\t\tLARGE_INTEGER dlibMove;\n\t\t\tULARGE_INTEGER dlibNewPosition;\n\t\t\tdlibMove.HighPart = fileContentsRequest->nPositionHigh;\n\t\t\tdlibMove.LowPart = fileContentsRequest->nPositionLow;\n\t\t\thRet = IStream_Seek(pStreamStc, dlibMove, STREAM_SEEK_SET, &dlibNewPosition);\n\n\t\t\tif (SUCCEEDED(hRet))\n\t\t\t\thRet = IStream_Read(pStreamStc, pData, cbRequested, (PULONG)&uSize);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (fileContentsRequest->dwFlags == FILECONTENTS_SIZE)\n\t\t{\n\t\t\tif (clipboard->nFiles <= fileContentsRequest->listIndex)\n\t\t\t\tgoto error;\n\t\t\t*((UINT32*)&pData[0]) =\n\t\t\t    clipboard->fileDescriptor[fileContentsRequest->listIndex]->nFileSizeLow;\n\t\t\t*((UINT32*)&pData[4]) =\n\t\t\t    clipboard->fileDescriptor[fileContentsRequest->listIndex]->nFileSizeHigh;\n\t\t\tuSize = cbRequested;\n\t\t}\n\t\telse if (fileContentsRequest->dwFlags == FILECONTENTS_RANGE)\n\t\t{\n\t\t\tBOOL bRet;\n\t\t\tif (clipboard->nFiles <= fileContentsRequest->listIndex)\n\t\t\t\tgoto error;\n\t\t\tbRet = wf_cliprdr_get_file_contents(\n\t\t\t    clipboard->file_names[fileContentsRequest->listIndex], pData,\n\t\t\t    fileContentsRequest->nPositionLow, fileContentsRequest->nPositionHigh, cbRequested,\n\t\t\t    &uSize);\n\n\t\t\tif (bRet == FALSE)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"get file contents failed.\");\n\t\t\t\tuSize = 0;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\trc = CHANNEL_RC_OK;\nerror:\n\n\tif (pDataObj)\n\t\tIDataObject_Release(pDataObj);\n\n\tif (uSize == 0)\n\t{\n\t\tfree(pData);\n\t\tpData = NULL;\n\t}\n\n\tsRc =\n\t    cliprdr_send_response_filecontents(clipboard, fileContentsRequest->streamId, uSize, pData);\n\tfree(pData);\n\n\tif (sRc != CHANNEL_RC_OK)\n\t\treturn sRc;\n\n\treturn rc;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145181,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "MonoReflectionMethod*\nmono_reflection_bind_generic_method_parameters (MonoReflectionMethod *rmethod, MonoArray *types)\n{\n\tMonoClass *klass;\n\tMonoMethod *method, *inflated;\n\tMonoMethodInflated *imethod;\n\tMonoGenericContext tmp_context;\n\tMonoGenericInst *ginst;\n\tMonoType **type_argv;\n\tint count, i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\t/*FIXME but this no longer should happen*/\n\tif (!strcmp (rmethod->object.vtable->klass->name, \"MethodBuilder\")) {\n#ifndef DISABLE_REFLECTION_EMIT\n\t\tMonoReflectionMethodBuilder *mb = NULL;\n\t\tMonoReflectionTypeBuilder *tb;\n\t\tMonoClass *klass;\n\n\t\tmb = (MonoReflectionMethodBuilder *) rmethod;\n\t\ttb = (MonoReflectionTypeBuilder *) mb->type;\n\t\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\n\t\tmethod = methodbuilder_to_mono_method (klass, mb);\n#else\n\t\tg_assert_not_reached ();\n\t\tmethod = NULL;\n#endif\n\t} else {\n\t\tmethod = rmethod->method;\n\t}\n\n\tklass = method->klass;\n\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tcount = mono_method_signature (method)->generic_param_count;\n\tif (count != mono_array_length (types))\n\t\treturn NULL;\n\n\ttype_argv = g_new0 (MonoType *, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionType *garg = mono_array_get (types, gpointer, i);\n\t\ttype_argv [i] = mono_reflection_type_get_handle (garg);\n\t}\n\tginst = mono_metadata_get_generic_inst (count, type_argv);\n\tg_free (type_argv);\n\n\ttmp_context.class_inst = klass->generic_class ? klass->generic_class->context.class_inst : NULL;\n\ttmp_context.method_inst = ginst;\n\n\tinflated = mono_class_inflate_generic_method (method, &tmp_context);\n\timethod = (MonoMethodInflated *) inflated;\n\n\t/*FIXME but I think this is no longer necessary*/\n\tif (method->klass->image->dynamic) {\n\t\tMonoDynamicImage *image = (MonoDynamicImage*)method->klass->image;\n\t\t/*\n\t\t * This table maps metadata structures representing inflated methods/fields\n\t\t * to the reflection objects representing their generic definitions.\n\t\t */\n\t\tmono_loader_lock ();\n\t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, rmethod);\n\t\tmono_loader_unlock ();\n\t}\n\t\n\treturn mono_method_get_object (mono_object_domain (rmethod), inflated, NULL);",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145232,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "MonoReflectionMethod*\nmono_reflection_bind_generic_method_parameters (MonoReflectionMethod *rmethod, MonoArray *types)\n{\n\tMonoClass *klass;\n\tMonoMethod *method, *inflated;\n\tMonoMethodInflated *imethod;\n\tMonoGenericContext tmp_context;\n\tMonoGenericInst *ginst;\n\tMonoType **type_argv;\n\tint count, i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\t/*FIXME but this no longer should happen*/\n\tif (!strcmp (rmethod->object.vtable->klass->name, \"MethodBuilder\")) {\n#ifndef DISABLE_REFLECTION_EMIT\n\t\tMonoReflectionMethodBuilder *mb = NULL;\n\t\tMonoReflectionTypeBuilder *tb;\n\t\tMonoClass *klass;\n\n\t\tmb = (MonoReflectionMethodBuilder *) rmethod;\n\t\ttb = (MonoReflectionTypeBuilder *) mb->type;\n\t\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\n\t\tmethod = methodbuilder_to_mono_method (klass, mb);\n#else\n\t\tg_assert_not_reached ();\n\t\tmethod = NULL;\n#endif\n\t} else {\n\t\tmethod = rmethod->method;\n\t}\n\n\tklass = method->klass;\n\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tcount = mono_method_signature (method)->generic_param_count;\n\tif (count != mono_array_length (types))\n\t\treturn NULL;\n\n\ttype_argv = g_new0 (MonoType *, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionType *garg = mono_array_get (types, gpointer, i);\n\t\ttype_argv [i] = mono_reflection_type_get_handle (garg);\n\t}\n\tginst = mono_metadata_get_generic_inst (count, type_argv);\n\tg_free (type_argv);\n\n\ttmp_context.class_inst = klass->generic_class ? klass->generic_class->context.class_inst : NULL;\n\ttmp_context.method_inst = ginst;\n\n\tinflated = mono_class_inflate_generic_method (method, &tmp_context);\n\timethod = (MonoMethodInflated *) inflated;\n\n\t/*FIXME but I think this is no longer necessary*/\n\tif (method->klass->image->dynamic) {\n\t\tMonoDynamicImage *image = (MonoDynamicImage*)method->klass->image;\n\t\t/*\n\t\t * This table maps metadata structures representing inflated methods/fields\n\t\t * to the reflection objects representing their generic definitions.\n\t\t */\n\t\tmono_loader_lock ();\n\t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, rmethod);\n\t\tmono_loader_unlock ();\n\t}\n\n\tif (!mono_verifier_is_method_valid_generic_instantiation (inflated))\n\t\tmono_raise_exception (mono_get_exception_argument (\"typeArguments\", \"Invalid generic arguments\"));\n\t\n\treturn mono_method_get_object (mono_object_domain (rmethod), inflated, NULL);",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145233,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "QPDFObjectHandle::parseInternal(PointerHolder<InputSource> input,\n                                std::string const& object_description,\n                                QPDFTokenizer& tokenizer, bool& empty,\n                                StringDecrypter* decrypter, QPDF* context,\n                                bool in_array, bool in_dictionary,\n                                bool content_stream)\n{\n    // This method must take care not to resolve any objects. Don't\n    // check the type of any object without first ensuring that it is\n    // a direct object. Otherwise, doing so may have the side effect\n    // of reading the object and changing the file pointer.\n\n    empty = false;\n    if (in_dictionary && in_array)\n    {\n\t// Although dictionaries and arrays arbitrarily nest, these\n\t// variables indicate what is at the top of the stack right\n\t// now, so they can, by definition, never both be true.\n\tthrow std::logic_error(\n\t    \"INTERNAL ERROR: parseInternal: in_dict && in_array\");\n    }\n\n    QPDFObjectHandle object;\n\n    qpdf_offset_t offset = input->tell();\n    std::vector<QPDFObjectHandle> olist;\n    bool done = false;\n    while (! done)\n    {\n\tobject = QPDFObjectHandle();\n\n\tQPDFTokenizer::Token token =\n            tokenizer.readToken(input, object_description);\n\n\tswitch (token.getType())\n\t{\n          case QPDFTokenizer::tt_eof:\n            if (content_stream)\n            {\n                // Return uninitialized object to indicate EOF\n                return object;\n            }\n            else\n            {\n                // When not in content stream mode, EOF is tt_bad and\n                // throws an exception before we get here.\n                throw std::logic_error(\n                    \"EOF received while not in content stream mode\");\n            }\n            break;\n\n\t  case QPDFTokenizer::tt_brace_open:\n\t  case QPDFTokenizer::tt_brace_close:\n\t    QTC::TC(\"qpdf\", \"QPDFObjectHandle bad brace\");\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \"treating unexpected brace token as null\"));\n            object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_close:\n\t    if (in_array)\n\t    {\n\t\tdone = true;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle bad array close\");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"treating unexpected array close token as null\"));\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_dict_close:\n\t    if (in_dictionary)\n\t    {\n\t\tdone = true;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle bad dictionary close\");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"unexpected dictionary close token\"));\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_open:\n\t    object = parseInternal(\n\t\tinput, object_description, tokenizer, empty,\n                decrypter, context, true, false, content_stream);\n\t    break;\n\n\t  case QPDFTokenizer::tt_dict_open:\n\t    object = parseInternal(\n\t\tinput, object_description, tokenizer, empty,\n                decrypter, context, false, true, content_stream);\n\t    break;\n\n\t  case QPDFTokenizer::tt_bool:\n\t    object = newBool((token.getValue() == \"true\"));\n\t    break;\n\n\t  case QPDFTokenizer::tt_null:\n\t    object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_integer:\n\t    object = newInteger(QUtil::string_to_ll(token.getValue().c_str()));\n\t    break;\n\n\t  case QPDFTokenizer::tt_real:\n\t    object = newReal(token.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_name:\n\t    object = newName(token.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_word:\n\t    {\n\t\tstd::string const& value = token.getValue();\n                if (content_stream)\n                {\n                    object = QPDFObjectHandle::newOperator(value);\n                }\n\t\telse if ((value == \"R\") && (in_array || in_dictionary) &&\n\t\t    (olist.size() >= 2) &&\n                    (! olist.at(olist.size() - 1).isIndirect()) &&\n\t\t    (olist.at(olist.size() - 1).isInteger()) &&\n                    (! olist.at(olist.size() - 2).isIndirect()) &&\n\t\t    (olist.at(olist.size() - 2).isInteger()))\n\t\t{\n                    if (context == 0)\n                    {\n                        QTC::TC(\"qpdf\", \"QPDFObjectHandle indirect without context\");\n                        throw std::logic_error(\n                            \"QPDFObjectHandle::parse called without context\"\n                            \" on an object with indirect references\");\n                    }\n\t\t    // Try to resolve indirect objects\n\t\t    object = newIndirect(\n\t\t\tcontext,\n\t\t\tolist.at(olist.size() - 2).getIntValue(),\n\t\t\tolist.at(olist.size() - 1).getIntValue());\n\t\t    olist.pop_back();\n\t\t    olist.pop_back();\n\t\t}\n\t\telse if ((value == \"endobj\") &&\n\t\t\t (! (in_array || in_dictionary)))\n\t\t{\n\t\t    // We just saw endobj without having read\n\t\t    // anything.  Treat this as a null and do not move\n\t\t    // the input source's offset.\n\t\t    object = newNull();\n\t\t    input->seek(input->getLastOffset(), SEEK_SET);\n                    empty = true;\n\t\t}\n\t\telse\n\t\t{\n                    QTC::TC(\"qpdf\", \"QPDFObjectHandle treat word as string\");\n                    warn(context,\n                         QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                                 object_description,\n                                 input->getLastOffset(),\n                                 \"unknown token while reading object;\"\n                                 \" treating as string\"));\n                    object = newString(value);\n\t\t}\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_string:\n\t    {\n\t\tstd::string val = token.getValue();\n                if (decrypter)\n                {\n                    decrypter->decryptString(val);\n                }\n\t\tobject = QPDFObjectHandle::newString(val);\n\t    }\n\n\t    break;\n\n\t  default:\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \"treating unknown token type as null while \"\n                         \"reading object\"));\n            object = newNull();\n\t    break;\n\t}\n\n\tif (in_dictionary || in_array)\n\t{\n\t    if (! done)\n\t    {\n\t\tolist.push_back(object);\n\t    }\n\t}\n\telse if (! object.isInitialized())\n\t{\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \"parse error while reading object\"));\n            object = newNull();\n\t}\n\telse\n\t{\n\t    done = true;\n\t}\n    }\n\n    if (in_array)\n    {\n\tobject = newArray(olist);\n    }\n    else if (in_dictionary)\n    {\n        // Convert list to map. Alternating elements are keys. Attempt\n        // to recover more or less gracefully from invalid\n        // dictionaries.\n        std::set<std::string> names;\n        for (std::vector<QPDFObjectHandle>::iterator iter = olist.begin();\n             iter != olist.end(); ++iter)\n        {\n            if ((! (*iter).isIndirect()) && (*iter).isName())\n            {\n                names.insert((*iter).getName());\n            }\n        }\n\n        std::map<std::string, QPDFObjectHandle> dict;\n        int next_fake_key = 1;\n        for (unsigned int i = 0; i < olist.size(); ++i)\n        {\n            QPDFObjectHandle key_obj = olist.at(i);\n            QPDFObjectHandle val;\n            if (key_obj.isIndirect() || (! key_obj.isName()))\n            {\n                bool found_fake = false;\n                std::string candidate;\n                while (! found_fake)\n                {\n                    candidate =\n                        \"/QPDFFake\" + QUtil::int_to_string(next_fake_key++);\n                    found_fake = (names.count(candidate) == 0);\n                    QTC::TC(\"qpdf\", \"QPDFObjectHandle found fake\",\n                            (found_fake ? 0 : 1));\n                }\n                warn(context,\n                     QPDFExc(\n                         qpdf_e_damaged_pdf,\n                         input->getName(), object_description, offset,\n                         \"expected dictionary key but found\"\n                         \" non-name object; inserting key \" +\n                         candidate));\n                val = key_obj;\n                key_obj = newName(candidate);\n            }\n            else if (i + 1 >= olist.size())\n            {\n                QTC::TC(\"qpdf\", \"QPDFObjectHandle no val for last key\");\n                warn(context,\n                     QPDFExc(\n                         qpdf_e_damaged_pdf,\n                         input->getName(), object_description, offset,\n                         \"dictionary ended prematurely; using null as value\"\n                         \" for last key\"));\n                val = newNull();\n            }\n            else\n            {\n                val = olist.at(++i);\n            }\n            dict[key_obj.getName()] = val;\n        }\n        object = newDictionary(dict);\n    }\n\n    return object;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145238,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "QPDFObjectHandle::parseInternal(PointerHolder<InputSource> input,\n                                std::string const& object_description,\n                                QPDFTokenizer& tokenizer, bool& empty,\n                                StringDecrypter* decrypter, QPDF* context,\n                                bool content_stream)\n{\n    // This method must take care not to resolve any objects. Don't\n    // check the type of any object without first ensuring that it is\n    // a direct object. Otherwise, doing so may have the side effect\n    // of reading the object and changing the file pointer.\n\n    empty = false;\n\n    QPDFObjectHandle object;\n\n    std::vector<std::vector<QPDFObjectHandle> > olist_stack;\n    olist_stack.push_back(std::vector<QPDFObjectHandle>());\n    enum state_e { st_top, st_start, st_stop, st_eof, st_dictionary, st_array };\n    std::vector<state_e> state_stack;\n    state_stack.push_back(st_top);\n    std::vector<qpdf_offset_t> offset_stack;\n    offset_stack.push_back(input->tell());\n    bool done = false;\n    while (! done)\n    {\n        std::vector<QPDFObjectHandle>& olist = olist_stack.back();\n        state_e state = state_stack.back();\n        qpdf_offset_t offset = offset_stack.back();\n\n\tobject = QPDFObjectHandle();\n\n\tQPDFTokenizer::Token token =\n            tokenizer.readToken(input, object_description);\n\n\tswitch (token.getType())\n\t{\n          case QPDFTokenizer::tt_eof:\n            if (content_stream)\n            {\n                state = st_eof;\n            }\n            else\n            {\n                // When not in content stream mode, EOF is tt_bad and\n                // throws an exception before we get here.\n                throw std::logic_error(\n                    \"EOF received while not in content stream mode\");\n            }\n            break;\n\n\t  case QPDFTokenizer::tt_brace_open:\n\t  case QPDFTokenizer::tt_brace_close:\n\t    QTC::TC(\"qpdf\", \"QPDFObjectHandle bad brace\");\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \"treating unexpected brace token as null\"));\n            object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_close:\n\t    if (state == st_array)\n\t    {\n                state = st_stop;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle bad array close\");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"treating unexpected array close token as null\"));\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_dict_close:\n\t    if (state == st_dictionary)\n\t    {\n                state = st_stop;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle bad dictionary close\");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"unexpected dictionary close token\"));\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_open:\n\t  case QPDFTokenizer::tt_dict_open:\n            olist_stack.push_back(std::vector<QPDFObjectHandle>());\n            state = st_start;\n            offset_stack.push_back(input->tell());\n            state_stack.push_back(\n                (token.getType() == QPDFTokenizer::tt_array_open) ?\n                st_array : st_dictionary);\n\t    break;\n\n\t  case QPDFTokenizer::tt_bool:\n\t    object = newBool((token.getValue() == \"true\"));\n\t    break;\n\n\t  case QPDFTokenizer::tt_null:\n\t    object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_integer:\n\t    object = newInteger(QUtil::string_to_ll(token.getValue().c_str()));\n\t    break;\n\n\t  case QPDFTokenizer::tt_real:\n\t    object = newReal(token.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_name:\n\t    object = newName(token.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_word:\n\t    {\n\t\tstd::string const& value = token.getValue();\n                if (content_stream)\n                {\n                    object = QPDFObjectHandle::newOperator(value);\n                }\n\t\telse if ((value == \"R\") && (state != st_top) &&\n                         (olist.size() >= 2) &&\n                         (! olist.at(olist.size() - 1).isIndirect()) &&\n                         (olist.at(olist.size() - 1).isInteger()) &&\n                         (! olist.at(olist.size() - 2).isIndirect()) &&\n                         (olist.at(olist.size() - 2).isInteger()))\n\t\t{\n                    if (context == 0)\n                    {\n                        QTC::TC(\"qpdf\", \"QPDFObjectHandle indirect without context\");\n                        throw std::logic_error(\n                            \"QPDFObjectHandle::parse called without context\"\n                            \" on an object with indirect references\");\n                    }\n\t\t    // Try to resolve indirect objects\n\t\t    object = newIndirect(\n\t\t\tcontext,\n\t\t\tolist.at(olist.size() - 2).getIntValue(),\n\t\t\tolist.at(olist.size() - 1).getIntValue());\n\t\t    olist.pop_back();\n\t\t    olist.pop_back();\n\t\t}\n\t\telse if ((value == \"endobj\") && (state == st_top))\n\t\t{\n\t\t    // We just saw endobj without having read\n\t\t    // anything.  Treat this as a null and do not move\n\t\t    // the input source's offset.\n\t\t    object = newNull();\n\t\t    input->seek(input->getLastOffset(), SEEK_SET);\n                    empty = true;\n\t\t}\n\t\telse\n\t\t{\n                    QTC::TC(\"qpdf\", \"QPDFObjectHandle treat word as string\");\n                    warn(context,\n                         QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                                 object_description,\n                                 input->getLastOffset(),\n                                 \"unknown token while reading object;\"\n                                 \" treating as string\"));\n                    object = newString(value);\n\t\t}\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_string:\n\t    {\n\t\tstd::string val = token.getValue();\n                if (decrypter)\n                {\n                    decrypter->decryptString(val);\n                }\n\t\tobject = QPDFObjectHandle::newString(val);\n\t    }\n\n\t    break;\n\n\t  default:\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \"treating unknown token type as null while \"\n                         \"reading object\"));\n            object = newNull();\n\t    break;\n\t}\n\n        if ((! object.isInitialized()) &&\n            (! ((state == st_start) ||\n                (state == st_stop) ||\n                (state == st_eof))))\n        {\n            throw std::logic_error(\n                \"QPDFObjectHandle::parseInternal: \"\n                \"unexpected uninitialized object\");\n            object = newNull();\n        }\n\n        switch (state)\n        {\n          case st_eof:\n            if (state_stack.size() > 1)\n            {\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"parse error while reading object\"));\n            }\n            done = true;\n            // Leave object uninitialized to indicate EOF\n            break;\n\n          case st_dictionary:\n          case st_array:\n            olist.push_back(object);\n            break;\n\n          case st_top:\n            done = true;\n            break;\n\n          case st_start:\n            break;\n\n          case st_stop:\n            if ((state_stack.size() < 2) || (olist_stack.size() < 2))\n            {\n                throw std::logic_error(\n                    \"QPDFObjectHandle::parseInternal: st_stop encountered\"\n                    \" with insufficient elements in stack\");\n            }\n            state_e old_state = state_stack.back();\n            state_stack.pop_back();\n            if (old_state == st_array)\n            {\n                object = newArray(olist);\n            }\n            else if (old_state == st_dictionary)\n            {\n                // Convert list to map. Alternating elements are keys.\n                // Attempt to recover more or less gracefully from\n                // invalid dictionaries.\n                std::set<std::string> names;\n                for (std::vector<QPDFObjectHandle>::iterator iter =\n                         olist.begin();\n                     iter != olist.end(); ++iter)\n                {\n                    if ((! (*iter).isIndirect()) && (*iter).isName())\n                    {\n                        names.insert((*iter).getName());\n                    }\n                }\n\n                std::map<std::string, QPDFObjectHandle> dict;\n                int next_fake_key = 1;\n                for (unsigned int i = 0; i < olist.size(); ++i)\n                {\n                    QPDFObjectHandle key_obj = olist.at(i);\n                    QPDFObjectHandle val;\n                    if (key_obj.isIndirect() || (! key_obj.isName()))\n                    {\n                        bool found_fake = false;\n                        std::string candidate;\n                        while (! found_fake)\n                        {\n                            candidate =\n                                \"/QPDFFake\" +\n                                QUtil::int_to_string(next_fake_key++);\n                            found_fake = (names.count(candidate) == 0);\n                            QTC::TC(\"qpdf\", \"QPDFObjectHandle found fake\",\n                                    (found_fake ? 0 : 1));\n                        }\n                        warn(context,\n                             QPDFExc(\n                                 qpdf_e_damaged_pdf,\n                                 input->getName(), object_description, offset,\n                                 \"expected dictionary key but found\"\n                                 \" non-name object; inserting key \" +\n                                 candidate));\n                        val = key_obj;\n                        key_obj = newName(candidate);\n                    }\n                    else if (i + 1 >= olist.size())\n                    {\n                        QTC::TC(\"qpdf\", \"QPDFObjectHandle no val for last key\");\n                        warn(context,\n                             QPDFExc(\n                                 qpdf_e_damaged_pdf,\n                                 input->getName(), object_description, offset,\n                                 \"dictionary ended prematurely; \"\n                                 \"using null as value for last key\"));\n                        val = newNull();\n                    }\n                    else\n                    {\n                        val = olist.at(++i);\n                    }\n                    dict[key_obj.getName()] = val;\n                }\n                object = newDictionary(dict);\n            }\n            olist_stack.pop_back();\n            offset_stack.pop_back();\n            if (state_stack.back() == st_top)\n            {\n                done = true;\n            }\n            else\n            {\n                olist_stack.back().push_back(object);\n            }\n        }\n    }\n\n    return object;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145239,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void php_filter_validate_url(PHP_INPUT_FILTER_PARAM_DECL) /* {{{ */\n{\n\tphp_url *url;\n\tsize_t old_len = Z_STRLEN_P(value);\n\n\tif (flags & (FILTER_FLAG_SCHEME_REQUIRED | FILTER_FLAG_HOST_REQUIRED)) {\n\t\tphp_error_docref(NULL, E_DEPRECATED,\n\t\t\t\"explicit use of FILTER_FLAG_SCHEME_REQUIRED and FILTER_FLAG_HOST_REQUIRED is deprecated\");\n\t}\n\n\tphp_filter_url(value, flags, option_array, charset);\n\n\tif (Z_TYPE_P(value) != IS_STRING || old_len != Z_STRLEN_P(value)) {\n\t\tRETURN_VALIDATION_FAILED\n\t}\n\n\t/* Use parse_url - if it returns false, we return NULL */\n\turl = php_url_parse_ex(Z_STRVAL_P(value), Z_STRLEN_P(value));\n\n\tif (url == NULL) {\n\t\tRETURN_VALIDATION_FAILED\n\t}\n\n\tif (url->scheme != NULL &&\n\t\t(zend_string_equals_literal_ci(url->scheme, \"http\") || zend_string_equals_literal_ci(url->scheme, \"https\"))) {\n\t\tchar *e, *s, *t;\n\t\tsize_t l;\n\n\t\tif (url->host == NULL) {\n\t\t\tgoto bad_url;\n\t\t}\n\n\t\ts = ZSTR_VAL(url->host);\n\t\tl = ZSTR_LEN(url->host);\n\t\te = s + l;\n\t\tt = e - 1;\n\n\t\t/* An IPv6 enclosed by square brackets is a valid hostname */\n\t\tif (*s == '[' && *t == ']' && _php_filter_validate_ipv6((s + 1), l - 2)) {\n\t\t\tphp_url_free(url);\n\t\t\treturn;\n\t\t}\n\n\t\t// Validate domain\n\t\tif (!_php_filter_validate_domain(ZSTR_VAL(url->host), l, FILTER_FLAG_HOSTNAME)) {\n\t\t\tphp_url_free(url);\n\t\t\tRETURN_VALIDATION_FAILED\n\t\t}\n\t}\n\n\tif (\n\t\turl->scheme == NULL ||\n\t\t/* some schemas allow the host to be empty */\n\t\t(url->host == NULL && (strcmp(ZSTR_VAL(url->scheme), \"mailto\") && strcmp(ZSTR_VAL(url->scheme), \"news\") && strcmp(ZSTR_VAL(url->scheme), \"file\"))) ||\n\t\t((flags & FILTER_FLAG_PATH_REQUIRED) && url->path == NULL) || ((flags & FILTER_FLAG_QUERY_REQUIRED) && url->query == NULL)\n\t) {\nbad_url:\n\t\tphp_url_free(url);\n\t\tRETURN_VALIDATION_FAILED\n\t}\n\n\tif (url->user != NULL && !is_userinfo_valid(url->user)) {\n\t\tphp_url_free(url);\n\t\tRETURN_VALIDATION_FAILED\n\n\t}\n\n\tphp_url_free(url);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145264,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void php_filter_validate_url(PHP_INPUT_FILTER_PARAM_DECL) /* {{{ */\n{\n\tphp_url *url;\n\tsize_t old_len = Z_STRLEN_P(value);\n\n\tif (flags & (FILTER_FLAG_SCHEME_REQUIRED | FILTER_FLAG_HOST_REQUIRED)) {\n\t\tphp_error_docref(NULL, E_DEPRECATED,\n\t\t\t\"explicit use of FILTER_FLAG_SCHEME_REQUIRED and FILTER_FLAG_HOST_REQUIRED is deprecated\");\n\t}\n\n\tphp_filter_url(value, flags, option_array, charset);\n\n\tif (Z_TYPE_P(value) != IS_STRING || old_len != Z_STRLEN_P(value)) {\n\t\tRETURN_VALIDATION_FAILED\n\t}\n\n\t/* Use parse_url - if it returns false, we return NULL */\n\turl = php_url_parse_ex(Z_STRVAL_P(value), Z_STRLEN_P(value));\n\n\tif (url == NULL) {\n\t\tRETURN_VALIDATION_FAILED\n\t}\n\n\tif (url->scheme != NULL &&\n\t\t(zend_string_equals_literal_ci(url->scheme, \"http\") || zend_string_equals_literal_ci(url->scheme, \"https\"))) {\n\t\tchar *e, *s, *t;\n\t\tsize_t l;\n\n\t\tif (url->host == NULL) {\n\t\t\tgoto bad_url;\n\t\t}\n\n\t\ts = ZSTR_VAL(url->host);\n\t\tl = ZSTR_LEN(url->host);\n\t\te = s + l;\n\t\tt = e - 1;\n\n\t\t/* An IPv6 enclosed by square brackets is a valid hostname */\n\t\tif (*s == '[' && *t == ']' && _php_filter_validate_ipv6((s + 1), l - 2)) {\n\t\t\tphp_url_free(url);\n\t\t\treturn;\n\t\t}\n\n\t\t// Validate domain\n\t\tif (!_php_filter_validate_domain(ZSTR_VAL(url->host), l, FILTER_FLAG_HOSTNAME)) {\n\t\t\tphp_url_free(url);\n\t\t\tRETURN_VALIDATION_FAILED\n\t\t}\n\t}\n\n\tif (\n\t\turl->scheme == NULL ||\n\t\t/* some schemas allow the host to be empty */\n\t\t(url->host == NULL && (strcmp(ZSTR_VAL(url->scheme), \"mailto\") && strcmp(ZSTR_VAL(url->scheme), \"news\") && strcmp(ZSTR_VAL(url->scheme), \"file\"))) ||\n\t\t((flags & FILTER_FLAG_PATH_REQUIRED) && url->path == NULL) || ((flags & FILTER_FLAG_QUERY_REQUIRED) && url->query == NULL)\n\t) {\nbad_url:\n\t\tphp_url_free(url);\n\t\tRETURN_VALIDATION_FAILED\n\t}\n\n\tif (url->user != NULL && !is_userinfo_valid(url->user)\n\t\t|| url->pass != NULL && !is_userinfo_valid(url->pass)\n\t) {\n\t\tphp_url_free(url);\n\t\tRETURN_VALIDATION_FAILED\n\n\t}\n\n\tphp_url_free(url);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145265,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int make_http_soap_request(zval        *this_ptr,\n                           zend_string *buf,\n                           char        *location,\n                           char        *soapaction,\n                           int          soap_version,\n                           zval        *return_value)\n{\n\tzend_string *request;\n\tsmart_str soap_headers = {0};\n\tsmart_str soap_headers_z = {0};\n\tint err;\n\tphp_url *phpurl = NULL;\n\tphp_stream *stream;\n\tzval *trace, *tmp;\n\tint use_proxy = 0;\n\tint use_ssl;\n\tzend_string *http_body;\n\tchar *content_type, *http_version, *cookie_itt;\n\tint http_close;\n\tzend_string *http_headers;\n\tchar *connection;\n\tint http_1_1;\n\tint http_status;\n\tint content_type_xml = 0;\n\tzend_long redirect_max = 20;\n\tchar *content_encoding;\n\tchar *http_msg = NULL;\n\tzend_bool old_allow_url_fopen;\n\tphp_stream_context *context = NULL;\n\tzend_bool has_authorization = 0;\n\tzend_bool has_proxy_authorization = 0;\n\tzend_bool has_cookies = 0;\n\n\tif (this_ptr == NULL || Z_TYPE_P(this_ptr) != IS_OBJECT) {\n\t\treturn FALSE;\n\t}\n\n\trequest = buf;\n\t/* Compress request */\n\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"compression\", sizeof(\"compression\")-1)) != NULL && Z_TYPE_P(tmp) == IS_LONG) {\n\t\tint level = Z_LVAL_P(tmp) & 0x0f;\n\t\tint kind  = Z_LVAL_P(tmp) & SOAP_COMPRESSION_DEFLATE;\n\n\t\tif (level > 9) {level = 9;}\n\n\t  if ((Z_LVAL_P(tmp) & SOAP_COMPRESSION_ACCEPT) != 0) {\n\t\t\tsmart_str_append_const(&soap_headers_z,\"Accept-Encoding: gzip, deflate\\r\\n\");\n\t  }\n\t  if (level > 0) {\n\t\t\tzval func;\n\t\t\tzval retval;\n\t\t\tzval params[3];\n\t\t\tint n;\n\n\t\t\tZVAL_STR_COPY(&params[0], buf);\n\t\t\tZVAL_LONG(&params[1], level);\n\t\t\tif (kind == SOAP_COMPRESSION_DEFLATE) {\n\t\t\t\tn = 2;\n\t\t\t\tZVAL_STRING(&func, \"gzcompress\");\n\t\t\t\tsmart_str_append_const(&soap_headers_z,\"Content-Encoding: deflate\\r\\n\");\n\t\t\t} else {\n\t\t\t\tn = 3;\n\t\t\t\tZVAL_STRING(&func, \"gzencode\");\n\t\t\t\tsmart_str_append_const(&soap_headers_z,\"Content-Encoding: gzip\\r\\n\");\n\t\t\t\tZVAL_LONG(&params[2], 0x1f);\n\t\t\t}\n\t\t\tif (call_user_function(CG(function_table), (zval*)NULL, &func, &retval, n, params) == SUCCESS &&\n\t\t\t    Z_TYPE(retval) == IS_STRING) {\n\t\t\t\tzval_ptr_dtor(&params[0]);\n\t\t\t\tzval_ptr_dtor(&func);\n\t\t\t\trequest = Z_STR(retval);\n\t\t\t} else {\n\t\t\t\tzval_ptr_dtor(&params[0]);\n\t\t\t\tzval_ptr_dtor(&func);\n\t\t\t\tif (request != buf) {\n\t\t\t\t\tzend_string_release(request);\n\t\t\t\t}\n\t\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t  }\n\t}\n\n\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1)) != NULL) {\n\t\tphp_stream_from_zval_no_verify(stream,tmp);\n\t\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1)) != NULL && Z_TYPE_P(tmp) == IS_LONG) {\n\t\t\tuse_proxy = Z_LVAL_P(tmp);\n\t\t}\n\t} else {\n\t\tstream = NULL;\n\t}\n\n\tif (location != NULL && location[0] != '\\000') {\n\t\tphpurl = php_url_parse(location);\n\t}\n\n\tif (NULL != (tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr),\n\t\t\t\"_stream_context\", sizeof(\"_stream_context\")-1))) {\n\t\tcontext = php_stream_context_from_zval(tmp, 0);\n\t}\n\n\tif (context &&\n\t\t(tmp = php_stream_context_get_option(context, \"http\", \"max_redirects\")) != NULL) {\n\t\tif (Z_TYPE_P(tmp) != IS_STRING || !is_numeric_string(Z_STRVAL_P(tmp), Z_STRLEN_P(tmp), &redirect_max, NULL, 1)) {\n\t\t\tif (Z_TYPE_P(tmp) == IS_LONG)\n\t\t\t\tredirect_max = Z_LVAL_P(tmp);\n\t\t}\n\t}\n\ntry_again:\n\tif (phpurl == NULL || phpurl->host == NULL) {\n\t  if (phpurl != NULL) {php_url_free(phpurl);}\n\t\tif (request != buf) {\n\t\t\tzend_string_release(request);\n\t\t}\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Unable to parse URL\", NULL, NULL);\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\tuse_ssl = 0;\n\tif (phpurl->scheme != NULL && strcmp(phpurl->scheme, \"https\") == 0) {\n\t\tuse_ssl = 1;\n\t} else if (phpurl->scheme == NULL || strcmp(phpurl->scheme, \"http\") != 0) {\n\t\tphp_url_free(phpurl);\n\t\tif (request != buf) {\n\t\t\tzend_string_release(request);\n\t\t}\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Unknown protocol. Only http and https are allowed.\", NULL, NULL);\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tif (use_ssl && php_stream_locate_url_wrapper(\"https://\", NULL, STREAM_LOCATE_WRAPPERS_ONLY) == NULL) {\n\t\tphp_url_free(phpurl);\n\t\tif (request != buf) {\n\t\t\tzend_string_release(request);\n\t\t}\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"SSL support is not available in this build\", NULL, NULL);\n\t\tPG(allow_url_fopen) = old_allow_url_fopen;\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\tif (phpurl->port == 0) {\n\t\tphpurl->port = use_ssl ? 443 : 80;\n\t}\n\n\t/* Check if request to the same host */\n\tif (stream != NULL) {\n\t  php_url *orig;\n\t\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"httpurl\", sizeof(\"httpurl\")-1)) != NULL &&\n\t\t    (orig = (php_url *) zend_fetch_resource_ex(tmp, \"httpurl\", le_url)) != NULL &&\n\t\t    ((use_proxy && !use_ssl) ||\n\t\t     (((use_ssl && orig->scheme != NULL && strcmp(orig->scheme, \"https\") == 0) ||\n\t\t      (!use_ssl && orig->scheme == NULL) ||\n\t\t      (!use_ssl && strcmp(orig->scheme, \"https\") != 0)) &&\n\t\t     strcmp(orig->host, phpurl->host) == 0 &&\n\t\t     orig->port == phpurl->port))) {\n    } else {\n\t\t\tphp_stream_close(stream);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpurl\", sizeof(\"httpurl\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\t\tstream = NULL;\n\t\t\tuse_proxy = 0;\n    }\n\t}\n\n\t/* Check if keep-alive connection is still opened */\n\tif (stream != NULL && php_stream_eof(stream)) {\n\t\tphp_stream_close(stream);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpurl\", sizeof(\"httpurl\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\tstream = NULL;\n\t\tuse_proxy = 0;\n\t}\n\n\tif (!stream) {\n\t\tstream = http_connect(this_ptr, phpurl, use_ssl, context, &use_proxy);\n\t\tif (stream) {\n\t\t\tphp_stream_auto_cleanup(stream);\n\t\t\tadd_property_resource(this_ptr, \"httpsocket\", stream->res);\n\t\t\tGC_REFCOUNT(stream->res)++;\n\t\t\tadd_property_long(this_ptr, \"_use_proxy\", use_proxy);\n\t\t} else {\n\t\t\tphp_url_free(phpurl);\n\t\t\tif (request != buf) {\n\t\t\t\tzend_string_release(request);\n\t\t\t}\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Could not connect to host\", NULL, NULL);\n\t\t\tPG(allow_url_fopen) = old_allow_url_fopen;\n\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\tPG(allow_url_fopen) = old_allow_url_fopen;\n\n\tif (stream) {\n\t\tzval *cookies, *login, *password;\n\t\tzend_resource *ret = zend_register_resource(phpurl, le_url);\n\n\t\tadd_property_resource(this_ptr, \"httpurl\", ret);\n\t\tGC_REFCOUNT(ret)++;\n\t\t/*zend_list_addref(ret);*/\n\n\t\tif (context &&\n\t\t    (tmp = php_stream_context_get_option(context, \"http\", \"protocol_version\")) != NULL &&\n\t\t    Z_TYPE_P(tmp) == IS_DOUBLE &&\n\t\t    Z_DVAL_P(tmp) == 1.0) {\n\t\t\thttp_1_1 = 0;\n\t\t} else {\n\t\t\thttp_1_1 = 1;\n\t\t}\n\n\t\tsmart_str_append_const(&soap_headers, \"POST \");\n\t\tif (use_proxy && !use_ssl) {\n\t\t\tsmart_str_appends(&soap_headers, phpurl->scheme);\n\t\t\tsmart_str_append_const(&soap_headers, \"://\");\n\t\t\tsmart_str_appends(&soap_headers, phpurl->host);\n\t\t\tsmart_str_appendc(&soap_headers, ':');\n\t\t\tsmart_str_append_unsigned(&soap_headers, phpurl->port);\n\t\t}\n\t\tif (phpurl->path) {\n\t\t\tsmart_str_appends(&soap_headers, phpurl->path);\n\t\t} else {\n\t\t\tsmart_str_appendc(&soap_headers, '/');\n\t\t}\n\t\tif (phpurl->query) {\n\t\t\tsmart_str_appendc(&soap_headers, '?');\n\t\t\tsmart_str_appends(&soap_headers, phpurl->query);\n\t\t}\n\t\tif (phpurl->fragment) {\n\t\t\tsmart_str_appendc(&soap_headers, '#');\n\t\t\tsmart_str_appends(&soap_headers, phpurl->fragment);\n\t\t}\n\t\tif (http_1_1) {\n\t\t\tsmart_str_append_const(&soap_headers, \" HTTP/1.1\\r\\n\");\n\t\t} else {\n\t\t\tsmart_str_append_const(&soap_headers, \" HTTP/1.0\\r\\n\");\n\t\t}\n\t\tsmart_str_append_const(&soap_headers, \"Host: \");\n\t\tsmart_str_appends(&soap_headers, phpurl->host);\n\t\tif (phpurl->port != (use_ssl?443:80)) {\n\t\t\tsmart_str_appendc(&soap_headers, ':');\n\t\t\tsmart_str_append_unsigned(&soap_headers, phpurl->port);\n\t\t}\n\t\tif (!http_1_1 ||\n\t\t\t((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_keep_alive\", sizeof(\"_keep_alive\")-1)) != NULL &&\n\t\t\t (Z_TYPE_P(tmp) == IS_FALSE || (Z_TYPE_P(tmp) == IS_LONG && Z_LVAL_P(tmp) == 0)))) {\n\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\"\n\t\t\t\t\"Connection: close\\r\\n\");\n\t\t} else {\n\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\"\n\t\t\t\t\"Connection: Keep-Alive\\r\\n\");\n\t\t}\n\t\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_user_agent\", sizeof(\"_user_agent\")-1)) != NULL &&\n\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\tif (Z_STRLEN_P(tmp) > 0) {\n\t\t\t\tsmart_str_append_const(&soap_headers, \"User-Agent: \");\n\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t\t}\n\t\t} else if (context &&\n\t\t           (tmp = php_stream_context_get_option(context, \"http\", \"user_agent\")) != NULL &&\n\t\t           Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\tif (Z_STRLEN_P(tmp) > 0) {\n\t\t\t\tsmart_str_append_const(&soap_headers, \"User-Agent: \");\n\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t\t}\n\t\t} else if (FG(user_agent)) {\n\t\t\tsmart_str_append_const(&soap_headers, \"User-Agent: \");\n\t\t\tsmart_str_appends(&soap_headers, FG(user_agent));\n\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t} else {\n\t\t\tsmart_str_append_const(&soap_headers, \"User-Agent: PHP-SOAP/\"PHP_VERSION\"\\r\\n\");\n\t\t}\n\n\t\tsmart_str_append_smart_str(&soap_headers, &soap_headers_z);\n\n\t\tif (soap_version == SOAP_1_2) {\n\t\t\tsmart_str_append_const(&soap_headers,\"Content-Type: application/soap+xml; charset=utf-8\");\n\t\t\tif (soapaction) {\n\t\t\t\tsmart_str_append_const(&soap_headers,\"; action=\\\"\");\n\t\t\t\tsmart_str_appends(&soap_headers, soapaction);\n\t\t\t\tsmart_str_append_const(&soap_headers,\"\\\"\");\n\t\t\t}\n\t\t\tsmart_str_append_const(&soap_headers,\"\\r\\n\");\n\t\t} else {\n\t\t\tsmart_str_append_const(&soap_headers,\"Content-Type: text/xml; charset=utf-8\\r\\n\");\n\t\t\tif (soapaction) {\n\t\t\t\tsmart_str_append_const(&soap_headers, \"SOAPAction: \\\"\");\n\t\t\t\tsmart_str_appends(&soap_headers, soapaction);\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\"\\r\\n\");\n\t\t\t}\n\t\t}\n\t\tsmart_str_append_const(&soap_headers,\"Content-Length: \");\n\t\tsmart_str_append_long(&soap_headers, request->len);\n\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\n\t\t/* HTTP Authentication */\n\t\tif ((login = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_login\", sizeof(\"_login\")-1)) != NULL &&\n\t\t    Z_TYPE_P(login) == IS_STRING) {\n\t\t\tzval *digest;\n\n\t\t\thas_authorization = 1;\n\t\t\tif ((digest = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_digest\", sizeof(\"_digest\")-1)) != NULL) {\n\t\t\t\tif (Z_TYPE_P(digest) == IS_ARRAY) {\n\t\t\t\t\tchar          HA1[33], HA2[33], response[33], cnonce[33], nc[9];\n\t\t\t\t\tPHP_MD5_CTX   md5ctx;\n\t\t\t\t\tunsigned char hash[16];\n\n\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\tsnprintf(cnonce, sizeof(cnonce), ZEND_LONG_FMT, php_rand());\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)cnonce, strlen(cnonce));\n\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\tmake_digest(cnonce, hash);\n\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"nc\", sizeof(\"nc\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_LONG) {\n\t\t\t\t\t\tZ_LVAL_P(tmp)++;\n\t\t\t\t\t\tsnprintf(nc, sizeof(nc), \"%08ld\", Z_LVAL_P(tmp));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tadd_assoc_long(digest, \"nc\", 1);\n\t\t\t\t\t\tstrcpy(nc, \"00000001\");\n\t\t\t\t\t}\n\n\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(login), Z_STRLEN_P(login));\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"realm\", sizeof(\"realm\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\tif ((password = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_password\", sizeof(\"_password\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(password) == IS_STRING) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(password), Z_STRLEN_P(password));\n\t\t\t\t\t}\n\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\tmake_digest(HA1, hash);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"algorithm\", sizeof(\"algorithm\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING &&\n\t\t\t\t\t    Z_STRLEN_P(tmp) == sizeof(\"md5-sess\")-1 &&\n\t\t\t\t\t    stricmp(Z_STRVAL_P(tmp), \"md5-sess\") == 0) {\n\t\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)HA1, 32);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"nonce\", sizeof(\"nonce\")-1)) != NULL &&\n\t\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)cnonce, 8);\n\t\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\t\tmake_digest(HA1, hash);\n\t\t\t\t\t}\n\n\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\"POST:\", sizeof(\"POST:\")-1);\n\t\t\t\t\tif (phpurl->path) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)phpurl->path, strlen(phpurl->path));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\"/\", 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (phpurl->query) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\"?\", 1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)phpurl->query, strlen(phpurl->query));\n\t\t\t\t\t}\n\n\t\t\t\t\t/* TODO: Support for qop=\"auth-int\" */\n/*\n\t\t\t\t\tif (zend_hash_find(Z_ARRVAL_PP(digest), \"qop\", sizeof(\"qop\"), (void **)&tmp) == SUCCESS &&\n\t\t\t\t\t    Z_TYPE_PP(tmp) == IS_STRING &&\n\t\t\t\t\t    Z_STRLEN_PP(tmp) == sizeof(\"auth-int\")-1 &&\n\t\t\t\t\t    stricmp(Z_STRVAL_PP(tmp), \"auth-int\") == 0) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, \":\", 1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, HEntity, HASHHEXLEN);\n\t\t\t\t\t}\n*/\n\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\tmake_digest(HA2, hash);\n\n\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)HA1, 32);\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"nonce\", sizeof(\"nonce\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"qop\", sizeof(\"qop\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)nc, 8);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)cnonce, 8);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t\t/* TODO: Support for qop=\"auth-int\" */\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\"auth\", sizeof(\"auth\")-1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t}\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)HA2, 32);\n\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\tmake_digest(response, hash);\n\n\t\t\t\t\tsmart_str_append_const(&soap_headers, \"Authorization: Digest username=\\\"\");\n\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(login), Z_STRLEN_P(login));\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"realm\", sizeof(\"realm\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", realm=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"nonce\", sizeof(\"nonce\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", nonce=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", uri=\\\"\");\n\t\t\t\t\tif (phpurl->path) {\n\t\t\t\t\t\tsmart_str_appends(&soap_headers, phpurl->path);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsmart_str_appendc(&soap_headers, '/');\n\t\t\t\t\t}\n\t\t\t\t\tif (phpurl->query) {\n\t\t\t\t\t\tsmart_str_appendc(&soap_headers, '?');\n\t\t\t\t\t\tsmart_str_appends(&soap_headers, phpurl->query);\n\t\t\t\t\t}\n\t\t\t\t\tif (phpurl->fragment) {\n\t\t\t\t\t\tsmart_str_appendc(&soap_headers, '#');\n\t\t\t\t\t\tsmart_str_appends(&soap_headers, phpurl->fragment);\n\t\t\t\t\t}\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"qop\", sizeof(\"qop\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t/* TODO: Support for qop=\"auth-int\" */\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", qop=\\\"auth\");\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", nc=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, nc, 8);\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", cnonce=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, cnonce, 8);\n\t\t\t\t\t}\n\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", response=\\\"\");\n\t\t\t\t\tsmart_str_appendl(&soap_headers, response, 32);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"opaque\", sizeof(\"opaque\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", opaque=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"algorithm\", sizeof(\"algorithm\")-1)) != NULL &&\n\t\t\t\t\t\tZ_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", algorithm=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\"\\r\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tzend_string *buf;\n\n\t\t\t\tsmart_str auth = {0};\n\t\t\t\tsmart_str_appendl(&auth, Z_STRVAL_P(login), Z_STRLEN_P(login));\n\t\t\t\tsmart_str_appendc(&auth, ':');\n\t\t\t\tif ((password = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_password\", sizeof(\"_password\")-1)) != NULL &&\n\t\t\t\t    Z_TYPE_P(password) == IS_STRING) {\n\t\t\t\t\tsmart_str_appendl(&auth, Z_STRVAL_P(password), Z_STRLEN_P(password));\n\t\t\t\t}\n\t\t\t\tsmart_str_0(&auth);\n\t\t\t\tbuf = php_base64_encode((unsigned char*)ZSTR_VAL(auth.s), ZSTR_LEN(auth.s));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"Authorization: Basic \");\n\t\t\t\tsmart_str_appendl(&soap_headers, (char*)ZSTR_VAL(buf), ZSTR_LEN(buf));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t\t\tzend_string_release(buf);\n\t\t\t\tsmart_str_free(&auth);\n\t\t\t}\n\t\t}\n\n\t\t/* Proxy HTTP Authentication */\n\t\tif (use_proxy && !use_ssl) {\n\t\t\thas_proxy_authorization = proxy_authentication(this_ptr, &soap_headers);\n\t\t}\n\n\t\t/* Send cookies along with request */\n\t\tif ((cookies = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_cookies\", sizeof(\"_cookies\")-1)) != NULL &&\n\t\t    Z_TYPE_P(cookies) == IS_ARRAY) {\n\t\t\tzval *data;\n\t\t\tzend_string *key;\n\t\t\tint i, n;\n\n\t\t\thas_cookies = 1;\n\t\t\tn = zend_hash_num_elements(Z_ARRVAL_P(cookies));\n\t\t\tif (n > 0) {\n\t\t\t\tzend_hash_internal_pointer_reset(Z_ARRVAL_P(cookies));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"Cookie: \");\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tzend_ulong numindx;\n\t\t\t\t\tint res = zend_hash_get_current_key(Z_ARRVAL_P(cookies), &key, &numindx);\n\t\t\t\t\tdata = zend_hash_get_current_data(Z_ARRVAL_P(cookies));\n\t\t\t\t\t\n\t\t\t\t\tif (res == HASH_KEY_IS_STRING && Z_TYPE_P(data) == IS_ARRAY) {\n\t\t\t\t\t  zval *value;\n\n\t\t\t\t\t\tif ((value = zend_hash_index_find(Z_ARRVAL_P(data), 0)) != NULL &&\n\t\t\t\t\t\t    Z_TYPE_P(value) == IS_STRING) {\n\t\t\t\t\t\t  zval *tmp;\n\t\t\t\t\t\t  if (((tmp = zend_hash_index_find(Z_ARRVAL_P(data), 1)) == NULL ||\n\t\t\t\t\t\t       strncmp(phpurl->path?phpurl->path:\"/\",Z_STRVAL_P(tmp),Z_STRLEN_P(tmp)) == 0) &&\n\t\t\t\t\t\t      ((tmp = zend_hash_index_find(Z_ARRVAL_P(data), 2)) == NULL ||\n\t\t\t\t\t\t       in_domain(phpurl->host,Z_STRVAL_P(tmp))) &&\n\t\t\t\t\t\t      (use_ssl || (tmp = zend_hash_index_find(Z_ARRVAL_P(data), 3)) == NULL)) {\n\t\t\t\t\t\t\t\tsmart_str_append(&soap_headers, key);\n\t\t\t\t\t\t\t\tsmart_str_appendc(&soap_headers, '=');\n\t\t\t\t\t\t\t\tsmart_str_append(&soap_headers, Z_STR_P(value));\n\t\t\t\t\t\t\t\tsmart_str_appendc(&soap_headers, ';');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_move_forward(Z_ARRVAL_P(cookies));\n\t\t\t\t}\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t\t}\n\t\t}\n\n\t\thttp_context_headers(context, has_authorization, has_proxy_authorization, has_cookies, &soap_headers);\n\n\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\tsmart_str_0(&soap_headers);\n\t\tif ((trace = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"trace\", sizeof(\"trace\")-1)) != NULL &&\n\t\t    (Z_TYPE_P(trace) == IS_TRUE || (Z_TYPE_P(trace) == IS_LONG && Z_LVAL_P(trace) != 0))) {\n\t\t\tadd_property_stringl(this_ptr, \"__last_request_headers\", ZSTR_VAL(soap_headers.s), ZSTR_LEN(soap_headers.s));\n\t\t}\n\t\tsmart_str_appendl(&soap_headers, request->val, request->len);\n\t\tsmart_str_0(&soap_headers);\n\n\t\terr = php_stream_write(stream, ZSTR_VAL(soap_headers.s), ZSTR_LEN(soap_headers.s));\n\t\tif (err != ZSTR_LEN(soap_headers.s)) {\n\t\t\tif (request != buf) {\n\t\t\t\tzend_string_release(request);\n\t\t\t}\n\t\t\tphp_stream_close(stream);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpurl\", sizeof(\"httpurl\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Failed Sending HTTP SOAP request\", NULL, NULL);\n\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\treturn FALSE;\n\t\t}\n\t\tsmart_str_free(&soap_headers);\n\t} else {\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Failed to create stream??\", NULL, NULL);\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\tif (!return_value) {\n\t\tphp_stream_close(stream);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn TRUE;\n\t}\n\n\tdo {\n\t\thttp_headers = get_http_headers(stream);\n\t\tif (!http_headers) {\n\t\t\tif (request != buf) {\n\t\t\t\tzend_string_release(request);\n\t\t\t}\n\t\t\tphp_stream_close(stream);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Error Fetching http headers\", NULL, NULL);\n\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif ((trace = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"trace\", sizeof(\"trace\")-1)) != NULL &&\n\t\t    (Z_TYPE_P(trace) == IS_TRUE || (Z_TYPE_P(trace) == IS_LONG && Z_LVAL_P(trace) != 0))) {\n\t\t\tadd_property_str(this_ptr, \"__last_response_headers\", zend_string_copy(http_headers));\n\t\t}\n\n\t\t/* Check to see what HTTP status was sent */\n\t\thttp_1_1 = 0;\n\t\thttp_status = 0;\n\t\thttp_version = get_http_header_value(ZSTR_VAL(http_headers), \"HTTP/\");\n\t\tif (http_version) {\n\t\t\tchar *tmp;\n\n\t\t\tif (!strncmp(http_version,\"1.1\", 3)) {\n\t\t\t\thttp_1_1 = 1;\n\t\t\t}\n\n\t\t\ttmp = strstr(http_version,\" \");\n\t\t\tif (tmp != NULL) {\n\t\t\t\ttmp++;\n\t\t\t\thttp_status = atoi(tmp);\n\t\t\t}\n\t\t\ttmp = strstr(tmp,\" \");\n\t\t\tif (tmp != NULL) {\n\t\t\t\ttmp++;\n\t\t\t\tif (http_msg) {\n\t\t\t\t\tefree(http_msg);\n\t\t\t\t}\n\t\t\t\thttp_msg = estrdup(tmp);\n\t\t\t}\n\t\t\tefree(http_version);\n\n\t\t\t/* Try and get headers again */\n\t\t\tif (http_status == 100) {\n\t\t\t\tzend_string_release(http_headers);\n\t\t\t}\n\t\t}\n\t} while (http_status == 100);\n\n\t/* Grab and send back every cookie */\n\n\t/* Not going to worry about Path: because\n\t   we shouldn't be changing urls so path dont\n\t   matter too much\n\t*/\n\tcookie_itt = strstr(ZSTR_VAL(http_headers), \"Set-Cookie: \");\n\twhile (cookie_itt) {\n\t\tchar *cookie;\n\t\tchar *eqpos, *sempos;\n\t\tzval *cookies;\n\n\t\tif ((cookies = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_cookies\", sizeof(\"_cookies\")-1)) == NULL ||\n\t\t    Z_TYPE_P(cookies) != IS_ARRAY) {\n\t\t\tzval tmp_cookies;\n\t\t\tarray_init(&tmp_cookies);\n\t\t\tcookies = zend_hash_str_update(Z_OBJPROP_P(this_ptr), \"_cookies\", sizeof(\"_cookies\")-1, &tmp_cookies);\n\t\t}\n\n\t\tcookie = get_http_header_value(cookie_itt,\"Set-Cookie: \");\n\n\t\teqpos = strstr(cookie, \"=\");\n\t\tsempos = strstr(cookie, \";\");\n\t\tif (eqpos != NULL && (sempos == NULL || sempos > eqpos)) {\n\t\t\tsmart_str name = {0};\n\t\t\tint cookie_len;\n\t\t\tzval zcookie;\n\n\t\t\tif (sempos != NULL) {\n\t\t\t\tcookie_len = sempos-(eqpos+1);\n\t\t\t} else {\n\t\t\t\tcookie_len = strlen(cookie)-(eqpos-cookie)-1;\n\t\t\t}\n\n\t\t\tsmart_str_appendl(&name, cookie, eqpos - cookie);\n\t\t\tsmart_str_0(&name);\n\n\t\t\tarray_init(&zcookie);\n\t\t\tadd_index_stringl(&zcookie, 0, eqpos + 1, cookie_len);\n\n\t\t\tif (sempos != NULL) {\n\t\t\t\tchar *options = cookie + cookie_len+1;\n\t\t\t\twhile (*options) {\n\t\t\t\t\twhile (*options == ' ') {options++;}\n\t\t\t\t\tsempos = strstr(options, \";\");\n\t\t\t\t\tif (strstr(options,\"path=\") == options) {\n\t\t\t\t\t\teqpos = options + sizeof(\"path=\")-1;\n\t\t\t\t\t\tadd_index_stringl(&zcookie, 1, eqpos, sempos?(sempos-eqpos):strlen(eqpos));\n\t\t\t\t\t} else if (strstr(options,\"domain=\") == options) {\n\t\t\t\t\t\teqpos = options + sizeof(\"domain=\")-1;\n\t\t\t\t\t\tadd_index_stringl(&zcookie, 2, eqpos, sempos?(sempos-eqpos):strlen(eqpos));\n\t\t\t\t\t} else if (strstr(options,\"secure\") == options) {\n\t\t\t\t\t\tadd_index_bool(&zcookie, 3, 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (sempos != NULL) {\n\t\t\t\t\t\toptions = sempos+1;\n\t\t\t\t\t} else {\n\t\t\t\t\t  break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!zend_hash_index_exists(Z_ARRVAL(zcookie), 1)) {\n\t\t\t\tchar *t = phpurl->path?phpurl->path:\"/\";\n\t\t\t\tchar *c = strrchr(t, '/');\n\t\t\t\tif (c) {\n\t\t\t\t\tadd_index_stringl(&zcookie, 1, t, c-t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!zend_hash_index_exists(Z_ARRVAL(zcookie), 2)) {\n\t\t\t\tadd_index_string(&zcookie, 2, phpurl->host);\n\t\t\t}\n\n\t\t\tzend_symtable_update(Z_ARRVAL_P(cookies), name.s, &zcookie);\n\t\t\tsmart_str_free(&name);\n\t\t}\n\n\t\tcookie_itt = strstr(cookie_itt + sizeof(\"Set-Cookie: \"), \"Set-Cookie: \");\n\t\tefree(cookie);\n\t}\n\n\t/* See if the server requested a close */\n\tif (http_1_1) {\n\t\thttp_close = FALSE;\n\t\tif (use_proxy && !use_ssl) {\n\t\t\tconnection = get_http_header_value(ZSTR_VAL(http_headers), \"Proxy-Connection: \");\n\t\t\tif (connection) {\n\t\t\t\tif (strncasecmp(connection, \"close\", sizeof(\"close\")-1) == 0) {\n\t\t\t\t\thttp_close = TRUE;\n\t\t\t\t}\n\t\t\t\tefree(connection);\n\t\t\t}\n\t\t}\n\t\tif (http_close == FALSE) {\n\t\t\tconnection = get_http_header_value(ZSTR_VAL(http_headers), \"Connection: \");\n\t\t\tif (connection) {\n\t\t\t\tif (strncasecmp(connection, \"close\", sizeof(\"close\")-1) == 0) {\n\t\t\t\t\thttp_close = TRUE;\n\t\t\t\t}\n\t\t\t\tefree(connection);\n\t\t\t}\n\t\t}\n\t} else {\n\t\thttp_close = TRUE;\n\t\tif (use_proxy && !use_ssl) {\n\t\t\tconnection = get_http_header_value(ZSTR_VAL(http_headers), \"Proxy-Connection: \");\n\t\t\tif (connection) {\n\t\t\t\tif (strncasecmp(connection, \"Keep-Alive\", sizeof(\"Keep-Alive\")-1) == 0) {\n\t\t\t\t\thttp_close = FALSE;\n\t\t\t\t}\n\t\t\t\tefree(connection);\n\t\t\t}\n\t\t}\n\t\tif (http_close == TRUE) {\n\t\t\tconnection = get_http_header_value(ZSTR_VAL(http_headers), \"Connection: \");\n\t\t\tif (connection) {\n\t\t\t\tif (strncasecmp(connection, \"Keep-Alive\", sizeof(\"Keep-Alive\")-1) == 0) {\n\t\t\t\t\thttp_close = FALSE;\n\t\t\t\t}\n\t\t\t\tefree(connection);\n\t\t\t}\n\t\t}\n\t}\n\n\n\thttp_body = get_http_body(stream, http_close, ZSTR_VAL(http_headers));\n\tif (!http_body) {\n\t\tif (request != buf) {\n\t\t\tzend_string_release(request);\n\t\t}\n\t\tphp_stream_close(stream);\n\t\tzend_string_release(http_headers);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Error Fetching http body, No Content-Length, connection closed or chunked data\", NULL, NULL);\n\t\tif (http_msg) {\n\t\t\tefree(http_msg);\n\t\t}\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\tif (request != buf) {\n\t\tzend_string_release(request);\n\t}\n\n\tif (http_close) {\n\t\tphp_stream_close(stream);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\tstream = NULL;\n\t}\n\n\t/* Process HTTP status codes */\n\tif (http_status >= 300 && http_status < 400) {\n\t\tchar *loc;\n\n\t\tif ((loc = get_http_header_value(ZSTR_VAL(http_headers), \"Location: \")) != NULL) {\n\t\t\tphp_url *new_url  = php_url_parse(loc);\n\n\t\t\tif (new_url != NULL) {\n\t\t\t\tzend_string_release(http_headers);\n\t\t\t\tzend_string_release(http_body);\n\t\t\t\tefree(loc);\n\t\t\t\tif (new_url->scheme == NULL && new_url->path != NULL) {\n\t\t\t\t\tnew_url->scheme = phpurl->scheme ? estrdup(phpurl->scheme) : NULL;\n\t\t\t\t\tnew_url->host = phpurl->host ? estrdup(phpurl->host) : NULL;\n\t\t\t\t\tnew_url->port = phpurl->port;\n\t\t\t\t\tif (new_url->path && new_url->path[0] != '/') {\n\t\t\t\t\t\tif (phpurl->path) {\n\t\t\t\t\t\t\tchar *t = phpurl->path;\n\t\t\t\t\t\t\tchar *p = strrchr(t, '/');\n\t\t\t\t\t\t\tif (p) {\n\t\t\t\t\t\t\t\tchar *s = emalloc((p - t) + strlen(new_url->path) + 2);\n\t\t\t\t\t\t\t\tstrncpy(s, t, (p - t) + 1);\n\t\t\t\t\t\t\t\ts[(p - t) + 1] = 0;\n\t\t\t\t\t\t\t\tstrcat(s, new_url->path);\n\t\t\t\t\t\t\t\tefree(new_url->path);\n\t\t\t\t\t\t\t\tnew_url->path = s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchar *s = emalloc(strlen(new_url->path) + 2);\n\t\t\t\t\t\t\ts[0] = '/'; s[1] = 0;\n\t\t\t\t\t\t\tstrcat(s, new_url->path);\n\t\t\t\t\t\t\tefree(new_url->path);\n\t\t\t\t\t\t\tnew_url->path = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tphpurl = new_url;\n\n\t\t\t\tif (--redirect_max < 1) {\n\t\t\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Redirection limit reached, aborting\", NULL, NULL);\n\t\t\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t}\n\t} else if (http_status == 401) {\n\t\t/* Digest authentication */\n\t\tzval *digest, *login, *password;\n\t\tchar *auth = get_http_header_value(ZSTR_VAL(http_headers), \"WWW-Authenticate: \");\n\n\t\tif (auth &&\n\t\t\t\tstrstr(auth, \"Digest\") == auth &&\n\t\t    ((digest = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_digest\", sizeof(\"_digest\")-1)) == NULL ||\n\t\t     Z_TYPE_P(digest) != IS_ARRAY) &&\n\t\t    (login = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_login\", sizeof(\"_login\")-1)) != NULL &&\n\t\t    Z_TYPE_P(login) == IS_STRING &&\n\t\t    (password = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_password\", sizeof(\"_password\")-1)) != NULL &&\n\t\t    Z_TYPE_P(password) == IS_STRING) {\n\t\t\tchar *s;\n\t\t\tzval digest;\n\n\t\t\tZVAL_UNDEF(&digest);\n\t\t\ts = auth + sizeof(\"Digest\")-1;\n\t\t\twhile (*s != '\\0') {\n\t\t\t\tchar *name, *val;\n\t\t\t\twhile (*s == ' ') ++s;\n\t\t\t\tname = s;\n\t\t\t\twhile (*s != '\\0' && *s != '=') ++s;\n\t\t\t\tif (*s == '=') {\n\t\t\t\t\t*s = '\\0';\n\t\t\t\t\t++s;\n\t\t\t\t\tif (*s == '\"') {\n\t\t\t\t\t\t++s;\n\t\t\t\t\t\tval = s;\n\t\t\t\t\t\twhile (*s != '\\0' && *s != '\"') ++s;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tval = s;\n\t\t\t\t\t\twhile (*s != '\\0' && *s != ' ' && *s != ',') ++s;\n\t\t\t\t\t}\n\t\t\t\t\tif (*s != '\\0') {\n\t\t\t\t\t\tif (*s != ',') {\n\t\t\t\t\t\t\t*s = '\\0';\n\t\t\t\t\t\t\t++s;\n\t\t\t\t\t\t\twhile (*s != '\\0' && *s != ',') ++s;\n\t\t\t\t\t\t\tif (*s != '\\0') ++s;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t*s = '\\0';\n\t\t\t\t\t\t\t++s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Z_TYPE(digest) == IS_UNDEF) {\n\t\t\t\t\t\tarray_init(&digest);\n\t\t\t\t\t}\n\t\t\t\t\tadd_assoc_string(&digest, name, val);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Z_TYPE(digest) != IS_UNDEF) {\n\t\t\t\tphp_url *new_url  = emalloc(sizeof(php_url));\n\n\t\t\t\tZ_DELREF(digest);\n\t\t\t\tadd_property_zval_ex(this_ptr, \"_digest\", sizeof(\"_digest\")-1, &digest);\n\n\t\t\t\t*new_url = *phpurl;\n\t\t\t\tif (phpurl->scheme) phpurl->scheme = estrdup(phpurl->scheme);\n\t\t\t\tif (phpurl->user) phpurl->user = estrdup(phpurl->user);\n\t\t\t\tif (phpurl->pass) phpurl->pass = estrdup(phpurl->pass);\n\t\t\t\tif (phpurl->host) phpurl->host = estrdup(phpurl->host);\n\t\t\t\tif (phpurl->path) phpurl->path = estrdup(phpurl->path);\n\t\t\t\tif (phpurl->query) phpurl->query = estrdup(phpurl->query);\n\t\t\t\tif (phpurl->fragment) phpurl->fragment = estrdup(phpurl->fragment);\n\t\t\t\tphpurl = new_url;\n\n\t\t\t\tefree(auth);\n\t\t\t\tzend_string_release(http_headers);\n\t\t\t\tzend_string_release(http_body);\n\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t}\n\t\tif (auth) efree(auth);\n\t}\n\tsmart_str_free(&soap_headers_z);\n\n\t/* Check and see if the server even sent a xml document */\n\tcontent_type = get_http_header_value(ZSTR_VAL(http_headers), \"Content-Type: \");\n\tif (content_type) {\n\t\tchar *pos = NULL;\n\t\tint cmplen;\n\t\tpos = strstr(content_type,\";\");\n\t\tif (pos != NULL) {\n\t\t\tcmplen = pos - content_type;\n\t\t} else {\n\t\t\tcmplen = strlen(content_type);\n\t\t}\n\t\tif (strncmp(content_type, \"text/xml\", cmplen) == 0 ||\n\t\t    strncmp(content_type, \"application/soap+xml\", cmplen) == 0) {\n\t\t\tcontent_type_xml = 1;\n/*\n\t\t\tif (strncmp(http_body, \"<?xml\", 5)) {\n\t\t\t\tzval *err;\n\t\t\t\tMAKE_STD_ZVAL(err);\n\t\t\t\tZVAL_STRINGL(err, http_body, http_body_size, 1);\n\t\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Didn't receive an xml document\", NULL, err);\n\t\t\t\tefree(content_type);\n\t\t\t\tzend_string_release(http_headers);\n\t\t\t\tefree(http_body);\n\t\t\t\treturn FALSE;\n\t\t\t}\n*/\n\t\t}\n\t\tefree(content_type);\n\t}\n\n\t/* Decompress response */\n\tcontent_encoding = get_http_header_value(ZSTR_VAL(http_headers), \"Content-Encoding: \");\n\tif (content_encoding) {\n\t\tzval func;\n\t\tzval retval;\n\t\tzval params[1];\n\n\t\tif ((strcmp(content_encoding,\"gzip\") == 0 ||\n\t\t     strcmp(content_encoding,\"x-gzip\") == 0) &&\n\t\t     zend_hash_str_exists(EG(function_table), \"gzinflate\", sizeof(\"gzinflate\")-1)) {\n\t\t\tZVAL_STRING(&func, \"gzinflate\");\n\t\t\tZVAL_STRINGL(&params[0], http_body->val+10, http_body->len-10);\n\t\t} else if (strcmp(content_encoding,\"deflate\") == 0 &&\n\t\t           zend_hash_str_exists(EG(function_table), \"gzuncompress\", sizeof(\"gzuncompress\")-1)) {\n\t\t\tZVAL_STRING(&func, \"gzuncompress\");\n\t\t\tZVAL_STR_COPY(&params[0], http_body);\n\t\t} else {\n\t\t\tefree(content_encoding);\n\t\t\tzend_string_release(http_headers);\n\t\t\tzend_string_release(http_body);\n\t\t\tif (http_msg) {\n\t\t\t\tefree(http_msg);\n\t\t\t}\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Unknown Content-Encoding\", NULL, NULL);\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (call_user_function(CG(function_table), (zval*)NULL, &func, &retval, 1, params) == SUCCESS &&\n\t\t    Z_TYPE(retval) == IS_STRING) {\n\t\t\tzval_ptr_dtor(&params[0]);\n\t\t\tzval_ptr_dtor(&func);\n\t\t\tzend_string_release(http_body);\n\t\t\tZVAL_COPY_VALUE(return_value, &retval);\n\t\t} else {\n\t\t\tzval_ptr_dtor(&params[0]);\n\t\t\tzval_ptr_dtor(&func);\n\t\t\tefree(content_encoding);\n\t\t\tzend_string_release(http_headers);\n\t\t\tzend_string_release(http_body);\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Can't uncompress compressed response\", NULL, NULL);\n\t\t\tif (http_msg) {\n\t\t\t\tefree(http_msg);\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\t\tefree(content_encoding);\n\t} else {\n\t\tZVAL_STR(return_value, http_body);\n\t}\n\n\tzend_string_release(http_headers);\n\n\tif (http_status >= 400) {\n\t\tint error = 0;\n\n\t\tif (Z_STRLEN_P(return_value) == 0) {\n\t\t\terror = 1;\n\t\t} else if (Z_STRLEN_P(return_value) > 0) {\n\t\t\tif (!content_type_xml) {\n\t\t\t\tchar *s = Z_STRVAL_P(return_value);\n\n\t\t\t\twhile (*s != '\\0' && *s < ' ') {\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t\tif (strncmp(s, \"<?xml\", 5)) {\n\t\t\t\t\terror = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (error) {\n\t\t\tzval_ptr_dtor(return_value);\n\t\t\tZVAL_UNDEF(return_value);\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", http_msg, NULL, NULL);\n\t\t\tefree(http_msg);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif (http_msg) {\n\t\tefree(http_msg);\n\t}\n\n\treturn TRUE;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145270,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int make_http_soap_request(zval        *this_ptr,\n                           zend_string *buf,\n                           char        *location,\n                           char        *soapaction,\n                           int          soap_version,\n                           zval        *return_value)\n{\n\tzend_string *request;\n\tsmart_str soap_headers = {0};\n\tsmart_str soap_headers_z = {0};\n\tint err;\n\tphp_url *phpurl = NULL;\n\tphp_stream *stream;\n\tzval *trace, *tmp;\n\tint use_proxy = 0;\n\tint use_ssl;\n\tzend_string *http_body;\n\tchar *content_type, *http_version, *cookie_itt;\n\tint http_close;\n\tzend_string *http_headers;\n\tchar *connection;\n\tint http_1_1;\n\tint http_status;\n\tint content_type_xml = 0;\n\tzend_long redirect_max = 20;\n\tchar *content_encoding;\n\tchar *http_msg = NULL;\n\tzend_bool old_allow_url_fopen;\n\tphp_stream_context *context = NULL;\n\tzend_bool has_authorization = 0;\n\tzend_bool has_proxy_authorization = 0;\n\tzend_bool has_cookies = 0;\n\n\tif (this_ptr == NULL || Z_TYPE_P(this_ptr) != IS_OBJECT) {\n\t\treturn FALSE;\n\t}\n\n\trequest = buf;\n\t/* Compress request */\n\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"compression\", sizeof(\"compression\")-1)) != NULL && Z_TYPE_P(tmp) == IS_LONG) {\n\t\tint level = Z_LVAL_P(tmp) & 0x0f;\n\t\tint kind  = Z_LVAL_P(tmp) & SOAP_COMPRESSION_DEFLATE;\n\n\t\tif (level > 9) {level = 9;}\n\n\t  if ((Z_LVAL_P(tmp) & SOAP_COMPRESSION_ACCEPT) != 0) {\n\t\t\tsmart_str_append_const(&soap_headers_z,\"Accept-Encoding: gzip, deflate\\r\\n\");\n\t  }\n\t  if (level > 0) {\n\t\t\tzval func;\n\t\t\tzval retval;\n\t\t\tzval params[3];\n\t\t\tint n;\n\n\t\t\tZVAL_STR_COPY(&params[0], buf);\n\t\t\tZVAL_LONG(&params[1], level);\n\t\t\tif (kind == SOAP_COMPRESSION_DEFLATE) {\n\t\t\t\tn = 2;\n\t\t\t\tZVAL_STRING(&func, \"gzcompress\");\n\t\t\t\tsmart_str_append_const(&soap_headers_z,\"Content-Encoding: deflate\\r\\n\");\n\t\t\t} else {\n\t\t\t\tn = 3;\n\t\t\t\tZVAL_STRING(&func, \"gzencode\");\n\t\t\t\tsmart_str_append_const(&soap_headers_z,\"Content-Encoding: gzip\\r\\n\");\n\t\t\t\tZVAL_LONG(&params[2], 0x1f);\n\t\t\t}\n\t\t\tif (call_user_function(CG(function_table), (zval*)NULL, &func, &retval, n, params) == SUCCESS &&\n\t\t\t    Z_TYPE(retval) == IS_STRING) {\n\t\t\t\tzval_ptr_dtor(&params[0]);\n\t\t\t\tzval_ptr_dtor(&func);\n\t\t\t\trequest = Z_STR(retval);\n\t\t\t} else {\n\t\t\t\tzval_ptr_dtor(&params[0]);\n\t\t\t\tzval_ptr_dtor(&func);\n\t\t\t\tif (request != buf) {\n\t\t\t\t\tzend_string_release(request);\n\t\t\t\t}\n\t\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t  }\n\t}\n\n\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1)) != NULL) {\n\t\tphp_stream_from_zval_no_verify(stream,tmp);\n\t\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1)) != NULL && Z_TYPE_P(tmp) == IS_LONG) {\n\t\t\tuse_proxy = Z_LVAL_P(tmp);\n\t\t}\n\t} else {\n\t\tstream = NULL;\n\t}\n\n\tif (location != NULL && location[0] != '\\000') {\n\t\tphpurl = php_url_parse(location);\n\t}\n\n\tif (NULL != (tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr),\n\t\t\t\"_stream_context\", sizeof(\"_stream_context\")-1))) {\n\t\tcontext = php_stream_context_from_zval(tmp, 0);\n\t}\n\n\tif (context &&\n\t\t(tmp = php_stream_context_get_option(context, \"http\", \"max_redirects\")) != NULL) {\n\t\tif (Z_TYPE_P(tmp) != IS_STRING || !is_numeric_string(Z_STRVAL_P(tmp), Z_STRLEN_P(tmp), &redirect_max, NULL, 1)) {\n\t\t\tif (Z_TYPE_P(tmp) == IS_LONG)\n\t\t\t\tredirect_max = Z_LVAL_P(tmp);\n\t\t}\n\t}\n\ntry_again:\n\tif (phpurl == NULL || phpurl->host == NULL) {\n\t  if (phpurl != NULL) {php_url_free(phpurl);}\n\t\tif (request != buf) {\n\t\t\tzend_string_release(request);\n\t\t}\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Unable to parse URL\", NULL, NULL);\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\tuse_ssl = 0;\n\tif (phpurl->scheme != NULL && strcmp(phpurl->scheme, \"https\") == 0) {\n\t\tuse_ssl = 1;\n\t} else if (phpurl->scheme == NULL || strcmp(phpurl->scheme, \"http\") != 0) {\n\t\tphp_url_free(phpurl);\n\t\tif (request != buf) {\n\t\t\tzend_string_release(request);\n\t\t}\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Unknown protocol. Only http and https are allowed.\", NULL, NULL);\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tif (use_ssl && php_stream_locate_url_wrapper(\"https://\", NULL, STREAM_LOCATE_WRAPPERS_ONLY) == NULL) {\n\t\tphp_url_free(phpurl);\n\t\tif (request != buf) {\n\t\t\tzend_string_release(request);\n\t\t}\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"SSL support is not available in this build\", NULL, NULL);\n\t\tPG(allow_url_fopen) = old_allow_url_fopen;\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\tif (phpurl->port == 0) {\n\t\tphpurl->port = use_ssl ? 443 : 80;\n\t}\n\n\t/* Check if request to the same host */\n\tif (stream != NULL) {\n\t  php_url *orig;\n\t\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"httpurl\", sizeof(\"httpurl\")-1)) != NULL &&\n\t\t    (orig = (php_url *) zend_fetch_resource_ex(tmp, \"httpurl\", le_url)) != NULL &&\n\t\t    ((use_proxy && !use_ssl) ||\n\t\t     (((use_ssl && orig->scheme != NULL && strcmp(orig->scheme, \"https\") == 0) ||\n\t\t      (!use_ssl && orig->scheme == NULL) ||\n\t\t      (!use_ssl && strcmp(orig->scheme, \"https\") != 0)) &&\n\t\t     strcmp(orig->host, phpurl->host) == 0 &&\n\t\t     orig->port == phpurl->port))) {\n    } else {\n\t\t\tphp_stream_close(stream);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpurl\", sizeof(\"httpurl\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\t\tstream = NULL;\n\t\t\tuse_proxy = 0;\n    }\n\t}\n\n\t/* Check if keep-alive connection is still opened */\n\tif (stream != NULL && php_stream_eof(stream)) {\n\t\tphp_stream_close(stream);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpurl\", sizeof(\"httpurl\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\tstream = NULL;\n\t\tuse_proxy = 0;\n\t}\n\n\tif (!stream) {\n\t\tstream = http_connect(this_ptr, phpurl, use_ssl, context, &use_proxy);\n\t\tif (stream) {\n\t\t\tphp_stream_auto_cleanup(stream);\n\t\t\tadd_property_resource(this_ptr, \"httpsocket\", stream->res);\n\t\t\tGC_REFCOUNT(stream->res)++;\n\t\t\tadd_property_long(this_ptr, \"_use_proxy\", use_proxy);\n\t\t} else {\n\t\t\tphp_url_free(phpurl);\n\t\t\tif (request != buf) {\n\t\t\t\tzend_string_release(request);\n\t\t\t}\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Could not connect to host\", NULL, NULL);\n\t\t\tPG(allow_url_fopen) = old_allow_url_fopen;\n\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\tPG(allow_url_fopen) = old_allow_url_fopen;\n\n\tif (stream) {\n\t\tzval *cookies, *login, *password;\n\t\tzend_resource *ret = zend_register_resource(phpurl, le_url);\n\n\t\tadd_property_resource(this_ptr, \"httpurl\", ret);\n\t\tGC_REFCOUNT(ret)++;\n\t\t/*zend_list_addref(ret);*/\n\n\t\tif (context &&\n\t\t    (tmp = php_stream_context_get_option(context, \"http\", \"protocol_version\")) != NULL &&\n\t\t    Z_TYPE_P(tmp) == IS_DOUBLE &&\n\t\t    Z_DVAL_P(tmp) == 1.0) {\n\t\t\thttp_1_1 = 0;\n\t\t} else {\n\t\t\thttp_1_1 = 1;\n\t\t}\n\n\t\tsmart_str_append_const(&soap_headers, \"POST \");\n\t\tif (use_proxy && !use_ssl) {\n\t\t\tsmart_str_appends(&soap_headers, phpurl->scheme);\n\t\t\tsmart_str_append_const(&soap_headers, \"://\");\n\t\t\tsmart_str_appends(&soap_headers, phpurl->host);\n\t\t\tsmart_str_appendc(&soap_headers, ':');\n\t\t\tsmart_str_append_unsigned(&soap_headers, phpurl->port);\n\t\t}\n\t\tif (phpurl->path) {\n\t\t\tsmart_str_appends(&soap_headers, phpurl->path);\n\t\t} else {\n\t\t\tsmart_str_appendc(&soap_headers, '/');\n\t\t}\n\t\tif (phpurl->query) {\n\t\t\tsmart_str_appendc(&soap_headers, '?');\n\t\t\tsmart_str_appends(&soap_headers, phpurl->query);\n\t\t}\n\t\tif (phpurl->fragment) {\n\t\t\tsmart_str_appendc(&soap_headers, '#');\n\t\t\tsmart_str_appends(&soap_headers, phpurl->fragment);\n\t\t}\n\t\tif (http_1_1) {\n\t\t\tsmart_str_append_const(&soap_headers, \" HTTP/1.1\\r\\n\");\n\t\t} else {\n\t\t\tsmart_str_append_const(&soap_headers, \" HTTP/1.0\\r\\n\");\n\t\t}\n\t\tsmart_str_append_const(&soap_headers, \"Host: \");\n\t\tsmart_str_appends(&soap_headers, phpurl->host);\n\t\tif (phpurl->port != (use_ssl?443:80)) {\n\t\t\tsmart_str_appendc(&soap_headers, ':');\n\t\t\tsmart_str_append_unsigned(&soap_headers, phpurl->port);\n\t\t}\n\t\tif (!http_1_1 ||\n\t\t\t((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_keep_alive\", sizeof(\"_keep_alive\")-1)) != NULL &&\n\t\t\t (Z_TYPE_P(tmp) == IS_FALSE || (Z_TYPE_P(tmp) == IS_LONG && Z_LVAL_P(tmp) == 0)))) {\n\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\"\n\t\t\t\t\"Connection: close\\r\\n\");\n\t\t} else {\n\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\"\n\t\t\t\t\"Connection: Keep-Alive\\r\\n\");\n\t\t}\n\t\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_user_agent\", sizeof(\"_user_agent\")-1)) != NULL &&\n\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\tif (Z_STRLEN_P(tmp) > 0) {\n\t\t\t\tsmart_str_append_const(&soap_headers, \"User-Agent: \");\n\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t\t}\n\t\t} else if (context &&\n\t\t           (tmp = php_stream_context_get_option(context, \"http\", \"user_agent\")) != NULL &&\n\t\t           Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\tif (Z_STRLEN_P(tmp) > 0) {\n\t\t\t\tsmart_str_append_const(&soap_headers, \"User-Agent: \");\n\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t\t}\n\t\t} else if (FG(user_agent)) {\n\t\t\tsmart_str_append_const(&soap_headers, \"User-Agent: \");\n\t\t\tsmart_str_appends(&soap_headers, FG(user_agent));\n\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t} else {\n\t\t\tsmart_str_append_const(&soap_headers, \"User-Agent: PHP-SOAP/\"PHP_VERSION\"\\r\\n\");\n\t\t}\n\n\t\tsmart_str_append_smart_str(&soap_headers, &soap_headers_z);\n\n\t\tif (soap_version == SOAP_1_2) {\n\t\t\tsmart_str_append_const(&soap_headers,\"Content-Type: application/soap+xml; charset=utf-8\");\n\t\t\tif (soapaction) {\n\t\t\t\tsmart_str_append_const(&soap_headers,\"; action=\\\"\");\n\t\t\t\tsmart_str_appends(&soap_headers, soapaction);\n\t\t\t\tsmart_str_append_const(&soap_headers,\"\\\"\");\n\t\t\t}\n\t\t\tsmart_str_append_const(&soap_headers,\"\\r\\n\");\n\t\t} else {\n\t\t\tsmart_str_append_const(&soap_headers,\"Content-Type: text/xml; charset=utf-8\\r\\n\");\n\t\t\tif (soapaction) {\n\t\t\t\tsmart_str_append_const(&soap_headers, \"SOAPAction: \\\"\");\n\t\t\t\tsmart_str_appends(&soap_headers, soapaction);\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\"\\r\\n\");\n\t\t\t}\n\t\t}\n\t\tsmart_str_append_const(&soap_headers,\"Content-Length: \");\n\t\tsmart_str_append_long(&soap_headers, request->len);\n\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\n\t\t/* HTTP Authentication */\n\t\tif ((login = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_login\", sizeof(\"_login\")-1)) != NULL &&\n\t\t    Z_TYPE_P(login) == IS_STRING) {\n\t\t\tzval *digest;\n\n\t\t\thas_authorization = 1;\n\t\t\tif ((digest = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_digest\", sizeof(\"_digest\")-1)) != NULL) {\n\t\t\t\tif (Z_TYPE_P(digest) == IS_ARRAY) {\n\t\t\t\t\tchar          HA1[33], HA2[33], response[33], cnonce[33], nc[9];\n\t\t\t\t\tPHP_MD5_CTX   md5ctx;\n\t\t\t\t\tunsigned char hash[16];\n\n\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\tsnprintf(cnonce, sizeof(cnonce), ZEND_LONG_FMT, php_rand());\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)cnonce, strlen(cnonce));\n\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\tmake_digest(cnonce, hash);\n\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"nc\", sizeof(\"nc\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_LONG) {\n\t\t\t\t\t\tZ_LVAL_P(tmp)++;\n\t\t\t\t\t\tsnprintf(nc, sizeof(nc), \"%08ld\", Z_LVAL_P(tmp));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tadd_assoc_long(digest, \"nc\", 1);\n\t\t\t\t\t\tstrcpy(nc, \"00000001\");\n\t\t\t\t\t}\n\n\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(login), Z_STRLEN_P(login));\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"realm\", sizeof(\"realm\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\tif ((password = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_password\", sizeof(\"_password\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(password) == IS_STRING) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(password), Z_STRLEN_P(password));\n\t\t\t\t\t}\n\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\tmake_digest(HA1, hash);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"algorithm\", sizeof(\"algorithm\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING &&\n\t\t\t\t\t    Z_STRLEN_P(tmp) == sizeof(\"md5-sess\")-1 &&\n\t\t\t\t\t    stricmp(Z_STRVAL_P(tmp), \"md5-sess\") == 0) {\n\t\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)HA1, 32);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"nonce\", sizeof(\"nonce\")-1)) != NULL &&\n\t\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)cnonce, 8);\n\t\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\t\tmake_digest(HA1, hash);\n\t\t\t\t\t}\n\n\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\"POST:\", sizeof(\"POST:\")-1);\n\t\t\t\t\tif (phpurl->path) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)phpurl->path, strlen(phpurl->path));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\"/\", 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (phpurl->query) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\"?\", 1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)phpurl->query, strlen(phpurl->query));\n\t\t\t\t\t}\n\n\t\t\t\t\t/* TODO: Support for qop=\"auth-int\" */\n/*\n\t\t\t\t\tif (zend_hash_find(Z_ARRVAL_PP(digest), \"qop\", sizeof(\"qop\"), (void **)&tmp) == SUCCESS &&\n\t\t\t\t\t    Z_TYPE_PP(tmp) == IS_STRING &&\n\t\t\t\t\t    Z_STRLEN_PP(tmp) == sizeof(\"auth-int\")-1 &&\n\t\t\t\t\t    stricmp(Z_STRVAL_PP(tmp), \"auth-int\") == 0) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, \":\", 1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, HEntity, HASHHEXLEN);\n\t\t\t\t\t}\n*/\n\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\tmake_digest(HA2, hash);\n\n\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)HA1, 32);\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"nonce\", sizeof(\"nonce\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"qop\", sizeof(\"qop\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)nc, 8);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)cnonce, 8);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t\t/* TODO: Support for qop=\"auth-int\" */\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\"auth\", sizeof(\"auth\")-1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t}\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)HA2, 32);\n\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\tmake_digest(response, hash);\n\n\t\t\t\t\tsmart_str_append_const(&soap_headers, \"Authorization: Digest username=\\\"\");\n\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(login), Z_STRLEN_P(login));\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"realm\", sizeof(\"realm\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", realm=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"nonce\", sizeof(\"nonce\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", nonce=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", uri=\\\"\");\n\t\t\t\t\tif (phpurl->path) {\n\t\t\t\t\t\tsmart_str_appends(&soap_headers, phpurl->path);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsmart_str_appendc(&soap_headers, '/');\n\t\t\t\t\t}\n\t\t\t\t\tif (phpurl->query) {\n\t\t\t\t\t\tsmart_str_appendc(&soap_headers, '?');\n\t\t\t\t\t\tsmart_str_appends(&soap_headers, phpurl->query);\n\t\t\t\t\t}\n\t\t\t\t\tif (phpurl->fragment) {\n\t\t\t\t\t\tsmart_str_appendc(&soap_headers, '#');\n\t\t\t\t\t\tsmart_str_appends(&soap_headers, phpurl->fragment);\n\t\t\t\t\t}\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"qop\", sizeof(\"qop\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t/* TODO: Support for qop=\"auth-int\" */\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", qop=\\\"auth\");\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", nc=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, nc, 8);\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", cnonce=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, cnonce, 8);\n\t\t\t\t\t}\n\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", response=\\\"\");\n\t\t\t\t\tsmart_str_appendl(&soap_headers, response, 32);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"opaque\", sizeof(\"opaque\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", opaque=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"algorithm\", sizeof(\"algorithm\")-1)) != NULL &&\n\t\t\t\t\t\tZ_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", algorithm=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\"\\r\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tzend_string *buf;\n\n\t\t\t\tsmart_str auth = {0};\n\t\t\t\tsmart_str_appendl(&auth, Z_STRVAL_P(login), Z_STRLEN_P(login));\n\t\t\t\tsmart_str_appendc(&auth, ':');\n\t\t\t\tif ((password = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_password\", sizeof(\"_password\")-1)) != NULL &&\n\t\t\t\t    Z_TYPE_P(password) == IS_STRING) {\n\t\t\t\t\tsmart_str_appendl(&auth, Z_STRVAL_P(password), Z_STRLEN_P(password));\n\t\t\t\t}\n\t\t\t\tsmart_str_0(&auth);\n\t\t\t\tbuf = php_base64_encode((unsigned char*)ZSTR_VAL(auth.s), ZSTR_LEN(auth.s));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"Authorization: Basic \");\n\t\t\t\tsmart_str_appendl(&soap_headers, (char*)ZSTR_VAL(buf), ZSTR_LEN(buf));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t\t\tzend_string_release(buf);\n\t\t\t\tsmart_str_free(&auth);\n\t\t\t}\n\t\t}\n\n\t\t/* Proxy HTTP Authentication */\n\t\tif (use_proxy && !use_ssl) {\n\t\t\thas_proxy_authorization = proxy_authentication(this_ptr, &soap_headers);\n\t\t}\n\n\t\t/* Send cookies along with request */\n\t\tif ((cookies = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_cookies\", sizeof(\"_cookies\")-1)) != NULL &&\n\t\t    Z_TYPE_P(cookies) == IS_ARRAY) {\n\t\t\tzval *data;\n\t\t\tzend_string *key;\n\t\t\tint i, n;\n\n\t\t\thas_cookies = 1;\n\t\t\tn = zend_hash_num_elements(Z_ARRVAL_P(cookies));\n\t\t\tif (n > 0) {\n\t\t\t\tzend_hash_internal_pointer_reset(Z_ARRVAL_P(cookies));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"Cookie: \");\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tzend_ulong numindx;\n\t\t\t\t\tint res = zend_hash_get_current_key(Z_ARRVAL_P(cookies), &key, &numindx);\n\t\t\t\t\tdata = zend_hash_get_current_data(Z_ARRVAL_P(cookies));\n\t\t\t\t\t\n\t\t\t\t\tif (res == HASH_KEY_IS_STRING && Z_TYPE_P(data) == IS_ARRAY) {\n\t\t\t\t\t  zval *value;\n\n\t\t\t\t\t\tif ((value = zend_hash_index_find(Z_ARRVAL_P(data), 0)) != NULL &&\n\t\t\t\t\t\t    Z_TYPE_P(value) == IS_STRING) {\n\t\t\t\t\t\t  zval *tmp;\n\t\t\t\t\t\t  if (((tmp = zend_hash_index_find(Z_ARRVAL_P(data), 1)) == NULL ||\n\t\t\t\t\t\t\t   Z_TYPE_P(tmp) != IS_STRING ||\n\t\t\t\t\t\t       strncmp(phpurl->path?phpurl->path:\"/\",Z_STRVAL_P(tmp),Z_STRLEN_P(tmp)) == 0) &&\n\t\t\t\t\t\t      ((tmp = zend_hash_index_find(Z_ARRVAL_P(data), 2)) == NULL ||\n\t\t\t\t\t\t\t   Z_TYPE_P(tmp) != IS_STRING ||\n\t\t\t\t\t\t       in_domain(phpurl->host,Z_STRVAL_P(tmp))) &&\n\t\t\t\t\t\t      (use_ssl || (tmp = zend_hash_index_find(Z_ARRVAL_P(data), 3)) == NULL)) {\n\t\t\t\t\t\t\t\tsmart_str_append(&soap_headers, key);\n\t\t\t\t\t\t\t\tsmart_str_appendc(&soap_headers, '=');\n\t\t\t\t\t\t\t\tsmart_str_append(&soap_headers, Z_STR_P(value));\n\t\t\t\t\t\t\t\tsmart_str_appendc(&soap_headers, ';');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_move_forward(Z_ARRVAL_P(cookies));\n\t\t\t\t}\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t\t}\n\t\t}\n\n\t\thttp_context_headers(context, has_authorization, has_proxy_authorization, has_cookies, &soap_headers);\n\n\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\tsmart_str_0(&soap_headers);\n\t\tif ((trace = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"trace\", sizeof(\"trace\")-1)) != NULL &&\n\t\t    (Z_TYPE_P(trace) == IS_TRUE || (Z_TYPE_P(trace) == IS_LONG && Z_LVAL_P(trace) != 0))) {\n\t\t\tadd_property_stringl(this_ptr, \"__last_request_headers\", ZSTR_VAL(soap_headers.s), ZSTR_LEN(soap_headers.s));\n\t\t}\n\t\tsmart_str_appendl(&soap_headers, request->val, request->len);\n\t\tsmart_str_0(&soap_headers);\n\n\t\terr = php_stream_write(stream, ZSTR_VAL(soap_headers.s), ZSTR_LEN(soap_headers.s));\n\t\tif (err != ZSTR_LEN(soap_headers.s)) {\n\t\t\tif (request != buf) {\n\t\t\t\tzend_string_release(request);\n\t\t\t}\n\t\t\tphp_stream_close(stream);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpurl\", sizeof(\"httpurl\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Failed Sending HTTP SOAP request\", NULL, NULL);\n\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\treturn FALSE;\n\t\t}\n\t\tsmart_str_free(&soap_headers);\n\t} else {\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Failed to create stream??\", NULL, NULL);\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\tif (!return_value) {\n\t\tphp_stream_close(stream);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn TRUE;\n\t}\n\n\tdo {\n\t\thttp_headers = get_http_headers(stream);\n\t\tif (!http_headers) {\n\t\t\tif (request != buf) {\n\t\t\t\tzend_string_release(request);\n\t\t\t}\n\t\t\tphp_stream_close(stream);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Error Fetching http headers\", NULL, NULL);\n\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif ((trace = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"trace\", sizeof(\"trace\")-1)) != NULL &&\n\t\t    (Z_TYPE_P(trace) == IS_TRUE || (Z_TYPE_P(trace) == IS_LONG && Z_LVAL_P(trace) != 0))) {\n\t\t\tadd_property_str(this_ptr, \"__last_response_headers\", zend_string_copy(http_headers));\n\t\t}\n\n\t\t/* Check to see what HTTP status was sent */\n\t\thttp_1_1 = 0;\n\t\thttp_status = 0;\n\t\thttp_version = get_http_header_value(ZSTR_VAL(http_headers), \"HTTP/\");\n\t\tif (http_version) {\n\t\t\tchar *tmp;\n\n\t\t\tif (!strncmp(http_version,\"1.1\", 3)) {\n\t\t\t\thttp_1_1 = 1;\n\t\t\t}\n\n\t\t\ttmp = strstr(http_version,\" \");\n\t\t\tif (tmp != NULL) {\n\t\t\t\ttmp++;\n\t\t\t\thttp_status = atoi(tmp);\n\t\t\t}\n\t\t\ttmp = strstr(tmp,\" \");\n\t\t\tif (tmp != NULL) {\n\t\t\t\ttmp++;\n\t\t\t\tif (http_msg) {\n\t\t\t\t\tefree(http_msg);\n\t\t\t\t}\n\t\t\t\thttp_msg = estrdup(tmp);\n\t\t\t}\n\t\t\tefree(http_version);\n\n\t\t\t/* Try and get headers again */\n\t\t\tif (http_status == 100) {\n\t\t\t\tzend_string_release(http_headers);\n\t\t\t}\n\t\t}\n\t} while (http_status == 100);\n\n\t/* Grab and send back every cookie */\n\n\t/* Not going to worry about Path: because\n\t   we shouldn't be changing urls so path dont\n\t   matter too much\n\t*/\n\tcookie_itt = strstr(ZSTR_VAL(http_headers), \"Set-Cookie: \");\n\twhile (cookie_itt) {\n\t\tchar *cookie;\n\t\tchar *eqpos, *sempos;\n\t\tzval *cookies;\n\n\t\tif ((cookies = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_cookies\", sizeof(\"_cookies\")-1)) == NULL ||\n\t\t    Z_TYPE_P(cookies) != IS_ARRAY) {\n\t\t\tzval tmp_cookies;\n\t\t\tarray_init(&tmp_cookies);\n\t\t\tcookies = zend_hash_str_update(Z_OBJPROP_P(this_ptr), \"_cookies\", sizeof(\"_cookies\")-1, &tmp_cookies);\n\t\t}\n\n\t\tcookie = get_http_header_value(cookie_itt,\"Set-Cookie: \");\n\n\t\teqpos = strstr(cookie, \"=\");\n\t\tsempos = strstr(cookie, \";\");\n\t\tif (eqpos != NULL && (sempos == NULL || sempos > eqpos)) {\n\t\t\tsmart_str name = {0};\n\t\t\tint cookie_len;\n\t\t\tzval zcookie;\n\n\t\t\tif (sempos != NULL) {\n\t\t\t\tcookie_len = sempos-(eqpos+1);\n\t\t\t} else {\n\t\t\t\tcookie_len = strlen(cookie)-(eqpos-cookie)-1;\n\t\t\t}\n\n\t\t\tsmart_str_appendl(&name, cookie, eqpos - cookie);\n\t\t\tsmart_str_0(&name);\n\n\t\t\tarray_init(&zcookie);\n\t\t\tadd_index_stringl(&zcookie, 0, eqpos + 1, cookie_len);\n\n\t\t\tif (sempos != NULL) {\n\t\t\t\tchar *options = cookie + cookie_len+1;\n\t\t\t\twhile (*options) {\n\t\t\t\t\twhile (*options == ' ') {options++;}\n\t\t\t\t\tsempos = strstr(options, \";\");\n\t\t\t\t\tif (strstr(options,\"path=\") == options) {\n\t\t\t\t\t\teqpos = options + sizeof(\"path=\")-1;\n\t\t\t\t\t\tadd_index_stringl(&zcookie, 1, eqpos, sempos?(sempos-eqpos):strlen(eqpos));\n\t\t\t\t\t} else if (strstr(options,\"domain=\") == options) {\n\t\t\t\t\t\teqpos = options + sizeof(\"domain=\")-1;\n\t\t\t\t\t\tadd_index_stringl(&zcookie, 2, eqpos, sempos?(sempos-eqpos):strlen(eqpos));\n\t\t\t\t\t} else if (strstr(options,\"secure\") == options) {\n\t\t\t\t\t\tadd_index_bool(&zcookie, 3, 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (sempos != NULL) {\n\t\t\t\t\t\toptions = sempos+1;\n\t\t\t\t\t} else {\n\t\t\t\t\t  break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!zend_hash_index_exists(Z_ARRVAL(zcookie), 1)) {\n\t\t\t\tchar *t = phpurl->path?phpurl->path:\"/\";\n\t\t\t\tchar *c = strrchr(t, '/');\n\t\t\t\tif (c) {\n\t\t\t\t\tadd_index_stringl(&zcookie, 1, t, c-t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!zend_hash_index_exists(Z_ARRVAL(zcookie), 2)) {\n\t\t\t\tadd_index_string(&zcookie, 2, phpurl->host);\n\t\t\t}\n\n\t\t\tzend_symtable_update(Z_ARRVAL_P(cookies), name.s, &zcookie);\n\t\t\tsmart_str_free(&name);\n\t\t}\n\n\t\tcookie_itt = strstr(cookie_itt + sizeof(\"Set-Cookie: \"), \"Set-Cookie: \");\n\t\tefree(cookie);\n\t}\n\n\t/* See if the server requested a close */\n\tif (http_1_1) {\n\t\thttp_close = FALSE;\n\t\tif (use_proxy && !use_ssl) {\n\t\t\tconnection = get_http_header_value(ZSTR_VAL(http_headers), \"Proxy-Connection: \");\n\t\t\tif (connection) {\n\t\t\t\tif (strncasecmp(connection, \"close\", sizeof(\"close\")-1) == 0) {\n\t\t\t\t\thttp_close = TRUE;\n\t\t\t\t}\n\t\t\t\tefree(connection);\n\t\t\t}\n\t\t}\n\t\tif (http_close == FALSE) {\n\t\t\tconnection = get_http_header_value(ZSTR_VAL(http_headers), \"Connection: \");\n\t\t\tif (connection) {\n\t\t\t\tif (strncasecmp(connection, \"close\", sizeof(\"close\")-1) == 0) {\n\t\t\t\t\thttp_close = TRUE;\n\t\t\t\t}\n\t\t\t\tefree(connection);\n\t\t\t}\n\t\t}\n\t} else {\n\t\thttp_close = TRUE;\n\t\tif (use_proxy && !use_ssl) {\n\t\t\tconnection = get_http_header_value(ZSTR_VAL(http_headers), \"Proxy-Connection: \");\n\t\t\tif (connection) {\n\t\t\t\tif (strncasecmp(connection, \"Keep-Alive\", sizeof(\"Keep-Alive\")-1) == 0) {\n\t\t\t\t\thttp_close = FALSE;\n\t\t\t\t}\n\t\t\t\tefree(connection);\n\t\t\t}\n\t\t}\n\t\tif (http_close == TRUE) {\n\t\t\tconnection = get_http_header_value(ZSTR_VAL(http_headers), \"Connection: \");\n\t\t\tif (connection) {\n\t\t\t\tif (strncasecmp(connection, \"Keep-Alive\", sizeof(\"Keep-Alive\")-1) == 0) {\n\t\t\t\t\thttp_close = FALSE;\n\t\t\t\t}\n\t\t\t\tefree(connection);\n\t\t\t}\n\t\t}\n\t}\n\n\n\thttp_body = get_http_body(stream, http_close, ZSTR_VAL(http_headers));\n\tif (!http_body) {\n\t\tif (request != buf) {\n\t\t\tzend_string_release(request);\n\t\t}\n\t\tphp_stream_close(stream);\n\t\tzend_string_release(http_headers);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Error Fetching http body, No Content-Length, connection closed or chunked data\", NULL, NULL);\n\t\tif (http_msg) {\n\t\t\tefree(http_msg);\n\t\t}\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\tif (request != buf) {\n\t\tzend_string_release(request);\n\t}\n\n\tif (http_close) {\n\t\tphp_stream_close(stream);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\tstream = NULL;\n\t}\n\n\t/* Process HTTP status codes */\n\tif (http_status >= 300 && http_status < 400) {\n\t\tchar *loc;\n\n\t\tif ((loc = get_http_header_value(ZSTR_VAL(http_headers), \"Location: \")) != NULL) {\n\t\t\tphp_url *new_url  = php_url_parse(loc);\n\n\t\t\tif (new_url != NULL) {\n\t\t\t\tzend_string_release(http_headers);\n\t\t\t\tzend_string_release(http_body);\n\t\t\t\tefree(loc);\n\t\t\t\tif (new_url->scheme == NULL && new_url->path != NULL) {\n\t\t\t\t\tnew_url->scheme = phpurl->scheme ? estrdup(phpurl->scheme) : NULL;\n\t\t\t\t\tnew_url->host = phpurl->host ? estrdup(phpurl->host) : NULL;\n\t\t\t\t\tnew_url->port = phpurl->port;\n\t\t\t\t\tif (new_url->path && new_url->path[0] != '/') {\n\t\t\t\t\t\tif (phpurl->path) {\n\t\t\t\t\t\t\tchar *t = phpurl->path;\n\t\t\t\t\t\t\tchar *p = strrchr(t, '/');\n\t\t\t\t\t\t\tif (p) {\n\t\t\t\t\t\t\t\tchar *s = emalloc((p - t) + strlen(new_url->path) + 2);\n\t\t\t\t\t\t\t\tstrncpy(s, t, (p - t) + 1);\n\t\t\t\t\t\t\t\ts[(p - t) + 1] = 0;\n\t\t\t\t\t\t\t\tstrcat(s, new_url->path);\n\t\t\t\t\t\t\t\tefree(new_url->path);\n\t\t\t\t\t\t\t\tnew_url->path = s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchar *s = emalloc(strlen(new_url->path) + 2);\n\t\t\t\t\t\t\ts[0] = '/'; s[1] = 0;\n\t\t\t\t\t\t\tstrcat(s, new_url->path);\n\t\t\t\t\t\t\tefree(new_url->path);\n\t\t\t\t\t\t\tnew_url->path = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tphpurl = new_url;\n\n\t\t\t\tif (--redirect_max < 1) {\n\t\t\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Redirection limit reached, aborting\", NULL, NULL);\n\t\t\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t}\n\t} else if (http_status == 401) {\n\t\t/* Digest authentication */\n\t\tzval *digest, *login, *password;\n\t\tchar *auth = get_http_header_value(ZSTR_VAL(http_headers), \"WWW-Authenticate: \");\n\n\t\tif (auth &&\n\t\t\t\tstrstr(auth, \"Digest\") == auth &&\n\t\t    ((digest = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_digest\", sizeof(\"_digest\")-1)) == NULL ||\n\t\t     Z_TYPE_P(digest) != IS_ARRAY) &&\n\t\t    (login = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_login\", sizeof(\"_login\")-1)) != NULL &&\n\t\t    Z_TYPE_P(login) == IS_STRING &&\n\t\t    (password = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_password\", sizeof(\"_password\")-1)) != NULL &&\n\t\t    Z_TYPE_P(password) == IS_STRING) {\n\t\t\tchar *s;\n\t\t\tzval digest;\n\n\t\t\tZVAL_UNDEF(&digest);\n\t\t\ts = auth + sizeof(\"Digest\")-1;\n\t\t\twhile (*s != '\\0') {\n\t\t\t\tchar *name, *val;\n\t\t\t\twhile (*s == ' ') ++s;\n\t\t\t\tname = s;\n\t\t\t\twhile (*s != '\\0' && *s != '=') ++s;\n\t\t\t\tif (*s == '=') {\n\t\t\t\t\t*s = '\\0';\n\t\t\t\t\t++s;\n\t\t\t\t\tif (*s == '\"') {\n\t\t\t\t\t\t++s;\n\t\t\t\t\t\tval = s;\n\t\t\t\t\t\twhile (*s != '\\0' && *s != '\"') ++s;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tval = s;\n\t\t\t\t\t\twhile (*s != '\\0' && *s != ' ' && *s != ',') ++s;\n\t\t\t\t\t}\n\t\t\t\t\tif (*s != '\\0') {\n\t\t\t\t\t\tif (*s != ',') {\n\t\t\t\t\t\t\t*s = '\\0';\n\t\t\t\t\t\t\t++s;\n\t\t\t\t\t\t\twhile (*s != '\\0' && *s != ',') ++s;\n\t\t\t\t\t\t\tif (*s != '\\0') ++s;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t*s = '\\0';\n\t\t\t\t\t\t\t++s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Z_TYPE(digest) == IS_UNDEF) {\n\t\t\t\t\t\tarray_init(&digest);\n\t\t\t\t\t}\n\t\t\t\t\tadd_assoc_string(&digest, name, val);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Z_TYPE(digest) != IS_UNDEF) {\n\t\t\t\tphp_url *new_url  = emalloc(sizeof(php_url));\n\n\t\t\t\tZ_DELREF(digest);\n\t\t\t\tadd_property_zval_ex(this_ptr, \"_digest\", sizeof(\"_digest\")-1, &digest);\n\n\t\t\t\t*new_url = *phpurl;\n\t\t\t\tif (phpurl->scheme) phpurl->scheme = estrdup(phpurl->scheme);\n\t\t\t\tif (phpurl->user) phpurl->user = estrdup(phpurl->user);\n\t\t\t\tif (phpurl->pass) phpurl->pass = estrdup(phpurl->pass);\n\t\t\t\tif (phpurl->host) phpurl->host = estrdup(phpurl->host);\n\t\t\t\tif (phpurl->path) phpurl->path = estrdup(phpurl->path);\n\t\t\t\tif (phpurl->query) phpurl->query = estrdup(phpurl->query);\n\t\t\t\tif (phpurl->fragment) phpurl->fragment = estrdup(phpurl->fragment);\n\t\t\t\tphpurl = new_url;\n\n\t\t\t\tefree(auth);\n\t\t\t\tzend_string_release(http_headers);\n\t\t\t\tzend_string_release(http_body);\n\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t}\n\t\tif (auth) efree(auth);\n\t}\n\tsmart_str_free(&soap_headers_z);\n\n\t/* Check and see if the server even sent a xml document */\n\tcontent_type = get_http_header_value(ZSTR_VAL(http_headers), \"Content-Type: \");\n\tif (content_type) {\n\t\tchar *pos = NULL;\n\t\tint cmplen;\n\t\tpos = strstr(content_type,\";\");\n\t\tif (pos != NULL) {\n\t\t\tcmplen = pos - content_type;\n\t\t} else {\n\t\t\tcmplen = strlen(content_type);\n\t\t}\n\t\tif (strncmp(content_type, \"text/xml\", cmplen) == 0 ||\n\t\t    strncmp(content_type, \"application/soap+xml\", cmplen) == 0) {\n\t\t\tcontent_type_xml = 1;\n/*\n\t\t\tif (strncmp(http_body, \"<?xml\", 5)) {\n\t\t\t\tzval *err;\n\t\t\t\tMAKE_STD_ZVAL(err);\n\t\t\t\tZVAL_STRINGL(err, http_body, http_body_size, 1);\n\t\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Didn't receive an xml document\", NULL, err);\n\t\t\t\tefree(content_type);\n\t\t\t\tzend_string_release(http_headers);\n\t\t\t\tefree(http_body);\n\t\t\t\treturn FALSE;\n\t\t\t}\n*/\n\t\t}\n\t\tefree(content_type);\n\t}\n\n\t/* Decompress response */\n\tcontent_encoding = get_http_header_value(ZSTR_VAL(http_headers), \"Content-Encoding: \");\n\tif (content_encoding) {\n\t\tzval func;\n\t\tzval retval;\n\t\tzval params[1];\n\n\t\tif ((strcmp(content_encoding,\"gzip\") == 0 ||\n\t\t     strcmp(content_encoding,\"x-gzip\") == 0) &&\n\t\t     zend_hash_str_exists(EG(function_table), \"gzinflate\", sizeof(\"gzinflate\")-1)) {\n\t\t\tZVAL_STRING(&func, \"gzinflate\");\n\t\t\tZVAL_STRINGL(&params[0], http_body->val+10, http_body->len-10);\n\t\t} else if (strcmp(content_encoding,\"deflate\") == 0 &&\n\t\t           zend_hash_str_exists(EG(function_table), \"gzuncompress\", sizeof(\"gzuncompress\")-1)) {\n\t\t\tZVAL_STRING(&func, \"gzuncompress\");\n\t\t\tZVAL_STR_COPY(&params[0], http_body);\n\t\t} else {\n\t\t\tefree(content_encoding);\n\t\t\tzend_string_release(http_headers);\n\t\t\tzend_string_release(http_body);\n\t\t\tif (http_msg) {\n\t\t\t\tefree(http_msg);\n\t\t\t}\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Unknown Content-Encoding\", NULL, NULL);\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (call_user_function(CG(function_table), (zval*)NULL, &func, &retval, 1, params) == SUCCESS &&\n\t\t    Z_TYPE(retval) == IS_STRING) {\n\t\t\tzval_ptr_dtor(&params[0]);\n\t\t\tzval_ptr_dtor(&func);\n\t\t\tzend_string_release(http_body);\n\t\t\tZVAL_COPY_VALUE(return_value, &retval);\n\t\t} else {\n\t\t\tzval_ptr_dtor(&params[0]);\n\t\t\tzval_ptr_dtor(&func);\n\t\t\tefree(content_encoding);\n\t\t\tzend_string_release(http_headers);\n\t\t\tzend_string_release(http_body);\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Can't uncompress compressed response\", NULL, NULL);\n\t\t\tif (http_msg) {\n\t\t\t\tefree(http_msg);\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\t\tefree(content_encoding);\n\t} else {\n\t\tZVAL_STR(return_value, http_body);\n\t}\n\n\tzend_string_release(http_headers);\n\n\tif (http_status >= 400) {\n\t\tint error = 0;\n\n\t\tif (Z_STRLEN_P(return_value) == 0) {\n\t\t\terror = 1;\n\t\t} else if (Z_STRLEN_P(return_value) > 0) {\n\t\t\tif (!content_type_xml) {\n\t\t\t\tchar *s = Z_STRVAL_P(return_value);\n\n\t\t\t\twhile (*s != '\\0' && *s < ' ') {\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t\tif (strncmp(s, \"<?xml\", 5)) {\n\t\t\t\t\terror = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (error) {\n\t\t\tzval_ptr_dtor(return_value);\n\t\t\tZVAL_UNDEF(return_value);\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", http_msg, NULL, NULL);\n\t\t\tefree(http_msg);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif (http_msg) {\n\t\tefree(http_msg);\n\t}\n\n\treturn TRUE;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145271,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "inline bool SegmentReader::containsInterval(const void* from, const void* to) {\n  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&\n      readLimiter->canRead(\n          intervalLength(reinterpret_cast<const byte*>(from),\n                         reinterpret_cast<const byte*>(to),\n                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)\n              / BYTES_PER_WORD,\n          arena);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145302,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "inline bool SegmentReader::containsInterval(const void* from, const void* to) {\n  uintptr_t start = reinterpret_cast<uintptr_t>(from) - reinterpret_cast<uintptr_t>(ptr.begin());\n  uintptr_t end = reinterpret_cast<uintptr_t>(to) - reinterpret_cast<uintptr_t>(ptr.begin());\n  uintptr_t bound = ptr.size() * sizeof(capnp::word);\n\n  return start <= bound && end <= bound && start <= end &&\n      readLimiter->canRead(\n          intervalLength(reinterpret_cast<const byte*>(from),\n                         reinterpret_cast<const byte*>(to),\n                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)\n              / BYTES_PER_WORD,\n          arena);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145303,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "crypto_recv(\n\tstruct peer *peer,\t/* peer structure pointer */\n\tstruct recvbuf *rbufp\t/* packet buffer pointer */\n\t)\n{\n\tconst EVP_MD *dp;\t/* message digest algorithm */\n\tu_int32\t*pkt;\t\t/* receive packet pointer */\n\tstruct autokey *ap, *bp; /* autokey pointer */\n\tstruct exten *ep, *fp;\t/* extension pointers */\n\tstruct cert_info *xinfo; /* certificate info pointer */\n\tint\thas_mac;\t/* length of MAC field */\n\tint\tauthlen;\t/* offset of MAC field */\n\tassocid_t associd;\t/* association ID */\n\ttstamp_t fstamp = 0;\t/* filestamp */\n\tu_int\tlen;\t\t/* extension field length */\n\tu_int\tcode;\t\t/* extension field opcode */\n\tu_int\tvallen = 0;\t/* value length */\n\tX509\t*cert;\t\t/* X509 certificate */\n\tchar\tstatstr[NTP_MAXSTRLEN]; /* statistics for filegen */\n\tkeyid_t\tcookie;\t\t/* crumbles */\n\tint\thismode;\t/* packet mode */\n\tint\trval = XEVNT_OK;\n\tconst u_char *puch;\n\tu_int32 temp32;\n\n\t/*\n\t * Initialize. Note that the packet has already been checked for\n\t * valid format and extension field lengths. First extract the\n\t * field length, command code and association ID in host byte\n\t * order. These are used with all commands and modes. Then check\n\t * the version number, which must be 2, and length, which must\n\t * be at least 8 for requests and VALUE_LEN (24) for responses.\n\t * Packets that fail either test sink without a trace. The\n\t * association ID is saved only if nonzero.\n\t */\n\tauthlen = LEN_PKT_NOMAC;\n\thismode = (int)PKT_MODE((&rbufp->recv_pkt)->li_vn_mode);\n\twhile ((has_mac = rbufp->recv_length - authlen) > (int)MAX_MAC_LEN) {\n\t\tpkt = (u_int32 *)&rbufp->recv_pkt + authlen / 4;\n\t\tep = (struct exten *)pkt;\n\t\tcode = ntohl(ep->opcode) & 0xffff0000;\n\t\tlen = ntohl(ep->opcode) & 0x0000ffff;\n\t\t// HMS: Why pkt[1] instead of ep->associd ?\n\t\tassocid = (associd_t)ntohl(pkt[1]);\n\t\trval = XEVNT_OK;\n\t\tDPRINTF(1, (\"crypto_recv: flags 0x%x ext offset %d len %u code 0x%x associd %d\\n\",\n\t\t\t    peer->crypto, authlen, len, code >> 16,\n\t\t\t    associd));\n\n\t\t/*\n\t\t * Check version number and field length. If bad,\n\t\t * quietly ignore the packet.\n\t\t */\n\t\tif (((code >> 24) & 0x3f) != CRYPTO_VN || len < 8) {\n\t\t\tsys_badlength++;\n\t\t\tcode |= CRYPTO_ERROR;\n\t\t}\n\n\t\tif (len >= VALUE_LEN) {\n\t\t\tfstamp = ntohl(ep->fstamp);\n\t\t\tvallen = ntohl(ep->vallen);\n\t\t\t/*\n\t\t\t * Bug 2761: I hope this isn't too early...\n\t\t\t */\n\t\t\tif (   vallen == 0\n\t\t\t    || len - VALUE_LEN < vallen)\n\t\t\t\treturn XEVNT_LEN;\n\t\t}\n\t\tswitch (code) {\n\n\t\t/*\n\t\t * Install status word, host name, signature scheme and\n\t\t * association ID. In OpenSSL the signature algorithm is\n\t\t * bound to the digest algorithm, so the NID completely\n\t\t * defines the signature scheme. Note the request and\n\t\t * response are identical, but neither is validated by\n\t\t * signature. The request is processed here only in\n\t\t * symmetric modes. The server name field might be\n\t\t * useful to implement access controls in future.\n\t\t */\n\t\tcase CRYPTO_ASSOC:\n\n\t\t\t/*\n\t\t\t * If our state machine is running when this\n\t\t\t * message arrives, the other fellow might have\n\t\t\t * restarted. However, this could be an\n\t\t\t * intruder, so just clamp the poll interval and\n\t\t\t * find out for ourselves. Otherwise, pass the\n\t\t\t * extension field to the transmit side.\n\t\t\t */\n\t\t\tif (peer->crypto & CRYPTO_FLAG_CERT) {\n\t\t\t\trval = XEVNT_ERR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (peer->cmmd) {\n\t\t\t\tif (peer->assoc != associd) {\n\t\t\t\t\trval = XEVNT_ERR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfp = emalloc(len);\n\t\t\tmemcpy(fp, ep, len);\n\t\t\tfp->associd = htonl(peer->associd);\n\t\t\tpeer->cmmd = fp;\n\t\t\t/* fall through */\n\n\t\tcase CRYPTO_ASSOC | CRYPTO_RESP:\n\n\t\t\t/*\n\t\t\t * Discard the message if it has already been\n\t\t\t * stored or the message has been amputated.\n\t\t\t */\n\t\t\tif (peer->crypto) {\n\t\t\t\tif (peer->assoc != associd)\n\t\t\t\t\trval = XEVNT_ERR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tINSIST(len >= VALUE_LEN);\n\t\t\tif (vallen == 0 || vallen > MAXHOSTNAME ||\n\t\t\t    len - VALUE_LEN < vallen) {\n\t\t\t\trval = XEVNT_LEN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tDPRINTF(1, (\"crypto_recv: ident host 0x%x %d server 0x%x %d\\n\",\n\t\t\t\t    crypto_flags, peer->associd, fstamp,\n\t\t\t\t    peer->assoc));\n\t\t\ttemp32 = crypto_flags & CRYPTO_FLAG_MASK;\n\n\t\t\t/*\n\t\t\t * If the client scheme is PC, the server scheme\n\t\t\t * must be PC. The public key and identity are\n\t\t\t * presumed valid, so we skip the certificate\n\t\t\t * and identity exchanges and move immediately\n\t\t\t * to the cookie exchange which confirms the\n\t\t\t * server signature.\n\t\t\t */\n\t\t\tif (crypto_flags & CRYPTO_FLAG_PRIV) {\n\t\t\t\tif (!(fstamp & CRYPTO_FLAG_PRIV)) {\n\t\t\t\t\trval = XEVNT_KEY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfstamp |= CRYPTO_FLAG_CERT |\n\t\t\t\t    CRYPTO_FLAG_VRFY | CRYPTO_FLAG_SIGN;\n\n\t\t\t/*\n\t\t\t * It is an error if either peer supports\n\t\t\t * identity, but the other does not.\n\t\t\t */\n\t\t\t} else if (hismode == MODE_ACTIVE || hismode ==\n\t\t\t    MODE_PASSIVE) {\n\t\t\t\tif ((temp32 && !(fstamp &\n\t\t\t\t    CRYPTO_FLAG_MASK)) ||\n\t\t\t\t    (!temp32 && (fstamp &\n\t\t\t\t    CRYPTO_FLAG_MASK))) {\n\t\t\t\t\trval = XEVNT_KEY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Discard the message if the signature digest\n\t\t\t * NID is not supported.\n\t\t\t */\n\t\t\ttemp32 = (fstamp >> 16) & 0xffff;\n\t\t\tdp =\n\t\t\t    (const EVP_MD *)EVP_get_digestbynid(temp32);\n\t\t\tif (dp == NULL) {\n\t\t\t\trval = XEVNT_MD;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Save status word, host name and message\n\t\t\t * digest/signature type. If this is from a\n\t\t\t * broadcast and the association ID has changed,\n\t\t\t * request the autokey values.\n\t\t\t */\n\t\t\tpeer->assoc = associd;\n\t\t\tif (hismode == MODE_SERVER)\n\t\t\t\tfstamp |= CRYPTO_FLAG_AUTO;\n\t\t\tif (!(fstamp & CRYPTO_FLAG_TAI))\n\t\t\t\tfstamp |= CRYPTO_FLAG_LEAP;\n\t\t\tRAND_bytes((u_char *)&peer->hcookie, 4);\n\t\t\tpeer->crypto = fstamp;\n\t\t\tpeer->digest = dp;\n\t\t\tif (peer->subject != NULL)\n\t\t\t\tfree(peer->subject);\n\t\t\tpeer->subject = emalloc(vallen + 1);\n\t\t\tmemcpy(peer->subject, ep->pkt, vallen);\n\t\t\tpeer->subject[vallen] = '\\0';\n\t\t\tif (peer->issuer != NULL)\n\t\t\t\tfree(peer->issuer);\n\t\t\tpeer->issuer = estrdup(peer->subject);\n\t\t\tsnprintf(statstr, sizeof(statstr),\n\t\t\t    \"assoc %d %d host %s %s\", peer->associd,\n\t\t\t    peer->assoc, peer->subject,\n\t\t\t    OBJ_nid2ln(temp32));\n\t\t\trecord_crypto_stats(&peer->srcadr, statstr);\n\t\t\tDPRINTF(1, (\"crypto_recv: %s\\n\", statstr));\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Decode X509 certificate in ASN.1 format and extract\n\t\t * the data containing, among other things, subject\n\t\t * name and public key. In the default identification\n\t\t * scheme, the certificate trail is followed to a self\n\t\t * signed trusted certificate.\n\t\t */\n\t\tcase CRYPTO_CERT | CRYPTO_RESP:\n\n\t\t\t/*\n\t\t\t * Discard the message if empty or invalid.\n\t\t\t */\n\t\t\tif (len < VALUE_LEN)\n\t\t\t\tbreak;\n\n\t\t\tif ((rval = crypto_verify(ep, NULL, peer)) !=\n\t\t\t    XEVNT_OK)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Scan the certificate list to delete old\n\t\t\t * versions and link the newest version first on\n\t\t\t * the list. Then, verify the signature. If the\n\t\t\t * certificate is bad or missing, just ignore\n\t\t\t * it.\n\t\t\t */\n\t\t\tif ((xinfo = cert_install(ep, peer)) == NULL) {\n\t\t\t\trval = XEVNT_CRT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((rval = cert_hike(peer, xinfo)) != XEVNT_OK)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * We plug in the public key and lifetime from\n\t\t\t * the first certificate received. However, note\n\t\t\t * that this certificate might not be signed by\n\t\t\t * the server, so we can't check the\n\t\t\t * signature/digest NID.\n\t\t\t */\n\t\t\tif (peer->pkey == NULL) {\n\t\t\t\tpuch = xinfo->cert.ptr;\n\t\t\t\tcert = d2i_X509(NULL, &puch,\n\t\t\t\t    ntohl(xinfo->cert.vallen));\n\t\t\t\tpeer->pkey = X509_get_pubkey(cert);\n\t\t\t\tX509_free(cert);\n\t\t\t}\n\t\t\tpeer->flash &= ~TEST8;\n\t\t\ttemp32 = xinfo->nid;\n\t\t\tsnprintf(statstr, sizeof(statstr),\n\t\t\t    \"cert %s %s 0x%x %s (%u) fs %u\",\n\t\t\t    xinfo->subject, xinfo->issuer, xinfo->flags,\n\t\t\t    OBJ_nid2ln(temp32), temp32,\n\t\t\t    ntohl(ep->fstamp));\n\t\t\trecord_crypto_stats(&peer->srcadr, statstr);\n\t\t\tDPRINTF(1, (\"crypto_recv: %s\\n\", statstr));\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Schnorr (IFF) identity scheme. This scheme is\n\t\t * designed for use with shared secret server group keys\n\t\t * and where the certificate may be generated by a third\n\t\t * party. The client sends a challenge to the server,\n\t\t * which performs a calculation and returns the result.\n\t\t * A positive result is possible only if both client and\n\t\t * server contain the same secret group key.\n\t\t */\n\t\tcase CRYPTO_IFF | CRYPTO_RESP:\n\n\t\t\t/*\n\t\t\t * Discard the message if invalid.\n\t\t\t */\n\t\t\tif ((rval = crypto_verify(ep, NULL, peer)) !=\n\t\t\t    XEVNT_OK)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * If the challenge matches the response, the\n\t\t\t * server public key, signature and identity are\n\t\t\t * all verified at the same time. The server is\n\t\t\t * declared trusted, so we skip further\n\t\t\t * certificate exchanges and move immediately to\n\t\t\t * the cookie exchange.\n\t\t\t */\n\t\t\tif ((rval = crypto_iff(ep, peer)) != XEVNT_OK)\n\t\t\t\tbreak;\n\n\t\t\tpeer->crypto |= CRYPTO_FLAG_VRFY;\n\t\t\tpeer->flash &= ~TEST8;\n\t\t\tsnprintf(statstr, sizeof(statstr), \"iff %s fs %u\",\n\t\t\t    peer->issuer, ntohl(ep->fstamp));\n\t\t\trecord_crypto_stats(&peer->srcadr, statstr);\n\t\t\tDPRINTF(1, (\"crypto_recv: %s\\n\", statstr));\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Guillou-Quisquater (GQ) identity scheme. This scheme\n\t\t * is designed for use with public certificates carrying\n\t\t * the GQ public key in an extension field. The client\n\t\t * sends a challenge to the server, which performs a\n\t\t * calculation and returns the result. A positive result\n\t\t * is possible only if both client and server contain\n\t\t * the same group key and the server has the matching GQ\n\t\t * private key.\n\t\t */\n\t\tcase CRYPTO_GQ | CRYPTO_RESP:\n\n\t\t\t/*\n\t\t\t * Discard the message if invalid\n\t\t\t */\n\t\t\tif ((rval = crypto_verify(ep, NULL, peer)) !=\n\t\t\t    XEVNT_OK)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * If the challenge matches the response, the\n\t\t\t * server public key, signature and identity are\n\t\t\t * all verified at the same time. The server is\n\t\t\t * declared trusted, so we skip further\n\t\t\t * certificate exchanges and move immediately to\n\t\t\t * the cookie exchange.\n\t\t\t */\n\t\t\tif ((rval = crypto_gq(ep, peer)) != XEVNT_OK)\n\t\t\t\tbreak;\n\n\t\t\tpeer->crypto |= CRYPTO_FLAG_VRFY;\n\t\t\tpeer->flash &= ~TEST8;\n\t\t\tsnprintf(statstr, sizeof(statstr), \"gq %s fs %u\",\n\t\t\t    peer->issuer, ntohl(ep->fstamp));\n\t\t\trecord_crypto_stats(&peer->srcadr, statstr);\n\t\t\tDPRINTF(1, (\"crypto_recv: %s\\n\", statstr));\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Mu-Varadharajan (MV) identity scheme. This scheme is\n\t\t * designed for use with three levels of trust, trusted\n\t\t * host, server and client. The trusted host key is\n\t\t * opaque to servers and clients; the server keys are\n\t\t * opaque to clients and each client key is different.\n\t\t * Client keys can be revoked without requiring new key\n\t\t * generations.\n\t\t */\n\t\tcase CRYPTO_MV | CRYPTO_RESP:\n\n\t\t\t/*\n\t\t\t * Discard the message if invalid.\n\t\t\t */\n\t\t\tif ((rval = crypto_verify(ep, NULL, peer)) !=\n\t\t\t    XEVNT_OK)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * If the challenge matches the response, the\n\t\t\t * server public key, signature and identity are\n\t\t\t * all verified at the same time. The server is\n\t\t\t * declared trusted, so we skip further\n\t\t\t * certificate exchanges and move immediately to\n\t\t\t * the cookie exchange.\n\t\t\t */\n\t\t\tif ((rval = crypto_mv(ep, peer)) != XEVNT_OK)\n\t\t\t\tbreak;\n\n\t\t\tpeer->crypto |= CRYPTO_FLAG_VRFY;\n\t\t\tpeer->flash &= ~TEST8;\n\t\t\tsnprintf(statstr, sizeof(statstr), \"mv %s fs %u\",\n\t\t\t    peer->issuer, ntohl(ep->fstamp));\n\t\t\trecord_crypto_stats(&peer->srcadr, statstr);\n\t\t\tDPRINTF(1, (\"crypto_recv: %s\\n\", statstr));\n\t\t\tbreak;\n\n\n\t\t/*\n\t\t * Cookie response in client and symmetric modes. If the\n\t\t * cookie bit is set, the working cookie is the EXOR of\n\t\t * the current and new values.\n\t\t */\n\t\tcase CRYPTO_COOK | CRYPTO_RESP:\n\n\t\t\t/*\n\t\t\t * Discard the message if invalid or signature\n\t\t\t * not verified with respect to the cookie\n\t\t\t * values.\n\t\t\t */\n\t\t\tif ((rval = crypto_verify(ep, &peer->cookval,\n\t\t\t    peer)) != XEVNT_OK)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Decrypt the cookie, hunting all the time for\n\t\t\t * errors.\n\t\t\t */\n\t\t\tif (vallen == (u_int)EVP_PKEY_size(host_pkey)) {\n\t\t\t\tu_int32 *cookiebuf = malloc(\n\t\t\t\t    RSA_size(host_pkey->pkey.rsa));\n\t\t\t\tif (!cookiebuf) {\n\t\t\t\t\trval = XEVNT_CKY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (RSA_private_decrypt(vallen,\n\t\t\t\t    (u_char *)ep->pkt,\n\t\t\t\t    (u_char *)cookiebuf,\n\t\t\t\t    host_pkey->pkey.rsa,\n\t\t\t\t    RSA_PKCS1_OAEP_PADDING) != 4) {\n\t\t\t\t\trval = XEVNT_CKY;\n\t\t\t\t\tfree(cookiebuf);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tcookie = ntohl(*cookiebuf);\n\t\t\t\t\tfree(cookiebuf);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trval = XEVNT_CKY;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Install cookie values and light the cookie\n\t\t\t * bit. If this is not broadcast client mode, we\n\t\t\t * are done here.\n\t\t\t */\n\t\t\tkey_expire(peer);\n\t\t\tif (hismode == MODE_ACTIVE || hismode ==\n\t\t\t    MODE_PASSIVE)\n\t\t\t\tpeer->pcookie = peer->hcookie ^ cookie;\n\t\t\telse\n\t\t\t\tpeer->pcookie = cookie;\n\t\t\tpeer->crypto |= CRYPTO_FLAG_COOK;\n\t\t\tpeer->flash &= ~TEST8;\n\t\t\tsnprintf(statstr, sizeof(statstr),\n\t\t\t    \"cook %x ts %u fs %u\", peer->pcookie,\n\t\t\t    ntohl(ep->tstamp), ntohl(ep->fstamp));\n\t\t\trecord_crypto_stats(&peer->srcadr, statstr);\n\t\t\tDPRINTF(1, (\"crypto_recv: %s\\n\", statstr));\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Install autokey values in broadcast client and\n\t\t * symmetric modes. We have to do this every time the\n\t\t * sever/peer cookie changes or a new keylist is\n\t\t * rolled. Ordinarily, this is automatic as this message\n\t\t * is piggybacked on the first NTP packet sent upon\n\t\t * either of these events. Note that a broadcast client\n\t\t * or symmetric peer can receive this response without a\n\t\t * matching request.\n\t\t */\n\t\tcase CRYPTO_AUTO | CRYPTO_RESP:\n\n\t\t\t/*\n\t\t\t * Discard the message if invalid or signature\n\t\t\t * not verified with respect to the receive\n\t\t\t * autokey values.\n\t\t\t */\n\t\t\tif ((rval = crypto_verify(ep, &peer->recval,\n\t\t\t    peer)) != XEVNT_OK) \n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Discard the message if a broadcast client and\n\t\t\t * the association ID does not match. This might\n\t\t\t * happen if a broacast server restarts the\n\t\t\t * protocol. A protocol restart will occur at\n\t\t\t * the next ASSOC message.\n\t\t\t */\n\t\t\tif ((peer->cast_flags & MDF_BCLNT) &&\n\t\t\t    peer->assoc != associd)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Install autokey values and light the\n\t\t\t * autokey bit. This is not hard.\n\t\t\t */\n\t\t\tif (ep->tstamp == 0)\n\t\t\t\tbreak;\n\n\t\t\tif (peer->recval.ptr == NULL)\n\t\t\t\tpeer->recval.ptr =\n\t\t\t\t    emalloc(sizeof(struct autokey));\n\t\t\tbp = (struct autokey *)peer->recval.ptr;\n\t\t\tpeer->recval.tstamp = ep->tstamp;\n\t\t\tpeer->recval.fstamp = ep->fstamp;\n\t\t\tap = (struct autokey *)ep->pkt;\n\t\t\tbp->seq = ntohl(ap->seq);\n\t\t\tbp->key = ntohl(ap->key);\n\t\t\tpeer->pkeyid = bp->key;\n\t\t\tpeer->crypto |= CRYPTO_FLAG_AUTO;\n\t\t\tpeer->flash &= ~TEST8;\n\t\t\tsnprintf(statstr, sizeof(statstr), \n\t\t\t    \"auto seq %d key %x ts %u fs %u\", bp->seq,\n\t\t\t    bp->key, ntohl(ep->tstamp),\n\t\t\t    ntohl(ep->fstamp));\n\t\t\trecord_crypto_stats(&peer->srcadr, statstr);\n\t\t\tDPRINTF(1, (\"crypto_recv: %s\\n\", statstr));\n\t\t\tbreak;\n\t\n\t\t/*\n\t\t * X509 certificate sign response. Validate the\n\t\t * certificate signed by the server and install. Later\n\t\t * this can be provided to clients of this server in\n\t\t * lieu of the self signed certificate in order to\n\t\t * validate the public key.\n\t\t */\n\t\tcase CRYPTO_SIGN | CRYPTO_RESP:\n\n\t\t\t/*\n\t\t\t * Discard the message if invalid.\n\t\t\t */\n\t\t\tif ((rval = crypto_verify(ep, NULL, peer)) !=\n\t\t\t    XEVNT_OK)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Scan the certificate list to delete old\n\t\t\t * versions and link the newest version first on\n\t\t\t * the list.\n\t\t\t */\n\t\t\tif ((xinfo = cert_install(ep, peer)) == NULL) {\n\t\t\t\trval = XEVNT_CRT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpeer->crypto |= CRYPTO_FLAG_SIGN;\n\t\t\tpeer->flash &= ~TEST8;\n\t\t\ttemp32 = xinfo->nid;\n\t\t\tsnprintf(statstr, sizeof(statstr),\n\t\t\t    \"sign %s %s 0x%x %s (%u) fs %u\",\n\t\t\t    xinfo->subject, xinfo->issuer, xinfo->flags,\n\t\t\t    OBJ_nid2ln(temp32), temp32,\n\t\t\t    ntohl(ep->fstamp));\n\t\t\trecord_crypto_stats(&peer->srcadr, statstr);\n\t\t\tDPRINTF(1, (\"crypto_recv: %s\\n\", statstr));\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Install leapseconds values. While the leapsecond\n\t\t * values epoch, TAI offset and values expiration epoch\n\t\t * are retained, only the current TAI offset is provided\n\t\t * via the kernel to other applications.\n\t\t */\n\t\tcase CRYPTO_LEAP | CRYPTO_RESP:\n\t\t\t/*\n\t\t\t * Discard the message if invalid. We can't\n\t\t\t * compare the value timestamps here, as they\n\t\t\t * can be updated by different servers.\n\t\t\t */\n\t\t\trval = crypto_verify(ep, NULL, peer);\n\t\t\tif ((rval   != XEVNT_OK          ) ||\n\t\t\t    (vallen != 3*sizeof(uint32_t))  )\n\t\t\t\tbreak;\n\n\t\t\t/* Check if we can update the basic TAI offset\n\t\t\t * for our current leap frame. This is a hack\n\t\t\t * and ignores the time stamps in the autokey\n\t\t\t * message.\n\t\t\t */\n\t\t\tif (sys_leap != LEAP_NOTINSYNC)\n\t\t\t\tleapsec_autokey_tai(ntohl(ep->pkt[0]),\n\t\t\t\t\t\t    rbufp->recv_time.l_ui, NULL);\n\t\t\ttai_leap.tstamp = ep->tstamp;\n\t\t\ttai_leap.fstamp = ep->fstamp;\n\t\t\tcrypto_update();\n\t\t\tmprintf_event(EVNT_TAI, peer,\n\t\t\t\t      \"%d seconds\", ntohl(ep->pkt[0]));\n\t\t\tpeer->crypto |= CRYPTO_FLAG_LEAP;\n\t\t\tpeer->flash &= ~TEST8;\n\t\t\tsnprintf(statstr, sizeof(statstr),\n\t\t\t\t \"leap TAI offset %d at %u expire %u fs %u\",\n\t\t\t\t ntohl(ep->pkt[0]), ntohl(ep->pkt[1]),\n\t\t\t\t ntohl(ep->pkt[2]), ntohl(ep->fstamp));\n\t\t\trecord_crypto_stats(&peer->srcadr, statstr);\n\t\t\tDPRINTF(1, (\"crypto_recv: %s\\n\", statstr));\n\t\t\tbreak;\n\n\t\t/*\n\t\t * We come here in symmetric modes for miscellaneous\n\t\t * commands that have value fields but are processed on\n\t\t * the transmit side. All we need do here is check for\n\t\t * valid field length. Note that ASSOC is handled\n\t\t * separately.\n\t\t */\n\t\tcase CRYPTO_CERT:\n\t\tcase CRYPTO_IFF:\n\t\tcase CRYPTO_GQ:\n\t\tcase CRYPTO_MV:\n\t\tcase CRYPTO_COOK:\n\t\tcase CRYPTO_SIGN:\n\t\t\tif (len < VALUE_LEN) {\n\t\t\t\trval = XEVNT_LEN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fall through */\n\n\t\t/*\n\t\t * We come here in symmetric modes for requests\n\t\t * requiring a response (above plus AUTO and LEAP) and\n\t\t * for responses. If a request, save the extension field\n\t\t * for later; invalid requests will be caught on the\n\t\t * transmit side. If an error or invalid response,\n\t\t * declare a protocol error.\n\t\t */\n\t\tdefault:\n\t\t\tif (code & (CRYPTO_RESP | CRYPTO_ERROR)) {\n\t\t\t\trval = XEVNT_ERR;\n\t\t\t} else if (peer->cmmd == NULL) {\n\t\t\t\tfp = emalloc(len);\n\t\t\t\tmemcpy(fp, ep, len);\n\t\t\t\tpeer->cmmd = fp;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * The first error found terminates the extension field\n\t\t * scan and we return the laundry to the caller.\n\t\t */\n\t\tif (rval != XEVNT_OK) {\n\t\t\tsnprintf(statstr, sizeof(statstr),\n\t\t\t    \"%04x %d %02x %s\", htonl(ep->opcode),\n\t\t\t    associd, rval, eventstr(rval));\n\t\t\trecord_crypto_stats(&peer->srcadr, statstr);\n\t\t\tDPRINTF(1, (\"crypto_recv: %s\\n\", statstr));\n\t\t\treturn (rval);\n\t\t}\n\t\tauthlen += (len + 3) / 4 * 4;\n\t}\n\treturn (rval);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145312,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "crypto_recv(\n\tstruct peer *peer,\t/* peer structure pointer */\n\tstruct recvbuf *rbufp\t/* packet buffer pointer */\n\t)\n{\n\tconst EVP_MD *dp;\t/* message digest algorithm */\n\tu_int32\t*pkt;\t\t/* receive packet pointer */\n\tstruct autokey *ap, *bp; /* autokey pointer */\n\tstruct exten *ep, *fp;\t/* extension pointers */\n\tstruct cert_info *xinfo; /* certificate info pointer */\n\tint\tmacbytes;\t/* length of MAC field, signed by intention */\n\tint\tauthlen;\t/* offset of MAC field */\n\tassocid_t associd;\t/* association ID */\n\ttstamp_t fstamp = 0;\t/* filestamp */\n\tu_int\tlen;\t\t/* extension field length */\n\tu_int\tcode;\t\t/* extension field opcode */\n\tu_int\tvallen = 0;\t/* value length */\n\tX509\t*cert;\t\t/* X509 certificate */\n\tchar\tstatstr[NTP_MAXSTRLEN]; /* statistics for filegen */\n\tkeyid_t\tcookie;\t\t/* crumbles */\n\tint\thismode;\t/* packet mode */\n\tint\trval = XEVNT_OK;\n\tconst u_char *puch;\n\tu_int32 temp32;\n\n\t/*\n\t * Initialize. Note that the packet has already been checked for\n\t * valid format and extension field lengths. First extract the\n\t * field length, command code and association ID in host byte\n\t * order. These are used with all commands and modes. Then check\n\t * the version number, which must be 2, and length, which must\n\t * be at least 8 for requests and VALUE_LEN (24) for responses.\n\t * Packets that fail either test sink without a trace. The\n\t * association ID is saved only if nonzero.\n\t */\n\tauthlen = LEN_PKT_NOMAC;\n\thismode = (int)PKT_MODE((&rbufp->recv_pkt)->li_vn_mode);\n\twhile ((macbytes = rbufp->recv_length - authlen) > (int)MAX_MAC_LEN) {\n\t\t/* We can be reasonably sure that we can read at least\n\t\t * the opcode and the size field here. More stringent\n\t\t * checks follow up shortly.\n\t\t */\n\t\tpkt = (u_int32 *)&rbufp->recv_pkt + authlen / 4;\n\t\tep = (struct exten *)pkt;\n\t\tcode = ntohl(ep->opcode) & 0xffff0000;\n\t\tlen = ntohl(ep->opcode) & 0x0000ffff;\n\t\t// HMS: Why pkt[1] instead of ep->associd ?\n\t\tassocid = (associd_t)ntohl(pkt[1]);\n\t\trval = XEVNT_OK;\n\t\tDPRINTF(1, (\"crypto_recv: flags 0x%x ext offset %d len %u code 0x%x associd %d\\n\",\n\t\t\t    peer->crypto, authlen, len, code >> 16,\n\t\t\t    associd));\n\n\t\t/*\n\t\t * Check version number and field length. If bad,\n\t\t * quietly ignore the packet.\n\t\t */\n\t\tif (((code >> 24) & 0x3f) != CRYPTO_VN || len < 8) {\n\t\t\tsys_badlength++;\n\t\t\tcode |= CRYPTO_ERROR;\n\t\t}\n\n\t\t/* Check if the declared size fits into the remaining\n\t\t * buffer.\n\t\t */\n\t\tif (len > macbytes) {\n\t\t\tDPRINTF(1, (\"crypto_recv: possible attack detected, associd %d\\n\",\n\t\t\t\t    associd));\n\t\t\treturn XEVNT_LEN;\n\t\t}\n\n\t\t/* Check if the paylod of the extension fits into the\n\t\t * declared frame.\n\t\t */\n\t\tif (len >= VALUE_LEN) {\n\t\t\tfstamp = ntohl(ep->fstamp);\n\t\t\tvallen = ntohl(ep->vallen);\n\t\t\t/*\n\t\t\t * Bug 2761: I hope this isn't too early...\n\t\t\t */\n\t\t\tif (   vallen == 0\n\t\t\t    || len - VALUE_LEN < vallen)\n\t\t\t\treturn XEVNT_LEN;\n\t\t}\n\t\tswitch (code) {\n\n\t\t/*\n\t\t * Install status word, host name, signature scheme and\n\t\t * association ID. In OpenSSL the signature algorithm is\n\t\t * bound to the digest algorithm, so the NID completely\n\t\t * defines the signature scheme. Note the request and\n\t\t * response are identical, but neither is validated by\n\t\t * signature. The request is processed here only in\n\t\t * symmetric modes. The server name field might be\n\t\t * useful to implement access controls in future.\n\t\t */\n\t\tcase CRYPTO_ASSOC:\n\n\t\t\t/*\n\t\t\t * If our state machine is running when this\n\t\t\t * message arrives, the other fellow might have\n\t\t\t * restarted. However, this could be an\n\t\t\t * intruder, so just clamp the poll interval and\n\t\t\t * find out for ourselves. Otherwise, pass the\n\t\t\t * extension field to the transmit side.\n\t\t\t */\n\t\t\tif (peer->crypto & CRYPTO_FLAG_CERT) {\n\t\t\t\trval = XEVNT_ERR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (peer->cmmd) {\n\t\t\t\tif (peer->assoc != associd) {\n\t\t\t\t\trval = XEVNT_ERR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfp = emalloc(len);\n\t\t\tmemcpy(fp, ep, len);\n\t\t\tfp->associd = htonl(peer->associd);\n\t\t\tpeer->cmmd = fp;\n\t\t\t/* fall through */\n\n\t\tcase CRYPTO_ASSOC | CRYPTO_RESP:\n\n\t\t\t/*\n\t\t\t * Discard the message if it has already been\n\t\t\t * stored or the message has been amputated.\n\t\t\t */\n\t\t\tif (peer->crypto) {\n\t\t\t\tif (peer->assoc != associd)\n\t\t\t\t\trval = XEVNT_ERR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tINSIST(len >= VALUE_LEN);\n\t\t\tif (vallen == 0 || vallen > MAXHOSTNAME ||\n\t\t\t    len - VALUE_LEN < vallen) {\n\t\t\t\trval = XEVNT_LEN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tDPRINTF(1, (\"crypto_recv: ident host 0x%x %d server 0x%x %d\\n\",\n\t\t\t\t    crypto_flags, peer->associd, fstamp,\n\t\t\t\t    peer->assoc));\n\t\t\ttemp32 = crypto_flags & CRYPTO_FLAG_MASK;\n\n\t\t\t/*\n\t\t\t * If the client scheme is PC, the server scheme\n\t\t\t * must be PC. The public key and identity are\n\t\t\t * presumed valid, so we skip the certificate\n\t\t\t * and identity exchanges and move immediately\n\t\t\t * to the cookie exchange which confirms the\n\t\t\t * server signature.\n\t\t\t */\n\t\t\tif (crypto_flags & CRYPTO_FLAG_PRIV) {\n\t\t\t\tif (!(fstamp & CRYPTO_FLAG_PRIV)) {\n\t\t\t\t\trval = XEVNT_KEY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfstamp |= CRYPTO_FLAG_CERT |\n\t\t\t\t    CRYPTO_FLAG_VRFY | CRYPTO_FLAG_SIGN;\n\n\t\t\t/*\n\t\t\t * It is an error if either peer supports\n\t\t\t * identity, but the other does not.\n\t\t\t */\n\t\t\t} else if (hismode == MODE_ACTIVE || hismode ==\n\t\t\t    MODE_PASSIVE) {\n\t\t\t\tif ((temp32 && !(fstamp &\n\t\t\t\t    CRYPTO_FLAG_MASK)) ||\n\t\t\t\t    (!temp32 && (fstamp &\n\t\t\t\t    CRYPTO_FLAG_MASK))) {\n\t\t\t\t\trval = XEVNT_KEY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Discard the message if the signature digest\n\t\t\t * NID is not supported.\n\t\t\t */\n\t\t\ttemp32 = (fstamp >> 16) & 0xffff;\n\t\t\tdp =\n\t\t\t    (const EVP_MD *)EVP_get_digestbynid(temp32);\n\t\t\tif (dp == NULL) {\n\t\t\t\trval = XEVNT_MD;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Save status word, host name and message\n\t\t\t * digest/signature type. If this is from a\n\t\t\t * broadcast and the association ID has changed,\n\t\t\t * request the autokey values.\n\t\t\t */\n\t\t\tpeer->assoc = associd;\n\t\t\tif (hismode == MODE_SERVER)\n\t\t\t\tfstamp |= CRYPTO_FLAG_AUTO;\n\t\t\tif (!(fstamp & CRYPTO_FLAG_TAI))\n\t\t\t\tfstamp |= CRYPTO_FLAG_LEAP;\n\t\t\tRAND_bytes((u_char *)&peer->hcookie, 4);\n\t\t\tpeer->crypto = fstamp;\n\t\t\tpeer->digest = dp;\n\t\t\tif (peer->subject != NULL)\n\t\t\t\tfree(peer->subject);\n\t\t\tpeer->subject = emalloc(vallen + 1);\n\t\t\tmemcpy(peer->subject, ep->pkt, vallen);\n\t\t\tpeer->subject[vallen] = '\\0';\n\t\t\tif (peer->issuer != NULL)\n\t\t\t\tfree(peer->issuer);\n\t\t\tpeer->issuer = estrdup(peer->subject);\n\t\t\tsnprintf(statstr, sizeof(statstr),\n\t\t\t    \"assoc %d %d host %s %s\", peer->associd,\n\t\t\t    peer->assoc, peer->subject,\n\t\t\t    OBJ_nid2ln(temp32));\n\t\t\trecord_crypto_stats(&peer->srcadr, statstr);\n\t\t\tDPRINTF(1, (\"crypto_recv: %s\\n\", statstr));\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Decode X509 certificate in ASN.1 format and extract\n\t\t * the data containing, among other things, subject\n\t\t * name and public key. In the default identification\n\t\t * scheme, the certificate trail is followed to a self\n\t\t * signed trusted certificate.\n\t\t */\n\t\tcase CRYPTO_CERT | CRYPTO_RESP:\n\n\t\t\t/*\n\t\t\t * Discard the message if empty or invalid.\n\t\t\t */\n\t\t\tif (len < VALUE_LEN)\n\t\t\t\tbreak;\n\n\t\t\tif ((rval = crypto_verify(ep, NULL, peer)) !=\n\t\t\t    XEVNT_OK)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Scan the certificate list to delete old\n\t\t\t * versions and link the newest version first on\n\t\t\t * the list. Then, verify the signature. If the\n\t\t\t * certificate is bad or missing, just ignore\n\t\t\t * it.\n\t\t\t */\n\t\t\tif ((xinfo = cert_install(ep, peer)) == NULL) {\n\t\t\t\trval = XEVNT_CRT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((rval = cert_hike(peer, xinfo)) != XEVNT_OK)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * We plug in the public key and lifetime from\n\t\t\t * the first certificate received. However, note\n\t\t\t * that this certificate might not be signed by\n\t\t\t * the server, so we can't check the\n\t\t\t * signature/digest NID.\n\t\t\t */\n\t\t\tif (peer->pkey == NULL) {\n\t\t\t\tpuch = xinfo->cert.ptr;\n\t\t\t\tcert = d2i_X509(NULL, &puch,\n\t\t\t\t    ntohl(xinfo->cert.vallen));\n\t\t\t\tpeer->pkey = X509_get_pubkey(cert);\n\t\t\t\tX509_free(cert);\n\t\t\t}\n\t\t\tpeer->flash &= ~TEST8;\n\t\t\ttemp32 = xinfo->nid;\n\t\t\tsnprintf(statstr, sizeof(statstr),\n\t\t\t    \"cert %s %s 0x%x %s (%u) fs %u\",\n\t\t\t    xinfo->subject, xinfo->issuer, xinfo->flags,\n\t\t\t    OBJ_nid2ln(temp32), temp32,\n\t\t\t    ntohl(ep->fstamp));\n\t\t\trecord_crypto_stats(&peer->srcadr, statstr);\n\t\t\tDPRINTF(1, (\"crypto_recv: %s\\n\", statstr));\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Schnorr (IFF) identity scheme. This scheme is\n\t\t * designed for use with shared secret server group keys\n\t\t * and where the certificate may be generated by a third\n\t\t * party. The client sends a challenge to the server,\n\t\t * which performs a calculation and returns the result.\n\t\t * A positive result is possible only if both client and\n\t\t * server contain the same secret group key.\n\t\t */\n\t\tcase CRYPTO_IFF | CRYPTO_RESP:\n\n\t\t\t/*\n\t\t\t * Discard the message if invalid.\n\t\t\t */\n\t\t\tif ((rval = crypto_verify(ep, NULL, peer)) !=\n\t\t\t    XEVNT_OK)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * If the challenge matches the response, the\n\t\t\t * server public key, signature and identity are\n\t\t\t * all verified at the same time. The server is\n\t\t\t * declared trusted, so we skip further\n\t\t\t * certificate exchanges and move immediately to\n\t\t\t * the cookie exchange.\n\t\t\t */\n\t\t\tif ((rval = crypto_iff(ep, peer)) != XEVNT_OK)\n\t\t\t\tbreak;\n\n\t\t\tpeer->crypto |= CRYPTO_FLAG_VRFY;\n\t\t\tpeer->flash &= ~TEST8;\n\t\t\tsnprintf(statstr, sizeof(statstr), \"iff %s fs %u\",\n\t\t\t    peer->issuer, ntohl(ep->fstamp));\n\t\t\trecord_crypto_stats(&peer->srcadr, statstr);\n\t\t\tDPRINTF(1, (\"crypto_recv: %s\\n\", statstr));\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Guillou-Quisquater (GQ) identity scheme. This scheme\n\t\t * is designed for use with public certificates carrying\n\t\t * the GQ public key in an extension field. The client\n\t\t * sends a challenge to the server, which performs a\n\t\t * calculation and returns the result. A positive result\n\t\t * is possible only if both client and server contain\n\t\t * the same group key and the server has the matching GQ\n\t\t * private key.\n\t\t */\n\t\tcase CRYPTO_GQ | CRYPTO_RESP:\n\n\t\t\t/*\n\t\t\t * Discard the message if invalid\n\t\t\t */\n\t\t\tif ((rval = crypto_verify(ep, NULL, peer)) !=\n\t\t\t    XEVNT_OK)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * If the challenge matches the response, the\n\t\t\t * server public key, signature and identity are\n\t\t\t * all verified at the same time. The server is\n\t\t\t * declared trusted, so we skip further\n\t\t\t * certificate exchanges and move immediately to\n\t\t\t * the cookie exchange.\n\t\t\t */\n\t\t\tif ((rval = crypto_gq(ep, peer)) != XEVNT_OK)\n\t\t\t\tbreak;\n\n\t\t\tpeer->crypto |= CRYPTO_FLAG_VRFY;\n\t\t\tpeer->flash &= ~TEST8;\n\t\t\tsnprintf(statstr, sizeof(statstr), \"gq %s fs %u\",\n\t\t\t    peer->issuer, ntohl(ep->fstamp));\n\t\t\trecord_crypto_stats(&peer->srcadr, statstr);\n\t\t\tDPRINTF(1, (\"crypto_recv: %s\\n\", statstr));\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Mu-Varadharajan (MV) identity scheme. This scheme is\n\t\t * designed for use with three levels of trust, trusted\n\t\t * host, server and client. The trusted host key is\n\t\t * opaque to servers and clients; the server keys are\n\t\t * opaque to clients and each client key is different.\n\t\t * Client keys can be revoked without requiring new key\n\t\t * generations.\n\t\t */\n\t\tcase CRYPTO_MV | CRYPTO_RESP:\n\n\t\t\t/*\n\t\t\t * Discard the message if invalid.\n\t\t\t */\n\t\t\tif ((rval = crypto_verify(ep, NULL, peer)) !=\n\t\t\t    XEVNT_OK)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * If the challenge matches the response, the\n\t\t\t * server public key, signature and identity are\n\t\t\t * all verified at the same time. The server is\n\t\t\t * declared trusted, so we skip further\n\t\t\t * certificate exchanges and move immediately to\n\t\t\t * the cookie exchange.\n\t\t\t */\n\t\t\tif ((rval = crypto_mv(ep, peer)) != XEVNT_OK)\n\t\t\t\tbreak;\n\n\t\t\tpeer->crypto |= CRYPTO_FLAG_VRFY;\n\t\t\tpeer->flash &= ~TEST8;\n\t\t\tsnprintf(statstr, sizeof(statstr), \"mv %s fs %u\",\n\t\t\t    peer->issuer, ntohl(ep->fstamp));\n\t\t\trecord_crypto_stats(&peer->srcadr, statstr);\n\t\t\tDPRINTF(1, (\"crypto_recv: %s\\n\", statstr));\n\t\t\tbreak;\n\n\n\t\t/*\n\t\t * Cookie response in client and symmetric modes. If the\n\t\t * cookie bit is set, the working cookie is the EXOR of\n\t\t * the current and new values.\n\t\t */\n\t\tcase CRYPTO_COOK | CRYPTO_RESP:\n\n\t\t\t/*\n\t\t\t * Discard the message if invalid or signature\n\t\t\t * not verified with respect to the cookie\n\t\t\t * values.\n\t\t\t */\n\t\t\tif ((rval = crypto_verify(ep, &peer->cookval,\n\t\t\t    peer)) != XEVNT_OK)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Decrypt the cookie, hunting all the time for\n\t\t\t * errors.\n\t\t\t */\n\t\t\tif (vallen == (u_int)EVP_PKEY_size(host_pkey)) {\n\t\t\t\tu_int32 *cookiebuf = malloc(\n\t\t\t\t    RSA_size(host_pkey->pkey.rsa));\n\t\t\t\tif (!cookiebuf) {\n\t\t\t\t\trval = XEVNT_CKY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (RSA_private_decrypt(vallen,\n\t\t\t\t    (u_char *)ep->pkt,\n\t\t\t\t    (u_char *)cookiebuf,\n\t\t\t\t    host_pkey->pkey.rsa,\n\t\t\t\t    RSA_PKCS1_OAEP_PADDING) != 4) {\n\t\t\t\t\trval = XEVNT_CKY;\n\t\t\t\t\tfree(cookiebuf);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tcookie = ntohl(*cookiebuf);\n\t\t\t\t\tfree(cookiebuf);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trval = XEVNT_CKY;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Install cookie values and light the cookie\n\t\t\t * bit. If this is not broadcast client mode, we\n\t\t\t * are done here.\n\t\t\t */\n\t\t\tkey_expire(peer);\n\t\t\tif (hismode == MODE_ACTIVE || hismode ==\n\t\t\t    MODE_PASSIVE)\n\t\t\t\tpeer->pcookie = peer->hcookie ^ cookie;\n\t\t\telse\n\t\t\t\tpeer->pcookie = cookie;\n\t\t\tpeer->crypto |= CRYPTO_FLAG_COOK;\n\t\t\tpeer->flash &= ~TEST8;\n\t\t\tsnprintf(statstr, sizeof(statstr),\n\t\t\t    \"cook %x ts %u fs %u\", peer->pcookie,\n\t\t\t    ntohl(ep->tstamp), ntohl(ep->fstamp));\n\t\t\trecord_crypto_stats(&peer->srcadr, statstr);\n\t\t\tDPRINTF(1, (\"crypto_recv: %s\\n\", statstr));\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Install autokey values in broadcast client and\n\t\t * symmetric modes. We have to do this every time the\n\t\t * sever/peer cookie changes or a new keylist is\n\t\t * rolled. Ordinarily, this is automatic as this message\n\t\t * is piggybacked on the first NTP packet sent upon\n\t\t * either of these events. Note that a broadcast client\n\t\t * or symmetric peer can receive this response without a\n\t\t * matching request.\n\t\t */\n\t\tcase CRYPTO_AUTO | CRYPTO_RESP:\n\n\t\t\t/*\n\t\t\t * Discard the message if invalid or signature\n\t\t\t * not verified with respect to the receive\n\t\t\t * autokey values.\n\t\t\t */\n\t\t\tif ((rval = crypto_verify(ep, &peer->recval,\n\t\t\t    peer)) != XEVNT_OK) \n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Discard the message if a broadcast client and\n\t\t\t * the association ID does not match. This might\n\t\t\t * happen if a broacast server restarts the\n\t\t\t * protocol. A protocol restart will occur at\n\t\t\t * the next ASSOC message.\n\t\t\t */\n\t\t\tif ((peer->cast_flags & MDF_BCLNT) &&\n\t\t\t    peer->assoc != associd)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Install autokey values and light the\n\t\t\t * autokey bit. This is not hard.\n\t\t\t */\n\t\t\tif (ep->tstamp == 0)\n\t\t\t\tbreak;\n\n\t\t\tif (peer->recval.ptr == NULL)\n\t\t\t\tpeer->recval.ptr =\n\t\t\t\t    emalloc(sizeof(struct autokey));\n\t\t\tbp = (struct autokey *)peer->recval.ptr;\n\t\t\tpeer->recval.tstamp = ep->tstamp;\n\t\t\tpeer->recval.fstamp = ep->fstamp;\n\t\t\tap = (struct autokey *)ep->pkt;\n\t\t\tbp->seq = ntohl(ap->seq);\n\t\t\tbp->key = ntohl(ap->key);\n\t\t\tpeer->pkeyid = bp->key;\n\t\t\tpeer->crypto |= CRYPTO_FLAG_AUTO;\n\t\t\tpeer->flash &= ~TEST8;\n\t\t\tsnprintf(statstr, sizeof(statstr), \n\t\t\t    \"auto seq %d key %x ts %u fs %u\", bp->seq,\n\t\t\t    bp->key, ntohl(ep->tstamp),\n\t\t\t    ntohl(ep->fstamp));\n\t\t\trecord_crypto_stats(&peer->srcadr, statstr);\n\t\t\tDPRINTF(1, (\"crypto_recv: %s\\n\", statstr));\n\t\t\tbreak;\n\t\n\t\t/*\n\t\t * X509 certificate sign response. Validate the\n\t\t * certificate signed by the server and install. Later\n\t\t * this can be provided to clients of this server in\n\t\t * lieu of the self signed certificate in order to\n\t\t * validate the public key.\n\t\t */\n\t\tcase CRYPTO_SIGN | CRYPTO_RESP:\n\n\t\t\t/*\n\t\t\t * Discard the message if invalid.\n\t\t\t */\n\t\t\tif ((rval = crypto_verify(ep, NULL, peer)) !=\n\t\t\t    XEVNT_OK)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Scan the certificate list to delete old\n\t\t\t * versions and link the newest version first on\n\t\t\t * the list.\n\t\t\t */\n\t\t\tif ((xinfo = cert_install(ep, peer)) == NULL) {\n\t\t\t\trval = XEVNT_CRT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpeer->crypto |= CRYPTO_FLAG_SIGN;\n\t\t\tpeer->flash &= ~TEST8;\n\t\t\ttemp32 = xinfo->nid;\n\t\t\tsnprintf(statstr, sizeof(statstr),\n\t\t\t    \"sign %s %s 0x%x %s (%u) fs %u\",\n\t\t\t    xinfo->subject, xinfo->issuer, xinfo->flags,\n\t\t\t    OBJ_nid2ln(temp32), temp32,\n\t\t\t    ntohl(ep->fstamp));\n\t\t\trecord_crypto_stats(&peer->srcadr, statstr);\n\t\t\tDPRINTF(1, (\"crypto_recv: %s\\n\", statstr));\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Install leapseconds values. While the leapsecond\n\t\t * values epoch, TAI offset and values expiration epoch\n\t\t * are retained, only the current TAI offset is provided\n\t\t * via the kernel to other applications.\n\t\t */\n\t\tcase CRYPTO_LEAP | CRYPTO_RESP:\n\t\t\t/*\n\t\t\t * Discard the message if invalid. We can't\n\t\t\t * compare the value timestamps here, as they\n\t\t\t * can be updated by different servers.\n\t\t\t */\n\t\t\trval = crypto_verify(ep, NULL, peer);\n\t\t\tif ((rval   != XEVNT_OK          ) ||\n\t\t\t    (vallen != 3*sizeof(uint32_t))  )\n\t\t\t\tbreak;\n\n\t\t\t/* Check if we can update the basic TAI offset\n\t\t\t * for our current leap frame. This is a hack\n\t\t\t * and ignores the time stamps in the autokey\n\t\t\t * message.\n\t\t\t */\n\t\t\tif (sys_leap != LEAP_NOTINSYNC)\n\t\t\t\tleapsec_autokey_tai(ntohl(ep->pkt[0]),\n\t\t\t\t\t\t    rbufp->recv_time.l_ui, NULL);\n\t\t\ttai_leap.tstamp = ep->tstamp;\n\t\t\ttai_leap.fstamp = ep->fstamp;\n\t\t\tcrypto_update();\n\t\t\tmprintf_event(EVNT_TAI, peer,\n\t\t\t\t      \"%d seconds\", ntohl(ep->pkt[0]));\n\t\t\tpeer->crypto |= CRYPTO_FLAG_LEAP;\n\t\t\tpeer->flash &= ~TEST8;\n\t\t\tsnprintf(statstr, sizeof(statstr),\n\t\t\t\t \"leap TAI offset %d at %u expire %u fs %u\",\n\t\t\t\t ntohl(ep->pkt[0]), ntohl(ep->pkt[1]),\n\t\t\t\t ntohl(ep->pkt[2]), ntohl(ep->fstamp));\n\t\t\trecord_crypto_stats(&peer->srcadr, statstr);\n\t\t\tDPRINTF(1, (\"crypto_recv: %s\\n\", statstr));\n\t\t\tbreak;\n\n\t\t/*\n\t\t * We come here in symmetric modes for miscellaneous\n\t\t * commands that have value fields but are processed on\n\t\t * the transmit side. All we need do here is check for\n\t\t * valid field length. Note that ASSOC is handled\n\t\t * separately.\n\t\t */\n\t\tcase CRYPTO_CERT:\n\t\tcase CRYPTO_IFF:\n\t\tcase CRYPTO_GQ:\n\t\tcase CRYPTO_MV:\n\t\tcase CRYPTO_COOK:\n\t\tcase CRYPTO_SIGN:\n\t\t\tif (len < VALUE_LEN) {\n\t\t\t\trval = XEVNT_LEN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fall through */\n\n\t\t/*\n\t\t * We come here in symmetric modes for requests\n\t\t * requiring a response (above plus AUTO and LEAP) and\n\t\t * for responses. If a request, save the extension field\n\t\t * for later; invalid requests will be caught on the\n\t\t * transmit side. If an error or invalid response,\n\t\t * declare a protocol error.\n\t\t */\n\t\tdefault:\n\t\t\tif (code & (CRYPTO_RESP | CRYPTO_ERROR)) {\n\t\t\t\trval = XEVNT_ERR;\n\t\t\t} else if (peer->cmmd == NULL) {\n\t\t\t\tfp = emalloc(len);\n\t\t\t\tmemcpy(fp, ep, len);\n\t\t\t\tpeer->cmmd = fp;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * The first error found terminates the extension field\n\t\t * scan and we return the laundry to the caller.\n\t\t */\n\t\tif (rval != XEVNT_OK) {\n\t\t\tsnprintf(statstr, sizeof(statstr),\n\t\t\t    \"%04x %d %02x %s\", htonl(ep->opcode),\n\t\t\t    associd, rval, eventstr(rval));\n\t\t\trecord_crypto_stats(&peer->srcadr, statstr);\n\t\t\tDPRINTF(1, (\"crypto_recv: %s\\n\", statstr));\n\t\t\treturn (rval);\n\t\t}\n\t\tauthlen += (len + 3) / 4 * 4;\n\t}\n\treturn (rval);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145313,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "crypto_xmit(\n\tstruct peer *peer,\t/* peer structure pointer */\n\tstruct pkt *xpkt,\t/* transmit packet pointer */\n\tstruct recvbuf *rbufp,\t/* receive buffer pointer */\n\tint\tstart,\t\t/* offset to extension field */\n\tstruct exten *ep,\t/* extension pointer */\n\tkeyid_t cookie\t\t/* session cookie */\n\t)\n{\n\tstruct exten *fp;\t/* extension pointers */\n\tstruct cert_info *cp, *xp, *yp; /* cert info/value pointer */\n\tsockaddr_u *srcadr_sin; /* source address */\n\tu_int32\t*pkt;\t\t/* packet pointer */\n\tu_int\topcode;\t\t/* extension field opcode */\n\tchar\tcertname[MAXHOSTNAME + 1]; /* subject name buffer */\n\tchar\tstatstr[NTP_MAXSTRLEN]; /* statistics for filegen */\n\ttstamp_t tstamp;\n\tstruct calendar tscal;\n\tu_int\tvallen;\n\tstruct value vtemp;\n\tassocid_t associd;\n\tint\trval;\n\tint\tlen;\n\tkeyid_t tcookie;\n\n\t/*\n\t * Generate the requested extension field request code, length\n\t * and association ID. If this is a response and the host is not\n\t * synchronized, light the error bit and go home.\n\t */\n\tpkt = (u_int32 *)xpkt + start / 4;\n\tfp = (struct exten *)pkt;\n\topcode = ntohl(ep->opcode);\n\tif (peer != NULL) {\n\t\tsrcadr_sin = &peer->srcadr;\n\t\tif (!(opcode & CRYPTO_RESP))\n\t\t\tpeer->opcode = ep->opcode;\n\t} else {\n\t\tsrcadr_sin = &rbufp->recv_srcadr;\n\t}\n\tassocid = (associd_t) ntohl(ep->associd);\n\tlen = 8;\n\tfp->opcode = htonl((opcode & 0xffff0000) | len);\n\tfp->associd = ep->associd;\n\trval = XEVNT_OK;\n\ttstamp = crypto_time();\n\tswitch (opcode & 0xffff0000) {\n\n\t/*\n\t * Send association request and response with status word and\n\t * host name. Note, this message is not signed and the filestamp\n\t * contains only the status word.\n\t */\n\tcase CRYPTO_ASSOC:\n\tcase CRYPTO_ASSOC | CRYPTO_RESP:\n\t\tlen = crypto_send(fp, &hostval, start);\n\t\tfp->fstamp = htonl(crypto_flags);\n\t\tbreak;\n\n\t/*\n\t * Send certificate request. Use the values from the extension\n\t * field.\n\t */\n\tcase CRYPTO_CERT:\n\t\tmemset(&vtemp, 0, sizeof(vtemp));\n\t\tvtemp.tstamp = ep->tstamp;\n\t\tvtemp.fstamp = ep->fstamp;\n\t\tvtemp.vallen = ep->vallen;\n\t\tvtemp.ptr = (u_char *)ep->pkt;\n\t\tlen = crypto_send(fp, &vtemp, start);\n\t\tbreak;\n\n\t/*\n\t * Send sign request. Use the host certificate, which is self-\n\t * signed and may or may not be trusted.\n\t */\n\tcase CRYPTO_SIGN:\n\t\t(void)ntpcal_ntp_to_date(&tscal, tstamp, NULL);\n\t\tif ((calcomp(&tscal, &(cert_host->first)) < 0)\n\t\t|| (calcomp(&tscal, &(cert_host->last)) > 0))\n\t\t\trval = XEVNT_PER;\n\t\telse\n\t\t\tlen = crypto_send(fp, &cert_host->cert, start);\n\t\tbreak;\n\n\t/*\n\t * Send certificate response. Use the name in the extension\n\t * field to find the certificate in the cache. If the request\n\t * contains no subject name, assume the name of this host. This\n\t * is for backwards compatibility. Private certificates are\n\t * never sent.\n\t *\n\t * There may be several certificates matching the request. First\n\t * choice is a self-signed trusted certificate; second choice is\n\t * any certificate signed by another host. There is no third\n\t * choice. \n\t */\n\tcase CRYPTO_CERT | CRYPTO_RESP:\n\t\tvallen = ntohl(ep->vallen);\t/* Must be <64k */\n\t\tif (vallen == 0 || vallen > MAXHOSTNAME ||\n\t\t    len - VALUE_LEN < vallen) {\n\t\t\trval = XEVNT_LEN;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Find all public valid certificates with matching\n\t\t * subject. If a self-signed, trusted certificate is\n\t\t * found, use that certificate. If not, use the last non\n\t\t * self-signed certificate.\n\t\t */\n\t\tmemcpy(certname, ep->pkt, vallen);\n\t\tcertname[vallen] = '\\0';\n\t\txp = yp = NULL;\n\t\tfor (cp = cinfo; cp != NULL; cp = cp->link) {\n\t\t\tif (cp->flags & (CERT_PRIV | CERT_ERROR))\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(certname, cp->subject) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(certname, cp->issuer) != 0)\n\t\t\t\typ = cp;\n\t\t\telse if (cp ->flags & CERT_TRUST)\n\t\t\t\txp = cp;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Be careful who you trust. If the certificate is not\n\t\t * found, return an empty response. Note that we dont\n\t\t * enforce lifetimes here.\n\t\t *\n\t\t * The timestamp and filestamp are taken from the\n\t\t * certificate value structure. For all certificates the\n\t\t * timestamp is the latest signature update time. For\n\t\t * host and imported certificates the filestamp is the\n\t\t * creation epoch. For signed certificates the filestamp\n\t\t * is the creation epoch of the trusted certificate at\n\t\t * the root of the certificate trail. In principle, this\n\t\t * allows strong checking for signature masquerade.\n\t\t */\n\t\tif (xp == NULL)\n\t\t\txp = yp;\n\t\tif (xp == NULL)\n\t\t\tbreak;\n\n\t\tif (tstamp == 0)\n\t\t\tbreak;\n\n\t\tlen = crypto_send(fp, &xp->cert, start);\n\t\tbreak;\n\n\t/*\n\t * Send challenge in Schnorr (IFF) identity scheme.\n\t */\n\tcase CRYPTO_IFF:\n\t\tif (peer == NULL)\n\t\t\tbreak;\t\t/* hack attack */\n\n\t\tif ((rval = crypto_alice(peer, &vtemp)) == XEVNT_OK) {\n\t\t\tlen = crypto_send(fp, &vtemp, start);\n\t\t\tvalue_free(&vtemp);\n\t\t}\n\t\tbreak;\n\n\t/*\n\t * Send response in Schnorr (IFF) identity scheme.\n\t */\n\tcase CRYPTO_IFF | CRYPTO_RESP:\n\t\tif ((rval = crypto_bob(ep, &vtemp)) == XEVNT_OK) {\n\t\t\tlen = crypto_send(fp, &vtemp, start);\n\t\t\tvalue_free(&vtemp);\n\t\t}\n\t\tbreak;\n\n\t/*\n\t * Send challenge in Guillou-Quisquater (GQ) identity scheme.\n\t */\n\tcase CRYPTO_GQ:\n\t\tif (peer == NULL)\n\t\t\tbreak;\t\t/* hack attack */\n\n\t\tif ((rval = crypto_alice2(peer, &vtemp)) == XEVNT_OK) {\n\t\t\tlen = crypto_send(fp, &vtemp, start);\n\t\t\tvalue_free(&vtemp);\n\t\t}\n\t\tbreak;\n\n\t/*\n\t * Send response in Guillou-Quisquater (GQ) identity scheme.\n\t */\n\tcase CRYPTO_GQ | CRYPTO_RESP:\n\t\tif ((rval = crypto_bob2(ep, &vtemp)) == XEVNT_OK) {\n\t\t\tlen = crypto_send(fp, &vtemp, start);\n\t\t\tvalue_free(&vtemp);\n\t\t}\n\t\tbreak;\n\n\t/*\n\t * Send challenge in MV identity scheme.\n\t */\n\tcase CRYPTO_MV:\n\t\tif (peer == NULL)\n\t\t\tbreak;\t\t/* hack attack */\n\n\t\tif ((rval = crypto_alice3(peer, &vtemp)) == XEVNT_OK) {\n\t\t\tlen = crypto_send(fp, &vtemp, start);\n\t\t\tvalue_free(&vtemp);\n\t\t}\n\t\tbreak;\n\n\t/*\n\t * Send response in MV identity scheme.\n\t */\n\tcase CRYPTO_MV | CRYPTO_RESP:\n\t\tif ((rval = crypto_bob3(ep, &vtemp)) == XEVNT_OK) {\n\t\t\tlen = crypto_send(fp, &vtemp, start);\n\t\t\tvalue_free(&vtemp);\n\t\t}\n\t\tbreak;\n\n\t/*\n\t * Send certificate sign response. The integrity of the request\n\t * certificate has already been verified on the receive side.\n\t * Sign the response using the local server key. Use the\n\t * filestamp from the request and use the timestamp as the\n\t * current time. Light the error bit if the certificate is\n\t * invalid or contains an unverified signature.\n\t */\n\tcase CRYPTO_SIGN | CRYPTO_RESP:\n\t\tif ((rval = cert_sign(ep, &vtemp)) == XEVNT_OK) {\n\t\t\tlen = crypto_send(fp, &vtemp, start);\n\t\t\tvalue_free(&vtemp);\n\t\t}\n\t\tbreak;\n\n\t/*\n\t * Send public key and signature. Use the values from the public\n\t * key.\n\t */\n\tcase CRYPTO_COOK:\n\t\tlen = crypto_send(fp, &pubkey, start);\n\t\tbreak;\n\n\t/*\n\t * Encrypt and send cookie and signature. Light the error bit if\n\t * anything goes wrong.\n\t */\n\tcase CRYPTO_COOK | CRYPTO_RESP:\n\t\tvallen = ntohl(ep->vallen);\t/* Must be <64k */\n\t\tif (   vallen == 0\n\t\t    || (vallen >= MAX_VALLEN)\n\t\t    || (opcode & 0x0000ffff)  < VALUE_LEN + vallen) {\n\t\t\trval = XEVNT_LEN;\n\t\t\tbreak;\n\t\t}\n\t\tif (peer == NULL)\n\t\t\ttcookie = cookie;\n\t\telse\n\t\t\ttcookie = peer->hcookie;\n\t\tif ((rval = crypto_encrypt((const u_char *)ep->pkt, vallen, &tcookie, &vtemp))\n\t\t    == XEVNT_OK) {\n\t\t\tlen = crypto_send(fp, &vtemp, start);\n\t\t\tvalue_free(&vtemp);\n\t\t}\n\t\tbreak;\n\n\t/*\n\t * Find peer and send autokey data and signature in broadcast\n\t * server and symmetric modes. Use the values in the autokey\n\t * structure. If no association is found, either the server has\n\t * restarted with new associations or some perp has replayed an\n\t * old message, in which case light the error bit.\n\t */\n\tcase CRYPTO_AUTO | CRYPTO_RESP:\n\t\tif (peer == NULL) {\n\t\t\tif ((peer = findpeerbyassoc(associd)) == NULL) {\n\t\t\t\trval = XEVNT_ERR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpeer->flags &= ~FLAG_ASSOC;\n\t\tlen = crypto_send(fp, &peer->sndval, start);\n\t\tbreak;\n\n\t/*\n\t * Send leapseconds values and signature. Use the values from\n\t * the tai structure. If no table has been loaded, just send an\n\t * empty request.\n\t */\n\tcase CRYPTO_LEAP | CRYPTO_RESP:\n\t\tlen = crypto_send(fp, &tai_leap, start);\n\t\tbreak;\n\n\t/*\n\t * Default - Send a valid command for unknown requests; send\n\t * an error response for unknown resonses.\n\t */\n\tdefault:\n\t\tif (opcode & CRYPTO_RESP)\n\t\t\trval = XEVNT_ERR;\n\t}\n\n\t/*\n\t * In case of error, flame the log. If a request, toss the\n\t * puppy; if a response, return so the sender can flame, too.\n\t */\n\tif (rval != XEVNT_OK) {\n\t\tu_int32\tuint32;\n\n\t\tuint32 = CRYPTO_ERROR;\n\t\topcode |= uint32;\n\t\tfp->opcode |= htonl(uint32);\n\t\tsnprintf(statstr, sizeof(statstr),\n\t\t    \"%04x %d %02x %s\", opcode, associd, rval,\n\t\t    eventstr(rval));\n\t\trecord_crypto_stats(srcadr_sin, statstr);\n\t\tDPRINTF(1, (\"crypto_xmit: %s\\n\", statstr));\n\t\tif (!(opcode & CRYPTO_RESP))\n\t\t\treturn (0);\n\t}\n\tDPRINTF(1, (\"crypto_xmit: flags 0x%x offset %d len %d code 0x%x associd %d\\n\",\n\t\t    crypto_flags, start, len, opcode >> 16, associd));\n\treturn (len);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145314,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "crypto_xmit(\n\tstruct peer *peer,\t/* peer structure pointer */\n\tstruct pkt *xpkt,\t/* transmit packet pointer */\n\tstruct recvbuf *rbufp,\t/* receive buffer pointer */\n\tint\tstart,\t\t/* offset to extension field */\n\tstruct exten *ep,\t/* extension pointer */\n\tkeyid_t cookie\t\t/* session cookie */\n\t)\n{\n\tstruct exten *fp;\t/* extension pointers */\n\tstruct cert_info *cp, *xp, *yp; /* cert info/value pointer */\n\tsockaddr_u *srcadr_sin; /* source address */\n\tu_int32\t*pkt;\t\t/* packet pointer */\n\tu_int\topcode;\t\t/* extension field opcode */\n\tchar\tcertname[MAXHOSTNAME + 1]; /* subject name buffer */\n\tchar\tstatstr[NTP_MAXSTRLEN]; /* statistics for filegen */\n\ttstamp_t tstamp;\n\tstruct calendar tscal;\n\tu_int\tvallen;\n\tstruct value vtemp;\n\tassocid_t associd;\n\tint\trval;\n\tint\tlen;\n\tkeyid_t tcookie;\n\n\t/*\n\t * Generate the requested extension field request code, length\n\t * and association ID. If this is a response and the host is not\n\t * synchronized, light the error bit and go home.\n\t */\n\tpkt = (u_int32 *)xpkt + start / 4;\n\tfp = (struct exten *)pkt;\n\topcode = ntohl(ep->opcode);\n\tif (peer != NULL) {\n\t\tsrcadr_sin = &peer->srcadr;\n\t\tif (!(opcode & CRYPTO_RESP))\n\t\t\tpeer->opcode = ep->opcode;\n\t} else {\n\t\tsrcadr_sin = &rbufp->recv_srcadr;\n\t}\n\tassocid = (associd_t) ntohl(ep->associd);\n\tlen = 8;\n\tfp->opcode = htonl((opcode & 0xffff0000) | len);\n\tfp->associd = ep->associd;\n\trval = XEVNT_OK;\n\ttstamp = crypto_time();\n\tswitch (opcode & 0xffff0000) {\n\n\t/*\n\t * Send association request and response with status word and\n\t * host name. Note, this message is not signed and the filestamp\n\t * contains only the status word.\n\t */\n\tcase CRYPTO_ASSOC:\n\tcase CRYPTO_ASSOC | CRYPTO_RESP:\n\t\tlen = crypto_send(fp, &hostval, start);\n\t\tfp->fstamp = htonl(crypto_flags);\n\t\tbreak;\n\n\t/*\n\t * Send certificate request. Use the values from the extension\n\t * field.\n\t */\n\tcase CRYPTO_CERT:\n\t\tmemset(&vtemp, 0, sizeof(vtemp));\n\t\tvtemp.tstamp = ep->tstamp;\n\t\tvtemp.fstamp = ep->fstamp;\n\t\tvtemp.vallen = ep->vallen;\n\t\tvtemp.ptr = (u_char *)ep->pkt;\n\t\tlen = crypto_send(fp, &vtemp, start);\n\t\tbreak;\n\n\t/*\n\t * Send sign request. Use the host certificate, which is self-\n\t * signed and may or may not be trusted.\n\t */\n\tcase CRYPTO_SIGN:\n\t\t(void)ntpcal_ntp_to_date(&tscal, tstamp, NULL);\n\t\tif ((calcomp(&tscal, &(cert_host->first)) < 0)\n\t\t|| (calcomp(&tscal, &(cert_host->last)) > 0))\n\t\t\trval = XEVNT_PER;\n\t\telse\n\t\t\tlen = crypto_send(fp, &cert_host->cert, start);\n\t\tbreak;\n\n\t/*\n\t * Send certificate response. Use the name in the extension\n\t * field to find the certificate in the cache. If the request\n\t * contains no subject name, assume the name of this host. This\n\t * is for backwards compatibility. Private certificates are\n\t * never sent.\n\t *\n\t * There may be several certificates matching the request. First\n\t * choice is a self-signed trusted certificate; second choice is\n\t * any certificate signed by another host. There is no third\n\t * choice. \n\t */\n\tcase CRYPTO_CERT | CRYPTO_RESP:\n\t\tvallen = exten_payload_size(ep); /* Must be <64k */\n\t\tif (vallen == 0 || vallen >= sizeof(certname) ) {\n\t\t\trval = XEVNT_LEN;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Find all public valid certificates with matching\n\t\t * subject. If a self-signed, trusted certificate is\n\t\t * found, use that certificate. If not, use the last non\n\t\t * self-signed certificate.\n\t\t */\n\t\tmemcpy(certname, ep->pkt, vallen);\n\t\tcertname[vallen] = '\\0';\n\t\txp = yp = NULL;\n\t\tfor (cp = cinfo; cp != NULL; cp = cp->link) {\n\t\t\tif (cp->flags & (CERT_PRIV | CERT_ERROR))\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(certname, cp->subject) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(certname, cp->issuer) != 0)\n\t\t\t\typ = cp;\n\t\t\telse if (cp ->flags & CERT_TRUST)\n\t\t\t\txp = cp;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Be careful who you trust. If the certificate is not\n\t\t * found, return an empty response. Note that we dont\n\t\t * enforce lifetimes here.\n\t\t *\n\t\t * The timestamp and filestamp are taken from the\n\t\t * certificate value structure. For all certificates the\n\t\t * timestamp is the latest signature update time. For\n\t\t * host and imported certificates the filestamp is the\n\t\t * creation epoch. For signed certificates the filestamp\n\t\t * is the creation epoch of the trusted certificate at\n\t\t * the root of the certificate trail. In principle, this\n\t\t * allows strong checking for signature masquerade.\n\t\t */\n\t\tif (xp == NULL)\n\t\t\txp = yp;\n\t\tif (xp == NULL)\n\t\t\tbreak;\n\n\t\tif (tstamp == 0)\n\t\t\tbreak;\n\n\t\tlen = crypto_send(fp, &xp->cert, start);\n\t\tbreak;\n\n\t/*\n\t * Send challenge in Schnorr (IFF) identity scheme.\n\t */\n\tcase CRYPTO_IFF:\n\t\tif (peer == NULL)\n\t\t\tbreak;\t\t/* hack attack */\n\n\t\tif ((rval = crypto_alice(peer, &vtemp)) == XEVNT_OK) {\n\t\t\tlen = crypto_send(fp, &vtemp, start);\n\t\t\tvalue_free(&vtemp);\n\t\t}\n\t\tbreak;\n\n\t/*\n\t * Send response in Schnorr (IFF) identity scheme.\n\t */\n\tcase CRYPTO_IFF | CRYPTO_RESP:\n\t\tif ((rval = crypto_bob(ep, &vtemp)) == XEVNT_OK) {\n\t\t\tlen = crypto_send(fp, &vtemp, start);\n\t\t\tvalue_free(&vtemp);\n\t\t}\n\t\tbreak;\n\n\t/*\n\t * Send challenge in Guillou-Quisquater (GQ) identity scheme.\n\t */\n\tcase CRYPTO_GQ:\n\t\tif (peer == NULL)\n\t\t\tbreak;\t\t/* hack attack */\n\n\t\tif ((rval = crypto_alice2(peer, &vtemp)) == XEVNT_OK) {\n\t\t\tlen = crypto_send(fp, &vtemp, start);\n\t\t\tvalue_free(&vtemp);\n\t\t}\n\t\tbreak;\n\n\t/*\n\t * Send response in Guillou-Quisquater (GQ) identity scheme.\n\t */\n\tcase CRYPTO_GQ | CRYPTO_RESP:\n\t\tif ((rval = crypto_bob2(ep, &vtemp)) == XEVNT_OK) {\n\t\t\tlen = crypto_send(fp, &vtemp, start);\n\t\t\tvalue_free(&vtemp);\n\t\t}\n\t\tbreak;\n\n\t/*\n\t * Send challenge in MV identity scheme.\n\t */\n\tcase CRYPTO_MV:\n\t\tif (peer == NULL)\n\t\t\tbreak;\t\t/* hack attack */\n\n\t\tif ((rval = crypto_alice3(peer, &vtemp)) == XEVNT_OK) {\n\t\t\tlen = crypto_send(fp, &vtemp, start);\n\t\t\tvalue_free(&vtemp);\n\t\t}\n\t\tbreak;\n\n\t/*\n\t * Send response in MV identity scheme.\n\t */\n\tcase CRYPTO_MV | CRYPTO_RESP:\n\t\tif ((rval = crypto_bob3(ep, &vtemp)) == XEVNT_OK) {\n\t\t\tlen = crypto_send(fp, &vtemp, start);\n\t\t\tvalue_free(&vtemp);\n\t\t}\n\t\tbreak;\n\n\t/*\n\t * Send certificate sign response. The integrity of the request\n\t * certificate has already been verified on the receive side.\n\t * Sign the response using the local server key. Use the\n\t * filestamp from the request and use the timestamp as the\n\t * current time. Light the error bit if the certificate is\n\t * invalid or contains an unverified signature.\n\t */\n\tcase CRYPTO_SIGN | CRYPTO_RESP:\n\t\tif ((rval = cert_sign(ep, &vtemp)) == XEVNT_OK) {\n\t\t\tlen = crypto_send(fp, &vtemp, start);\n\t\t\tvalue_free(&vtemp);\n\t\t}\n\t\tbreak;\n\n\t/*\n\t * Send public key and signature. Use the values from the public\n\t * key.\n\t */\n\tcase CRYPTO_COOK:\n\t\tlen = crypto_send(fp, &pubkey, start);\n\t\tbreak;\n\n\t/*\n\t * Encrypt and send cookie and signature. Light the error bit if\n\t * anything goes wrong.\n\t */\n\tcase CRYPTO_COOK | CRYPTO_RESP:\n\t\tvallen = ntohl(ep->vallen);\t/* Must be <64k */\n\t\tif (   vallen == 0\n\t\t    || (vallen >= MAX_VALLEN)\n\t\t    || (opcode & 0x0000ffff)  < VALUE_LEN + vallen) {\n\t\t\trval = XEVNT_LEN;\n\t\t\tbreak;\n\t\t}\n\t\tif (peer == NULL)\n\t\t\ttcookie = cookie;\n\t\telse\n\t\t\ttcookie = peer->hcookie;\n\t\tif ((rval = crypto_encrypt((const u_char *)ep->pkt, vallen, &tcookie, &vtemp))\n\t\t    == XEVNT_OK) {\n\t\t\tlen = crypto_send(fp, &vtemp, start);\n\t\t\tvalue_free(&vtemp);\n\t\t}\n\t\tbreak;\n\n\t/*\n\t * Find peer and send autokey data and signature in broadcast\n\t * server and symmetric modes. Use the values in the autokey\n\t * structure. If no association is found, either the server has\n\t * restarted with new associations or some perp has replayed an\n\t * old message, in which case light the error bit.\n\t */\n\tcase CRYPTO_AUTO | CRYPTO_RESP:\n\t\tif (peer == NULL) {\n\t\t\tif ((peer = findpeerbyassoc(associd)) == NULL) {\n\t\t\t\trval = XEVNT_ERR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpeer->flags &= ~FLAG_ASSOC;\n\t\tlen = crypto_send(fp, &peer->sndval, start);\n\t\tbreak;\n\n\t/*\n\t * Send leapseconds values and signature. Use the values from\n\t * the tai structure. If no table has been loaded, just send an\n\t * empty request.\n\t */\n\tcase CRYPTO_LEAP | CRYPTO_RESP:\n\t\tlen = crypto_send(fp, &tai_leap, start);\n\t\tbreak;\n\n\t/*\n\t * Default - Send a valid command for unknown requests; send\n\t * an error response for unknown resonses.\n\t */\n\tdefault:\n\t\tif (opcode & CRYPTO_RESP)\n\t\t\trval = XEVNT_ERR;\n\t}\n\n\t/*\n\t * In case of error, flame the log. If a request, toss the\n\t * puppy; if a response, return so the sender can flame, too.\n\t */\n\tif (rval != XEVNT_OK) {\n\t\tu_int32\tuint32;\n\n\t\tuint32 = CRYPTO_ERROR;\n\t\topcode |= uint32;\n\t\tfp->opcode |= htonl(uint32);\n\t\tsnprintf(statstr, sizeof(statstr),\n\t\t    \"%04x %d %02x %s\", opcode, associd, rval,\n\t\t    eventstr(rval));\n\t\trecord_crypto_stats(srcadr_sin, statstr);\n\t\tDPRINTF(1, (\"crypto_xmit: %s\\n\", statstr));\n\t\tif (!(opcode & CRYPTO_RESP))\n\t\t\treturn (0);\n\t}\n\tDPRINTF(1, (\"crypto_xmit: flags 0x%x offset %d len %d code 0x%x associd %d\\n\",\n\t\t    crypto_flags, start, len, opcode >> 16, associd));\n\treturn (len);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145315,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void manager_invoke_notify_message(Manager *m, Unit *u, pid_t pid, const char *buf, size_t n, FDSet *fds) {\n        _cleanup_strv_free_ char **tags = NULL;\n\n        assert(m);\n        assert(u);\n        assert(buf);\n        assert(n > 0);\n\n        tags = strv_split(buf, \"\\n\\r\");\n        if (!tags) {\n                log_oom();\n                return;\n        }\n\n        if (UNIT_VTABLE(u)->notify_message)\n                UNIT_VTABLE(u)->notify_message(u, pid, tags, fds);\n        else\n                log_unit_debug(u, \"Got notification message for unit. Ignoring.\");\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145338,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void manager_invoke_notify_message(Manager *m, Unit *u, pid_t pid, const char *buf, FDSet *fds) {\n        _cleanup_strv_free_ char **tags = NULL;\n\n        assert(m);\n        assert(u);\n        assert(buf);\n\n        tags = strv_split(buf, \"\\n\\r\");\n        if (!tags) {\n                log_oom();\n                return;\n        }\n\n        if (UNIT_VTABLE(u)->notify_message)\n                UNIT_VTABLE(u)->notify_message(u, pid, tags, fds);\n        else\n                log_unit_debug(u, \"Got notification message for unit. Ignoring.\");\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145339,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int ldb_kv_index_dn_attr(struct ldb_module *module,\n\t\t\t\tstruct ldb_kv_private *ldb_kv,\n\t\t\t\tconst char *attr,\n\t\t\t\tstruct ldb_dn *dn,\n\t\t\t\tstruct dn_list *list,\n\t\t\t\tenum key_truncation *truncation)\n{\n\tstruct ldb_context *ldb;\n\tstruct ldb_dn *key;\n\tstruct ldb_val val;\n\tint ret;\n\n\tldb = ldb_module_get_ctx(module);\n\n\t/* work out the index key from the parent DN */\n\tval.data = (uint8_t *)((uintptr_t)ldb_dn_get_casefold(dn));\n\tval.length = strlen((char *)val.data);\n\tkey = ldb_kv_index_key(ldb, ldb_kv, attr, &val, NULL, truncation);\n\tif (!key) {\n\t\tldb_oom(ldb);\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n\n\tret = ldb_kv_dn_list_load(module, ldb_kv, key, list);\n\ttalloc_free(key);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (list->count == 0) {\n\t\treturn LDB_ERR_NO_SUCH_OBJECT;\n\t}\n\n\treturn LDB_SUCCESS;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145344,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int ldb_kv_index_dn_attr(struct ldb_module *module,\n\t\t\t\tstruct ldb_kv_private *ldb_kv,\n\t\t\t\tconst char *attr,\n\t\t\t\tstruct ldb_dn *dn,\n\t\t\t\tstruct dn_list *list,\n\t\t\t\tenum key_truncation *truncation)\n{\n\tstruct ldb_context *ldb;\n\tstruct ldb_dn *key;\n\tstruct ldb_val val;\n\tint ret;\n\n\tldb = ldb_module_get_ctx(module);\n\n\t/* work out the index key from the parent DN */\n\tval.data = (uint8_t *)((uintptr_t)ldb_dn_get_casefold(dn));\n\tif (val.data == NULL) {\n\t\tconst char *dn_str = ldb_dn_get_linearized(dn);\n\t\tldb_asprintf_errstring(ldb_module_get_ctx(module),\n\t\t\t\t       __location__\n\t\t\t\t       \": Failed to get casefold DN \"\n\t\t\t\t       \"from: %s\",\n\t\t\t\t       dn_str);\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n\tval.length = strlen((char *)val.data);\n\tkey = ldb_kv_index_key(ldb, ldb_kv, attr, &val, NULL, truncation);\n\tif (!key) {\n\t\tldb_oom(ldb);\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n\n\tret = ldb_kv_dn_list_load(module, ldb_kv, key, list);\n\ttalloc_free(key);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (list->count == 0) {\n\t\treturn LDB_ERR_NO_SUCH_OBJECT;\n\t}\n\n\treturn LDB_SUCCESS;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145345,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "local int construct(struct huffman *h, boost::int16_t *length, int n)\n{\n    int symbol;         /* current symbol when stepping through length[] */\n    int len;            /* current length when stepping through h->count[] */\n    int left;           /* number of possible codes left of current length */\n\t boost::int16_t offs[MAXBITS+1];      /* offsets in symbol table for each length */\n\n    /* count number of codes of each length */\n    for (len = 0; len <= MAXBITS; len++)\n        h->count[len] = 0;\n    for (symbol = 0; symbol < n; symbol++)\n        (h->count[length[symbol]])++;   /* assumes lengths are within bounds */\n    if (h->count[0] == n)               /* no codes! */\n        return 0;                       /* complete, but decode() will fail */\n\n    /* check for an over-subscribed or incomplete set of lengths */\n    left = 1;                           /* one possible code of zero length */\n    for (len = 1; len <= MAXBITS; len++) {\n        left <<= 1;                     /* one more bit, double codes left */\n        left -= h->count[len];          /* deduct count from possible codes */\n        if (left < 0) return left;      /* over-subscribed--return negative */\n    }                                   /* left > 0 means incomplete */\n\n    /* generate offsets into symbol table for each length for sorting */\n    offs[1] = 0;\n    for (len = 1; len < MAXBITS; len++)\n        offs[len + 1] = offs[len] + h->count[len];\n\n    /*\n     * put symbols in table sorted by length, by symbol order within each\n     * length\n     */\n    for (symbol = 0; symbol < n; symbol++)\n        if (length[symbol] != 0)\n            h->symbol[offs[length[symbol]]++] = symbol;\n\n    /* return zero for complete set, positive for incomplete set */\n    return left;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145352,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "local int construct(struct huffman *h, const short *length, int n)\n{\n    int symbol;         /* current symbol when stepping through length[] */\n    int len;            /* current length when stepping through h->count[] */\n    int left;           /* number of possible codes left of current length */\n    short offs[MAXBITS+1];      /* offsets in symbol table for each length */\n\n    /* count number of codes of each length */\n    for (len = 0; len <= MAXBITS; len++)\n        h->count[len] = 0;\n    for (symbol = 0; symbol < n; symbol++)\n        (h->count[length[symbol]])++;   /* assumes lengths are within bounds */\n    if (h->count[0] == n)               /* no codes! */\n        return 0;                       /* complete, but decode() will fail */\n\n    /* check for an over-subscribed or incomplete set of lengths */\n    left = 1;                           /* one possible code of zero length */\n    for (len = 1; len <= MAXBITS; len++) {\n        left <<= 1;                     /* one more bit, double codes left */\n        left -= h->count[len];          /* deduct count from possible codes */\n        if (left < 0)\n            return left;                /* over-subscribed--return negative */\n    }                                   /* left > 0 means incomplete */\n\n    /* generate offsets into symbol table for each length for sorting */\n    offs[1] = 0;\n    for (len = 1; len < MAXBITS; len++)\n        offs[len + 1] = offs[len] + h->count[len];\n\n    /*\n     * put symbols in table sorted by length, by symbol order within each\n     * length\n     */\n    for (symbol = 0; symbol < n; symbol++)\n        if (length[symbol] != 0)\n            h->symbol[offs[length[symbol]]++] = symbol;\n\n    /* return zero for complete set, positive for incomplete set */\n    return left;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145353,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static size_t curl_read_cb(void *ptr, size_t size, size_t nmemb, void *opaque)\n{\n    CURLState *s = ((CURLState*)opaque);\n    size_t realsize = size * nmemb;\n    int i;\n\n    DPRINTF(\"CURL: Just reading %zd bytes\\n\", realsize);\n\n    if (!s || !s->orig_buf)\n        goto read_end;\n\n    memcpy(s->orig_buf + s->buf_off, ptr, realsize);\n    s->buf_off += realsize;\n\n    for(i=0; i<CURL_NUM_ACB; i++) {\n        CURLAIOCB *acb = s->acb[i];\n\n        if (!acb)\n            continue;\n\n        if ((s->buf_off >= acb->end)) {\n            qemu_iovec_from_buf(acb->qiov, 0, s->orig_buf + acb->start,\n                                acb->end - acb->start);\n            acb->common.cb(acb->common.opaque, 0);\n            qemu_aio_release(acb);\n            s->acb[i] = NULL;\n        }\n    }\n\nread_end:\n    return realsize;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145384,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static size_t curl_read_cb(void *ptr, size_t size, size_t nmemb, void *opaque)\n{\n    CURLState *s = ((CURLState*)opaque);\n    size_t realsize = size * nmemb;\n    int i;\n\n    DPRINTF(\"CURL: Just reading %zd bytes\\n\", realsize);\n\n    if (!s || !s->orig_buf)\n        goto read_end;\n\n    if (s->buf_off >= s->buf_len) {\n        /* buffer full, read nothing */\n        return 0;\n    }\n    realsize = MIN(realsize, s->buf_len - s->buf_off);\n    memcpy(s->orig_buf + s->buf_off, ptr, realsize);\n    s->buf_off += realsize;\n\n    for(i=0; i<CURL_NUM_ACB; i++) {\n        CURLAIOCB *acb = s->acb[i];\n\n        if (!acb)\n            continue;\n\n        if ((s->buf_off >= acb->end)) {\n            qemu_iovec_from_buf(acb->qiov, 0, s->orig_buf + acb->start,\n                                acb->end - acb->start);\n            acb->common.cb(acb->common.opaque, 0);\n            qemu_aio_release(acb);\n            s->acb[i] = NULL;\n        }\n    }\n\nread_end:\n    return realsize;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145385,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int amqp_handle_input(amqp_connection_state_t state, amqp_bytes_t received_data,\n                      amqp_frame_t *decoded_frame) {\n  size_t bytes_consumed;\n  void *raw_frame;\n\n  /* Returning frame_type of zero indicates either insufficient input,\n     or a complete, ignored frame was read. */\n  decoded_frame->frame_type = 0;\n\n  if (received_data.len == 0) {\n    return AMQP_STATUS_OK;\n  }\n\n  if (state->state == CONNECTION_STATE_IDLE) {\n    state->state = CONNECTION_STATE_HEADER;\n  }\n\n  bytes_consumed = consume_data(state, &received_data);\n\n  /* do we have target_size data yet? if not, return with the\n     expectation that more will arrive */\n  if (state->inbound_offset < state->target_size) {\n    return (int)bytes_consumed;\n  }\n\n  raw_frame = state->inbound_buffer.bytes;\n\n  switch (state->state) {\n    case CONNECTION_STATE_INITIAL:\n      /* check for a protocol header from the server */\n      if (memcmp(raw_frame, \"AMQP\", 4) == 0) {\n        decoded_frame->frame_type = AMQP_PSEUDOFRAME_PROTOCOL_HEADER;\n        decoded_frame->channel = 0;\n\n        decoded_frame->payload.protocol_header.transport_high =\n            amqp_d8(amqp_offset(raw_frame, 4));\n        decoded_frame->payload.protocol_header.transport_low =\n            amqp_d8(amqp_offset(raw_frame, 5));\n        decoded_frame->payload.protocol_header.protocol_version_major =\n            amqp_d8(amqp_offset(raw_frame, 6));\n        decoded_frame->payload.protocol_header.protocol_version_minor =\n            amqp_d8(amqp_offset(raw_frame, 7));\n\n        return_to_idle(state);\n        return (int)bytes_consumed;\n      }\n\n    /* it's not a protocol header; fall through to process it as a\n       regular frame header */\n\n    case CONNECTION_STATE_HEADER: {\n      amqp_channel_t channel;\n      amqp_pool_t *channel_pool;\n      /* frame length is 3 bytes in */\n      channel = amqp_d16(amqp_offset(raw_frame, 1));\n\n      state->target_size =\n          amqp_d32(amqp_offset(raw_frame, 3)) + HEADER_SIZE + FOOTER_SIZE;\n\n      if ((size_t)state->frame_max < state->target_size) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      channel_pool = amqp_get_or_create_channel_pool(state, channel);\n      if (NULL == channel_pool) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n\n      amqp_pool_alloc_bytes(channel_pool, state->target_size,\n                            &state->inbound_buffer);\n      if (NULL == state->inbound_buffer.bytes) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n      memcpy(state->inbound_buffer.bytes, state->header_buffer, HEADER_SIZE);\n      raw_frame = state->inbound_buffer.bytes;\n\n      state->state = CONNECTION_STATE_BODY;\n\n      bytes_consumed += consume_data(state, &received_data);\n\n      /* do we have target_size data yet? if not, return with the\n         expectation that more will arrive */\n      if (state->inbound_offset < state->target_size) {\n        return (int)bytes_consumed;\n      }\n    }\n    /* fall through to process body */\n\n    case CONNECTION_STATE_BODY: {\n      amqp_bytes_t encoded;\n      int res;\n      amqp_pool_t *channel_pool;\n\n      /* Check frame end marker (footer) */\n      if (amqp_d8(amqp_offset(raw_frame, state->target_size - 1)) !=\n          AMQP_FRAME_END) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      decoded_frame->frame_type = amqp_d8(amqp_offset(raw_frame, 0));\n      decoded_frame->channel = amqp_d16(amqp_offset(raw_frame, 1));\n\n      channel_pool =\n          amqp_get_or_create_channel_pool(state, decoded_frame->channel);\n      if (NULL == channel_pool) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n\n      switch (decoded_frame->frame_type) {\n        case AMQP_FRAME_METHOD:\n          decoded_frame->payload.method.id =\n              amqp_d32(amqp_offset(raw_frame, HEADER_SIZE));\n          encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 4);\n          encoded.len = state->target_size - HEADER_SIZE - 4 - FOOTER_SIZE;\n\n          res = amqp_decode_method(decoded_frame->payload.method.id,\n                                   channel_pool, encoded,\n                                   &decoded_frame->payload.method.decoded);\n          if (res < 0) {\n            return res;\n          }\n\n          break;\n\n        case AMQP_FRAME_HEADER:\n          decoded_frame->payload.properties.class_id =\n              amqp_d16(amqp_offset(raw_frame, HEADER_SIZE));\n          /* unused 2-byte weight field goes here */\n          decoded_frame->payload.properties.body_size =\n              amqp_d64(amqp_offset(raw_frame, HEADER_SIZE + 4));\n          encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 12);\n          encoded.len = state->target_size - HEADER_SIZE - 12 - FOOTER_SIZE;\n          decoded_frame->payload.properties.raw = encoded;\n\n          res = amqp_decode_properties(\n              decoded_frame->payload.properties.class_id, channel_pool, encoded,\n              &decoded_frame->payload.properties.decoded);\n          if (res < 0) {\n            return res;\n          }\n\n          break;\n\n        case AMQP_FRAME_BODY:\n          decoded_frame->payload.body_fragment.len =\n              state->target_size - HEADER_SIZE - FOOTER_SIZE;\n          decoded_frame->payload.body_fragment.bytes =\n              amqp_offset(raw_frame, HEADER_SIZE);\n          break;\n\n        case AMQP_FRAME_HEARTBEAT:\n          break;\n\n        default:\n          /* Ignore the frame */\n          decoded_frame->frame_type = 0;\n          break;\n      }\n\n      return_to_idle(state);\n      return (int)bytes_consumed;\n    }\n\n    default:\n      amqp_abort(\"Internal error: invalid amqp_connection_state_t->state %d\",\n                 state->state);\n  }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145386,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int amqp_handle_input(amqp_connection_state_t state, amqp_bytes_t received_data,\n                      amqp_frame_t *decoded_frame) {\n  size_t bytes_consumed;\n  void *raw_frame;\n\n  /* Returning frame_type of zero indicates either insufficient input,\n     or a complete, ignored frame was read. */\n  decoded_frame->frame_type = 0;\n\n  if (received_data.len == 0) {\n    return AMQP_STATUS_OK;\n  }\n\n  if (state->state == CONNECTION_STATE_IDLE) {\n    state->state = CONNECTION_STATE_HEADER;\n  }\n\n  bytes_consumed = consume_data(state, &received_data);\n\n  /* do we have target_size data yet? if not, return with the\n     expectation that more will arrive */\n  if (state->inbound_offset < state->target_size) {\n    return (int)bytes_consumed;\n  }\n\n  raw_frame = state->inbound_buffer.bytes;\n\n  switch (state->state) {\n    case CONNECTION_STATE_INITIAL:\n      /* check for a protocol header from the server */\n      if (memcmp(raw_frame, \"AMQP\", 4) == 0) {\n        decoded_frame->frame_type = AMQP_PSEUDOFRAME_PROTOCOL_HEADER;\n        decoded_frame->channel = 0;\n\n        decoded_frame->payload.protocol_header.transport_high =\n            amqp_d8(amqp_offset(raw_frame, 4));\n        decoded_frame->payload.protocol_header.transport_low =\n            amqp_d8(amqp_offset(raw_frame, 5));\n        decoded_frame->payload.protocol_header.protocol_version_major =\n            amqp_d8(amqp_offset(raw_frame, 6));\n        decoded_frame->payload.protocol_header.protocol_version_minor =\n            amqp_d8(amqp_offset(raw_frame, 7));\n\n        return_to_idle(state);\n        return (int)bytes_consumed;\n      }\n\n    /* it's not a protocol header; fall through to process it as a\n       regular frame header */\n\n    case CONNECTION_STATE_HEADER: {\n      amqp_channel_t channel;\n      amqp_pool_t *channel_pool;\n      uint32_t frame_size;\n\n      channel = amqp_d16(amqp_offset(raw_frame, 1));\n\n      /* frame length is 3 bytes in */\n      frame_size = amqp_d32(amqp_offset(raw_frame, 3));\n      /* To prevent the target_size calculation below from overflowing, check\n       * that the stated frame_size is smaller than a signed 32-bit. Given\n       * the library only allows configuring frame_max as an int32_t, and\n       * frame_size is uint32_t, the math below is safe from overflow. */\n      if (frame_size >= INT32_MAX) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      state->target_size = frame_size + HEADER_SIZE + FOOTER_SIZE;\n      if ((size_t)state->frame_max < state->target_size) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      channel_pool = amqp_get_or_create_channel_pool(state, channel);\n      if (NULL == channel_pool) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n\n      amqp_pool_alloc_bytes(channel_pool, state->target_size,\n                            &state->inbound_buffer);\n      if (NULL == state->inbound_buffer.bytes) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n      memcpy(state->inbound_buffer.bytes, state->header_buffer, HEADER_SIZE);\n      raw_frame = state->inbound_buffer.bytes;\n\n      state->state = CONNECTION_STATE_BODY;\n\n      bytes_consumed += consume_data(state, &received_data);\n\n      /* do we have target_size data yet? if not, return with the\n         expectation that more will arrive */\n      if (state->inbound_offset < state->target_size) {\n        return (int)bytes_consumed;\n      }\n    }\n    /* fall through to process body */\n\n    case CONNECTION_STATE_BODY: {\n      amqp_bytes_t encoded;\n      int res;\n      amqp_pool_t *channel_pool;\n\n      /* Check frame end marker (footer) */\n      if (amqp_d8(amqp_offset(raw_frame, state->target_size - 1)) !=\n          AMQP_FRAME_END) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      decoded_frame->frame_type = amqp_d8(amqp_offset(raw_frame, 0));\n      decoded_frame->channel = amqp_d16(amqp_offset(raw_frame, 1));\n\n      channel_pool =\n          amqp_get_or_create_channel_pool(state, decoded_frame->channel);\n      if (NULL == channel_pool) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n\n      switch (decoded_frame->frame_type) {\n        case AMQP_FRAME_METHOD:\n          decoded_frame->payload.method.id =\n              amqp_d32(amqp_offset(raw_frame, HEADER_SIZE));\n          encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 4);\n          encoded.len = state->target_size - HEADER_SIZE - 4 - FOOTER_SIZE;\n\n          res = amqp_decode_method(decoded_frame->payload.method.id,\n                                   channel_pool, encoded,\n                                   &decoded_frame->payload.method.decoded);\n          if (res < 0) {\n            return res;\n          }\n\n          break;\n\n        case AMQP_FRAME_HEADER:\n          decoded_frame->payload.properties.class_id =\n              amqp_d16(amqp_offset(raw_frame, HEADER_SIZE));\n          /* unused 2-byte weight field goes here */\n          decoded_frame->payload.properties.body_size =\n              amqp_d64(amqp_offset(raw_frame, HEADER_SIZE + 4));\n          encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 12);\n          encoded.len = state->target_size - HEADER_SIZE - 12 - FOOTER_SIZE;\n          decoded_frame->payload.properties.raw = encoded;\n\n          res = amqp_decode_properties(\n              decoded_frame->payload.properties.class_id, channel_pool, encoded,\n              &decoded_frame->payload.properties.decoded);\n          if (res < 0) {\n            return res;\n          }\n\n          break;\n\n        case AMQP_FRAME_BODY:\n          decoded_frame->payload.body_fragment.len =\n              state->target_size - HEADER_SIZE - FOOTER_SIZE;\n          decoded_frame->payload.body_fragment.bytes =\n              amqp_offset(raw_frame, HEADER_SIZE);\n          break;\n\n        case AMQP_FRAME_HEARTBEAT:\n          break;\n\n        default:\n          /* Ignore the frame */\n          decoded_frame->frame_type = 0;\n          break;\n      }\n\n      return_to_idle(state);\n      return (int)bytes_consumed;\n    }\n\n    default:\n      amqp_abort(\"Internal error: invalid amqp_connection_state_t->state %d\",\n                 state->state);\n  }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145387,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "Status renameCollectionForApplyOps(OperationContext* opCtx,\n                                   const std::string& dbName,\n                                   const BSONElement& ui,\n                                   const BSONObj& cmd,\n                                   const repl::OpTime& renameOpTime) {\n\n    const auto sourceNsElt = cmd.firstElement();\n    const auto targetNsElt = cmd[\"to\"];\n    uassert(ErrorCodes::TypeMismatch,\n            \"'renameCollection' must be of type String\",\n            sourceNsElt.type() == BSONType::String);\n    uassert(ErrorCodes::TypeMismatch,\n            \"'to' must be of type String\",\n            targetNsElt.type() == BSONType::String);\n\n    NamespaceString sourceNss(sourceNsElt.valueStringData());\n    NamespaceString targetNss(targetNsElt.valueStringData());\n    NamespaceString uiNss(getNamespaceFromUUIDElement(opCtx, ui));\n\n    if ((repl::ReplicationCoordinator::get(opCtx)->getReplicationMode() ==\n         repl::ReplicationCoordinator::modeNone) &&\n        targetNss.isOplog()) {\n        return Status(ErrorCodes::IllegalOperation,\n                      str::stream() << \"Cannot rename collection to the oplog\");\n    }\n\n    // If the UUID we're targeting already exists, rename from there no matter what.\n    if (!uiNss.isEmpty()) {\n        sourceNss = uiNss;\n    }\n\n    OptionalCollectionUUID targetUUID;\n    if (!ui.eoo())\n        targetUUID = uassertStatusOK(UUID::parse(ui));\n\n    RenameCollectionOptions options;\n    options.dropTarget = cmd[\"dropTarget\"].trueValue();\n    if (cmd[\"dropTarget\"].type() == BinData) {\n        auto uuid = uassertStatusOK(UUID::parse(cmd[\"dropTarget\"]));\n        options.dropTargetUUID = uuid;\n    }\n\n    const Collection* const sourceColl =\n        AutoGetCollectionForRead(opCtx, sourceNss, AutoGetCollection::ViewMode::kViewsPermitted)\n            .getCollection();\n\n    if (sourceNss.isDropPendingNamespace() || sourceColl == nullptr) {\n        NamespaceString dropTargetNss;\n\n        if (options.dropTarget)\n            dropTargetNss = targetNss;\n\n        if (options.dropTargetUUID) {\n            dropTargetNss = getNamespaceFromUUID(opCtx, options.dropTargetUUID.get());\n        }\n\n        // Downgrade renameCollection to dropCollection.\n        if (!dropTargetNss.isEmpty()) {\n            BSONObjBuilder unusedResult;\n            return dropCollection(opCtx,\n                                  dropTargetNss,\n                                  unusedResult,\n                                  renameOpTime,\n                                  DropCollectionSystemCollectionMode::kAllowSystemCollectionDrops);\n        }\n\n        return Status(ErrorCodes::NamespaceNotFound,\n                      str::stream()\n                          << \"renameCollection() cannot accept a source \"\n                             \"collection that does not exist or is in a drop-pending state: \"\n                          << sourceNss.toString());\n    }\n\n    const std::string dropTargetMsg =\n        options.dropTargetUUID ? \" and drop \" + options.dropTargetUUID->toString() + \".\" : \".\";\n    const std::string uuidString = targetUUID ? targetUUID->toString() : \"UUID unknown\";\n    log() << \"renameCollectionForApplyOps: rename \" << sourceNss << \" (\" << uuidString << \") to \"\n          << targetNss << dropTargetMsg;\n\n    options.stayTemp = cmd[\"stayTemp\"].trueValue();\n    return renameCollectionCommon(opCtx, sourceNss, targetNss, targetUUID, renameOpTime, options);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145406,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "Status renameCollectionForApplyOps(OperationContext* opCtx,\n                                   const std::string& dbName,\n                                   const BSONElement& ui,\n                                   const BSONObj& cmd,\n                                   const repl::OpTime& renameOpTime) {\n\n    const auto sourceNsElt = cmd.firstElement();\n    const auto targetNsElt = cmd[\"to\"];\n    uassert(ErrorCodes::TypeMismatch,\n            \"'renameCollection' must be of type String\",\n            sourceNsElt.type() == BSONType::String);\n    uassert(ErrorCodes::TypeMismatch,\n            \"'to' must be of type String\",\n            targetNsElt.type() == BSONType::String);\n\n    NamespaceString sourceNss(sourceNsElt.valueStringData());\n    NamespaceString targetNss(targetNsElt.valueStringData());\n    NamespaceString uiNss(getNamespaceFromUUIDElement(opCtx, ui));\n\n    if ((repl::ReplicationCoordinator::get(opCtx)->getReplicationMode() ==\n         repl::ReplicationCoordinator::modeNone) &&\n        targetNss.isOplog()) {\n        return Status(ErrorCodes::IllegalOperation,\n                      str::stream() << \"Cannot rename collection to the oplog\");\n    }\n\n    // If the UUID we're targeting already exists, rename from there no matter what.\n    if (!uiNss.isEmpty()) {\n        sourceNss = uiNss;\n    }\n\n    // Check that the target namespace is in the correct form, \"database.collection\".\n    auto targetStatus = userAllowedWriteNS(targetNss);\n    if (!targetStatus.isOK()) {\n        return Status(targetStatus.code(),\n                      str::stream() << \"error with target namespace: \" << targetStatus.reason());\n    }\n\n    OptionalCollectionUUID targetUUID;\n    if (!ui.eoo())\n        targetUUID = uassertStatusOK(UUID::parse(ui));\n\n    RenameCollectionOptions options;\n    options.dropTarget = cmd[\"dropTarget\"].trueValue();\n    if (cmd[\"dropTarget\"].type() == BinData) {\n        auto uuid = uassertStatusOK(UUID::parse(cmd[\"dropTarget\"]));\n        options.dropTargetUUID = uuid;\n    }\n\n    const Collection* const sourceColl =\n        AutoGetCollectionForRead(opCtx, sourceNss, AutoGetCollection::ViewMode::kViewsPermitted)\n            .getCollection();\n\n    if (sourceNss.isDropPendingNamespace() || sourceColl == nullptr) {\n        NamespaceString dropTargetNss;\n\n        if (options.dropTarget)\n            dropTargetNss = targetNss;\n\n        if (options.dropTargetUUID) {\n            dropTargetNss = getNamespaceFromUUID(opCtx, options.dropTargetUUID.get());\n        }\n\n        // Downgrade renameCollection to dropCollection.\n        if (!dropTargetNss.isEmpty()) {\n            BSONObjBuilder unusedResult;\n            return dropCollection(opCtx,\n                                  dropTargetNss,\n                                  unusedResult,\n                                  renameOpTime,\n                                  DropCollectionSystemCollectionMode::kAllowSystemCollectionDrops);\n        }\n\n        return Status(ErrorCodes::NamespaceNotFound,\n                      str::stream()\n                          << \"renameCollection() cannot accept a source \"\n                             \"collection that does not exist or is in a drop-pending state: \"\n                          << sourceNss.toString());\n    }\n\n    const std::string dropTargetMsg =\n        options.dropTargetUUID ? \" and drop \" + options.dropTargetUUID->toString() + \".\" : \".\";\n    const std::string uuidString = targetUUID ? targetUUID->toString() : \"UUID unknown\";\n    log() << \"renameCollectionForApplyOps: rename \" << sourceNss << \" (\" << uuidString << \") to \"\n          << targetNss << dropTargetMsg;\n\n    options.stayTemp = cmd[\"stayTemp\"].trueValue();\n    return renameCollectionCommon(opCtx, sourceNss, targetNss, targetUUID, renameOpTime, options);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145407,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static struct tevent_req *dns_process_send(TALLOC_CTX *mem_ctx,\n\t\t\t\t\t   struct tevent_context *ev,\n\t\t\t\t\t   struct dns_server *dns,\n\t\t\t\t\t   DATA_BLOB *in)\n{\n\tstruct tevent_req *req, *subreq;\n\tstruct dns_process_state *state;\n\tenum ndr_err_code ndr_err;\n\tWERROR ret;\n\tconst char *forwarder = lpcfg_dns_forwarder(dns->task->lp_ctx);\n\treq = tevent_req_create(mem_ctx, &state, struct dns_process_state);\n\tif (req == NULL) {\n\t\treturn NULL;\n\t}\n\tstate->in = in;\n\n\tstate->dns = dns;\n\n\tif (in->length < 12) {\n\t\ttevent_req_werror(req, WERR_INVALID_PARAM);\n\t\treturn tevent_req_post(req, ev);\n\t}\n\tdump_data_dbgc(DBGC_DNS, 8, in->data, in->length);\n\n\tndr_err = ndr_pull_struct_blob(\n\t\tin, state, &state->in_packet,\n\t\t(ndr_pull_flags_fn_t)ndr_pull_dns_name_packet);\n\n\tif (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {\n\t\tstate->dns_err = DNS_RCODE_FORMERR;\n\t\ttevent_req_done(req);\n\t\treturn tevent_req_post(req, ev);\n\t}\n\tif (DEBUGLVLC(DBGC_DNS, 8)) {\n\t\tNDR_PRINT_DEBUGC(DBGC_DNS, dns_name_packet, &state->in_packet);\n\t}\n\n\tret = dns_verify_tsig(dns, state, &state->state, &state->in_packet, in);\n\tif (!W_ERROR_IS_OK(ret)) {\n\t\tDEBUG(1, (\"Failed to verify TSIG!\\n\"));\n\t\tstate->dns_err = werr_to_dns_err(ret);\n\t\ttevent_req_done(req);\n\t\treturn tevent_req_post(req, ev);\n\t}\n\n\tstate->state.flags = state->in_packet.operation;\n\tstate->state.flags |= DNS_FLAG_REPLY;\n\n\t\n\tif (forwarder && *forwarder) {\n\t\tstate->state.flags |= DNS_FLAG_RECURSION_AVAIL;\n\t}\n\n\tstate->out_packet = state->in_packet;\n\n\tswitch (state->in_packet.operation & DNS_OPCODE) {\n\tcase DNS_OPCODE_QUERY:\n\t\tsubreq = dns_server_process_query_send(\n\t\t\tstate, ev, dns, &state->state, &state->in_packet);\n\t\tif (tevent_req_nomem(subreq, req)) {\n\t\t\treturn tevent_req_post(req, ev);\n\t\t}\n\t\ttevent_req_set_callback(subreq, dns_process_done, req);\n\t\treturn req;\n\tcase DNS_OPCODE_UPDATE:\n\t\tret = dns_server_process_update(\n\t\t\tdns, &state->state, state, &state->in_packet,\n\t\t\t&state->out_packet.answers, &state->out_packet.ancount,\n\t\t\t&state->out_packet.nsrecs,  &state->out_packet.nscount,\n\t\t\t&state->out_packet.additional,\n\t\t\t&state->out_packet.arcount);\n\t\tbreak;\n\tdefault:\n\t\tret = WERR_DNS_ERROR_RCODE_NOT_IMPLEMENTED;\n\t}\n\tif (!W_ERROR_IS_OK(ret)) {\n\t\tstate->dns_err = werr_to_dns_err(ret);\n\t}\n\ttevent_req_done(req);\n\treturn tevent_req_post(req, ev);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145462,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static struct tevent_req *dns_process_send(TALLOC_CTX *mem_ctx,\n\t\t\t\t\t   struct tevent_context *ev,\n\t\t\t\t\t   struct dns_server *dns,\n\t\t\t\t\t   DATA_BLOB *in)\n{\n\tstruct tevent_req *req, *subreq;\n\tstruct dns_process_state *state;\n\tenum ndr_err_code ndr_err;\n\tWERROR ret;\n\tconst char *forwarder = lpcfg_dns_forwarder(dns->task->lp_ctx);\n\treq = tevent_req_create(mem_ctx, &state, struct dns_process_state);\n\tif (req == NULL) {\n\t\treturn NULL;\n\t}\n\tstate->in = in;\n\n\tstate->dns = dns;\n\n\tif (in->length < 12) {\n\t\ttevent_req_werror(req, WERR_INVALID_PARAM);\n\t\treturn tevent_req_post(req, ev);\n\t}\n\tdump_data_dbgc(DBGC_DNS, 8, in->data, in->length);\n\n\tndr_err = ndr_pull_struct_blob(\n\t\tin, state, &state->in_packet,\n\t\t(ndr_pull_flags_fn_t)ndr_pull_dns_name_packet);\n\n\tif (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {\n\t\tstate->dns_err = DNS_RCODE_FORMERR;\n\t\ttevent_req_done(req);\n\t\treturn tevent_req_post(req, ev);\n\t}\n\tif (DEBUGLVLC(DBGC_DNS, 8)) {\n\t\tNDR_PRINT_DEBUGC(DBGC_DNS, dns_name_packet, &state->in_packet);\n\t}\n\n\tret = dns_verify_tsig(dns, state, &state->state, &state->in_packet, in);\n\tif (!W_ERROR_IS_OK(ret)) {\n\t\tDEBUG(1, (\"Failed to verify TSIG!\\n\"));\n\t\tstate->dns_err = werr_to_dns_err(ret);\n\t\ttevent_req_done(req);\n\t\treturn tevent_req_post(req, ev);\n\t}\n\n\tif (state->in_packet.operation & DNS_FLAG_REPLY) {\n\t\tDEBUG(1, (\"Won't reply to replies.\\n\"));\n\t\ttevent_req_werror(req, WERR_INVALID_PARAM);\n\t\treturn tevent_req_post(req, ev);\n\t}\n\n\tstate->state.flags = state->in_packet.operation;\n\tstate->state.flags |= DNS_FLAG_REPLY;\n\n\t\n\tif (forwarder && *forwarder) {\n\t\tstate->state.flags |= DNS_FLAG_RECURSION_AVAIL;\n\t}\n\n\tstate->out_packet = state->in_packet;\n\n\tswitch (state->in_packet.operation & DNS_OPCODE) {\n\tcase DNS_OPCODE_QUERY:\n\t\tsubreq = dns_server_process_query_send(\n\t\t\tstate, ev, dns, &state->state, &state->in_packet);\n\t\tif (tevent_req_nomem(subreq, req)) {\n\t\t\treturn tevent_req_post(req, ev);\n\t\t}\n\t\ttevent_req_set_callback(subreq, dns_process_done, req);\n\t\treturn req;\n\tcase DNS_OPCODE_UPDATE:\n\t\tret = dns_server_process_update(\n\t\t\tdns, &state->state, state, &state->in_packet,\n\t\t\t&state->out_packet.answers, &state->out_packet.ancount,\n\t\t\t&state->out_packet.nsrecs,  &state->out_packet.nscount,\n\t\t\t&state->out_packet.additional,\n\t\t\t&state->out_packet.arcount);\n\t\tbreak;\n\tdefault:\n\t\tret = WERR_DNS_ERROR_RCODE_NOT_IMPLEMENTED;\n\t}\n\tif (!W_ERROR_IS_OK(ret)) {\n\t\tstate->dns_err = werr_to_dns_err(ret);\n\t}\n\ttevent_req_done(req);\n\treturn tevent_req_post(req, ev);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145463,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "privsep_read_loop(void)\n{\n\tstruct privsep_command cmd;\n\tint ret;\n\n\twhile (1) {\n\t\tret = readn(pfd, &cmd, sizeof(cmd));\n\t\tif (ret <= 0) {\n\t\t\t/* Error or EOF, give up */\n\t\t\tif (ret < 0) {\n\t\t\t\tflog(LOG_ERR, \"Exiting, privsep_read_loop had readn error: %s\\n\",\n\t\t\t\t     strerror(errno));\n\t\t\t} else {\n\t\t\t\tflog(LOG_ERR, \"Exiting, privsep_read_loop had readn return 0 bytes\\n\");\n\t\t\t}\n\t\t\tclose(pfd);\n\t\t\t_exit(0);\n\t\t}\n\t\tif (ret != sizeof(cmd)) {\n\t\t\t/* Short read, ignore */\n\t\t\tcontinue;\n\t\t}\n\n\t\tcmd.iface[IFNAMSIZ-1] = '\\0';\n\n\t\tswitch(cmd.type) {\n\n\t\tcase SET_INTERFACE_LINKMTU:\n\t\t\tif (cmd.val < MIN_AdvLinkMTU || cmd.val > MAX_AdvLinkMTU) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: LinkMTU (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_LINKMTU, \"LinkMTU\", cmd.val);\n\t\t\tbreak;\n\n\t\tcase SET_INTERFACE_CURHLIM:\n\t\t\tif (cmd.val < MIN_AdvCurHopLimit || cmd.val > MAX_AdvCurHopLimit) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: CurHopLimit (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_CURHLIM, \"CurHopLimit\", cmd.val);\n\t\t\tbreak;\n\n\t\tcase SET_INTERFACE_REACHTIME:\n\t\t\tif (cmd.val < MIN_AdvReachableTime || cmd.val > MAX_AdvReachableTime) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: BaseReachableTimer (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_BASEREACHTIME_MS, \"BaseReachableTimer (ms)\", cmd.val);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tset_interface_var(cmd.iface, PROC_SYS_IP6_BASEREACHTIME, \"BaseReachableTimer\", cmd.val / 1000);\n\t\t\tbreak;\n\n\t\tcase SET_INTERFACE_RETRANSTIMER:\n\t\t\tif (cmd.val < MIN_AdvRetransTimer || cmd.val > MAX_AdvRetransTimer) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: RetransTimer (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_RETRANSTIMER_MS, \"RetransTimer (ms)\", cmd.val);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tset_interface_var(cmd.iface, PROC_SYS_IP6_RETRANSTIMER, \"RetransTimer\", cmd.val / 1000 * USER_HZ); /* XXX user_hz */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Bad command */\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145464,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "privsep_read_loop(void)\n{\n\tstruct privsep_command cmd;\n\tint ret;\n\n\twhile (1) {\n\t\tret = readn(pfd, &cmd, sizeof(cmd));\n\t\tif (ret <= 0) {\n\t\t\t/* Error or EOF, give up */\n\t\t\tif (ret < 0) {\n\t\t\t\tflog(LOG_ERR, \"Exiting, privsep_read_loop had readn error: %s\\n\",\n\t\t\t\t     strerror(errno));\n\t\t\t} else {\n\t\t\t\tflog(LOG_ERR, \"Exiting, privsep_read_loop had readn return 0 bytes\\n\");\n\t\t\t}\n\t\t\tclose(pfd);\n\t\t\t_exit(0);\n\t\t}\n\t\tif (ret != sizeof(cmd)) {\n\t\t\t/* Short read, ignore */\n\t\t\treturn;\n\t\t}\n\n\t\tcmd.iface[IFNAMSIZ-1] = '\\0';\n\n\t\tswitch(cmd.type) {\n\n\t\tcase SET_INTERFACE_LINKMTU:\n\t\t\tif (cmd.val < MIN_AdvLinkMTU || cmd.val > MAX_AdvLinkMTU) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: LinkMTU (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_LINKMTU, \"LinkMTU\", cmd.val);\n\t\t\tbreak;\n\n\t\tcase SET_INTERFACE_CURHLIM:\n\t\t\tif (cmd.val < MIN_AdvCurHopLimit || cmd.val > MAX_AdvCurHopLimit) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: CurHopLimit (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_CURHLIM, \"CurHopLimit\", cmd.val);\n\t\t\tbreak;\n\n\t\tcase SET_INTERFACE_REACHTIME:\n\t\t\tif (cmd.val < MIN_AdvReachableTime || cmd.val > MAX_AdvReachableTime) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: BaseReachableTimer (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_BASEREACHTIME_MS, \"BaseReachableTimer (ms)\", cmd.val);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tset_interface_var(cmd.iface, PROC_SYS_IP6_BASEREACHTIME, \"BaseReachableTimer\", cmd.val / 1000);\n\t\t\tbreak;\n\n\t\tcase SET_INTERFACE_RETRANSTIMER:\n\t\t\tif (cmd.val < MIN_AdvRetransTimer || cmd.val > MAX_AdvRetransTimer) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: RetransTimer (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_RETRANSTIMER_MS, \"RetransTimer (ms)\", cmd.val);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tset_interface_var(cmd.iface, PROC_SYS_IP6_RETRANSTIMER, \"RetransTimer\", cmd.val / 1000 * USER_HZ); /* XXX user_hz */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Bad command */\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145465,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "rsock_init_unixsock(VALUE sock, VALUE path, int server)\n{\n    struct sockaddr_un sockaddr;\n    socklen_t sockaddrlen;\n    int fd, status;\n    rb_io_t *fptr;\n\n    FilePathValue(path);\n\n    INIT_SOCKADDR_UN(&sockaddr, sizeof(struct sockaddr_un));\n    if (sizeof(sockaddr.sun_path) < (size_t)RSTRING_LEN(path)) {\n        rb_raise(rb_eArgError, \"too long unix socket path (%ldbytes given but %dbytes max)\",\n            RSTRING_LEN(path), (int)sizeof(sockaddr.sun_path));\n    }\n    memcpy(sockaddr.sun_path, RSTRING_PTR(path), RSTRING_LEN(path));\n    sockaddrlen = rsock_unix_sockaddr_len(path);\n\n    fd = rsock_socket(AF_UNIX, SOCK_STREAM, 0);\n    if (fd < 0) {\n\trsock_sys_fail_path(\"socket(2)\", path);\n    }\n\n    if (server) {\n        status = bind(fd, (struct sockaddr*)&sockaddr, sockaddrlen);\n    }\n    else {\n\tint prot;\n\tstruct unixsock_arg arg;\n\targ.sockaddr = &sockaddr;\n\targ.sockaddrlen = sockaddrlen;\n\targ.fd = fd;\n        status = (int)rb_protect(unixsock_connect_internal, (VALUE)&arg, &prot);\n\tif (prot) {\n\t    close(fd);\n\t    rb_jump_tag(prot);\n\t}\n    }\n\n    if (status < 0) {\n\tint e = errno;\n\tclose(fd);\n\trsock_syserr_fail_path(e, \"connect(2)\", path);\n    }\n\n    if (server) {\n\tif (listen(fd, SOMAXCONN) < 0) {\n\t    int e = errno;\n\t    close(fd);\n\t    rsock_syserr_fail_path(e, \"listen(2)\", path);\n\t}\n    }\n\n    rsock_init_sock(sock, fd);\n    if (server) {\n\tGetOpenFile(sock, fptr);\n        fptr->pathv = rb_str_new_frozen(path);\n    }\n\n    return sock;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145468,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "rsock_init_unixsock(VALUE sock, VALUE path, int server)\n{\n    struct sockaddr_un sockaddr;\n    socklen_t sockaddrlen;\n    int fd, status;\n    rb_io_t *fptr;\n\n    path = unixsock_path_value(path);\n\n    INIT_SOCKADDR_UN(&sockaddr, sizeof(struct sockaddr_un));\n    if (sizeof(sockaddr.sun_path) < (size_t)RSTRING_LEN(path)) {\n        rb_raise(rb_eArgError, \"too long unix socket path (%ldbytes given but %dbytes max)\",\n            RSTRING_LEN(path), (int)sizeof(sockaddr.sun_path));\n    }\n    memcpy(sockaddr.sun_path, RSTRING_PTR(path), RSTRING_LEN(path));\n    sockaddrlen = rsock_unix_sockaddr_len(path);\n\n    fd = rsock_socket(AF_UNIX, SOCK_STREAM, 0);\n    if (fd < 0) {\n\trsock_sys_fail_path(\"socket(2)\", path);\n    }\n\n    if (server) {\n        status = bind(fd, (struct sockaddr*)&sockaddr, sockaddrlen);\n    }\n    else {\n\tint prot;\n\tstruct unixsock_arg arg;\n\targ.sockaddr = &sockaddr;\n\targ.sockaddrlen = sockaddrlen;\n\targ.fd = fd;\n        status = (int)rb_protect(unixsock_connect_internal, (VALUE)&arg, &prot);\n\tif (prot) {\n\t    close(fd);\n\t    rb_jump_tag(prot);\n\t}\n    }\n\n    if (status < 0) {\n\tint e = errno;\n\tclose(fd);\n\trsock_syserr_fail_path(e, \"connect(2)\", path);\n    }\n\n    if (server) {\n\tif (listen(fd, SOMAXCONN) < 0) {\n\t    int e = errno;\n\t    close(fd);\n\t    rsock_syserr_fail_path(e, \"listen(2)\", path);\n\t}\n    }\n\n    rsock_init_sock(sock, fd);\n    if (server) {\n\tGetOpenFile(sock, fptr);\n        fptr->pathv = rb_str_new_frozen(path);\n    }\n\n    return sock;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145469,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void jas_matrix_clip(jas_matrix_t *matrix, jas_seqent_t minval, jas_seqent_t maxval)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t v;\n\tjas_seqent_t *rowstart;\n\tjas_seqent_t *data;\n\tint rowstep;\n\n\trowstep = jas_matrix_rowstep(matrix);\n\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t  rowstart += rowstep) {\n\t\tdata = rowstart;\n\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t  ++data) {\n\t\t\tv = *data;\n\t\t\tif (v < minval) {\n\t\t\t\t*data = minval;\n\t\t\t} else if (v > maxval) {\n\t\t\t\t*data = maxval;\n\t\t\t}\n\t\t}\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145492,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void jas_matrix_clip(jas_matrix_t *matrix, jas_seqent_t minval, jas_seqent_t maxval)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t v;\n\tjas_seqent_t *rowstart;\n\tjas_seqent_t *data;\n\tint rowstep;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tdata = rowstart;\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\tv = *data;\n\t\t\t\tif (v < minval) {\n\t\t\t\t\t*data = minval;\n\t\t\t\t} else if (v > maxval) {\n\t\t\t\t\t*data = maxval;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145493,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static inline Quantum GetPixelChannel(const Image *magick_restrict image,\n  const PixelChannel channel,const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[channel].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[channel].offset]);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145540,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static inline Quantum GetPixelChannel(const Image *magick_restrict image,\n  const PixelChannel channel,const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[image->channel_map[channel].offset].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[channel].offset]);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145541,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int manager_dispatch_notify_fd(sd_event_source *source, int fd, uint32_t revents, void *userdata) {\n        Manager *m = userdata;\n        ssize_t n;\n\n        assert(m);\n        assert(m->notify_fd == fd);\n\n        if (revents != EPOLLIN) {\n                log_warning(\"Got unexpected poll event for notify fd.\");\n                return 0;\n        }\n\n        for (;;) {\n                char buf[4096];\n                struct iovec iovec = {\n                        .iov_base = buf,\n                        .iov_len = sizeof(buf)-1,\n                };\n\n                union {\n                        struct cmsghdr cmsghdr;\n                        uint8_t buf[CMSG_SPACE(sizeof(struct ucred))];\n                } control = {};\n\n                struct msghdr msghdr = {\n                        .msg_iov = &iovec,\n                        .msg_iovlen = 1,\n                        .msg_control = &control,\n                        .msg_controllen = sizeof(control),\n                };\n                struct ucred *ucred;\n                Unit *u;\n                _cleanup_strv_free_ char **tags = NULL;\n\n                n = recvmsg(m->notify_fd, &msghdr, MSG_DONTWAIT);\n                if (n <= 0) {\n                        if (n == 0)\n                                return -EIO;\n\n                        if (errno == EAGAIN || errno == EINTR)\n                                break;\n\n                        return -errno;\n                }\n\n                if (msghdr.msg_controllen < CMSG_LEN(sizeof(struct ucred)) ||\n                    control.cmsghdr.cmsg_level != SOL_SOCKET ||\n                    control.cmsghdr.cmsg_type != SCM_CREDENTIALS ||\n                    control.cmsghdr.cmsg_len != CMSG_LEN(sizeof(struct ucred))) {\n                        log_warning(\"Received notify message without credentials. Ignoring.\");\n                        continue;\n                }\n\n                ucred = (struct ucred*) CMSG_DATA(&control.cmsghdr);\n\n                u = hashmap_get(m->watch_pids, LONG_TO_PTR(ucred->pid));\n                if (!u) {\n                        u = manager_get_unit_by_pid(m, ucred->pid);\n                        if (!u) {\n                                log_warning(\"Cannot find unit for notify message of PID \"PID_FMT\".\", ucred->pid);\n                                continue;\n                        }\n                }\n\n                assert((size_t) n < sizeof(buf));\n                buf[n] = 0;\n                tags = strv_split(buf, \"\\n\\r\");\n                if (!tags)\n                        return log_oom();\n\n                log_debug_unit(u->id, \"Got notification message for unit %s\", u->id);\n\n                if (UNIT_VTABLE(u)->notify_message)\n                        UNIT_VTABLE(u)->notify_message(u, ucred->pid, tags);\n        }\n\n        return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145600,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int manager_dispatch_notify_fd(sd_event_source *source, int fd, uint32_t revents, void *userdata) {\n        Manager *m = userdata;\n        ssize_t n;\n\n        assert(m);\n        assert(m->notify_fd == fd);\n\n        if (revents != EPOLLIN) {\n                log_warning(\"Got unexpected poll event for notify fd.\");\n                return 0;\n        }\n\n        for (;;) {\n                char buf[4096];\n                struct iovec iovec = {\n                        .iov_base = buf,\n                        .iov_len = sizeof(buf)-1,\n                };\n                bool found = false;\n\n                union {\n                        struct cmsghdr cmsghdr;\n                        uint8_t buf[CMSG_SPACE(sizeof(struct ucred))];\n                } control = {};\n\n                struct msghdr msghdr = {\n                        .msg_iov = &iovec,\n                        .msg_iovlen = 1,\n                        .msg_control = &control,\n                        .msg_controllen = sizeof(control),\n                };\n                struct ucred *ucred;\n                Unit *u;\n\n                n = recvmsg(m->notify_fd, &msghdr, MSG_DONTWAIT);\n                if (n <= 0) {\n                        if (n == 0)\n                                return -EIO;\n\n                        if (errno == EAGAIN || errno == EINTR)\n                                break;\n\n                        return -errno;\n                }\n\n                if (msghdr.msg_controllen < CMSG_LEN(sizeof(struct ucred)) ||\n                    control.cmsghdr.cmsg_level != SOL_SOCKET ||\n                    control.cmsghdr.cmsg_type != SCM_CREDENTIALS ||\n                    control.cmsghdr.cmsg_len != CMSG_LEN(sizeof(struct ucred))) {\n                        log_warning(\"Received notify message without credentials. Ignoring.\");\n                        continue;\n                }\n\n                ucred = (struct ucred*) CMSG_DATA(&control.cmsghdr);\n\n                assert((size_t) n < sizeof(buf));\n                buf[n] = 0;\n\n                u = manager_get_unit_by_pid(m, ucred->pid);\n                if (u) {\n                        manager_invoke_notify_message(m, u, ucred->pid, buf, n);\n                        found = true;\n                }\n\n                u = hashmap_get(m->watch_pids1, LONG_TO_PTR(ucred->pid));\n                if (u) {\n                        manager_invoke_notify_message(m, u, ucred->pid, buf, n);\n                        found = true;\n                }\n\n                u = hashmap_get(m->watch_pids2, LONG_TO_PTR(ucred->pid));\n                if (u) {\n                        manager_invoke_notify_message(m, u, ucred->pid, buf, n);\n                        found = true;\n                }\n\n                if (!found)\n                        log_warning(\"Cannot find unit for notify message of PID \"PID_FMT\".\", ucred->pid);\n        }\n\n        return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145601,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "setup_seccomp (GPtrArray  *argv_array,\n               GArray     *fd_array,\n               const char *arch,\n               gboolean    multiarch,\n               gboolean    devel,\n               GError    **error)\n{\n  __attribute__((cleanup (cleanup_seccomp))) scmp_filter_ctx seccomp = NULL;\n\n  /**** BEGIN NOTE ON CODE SHARING\n   *\n   * There are today a number of different Linux container\n   * implementations.  That will likely continue for long into the\n   * future.  But we can still try to share code, and it's important\n   * to do so because it affects what library and application writers\n   * can do, and we should support code portability between different\n   * container tools.\n   *\n   * This syscall blacklist is copied from linux-user-chroot, which was in turn\n   * clearly influenced by the Sandstorm.io blacklist.\n   *\n   * If you make any changes here, I suggest sending the changes along\n   * to other sandbox maintainers.  Using the libseccomp list is also\n   * an appropriate venue:\n   * https://groups.google.com/forum/#!topic/libseccomp\n   *\n   * A non-exhaustive list of links to container tooling that might\n   * want to share this blacklist:\n   *\n   *  https://github.com/sandstorm-io/sandstorm\n   *    in src/sandstorm/supervisor.c++\n   *  http://cgit.freedesktop.org/xdg-app/xdg-app/\n   *    in common/flatpak-run.c\n   *  https://git.gnome.org/browse/linux-user-chroot\n   *    in src/setup-seccomp.c\n   *\n   **** END NOTE ON CODE SHARING\n   */\n  struct\n  {\n    int                  scall;\n    struct scmp_arg_cmp *arg;\n  } syscall_blacklist[] = {\n    /* Block dmesg */\n    {SCMP_SYS (syslog)},\n    /* Useless old syscall */\n    {SCMP_SYS (uselib)},\n    /* Don't allow you to switch to bsd emulation or whatnot */\n    {SCMP_SYS (personality)},\n    /* Don't allow disabling accounting */\n    {SCMP_SYS (acct)},\n    /* 16-bit code is unnecessary in the sandbox, and modify_ldt is a\n       historic source of interesting information leaks. */\n    {SCMP_SYS (modify_ldt)},\n    /* Don't allow reading current quota use */\n    {SCMP_SYS (quotactl)},\n\n    /* Don't allow access to the kernel keyring */\n    {SCMP_SYS (add_key)},\n    {SCMP_SYS (keyctl)},\n    {SCMP_SYS (request_key)},\n\n    /* Scary VM/NUMA ops */\n    {SCMP_SYS (move_pages)},\n    {SCMP_SYS (mbind)},\n    {SCMP_SYS (get_mempolicy)},\n    {SCMP_SYS (set_mempolicy)},\n    {SCMP_SYS (migrate_pages)},\n\n    /* Don't allow subnamespace setups: */\n    {SCMP_SYS (unshare)},\n    {SCMP_SYS (mount)},\n    {SCMP_SYS (pivot_root)},\n    {SCMP_SYS (clone), &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n  };\n\n  struct\n  {\n    int                  scall;\n    struct scmp_arg_cmp *arg;\n  } syscall_nondevel_blacklist[] = {\n    /* Profiling operations; we expect these to be done by tools from outside\n     * the sandbox.  In particular perf has been the source of many CVEs.\n     */\n    {SCMP_SYS (perf_event_open)},\n    {SCMP_SYS (ptrace)}\n  };\n  /* Blacklist all but unix, inet, inet6 and netlink */\n  int socket_family_blacklist[] = {\n    AF_AX25,\n    AF_IPX,\n    AF_APPLETALK,\n    AF_NETROM,\n    AF_BRIDGE,\n    AF_ATMPVC,\n    AF_X25,\n    AF_ROSE,\n    AF_DECnet,\n    AF_NETBEUI,\n    AF_SECURITY,\n    AF_KEY,\n    AF_NETLINK + 1, /* Last gets CMP_GE, so order is important */\n  };\n  int i, r;\n  glnx_fd_close int fd = -1;\n  g_autofree char *fd_str = NULL;\n  g_autofree char *path = NULL;\n\n  seccomp = seccomp_init (SCMP_ACT_ALLOW);\n  if (!seccomp)\n    return flatpak_fail (error, \"Initialize seccomp failed\");\n\n  if (arch != NULL)\n    {\n      uint32_t arch_id = 0;\n      const uint32_t *extra_arches = NULL;\n\n      if (strcmp (arch, \"i386\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86;\n        }\n      else if (strcmp (arch, \"x86_64\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86_64;\n          extra_arches = seccomp_x86_64_extra_arches;\n        }\n      else if (strcmp (arch, \"arm\") == 0)\n        {\n          arch_id = SCMP_ARCH_ARM;\n        }\n#ifdef SCMP_ARCH_AARCH64\n      else if (strcmp (arch, \"aarch64\") == 0)\n        {\n          arch_id = SCMP_ARCH_AARCH64;\n          extra_arches = seccomp_aarch64_extra_arches;\n        }\n#endif\n\n      /* We only really need to handle arches on multiarch systems.\n       * If only one arch is supported the default is fine */\n      if (arch_id != 0)\n        {\n          /* This *adds* the target arch, instead of replacing the\n             native one. This is not ideal, because we'd like to only\n             allow the target arch, but we can't really disallow the\n             native arch at this point, because then bubblewrap\n             couldn't continue running. */\n          r = seccomp_arch_add (seccomp, arch_id);\n          if (r < 0 && r != -EEXIST)\n            return flatpak_fail (error, \"Failed to add architecture to seccomp filter\");\n\n          if (multiarch && extra_arches != NULL)\n            {\n              unsigned i;\n              for (i = 0; extra_arches[i] != 0; i++)\n                {\n                  r = seccomp_arch_add (seccomp, extra_arches[i]);\n                  if (r < 0 && r != -EEXIST)\n                    return flatpak_fail (error, \"Failed to add multiarch architecture to seccomp filter\");\n                }\n            }\n        }\n    }\n\n  /* TODO: Should we filter the kernel keyring syscalls in some way?\n   * We do want them to be used by desktop apps, but they could also perhaps\n   * leak system stuff or secrets from other apps.\n   */\n\n  for (i = 0; i < G_N_ELEMENTS (syscall_blacklist); i++)\n    {\n      int scall = syscall_blacklist[i].scall;\n      if (syscall_blacklist[i].arg)\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 1, *syscall_blacklist[i].arg);\n      else\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);\n      if (r < 0 && r == -EFAULT /* unknown syscall */)\n        return flatpak_fail (error, \"Failed to block syscall %d\", scall);\n    }\n\n  if (!devel)\n    {\n      for (i = 0; i < G_N_ELEMENTS (syscall_nondevel_blacklist); i++)\n        {\n          int scall = syscall_nondevel_blacklist[i].scall;\n          if (syscall_nondevel_blacklist[i].arg)\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 1, *syscall_nondevel_blacklist[i].arg);\n          else\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);\n\n          if (r < 0 && r == -EFAULT /* unknown syscall */)\n            return flatpak_fail (error, \"Failed to block syscall %d\", scall);\n        }\n    }\n\n  /* Socket filtering doesn't work on e.g. i386, so ignore failures here\n   * However, we need to user seccomp_rule_add_exact to avoid libseccomp doing\n   * something else: https://github.com/seccomp/libseccomp/issues/8 */\n  for (i = 0; i < G_N_ELEMENTS (socket_family_blacklist); i++)\n    {\n      int family = socket_family_blacklist[i];\n      if (i == G_N_ELEMENTS (socket_family_blacklist) - 1)\n        seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE, family));\n      else\n        seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, family));\n    }\n\n  fd = g_file_open_tmp (\"flatpak-seccomp-XXXXXX\", &path, error);\n  if (fd == -1)\n    return FALSE;\n\n  unlink (path);\n\n  if (seccomp_export_bpf (seccomp, fd) != 0)\n    return flatpak_fail (error, \"Failed to export bpf\");\n\n  lseek (fd, 0, SEEK_SET);\n\n  fd_str = g_strdup_printf (\"%d\", fd);\n  if (fd_array)\n    g_array_append_val (fd_array, fd);\n\n  add_args (argv_array,\n            \"--seccomp\", fd_str,\n            NULL);\n\n  fd = -1; /* Don't close on success */\n\n  return TRUE;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145700,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "setup_seccomp (GPtrArray  *argv_array,\n               GArray     *fd_array,\n               const char *arch,\n               gboolean    multiarch,\n               gboolean    devel,\n               GError    **error)\n{\n  __attribute__((cleanup (cleanup_seccomp))) scmp_filter_ctx seccomp = NULL;\n\n  /**** BEGIN NOTE ON CODE SHARING\n   *\n   * There are today a number of different Linux container\n   * implementations.  That will likely continue for long into the\n   * future.  But we can still try to share code, and it's important\n   * to do so because it affects what library and application writers\n   * can do, and we should support code portability between different\n   * container tools.\n   *\n   * This syscall blacklist is copied from linux-user-chroot, which was in turn\n   * clearly influenced by the Sandstorm.io blacklist.\n   *\n   * If you make any changes here, I suggest sending the changes along\n   * to other sandbox maintainers.  Using the libseccomp list is also\n   * an appropriate venue:\n   * https://groups.google.com/forum/#!topic/libseccomp\n   *\n   * A non-exhaustive list of links to container tooling that might\n   * want to share this blacklist:\n   *\n   *  https://github.com/sandstorm-io/sandstorm\n   *    in src/sandstorm/supervisor.c++\n   *  http://cgit.freedesktop.org/xdg-app/xdg-app/\n   *    in common/flatpak-run.c\n   *  https://git.gnome.org/browse/linux-user-chroot\n   *    in src/setup-seccomp.c\n   *\n   **** END NOTE ON CODE SHARING\n   */\n  struct\n  {\n    int                  scall;\n    struct scmp_arg_cmp *arg;\n  } syscall_blacklist[] = {\n    /* Block dmesg */\n    {SCMP_SYS (syslog)},\n    /* Useless old syscall */\n    {SCMP_SYS (uselib)},\n    /* Don't allow you to switch to bsd emulation or whatnot */\n    {SCMP_SYS (personality)},\n    /* Don't allow disabling accounting */\n    {SCMP_SYS (acct)},\n    /* 16-bit code is unnecessary in the sandbox, and modify_ldt is a\n       historic source of interesting information leaks. */\n    {SCMP_SYS (modify_ldt)},\n    /* Don't allow reading current quota use */\n    {SCMP_SYS (quotactl)},\n\n    /* Don't allow access to the kernel keyring */\n    {SCMP_SYS (add_key)},\n    {SCMP_SYS (keyctl)},\n    {SCMP_SYS (request_key)},\n\n    /* Scary VM/NUMA ops */\n    {SCMP_SYS (move_pages)},\n    {SCMP_SYS (mbind)},\n    {SCMP_SYS (get_mempolicy)},\n    {SCMP_SYS (set_mempolicy)},\n    {SCMP_SYS (migrate_pages)},\n\n    /* Don't allow subnamespace setups: */\n    {SCMP_SYS (unshare)},\n    {SCMP_SYS (mount)},\n    {SCMP_SYS (pivot_root)},\n    {SCMP_SYS (clone), &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n\n    /* Don't allow faking input to the controlling tty (CVE-2017-5226) */\n    {SCMP_SYS (ioctl), &SCMP_A1(SCMP_CMP_EQ, (int)TIOCSTI)},\n  };\n\n  struct\n  {\n    int                  scall;\n    struct scmp_arg_cmp *arg;\n  } syscall_nondevel_blacklist[] = {\n    /* Profiling operations; we expect these to be done by tools from outside\n     * the sandbox.  In particular perf has been the source of many CVEs.\n     */\n    {SCMP_SYS (perf_event_open)},\n    {SCMP_SYS (ptrace)}\n  };\n  /* Blacklist all but unix, inet, inet6 and netlink */\n  int socket_family_blacklist[] = {\n    AF_AX25,\n    AF_IPX,\n    AF_APPLETALK,\n    AF_NETROM,\n    AF_BRIDGE,\n    AF_ATMPVC,\n    AF_X25,\n    AF_ROSE,\n    AF_DECnet,\n    AF_NETBEUI,\n    AF_SECURITY,\n    AF_KEY,\n    AF_NETLINK + 1, /* Last gets CMP_GE, so order is important */\n  };\n  int i, r;\n  glnx_fd_close int fd = -1;\n  g_autofree char *fd_str = NULL;\n  g_autofree char *path = NULL;\n\n  seccomp = seccomp_init (SCMP_ACT_ALLOW);\n  if (!seccomp)\n    return flatpak_fail (error, \"Initialize seccomp failed\");\n\n  if (arch != NULL)\n    {\n      uint32_t arch_id = 0;\n      const uint32_t *extra_arches = NULL;\n\n      if (strcmp (arch, \"i386\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86;\n        }\n      else if (strcmp (arch, \"x86_64\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86_64;\n          extra_arches = seccomp_x86_64_extra_arches;\n        }\n      else if (strcmp (arch, \"arm\") == 0)\n        {\n          arch_id = SCMP_ARCH_ARM;\n        }\n#ifdef SCMP_ARCH_AARCH64\n      else if (strcmp (arch, \"aarch64\") == 0)\n        {\n          arch_id = SCMP_ARCH_AARCH64;\n          extra_arches = seccomp_aarch64_extra_arches;\n        }\n#endif\n\n      /* We only really need to handle arches on multiarch systems.\n       * If only one arch is supported the default is fine */\n      if (arch_id != 0)\n        {\n          /* This *adds* the target arch, instead of replacing the\n             native one. This is not ideal, because we'd like to only\n             allow the target arch, but we can't really disallow the\n             native arch at this point, because then bubblewrap\n             couldn't continue running. */\n          r = seccomp_arch_add (seccomp, arch_id);\n          if (r < 0 && r != -EEXIST)\n            return flatpak_fail (error, \"Failed to add architecture to seccomp filter\");\n\n          if (multiarch && extra_arches != NULL)\n            {\n              unsigned i;\n              for (i = 0; extra_arches[i] != 0; i++)\n                {\n                  r = seccomp_arch_add (seccomp, extra_arches[i]);\n                  if (r < 0 && r != -EEXIST)\n                    return flatpak_fail (error, \"Failed to add multiarch architecture to seccomp filter\");\n                }\n            }\n        }\n    }\n\n  /* TODO: Should we filter the kernel keyring syscalls in some way?\n   * We do want them to be used by desktop apps, but they could also perhaps\n   * leak system stuff or secrets from other apps.\n   */\n\n  for (i = 0; i < G_N_ELEMENTS (syscall_blacklist); i++)\n    {\n      int scall = syscall_blacklist[i].scall;\n      if (syscall_blacklist[i].arg)\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 1, *syscall_blacklist[i].arg);\n      else\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);\n      if (r < 0 && r == -EFAULT /* unknown syscall */)\n        return flatpak_fail (error, \"Failed to block syscall %d\", scall);\n    }\n\n  if (!devel)\n    {\n      for (i = 0; i < G_N_ELEMENTS (syscall_nondevel_blacklist); i++)\n        {\n          int scall = syscall_nondevel_blacklist[i].scall;\n          if (syscall_nondevel_blacklist[i].arg)\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 1, *syscall_nondevel_blacklist[i].arg);\n          else\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);\n\n          if (r < 0 && r == -EFAULT /* unknown syscall */)\n            return flatpak_fail (error, \"Failed to block syscall %d\", scall);\n        }\n    }\n\n  /* Socket filtering doesn't work on e.g. i386, so ignore failures here\n   * However, we need to user seccomp_rule_add_exact to avoid libseccomp doing\n   * something else: https://github.com/seccomp/libseccomp/issues/8 */\n  for (i = 0; i < G_N_ELEMENTS (socket_family_blacklist); i++)\n    {\n      int family = socket_family_blacklist[i];\n      if (i == G_N_ELEMENTS (socket_family_blacklist) - 1)\n        seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE, family));\n      else\n        seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, family));\n    }\n\n  fd = g_file_open_tmp (\"flatpak-seccomp-XXXXXX\", &path, error);\n  if (fd == -1)\n    return FALSE;\n\n  unlink (path);\n\n  if (seccomp_export_bpf (seccomp, fd) != 0)\n    return flatpak_fail (error, \"Failed to export bpf\");\n\n  lseek (fd, 0, SEEK_SET);\n\n  fd_str = g_strdup_printf (\"%d\", fd);\n  if (fd_array)\n    g_array_append_val (fd_array, fd);\n\n  add_args (argv_array,\n            \"--seccomp\", fd_str,\n            NULL);\n\n  fd = -1; /* Don't close on success */\n\n  return TRUE;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145701,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int qcow2_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVQcowState *s = bs->opaque;\n    int len, i, ret = 0;\n    QCowHeader header;\n    QemuOpts *opts;\n    Error *local_err = NULL;\n    uint64_t ext_end;\n    uint64_t l1_vm_state_index;\n    const char *opt_overlap_check;\n    int overlap_check_template = 0;\n\n    ret = bdrv_pread(bs->file, 0, &header, sizeof(header));\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not read qcow2 header\");\n        goto fail;\n    }\n    be32_to_cpus(&header.magic);\n    be32_to_cpus(&header.version);\n    be64_to_cpus(&header.backing_file_offset);\n    be32_to_cpus(&header.backing_file_size);\n    be64_to_cpus(&header.size);\n    be32_to_cpus(&header.cluster_bits);\n    be32_to_cpus(&header.crypt_method);\n    be64_to_cpus(&header.l1_table_offset);\n    be32_to_cpus(&header.l1_size);\n    be64_to_cpus(&header.refcount_table_offset);\n    be32_to_cpus(&header.refcount_table_clusters);\n    be64_to_cpus(&header.snapshots_offset);\n    be32_to_cpus(&header.nb_snapshots);\n\n    if (header.magic != QCOW_MAGIC) {\n        error_setg(errp, \"Image is not in qcow2 format\");\n        ret = -EINVAL;\n        goto fail;\n    }\n    if (header.version < 2 || header.version > 3) {\n        report_unsupported(bs, errp, \"QCOW version %d\", header.version);\n        ret = -ENOTSUP;\n        goto fail;\n    }\n\n    s->qcow_version = header.version;\n\n    /* Initialise cluster size */\n    if (header.cluster_bits < MIN_CLUSTER_BITS ||\n        header.cluster_bits > MAX_CLUSTER_BITS) {\n        error_setg(errp, \"Unsupported cluster size: 2^%i\", header.cluster_bits);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    s->cluster_bits = header.cluster_bits;\n    s->cluster_size = 1 << s->cluster_bits;\n    s->cluster_sectors = 1 << (s->cluster_bits - 9);\n\n    /* Initialise version 3 header fields */\n    if (header.version == 2) {\n        header.incompatible_features    = 0;\n        header.compatible_features      = 0;\n        header.autoclear_features       = 0;\n        header.refcount_order           = 4;\n        header.header_length            = 72;\n    } else {\n        be64_to_cpus(&header.incompatible_features);\n        be64_to_cpus(&header.compatible_features);\n        be64_to_cpus(&header.autoclear_features);\n        be32_to_cpus(&header.refcount_order);\n        be32_to_cpus(&header.header_length);\n\n        if (header.header_length < 104) {\n            error_setg(errp, \"qcow2 header too short\");\n            ret = -EINVAL;\n            goto fail;\n        }\n    }\n\n    if (header.header_length > s->cluster_size) {\n        error_setg(errp, \"qcow2 header exceeds cluster size\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    if (header.header_length > sizeof(header)) {\n        s->unknown_header_fields_size = header.header_length - sizeof(header);\n        s->unknown_header_fields = g_malloc(s->unknown_header_fields_size);\n        ret = bdrv_pread(bs->file, sizeof(header), s->unknown_header_fields,\n                         s->unknown_header_fields_size);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not read unknown qcow2 header \"\n                             \"fields\");\n            goto fail;\n        }\n    }\n\n    if (header.backing_file_offset > s->cluster_size) {\n        error_setg(errp, \"Invalid backing file offset\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    if (header.backing_file_offset) {\n        ext_end = header.backing_file_offset;\n    } else {\n        ext_end = 1 << header.cluster_bits;\n    }\n\n    /* Handle feature bits */\n    s->incompatible_features    = header.incompatible_features;\n    s->compatible_features      = header.compatible_features;\n    s->autoclear_features       = header.autoclear_features;\n\n    if (s->incompatible_features & ~QCOW2_INCOMPAT_MASK) {\n        void *feature_table = NULL;\n        qcow2_read_extensions(bs, header.header_length, ext_end,\n                              &feature_table, NULL);\n        report_unsupported_feature(bs, errp, feature_table,\n                                   s->incompatible_features &\n                                   ~QCOW2_INCOMPAT_MASK);\n        ret = -ENOTSUP;\n        g_free(feature_table);\n        goto fail;\n    }\n\n    if (s->incompatible_features & QCOW2_INCOMPAT_CORRUPT) {\n        /* Corrupt images may not be written to unless they are being repaired\n         */\n        if ((flags & BDRV_O_RDWR) && !(flags & BDRV_O_CHECK)) {\n            error_setg(errp, \"qcow2: Image is corrupt; cannot be opened \"\n                       \"read/write\");\n            ret = -EACCES;\n            goto fail;\n        }\n    }\n\n    /* Check support for various header values */\n    if (header.refcount_order != 4) {\n        report_unsupported(bs, errp, \"%d bit reference counts\",\n                           1 << header.refcount_order);\n        ret = -ENOTSUP;\n        goto fail;\n    }\n    s->refcount_order = header.refcount_order;\n\n    if (header.crypt_method > QCOW_CRYPT_AES) {\n        error_setg(errp, \"Unsupported encryption method: %i\",\n                   header.crypt_method);\n        ret = -EINVAL;\n        goto fail;\n    }\n    s->crypt_method_header = header.crypt_method;\n    if (s->crypt_method_header) {\n        bs->encrypted = 1;\n    }\n\n    s->l2_bits = s->cluster_bits - 3; /* L2 is always one cluster */\n    s->l2_size = 1 << s->l2_bits;\n    bs->total_sectors = header.size / 512;\n    s->csize_shift = (62 - (s->cluster_bits - 8));\n    s->csize_mask = (1 << (s->cluster_bits - 8)) - 1;\n    s->cluster_offset_mask = (1LL << s->csize_shift) - 1;\n\n    s->refcount_table_offset = header.refcount_table_offset;\n    s->refcount_table_size =\n        header.refcount_table_clusters << (s->cluster_bits - 3);\n\n    if (header.refcount_table_clusters > (0x800000 >> s->cluster_bits)) {\n        /* 8 MB refcount table is enough for 2 PB images at 64k cluster size\n         * (128 GB for 512 byte clusters, 2 EB for 2 MB clusters) */\n        error_setg(errp, \"Reference count table too large\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    ret = validate_table_offset(bs, s->refcount_table_offset,\n                                s->refcount_table_size, sizeof(uint64_t));\n    if (ret < 0) {\n        error_setg(errp, \"Invalid reference count table offset\");\n        goto fail;\n    }\n\n    /* Snapshot table offset/length */\n    if (header.nb_snapshots > QCOW_MAX_SNAPSHOTS) {\n        error_setg(errp, \"Too many snapshots\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    ret = validate_table_offset(bs, header.snapshots_offset,\n                                header.nb_snapshots,\n                                sizeof(QCowSnapshotHeader));\n    if (ret < 0) {\n        error_setg(errp, \"Invalid snapshot table offset\");\n        goto fail;\n    }\n\n    s->snapshots_offset = header.snapshots_offset;\n    s->nb_snapshots = header.nb_snapshots;\n\n    /* read the level 1 table */\n    s->l1_size = header.l1_size;\n\n    l1_vm_state_index = size_to_l1(s, header.size);\n    if (l1_vm_state_index > INT_MAX) {\n        error_setg(errp, \"Image is too big\");\n        ret = -EFBIG;\n        goto fail;\n    }\n    s->l1_vm_state_index = l1_vm_state_index;\n\n    /* the L1 table must contain at least enough entries to put\n       header.size bytes */\n    if (s->l1_size < s->l1_vm_state_index) {\n        error_setg(errp, \"L1 table is too small\");\n        ret = -EINVAL;\n        goto fail;\n    }\n    s->l1_table_offset = header.l1_table_offset;\n    if (s->l1_size > 0) {\n        s->l1_table = g_malloc0(\n            align_offset(s->l1_size * sizeof(uint64_t), 512));\n        ret = bdrv_pread(bs->file, s->l1_table_offset, s->l1_table,\n                         s->l1_size * sizeof(uint64_t));\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not read L1 table\");\n            goto fail;\n        }\n        for(i = 0;i < s->l1_size; i++) {\n            be64_to_cpus(&s->l1_table[i]);\n        }\n    }\n\n    /* alloc L2 table/refcount block cache */\n    s->l2_table_cache = qcow2_cache_create(bs, L2_CACHE_SIZE);\n    s->refcount_block_cache = qcow2_cache_create(bs, REFCOUNT_CACHE_SIZE);\n\n    s->cluster_cache = g_malloc(s->cluster_size);\n    /* one more sector for decompressed data alignment */\n    s->cluster_data = qemu_blockalign(bs, QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size\n                                  + 512);\n    s->cluster_cache_offset = -1;\n    s->flags = flags;\n\n    ret = qcow2_refcount_init(bs);\n    if (ret != 0) {\n        error_setg_errno(errp, -ret, \"Could not initialize refcount handling\");\n        goto fail;\n    }\n\n    QLIST_INIT(&s->cluster_allocs);\n    QTAILQ_INIT(&s->discards);\n\n    /* read qcow2 extensions */\n    if (qcow2_read_extensions(bs, header.header_length, ext_end, NULL,\n        &local_err)) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    /* read the backing file name */\n    if (header.backing_file_offset != 0) {\n        len = header.backing_file_size;\n        if (len > 1023) {\n            len = 1023;\n        }\n        ret = bdrv_pread(bs->file, header.backing_file_offset,\n                         bs->backing_file, len);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not read backing file name\");\n            goto fail;\n        }\n        bs->backing_file[len] = '\\0';\n    }\n\n    ret = qcow2_read_snapshots(bs);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not read snapshots\");\n        goto fail;\n    }\n\n    /* Clear unknown autoclear feature bits */\n    if (!bs->read_only && !(flags & BDRV_O_INCOMING) && s->autoclear_features) {\n        s->autoclear_features = 0;\n        ret = qcow2_update_header(bs);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not update qcow2 header\");\n            goto fail;\n        }\n    }\n\n    /* Initialise locks */\n    qemu_co_mutex_init(&s->lock);\n\n    /* Repair image if dirty */\n    if (!(flags & (BDRV_O_CHECK | BDRV_O_INCOMING)) && !bs->read_only &&\n        (s->incompatible_features & QCOW2_INCOMPAT_DIRTY)) {\n        BdrvCheckResult result = {0};\n\n        ret = qcow2_check(bs, &result, BDRV_FIX_ERRORS);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not repair dirty image\");\n            goto fail;\n        }\n    }\n\n    /* Enable lazy_refcounts according to image and command line options */\n    opts = qemu_opts_create(&qcow2_runtime_opts, NULL, 0, &error_abort);\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    s->use_lazy_refcounts = qemu_opt_get_bool(opts, QCOW2_OPT_LAZY_REFCOUNTS,\n        (s->compatible_features & QCOW2_COMPAT_LAZY_REFCOUNTS));\n\n    s->discard_passthrough[QCOW2_DISCARD_NEVER] = false;\n    s->discard_passthrough[QCOW2_DISCARD_ALWAYS] = true;\n    s->discard_passthrough[QCOW2_DISCARD_REQUEST] =\n        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_REQUEST,\n                          flags & BDRV_O_UNMAP);\n    s->discard_passthrough[QCOW2_DISCARD_SNAPSHOT] =\n        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_SNAPSHOT, true);\n    s->discard_passthrough[QCOW2_DISCARD_OTHER] =\n        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_OTHER, false);\n\n    opt_overlap_check = qemu_opt_get(opts, \"overlap-check\") ?: \"cached\";\n    if (!strcmp(opt_overlap_check, \"none\")) {\n        overlap_check_template = 0;\n    } else if (!strcmp(opt_overlap_check, \"constant\")) {\n        overlap_check_template = QCOW2_OL_CONSTANT;\n    } else if (!strcmp(opt_overlap_check, \"cached\")) {\n        overlap_check_template = QCOW2_OL_CACHED;\n    } else if (!strcmp(opt_overlap_check, \"all\")) {\n        overlap_check_template = QCOW2_OL_ALL;\n    } else {\n        error_setg(errp, \"Unsupported value '%s' for qcow2 option \"\n                   \"'overlap-check'. Allowed are either of the following: \"\n                   \"none, constant, cached, all\", opt_overlap_check);\n        qemu_opts_del(opts);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    s->overlap_check = 0;\n    for (i = 0; i < QCOW2_OL_MAX_BITNR; i++) {\n        /* overlap-check defines a template bitmask, but every flag may be\n         * overwritten through the associated boolean option */\n        s->overlap_check |=\n            qemu_opt_get_bool(opts, overlap_bool_option_names[i],\n                              overlap_check_template & (1 << i)) << i;\n    }\n\n    qemu_opts_del(opts);\n\n    if (s->use_lazy_refcounts && s->qcow_version < 3) {\n        error_setg(errp, \"Lazy refcounts require a qcow2 image with at least \"\n                   \"qemu 1.1 compatibility level\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n#ifdef DEBUG_ALLOC\n    {\n        BdrvCheckResult result = {0};\n        qcow2_check_refcounts(bs, &result, 0);\n    }\n#endif\n    return ret;\n\n fail:\n    g_free(s->unknown_header_fields);\n    cleanup_unknown_header_ext(bs);\n    qcow2_free_snapshots(bs);\n    qcow2_refcount_close(bs);\n    g_free(s->l1_table);\n    /* else pre-write overlap checks in cache_destroy may crash */\n    s->l1_table = NULL;\n    if (s->l2_table_cache) {\n        qcow2_cache_destroy(bs, s->l2_table_cache);\n    }\n    if (s->refcount_block_cache) {\n        qcow2_cache_destroy(bs, s->refcount_block_cache);\n    }\n    g_free(s->cluster_cache);\n    qemu_vfree(s->cluster_data);\n    return ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145714,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int qcow2_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVQcowState *s = bs->opaque;\n    int len, i, ret = 0;\n    QCowHeader header;\n    QemuOpts *opts;\n    Error *local_err = NULL;\n    uint64_t ext_end;\n    uint64_t l1_vm_state_index;\n    const char *opt_overlap_check;\n    int overlap_check_template = 0;\n\n    ret = bdrv_pread(bs->file, 0, &header, sizeof(header));\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not read qcow2 header\");\n        goto fail;\n    }\n    be32_to_cpus(&header.magic);\n    be32_to_cpus(&header.version);\n    be64_to_cpus(&header.backing_file_offset);\n    be32_to_cpus(&header.backing_file_size);\n    be64_to_cpus(&header.size);\n    be32_to_cpus(&header.cluster_bits);\n    be32_to_cpus(&header.crypt_method);\n    be64_to_cpus(&header.l1_table_offset);\n    be32_to_cpus(&header.l1_size);\n    be64_to_cpus(&header.refcount_table_offset);\n    be32_to_cpus(&header.refcount_table_clusters);\n    be64_to_cpus(&header.snapshots_offset);\n    be32_to_cpus(&header.nb_snapshots);\n\n    if (header.magic != QCOW_MAGIC) {\n        error_setg(errp, \"Image is not in qcow2 format\");\n        ret = -EINVAL;\n        goto fail;\n    }\n    if (header.version < 2 || header.version > 3) {\n        report_unsupported(bs, errp, \"QCOW version %d\", header.version);\n        ret = -ENOTSUP;\n        goto fail;\n    }\n\n    s->qcow_version = header.version;\n\n    /* Initialise cluster size */\n    if (header.cluster_bits < MIN_CLUSTER_BITS ||\n        header.cluster_bits > MAX_CLUSTER_BITS) {\n        error_setg(errp, \"Unsupported cluster size: 2^%i\", header.cluster_bits);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    s->cluster_bits = header.cluster_bits;\n    s->cluster_size = 1 << s->cluster_bits;\n    s->cluster_sectors = 1 << (s->cluster_bits - 9);\n\n    /* Initialise version 3 header fields */\n    if (header.version == 2) {\n        header.incompatible_features    = 0;\n        header.compatible_features      = 0;\n        header.autoclear_features       = 0;\n        header.refcount_order           = 4;\n        header.header_length            = 72;\n    } else {\n        be64_to_cpus(&header.incompatible_features);\n        be64_to_cpus(&header.compatible_features);\n        be64_to_cpus(&header.autoclear_features);\n        be32_to_cpus(&header.refcount_order);\n        be32_to_cpus(&header.header_length);\n\n        if (header.header_length < 104) {\n            error_setg(errp, \"qcow2 header too short\");\n            ret = -EINVAL;\n            goto fail;\n        }\n    }\n\n    if (header.header_length > s->cluster_size) {\n        error_setg(errp, \"qcow2 header exceeds cluster size\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    if (header.header_length > sizeof(header)) {\n        s->unknown_header_fields_size = header.header_length - sizeof(header);\n        s->unknown_header_fields = g_malloc(s->unknown_header_fields_size);\n        ret = bdrv_pread(bs->file, sizeof(header), s->unknown_header_fields,\n                         s->unknown_header_fields_size);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not read unknown qcow2 header \"\n                             \"fields\");\n            goto fail;\n        }\n    }\n\n    if (header.backing_file_offset > s->cluster_size) {\n        error_setg(errp, \"Invalid backing file offset\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    if (header.backing_file_offset) {\n        ext_end = header.backing_file_offset;\n    } else {\n        ext_end = 1 << header.cluster_bits;\n    }\n\n    /* Handle feature bits */\n    s->incompatible_features    = header.incompatible_features;\n    s->compatible_features      = header.compatible_features;\n    s->autoclear_features       = header.autoclear_features;\n\n    if (s->incompatible_features & ~QCOW2_INCOMPAT_MASK) {\n        void *feature_table = NULL;\n        qcow2_read_extensions(bs, header.header_length, ext_end,\n                              &feature_table, NULL);\n        report_unsupported_feature(bs, errp, feature_table,\n                                   s->incompatible_features &\n                                   ~QCOW2_INCOMPAT_MASK);\n        ret = -ENOTSUP;\n        g_free(feature_table);\n        goto fail;\n    }\n\n    if (s->incompatible_features & QCOW2_INCOMPAT_CORRUPT) {\n        /* Corrupt images may not be written to unless they are being repaired\n         */\n        if ((flags & BDRV_O_RDWR) && !(flags & BDRV_O_CHECK)) {\n            error_setg(errp, \"qcow2: Image is corrupt; cannot be opened \"\n                       \"read/write\");\n            ret = -EACCES;\n            goto fail;\n        }\n    }\n\n    /* Check support for various header values */\n    if (header.refcount_order != 4) {\n        report_unsupported(bs, errp, \"%d bit reference counts\",\n                           1 << header.refcount_order);\n        ret = -ENOTSUP;\n        goto fail;\n    }\n    s->refcount_order = header.refcount_order;\n\n    if (header.crypt_method > QCOW_CRYPT_AES) {\n        error_setg(errp, \"Unsupported encryption method: %i\",\n                   header.crypt_method);\n        ret = -EINVAL;\n        goto fail;\n    }\n    s->crypt_method_header = header.crypt_method;\n    if (s->crypt_method_header) {\n        bs->encrypted = 1;\n    }\n\n    s->l2_bits = s->cluster_bits - 3; /* L2 is always one cluster */\n    s->l2_size = 1 << s->l2_bits;\n    bs->total_sectors = header.size / 512;\n    s->csize_shift = (62 - (s->cluster_bits - 8));\n    s->csize_mask = (1 << (s->cluster_bits - 8)) - 1;\n    s->cluster_offset_mask = (1LL << s->csize_shift) - 1;\n\n    s->refcount_table_offset = header.refcount_table_offset;\n    s->refcount_table_size =\n        header.refcount_table_clusters << (s->cluster_bits - 3);\n\n    if (header.refcount_table_clusters > (0x800000 >> s->cluster_bits)) {\n        /* 8 MB refcount table is enough for 2 PB images at 64k cluster size\n         * (128 GB for 512 byte clusters, 2 EB for 2 MB clusters) */\n        error_setg(errp, \"Reference count table too large\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    ret = validate_table_offset(bs, s->refcount_table_offset,\n                                s->refcount_table_size, sizeof(uint64_t));\n    if (ret < 0) {\n        error_setg(errp, \"Invalid reference count table offset\");\n        goto fail;\n    }\n\n    /* Snapshot table offset/length */\n    if (header.nb_snapshots > QCOW_MAX_SNAPSHOTS) {\n        error_setg(errp, \"Too many snapshots\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    ret = validate_table_offset(bs, header.snapshots_offset,\n                                header.nb_snapshots,\n                                sizeof(QCowSnapshotHeader));\n    if (ret < 0) {\n        error_setg(errp, \"Invalid snapshot table offset\");\n        goto fail;\n    }\n\n    s->snapshots_offset = header.snapshots_offset;\n    s->nb_snapshots = header.nb_snapshots;\n\n    /* read the level 1 table */\n    if (header.l1_size > 0x2000000) {\n        /* 32 MB L1 table is enough for 2 PB images at 64k cluster size\n         * (128 GB for 512 byte clusters, 2 EB for 2 MB clusters) */\n        error_setg(errp, \"Active L1 table too large\");\n        ret = -EFBIG;\n        goto fail;\n    }\n    s->l1_size = header.l1_size;\n\n    l1_vm_state_index = size_to_l1(s, header.size);\n    if (l1_vm_state_index > INT_MAX) {\n        error_setg(errp, \"Image is too big\");\n        ret = -EFBIG;\n        goto fail;\n    }\n    s->l1_vm_state_index = l1_vm_state_index;\n\n    /* the L1 table must contain at least enough entries to put\n       header.size bytes */\n    if (s->l1_size < s->l1_vm_state_index) {\n        error_setg(errp, \"L1 table is too small\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    ret = validate_table_offset(bs, header.l1_table_offset,\n                                header.l1_size, sizeof(uint64_t));\n    if (ret < 0) {\n        error_setg(errp, \"Invalid L1 table offset\");\n        goto fail;\n    }\n    s->l1_table_offset = header.l1_table_offset;\n\n\n    if (s->l1_size > 0) {\n        s->l1_table = g_malloc0(\n            align_offset(s->l1_size * sizeof(uint64_t), 512));\n        ret = bdrv_pread(bs->file, s->l1_table_offset, s->l1_table,\n                         s->l1_size * sizeof(uint64_t));\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not read L1 table\");\n            goto fail;\n        }\n        for(i = 0;i < s->l1_size; i++) {\n            be64_to_cpus(&s->l1_table[i]);\n        }\n    }\n\n    /* alloc L2 table/refcount block cache */\n    s->l2_table_cache = qcow2_cache_create(bs, L2_CACHE_SIZE);\n    s->refcount_block_cache = qcow2_cache_create(bs, REFCOUNT_CACHE_SIZE);\n\n    s->cluster_cache = g_malloc(s->cluster_size);\n    /* one more sector for decompressed data alignment */\n    s->cluster_data = qemu_blockalign(bs, QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size\n                                  + 512);\n    s->cluster_cache_offset = -1;\n    s->flags = flags;\n\n    ret = qcow2_refcount_init(bs);\n    if (ret != 0) {\n        error_setg_errno(errp, -ret, \"Could not initialize refcount handling\");\n        goto fail;\n    }\n\n    QLIST_INIT(&s->cluster_allocs);\n    QTAILQ_INIT(&s->discards);\n\n    /* read qcow2 extensions */\n    if (qcow2_read_extensions(bs, header.header_length, ext_end, NULL,\n        &local_err)) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    /* read the backing file name */\n    if (header.backing_file_offset != 0) {\n        len = header.backing_file_size;\n        if (len > 1023) {\n            len = 1023;\n        }\n        ret = bdrv_pread(bs->file, header.backing_file_offset,\n                         bs->backing_file, len);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not read backing file name\");\n            goto fail;\n        }\n        bs->backing_file[len] = '\\0';\n    }\n\n    ret = qcow2_read_snapshots(bs);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not read snapshots\");\n        goto fail;\n    }\n\n    /* Clear unknown autoclear feature bits */\n    if (!bs->read_only && !(flags & BDRV_O_INCOMING) && s->autoclear_features) {\n        s->autoclear_features = 0;\n        ret = qcow2_update_header(bs);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not update qcow2 header\");\n            goto fail;\n        }\n    }\n\n    /* Initialise locks */\n    qemu_co_mutex_init(&s->lock);\n\n    /* Repair image if dirty */\n    if (!(flags & (BDRV_O_CHECK | BDRV_O_INCOMING)) && !bs->read_only &&\n        (s->incompatible_features & QCOW2_INCOMPAT_DIRTY)) {\n        BdrvCheckResult result = {0};\n\n        ret = qcow2_check(bs, &result, BDRV_FIX_ERRORS);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not repair dirty image\");\n            goto fail;\n        }\n    }\n\n    /* Enable lazy_refcounts according to image and command line options */\n    opts = qemu_opts_create(&qcow2_runtime_opts, NULL, 0, &error_abort);\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    s->use_lazy_refcounts = qemu_opt_get_bool(opts, QCOW2_OPT_LAZY_REFCOUNTS,\n        (s->compatible_features & QCOW2_COMPAT_LAZY_REFCOUNTS));\n\n    s->discard_passthrough[QCOW2_DISCARD_NEVER] = false;\n    s->discard_passthrough[QCOW2_DISCARD_ALWAYS] = true;\n    s->discard_passthrough[QCOW2_DISCARD_REQUEST] =\n        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_REQUEST,\n                          flags & BDRV_O_UNMAP);\n    s->discard_passthrough[QCOW2_DISCARD_SNAPSHOT] =\n        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_SNAPSHOT, true);\n    s->discard_passthrough[QCOW2_DISCARD_OTHER] =\n        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_OTHER, false);\n\n    opt_overlap_check = qemu_opt_get(opts, \"overlap-check\") ?: \"cached\";\n    if (!strcmp(opt_overlap_check, \"none\")) {\n        overlap_check_template = 0;\n    } else if (!strcmp(opt_overlap_check, \"constant\")) {\n        overlap_check_template = QCOW2_OL_CONSTANT;\n    } else if (!strcmp(opt_overlap_check, \"cached\")) {\n        overlap_check_template = QCOW2_OL_CACHED;\n    } else if (!strcmp(opt_overlap_check, \"all\")) {\n        overlap_check_template = QCOW2_OL_ALL;\n    } else {\n        error_setg(errp, \"Unsupported value '%s' for qcow2 option \"\n                   \"'overlap-check'. Allowed are either of the following: \"\n                   \"none, constant, cached, all\", opt_overlap_check);\n        qemu_opts_del(opts);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    s->overlap_check = 0;\n    for (i = 0; i < QCOW2_OL_MAX_BITNR; i++) {\n        /* overlap-check defines a template bitmask, but every flag may be\n         * overwritten through the associated boolean option */\n        s->overlap_check |=\n            qemu_opt_get_bool(opts, overlap_bool_option_names[i],\n                              overlap_check_template & (1 << i)) << i;\n    }\n\n    qemu_opts_del(opts);\n\n    if (s->use_lazy_refcounts && s->qcow_version < 3) {\n        error_setg(errp, \"Lazy refcounts require a qcow2 image with at least \"\n                   \"qemu 1.1 compatibility level\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n#ifdef DEBUG_ALLOC\n    {\n        BdrvCheckResult result = {0};\n        qcow2_check_refcounts(bs, &result, 0);\n    }\n#endif\n    return ret;\n\n fail:\n    g_free(s->unknown_header_fields);\n    cleanup_unknown_header_ext(bs);\n    qcow2_free_snapshots(bs);\n    qcow2_refcount_close(bs);\n    g_free(s->l1_table);\n    /* else pre-write overlap checks in cache_destroy may crash */\n    s->l1_table = NULL;\n    if (s->l2_table_cache) {\n        qcow2_cache_destroy(bs, s->l2_table_cache);\n    }\n    if (s->refcount_block_cache) {\n        qcow2_cache_destroy(bs, s->refcount_block_cache);\n    }\n    g_free(s->cluster_cache);\n    qemu_vfree(s->cluster_data);\n    return ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145715,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int main(int argc G_GNUC_UNUSED, char **argv G_GNUC_UNUSED)\n{\n    SpiceMarshaller *marshaller;\n    SpiceMsgMainShortDataSubMarshall *msg;\n    size_t len, msg_len;\n    int free_res;\n    uint8_t *data;\n    message_destructor_t free_message;\n\n    msg = g_new0(SpiceMsgMainShortDataSubMarshall, 1);\n    msg->data = g_new(uint64_t, 2);\n    msg->dummy_byte = 123;\n    msg->data_size = 2;\n    msg->data[0] = 0x1234567890abcdef;\n    msg->data[1] = 0xfedcba0987654321;\n\n    marshaller = spice_marshaller_new();\n    spice_marshall_msg_main_ShortDataSubMarshall(marshaller, msg);\n    spice_marshaller_flush(marshaller);\n    data = spice_marshaller_linearize(marshaller, 0, &len, &free_res);\n    g_assert_cmpint(len, ==, G_N_ELEMENTS(expected_data));\n    g_assert_true(memcmp(data, expected_data, len) == 0);\n\n    g_free(msg->data);\n    g_free(msg);\n\n    // test demarshaller\n    msg = (SpiceMsgMainShortDataSubMarshall *)\n        spice_parse_msg(data, data + len, SPICE_CHANNEL_MAIN, SPICE_MSG_MAIN_SHORTDATASUBMARSHALL,\n                        0, &msg_len, &free_message);\n\n    g_assert_nonnull(msg);\n    g_assert_cmpint(msg->dummy_byte, ==, 123);\n    g_assert_cmpint(msg->data_size, ==, 2);\n    g_assert_nonnull(msg->data);\n    g_assert_cmpint(msg->data[0], ==, 0x1234567890abcdef);\n    g_assert_cmpint(msg->data[1], ==, 0xfedcba0987654321);\n\n    free_message((uint8_t *) msg);\n\n    if (free_res) {\n        free(data);\n    }\n    spice_marshaller_reset(marshaller);\n\n    SpiceMsgMainZeroes msg_zeroes = { 0x0102 };\n\n    spice_marshall_msg_main_Zeroes(marshaller, &msg_zeroes);\n    spice_marshaller_flush(marshaller);\n    data = spice_marshaller_linearize(marshaller, 0, &len, &free_res);\n    g_assert_cmpint(len, ==, 7);\n    g_assert_true(memcmp(data, \"\\x00\\x02\\x01\\x00\\x00\\x00\\x00\", 7) == 0);\n    if (free_res) {\n        free(data);\n    }\n\n    test_overflow(marshaller);\n\n    spice_marshaller_destroy(marshaller);\n\n    return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145776,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int main(int argc G_GNUC_UNUSED, char **argv G_GNUC_UNUSED)\n{\n    SpiceMarshaller *marshaller;\n    SpiceMsgMainShortDataSubMarshall *msg;\n    size_t len, msg_len;\n    int free_res;\n    uint8_t *data;\n    message_destructor_t free_message;\n\n    msg = g_new0(SpiceMsgMainShortDataSubMarshall, 1);\n    msg->data = g_new(uint64_t, 2);\n    msg->dummy_byte = 123;\n    msg->data_size = 2;\n    msg->data[0] = 0x1234567890abcdef;\n    msg->data[1] = 0xfedcba0987654321;\n\n    marshaller = spice_marshaller_new();\n    spice_marshall_msg_main_ShortDataSubMarshall(marshaller, msg);\n    spice_marshaller_flush(marshaller);\n    data = spice_marshaller_linearize(marshaller, 0, &len, &free_res);\n    g_assert_cmpint(len, ==, G_N_ELEMENTS(expected_data));\n    g_assert_true(memcmp(data, expected_data, len) == 0);\n\n    g_free(msg->data);\n    g_free(msg);\n\n    // test demarshaller\n    msg = (SpiceMsgMainShortDataSubMarshall *)\n        spice_parse_msg(data, data + len, SPICE_CHANNEL_MAIN, SPICE_MSG_MAIN_SHORTDATASUBMARSHALL,\n                        0, &msg_len, &free_message);\n\n    g_assert_nonnull(msg);\n    g_assert_cmpint(msg->dummy_byte, ==, 123);\n    g_assert_cmpint(msg->data_size, ==, 2);\n    g_assert_nonnull(msg->data);\n    g_assert_cmpint(msg->data[0], ==, 0x1234567890abcdef);\n    g_assert_cmpint(msg->data[1], ==, 0xfedcba0987654321);\n\n    free_message((uint8_t *) msg);\n\n    if (free_res) {\n        free(data);\n    }\n    spice_marshaller_reset(marshaller);\n\n    SpiceMsgMainZeroes msg_zeroes = { 0x0102 };\n\n    spice_marshall_msg_main_Zeroes(marshaller, &msg_zeroes);\n    spice_marshaller_flush(marshaller);\n    data = spice_marshaller_linearize(marshaller, 0, &len, &free_res);\n    g_assert_cmpint(len, ==, 7);\n    g_assert_true(memcmp(data, \"\\x00\\x02\\x01\\x00\\x00\\x00\\x00\", 7) == 0);\n    if (free_res) {\n        free(data);\n    }\n\n    test_overflow(marshaller);\n\n    len = 4;\n    data = g_new0(uint8_t, len);\n    memset(data, 0, len);\n    msg = (SpiceMsgMainShortDataSubMarshall *) spice_parse_msg(data, data + len, 1, 3, 0,\n                                                               &msg_len, &free_message);\n    g_assert_null(msg);\n    g_free(data);\n\n    spice_marshaller_destroy(marshaller);\n\n    return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145777,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int odbc_bindcols(odbc_result *result TSRMLS_DC)\n{\n\tRETCODE rc;\n\tint i;\n\tSQLSMALLINT \tcolnamelen; /* Not used */\n\tSQLLEN      \tdisplaysize;\n\tSQLUSMALLINT\tcolfieldid;\n\tint\t\tcharextraalloc;\n\n\tresult->values = (odbc_result_value *) safe_emalloc(sizeof(odbc_result_value), result->numcols, 0);\n\n\tresult->longreadlen = ODBCG(defaultlrl);\n\tresult->binmode = ODBCG(defaultbinmode);\n\n\tfor(i = 0; i < result->numcols; i++) {\n\t\tcharextraalloc = 0;\n\t\tcolfieldid = SQL_COLUMN_DISPLAY_SIZE;\n\n\t\trc = PHP_ODBC_SQLCOLATTRIBUTE(result->stmt, (SQLUSMALLINT)(i+1), PHP_ODBC_SQL_DESC_NAME,\n\t\t\t\tresult->values[i].name, sizeof(result->values[i].name), &colnamelen, 0);\n\t\trc = PHP_ODBC_SQLCOLATTRIBUTE(result->stmt, (SQLUSMALLINT)(i+1), SQL_COLUMN_TYPE, \n\t\t\t\tNULL, 0, NULL, &result->values[i].coltype);\n\t\t\n\t\t/* Don't bind LONG / BINARY columns, so that fetch behaviour can\n\t\t * be controlled by odbc_binmode() / odbc_longreadlen()\n\t\t */\n\t\t\n\t\tswitch(result->values[i].coltype) {\n\t\t\tcase SQL_BINARY:\n\t\t\tcase SQL_VARBINARY:\n\t\t\tcase SQL_LONGVARBINARY:\n\t\t\tcase SQL_LONGVARCHAR:\n#if defined(ODBCVER) && (ODBCVER >= 0x0300)\n\t\t\tcase SQL_WLONGVARCHAR:\n#endif\n\t\t\t\tresult->values[i].value = NULL;\n\t\t\t\tbreak;\n\t\t\t\t\n#ifdef HAVE_ADABAS\n\t\t\tcase SQL_TIMESTAMP:\n\t\t\t\tresult->values[i].value = (char *)emalloc(27);\n\t\t\t\tSQLBindCol(result->stmt, (SQLUSMALLINT)(i+1), SQL_C_CHAR, result->values[i].value,\n\t\t\t\t\t\t\t27, &result->values[i].vallen);\n\t\t\t\tbreak;\n#endif /* HAVE_ADABAS */\n\t\t\tcase SQL_CHAR:\n\t\t\tcase SQL_VARCHAR:\n#if defined(ODBCVER) && (ODBCVER >= 0x0300)\n\t\t\tcase SQL_WCHAR:\n\t\t\tcase SQL_WVARCHAR:\n\t\t\t\tcolfieldid = SQL_DESC_OCTET_LENGTH;\n#else\n\t\t\t\tcharextraalloc = 1;\n#endif\n\t\t\tdefault:\n\t\t\t\trc = PHP_ODBC_SQLCOLATTRIBUTE(result->stmt, (SQLUSMALLINT)(i+1), colfieldid,\n\t\t\t\t\t\t\t\tNULL, 0, NULL, &displaysize);\n#if defined(ODBCVER) && (ODBCVER >= 0x0300)\n\t\t\t\tif (rc != SQL_SUCCESS && rc != SQL_SUCCESS_WITH_INFO && colfieldid == SQL_DESC_OCTET_LENGTH) {\n\t\t\t\t\t /* This is  a quirk for ODBC 2.0 compatibility for broken driver implementations.\n\t\t\t\t\t  */\n\t\t\t\t\tcharextraalloc = 1;\n\t\t\t\t\trc = SQLColAttributes(result->stmt, (SQLUSMALLINT)(i+1), SQL_COLUMN_DISPLAY_SIZE,\n\t\t\t\t\t\t\t\tNULL, 0, NULL, &displaysize);\n\t\t\t\t}\n#endif\n\t\t\t\t/* Workaround for drivers that report NVARCHAR(MAX) columns as SQL_WVARCHAR with size 0 (bug #69975) */\n\t\t\t\tif (result->values[i].coltype == SQL_WVARCHAR && displaysize == 0) {\n\t\t\t\t\tresult->values[i].coltype = SQL_WLONGVARCHAR;\n\t\t\t\t\tresult->values[i].value = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* Workaround for Oracle ODBC Driver bug (#50162) when fetching TIMESTAMP column */\n\t\t\t\tif (result->values[i].coltype == SQL_TIMESTAMP) {\n\t\t\t\t\tdisplaysize += 3;\n\t\t\t\t}\n\n\t\t\t\tif (charextraalloc) {\n\t\t\t\t\t/* Since we don't know the exact # of bytes, allocate extra */\n\t\t\t\t\tdisplaysize *= 4;\n\t\t\t\t}\n\t\t\t\tresult->values[i].value = (char *)emalloc(displaysize + 1);\n\t\t\t\trc = SQLBindCol(result->stmt, (SQLUSMALLINT)(i+1), SQL_C_CHAR, result->values[i].value,\n\t\t\t\t\t\t\tdisplaysize + 1, &result->values[i].vallen);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn 1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145802,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int odbc_bindcols(odbc_result *result TSRMLS_DC)\n{\n\tRETCODE rc;\n\tint i;\n\tSQLSMALLINT \tcolnamelen; /* Not used */\n\tSQLLEN      \tdisplaysize;\n\tSQLUSMALLINT\tcolfieldid;\n\tint\t\tcharextraalloc;\n\n\tresult->values = (odbc_result_value *) safe_emalloc(sizeof(odbc_result_value), result->numcols, 0);\n\n\tresult->longreadlen = ODBCG(defaultlrl);\n\tresult->binmode = ODBCG(defaultbinmode);\n\n\tfor(i = 0; i < result->numcols; i++) {\n\t\tcharextraalloc = 0;\n\t\tcolfieldid = SQL_COLUMN_DISPLAY_SIZE;\n\n\t\trc = PHP_ODBC_SQLCOLATTRIBUTE(result->stmt, (SQLUSMALLINT)(i+1), PHP_ODBC_SQL_DESC_NAME,\n\t\t\t\tresult->values[i].name, sizeof(result->values[i].name), &colnamelen, 0);\n\t\trc = PHP_ODBC_SQLCOLATTRIBUTE(result->stmt, (SQLUSMALLINT)(i+1), SQL_COLUMN_TYPE, \n\t\t\t\tNULL, 0, NULL, &result->values[i].coltype);\n\t\t\n\t\t/* Don't bind LONG / BINARY columns, so that fetch behaviour can\n\t\t * be controlled by odbc_binmode() / odbc_longreadlen()\n\t\t */\n\t\t\n\t\tswitch(result->values[i].coltype) {\n\t\t\tcase SQL_BINARY:\n\t\t\tcase SQL_VARBINARY:\n\t\t\tcase SQL_LONGVARBINARY:\n\t\t\tcase SQL_LONGVARCHAR:\n#if defined(ODBCVER) && (ODBCVER >= 0x0300)\n\t\t\tcase SQL_WLONGVARCHAR:\n#endif\n\t\t\t\tresult->values[i].value = NULL;\n\t\t\t\tbreak;\n\t\t\t\t\n#ifdef HAVE_ADABAS\n\t\t\tcase SQL_TIMESTAMP:\n\t\t\t\tresult->values[i].value = (char *)emalloc(27);\n\t\t\t\tSQLBindCol(result->stmt, (SQLUSMALLINT)(i+1), SQL_C_CHAR, result->values[i].value,\n\t\t\t\t\t\t\t27, &result->values[i].vallen);\n\t\t\t\tbreak;\n#endif /* HAVE_ADABAS */\n\t\t\tcase SQL_CHAR:\n\t\t\tcase SQL_VARCHAR:\n#if defined(ODBCVER) && (ODBCVER >= 0x0300)\n\t\t\tcase SQL_WCHAR:\n\t\t\tcase SQL_WVARCHAR:\n\t\t\t\tcolfieldid = SQL_DESC_OCTET_LENGTH;\n#else\n\t\t\t\tcharextraalloc = 1;\n#endif\n\t\t\tdefault:\n\t\t\t\trc = PHP_ODBC_SQLCOLATTRIBUTE(result->stmt, (SQLUSMALLINT)(i+1), colfieldid,\n\t\t\t\t\t\t\t\tNULL, 0, NULL, &displaysize);\n#if defined(ODBCVER) && (ODBCVER >= 0x0300)\n\t\t\t\tif (rc != SQL_SUCCESS && rc != SQL_SUCCESS_WITH_INFO && colfieldid == SQL_DESC_OCTET_LENGTH) {\n\t\t\t\t\t /* This is  a quirk for ODBC 2.0 compatibility for broken driver implementations.\n\t\t\t\t\t  */\n\t\t\t\t\tcharextraalloc = 1;\n\t\t\t\t\trc = SQLColAttributes(result->stmt, (SQLUSMALLINT)(i+1), SQL_COLUMN_DISPLAY_SIZE,\n\t\t\t\t\t\t\t\tNULL, 0, NULL, &displaysize);\n\t\t\t\t}\n\n\t\t\t\t/* Workaround for drivers that report NVARCHAR(MAX) columns as SQL_WVARCHAR with size 0 (bug #69975) */\n\t\t\t\tif (result->values[i].coltype == SQL_WVARCHAR && displaysize == 0) {\n\t\t\t\t\tresult->values[i].coltype = SQL_WLONGVARCHAR;\n\t\t\t\t\tresult->values[i].value = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n\t\t\t\t/* Workaround for Oracle ODBC Driver bug (#50162) when fetching TIMESTAMP column */\n\t\t\t\tif (result->values[i].coltype == SQL_TIMESTAMP) {\n\t\t\t\t\tdisplaysize += 3;\n\t\t\t\t}\n\n\t\t\t\tif (charextraalloc) {\n\t\t\t\t\t/* Since we don't know the exact # of bytes, allocate extra */\n\t\t\t\t\tdisplaysize *= 4;\n\t\t\t\t}\n\t\t\t\tresult->values[i].value = (char *)emalloc(displaysize + 1);\n\t\t\t\trc = SQLBindCol(result->stmt, (SQLUSMALLINT)(i+1), SQL_C_CHAR, result->values[i].value,\n\t\t\t\t\t\t\tdisplaysize + 1, &result->values[i].vallen);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn 1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145803,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "long VideoTrack::Parse(Segment* pSegment, const Info& info,\n                       long long element_start, long long element_size,\n                       VideoTrack*& pResult) {\n  if (pResult)\n    return -1;\n\n  if (info.type != Track::kVideo)\n    return -1;\n\n  long long width = 0;\n  long long height = 0;\n  long long display_width = 0;\n  long long display_height = 0;\n  long long display_unit = 0;\n  long long stereo_mode = 0;\n\n  double rate = 0.0;\n  char* colour_space = NULL;\n\n  IMkvReader* const pReader = pSegment->m_pReader;\n\n  const Settings& s = info.settings;\n  assert(s.start >= 0);\n  assert(s.size >= 0);\n\n  long long pos = s.start;\n  assert(pos >= 0);\n\n  const long long stop = pos + s.size;\n\n  Colour* colour = NULL;\n  std::unique_ptr<Projection> projection_ptr;\n\n  while (pos < stop) {\n    long long id, size;\n\n    const long status = ParseElementHeader(pReader, pos, stop, id, size);\n\n    if (status < 0)  // error\n      return status;\n\n    if (id == libwebm::kMkvPixelWidth) {\n      width = UnserializeUInt(pReader, pos, size);\n\n      if (width <= 0)\n        return E_FILE_FORMAT_INVALID;\n    } else if (id == libwebm::kMkvPixelHeight) {\n      height = UnserializeUInt(pReader, pos, size);\n\n      if (height <= 0)\n        return E_FILE_FORMAT_INVALID;\n    } else if (id == libwebm::kMkvDisplayWidth) {\n      display_width = UnserializeUInt(pReader, pos, size);\n\n      if (display_width <= 0)\n        return E_FILE_FORMAT_INVALID;\n    } else if (id == libwebm::kMkvDisplayHeight) {\n      display_height = UnserializeUInt(pReader, pos, size);\n\n      if (display_height <= 0)\n        return E_FILE_FORMAT_INVALID;\n    } else if (id == libwebm::kMkvDisplayUnit) {\n      display_unit = UnserializeUInt(pReader, pos, size);\n\n      if (display_unit < 0)\n        return E_FILE_FORMAT_INVALID;\n    } else if (id == libwebm::kMkvStereoMode) {\n      stereo_mode = UnserializeUInt(pReader, pos, size);\n\n      if (stereo_mode < 0)\n        return E_FILE_FORMAT_INVALID;\n    } else if (id == libwebm::kMkvFrameRate) {\n      const long status = UnserializeFloat(pReader, pos, size, rate);\n\n      if (status < 0)\n        return status;\n\n      if (rate <= 0)\n        return E_FILE_FORMAT_INVALID;\n    } else if (id == libwebm::kMkvColour) {\n      if (!Colour::Parse(pReader, pos, size, &colour))\n        return E_FILE_FORMAT_INVALID;\n    } else if (id == libwebm::kMkvProjection) {\n      Projection* projection = NULL;\n      if (!Projection::Parse(pReader, pos, size, &projection)) {\n        return E_FILE_FORMAT_INVALID;\n      } else {\n        projection_ptr.reset(projection);\n      }\n    } else if (id == libwebm::kMkvColourSpace) {\n      const long status = UnserializeString(pReader, pos, size, colour_space);\n      if (status < 0)\n        return status;\n    }\n\n    pos += size;  // consume payload\n    if (pos > stop)\n      return E_FILE_FORMAT_INVALID;\n  }\n\n  if (pos != stop)\n    return E_FILE_FORMAT_INVALID;\n\n  VideoTrack* const pTrack =\n      new (std::nothrow) VideoTrack(pSegment, element_start, element_size);\n\n  if (pTrack == NULL)\n    return -1;  // generic error\n\n  const int status = info.Copy(pTrack->m_info);\n\n  if (status) {  // error\n    delete pTrack;\n    return status;\n  }\n\n  pTrack->m_width = width;\n  pTrack->m_height = height;\n  pTrack->m_display_width = display_width;\n  pTrack->m_display_height = display_height;\n  pTrack->m_display_unit = display_unit;\n  pTrack->m_stereo_mode = stereo_mode;\n  pTrack->m_rate = rate;\n  pTrack->m_colour = colour;\n  pTrack->m_colour_space = colour_space;\n  pTrack->m_projection = projection_ptr.release();\n\n  pResult = pTrack;\n  return 0;  // success\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145804,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "long VideoTrack::Parse(Segment* pSegment, const Info& info,\n                       long long element_start, long long element_size,\n                       VideoTrack*& pResult) {\n  if (pResult)\n    return -1;\n\n  if (info.type != Track::kVideo)\n    return -1;\n\n  long long width = 0;\n  long long height = 0;\n  long long display_width = 0;\n  long long display_height = 0;\n  long long display_unit = 0;\n  long long stereo_mode = 0;\n\n  double rate = 0.0;\n  char* colour_space = NULL;\n\n  IMkvReader* const pReader = pSegment->m_pReader;\n\n  const Settings& s = info.settings;\n  assert(s.start >= 0);\n  assert(s.size >= 0);\n\n  long long pos = s.start;\n  assert(pos >= 0);\n\n  const long long stop = pos + s.size;\n\n  std::unique_ptr<Colour> colour_ptr;\n  std::unique_ptr<Projection> projection_ptr;\n\n  while (pos < stop) {\n    long long id, size;\n\n    const long status = ParseElementHeader(pReader, pos, stop, id, size);\n\n    if (status < 0)  // error\n      return status;\n\n    if (id == libwebm::kMkvPixelWidth) {\n      width = UnserializeUInt(pReader, pos, size);\n\n      if (width <= 0)\n        return E_FILE_FORMAT_INVALID;\n    } else if (id == libwebm::kMkvPixelHeight) {\n      height = UnserializeUInt(pReader, pos, size);\n\n      if (height <= 0)\n        return E_FILE_FORMAT_INVALID;\n    } else if (id == libwebm::kMkvDisplayWidth) {\n      display_width = UnserializeUInt(pReader, pos, size);\n\n      if (display_width <= 0)\n        return E_FILE_FORMAT_INVALID;\n    } else if (id == libwebm::kMkvDisplayHeight) {\n      display_height = UnserializeUInt(pReader, pos, size);\n\n      if (display_height <= 0)\n        return E_FILE_FORMAT_INVALID;\n    } else if (id == libwebm::kMkvDisplayUnit) {\n      display_unit = UnserializeUInt(pReader, pos, size);\n\n      if (display_unit < 0)\n        return E_FILE_FORMAT_INVALID;\n    } else if (id == libwebm::kMkvStereoMode) {\n      stereo_mode = UnserializeUInt(pReader, pos, size);\n\n      if (stereo_mode < 0)\n        return E_FILE_FORMAT_INVALID;\n    } else if (id == libwebm::kMkvFrameRate) {\n      const long status = UnserializeFloat(pReader, pos, size, rate);\n\n      if (status < 0)\n        return status;\n\n      if (rate <= 0)\n        return E_FILE_FORMAT_INVALID;\n    } else if (id == libwebm::kMkvColour) {\n      Colour* colour = NULL;\n      if (!Colour::Parse(pReader, pos, size, &colour)) {\n        return E_FILE_FORMAT_INVALID;\n      } else {\n        colour_ptr.reset(colour);\n      }\n    } else if (id == libwebm::kMkvProjection) {\n      Projection* projection = NULL;\n      if (!Projection::Parse(pReader, pos, size, &projection)) {\n        return E_FILE_FORMAT_INVALID;\n      } else {\n        projection_ptr.reset(projection);\n      }\n    } else if (id == libwebm::kMkvColourSpace) {\n      const long status = UnserializeString(pReader, pos, size, colour_space);\n      if (status < 0)\n        return status;\n    }\n\n    pos += size;  // consume payload\n    if (pos > stop)\n      return E_FILE_FORMAT_INVALID;\n  }\n\n  if (pos != stop)\n    return E_FILE_FORMAT_INVALID;\n\n  VideoTrack* const pTrack =\n      new (std::nothrow) VideoTrack(pSegment, element_start, element_size);\n\n  if (pTrack == NULL)\n    return -1;  // generic error\n\n  const int status = info.Copy(pTrack->m_info);\n\n  if (status) {  // error\n    delete pTrack;\n    return status;\n  }\n\n  pTrack->m_width = width;\n  pTrack->m_height = height;\n  pTrack->m_display_width = display_width;\n  pTrack->m_display_height = display_height;\n  pTrack->m_display_unit = display_unit;\n  pTrack->m_stereo_mode = stereo_mode;\n  pTrack->m_rate = rate;\n  pTrack->m_colour = colour_ptr.release();\n  pTrack->m_colour_space = colour_space;\n  pTrack->m_projection = projection_ptr.release();\n\n  pResult = pTrack;\n  return 0;  // success\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145805,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void ppp_cp_parse_cr(struct net_device *dev, u16 pid, u8 id,\n\t\t\t    unsigned int req_len, const u8 *data)\n{\n\tstatic u8 const valid_accm[6] = { LCP_OPTION_ACCM, 6, 0, 0, 0, 0 };\n\tconst u8 *opt;\n\tu8 *out;\n\tunsigned int len = req_len, nak_len = 0, rej_len = 0;\n\n\tif (!(out = kmalloc(len, GFP_ATOMIC))) {\n\t\tdev->stats.rx_dropped++;\n\t\treturn;\t/* out of memory, ignore CR packet */\n\t}\n\n\tfor (opt = data; len; len -= opt[1], opt += opt[1]) {\n\t\tif (len < 2 || len < opt[1]) {\n\t\t\tdev->stats.rx_errors++;\n\t\t\tkfree(out);\n\t\t\treturn; /* bad packet, drop silently */\n\t\t}\n\n\t\tif (pid == PID_LCP)\n\t\t\tswitch (opt[0]) {\n\t\t\tcase LCP_OPTION_MRU:\n\t\t\t\tcontinue; /* MRU always OK and > 1500 bytes? */\n\n\t\t\tcase LCP_OPTION_ACCM: /* async control character map */\n\t\t\t\tif (!memcmp(opt, valid_accm,\n\t\t\t\t\t    sizeof(valid_accm)))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!rej_len) { /* NAK it */\n\t\t\t\t\tmemcpy(out + nak_len, valid_accm,\n\t\t\t\t\t       sizeof(valid_accm));\n\t\t\t\t\tnak_len += sizeof(valid_accm);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LCP_OPTION_MAGIC:\n\t\t\t\tif (opt[1] != 6 || (!opt[2] && !opt[3] &&\n\t\t\t\t\t\t    !opt[4] && !opt[5]))\n\t\t\t\t\tbreak; /* reject invalid magic number */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t/* reject this option */\n\t\tmemcpy(out + rej_len, opt, opt[1]);\n\t\trej_len += opt[1];\n\t}\n\n\tif (rej_len)\n\t\tppp_cp_event(dev, pid, RCR_BAD, CP_CONF_REJ, id, rej_len, out);\n\telse if (nak_len)\n\t\tppp_cp_event(dev, pid, RCR_BAD, CP_CONF_NAK, id, nak_len, out);\n\telse\n\t\tppp_cp_event(dev, pid, RCR_GOOD, CP_CONF_ACK, id, req_len, data);\n\n\tkfree(out);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145812,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void ppp_cp_parse_cr(struct net_device *dev, u16 pid, u8 id,\n\t\t\t    unsigned int req_len, const u8 *data)\n{\n\tstatic u8 const valid_accm[6] = { LCP_OPTION_ACCM, 6, 0, 0, 0, 0 };\n\tconst u8 *opt;\n\tu8 *out;\n\tunsigned int len = req_len, nak_len = 0, rej_len = 0;\n\n\tif (!(out = kmalloc(len, GFP_ATOMIC))) {\n\t\tdev->stats.rx_dropped++;\n\t\treturn;\t/* out of memory, ignore CR packet */\n\t}\n\n\tfor (opt = data; len; len -= opt[1], opt += opt[1]) {\n\t\tif (len < 2 || opt[1] < 2 || len < opt[1])\n\t\t\tgoto err_out;\n\n\t\tif (pid == PID_LCP)\n\t\t\tswitch (opt[0]) {\n\t\t\tcase LCP_OPTION_MRU:\n\t\t\t\tcontinue; /* MRU always OK and > 1500 bytes? */\n\n\t\t\tcase LCP_OPTION_ACCM: /* async control character map */\n\t\t\t\tif (opt[1] < sizeof(valid_accm))\n\t\t\t\t\tgoto err_out;\n\t\t\t\tif (!memcmp(opt, valid_accm,\n\t\t\t\t\t    sizeof(valid_accm)))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!rej_len) { /* NAK it */\n\t\t\t\t\tmemcpy(out + nak_len, valid_accm,\n\t\t\t\t\t       sizeof(valid_accm));\n\t\t\t\t\tnak_len += sizeof(valid_accm);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LCP_OPTION_MAGIC:\n\t\t\t\tif (len < 6)\n\t\t\t\t\tgoto err_out;\n\t\t\t\tif (opt[1] != 6 || (!opt[2] && !opt[3] &&\n\t\t\t\t\t\t    !opt[4] && !opt[5]))\n\t\t\t\t\tbreak; /* reject invalid magic number */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t/* reject this option */\n\t\tmemcpy(out + rej_len, opt, opt[1]);\n\t\trej_len += opt[1];\n\t}\n\n\tif (rej_len)\n\t\tppp_cp_event(dev, pid, RCR_BAD, CP_CONF_REJ, id, rej_len, out);\n\telse if (nak_len)\n\t\tppp_cp_event(dev, pid, RCR_BAD, CP_CONF_NAK, id, nak_len, out);\n\telse\n\t\tppp_cp_event(dev, pid, RCR_GOOD, CP_CONF_ACK, id, req_len, data);\n\n\tkfree(out);\n\treturn;\n\nerr_out:\n\tdev->stats.rx_errors++;\n\tkfree(out);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145813,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "decodenetnum(\n\tconst char *num,\n\tsockaddr_u *netnum\n\t)\n{\n\tstruct addrinfo hints, *ai = NULL;\n\tint err;\n\tu_short port;\n\tconst char *cp;\n\tconst char *port_str;\n\tchar *pp;\n\tchar *np;\n\tchar name[80];\n\n\tREQUIRE(num != NULL);\n\tREQUIRE(strlen(num) < sizeof(name));\n\n\tport_str = NULL;\n\tif ('[' != num[0]) {\n\t\t/*\n\t\t * to distinguish IPv6 embedded colons from a port\n\t\t * specification on an IPv4 address, assume all \n\t\t * legal IPv6 addresses have at least two colons.\n\t\t */\n\t\tpp = strchr(num, ':');\n\t\tif (NULL == pp)\n\t\t\tcp = num;\t/* no colons */\n\t\telse if (NULL != strchr(pp + 1, ':'))\n\t\t\tcp = num;\t/* two or more colons */\n\t\telse {\t\t\t/* one colon */\n\t\t\tstrlcpy(name, num, sizeof(name));\n\t\t\tcp = name;\n\t\t\tpp = strchr(cp, ':');\n\t\t\t*pp = '\\0';\n\t\t\tport_str = pp + 1;\n\t\t}\n\t} else {\n\t\tcp = num + 1;\n\t\tnp = name; \n\t\twhile (*cp && ']' != *cp)\n\t\t\t*np++ = *cp++;\n\t\t*np = 0;\n\t\tif (']' == cp[0] && ':' == cp[1] && '\\0' != cp[2])\n\t\t\tport_str = &cp[2];\n\t\tcp = name; \n\t}\n\tZERO(hints);\n\thints.ai_flags = Z_AI_NUMERICHOST;\n\terr = getaddrinfo(cp, \"ntp\", &hints, &ai);\n\tif (err != 0)\n\t\treturn 0;\n\tINSIST(ai->ai_addrlen <= sizeof(*netnum));\n\tZERO(*netnum);\n\tmemcpy(netnum, ai->ai_addr, ai->ai_addrlen);\n\tfreeaddrinfo(ai);\n\tif (NULL == port_str || 1 != sscanf(port_str, \"%hu\", &port))\n\t\tport = NTP_PORT;\n\tSET_PORT(netnum, port);\n\treturn 1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145820,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "decodenetnum(\n\tconst char *num,\n\tsockaddr_u *netnum\n\t)\n{\n\tstruct addrinfo hints, *ai = NULL;\n\tint err;\n\tu_short port;\n\tconst char *cp;\n\tconst char *port_str;\n\tchar *pp;\n\tchar *np;\n\tchar name[80];\n\n\tREQUIRE(num != NULL);\n\n\tif (strlen(num) >= sizeof(name)) {\n\t\treturn 0;\n\t}\n\n\tport_str = NULL;\n\tif ('[' != num[0]) {\n\t\t/*\n\t\t * to distinguish IPv6 embedded colons from a port\n\t\t * specification on an IPv4 address, assume all \n\t\t * legal IPv6 addresses have at least two colons.\n\t\t */\n\t\tpp = strchr(num, ':');\n\t\tif (NULL == pp)\n\t\t\tcp = num;\t/* no colons */\n\t\telse if (NULL != strchr(pp + 1, ':'))\n\t\t\tcp = num;\t/* two or more colons */\n\t\telse {\t\t\t/* one colon */\n\t\t\tstrlcpy(name, num, sizeof(name));\n\t\t\tcp = name;\n\t\t\tpp = strchr(cp, ':');\n\t\t\t*pp = '\\0';\n\t\t\tport_str = pp + 1;\n\t\t}\n\t} else {\n\t\tcp = num + 1;\n\t\tnp = name; \n\t\twhile (*cp && ']' != *cp)\n\t\t\t*np++ = *cp++;\n\t\t*np = 0;\n\t\tif (']' == cp[0] && ':' == cp[1] && '\\0' != cp[2])\n\t\t\tport_str = &cp[2];\n\t\tcp = name; \n\t}\n\tZERO(hints);\n\thints.ai_flags = Z_AI_NUMERICHOST;\n\terr = getaddrinfo(cp, \"ntp\", &hints, &ai);\n\tif (err != 0)\n\t\treturn 0;\n\tINSIST(ai->ai_addrlen <= sizeof(*netnum));\n\tZERO(*netnum);\n\tmemcpy(netnum, ai->ai_addr, ai->ai_addrlen);\n\tfreeaddrinfo(ai);\n\tif (NULL == port_str || 1 != sscanf(port_str, \"%hu\", &port))\n\t\tport = NTP_PORT;\n\tSET_PORT(netnum, port);\n\treturn 1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145821,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int is_ntfs_dotgit(const char *name)\n{\n\tsize_t len;\n\n\tfor (len = 0; ; len++)\n\t\tif (!name[len] || name[len] == '\\\\' || is_dir_sep(name[len])) {\n\t\t\tif (only_spaces_and_periods(name, len, 4) &&\n\t\t\t\t\t!strncasecmp(name, \".git\", 4))\n\t\t\t\treturn 1;\n\t\t\tif (only_spaces_and_periods(name, len, 5) &&\n\t\t\t\t\t!strncasecmp(name, \"git~1\", 5))\n\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145834,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int is_ntfs_dotgit(const char *name)\n{\n\tsize_t len;\n\n\tfor (len = 0; ; len++)\n\t\tif (!name[len] || name[len] == '\\\\' || is_dir_sep(name[len]) ||\n\t\t    name[len] == ':') {\n\t\t\tif (only_spaces_and_periods(name, len, 4) &&\n\t\t\t\t\t!strncasecmp(name, \".git\", 4))\n\t\t\t\treturn 1;\n\t\t\tif (only_spaces_and_periods(name, len, 5) &&\n\t\t\t\t\t!strncasecmp(name, \"git~1\", 5))\n\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145835,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "pam_sm_authenticate (pam_handle_t * pamh,\n\t\t     int flags, int argc, const char **argv)\n{\n  int retval, rc;\n  const char *user = NULL;\n  const char *password = NULL;\n  char otp[MAX_TOKEN_ID_LEN + TOKEN_OTP_LEN + 1] = { 0 };\n  char otp_id[MAX_TOKEN_ID_LEN + 1] = { 0 };\n  int password_len = 0;\n  int skip_bytes = 0;\n  int valid_token = 0;\n  struct pam_conv *conv;\n  struct pam_message *pmsg[1], msg[1];\n  struct pam_response *resp;\n  int nargs = 1;\n  ykclient_t *ykc = NULL;\n  struct cfg cfg_st;\n  struct cfg *cfg = &cfg_st; /* for DBG macro */\n\n  parse_cfg (flags, argc, argv, cfg);\n\n  retval = pam_get_user (pamh, &user, NULL);\n  if (retval != PAM_SUCCESS)\n    {\n      DBG ((\"get user returned error: %s\", pam_strerror (pamh, retval)));\n      goto done;\n    }\n  DBG ((\"get user returned: %s\", user));\n\n  if (cfg->mode == CHRESP) {\n#if HAVE_LIBYKPERS_1\n    return do_challenge_response(pamh, cfg, user);\n#else\n    DBG ((\"no support for challenge/response\"));\n    retval = PAM_AUTH_ERR;\n    goto done;\n#endif\n  }\n\n  if (cfg->try_first_pass || cfg->use_first_pass)\n    {\n      retval = pam_get_item (pamh, PAM_AUTHTOK, (const void **) &password);\n      if (retval != PAM_SUCCESS)\n\t{\n\t  DBG ((\"get password returned error: %s\",\n\t      pam_strerror (pamh, retval)));\n\t  goto done;\n\t}\n      DBG ((\"get password returned: %s\", password));\n    }\n\n  if (cfg->use_first_pass && password == NULL)\n    {\n      DBG ((\"use_first_pass set and no password, giving up\"));\n      retval = PAM_AUTH_ERR;\n      goto done;\n    }\n\n  rc = ykclient_init (&ykc);\n  if (rc != YKCLIENT_OK)\n    {\n      DBG ((\"ykclient_init() failed (%d): %s\", rc, ykclient_strerror (rc)));\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n\n  rc = ykclient_set_client_b64 (ykc, cfg->client_id, cfg->client_key);\n  if (rc != YKCLIENT_OK)\n    {\n      DBG ((\"ykclient_set_client_b64() failed (%d): %s\",\n\t    rc, ykclient_strerror (rc)));\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n\n  if (cfg->capath)\n    ykclient_set_ca_path (ykc, cfg->capath);\n\n  if (cfg->url)\n    ykclient_set_url_template (ykc, cfg->url);\n\n  if (password == NULL)\n    {\n      retval = pam_get_item (pamh, PAM_CONV, (const void **) &conv);\n      if (retval != PAM_SUCCESS)\n\t{\n\t  DBG ((\"get conv returned error: %s\", pam_strerror (pamh, retval)));\n\t  goto done;\n\t}\n\n      pmsg[0] = &msg[0];\n      {\n\tconst char *query_template = \"Yubikey for `%s': \";\n\tsize_t len = strlen (query_template) + strlen (user);\n\tsize_t wrote;\n\n\tmsg[0].msg = malloc (len);\n\tif (!msg[0].msg)\n\t  {\n\t    retval = PAM_BUF_ERR;\n\t    goto done;\n\t  }\n\n\twrote = snprintf ((char *) msg[0].msg, len, query_template, user);\n\tif (wrote < 0 || wrote >= len)\n\t  {\n\t    retval = PAM_BUF_ERR;\n\t    goto done;\n\t  }\n      }\n      msg[0].msg_style = cfg->verbose_otp ? PAM_PROMPT_ECHO_ON : PAM_PROMPT_ECHO_OFF;\n      resp = NULL;\n\n      retval = conv->conv (nargs, (const struct pam_message **) pmsg,\n\t\t\t   &resp, conv->appdata_ptr);\n\n      free ((char *) msg[0].msg);\n\n      if (retval != PAM_SUCCESS)\n\t{\n\t  DBG ((\"conv returned error: %s\", pam_strerror (pamh, retval)));\n\t  goto done;\n\t}\n\n      if (resp->resp == NULL)\n\t{\n\t  DBG ((\"conv returned NULL passwd?\"));\n\t  goto done;\n\t}\n\n      DBG ((\"conv returned %i bytes\", strlen(resp->resp)));\n\n      password = resp->resp;\n    }\n\n  password_len = strlen (password);\n  if (password_len < (cfg->token_id_length + TOKEN_OTP_LEN))\n    {\n      DBG ((\"OTP too short to be considered : %i < %i\", password_len, (cfg->token_id_length + TOKEN_OTP_LEN)));\n      retval = PAM_AUTH_ERR;\n      goto done;\n    }\n\n  /* In case the input was systempassword+YubiKeyOTP, we want to skip over\n     \"systempassword\" when copying the token_id and OTP to separate buffers */\n  skip_bytes = password_len - (cfg->token_id_length + TOKEN_OTP_LEN);\n\n  DBG ((\"Skipping first %i bytes. Length is %i, token_id set to %i and token OTP always %i.\",\n\tskip_bytes, password_len, cfg->token_id_length, TOKEN_OTP_LEN));\n\n  /* Copy full YubiKey output (public ID + OTP) into otp */\n  strncpy (otp, password + skip_bytes, sizeof (otp) - 1);\n  /* Copy only public ID into otp_id. Destination buffer is zeroed. */\n  strncpy (otp_id, password + skip_bytes, cfg->token_id_length);\n\n  DBG ((\"OTP: %s ID: %s \", otp, otp_id));\n\n  /* user entered their system password followed by generated OTP? */\n  if (password_len > TOKEN_OTP_LEN + cfg->token_id_length)\n    {\n      char *onlypasswd = strdup (password);\n\n      onlypasswd[password_len - (TOKEN_OTP_LEN + cfg->token_id_length)] = '\\0';\n\n      DBG ((\"Extracted a probable system password entered before the OTP - \"\n\t    \"setting item PAM_AUTHTOK\"));\n\n      retval = pam_set_item (pamh, PAM_AUTHTOK, onlypasswd);\n      free (onlypasswd);\n      if (retval != PAM_SUCCESS)\n\t{\n\t  DBG ((\"set_item returned error: %s\", pam_strerror (pamh, retval)));\n\t  goto done;\n\t}\n    }\n  else\n    password = NULL;\n\n  rc = ykclient_request (ykc, otp);\n\n  DBG ((\"ykclient return value (%d): %s\", rc,\n\tykclient_strerror (rc)));\n\n  switch (rc)\n    {\n    case YKCLIENT_OK:\n      break;\n\n    case YKCLIENT_BAD_OTP:\n    case YKCLIENT_REPLAYED_OTP:\n      retval = PAM_AUTH_ERR;\n      goto done;\n\n    default:\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n\n  /* authorize the user with supplied token id */\n  if (cfg->ldapserver != NULL || cfg->ldap_uri != NULL)\n    valid_token = authorize_user_token_ldap (cfg, user, otp_id);\n  else\n    valid_token = authorize_user_token (cfg, user, otp_id);\n\n  if (valid_token == 0)\n    {\n      DBG ((\"Yubikey not authorized to login as user\"));\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n\n  retval = PAM_SUCCESS;\n\ndone:\n  if (ykc)\n    ykclient_done (&ykc);\n  if (cfg->alwaysok && retval != PAM_SUCCESS)\n    {\n      DBG ((\"alwaysok needed (otherwise return with %d)\", retval));\n      retval = PAM_SUCCESS;\n    }\n  DBG ((\"done. [%s]\", pam_strerror (pamh, retval)));\n  pam_set_data (pamh, \"yubico_setcred_return\", (void*) (intptr_t) retval, NULL);\n\n  return retval;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145840,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "pam_sm_authenticate (pam_handle_t * pamh,\n\t\t     int flags, int argc, const char **argv)\n{\n  int retval, rc;\n  const char *user = NULL;\n  const char *password = NULL;\n  char otp[MAX_TOKEN_ID_LEN + TOKEN_OTP_LEN + 1] = { 0 };\n  char otp_id[MAX_TOKEN_ID_LEN + 1] = { 0 };\n  int password_len = 0;\n  int skip_bytes = 0;\n  int valid_token = 0;\n  struct pam_conv *conv;\n  struct pam_message *pmsg[1], msg[1];\n  struct pam_response *resp;\n  int nargs = 1;\n  ykclient_t *ykc = NULL;\n  struct cfg cfg_st;\n  struct cfg *cfg = &cfg_st; /* for DBG macro */\n\n  parse_cfg (flags, argc, argv, cfg);\n\n  retval = pam_get_user (pamh, &user, NULL);\n  if (retval != PAM_SUCCESS)\n    {\n      DBG ((\"get user returned error: %s\", pam_strerror (pamh, retval)));\n      goto done;\n    }\n  DBG ((\"get user returned: %s\", user));\n\n  if (cfg->mode == CHRESP) {\n#if HAVE_LIBYKPERS_1\n    return do_challenge_response(pamh, cfg, user);\n#else\n    DBG ((\"no support for challenge/response\"));\n    retval = PAM_AUTH_ERR;\n    goto done;\n#endif\n  }\n\n  if (cfg->try_first_pass || cfg->use_first_pass)\n    {\n      retval = pam_get_item (pamh, PAM_AUTHTOK, (const void **) &password);\n      if (retval != PAM_SUCCESS)\n\t{\n\t  DBG ((\"get password returned error: %s\",\n\t      pam_strerror (pamh, retval)));\n\t  goto done;\n\t}\n      DBG ((\"get password returned: %s\", password));\n    }\n\n  if (cfg->use_first_pass && password == NULL)\n    {\n      DBG ((\"use_first_pass set and no password, giving up\"));\n      retval = PAM_AUTH_ERR;\n      goto done;\n    }\n\n  rc = ykclient_init (&ykc);\n  if (rc != YKCLIENT_OK)\n    {\n      DBG ((\"ykclient_init() failed (%d): %s\", rc, ykclient_strerror (rc)));\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n\n  rc = ykclient_set_client_b64 (ykc, cfg->client_id, cfg->client_key);\n  if (rc != YKCLIENT_OK)\n    {\n      DBG ((\"ykclient_set_client_b64() failed (%d): %s\",\n\t    rc, ykclient_strerror (rc)));\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n\n  if (cfg->capath)\n    ykclient_set_ca_path (ykc, cfg->capath);\n\n  if (cfg->url)\n    ykclient_set_url_template (ykc, cfg->url);\n\n  if (password == NULL)\n    {\n      retval = pam_get_item (pamh, PAM_CONV, (const void **) &conv);\n      if (retval != PAM_SUCCESS)\n\t{\n\t  DBG ((\"get conv returned error: %s\", pam_strerror (pamh, retval)));\n\t  goto done;\n\t}\n\n      pmsg[0] = &msg[0];\n      {\n\tconst char *query_template = \"Yubikey for `%s': \";\n\tsize_t len = strlen (query_template) + strlen (user);\n\tsize_t wrote;\n\n\tmsg[0].msg = malloc (len);\n\tif (!msg[0].msg)\n\t  {\n\t    retval = PAM_BUF_ERR;\n\t    goto done;\n\t  }\n\n\twrote = snprintf ((char *) msg[0].msg, len, query_template, user);\n\tif (wrote < 0 || wrote >= len)\n\t  {\n\t    retval = PAM_BUF_ERR;\n\t    goto done;\n\t  }\n      }\n      msg[0].msg_style = cfg->verbose_otp ? PAM_PROMPT_ECHO_ON : PAM_PROMPT_ECHO_OFF;\n      resp = NULL;\n\n      retval = conv->conv (nargs, (const struct pam_message **) pmsg,\n\t\t\t   &resp, conv->appdata_ptr);\n\n      free ((char *) msg[0].msg);\n\n      if (retval != PAM_SUCCESS)\n\t{\n\t  DBG ((\"conv returned error: %s\", pam_strerror (pamh, retval)));\n\t  goto done;\n\t}\n\n      if (resp->resp == NULL)\n\t{\n\t  DBG ((\"conv returned NULL passwd?\"));\n\t  retval = PAM_AUTH_ERR;\n\t  goto done;\n\t}\n\n      DBG ((\"conv returned %i bytes\", strlen(resp->resp)));\n\n      password = resp->resp;\n    }\n\n  password_len = strlen (password);\n  if (password_len < (cfg->token_id_length + TOKEN_OTP_LEN))\n    {\n      DBG ((\"OTP too short to be considered : %i < %i\", password_len, (cfg->token_id_length + TOKEN_OTP_LEN)));\n      retval = PAM_AUTH_ERR;\n      goto done;\n    }\n\n  /* In case the input was systempassword+YubiKeyOTP, we want to skip over\n     \"systempassword\" when copying the token_id and OTP to separate buffers */\n  skip_bytes = password_len - (cfg->token_id_length + TOKEN_OTP_LEN);\n\n  DBG ((\"Skipping first %i bytes. Length is %i, token_id set to %i and token OTP always %i.\",\n\tskip_bytes, password_len, cfg->token_id_length, TOKEN_OTP_LEN));\n\n  /* Copy full YubiKey output (public ID + OTP) into otp */\n  strncpy (otp, password + skip_bytes, sizeof (otp) - 1);\n  /* Copy only public ID into otp_id. Destination buffer is zeroed. */\n  strncpy (otp_id, password + skip_bytes, cfg->token_id_length);\n\n  DBG ((\"OTP: %s ID: %s \", otp, otp_id));\n\n  /* user entered their system password followed by generated OTP? */\n  if (password_len > TOKEN_OTP_LEN + cfg->token_id_length)\n    {\n      char *onlypasswd = strdup (password);\n\n      onlypasswd[password_len - (TOKEN_OTP_LEN + cfg->token_id_length)] = '\\0';\n\n      DBG ((\"Extracted a probable system password entered before the OTP - \"\n\t    \"setting item PAM_AUTHTOK\"));\n\n      retval = pam_set_item (pamh, PAM_AUTHTOK, onlypasswd);\n      free (onlypasswd);\n      if (retval != PAM_SUCCESS)\n\t{\n\t  DBG ((\"set_item returned error: %s\", pam_strerror (pamh, retval)));\n\t  goto done;\n\t}\n    }\n  else\n    password = NULL;\n\n  rc = ykclient_request (ykc, otp);\n\n  DBG ((\"ykclient return value (%d): %s\", rc,\n\tykclient_strerror (rc)));\n\n  switch (rc)\n    {\n    case YKCLIENT_OK:\n      break;\n\n    case YKCLIENT_BAD_OTP:\n    case YKCLIENT_REPLAYED_OTP:\n      retval = PAM_AUTH_ERR;\n      goto done;\n\n    default:\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n\n  /* authorize the user with supplied token id */\n  if (cfg->ldapserver != NULL || cfg->ldap_uri != NULL)\n    valid_token = authorize_user_token_ldap (cfg, user, otp_id);\n  else\n    valid_token = authorize_user_token (cfg, user, otp_id);\n\n  if (valid_token == 0)\n    {\n      DBG ((\"Yubikey not authorized to login as user\"));\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n\n  retval = PAM_SUCCESS;\n\ndone:\n  if (ykc)\n    ykclient_done (&ykc);\n  if (cfg->alwaysok && retval != PAM_SUCCESS)\n    {\n      DBG ((\"alwaysok needed (otherwise return with %d)\", retval));\n      retval = PAM_SUCCESS;\n    }\n  DBG ((\"done. [%s]\", pam_strerror (pamh, retval)));\n  pam_set_data (pamh, \"yubico_setcred_return\", (void*) (intptr_t) retval, NULL);\n\n  return retval;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145841,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "AnyP::Uri::parse(const HttpRequestMethod& method, const SBuf &rawUrl)\n{\n    try {\n\n        LOCAL_ARRAY(char, login, MAX_URL);\n        LOCAL_ARRAY(char, foundHost, MAX_URL);\n        LOCAL_ARRAY(char, urlpath, MAX_URL);\n        char *t = NULL;\n        char *q = NULL;\n        int foundPort;\n        int l;\n        int i;\n        const char *src;\n        char *dst;\n        foundHost[0] = urlpath[0] = login[0] = '\\0';\n\n        if ((l = rawUrl.length()) + Config.appendDomainLen > (MAX_URL - 1)) {\n            debugs(23, DBG_IMPORTANT, MYNAME << \"URL too large (\" << l << \" bytes)\");\n            return false;\n        }\n\n        if ((method == Http::METHOD_OPTIONS || method == Http::METHOD_TRACE) &&\n                Asterisk().cmp(rawUrl) == 0) {\n            // XXX: these methods might also occur in HTTPS traffic. Handle this better.\n            setScheme(AnyP::PROTO_HTTP, nullptr);\n            port(getScheme().defaultPort());\n            path(Asterisk());\n            return true;\n        }\n\n        Parser::Tokenizer tok(rawUrl);\n        AnyP::UriScheme scheme;\n\n        if (method == Http::METHOD_CONNECT) {\n            /*\n             * RFC 7230 section 5.3.3:  authority-form = authority\n             *  \"excluding any userinfo and its \"@\" delimiter\"\n             *\n             * RFC 3986 section 3.2:    authority = [ userinfo \"@\" ] host [ \":\" port ]\n             *\n             * As an HTTP(S) proxy we assume HTTPS (443) if no port provided.\n             */\n            foundPort = 443;\n\n            // XXX: use tokenizer\n            auto B = tok.buf();\n            const char *url = B.c_str();\n\n            if (sscanf(url, \"[%[^]]]:%d\", foundHost, &foundPort) < 1)\n                if (sscanf(url, \"%[^:]:%d\", foundHost, &foundPort) < 1)\n                    return false;\n\n        } else {\n\n            scheme = uriParseScheme(tok);\n\n            if (scheme == AnyP::PROTO_NONE)\n                return false; // invalid scheme\n\n            if (scheme == AnyP::PROTO_URN) {\n                parseUrn(tok); // throws on any error\n                return true;\n            }\n\n            // URLs then have \"//\"\n            static const SBuf doubleSlash(\"//\");\n            if (!tok.skip(doubleSlash))\n                return false;\n\n            auto B = tok.remaining();\n            const char *url = B.c_str();\n\n            /* Parse the URL: */\n            src = url;\n            i = 0;\n\n            /* Then everything until first /; that's host (and port; which we'll look for here later) */\n            // bug 1881: If we don't get a \"/\" then we imply it was there\n            // bug 3074: We could just be given a \"?\" or \"#\". These also imply \"/\"\n            // bug 3233: whitespace is also a hostname delimiter.\n            for (dst = foundHost; i < l && *src != '/' && *src != '?' && *src != '#' && *src != '\\0' && !xisspace(*src); ++i, ++src, ++dst) {\n                *dst = *src;\n            }\n\n            /*\n             * We can't check for \"i >= l\" here because we could be at the end of the line\n             * and have a perfectly valid URL w/ no trailing '/'. In this case we assume we've\n             * been -given- a valid URL and the path is just '/'.\n             */\n            if (i > l)\n                return false;\n            *dst = '\\0';\n\n            // bug 3074: received 'path' starting with '?', '#', or '\\0' implies '/'\n            if (*src == '?' || *src == '#' || *src == '\\0') {\n                urlpath[0] = '/';\n                dst = &urlpath[1];\n            } else {\n                dst = urlpath;\n            }\n            /* Then everything from / (inclusive) until \\r\\n or \\0 - that's urlpath */\n            for (; i < l && *src != '\\r' && *src != '\\n' && *src != '\\0'; ++i, ++src, ++dst) {\n                *dst = *src;\n            }\n\n            /* We -could- be at the end of the buffer here */\n            if (i > l)\n                return false;\n            /* If the URL path is empty we set it to be \"/\" */\n            if (dst == urlpath) {\n                *dst = '/';\n                ++dst;\n            }\n            *dst = '\\0';\n\n            foundPort = scheme.defaultPort(); // may be reset later\n\n            /* Is there any login information? (we should eventually parse it above) */\n            t = strrchr(foundHost, '@');\n            if (t != NULL) {\n                strncpy((char *) login, (char *) foundHost, sizeof(login)-1);\n                login[sizeof(login)-1] = '\\0';\n                t = strrchr(login, '@');\n                *t = 0;\n                strncpy((char *) foundHost, t + 1, sizeof(foundHost)-1);\n                foundHost[sizeof(foundHost)-1] = '\\0';\n                // Bug 4498: URL-unescape the login info after extraction\n                rfc1738_unescape(login);\n            }\n\n            /* Is there any host information? (we should eventually parse it above) */\n            if (*foundHost == '[') {\n                /* strip any IPA brackets. valid under IPv6. */\n                dst = foundHost;\n                /* only for IPv6 sadly, pre-IPv6/URL code can't handle the clean result properly anyway. */\n                src = foundHost;\n                ++src;\n                l = strlen(foundHost);\n                i = 1;\n                for (; i < l && *src != ']' && *src != '\\0'; ++i, ++src, ++dst) {\n                    *dst = *src;\n                }\n\n                /* we moved in-place, so truncate the actual hostname found */\n                *dst = '\\0';\n                ++dst;\n\n                /* skip ahead to either start of port, or original EOS */\n                while (*dst != '\\0' && *dst != ':')\n                    ++dst;\n                t = dst;\n            } else {\n                t = strrchr(foundHost, ':');\n\n                if (t != strchr(foundHost,':') ) {\n                    /* RFC 2732 states IPv6 \"SHOULD\" be bracketed. allowing for times when its not. */\n                    /* RFC 3986 'update' simply modifies this to an \"is\" with no emphasis at all! */\n                    /* therefore we MUST accept the case where they are not bracketed at all. */\n                    t = NULL;\n                }\n            }\n\n            // Bug 3183 sanity check: If scheme is present, host must be too.\n            if (scheme != AnyP::PROTO_NONE && foundHost[0] == '\\0') {\n                debugs(23, DBG_IMPORTANT, \"SECURITY ALERT: Missing hostname in URL '\" << url << \"'. see access.log for details.\");\n                return false;\n            }\n\n            if (t && *t == ':') {\n                *t = '\\0';\n                ++t;\n                foundPort = atoi(t);\n            }\n        }\n\n        for (t = foundHost; *t; ++t)\n            *t = xtolower(*t);\n\n        if (stringHasWhitespace(foundHost)) {\n            if (URI_WHITESPACE_STRIP == Config.uri_whitespace) {\n                t = q = foundHost;\n                while (*t) {\n                    if (!xisspace(*t)) {\n                        *q = *t;\n                        ++q;\n                    }\n                    ++t;\n                }\n                *q = '\\0';\n            }\n        }\n\n        debugs(23, 3, \"Split URL '\" << rawUrl << \"' into proto='\" << scheme.image() << \"', host='\" << foundHost << \"', port='\" << foundPort << \"', path='\" << urlpath << \"'\");\n\n        if (Config.onoff.check_hostnames &&\n                strspn(foundHost, Config.onoff.allow_underscore ? valid_hostname_chars_u : valid_hostname_chars) != strlen(foundHost)) {\n            debugs(23, DBG_IMPORTANT, MYNAME << \"Illegal character in hostname '\" << foundHost << \"'\");\n            return false;\n        }\n\n        if (!urlAppendDomain(foundHost))\n            return false;\n\n        /* remove trailing dots from hostnames */\n        while ((l = strlen(foundHost)) > 0 && foundHost[--l] == '.')\n            foundHost[l] = '\\0';\n\n        /* reject duplicate or leading dots */\n        if (strstr(foundHost, \"..\") || *foundHost == '.') {\n            debugs(23, DBG_IMPORTANT, MYNAME << \"Illegal hostname '\" << foundHost << \"'\");\n            return false;\n        }\n\n        if (foundPort < 1 || foundPort > 65535) {\n            debugs(23, 3, \"Invalid port '\" << foundPort << \"'\");\n            return false;\n        }\n\n#if HARDCODE_DENY_PORTS\n        /* These ports are filtered in the default squid.conf, but\n         * maybe someone wants them hardcoded... */\n        if (foundPort == 7 || foundPort == 9 || foundPort == 19) {\n            debugs(23, DBG_CRITICAL, MYNAME << \"Deny access to port \" << foundPort);\n            return false;\n        }\n#endif\n\n        if (stringHasWhitespace(urlpath)) {\n            debugs(23, 2, \"URI has whitespace: {\" << rawUrl << \"}\");\n\n            switch (Config.uri_whitespace) {\n\n            case URI_WHITESPACE_DENY:\n                return false;\n\n            case URI_WHITESPACE_ALLOW:\n                break;\n\n            case URI_WHITESPACE_ENCODE:\n                t = rfc1738_escape_unescaped(urlpath);\n                xstrncpy(urlpath, t, MAX_URL);\n                break;\n\n            case URI_WHITESPACE_CHOP:\n                *(urlpath + strcspn(urlpath, w_space)) = '\\0';\n                break;\n\n            case URI_WHITESPACE_STRIP:\n            default:\n                t = q = urlpath;\n                while (*t) {\n                    if (!xisspace(*t)) {\n                        *q = *t;\n                        ++q;\n                    }\n                    ++t;\n                }\n                *q = '\\0';\n            }\n        }\n\n        setScheme(scheme);\n        path(urlpath);\n        host(foundHost);\n        userInfo(SBuf(login));\n        port(foundPort);\n        return true;\n\n    } catch (...) {\n        debugs(23, 2, \"error: \" << CurrentException << \" \" << Raw(\"rawUrl\", rawUrl.rawContent(), rawUrl.length()));\n        return false;\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145912,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "AnyP::Uri::parse(const HttpRequestMethod& method, const SBuf &rawUrl)\n{\n    try {\n\n        LOCAL_ARRAY(char, login, MAX_URL);\n        LOCAL_ARRAY(char, foundHost, MAX_URL);\n        LOCAL_ARRAY(char, urlpath, MAX_URL);\n        char *t = NULL;\n        char *q = NULL;\n        int foundPort;\n        int l;\n        int i;\n        const char *src;\n        char *dst;\n        foundHost[0] = urlpath[0] = login[0] = '\\0';\n\n        if ((l = rawUrl.length()) + Config.appendDomainLen > (MAX_URL - 1)) {\n            debugs(23, DBG_IMPORTANT, MYNAME << \"URL too large (\" << l << \" bytes)\");\n            return false;\n        }\n\n        if ((method == Http::METHOD_OPTIONS || method == Http::METHOD_TRACE) &&\n                Asterisk().cmp(rawUrl) == 0) {\n            // XXX: these methods might also occur in HTTPS traffic. Handle this better.\n            setScheme(AnyP::PROTO_HTTP, nullptr);\n            port(getScheme().defaultPort());\n            path(Asterisk());\n            return true;\n        }\n\n        Parser::Tokenizer tok(rawUrl);\n        AnyP::UriScheme scheme;\n\n        if (method == Http::METHOD_CONNECT) {\n            /*\n             * RFC 7230 section 5.3.3:  authority-form = authority\n             *  \"excluding any userinfo and its \"@\" delimiter\"\n             *\n             * RFC 3986 section 3.2:    authority = [ userinfo \"@\" ] host [ \":\" port ]\n             *\n             * As an HTTP(S) proxy we assume HTTPS (443) if no port provided.\n             */\n            foundPort = 443;\n\n            // XXX: use tokenizer\n            auto B = tok.buf();\n            const char *url = B.c_str();\n\n            if (sscanf(url, \"[%[^]]]:%d\", foundHost, &foundPort) < 1)\n                if (sscanf(url, \"%[^:]:%d\", foundHost, &foundPort) < 1)\n                    return false;\n\n        } else {\n\n            scheme = uriParseScheme(tok);\n\n            if (scheme == AnyP::PROTO_NONE)\n                return false; // invalid scheme\n\n            if (scheme == AnyP::PROTO_URN) {\n                parseUrn(tok); // throws on any error\n                return true;\n            }\n\n            // URLs then have \"//\"\n            static const SBuf doubleSlash(\"//\");\n            if (!tok.skip(doubleSlash))\n                return false;\n\n            auto B = tok.remaining();\n            const char *url = B.c_str();\n\n            /* Parse the URL: */\n            src = url;\n            i = 0;\n\n            /* Then everything until first /; that's host (and port; which we'll look for here later) */\n            // bug 1881: If we don't get a \"/\" then we imply it was there\n            // bug 3074: We could just be given a \"?\" or \"#\". These also imply \"/\"\n            // bug 3233: whitespace is also a hostname delimiter.\n            for (dst = foundHost; i < l && *src != '/' && *src != '?' && *src != '#' && *src != '\\0' && !xisspace(*src); ++i, ++src, ++dst) {\n                *dst = *src;\n            }\n\n            /*\n             * We can't check for \"i >= l\" here because we could be at the end of the line\n             * and have a perfectly valid URL w/ no trailing '/'. In this case we assume we've\n             * been -given- a valid URL and the path is just '/'.\n             */\n            if (i > l)\n                return false;\n            *dst = '\\0';\n\n            // We are looking at path-abempty.\n            if (*src != '/') {\n                // path-empty, including the end of the `src` c-string cases\n                urlpath[0] = '/';\n                dst = &urlpath[1];\n            } else {\n                dst = urlpath;\n            }\n            /* Then everything from / (inclusive) until \\r\\n or \\0 - that's urlpath */\n            for (; i < l && *src != '\\r' && *src != '\\n' && *src != '\\0'; ++i, ++src, ++dst) {\n                *dst = *src;\n            }\n\n            /* We -could- be at the end of the buffer here */\n            if (i > l)\n                return false;\n            *dst = '\\0';\n\n            foundPort = scheme.defaultPort(); // may be reset later\n\n            /* Is there any login information? (we should eventually parse it above) */\n            t = strrchr(foundHost, '@');\n            if (t != NULL) {\n                strncpy((char *) login, (char *) foundHost, sizeof(login)-1);\n                login[sizeof(login)-1] = '\\0';\n                t = strrchr(login, '@');\n                *t = 0;\n                strncpy((char *) foundHost, t + 1, sizeof(foundHost)-1);\n                foundHost[sizeof(foundHost)-1] = '\\0';\n                // Bug 4498: URL-unescape the login info after extraction\n                rfc1738_unescape(login);\n            }\n\n            /* Is there any host information? (we should eventually parse it above) */\n            if (*foundHost == '[') {\n                /* strip any IPA brackets. valid under IPv6. */\n                dst = foundHost;\n                /* only for IPv6 sadly, pre-IPv6/URL code can't handle the clean result properly anyway. */\n                src = foundHost;\n                ++src;\n                l = strlen(foundHost);\n                i = 1;\n                for (; i < l && *src != ']' && *src != '\\0'; ++i, ++src, ++dst) {\n                    *dst = *src;\n                }\n\n                /* we moved in-place, so truncate the actual hostname found */\n                *dst = '\\0';\n                ++dst;\n\n                /* skip ahead to either start of port, or original EOS */\n                while (*dst != '\\0' && *dst != ':')\n                    ++dst;\n                t = dst;\n            } else {\n                t = strrchr(foundHost, ':');\n\n                if (t != strchr(foundHost,':') ) {\n                    /* RFC 2732 states IPv6 \"SHOULD\" be bracketed. allowing for times when its not. */\n                    /* RFC 3986 'update' simply modifies this to an \"is\" with no emphasis at all! */\n                    /* therefore we MUST accept the case where they are not bracketed at all. */\n                    t = NULL;\n                }\n            }\n\n            // Bug 3183 sanity check: If scheme is present, host must be too.\n            if (scheme != AnyP::PROTO_NONE && foundHost[0] == '\\0') {\n                debugs(23, DBG_IMPORTANT, \"SECURITY ALERT: Missing hostname in URL '\" << url << \"'. see access.log for details.\");\n                return false;\n            }\n\n            if (t && *t == ':') {\n                *t = '\\0';\n                ++t;\n                foundPort = atoi(t);\n            }\n        }\n\n        for (t = foundHost; *t; ++t)\n            *t = xtolower(*t);\n\n        if (stringHasWhitespace(foundHost)) {\n            if (URI_WHITESPACE_STRIP == Config.uri_whitespace) {\n                t = q = foundHost;\n                while (*t) {\n                    if (!xisspace(*t)) {\n                        *q = *t;\n                        ++q;\n                    }\n                    ++t;\n                }\n                *q = '\\0';\n            }\n        }\n\n        debugs(23, 3, \"Split URL '\" << rawUrl << \"' into proto='\" << scheme.image() << \"', host='\" << foundHost << \"', port='\" << foundPort << \"', path='\" << urlpath << \"'\");\n\n        if (Config.onoff.check_hostnames &&\n                strspn(foundHost, Config.onoff.allow_underscore ? valid_hostname_chars_u : valid_hostname_chars) != strlen(foundHost)) {\n            debugs(23, DBG_IMPORTANT, MYNAME << \"Illegal character in hostname '\" << foundHost << \"'\");\n            return false;\n        }\n\n        if (!urlAppendDomain(foundHost))\n            return false;\n\n        /* remove trailing dots from hostnames */\n        while ((l = strlen(foundHost)) > 0 && foundHost[--l] == '.')\n            foundHost[l] = '\\0';\n\n        /* reject duplicate or leading dots */\n        if (strstr(foundHost, \"..\") || *foundHost == '.') {\n            debugs(23, DBG_IMPORTANT, MYNAME << \"Illegal hostname '\" << foundHost << \"'\");\n            return false;\n        }\n\n        if (foundPort < 1 || foundPort > 65535) {\n            debugs(23, 3, \"Invalid port '\" << foundPort << \"'\");\n            return false;\n        }\n\n#if HARDCODE_DENY_PORTS\n        /* These ports are filtered in the default squid.conf, but\n         * maybe someone wants them hardcoded... */\n        if (foundPort == 7 || foundPort == 9 || foundPort == 19) {\n            debugs(23, DBG_CRITICAL, MYNAME << \"Deny access to port \" << foundPort);\n            return false;\n        }\n#endif\n\n        if (stringHasWhitespace(urlpath)) {\n            debugs(23, 2, \"URI has whitespace: {\" << rawUrl << \"}\");\n\n            switch (Config.uri_whitespace) {\n\n            case URI_WHITESPACE_DENY:\n                return false;\n\n            case URI_WHITESPACE_ALLOW:\n                break;\n\n            case URI_WHITESPACE_ENCODE:\n                t = rfc1738_escape_unescaped(urlpath);\n                xstrncpy(urlpath, t, MAX_URL);\n                break;\n\n            case URI_WHITESPACE_CHOP:\n                *(urlpath + strcspn(urlpath, w_space)) = '\\0';\n                break;\n\n            case URI_WHITESPACE_STRIP:\n            default:\n                t = q = urlpath;\n                while (*t) {\n                    if (!xisspace(*t)) {\n                        *q = *t;\n                        ++q;\n                    }\n                    ++t;\n                }\n                *q = '\\0';\n            }\n        }\n\n        setScheme(scheme);\n        path(urlpath);\n        host(foundHost);\n        userInfo(SBuf(login));\n        port(foundPort);\n        return true;\n\n    } catch (...) {\n        debugs(23, 2, \"error: \" << CurrentException << \" \" << Raw(\"rawUrl\", rawUrl.rawContent(), rawUrl.length()));\n        return false;\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145913,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int checkout_verify_paths(\n\tgit_repository *repo,\n\tint action,\n\tgit_diff_delta *delta)\n{\n\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\n\tif (action & CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot remove invalid path '%s'\", delta->old_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (action & ~CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->new_file.path, delta->new_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot checkout to invalid path '%s'\", delta->new_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145988,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int checkout_verify_paths(\n\tgit_repository *repo,\n\tint action,\n\tgit_diff_delta *delta)\n{\n\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS | GIT_PATH_REJECT_DOT_GIT_NTFS;\n\n\tif (action & CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot remove invalid path '%s'\", delta->old_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (action & ~CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->new_file.path, delta->new_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot checkout to invalid path '%s'\", delta->new_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145989,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int rsa_verify_hash_ex(const unsigned char *sig,      unsigned long siglen,\n                       const unsigned char *hash,     unsigned long hashlen,\n                             int            padding,\n                             int            hash_idx, unsigned long saltlen,\n                             int           *stat,     rsa_key      *key)\n{\n  unsigned long modulus_bitlen, modulus_bytelen, x;\n  int           err;\n  unsigned char *tmpbuf;\n\n  LTC_ARGCHK(hash  != NULL);\n  LTC_ARGCHK(sig   != NULL);\n  LTC_ARGCHK(stat  != NULL);\n  LTC_ARGCHK(key   != NULL);\n\n  /* default to invalid */\n  *stat = 0;\n\n  /* valid padding? */\n\n  if ((padding != LTC_LTC_PKCS_1_V1_5) &&\n      (padding != LTC_LTC_PKCS_1_PSS)) {\n    return CRYPT_PK_INVALID_PADDING;\n  }\n\n  if (padding == LTC_LTC_PKCS_1_PSS) {\n    /* valid hash ? */\n    if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {\n       return err;\n    }\n  }\n\n  /* get modulus len in bits */\n  modulus_bitlen = mp_count_bits( (key->N));\n\n  /* outlen must be at least the size of the modulus */\n  modulus_bytelen = mp_unsigned_bin_size( (key->N));\n  if (modulus_bytelen != siglen) {\n     return CRYPT_INVALID_PACKET;\n  }\n\n  /* allocate temp buffer for decoded sig */\n  tmpbuf = XMALLOC(siglen);\n  if (tmpbuf == NULL) {\n     return CRYPT_MEM;\n  }\n\n  /* RSA decode it  */\n  x = siglen;\n  if ((err = ltc_mp.rsa_me(sig, siglen, tmpbuf, &x, PK_PUBLIC, key)) != CRYPT_OK) {\n     XFREE(tmpbuf);\n     return err;\n  }\n\n  /* make sure the output is the right size */\n  if (x != siglen) {\n     XFREE(tmpbuf);\n     return CRYPT_INVALID_PACKET;\n  }\n\n  if (padding == LTC_LTC_PKCS_1_PSS) {\n    /* PSS decode and verify it */\n    err = pkcs_1_pss_decode(hash, hashlen, tmpbuf, x, saltlen, hash_idx, modulus_bitlen, stat);\n  } else {\n    /* LTC_PKCS #1 v1.5 decode it */\n    unsigned char *out;\n    unsigned long outlen, loid[16];\n    int           decoded;\n    ltc_asn1_list digestinfo[2], siginfo[2];\n\n    /* not all hashes have OIDs... so sad */\n    if (hash_descriptor[hash_idx]->OIDlen == 0) {\n       err = CRYPT_INVALID_ARG;\n       goto bail_2;\n    }\n\n    /* allocate temp buffer for decoded hash */\n    outlen = ((modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0)) - 3;\n    out    = XMALLOC(outlen);\n    if (out == NULL) {\n      err = CRYPT_MEM;\n      goto bail_2;\n    }\n\n    if ((err = pkcs_1_v1_5_decode(tmpbuf, x, LTC_LTC_PKCS_1_EMSA, modulus_bitlen, out, &outlen, &decoded)) != CRYPT_OK) {\n      XFREE(out);       \n      goto bail_2;\n    }\n\n    /* now we must decode out[0...outlen-1] using ASN.1, test the OID and then test the hash */\n    /* construct the SEQUENCE \n      SEQUENCE {\n         SEQUENCE {hashoid OID\n                   blah    NULL\n         }\n         hash    OCTET STRING \n      }\n   */\n    LTC_SET_ASN1(digestinfo, 0, LTC_ASN1_OBJECT_IDENTIFIER, loid, sizeof(loid)/sizeof(loid[0]));\n    LTC_SET_ASN1(digestinfo, 1, LTC_ASN1_NULL,              NULL,                          0);\n    LTC_SET_ASN1(siginfo,    0, LTC_ASN1_SEQUENCE,          digestinfo,                    2);\n    LTC_SET_ASN1(siginfo,    1, LTC_ASN1_OCTET_STRING,      tmpbuf,                        siglen);\n   \n    if ((err = der_decode_sequence(out, outlen, siginfo, 2)) != CRYPT_OK) {\n       XFREE(out);\n       goto bail_2;\n    }\n\n    /* test OID */\n    if ((digestinfo[0].size == hash_descriptor[hash_idx]->OIDlen) &&\n        (XMEMCMP(digestinfo[0].data, hash_descriptor[hash_idx]->OID, sizeof(unsigned long) * hash_descriptor[hash_idx]->OIDlen) == 0) &&\n        (siginfo[1].size == hashlen) &&\n        (XMEMCMP(siginfo[1].data, hash, hashlen) == 0)) {\n       *stat = 1;\n    }\n\n#ifdef LTC_CLEAN_STACK\n    zeromem(out, outlen);\n#endif\n    XFREE(out);\n  }\n\nbail_2:\n#ifdef LTC_CLEAN_STACK\n  zeromem(tmpbuf, siglen);\n#endif\n  XFREE(tmpbuf);\n  return err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145990,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int rsa_verify_hash_ex(const unsigned char *sig,      unsigned long siglen,\n                       const unsigned char *hash,     unsigned long hashlen,\n                             int            padding,\n                             int            hash_idx, unsigned long saltlen,\n                             int           *stat,     rsa_key      *key)\n{\n  unsigned long modulus_bitlen, modulus_bytelen, x;\n  int           err;\n  unsigned char *tmpbuf;\n\n  LTC_ARGCHK(hash  != NULL);\n  LTC_ARGCHK(sig   != NULL);\n  LTC_ARGCHK(stat  != NULL);\n  LTC_ARGCHK(key   != NULL);\n\n  /* default to invalid */\n  *stat = 0;\n\n  /* valid padding? */\n\n  if ((padding != LTC_LTC_PKCS_1_V1_5) &&\n      (padding != LTC_LTC_PKCS_1_PSS)) {\n    return CRYPT_PK_INVALID_PADDING;\n  }\n\n  if (padding == LTC_LTC_PKCS_1_PSS) {\n    /* valid hash ? */\n    if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {\n       return err;\n    }\n  }\n\n  /* get modulus len in bits */\n  modulus_bitlen = mp_count_bits( (key->N));\n\n  /* outlen must be at least the size of the modulus */\n  modulus_bytelen = mp_unsigned_bin_size( (key->N));\n  if (modulus_bytelen != siglen) {\n     return CRYPT_INVALID_PACKET;\n  }\n\n  /* allocate temp buffer for decoded sig */\n  tmpbuf = XMALLOC(siglen);\n  if (tmpbuf == NULL) {\n     return CRYPT_MEM;\n  }\n\n  /* RSA decode it  */\n  x = siglen;\n  if ((err = ltc_mp.rsa_me(sig, siglen, tmpbuf, &x, PK_PUBLIC, key)) != CRYPT_OK) {\n     XFREE(tmpbuf);\n     return err;\n  }\n\n  /* make sure the output is the right size */\n  if (x != siglen) {\n     XFREE(tmpbuf);\n     return CRYPT_INVALID_PACKET;\n  }\n\n  if (padding == LTC_LTC_PKCS_1_PSS) {\n    /* PSS decode and verify it */\n    err = pkcs_1_pss_decode(hash, hashlen, tmpbuf, x, saltlen, hash_idx, modulus_bitlen, stat);\n  } else {\n    /* LTC_PKCS #1 v1.5 decode it */\n    unsigned char *out;\n    unsigned long outlen, loid[16], reallen;\n    int           decoded;\n    ltc_asn1_list digestinfo[2], siginfo[2];\n\n    /* not all hashes have OIDs... so sad */\n    if (hash_descriptor[hash_idx]->OIDlen == 0) {\n       err = CRYPT_INVALID_ARG;\n       goto bail_2;\n    }\n\n    /* allocate temp buffer for decoded hash */\n    outlen = ((modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0)) - 3;\n    out    = XMALLOC(outlen);\n    if (out == NULL) {\n      err = CRYPT_MEM;\n      goto bail_2;\n    }\n\n    if ((err = pkcs_1_v1_5_decode(tmpbuf, x, LTC_LTC_PKCS_1_EMSA, modulus_bitlen, out, &outlen, &decoded)) != CRYPT_OK) {\n      XFREE(out);       \n      goto bail_2;\n    }\n\n    /* now we must decode out[0...outlen-1] using ASN.1, test the OID and then test the hash */\n    /* construct the SEQUENCE \n      SEQUENCE {\n         SEQUENCE {hashoid OID\n                   blah    NULL\n         }\n         hash    OCTET STRING \n      }\n   */\n    LTC_SET_ASN1(digestinfo, 0, LTC_ASN1_OBJECT_IDENTIFIER, loid, sizeof(loid)/sizeof(loid[0]));\n    LTC_SET_ASN1(digestinfo, 1, LTC_ASN1_NULL,              NULL,                          0);\n    LTC_SET_ASN1(siginfo,    0, LTC_ASN1_SEQUENCE,          digestinfo,                    2);\n    LTC_SET_ASN1(siginfo,    1, LTC_ASN1_OCTET_STRING,      tmpbuf,                        siglen);\n   \n    if ((err = der_decode_sequence(out, outlen, siginfo, 2)) != CRYPT_OK) {\n       XFREE(out);\n       goto bail_2;\n    }\n\n    if ((err = der_length_sequence(siginfo, 2, &reallen)) != CRYPT_OK) {\n\t    XFREE(out);\n\t    goto bail_2;\n    }\n\n    /* test OID */\n    if ((reallen == outlen) &&\n        (digestinfo[0].size == hash_descriptor[hash_idx]->OIDlen) &&\n        (XMEMCMP(digestinfo[0].data, hash_descriptor[hash_idx]->OID, sizeof(unsigned long) * hash_descriptor[hash_idx]->OIDlen) == 0) &&\n        (siginfo[1].size == hashlen) &&\n        (XMEMCMP(siginfo[1].data, hash, hashlen) == 0)) {\n       *stat = 1;\n    }\n\n#ifdef LTC_CLEAN_STACK\n    zeromem(out, outlen);\n#endif\n    XFREE(out);\n  }\n\nbail_2:\n#ifdef LTC_CLEAN_STACK\n  zeromem(tmpbuf, siglen);\n#endif\n  XFREE(tmpbuf);\n  return err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145991,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int decode_tree_entry(struct tree_desc *desc, const char *buf, unsigned long size, struct strbuf *err)\n{\n\tconst char *path;\n\tunsigned int mode, len;\n\n\tif (size < 23 || buf[size - 21]) {\n\t\tstrbuf_addstr(err, _(\"too-short tree object\"));\n\t\treturn -1;\n\t}\n\n\tpath = get_mode(buf, &mode);\n\tif (!path) {\n\t\tstrbuf_addstr(err, _(\"malformed mode in tree entry\"));\n\t\treturn -1;\n\t}\n\tif (!*path) {\n\t\tstrbuf_addstr(err, _(\"empty filename in tree entry\"));\n\t\treturn -1;\n\t}\n\tlen = strlen(path) + 1;\n\n\t/* Initialize the descriptor entry */\n\tdesc->entry.path = path;\n\tdesc->entry.mode = canon_mode(mode);\n\tdesc->entry.oid  = (const struct object_id *)(path + len);\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146058,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int decode_tree_entry(struct tree_desc *desc, const char *buf, unsigned long size, struct strbuf *err)\n{\n\tconst char *path;\n\tunsigned int mode, len;\n\n\tif (size < 23 || buf[size - 21]) {\n\t\tstrbuf_addstr(err, _(\"too-short tree object\"));\n\t\treturn -1;\n\t}\n\n\tpath = get_mode(buf, &mode);\n\tif (!path) {\n\t\tstrbuf_addstr(err, _(\"malformed mode in tree entry\"));\n\t\treturn -1;\n\t}\n\tif (!*path) {\n\t\tstrbuf_addstr(err, _(\"empty filename in tree entry\"));\n\t\treturn -1;\n\t}\n#ifdef GIT_WINDOWS_NATIVE\n\tif (protect_ntfs && strchr(path, '\\\\')) {\n\t\tstrbuf_addf(err, _(\"filename in tree entry contains backslash: '%s'\"), path);\n\t\treturn -1;\n\t}\n#endif\n\tlen = strlen(path) + 1;\n\n\t/* Initialize the descriptor entry */\n\tdesc->entry.path = path;\n\tdesc->entry.mode = canon_mode(mode);\n\tdesc->entry.oid  = (const struct object_id *)(path + len);\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146059,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void _php_image_output_ctx(INTERNAL_FUNCTION_PARAMETERS, int image_type, char *tn, void (*func_p)())\n{\n\tzval *imgind;\n\tchar *file = NULL;\n\tint file_len = 0;\n\tlong quality, basefilter;\n\tgdImagePtr im;\n\tint argc = ZEND_NUM_ARGS();\n\tint q = -1, i;\n\tint f = -1;\n\tgdIOCtx *ctx = NULL;\n\tzval *to_zval = NULL;\n\tphp_stream *stream;\n\n\t/* The third (quality) parameter for Wbmp stands for the threshold when called from image2wbmp().\n\t * The third (quality) parameter for Wbmp and Xbm stands for the foreground color index when called\n\t * from imagey<type>().\n\t */\n\tif (image_type == PHP_GDIMG_TYPE_XBM) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rp!|ll\", &imgind, &file, &file_len, &quality, &basefilter) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t/* PHP_GDIMG_TYPE_GIF\n\t\t * PHP_GDIMG_TYPE_PNG \n\t\t * PHP_GDIMG_TYPE_JPG \n\t\t * PHP_GDIMG_TYPE_WBM \n\t\t * PHP_GDIMG_TYPE_WEBP \n\t\t * */\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|z/!ll\", &imgind, &to_zval, &quality, &basefilter) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &imgind, -1, \"Image\", phpi_get_le_gd());\n\n\tif (argc >= 3) {\n\t\tq = quality; /* or colorindex for foreground of BW images (defaults to black) */\n\t\tif (argc == 4) {\n\t\t\tf = basefilter;\n\t\t}\n\t}\n\n\tif (argc > 1 && to_zval != NULL) {\n\t\tif (Z_TYPE_P(to_zval) == IS_RESOURCE) {\n\t\t\tphp_stream_from_zval_no_verify(stream, &to_zval);\n\t\t\tif (stream == NULL) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t} else if (Z_TYPE_P(to_zval) == IS_STRING) {\n\t\t\tstream = php_stream_open_wrapper(Z_STRVAL_P(to_zval), \"wb\", REPORT_ERRORS|IGNORE_PATH|IGNORE_URL_WIN, NULL);\n\t\t\tif (stream == NULL) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid 2nd parameter, it must a filename or a stream\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tctx = emalloc(sizeof(gdIOCtx));\n\t\tctx->putC = _php_image_output_putc;\n\t\tctx->putBuf = _php_image_output_putbuf;\n\t\tctx->gd_free = _php_image_output_ctxfree;\n\n#if APACHE && defined(CHARSET_EBCDIC)\n\t\t/* XXX this is unlikely to work any more thies@thieso.net */\n\t\t/* This is a binary file already: avoid EBCDIC->ASCII conversion */\n\t\tap_bsetflag(php3_rqst->connection->client, B_EBCDIC2ASCII, 0);\n#endif\n\t}\n\n\tif (!ctx)\t{\n\t\tctx = emalloc(sizeof(gdIOCtx));\n\t\tctx->putC = _php_image_stream_putc;\n\t\tctx->putBuf = _php_image_stream_putbuf;\n\t\tctx->gd_free = _php_image_stream_ctxfree;\n\t\tctx->data = (void *)stream;\n\t}\n\n\tswitch(image_type) {\n\t\tcase PHP_GDIMG_CONVERT_WBM:\n\t\t\tif(q<0||q>255) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid threshold value '%d'. It must be between 0 and 255\", q);\n\t\t\t}\n\t\tcase PHP_GDIMG_TYPE_JPG:\n\t\t\t(*func_p)(im, ctx, q);\n\t\t\tbreak;\n\t\tcase PHP_GDIMG_TYPE_WEBP:\n\t\t\tif (q == -1) {\n\t\t\t\tq = 80;\n\t\t\t}\n\t\t\t(*func_p)(im, ctx, q);\n\t\t\tbreak;\n\t\tcase PHP_GDIMG_TYPE_PNG:\n\t\t\t(*func_p)(im, ctx, q, f);\n\t\t\tbreak;\n\t\tcase PHP_GDIMG_TYPE_XBM:\n\t\tcase PHP_GDIMG_TYPE_WBM:\n\t\t\tif (argc < 3) {\n\t\t\t\tfor(i=0; i < gdImageColorsTotal(im); i++) {\n\t\t\t\t\tif(!gdImageRed(im, i) && !gdImageGreen(im, i) && !gdImageBlue(im, i)) break;\n\t\t\t\t}\n\t\t\t\tq = i;\n\t\t\t}\n\t\t\tif (image_type == PHP_GDIMG_TYPE_XBM) {\n\t\t\t\t(*func_p)(im, file, q, ctx);\n\t\t\t} else {\n\t\t\t\t(*func_p)(im, q, ctx);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t(*func_p)(im, ctx);\n\t\t\tbreak;\n\t}\n\n\tctx->gd_free(ctx);\n\n\tRETURN_TRUE;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146060,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void _php_image_output_ctx(INTERNAL_FUNCTION_PARAMETERS, int image_type, char *tn, void (*func_p)())\n{\n\tzval *imgind;\n\tchar *file = NULL;\n\tint file_len = 0;\n\tlong quality, basefilter;\n\tgdImagePtr im;\n\tint argc = ZEND_NUM_ARGS();\n\tint q = -1, i;\n\tint f = -1;\n\tgdIOCtx *ctx = NULL;\n\tzval *to_zval = NULL;\n\tphp_stream *stream;\n\n\t/* The third (quality) parameter for Wbmp stands for the threshold when called from image2wbmp().\n\t * The third (quality) parameter for Wbmp and Xbm stands for the foreground color index when called\n\t * from imagey<type>().\n\t */\n\tif (image_type == PHP_GDIMG_TYPE_XBM) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rp!|ll\", &imgind, &file, &file_len, &quality, &basefilter) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t/* PHP_GDIMG_TYPE_GIF\n\t\t * PHP_GDIMG_TYPE_PNG \n\t\t * PHP_GDIMG_TYPE_JPG \n\t\t * PHP_GDIMG_TYPE_WBM \n\t\t * PHP_GDIMG_TYPE_WEBP \n\t\t * */\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|z/!ll\", &imgind, &to_zval, &quality, &basefilter) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &imgind, -1, \"Image\", phpi_get_le_gd());\n\n\tif (argc >= 3) {\n\t\tq = quality; /* or colorindex for foreground of BW images (defaults to black) */\n\t\tif (argc == 4) {\n\t\t\tf = basefilter;\n\t\t}\n\t}\n\n\tif (argc > 1 && to_zval != NULL) {\n\t\tif (Z_TYPE_P(to_zval) == IS_RESOURCE) {\n\t\t\tphp_stream_from_zval_no_verify(stream, &to_zval);\n\t\t\tif (stream == NULL) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t} else if (Z_TYPE_P(to_zval) == IS_STRING) {\n\t\t\tif (CHECK_ZVAL_NULL_PATH(to_zval)) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid 2nd parameter, filename must not contain null bytes\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\n\t\t\tstream = php_stream_open_wrapper(Z_STRVAL_P(to_zval), \"wb\", REPORT_ERRORS|IGNORE_PATH|IGNORE_URL_WIN, NULL);\n\t\t\tif (stream == NULL) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid 2nd parameter, it must a filename or a stream\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tctx = emalloc(sizeof(gdIOCtx));\n\t\tctx->putC = _php_image_output_putc;\n\t\tctx->putBuf = _php_image_output_putbuf;\n\t\tctx->gd_free = _php_image_output_ctxfree;\n\n#if APACHE && defined(CHARSET_EBCDIC)\n\t\t/* XXX this is unlikely to work any more thies@thieso.net */\n\t\t/* This is a binary file already: avoid EBCDIC->ASCII conversion */\n\t\tap_bsetflag(php3_rqst->connection->client, B_EBCDIC2ASCII, 0);\n#endif\n\t}\n\n\tif (!ctx)\t{\n\t\tctx = emalloc(sizeof(gdIOCtx));\n\t\tctx->putC = _php_image_stream_putc;\n\t\tctx->putBuf = _php_image_stream_putbuf;\n\t\tctx->gd_free = _php_image_stream_ctxfree;\n\t\tctx->data = (void *)stream;\n\t}\n\n\tswitch(image_type) {\n\t\tcase PHP_GDIMG_CONVERT_WBM:\n\t\t\tif(q<0||q>255) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid threshold value '%d'. It must be between 0 and 255\", q);\n\t\t\t}\n\t\tcase PHP_GDIMG_TYPE_JPG:\n\t\t\t(*func_p)(im, ctx, q);\n\t\t\tbreak;\n\t\tcase PHP_GDIMG_TYPE_WEBP:\n\t\t\tif (q == -1) {\n\t\t\t\tq = 80;\n\t\t\t}\n\t\t\t(*func_p)(im, ctx, q);\n\t\t\tbreak;\n\t\tcase PHP_GDIMG_TYPE_PNG:\n\t\t\t(*func_p)(im, ctx, q, f);\n\t\t\tbreak;\n\t\tcase PHP_GDIMG_TYPE_XBM:\n\t\tcase PHP_GDIMG_TYPE_WBM:\n\t\t\tif (argc < 3) {\n\t\t\t\tfor(i=0; i < gdImageColorsTotal(im); i++) {\n\t\t\t\t\tif(!gdImageRed(im, i) && !gdImageGreen(im, i) && !gdImageBlue(im, i)) break;\n\t\t\t\t}\n\t\t\t\tq = i;\n\t\t\t}\n\t\t\tif (image_type == PHP_GDIMG_TYPE_XBM) {\n\t\t\t\t(*func_p)(im, file, q, ctx);\n\t\t\t} else {\n\t\t\t\t(*func_p)(im, q, ctx);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t(*func_p)(im, ctx);\n\t\t\tbreak;\n\t}\n\n\tctx->gd_free(ctx);\n\n\tRETURN_TRUE;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146061,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int sqlite3Select(\n  Parse *pParse,         /* The parser context */\n  Select *p,             /* The SELECT statement being coded. */\n  SelectDest *pDest      /* What to do with the query results */\n){\n  int i, j;              /* Loop counters */\n  WhereInfo *pWInfo;     /* Return from sqlite3WhereBegin() */\n  Vdbe *v;               /* The virtual machine under construction */\n  int isAgg;             /* True for select lists like \"count(*)\" */\n  ExprList *pEList = 0;  /* List of columns to extract. */\n  SrcList *pTabList;     /* List of tables to select from */\n  Expr *pWhere;          /* The WHERE clause.  May be NULL */\n  ExprList *pGroupBy;    /* The GROUP BY clause.  May be NULL */\n  Expr *pHaving;         /* The HAVING clause.  May be NULL */\n  int rc = 1;            /* Value to return from this function */\n  DistinctCtx sDistinct; /* Info on how to code the DISTINCT keyword */\n  SortCtx sSort;         /* Info on how to code the ORDER BY clause */\n  AggInfo sAggInfo;      /* Information used by aggregate queries */\n  int iEnd;              /* Address of the end of the query */\n  sqlite3 *db;           /* The database connection */\n  ExprList *pMinMaxOrderBy = 0;  /* Added ORDER BY for min/max queries */\n  u8 minMaxFlag;                 /* Flag for min/max queries */\n\n  db = pParse->db;\n  v = sqlite3GetVdbe(pParse);\n  if( p==0 || db->mallocFailed || pParse->nErr ){\n    return 1;\n  }\n  if( sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0) ) return 1;\n  memset(&sAggInfo, 0, sizeof(sAggInfo));\n#if SELECTTRACE_ENABLED\n  SELECTTRACE(1,pParse,p, (\"begin processing:\\n\", pParse->addrExplain));\n  if( sqlite3SelectTrace & 0x100 ){\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistFifo );\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_Fifo );\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistQueue );\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_Queue );\n  if( IgnorableOrderby(pDest) ){\n    assert(pDest->eDest==SRT_Exists || pDest->eDest==SRT_Union || \n           pDest->eDest==SRT_Except || pDest->eDest==SRT_Discard ||\n           pDest->eDest==SRT_Queue  || pDest->eDest==SRT_DistFifo ||\n           pDest->eDest==SRT_DistQueue || pDest->eDest==SRT_Fifo);\n    /* If ORDER BY makes no difference in the output then neither does\n    ** DISTINCT so it can be removed too. */\n    sqlite3ExprListDelete(db, p->pOrderBy);\n    p->pOrderBy = 0;\n    p->selFlags &= ~SF_Distinct;\n  }\n  sqlite3SelectPrep(pParse, p, 0);\n  if( pParse->nErr || db->mallocFailed ){\n    goto select_end;\n  }\n  assert( p->pEList!=0 );\n#if SELECTTRACE_ENABLED\n  if( sqlite3SelectTrace & 0x104 ){\n    SELECTTRACE(0x104,pParse,p, (\"after name resolution:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  if( pDest->eDest==SRT_Output ){\n    generateColumnNames(pParse, p);\n  }\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  if( sqlite3WindowRewrite(pParse, p) ){\n    goto select_end;\n  }\n#if SELECTTRACE_ENABLED\n  if( p->pWin && (sqlite3SelectTrace & 0x108)!=0 ){\n    SELECTTRACE(0x104,pParse,p, (\"after window rewrite:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n#endif /* SQLITE_OMIT_WINDOWFUNC */\n  pTabList = p->pSrc;\n  isAgg = (p->selFlags & SF_Aggregate)!=0;\n  memset(&sSort, 0, sizeof(sSort));\n  sSort.pOrderBy = p->pOrderBy;\n\n  /* Try to various optimizations (flattening subqueries, and strength\n  ** reduction of join operators) in the FROM clause up into the main query\n  */\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n  for(i=0; !p->pPrior && i<pTabList->nSrc; i++){\n    struct SrcList_item *pItem = &pTabList->a[i];\n    Select *pSub = pItem->pSelect;\n    Table *pTab = pItem->pTab;\n\n    /* Convert LEFT JOIN into JOIN if there are terms of the right table\n    ** of the LEFT JOIN used in the WHERE clause.\n    */\n    if( (pItem->fg.jointype & JT_LEFT)!=0\n     && sqlite3ExprImpliesNonNullRow(p->pWhere, pItem->iCursor)\n     && OptimizationEnabled(db, SQLITE_SimplifyJoin)\n    ){\n      SELECTTRACE(0x100,pParse,p,\n                (\"LEFT-JOIN simplifies to JOIN on term %d\\n\",i));\n      pItem->fg.jointype &= ~(JT_LEFT|JT_OUTER);\n      unsetJoinExpr(p->pWhere, pItem->iCursor);\n    }\n\n    /* No futher action if this term of the FROM clause is no a subquery */\n    if( pSub==0 ) continue;\n\n    /* Catch mismatch in the declared columns of a view and the number of\n    ** columns in the SELECT on the RHS */\n    if( pTab->nCol!=pSub->pEList->nExpr ){\n      sqlite3ErrorMsg(pParse, \"expected %d columns for '%s' but got %d\",\n                      pTab->nCol, pTab->zName, pSub->pEList->nExpr);\n      goto select_end;\n    }\n\n    /* Do not try to flatten an aggregate subquery.\n    **\n    ** Flattening an aggregate subquery is only possible if the outer query\n    ** is not a join.  But if the outer query is not a join, then the subquery\n    ** will be implemented as a co-routine and there is no advantage to\n    ** flattening in that case.\n    */\n    if( (pSub->selFlags & SF_Aggregate)!=0 ) continue;\n    assert( pSub->pGroupBy==0 );\n\n    /* If the outer query contains a \"complex\" result set (that is,\n    ** if the result set of the outer query uses functions or subqueries)\n    ** and if the subquery contains an ORDER BY clause and if\n    ** it will be implemented as a co-routine, then do not flatten.  This\n    ** restriction allows SQL constructs like this:\n    **\n    **  SELECT expensive_function(x)\n    **    FROM (SELECT x FROM tab ORDER BY y LIMIT 10);\n    **\n    ** The expensive_function() is only computed on the 10 rows that\n    ** are output, rather than every row of the table.\n    **\n    ** The requirement that the outer query have a complex result set\n    ** means that flattening does occur on simpler SQL constraints without\n    ** the expensive_function() like:\n    **\n    **  SELECT x FROM (SELECT x FROM tab ORDER BY y LIMIT 10);\n    */\n    if( pSub->pOrderBy!=0\n     && i==0\n     && (p->selFlags & SF_ComplexResult)!=0\n     && (pTabList->nSrc==1\n         || (pTabList->a[1].fg.jointype&(JT_LEFT|JT_CROSS))!=0)\n    ){\n      continue;\n    }\n\n    if( flattenSubquery(pParse, p, i, isAgg) ){\n      if( pParse->nErr ) goto select_end;\n      /* This subquery can be absorbed into its parent. */\n      i = -1;\n    }\n    pTabList = p->pSrc;\n    if( db->mallocFailed ) goto select_end;\n    if( !IgnorableOrderby(pDest) ){\n      sSort.pOrderBy = p->pOrderBy;\n    }\n  }\n#endif\n\n#ifndef SQLITE_OMIT_COMPOUND_SELECT\n  /* Handle compound SELECT statements using the separate multiSelect()\n  ** procedure.\n  */\n  if( p->pPrior ){\n    rc = multiSelect(pParse, p, pDest);\n#if SELECTTRACE_ENABLED\n    SELECTTRACE(0x1,pParse,p,(\"end compound-select processing\\n\"));\n    if( (sqlite3SelectTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){\n      sqlite3TreeViewSelect(0, p, 0);\n    }\n#endif\n    if( p->pNext==0 ) ExplainQueryPlanPop(pParse);\n    return rc;\n  }\n#endif\n\n  /* Do the WHERE-clause constant propagation optimization if this is\n  ** a join.  No need to speed time on this operation for non-join queries\n  ** as the equivalent optimization will be handled by query planner in\n  ** sqlite3WhereBegin().\n  */\n  if( pTabList->nSrc>1\n   && OptimizationEnabled(db, SQLITE_PropagateConst)\n   && propagateConstants(pParse, p)\n  ){\n#if SELECTTRACE_ENABLED\n    if( sqlite3SelectTrace & 0x100 ){\n      SELECTTRACE(0x100,pParse,p,(\"After constant propagation:\\n\"));\n      sqlite3TreeViewSelect(0, p, 0);\n    }\n#endif\n  }else{\n    SELECTTRACE(0x100,pParse,p,(\"Constant propagation not helpful\\n\"));\n  }\n\n#ifdef SQLITE_COUNTOFVIEW_OPTIMIZATION\n  if( OptimizationEnabled(db, SQLITE_QueryFlattener|SQLITE_CountOfView)\n   && countOfViewOptimization(pParse, p)\n  ){\n    if( db->mallocFailed ) goto select_end;\n    pEList = p->pEList;\n    pTabList = p->pSrc;\n  }\n#endif\n\n  /* For each term in the FROM clause, do two things:\n  ** (1) Authorized unreferenced tables\n  ** (2) Generate code for all sub-queries\n  */\n  for(i=0; i<pTabList->nSrc; i++){\n    struct SrcList_item *pItem = &pTabList->a[i];\n    SelectDest dest;\n    Select *pSub;\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n    const char *zSavedAuthContext;\n#endif\n\n    /* Issue SQLITE_READ authorizations with a fake column name for any\n    ** tables that are referenced but from which no values are extracted.\n    ** Examples of where these kinds of null SQLITE_READ authorizations\n    ** would occur:\n    **\n    **     SELECT count(*) FROM t1;   -- SQLITE_READ t1.\"\"\n    **     SELECT t1.* FROM t1, t2;   -- SQLITE_READ t2.\"\"\n    **\n    ** The fake column name is an empty string.  It is possible for a table to\n    ** have a column named by the empty string, in which case there is no way to\n    ** distinguish between an unreferenced table and an actual reference to the\n    ** \"\" column. The original design was for the fake column name to be a NULL,\n    ** which would be unambiguous.  But legacy authorization callbacks might\n    ** assume the column name is non-NULL and segfault.  The use of an empty\n    ** string for the fake column name seems safer.\n    */\n    if( pItem->colUsed==0 && pItem->zName!=0 ){\n      sqlite3AuthCheck(pParse, SQLITE_READ, pItem->zName, \"\", pItem->zDatabase);\n    }\n\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n    /* Generate code for all sub-queries in the FROM clause\n    */\n    pSub = pItem->pSelect;\n    if( pSub==0 ) continue;\n\n    /* The code for a subquery should only be generated once, though it is\n    ** technically harmless for it to be generated multiple times. The\n    ** following assert() will detect if something changes to cause\n    ** the same subquery to be coded multiple times, as a signal to the\n    ** developers to try to optimize the situation.\n    **\n    ** Update 2019-07-24:\n    ** See ticket https://sqlite.org/src/tktview/c52b09c7f38903b1311cec40.\n    ** The dbsqlfuzz fuzzer found a case where the same subquery gets\n    ** coded twice.  So this assert() now becomes a testcase().  It should\n    ** be very rare, though.\n    */\n    testcase( pItem->addrFillSub!=0 );\n\n    /* Increment Parse.nHeight by the height of the largest expression\n    ** tree referred to by this, the parent select. The child select\n    ** may contain expression trees of at most\n    ** (SQLITE_MAX_EXPR_DEPTH-Parse.nHeight) height. This is a bit\n    ** more conservative than necessary, but much easier than enforcing\n    ** an exact limit.\n    */\n    pParse->nHeight += sqlite3SelectExprHeight(p);\n\n    /* Make copies of constant WHERE-clause terms in the outer query down\n    ** inside the subquery.  This can help the subquery to run more efficiently.\n    */\n    if( OptimizationEnabled(db, SQLITE_PushDown)\n     && pushDownWhereTerms(pParse, pSub, p->pWhere, pItem->iCursor,\n                           (pItem->fg.jointype & JT_OUTER)!=0)\n    ){\n#if SELECTTRACE_ENABLED\n      if( sqlite3SelectTrace & 0x100 ){\n        SELECTTRACE(0x100,pParse,p,\n            (\"After WHERE-clause push-down into subquery %d:\\n\", pSub->selId));\n        sqlite3TreeViewSelect(0, p, 0);\n      }\n#endif\n    }else{\n      SELECTTRACE(0x100,pParse,p,(\"Push-down not possible\\n\"));\n    }\n\n    zSavedAuthContext = pParse->zAuthContext;\n    pParse->zAuthContext = pItem->zName;\n\n    /* Generate code to implement the subquery\n    **\n    ** The subquery is implemented as a co-routine if the subquery is\n    ** guaranteed to be the outer loop (so that it does not need to be\n    ** computed more than once)\n    **\n    ** TODO: Are there other reasons beside (1) to use a co-routine\n    ** implementation?\n    */\n    if( i==0\n     && (pTabList->nSrc==1\n            || (pTabList->a[1].fg.jointype&(JT_LEFT|JT_CROSS))!=0)  /* (1) */\n    ){\n      /* Implement a co-routine that will return a single row of the result\n      ** set on each invocation.\n      */\n      int addrTop = sqlite3VdbeCurrentAddr(v)+1;\n     \n      pItem->regReturn = ++pParse->nMem;\n      sqlite3VdbeAddOp3(v, OP_InitCoroutine, pItem->regReturn, 0, addrTop);\n      VdbeComment((v, \"%s\", pItem->pTab->zName));\n      pItem->addrFillSub = addrTop;\n      sqlite3SelectDestInit(&dest, SRT_Coroutine, pItem->regReturn);\n      ExplainQueryPlan((pParse, 1, \"CO-ROUTINE %u\", pSub->selId));\n      sqlite3Select(pParse, pSub, &dest);\n      pItem->pTab->nRowLogEst = pSub->nSelectRow;\n      pItem->fg.viaCoroutine = 1;\n      pItem->regResult = dest.iSdst;\n      sqlite3VdbeEndCoroutine(v, pItem->regReturn);\n      sqlite3VdbeJumpHere(v, addrTop-1);\n      sqlite3ClearTempRegCache(pParse);\n    }else{\n      /* Generate a subroutine that will fill an ephemeral table with\n      ** the content of this subquery.  pItem->addrFillSub will point\n      ** to the address of the generated subroutine.  pItem->regReturn\n      ** is a register allocated to hold the subroutine return address\n      */\n      int topAddr;\n      int onceAddr = 0;\n      int retAddr;\n      struct SrcList_item *pPrior;\n\n      testcase( pItem->addrFillSub==0 ); /* Ticket c52b09c7f38903b1311 */\n      pItem->regReturn = ++pParse->nMem;\n      topAddr = sqlite3VdbeAddOp2(v, OP_Integer, 0, pItem->regReturn);\n      pItem->addrFillSub = topAddr+1;\n      if( pItem->fg.isCorrelated==0 ){\n        /* If the subquery is not correlated and if we are not inside of\n        ** a trigger, then we only need to compute the value of the subquery\n        ** once. */\n        onceAddr = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);\n        VdbeComment((v, \"materialize \\\"%s\\\"\", pItem->pTab->zName));\n      }else{\n        VdbeNoopComment((v, \"materialize \\\"%s\\\"\", pItem->pTab->zName));\n      }\n      pPrior = isSelfJoinView(pTabList, pItem);\n      if( pPrior ){\n        sqlite3VdbeAddOp2(v, OP_OpenDup, pItem->iCursor, pPrior->iCursor);\n        assert( pPrior->pSelect!=0 );\n        pSub->nSelectRow = pPrior->pSelect->nSelectRow;\n      }else{\n        sqlite3SelectDestInit(&dest, SRT_EphemTab, pItem->iCursor);\n        ExplainQueryPlan((pParse, 1, \"MATERIALIZE %u\", pSub->selId));\n        sqlite3Select(pParse, pSub, &dest);\n      }\n      pItem->pTab->nRowLogEst = pSub->nSelectRow;\n      if( onceAddr ) sqlite3VdbeJumpHere(v, onceAddr);\n      retAddr = sqlite3VdbeAddOp1(v, OP_Return, pItem->regReturn);\n      VdbeComment((v, \"end %s\", pItem->pTab->zName));\n      sqlite3VdbeChangeP1(v, topAddr, retAddr);\n      sqlite3ClearTempRegCache(pParse);\n    }\n    if( db->mallocFailed ) goto select_end;\n    pParse->nHeight -= sqlite3SelectExprHeight(p);\n    pParse->zAuthContext = zSavedAuthContext;\n#endif\n  }\n\n  /* Various elements of the SELECT copied into local variables for\n  ** convenience */\n  pEList = p->pEList;\n  pWhere = p->pWhere;\n  pGroupBy = p->pGroupBy;\n  pHaving = p->pHaving;\n  sDistinct.isTnct = (p->selFlags & SF_Distinct)!=0;\n\n#if SELECTTRACE_ENABLED\n  if( sqlite3SelectTrace & 0x400 ){\n    SELECTTRACE(0x400,pParse,p,(\"After all FROM-clause analysis:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  /* If the query is DISTINCT with an ORDER BY but is not an aggregate, and \n  ** if the select-list is the same as the ORDER BY list, then this query\n  ** can be rewritten as a GROUP BY. In other words, this:\n  **\n  **     SELECT DISTINCT xyz FROM ... ORDER BY xyz\n  **\n  ** is transformed to:\n  **\n  **     SELECT xyz FROM ... GROUP BY xyz ORDER BY xyz\n  **\n  ** The second form is preferred as a single index (or temp-table) may be \n  ** used for both the ORDER BY and DISTINCT processing. As originally \n  ** written the query must use a temp-table for at least one of the ORDER \n  ** BY and DISTINCT, and an index or separate temp-table for the other.\n  */\n  if( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct \n   && sqlite3ExprListCompare(sSort.pOrderBy, pEList, -1)==0\n  ){\n    p->selFlags &= ~SF_Distinct;\n    pGroupBy = p->pGroupBy = sqlite3ExprListDup(db, pEList, 0);\n    /* Notice that even thought SF_Distinct has been cleared from p->selFlags,\n    ** the sDistinct.isTnct is still set.  Hence, isTnct represents the\n    ** original setting of the SF_Distinct flag, not the current setting */\n    assert( sDistinct.isTnct );\n\n#if SELECTTRACE_ENABLED\n    if( sqlite3SelectTrace & 0x400 ){\n      SELECTTRACE(0x400,pParse,p,(\"Transform DISTINCT into GROUP BY:\\n\"));\n      sqlite3TreeViewSelect(0, p, 0);\n    }\n#endif\n  }\n\n  /* If there is an ORDER BY clause, then create an ephemeral index to\n  ** do the sorting.  But this sorting ephemeral index might end up\n  ** being unused if the data can be extracted in pre-sorted order.\n  ** If that is the case, then the OP_OpenEphemeral instruction will be\n  ** changed to an OP_Noop once we figure out that the sorting index is\n  ** not needed.  The sSort.addrSortIndex variable is used to facilitate\n  ** that change.\n  */\n  if( sSort.pOrderBy ){\n    KeyInfo *pKeyInfo;\n    pKeyInfo = sqlite3KeyInfoFromExprList(\n        pParse, sSort.pOrderBy, 0, pEList->nExpr);\n    sSort.iECursor = pParse->nTab++;\n    sSort.addrSortIndex =\n      sqlite3VdbeAddOp4(v, OP_OpenEphemeral,\n          sSort.iECursor, sSort.pOrderBy->nExpr+1+pEList->nExpr, 0,\n          (char*)pKeyInfo, P4_KEYINFO\n      );\n  }else{\n    sSort.addrSortIndex = -1;\n  }\n\n  /* If the output is destined for a temporary table, open that table.\n  */\n  if( pDest->eDest==SRT_EphemTab ){\n    sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pDest->iSDParm, pEList->nExpr);\n  }\n\n  /* Set the limiter.\n  */\n  iEnd = sqlite3VdbeMakeLabel(pParse);\n  if( (p->selFlags & SF_FixedLimit)==0 ){\n    p->nSelectRow = 320;  /* 4 billion rows */\n  }\n  computeLimitRegisters(pParse, p, iEnd);\n  if( p->iLimit==0 && sSort.addrSortIndex>=0 ){\n    sqlite3VdbeChangeOpcode(v, sSort.addrSortIndex, OP_SorterOpen);\n    sSort.sortFlags |= SORTFLAG_UseSorter;\n  }\n\n  /* Open an ephemeral index to use for the distinct set.\n  */\n  if( p->selFlags & SF_Distinct ){\n    sDistinct.tabTnct = pParse->nTab++;\n    sDistinct.addrTnct = sqlite3VdbeAddOp4(v, OP_OpenEphemeral,\n                       sDistinct.tabTnct, 0, 0,\n                       (char*)sqlite3KeyInfoFromExprList(pParse, p->pEList,0,0),\n                       P4_KEYINFO);\n    sqlite3VdbeChangeP5(v, BTREE_UNORDERED);\n    sDistinct.eTnctType = WHERE_DISTINCT_UNORDERED;\n  }else{\n    sDistinct.eTnctType = WHERE_DISTINCT_NOOP;\n  }\n\n  if( !isAgg && pGroupBy==0 ){\n    /* No aggregate functions and no GROUP BY clause */\n    u16 wctrlFlags = (sDistinct.isTnct ? WHERE_WANT_DISTINCT : 0)\n                   | (p->selFlags & SF_FixedLimit);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    Window *pWin = p->pWin;      /* Master window object (or NULL) */\n    if( pWin ){\n      sqlite3WindowCodeInit(pParse, pWin);\n    }\n#endif\n    assert( WHERE_USE_LIMIT==SF_FixedLimit );\n\n\n    /* Begin the database scan. */\n    SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, sSort.pOrderBy,\n                               p->pEList, wctrlFlags, p->nSelectRow);\n    if( pWInfo==0 ) goto select_end;\n    if( sqlite3WhereOutputRowCount(pWInfo) < p->nSelectRow ){\n      p->nSelectRow = sqlite3WhereOutputRowCount(pWInfo);\n    }\n    if( sDistinct.isTnct && sqlite3WhereIsDistinct(pWInfo) ){\n      sDistinct.eTnctType = sqlite3WhereIsDistinct(pWInfo);\n    }\n    if( sSort.pOrderBy ){\n      sSort.nOBSat = sqlite3WhereIsOrdered(pWInfo);\n      sSort.labelOBLopt = sqlite3WhereOrderByLimitOptLabel(pWInfo);\n      if( sSort.nOBSat==sSort.pOrderBy->nExpr ){\n        sSort.pOrderBy = 0;\n      }\n    }\n\n    /* If sorting index that was created by a prior OP_OpenEphemeral \n    ** instruction ended up not being needed, then change the OP_OpenEphemeral\n    ** into an OP_Noop.\n    */\n    if( sSort.addrSortIndex>=0 && sSort.pOrderBy==0 ){\n      sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);\n    }\n\n    assert( p->pEList==pEList );\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    if( pWin ){\n      int addrGosub = sqlite3VdbeMakeLabel(pParse);\n      int iCont = sqlite3VdbeMakeLabel(pParse);\n      int iBreak = sqlite3VdbeMakeLabel(pParse);\n      int regGosub = ++pParse->nMem;\n\n      sqlite3WindowCodeStep(pParse, p, pWInfo, regGosub, addrGosub);\n\n      sqlite3VdbeAddOp2(v, OP_Goto, 0, iBreak);\n      sqlite3VdbeResolveLabel(v, addrGosub);\n      VdbeNoopComment((v, \"inner-loop subroutine\"));\n      sSort.labelOBLopt = 0;\n      selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, iCont, iBreak);\n      sqlite3VdbeResolveLabel(v, iCont);\n      sqlite3VdbeAddOp1(v, OP_Return, regGosub);\n      VdbeComment((v, \"end inner-loop subroutine\"));\n      sqlite3VdbeResolveLabel(v, iBreak);\n    }else\n#endif /* SQLITE_OMIT_WINDOWFUNC */\n    {\n      /* Use the standard inner loop. */\n      selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest,\n          sqlite3WhereContinueLabel(pWInfo),\n          sqlite3WhereBreakLabel(pWInfo));\n\n      /* End the database scan loop.\n      */\n      sqlite3WhereEnd(pWInfo);\n    }\n  }else{\n    /* This case when there exist aggregate functions or a GROUP BY clause\n    ** or both */\n    NameContext sNC;    /* Name context for processing aggregate information */\n    int iAMem;          /* First Mem address for storing current GROUP BY */\n    int iBMem;          /* First Mem address for previous GROUP BY */\n    int iUseFlag;       /* Mem address holding flag indicating that at least\n                        ** one row of the input to the aggregator has been\n                        ** processed */\n    int iAbortFlag;     /* Mem address which causes query abort if positive */\n    int groupBySort;    /* Rows come from source in GROUP BY order */\n    int addrEnd;        /* End of processing for this SELECT */\n    int sortPTab = 0;   /* Pseudotable used to decode sorting results */\n    int sortOut = 0;    /* Output register from the sorter */\n    int orderByGrp = 0; /* True if the GROUP BY and ORDER BY are the same */\n\n    /* Remove any and all aliases between the result set and the\n    ** GROUP BY clause.\n    */\n    if( pGroupBy ){\n      int k;                        /* Loop counter */\n      struct ExprList_item *pItem;  /* For looping over expression in a list */\n\n      for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++){\n        pItem->u.x.iAlias = 0;\n      }\n      for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++){\n        pItem->u.x.iAlias = 0;\n      }\n      assert( 66==sqlite3LogEst(100) );\n      if( p->nSelectRow>66 ) p->nSelectRow = 66;\n\n      /* If there is both a GROUP BY and an ORDER BY clause and they are\n      ** identical, then it may be possible to disable the ORDER BY clause \n      ** on the grounds that the GROUP BY will cause elements to come out \n      ** in the correct order. It also may not - the GROUP BY might use a\n      ** database index that causes rows to be grouped together as required\n      ** but not actually sorted. Either way, record the fact that the\n      ** ORDER BY and GROUP BY clauses are the same by setting the orderByGrp\n      ** variable.  */\n      if( sSort.pOrderBy && pGroupBy->nExpr==sSort.pOrderBy->nExpr ){\n        int ii;\n        /* The GROUP BY processing doesn't care whether rows are delivered in\n        ** ASC or DESC order - only that each group is returned contiguously.\n        ** So set the ASC/DESC flags in the GROUP BY to match those in the \n        ** ORDER BY to maximize the chances of rows being delivered in an \n        ** order that makes the ORDER BY redundant.  */\n        for(ii=0; ii<pGroupBy->nExpr; ii++){\n          u8 sortFlags = sSort.pOrderBy->a[ii].sortFlags & KEYINFO_ORDER_DESC;\n          pGroupBy->a[ii].sortFlags = sortFlags;\n        }\n        if( sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, -1)==0 ){\n          orderByGrp = 1;\n        }\n      }\n    }else{\n      assert( 0==sqlite3LogEst(1) );\n      p->nSelectRow = 0;\n    }\n\n    /* Create a label to jump to when we want to abort the query */\n    addrEnd = sqlite3VdbeMakeLabel(pParse);\n\n    /* Convert TK_COLUMN nodes into TK_AGG_COLUMN and make entries in\n    ** sAggInfo for all TK_AGG_FUNCTION nodes in expressions of the\n    ** SELECT statement.\n    */\n    memset(&sNC, 0, sizeof(sNC));\n    sNC.pParse = pParse;\n    sNC.pSrcList = pTabList;\n    sNC.uNC.pAggInfo = &sAggInfo;\n    VVA_ONLY( sNC.ncFlags = NC_UAggInfo; )\n    sAggInfo.mnReg = pParse->nMem+1;\n    sAggInfo.nSortingColumn = pGroupBy ? pGroupBy->nExpr : 0;\n    sAggInfo.pGroupBy = pGroupBy;\n    sqlite3ExprAnalyzeAggList(&sNC, pEList);\n    sqlite3ExprAnalyzeAggList(&sNC, sSort.pOrderBy);\n    if( pHaving ){\n      if( pGroupBy ){\n        assert( pWhere==p->pWhere );\n        assert( pHaving==p->pHaving );\n        assert( pGroupBy==p->pGroupBy );\n        havingToWhere(pParse, p);\n        pWhere = p->pWhere;\n      }\n      sqlite3ExprAnalyzeAggregates(&sNC, pHaving);\n    }\n    sAggInfo.nAccumulator = sAggInfo.nColumn;\n    if( p->pGroupBy==0 && p->pHaving==0 && sAggInfo.nFunc==1 ){\n      minMaxFlag = minMaxQuery(db, sAggInfo.aFunc[0].pExpr, &pMinMaxOrderBy);\n    }else{\n      minMaxFlag = WHERE_ORDERBY_NORMAL;\n    }\n    for(i=0; i<sAggInfo.nFunc; i++){\n      Expr *pExpr = sAggInfo.aFunc[i].pExpr;\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n      sNC.ncFlags |= NC_InAggFunc;\n      sqlite3ExprAnalyzeAggList(&sNC, pExpr->x.pList);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n      assert( !IsWindowFunc(pExpr) );\n      if( ExprHasProperty(pExpr, EP_WinFunc) ){\n        sqlite3ExprAnalyzeAggregates(&sNC, pExpr->y.pWin->pFilter);\n      }\n#endif\n      sNC.ncFlags &= ~NC_InAggFunc;\n    }\n    sAggInfo.mxReg = pParse->nMem;\n    if( db->mallocFailed ) goto select_end;\n#if SELECTTRACE_ENABLED\n    if( sqlite3SelectTrace & 0x400 ){\n      int ii;\n      SELECTTRACE(0x400,pParse,p,(\"After aggregate analysis:\\n\"));\n      sqlite3TreeViewSelect(0, p, 0);\n      for(ii=0; ii<sAggInfo.nColumn; ii++){\n        sqlite3DebugPrintf(\"agg-column[%d] iMem=%d\\n\",\n            ii, sAggInfo.aCol[ii].iMem);\n        sqlite3TreeViewExpr(0, sAggInfo.aCol[ii].pExpr, 0);\n      }\n      for(ii=0; ii<sAggInfo.nFunc; ii++){\n        sqlite3DebugPrintf(\"agg-func[%d]: iMem=%d\\n\",\n            ii, sAggInfo.aFunc[ii].iMem);\n        sqlite3TreeViewExpr(0, sAggInfo.aFunc[ii].pExpr, 0);\n      }\n    }\n#endif\n\n\n    /* Processing for aggregates with GROUP BY is very different and\n    ** much more complex than aggregates without a GROUP BY.\n    */\n    if( pGroupBy ){\n      KeyInfo *pKeyInfo;  /* Keying information for the group by clause */\n      int addr1;          /* A-vs-B comparision jump */\n      int addrOutputRow;  /* Start of subroutine that outputs a result row */\n      int regOutputRow;   /* Return address register for output subroutine */\n      int addrSetAbort;   /* Set the abort flag and return */\n      int addrTopOfLoop;  /* Top of the input loop */\n      int addrSortingIdx; /* The OP_OpenEphemeral for the sorting index */\n      int addrReset;      /* Subroutine for resetting the accumulator */\n      int regReset;       /* Return address register for reset subroutine */\n\n      /* If there is a GROUP BY clause we might need a sorting index to\n      ** implement it.  Allocate that sorting index now.  If it turns out\n      ** that we do not need it after all, the OP_SorterOpen instruction\n      ** will be converted into a Noop.  \n      */\n      sAggInfo.sortingIdx = pParse->nTab++;\n      pKeyInfo = sqlite3KeyInfoFromExprList(pParse,pGroupBy,0,sAggInfo.nColumn);\n      addrSortingIdx = sqlite3VdbeAddOp4(v, OP_SorterOpen, \n          sAggInfo.sortingIdx, sAggInfo.nSortingColumn, \n          0, (char*)pKeyInfo, P4_KEYINFO);\n\n      /* Initialize memory locations used by GROUP BY aggregate processing\n      */\n      iUseFlag = ++pParse->nMem;\n      iAbortFlag = ++pParse->nMem;\n      regOutputRow = ++pParse->nMem;\n      addrOutputRow = sqlite3VdbeMakeLabel(pParse);\n      regReset = ++pParse->nMem;\n      addrReset = sqlite3VdbeMakeLabel(pParse);\n      iAMem = pParse->nMem + 1;\n      pParse->nMem += pGroupBy->nExpr;\n      iBMem = pParse->nMem + 1;\n      pParse->nMem += pGroupBy->nExpr;\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, iAbortFlag);\n      VdbeComment((v, \"clear abort flag\"));\n      sqlite3VdbeAddOp3(v, OP_Null, 0, iAMem, iAMem+pGroupBy->nExpr-1);\n\n      /* Begin a loop that will extract all source rows in GROUP BY order.\n      ** This might involve two separate loops with an OP_Sort in between, or\n      ** it might be a single loop that uses an index to extract information\n      ** in the right order to begin with.\n      */\n      sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);\n      SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n      pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, 0,\n          WHERE_GROUPBY | (orderByGrp ? WHERE_SORTBYGROUP : 0), 0\n      );\n      if( pWInfo==0 ) goto select_end;\n      if( sqlite3WhereIsOrdered(pWInfo)==pGroupBy->nExpr ){\n        /* The optimizer is able to deliver rows in group by order so\n        ** we do not have to sort.  The OP_OpenEphemeral table will be\n        ** cancelled later because we still need to use the pKeyInfo\n        */\n        groupBySort = 0;\n      }else{\n        /* Rows are coming out in undetermined order.  We have to push\n        ** each row into a sorting index, terminate the first loop,\n        ** then loop over the sorting index in order to get the output\n        ** in sorted order\n        */\n        int regBase;\n        int regRecord;\n        int nCol;\n        int nGroupBy;\n\n        explainTempTable(pParse, \n            (sDistinct.isTnct && (p->selFlags&SF_Distinct)==0) ?\n                    \"DISTINCT\" : \"GROUP BY\");\n\n        groupBySort = 1;\n        nGroupBy = pGroupBy->nExpr;\n        nCol = nGroupBy;\n        j = nGroupBy;\n        for(i=0; i<sAggInfo.nColumn; i++){\n          if( sAggInfo.aCol[i].iSorterColumn>=j ){\n            nCol++;\n            j++;\n          }\n        }\n        regBase = sqlite3GetTempRange(pParse, nCol);\n        sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0, 0);\n        j = nGroupBy;\n        for(i=0; i<sAggInfo.nColumn; i++){\n          struct AggInfo_col *pCol = &sAggInfo.aCol[i];\n          if( pCol->iSorterColumn>=j ){\n            int r1 = j + regBase;\n            sqlite3ExprCodeGetColumnOfTable(v,\n                               pCol->pTab, pCol->iTable, pCol->iColumn, r1);\n            j++;\n          }\n        }\n        regRecord = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase, nCol, regRecord);\n        sqlite3VdbeAddOp2(v, OP_SorterInsert, sAggInfo.sortingIdx, regRecord);\n        sqlite3ReleaseTempReg(pParse, regRecord);\n        sqlite3ReleaseTempRange(pParse, regBase, nCol);\n        sqlite3WhereEnd(pWInfo);\n        sAggInfo.sortingIdxPTab = sortPTab = pParse->nTab++;\n        sortOut = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp3(v, OP_OpenPseudo, sortPTab, sortOut, nCol);\n        sqlite3VdbeAddOp2(v, OP_SorterSort, sAggInfo.sortingIdx, addrEnd);\n        VdbeComment((v, \"GROUP BY sort\")); VdbeCoverage(v);\n        sAggInfo.useSortingIdx = 1;\n      }\n\n      /* If the index or temporary table used by the GROUP BY sort\n      ** will naturally deliver rows in the order required by the ORDER BY\n      ** clause, cancel the ephemeral table open coded earlier.\n      **\n      ** This is an optimization - the correct answer should result regardless.\n      ** Use the SQLITE_GroupByOrder flag with SQLITE_TESTCTRL_OPTIMIZER to \n      ** disable this optimization for testing purposes.  */\n      if( orderByGrp && OptimizationEnabled(db, SQLITE_GroupByOrder) \n       && (groupBySort || sqlite3WhereIsSorted(pWInfo))\n      ){\n        sSort.pOrderBy = 0;\n        sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);\n      }\n\n      /* Evaluate the current GROUP BY terms and store in b0, b1, b2...\n      ** (b0 is memory location iBMem+0, b1 is iBMem+1, and so forth)\n      ** Then compare the current GROUP BY terms against the GROUP BY terms\n      ** from the previous row currently stored in a0, a1, a2...\n      */\n      addrTopOfLoop = sqlite3VdbeCurrentAddr(v);\n      if( groupBySort ){\n        sqlite3VdbeAddOp3(v, OP_SorterData, sAggInfo.sortingIdx,\n                          sortOut, sortPTab);\n      }\n      for(j=0; j<pGroupBy->nExpr; j++){\n        if( groupBySort ){\n          sqlite3VdbeAddOp3(v, OP_Column, sortPTab, j, iBMem+j);\n        }else{\n          sAggInfo.directMode = 1;\n          sqlite3ExprCode(pParse, pGroupBy->a[j].pExpr, iBMem+j);\n        }\n      }\n      sqlite3VdbeAddOp4(v, OP_Compare, iAMem, iBMem, pGroupBy->nExpr,\n                          (char*)sqlite3KeyInfoRef(pKeyInfo), P4_KEYINFO);\n      addr1 = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp3(v, OP_Jump, addr1+1, 0, addr1+1); VdbeCoverage(v);\n\n      /* Generate code that runs whenever the GROUP BY changes.\n      ** Changes in the GROUP BY are detected by the previous code\n      ** block.  If there were no changes, this block is skipped.\n      **\n      ** This code copies current group by terms in b0,b1,b2,...\n      ** over to a0,a1,a2.  It then calls the output subroutine\n      ** and resets the aggregate accumulator registers in preparation\n      ** for the next GROUP BY batch.\n      */\n      sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr);\n      sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);\n      VdbeComment((v, \"output one row\"));\n      sqlite3VdbeAddOp2(v, OP_IfPos, iAbortFlag, addrEnd); VdbeCoverage(v);\n      VdbeComment((v, \"check abort flag\"));\n      sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);\n      VdbeComment((v, \"reset accumulator\"));\n\n      /* Update the aggregate accumulators based on the content of\n      ** the current row\n      */\n      sqlite3VdbeJumpHere(v, addr1);\n      updateAccumulator(pParse, iUseFlag, &sAggInfo);\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, iUseFlag);\n      VdbeComment((v, \"indicate data in accumulator\"));\n\n      /* End of the loop\n      */\n      if( groupBySort ){\n        sqlite3VdbeAddOp2(v, OP_SorterNext, sAggInfo.sortingIdx, addrTopOfLoop);\n        VdbeCoverage(v);\n      }else{\n        sqlite3WhereEnd(pWInfo);\n        sqlite3VdbeChangeToNoop(v, addrSortingIdx);\n      }\n\n      /* Output the final row of result\n      */\n      sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);\n      VdbeComment((v, \"output final row\"));\n\n      /* Jump over the subroutines\n      */\n      sqlite3VdbeGoto(v, addrEnd);\n\n      /* Generate a subroutine that outputs a single row of the result\n      ** set.  This subroutine first looks at the iUseFlag.  If iUseFlag\n      ** is less than or equal to zero, the subroutine is a no-op.  If\n      ** the processing calls for the query to abort, this subroutine\n      ** increments the iAbortFlag memory location before returning in\n      ** order to signal the caller to abort.\n      */\n      addrSetAbort = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, iAbortFlag);\n      VdbeComment((v, \"set abort flag\"));\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      sqlite3VdbeResolveLabel(v, addrOutputRow);\n      addrOutputRow = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp2(v, OP_IfPos, iUseFlag, addrOutputRow+2);\n      VdbeCoverage(v);\n      VdbeComment((v, \"Groupby result generator entry point\"));\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      finalizeAggFunctions(pParse, &sAggInfo);\n      sqlite3ExprIfFalse(pParse, pHaving, addrOutputRow+1, SQLITE_JUMPIFNULL);\n      selectInnerLoop(pParse, p, -1, &sSort,\n                      &sDistinct, pDest,\n                      addrOutputRow+1, addrSetAbort);\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      VdbeComment((v, \"end groupby result generator\"));\n\n      /* Generate a subroutine that will reset the group-by accumulator\n      */\n      sqlite3VdbeResolveLabel(v, addrReset);\n      resetAccumulator(pParse, &sAggInfo);\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, iUseFlag);\n      VdbeComment((v, \"indicate accumulator empty\"));\n      sqlite3VdbeAddOp1(v, OP_Return, regReset);\n     \n    } /* endif pGroupBy.  Begin aggregate queries without GROUP BY: */\n    else {\n#ifndef SQLITE_OMIT_BTREECOUNT\n      Table *pTab;\n      if( (pTab = isSimpleCount(p, &sAggInfo))!=0 ){\n        /* If isSimpleCount() returns a pointer to a Table structure, then\n        ** the SQL statement is of the form:\n        **\n        **   SELECT count(*) FROM <tbl>\n        **\n        ** where the Table structure returned represents table <tbl>.\n        **\n        ** This statement is so common that it is optimized specially. The\n        ** OP_Count instruction is executed either on the intkey table that\n        ** contains the data for table <tbl> or on one of its indexes. It\n        ** is better to execute the op on an index, as indexes are almost\n        ** always spread across less pages than their corresponding tables.\n        */\n        const int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n        const int iCsr = pParse->nTab++;     /* Cursor to scan b-tree */\n        Index *pIdx;                         /* Iterator variable */\n        KeyInfo *pKeyInfo = 0;               /* Keyinfo for scanned index */\n        Index *pBest = 0;                    /* Best index found so far */\n        int iRoot = pTab->tnum;              /* Root page of scanned b-tree */\n\n        sqlite3CodeVerifySchema(pParse, iDb);\n        sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n\n        /* Search for the index that has the lowest scan cost.\n        **\n        ** (2011-04-15) Do not do a full scan of an unordered index.\n        **\n        ** (2013-10-03) Do not count the entries in a partial index.\n        **\n        ** In practice the KeyInfo structure will not be used. It is only \n        ** passed to keep OP_OpenRead happy.\n        */\n        if( !HasRowid(pTab) ) pBest = sqlite3PrimaryKeyIndex(pTab);\n        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n          if( pIdx->bUnordered==0\n           && pIdx->szIdxRow<pTab->szTabRow\n           && pIdx->pPartIdxWhere==0\n           && (!pBest || pIdx->szIdxRow<pBest->szIdxRow)\n          ){\n            pBest = pIdx;\n          }\n        }\n        if( pBest ){\n          iRoot = pBest->tnum;\n          pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pBest);\n        }\n\n        /* Open a read-only cursor, execute the OP_Count, close the cursor. */\n        sqlite3VdbeAddOp4Int(v, OP_OpenRead, iCsr, iRoot, iDb, 1);\n        if( pKeyInfo ){\n          sqlite3VdbeChangeP4(v, -1, (char *)pKeyInfo, P4_KEYINFO);\n        }\n        sqlite3VdbeAddOp2(v, OP_Count, iCsr, sAggInfo.aFunc[0].iMem);\n        sqlite3VdbeAddOp1(v, OP_Close, iCsr);\n        explainSimpleCount(pParse, pTab, pBest);\n      }else\n#endif /* SQLITE_OMIT_BTREECOUNT */\n      {\n        int regAcc = 0;           /* \"populate accumulators\" flag */\n\n        /* If there are accumulator registers but no min() or max() functions\n        ** without FILTER clauses, allocate register regAcc. Register regAcc\n        ** will contain 0 the first time the inner loop runs, and 1 thereafter.\n        ** The code generated by updateAccumulator() uses this to ensure\n        ** that the accumulator registers are (a) updated only once if\n        ** there are no min() or max functions or (b) always updated for the\n        ** first row visited by the aggregate, so that they are updated at\n        ** least once even if the FILTER clause means the min() or max() \n        ** function visits zero rows.  */\n        if( sAggInfo.nAccumulator ){\n          for(i=0; i<sAggInfo.nFunc; i++){\n            if( ExprHasProperty(sAggInfo.aFunc[i].pExpr, EP_WinFunc) ) continue;\n            if( sAggInfo.aFunc[i].pFunc->funcFlags&SQLITE_FUNC_NEEDCOLL ) break;\n          }\n          if( i==sAggInfo.nFunc ){\n            regAcc = ++pParse->nMem;\n            sqlite3VdbeAddOp2(v, OP_Integer, 0, regAcc);\n          }\n        }\n\n        /* This case runs if the aggregate has no GROUP BY clause.  The\n        ** processing is much simpler since there is only a single row\n        ** of output.\n        */\n        assert( p->pGroupBy==0 );\n        resetAccumulator(pParse, &sAggInfo);\n\n        /* If this query is a candidate for the min/max optimization, then\n        ** minMaxFlag will have been previously set to either\n        ** WHERE_ORDERBY_MIN or WHERE_ORDERBY_MAX and pMinMaxOrderBy will\n        ** be an appropriate ORDER BY expression for the optimization.\n        */\n        assert( minMaxFlag==WHERE_ORDERBY_NORMAL || pMinMaxOrderBy!=0 );\n        assert( pMinMaxOrderBy==0 || pMinMaxOrderBy->nExpr==1 );\n\n        SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n        pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMaxOrderBy,\n                                   0, minMaxFlag, 0);\n        if( pWInfo==0 ){\n          goto select_end;\n        }\n        updateAccumulator(pParse, regAcc, &sAggInfo);\n        if( regAcc ) sqlite3VdbeAddOp2(v, OP_Integer, 1, regAcc);\n        if( sqlite3WhereIsOrdered(pWInfo)>0 ){\n          sqlite3VdbeGoto(v, sqlite3WhereBreakLabel(pWInfo));\n          VdbeComment((v, \"%s() by index\",\n                (minMaxFlag==WHERE_ORDERBY_MIN?\"min\":\"max\")));\n        }\n        sqlite3WhereEnd(pWInfo);\n        finalizeAggFunctions(pParse, &sAggInfo);\n      }\n\n      sSort.pOrderBy = 0;\n      sqlite3ExprIfFalse(pParse, pHaving, addrEnd, SQLITE_JUMPIFNULL);\n      selectInnerLoop(pParse, p, -1, 0, 0, \n                      pDest, addrEnd, addrEnd);\n    }\n    sqlite3VdbeResolveLabel(v, addrEnd);\n    \n  } /* endif aggregate query */\n\n  if( sDistinct.eTnctType==WHERE_DISTINCT_UNORDERED ){\n    explainTempTable(pParse, \"DISTINCT\");\n  }\n\n  /* If there is an ORDER BY clause, then we need to sort the results\n  ** and send them to the callback one by one.\n  */\n  if( sSort.pOrderBy ){\n    explainTempTable(pParse,\n                     sSort.nOBSat>0 ? \"RIGHT PART OF ORDER BY\":\"ORDER BY\");\n    assert( p->pEList==pEList );\n    generateSortTail(pParse, p, &sSort, pEList->nExpr, pDest);\n  }\n\n  /* Jump here to skip this query\n  */\n  sqlite3VdbeResolveLabel(v, iEnd);\n\n  /* The SELECT has been coded. If there is an error in the Parse structure,\n  ** set the return code to 1. Otherwise 0. */\n  rc = (pParse->nErr>0);\n\n  /* Control jumps to here if an error is encountered above, or upon\n  ** successful coding of the SELECT.\n  */\nselect_end:\n  sqlite3ExprListDelete(db, pMinMaxOrderBy);\n  sqlite3DbFree(db, sAggInfo.aCol);\n  sqlite3DbFree(db, sAggInfo.aFunc);\n#if SELECTTRACE_ENABLED\n  SELECTTRACE(0x1,pParse,p,(\"end processing\\n\"));\n  if( (sqlite3SelectTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n  ExplainQueryPlanPop(pParse);\n  return rc;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146062,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int sqlite3Select(\n  Parse *pParse,         /* The parser context */\n  Select *p,             /* The SELECT statement being coded. */\n  SelectDest *pDest      /* What to do with the query results */\n){\n  int i, j;              /* Loop counters */\n  WhereInfo *pWInfo;     /* Return from sqlite3WhereBegin() */\n  Vdbe *v;               /* The virtual machine under construction */\n  int isAgg;             /* True for select lists like \"count(*)\" */\n  ExprList *pEList = 0;  /* List of columns to extract. */\n  SrcList *pTabList;     /* List of tables to select from */\n  Expr *pWhere;          /* The WHERE clause.  May be NULL */\n  ExprList *pGroupBy;    /* The GROUP BY clause.  May be NULL */\n  Expr *pHaving;         /* The HAVING clause.  May be NULL */\n  int rc = 1;            /* Value to return from this function */\n  DistinctCtx sDistinct; /* Info on how to code the DISTINCT keyword */\n  SortCtx sSort;         /* Info on how to code the ORDER BY clause */\n  AggInfo sAggInfo;      /* Information used by aggregate queries */\n  int iEnd;              /* Address of the end of the query */\n  sqlite3 *db;           /* The database connection */\n  ExprList *pMinMaxOrderBy = 0;  /* Added ORDER BY for min/max queries */\n  u8 minMaxFlag;                 /* Flag for min/max queries */\n\n  db = pParse->db;\n  v = sqlite3GetVdbe(pParse);\n  if( p==0 || db->mallocFailed || pParse->nErr ){\n    return 1;\n  }\n  if( sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0) ) return 1;\n  memset(&sAggInfo, 0, sizeof(sAggInfo));\n#if SELECTTRACE_ENABLED\n  SELECTTRACE(1,pParse,p, (\"begin processing:\\n\", pParse->addrExplain));\n  if( sqlite3SelectTrace & 0x100 ){\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistFifo );\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_Fifo );\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistQueue );\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_Queue );\n  if( IgnorableOrderby(pDest) ){\n    assert(pDest->eDest==SRT_Exists || pDest->eDest==SRT_Union || \n           pDest->eDest==SRT_Except || pDest->eDest==SRT_Discard ||\n           pDest->eDest==SRT_Queue  || pDest->eDest==SRT_DistFifo ||\n           pDest->eDest==SRT_DistQueue || pDest->eDest==SRT_Fifo);\n    /* If ORDER BY makes no difference in the output then neither does\n    ** DISTINCT so it can be removed too. */\n    sqlite3ExprListDelete(db, p->pOrderBy);\n    p->pOrderBy = 0;\n    p->selFlags &= ~SF_Distinct;\n  }\n  sqlite3SelectPrep(pParse, p, 0);\n  if( pParse->nErr || db->mallocFailed ){\n    goto select_end;\n  }\n  assert( p->pEList!=0 );\n#if SELECTTRACE_ENABLED\n  if( sqlite3SelectTrace & 0x104 ){\n    SELECTTRACE(0x104,pParse,p, (\"after name resolution:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  if( pDest->eDest==SRT_Output ){\n    generateColumnNames(pParse, p);\n  }\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  if( sqlite3WindowRewrite(pParse, p) ){\n    goto select_end;\n  }\n#if SELECTTRACE_ENABLED\n  if( p->pWin && (sqlite3SelectTrace & 0x108)!=0 ){\n    SELECTTRACE(0x104,pParse,p, (\"after window rewrite:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n#endif /* SQLITE_OMIT_WINDOWFUNC */\n  pTabList = p->pSrc;\n  isAgg = (p->selFlags & SF_Aggregate)!=0;\n  memset(&sSort, 0, sizeof(sSort));\n  sSort.pOrderBy = p->pOrderBy;\n\n  /* Try to various optimizations (flattening subqueries, and strength\n  ** reduction of join operators) in the FROM clause up into the main query\n  */\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n  for(i=0; !p->pPrior && i<pTabList->nSrc; i++){\n    struct SrcList_item *pItem = &pTabList->a[i];\n    Select *pSub = pItem->pSelect;\n    Table *pTab = pItem->pTab;\n\n    /* Convert LEFT JOIN into JOIN if there are terms of the right table\n    ** of the LEFT JOIN used in the WHERE clause.\n    */\n    if( (pItem->fg.jointype & JT_LEFT)!=0\n     && sqlite3ExprImpliesNonNullRow(p->pWhere, pItem->iCursor)\n     && OptimizationEnabled(db, SQLITE_SimplifyJoin)\n    ){\n      SELECTTRACE(0x100,pParse,p,\n                (\"LEFT-JOIN simplifies to JOIN on term %d\\n\",i));\n      pItem->fg.jointype &= ~(JT_LEFT|JT_OUTER);\n      unsetJoinExpr(p->pWhere, pItem->iCursor);\n    }\n\n    /* No futher action if this term of the FROM clause is no a subquery */\n    if( pSub==0 ) continue;\n\n    /* Catch mismatch in the declared columns of a view and the number of\n    ** columns in the SELECT on the RHS */\n    if( pTab->nCol!=pSub->pEList->nExpr ){\n      sqlite3ErrorMsg(pParse, \"expected %d columns for '%s' but got %d\",\n                      pTab->nCol, pTab->zName, pSub->pEList->nExpr);\n      goto select_end;\n    }\n\n    /* Do not try to flatten an aggregate subquery.\n    **\n    ** Flattening an aggregate subquery is only possible if the outer query\n    ** is not a join.  But if the outer query is not a join, then the subquery\n    ** will be implemented as a co-routine and there is no advantage to\n    ** flattening in that case.\n    */\n    if( (pSub->selFlags & SF_Aggregate)!=0 ) continue;\n    assert( pSub->pGroupBy==0 );\n\n    /* If the outer query contains a \"complex\" result set (that is,\n    ** if the result set of the outer query uses functions or subqueries)\n    ** and if the subquery contains an ORDER BY clause and if\n    ** it will be implemented as a co-routine, then do not flatten.  This\n    ** restriction allows SQL constructs like this:\n    **\n    **  SELECT expensive_function(x)\n    **    FROM (SELECT x FROM tab ORDER BY y LIMIT 10);\n    **\n    ** The expensive_function() is only computed on the 10 rows that\n    ** are output, rather than every row of the table.\n    **\n    ** The requirement that the outer query have a complex result set\n    ** means that flattening does occur on simpler SQL constraints without\n    ** the expensive_function() like:\n    **\n    **  SELECT x FROM (SELECT x FROM tab ORDER BY y LIMIT 10);\n    */\n    if( pSub->pOrderBy!=0\n     && i==0\n     && (p->selFlags & SF_ComplexResult)!=0\n     && (pTabList->nSrc==1\n         || (pTabList->a[1].fg.jointype&(JT_LEFT|JT_CROSS))!=0)\n    ){\n      continue;\n    }\n\n    if( flattenSubquery(pParse, p, i, isAgg) ){\n      if( pParse->nErr ) goto select_end;\n      /* This subquery can be absorbed into its parent. */\n      i = -1;\n    }\n    pTabList = p->pSrc;\n    if( db->mallocFailed ) goto select_end;\n    if( !IgnorableOrderby(pDest) ){\n      sSort.pOrderBy = p->pOrderBy;\n    }\n  }\n#endif\n\n#ifndef SQLITE_OMIT_COMPOUND_SELECT\n  /* Handle compound SELECT statements using the separate multiSelect()\n  ** procedure.\n  */\n  if( p->pPrior ){\n    rc = multiSelect(pParse, p, pDest);\n#if SELECTTRACE_ENABLED\n    SELECTTRACE(0x1,pParse,p,(\"end compound-select processing\\n\"));\n    if( (sqlite3SelectTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){\n      sqlite3TreeViewSelect(0, p, 0);\n    }\n#endif\n    if( p->pNext==0 ) ExplainQueryPlanPop(pParse);\n    return rc;\n  }\n#endif\n\n  /* Do the WHERE-clause constant propagation optimization if this is\n  ** a join.  No need to speed time on this operation for non-join queries\n  ** as the equivalent optimization will be handled by query planner in\n  ** sqlite3WhereBegin().\n  */\n  if( pTabList->nSrc>1\n   && OptimizationEnabled(db, SQLITE_PropagateConst)\n   && propagateConstants(pParse, p)\n  ){\n#if SELECTTRACE_ENABLED\n    if( sqlite3SelectTrace & 0x100 ){\n      SELECTTRACE(0x100,pParse,p,(\"After constant propagation:\\n\"));\n      sqlite3TreeViewSelect(0, p, 0);\n    }\n#endif\n  }else{\n    SELECTTRACE(0x100,pParse,p,(\"Constant propagation not helpful\\n\"));\n  }\n\n#ifdef SQLITE_COUNTOFVIEW_OPTIMIZATION\n  if( OptimizationEnabled(db, SQLITE_QueryFlattener|SQLITE_CountOfView)\n   && countOfViewOptimization(pParse, p)\n  ){\n    if( db->mallocFailed ) goto select_end;\n    pEList = p->pEList;\n    pTabList = p->pSrc;\n  }\n#endif\n\n  /* For each term in the FROM clause, do two things:\n  ** (1) Authorized unreferenced tables\n  ** (2) Generate code for all sub-queries\n  */\n  for(i=0; i<pTabList->nSrc; i++){\n    struct SrcList_item *pItem = &pTabList->a[i];\n    SelectDest dest;\n    Select *pSub;\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n    const char *zSavedAuthContext;\n#endif\n\n    /* Issue SQLITE_READ authorizations with a fake column name for any\n    ** tables that are referenced but from which no values are extracted.\n    ** Examples of where these kinds of null SQLITE_READ authorizations\n    ** would occur:\n    **\n    **     SELECT count(*) FROM t1;   -- SQLITE_READ t1.\"\"\n    **     SELECT t1.* FROM t1, t2;   -- SQLITE_READ t2.\"\"\n    **\n    ** The fake column name is an empty string.  It is possible for a table to\n    ** have a column named by the empty string, in which case there is no way to\n    ** distinguish between an unreferenced table and an actual reference to the\n    ** \"\" column. The original design was for the fake column name to be a NULL,\n    ** which would be unambiguous.  But legacy authorization callbacks might\n    ** assume the column name is non-NULL and segfault.  The use of an empty\n    ** string for the fake column name seems safer.\n    */\n    if( pItem->colUsed==0 && pItem->zName!=0 ){\n      sqlite3AuthCheck(pParse, SQLITE_READ, pItem->zName, \"\", pItem->zDatabase);\n    }\n\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n    /* Generate code for all sub-queries in the FROM clause\n    */\n    pSub = pItem->pSelect;\n    if( pSub==0 ) continue;\n\n    /* The code for a subquery should only be generated once, though it is\n    ** technically harmless for it to be generated multiple times. The\n    ** following assert() will detect if something changes to cause\n    ** the same subquery to be coded multiple times, as a signal to the\n    ** developers to try to optimize the situation.\n    **\n    ** Update 2019-07-24:\n    ** See ticket https://sqlite.org/src/tktview/c52b09c7f38903b1311cec40.\n    ** The dbsqlfuzz fuzzer found a case where the same subquery gets\n    ** coded twice.  So this assert() now becomes a testcase().  It should\n    ** be very rare, though.\n    */\n    testcase( pItem->addrFillSub!=0 );\n\n    /* Increment Parse.nHeight by the height of the largest expression\n    ** tree referred to by this, the parent select. The child select\n    ** may contain expression trees of at most\n    ** (SQLITE_MAX_EXPR_DEPTH-Parse.nHeight) height. This is a bit\n    ** more conservative than necessary, but much easier than enforcing\n    ** an exact limit.\n    */\n    pParse->nHeight += sqlite3SelectExprHeight(p);\n\n    /* Make copies of constant WHERE-clause terms in the outer query down\n    ** inside the subquery.  This can help the subquery to run more efficiently.\n    */\n    if( OptimizationEnabled(db, SQLITE_PushDown)\n     && pushDownWhereTerms(pParse, pSub, p->pWhere, pItem->iCursor,\n                           (pItem->fg.jointype & JT_OUTER)!=0)\n    ){\n#if SELECTTRACE_ENABLED\n      if( sqlite3SelectTrace & 0x100 ){\n        SELECTTRACE(0x100,pParse,p,\n            (\"After WHERE-clause push-down into subquery %d:\\n\", pSub->selId));\n        sqlite3TreeViewSelect(0, p, 0);\n      }\n#endif\n    }else{\n      SELECTTRACE(0x100,pParse,p,(\"Push-down not possible\\n\"));\n    }\n\n    zSavedAuthContext = pParse->zAuthContext;\n    pParse->zAuthContext = pItem->zName;\n\n    /* Generate code to implement the subquery\n    **\n    ** The subquery is implemented as a co-routine if the subquery is\n    ** guaranteed to be the outer loop (so that it does not need to be\n    ** computed more than once)\n    **\n    ** TODO: Are there other reasons beside (1) to use a co-routine\n    ** implementation?\n    */\n    if( i==0\n     && (pTabList->nSrc==1\n            || (pTabList->a[1].fg.jointype&(JT_LEFT|JT_CROSS))!=0)  /* (1) */\n    ){\n      /* Implement a co-routine that will return a single row of the result\n      ** set on each invocation.\n      */\n      int addrTop = sqlite3VdbeCurrentAddr(v)+1;\n     \n      pItem->regReturn = ++pParse->nMem;\n      sqlite3VdbeAddOp3(v, OP_InitCoroutine, pItem->regReturn, 0, addrTop);\n      VdbeComment((v, \"%s\", pItem->pTab->zName));\n      pItem->addrFillSub = addrTop;\n      sqlite3SelectDestInit(&dest, SRT_Coroutine, pItem->regReturn);\n      ExplainQueryPlan((pParse, 1, \"CO-ROUTINE %u\", pSub->selId));\n      sqlite3Select(pParse, pSub, &dest);\n      pItem->pTab->nRowLogEst = pSub->nSelectRow;\n      pItem->fg.viaCoroutine = 1;\n      pItem->regResult = dest.iSdst;\n      sqlite3VdbeEndCoroutine(v, pItem->regReturn);\n      sqlite3VdbeJumpHere(v, addrTop-1);\n      sqlite3ClearTempRegCache(pParse);\n    }else{\n      /* Generate a subroutine that will fill an ephemeral table with\n      ** the content of this subquery.  pItem->addrFillSub will point\n      ** to the address of the generated subroutine.  pItem->regReturn\n      ** is a register allocated to hold the subroutine return address\n      */\n      int topAddr;\n      int onceAddr = 0;\n      int retAddr;\n      struct SrcList_item *pPrior;\n\n      testcase( pItem->addrFillSub==0 ); /* Ticket c52b09c7f38903b1311 */\n      pItem->regReturn = ++pParse->nMem;\n      topAddr = sqlite3VdbeAddOp2(v, OP_Integer, 0, pItem->regReturn);\n      pItem->addrFillSub = topAddr+1;\n      if( pItem->fg.isCorrelated==0 ){\n        /* If the subquery is not correlated and if we are not inside of\n        ** a trigger, then we only need to compute the value of the subquery\n        ** once. */\n        onceAddr = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);\n        VdbeComment((v, \"materialize \\\"%s\\\"\", pItem->pTab->zName));\n      }else{\n        VdbeNoopComment((v, \"materialize \\\"%s\\\"\", pItem->pTab->zName));\n      }\n      pPrior = isSelfJoinView(pTabList, pItem);\n      if( pPrior ){\n        sqlite3VdbeAddOp2(v, OP_OpenDup, pItem->iCursor, pPrior->iCursor);\n        assert( pPrior->pSelect!=0 );\n        pSub->nSelectRow = pPrior->pSelect->nSelectRow;\n      }else{\n        sqlite3SelectDestInit(&dest, SRT_EphemTab, pItem->iCursor);\n        ExplainQueryPlan((pParse, 1, \"MATERIALIZE %u\", pSub->selId));\n        sqlite3Select(pParse, pSub, &dest);\n      }\n      pItem->pTab->nRowLogEst = pSub->nSelectRow;\n      if( onceAddr ) sqlite3VdbeJumpHere(v, onceAddr);\n      retAddr = sqlite3VdbeAddOp1(v, OP_Return, pItem->regReturn);\n      VdbeComment((v, \"end %s\", pItem->pTab->zName));\n      sqlite3VdbeChangeP1(v, topAddr, retAddr);\n      sqlite3ClearTempRegCache(pParse);\n    }\n    if( db->mallocFailed ) goto select_end;\n    pParse->nHeight -= sqlite3SelectExprHeight(p);\n    pParse->zAuthContext = zSavedAuthContext;\n#endif\n  }\n\n  /* Various elements of the SELECT copied into local variables for\n  ** convenience */\n  pEList = p->pEList;\n  pWhere = p->pWhere;\n  pGroupBy = p->pGroupBy;\n  pHaving = p->pHaving;\n  sDistinct.isTnct = (p->selFlags & SF_Distinct)!=0;\n\n#if SELECTTRACE_ENABLED\n  if( sqlite3SelectTrace & 0x400 ){\n    SELECTTRACE(0x400,pParse,p,(\"After all FROM-clause analysis:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  /* If the query is DISTINCT with an ORDER BY but is not an aggregate, and \n  ** if the select-list is the same as the ORDER BY list, then this query\n  ** can be rewritten as a GROUP BY. In other words, this:\n  **\n  **     SELECT DISTINCT xyz FROM ... ORDER BY xyz\n  **\n  ** is transformed to:\n  **\n  **     SELECT xyz FROM ... GROUP BY xyz ORDER BY xyz\n  **\n  ** The second form is preferred as a single index (or temp-table) may be \n  ** used for both the ORDER BY and DISTINCT processing. As originally \n  ** written the query must use a temp-table for at least one of the ORDER \n  ** BY and DISTINCT, and an index or separate temp-table for the other.\n  */\n  if( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct \n   && sqlite3ExprListCompare(sSort.pOrderBy, pEList, -1)==0\n   && p->pWin==0\n  ){\n    p->selFlags &= ~SF_Distinct;\n    pGroupBy = p->pGroupBy = sqlite3ExprListDup(db, pEList, 0);\n    /* Notice that even thought SF_Distinct has been cleared from p->selFlags,\n    ** the sDistinct.isTnct is still set.  Hence, isTnct represents the\n    ** original setting of the SF_Distinct flag, not the current setting */\n    assert( sDistinct.isTnct );\n\n#if SELECTTRACE_ENABLED\n    if( sqlite3SelectTrace & 0x400 ){\n      SELECTTRACE(0x400,pParse,p,(\"Transform DISTINCT into GROUP BY:\\n\"));\n      sqlite3TreeViewSelect(0, p, 0);\n    }\n#endif\n  }\n\n  /* If there is an ORDER BY clause, then create an ephemeral index to\n  ** do the sorting.  But this sorting ephemeral index might end up\n  ** being unused if the data can be extracted in pre-sorted order.\n  ** If that is the case, then the OP_OpenEphemeral instruction will be\n  ** changed to an OP_Noop once we figure out that the sorting index is\n  ** not needed.  The sSort.addrSortIndex variable is used to facilitate\n  ** that change.\n  */\n  if( sSort.pOrderBy ){\n    KeyInfo *pKeyInfo;\n    pKeyInfo = sqlite3KeyInfoFromExprList(\n        pParse, sSort.pOrderBy, 0, pEList->nExpr);\n    sSort.iECursor = pParse->nTab++;\n    sSort.addrSortIndex =\n      sqlite3VdbeAddOp4(v, OP_OpenEphemeral,\n          sSort.iECursor, sSort.pOrderBy->nExpr+1+pEList->nExpr, 0,\n          (char*)pKeyInfo, P4_KEYINFO\n      );\n  }else{\n    sSort.addrSortIndex = -1;\n  }\n\n  /* If the output is destined for a temporary table, open that table.\n  */\n  if( pDest->eDest==SRT_EphemTab ){\n    sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pDest->iSDParm, pEList->nExpr);\n  }\n\n  /* Set the limiter.\n  */\n  iEnd = sqlite3VdbeMakeLabel(pParse);\n  if( (p->selFlags & SF_FixedLimit)==0 ){\n    p->nSelectRow = 320;  /* 4 billion rows */\n  }\n  computeLimitRegisters(pParse, p, iEnd);\n  if( p->iLimit==0 && sSort.addrSortIndex>=0 ){\n    sqlite3VdbeChangeOpcode(v, sSort.addrSortIndex, OP_SorterOpen);\n    sSort.sortFlags |= SORTFLAG_UseSorter;\n  }\n\n  /* Open an ephemeral index to use for the distinct set.\n  */\n  if( p->selFlags & SF_Distinct ){\n    sDistinct.tabTnct = pParse->nTab++;\n    sDistinct.addrTnct = sqlite3VdbeAddOp4(v, OP_OpenEphemeral,\n                       sDistinct.tabTnct, 0, 0,\n                       (char*)sqlite3KeyInfoFromExprList(pParse, p->pEList,0,0),\n                       P4_KEYINFO);\n    sqlite3VdbeChangeP5(v, BTREE_UNORDERED);\n    sDistinct.eTnctType = WHERE_DISTINCT_UNORDERED;\n  }else{\n    sDistinct.eTnctType = WHERE_DISTINCT_NOOP;\n  }\n\n  if( !isAgg && pGroupBy==0 ){\n    /* No aggregate functions and no GROUP BY clause */\n    u16 wctrlFlags = (sDistinct.isTnct ? WHERE_WANT_DISTINCT : 0)\n                   | (p->selFlags & SF_FixedLimit);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    Window *pWin = p->pWin;      /* Master window object (or NULL) */\n    if( pWin ){\n      sqlite3WindowCodeInit(pParse, pWin);\n    }\n#endif\n    assert( WHERE_USE_LIMIT==SF_FixedLimit );\n\n\n    /* Begin the database scan. */\n    SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, sSort.pOrderBy,\n                               p->pEList, wctrlFlags, p->nSelectRow);\n    if( pWInfo==0 ) goto select_end;\n    if( sqlite3WhereOutputRowCount(pWInfo) < p->nSelectRow ){\n      p->nSelectRow = sqlite3WhereOutputRowCount(pWInfo);\n    }\n    if( sDistinct.isTnct && sqlite3WhereIsDistinct(pWInfo) ){\n      sDistinct.eTnctType = sqlite3WhereIsDistinct(pWInfo);\n    }\n    if( sSort.pOrderBy ){\n      sSort.nOBSat = sqlite3WhereIsOrdered(pWInfo);\n      sSort.labelOBLopt = sqlite3WhereOrderByLimitOptLabel(pWInfo);\n      if( sSort.nOBSat==sSort.pOrderBy->nExpr ){\n        sSort.pOrderBy = 0;\n      }\n    }\n\n    /* If sorting index that was created by a prior OP_OpenEphemeral \n    ** instruction ended up not being needed, then change the OP_OpenEphemeral\n    ** into an OP_Noop.\n    */\n    if( sSort.addrSortIndex>=0 && sSort.pOrderBy==0 ){\n      sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);\n    }\n\n    assert( p->pEList==pEList );\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    if( pWin ){\n      int addrGosub = sqlite3VdbeMakeLabel(pParse);\n      int iCont = sqlite3VdbeMakeLabel(pParse);\n      int iBreak = sqlite3VdbeMakeLabel(pParse);\n      int regGosub = ++pParse->nMem;\n\n      sqlite3WindowCodeStep(pParse, p, pWInfo, regGosub, addrGosub);\n\n      sqlite3VdbeAddOp2(v, OP_Goto, 0, iBreak);\n      sqlite3VdbeResolveLabel(v, addrGosub);\n      VdbeNoopComment((v, \"inner-loop subroutine\"));\n      sSort.labelOBLopt = 0;\n      selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, iCont, iBreak);\n      sqlite3VdbeResolveLabel(v, iCont);\n      sqlite3VdbeAddOp1(v, OP_Return, regGosub);\n      VdbeComment((v, \"end inner-loop subroutine\"));\n      sqlite3VdbeResolveLabel(v, iBreak);\n    }else\n#endif /* SQLITE_OMIT_WINDOWFUNC */\n    {\n      /* Use the standard inner loop. */\n      selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest,\n          sqlite3WhereContinueLabel(pWInfo),\n          sqlite3WhereBreakLabel(pWInfo));\n\n      /* End the database scan loop.\n      */\n      sqlite3WhereEnd(pWInfo);\n    }\n  }else{\n    /* This case when there exist aggregate functions or a GROUP BY clause\n    ** or both */\n    NameContext sNC;    /* Name context for processing aggregate information */\n    int iAMem;          /* First Mem address for storing current GROUP BY */\n    int iBMem;          /* First Mem address for previous GROUP BY */\n    int iUseFlag;       /* Mem address holding flag indicating that at least\n                        ** one row of the input to the aggregator has been\n                        ** processed */\n    int iAbortFlag;     /* Mem address which causes query abort if positive */\n    int groupBySort;    /* Rows come from source in GROUP BY order */\n    int addrEnd;        /* End of processing for this SELECT */\n    int sortPTab = 0;   /* Pseudotable used to decode sorting results */\n    int sortOut = 0;    /* Output register from the sorter */\n    int orderByGrp = 0; /* True if the GROUP BY and ORDER BY are the same */\n\n    /* Remove any and all aliases between the result set and the\n    ** GROUP BY clause.\n    */\n    if( pGroupBy ){\n      int k;                        /* Loop counter */\n      struct ExprList_item *pItem;  /* For looping over expression in a list */\n\n      for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++){\n        pItem->u.x.iAlias = 0;\n      }\n      for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++){\n        pItem->u.x.iAlias = 0;\n      }\n      assert( 66==sqlite3LogEst(100) );\n      if( p->nSelectRow>66 ) p->nSelectRow = 66;\n\n      /* If there is both a GROUP BY and an ORDER BY clause and they are\n      ** identical, then it may be possible to disable the ORDER BY clause \n      ** on the grounds that the GROUP BY will cause elements to come out \n      ** in the correct order. It also may not - the GROUP BY might use a\n      ** database index that causes rows to be grouped together as required\n      ** but not actually sorted. Either way, record the fact that the\n      ** ORDER BY and GROUP BY clauses are the same by setting the orderByGrp\n      ** variable.  */\n      if( sSort.pOrderBy && pGroupBy->nExpr==sSort.pOrderBy->nExpr ){\n        int ii;\n        /* The GROUP BY processing doesn't care whether rows are delivered in\n        ** ASC or DESC order - only that each group is returned contiguously.\n        ** So set the ASC/DESC flags in the GROUP BY to match those in the \n        ** ORDER BY to maximize the chances of rows being delivered in an \n        ** order that makes the ORDER BY redundant.  */\n        for(ii=0; ii<pGroupBy->nExpr; ii++){\n          u8 sortFlags = sSort.pOrderBy->a[ii].sortFlags & KEYINFO_ORDER_DESC;\n          pGroupBy->a[ii].sortFlags = sortFlags;\n        }\n        if( sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, -1)==0 ){\n          orderByGrp = 1;\n        }\n      }\n    }else{\n      assert( 0==sqlite3LogEst(1) );\n      p->nSelectRow = 0;\n    }\n\n    /* Create a label to jump to when we want to abort the query */\n    addrEnd = sqlite3VdbeMakeLabel(pParse);\n\n    /* Convert TK_COLUMN nodes into TK_AGG_COLUMN and make entries in\n    ** sAggInfo for all TK_AGG_FUNCTION nodes in expressions of the\n    ** SELECT statement.\n    */\n    memset(&sNC, 0, sizeof(sNC));\n    sNC.pParse = pParse;\n    sNC.pSrcList = pTabList;\n    sNC.uNC.pAggInfo = &sAggInfo;\n    VVA_ONLY( sNC.ncFlags = NC_UAggInfo; )\n    sAggInfo.mnReg = pParse->nMem+1;\n    sAggInfo.nSortingColumn = pGroupBy ? pGroupBy->nExpr : 0;\n    sAggInfo.pGroupBy = pGroupBy;\n    sqlite3ExprAnalyzeAggList(&sNC, pEList);\n    sqlite3ExprAnalyzeAggList(&sNC, sSort.pOrderBy);\n    if( pHaving ){\n      if( pGroupBy ){\n        assert( pWhere==p->pWhere );\n        assert( pHaving==p->pHaving );\n        assert( pGroupBy==p->pGroupBy );\n        havingToWhere(pParse, p);\n        pWhere = p->pWhere;\n      }\n      sqlite3ExprAnalyzeAggregates(&sNC, pHaving);\n    }\n    sAggInfo.nAccumulator = sAggInfo.nColumn;\n    if( p->pGroupBy==0 && p->pHaving==0 && sAggInfo.nFunc==1 ){\n      minMaxFlag = minMaxQuery(db, sAggInfo.aFunc[0].pExpr, &pMinMaxOrderBy);\n    }else{\n      minMaxFlag = WHERE_ORDERBY_NORMAL;\n    }\n    for(i=0; i<sAggInfo.nFunc; i++){\n      Expr *pExpr = sAggInfo.aFunc[i].pExpr;\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n      sNC.ncFlags |= NC_InAggFunc;\n      sqlite3ExprAnalyzeAggList(&sNC, pExpr->x.pList);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n      assert( !IsWindowFunc(pExpr) );\n      if( ExprHasProperty(pExpr, EP_WinFunc) ){\n        sqlite3ExprAnalyzeAggregates(&sNC, pExpr->y.pWin->pFilter);\n      }\n#endif\n      sNC.ncFlags &= ~NC_InAggFunc;\n    }\n    sAggInfo.mxReg = pParse->nMem;\n    if( db->mallocFailed ) goto select_end;\n#if SELECTTRACE_ENABLED\n    if( sqlite3SelectTrace & 0x400 ){\n      int ii;\n      SELECTTRACE(0x400,pParse,p,(\"After aggregate analysis:\\n\"));\n      sqlite3TreeViewSelect(0, p, 0);\n      for(ii=0; ii<sAggInfo.nColumn; ii++){\n        sqlite3DebugPrintf(\"agg-column[%d] iMem=%d\\n\",\n            ii, sAggInfo.aCol[ii].iMem);\n        sqlite3TreeViewExpr(0, sAggInfo.aCol[ii].pExpr, 0);\n      }\n      for(ii=0; ii<sAggInfo.nFunc; ii++){\n        sqlite3DebugPrintf(\"agg-func[%d]: iMem=%d\\n\",\n            ii, sAggInfo.aFunc[ii].iMem);\n        sqlite3TreeViewExpr(0, sAggInfo.aFunc[ii].pExpr, 0);\n      }\n    }\n#endif\n\n\n    /* Processing for aggregates with GROUP BY is very different and\n    ** much more complex than aggregates without a GROUP BY.\n    */\n    if( pGroupBy ){\n      KeyInfo *pKeyInfo;  /* Keying information for the group by clause */\n      int addr1;          /* A-vs-B comparision jump */\n      int addrOutputRow;  /* Start of subroutine that outputs a result row */\n      int regOutputRow;   /* Return address register for output subroutine */\n      int addrSetAbort;   /* Set the abort flag and return */\n      int addrTopOfLoop;  /* Top of the input loop */\n      int addrSortingIdx; /* The OP_OpenEphemeral for the sorting index */\n      int addrReset;      /* Subroutine for resetting the accumulator */\n      int regReset;       /* Return address register for reset subroutine */\n\n      /* If there is a GROUP BY clause we might need a sorting index to\n      ** implement it.  Allocate that sorting index now.  If it turns out\n      ** that we do not need it after all, the OP_SorterOpen instruction\n      ** will be converted into a Noop.  \n      */\n      sAggInfo.sortingIdx = pParse->nTab++;\n      pKeyInfo = sqlite3KeyInfoFromExprList(pParse,pGroupBy,0,sAggInfo.nColumn);\n      addrSortingIdx = sqlite3VdbeAddOp4(v, OP_SorterOpen, \n          sAggInfo.sortingIdx, sAggInfo.nSortingColumn, \n          0, (char*)pKeyInfo, P4_KEYINFO);\n\n      /* Initialize memory locations used by GROUP BY aggregate processing\n      */\n      iUseFlag = ++pParse->nMem;\n      iAbortFlag = ++pParse->nMem;\n      regOutputRow = ++pParse->nMem;\n      addrOutputRow = sqlite3VdbeMakeLabel(pParse);\n      regReset = ++pParse->nMem;\n      addrReset = sqlite3VdbeMakeLabel(pParse);\n      iAMem = pParse->nMem + 1;\n      pParse->nMem += pGroupBy->nExpr;\n      iBMem = pParse->nMem + 1;\n      pParse->nMem += pGroupBy->nExpr;\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, iAbortFlag);\n      VdbeComment((v, \"clear abort flag\"));\n      sqlite3VdbeAddOp3(v, OP_Null, 0, iAMem, iAMem+pGroupBy->nExpr-1);\n\n      /* Begin a loop that will extract all source rows in GROUP BY order.\n      ** This might involve two separate loops with an OP_Sort in between, or\n      ** it might be a single loop that uses an index to extract information\n      ** in the right order to begin with.\n      */\n      sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);\n      SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n      pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, 0,\n          WHERE_GROUPBY | (orderByGrp ? WHERE_SORTBYGROUP : 0), 0\n      );\n      if( pWInfo==0 ) goto select_end;\n      if( sqlite3WhereIsOrdered(pWInfo)==pGroupBy->nExpr ){\n        /* The optimizer is able to deliver rows in group by order so\n        ** we do not have to sort.  The OP_OpenEphemeral table will be\n        ** cancelled later because we still need to use the pKeyInfo\n        */\n        groupBySort = 0;\n      }else{\n        /* Rows are coming out in undetermined order.  We have to push\n        ** each row into a sorting index, terminate the first loop,\n        ** then loop over the sorting index in order to get the output\n        ** in sorted order\n        */\n        int regBase;\n        int regRecord;\n        int nCol;\n        int nGroupBy;\n\n        explainTempTable(pParse, \n            (sDistinct.isTnct && (p->selFlags&SF_Distinct)==0) ?\n                    \"DISTINCT\" : \"GROUP BY\");\n\n        groupBySort = 1;\n        nGroupBy = pGroupBy->nExpr;\n        nCol = nGroupBy;\n        j = nGroupBy;\n        for(i=0; i<sAggInfo.nColumn; i++){\n          if( sAggInfo.aCol[i].iSorterColumn>=j ){\n            nCol++;\n            j++;\n          }\n        }\n        regBase = sqlite3GetTempRange(pParse, nCol);\n        sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0, 0);\n        j = nGroupBy;\n        for(i=0; i<sAggInfo.nColumn; i++){\n          struct AggInfo_col *pCol = &sAggInfo.aCol[i];\n          if( pCol->iSorterColumn>=j ){\n            int r1 = j + regBase;\n            sqlite3ExprCodeGetColumnOfTable(v,\n                               pCol->pTab, pCol->iTable, pCol->iColumn, r1);\n            j++;\n          }\n        }\n        regRecord = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase, nCol, regRecord);\n        sqlite3VdbeAddOp2(v, OP_SorterInsert, sAggInfo.sortingIdx, regRecord);\n        sqlite3ReleaseTempReg(pParse, regRecord);\n        sqlite3ReleaseTempRange(pParse, regBase, nCol);\n        sqlite3WhereEnd(pWInfo);\n        sAggInfo.sortingIdxPTab = sortPTab = pParse->nTab++;\n        sortOut = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp3(v, OP_OpenPseudo, sortPTab, sortOut, nCol);\n        sqlite3VdbeAddOp2(v, OP_SorterSort, sAggInfo.sortingIdx, addrEnd);\n        VdbeComment((v, \"GROUP BY sort\")); VdbeCoverage(v);\n        sAggInfo.useSortingIdx = 1;\n      }\n\n      /* If the index or temporary table used by the GROUP BY sort\n      ** will naturally deliver rows in the order required by the ORDER BY\n      ** clause, cancel the ephemeral table open coded earlier.\n      **\n      ** This is an optimization - the correct answer should result regardless.\n      ** Use the SQLITE_GroupByOrder flag with SQLITE_TESTCTRL_OPTIMIZER to \n      ** disable this optimization for testing purposes.  */\n      if( orderByGrp && OptimizationEnabled(db, SQLITE_GroupByOrder) \n       && (groupBySort || sqlite3WhereIsSorted(pWInfo))\n      ){\n        sSort.pOrderBy = 0;\n        sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);\n      }\n\n      /* Evaluate the current GROUP BY terms and store in b0, b1, b2...\n      ** (b0 is memory location iBMem+0, b1 is iBMem+1, and so forth)\n      ** Then compare the current GROUP BY terms against the GROUP BY terms\n      ** from the previous row currently stored in a0, a1, a2...\n      */\n      addrTopOfLoop = sqlite3VdbeCurrentAddr(v);\n      if( groupBySort ){\n        sqlite3VdbeAddOp3(v, OP_SorterData, sAggInfo.sortingIdx,\n                          sortOut, sortPTab);\n      }\n      for(j=0; j<pGroupBy->nExpr; j++){\n        if( groupBySort ){\n          sqlite3VdbeAddOp3(v, OP_Column, sortPTab, j, iBMem+j);\n        }else{\n          sAggInfo.directMode = 1;\n          sqlite3ExprCode(pParse, pGroupBy->a[j].pExpr, iBMem+j);\n        }\n      }\n      sqlite3VdbeAddOp4(v, OP_Compare, iAMem, iBMem, pGroupBy->nExpr,\n                          (char*)sqlite3KeyInfoRef(pKeyInfo), P4_KEYINFO);\n      addr1 = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp3(v, OP_Jump, addr1+1, 0, addr1+1); VdbeCoverage(v);\n\n      /* Generate code that runs whenever the GROUP BY changes.\n      ** Changes in the GROUP BY are detected by the previous code\n      ** block.  If there were no changes, this block is skipped.\n      **\n      ** This code copies current group by terms in b0,b1,b2,...\n      ** over to a0,a1,a2.  It then calls the output subroutine\n      ** and resets the aggregate accumulator registers in preparation\n      ** for the next GROUP BY batch.\n      */\n      sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr);\n      sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);\n      VdbeComment((v, \"output one row\"));\n      sqlite3VdbeAddOp2(v, OP_IfPos, iAbortFlag, addrEnd); VdbeCoverage(v);\n      VdbeComment((v, \"check abort flag\"));\n      sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);\n      VdbeComment((v, \"reset accumulator\"));\n\n      /* Update the aggregate accumulators based on the content of\n      ** the current row\n      */\n      sqlite3VdbeJumpHere(v, addr1);\n      updateAccumulator(pParse, iUseFlag, &sAggInfo);\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, iUseFlag);\n      VdbeComment((v, \"indicate data in accumulator\"));\n\n      /* End of the loop\n      */\n      if( groupBySort ){\n        sqlite3VdbeAddOp2(v, OP_SorterNext, sAggInfo.sortingIdx, addrTopOfLoop);\n        VdbeCoverage(v);\n      }else{\n        sqlite3WhereEnd(pWInfo);\n        sqlite3VdbeChangeToNoop(v, addrSortingIdx);\n      }\n\n      /* Output the final row of result\n      */\n      sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);\n      VdbeComment((v, \"output final row\"));\n\n      /* Jump over the subroutines\n      */\n      sqlite3VdbeGoto(v, addrEnd);\n\n      /* Generate a subroutine that outputs a single row of the result\n      ** set.  This subroutine first looks at the iUseFlag.  If iUseFlag\n      ** is less than or equal to zero, the subroutine is a no-op.  If\n      ** the processing calls for the query to abort, this subroutine\n      ** increments the iAbortFlag memory location before returning in\n      ** order to signal the caller to abort.\n      */\n      addrSetAbort = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, iAbortFlag);\n      VdbeComment((v, \"set abort flag\"));\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      sqlite3VdbeResolveLabel(v, addrOutputRow);\n      addrOutputRow = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp2(v, OP_IfPos, iUseFlag, addrOutputRow+2);\n      VdbeCoverage(v);\n      VdbeComment((v, \"Groupby result generator entry point\"));\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      finalizeAggFunctions(pParse, &sAggInfo);\n      sqlite3ExprIfFalse(pParse, pHaving, addrOutputRow+1, SQLITE_JUMPIFNULL);\n      selectInnerLoop(pParse, p, -1, &sSort,\n                      &sDistinct, pDest,\n                      addrOutputRow+1, addrSetAbort);\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      VdbeComment((v, \"end groupby result generator\"));\n\n      /* Generate a subroutine that will reset the group-by accumulator\n      */\n      sqlite3VdbeResolveLabel(v, addrReset);\n      resetAccumulator(pParse, &sAggInfo);\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, iUseFlag);\n      VdbeComment((v, \"indicate accumulator empty\"));\n      sqlite3VdbeAddOp1(v, OP_Return, regReset);\n     \n    } /* endif pGroupBy.  Begin aggregate queries without GROUP BY: */\n    else {\n#ifndef SQLITE_OMIT_BTREECOUNT\n      Table *pTab;\n      if( (pTab = isSimpleCount(p, &sAggInfo))!=0 ){\n        /* If isSimpleCount() returns a pointer to a Table structure, then\n        ** the SQL statement is of the form:\n        **\n        **   SELECT count(*) FROM <tbl>\n        **\n        ** where the Table structure returned represents table <tbl>.\n        **\n        ** This statement is so common that it is optimized specially. The\n        ** OP_Count instruction is executed either on the intkey table that\n        ** contains the data for table <tbl> or on one of its indexes. It\n        ** is better to execute the op on an index, as indexes are almost\n        ** always spread across less pages than their corresponding tables.\n        */\n        const int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n        const int iCsr = pParse->nTab++;     /* Cursor to scan b-tree */\n        Index *pIdx;                         /* Iterator variable */\n        KeyInfo *pKeyInfo = 0;               /* Keyinfo for scanned index */\n        Index *pBest = 0;                    /* Best index found so far */\n        int iRoot = pTab->tnum;              /* Root page of scanned b-tree */\n\n        sqlite3CodeVerifySchema(pParse, iDb);\n        sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n\n        /* Search for the index that has the lowest scan cost.\n        **\n        ** (2011-04-15) Do not do a full scan of an unordered index.\n        **\n        ** (2013-10-03) Do not count the entries in a partial index.\n        **\n        ** In practice the KeyInfo structure will not be used. It is only \n        ** passed to keep OP_OpenRead happy.\n        */\n        if( !HasRowid(pTab) ) pBest = sqlite3PrimaryKeyIndex(pTab);\n        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n          if( pIdx->bUnordered==0\n           && pIdx->szIdxRow<pTab->szTabRow\n           && pIdx->pPartIdxWhere==0\n           && (!pBest || pIdx->szIdxRow<pBest->szIdxRow)\n          ){\n            pBest = pIdx;\n          }\n        }\n        if( pBest ){\n          iRoot = pBest->tnum;\n          pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pBest);\n        }\n\n        /* Open a read-only cursor, execute the OP_Count, close the cursor. */\n        sqlite3VdbeAddOp4Int(v, OP_OpenRead, iCsr, iRoot, iDb, 1);\n        if( pKeyInfo ){\n          sqlite3VdbeChangeP4(v, -1, (char *)pKeyInfo, P4_KEYINFO);\n        }\n        sqlite3VdbeAddOp2(v, OP_Count, iCsr, sAggInfo.aFunc[0].iMem);\n        sqlite3VdbeAddOp1(v, OP_Close, iCsr);\n        explainSimpleCount(pParse, pTab, pBest);\n      }else\n#endif /* SQLITE_OMIT_BTREECOUNT */\n      {\n        int regAcc = 0;           /* \"populate accumulators\" flag */\n\n        /* If there are accumulator registers but no min() or max() functions\n        ** without FILTER clauses, allocate register regAcc. Register regAcc\n        ** will contain 0 the first time the inner loop runs, and 1 thereafter.\n        ** The code generated by updateAccumulator() uses this to ensure\n        ** that the accumulator registers are (a) updated only once if\n        ** there are no min() or max functions or (b) always updated for the\n        ** first row visited by the aggregate, so that they are updated at\n        ** least once even if the FILTER clause means the min() or max() \n        ** function visits zero rows.  */\n        if( sAggInfo.nAccumulator ){\n          for(i=0; i<sAggInfo.nFunc; i++){\n            if( ExprHasProperty(sAggInfo.aFunc[i].pExpr, EP_WinFunc) ) continue;\n            if( sAggInfo.aFunc[i].pFunc->funcFlags&SQLITE_FUNC_NEEDCOLL ) break;\n          }\n          if( i==sAggInfo.nFunc ){\n            regAcc = ++pParse->nMem;\n            sqlite3VdbeAddOp2(v, OP_Integer, 0, regAcc);\n          }\n        }\n\n        /* This case runs if the aggregate has no GROUP BY clause.  The\n        ** processing is much simpler since there is only a single row\n        ** of output.\n        */\n        assert( p->pGroupBy==0 );\n        resetAccumulator(pParse, &sAggInfo);\n\n        /* If this query is a candidate for the min/max optimization, then\n        ** minMaxFlag will have been previously set to either\n        ** WHERE_ORDERBY_MIN or WHERE_ORDERBY_MAX and pMinMaxOrderBy will\n        ** be an appropriate ORDER BY expression for the optimization.\n        */\n        assert( minMaxFlag==WHERE_ORDERBY_NORMAL || pMinMaxOrderBy!=0 );\n        assert( pMinMaxOrderBy==0 || pMinMaxOrderBy->nExpr==1 );\n\n        SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n        pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMaxOrderBy,\n                                   0, minMaxFlag, 0);\n        if( pWInfo==0 ){\n          goto select_end;\n        }\n        updateAccumulator(pParse, regAcc, &sAggInfo);\n        if( regAcc ) sqlite3VdbeAddOp2(v, OP_Integer, 1, regAcc);\n        if( sqlite3WhereIsOrdered(pWInfo)>0 ){\n          sqlite3VdbeGoto(v, sqlite3WhereBreakLabel(pWInfo));\n          VdbeComment((v, \"%s() by index\",\n                (minMaxFlag==WHERE_ORDERBY_MIN?\"min\":\"max\")));\n        }\n        sqlite3WhereEnd(pWInfo);\n        finalizeAggFunctions(pParse, &sAggInfo);\n      }\n\n      sSort.pOrderBy = 0;\n      sqlite3ExprIfFalse(pParse, pHaving, addrEnd, SQLITE_JUMPIFNULL);\n      selectInnerLoop(pParse, p, -1, 0, 0, \n                      pDest, addrEnd, addrEnd);\n    }\n    sqlite3VdbeResolveLabel(v, addrEnd);\n    \n  } /* endif aggregate query */\n\n  if( sDistinct.eTnctType==WHERE_DISTINCT_UNORDERED ){\n    explainTempTable(pParse, \"DISTINCT\");\n  }\n\n  /* If there is an ORDER BY clause, then we need to sort the results\n  ** and send them to the callback one by one.\n  */\n  if( sSort.pOrderBy ){\n    explainTempTable(pParse,\n                     sSort.nOBSat>0 ? \"RIGHT PART OF ORDER BY\":\"ORDER BY\");\n    assert( p->pEList==pEList );\n    generateSortTail(pParse, p, &sSort, pEList->nExpr, pDest);\n  }\n\n  /* Jump here to skip this query\n  */\n  sqlite3VdbeResolveLabel(v, iEnd);\n\n  /* The SELECT has been coded. If there is an error in the Parse structure,\n  ** set the return code to 1. Otherwise 0. */\n  rc = (pParse->nErr>0);\n\n  /* Control jumps to here if an error is encountered above, or upon\n  ** successful coding of the SELECT.\n  */\nselect_end:\n  sqlite3ExprListDelete(db, pMinMaxOrderBy);\n  sqlite3DbFree(db, sAggInfo.aCol);\n  sqlite3DbFree(db, sAggInfo.aFunc);\n#if SELECTTRACE_ENABLED\n  SELECTTRACE(0x1,pParse,p,(\"end processing\\n\"));\n  if( (sqlite3SelectTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n  ExplainQueryPlanPop(pParse);\n  return rc;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146063,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "ssize_t sys_recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlen)\n{\n\tssize_t ret;\n\n\tdo {\n\t\tret = recvfrom(s, buf, len, flags, from, fromlen);\n#if defined(EWOULDBLOCK)\n\t} while (ret == -1 && (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK));\n#else\n\t} while (ret == -1 && (errno == EINTR || errno == EAGAIN));",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146116,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "ssize_t sys_send(int s, const void *msg, size_t len, int flags)\n{\n\tssize_t ret;\n\n\tdo {\n\t\tret = send(s, msg, len, flags);\n#if defined(EWOULDBLOCK)\n\t} while (ret == -1 && (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK));\n#else\n\t} while (ret == -1 && (errno == EINTR || errno == EAGAIN));",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146117,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "PHPAPI php_url *php_url_parse_ex(char const *str, size_t length)\n{\n\tchar port_buf[6];\n\tphp_url *ret = ecalloc(1, sizeof(php_url));\n\tchar const *s, *e, *p, *pp, *ue;\n\n\ts = str;\n\tue = s + length;\n\n\t/* parse scheme */\n\tif ((e = memchr(s, ':', length)) && e != s) {\n\t\t/* validate scheme */\n\t\tp = s;\n\t\twhile (p < e) {\n\t\t\t/* scheme = 1*[ lowalpha | digit | \"+\" | \"-\" | \".\" ] */\n\t\t\tif (!isalpha(*p) && !isdigit(*p) && *p != '+' && *p != '.' && *p != '-') {\n\t\t\t\tif (e + 1 < ue && e < s + strcspn(s, \"?#\")) {\n\t\t\t\t\tgoto parse_port;\n\t\t\t\t} else if (s + 1 < ue && *s == '/' && *(s + 1) == '/') { /* relative-scheme URL */\n\t\t\t\t\ts += 2;\n\t\t\t\t\te = 0;\n\t\t\t\t\tgoto parse_host;\n\t\t\t\t} else {\n\t\t\t\t\tgoto just_path;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\n\t\tif (e + 1 == ue) { /* only scheme is available */\n\t\t\tret->scheme = estrndup(s, (e - s));\n\t\t\tphp_replace_controlchars_ex(ret->scheme, (e - s));\n\t\t\treturn ret;\n\t\t}\n\n\t\t/*\n\t\t * certain schemas like mailto: and zlib: may not have any / after them\n\t\t * this check ensures we support those.\n\t\t */\n\t\tif (*(e+1) != '/') {\n\t\t\t/* check if the data we get is a port this allows us to\n\t\t\t * correctly parse things like a.com:80\n\t\t\t */\n\t\t\tp = e + 1;\n\t\t\twhile (p < ue && isdigit(*p)) {\n\t\t\t\tp++;\n\t\t\t}\n\n\t\t\tif ((p == ue || *p == '/') && (p - e) < 7) {\n\t\t\t\tgoto parse_port;\n\t\t\t}\n\n\t\t\tret->scheme = estrndup(s, (e-s));\n\t\t\tphp_replace_controlchars_ex(ret->scheme, (e - s));\n\n\t\t\ts = e + 1;\n\t\t\tgoto just_path;\n\t\t} else {\n\t\t\tret->scheme = estrndup(s, (e-s));\n\t\t\tphp_replace_controlchars_ex(ret->scheme, (e - s));\n\n\t\t\tif (e + 2 < ue && *(e + 2) == '/') {\n\t\t\t\ts = e + 3;\n\t\t\t\tif (!strncasecmp(\"file\", ret->scheme, sizeof(\"file\"))) {\n\t\t\t\t\tif (e + 3 < ue && *(e + 3) == '/') {\n\t\t\t\t\t\t/* support windows drive letters as in:\n\t\t\t\t\t\t   file:///c:/somedir/file.txt\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tif (e + 5 < ue && *(e + 5) == ':') {\n\t\t\t\t\t\t\ts = e + 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto just_path;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ts = e + 1;\n\t\t\t\tgoto just_path;\n\t\t\t}\n\t\t}\n\t} else if (e) { /* no scheme; starts with colon: look for port */\n\t\tparse_port:\n\t\tp = e + 1;\n\t\tpp = p;\n\n\t\twhile (pp < ue && pp - p < 6 && isdigit(*pp)) {\n\t\t\tpp++;\n\t\t}\n\n\t\tif (pp - p > 0 && pp - p < 6 && (pp == ue || *pp == '/')) {\n\t\t\tzend_long port;\n\t\t\tmemcpy(port_buf, p, (pp - p));\n\t\t\tport_buf[pp - p] = '\\0';\n\t\t\tport = ZEND_STRTOL(port_buf, NULL, 10);\n\t\t\tif (port > 0 && port <= 65535) {\n\t\t\t\tret->port = (unsigned short) port;\n\t\t\t\tif (s + 1 < ue && *s == '/' && *(s + 1) == '/') { /* relative-scheme URL */\n\t\t\t\t    s += 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ret->scheme) efree(ret->scheme);\n\t\t\t\tefree(ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else if (p == pp && pp == ue) {\n\t\t\tif (ret->scheme) efree(ret->scheme);\n\t\t\tefree(ret);\n\t\t\treturn NULL;\n\t\t} else if (s + 1 < ue && *s == '/' && *(s + 1) == '/') { /* relative-scheme URL */\n\t\t\ts += 2;\n\t\t} else {\n\t\t\tgoto just_path;\n\t\t}\n\t} else if (s + 1 < ue && *s == '/' && *(s + 1) == '/') { /* relative-scheme URL */\n\t\ts += 2;\n\t} else {\n\t\tgoto just_path;\n\t}\n\n\tparse_host:\n\t/* Binary-safe strcspn(s, \"/?#\") */\n\te = ue;\n\tif ((p = memchr(s, '/', e - s))) {\n\t\te = p;\n\t}\n\tif ((p = memchr(s, '?', e - s))) {\n\t\te = p;\n\t}\n\tif ((p = memchr(s, '#', e - s))) {\n\t\te = p;\n\t}\n\n\t/* check for login and password */\n\tif ((p = zend_memrchr(s, '@', (e-s)))) {\n\t\tif ((pp = memchr(s, ':', (p-s)))) {\n\t\t\tret->user = estrndup(s, (pp-s));\n\t\t\tphp_replace_controlchars_ex(ret->user, (pp - s));\n\n\t\t\tpp++;\n\t\t\tret->pass = estrndup(pp, (p-pp));\n\t\t\tphp_replace_controlchars_ex(ret->pass, (p-pp));\n\t\t} else {\n\t\t\tret->user = estrndup(s, (p-s));\n\t\t\tphp_replace_controlchars_ex(ret->user, (p-s));\n\t\t}\n\n\t\ts = p + 1;\n\t}\n\n\t/* check for port */\n\tif (s < ue && *s == '[' && *(e-1) == ']') {\n\t\t/* Short circuit portscan,\n\t\t   we're dealing with an\n\t\t   IPv6 embedded address */\n\t\tp = NULL;\n\t} else {\n\t\tp = zend_memrchr(s, ':', (e-s));\n\t}\n\n\tif (p) {\n\t\tif (!ret->port) {\n\t\t\tp++;\n\t\t\tif (e-p > 5) { /* port cannot be longer then 5 characters */\n\t\t\t\tif (ret->scheme) efree(ret->scheme);\n\t\t\t\tif (ret->user) efree(ret->user);\n\t\t\t\tif (ret->pass) efree(ret->pass);\n\t\t\t\tefree(ret);\n\t\t\t\treturn NULL;\n\t\t\t} else if (e - p > 0) {\n\t\t\t\tzend_long port;\n\t\t\t\tmemcpy(port_buf, p, (e - p));\n\t\t\t\tport_buf[e - p] = '\\0';\n\t\t\t\tport = ZEND_STRTOL(port_buf, NULL, 10);\n\t\t\t\tif (port > 0 && port <= 65535) {\n\t\t\t\t\tret->port = (unsigned short)port;\n\t\t\t\t} else {\n\t\t\t\t\tif (ret->scheme) efree(ret->scheme);\n\t\t\t\t\tif (ret->user) efree(ret->user);\n\t\t\t\t\tif (ret->pass) efree(ret->pass);\n\t\t\t\t\tefree(ret);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp--;\n\t\t}\n\t} else {\n\t\tp = e;\n\t}\n\n\t/* check if we have a valid host, if we don't reject the string as url */\n\tif ((p-s) < 1) {\n\t\tif (ret->scheme) efree(ret->scheme);\n\t\tif (ret->user) efree(ret->user);\n\t\tif (ret->pass) efree(ret->pass);\n\t\tefree(ret);\n\t\treturn NULL;\n\t}\n\n\tret->host = estrndup(s, (p-s));\n\tphp_replace_controlchars_ex(ret->host, (p - s));\n\n\tif (e == ue) {\n\t\treturn ret;\n\t}\n\n\ts = e;\n\n\tjust_path:\n\n\te = ue;\n\tp = memchr(s, '#', (e - s));\n\tif (p) {\n\t\tp++;\n\t\tif (p < e) {\n\t\t\tret->fragment = estrndup(p, (e - p));\n\t\t\tphp_replace_controlchars_ex(ret->fragment, (e - p));\n\t\t}\n\t\te = p-1;\n\t}\n\n\tp = memchr(s, '?', (e - s));\n\tif (p) {\n\t\tp++;\n\t\tif (p < e) {\n\t\t\tret->query = estrndup(p, (e - p));\n\t\t\tphp_replace_controlchars_ex(ret->query, (e - p));\n\t\t}\n\t\te = p-1;\n\t}\n\n\tif (s < e || s == ue) {\n\t\tret->path = estrndup(s, (e - s));\n\t\tphp_replace_controlchars_ex(ret->path, (e - s));\n\t}\n\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146140,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "PHPAPI php_url *php_url_parse_ex(char const *str, size_t length)\n{\n\tchar port_buf[6];\n\tphp_url *ret = ecalloc(1, sizeof(php_url));\n\tchar const *s, *e, *p, *pp, *ue;\n\n\ts = str;\n\tue = s + length;\n\n\t/* parse scheme */\n\tif ((e = memchr(s, ':', length)) && e != s) {\n\t\t/* validate scheme */\n\t\tp = s;\n\t\twhile (p < e) {\n\t\t\t/* scheme = 1*[ lowalpha | digit | \"+\" | \"-\" | \".\" ] */\n\t\t\tif (!isalpha(*p) && !isdigit(*p) && *p != '+' && *p != '.' && *p != '-') {\n\t\t\t\tif (e + 1 < ue && e < s + strcspn(s, \"?#\")) {\n\t\t\t\t\tgoto parse_port;\n\t\t\t\t} else if (s + 1 < ue && *s == '/' && *(s + 1) == '/') { /* relative-scheme URL */\n\t\t\t\t\ts += 2;\n\t\t\t\t\te = 0;\n\t\t\t\t\tgoto parse_host;\n\t\t\t\t} else {\n\t\t\t\t\tgoto just_path;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\n\t\tif (e + 1 == ue) { /* only scheme is available */\n\t\t\tret->scheme = estrndup(s, (e - s));\n\t\t\tphp_replace_controlchars_ex(ret->scheme, (e - s));\n\t\t\treturn ret;\n\t\t}\n\n\t\t/*\n\t\t * certain schemas like mailto: and zlib: may not have any / after them\n\t\t * this check ensures we support those.\n\t\t */\n\t\tif (*(e+1) != '/') {\n\t\t\t/* check if the data we get is a port this allows us to\n\t\t\t * correctly parse things like a.com:80\n\t\t\t */\n\t\t\tp = e + 1;\n\t\t\twhile (p < ue && isdigit(*p)) {\n\t\t\t\tp++;\n\t\t\t}\n\n\t\t\tif ((p == ue || *p == '/') && (p - e) < 7) {\n\t\t\t\tgoto parse_port;\n\t\t\t}\n\n\t\t\tret->scheme = estrndup(s, (e-s));\n\t\t\tphp_replace_controlchars_ex(ret->scheme, (e - s));\n\n\t\t\ts = e + 1;\n\t\t\tgoto just_path;\n\t\t} else {\n\t\t\tret->scheme = estrndup(s, (e-s));\n\t\t\tphp_replace_controlchars_ex(ret->scheme, (e - s));\n\n\t\t\tif (e + 2 < ue && *(e + 2) == '/') {\n\t\t\t\ts = e + 3;\n\t\t\t\tif (!strncasecmp(\"file\", ret->scheme, sizeof(\"file\"))) {\n\t\t\t\t\tif (e + 3 < ue && *(e + 3) == '/') {\n\t\t\t\t\t\t/* support windows drive letters as in:\n\t\t\t\t\t\t   file:///c:/somedir/file.txt\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tif (e + 5 < ue && *(e + 5) == ':') {\n\t\t\t\t\t\t\ts = e + 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto just_path;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ts = e + 1;\n\t\t\t\tgoto just_path;\n\t\t\t}\n\t\t}\n\t} else if (e) { /* no scheme; starts with colon: look for port */\n\t\tparse_port:\n\t\tp = e + 1;\n\t\tpp = p;\n\n\t\twhile (pp < ue && pp - p < 6 && isdigit(*pp)) {\n\t\t\tpp++;\n\t\t}\n\n\t\tif (pp - p > 0 && pp - p < 6 && (pp == ue || *pp == '/')) {\n\t\t\tzend_long port;\n\t\t\tmemcpy(port_buf, p, (pp - p));\n\t\t\tport_buf[pp - p] = '\\0';\n\t\t\tport = ZEND_STRTOL(port_buf, NULL, 10);\n\t\t\tif (port > 0 && port <= 65535) {\n\t\t\t\tret->port = (unsigned short) port;\n\t\t\t\tif (s + 1 < ue && *s == '/' && *(s + 1) == '/') { /* relative-scheme URL */\n\t\t\t\t    s += 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ret->scheme) efree(ret->scheme);\n\t\t\t\tefree(ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else if (p == pp && pp == ue) {\n\t\t\tif (ret->scheme) efree(ret->scheme);\n\t\t\tefree(ret);\n\t\t\treturn NULL;\n\t\t} else if (s + 1 < ue && *s == '/' && *(s + 1) == '/') { /* relative-scheme URL */\n\t\t\ts += 2;\n\t\t} else {\n\t\t\tgoto just_path;\n\t\t}\n\t} else if (s + 1 < ue && *s == '/' && *(s + 1) == '/') { /* relative-scheme URL */\n\t\ts += 2;\n\t} else {\n\t\tgoto just_path;\n\t}\n\n\tparse_host:\n\t/* Binary-safe strcspn(s, \"/?#\") */\n\te = ue;\n\tif ((p = memchr(s, '/', e - s))) {\n\t\te = p;\n\t}\n\tif ((p = memchr(s, '?', e - s))) {\n\t\te = p;\n\t}\n\tif ((p = memchr(s, '#', e - s))) {\n\t\te = p;\n\t}\n\n\t/* check for login and password */\n\tif ((p = zend_memrchr(s, '@', (e-s)))) {\n\t\tif ((pp = memchr(s, ':', (p-s)))) {\n\t\t\tret->user = estrndup(s, (pp-s));\n\t\t\tphp_replace_controlchars_ex(ret->user, (pp - s));\n\n\t\t\tpp++;\n\t\t\tret->pass = estrndup(pp, (p-pp));\n\t\t\tphp_replace_controlchars_ex(ret->pass, (p-pp));\n\t\t} else {\n\t\t\tif (!is_userinfo_valid(s, p-s)) {\n\t\t\t\tgoto check_port;\n\t\t\t}\n\t\t\tret->user = estrndup(s, (p-s));\n\t\t\tphp_replace_controlchars_ex(ret->user, (p-s));\n\n\t\t}\n\n\t\ts = p + 1;\n\t}\n\ncheck_port:\n\t/* check for port */\n\tif (s < ue && *s == '[' && *(e-1) == ']') {\n\t\t/* Short circuit portscan,\n\t\t   we're dealing with an\n\t\t   IPv6 embedded address */\n\t\tp = NULL;\n\t} else {\n\t\tp = zend_memrchr(s, ':', (e-s));\n\t}\n\n\tif (p) {\n\t\tif (!ret->port) {\n\t\t\tp++;\n\t\t\tif (e-p > 5) { /* port cannot be longer then 5 characters */\n\t\t\t\tif (ret->scheme) efree(ret->scheme);\n\t\t\t\tif (ret->user) efree(ret->user);\n\t\t\t\tif (ret->pass) efree(ret->pass);\n\t\t\t\tefree(ret);\n\t\t\t\treturn NULL;\n\t\t\t} else if (e - p > 0) {\n\t\t\t\tzend_long port;\n\t\t\t\tmemcpy(port_buf, p, (e - p));\n\t\t\t\tport_buf[e - p] = '\\0';\n\t\t\t\tport = ZEND_STRTOL(port_buf, NULL, 10);\n\t\t\t\tif (port > 0 && port <= 65535) {\n\t\t\t\t\tret->port = (unsigned short)port;\n\t\t\t\t} else {\n\t\t\t\t\tif (ret->scheme) efree(ret->scheme);\n\t\t\t\t\tif (ret->user) efree(ret->user);\n\t\t\t\t\tif (ret->pass) efree(ret->pass);\n\t\t\t\t\tefree(ret);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp--;\n\t\t}\n\t} else {\n\t\tp = e;\n\t}\n\n\t/* check if we have a valid host, if we don't reject the string as url */\n\tif ((p-s) < 1) {\n\t\tif (ret->scheme) efree(ret->scheme);\n\t\tif (ret->user) efree(ret->user);\n\t\tif (ret->pass) efree(ret->pass);\n\t\tefree(ret);\n\t\treturn NULL;\n\t}\n\n\tret->host = estrndup(s, (p-s));\n\tphp_replace_controlchars_ex(ret->host, (p - s));\n\n\tif (e == ue) {\n\t\treturn ret;\n\t}\n\n\ts = e;\n\n\tjust_path:\n\n\te = ue;\n\tp = memchr(s, '#', (e - s));\n\tif (p) {\n\t\tp++;\n\t\tif (p < e) {\n\t\t\tret->fragment = estrndup(p, (e - p));\n\t\t\tphp_replace_controlchars_ex(ret->fragment, (e - p));\n\t\t}\n\t\te = p-1;\n\t}\n\n\tp = memchr(s, '?', (e - s));\n\tif (p) {\n\t\tp++;\n\t\tif (p < e) {\n\t\t\tret->query = estrndup(p, (e - p));\n\t\t\tphp_replace_controlchars_ex(ret->query, (e - p));\n\t\t}\n\t\te = p-1;\n\t}\n\n\tif (s < e || s == ue) {\n\t\tret->path = estrndup(s, (e - s));\n\t\tphp_replace_controlchars_ex(ret->path, (e - s));\n\t}\n\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146141,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void IRC_Analyzer::DeliverStream(int length, const u_char* line, bool orig)\n\t{\n\ttcp::TCP_ApplicationAnalyzer::DeliverStream(length, line, orig);\n\n\tif ( starttls )\n\t\t{\n\t\tForwardStream(length, line, orig);\n\t\treturn;\n\t\t}\n\n\t// check line size\n\tif ( length > 512 )\n\t\t{\n\t\tWeird(\"irc_line_size_exceeded\");\n\t\treturn;\n\t\t}\n\n\tstring myline = string((const char*) line, length);\n\tSkipLeadingWhitespace(myline);\n\n\tif ( myline.length() < 3 )\n\t\t{\n\t\tWeird(\"irc_line_too_short\");\n\t\treturn;\n\t\t}\n\n\t// Check for prefix.\n\tstring prefix = \"\";\n\tif ( myline[0] == ':' )\n\t\t{ // find end of prefix and extract it\n\t\tauto pos = myline.find(' ');\n\t\tif ( pos == string::npos )\n\t\t\t{\n\t\t\tWeird(\"irc_invalid_line\");\n\t\t\treturn;\n\t\t\t}\n\n\t\tprefix = myline.substr(1, pos - 1);\n\t\tmyline = myline.substr(pos + 1);  // remove prefix from line\n\t\tSkipLeadingWhitespace(myline);\n\t\t}\n\n\tif ( orig )\n\t\tProtocolConfirmation();\n\n\tint code = 0;\n\tstring command = \"\";\n\n\t// Check if line is long enough to include status code or command.\n\t// (shortest command with optional params is \"WHO\")\n\tif ( myline.length() < 3 )\n\t\t{\n\t\tWeird(\"irc_invalid_line\");\n\t\tProtocolViolation(\"line too short\");\n\t\treturn;\n\t\t}\n\n\t// Check if this is a server reply.\n\tif ( isdigit(myline[0]) )\n\t\t{\n\t\tif ( isdigit(myline[1]) && isdigit(myline[2]) &&\n\t\t     myline[3] == ' ')\n\t\t\t{\n\t\t\tcode = (myline[0] - '0') * 100 +\n\t\t\t\t(myline[1] - '0') * 10 + (myline[2] - '0');\n\t\t\tmyline = myline.substr(4);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tWeird(\"irc_invalid_reply_number\");\n\t\t\tProtocolViolation(\"invalid reply number\");\n\t\t\treturn;\n\t\t\t}\n\t\t}\n\telse\n\t\t{ // get command\n\t\tauto pos = myline.find(' ');\n\t\t// Not all commands require parameters\n\t\tif ( pos == string::npos )\n\t\t\tpos = myline.length();\n\n\t\tcommand = myline.substr(0, pos);\n\t\tfor ( unsigned int i = 0; i < command.size(); ++i )\n\t\t\tcommand[i] = toupper(command[i]);\n\n\t\t// Adjust for the no-parameter case\n\t\tif ( pos == myline.length() )\n\t\t\tpos--;\n\n\t\tmyline = myline.substr(pos + 1);\n\t\tSkipLeadingWhitespace(myline);\n\t\t}\n\n\t// Extract parameters.\n\tstring params = myline;\n\n\t// special case\n\tif ( command == \"STARTTLS\" )\n\t\treturn;\n\n\t// Check for Server2Server - connections with ZIP enabled.\n\tif ( orig && orig_status == WAIT_FOR_REGISTRATION )\n\t\t{\n\t\tif ( command == \"PASS\" )\n\t\t\t{\n\t\t\tvector<string> p = SplitWords(params,' ');\n\t\t\tif ( p.size() > 3 &&\n\t\t\t     (p[3].find('Z')<=p[3].size() ||\n\t\t\t      p[3].find('z')<=p[3].size()) )\n\t\t\t\torig_zip_status = ACCEPT_ZIP;\n\t\t\telse\n\t\t\t        orig_zip_status = NO_ZIP;\n\t\t\t}\n\n\t\t// We do not check if SERVER command is successful, since\n\t\t// the connection will be terminated by the server if\n\t\t// authentication fails.\n\t\t//\n\t\t// (### This seems not quite prudent to me - VP)\n\t\tif ( command == \"SERVER\" && prefix == \"\")\n\t\t\t{\n\t\t\torig_status = REGISTERED;\n\t\t\t}\n\t\t}\n\n\tif ( ! orig && resp_status == WAIT_FOR_REGISTRATION )\n\t\t{\n\t\tif ( command == \"PASS\" )\n\t\t\t{\n\t\t\tvector<string> p = SplitWords(params,' ');\n\t\t\tif ( p.size() > 3 &&\n\t\t\t     (p[3].find('Z')<=p[3].size() ||\n\t\t\t      p[3].find('z')<=p[3].size()) )\n\t\t\t        resp_zip_status = ACCEPT_ZIP;\n\t\t\telse\n\t\t\t        resp_zip_status = NO_ZIP;\n\n\t\t\t}\n\n\t\t// Again, don't bother checking whether SERVER command\n\t\t// is successful.\n\t\tif ( command == \"SERVER\" && prefix == \"\")\n\t\t\tresp_status = REGISTERED;\n\t\t}\n\n\t// Analyze server reply messages.\n\tif ( code > 0 )\n\t\t{\n\t\tswitch ( code ) {\n\t\t/*\n\t\tcase 1: // RPL_WELCOME\n\t\tcase 2: // RPL_YOURHOST\n\t\tcase 3: // RPL_CREATED\n\t\tcase 4: // RPL_MYINFO\n\t\tcase 5: // RPL_BOUNCE\n\t\tcase 252: // number of ops online\n\t\tcase 253: // number of unknown connections\n\t\tcase 265: // RPL_LOCALUSERS\n\t\tcase 312: // whois server reply\n\t\tcase 315: // end of who list\n\t\tcase 317: // whois idle reply\n\t\tcase 318: // end of whois list\n\t\tcase 366: // end of names list\n\t\tcase 372: // RPL_MOTD\n\t\tcase 375: // RPL_MOTDSTART\n\t\tcase 376: // RPL_ENDOFMOTD\n\t\tcase 331: // RPL_NOTOPIC\n\t\t\tbreak;\n\t\t*/\n\n\t\t// Count of users, services and servers in whole network.\n\t\tcase 251:\n\t\t\tif ( ! irc_network_info )\n\t\t\t\tbreak;\n\n\t\t\t{\n\t\t\tvector<string> parts = SplitWords(params, ' ');\n\t\t\tint users = 0;\n\t\t\tint services = 0;\n\t\t\tint servers = 0;\n\n\t\t\tfor ( unsigned int i = 1; i < parts.size(); ++i )\n\t\t\t\t{\n\t\t\t\tif ( parts[i] == \"users\" )\n\t\t\t\t\tusers = atoi(parts[i-1].c_str());\n\t\t\t\telse if ( parts[i] == \"services\" )\n\t\t\t\t\tservices = atoi(parts[i-1].c_str());\n\t\t\t\telse if ( parts[i] == \"servers\" )\n\t\t\t\t\tservers = atoi(parts[i-1].c_str());\n\t\t\t\t// else ###\n\t\t\t\t}\n\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new Val(users, TYPE_INT));\n\t\t\tvl->append(new Val(services, TYPE_INT));\n\t\t\tvl->append(new Val(servers, TYPE_INT));\n\n\t\t\tConnectionEvent(irc_network_info, vl);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// List of users in a channel (names command).\n\t\tcase 353:\n\t\t\tif ( ! irc_names_info )\n\t\t\t\tbreak;\n\n\t\t\t{\n\t\t\tvector<string> parts = SplitWords(params, ' ');\n\n\t\t\t// Remove nick name.\n\t\t\tparts.erase(parts.begin());\n\t\t\tif ( parts.size() < 2 )\n\t\t\t\t{\n\t\t\t\tWeird(\"irc_invalid_names_line\");\n\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\tstring type = parts[0];\n\t\t\tstring channel = parts[1];\n\n\t\t\t// Remove type and channel.\n\t\t\tparts.erase(parts.begin());\n\t\t\tparts.erase(parts.begin());\n\n\t\t\tif ( parts.size() > 0 && parts[0][0] == ':' )\n\t\t\t\tparts[0] = parts[0].substr(1);\n\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(type.c_str()));\n\t\t\tvl->append(new StringVal(channel.c_str()));\n\n\t\t\tTableVal* set = new TableVal(string_set);\n\t\t\tfor ( unsigned int i = 0; i < parts.size(); ++i )\n\t\t\t\t{\n\t\t\t\tif ( parts[i][0] == '@' )\n\t\t\t\t\tparts[i] = parts[i].substr(1);\n\t\t\t\tVal* idx = new StringVal(parts[i].c_str());\n\t\t\t\tset->Assign(idx, 0);\n\t\t\t\tUnref(idx);\n\t\t\t\t}\n\t\t\tvl->append(set);\n\n\t\t\tConnectionEvent(irc_names_info, vl);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Count of users and services on this server.\n\t\tcase 255:\n\t\t\tif ( ! irc_server_info )\n\t\t\t\tbreak;\n\n\t\t\t{\n\t\t\tvector<string> parts = SplitWords(params, ' ');\n\t\t\tint users = 0;\n\t\t\tint services = 0;\n\t\t\tint servers = 0;\n\n\t\t\tfor ( unsigned int i = 1; i < parts.size(); ++i )\n\t\t\t\t{\n\t\t\t\tif ( parts[i] == \"users,\" )\n\t\t\t\t\tusers = atoi(parts[i-1].c_str());\n\t\t\t\telse if ( parts[i] == \"clients\" )\n\t\t\t\t\tusers = atoi(parts[i-1].c_str());\n\t\t\t\telse if ( parts[i] == \"services\" )\n\t\t\t\t\tservices = atoi(parts[i-1].c_str());\n\t\t\t\telse if ( parts[i] == \"servers\" )\n\t\t\t\t\tservers = atoi(parts[i-1].c_str());\n\t\t\t\t// else ###\n\t\t\t\t}\n\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new Val(users, TYPE_INT));\n\t\t\tvl->append(new Val(services, TYPE_INT));\n\t\t\tvl->append(new Val(servers, TYPE_INT));\n\n\t\t\tConnectionEvent(irc_server_info, vl);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Count of channels.\n\t\tcase 254:\n\t\t\tif ( ! irc_channel_info )\n\t\t\t\tbreak;\n\n\t\t\t{\n\t\t\tvector<string> parts = SplitWords(params, ' ');\n\t\t\tint channels = 0;\n\t\t\tfor ( unsigned int i = 1; i < parts.size(); ++i )\n\t\t\t\tif ( parts[i] == \":channels\" )\n\t\t\t\t\tchannels = atoi(parts[i - 1].c_str());\n\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new Val(channels, TYPE_INT));\n\n\t\t\tConnectionEvent(irc_channel_info, vl);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// RPL_GLOBALUSERS\n\t\tcase 266:\n\t\t\t{\n\t\t\t// FIXME: We should really streamline all this\n\t\t\t// parsing code ...\n\t\t\tif ( ! irc_global_users )\n\t\t\t\tbreak;\n\n\t\t\tconst char* prefix = params.c_str();\n\n\t\t\tconst char* eop = strchr(prefix, ' ');\n\t\t\tif ( ! eop )\n\t\t\t\t{\n\t\t\t\tWeird(\"invalid_irc_global_users_reply\");\n\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tconst char *msg = strchr(++eop, ':');\n\t\t\tif ( ! msg )\n\t\t\t\t{\n\t\t\t\tWeird(\"invalid_irc_global_users_reply\");\n\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(eop - prefix, prefix));\n\t\t\tvl->append(new StringVal(++msg));\n\t\t\tConnectionEvent(irc_global_users, vl);\n\t\t\tbreak;\n\t\t\t}\n\n\t\t// WHOIS user reply line.\n\t\tcase 311:\n\t\t\tif ( ! irc_whois_user_line )\n\t\t\t\tbreak;\n\n\t\t\t{\n\t\t\tvector<string> parts = SplitWords(params, ' ');\n\n\t\t\tif ( parts.size() > 1 )\n\t\t\t\tparts.erase(parts.begin());\n\t\t\tif ( parts.size() < 5 )\n\t\t\t\t{\n\t\t\t\tWeird(\"irc_invalid_whois_user_line\");\n\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(parts[0].c_str()));\n\t\t\tvl->append(new StringVal(parts[1].c_str()));\n\t\t\tvl->append(new StringVal(parts[2].c_str()));\n\n\t\t\tparts.erase(parts.begin(), parts.begin() + 4);\n\n\t\t\tstring real_name = parts[0];\n\t\t\tfor ( unsigned int i = 1; i < parts.size(); ++i )\n\t\t\t\treal_name = real_name + \" \" + parts[i];\n\n\t\t\tif ( real_name[0] == ':' )\n\t\t\t\treal_name = real_name.substr(1);\n\n\t\t\tvl->append(new StringVal(real_name.c_str()));\n\n\t\t\tConnectionEvent(irc_whois_user_line, vl);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// WHOIS operator reply line.\n\t\tcase 313:\n\t\t\tif ( ! irc_whois_operator_line )\n\t\t\t\tbreak;\n\n\t\t\t{\n\t\t\tvector<string> parts = SplitWords(params, ' ');\n\n\t\t\tif ( parts.size() > 1 )\n\t\t\t\tparts.erase(parts.begin());\n\n\t\t\tif ( parts.size() < 2 )\n\t\t\t\t{\n\t\t\t\tWeird(\"irc_invalid_whois_operator_line\");\n\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(parts[0].c_str()));\n\n\t\t\tConnectionEvent(irc_whois_operator_line, vl);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// WHOIS channel reply.\n\t\tcase 319:\n\t\t\tif ( ! irc_whois_channel_line )\n\t\t\t\tbreak;\n\n\t\t\t{\n\t\t\tvector<string> parts = SplitWords(params, ' ');\n\n\t\t\t// Remove nick name.\n\t\t\tparts.erase(parts.begin());\n\t\t\tif ( parts.size() < 2 )\n\t\t\t\t{\n\t\t\t\tWeird(\"irc_invalid_whois_channel_line\");\n\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\tstring nick = parts[0];\n\t\t\tparts.erase(parts.begin());\n\n\t\t\tif ( parts.size() > 0 && parts[0][0] == ':' )\n\t\t\t\tparts[0] = parts[0].substr(1);\n\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(nick.c_str()));\n\t\t\tTableVal* set = new TableVal(string_set);\n\t\t\tfor ( unsigned int i = 0; i < parts.size(); ++i )\n\t\t\t\t{\n\t\t\t\tVal* idx = new StringVal(parts[i].c_str());\n\t\t\t\tset->Assign(idx, 0);\n\t\t\t\tUnref(idx);\n\t\t\t\t}\n\n\t\t\tvl->append(set);\n\n\t\t\tConnectionEvent(irc_whois_channel_line, vl);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// RPL_TOPIC reply.\n\t\tcase 332:\n\t\t\t{\n\t\t\tif ( ! irc_channel_topic )\n\t\t\t\tbreak;\n\n\t\t\tvector<string> parts = SplitWords(params, ' ');\n\t\t\tif ( parts.size() < 4 )\n\t\t\t\t{\n\t\t\t\tWeird(\"irc_invalid_topic_reply\");\n\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\tunsigned int pos = params.find(':');\n\t\t\tif ( pos < params.size() )\n\t\t\t\t{\n\t\t\t\tstring topic = params.substr(pos + 1);\n\t\t\t\tval_list* vl = new val_list;\n\n\t\t\t\tvl->append(BuildConnVal());\n\t\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\t\tvl->append(new StringVal(parts[1].c_str()));\n\n\t\t\t\tconst char* t = topic.c_str();\n\t\t\t\tif ( *t == ':' )\n\t\t\t\t\t++t;\n\n\t\t\t\tvl->append(new StringVal(t));\n\n\t\t\t\tConnectionEvent(irc_channel_topic, vl);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tWeird(\"irc_invalid_topic_reply\");\n\t\t\t\treturn;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\t}\n\n\t\t// WHO reply line.\n\t\tcase 352:\n\t\t\tif ( ! irc_who_line )\n\t\t\t\tbreak;\n\n\t\t\t{\n\t\t\tvector<string> parts = SplitWords(params, ' ');\n\t\t\tif ( parts.size() < 9 )\n\t\t\t\t{\n\t\t\t\tWeird(\"irc_invalid_who_line\");\n\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(parts[0].c_str()));\n\t\t\tvl->append(new StringVal(parts[1].c_str()));\n\t\t\tif ( parts[2][0] == '~' )\n\t\t\t\tparts[2] = parts[2].substr(1);\n\t\t\tvl->append(new StringVal(parts[2].c_str()));\n\t\t\tvl->append(new StringVal(parts[3].c_str()));\n\t\t\tvl->append(new StringVal(parts[4].c_str()));\n\t\t\tvl->append(new StringVal(parts[5].c_str()));\n\t\t\tvl->append(new StringVal(parts[6].c_str()));\n\t\t\tif ( parts[7][0] == ':' )\n\t\t\t\tparts[7] = parts[7].substr(1);\n\t\t\tvl->append(new Val(atoi(parts[7].c_str()), TYPE_INT));\n\t\t\tvl->append(new StringVal(parts[8].c_str()));\n\n\t\t\tConnectionEvent(irc_who_line, vl);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Invalid nick name.\n\t\tcase 431:\n\t\tcase 432:\n\t\tcase 433:\n\t\tcase 436:\n\t\t\tif ( irc_invalid_nick )\n\t\t\t\t{\n\t\t\t\tval_list* vl = new val_list;\n\t\t\t\tvl->append(BuildConnVal());\n\t\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\t\tConnectionEvent(irc_invalid_nick, vl);\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\t// Operator responses.\n\t\tcase 381:  // User is operator\n\t\tcase 491:  // user is not operator\n\t\t\tif ( irc_oper_response )\n\t\t\t\t{\n\t\t\t\tval_list* vl = new val_list;\n\t\t\t\tvl->append(BuildConnVal());\n\t\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\t\tvl->append(new Val(code == 381, TYPE_BOOL));\n\t\t\t\tConnectionEvent(irc_oper_response, vl);\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 670:\n\t\t\t// StartTLS success reply to StartTLS\n\t\t\tStartTLS();\n\t\t\tbreak;\n\n\t\t// All other server replies.\n\t\tdefault:\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(prefix.c_str()));\n\t\t\tvl->append(new Val(code, TYPE_COUNT));\n\t\t\tvl->append(new StringVal(params.c_str()));\n\n\t\t\tConnectionEvent(irc_reply, vl);\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t\t}\n\n\t// Check if command is valid.\n\tif ( command.size() > 20 )\n\t\t{\n\t\tWeird(\"irc_invalid_command\");\n\t\tif ( ++invalid_msg_count > invalid_msg_max_count )\n\t\t\t{\n\t\t\tWeird(\"irc_too_many_invalid\");\n\t\t\tProtocolViolation(\"too many long lines\");\n\t\t\treturn;\n\t\t\t}\n\t\treturn;\n\t\t}\n\n\telse if ( ( irc_privmsg_message || irc_dcc_message ) && command == \"PRIVMSG\")\n\t\t{\n\t\tunsigned int pos = params.find(' ');\n\t\tif ( pos >= params.size() )\n\t\t\t{\n\t\t\tWeird(\"irc_invalid_privmsg_message_format\");\n\t\t\treturn;\n\t\t\t}\n\n\t\tstring target = params.substr(0, pos);\n\t\tstring message = params.substr(pos + 1);\n\t\tSkipLeadingWhitespace(message);\n\n\t\tif ( message.size() > 0 && message[0] == ':' )\n\t\t\tmessage = message.substr(1);\n\t\tif ( message.size() > 0 && message[0] == 1 )\n\t\t\tmessage = message.substr(1); // DCC\n\n\t\t// Check for DCC messages.\n\t\tif ( message.size() > 3 && message.substr(0, 3) == \"DCC\" )\n\t\t\t{\n\t\t\tif ( message.size() > 0 &&\n\t\t\t     message[message.size() - 1] == 1 )\n\t\t\t\tmessage = message.substr(0, message.size() - 1);\n\n\t\t\tvector<string> parts = SplitWords(message, ' ');\n\t\t\tif ( parts.size() < 5 || parts.size() > 6 )\n\t\t\t\t{\n\t\t\t\t// Turbo DCC extension appends a \"T\" at the end of handshake.\n\t\t\t\tif ( ! (parts.size() == 7 && parts[6] == \"T\") )\n\t\t\t\t\t{\n\t\t\t\t\tWeird(\"irc_invalid_dcc_message_format\");\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Calculate IP address.\n\t\t\tuint32 raw_ip = 0;\n\t\t\tfor ( unsigned int i = 0; i < parts[3].size(); ++i )\n\t\t\t\t{\n\t\t\t\tstring s = parts[3].substr(i, 1);\n\t\t\t\traw_ip = (10 * raw_ip) + atoi(s.c_str());\n\t\t\t\t}\n\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(prefix.c_str()));\n\t\t\tvl->append(new StringVal(target.c_str()));\n\t\t\tvl->append(new StringVal(parts[1].c_str()));\n\t\t\tvl->append(new StringVal(parts[2].c_str()));\n\t\t\tvl->append(new AddrVal(htonl(raw_ip)));\n\t\t\tvl->append(new Val(atoi(parts[4].c_str()), TYPE_COUNT));\n\t\t\tif ( parts.size() >= 6 )\n\t\t\t\tvl->append(new Val(atoi(parts[5].c_str()),\n\t\t\t\t\t\t\tTYPE_COUNT));\n\t\t\telse\n\t\t\t\tvl->append(new Val(0, TYPE_COUNT));\n\n\t\t\tConnectionEvent(irc_dcc_message, vl);\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(prefix.c_str()));\n\t\t\tvl->append(new StringVal(target.c_str()));\n\t\t\tvl->append(new StringVal(message.c_str()));\n\n\t\t\tConnectionEvent(irc_privmsg_message, vl);\n\t\t\t}\n\t\t}\n\n\telse if ( irc_notice_message && command == \"NOTICE\" )\n\t\t{\n\t\tunsigned int pos = params.find(' ');\n\t\tif ( pos >= params.size() )\n\t\t\t{\n\t\t\tWeird(\"irc_invalid_notice_message_format\");\n\t\t\treturn;\n\t\t\t}\n\n\t\tstring target = params.substr(0, pos);\n\t\tstring message = params.substr(pos + 1);\n\t\tSkipLeadingWhitespace(message);\n\t\tif ( message[0] == ':' )\n\t\t\tmessage = message.substr(1);\n\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\tvl->append(new StringVal(prefix.c_str()));\n\t\tvl->append(new StringVal(target.c_str()));\n\t\tvl->append(new StringVal(message.c_str()));\n\n\t\tConnectionEvent(irc_notice_message, vl);\n\t\t}\n\n\telse if ( irc_squery_message && command == \"SQUERY\" )\n\t\t{\n\t\tunsigned int pos = params.find(' ');\n\t\tif ( pos >= params.size() )\n\t\t\t{\n\t\t\tWeird(\"irc_invalid_squery_message_format\");\n\t\t\treturn;\n\t\t\t}\n\n\t\tstring target = params.substr(0, pos);\n\t\tstring message = params.substr(pos + 1);\n\t\tSkipLeadingWhitespace(message);\n\t\tif ( message[0] == ':' )\n\t\t\tmessage = message.substr(1);\n\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\tvl->append(new StringVal(prefix.c_str()));\n\t\tvl->append(new StringVal(target.c_str()));\n\t\tvl->append(new StringVal(message.c_str()));\n\n\t\tConnectionEvent(irc_squery_message, vl);\n\t\t}\n\n\telse if ( irc_user_message && command == \"USER\" )\n\t\t{\n\t\t// extract username and real name\n\t\tvector<string> parts = SplitWords(params, ' ');\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\n\t\tif ( parts.size() > 0 )\n\t\t\tvl->append(new StringVal(parts[0].c_str()));\n\t\telse vl->append(new StringVal(\"\"));\n\n\t\tif ( parts.size() > 1 )\n\t\t\tvl->append(new StringVal(parts[1].c_str()));\n\t\telse vl->append(new StringVal(\"\"));\n\n\t\tif ( parts.size() > 2 )\n\t\t\tvl->append(new StringVal(parts[2].c_str()));\n\t\telse vl->append(new StringVal(\"\"));\n\n\t\tstring realname;\n\t\tfor ( unsigned int i = 3; i < parts.size(); i++ )\n\t\t\t{\n\t\t\trealname += parts[i];\n\t\t\tif ( i > 3 )\n\t\t\t\trealname += \" \";\n\t\t\t}\n\n\t\tconst char* name = realname.c_str();\n\t\tvl->append(new StringVal(*name == ':' ? name + 1 : name));\n\n\t\tConnectionEvent(irc_user_message, vl);\n\t\t}\n\n\telse if ( irc_oper_message && command == \"OPER\" )\n\t\t{\n\t\t// extract username and password\n\t\tvector<string> parts = SplitWords(params, ' ');\n\t\tif ( parts.size() == 2 )\n\t\t\t{\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(parts[0].c_str()));\n\t\t\tvl->append(new StringVal(parts[1].c_str()));\n\n\t\t\tConnectionEvent(irc_oper_message, vl);\n\t\t\t}\n\n\t\telse\n\t\t\tWeird(\"irc_invalid_oper_message_format\");\n\t\t}\n\n\telse if ( irc_kick_message && command == \"KICK\" )\n\t\t{\n\t\t// Extract channels, users and comment.\n\t\tvector<string> parts = SplitWords(params, ' ');\n\t\tif ( parts.size() <= 1 )\n\t\t\t{\n\t\t\tWeird(\"irc_invalid_kick_message_format\");\n\t\t\treturn;\n\t\t\t}\n\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\tvl->append(new StringVal(prefix.c_str()));\n\t\tvl->append(new StringVal(parts[0].c_str()));\n\t\tvl->append(new StringVal(parts[1].c_str()));\n\t\tif ( parts.size() > 2 )\n\t\t\t{\n\t\t\tstring comment = parts[2];\n\t\t\tfor ( unsigned int i = 3; i < parts.size(); ++i )\n\t\t\t\tcomment += \" \" + parts[i];\n\n\t\t\tif ( comment[0] == ':' )\n\t\t\t\tcomment = comment.substr(1);\n\n\t\t\tvl->append(new StringVal(comment.c_str()));\n\t\t\t}\n\t\telse\n\t\t\tvl->append(new StringVal(\"\"));\n\n\t\tConnectionEvent(irc_kick_message, vl);\n\t\t}\n\n\telse if ( irc_join_message && command == \"JOIN\" )\n\t\t{\n\t\tif ( params[0] == ':' )\n\t\t\tparams = params.substr(1);\n\n\t\tvector<string> parts = SplitWords(params, ' ');\n\n\t\tif ( parts.size() < 1 )\n\t\t\t{\n\t\t\tWeird(\"irc_invalid_join_line\");\n\t\t\treturn;\n\t\t\t}\n\n\t\tstring nickname = \"\";\n\t\tif ( prefix.size() > 0 )\n\t\t\t{\n\t\t\tunsigned int pos = prefix.find('!');\n\t\t\tif ( pos < prefix.size() )\n\t\t\t\tnickname = prefix.substr(0, pos);\n\t\t\t}\n\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\n\t\tTableVal* list = new TableVal(irc_join_list);\n\t\tvector<string> channels = SplitWords(parts[0], ',');\n\t\tvector<string> passwords;\n\n\t\tif ( parts.size() > 1 )\n\t\t\tpasswords = SplitWords(parts[1], ',');\n\n\t\tstring empty_string = \"\";\n\t\tfor ( unsigned int i = 0; i < channels.size(); ++i )\n\t\t\t{\n\t\t\tRecordVal* info = new RecordVal(irc_join_info);\n\t\t\tinfo->Assign(0, new StringVal(nickname.c_str()));\n\t\t\tinfo->Assign(1, new StringVal(channels[i].c_str()));\n\t\t\tif ( i < passwords.size() )\n\t\t\t\tinfo->Assign(2, new StringVal(passwords[i].c_str()));\n\t\t\telse\n\t\t\t\tinfo->Assign(2, new StringVal(empty_string.c_str()));\n\t\t\t// User mode.\n\t\t\tinfo->Assign(3, new StringVal(empty_string.c_str()));\n\t\t\tlist->Assign(info, 0);\n\t\t\tUnref(info);\n\t\t\t}\n\n\t\tvl->append(list);\n\n\t\tConnectionEvent(irc_join_message, vl);\n\t\t}\n\n\telse if ( irc_join_message && command == \"NJOIN\" )\n\t\t{\n\t\tvector<string> parts = SplitWords(params, ' ');\n\t\tif ( parts.size() != 2 )\n\t\t\t{\n\t\t\tWeird(\"irc_invalid_njoin_line\");\n\t\t\treturn;\n\t\t\t}\n\n\t\tstring channel = parts[0];\n\t\tif ( parts[1][0] == ':' )\n\t\t\tparts[1] = parts[1].substr(1);\n\n\t\tvector<string> users = SplitWords(parts[1], ',');\n\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\n\t\tTableVal* list = new TableVal(irc_join_list);\n\t\tstring empty_string = \"\";\n\n\t\tfor ( unsigned int i = 0; i < users.size(); ++i )\n\t\t\t{\n\t\t\tRecordVal* info = new RecordVal(irc_join_info);\n\t\t\tstring nick = users[i];\n\t\t\tstring mode = \"none\";\n\n\t\t\tif ( nick[0] == '@' )\n\t\t\t\t{\n\t\t\t\tif ( nick[1] == '@' )\n\t\t\t\t\t{\n\t\t\t\t\tnick = nick.substr(2);\n\t\t\t\t\tmode = \"creator\";\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tnick = nick.substr(1);\n\t\t\t\t\tmode = \"operator\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\telse if ( nick[0] == '+' )\n\t\t\t\t{\n\t\t\t\tnick = nick.substr(1);\n\t\t\t\tmode = \"voice\";\n\t\t\t\t}\n\n\t\t\tinfo->Assign(0, new StringVal(nick.c_str()));\n\t\t\tinfo->Assign(1, new StringVal(channel.c_str()));\n\t\t\t// Password:\n\t\t\tinfo->Assign(2, new StringVal(empty_string.c_str()));\n\t\t\t// User mode:\n\t\t\tinfo->Assign(3, new StringVal(mode.c_str()));\n\t\t\tlist->Assign(info, 0);\n\t\t\tUnref(info);\n\t\t\t}\n\n\t\tvl->append(list);\n\n\t\tConnectionEvent(irc_join_message, vl);\n\t\t}\n\n\telse if ( irc_part_message && command == \"PART\" )\n\t\t{\n\t\tstring channels = params;\n\t\tstring message = \"\";\n\t\tunsigned int pos = params.find(' ');\n\n\t\tif ( pos < params.size() )\n\t\t\t{\n\t\t\tchannels = params.substr(0, pos);\n\t\t\tif ( params.size() > pos + 1 )\n\t\t\t\t{\n\t\t\t\tmessage = params.substr(pos + 1);\n\t\t\t\tSkipLeadingWhitespace(message);\n\t\t\t\t}\n\t\t\tif ( message[0] == ':' )\n\t\t\t\tmessage = message.substr(1);\n\t\t\t}\n\n\t\tstring nick = prefix;\n\t\tpos = nick.find('!');\n\t\tif ( pos < nick.size() )\n\t\t\tnick = nick.substr(0, pos);\n\n\t\tvector<string> channelList = SplitWords(channels, ',');\n\t\tTableVal* set = new TableVal(string_set);\n\n\t\tfor ( unsigned int i = 0; i < channelList.size(); ++i )\n\t\t\t{\n\t\t\tVal* idx = new StringVal(channelList[i].c_str());\n\t\t\tset->Assign(idx, 0);\n\t\t\tUnref(idx);\n\t\t\t}\n\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\tvl->append(new StringVal(nick.c_str()));\n\t\tvl->append(set);\n\t\tvl->append(new StringVal(message.c_str()));\n\n\t\tConnectionEvent(irc_part_message, vl);\n\t\t}\n\n\telse if ( irc_quit_message && command == \"QUIT\" )\n\t\t{\n\t\tstring message = params;\n\t\tif ( message[0] == ':' )\n\t\t\tmessage = message.substr(1);\n\n\t\tstring nickname = \"\";\n\t\tif ( prefix.size() > 0 )\n\t\t\t{\n\t\t\tunsigned int pos = prefix.find('!');\n\t\t\tif ( pos < prefix.size() )\n\t\t\t\tnickname = prefix.substr(0, pos);\n\t\t\t}\n\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\tvl->append(new StringVal(nickname.c_str()));\n\t\tvl->append(new StringVal(message.c_str()));\n\n\t\tConnectionEvent(irc_quit_message, vl);\n\t\t}\n\n\telse if ( irc_nick_message && command == \"NICK\" )\n\t\t{\n\t\tstring nick = params;\n\t\tif ( nick[0] == ':' )\n\t\t\tnick = nick.substr(1);\n\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\tvl->append(new StringVal(prefix.c_str()));\n\t\tvl->append(new StringVal(nick.c_str()));\n\n\t\tConnectionEvent(irc_nick_message, vl);\n\t\t}\n\n\telse if ( irc_who_message && command == \"WHO\" )\n\t\t{\n\t\tvector<string> parts = SplitWords(params, ' ');\n\t\tif ( parts.size() > 2 )\n\t\t\t{\n\t\t\tWeird(\"irc_invalid_who_message_format\");\n\t\t\treturn;\n\t\t\t}\n\n\t\tbool oper = false;\n\t\tif ( parts.size() == 2 && parts[1] == \"o\" )\n\t\t\toper = true;\n\n\t\t// Remove \":\" from mask.\n\t\tif ( parts.size() > 0 && parts[0].size() > 0 && parts[0][0] == ':' )\n\t\t\tparts[0] = parts[0].substr(1);\n\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\tif ( parts.size() > 0 )\n\t\t\tvl->append(new StringVal(parts[0].c_str()));\n\t\telse\n\t\t\tvl->append(new StringVal(\"\"));\n\t\tvl->append(new Val(oper, TYPE_BOOL));\n\n\t\tConnectionEvent(irc_who_message, vl);\n\t\t}\n\n\telse if ( irc_whois_message && command == \"WHOIS\" )\n\t\t{\n\t\tvector<string> parts = SplitWords(params, ' ');\n\t\tif ( parts.size() < 1 || parts.size() > 2 )\n\t\t\t{\n\t\t\tWeird(\"irc_invalid_whois_message_format\");\n\t\t\treturn;\n\t\t\t}\n\n\t\tstring server = \"\";\n\t\tstring users = \"\";\n\n\t\tif ( parts.size() == 2 )\n\t\t\t{\n\t\t\tserver = parts[0];\n\t\t\tusers = parts[1];\n\t\t\t}\n\t\telse\n\t\t\tusers = parts[0];\n\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\tvl->append(new StringVal(server.c_str()));\n\t\tvl->append(new StringVal(users.c_str()));\n\n\t\tConnectionEvent(irc_whois_message, vl);\n\t\t}\n\n\telse if ( irc_error_message && command == \"ERROR\" )\n\t\t{\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\tvl->append(new StringVal(prefix.c_str()));\n\t\tif ( params[0] == ':' )\n\t\t\tparams = params.substr(1);\n\t\tvl->append(new StringVal(params.c_str()));\n\n\t\tConnectionEvent(irc_error_message, vl);\n\t\t}\n\n\telse if ( irc_invite_message && command == \"INVITE\" )\n\t\t{\n\t\tvector<string> parts = SplitWords(params, ' ');\n\t\tif ( parts.size() == 2 )\n\t\t\t{ // remove \":\" from channel\n\t\t\tif ( parts[1].size() > 0 && parts[1][0] == ':' )\n\t\t\t\tparts[1] = parts[1].substr(1);\n\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(prefix.c_str()));\n\t\t\tvl->append(new StringVal(parts[0].c_str()));\n\t\t\tvl->append(new StringVal(parts[1].c_str()));\n\n\t\t\tConnectionEvent(irc_invite_message, vl);\n\t\t\t}\n\t\telse\n\t\t\tWeird(\"irc_invalid_invite_message_format\");\n\t\t}\n\n\telse if ( irc_mode_message && command == \"MODE\" )\n\t\t{\n\t\tif ( params.size() > 0 )\n\t\t\t{\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(prefix.c_str()));\n\t\t\tvl->append(new StringVal(params.c_str()));\n\n\t\t\tConnectionEvent(irc_mode_message, vl);\n\t\t\t}\n\n\t\telse\n\t\t\tWeird(\"irc_invalid_mode_message_format\");\n\t\t}\n\n\telse if ( irc_password_message && command == \"PASS\" )\n\t\t{\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\tvl->append(new StringVal(params.c_str()));\n\t\tConnectionEvent(irc_password_message, vl);\n\t\t}\n\n\telse if ( irc_squit_message && command == \"SQUIT\" )\n\t\t{\n\t\tstring server = params;\n\t\tstring message = \"\";\n\n\t\tunsigned int pos = params.find(' ');\n\t\tif ( pos < params.size() )\n\t\t\t{\n\t\t\tserver = params.substr(0, pos);\n\t\t\tmessage = params.substr(pos + 1);\n\t\t\tSkipLeadingWhitespace(message);\n\t\t\tif ( message[0] == ':' )\n\t\t\t\tmessage = message.substr(1);\n\t\t\t}\n\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\tvl->append(new StringVal(prefix.c_str()));\n\t\tvl->append(new StringVal(server.c_str()));\n\t\tvl->append(new StringVal(message.c_str()));\n\n\t\tConnectionEvent(irc_squit_message, vl);\n\t\t}\n\n\n\telse if ( orig )\n\t\t{\n\t\tif ( irc_request )\n\t\t\t{\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(prefix.c_str()));\n\t\t\tvl->append(new StringVal(command.c_str()));\n\t\t\tvl->append(new StringVal(params.c_str()));\n\n\t\t\tConnectionEvent(irc_request, vl);\n\t\t\t}\n\t\t}\n\n\telse\n\t\t{\n\t\tif ( irc_message )\n\t\t\t{\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(prefix.c_str()));\n\t\t\tvl->append(new StringVal(command.c_str()));\n\t\t\tvl->append(new StringVal(params.c_str()));\n\n\t\t\tConnectionEvent(irc_message, vl);\n\t\t\t}\n\t\t}\n\n\tif ( orig_status == REGISTERED && resp_status == REGISTERED &&\n\t     orig_zip_status == ACCEPT_ZIP && resp_zip_status == ACCEPT_ZIP )\n\t\t{\n\t\torig_zip_status = ZIP_LOADED;\n\t\tresp_zip_status = ZIP_LOADED;\n\t\tAddSupportAnalyzer(new zip::ZIP_Analyzer(Conn(), true));\n\t\tAddSupportAnalyzer(new zip::ZIP_Analyzer(Conn(), false));\n\t\t}\n\n\treturn;\n\t}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146152,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void IRC_Analyzer::DeliverStream(int length, const u_char* line, bool orig)\n\t{\n\ttcp::TCP_ApplicationAnalyzer::DeliverStream(length, line, orig);\n\n\tif ( starttls )\n\t\t{\n\t\tForwardStream(length, line, orig);\n\t\treturn;\n\t\t}\n\n\t// check line size\n\tif ( length > 512 )\n\t\t{\n\t\tWeird(\"irc_line_size_exceeded\");\n\t\treturn;\n\t\t}\n\n\tstring myline = string((const char*) line, length);\n\tSkipLeadingWhitespace(myline);\n\n\tif ( myline.length() < 3 )\n\t\t{\n\t\tWeird(\"irc_line_too_short\");\n\t\treturn;\n\t\t}\n\n\t// Check for prefix.\n\tstring prefix = \"\";\n\tif ( myline[0] == ':' )\n\t\t{ // find end of prefix and extract it\n\t\tauto pos = myline.find(' ');\n\t\tif ( pos == string::npos )\n\t\t\t{\n\t\t\tWeird(\"irc_invalid_line\");\n\t\t\treturn;\n\t\t\t}\n\n\t\tprefix = myline.substr(1, pos - 1);\n\t\tmyline = myline.substr(pos + 1);  // remove prefix from line\n\t\tSkipLeadingWhitespace(myline);\n\t\t}\n\n\tif ( orig )\n\t\tProtocolConfirmation();\n\n\tint code = 0;\n\tstring command = \"\";\n\n\t// Check if line is long enough to include status code or command.\n\t// (shortest command with optional params is \"WHO\")\n\tif ( myline.length() < 3 )\n\t\t{\n\t\tWeird(\"irc_invalid_line\");\n\t\tProtocolViolation(\"line too short\");\n\t\treturn;\n\t\t}\n\n\t// Check if this is a server reply.\n\tif ( isdigit(myline[0]) )\n\t\t{\n\t\tif ( isdigit(myline[1]) && isdigit(myline[2]) &&\n\t\t     myline[3] == ' ')\n\t\t\t{\n\t\t\tcode = (myline[0] - '0') * 100 +\n\t\t\t\t(myline[1] - '0') * 10 + (myline[2] - '0');\n\t\t\tmyline = myline.substr(4);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tWeird(\"irc_invalid_reply_number\");\n\t\t\tProtocolViolation(\"invalid reply number\");\n\t\t\treturn;\n\t\t\t}\n\t\t}\n\telse\n\t\t{ // get command\n\t\tauto pos = myline.find(' ');\n\t\t// Not all commands require parameters\n\t\tif ( pos == string::npos )\n\t\t\tpos = myline.length();\n\n\t\tcommand = myline.substr(0, pos);\n\t\tfor ( unsigned int i = 0; i < command.size(); ++i )\n\t\t\tcommand[i] = toupper(command[i]);\n\n\t\t// Adjust for the no-parameter case\n\t\tif ( pos == myline.length() )\n\t\t\tpos--;\n\n\t\tmyline = myline.substr(pos + 1);\n\t\tSkipLeadingWhitespace(myline);\n\t\t}\n\n\t// Extract parameters.\n\tstring params = myline;\n\n\t// special case\n\tif ( command == \"STARTTLS\" )\n\t\treturn;\n\n\t// Check for Server2Server - connections with ZIP enabled.\n\tif ( orig && orig_status == WAIT_FOR_REGISTRATION )\n\t\t{\n\t\tif ( command == \"PASS\" )\n\t\t\t{\n\t\t\tvector<string> p = SplitWords(params,' ');\n\t\t\tif ( p.size() > 3 &&\n\t\t\t     (p[3].find('Z')<=p[3].size() ||\n\t\t\t      p[3].find('z')<=p[3].size()) )\n\t\t\t\torig_zip_status = ACCEPT_ZIP;\n\t\t\telse\n\t\t\t        orig_zip_status = NO_ZIP;\n\t\t\t}\n\n\t\t// We do not check if SERVER command is successful, since\n\t\t// the connection will be terminated by the server if\n\t\t// authentication fails.\n\t\t//\n\t\t// (### This seems not quite prudent to me - VP)\n\t\tif ( command == \"SERVER\" && prefix == \"\")\n\t\t\t{\n\t\t\torig_status = REGISTERED;\n\t\t\t}\n\t\t}\n\n\tif ( ! orig && resp_status == WAIT_FOR_REGISTRATION )\n\t\t{\n\t\tif ( command == \"PASS\" )\n\t\t\t{\n\t\t\tvector<string> p = SplitWords(params,' ');\n\t\t\tif ( p.size() > 3 &&\n\t\t\t     (p[3].find('Z')<=p[3].size() ||\n\t\t\t      p[3].find('z')<=p[3].size()) )\n\t\t\t        resp_zip_status = ACCEPT_ZIP;\n\t\t\telse\n\t\t\t        resp_zip_status = NO_ZIP;\n\n\t\t\t}\n\n\t\t// Again, don't bother checking whether SERVER command\n\t\t// is successful.\n\t\tif ( command == \"SERVER\" && prefix == \"\")\n\t\t\tresp_status = REGISTERED;\n\t\t}\n\n\t// Analyze server reply messages.\n\tif ( code > 0 )\n\t\t{\n\t\tswitch ( code ) {\n\t\t/*\n\t\tcase 1: // RPL_WELCOME\n\t\tcase 2: // RPL_YOURHOST\n\t\tcase 3: // RPL_CREATED\n\t\tcase 4: // RPL_MYINFO\n\t\tcase 5: // RPL_BOUNCE\n\t\tcase 252: // number of ops online\n\t\tcase 253: // number of unknown connections\n\t\tcase 265: // RPL_LOCALUSERS\n\t\tcase 312: // whois server reply\n\t\tcase 315: // end of who list\n\t\tcase 317: // whois idle reply\n\t\tcase 318: // end of whois list\n\t\tcase 366: // end of names list\n\t\tcase 372: // RPL_MOTD\n\t\tcase 375: // RPL_MOTDSTART\n\t\tcase 376: // RPL_ENDOFMOTD\n\t\tcase 331: // RPL_NOTOPIC\n\t\t\tbreak;\n\t\t*/\n\n\t\t// Count of users, services and servers in whole network.\n\t\tcase 251:\n\t\t\tif ( ! irc_network_info )\n\t\t\t\tbreak;\n\n\t\t\t{\n\t\t\tvector<string> parts = SplitWords(params, ' ');\n\t\t\tint users = 0;\n\t\t\tint services = 0;\n\t\t\tint servers = 0;\n\n\t\t\tfor ( unsigned int i = 1; i < parts.size(); ++i )\n\t\t\t\t{\n\t\t\t\tif ( parts[i] == \"users\" )\n\t\t\t\t\tusers = atoi(parts[i-1].c_str());\n\t\t\t\telse if ( parts[i] == \"services\" )\n\t\t\t\t\tservices = atoi(parts[i-1].c_str());\n\t\t\t\telse if ( parts[i] == \"servers\" )\n\t\t\t\t\tservers = atoi(parts[i-1].c_str());\n\t\t\t\t// else ###\n\t\t\t\t}\n\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new Val(users, TYPE_INT));\n\t\t\tvl->append(new Val(services, TYPE_INT));\n\t\t\tvl->append(new Val(servers, TYPE_INT));\n\n\t\t\tConnectionEvent(irc_network_info, vl);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// List of users in a channel (names command).\n\t\tcase 353:\n\t\t\tif ( ! irc_names_info )\n\t\t\t\tbreak;\n\n\t\t\t{\n\t\t\tvector<string> parts = SplitWords(params, ' ');\n\n\t\t\tif ( parts.size() < 3 )\n\t\t\t\t{\n\t\t\t\tWeird(\"irc_invalid_names_line\");\n\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t// Remove nick name.\n\t\t\tparts.erase(parts.begin());\n\n\t\t\tstring type = parts[0];\n\t\t\tstring channel = parts[1];\n\n\t\t\t// Remove type and channel.\n\t\t\tparts.erase(parts.begin());\n\t\t\tparts.erase(parts.begin());\n\n\t\t\tif ( parts.size() > 0 && parts[0][0] == ':' )\n\t\t\t\tparts[0] = parts[0].substr(1);\n\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(type.c_str()));\n\t\t\tvl->append(new StringVal(channel.c_str()));\n\n\t\t\tTableVal* set = new TableVal(string_set);\n\t\t\tfor ( unsigned int i = 0; i < parts.size(); ++i )\n\t\t\t\t{\n\t\t\t\tif ( parts[i][0] == '@' )\n\t\t\t\t\tparts[i] = parts[i].substr(1);\n\t\t\t\tVal* idx = new StringVal(parts[i].c_str());\n\t\t\t\tset->Assign(idx, 0);\n\t\t\t\tUnref(idx);\n\t\t\t\t}\n\t\t\tvl->append(set);\n\n\t\t\tConnectionEvent(irc_names_info, vl);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Count of users and services on this server.\n\t\tcase 255:\n\t\t\tif ( ! irc_server_info )\n\t\t\t\tbreak;\n\n\t\t\t{\n\t\t\tvector<string> parts = SplitWords(params, ' ');\n\t\t\tint users = 0;\n\t\t\tint services = 0;\n\t\t\tint servers = 0;\n\n\t\t\tfor ( unsigned int i = 1; i < parts.size(); ++i )\n\t\t\t\t{\n\t\t\t\tif ( parts[i] == \"users,\" )\n\t\t\t\t\tusers = atoi(parts[i-1].c_str());\n\t\t\t\telse if ( parts[i] == \"clients\" )\n\t\t\t\t\tusers = atoi(parts[i-1].c_str());\n\t\t\t\telse if ( parts[i] == \"services\" )\n\t\t\t\t\tservices = atoi(parts[i-1].c_str());\n\t\t\t\telse if ( parts[i] == \"servers\" )\n\t\t\t\t\tservers = atoi(parts[i-1].c_str());\n\t\t\t\t// else ###\n\t\t\t\t}\n\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new Val(users, TYPE_INT));\n\t\t\tvl->append(new Val(services, TYPE_INT));\n\t\t\tvl->append(new Val(servers, TYPE_INT));\n\n\t\t\tConnectionEvent(irc_server_info, vl);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Count of channels.\n\t\tcase 254:\n\t\t\tif ( ! irc_channel_info )\n\t\t\t\tbreak;\n\n\t\t\t{\n\t\t\tvector<string> parts = SplitWords(params, ' ');\n\t\t\tint channels = 0;\n\t\t\tfor ( unsigned int i = 1; i < parts.size(); ++i )\n\t\t\t\tif ( parts[i] == \":channels\" )\n\t\t\t\t\tchannels = atoi(parts[i - 1].c_str());\n\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new Val(channels, TYPE_INT));\n\n\t\t\tConnectionEvent(irc_channel_info, vl);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// RPL_GLOBALUSERS\n\t\tcase 266:\n\t\t\t{\n\t\t\t// FIXME: We should really streamline all this\n\t\t\t// parsing code ...\n\t\t\tif ( ! irc_global_users )\n\t\t\t\tbreak;\n\n\t\t\tconst char* prefix = params.c_str();\n\n\t\t\tconst char* eop = strchr(prefix, ' ');\n\t\t\tif ( ! eop )\n\t\t\t\t{\n\t\t\t\tWeird(\"invalid_irc_global_users_reply\");\n\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tconst char *msg = strchr(++eop, ':');\n\t\t\tif ( ! msg )\n\t\t\t\t{\n\t\t\t\tWeird(\"invalid_irc_global_users_reply\");\n\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(eop - prefix, prefix));\n\t\t\tvl->append(new StringVal(++msg));\n\t\t\tConnectionEvent(irc_global_users, vl);\n\t\t\tbreak;\n\t\t\t}\n\n\t\t// WHOIS user reply line.\n\t\tcase 311:\n\t\t\tif ( ! irc_whois_user_line )\n\t\t\t\tbreak;\n\n\t\t\t{\n\t\t\tvector<string> parts = SplitWords(params, ' ');\n\n\t\t\tif ( parts.size() > 1 )\n\t\t\t\tparts.erase(parts.begin());\n\t\t\tif ( parts.size() < 5 )\n\t\t\t\t{\n\t\t\t\tWeird(\"irc_invalid_whois_user_line\");\n\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(parts[0].c_str()));\n\t\t\tvl->append(new StringVal(parts[1].c_str()));\n\t\t\tvl->append(new StringVal(parts[2].c_str()));\n\n\t\t\tparts.erase(parts.begin(), parts.begin() + 4);\n\n\t\t\tstring real_name = parts[0];\n\t\t\tfor ( unsigned int i = 1; i < parts.size(); ++i )\n\t\t\t\treal_name = real_name + \" \" + parts[i];\n\n\t\t\tif ( real_name[0] == ':' )\n\t\t\t\treal_name = real_name.substr(1);\n\n\t\t\tvl->append(new StringVal(real_name.c_str()));\n\n\t\t\tConnectionEvent(irc_whois_user_line, vl);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// WHOIS operator reply line.\n\t\tcase 313:\n\t\t\tif ( ! irc_whois_operator_line )\n\t\t\t\tbreak;\n\n\t\t\t{\n\t\t\tvector<string> parts = SplitWords(params, ' ');\n\n\t\t\tif ( parts.size() > 1 )\n\t\t\t\tparts.erase(parts.begin());\n\n\t\t\tif ( parts.size() < 2 )\n\t\t\t\t{\n\t\t\t\tWeird(\"irc_invalid_whois_operator_line\");\n\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(parts[0].c_str()));\n\n\t\t\tConnectionEvent(irc_whois_operator_line, vl);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// WHOIS channel reply.\n\t\tcase 319:\n\t\t\tif ( ! irc_whois_channel_line )\n\t\t\t\tbreak;\n\n\t\t\t{\n\t\t\tvector<string> parts = SplitWords(params, ' ');\n\n\t\t\t// Remove nick name.\n\t\t\tparts.erase(parts.begin());\n\t\t\tif ( parts.size() < 2 )\n\t\t\t\t{\n\t\t\t\tWeird(\"irc_invalid_whois_channel_line\");\n\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\tstring nick = parts[0];\n\t\t\tparts.erase(parts.begin());\n\n\t\t\tif ( parts.size() > 0 && parts[0][0] == ':' )\n\t\t\t\tparts[0] = parts[0].substr(1);\n\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(nick.c_str()));\n\t\t\tTableVal* set = new TableVal(string_set);\n\t\t\tfor ( unsigned int i = 0; i < parts.size(); ++i )\n\t\t\t\t{\n\t\t\t\tVal* idx = new StringVal(parts[i].c_str());\n\t\t\t\tset->Assign(idx, 0);\n\t\t\t\tUnref(idx);\n\t\t\t\t}\n\n\t\t\tvl->append(set);\n\n\t\t\tConnectionEvent(irc_whois_channel_line, vl);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// RPL_TOPIC reply.\n\t\tcase 332:\n\t\t\t{\n\t\t\tif ( ! irc_channel_topic )\n\t\t\t\tbreak;\n\n\t\t\tvector<string> parts = SplitWords(params, ' ');\n\t\t\tif ( parts.size() < 4 )\n\t\t\t\t{\n\t\t\t\tWeird(\"irc_invalid_topic_reply\");\n\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\tunsigned int pos = params.find(':');\n\t\t\tif ( pos < params.size() )\n\t\t\t\t{\n\t\t\t\tstring topic = params.substr(pos + 1);\n\t\t\t\tval_list* vl = new val_list;\n\n\t\t\t\tvl->append(BuildConnVal());\n\t\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\t\tvl->append(new StringVal(parts[1].c_str()));\n\n\t\t\t\tconst char* t = topic.c_str();\n\t\t\t\tif ( *t == ':' )\n\t\t\t\t\t++t;\n\n\t\t\t\tvl->append(new StringVal(t));\n\n\t\t\t\tConnectionEvent(irc_channel_topic, vl);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tWeird(\"irc_invalid_topic_reply\");\n\t\t\t\treturn;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\t}\n\n\t\t// WHO reply line.\n\t\tcase 352:\n\t\t\tif ( ! irc_who_line )\n\t\t\t\tbreak;\n\n\t\t\t{\n\t\t\tvector<string> parts = SplitWords(params, ' ');\n\t\t\tif ( parts.size() < 9 )\n\t\t\t\t{\n\t\t\t\tWeird(\"irc_invalid_who_line\");\n\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(parts[0].c_str()));\n\t\t\tvl->append(new StringVal(parts[1].c_str()));\n\t\t\tif ( parts[2][0] == '~' )\n\t\t\t\tparts[2] = parts[2].substr(1);\n\t\t\tvl->append(new StringVal(parts[2].c_str()));\n\t\t\tvl->append(new StringVal(parts[3].c_str()));\n\t\t\tvl->append(new StringVal(parts[4].c_str()));\n\t\t\tvl->append(new StringVal(parts[5].c_str()));\n\t\t\tvl->append(new StringVal(parts[6].c_str()));\n\t\t\tif ( parts[7][0] == ':' )\n\t\t\t\tparts[7] = parts[7].substr(1);\n\t\t\tvl->append(new Val(atoi(parts[7].c_str()), TYPE_INT));\n\t\t\tvl->append(new StringVal(parts[8].c_str()));\n\n\t\t\tConnectionEvent(irc_who_line, vl);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Invalid nick name.\n\t\tcase 431:\n\t\tcase 432:\n\t\tcase 433:\n\t\tcase 436:\n\t\t\tif ( irc_invalid_nick )\n\t\t\t\t{\n\t\t\t\tval_list* vl = new val_list;\n\t\t\t\tvl->append(BuildConnVal());\n\t\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\t\tConnectionEvent(irc_invalid_nick, vl);\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\t// Operator responses.\n\t\tcase 381:  // User is operator\n\t\tcase 491:  // user is not operator\n\t\t\tif ( irc_oper_response )\n\t\t\t\t{\n\t\t\t\tval_list* vl = new val_list;\n\t\t\t\tvl->append(BuildConnVal());\n\t\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\t\tvl->append(new Val(code == 381, TYPE_BOOL));\n\t\t\t\tConnectionEvent(irc_oper_response, vl);\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 670:\n\t\t\t// StartTLS success reply to StartTLS\n\t\t\tStartTLS();\n\t\t\tbreak;\n\n\t\t// All other server replies.\n\t\tdefault:\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(prefix.c_str()));\n\t\t\tvl->append(new Val(code, TYPE_COUNT));\n\t\t\tvl->append(new StringVal(params.c_str()));\n\n\t\t\tConnectionEvent(irc_reply, vl);\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t\t}\n\n\t// Check if command is valid.\n\tif ( command.size() > 20 )\n\t\t{\n\t\tWeird(\"irc_invalid_command\");\n\t\tif ( ++invalid_msg_count > invalid_msg_max_count )\n\t\t\t{\n\t\t\tWeird(\"irc_too_many_invalid\");\n\t\t\tProtocolViolation(\"too many long lines\");\n\t\t\treturn;\n\t\t\t}\n\t\treturn;\n\t\t}\n\n\telse if ( ( irc_privmsg_message || irc_dcc_message ) && command == \"PRIVMSG\")\n\t\t{\n\t\tunsigned int pos = params.find(' ');\n\t\tif ( pos >= params.size() )\n\t\t\t{\n\t\t\tWeird(\"irc_invalid_privmsg_message_format\");\n\t\t\treturn;\n\t\t\t}\n\n\t\tstring target = params.substr(0, pos);\n\t\tstring message = params.substr(pos + 1);\n\t\tSkipLeadingWhitespace(message);\n\n\t\tif ( message.size() > 0 && message[0] == ':' )\n\t\t\tmessage = message.substr(1);\n\t\tif ( message.size() > 0 && message[0] == 1 )\n\t\t\tmessage = message.substr(1); // DCC\n\n\t\t// Check for DCC messages.\n\t\tif ( message.size() > 3 && message.substr(0, 3) == \"DCC\" )\n\t\t\t{\n\t\t\tif ( message.size() > 0 &&\n\t\t\t     message[message.size() - 1] == 1 )\n\t\t\t\tmessage = message.substr(0, message.size() - 1);\n\n\t\t\tvector<string> parts = SplitWords(message, ' ');\n\t\t\tif ( parts.size() < 5 || parts.size() > 6 )\n\t\t\t\t{\n\t\t\t\t// Turbo DCC extension appends a \"T\" at the end of handshake.\n\t\t\t\tif ( ! (parts.size() == 7 && parts[6] == \"T\") )\n\t\t\t\t\t{\n\t\t\t\t\tWeird(\"irc_invalid_dcc_message_format\");\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Calculate IP address.\n\t\t\tuint32 raw_ip = 0;\n\t\t\tfor ( unsigned int i = 0; i < parts[3].size(); ++i )\n\t\t\t\t{\n\t\t\t\tstring s = parts[3].substr(i, 1);\n\t\t\t\traw_ip = (10 * raw_ip) + atoi(s.c_str());\n\t\t\t\t}\n\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(prefix.c_str()));\n\t\t\tvl->append(new StringVal(target.c_str()));\n\t\t\tvl->append(new StringVal(parts[1].c_str()));\n\t\t\tvl->append(new StringVal(parts[2].c_str()));\n\t\t\tvl->append(new AddrVal(htonl(raw_ip)));\n\t\t\tvl->append(new Val(atoi(parts[4].c_str()), TYPE_COUNT));\n\t\t\tif ( parts.size() >= 6 )\n\t\t\t\tvl->append(new Val(atoi(parts[5].c_str()),\n\t\t\t\t\t\t\tTYPE_COUNT));\n\t\t\telse\n\t\t\t\tvl->append(new Val(0, TYPE_COUNT));\n\n\t\t\tConnectionEvent(irc_dcc_message, vl);\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(prefix.c_str()));\n\t\t\tvl->append(new StringVal(target.c_str()));\n\t\t\tvl->append(new StringVal(message.c_str()));\n\n\t\t\tConnectionEvent(irc_privmsg_message, vl);\n\t\t\t}\n\t\t}\n\n\telse if ( irc_notice_message && command == \"NOTICE\" )\n\t\t{\n\t\tunsigned int pos = params.find(' ');\n\t\tif ( pos >= params.size() )\n\t\t\t{\n\t\t\tWeird(\"irc_invalid_notice_message_format\");\n\t\t\treturn;\n\t\t\t}\n\n\t\tstring target = params.substr(0, pos);\n\t\tstring message = params.substr(pos + 1);\n\t\tSkipLeadingWhitespace(message);\n\t\tif ( message[0] == ':' )\n\t\t\tmessage = message.substr(1);\n\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\tvl->append(new StringVal(prefix.c_str()));\n\t\tvl->append(new StringVal(target.c_str()));\n\t\tvl->append(new StringVal(message.c_str()));\n\n\t\tConnectionEvent(irc_notice_message, vl);\n\t\t}\n\n\telse if ( irc_squery_message && command == \"SQUERY\" )\n\t\t{\n\t\tunsigned int pos = params.find(' ');\n\t\tif ( pos >= params.size() )\n\t\t\t{\n\t\t\tWeird(\"irc_invalid_squery_message_format\");\n\t\t\treturn;\n\t\t\t}\n\n\t\tstring target = params.substr(0, pos);\n\t\tstring message = params.substr(pos + 1);\n\t\tSkipLeadingWhitespace(message);\n\t\tif ( message[0] == ':' )\n\t\t\tmessage = message.substr(1);\n\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\tvl->append(new StringVal(prefix.c_str()));\n\t\tvl->append(new StringVal(target.c_str()));\n\t\tvl->append(new StringVal(message.c_str()));\n\n\t\tConnectionEvent(irc_squery_message, vl);\n\t\t}\n\n\telse if ( irc_user_message && command == \"USER\" )\n\t\t{\n\t\t// extract username and real name\n\t\tvector<string> parts = SplitWords(params, ' ');\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\n\t\tif ( parts.size() > 0 )\n\t\t\tvl->append(new StringVal(parts[0].c_str()));\n\t\telse vl->append(new StringVal(\"\"));\n\n\t\tif ( parts.size() > 1 )\n\t\t\tvl->append(new StringVal(parts[1].c_str()));\n\t\telse vl->append(new StringVal(\"\"));\n\n\t\tif ( parts.size() > 2 )\n\t\t\tvl->append(new StringVal(parts[2].c_str()));\n\t\telse vl->append(new StringVal(\"\"));\n\n\t\tstring realname;\n\t\tfor ( unsigned int i = 3; i < parts.size(); i++ )\n\t\t\t{\n\t\t\trealname += parts[i];\n\t\t\tif ( i > 3 )\n\t\t\t\trealname += \" \";\n\t\t\t}\n\n\t\tconst char* name = realname.c_str();\n\t\tvl->append(new StringVal(*name == ':' ? name + 1 : name));\n\n\t\tConnectionEvent(irc_user_message, vl);\n\t\t}\n\n\telse if ( irc_oper_message && command == \"OPER\" )\n\t\t{\n\t\t// extract username and password\n\t\tvector<string> parts = SplitWords(params, ' ');\n\t\tif ( parts.size() == 2 )\n\t\t\t{\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(parts[0].c_str()));\n\t\t\tvl->append(new StringVal(parts[1].c_str()));\n\n\t\t\tConnectionEvent(irc_oper_message, vl);\n\t\t\t}\n\n\t\telse\n\t\t\tWeird(\"irc_invalid_oper_message_format\");\n\t\t}\n\n\telse if ( irc_kick_message && command == \"KICK\" )\n\t\t{\n\t\t// Extract channels, users and comment.\n\t\tvector<string> parts = SplitWords(params, ' ');\n\t\tif ( parts.size() <= 1 )\n\t\t\t{\n\t\t\tWeird(\"irc_invalid_kick_message_format\");\n\t\t\treturn;\n\t\t\t}\n\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\tvl->append(new StringVal(prefix.c_str()));\n\t\tvl->append(new StringVal(parts[0].c_str()));\n\t\tvl->append(new StringVal(parts[1].c_str()));\n\t\tif ( parts.size() > 2 )\n\t\t\t{\n\t\t\tstring comment = parts[2];\n\t\t\tfor ( unsigned int i = 3; i < parts.size(); ++i )\n\t\t\t\tcomment += \" \" + parts[i];\n\n\t\t\tif ( comment[0] == ':' )\n\t\t\t\tcomment = comment.substr(1);\n\n\t\t\tvl->append(new StringVal(comment.c_str()));\n\t\t\t}\n\t\telse\n\t\t\tvl->append(new StringVal(\"\"));\n\n\t\tConnectionEvent(irc_kick_message, vl);\n\t\t}\n\n\telse if ( irc_join_message && command == \"JOIN\" )\n\t\t{\n\t\tif ( params[0] == ':' )\n\t\t\tparams = params.substr(1);\n\n\t\tvector<string> parts = SplitWords(params, ' ');\n\n\t\tif ( parts.size() < 1 )\n\t\t\t{\n\t\t\tWeird(\"irc_invalid_join_line\");\n\t\t\treturn;\n\t\t\t}\n\n\t\tstring nickname = \"\";\n\t\tif ( prefix.size() > 0 )\n\t\t\t{\n\t\t\tunsigned int pos = prefix.find('!');\n\t\t\tif ( pos < prefix.size() )\n\t\t\t\tnickname = prefix.substr(0, pos);\n\t\t\t}\n\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\n\t\tTableVal* list = new TableVal(irc_join_list);\n\t\tvector<string> channels = SplitWords(parts[0], ',');\n\t\tvector<string> passwords;\n\n\t\tif ( parts.size() > 1 )\n\t\t\tpasswords = SplitWords(parts[1], ',');\n\n\t\tstring empty_string = \"\";\n\t\tfor ( unsigned int i = 0; i < channels.size(); ++i )\n\t\t\t{\n\t\t\tRecordVal* info = new RecordVal(irc_join_info);\n\t\t\tinfo->Assign(0, new StringVal(nickname.c_str()));\n\t\t\tinfo->Assign(1, new StringVal(channels[i].c_str()));\n\t\t\tif ( i < passwords.size() )\n\t\t\t\tinfo->Assign(2, new StringVal(passwords[i].c_str()));\n\t\t\telse\n\t\t\t\tinfo->Assign(2, new StringVal(empty_string.c_str()));\n\t\t\t// User mode.\n\t\t\tinfo->Assign(3, new StringVal(empty_string.c_str()));\n\t\t\tlist->Assign(info, 0);\n\t\t\tUnref(info);\n\t\t\t}\n\n\t\tvl->append(list);\n\n\t\tConnectionEvent(irc_join_message, vl);\n\t\t}\n\n\telse if ( irc_join_message && command == \"NJOIN\" )\n\t\t{\n\t\tvector<string> parts = SplitWords(params, ' ');\n\t\tif ( parts.size() != 2 )\n\t\t\t{\n\t\t\tWeird(\"irc_invalid_njoin_line\");\n\t\t\treturn;\n\t\t\t}\n\n\t\tstring channel = parts[0];\n\t\tif ( parts[1][0] == ':' )\n\t\t\tparts[1] = parts[1].substr(1);\n\n\t\tvector<string> users = SplitWords(parts[1], ',');\n\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\n\t\tTableVal* list = new TableVal(irc_join_list);\n\t\tstring empty_string = \"\";\n\n\t\tfor ( unsigned int i = 0; i < users.size(); ++i )\n\t\t\t{\n\t\t\tRecordVal* info = new RecordVal(irc_join_info);\n\t\t\tstring nick = users[i];\n\t\t\tstring mode = \"none\";\n\n\t\t\tif ( nick[0] == '@' )\n\t\t\t\t{\n\t\t\t\tif ( nick[1] == '@' )\n\t\t\t\t\t{\n\t\t\t\t\tnick = nick.substr(2);\n\t\t\t\t\tmode = \"creator\";\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tnick = nick.substr(1);\n\t\t\t\t\tmode = \"operator\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\telse if ( nick[0] == '+' )\n\t\t\t\t{\n\t\t\t\tnick = nick.substr(1);\n\t\t\t\tmode = \"voice\";\n\t\t\t\t}\n\n\t\t\tinfo->Assign(0, new StringVal(nick.c_str()));\n\t\t\tinfo->Assign(1, new StringVal(channel.c_str()));\n\t\t\t// Password:\n\t\t\tinfo->Assign(2, new StringVal(empty_string.c_str()));\n\t\t\t// User mode:\n\t\t\tinfo->Assign(3, new StringVal(mode.c_str()));\n\t\t\tlist->Assign(info, 0);\n\t\t\tUnref(info);\n\t\t\t}\n\n\t\tvl->append(list);\n\n\t\tConnectionEvent(irc_join_message, vl);\n\t\t}\n\n\telse if ( irc_part_message && command == \"PART\" )\n\t\t{\n\t\tstring channels = params;\n\t\tstring message = \"\";\n\t\tunsigned int pos = params.find(' ');\n\n\t\tif ( pos < params.size() )\n\t\t\t{\n\t\t\tchannels = params.substr(0, pos);\n\t\t\tif ( params.size() > pos + 1 )\n\t\t\t\t{\n\t\t\t\tmessage = params.substr(pos + 1);\n\t\t\t\tSkipLeadingWhitespace(message);\n\t\t\t\t}\n\t\t\tif ( message[0] == ':' )\n\t\t\t\tmessage = message.substr(1);\n\t\t\t}\n\n\t\tstring nick = prefix;\n\t\tpos = nick.find('!');\n\t\tif ( pos < nick.size() )\n\t\t\tnick = nick.substr(0, pos);\n\n\t\tvector<string> channelList = SplitWords(channels, ',');\n\t\tTableVal* set = new TableVal(string_set);\n\n\t\tfor ( unsigned int i = 0; i < channelList.size(); ++i )\n\t\t\t{\n\t\t\tVal* idx = new StringVal(channelList[i].c_str());\n\t\t\tset->Assign(idx, 0);\n\t\t\tUnref(idx);\n\t\t\t}\n\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\tvl->append(new StringVal(nick.c_str()));\n\t\tvl->append(set);\n\t\tvl->append(new StringVal(message.c_str()));\n\n\t\tConnectionEvent(irc_part_message, vl);\n\t\t}\n\n\telse if ( irc_quit_message && command == \"QUIT\" )\n\t\t{\n\t\tstring message = params;\n\t\tif ( message[0] == ':' )\n\t\t\tmessage = message.substr(1);\n\n\t\tstring nickname = \"\";\n\t\tif ( prefix.size() > 0 )\n\t\t\t{\n\t\t\tunsigned int pos = prefix.find('!');\n\t\t\tif ( pos < prefix.size() )\n\t\t\t\tnickname = prefix.substr(0, pos);\n\t\t\t}\n\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\tvl->append(new StringVal(nickname.c_str()));\n\t\tvl->append(new StringVal(message.c_str()));\n\n\t\tConnectionEvent(irc_quit_message, vl);\n\t\t}\n\n\telse if ( irc_nick_message && command == \"NICK\" )\n\t\t{\n\t\tstring nick = params;\n\t\tif ( nick[0] == ':' )\n\t\t\tnick = nick.substr(1);\n\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\tvl->append(new StringVal(prefix.c_str()));\n\t\tvl->append(new StringVal(nick.c_str()));\n\n\t\tConnectionEvent(irc_nick_message, vl);\n\t\t}\n\n\telse if ( irc_who_message && command == \"WHO\" )\n\t\t{\n\t\tvector<string> parts = SplitWords(params, ' ');\n\t\tif ( parts.size() > 2 )\n\t\t\t{\n\t\t\tWeird(\"irc_invalid_who_message_format\");\n\t\t\treturn;\n\t\t\t}\n\n\t\tbool oper = false;\n\t\tif ( parts.size() == 2 && parts[1] == \"o\" )\n\t\t\toper = true;\n\n\t\t// Remove \":\" from mask.\n\t\tif ( parts.size() > 0 && parts[0].size() > 0 && parts[0][0] == ':' )\n\t\t\tparts[0] = parts[0].substr(1);\n\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\tif ( parts.size() > 0 )\n\t\t\tvl->append(new StringVal(parts[0].c_str()));\n\t\telse\n\t\t\tvl->append(new StringVal(\"\"));\n\t\tvl->append(new Val(oper, TYPE_BOOL));\n\n\t\tConnectionEvent(irc_who_message, vl);\n\t\t}\n\n\telse if ( irc_whois_message && command == \"WHOIS\" )\n\t\t{\n\t\tvector<string> parts = SplitWords(params, ' ');\n\t\tif ( parts.size() < 1 || parts.size() > 2 )\n\t\t\t{\n\t\t\tWeird(\"irc_invalid_whois_message_format\");\n\t\t\treturn;\n\t\t\t}\n\n\t\tstring server = \"\";\n\t\tstring users = \"\";\n\n\t\tif ( parts.size() == 2 )\n\t\t\t{\n\t\t\tserver = parts[0];\n\t\t\tusers = parts[1];\n\t\t\t}\n\t\telse\n\t\t\tusers = parts[0];\n\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\tvl->append(new StringVal(server.c_str()));\n\t\tvl->append(new StringVal(users.c_str()));\n\n\t\tConnectionEvent(irc_whois_message, vl);\n\t\t}\n\n\telse if ( irc_error_message && command == \"ERROR\" )\n\t\t{\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\tvl->append(new StringVal(prefix.c_str()));\n\t\tif ( params[0] == ':' )\n\t\t\tparams = params.substr(1);\n\t\tvl->append(new StringVal(params.c_str()));\n\n\t\tConnectionEvent(irc_error_message, vl);\n\t\t}\n\n\telse if ( irc_invite_message && command == \"INVITE\" )\n\t\t{\n\t\tvector<string> parts = SplitWords(params, ' ');\n\t\tif ( parts.size() == 2 )\n\t\t\t{ // remove \":\" from channel\n\t\t\tif ( parts[1].size() > 0 && parts[1][0] == ':' )\n\t\t\t\tparts[1] = parts[1].substr(1);\n\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(prefix.c_str()));\n\t\t\tvl->append(new StringVal(parts[0].c_str()));\n\t\t\tvl->append(new StringVal(parts[1].c_str()));\n\n\t\t\tConnectionEvent(irc_invite_message, vl);\n\t\t\t}\n\t\telse\n\t\t\tWeird(\"irc_invalid_invite_message_format\");\n\t\t}\n\n\telse if ( irc_mode_message && command == \"MODE\" )\n\t\t{\n\t\tif ( params.size() > 0 )\n\t\t\t{\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(prefix.c_str()));\n\t\t\tvl->append(new StringVal(params.c_str()));\n\n\t\t\tConnectionEvent(irc_mode_message, vl);\n\t\t\t}\n\n\t\telse\n\t\t\tWeird(\"irc_invalid_mode_message_format\");\n\t\t}\n\n\telse if ( irc_password_message && command == \"PASS\" )\n\t\t{\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\tvl->append(new StringVal(params.c_str()));\n\t\tConnectionEvent(irc_password_message, vl);\n\t\t}\n\n\telse if ( irc_squit_message && command == \"SQUIT\" )\n\t\t{\n\t\tstring server = params;\n\t\tstring message = \"\";\n\n\t\tunsigned int pos = params.find(' ');\n\t\tif ( pos < params.size() )\n\t\t\t{\n\t\t\tserver = params.substr(0, pos);\n\t\t\tmessage = params.substr(pos + 1);\n\t\t\tSkipLeadingWhitespace(message);\n\t\t\tif ( message[0] == ':' )\n\t\t\t\tmessage = message.substr(1);\n\t\t\t}\n\n\t\tval_list* vl = new val_list;\n\t\tvl->append(BuildConnVal());\n\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\tvl->append(new StringVal(prefix.c_str()));\n\t\tvl->append(new StringVal(server.c_str()));\n\t\tvl->append(new StringVal(message.c_str()));\n\n\t\tConnectionEvent(irc_squit_message, vl);\n\t\t}\n\n\n\telse if ( orig )\n\t\t{\n\t\tif ( irc_request )\n\t\t\t{\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(prefix.c_str()));\n\t\t\tvl->append(new StringVal(command.c_str()));\n\t\t\tvl->append(new StringVal(params.c_str()));\n\n\t\t\tConnectionEvent(irc_request, vl);\n\t\t\t}\n\t\t}\n\n\telse\n\t\t{\n\t\tif ( irc_message )\n\t\t\t{\n\t\t\tval_list* vl = new val_list;\n\t\t\tvl->append(BuildConnVal());\n\t\t\tvl->append(new Val(orig, TYPE_BOOL));\n\t\t\tvl->append(new StringVal(prefix.c_str()));\n\t\t\tvl->append(new StringVal(command.c_str()));\n\t\t\tvl->append(new StringVal(params.c_str()));\n\n\t\t\tConnectionEvent(irc_message, vl);\n\t\t\t}\n\t\t}\n\n\tif ( orig_status == REGISTERED && resp_status == REGISTERED &&\n\t     orig_zip_status == ACCEPT_ZIP && resp_zip_status == ACCEPT_ZIP )\n\t\t{\n\t\torig_zip_status = ZIP_LOADED;\n\t\tresp_zip_status = ZIP_LOADED;\n\t\tAddSupportAnalyzer(new zip::ZIP_Analyzer(Conn(), true));\n\t\tAddSupportAnalyzer(new zip::ZIP_Analyzer(Conn(), false));\n\t\t}\n\n\treturn;\n\t}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146153,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "nm_wildcard_match_check(const char *str, const char *const *patterns, guint num_patterns)\n{\n    gboolean has_optional     = FALSE;\n    gboolean has_any_optional = FALSE;\n    guint    i;\n\n    for (i = 0; i < num_patterns; i++) {\n        gboolean    is_inverted;\n        gboolean    is_mandatory;\n        gboolean    match;\n        const char *p;\n\n        _pattern_parse(patterns[i], &p, &is_inverted, &is_mandatory);\n\n        match = (fnmatch(p, str, 0) == 0);\n        if (is_inverted)\n            match = !match;\n\n        if (is_mandatory) {\n            if (!match)\n                return FALSE;\n        } else {\n            has_any_optional = TRUE;\n            if (match)\n                has_optional = TRUE;\n        }\n    }\n\n    return has_optional || !has_any_optional;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146202,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "nm_wildcard_match_check(const char *str, const char *const *patterns, guint num_patterns)\n{\n    gboolean has_optional     = FALSE;\n    gboolean has_any_optional = FALSE;\n    guint    i;\n\n    for (i = 0; i < num_patterns; i++) {\n        gboolean    is_inverted;\n        gboolean    is_mandatory;\n        gboolean    match;\n        const char *p;\n\n        _pattern_parse(patterns[i], &p, &is_inverted, &is_mandatory);\n\n        match = (fnmatch(p, str ?: \"\", 0) == 0);\n\n        if (is_inverted)\n            match = !match;\n\n        if (is_mandatory) {\n            if (!match)\n                return FALSE;\n        } else {\n            has_any_optional = TRUE;\n            if (match)\n                has_optional = TRUE;\n        }\n    }\n\n    return has_optional || !has_any_optional;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146203,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask)\n\t\treturn -1;\n\n\tioapic_debug(\"dest=%x dest_mode=%x delivery_mode=%x \"\n\t\t     \"vector=%x trig_mode=%x\\n\",\n\t\t     entry->fields.dest_id, entry->fields.dest_mode,\n\t\t     entry->fields.delivery_mode, entry->fields.vector,\n\t\t     entry->fields.trig_mode);\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = entry->fields.dest_mode;\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = 0;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr &= ~(1 << irq);\n\n\tif (irq == RTC_GSI && line_status) {\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\tioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = ret;\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146268,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask)\n\t\treturn -1;\n\n\tioapic_debug(\"dest=%x dest_mode=%x delivery_mode=%x \"\n\t\t     \"vector=%x trig_mode=%x\\n\",\n\t\t     entry->fields.dest_id, entry->fields.dest_mode,\n\t\t     entry->fields.delivery_mode, entry->fields.vector,\n\t\t     entry->fields.trig_mode);\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = entry->fields.dest_mode;\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = 0;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr &= ~(1 << irq);\n\n\tif (irq == RTC_GSI && line_status) {\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\tioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146269,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "rsock_init_unixsock(VALUE sock, VALUE path, int server)\n{\n    struct sockaddr_un sockaddr;\n    socklen_t sockaddrlen;\n    int fd, status;\n    rb_io_t *fptr;\n\n    SafeStringValue(path);\n\n    INIT_SOCKADDR_UN(&sockaddr, sizeof(struct sockaddr_un));\n    if (sizeof(sockaddr.sun_path) < (size_t)RSTRING_LEN(path)) {\n        rb_raise(rb_eArgError, \"too long unix socket path (%ldbytes given but %dbytes max)\",\n            RSTRING_LEN(path), (int)sizeof(sockaddr.sun_path));\n    }\n    memcpy(sockaddr.sun_path, RSTRING_PTR(path), RSTRING_LEN(path));\n    sockaddrlen = rsock_unix_sockaddr_len(path);\n\n    fd = rsock_socket(AF_UNIX, SOCK_STREAM, 0);\n    if (fd < 0) {\n\trsock_sys_fail_path(\"socket(2)\", path);\n    }\n\n    if (server) {\n        status = bind(fd, (struct sockaddr*)&sockaddr, sockaddrlen);\n    }\n    else {\n\tint prot;\n\tstruct unixsock_arg arg;\n\targ.sockaddr = &sockaddr;\n\targ.sockaddrlen = sockaddrlen;\n\targ.fd = fd;\n        status = (int)rb_protect(unixsock_connect_internal, (VALUE)&arg, &prot);\n\tif (prot) {\n\t    close(fd);\n\t    rb_jump_tag(prot);\n\t}\n    }\n\n    if (status < 0) {\n\tclose(fd);\n        rsock_sys_fail_path(\"connect(2)\", path);\n    }\n\n    if (server) {\n\tif (listen(fd, SOMAXCONN) < 0) {\n\t    close(fd);\n            rsock_sys_fail_path(\"listen(2)\", path);\n\t}\n    }\n\n    rsock_init_sock(sock, fd);\n    if (server) {\n\tGetOpenFile(sock, fptr);\n        fptr->pathv = rb_str_new_frozen(path);\n    }\n\n    return sock;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146272,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "rsock_init_unixsock(VALUE sock, VALUE path, int server)\n{\n    struct sockaddr_un sockaddr;\n    socklen_t sockaddrlen;\n    int fd, status;\n    rb_io_t *fptr;\n\n    path = unixsock_path_value(path);\n\n    INIT_SOCKADDR_UN(&sockaddr, sizeof(struct sockaddr_un));\n    if (sizeof(sockaddr.sun_path) < (size_t)RSTRING_LEN(path)) {\n        rb_raise(rb_eArgError, \"too long unix socket path (%ldbytes given but %dbytes max)\",\n            RSTRING_LEN(path), (int)sizeof(sockaddr.sun_path));\n    }\n    memcpy(sockaddr.sun_path, RSTRING_PTR(path), RSTRING_LEN(path));\n    sockaddrlen = rsock_unix_sockaddr_len(path);\n\n    fd = rsock_socket(AF_UNIX, SOCK_STREAM, 0);\n    if (fd < 0) {\n\trsock_sys_fail_path(\"socket(2)\", path);\n    }\n\n    if (server) {\n        status = bind(fd, (struct sockaddr*)&sockaddr, sockaddrlen);\n    }\n    else {\n\tint prot;\n\tstruct unixsock_arg arg;\n\targ.sockaddr = &sockaddr;\n\targ.sockaddrlen = sockaddrlen;\n\targ.fd = fd;\n        status = (int)rb_protect(unixsock_connect_internal, (VALUE)&arg, &prot);\n\tif (prot) {\n\t    close(fd);\n\t    rb_jump_tag(prot);\n\t}\n    }\n\n    if (status < 0) {\n\tclose(fd);\n        rsock_sys_fail_path(\"connect(2)\", path);\n    }\n\n    if (server) {\n\tif (listen(fd, SOMAXCONN) < 0) {\n\t    close(fd);\n            rsock_sys_fail_path(\"listen(2)\", path);\n\t}\n    }\n\n    rsock_init_sock(sock, fd);\n    if (server) {\n\tGetOpenFile(sock, fptr);\n        fptr->pathv = rb_str_new_frozen(path);\n    }\n\n    return sock;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146273,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "main(int argc, char *argv[])\n{\n\tchar pidstr[16];\n\tssize_t ret;\n\tint c, log_method;\n\tchar *logfile, *pidfile;\n\tint facility, fd;\n\tchar *username = NULL;\n\tchar *chrootdir = NULL;\n\tint configtest = 0;\n\tint singleprocess = 0;\n#ifdef HAVE_GETOPT_LONG\n\tint opt_idx;\n#endif\n\n\tpname = ((pname=strrchr(argv[0],'/')) != NULL)?pname+1:argv[0];\n\n\tsrand((unsigned int)time(NULL));\n\n\tlog_method = L_STDERR_SYSLOG;\n\tlogfile = PATH_RADVD_LOG;\n\tconf_file = PATH_RADVD_CONF;\n\tfacility = LOG_FACILITY;\n\tpidfile = PATH_RADVD_PID;\n\n\t/* parse args */\n#define OPTIONS_STR \"d:C:l:m:p:t:u:vhcs\"\n#ifdef HAVE_GETOPT_LONG\n\twhile ((c = getopt_long(argc, argv, OPTIONS_STR, prog_opt, &opt_idx)) > 0)\n#else\n\twhile ((c = getopt(argc, argv, OPTIONS_STR)) > 0)\n#endif\n\t{\n\t\tswitch (c) {\n\t\tcase 'C':\n\t\t\tconf_file = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tset_debuglevel(atoi(optarg));\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tfacility = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlogfile = optarg;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpidfile = optarg;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (!strcmp(optarg, \"syslog\"))\n\t\t\t{\n\t\t\t\tlog_method = L_SYSLOG;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"stderr_syslog\"))\n\t\t\t{\n\t\t\t\tlog_method = L_STDERR_SYSLOG;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"stderr\"))\n\t\t\t{\n\t\t\t\tlog_method = L_STDERR;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"logfile\"))\n\t\t\t{\n\t\t\t\tlog_method = L_LOGFILE;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"none\"))\n\t\t\t{\n\t\t\t\tlog_method = L_NONE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"%s: unknown log method: %s\\n\", pname, optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tchrootdir = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tusername = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tversion();\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tconfigtest = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsingleprocess = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n#ifdef HAVE_GETOPT_LONG\n\t\tcase ':':\n\t\t\tfprintf(stderr, \"%s: option %s: parameter expected\\n\", pname,\n\t\t\t\tprog_opt[opt_idx].name);\n\t\t\texit(1);\n#endif\n\t\tcase '?':\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (chrootdir) {\n\t\tif (!username) {\n\t\t\tfprintf(stderr, \"Chroot as root is not safe, exiting\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (chroot(chrootdir) == -1) {\n\t\t\tperror(\"chroot\");\n\t\t\texit (1);\n\t\t}\n\n\t\tif (chdir(\"/\") == -1) {\n\t\t\tperror(\"chdir\");\n\t\t\texit (1);\n\t\t}\n\t\t/* username will be switched later */\n\t}\n\n\tif (configtest) {\n\t\tlog_method = L_STDERR;\n\t}\n\n\tif (log_open(log_method, pname, logfile, facility) < 0) {\n\t\tperror(\"log_open\");\n\t\texit(1);\n\t}\n\n\tif (!configtest) {\n\t\tflog(LOG_INFO, \"version %s started\", VERSION);\n\t}\n\n\t/* get a raw socket for sending and receiving ICMPv6 messages */\n\tsock = open_icmpv6_socket();\n\tif (sock < 0) {\n\t\tperror(\"open_icmpv6_socket\");\n\t\texit(1);\n\t}\n\n\t/* check that 'other' cannot write the file\n         * for non-root, also that self/own group can't either\n         */\n\tif (check_conffile_perm(username, conf_file) < 0) {\n\t\tif (get_debuglevel() == 0) {\n\t\t\tflog(LOG_ERR, \"Exiting, permissions on conf_file invalid.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\telse\n\t\t\tflog(LOG_WARNING, \"Insecure file permissions, but continuing anyway\");\n\t}\n\n\t/* if we know how to do it, check whether forwarding is enabled */\n\tif (check_ip6_forwarding()) {\n\t\tflog(LOG_WARNING, \"IPv6 forwarding seems to be disabled, but continuing anyway.\");\n\t}\n\n\t/* parse config file */\n\tif (readin_config(conf_file) < 0) {\n\t\tflog(LOG_ERR, \"Exiting, failed to read config file.\\n\");\n\t\texit(1);\n\t}\n\n\tif (configtest) {\n\t\tfprintf(stderr, \"Syntax OK\\n\");\n\t\texit(0);\n\t}\n\n\t/* drop root privileges if requested. */\n\tif (username) {\n\t\tif (!singleprocess) {\n\t\t \tdlog(LOG_DEBUG, 3, \"Initializing privsep\");\n\t\t \tif (privsep_init() < 0)\n\t\t\t\tperror(\"Failed to initialize privsep.\");\n\t\t}\n\n\t\tif (drop_root_privileges(username) < 0) {\n\t\t\tperror(\"drop_root_privileges\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif ((fd = open(pidfile, O_RDONLY, 0)) > 0)\n\t{\n\t\tret = read(fd, pidstr, sizeof(pidstr) - 1);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tflog(LOG_ERR, \"cannot read radvd pid file, terminating: %s\", strerror(errno));\n\t\t\texit(1);\n\t\t}\n\t\tpidstr[ret] = '\\0';\n\t\tif (!kill((pid_t)atol(pidstr), 0))\n\t\t{\n\t\t\tflog(LOG_ERR, \"radvd already running, terminating.\");\n\t\t\texit(1);\n\t\t}\n\t\tclose(fd);\n\t\tfd = open(pidfile, O_CREAT|O_TRUNC|O_WRONLY, 0644);\n\t}\n\telse\t/* FIXME: not atomic if pidfile is on an NFS mounted volume */\n\t\tfd = open(pidfile, O_CREAT|O_EXCL|O_WRONLY, 0644);\n\n\tif (fd < 0)\n\t{\n\t\tflog(LOG_ERR, \"cannot create radvd pid file, terminating: %s\", strerror(errno));\n\t\texit(1);\n\t}\n\n\t/*\n\t * okay, config file is read in, socket and stuff is setup, so\n\t * lets fork now...\n\t */\n\n\tif (get_debuglevel() == 0) {\n\n\t\t/* Detach from controlling terminal */\n\t\tif (daemon(0, 0) < 0)\n\t\t\tperror(\"daemon\");\n\n\t\t/* close old logfiles, including stderr */\n\t\tlog_close();\n\n\t\t/* reopen logfiles, but don't log to stderr unless explicitly requested */\n\t\tif (log_method == L_STDERR_SYSLOG)\n\t\t\tlog_method = L_SYSLOG;\n\t\tif (log_open(log_method, pname, logfile, facility) < 0) {\n\t\t\tperror(\"log_open\");\n\t\t\texit(1);\n\t\t}\n\n\t}\n\n\t/*\n\t *\tconfig signal handlers\n\t */\n\tsignal(SIGHUP, sighup_handler);\n\tsignal(SIGTERM, sigterm_handler);\n\tsignal(SIGINT, sigint_handler);\n\tsignal(SIGUSR1, sigusr1_handler);\n\n\tsnprintf(pidstr, sizeof(pidstr), \"%ld\\n\", (long)getpid());\n\n\tret = write(fd, pidstr, strlen(pidstr));\n\tif (ret != strlen(pidstr))\n\t{\n\t\tflog(LOG_ERR, \"cannot write radvd pid file, terminating: %s\", strerror(errno));\n\t\texit(1);\n\t}\n\n\tclose(fd);\n\n\tconfig_interface();\n\tkickoff_adverts();\n\tmain_loop();\n\tstop_adverts();\n\tunlink(pidfile);\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146280,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "main(int argc, char *argv[])\n{\n\tchar pidstr[16];\n\tssize_t ret;\n\tint c, log_method;\n\tchar *logfile, *pidfile;\n\tint facility, fd;\n\tchar *username = NULL;\n\tchar *chrootdir = NULL;\n\tint configtest = 0;\n\tint singleprocess = 0;\n#ifdef HAVE_GETOPT_LONG\n\tint opt_idx;\n#endif\n\n\tpname = ((pname=strrchr(argv[0],'/')) != NULL)?pname+1:argv[0];\n\n\tsrand((unsigned int)time(NULL));\n\n\tlog_method = L_STDERR_SYSLOG;\n\tlogfile = PATH_RADVD_LOG;\n\tconf_file = PATH_RADVD_CONF;\n\tfacility = LOG_FACILITY;\n\tpidfile = PATH_RADVD_PID;\n\n\t/* parse args */\n#define OPTIONS_STR \"d:C:l:m:p:t:u:vhcs\"\n#ifdef HAVE_GETOPT_LONG\n\twhile ((c = getopt_long(argc, argv, OPTIONS_STR, prog_opt, &opt_idx)) > 0)\n#else\n\twhile ((c = getopt(argc, argv, OPTIONS_STR)) > 0)\n#endif\n\t{\n\t\tswitch (c) {\n\t\tcase 'C':\n\t\t\tconf_file = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tset_debuglevel(atoi(optarg));\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tfacility = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlogfile = optarg;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpidfile = optarg;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (!strcmp(optarg, \"syslog\"))\n\t\t\t{\n\t\t\t\tlog_method = L_SYSLOG;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"stderr_syslog\"))\n\t\t\t{\n\t\t\t\tlog_method = L_STDERR_SYSLOG;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"stderr\"))\n\t\t\t{\n\t\t\t\tlog_method = L_STDERR;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"logfile\"))\n\t\t\t{\n\t\t\t\tlog_method = L_LOGFILE;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"none\"))\n\t\t\t{\n\t\t\t\tlog_method = L_NONE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"%s: unknown log method: %s\\n\", pname, optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tchrootdir = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tusername = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tversion();\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tconfigtest = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsingleprocess = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n#ifdef HAVE_GETOPT_LONG\n\t\tcase ':':\n\t\t\tfprintf(stderr, \"%s: option %s: parameter expected\\n\", pname,\n\t\t\t\tprog_opt[opt_idx].name);\n\t\t\texit(1);\n#endif\n\t\tcase '?':\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (chrootdir) {\n\t\tif (!username) {\n\t\t\tfprintf(stderr, \"Chroot as root is not safe, exiting\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (chroot(chrootdir) == -1) {\n\t\t\tperror(\"chroot\");\n\t\t\texit (1);\n\t\t}\n\n\t\tif (chdir(\"/\") == -1) {\n\t\t\tperror(\"chdir\");\n\t\t\texit (1);\n\t\t}\n\t\t/* username will be switched later */\n\t}\n\n\tif (configtest) {\n\t\tlog_method = L_STDERR;\n\t}\n\n\tif (log_open(log_method, pname, logfile, facility) < 0) {\n\t\tperror(\"log_open\");\n\t\texit(1);\n\t}\n\n\tif (!configtest) {\n\t\tflog(LOG_INFO, \"version %s started\", VERSION);\n\t}\n\n\t/* get a raw socket for sending and receiving ICMPv6 messages */\n\tsock = open_icmpv6_socket();\n\tif (sock < 0) {\n\t\tperror(\"open_icmpv6_socket\");\n\t\texit(1);\n\t}\n\n\t/* check that 'other' cannot write the file\n         * for non-root, also that self/own group can't either\n         */\n\tif (check_conffile_perm(username, conf_file) < 0) {\n\t\tif (get_debuglevel() == 0) {\n\t\t\tflog(LOG_ERR, \"Exiting, permissions on conf_file invalid.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\telse\n\t\t\tflog(LOG_WARNING, \"Insecure file permissions, but continuing anyway\");\n\t}\n\n\t/* if we know how to do it, check whether forwarding is enabled */\n\tif (check_ip6_forwarding()) {\n\t\tflog(LOG_WARNING, \"IPv6 forwarding seems to be disabled, but continuing anyway.\");\n\t}\n\n\t/* parse config file */\n\tif (readin_config(conf_file) < 0) {\n\t\tflog(LOG_ERR, \"Exiting, failed to read config file.\\n\");\n\t\texit(1);\n\t}\n\n\tif (configtest) {\n\t\tfprintf(stderr, \"Syntax OK\\n\");\n\t\texit(0);\n\t}\n\n\t/* drop root privileges if requested. */\n\tif (username) {\n\t\tif (!singleprocess) {\n\t\t \tdlog(LOG_DEBUG, 3, \"Initializing privsep\");\n\t\t\tif (privsep_init() < 0) {\n\t\t\t\tperror(\"Failed to initialize privsep.\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tif (drop_root_privileges(username) < 0) {\n\t\t\tperror(\"drop_root_privileges\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif ((fd = open(pidfile, O_RDONLY, 0)) > 0)\n\t{\n\t\tret = read(fd, pidstr, sizeof(pidstr) - 1);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tflog(LOG_ERR, \"cannot read radvd pid file, terminating: %s\", strerror(errno));\n\t\t\texit(1);\n\t\t}\n\t\tpidstr[ret] = '\\0';\n\t\tif (!kill((pid_t)atol(pidstr), 0))\n\t\t{\n\t\t\tflog(LOG_ERR, \"radvd already running, terminating.\");\n\t\t\texit(1);\n\t\t}\n\t\tclose(fd);\n\t\tfd = open(pidfile, O_CREAT|O_TRUNC|O_WRONLY, 0644);\n\t}\n\telse\t/* FIXME: not atomic if pidfile is on an NFS mounted volume */\n\t\tfd = open(pidfile, O_CREAT|O_EXCL|O_WRONLY, 0644);\n\n\tif (fd < 0)\n\t{\n\t\tflog(LOG_ERR, \"cannot create radvd pid file, terminating: %s\", strerror(errno));\n\t\texit(1);\n\t}\n\n\t/*\n\t * okay, config file is read in, socket and stuff is setup, so\n\t * lets fork now...\n\t */\n\n\tif (get_debuglevel() == 0) {\n\n\t\t/* Detach from controlling terminal */\n\t\tif (daemon(0, 0) < 0)\n\t\t\tperror(\"daemon\");\n\n\t\t/* close old logfiles, including stderr */\n\t\tlog_close();\n\n\t\t/* reopen logfiles, but don't log to stderr unless explicitly requested */\n\t\tif (log_method == L_STDERR_SYSLOG)\n\t\t\tlog_method = L_SYSLOG;\n\t\tif (log_open(log_method, pname, logfile, facility) < 0) {\n\t\t\tperror(\"log_open\");\n\t\t\texit(1);\n\t\t}\n\n\t}\n\n\t/*\n\t *\tconfig signal handlers\n\t */\n\tsignal(SIGHUP, sighup_handler);\n\tsignal(SIGTERM, sigterm_handler);\n\tsignal(SIGINT, sigint_handler);\n\tsignal(SIGUSR1, sigusr1_handler);\n\n\tsnprintf(pidstr, sizeof(pidstr), \"%ld\\n\", (long)getpid());\n\n\tret = write(fd, pidstr, strlen(pidstr));\n\tif (ret != strlen(pidstr))\n\t{\n\t\tflog(LOG_ERR, \"cannot write radvd pid file, terminating: %s\", strerror(errno));\n\t\texit(1);\n\t}\n\n\tclose(fd);\n\n\tconfig_interface();\n\tkickoff_adverts();\n\tmain_loop();\n\tstop_adverts();\n\tunlink(pidfile);\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146281,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "extract_VOMS_info( globus_gsi_cred_handle_t cred_handle, int verify_type, char **voname, char **firstfqan, char **quoted_DN_and_FQAN)\n{\n\n#if !defined(HAVE_EXT_VOMS)\n\treturn 1;\n#else\n\n\tint ret;\n\tstruct vomsdata *voms_data = NULL;\n\tstruct voms *voms_cert  = NULL;\n\tchar *subject_name = NULL;\n\tchar **fqan = NULL;\n\tint voms_err;\n\tint fqan_len = 0;\n\tchar *retfqan = NULL;\n\tchar *tmp_scan_ptr = NULL;\n\n\tSTACK_OF(X509) *chain = NULL;\n\tX509 *cert = NULL;\n\n\tchar* x509_fqan_delimiter = NULL;\n\n\tif ( activate_globus_gsi() != 0 ) {\n\t\treturn 1;\n\t}\n\n\t// calling this function on something that doesn't have VOMS attributes\n\t// should return error 1.  when the config knob disables VOMS, behave the\n\t// same way.\n\tif (!param_boolean_int(\"USE_VOMS_ATTRIBUTES\", 1)) {\n\t\treturn 1;\n\t}\n\n\tret = (*globus_gsi_cred_get_cert_chain_ptr)(cred_handle, &chain);\n\tif(ret != GLOBUS_SUCCESS) {\n\t\tret = 10;\n\t\tgoto end;\n\t}\n\n\tret = (*globus_gsi_cred_get_cert_ptr)(cred_handle, &cert);\n\tif(ret != GLOBUS_SUCCESS) {\n\t\tret = 11;\n\t\tgoto end;\n\t}\n\n\tif ((*globus_gsi_cred_get_identity_name_ptr)(cred_handle, &subject_name)) {\n\t\tset_error_string( \"unable to extract subject name\" );\n\t\tret = 12;\n\t\tgoto end;\n\t}\n\n\tvoms_data = (*VOMS_Init_ptr)(NULL, NULL);\n\tif (voms_data == NULL) {\n\t\tret = 13;\n\t\tgoto end;\n\t}\n\n\tif (verify_type == 0) {\n\t\tret = (*VOMS_SetVerificationType_ptr)( VERIFY_NONE, voms_data, &voms_err );\n\t\tif (ret == 0) {\n\t\t\t(*VOMS_ErrorMessage_ptr)(voms_data, voms_err, NULL, 0);\n\t\t\tret = voms_err;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tret = (*VOMS_Retrieve_ptr)(cert, chain, RECURSE_CHAIN,\n\t\t\t\t\t\tvoms_data, &voms_err);\n\tif (ret == 0) {\n\t\tif (voms_err == VERR_NOEXT) {\n\t\t\t// No VOMS extensions present\n\t\t\tret = 1;\n\t\t\tgoto end;\n\t\t} else {\n\t\t\t(*VOMS_ErrorMessage_ptr)(voms_data, voms_err, NULL, 0);\n\t\t\tret = voms_err;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\t// we only support one cert for now.  serializing and encoding all the\n\t// attributes is bad enough, i don't want to deal with doing this to\n\t// multiple certs.\n\tvoms_cert = voms_data->data[0];\n\n\t// fill in the unquoted versions of things\n\tif(voname) {\n\t\t*voname = strdup(voms_cert->voname);\n\t}\n\n\tif(firstfqan) {\n\t\t*firstfqan = strdup(voms_cert->fqan[0]);\n\t}\n\n\t// only construct the quoted_DN_and_FQAN if needed\n\tif (quoted_DN_and_FQAN) {\n\t\t// get our delimiter and trim it\n\t\tif (!(x509_fqan_delimiter = param(\"X509_FQAN_DELIMITER\"))) {\n\t\t\tx509_fqan_delimiter = strdup(\",\");\n\t\t}\n\t\ttmp_scan_ptr = trim_quotes(x509_fqan_delimiter);\n\t\tfree(x509_fqan_delimiter);\n\t\tx509_fqan_delimiter = tmp_scan_ptr;\n\n\t\t// calculate the length\n\t\tfqan_len = 0;\n\n\t\t// start with the length of the quoted DN\n\t\ttmp_scan_ptr = quote_x509_string( subject_name );\n\t\tfqan_len += strlen( tmp_scan_ptr );\n\t\tfree(tmp_scan_ptr);\n\n\t\t// add the length of delimiter plus each voms attribute\n\t\tfor (fqan = voms_cert->fqan; fqan && *fqan; fqan++) {\n\t\t\t// delimiter\n\t\t\tfqan_len += strlen(x509_fqan_delimiter);\n\n\t\t\ttmp_scan_ptr = quote_x509_string( *fqan );\n\t\t\tfqan_len += strlen( tmp_scan_ptr );\n\t\t\tfree(tmp_scan_ptr);\n\t\t}\n\n\t\t// now malloc enough room for the quoted DN, quoted attrs, delimiters, and\n\t\t// NULL terminator\n\t\tretfqan = (char*) malloc (fqan_len+1);\n\t\t*retfqan = 0;  // set null terminiator\n\n\t\t// reset length counter -- we use this for efficient appending.\n\t\tfqan_len = 0;\n\n\t\t// start with the quoted DN\n\t\ttmp_scan_ptr = quote_x509_string( subject_name );\n\t\tstrcat(retfqan, tmp_scan_ptr);\n\t\tfqan_len += strlen( tmp_scan_ptr );\n\t\tfree(tmp_scan_ptr);\n\n\t\t// add the delimiter plus each voms attribute\n\t\tfor (fqan = voms_cert->fqan; fqan && *fqan; fqan++) {\n\t\t\t// delimiter\n\t\t\tstrcat(&(retfqan[fqan_len]), x509_fqan_delimiter);\n\t\t\tfqan_len += strlen(x509_fqan_delimiter);\n\n\t\t\ttmp_scan_ptr = quote_x509_string( *fqan );\n\t\t\tstrcat(&(retfqan[fqan_len]), tmp_scan_ptr);\n\t\t\tfqan_len += strlen( tmp_scan_ptr );\n\t\t\tfree(tmp_scan_ptr);\n\t\t}\n\n\t\t*quoted_DN_and_FQAN = retfqan;\n\t}\n\n\tret = 0;\n\nend:\n\tfree(subject_name);\n\tfree(x509_fqan_delimiter);\n\tif (voms_data)\n\t\t(*VOMS_Destroy_ptr)(voms_data);\n\tif (cert)\n\t\tX509_free(cert);\n\tif(chain)\n\t\tsk_X509_pop_free(chain, X509_free);\n\n\treturn ret;\n#endif\n\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146362,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "extract_VOMS_info( globus_gsi_cred_handle_t cred_handle, int verify_type, char **voname, char **firstfqan, char **quoted_DN_and_FQAN)\n{\n\n#if !defined(HAVE_EXT_VOMS)\n\treturn 1;\n#else\n\n\tint ret;\n\tstruct vomsdata *voms_data = NULL;\n\tstruct voms *voms_cert  = NULL;\n\tchar *subject_name = NULL;\n\tchar **fqan = NULL;\n\tint voms_err;\n\tint fqan_len = 0;\n\tchar *retfqan = NULL;\n\tchar *tmp_scan_ptr = NULL;\n\n\tSTACK_OF(X509) *chain = NULL;\n\tX509 *cert = NULL;\n\n\tchar* x509_fqan_delimiter = NULL;\n\n\tif ( activate_globus_gsi() != 0 ) {\n\t\treturn 1;\n\t}\n\n\t// calling this function on something that doesn't have VOMS attributes\n\t// should return error 1.  when the config knob disables VOMS, behave the\n\t// same way.\n\tif (!param_boolean_int(\"USE_VOMS_ATTRIBUTES\", 1)) {\n\t\treturn 1;\n\t}\n\n\tret = (*globus_gsi_cred_get_cert_chain_ptr)(cred_handle, &chain);\n\tif(ret != GLOBUS_SUCCESS) {\n\t\tret = 10;\n\t\tgoto end;\n\t}\n\n\tret = (*globus_gsi_cred_get_cert_ptr)(cred_handle, &cert);\n\tif(ret != GLOBUS_SUCCESS) {\n\t\tret = 11;\n\t\tgoto end;\n\t}\n\n\tif ((*globus_gsi_cred_get_identity_name_ptr)(cred_handle, &subject_name)) {\n\t\tset_error_string( \"unable to extract subject name\" );\n\t\tret = 12;\n\t\tgoto end;\n\t}\n\n\tvoms_data = (*VOMS_Init_ptr)(NULL, NULL);\n\tif (voms_data == NULL) {\n\t\tret = 13;\n\t\tgoto end;\n\t}\n\n\tif (verify_type == 0) {\n\t\tret = (*VOMS_SetVerificationType_ptr)( VERIFY_NONE, voms_data, &voms_err );\n\t\tif (ret == 0) {\n\t\t\t(*VOMS_ErrorMessage_ptr)(voms_data, voms_err, NULL, 0);\n\t\t\tret = voms_err;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tret = (*VOMS_Retrieve_ptr)(cert, chain, RECURSE_CHAIN,\n\t\t\t\t\t\tvoms_data, &voms_err);\n\tif (ret == 0) {\n\t\tif (voms_err == VERR_NOEXT) {\n\t\t\t// No VOMS extensions present\n\t\t\tret = 1;\n\t\t\tgoto end;\n\t\t} else {\n\t\t\t(*VOMS_ErrorMessage_ptr)(voms_data, voms_err, NULL, 0);\n\t\t\tret = voms_err;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\t// we only support one cert for now.  serializing and encoding all the\n\t// attributes is bad enough, i don't want to deal with doing this to\n\t// multiple certs.\n\tvoms_cert = voms_data->data[0];\n\n\tif (voms_cert == NULL) {\n\t\t// No VOMS certs?? Treat like VOMS_Retrieve() returned VERR_NOEXT.\n\t\tret = 1;\n\t\tgoto end;\n\t}\n\n\t// fill in the unquoted versions of things\n\tif(voname) {\n\t\t*voname = strdup(voms_cert->voname ? voms_cert->voname : \"\");\n\t}\n\n\tif(firstfqan) {\n\t\t*firstfqan = strdup(voms_cert->fqan[0] ? voms_cert->fqan[0] : \"\");\n\t}\n\n\t// only construct the quoted_DN_and_FQAN if needed\n\tif (quoted_DN_and_FQAN) {\n\t\t// get our delimiter and trim it\n\t\tif (!(x509_fqan_delimiter = param(\"X509_FQAN_DELIMITER\"))) {\n\t\t\tx509_fqan_delimiter = strdup(\",\");\n\t\t}\n\t\ttmp_scan_ptr = trim_quotes(x509_fqan_delimiter);\n\t\tfree(x509_fqan_delimiter);\n\t\tx509_fqan_delimiter = tmp_scan_ptr;\n\n\t\t// calculate the length\n\t\tfqan_len = 0;\n\n\t\t// start with the length of the quoted DN\n\t\ttmp_scan_ptr = quote_x509_string( subject_name );\n\t\tfqan_len += strlen( tmp_scan_ptr );\n\t\tfree(tmp_scan_ptr);\n\n\t\t// add the length of delimiter plus each voms attribute\n\t\tfor (fqan = voms_cert->fqan; fqan && *fqan; fqan++) {\n\t\t\t// delimiter\n\t\t\tfqan_len += strlen(x509_fqan_delimiter);\n\n\t\t\ttmp_scan_ptr = quote_x509_string( *fqan );\n\t\t\tfqan_len += strlen( tmp_scan_ptr );\n\t\t\tfree(tmp_scan_ptr);\n\t\t}\n\n\t\t// now malloc enough room for the quoted DN, quoted attrs, delimiters, and\n\t\t// NULL terminator\n\t\tretfqan = (char*) malloc (fqan_len+1);\n\t\t*retfqan = 0;  // set null terminiator\n\n\t\t// reset length counter -- we use this for efficient appending.\n\t\tfqan_len = 0;\n\n\t\t// start with the quoted DN\n\t\ttmp_scan_ptr = quote_x509_string( subject_name );\n\t\tstrcat(retfqan, tmp_scan_ptr);\n\t\tfqan_len += strlen( tmp_scan_ptr );\n\t\tfree(tmp_scan_ptr);\n\n\t\t// add the delimiter plus each voms attribute\n\t\tfor (fqan = voms_cert->fqan; fqan && *fqan; fqan++) {\n\t\t\t// delimiter\n\t\t\tstrcat(&(retfqan[fqan_len]), x509_fqan_delimiter);\n\t\t\tfqan_len += strlen(x509_fqan_delimiter);\n\n\t\t\ttmp_scan_ptr = quote_x509_string( *fqan );\n\t\t\tstrcat(&(retfqan[fqan_len]), tmp_scan_ptr);\n\t\t\tfqan_len += strlen( tmp_scan_ptr );\n\t\t\tfree(tmp_scan_ptr);\n\t\t}\n\n\t\t*quoted_DN_and_FQAN = retfqan;\n\t}\n\n\tret = 0;\n\nend:\n\tfree(subject_name);\n\tfree(x509_fqan_delimiter);\n\tif (voms_data)\n\t\t(*VOMS_Destroy_ptr)(voms_data);\n\tif (cert)\n\t\tX509_free(cert);\n\tif(chain)\n\t\tsk_X509_pop_free(chain, X509_free);\n\n\treturn ret;\n#endif\n\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146363,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static char *parsetree_to_sql(struct ldb_module *module,\n\t\t\t      void *mem_ctx,\n\t\t\t      const struct ldb_parse_tree *t)\n{\n\tstruct ldb_context *ldb;\n\tconst struct ldb_schema_attribute *a;\n\tstruct ldb_val value, subval;\n\tchar *wild_card_string;\n\tchar *child, *tmp;\n\tchar *ret = NULL;\n\tchar *attr;\n\tunsigned int i;\n\n\tldb = ldb_module_get_ctx(module);\n\n\tswitch(t->operation) {\n\tcase LDB_OP_AND:\n\n\t\ttmp = parsetree_to_sql(module, mem_ctx, t->u.list.elements[0]);\n\t\tif (tmp == NULL) return NULL;\n\n\t\tfor (i = 1; i < t->u.list.num_elements; i++) {\n\n\t\t\tchild = parsetree_to_sql(module, mem_ctx, t->u.list.elements[i]);\n\t\t\tif (child == NULL) return NULL;\n\n\t\t\ttmp = talloc_asprintf_append(tmp, \" INTERSECT %s \", child);\n\t\t\tif (tmp == NULL) return NULL;\n\t\t}\n\n\t\tret = talloc_asprintf(mem_ctx, \"SELECT * FROM ( %s )\\n\", tmp);\n\n\t\treturn ret;\n\n\tcase LDB_OP_OR:\n\n\t\ttmp = parsetree_to_sql(module, mem_ctx, t->u.list.elements[0]);\n\t\tif (tmp == NULL) return NULL;\n\n\t\tfor (i = 1; i < t->u.list.num_elements; i++) {\n\n\t\t\tchild = parsetree_to_sql(module, mem_ctx, t->u.list.elements[i]);\n\t\t\tif (child == NULL) return NULL;\n\n\t\t\ttmp = talloc_asprintf_append(tmp, \" UNION %s \", child);\n\t\t\tif (tmp == NULL) return NULL;\n\t\t}\n\n\t\treturn talloc_asprintf(mem_ctx, \"SELECT * FROM ( %s ) \", tmp);\n\n\tcase LDB_OP_NOT:\n\n\t\tchild = parsetree_to_sql(module, mem_ctx, t->u.isnot.child);\n\t\tif (child == NULL) return NULL;\n\n\t\treturn talloc_asprintf(mem_ctx,\n\t\t\t\t\t\"SELECT eid FROM ldb_entry \"\n\t\t\t\t\t\"WHERE eid NOT IN ( %s ) \", child);\n\n\tcase LDB_OP_EQUALITY:\n\t\t/*\n\t\t * For simple searches, we want to retrieve the list of EIDs that\n\t\t * match the criteria.\n\t\t*/\n\t\tattr = ldb_attr_casefold(mem_ctx, t->u.equality.attr);\n\t\tif (attr == NULL) return NULL;\n\t\ta = ldb_schema_attribute_by_name(ldb, attr);\n\n\t\t/* Get a canonicalised copy of the data */\n\t\ta->syntax->canonicalise_fn(ldb, mem_ctx, &(t->u.equality.value), &value);\n\t\tif (value.data == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (strcasecmp(t->u.equality.attr, \"dn\") == 0) {\n\t\t\t/* DN query is a special ldb case */\n\t\t \tconst char *cdn = ldb_dn_get_casefold(\n\t\t\t\t\t\tldb_dn_new(mem_ctx, ldb,\n\t\t\t\t\t\t\t      (const char *)value.data));\n\n\t\t\treturn lsqlite3_tprintf(mem_ctx,\n\t\t\t\t\t\t\"SELECT eid FROM ldb_entry \"\n\t\t\t\t\t\t\"WHERE norm_dn = '%q'\", cdn);\n\n\t\t} else {\n\t\t\t/* A normal query. */\n\t\t\treturn lsqlite3_tprintf(mem_ctx,\n\t\t\t\t\t\t\"SELECT eid FROM ldb_attribute_values \"\n\t\t\t\t\t\t\"WHERE norm_attr_name = '%q' \"\n\t\t\t\t\t\t\"AND norm_attr_value = '%q'\",\n\t\t\t\t\t\tattr,\n\t\t\t\t\t\tvalue.data);\n\n\t\t}\n\n\tcase LDB_OP_SUBSTRING:\n\n\t\twild_card_string = talloc_strdup(mem_ctx,\n\t\t\t\t\t(t->u.substring.start_with_wildcard)?\"*\":\"\");\n\t\tif (wild_card_string == NULL) return NULL;\n\n\t\tfor (i = 0; t->u.substring.chunks[i]; i++) {\n\t\t\twild_card_string = talloc_asprintf_append(wild_card_string, \"%s*\",\n\t\t\t\t\t\t\tt->u.substring.chunks[i]->data);\n\t\t\tif (wild_card_string == NULL) return NULL;\n\t\t}\n\n\t\tif ( ! t->u.substring.end_with_wildcard ) {\n\t\t\t/* remove last wildcard */\n\t\t\twild_card_string[strlen(wild_card_string) - 1] = '\\0';\n\t\t}\n\n\t\tattr = ldb_attr_casefold(mem_ctx, t->u.substring.attr);\n\t\tif (attr == NULL) return NULL;\n\t\ta = ldb_schema_attribute_by_name(ldb, attr);\n\n\t\tsubval.data = (void *)wild_card_string;\n\t\tsubval.length = strlen(wild_card_string) + 1;\n\n\t\t/* Get a canonicalised copy of the data */\n\t\ta->syntax->canonicalise_fn(ldb, mem_ctx, &(subval), &value);\n\t\tif (value.data == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn lsqlite3_tprintf(mem_ctx,\n\t\t\t\t\t\"SELECT eid FROM ldb_attribute_values \"\n\t\t\t\t\t\"WHERE norm_attr_name = '%q' \"\n\t\t\t\t\t\"AND norm_attr_value GLOB '%q'\",\n\t\t\t\t\tattr,\n\t\t\t\t\tvalue.data);\n\n\tcase LDB_OP_GREATER:\n\t\tattr = ldb_attr_casefold(mem_ctx, t->u.equality.attr);\n\t\tif (attr == NULL) return NULL;\n\t\ta = ldb_schema_attribute_by_name(ldb, attr);\n\n\t\t/* Get a canonicalised copy of the data */\n\t\ta->syntax->canonicalise_fn(ldb, mem_ctx, &(t->u.equality.value), &value);\n\t\tif (value.data == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn lsqlite3_tprintf(mem_ctx,\n\t\t\t\t\t\"SELECT eid FROM ldb_attribute_values \"\n\t\t\t\t\t\"WHERE norm_attr_name = '%q' \"\n\t\t\t\t\t\"AND ldap_compare(norm_attr_value, '>=', '%q', '%q') \",\n\t\t\t\t\tattr,\n\t\t\t\t\tvalue.data,\n\t\t\t\t\tattr);\n\n\tcase LDB_OP_LESS:\n\t\tattr = ldb_attr_casefold(mem_ctx, t->u.equality.attr);\n\t\tif (attr == NULL) return NULL;\n\t\ta = ldb_schema_attribute_by_name(ldb, attr);\n\n\t\t/* Get a canonicalised copy of the data */\n\t\ta->syntax->canonicalise_fn(ldb, mem_ctx, &(t->u.equality.value), &value);\n\t\tif (value.data == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn lsqlite3_tprintf(mem_ctx,\n\t\t\t\t\t\"SELECT eid FROM ldb_attribute_values \"\n\t\t\t\t\t\"WHERE norm_attr_name = '%q' \"\n\t\t\t\t\t\"AND ldap_compare(norm_attr_value, '<=', '%q', '%q') \",\n\t\t\t\t\tattr,\n\t\t\t\t\tvalue.data,\n\t\t\t\t\tattr);\n\n\tcase LDB_OP_PRESENT:\n\t\tif (strcasecmp(t->u.present.attr, \"dn\") == 0) {\n\t\t\treturn talloc_strdup(mem_ctx, \"SELECT eid FROM ldb_entry\");\n\t\t}\n\n\t\tattr = ldb_attr_casefold(mem_ctx, t->u.present.attr);\n\t\tif (attr == NULL) return NULL;\n\n\t\treturn lsqlite3_tprintf(mem_ctx,\n\t\t\t\t\t\"SELECT eid FROM ldb_attribute_values \"\n\t\t\t\t\t\"WHERE norm_attr_name = '%q' \",\n\t\t\t\t\tattr);\n\n\tcase LDB_OP_APPROX:\n\t\tattr = ldb_attr_casefold(mem_ctx, t->u.equality.attr);\n\t\tif (attr == NULL) return NULL;\n\t\ta = ldb_schema_attribute_by_name(ldb, attr);\n\n\t\t/* Get a canonicalised copy of the data */\n\t\ta->syntax->canonicalise_fn(ldb, mem_ctx, &(t->u.equality.value), &value);\n\t\tif (value.data == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn lsqlite3_tprintf(mem_ctx,\n\t\t\t\t\t\"SELECT eid FROM ldb_attribute_values \"\n\t\t\t\t\t\"WHERE norm_attr_name = '%q' \"\n\t\t\t\t\t\"AND ldap_compare(norm_attr_value, '~%', 'q', '%q') \",\n\t\t\t\t\tattr,\n\t\t\t\t\tvalue.data,\n\t\t\t\t\tattr);\n\n\tcase LDB_OP_EXTENDED:\n#warning  \"work out how to handle bitops\"\n\t\treturn NULL;\n\n\tdefault:\n\t\tbreak;\n\t};\n\n\t/* should never occur */\n\tabort();\n\treturn NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146368,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static char *parsetree_to_sql(struct ldb_module *module,\n\t\t\t      void *mem_ctx,\n\t\t\t      const struct ldb_parse_tree *t)\n{\n\tstruct ldb_context *ldb;\n\tconst struct ldb_schema_attribute *a;\n\tstruct ldb_val value, subval;\n\tchar *wild_card_string;\n\tchar *child, *tmp;\n\tchar *ret = NULL;\n\tchar *attr;\n\tunsigned int i;\n\n\tldb = ldb_module_get_ctx(module);\n\n\tswitch(t->operation) {\n\tcase LDB_OP_AND:\n\n\t\ttmp = parsetree_to_sql(module, mem_ctx, t->u.list.elements[0]);\n\t\tif (tmp == NULL) return NULL;\n\n\t\tfor (i = 1; i < t->u.list.num_elements; i++) {\n\n\t\t\tchild = parsetree_to_sql(module, mem_ctx, t->u.list.elements[i]);\n\t\t\tif (child == NULL) return NULL;\n\n\t\t\ttmp = talloc_asprintf_append(tmp, \" INTERSECT %s \", child);\n\t\t\tif (tmp == NULL) return NULL;\n\t\t}\n\n\t\tret = talloc_asprintf(mem_ctx, \"SELECT * FROM ( %s )\\n\", tmp);\n\n\t\treturn ret;\n\n\tcase LDB_OP_OR:\n\n\t\ttmp = parsetree_to_sql(module, mem_ctx, t->u.list.elements[0]);\n\t\tif (tmp == NULL) return NULL;\n\n\t\tfor (i = 1; i < t->u.list.num_elements; i++) {\n\n\t\t\tchild = parsetree_to_sql(module, mem_ctx, t->u.list.elements[i]);\n\t\t\tif (child == NULL) return NULL;\n\n\t\t\ttmp = talloc_asprintf_append(tmp, \" UNION %s \", child);\n\t\t\tif (tmp == NULL) return NULL;\n\t\t}\n\n\t\treturn talloc_asprintf(mem_ctx, \"SELECT * FROM ( %s ) \", tmp);\n\n\tcase LDB_OP_NOT:\n\n\t\tchild = parsetree_to_sql(module, mem_ctx, t->u.isnot.child);\n\t\tif (child == NULL) return NULL;\n\n\t\treturn talloc_asprintf(mem_ctx,\n\t\t\t\t\t\"SELECT eid FROM ldb_entry \"\n\t\t\t\t\t\"WHERE eid NOT IN ( %s ) \", child);\n\n\tcase LDB_OP_EQUALITY:\n\t\t/*\n\t\t * For simple searches, we want to retrieve the list of EIDs that\n\t\t * match the criteria.\n\t\t*/\n\t\tattr = ldb_attr_casefold(mem_ctx, t->u.equality.attr);\n\t\tif (attr == NULL) return NULL;\n\t\ta = ldb_schema_attribute_by_name(ldb, attr);\n\n\t\t/* Get a canonicalised copy of the data */\n\t\ta->syntax->canonicalise_fn(ldb, mem_ctx, &(t->u.equality.value), &value);\n\t\tif (value.data == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (strcasecmp(t->u.equality.attr, \"dn\") == 0) {\n\t\t\t/* DN query is a special ldb case */\n\t\t \tconst char *cdn = ldb_dn_get_casefold(\n\t\t\t\t\t\tldb_dn_new(mem_ctx, ldb,\n\t\t\t\t\t\t\t      (const char *)value.data));\n\t\t\tif (cdn == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\treturn lsqlite3_tprintf(mem_ctx,\n\t\t\t\t\t\t\"SELECT eid FROM ldb_entry \"\n\t\t\t\t\t\t\"WHERE norm_dn = '%q'\", cdn);\n\n\t\t} else {\n\t\t\t/* A normal query. */\n\t\t\treturn lsqlite3_tprintf(mem_ctx,\n\t\t\t\t\t\t\"SELECT eid FROM ldb_attribute_values \"\n\t\t\t\t\t\t\"WHERE norm_attr_name = '%q' \"\n\t\t\t\t\t\t\"AND norm_attr_value = '%q'\",\n\t\t\t\t\t\tattr,\n\t\t\t\t\t\tvalue.data);\n\n\t\t}\n\n\tcase LDB_OP_SUBSTRING:\n\n\t\twild_card_string = talloc_strdup(mem_ctx,\n\t\t\t\t\t(t->u.substring.start_with_wildcard)?\"*\":\"\");\n\t\tif (wild_card_string == NULL) return NULL;\n\n\t\tfor (i = 0; t->u.substring.chunks[i]; i++) {\n\t\t\twild_card_string = talloc_asprintf_append(wild_card_string, \"%s*\",\n\t\t\t\t\t\t\tt->u.substring.chunks[i]->data);\n\t\t\tif (wild_card_string == NULL) return NULL;\n\t\t}\n\n\t\tif ( ! t->u.substring.end_with_wildcard ) {\n\t\t\t/* remove last wildcard */\n\t\t\twild_card_string[strlen(wild_card_string) - 1] = '\\0';\n\t\t}\n\n\t\tattr = ldb_attr_casefold(mem_ctx, t->u.substring.attr);\n\t\tif (attr == NULL) return NULL;\n\t\ta = ldb_schema_attribute_by_name(ldb, attr);\n\n\t\tsubval.data = (void *)wild_card_string;\n\t\tsubval.length = strlen(wild_card_string) + 1;\n\n\t\t/* Get a canonicalised copy of the data */\n\t\ta->syntax->canonicalise_fn(ldb, mem_ctx, &(subval), &value);\n\t\tif (value.data == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn lsqlite3_tprintf(mem_ctx,\n\t\t\t\t\t\"SELECT eid FROM ldb_attribute_values \"\n\t\t\t\t\t\"WHERE norm_attr_name = '%q' \"\n\t\t\t\t\t\"AND norm_attr_value GLOB '%q'\",\n\t\t\t\t\tattr,\n\t\t\t\t\tvalue.data);\n\n\tcase LDB_OP_GREATER:\n\t\tattr = ldb_attr_casefold(mem_ctx, t->u.equality.attr);\n\t\tif (attr == NULL) return NULL;\n\t\ta = ldb_schema_attribute_by_name(ldb, attr);\n\n\t\t/* Get a canonicalised copy of the data */\n\t\ta->syntax->canonicalise_fn(ldb, mem_ctx, &(t->u.equality.value), &value);\n\t\tif (value.data == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn lsqlite3_tprintf(mem_ctx,\n\t\t\t\t\t\"SELECT eid FROM ldb_attribute_values \"\n\t\t\t\t\t\"WHERE norm_attr_name = '%q' \"\n\t\t\t\t\t\"AND ldap_compare(norm_attr_value, '>=', '%q', '%q') \",\n\t\t\t\t\tattr,\n\t\t\t\t\tvalue.data,\n\t\t\t\t\tattr);\n\n\tcase LDB_OP_LESS:\n\t\tattr = ldb_attr_casefold(mem_ctx, t->u.equality.attr);\n\t\tif (attr == NULL) return NULL;\n\t\ta = ldb_schema_attribute_by_name(ldb, attr);\n\n\t\t/* Get a canonicalised copy of the data */\n\t\ta->syntax->canonicalise_fn(ldb, mem_ctx, &(t->u.equality.value), &value);\n\t\tif (value.data == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn lsqlite3_tprintf(mem_ctx,\n\t\t\t\t\t\"SELECT eid FROM ldb_attribute_values \"\n\t\t\t\t\t\"WHERE norm_attr_name = '%q' \"\n\t\t\t\t\t\"AND ldap_compare(norm_attr_value, '<=', '%q', '%q') \",\n\t\t\t\t\tattr,\n\t\t\t\t\tvalue.data,\n\t\t\t\t\tattr);\n\n\tcase LDB_OP_PRESENT:\n\t\tif (strcasecmp(t->u.present.attr, \"dn\") == 0) {\n\t\t\treturn talloc_strdup(mem_ctx, \"SELECT eid FROM ldb_entry\");\n\t\t}\n\n\t\tattr = ldb_attr_casefold(mem_ctx, t->u.present.attr);\n\t\tif (attr == NULL) return NULL;\n\n\t\treturn lsqlite3_tprintf(mem_ctx,\n\t\t\t\t\t\"SELECT eid FROM ldb_attribute_values \"\n\t\t\t\t\t\"WHERE norm_attr_name = '%q' \",\n\t\t\t\t\tattr);\n\n\tcase LDB_OP_APPROX:\n\t\tattr = ldb_attr_casefold(mem_ctx, t->u.equality.attr);\n\t\tif (attr == NULL) return NULL;\n\t\ta = ldb_schema_attribute_by_name(ldb, attr);\n\n\t\t/* Get a canonicalised copy of the data */\n\t\ta->syntax->canonicalise_fn(ldb, mem_ctx, &(t->u.equality.value), &value);\n\t\tif (value.data == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn lsqlite3_tprintf(mem_ctx,\n\t\t\t\t\t\"SELECT eid FROM ldb_attribute_values \"\n\t\t\t\t\t\"WHERE norm_attr_name = '%q' \"\n\t\t\t\t\t\"AND ldap_compare(norm_attr_value, '~%', 'q', '%q') \",\n\t\t\t\t\tattr,\n\t\t\t\t\tvalue.data,\n\t\t\t\t\tattr);\n\n\tcase LDB_OP_EXTENDED:\n#warning  \"work out how to handle bitops\"\n\t\treturn NULL;\n\n\tdefault:\n\t\tbreak;\n\t};\n\n\t/* should never occur */\n\tabort();\n\treturn NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146369,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int cloop_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVCloopState *s = bs->opaque;\n    uint32_t offsets_size, max_compressed_block_size = 1, i;\n    int ret;\n\n    bs->read_only = 1;\n\n    /* read header */\n    ret = bdrv_pread(bs->file, 128, &s->block_size, 4);\n    if (ret < 0) {\n        return ret;\n    }\n    s->block_size = be32_to_cpu(s->block_size);\n\n    ret = bdrv_pread(bs->file, 128 + 4, &s->n_blocks, 4);\n    if (ret < 0) {\n        return ret;\n    }\n    s->n_blocks = be32_to_cpu(s->n_blocks);\n\n    /* read offsets */\n    offsets_size = s->n_blocks * sizeof(uint64_t);\n    s->offsets = g_malloc(offsets_size);\n\n    ret = bdrv_pread(bs->file, 128 + 4 + 4, s->offsets, offsets_size);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    for(i=0;i<s->n_blocks;i++) {\n        s->offsets[i] = be64_to_cpu(s->offsets[i]);\n        if (i > 0) {\n            uint32_t size = s->offsets[i] - s->offsets[i - 1];\n            if (size > max_compressed_block_size) {\n                max_compressed_block_size = size;\n            }\n        }\n    }\n\n    /* initialize zlib engine */\n    s->compressed_block = g_malloc(max_compressed_block_size + 1);\n    s->uncompressed_block = g_malloc(s->block_size);\n    if (inflateInit(&s->zstream) != Z_OK) {\n        ret = -EINVAL;\n        goto fail;\n    }\n    s->current_block = s->n_blocks;\n\n    s->sectors_per_block = s->block_size/512;\n    bs->total_sectors = s->n_blocks * s->sectors_per_block;\n    qemu_co_mutex_init(&s->lock);\n    return 0;\n\nfail:\n    g_free(s->offsets);\n    g_free(s->compressed_block);\n    g_free(s->uncompressed_block);\n    return ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146370,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int cloop_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVCloopState *s = bs->opaque;\n    uint32_t offsets_size, max_compressed_block_size = 1, i;\n    int ret;\n\n    bs->read_only = 1;\n\n    /* read header */\n    ret = bdrv_pread(bs->file, 128, &s->block_size, 4);\n    if (ret < 0) {\n        return ret;\n    }\n    s->block_size = be32_to_cpu(s->block_size);\n    if (s->block_size % 512) {\n        error_setg(errp, \"block_size %u must be a multiple of 512\",\n                   s->block_size);\n        return -EINVAL;\n    }\n    if (s->block_size == 0) {\n        error_setg(errp, \"block_size cannot be zero\");\n        return -EINVAL;\n    }\n\n    /* cloop's create_compressed_fs.c warns about block sizes beyond 256 KB but\n     * we can accept more.  Prevent ridiculous values like 4 GB - 1 since we\n     * need a buffer this big.\n     */\n    if (s->block_size > MAX_BLOCK_SIZE) {\n        error_setg(errp, \"block_size %u must be %u MB or less\",\n                   s->block_size,\n                   MAX_BLOCK_SIZE / (1024 * 1024));\n        return -EINVAL;\n    }\n\n    ret = bdrv_pread(bs->file, 128 + 4, &s->n_blocks, 4);\n    if (ret < 0) {\n        return ret;\n    }\n    s->n_blocks = be32_to_cpu(s->n_blocks);\n\n    /* read offsets */\n    offsets_size = s->n_blocks * sizeof(uint64_t);\n    s->offsets = g_malloc(offsets_size);\n\n    ret = bdrv_pread(bs->file, 128 + 4 + 4, s->offsets, offsets_size);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    for(i=0;i<s->n_blocks;i++) {\n        s->offsets[i] = be64_to_cpu(s->offsets[i]);\n        if (i > 0) {\n            uint32_t size = s->offsets[i] - s->offsets[i - 1];\n            if (size > max_compressed_block_size) {\n                max_compressed_block_size = size;\n            }\n        }\n    }\n\n    /* initialize zlib engine */\n    s->compressed_block = g_malloc(max_compressed_block_size + 1);\n    s->uncompressed_block = g_malloc(s->block_size);\n    if (inflateInit(&s->zstream) != Z_OK) {\n        ret = -EINVAL;\n        goto fail;\n    }\n    s->current_block = s->n_blocks;\n\n    s->sectors_per_block = s->block_size/512;\n    bs->total_sectors = s->n_blocks * s->sectors_per_block;\n    qemu_co_mutex_init(&s->lock);\n    return 0;\n\nfail:\n    g_free(s->offsets);\n    g_free(s->compressed_block);\n    g_free(s->uncompressed_block);\n    return ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146371,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_type_t type;\n    pb_decoder_t func;\n    \n    type = iter->pos->type;\n    func = PB_DECODERS[PB_LTYPE(type)];\n\n    switch (PB_HTYPE(type))\n    {\n        case PB_HTYPE_REQUIRED:\n            return func(stream, iter->pos, iter->pData);\n            \n        case PB_HTYPE_OPTIONAL:\n            if (iter->pSize != iter->pData)\n                *(bool*)iter->pSize = true;\n            return func(stream, iter->pos, iter->pData);\n    \n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                /* Packed array */\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n\n                pb_istream_t substream;\n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n\n                while (substream.bytes_left > 0 && *size < iter->pos->array_size)\n                {\n                    void *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                    if (!func(&substream, iter->pos, pItem))\n                    {\n                        status = false;\n                        break;\n                    }\n                    (*size)++;\n                }\n\n                if (substream.bytes_left != 0)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n\n                return status;\n            }\n            else\n            {\n                /* Repeated field */\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                char *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n\n                if ((*size)++ >= iter->pos->array_size)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n\n                return func(stream, iter->pos, pItem);\n            }\n\n        case PB_HTYPE_ONEOF:\n            *(pb_size_t*)iter->pSize = iter->pos->tag;\n            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE)\n            {\n                /* We memset to zero so that any callbacks are set to NULL.\n                 * Then set any default values. */\n                memset(iter->pData, 0, iter->pos->data_size);\n                pb_message_set_to_defaults((const pb_field_t*)iter->pos->ptr, iter->pData);\n            }\n            return func(stream, iter->pos, iter->pData);\n\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146392,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_type_t type;\n    pb_decoder_t func;\n    \n    type = iter->pos->type;\n    func = PB_DECODERS[PB_LTYPE(type)];\n\n    switch (PB_HTYPE(type))\n    {\n        case PB_HTYPE_REQUIRED:\n            return func(stream, iter->pos, iter->pData);\n            \n        case PB_HTYPE_OPTIONAL:\n            if (iter->pSize != iter->pData)\n                *(bool*)iter->pSize = true;\n            return func(stream, iter->pos, iter->pData);\n    \n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                /* Packed array */\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n\n                pb_istream_t substream;\n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n\n                while (substream.bytes_left > 0 && *size < iter->pos->array_size)\n                {\n                    void *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                    if (!func(&substream, iter->pos, pItem))\n                    {\n                        status = false;\n                        break;\n                    }\n                    (*size)++;\n                }\n\n                if (substream.bytes_left != 0)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n\n                return status;\n            }\n            else\n            {\n                /* Repeated field */\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                char *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n\n                if ((*size)++ >= iter->pos->array_size)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n\n                return func(stream, iter->pos, pItem);\n            }\n\n        case PB_HTYPE_ONEOF:\n            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE &&\n                *(pb_size_t*)iter->pSize != iter->pos->tag)\n            {\n                /* We memset to zero so that any callbacks are set to NULL.\n                 * This is because the callbacks might otherwise have values\n                 * from some other union field. */\n                memset(iter->pData, 0, iter->pos->data_size);\n                pb_message_set_to_defaults((const pb_field_t*)iter->pos->ptr, iter->pData);\n            }\n            *(pb_size_t*)iter->pSize = iter->pos->tag;\n\n            return func(stream, iter->pos, iter->pData);\n\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146393,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "email_open( const char *email_addr, const char *subject )\n{\n\tchar *Mailer;\n\tchar *SmtpServer = NULL;\n\tchar *FromAddress = NULL;\n\tchar *FinalSubject;\n\tchar *FinalAddr;\n\tchar *temp;\n\tint token_boundary;\n\tint num_addresses;\n\tint arg_index;\n\tFILE *mailerstream;\n\n\tif ( (Mailer = param(\"MAIL\")) == NULL ) {\n\t\tdprintf(D_FULLDEBUG,\n\t\t\t\"Trying to email, but MAIL not specified in config file\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* Take care of the subject. */\n\tif ( subject ) {\n\t\tsize_t prolog_length = strlen(EMAIL_SUBJECT_PROLOG);\n\t\tsize_t subject_length = strlen(subject);\n\t\tFinalSubject = (char *)malloc(prolog_length + subject_length + 1);\n\t\tASSERT( FinalSubject != NULL );\n\t\tmemcpy(FinalSubject, EMAIL_SUBJECT_PROLOG, prolog_length);\n\t\tmemcpy(&FinalSubject[prolog_length], subject, subject_length);\n\t\tFinalSubject[prolog_length + subject_length] = '\\0';\n\t}\n\telse {\n\t\tFinalSubject = strdup(EMAIL_SUBJECT_PROLOG);\n\t}\n\n\t/** The following will not cause a fatal error, it just means\n\t\tthat on Windows we may construct an invalid \"from\" address. */\n\tFromAddress = param(\"MAIL_FROM\");\n\t\n#ifdef WIN32\n\t/* On WinNT, we need to be given an SMTP server, and we must pass\n\t * this servername to the Mailer with a -relay option.\n\t */\n\tif ( (SmtpServer=param(\"SMTP_SERVER\")) == NULL ) {\n\t\tdprintf(D_FULLDEBUG,\n\t\t\t\"Trying to email, but SMTP_SERVER not specified in config file\\n\");\n\t\tfree(Mailer);\n\t\tfree(FinalSubject);\n\t\tif (FromAddress) free(FromAddress);\n\t\treturn NULL;\n\t}\n#endif \t\n\n\t/* Take care of destination email address.  If it is NULL, grab \n\t * the email of the Condor admin from the config file.\n\t * We strdup this since we modify it (we split it into tokens so that\n\t * each address is a separate argument to the mailer).\n\t */\n\tif ( email_addr ) {\n\t\tFinalAddr = strdup(email_addr);\n\t} else {\n\t\tif ( (FinalAddr = param(\"CONDOR_ADMIN\")) == NULL ) {\n\t\t\tdprintf(D_FULLDEBUG,\n\t\t\t\t\"Trying to email, but CONDOR_ADMIN not specified in config file\\n\");\n\t\t\tfree(Mailer);\n\t\t\tfree(FinalSubject);\n\t\t\tif (FromAddress) free(FromAddress);\n\t\t\tif (SmtpServer) free(SmtpServer);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* Now tokenize the list of addresses on commas and/or spaces (by replacing\n\t * commas and spaces with nils). We also count the addresses here so we\n\t * know how large to make our argument vector\n\t */\n\ttoken_boundary = TRUE;\n\tnum_addresses = 0;\n\tfor (temp = FinalAddr; *temp != '\\0'; temp++) {\n\t\tif (*temp == ',' || *temp == ' ') {\n\t\t\t*temp = '\\0';\n\t\t\ttoken_boundary = TRUE;\n\t\t}\n\t\telse if (token_boundary) {\n\t\t\tnum_addresses++;\n\t\t\ttoken_boundary = FALSE;\n\t\t}\n\t}\n\tif (num_addresses == 0) {\n\t\tdprintf(D_FULLDEBUG, \"Trying to email, but address list is empty\\n\");\n\t\tfree(Mailer);\n\t\tfree(FinalSubject);\n\t\tif (FromAddress) free(FromAddress);\n\t\tif (SmtpServer) free(SmtpServer);\n\t\tfree(FinalAddr);\n\t\treturn NULL;\n\t}\n\n\t/* construct the argument vector for the mailer */\n\t//char const * const * final_args;\n\tconst char * * final_args;\n\tfinal_args = (char const * *)malloc((8 + num_addresses) * sizeof(char*));\n\tif (final_args == NULL) {\n\t\tEXCEPT(\"Out of memory\");\n\t}\n\targ_index = 0;\n\tfinal_args[arg_index++] = Mailer;\n\tfinal_args[arg_index++] = \"-s\";\n\tfinal_args[arg_index++] = FinalSubject;\n\tif (FromAddress) {\n\t\tfinal_args[arg_index++] = \"-f\";\n\t\tfinal_args[arg_index++] = FromAddress;\n\t}\n\tif (SmtpServer) {\n\t\tfinal_args[arg_index++] = \"-relay\";\n\t\tfinal_args[arg_index++] = SmtpServer;\n\t}\n\ttemp = FinalAddr;\n\tfor (;;) {\n\t\twhile (*temp == '\\0') temp++;\n\t\tfinal_args[arg_index++] = temp;\n\t\tif (--num_addresses == 0) break;\n\t\twhile (*temp != '\\0') temp++;\n\t}\n\tfinal_args[arg_index] = NULL;\n\n/* NEW CODE */\n\t/* open a FILE* so that the mail we get will end up from condor,\n\t\tand not from root */\n#ifdef WIN32\n\tmailerstream = email_open_implementation(Mailer, final_args);\n#else\n\tmailerstream = email_open_implementation(final_args);\n#endif\n\n\tif ( mailerstream ) {\n\t\tfprintf(mailerstream,\"This is an automated email from the Condor \"\n\t\t\t\"system\\non machine \\\"%s\\\".  Do not reply.\\n\\n\",get_local_fqdn().Value());\n\t}\n\n\t/* free up everything we strdup-ed and param-ed, and return result */\n\tfree(Mailer);\n\tfree(FinalSubject);\n\tif (FromAddress) free(FromAddress);\n\tif (SmtpServer) free(SmtpServer);\n\tfree(FinalAddr);\n\tfree(final_args);\n\n\treturn mailerstream;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146456,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "email_open( const char *email_addr, const char *subject )\n{\n\tchar *Sendmail = NULL;\n\tchar *Mailer = NULL;\n\tchar *SmtpServer = NULL;\n\tchar *FromAddress = NULL;\n\tchar *FinalSubject;\n\tchar *FinalAddr;\n\tchar *temp;\n\tint token_boundary;\n\tint num_addresses;\n\tint arg_index;\n\tFILE *mailerstream;\n\n\t/* Take care of the subject. */\n\tif ( subject ) {\n\t\tsize_t prolog_length = strlen(EMAIL_SUBJECT_PROLOG);\n\t\tsize_t subject_length = strlen(subject);\n\t\tFinalSubject = (char *)malloc(prolog_length + subject_length + 1);\n\t\tASSERT( FinalSubject != NULL );\n\t\tmemcpy(FinalSubject, EMAIL_SUBJECT_PROLOG, prolog_length);\n\t\tmemcpy(&FinalSubject[prolog_length], subject, subject_length);\n\t\tFinalSubject[prolog_length + subject_length] = '\\0';\n\t}\n\telse {\n\t\tFinalSubject = strdup(EMAIL_SUBJECT_PROLOG);\n\t}\n\n\t/** The following will not cause a fatal error, it just means\n\t\tthat on Windows we may construct an invalid \"from\" address. */\n\tFromAddress = param(\"MAIL_FROM\");\n\t\n#ifdef WIN32\n\t/* On WinNT, we need to be given an SMTP server, and we must pass\n\t * this servername to the Mailer with a -relay option.\n\t */\n\tif ( (SmtpServer=param(\"SMTP_SERVER\")) == NULL ) {\n\t\tdprintf(D_FULLDEBUG,\n\t\t\t\"Trying to email, but SMTP_SERVER not specified in config file\\n\");\n\t\tfree(FinalSubject);\n\t\tif (FromAddress) free(FromAddress);\n\t\treturn NULL;\n\t}\n#endif \t\n\n\t/* Take care of destination email address.  If it is NULL, grab \n\t * the email of the Condor admin from the config file.\n\t * We strdup this since we modify it (we split it into tokens so that\n\t * each address is a separate argument to the mailer).\n\t */\n\tif ( email_addr ) {\n\t\tFinalAddr = strdup(email_addr);\n\t} else {\n\t\tif ( (FinalAddr = param(\"CONDOR_ADMIN\")) == NULL ) {\n\t\t\tdprintf(D_FULLDEBUG,\n\t\t\t\t\"Trying to email, but CONDOR_ADMIN not specified in config file\\n\");\n\t\t\tfree(FinalSubject);\n\t\t\tif (FromAddress) free(FromAddress);\n\t\t\tif (SmtpServer) free(SmtpServer);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* Now tokenize the list of addresses on commas and/or spaces (by replacing\n\t * commas and spaces with nils). We also count the addresses here so we\n\t * know how large to make our argument vector\n\t */\n\ttoken_boundary = TRUE;\n\tnum_addresses = 0;\n\tfor (temp = FinalAddr; *temp != '\\0'; temp++) {\n\t\tif (*temp == ',' || *temp == ' ') {\n\t\t\t*temp = '\\0';\n\t\t\ttoken_boundary = TRUE;\n\t\t}\n\t\telse if (token_boundary) {\n\t\t\tnum_addresses++;\n\t\t\ttoken_boundary = FALSE;\n\t\t}\n\t}\n\tif (num_addresses == 0) {\n\t\tdprintf(D_FULLDEBUG, \"Trying to email, but address list is empty\\n\");\n\t\tfree(FinalSubject);\n\t\tif (FromAddress) free(FromAddress);\n\t\tif (SmtpServer) free(SmtpServer);\n\t\tfree(FinalAddr);\n\t\treturn NULL;\n\t}\n\n\tSendmail = param(\"SENDMAIL\");\n\tMailer = param(\"MAIL\");\n\n\tif ( Mailer == NULL && Sendmail == NULL ) {\n\t\tdprintf(D_FULLDEBUG,\n\t\t\t\"Trying to email, but MAIL and SENDMAIL not specified in config file\\n\");\n\t\tfree(FinalSubject);\n\t\tfree(FromAddress);\n\t\tfree(SmtpServer);\n\t\tfree(FinalAddr);\n\t\treturn NULL;\n\t}\n\n\t/* construct the argument vector for the mailer */\n\t//char const * const * final_args;\n\tconst char * * final_args;\n\tfinal_args = (char const * *)malloc((8 + num_addresses) * sizeof(char*));\n\tif (final_args == NULL) {\n\t\tEXCEPT(\"Out of memory\");\n\t}\n\targ_index = 0;\n\tif (Sendmail != NULL) {\n\t\tfinal_args[arg_index++] = Sendmail;\n\t\t// Obtain addresses from the header.\n\t\tfinal_args[arg_index++] = \"-t\";\n\t\t// No special treatment of dot-starting lines.\n\t\tfinal_args[arg_index++] = \"-i\";\n\t} else {\n\t\tfinal_args[arg_index++] = Mailer;\n\t\tfinal_args[arg_index++] = \"-s\";\n\t\tfinal_args[arg_index++] = FinalSubject;\n\n\t\tif (FromAddress) {\n#ifdef WIN32\n\t\t\t// condor_mail.exe uses this flag\n\t\t\tfinal_args[arg_index++] = \"-f\";\n#else\n\t\t\t// modern mailx uses this flag\n\t\t\tfinal_args[arg_index++] = \"-r\";\n#endif\n\t\t\tfinal_args[arg_index++] = FromAddress;\n\t\t}\n\t\tif (SmtpServer) {\n\t\t\t// SmtpServer is only set on windows\n\t\t\t// condor_mail.exe uses this flag\n\t\t\tfinal_args[arg_index++] = \"-relay\";\n\t\t\tfinal_args[arg_index++] = SmtpServer;\n\t\t}\n\t\ttemp = FinalAddr;\n\t\tfor (;;) {\n\t\t\twhile (*temp == '\\0') temp++;\n\t\t\tfinal_args[arg_index++] = temp;\n\t\t\tif (--num_addresses == 0) break;\n\t\t\twhile (*temp != '\\0') temp++;\n\t\t}\n\t}\n\tfinal_args[arg_index] = NULL;\n\n/* NEW CODE */\n\t/* open a FILE* so that the mail we get will end up from condor,\n\t\tand not from root */\n#ifdef WIN32\n\tmailerstream = email_open_implementation(Mailer, final_args);\n#else\n\tmailerstream = email_open_implementation(final_args);\n#endif\n\n\tif ( mailerstream ) {\n\t\tif (Sendmail != NULL) {\n\t\t\temail_write_headers(mailerstream,\n\t\t\t\t\t    FromAddress,\n\t\t\t\t\t    FinalSubject,\n\t\t\t\t\t    FinalAddr,\n\t\t\t\t\t    num_addresses);\n\t\t}\n\n\t\tfprintf(mailerstream,\"This is an automated email from the Condor \"\n\t\t\t\"system\\non machine \\\"%s\\\".  Do not reply.\\n\\n\",get_local_fqdn().Value());\n\t}\n\n\t/* free up everything we strdup-ed and param-ed, and return result */\n\tfree(Sendmail);\n\tfree(Mailer);\n\tfree(FinalSubject);\n\tif (FromAddress) free(FromAddress);\n\tif (SmtpServer) free(SmtpServer);\n\tfree(FinalAddr);\n\tfree(final_args);\n\n\treturn mailerstream;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146457,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void vp8_deblock(VP8_COMMON *cm, YV12_BUFFER_CONFIG *source,\n                 YV12_BUFFER_CONFIG *post, int q, int low_var_thresh,\n                 int flag) {\n  double level = 6.0e-05 * q * q * q - .0067 * q * q + .306 * q + .0065;\n  int ppl = (int)(level + .5);\n\n  const MODE_INFO *mode_info_context = cm->show_frame_mi;\n  int mbr, mbc;\n\n  /* The pixel thresholds are adjusted according to if or not the macroblock\n   * is a skipped block.  */\n  unsigned char *ylimits = cm->pp_limits_buffer;\n  unsigned char *uvlimits = cm->pp_limits_buffer + 16 * cm->mb_cols;\n  (void)low_var_thresh;\n  (void)flag;\n\n  if (ppl > 0) {\n    for (mbr = 0; mbr < cm->mb_rows; ++mbr) {\n      unsigned char *ylptr = ylimits;\n      unsigned char *uvlptr = uvlimits;\n      for (mbc = 0; mbc < cm->mb_cols; ++mbc) {\n        unsigned char mb_ppl;\n\n        if (mode_info_context->mbmi.mb_skip_coeff) {\n          mb_ppl = (unsigned char)ppl >> 1;\n        } else {\n          mb_ppl = (unsigned char)ppl;\n        }\n\n        memset(ylptr, mb_ppl, 16);\n        memset(uvlptr, mb_ppl, 8);\n\n        ylptr += 16;\n        uvlptr += 8;\n        mode_info_context++;\n      }\n      mode_info_context++;\n\n      vpx_post_proc_down_and_across_mb_row(\n          source->y_buffer + 16 * mbr * source->y_stride,\n          post->y_buffer + 16 * mbr * post->y_stride, source->y_stride,\n          post->y_stride, source->y_width, ylimits, 16);\n\n      vpx_post_proc_down_and_across_mb_row(\n          source->u_buffer + 8 * mbr * source->uv_stride,\n          post->u_buffer + 8 * mbr * post->uv_stride, source->uv_stride,\n          post->uv_stride, source->uv_width, uvlimits, 8);\n      vpx_post_proc_down_and_across_mb_row(\n          source->v_buffer + 8 * mbr * source->uv_stride,\n          post->v_buffer + 8 * mbr * post->uv_stride, source->uv_stride,\n          post->uv_stride, source->uv_width, uvlimits, 8);\n    }\n  } else {\n    vp8_yv12_copy_frame(source, post);\n  }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146508,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void vp8_deblock(VP8_COMMON *cm, YV12_BUFFER_CONFIG *source,\n                 YV12_BUFFER_CONFIG *post, int q, int low_var_thresh,\n                 int flag) {\n  double level = 6.0e-05 * q * q * q - .0067 * q * q + .306 * q + .0065;\n  int ppl = (int)(level + .5);\n\n  const MODE_INFO *mode_info_context = cm->mi;\n  int mbr, mbc;\n\n  /* The pixel thresholds are adjusted according to if or not the macroblock\n   * is a skipped block.  */\n  unsigned char *ylimits = cm->pp_limits_buffer;\n  unsigned char *uvlimits = cm->pp_limits_buffer + 16 * cm->mb_cols;\n  (void)low_var_thresh;\n  (void)flag;\n\n  if (ppl > 0) {\n    for (mbr = 0; mbr < cm->mb_rows; ++mbr) {\n      unsigned char *ylptr = ylimits;\n      unsigned char *uvlptr = uvlimits;\n      for (mbc = 0; mbc < cm->mb_cols; ++mbc) {\n        unsigned char mb_ppl;\n\n        if (mode_info_context->mbmi.mb_skip_coeff) {\n          mb_ppl = (unsigned char)ppl >> 1;\n        } else {\n          mb_ppl = (unsigned char)ppl;\n        }\n\n        memset(ylptr, mb_ppl, 16);\n        memset(uvlptr, mb_ppl, 8);\n\n        ylptr += 16;\n        uvlptr += 8;\n        mode_info_context++;\n      }\n      mode_info_context++;\n\n      vpx_post_proc_down_and_across_mb_row(\n          source->y_buffer + 16 * mbr * source->y_stride,\n          post->y_buffer + 16 * mbr * post->y_stride, source->y_stride,\n          post->y_stride, source->y_width, ylimits, 16);\n\n      vpx_post_proc_down_and_across_mb_row(\n          source->u_buffer + 8 * mbr * source->uv_stride,\n          post->u_buffer + 8 * mbr * post->uv_stride, source->uv_stride,\n          post->uv_stride, source->uv_width, uvlimits, 8);\n      vpx_post_proc_down_and_across_mb_row(\n          source->v_buffer + 8 * mbr * source->uv_stride,\n          post->v_buffer + 8 * mbr * post->uv_stride, source->uv_stride,\n          post->uv_stride, source->uv_width, uvlimits, 8);\n    }\n  } else {\n    vp8_yv12_copy_frame(source, post);\n  }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146509,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int intel_vgpu_mmap(struct mdev_device *mdev, struct vm_area_struct *vma)\n{\n\tunsigned int index;\n\tu64 virtaddr;\n\tunsigned long req_size, pgoff = 0;\n\tpgprot_t pg_prot;\n\tstruct intel_vgpu *vgpu = mdev_get_drvdata(mdev);\n\n\tindex = vma->vm_pgoff >> (VFIO_PCI_OFFSET_SHIFT - PAGE_SHIFT);\n\tif (index >= VFIO_PCI_ROM_REGION_INDEX)\n\t\treturn -EINVAL;\n\n\tif (vma->vm_end < vma->vm_start)\n\t\treturn -EINVAL;\n\tif ((vma->vm_flags & VM_SHARED) == 0)\n\t\treturn -EINVAL;\n\tif (index != VFIO_PCI_BAR2_REGION_INDEX)\n\t\treturn -EINVAL;\n\n\tpg_prot = vma->vm_page_prot;\n\tvirtaddr = vma->vm_start;\n\treq_size = vma->vm_end - vma->vm_start;\n\tpgoff = vgpu_aperture_pa_base(vgpu) >> PAGE_SHIFT;\n\n\treturn remap_pfn_range(vma, virtaddr, pgoff, req_size, pg_prot);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146518,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int intel_vgpu_mmap(struct mdev_device *mdev, struct vm_area_struct *vma)\n{\n\tunsigned int index;\n\tu64 virtaddr;\n\tunsigned long req_size, pgoff, req_start;\n\tpgprot_t pg_prot;\n\tstruct intel_vgpu *vgpu = mdev_get_drvdata(mdev);\n\n\tindex = vma->vm_pgoff >> (VFIO_PCI_OFFSET_SHIFT - PAGE_SHIFT);\n\tif (index >= VFIO_PCI_ROM_REGION_INDEX)\n\t\treturn -EINVAL;\n\n\tif (vma->vm_end < vma->vm_start)\n\t\treturn -EINVAL;\n\tif ((vma->vm_flags & VM_SHARED) == 0)\n\t\treturn -EINVAL;\n\tif (index != VFIO_PCI_BAR2_REGION_INDEX)\n\t\treturn -EINVAL;\n\n\tpg_prot = vma->vm_page_prot;\n\tvirtaddr = vma->vm_start;\n\treq_size = vma->vm_end - vma->vm_start;\n\tpgoff = vma->vm_pgoff &\n\t\t((1U << (VFIO_PCI_OFFSET_SHIFT - PAGE_SHIFT)) - 1);\n\treq_start = pgoff << PAGE_SHIFT;\n\n\tif (!intel_vgpu_in_aperture(vgpu, req_start))\n\t\treturn -EINVAL;\n\tif (req_start + req_size >\n\t    vgpu_aperture_offset(vgpu) + vgpu_aperture_sz(vgpu))\n\t\treturn -EINVAL;\n\n\tpgoff = (gvt_aperture_pa_base(vgpu->gvt) >> PAGE_SHIFT) + pgoff;\n\n\treturn remap_pfn_range(vma, virtaddr, pgoff, req_size, pg_prot);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146519,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void cmd_parse_status (IMAP_DATA* idata, char* s)\n{\n  char* mailbox;\n  char* value;\n  BUFFY* inc;\n  IMAP_MBOX mx;\n  unsigned long ulcount;\n  unsigned int count;\n  IMAP_STATUS *status;\n  unsigned int olduv, oldun;\n  unsigned int litlen;\n  short new = 0;\n  short new_msg_count = 0;\n\n  mailbox = imap_next_word (s);\n\n  /* We need a real tokenizer. */\n  if (!imap_get_literal_count (mailbox, &litlen))\n  {\n    if (imap_cmd_step (idata) != IMAP_CMD_CONTINUE)\n    {\n      idata->status = IMAP_FATAL;\n      return;\n    }\n    mailbox = idata->buf;\n    s = mailbox + litlen;\n    *s = '\\0';\n    s++;\n    SKIPWS(s);\n  }\n  else\n  {\n    s = imap_next_word (mailbox);\n    *(s - 1) = '\\0';\n    imap_unmunge_mbox_name (idata, mailbox);\n  }\n\n  status = imap_mboxcache_get (idata, mailbox, 1);\n  olduv = status->uidvalidity;\n  oldun = status->uidnext;\n\n  if (*s++ != '(')\n  {\n    dprint (1, (debugfile, \"Error parsing STATUS\\n\"));\n    return;\n  }\n  while (*s && *s != ')')\n  {\n    value = imap_next_word (s);\n\n    errno = 0;\n    ulcount = strtoul (value, &value, 10);\n    if ((errno == ERANGE && ulcount == ULONG_MAX) ||\n        ((unsigned int) ulcount != ulcount))\n    {\n      dprint (1, (debugfile, \"Error parsing STATUS number\\n\"));\n      return;\n    }\n    count = (unsigned int) ulcount;\n\n    if (!ascii_strncmp (\"MESSAGES\", s, 8))\n    {\n      status->messages = count;\n      new_msg_count = 1;\n    }\n    else if (!ascii_strncmp (\"RECENT\", s, 6))\n      status->recent = count;\n    else if (!ascii_strncmp (\"UIDNEXT\", s, 7))\n      status->uidnext = count;\n    else if (!ascii_strncmp (\"UIDVALIDITY\", s, 11))\n      status->uidvalidity = count;\n    else if (!ascii_strncmp (\"UNSEEN\", s, 6))\n      status->unseen = count;\n\n    s = value;\n    if (*s && *s != ')')\n      s = imap_next_word (s);\n  }\n  dprint (3, (debugfile, \"%s (UIDVALIDITY: %u, UIDNEXT: %u) %d messages, %d recent, %d unseen\\n\",\n              status->name, status->uidvalidity, status->uidnext,\n              status->messages, status->recent, status->unseen));\n\n  /* caller is prepared to handle the result herself */\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_STATUS)\n  {\n    memcpy (idata->cmddata, status, sizeof (IMAP_STATUS));\n    return;\n  }\n\n  dprint (3, (debugfile, \"Running default STATUS handler\\n\"));\n\n  /* should perhaps move this code back to imap_buffy_check */\n  for (inc = Incoming; inc; inc = inc->next)\n  {\n    if (inc->magic != MUTT_IMAP)\n      continue;\n    \n    if (imap_parse_path (inc->path, &mx) < 0)\n    {\n      dprint (1, (debugfile, \"Error parsing mailbox %s, skipping\\n\", inc->path));\n      continue;\n    }\n    /* dprint (2, (debugfile, \"Buffy entry: [%s] mbox: [%s]\\n\", inc->path, NONULL(mx.mbox))); */\n    \n    if (imap_account_match (&idata->conn->account, &mx.account))\n    {\n      if (mx.mbox)\n      {\n\tvalue = safe_strdup (mx.mbox);\n\timap_fix_path (idata, mx.mbox, value, mutt_strlen (value) + 1);\n\tFREE (&mx.mbox);\n      }\n      else\n\tvalue = safe_strdup (\"INBOX\");\n\n      if (value && !imap_mxcmp (mailbox, value))\n      {\n        dprint (3, (debugfile, \"Found %s in buffy list (OV: %u ON: %u U: %d)\\n\",\n                    mailbox, olduv, oldun, status->unseen));\n        \n\tif (option(OPTMAILCHECKRECENT))\n\t{\n\t  if (olduv && olduv == status->uidvalidity)\n\t  {\n\t    if (oldun < status->uidnext)\n\t      new = (status->unseen > 0);\n\t  }\n\t  else if (!olduv && !oldun)\n\t    /* first check per session, use recent. might need a flag for this. */\n\t    new = (status->recent > 0);\n\t  else\n\t    new = (status->unseen > 0);\n\t}\n\telse\n          new = (status->unseen > 0);\n\n#ifdef USE_SIDEBAR\n        if ((inc->new != new) ||\n            (inc->msg_count != status->messages) ||\n            (inc->msg_unread != status->unseen))\n          mutt_set_current_menu_redraw (REDRAW_SIDEBAR);\n#endif\n        inc->new = new;\n        if (new_msg_count)\n          inc->msg_count = status->messages;\n        inc->msg_unread = status->unseen;\n\n\tif (inc->new)\n\t  /* force back to keep detecting new mail until the mailbox is\n\t     opened */\n\t  status->uidnext = oldun;\n\n        FREE (&value);\n        return;\n      }\n\n      FREE (&value);\n    }\n\n    FREE (&mx.mbox);\n  }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146568,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void cmd_parse_status (IMAP_DATA* idata, char* s)\n{\n  char* mailbox;\n  char* value;\n  BUFFY* inc;\n  IMAP_MBOX mx;\n  unsigned long ulcount;\n  unsigned int count;\n  IMAP_STATUS *status;\n  unsigned int olduv, oldun;\n  unsigned int litlen;\n  short new = 0;\n  short new_msg_count = 0;\n\n  mailbox = imap_next_word (s);\n\n  /* We need a real tokenizer. */\n  if (!imap_get_literal_count (mailbox, &litlen))\n  {\n    if (imap_cmd_step (idata) != IMAP_CMD_CONTINUE)\n    {\n      idata->status = IMAP_FATAL;\n      return;\n    }\n\n    if (strlen(idata->buf) < litlen)\n    {\n      dprint (1, (debugfile, \"Error parsing STATUS mailbox\\n\"));\n      return;\n    }\n\n    mailbox = idata->buf;\n    s = mailbox + litlen;\n    *s = '\\0';\n    s++;\n    SKIPWS(s);\n  }\n  else\n  {\n    s = imap_next_word (mailbox);\n    *(s - 1) = '\\0';\n    imap_unmunge_mbox_name (idata, mailbox);\n  }\n\n  status = imap_mboxcache_get (idata, mailbox, 1);\n  olduv = status->uidvalidity;\n  oldun = status->uidnext;\n\n  if (*s++ != '(')\n  {\n    dprint (1, (debugfile, \"Error parsing STATUS\\n\"));\n    return;\n  }\n  while (*s && *s != ')')\n  {\n    value = imap_next_word (s);\n\n    errno = 0;\n    ulcount = strtoul (value, &value, 10);\n    if ((errno == ERANGE && ulcount == ULONG_MAX) ||\n        ((unsigned int) ulcount != ulcount))\n    {\n      dprint (1, (debugfile, \"Error parsing STATUS number\\n\"));\n      return;\n    }\n    count = (unsigned int) ulcount;\n\n    if (!ascii_strncmp (\"MESSAGES\", s, 8))\n    {\n      status->messages = count;\n      new_msg_count = 1;\n    }\n    else if (!ascii_strncmp (\"RECENT\", s, 6))\n      status->recent = count;\n    else if (!ascii_strncmp (\"UIDNEXT\", s, 7))\n      status->uidnext = count;\n    else if (!ascii_strncmp (\"UIDVALIDITY\", s, 11))\n      status->uidvalidity = count;\n    else if (!ascii_strncmp (\"UNSEEN\", s, 6))\n      status->unseen = count;\n\n    s = value;\n    if (*s && *s != ')')\n      s = imap_next_word (s);\n  }\n  dprint (3, (debugfile, \"%s (UIDVALIDITY: %u, UIDNEXT: %u) %d messages, %d recent, %d unseen\\n\",\n              status->name, status->uidvalidity, status->uidnext,\n              status->messages, status->recent, status->unseen));\n\n  /* caller is prepared to handle the result herself */\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_STATUS)\n  {\n    memcpy (idata->cmddata, status, sizeof (IMAP_STATUS));\n    return;\n  }\n\n  dprint (3, (debugfile, \"Running default STATUS handler\\n\"));\n\n  /* should perhaps move this code back to imap_buffy_check */\n  for (inc = Incoming; inc; inc = inc->next)\n  {\n    if (inc->magic != MUTT_IMAP)\n      continue;\n    \n    if (imap_parse_path (inc->path, &mx) < 0)\n    {\n      dprint (1, (debugfile, \"Error parsing mailbox %s, skipping\\n\", inc->path));\n      continue;\n    }\n    /* dprint (2, (debugfile, \"Buffy entry: [%s] mbox: [%s]\\n\", inc->path, NONULL(mx.mbox))); */\n    \n    if (imap_account_match (&idata->conn->account, &mx.account))\n    {\n      if (mx.mbox)\n      {\n\tvalue = safe_strdup (mx.mbox);\n\timap_fix_path (idata, mx.mbox, value, mutt_strlen (value) + 1);\n\tFREE (&mx.mbox);\n      }\n      else\n\tvalue = safe_strdup (\"INBOX\");\n\n      if (value && !imap_mxcmp (mailbox, value))\n      {\n        dprint (3, (debugfile, \"Found %s in buffy list (OV: %u ON: %u U: %d)\\n\",\n                    mailbox, olduv, oldun, status->unseen));\n        \n\tif (option(OPTMAILCHECKRECENT))\n\t{\n\t  if (olduv && olduv == status->uidvalidity)\n\t  {\n\t    if (oldun < status->uidnext)\n\t      new = (status->unseen > 0);\n\t  }\n\t  else if (!olduv && !oldun)\n\t    /* first check per session, use recent. might need a flag for this. */\n\t    new = (status->recent > 0);\n\t  else\n\t    new = (status->unseen > 0);\n\t}\n\telse\n          new = (status->unseen > 0);\n\n#ifdef USE_SIDEBAR\n        if ((inc->new != new) ||\n            (inc->msg_count != status->messages) ||\n            (inc->msg_unread != status->unseen))\n          mutt_set_current_menu_redraw (REDRAW_SIDEBAR);\n#endif\n        inc->new = new;\n        if (new_msg_count)\n          inc->msg_count = status->messages;\n        inc->msg_unread = status->unseen;\n\n\tif (inc->new)\n\t  /* force back to keep detecting new mail until the mailbox is\n\t     opened */\n\t  status->uidnext = oldun;\n\n        FREE (&value);\n        return;\n      }\n\n      FREE (&value);\n    }\n\n    FREE (&mx.mbox);\n  }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146569,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "mbed_connect_step1(struct connectdata *conn,\n                   int sockindex)\n{\n  struct SessionHandle *data = conn->data;\n  struct ssl_connect_data* connssl = &conn->ssl[sockindex];\n\n  bool sni = TRUE; /* default is SNI enabled */\n  int ret = -1;\n#ifdef ENABLE_IPV6\n  struct in6_addr addr;\n#else\n  struct in_addr addr;\n#endif\n  void *old_session = NULL;\n  char errorbuf[128];\n  errorbuf[0]=0;\n\n  /* mbedTLS only supports SSLv3 and TLSv1 */\n  if(data->set.ssl.version == CURL_SSLVERSION_SSLv2) {\n    failf(data, \"mbedTLS does not support SSLv2\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n  else if(data->set.ssl.version == CURL_SSLVERSION_SSLv3)\n    sni = FALSE; /* SSLv3 has no SNI */\n\n#ifdef THREADING_SUPPORT\n  entropy_init_mutex(&entropy);\n  mbedtls_ctr_drbg_init(&connssl->ctr_drbg);\n\n  ret = mbedtls_ctr_drbg_seed(&connssl->ctr_drbg, entropy_func_mutex,\n                              &entropy, NULL, 0);\n  if(ret) {\n#ifdef MBEDTLS_ERROR_C\n    mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n    failf(data, \"Failed - mbedTLS: ctr_drbg_init returned (-0x%04X) %s\\n\",\n          -ret, errorbuf);\n  }\n#else\n  mbedtls_entropy_init(&connssl->entropy);\n  mbedtls_ctr_drbg_init(&connssl->ctr_drbg);\n\n  ret = mbedtls_ctr_drbg_seed(&connssl->ctr_drbg, mbedtls_entropy_func,\n                              &connssl->entropy, NULL, 0);\n  if(ret) {\n#ifdef MBEDTLS_ERROR_C\n    mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n    failf(data, \"Failed - mbedTLS: ctr_drbg_init returned (-0x%04X) %s\\n\",\n          -ret, errorbuf);\n  }\n#endif /* THREADING_SUPPORT */\n\n  /* Load the trusted CA */\n  mbedtls_x509_crt_init(&connssl->cacert);\n\n  if(data->set.str[STRING_SSL_CAFILE]) {\n    ret = mbedtls_x509_crt_parse_file(&connssl->cacert,\n                                      data->set.str[STRING_SSL_CAFILE]);\n\n    if(ret<0) {\n#ifdef MBEDTLS_ERROR_C\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n      failf(data, \"Error reading ca cert file %s - mbedTLS: (-0x%04X) %s\",\n            data->set.str[STRING_SSL_CAFILE], -ret, errorbuf);\n\n      if(data->set.ssl.verifypeer)\n        return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n\n  if(data->set.str[STRING_SSL_CAPATH]) {\n    ret = mbedtls_x509_crt_parse_path(&connssl->cacert,\n                                      data->set.str[STRING_SSL_CAPATH]);\n\n    if(ret<0) {\n#ifdef MBEDTLS_ERROR_C\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n      failf(data, \"Error reading ca cert path %s - mbedTLS: (-0x%04X) %s\",\n            data->set.str[STRING_SSL_CAPATH], -ret, errorbuf);\n\n      if(data->set.ssl.verifypeer)\n        return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n\n  /* Load the client certificate */\n  mbedtls_x509_crt_init(&connssl->clicert);\n\n  if(data->set.str[STRING_CERT]) {\n    ret = mbedtls_x509_crt_parse_file(&connssl->clicert,\n                                      data->set.str[STRING_CERT]);\n\n    if(ret) {\n#ifdef MBEDTLS_ERROR_C\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n      failf(data, \"Error reading client cert file %s - mbedTLS: (-0x%04X) %s\",\n            data->set.str[STRING_CERT], -ret, errorbuf);\n\n      return CURLE_SSL_CERTPROBLEM;\n    }\n  }\n\n  /* Load the client private key */\n  mbedtls_pk_init(&connssl->pk);\n\n  if(data->set.str[STRING_KEY]) {\n    ret = mbedtls_pk_parse_keyfile(&connssl->pk, data->set.str[STRING_KEY],\n                                   data->set.str[STRING_KEY_PASSWD]);\n    if(ret == 0 && !mbedtls_pk_can_do(&connssl->pk, MBEDTLS_PK_RSA))\n      ret = MBEDTLS_ERR_PK_TYPE_MISMATCH;\n\n    if(ret) {\n#ifdef MBEDTLS_ERROR_C\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n      failf(data, \"Error reading private key %s - mbedTLS: (-0x%04X) %s\",\n            data->set.str[STRING_KEY], -ret, errorbuf);\n\n      return CURLE_SSL_CERTPROBLEM;\n    }\n  }\n\n  /* Load the CRL */\n  mbedtls_x509_crl_init(&connssl->crl);\n\n  if(data->set.str[STRING_SSL_CRLFILE]) {\n    ret = mbedtls_x509_crl_parse_file(&connssl->crl,\n                                      data->set.str[STRING_SSL_CRLFILE]);\n\n    if(ret) {\n#ifdef MBEDTLS_ERROR_C\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n      failf(data, \"Error reading CRL file %s - mbedTLS: (-0x%04X) %s\",\n            data->set.str[STRING_SSL_CRLFILE], -ret, errorbuf);\n\n      return CURLE_SSL_CRL_BADFILE;\n    }\n  }\n\n  infof(data, \"mbedTLS: Connecting to %s:%d\\n\",\n        conn->host.name, conn->remote_port);\n\n  mbedtls_ssl_config_init(&connssl->config);\n\n  mbedtls_ssl_init(&connssl->ssl);\n  if(mbedtls_ssl_setup(&connssl->ssl, &connssl->config)) {\n    failf(data, \"mbedTLS: ssl_init failed\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n  ret = mbedtls_ssl_config_defaults(&connssl->config,\n                                    MBEDTLS_SSL_IS_CLIENT,\n                                    MBEDTLS_SSL_TRANSPORT_STREAM,\n                                    MBEDTLS_SSL_PRESET_DEFAULT);\n  if(ret) {\n    failf(data, \"mbedTLS: ssl_config failed\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  /* new profile with RSA min key len = 1024 ... */\n  mbedtls_ssl_conf_cert_profile(&connssl->config,\n                                &mbedtls_x509_crt_profile_fr);\n\n  switch(data->set.ssl.version) {\n  case CURL_SSLVERSION_DEFAULT:\n  case CURL_SSLVERSION_TLSv1:\n    mbedtls_ssl_conf_min_version(&connssl->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                                 MBEDTLS_SSL_MINOR_VERSION_1);\n    infof(data, \"mbedTLS: Set min SSL version to TLS 1.0\\n\");\n    break;\n  case CURL_SSLVERSION_SSLv3:\n    mbedtls_ssl_conf_min_version(&connssl->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                                 MBEDTLS_SSL_MINOR_VERSION_0);\n    mbedtls_ssl_conf_max_version(&connssl->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                                 MBEDTLS_SSL_MINOR_VERSION_0);\n    infof(data, \"mbedTLS: Set SSL version to SSLv3\\n\");\n    break;\n  case CURL_SSLVERSION_TLSv1_0:\n    mbedtls_ssl_conf_min_version(&connssl->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                                 MBEDTLS_SSL_MINOR_VERSION_1);\n    mbedtls_ssl_conf_max_version(&connssl->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                                 MBEDTLS_SSL_MINOR_VERSION_1);\n    infof(data, \"mbedTLS: Set SSL version to TLS 1.0\\n\");\n    break;\n  case CURL_SSLVERSION_TLSv1_1:\n    mbedtls_ssl_conf_min_version(&connssl->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                                 MBEDTLS_SSL_MINOR_VERSION_2);\n    mbedtls_ssl_conf_max_version(&connssl->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                                 MBEDTLS_SSL_MINOR_VERSION_2);\n    infof(data, \"mbedTLS: Set SSL version to TLS 1.1\\n\");\n    break;\n  case CURL_SSLVERSION_TLSv1_2:\n    mbedtls_ssl_conf_min_version(&connssl->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                                 MBEDTLS_SSL_MINOR_VERSION_3);\n    mbedtls_ssl_conf_max_version(&connssl->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                                 MBEDTLS_SSL_MINOR_VERSION_3);\n    infof(data, \"mbedTLS: Set SSL version to TLS 1.2\\n\");\n    break;\n  default:\n    failf(data, \"mbedTLS: Unsupported SSL protocol version\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  mbedtls_ssl_conf_authmode(&connssl->config, MBEDTLS_SSL_VERIFY_OPTIONAL);\n\n  mbedtls_ssl_conf_rng(&connssl->config, mbedtls_ctr_drbg_random,\n                       &connssl->ctr_drbg);\n  mbedtls_ssl_set_bio(&connssl->ssl, &conn->sock[sockindex],\n                      mbedtls_net_send,\n                      mbedtls_net_recv,\n                      NULL /*  rev_timeout() */);\n\n  mbedtls_ssl_conf_ciphersuites(&connssl->config,\n                                mbedtls_ssl_list_ciphersuites());\n  if(!Curl_ssl_getsessionid(conn, &old_session, NULL)) {\n    ret = mbedtls_ssl_set_session(&connssl->ssl, old_session);\n    if(ret) {\n      failf(data, \"mbedtls_ssl_set_session returned -0x%x\", -ret);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    infof(data, \"mbedTLS re-using session\\n\");\n  }\n\n  mbedtls_ssl_conf_ca_chain(&connssl->config,\n                            &connssl->cacert,\n                            &connssl->crl);\n\n  if(data->set.str[STRING_KEY]) {\n    mbedtls_ssl_conf_own_cert(&connssl->config,\n                              &connssl->clicert, &connssl->pk);\n  }\n  if(!Curl_inet_pton(AF_INET, conn->host.name, &addr) &&\n#ifdef ENABLE_IPV6\n     !Curl_inet_pton(AF_INET6, conn->host.name, &addr) &&\n#endif\n     sni && mbedtls_ssl_set_hostname(&connssl->ssl, conn->host.name)) {\n    infof(data, \"WARNING: failed to configure \"\n          \"server name indication (SNI) TLS extension\\n\");\n  }\n\n#ifdef HAS_ALPN\n  if(conn->bits.tls_enable_alpn) {\n    const char **p = &connssl->protocols[0];\n#ifdef USE_NGHTTP2\n    if(data->set.httpversion >= CURL_HTTP_VERSION_2)\n      *p++ = NGHTTP2_PROTO_VERSION_ID;\n#endif\n    *p++ = ALPN_HTTP_1_1;\n    *p = NULL;\n    /* this function doesn't clone the protocols array, which is why we need\n       to keep it around */\n    if(mbedtls_ssl_conf_alpn_protocols(&connssl->config,\n                                       &connssl->protocols[0])) {\n      failf(data, \"Failed setting ALPN protocols\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    for(p = &connssl->protocols[0]; *p; ++p)\n      infof(data, \"ALPN, offering %s\\n\", *p);\n  }\n#endif\n\n#ifdef MBEDTLS_DEBUG\n  mbedtls_ssl_conf_dbg(&connssl->config, mbedtls_debug, data);\n#endif\n\n  connssl->connecting_state = ssl_connect_2;\n\n  return CURLE_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146570,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "mbed_connect_step1(struct connectdata *conn,\n                   int sockindex)\n{\n  struct SessionHandle *data = conn->data;\n  struct ssl_connect_data* connssl = &conn->ssl[sockindex];\n\n  bool sni = TRUE; /* default is SNI enabled */\n  int ret = -1;\n#ifdef ENABLE_IPV6\n  struct in6_addr addr;\n#else\n  struct in_addr addr;\n#endif\n  void *old_session = NULL;\n  char errorbuf[128];\n  errorbuf[0]=0;\n\n  /* mbedTLS only supports SSLv3 and TLSv1 */\n  if(data->set.ssl.version == CURL_SSLVERSION_SSLv2) {\n    failf(data, \"mbedTLS does not support SSLv2\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n  else if(data->set.ssl.version == CURL_SSLVERSION_SSLv3)\n    sni = FALSE; /* SSLv3 has no SNI */\n\n#ifdef THREADING_SUPPORT\n  entropy_init_mutex(&entropy);\n  mbedtls_ctr_drbg_init(&connssl->ctr_drbg);\n\n  ret = mbedtls_ctr_drbg_seed(&connssl->ctr_drbg, entropy_func_mutex,\n                              &entropy, NULL, 0);\n  if(ret) {\n#ifdef MBEDTLS_ERROR_C\n    mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n    failf(data, \"Failed - mbedTLS: ctr_drbg_init returned (-0x%04X) %s\\n\",\n          -ret, errorbuf);\n  }\n#else\n  mbedtls_entropy_init(&connssl->entropy);\n  mbedtls_ctr_drbg_init(&connssl->ctr_drbg);\n\n  ret = mbedtls_ctr_drbg_seed(&connssl->ctr_drbg, mbedtls_entropy_func,\n                              &connssl->entropy, NULL, 0);\n  if(ret) {\n#ifdef MBEDTLS_ERROR_C\n    mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n    failf(data, \"Failed - mbedTLS: ctr_drbg_init returned (-0x%04X) %s\\n\",\n          -ret, errorbuf);\n  }\n#endif /* THREADING_SUPPORT */\n\n  /* Load the trusted CA */\n  mbedtls_x509_crt_init(&connssl->cacert);\n\n  if(data->set.str[STRING_SSL_CAFILE]) {\n    ret = mbedtls_x509_crt_parse_file(&connssl->cacert,\n                                      data->set.str[STRING_SSL_CAFILE]);\n\n    if(ret<0) {\n#ifdef MBEDTLS_ERROR_C\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n      failf(data, \"Error reading ca cert file %s - mbedTLS: (-0x%04X) %s\",\n            data->set.str[STRING_SSL_CAFILE], -ret, errorbuf);\n\n      if(data->set.ssl.verifypeer)\n        return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n\n  if(data->set.str[STRING_SSL_CAPATH]) {\n    ret = mbedtls_x509_crt_parse_path(&connssl->cacert,\n                                      data->set.str[STRING_SSL_CAPATH]);\n\n    if(ret<0) {\n#ifdef MBEDTLS_ERROR_C\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n      failf(data, \"Error reading ca cert path %s - mbedTLS: (-0x%04X) %s\",\n            data->set.str[STRING_SSL_CAPATH], -ret, errorbuf);\n\n      if(data->set.ssl.verifypeer)\n        return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n\n  /* Load the client certificate */\n  mbedtls_x509_crt_init(&connssl->clicert);\n\n  if(data->set.str[STRING_CERT]) {\n    ret = mbedtls_x509_crt_parse_file(&connssl->clicert,\n                                      data->set.str[STRING_CERT]);\n\n    if(ret) {\n#ifdef MBEDTLS_ERROR_C\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n      failf(data, \"Error reading client cert file %s - mbedTLS: (-0x%04X) %s\",\n            data->set.str[STRING_CERT], -ret, errorbuf);\n\n      return CURLE_SSL_CERTPROBLEM;\n    }\n  }\n\n  /* Load the client private key */\n  mbedtls_pk_init(&connssl->pk);\n\n  if(data->set.str[STRING_KEY]) {\n    ret = mbedtls_pk_parse_keyfile(&connssl->pk, data->set.str[STRING_KEY],\n                                   data->set.str[STRING_KEY_PASSWD]);\n    if(ret == 0 && !mbedtls_pk_can_do(&connssl->pk, MBEDTLS_PK_RSA))\n      ret = MBEDTLS_ERR_PK_TYPE_MISMATCH;\n\n    if(ret) {\n#ifdef MBEDTLS_ERROR_C\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n      failf(data, \"Error reading private key %s - mbedTLS: (-0x%04X) %s\",\n            data->set.str[STRING_KEY], -ret, errorbuf);\n\n      return CURLE_SSL_CERTPROBLEM;\n    }\n  }\n\n  /* Load the CRL */\n  mbedtls_x509_crl_init(&connssl->crl);\n\n  if(data->set.str[STRING_SSL_CRLFILE]) {\n    ret = mbedtls_x509_crl_parse_file(&connssl->crl,\n                                      data->set.str[STRING_SSL_CRLFILE]);\n\n    if(ret) {\n#ifdef MBEDTLS_ERROR_C\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n      failf(data, \"Error reading CRL file %s - mbedTLS: (-0x%04X) %s\",\n            data->set.str[STRING_SSL_CRLFILE], -ret, errorbuf);\n\n      return CURLE_SSL_CRL_BADFILE;\n    }\n  }\n\n  infof(data, \"mbedTLS: Connecting to %s:%d\\n\",\n        conn->host.name, conn->remote_port);\n\n  mbedtls_ssl_config_init(&connssl->config);\n\n  mbedtls_ssl_init(&connssl->ssl);\n  if(mbedtls_ssl_setup(&connssl->ssl, &connssl->config)) {\n    failf(data, \"mbedTLS: ssl_init failed\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n  ret = mbedtls_ssl_config_defaults(&connssl->config,\n                                    MBEDTLS_SSL_IS_CLIENT,\n                                    MBEDTLS_SSL_TRANSPORT_STREAM,\n                                    MBEDTLS_SSL_PRESET_DEFAULT);\n  if(ret) {\n    failf(data, \"mbedTLS: ssl_config failed\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  /* new profile with RSA min key len = 1024 ... */\n  mbedtls_ssl_conf_cert_profile(&connssl->config,\n                                &mbedtls_x509_crt_profile_fr);\n\n  switch(data->set.ssl.version) {\n  case CURL_SSLVERSION_DEFAULT:\n  case CURL_SSLVERSION_TLSv1:\n    mbedtls_ssl_conf_min_version(&connssl->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                                 MBEDTLS_SSL_MINOR_VERSION_1);\n    infof(data, \"mbedTLS: Set min SSL version to TLS 1.0\\n\");\n    break;\n  case CURL_SSLVERSION_SSLv3:\n    mbedtls_ssl_conf_min_version(&connssl->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                                 MBEDTLS_SSL_MINOR_VERSION_0);\n    mbedtls_ssl_conf_max_version(&connssl->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                                 MBEDTLS_SSL_MINOR_VERSION_0);\n    infof(data, \"mbedTLS: Set SSL version to SSLv3\\n\");\n    break;\n  case CURL_SSLVERSION_TLSv1_0:\n    mbedtls_ssl_conf_min_version(&connssl->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                                 MBEDTLS_SSL_MINOR_VERSION_1);\n    mbedtls_ssl_conf_max_version(&connssl->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                                 MBEDTLS_SSL_MINOR_VERSION_1);\n    infof(data, \"mbedTLS: Set SSL version to TLS 1.0\\n\");\n    break;\n  case CURL_SSLVERSION_TLSv1_1:\n    mbedtls_ssl_conf_min_version(&connssl->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                                 MBEDTLS_SSL_MINOR_VERSION_2);\n    mbedtls_ssl_conf_max_version(&connssl->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                                 MBEDTLS_SSL_MINOR_VERSION_2);\n    infof(data, \"mbedTLS: Set SSL version to TLS 1.1\\n\");\n    break;\n  case CURL_SSLVERSION_TLSv1_2:\n    mbedtls_ssl_conf_min_version(&connssl->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                                 MBEDTLS_SSL_MINOR_VERSION_3);\n    mbedtls_ssl_conf_max_version(&connssl->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                                 MBEDTLS_SSL_MINOR_VERSION_3);\n    infof(data, \"mbedTLS: Set SSL version to TLS 1.2\\n\");\n    break;\n  default:\n    failf(data, \"mbedTLS: Unsupported SSL protocol version\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  mbedtls_ssl_conf_authmode(&connssl->config, MBEDTLS_SSL_VERIFY_OPTIONAL);\n\n  mbedtls_ssl_conf_rng(&connssl->config, mbedtls_ctr_drbg_random,\n                       &connssl->ctr_drbg);\n  mbedtls_ssl_set_bio(&connssl->ssl, &conn->sock[sockindex],\n                      mbedtls_net_send,\n                      mbedtls_net_recv,\n                      NULL /*  rev_timeout() */);\n\n  mbedtls_ssl_conf_ciphersuites(&connssl->config,\n                                mbedtls_ssl_list_ciphersuites());\n  if(!Curl_ssl_getsessionid(conn, &old_session, NULL)) {\n    ret = mbedtls_ssl_set_session(&connssl->ssl, old_session);\n    if(ret) {\n      failf(data, \"mbedtls_ssl_set_session returned -0x%x\", -ret);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    infof(data, \"mbedTLS re-using session\\n\");\n  }\n\n  mbedtls_ssl_conf_ca_chain(&connssl->config,\n                            &connssl->cacert,\n                            &connssl->crl);\n\n  if(data->set.str[STRING_KEY]) {\n    mbedtls_ssl_conf_own_cert(&connssl->config,\n                              &connssl->clicert, &connssl->pk);\n  }\n  if(mbedtls_ssl_set_hostname(&connssl->ssl, conn->host.name)) {\n    /* mbedtls_ssl_set_hostname() sets the name to use in CN/SAN checks *and*\n       the name to set in the SNI extension. So even if curl connects to a\n       host specified as an IP address, this function must be used. */\n    failf(data, \"couldn't set hostname in mbedTLS\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n#ifdef HAS_ALPN\n  if(conn->bits.tls_enable_alpn) {\n    const char **p = &connssl->protocols[0];\n#ifdef USE_NGHTTP2\n    if(data->set.httpversion >= CURL_HTTP_VERSION_2)\n      *p++ = NGHTTP2_PROTO_VERSION_ID;\n#endif\n    *p++ = ALPN_HTTP_1_1;\n    *p = NULL;\n    /* this function doesn't clone the protocols array, which is why we need\n       to keep it around */\n    if(mbedtls_ssl_conf_alpn_protocols(&connssl->config,\n                                       &connssl->protocols[0])) {\n      failf(data, \"Failed setting ALPN protocols\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    for(p = &connssl->protocols[0]; *p; ++p)\n      infof(data, \"ALPN, offering %s\\n\", *p);\n  }\n#endif\n\n#ifdef MBEDTLS_DEBUG\n  mbedtls_ssl_conf_dbg(&connssl->config, mbedtls_debug, data);\n#endif\n\n  connssl->connecting_state = ssl_connect_2;\n\n  return CURLE_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146571,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "polarssl_connect_step1(struct connectdata *conn,\n                     int sockindex)\n{\n  struct SessionHandle *data = conn->data;\n  struct ssl_connect_data* connssl = &conn->ssl[sockindex];\n\n  bool sni = TRUE; /* default is SNI enabled */\n  int ret = -1;\n#ifdef ENABLE_IPV6\n  struct in6_addr addr;\n#else\n  struct in_addr addr;\n#endif\n  void *old_session = NULL;\n  char errorbuf[128];\n  errorbuf[0]=0;\n\n  /* PolarSSL only supports SSLv3 and TLSv1 */\n  if(data->set.ssl.version == CURL_SSLVERSION_SSLv2) {\n    failf(data, \"PolarSSL does not support SSLv2\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n  else if(data->set.ssl.version == CURL_SSLVERSION_SSLv3)\n    sni = FALSE; /* SSLv3 has no SNI */\n\n#ifdef THREADING_SUPPORT\n  entropy_init_mutex(&entropy);\n\n  if((ret = ctr_drbg_init(&connssl->ctr_drbg, entropy_func_mutex, &entropy,\n                          NULL, 0)) != 0) {\n#ifdef POLARSSL_ERROR_C\n     error_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* POLARSSL_ERROR_C */\n     failf(data, \"Failed - PolarSSL: ctr_drbg_init returned (-0x%04X) %s\\n\",\n                                                            -ret, errorbuf);\n  }\n#else\n  entropy_init(&connssl->entropy);\n\n  if((ret = ctr_drbg_init(&connssl->ctr_drbg, entropy_func, &connssl->entropy,\n                          NULL, 0)) != 0) {\n#ifdef POLARSSL_ERROR_C\n     error_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* POLARSSL_ERROR_C */\n     failf(data, \"Failed - PolarSSL: ctr_drbg_init returned (-0x%04X) %s\\n\",\n                                                            -ret, errorbuf);\n  }\n#endif /* THREADING_SUPPORT */\n\n  /* Load the trusted CA */\n  memset(&connssl->cacert, 0, sizeof(x509_crt));\n\n  if(data->set.str[STRING_SSL_CAFILE]) {\n    ret = x509_crt_parse_file(&connssl->cacert,\n                              data->set.str[STRING_SSL_CAFILE]);\n\n    if(ret<0) {\n#ifdef POLARSSL_ERROR_C\n      error_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* POLARSSL_ERROR_C */\n      failf(data, \"Error reading ca cert file %s - PolarSSL: (-0x%04X) %s\",\n            data->set.str[STRING_SSL_CAFILE], -ret, errorbuf);\n\n      if(data->set.ssl.verifypeer)\n        return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n\n  if(data->set.str[STRING_SSL_CAPATH]) {\n    ret = x509_crt_parse_path(&connssl->cacert,\n                              data->set.str[STRING_SSL_CAPATH]);\n\n    if(ret<0) {\n#ifdef POLARSSL_ERROR_C\n      error_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* POLARSSL_ERROR_C */\n      failf(data, \"Error reading ca cert path %s - PolarSSL: (-0x%04X) %s\",\n            data->set.str[STRING_SSL_CAPATH], -ret, errorbuf);\n\n      if(data->set.ssl.verifypeer)\n        return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n\n  /* Load the client certificate */\n  memset(&connssl->clicert, 0, sizeof(x509_crt));\n\n  if(data->set.str[STRING_CERT]) {\n    ret = x509_crt_parse_file(&connssl->clicert,\n                              data->set.str[STRING_CERT]);\n\n    if(ret) {\n#ifdef POLARSSL_ERROR_C\n      error_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* POLARSSL_ERROR_C */\n      failf(data, \"Error reading client cert file %s - PolarSSL: (-0x%04X) %s\",\n            data->set.str[STRING_CERT], -ret, errorbuf);\n\n      return CURLE_SSL_CERTPROBLEM;\n    }\n  }\n\n  /* Load the client private key */\n  if(data->set.str[STRING_KEY]) {\n    pk_context pk;\n    pk_init(&pk);\n    ret = pk_parse_keyfile(&pk, data->set.str[STRING_KEY],\n                           data->set.str[STRING_KEY_PASSWD]);\n    if(ret == 0 && !pk_can_do(&pk, POLARSSL_PK_RSA))\n      ret = POLARSSL_ERR_PK_TYPE_MISMATCH;\n    if(ret == 0)\n      rsa_copy(&connssl->rsa, pk_rsa(pk));\n    else\n      rsa_free(&connssl->rsa);\n    pk_free(&pk);\n\n    if(ret) {\n#ifdef POLARSSL_ERROR_C\n      error_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* POLARSSL_ERROR_C */\n      failf(data, \"Error reading private key %s - PolarSSL: (-0x%04X) %s\",\n            data->set.str[STRING_KEY], -ret, errorbuf);\n\n      return CURLE_SSL_CERTPROBLEM;\n    }\n  }\n\n  /* Load the CRL */\n  memset(&connssl->crl, 0, sizeof(x509_crl));\n\n  if(data->set.str[STRING_SSL_CRLFILE]) {\n    ret = x509_crl_parse_file(&connssl->crl,\n                              data->set.str[STRING_SSL_CRLFILE]);\n\n    if(ret) {\n#ifdef POLARSSL_ERROR_C\n      error_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* POLARSSL_ERROR_C */\n      failf(data, \"Error reading CRL file %s - PolarSSL: (-0x%04X) %s\",\n            data->set.str[STRING_SSL_CRLFILE], -ret, errorbuf);\n\n      return CURLE_SSL_CRL_BADFILE;\n    }\n  }\n\n  infof(data, \"PolarSSL: Connecting to %s:%d\\n\",\n        conn->host.name, conn->remote_port);\n\n  if(ssl_init(&connssl->ssl)) {\n    failf(data, \"PolarSSL: ssl_init failed\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  switch(data->set.ssl.version) {\n  default:\n  case CURL_SSLVERSION_DEFAULT:\n  case CURL_SSLVERSION_TLSv1:\n    ssl_set_min_version(&connssl->ssl, SSL_MAJOR_VERSION_3,\n                        SSL_MINOR_VERSION_1);\n    break;\n  case CURL_SSLVERSION_SSLv3:\n    ssl_set_min_version(&connssl->ssl, SSL_MAJOR_VERSION_3,\n                        SSL_MINOR_VERSION_0);\n    ssl_set_max_version(&connssl->ssl, SSL_MAJOR_VERSION_3,\n                        SSL_MINOR_VERSION_0);\n    infof(data, \"PolarSSL: Forced min. SSL Version to be SSLv3\\n\");\n    break;\n  case CURL_SSLVERSION_TLSv1_0:\n    ssl_set_min_version(&connssl->ssl, SSL_MAJOR_VERSION_3,\n                        SSL_MINOR_VERSION_1);\n    ssl_set_max_version(&connssl->ssl, SSL_MAJOR_VERSION_3,\n                        SSL_MINOR_VERSION_1);\n    infof(data, \"PolarSSL: Forced min. SSL Version to be TLS 1.0\\n\");\n    break;\n  case CURL_SSLVERSION_TLSv1_1:\n    ssl_set_min_version(&connssl->ssl, SSL_MAJOR_VERSION_3,\n                        SSL_MINOR_VERSION_2);\n    ssl_set_max_version(&connssl->ssl, SSL_MAJOR_VERSION_3,\n                        SSL_MINOR_VERSION_2);\n    infof(data, \"PolarSSL: Forced min. SSL Version to be TLS 1.1\\n\");\n    break;\n  case CURL_SSLVERSION_TLSv1_2:\n    ssl_set_min_version(&connssl->ssl, SSL_MAJOR_VERSION_3,\n                        SSL_MINOR_VERSION_3);\n    ssl_set_max_version(&connssl->ssl, SSL_MAJOR_VERSION_3,\n                        SSL_MINOR_VERSION_3);\n    infof(data, \"PolarSSL: Forced min. SSL Version to be TLS 1.2\\n\");\n    break;\n  }\n\n  ssl_set_endpoint(&connssl->ssl, SSL_IS_CLIENT);\n  ssl_set_authmode(&connssl->ssl, SSL_VERIFY_OPTIONAL);\n\n  ssl_set_rng(&connssl->ssl, ctr_drbg_random,\n              &connssl->ctr_drbg);\n  ssl_set_bio(&connssl->ssl,\n              net_recv, &conn->sock[sockindex],\n              net_send, &conn->sock[sockindex]);\n\n  ssl_set_ciphersuites(&connssl->ssl, ssl_list_ciphersuites());\n  if(!Curl_ssl_getsessionid(conn, &old_session, NULL)) {\n    ret = ssl_set_session(&connssl->ssl, old_session);\n    if(ret) {\n      failf(data, \"ssl_set_session returned -0x%x\", -ret);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    infof(data, \"PolarSSL re-using session\\n\");\n  }\n\n  ssl_set_ca_chain(&connssl->ssl,\n                   &connssl->cacert,\n                   &connssl->crl,\n                   conn->host.name);\n\n  ssl_set_own_cert_rsa(&connssl->ssl,\n                       &connssl->clicert, &connssl->rsa);\n\n  if(!Curl_inet_pton(AF_INET, conn->host.name, &addr) &&\n#ifdef ENABLE_IPV6\n     !Curl_inet_pton(AF_INET6, conn->host.name, &addr) &&\n#endif\n     sni && ssl_set_hostname(&connssl->ssl, conn->host.name)) {\n     infof(data, \"WARNING: failed to configure \"\n                 \"server name indication (SNI) TLS extension\\n\");\n  }\n\n#ifdef HAS_ALPN\n  if(conn->bits.tls_enable_alpn) {\n    static const char* protocols[3];\n    int cur = 0;\n\n#ifdef USE_NGHTTP2\n    if(data->set.httpversion >= CURL_HTTP_VERSION_2) {\n      protocols[cur++] = NGHTTP2_PROTO_VERSION_ID;\n      infof(data, \"ALPN, offering %s\\n\", NGHTTP2_PROTO_VERSION_ID);\n    }\n#endif\n\n    protocols[cur++] = ALPN_HTTP_1_1;\n    infof(data, \"ALPN, offering %s\\n\", ALPN_HTTP_1_1);\n\n    protocols[cur] = NULL;\n\n    ssl_set_alpn_protocols(&connssl->ssl, protocols);\n  }\n#endif\n\n#ifdef POLARSSL_DEBUG\n  ssl_set_dbg(&connssl->ssl, polarssl_debug, data);\n#endif\n\n  connssl->connecting_state = ssl_connect_2;\n\n  return CURLE_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146572,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "polarssl_connect_step1(struct connectdata *conn,\n                     int sockindex)\n{\n  struct SessionHandle *data = conn->data;\n  struct ssl_connect_data* connssl = &conn->ssl[sockindex];\n\n  bool sni = TRUE; /* default is SNI enabled */\n  int ret = -1;\n#ifdef ENABLE_IPV6\n  struct in6_addr addr;\n#else\n  struct in_addr addr;\n#endif\n  void *old_session = NULL;\n  char errorbuf[128];\n  errorbuf[0]=0;\n\n  /* PolarSSL only supports SSLv3 and TLSv1 */\n  if(data->set.ssl.version == CURL_SSLVERSION_SSLv2) {\n    failf(data, \"PolarSSL does not support SSLv2\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n  else if(data->set.ssl.version == CURL_SSLVERSION_SSLv3)\n    sni = FALSE; /* SSLv3 has no SNI */\n\n#ifdef THREADING_SUPPORT\n  entropy_init_mutex(&entropy);\n\n  if((ret = ctr_drbg_init(&connssl->ctr_drbg, entropy_func_mutex, &entropy,\n                          NULL, 0)) != 0) {\n#ifdef POLARSSL_ERROR_C\n     error_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* POLARSSL_ERROR_C */\n     failf(data, \"Failed - PolarSSL: ctr_drbg_init returned (-0x%04X) %s\\n\",\n                                                            -ret, errorbuf);\n  }\n#else\n  entropy_init(&connssl->entropy);\n\n  if((ret = ctr_drbg_init(&connssl->ctr_drbg, entropy_func, &connssl->entropy,\n                          NULL, 0)) != 0) {\n#ifdef POLARSSL_ERROR_C\n     error_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* POLARSSL_ERROR_C */\n     failf(data, \"Failed - PolarSSL: ctr_drbg_init returned (-0x%04X) %s\\n\",\n                                                            -ret, errorbuf);\n  }\n#endif /* THREADING_SUPPORT */\n\n  /* Load the trusted CA */\n  memset(&connssl->cacert, 0, sizeof(x509_crt));\n\n  if(data->set.str[STRING_SSL_CAFILE]) {\n    ret = x509_crt_parse_file(&connssl->cacert,\n                              data->set.str[STRING_SSL_CAFILE]);\n\n    if(ret<0) {\n#ifdef POLARSSL_ERROR_C\n      error_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* POLARSSL_ERROR_C */\n      failf(data, \"Error reading ca cert file %s - PolarSSL: (-0x%04X) %s\",\n            data->set.str[STRING_SSL_CAFILE], -ret, errorbuf);\n\n      if(data->set.ssl.verifypeer)\n        return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n\n  if(data->set.str[STRING_SSL_CAPATH]) {\n    ret = x509_crt_parse_path(&connssl->cacert,\n                              data->set.str[STRING_SSL_CAPATH]);\n\n    if(ret<0) {\n#ifdef POLARSSL_ERROR_C\n      error_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* POLARSSL_ERROR_C */\n      failf(data, \"Error reading ca cert path %s - PolarSSL: (-0x%04X) %s\",\n            data->set.str[STRING_SSL_CAPATH], -ret, errorbuf);\n\n      if(data->set.ssl.verifypeer)\n        return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n\n  /* Load the client certificate */\n  memset(&connssl->clicert, 0, sizeof(x509_crt));\n\n  if(data->set.str[STRING_CERT]) {\n    ret = x509_crt_parse_file(&connssl->clicert,\n                              data->set.str[STRING_CERT]);\n\n    if(ret) {\n#ifdef POLARSSL_ERROR_C\n      error_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* POLARSSL_ERROR_C */\n      failf(data, \"Error reading client cert file %s - PolarSSL: (-0x%04X) %s\",\n            data->set.str[STRING_CERT], -ret, errorbuf);\n\n      return CURLE_SSL_CERTPROBLEM;\n    }\n  }\n\n  /* Load the client private key */\n  if(data->set.str[STRING_KEY]) {\n    pk_context pk;\n    pk_init(&pk);\n    ret = pk_parse_keyfile(&pk, data->set.str[STRING_KEY],\n                           data->set.str[STRING_KEY_PASSWD]);\n    if(ret == 0 && !pk_can_do(&pk, POLARSSL_PK_RSA))\n      ret = POLARSSL_ERR_PK_TYPE_MISMATCH;\n    if(ret == 0)\n      rsa_copy(&connssl->rsa, pk_rsa(pk));\n    else\n      rsa_free(&connssl->rsa);\n    pk_free(&pk);\n\n    if(ret) {\n#ifdef POLARSSL_ERROR_C\n      error_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* POLARSSL_ERROR_C */\n      failf(data, \"Error reading private key %s - PolarSSL: (-0x%04X) %s\",\n            data->set.str[STRING_KEY], -ret, errorbuf);\n\n      return CURLE_SSL_CERTPROBLEM;\n    }\n  }\n\n  /* Load the CRL */\n  memset(&connssl->crl, 0, sizeof(x509_crl));\n\n  if(data->set.str[STRING_SSL_CRLFILE]) {\n    ret = x509_crl_parse_file(&connssl->crl,\n                              data->set.str[STRING_SSL_CRLFILE]);\n\n    if(ret) {\n#ifdef POLARSSL_ERROR_C\n      error_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* POLARSSL_ERROR_C */\n      failf(data, \"Error reading CRL file %s - PolarSSL: (-0x%04X) %s\",\n            data->set.str[STRING_SSL_CRLFILE], -ret, errorbuf);\n\n      return CURLE_SSL_CRL_BADFILE;\n    }\n  }\n\n  infof(data, \"PolarSSL: Connecting to %s:%d\\n\",\n        conn->host.name, conn->remote_port);\n\n  if(ssl_init(&connssl->ssl)) {\n    failf(data, \"PolarSSL: ssl_init failed\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  switch(data->set.ssl.version) {\n  default:\n  case CURL_SSLVERSION_DEFAULT:\n  case CURL_SSLVERSION_TLSv1:\n    ssl_set_min_version(&connssl->ssl, SSL_MAJOR_VERSION_3,\n                        SSL_MINOR_VERSION_1);\n    break;\n  case CURL_SSLVERSION_SSLv3:\n    ssl_set_min_version(&connssl->ssl, SSL_MAJOR_VERSION_3,\n                        SSL_MINOR_VERSION_0);\n    ssl_set_max_version(&connssl->ssl, SSL_MAJOR_VERSION_3,\n                        SSL_MINOR_VERSION_0);\n    infof(data, \"PolarSSL: Forced min. SSL Version to be SSLv3\\n\");\n    break;\n  case CURL_SSLVERSION_TLSv1_0:\n    ssl_set_min_version(&connssl->ssl, SSL_MAJOR_VERSION_3,\n                        SSL_MINOR_VERSION_1);\n    ssl_set_max_version(&connssl->ssl, SSL_MAJOR_VERSION_3,\n                        SSL_MINOR_VERSION_1);\n    infof(data, \"PolarSSL: Forced min. SSL Version to be TLS 1.0\\n\");\n    break;\n  case CURL_SSLVERSION_TLSv1_1:\n    ssl_set_min_version(&connssl->ssl, SSL_MAJOR_VERSION_3,\n                        SSL_MINOR_VERSION_2);\n    ssl_set_max_version(&connssl->ssl, SSL_MAJOR_VERSION_3,\n                        SSL_MINOR_VERSION_2);\n    infof(data, \"PolarSSL: Forced min. SSL Version to be TLS 1.1\\n\");\n    break;\n  case CURL_SSLVERSION_TLSv1_2:\n    ssl_set_min_version(&connssl->ssl, SSL_MAJOR_VERSION_3,\n                        SSL_MINOR_VERSION_3);\n    ssl_set_max_version(&connssl->ssl, SSL_MAJOR_VERSION_3,\n                        SSL_MINOR_VERSION_3);\n    infof(data, \"PolarSSL: Forced min. SSL Version to be TLS 1.2\\n\");\n    break;\n  }\n\n  ssl_set_endpoint(&connssl->ssl, SSL_IS_CLIENT);\n  ssl_set_authmode(&connssl->ssl, SSL_VERIFY_OPTIONAL);\n\n  ssl_set_rng(&connssl->ssl, ctr_drbg_random,\n              &connssl->ctr_drbg);\n  ssl_set_bio(&connssl->ssl,\n              net_recv, &conn->sock[sockindex],\n              net_send, &conn->sock[sockindex]);\n\n  ssl_set_ciphersuites(&connssl->ssl, ssl_list_ciphersuites());\n  if(!Curl_ssl_getsessionid(conn, &old_session, NULL)) {\n    ret = ssl_set_session(&connssl->ssl, old_session);\n    if(ret) {\n      failf(data, \"ssl_set_session returned -0x%x\", -ret);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    infof(data, \"PolarSSL re-using session\\n\");\n  }\n\n  ssl_set_ca_chain(&connssl->ssl,\n                   &connssl->cacert,\n                   &connssl->crl,\n                   conn->host.name);\n\n  ssl_set_own_cert_rsa(&connssl->ssl,\n                       &connssl->clicert, &connssl->rsa);\n\n  if(ssl_set_hostname(&connssl->ssl, conn->host.name)) {\n    /* ssl_set_hostname() sets the name to use in CN/SAN checks *and* the name\n       to set in the SNI extension. So even if curl connects to a host\n       specified as an IP address, this function must be used. */\n    failf(data, \"couldn't set hostname in PolarSSL\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n#ifdef HAS_ALPN\n  if(conn->bits.tls_enable_alpn) {\n    static const char* protocols[3];\n    int cur = 0;\n\n#ifdef USE_NGHTTP2\n    if(data->set.httpversion >= CURL_HTTP_VERSION_2) {\n      protocols[cur++] = NGHTTP2_PROTO_VERSION_ID;\n      infof(data, \"ALPN, offering %s\\n\", NGHTTP2_PROTO_VERSION_ID);\n    }\n#endif\n\n    protocols[cur++] = ALPN_HTTP_1_1;\n    infof(data, \"ALPN, offering %s\\n\", ALPN_HTTP_1_1);\n\n    protocols[cur] = NULL;\n\n    ssl_set_alpn_protocols(&connssl->ssl, protocols);\n  }\n#endif\n\n#ifdef POLARSSL_DEBUG\n  ssl_set_dbg(&connssl->ssl, polarssl_debug, data);\n#endif\n\n  connssl->connecting_state = ssl_connect_2;\n\n  return CURLE_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146573,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "RoleName RoleName::parseFromBSON(const BSONElement& elem) {\n    auto obj = elem.embeddedObjectUserCheck();\n    std::array<BSONElement, 2> fields;\n    obj.getFields(\n        {AuthorizationManager::ROLE_NAME_FIELD_NAME, AuthorizationManager::ROLE_DB_FIELD_NAME},\n        &fields);\n    const auto& nameField = fields[0];\n    uassert(ErrorCodes::BadValue,\n            str::stream() << \"user name must contain a string field named: \"\n                          << AuthorizationManager::ROLE_NAME_FIELD_NAME,\n            nameField.type() == String);\n\n    const auto& dbField = fields[1];\n    uassert(ErrorCodes::BadValue,\n            str::stream() << \"role name must contain a string field named: \"\n                          << AuthorizationManager::ROLE_DB_FIELD_NAME,\n            nameField.type() == String);\n\n    return RoleName(nameField.valueStringData(), dbField.valueStringData());\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146592,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "RoleName RoleName::parseFromBSON(const BSONElement& elem) {\n    auto obj = elem.embeddedObjectUserCheck();\n    std::array<BSONElement, 2> fields;\n    obj.getFields(\n        {AuthorizationManager::ROLE_NAME_FIELD_NAME, AuthorizationManager::ROLE_DB_FIELD_NAME},\n        &fields);\n    const auto& nameField = fields[0];\n    uassert(ErrorCodes::BadValue,\n            str::stream() << \"user name must contain a string field named: \"\n                          << AuthorizationManager::ROLE_NAME_FIELD_NAME,\n            nameField.type() == String);\n\n    const auto& dbField = fields[1];\n    uassert(ErrorCodes::BadValue,\n            str::stream() << \"role name must contain a string field named: \"\n                          << AuthorizationManager::ROLE_DB_FIELD_NAME,\n            dbField.type() == String);\n\n    return RoleName(nameField.valueStringData(), dbField.valueStringData());\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146593,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "PHP_FUNCTION(odbc_execute)\n{ \n\tzval *pv_res, *pv_param_arr, **tmp;\n\ttypedef struct params_t {\n\t\tSQLLEN vallen;\n\t\tint fp;\n\t} params_t;\n\tparams_t *params = NULL;\n\tchar *filename;\n\tunsigned char otype;\n   \tSQLSMALLINT sqltype, ctype, scale;\n\tSQLSMALLINT nullable;\n\tSQLULEN precision;\n   \todbc_result *result;\n\tint numArgs, i, ne;\n\tRETCODE rc;\n\t\n\tnumArgs = ZEND_NUM_ARGS();\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|a\", &pv_res, &pv_param_arr) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(result, odbc_result *, &pv_res, -1, \"ODBC result\", le_result);\n\t\n\t/* XXX check for already bound parameters*/\n\tif (result->numparams > 0 && numArgs == 1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No parameters to SQL statement given\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (result->numparams > 0) {\n\t\tif ((ne = zend_hash_num_elements(Z_ARRVAL_P(pv_param_arr))) < result->numparams) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\"Not enough parameters (%d should be %d) given\", ne, result->numparams);\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tzend_hash_internal_pointer_reset(Z_ARRVAL_P(pv_param_arr));\n\t\tparams = (params_t *)safe_emalloc(sizeof(params_t), result->numparams, 0);\n\t\tfor(i = 0; i < result->numparams; i++) {\n\t\t\tparams[i].fp = -1;\n\t\t}\n\t\t\n\t\tfor(i = 1; i <= result->numparams; i++) {\n\t\t\tif (zend_hash_get_current_data(Z_ARRVAL_P(pv_param_arr), (void **) &tmp) == FAILURE) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\"Error getting parameter\");\n\t\t\t\tSQLFreeStmt(result->stmt,SQL_RESET_PARAMS);\n\t\t\t\tfor (i = 0; i < result->numparams; i++) {\n\t\t\t\t\tif (params[i].fp != -1) {\n\t\t\t\t\t\tclose(params[i].fp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tefree(params);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\n\t\t\totype = (*tmp)->type;\n\t\t\tconvert_to_string_ex(tmp);\n\t\t\tif (Z_TYPE_PP(tmp) != IS_STRING) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\"Error converting parameter\");\n\t\t\t\tSQLFreeStmt(result->stmt, SQL_RESET_PARAMS);\n\t\t\t\tfor (i = 0; i < result->numparams; i++) {\n\t\t\t\t\tif (params[i].fp != -1) {\n\t\t\t\t\t\tclose(params[i].fp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tefree(params);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\t\n\t\t\trc = SQLDescribeParam(result->stmt, (SQLUSMALLINT)i, &sqltype, &precision, &scale, &nullable);\n\t\t\tparams[i-1].vallen = Z_STRLEN_PP(tmp);\n\t\t\tparams[i-1].fp = -1;\n\t\t\tif (rc == SQL_ERROR) {\n\t\t\t\todbc_sql_error(result->conn_ptr, result->stmt, \"SQLDescribeParameter\");\t\n\t\t\t\tSQLFreeStmt(result->stmt, SQL_RESET_PARAMS);\n\t\t\t\tfor (i = 0; i < result->numparams; i++) {\n\t\t\t\t\tif (params[i].fp != -1) {\n\t\t\t\t\t\tclose(params[i].fp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tefree(params);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\n\t\t\tif (IS_SQL_BINARY(sqltype)) {\n\t\t\t\tctype = SQL_C_BINARY;\n\t\t\t} else {\n\t\t\t\tctype = SQL_C_CHAR;\n\t\t\t}\n\n\t\t\tif (Z_STRLEN_PP(tmp) > 2 &&\n\t\t\t\tZ_STRVAL_PP(tmp)[0] == '\\'' &&\n\t\t\t\tZ_STRVAL_PP(tmp)[Z_STRLEN_PP(tmp) - 1] == '\\'') {\n\t\t\t\tif (strlen(tmp) != Z_STRLEN_PP(tmp)) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\n\t\t\t\tfilename = estrndup(&Z_STRVAL_PP(tmp)[1], Z_STRLEN_PP(tmp) - 2);\n\n\t\t\t\t/* Check for safe mode. */\n\t\t\t\tif (PG(safe_mode) && (!php_checkuid(filename, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {\n\t\t\t\t\tefree(filename);\n\t\t\t\t\tefree(params);\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\n\t\t\t\t/* Check the basedir */\n\t\t\t\tif (php_check_open_basedir(filename TSRMLS_CC)) {\n\t\t\t\t\tefree(filename);\n\t\t\t\t\tSQLFreeStmt(result->stmt, SQL_RESET_PARAMS);\n\t\t\t\t\tfor (i = 0; i < result->numparams; i++) {\n\t\t\t\t\t\tif (params[i].fp != -1) {\n\t\t\t\t\t\t\tclose(params[i].fp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tefree(params);\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\n\t\t\t\tif ((params[i-1].fp = open(filename,O_RDONLY)) == -1) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\"Can't open file %s\", filename);\n\t\t\t\t\tSQLFreeStmt(result->stmt, SQL_RESET_PARAMS);\n\t\t\t\t\tfor (i = 0; i < result->numparams; i++) {\n\t\t\t\t\t\tif (params[i].fp != -1) {\n\t\t\t\t\t\t\tclose(params[i].fp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tefree(params);\n\t\t\t\t\tefree(filename);\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\n\t\t\t\tefree(filename);\n\n\t\t\t\tparams[i-1].vallen = SQL_LEN_DATA_AT_EXEC(0);\n\n\t\t\t\trc = SQLBindParameter(result->stmt, (SQLUSMALLINT)i, SQL_PARAM_INPUT,\n\t\t\t\t\t\t\t\t\t  ctype, sqltype, precision, scale,\n\t\t\t\t\t\t\t\t\t  (void *)params[i-1].fp, 0,\n\t\t\t\t\t\t\t\t\t  &params[i-1].vallen);\n\t\t\t} else {\n#ifdef HAVE_DBMAKER\n\t\t\t\tprecision = params[i-1].vallen;\n#endif\n\t\t\t\tif (otype == IS_NULL) {\n\t\t\t\t\tparams[i-1].vallen = SQL_NULL_DATA;\n\t\t\t\t}\n\n\t\t\t\trc = SQLBindParameter(result->stmt, (SQLUSMALLINT)i, SQL_PARAM_INPUT,\n\t\t\t\t\t\t\t\t\t  ctype, sqltype, precision, scale,\n\t\t\t\t\t\t\t\t\t  Z_STRVAL_PP(tmp), 0,\n\t\t\t\t\t\t\t\t\t  &params[i-1].vallen);\n\t\t\t}\n\t\t\tif (rc == SQL_ERROR) {\n\t\t\t\todbc_sql_error(result->conn_ptr, result->stmt, \"SQLBindParameter\");\t\n\t\t\t\tSQLFreeStmt(result->stmt, SQL_RESET_PARAMS);\n\t\t\t\tfor (i = 0; i < result->numparams; i++) {\n\t\t\t\t\tif (params[i].fp != -1) {\n\t\t\t\t\t\tclose(params[i].fp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tefree(params);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tzend_hash_move_forward(Z_ARRVAL_P(pv_param_arr));\n\t\t}\n\t}\n\t/* Close cursor, needed for doing multiple selects */\n\trc = SQLFreeStmt(result->stmt, SQL_CLOSE);\n\n\tif (rc == SQL_ERROR) {\n\t\todbc_sql_error(result->conn_ptr, result->stmt, \"SQLFreeStmt\");\t\n\t}\n\n\trc = SQLExecute(result->stmt);\n\n\tresult->fetched = 0;\n\tif (rc == SQL_NEED_DATA) {\n\t\tchar buf[4096];\n\t\tint fp, nbytes;\n\t\twhile (rc == SQL_NEED_DATA) {\n\t\t\trc = SQLParamData(result->stmt, (void*)&fp);\n\t\t\tif (rc == SQL_NEED_DATA) {\n\t\t\t\twhile ((nbytes = read(fp, &buf, 4096)) > 0) {\n\t\t\t\t\tSQLPutData(result->stmt, (void*)&buf, nbytes);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tswitch (rc) {\n\t\t\tcase SQL_SUCCESS:\n\t\t\t\tbreak;\n\t\t\tcase SQL_NO_DATA_FOUND:\n\t\t\tcase SQL_SUCCESS_WITH_INFO:\n\t\t\t\todbc_sql_error(result->conn_ptr, result->stmt, \"SQLExecute\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\todbc_sql_error(result->conn_ptr, result->stmt, \"SQLExecute\");\n\t\t\t\tRETVAL_FALSE;\n\t\t}\n\t}\t\n\t\n\tif (result->numparams > 0) {\n\t\tSQLFreeStmt(result->stmt, SQL_RESET_PARAMS);\n\t\tfor(i = 0; i < result->numparams; i++) {\n\t\t\tif (params[i].fp != -1) {\n\t\t\t\tclose(params[i].fp);\n\t\t\t}\n\t\t}\n\t\tefree(params);\n\t}\n\n\tif (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO || rc == SQL_NO_DATA_FOUND) {\n\t\tRETVAL_TRUE;\n\t}\n\n\tif (result->numcols == 0) {\n\t\tSQLNumResultCols(result->stmt, &(result->numcols));\n\n\t\tif (result->numcols > 0) {\n\t\t\tif (!odbc_bindcols(result TSRMLS_CC)) {\n\t\t\t\tefree(result);\n\t\t\t\tRETVAL_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tresult->values = NULL;\n\t\t}\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146622,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "PHP_FUNCTION(odbc_execute)\n{ \n\tzval *pv_res, *pv_param_arr, **tmp;\n\ttypedef struct params_t {\n\t\tSQLLEN vallen;\n\t\tint fp;\n\t} params_t;\n\tparams_t *params = NULL;\n\tchar *filename;\n\tunsigned char otype;\n   \tSQLSMALLINT sqltype, ctype, scale;\n\tSQLSMALLINT nullable;\n\tSQLULEN precision;\n   \todbc_result *result;\n\tint numArgs, i, ne;\n\tRETCODE rc;\n\t\n\tnumArgs = ZEND_NUM_ARGS();\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|a\", &pv_res, &pv_param_arr) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(result, odbc_result *, &pv_res, -1, \"ODBC result\", le_result);\n\t\n\t/* XXX check for already bound parameters*/\n\tif (result->numparams > 0 && numArgs == 1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No parameters to SQL statement given\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (result->numparams > 0) {\n\t\tif ((ne = zend_hash_num_elements(Z_ARRVAL_P(pv_param_arr))) < result->numparams) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\"Not enough parameters (%d should be %d) given\", ne, result->numparams);\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tzend_hash_internal_pointer_reset(Z_ARRVAL_P(pv_param_arr));\n\t\tparams = (params_t *)safe_emalloc(sizeof(params_t), result->numparams, 0);\n\t\tfor(i = 0; i < result->numparams; i++) {\n\t\t\tparams[i].fp = -1;\n\t\t}\n\t\t\n\t\tfor(i = 1; i <= result->numparams; i++) {\n\t\t\tif (zend_hash_get_current_data(Z_ARRVAL_P(pv_param_arr), (void **) &tmp) == FAILURE) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\"Error getting parameter\");\n\t\t\t\tSQLFreeStmt(result->stmt,SQL_RESET_PARAMS);\n\t\t\t\tfor (i = 0; i < result->numparams; i++) {\n\t\t\t\t\tif (params[i].fp != -1) {\n\t\t\t\t\t\tclose(params[i].fp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tefree(params);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\n\t\t\totype = (*tmp)->type;\n\t\t\tconvert_to_string_ex(tmp);\n\t\t\tif (Z_TYPE_PP(tmp) != IS_STRING) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\"Error converting parameter\");\n\t\t\t\tSQLFreeStmt(result->stmt, SQL_RESET_PARAMS);\n\t\t\t\tfor (i = 0; i < result->numparams; i++) {\n\t\t\t\t\tif (params[i].fp != -1) {\n\t\t\t\t\t\tclose(params[i].fp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tefree(params);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\t\n\t\t\trc = SQLDescribeParam(result->stmt, (SQLUSMALLINT)i, &sqltype, &precision, &scale, &nullable);\n\t\t\tparams[i-1].vallen = Z_STRLEN_PP(tmp);\n\t\t\tparams[i-1].fp = -1;\n\t\t\tif (rc == SQL_ERROR) {\n\t\t\t\todbc_sql_error(result->conn_ptr, result->stmt, \"SQLDescribeParameter\");\t\n\t\t\t\tSQLFreeStmt(result->stmt, SQL_RESET_PARAMS);\n\t\t\t\tfor (i = 0; i < result->numparams; i++) {\n\t\t\t\t\tif (params[i].fp != -1) {\n\t\t\t\t\t\tclose(params[i].fp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tefree(params);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\n\t\t\tif (IS_SQL_BINARY(sqltype)) {\n\t\t\t\tctype = SQL_C_BINARY;\n\t\t\t} else {\n\t\t\t\tctype = SQL_C_CHAR;\n\t\t\t}\n\n\t\t\tif (Z_STRLEN_PP(tmp) > 2 &&\n\t\t\t\tZ_STRVAL_PP(tmp)[0] == '\\'' &&\n\t\t\t\tZ_STRVAL_PP(tmp)[Z_STRLEN_PP(tmp) - 1] == '\\'') {\n\t\t\t\tif (strlen(Z_STRVAL_PP(tmp)) != Z_STRLEN_PP(tmp)) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\n\t\t\t\tfilename = estrndup(&Z_STRVAL_PP(tmp)[1], Z_STRLEN_PP(tmp) - 2);\n\n\t\t\t\t/* Check for safe mode. */\n\t\t\t\tif (PG(safe_mode) && (!php_checkuid(filename, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {\n\t\t\t\t\tefree(filename);\n\t\t\t\t\tefree(params);\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\n\t\t\t\t/* Check the basedir */\n\t\t\t\tif (php_check_open_basedir(filename TSRMLS_CC)) {\n\t\t\t\t\tefree(filename);\n\t\t\t\t\tSQLFreeStmt(result->stmt, SQL_RESET_PARAMS);\n\t\t\t\t\tfor (i = 0; i < result->numparams; i++) {\n\t\t\t\t\t\tif (params[i].fp != -1) {\n\t\t\t\t\t\t\tclose(params[i].fp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tefree(params);\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\n\t\t\t\tif ((params[i-1].fp = open(filename,O_RDONLY)) == -1) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\"Can't open file %s\", filename);\n\t\t\t\t\tSQLFreeStmt(result->stmt, SQL_RESET_PARAMS);\n\t\t\t\t\tfor (i = 0; i < result->numparams; i++) {\n\t\t\t\t\t\tif (params[i].fp != -1) {\n\t\t\t\t\t\t\tclose(params[i].fp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tefree(params);\n\t\t\t\t\tefree(filename);\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\n\t\t\t\tefree(filename);\n\n\t\t\t\tparams[i-1].vallen = SQL_LEN_DATA_AT_EXEC(0);\n\n\t\t\t\trc = SQLBindParameter(result->stmt, (SQLUSMALLINT)i, SQL_PARAM_INPUT,\n\t\t\t\t\t\t\t\t\t  ctype, sqltype, precision, scale,\n\t\t\t\t\t\t\t\t\t  (void *)params[i-1].fp, 0,\n\t\t\t\t\t\t\t\t\t  &params[i-1].vallen);\n\t\t\t} else {\n#ifdef HAVE_DBMAKER\n\t\t\t\tprecision = params[i-1].vallen;\n#endif\n\t\t\t\tif (otype == IS_NULL) {\n\t\t\t\t\tparams[i-1].vallen = SQL_NULL_DATA;\n\t\t\t\t}\n\n\t\t\t\trc = SQLBindParameter(result->stmt, (SQLUSMALLINT)i, SQL_PARAM_INPUT,\n\t\t\t\t\t\t\t\t\t  ctype, sqltype, precision, scale,\n\t\t\t\t\t\t\t\t\t  Z_STRVAL_PP(tmp), 0,\n\t\t\t\t\t\t\t\t\t  &params[i-1].vallen);\n\t\t\t}\n\t\t\tif (rc == SQL_ERROR) {\n\t\t\t\todbc_sql_error(result->conn_ptr, result->stmt, \"SQLBindParameter\");\t\n\t\t\t\tSQLFreeStmt(result->stmt, SQL_RESET_PARAMS);\n\t\t\t\tfor (i = 0; i < result->numparams; i++) {\n\t\t\t\t\tif (params[i].fp != -1) {\n\t\t\t\t\t\tclose(params[i].fp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tefree(params);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tzend_hash_move_forward(Z_ARRVAL_P(pv_param_arr));\n\t\t}\n\t}\n\t/* Close cursor, needed for doing multiple selects */\n\trc = SQLFreeStmt(result->stmt, SQL_CLOSE);\n\n\tif (rc == SQL_ERROR) {\n\t\todbc_sql_error(result->conn_ptr, result->stmt, \"SQLFreeStmt\");\t\n\t}\n\n\trc = SQLExecute(result->stmt);\n\n\tresult->fetched = 0;\n\tif (rc == SQL_NEED_DATA) {\n\t\tchar buf[4096];\n\t\tint fp, nbytes;\n\t\twhile (rc == SQL_NEED_DATA) {\n\t\t\trc = SQLParamData(result->stmt, (void*)&fp);\n\t\t\tif (rc == SQL_NEED_DATA) {\n\t\t\t\twhile ((nbytes = read(fp, &buf, 4096)) > 0) {\n\t\t\t\t\tSQLPutData(result->stmt, (void*)&buf, nbytes);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tswitch (rc) {\n\t\t\tcase SQL_SUCCESS:\n\t\t\t\tbreak;\n\t\t\tcase SQL_NO_DATA_FOUND:\n\t\t\tcase SQL_SUCCESS_WITH_INFO:\n\t\t\t\todbc_sql_error(result->conn_ptr, result->stmt, \"SQLExecute\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\todbc_sql_error(result->conn_ptr, result->stmt, \"SQLExecute\");\n\t\t\t\tRETVAL_FALSE;\n\t\t}\n\t}\t\n\t\n\tif (result->numparams > 0) {\n\t\tSQLFreeStmt(result->stmt, SQL_RESET_PARAMS);\n\t\tfor(i = 0; i < result->numparams; i++) {\n\t\t\tif (params[i].fp != -1) {\n\t\t\t\tclose(params[i].fp);\n\t\t\t}\n\t\t}\n\t\tefree(params);\n\t}\n\n\tif (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO || rc == SQL_NO_DATA_FOUND) {\n\t\tRETVAL_TRUE;\n\t}\n\n\tif (result->numcols == 0) {\n\t\tSQLNumResultCols(result->stmt, &(result->numcols));\n\n\t\tif (result->numcols > 0) {\n\t\t\tif (!odbc_bindcols(result TSRMLS_CC)) {\n\t\t\t\tefree(result);\n\t\t\t\tRETVAL_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tresult->values = NULL;\n\t\t}\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146623,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "\nprivate int\nmcopy(struct magic_set *ms, union VALUETYPE *p, int type, int indir,\n    const unsigned char *s, uint32_t offset, size_t nbytes, struct magic *m)\n{\n\t/*\n\t * Note: FILE_SEARCH and FILE_REGEX do not actually copy\n\t * anything, but setup pointers into the source\n\t */\n\tif (indir == 0) {\n\t\tswitch (type) {\n\t\tcase FILE_SEARCH:\n\t\t\tms->search.s = RCAST(const char *, s) + offset;\n\t\t\tms->search.s_len = nbytes - offset;\n\t\t\tms->search.offset = offset;\n\t\t\treturn 0;\n\n\t\tcase FILE_REGEX: {\n\t\t\tconst char *b;\n\t\t\tconst char *c;\n\t\t\tconst char *last;\t/* end of search region */\n\t\t\tconst char *buf;\t/* start of search region */\n\t\t\tconst char *end;\n\t\t\tsize_t lines, linecnt, bytecnt;\n\n\t\t\tlinecnt = m->str_range;\n\t\t\tbytecnt = linecnt * 80;\n\n\t\t\tif (bytecnt == 0) {\n\t\t\t\tbytecnt = 8192;\n\t\t\t}\n\t\t\tif (bytecnt > nbytes) {\n\t\t\t\tbytecnt = nbytes;\n\t\t\t}\n\t\t\tif (s == NULL) {\n\t\t\t\tms->search.s_len = 0;\n\t\t\t\tms->search.s = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbuf = RCAST(const char *, s) + offset;\n\t\t\tend = last = RCAST(const char *, s) + bytecnt;\n\t\t\t/* mget() guarantees buf <= last */\n\t\t\tfor (lines = linecnt, b = buf; lines && b < end &&\n\t\t\t     ((b = CAST(const char *,\n\t\t\t\t memchr(c = b, '\\n', CAST(size_t, (end - b)))))\n\t\t\t     || (b = CAST(const char *,\n\t\t\t\t memchr(c, '\\r', CAST(size_t, (end - c))))));\n\t\t\t     lines--, b++) {\n\t\t\t\tlast = b;\n\t\t\t\tif (b[0] == '\\r' && b[1] == '\\n')\n\t\t\t\t\tb++;\n\t\t\t}\n\t\t\tif (lines)\n\t\t\t\tlast = RCAST(const char *, s) + bytecnt;\n\n\t\t\tms->search.s = buf;\n\t\t\tms->search.s_len = last - buf;\n\t\t\tms->search.offset = offset;\n\t\t\tms->search.rm_len = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16: {\n\t\t\tconst unsigned char *src = s + offset;\n\t\t\tconst unsigned char *esrc = s + nbytes;\n\t\t\tchar *dst = p->s;\n\t\t\tchar *edst = &p->s[sizeof(p->s) - 1];\n\n\t\t\tif (type == FILE_BESTRING16)\n\t\t\t\tsrc++;\n\n\t\t\t/* check that offset is within range */\n\t\t\tif (offset >= nbytes) {\n\t\t\t\tfile_magerror(ms, \"invalid offset %u in mcopy()\",\n\t\t\t\t    offset);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (/*EMPTY*/; src < esrc; src += 2, dst++) {\n\t\t\t\tif (dst < edst)\n\t\t\t\t\t*dst = *src;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t\tif (*dst == '\\0') {\n\t\t\t\t\tif (type == FILE_BESTRING16 ?\n\t\t\t\t\t    *(src - 1) != '\\0' :\n\t\t\t\t\t    *(src + 1) != '\\0')\n\t\t\t\t\t\t*dst = ' ';\n\t\t\t\t}\n\t\t\t}\n\t\t\t*edst = '\\0';\n\t\t\treturn 0;\n\t\t}\n\t\tcase FILE_STRING:\t/* XXX - these two should not need */\n\t\tcase FILE_PSTRING:\t/* to copy anything, but do anyway. */\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (offset >= nbytes) {\n\t\t(void)memset(p, '\\0', sizeof(*p));\n\t\treturn 0;\n\t}\n\tif (nbytes - offset < sizeof(*p))\n\t\tnbytes = nbytes - offset;\n\telse\n\t\tnbytes = sizeof(*p);\n\n\t(void)memcpy(p, s + offset, nbytes);\n\n\t/*\n\t * the usefulness of padding with zeroes eludes me, it\n\t * might even cause problems\n\t */\n\tif (nbytes < sizeof(*p))\n\t\t(void)memset(((char *)(void *)p) + nbytes, '\\0',\n\t\t    sizeof(*p) - nbytes);",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146668,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "\nprivate int\nmcopy(struct magic_set *ms, union VALUETYPE *p, int type, int indir,\n    const unsigned char *s, uint32_t offset, size_t nbytes, struct magic *m)\n{\n\t/*\n\t * Note: FILE_SEARCH and FILE_REGEX do not actually copy\n\t * anything, but setup pointers into the source\n\t */\n\tif (indir == 0) {\n\t\tswitch (type) {\n\t\tcase FILE_SEARCH:\n\t\t\tms->search.s = RCAST(const char *, s) + offset;\n\t\t\tms->search.s_len = nbytes - offset;\n\t\t\tms->search.offset = offset;\n\t\t\treturn 0;\n\n\t\tcase FILE_REGEX: {\n\t\t\tconst char *b;\n\t\t\tconst char *c;\n\t\t\tconst char *last;\t/* end of search region */\n\t\t\tconst char *buf;\t/* start of search region */\n\t\t\tconst char *end;\n\t\t\tsize_t lines, linecnt, bytecnt;\n\n\t\t\tlinecnt = m->str_range;\n\t\t\tbytecnt = linecnt * 80;\n\n\t\t\tif (bytecnt == 0) {\n\t\t\t\tbytecnt = 8192;\n\t\t\t}\n\t\t\tif (bytecnt > nbytes) {\n\t\t\t\tbytecnt = nbytes;\n\t\t\t}\n\t\t\tif (offset > bytecnt) {\n\t\t\t\toffset = bytecnt;\n\t\t\t}\n\t\t\tif (s == NULL) {\n\t\t\t\tms->search.s_len = 0;\n\t\t\t\tms->search.s = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbuf = RCAST(const char *, s) + offset;\n\t\t\tend = last = RCAST(const char *, s) + bytecnt;\n\t\t\t/* mget() guarantees buf <= last */\n\t\t\tfor (lines = linecnt, b = buf; lines && b < end &&\n\t\t\t     ((b = CAST(const char *,\n\t\t\t\t memchr(c = b, '\\n', CAST(size_t, (end - b)))))\n\t\t\t     || (b = CAST(const char *,\n\t\t\t\t memchr(c, '\\r', CAST(size_t, (end - c))))));\n\t\t\t     lines--, b++) {\n\t\t\t\tlast = b;\n\t\t\t\tif (b[0] == '\\r' && b[1] == '\\n')\n\t\t\t\t\tb++;\n\t\t\t}\n\t\t\tif (lines)\n\t\t\t\tlast = RCAST(const char *, s) + bytecnt;\n\n\t\t\tms->search.s = buf;\n\t\t\tms->search.s_len = last - buf;\n\t\t\tms->search.offset = offset;\n\t\t\tms->search.rm_len = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16: {\n\t\t\tconst unsigned char *src = s + offset;\n\t\t\tconst unsigned char *esrc = s + nbytes;\n\t\t\tchar *dst = p->s;\n\t\t\tchar *edst = &p->s[sizeof(p->s) - 1];\n\n\t\t\tif (type == FILE_BESTRING16)\n\t\t\t\tsrc++;\n\n\t\t\t/* check that offset is within range */\n\t\t\tif (offset >= nbytes) {\n\t\t\t\tfile_magerror(ms, \"invalid offset %u in mcopy()\",\n\t\t\t\t    offset);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (/*EMPTY*/; src < esrc; src += 2, dst++) {\n\t\t\t\tif (dst < edst)\n\t\t\t\t\t*dst = *src;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t\tif (*dst == '\\0') {\n\t\t\t\t\tif (type == FILE_BESTRING16 ?\n\t\t\t\t\t    *(src - 1) != '\\0' :\n\t\t\t\t\t    *(src + 1) != '\\0')\n\t\t\t\t\t\t*dst = ' ';\n\t\t\t\t}\n\t\t\t}\n\t\t\t*edst = '\\0';\n\t\t\treturn 0;\n\t\t}\n\t\tcase FILE_STRING:\t/* XXX - these two should not need */\n\t\tcase FILE_PSTRING:\t/* to copy anything, but do anyway. */\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (offset >= nbytes) {\n\t\t(void)memset(p, '\\0', sizeof(*p));\n\t\treturn 0;\n\t}\n\tif (nbytes - offset < sizeof(*p))\n\t\tnbytes = nbytes - offset;\n\telse\n\t\tnbytes = sizeof(*p);\n\n\t(void)memcpy(p, s + offset, nbytes);\n\n\t/*\n\t * the usefulness of padding with zeroes eludes me, it\n\t * might even cause problems\n\t */\n\tif (nbytes < sizeof(*p))\n\t\t(void)memset(((char *)(void *)p) + nbytes, '\\0',\n\t\t    sizeof(*p) - nbytes);",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146669,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "PHPAPI php_url *php_url_parse_ex(char const *str, int length)\n{\n\tchar port_buf[6];\n\tphp_url *ret = ecalloc(1, sizeof(php_url));\n\tchar const *s, *e, *p, *pp, *ue;\n\n\ts = str;\n\tue = s + length;\n\n\t/* parse scheme */\n\tif ((e = memchr(s, ':', length)) && (e - s)) {\n\t\t/* validate scheme */\n\t\tp = s;\n\t\twhile (p < e) {\n\t\t\t/* scheme = 1*[ lowalpha | digit | \"+\" | \"-\" | \".\" ] */\n\t\t\tif (!isalpha(*p) && !isdigit(*p) && *p != '+' && *p != '.' && *p != '-') {\n\t\t\t\tif (e + 1 < ue) {\n\t\t\t\t\tgoto parse_port;\n\t\t\t\t} else {\n\t\t\t\t\tgoto just_path;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\n\t\tif (*(e + 1) == '\\0') { /* only scheme is available */\n\t\t\tret->scheme = estrndup(s, (e - s));\n\t\t\tphp_replace_controlchars_ex(ret->scheme, (e - s));\n\t\t\tgoto end;\n\t\t}\n\n\t\t/*\n\t\t * certain schemas like mailto: and zlib: may not have any / after them\n\t\t * this check ensures we support those.\n\t\t */\n\t\tif (*(e+1) != '/') {\n\t\t\t/* check if the data we get is a port this allows us to\n\t\t\t * correctly parse things like a.com:80\n\t\t\t */\n\t\t\tp = e + 1;\n\t\t\twhile (isdigit(*p)) {\n\t\t\t\tp++;\n\t\t\t}\n\n\t\t\tif ((*p == '\\0' || *p == '/') && (p - e) < 7) {\n\t\t\t\tgoto parse_port;\n\t\t\t}\n\n\t\t\tret->scheme = estrndup(s, (e-s));\n\t\t\tphp_replace_controlchars_ex(ret->scheme, (e - s));\n\n\t\t\tlength -= ++e - s;\n\t\t\ts = e;\n\t\t\tgoto just_path;\n\t\t} else {\n\t\t\tret->scheme = estrndup(s, (e-s));\n\t\t\tphp_replace_controlchars_ex(ret->scheme, (e - s));\n\n\t\t\tif (*(e+2) == '/') {\n\t\t\t\ts = e + 3;\n\t\t\t\tif (!strncasecmp(\"file\", ret->scheme, sizeof(\"file\"))) {\n\t\t\t\t\tif (*(e + 3) == '/') {\n\t\t\t\t\t\t/* support windows drive letters as in:\n\t\t\t\t\t\t   file:///c:/somedir/file.txt\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tif (*(e + 5) == ':') {\n\t\t\t\t\t\t\ts = e + 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto nohost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!strncasecmp(\"file\", ret->scheme, sizeof(\"file\"))) {\n\t\t\t\t\ts = e + 1;\n\t\t\t\t\tgoto nohost;\n\t\t\t\t} else {\n\t\t\t\t\tlength -= ++e - s;\n\t\t\t\t\ts = e;\n\t\t\t\t\tgoto just_path;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (e) { /* no scheme; starts with colon: look for port */\n\t\tparse_port:\n\t\tp = e + 1;\n\t\tpp = p;\n\n\t\twhile (pp-p < 6 && isdigit(*pp)) {\n\t\t\tpp++;\n\t\t}\n\n\t\tif (pp - p > 0 && pp - p < 6 && (*pp == '/' || *pp == '\\0')) {\n\t\t\tlong port;\n\t\t\tmemcpy(port_buf, p, (pp - p));\n\t\t\tport_buf[pp - p] = '\\0';\n\t\t\tport = strtol(port_buf, NULL, 10);\n\t\t\tif (port > 0 && port <= 65535) {\n\t\t\t\tret->port = (unsigned short) port;\n\t\t\t\tif (*s == '/' && *(s + 1) == '/') { /* relative-scheme URL */\n\t\t\t\t    s += 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSTR_FREE(ret->scheme);\n\t\t\t\tefree(ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else if (p == pp && *pp == '\\0') {\n\t\t\tSTR_FREE(ret->scheme);\n\t\t\tefree(ret);\n\t\t\treturn NULL;\n\t\t} else if (*s == '/' && *(s + 1) == '/') { /* relative-scheme URL */\n\t\t\ts += 2;\n\t\t} else {\n\t\t\tgoto just_path;\n\t\t}\n\t} else if (*s == '/' && *(s + 1) == '/') { /* relative-scheme URL */\n\t\ts += 2;\n\t} else {\n\t\tjust_path:\n\t\tue = s + length;\n\t\tgoto nohost;\n\t}\n\n\te = ue;\n\n\tif (!(p = memchr(s, '/', (ue - s)))) {\n\t\tchar *query, *fragment;\n\n\t\tquery = memchr(s, '?', (ue - s));\n\t\tfragment = memchr(s, '#', (ue - s));\n\n\t\tif (query && fragment) {\n\t\t\tif (query > fragment) {\n\t\t\t\te = fragment;\n\t\t\t} else {\n\t\t\t\te = query;\n\t\t\t}\n\t\t} else if (query) {\n\t\t\te = query;\n\t\t} else if (fragment) {\n\t\t\te = fragment;\n\t\t}\n\t} else {\n\t\te = p;\n\t}\n\n\t/* check for login and password */\n\tif ((p = zend_memrchr(s, '@', (e-s)))) {\n\t\tif ((pp = memchr(s, ':', (p-s)))) {\n\t\t\tret->user = estrndup(s, (pp-s));\n\t\t\tphp_replace_controlchars_ex(ret->user, (pp - s));\n\n\t\t\tpp++;\n\t\t\tret->pass = estrndup(pp, (p-pp));\n\t\t\tphp_replace_controlchars_ex(ret->pass, (p-pp));\n\t\t} else {\n\t\t\tret->user = estrndup(s, (p-s));\n\t\t\tphp_replace_controlchars_ex(ret->user, (p-s));\n\t\t}\n\n\t\ts = p + 1;\n\t}\n\n\t/* check for port */\n\tif (*s == '[' && *(e-1) == ']') {\n\t\t/* Short circuit portscan,\n\t\t   we're dealing with an\n\t\t   IPv6 embedded address */\n\t\tp = s;\n\t} else {\n\t\t/* memrchr is a GNU specific extension\n\t\t   Emulate for wide compatibility */\n\t\tfor(p = e; p >= s && *p != ':'; p--);\n\t}\n\n\tif (p >= s && *p == ':') {\n\t\tif (!ret->port) {\n\t\t\tp++;\n\t\t\tif (e-p > 5) { /* port cannot be longer then 5 characters */\n\t\t\t\tSTR_FREE(ret->scheme);\n\t\t\t\tSTR_FREE(ret->user);\n\t\t\t\tSTR_FREE(ret->pass);\n\t\t\t\tefree(ret);\n\t\t\t\treturn NULL;\n\t\t\t} else if (e - p > 0) {\n\t\t\t\tlong port;\n\t\t\t\tmemcpy(port_buf, p, (e - p));\n\t\t\t\tport_buf[e - p] = '\\0';\n\t\t\t\tport = strtol(port_buf, NULL, 10);\n\t\t\t\tif (port > 0 && port <= 65535) {\n\t\t\t\t\tret->port = (unsigned short)port;\n\t\t\t\t} else {\n\t\t\t\t\tSTR_FREE(ret->scheme);\n\t\t\t\t\tSTR_FREE(ret->user);\n\t\t\t\t\tSTR_FREE(ret->pass);\n\t\t\t\t\tefree(ret);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp--;\n\t\t}\n\t} else {\n\t\tp = e;\n\t}\n\n\t/* check if we have a valid host, if we don't reject the string as url */\n\tif ((p-s) < 1) {\n\t\tSTR_FREE(ret->scheme);\n\t\tSTR_FREE(ret->user);\n\t\tSTR_FREE(ret->pass);\n\t\tefree(ret);\n\t\treturn NULL;\n\t}\n\n\tret->host = estrndup(s, (p-s));\n\tphp_replace_controlchars_ex(ret->host, (p - s));\n\n\tif (e == ue) {\n\t\treturn ret;\n\t}\n\n\ts = e;\n\n\tnohost:\n\n\tif ((p = memchr(s, '?', (ue - s)))) {\n\t\tpp = memchr(s, '#', (ue - s));\n\n\t\tif (pp && pp < p) {\n\t\t\tif (pp - s) {\n\t\t\t\tret->path = estrndup(s, (pp-s));\n\t\t\t\tphp_replace_controlchars_ex(ret->path, (pp - s));\n\t\t\t}\n\t\t\tp = pp;\n\t\t\tgoto label_parse;\n\t\t}\n\n\t\tif (p - s) {\n\t\t\tret->path = estrndup(s, (p-s));\n\t\t\tphp_replace_controlchars_ex(ret->path, (p - s));\n\t\t}\n\n\t\tif (pp) {\n\t\t\tif (pp - ++p) {\n\t\t\t\tret->query = estrndup(p, (pp-p));\n\t\t\t\tphp_replace_controlchars_ex(ret->query, (pp - p));\n\t\t\t}\n\t\t\tp = pp;\n\t\t\tgoto label_parse;\n\t\t} else if (++p - ue) {\n\t\t\tret->query = estrndup(p, (ue-p));\n\t\t\tphp_replace_controlchars_ex(ret->query, (ue - p));\n\t\t}\n\t} else if ((p = memchr(s, '#', (ue - s)))) {\n\t\tif (p - s) {\n\t\t\tret->path = estrndup(s, (p-s));\n\t\t\tphp_replace_controlchars_ex(ret->path, (p - s));\n\t\t}\n\n\t\tlabel_parse:\n\t\tp++;\n\n\t\tif (ue - p) {\n\t\t\tret->fragment = estrndup(p, (ue-p));\n\t\t\tphp_replace_controlchars_ex(ret->fragment, (ue - p));\n\t\t}\n\t} else {\n\t\tret->path = estrndup(s, (ue-s));\n\t\tphp_replace_controlchars_ex(ret->path, (ue - s));\n\t}\nend:\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146702,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "PHPAPI php_url *php_url_parse_ex(char const *str, int length)\n{\n\tchar port_buf[6];\n\tphp_url *ret = ecalloc(1, sizeof(php_url));\n\tchar const *s, *e, *p, *pp, *ue;\n\n\ts = str;\n\tue = s + length;\n\n\t/* parse scheme */\n\tif ((e = memchr(s, ':', length)) && (e - s)) {\n\t\t/* validate scheme */\n\t\tp = s;\n\t\twhile (p < e) {\n\t\t\t/* scheme = 1*[ lowalpha | digit | \"+\" | \"-\" | \".\" ] */\n\t\t\tif (!isalpha(*p) && !isdigit(*p) && *p != '+' && *p != '.' && *p != '-') {\n\t\t\t\tif (e + 1 < ue) {\n\t\t\t\t\tgoto parse_port;\n\t\t\t\t} else {\n\t\t\t\t\tgoto just_path;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\n\t\tif (*(e + 1) == '\\0') { /* only scheme is available */\n\t\t\tret->scheme = estrndup(s, (e - s));\n\t\t\tphp_replace_controlchars_ex(ret->scheme, (e - s));\n\t\t\tgoto end;\n\t\t}\n\n\t\t/*\n\t\t * certain schemas like mailto: and zlib: may not have any / after them\n\t\t * this check ensures we support those.\n\t\t */\n\t\tif (*(e+1) != '/') {\n\t\t\t/* check if the data we get is a port this allows us to\n\t\t\t * correctly parse things like a.com:80\n\t\t\t */\n\t\t\tp = e + 1;\n\t\t\twhile (isdigit(*p)) {\n\t\t\t\tp++;\n\t\t\t}\n\n\t\t\tif ((*p == '\\0' || *p == '/') && (p - e) < 7) {\n\t\t\t\tgoto parse_port;\n\t\t\t}\n\n\t\t\tret->scheme = estrndup(s, (e-s));\n\t\t\tphp_replace_controlchars_ex(ret->scheme, (e - s));\n\n\t\t\tlength -= ++e - s;\n\t\t\ts = e;\n\t\t\tgoto just_path;\n\t\t} else {\n\t\t\tret->scheme = estrndup(s, (e-s));\n\t\t\tphp_replace_controlchars_ex(ret->scheme, (e - s));\n\n\t\t\tif (*(e+2) == '/') {\n\t\t\t\ts = e + 3;\n\t\t\t\tif (!strncasecmp(\"file\", ret->scheme, sizeof(\"file\"))) {\n\t\t\t\t\tif (*(e + 3) == '/') {\n\t\t\t\t\t\t/* support windows drive letters as in:\n\t\t\t\t\t\t   file:///c:/somedir/file.txt\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tif (*(e + 5) == ':') {\n\t\t\t\t\t\t\ts = e + 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto nohost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!strncasecmp(\"file\", ret->scheme, sizeof(\"file\"))) {\n\t\t\t\t\ts = e + 1;\n\t\t\t\t\tgoto nohost;\n\t\t\t\t} else {\n\t\t\t\t\tlength -= ++e - s;\n\t\t\t\t\ts = e;\n\t\t\t\t\tgoto just_path;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (e) { /* no scheme; starts with colon: look for port */\n\t\tparse_port:\n\t\tp = e + 1;\n\t\tpp = p;\n\n\t\twhile (pp-p < 6 && isdigit(*pp)) {\n\t\t\tpp++;\n\t\t}\n\n\t\tif (pp - p > 0 && pp - p < 6 && (*pp == '/' || *pp == '\\0')) {\n\t\t\tlong port;\n\t\t\tmemcpy(port_buf, p, (pp - p));\n\t\t\tport_buf[pp - p] = '\\0';\n\t\t\tport = strtol(port_buf, NULL, 10);\n\t\t\tif (port > 0 && port <= 65535) {\n\t\t\t\tret->port = (unsigned short) port;\n\t\t\t\tif (*s == '/' && *(s + 1) == '/') { /* relative-scheme URL */\n\t\t\t\t    s += 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSTR_FREE(ret->scheme);\n\t\t\t\tefree(ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else if (p == pp && *pp == '\\0') {\n\t\t\tSTR_FREE(ret->scheme);\n\t\t\tefree(ret);\n\t\t\treturn NULL;\n\t\t} else if (*s == '/' && *(s + 1) == '/') { /* relative-scheme URL */\n\t\t\ts += 2;\n\t\t} else {\n\t\t\tgoto just_path;\n\t\t}\n\t} else if (*s == '/' && *(s + 1) == '/') { /* relative-scheme URL */\n\t\ts += 2;\n\t} else {\n\t\tjust_path:\n\t\tue = s + length;\n\t\tgoto nohost;\n\t}\n\n\te = s + strcspn(s, \"/?#\");\n\n\t/* check for login and password */\n\tif ((p = zend_memrchr(s, '@', (e-s)))) {\n\t\tif ((pp = memchr(s, ':', (p-s)))) {\n\t\t\tret->user = estrndup(s, (pp-s));\n\t\t\tphp_replace_controlchars_ex(ret->user, (pp - s));\n\n\t\t\tpp++;\n\t\t\tret->pass = estrndup(pp, (p-pp));\n\t\t\tphp_replace_controlchars_ex(ret->pass, (p-pp));\n\t\t} else {\n\t\t\tret->user = estrndup(s, (p-s));\n\t\t\tphp_replace_controlchars_ex(ret->user, (p-s));\n\t\t}\n\n\t\ts = p + 1;\n\t}\n\n\t/* check for port */\n\tif (*s == '[' && *(e-1) == ']') {\n\t\t/* Short circuit portscan,\n\t\t   we're dealing with an\n\t\t   IPv6 embedded address */\n\t\tp = s;\n\t} else {\n\t\t/* memrchr is a GNU specific extension\n\t\t   Emulate for wide compatibility */\n\t\tfor(p = e; p >= s && *p != ':'; p--);\n\t}\n\n\tif (p >= s && *p == ':') {\n\t\tif (!ret->port) {\n\t\t\tp++;\n\t\t\tif (e-p > 5) { /* port cannot be longer then 5 characters */\n\t\t\t\tSTR_FREE(ret->scheme);\n\t\t\t\tSTR_FREE(ret->user);\n\t\t\t\tSTR_FREE(ret->pass);\n\t\t\t\tefree(ret);\n\t\t\t\treturn NULL;\n\t\t\t} else if (e - p > 0) {\n\t\t\t\tlong port;\n\t\t\t\tmemcpy(port_buf, p, (e - p));\n\t\t\t\tport_buf[e - p] = '\\0';\n\t\t\t\tport = strtol(port_buf, NULL, 10);\n\t\t\t\tif (port > 0 && port <= 65535) {\n\t\t\t\t\tret->port = (unsigned short)port;\n\t\t\t\t} else {\n\t\t\t\t\tSTR_FREE(ret->scheme);\n\t\t\t\t\tSTR_FREE(ret->user);\n\t\t\t\t\tSTR_FREE(ret->pass);\n\t\t\t\t\tefree(ret);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp--;\n\t\t}\n\t} else {\n\t\tp = e;\n\t}\n\n\t/* check if we have a valid host, if we don't reject the string as url */\n\tif ((p-s) < 1) {\n\t\tSTR_FREE(ret->scheme);\n\t\tSTR_FREE(ret->user);\n\t\tSTR_FREE(ret->pass);\n\t\tefree(ret);\n\t\treturn NULL;\n\t}\n\n\tret->host = estrndup(s, (p-s));\n\tphp_replace_controlchars_ex(ret->host, (p - s));\n\n\tif (e == ue) {\n\t\treturn ret;\n\t}\n\n\ts = e;\n\n\tnohost:\n\n\tif ((p = memchr(s, '?', (ue - s)))) {\n\t\tpp = memchr(s, '#', (ue - s));\n\n\t\tif (pp && pp < p) {\n\t\t\tif (pp - s) {\n\t\t\t\tret->path = estrndup(s, (pp-s));\n\t\t\t\tphp_replace_controlchars_ex(ret->path, (pp - s));\n\t\t\t}\n\t\t\tp = pp;\n\t\t\tgoto label_parse;\n\t\t}\n\n\t\tif (p - s) {\n\t\t\tret->path = estrndup(s, (p-s));\n\t\t\tphp_replace_controlchars_ex(ret->path, (p - s));\n\t\t}\n\n\t\tif (pp) {\n\t\t\tif (pp - ++p) {\n\t\t\t\tret->query = estrndup(p, (pp-p));\n\t\t\t\tphp_replace_controlchars_ex(ret->query, (pp - p));\n\t\t\t}\n\t\t\tp = pp;\n\t\t\tgoto label_parse;\n\t\t} else if (++p - ue) {\n\t\t\tret->query = estrndup(p, (ue-p));\n\t\t\tphp_replace_controlchars_ex(ret->query, (ue - p));\n\t\t}\n\t} else if ((p = memchr(s, '#', (ue - s)))) {\n\t\tif (p - s) {\n\t\t\tret->path = estrndup(s, (p-s));\n\t\t\tphp_replace_controlchars_ex(ret->path, (p - s));\n\t\t}\n\n\t\tlabel_parse:\n\t\tp++;\n\n\t\tif (ue - p) {\n\t\t\tret->fragment = estrndup(p, (ue-p));\n\t\t\tphp_replace_controlchars_ex(ret->fragment, (ue - p));\n\t\t}\n\t} else {\n\t\tret->path = estrndup(s, (ue-s));\n\t\tphp_replace_controlchars_ex(ret->path, (ue - s));\n\t}\nend:\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146703,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "i915_gem_execbuffer2_ioctl(struct drm_device *dev, void *data,\n\t\t\t   struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n\tstruct drm_i915_gem_exec_object2 *exec2_list;\n\tstruct drm_syncobj **fences = NULL;\n\tconst size_t count = args->buffer_count;\n\tint err;\n\n\tif (!check_buffer_count(count)) {\n\t\tDRM_DEBUG(\"execbuf2 with %zd buffers\\n\", count);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!i915_gem_check_execbuffer(args))\n\t\treturn -EINVAL;\n\n\t/* Allocate an extra slot for use by the command parser */\n\texec2_list = kvmalloc_array(count + 1, eb_element_size(),\n\t\t\t\t    __GFP_NOWARN | GFP_KERNEL);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %zd buffers\\n\",\n\t\t\t  count);\n\t\treturn -ENOMEM;\n\t}\n\tif (copy_from_user(exec2_list,\n\t\t\t   u64_to_user_ptr(args->buffers_ptr),\n\t\t\t   sizeof(*exec2_list) * count)) {\n\t\tDRM_DEBUG(\"copy %zd exec entries failed\\n\", count);\n\t\tkvfree(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\n\tif (args->flags & I915_EXEC_FENCE_ARRAY) {\n\t\tfences = get_fence_array(args, file);\n\t\tif (IS_ERR(fences)) {\n\t\t\tkvfree(exec2_list);\n\t\t\treturn PTR_ERR(fences);\n\t\t}\n\t}\n\n\terr = i915_gem_do_execbuffer(dev, file, args, exec2_list, fences);\n\n\t/*\n\t * Now that we have begun execution of the batchbuffer, we ignore\n\t * any new error after this point. Also given that we have already\n\t * updated the associated relocations, we try to write out the current\n\t * object locations irrespective of any error.\n\t */\n\tif (args->flags & __EXEC_HAS_RELOC) {\n\t\tstruct drm_i915_gem_exec_object2 __user *user_exec_list =\n\t\t\tu64_to_user_ptr(args->buffers_ptr);\n\t\tunsigned int i;\n\n\t\t/* Copy the new buffer offsets back to the user's exec list. */\n\t\tuser_access_begin();\n\t\tfor (i = 0; i < args->buffer_count; i++) {\n\t\t\tif (!(exec2_list[i].offset & UPDATE))\n\t\t\t\tcontinue;\n\n\t\t\texec2_list[i].offset =\n\t\t\t\tgen8_canonical_addr(exec2_list[i].offset & PIN_OFFSET_MASK);\n\t\t\tunsafe_put_user(exec2_list[i].offset,\n\t\t\t\t\t&user_exec_list[i].offset,\n\t\t\t\t\tend_user);\n\t\t}\nend_user:\n\t\tuser_access_end();\n\t}\n\n\targs->flags &= ~__I915_EXEC_UNKNOWN_FLAGS;\n\tput_fence_array(args, fences);\n\tkvfree(exec2_list);\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146734,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "i915_gem_execbuffer2_ioctl(struct drm_device *dev, void *data,\n\t\t\t   struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n\tstruct drm_i915_gem_exec_object2 *exec2_list;\n\tstruct drm_syncobj **fences = NULL;\n\tconst size_t count = args->buffer_count;\n\tint err;\n\n\tif (!check_buffer_count(count)) {\n\t\tDRM_DEBUG(\"execbuf2 with %zd buffers\\n\", count);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!i915_gem_check_execbuffer(args))\n\t\treturn -EINVAL;\n\n\t/* Allocate an extra slot for use by the command parser */\n\texec2_list = kvmalloc_array(count + 1, eb_element_size(),\n\t\t\t\t    __GFP_NOWARN | GFP_KERNEL);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %zd buffers\\n\",\n\t\t\t  count);\n\t\treturn -ENOMEM;\n\t}\n\tif (copy_from_user(exec2_list,\n\t\t\t   u64_to_user_ptr(args->buffers_ptr),\n\t\t\t   sizeof(*exec2_list) * count)) {\n\t\tDRM_DEBUG(\"copy %zd exec entries failed\\n\", count);\n\t\tkvfree(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\n\tif (args->flags & I915_EXEC_FENCE_ARRAY) {\n\t\tfences = get_fence_array(args, file);\n\t\tif (IS_ERR(fences)) {\n\t\t\tkvfree(exec2_list);\n\t\t\treturn PTR_ERR(fences);\n\t\t}\n\t}\n\n\terr = i915_gem_do_execbuffer(dev, file, args, exec2_list, fences);\n\n\t/*\n\t * Now that we have begun execution of the batchbuffer, we ignore\n\t * any new error after this point. Also given that we have already\n\t * updated the associated relocations, we try to write out the current\n\t * object locations irrespective of any error.\n\t */\n\tif (args->flags & __EXEC_HAS_RELOC) {\n\t\tstruct drm_i915_gem_exec_object2 __user *user_exec_list =\n\t\t\tu64_to_user_ptr(args->buffers_ptr);\n\t\tunsigned int i;\n\n\t\t/* Copy the new buffer offsets back to the user's exec list. */\n\t\t/*\n\t\t * Note: count * sizeof(*user_exec_list) does not overflow,\n\t\t * because we checked 'count' in check_buffer_count().\n\t\t *\n\t\t * And this range already got effectively checked earlier\n\t\t * when we did the \"copy_from_user()\" above.\n\t\t */\n\t\tif (!user_access_begin(user_exec_list, count * sizeof(*user_exec_list)))\n\t\t\tgoto end_user;\n\n\t\tfor (i = 0; i < args->buffer_count; i++) {\n\t\t\tif (!(exec2_list[i].offset & UPDATE))\n\t\t\t\tcontinue;\n\n\t\t\texec2_list[i].offset =\n\t\t\t\tgen8_canonical_addr(exec2_list[i].offset & PIN_OFFSET_MASK);\n\t\t\tunsafe_put_user(exec2_list[i].offset,\n\t\t\t\t\t&user_exec_list[i].offset,\n\t\t\t\t\tend_user);\n\t\t}\nend_user:\n\t\tuser_access_end();\n\t}\n\n\targs->flags &= ~__I915_EXEC_UNKNOWN_FLAGS;\n\tput_fence_array(args, fences);\n\tkvfree(exec2_list);\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146735,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int cloop_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVCloopState *s = bs->opaque;\n    uint32_t offsets_size, max_compressed_block_size = 1, i;\n    int ret;\n\n    bs->read_only = 1;\n\n    /* read header */\n    ret = bdrv_pread(bs->file, 128, &s->block_size, 4);\n    if (ret < 0) {\n        return ret;\n    }\n    s->block_size = be32_to_cpu(s->block_size);\n    if (s->block_size % 512) {\n        error_setg(errp, \"block_size %u must be a multiple of 512\",\n                   s->block_size);\n        return -EINVAL;\n    }\n    if (s->block_size == 0) {\n        error_setg(errp, \"block_size cannot be zero\");\n        return -EINVAL;\n    }\n\n    /* cloop's create_compressed_fs.c warns about block sizes beyond 256 KB but\n     * we can accept more.  Prevent ridiculous values like 4 GB - 1 since we\n     * need a buffer this big.\n     */\n    if (s->block_size > MAX_BLOCK_SIZE) {\n        error_setg(errp, \"block_size %u must be %u MB or less\",\n                   s->block_size,\n                   MAX_BLOCK_SIZE / (1024 * 1024));\n        return -EINVAL;\n    }\n\n    ret = bdrv_pread(bs->file, 128 + 4, &s->n_blocks, 4);\n    if (ret < 0) {\n        return ret;\n    }\n    s->n_blocks = be32_to_cpu(s->n_blocks);\n\n    /* read offsets */\n    if (s->n_blocks > UINT32_MAX / sizeof(uint64_t)) {\n        /* Prevent integer overflow */\n        error_setg(errp, \"n_blocks %u must be %zu or less\",\n                   s->n_blocks,\n                   UINT32_MAX / sizeof(uint64_t));\n        return -EINVAL;\n    }\n    offsets_size = s->n_blocks * sizeof(uint64_t);\n    if (offsets_size > 512 * 1024 * 1024) {\n        /* Prevent ridiculous offsets_size which causes memory allocation to\n         * fail or overflows bdrv_pread() size.  In practice the 512 MB\n         * offsets[] limit supports 16 TB images at 256 KB block size.\n         */\n        error_setg(errp, \"image requires too many offsets, \"\n                   \"try increasing block size\");\n        return -EINVAL;\n    }\n    s->offsets = g_malloc(offsets_size);\n\n    ret = bdrv_pread(bs->file, 128 + 4 + 4, s->offsets, offsets_size);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    for(i=0;i<s->n_blocks;i++) {\n        s->offsets[i] = be64_to_cpu(s->offsets[i]);\n        if (i > 0) {\n            uint32_t size = s->offsets[i] - s->offsets[i - 1];\n            if (size > max_compressed_block_size) {\n                max_compressed_block_size = size;\n            }\n        }\n    }\n\n    /* initialize zlib engine */\n    s->compressed_block = g_malloc(max_compressed_block_size + 1);\n    s->uncompressed_block = g_malloc(s->block_size);\n    if (inflateInit(&s->zstream) != Z_OK) {\n        ret = -EINVAL;\n        goto fail;\n    }\n    s->current_block = s->n_blocks;\n\n    s->sectors_per_block = s->block_size/512;\n    bs->total_sectors = s->n_blocks * s->sectors_per_block;\n    qemu_co_mutex_init(&s->lock);\n    return 0;\n\nfail:\n    g_free(s->offsets);\n    g_free(s->compressed_block);\n    g_free(s->uncompressed_block);\n    return ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146828,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int cloop_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVCloopState *s = bs->opaque;\n    uint32_t offsets_size, max_compressed_block_size = 1, i;\n    int ret;\n\n    bs->read_only = 1;\n\n    /* read header */\n    ret = bdrv_pread(bs->file, 128, &s->block_size, 4);\n    if (ret < 0) {\n        return ret;\n    }\n    s->block_size = be32_to_cpu(s->block_size);\n    if (s->block_size % 512) {\n        error_setg(errp, \"block_size %u must be a multiple of 512\",\n                   s->block_size);\n        return -EINVAL;\n    }\n    if (s->block_size == 0) {\n        error_setg(errp, \"block_size cannot be zero\");\n        return -EINVAL;\n    }\n\n    /* cloop's create_compressed_fs.c warns about block sizes beyond 256 KB but\n     * we can accept more.  Prevent ridiculous values like 4 GB - 1 since we\n     * need a buffer this big.\n     */\n    if (s->block_size > MAX_BLOCK_SIZE) {\n        error_setg(errp, \"block_size %u must be %u MB or less\",\n                   s->block_size,\n                   MAX_BLOCK_SIZE / (1024 * 1024));\n        return -EINVAL;\n    }\n\n    ret = bdrv_pread(bs->file, 128 + 4, &s->n_blocks, 4);\n    if (ret < 0) {\n        return ret;\n    }\n    s->n_blocks = be32_to_cpu(s->n_blocks);\n\n    /* read offsets */\n    if (s->n_blocks > UINT32_MAX / sizeof(uint64_t)) {\n        /* Prevent integer overflow */\n        error_setg(errp, \"n_blocks %u must be %zu or less\",\n                   s->n_blocks,\n                   UINT32_MAX / sizeof(uint64_t));\n        return -EINVAL;\n    }\n    offsets_size = s->n_blocks * sizeof(uint64_t);\n    if (offsets_size > 512 * 1024 * 1024) {\n        /* Prevent ridiculous offsets_size which causes memory allocation to\n         * fail or overflows bdrv_pread() size.  In practice the 512 MB\n         * offsets[] limit supports 16 TB images at 256 KB block size.\n         */\n        error_setg(errp, \"image requires too many offsets, \"\n                   \"try increasing block size\");\n        return -EINVAL;\n    }\n    s->offsets = g_malloc(offsets_size);\n\n    ret = bdrv_pread(bs->file, 128 + 4 + 4, s->offsets, offsets_size);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    for(i=0;i<s->n_blocks;i++) {\n        uint64_t size;\n\n        s->offsets[i] = be64_to_cpu(s->offsets[i]);\n        if (i == 0) {\n            continue;\n        }\n\n        if (s->offsets[i] < s->offsets[i - 1]) {\n            error_setg(errp, \"offsets not monotonically increasing at \"\n                       \"index %u, image file is corrupt\", i);\n            ret = -EINVAL;\n            goto fail;\n        }\n\n        size = s->offsets[i] - s->offsets[i - 1];\n\n        /* Compressed blocks should be smaller than the uncompressed block size\n         * but maybe compression performed poorly so the compressed block is\n         * actually bigger.  Clamp down on unrealistic values to prevent\n         * ridiculous s->compressed_block allocation.\n         */\n        if (size > 2 * MAX_BLOCK_SIZE) {\n            error_setg(errp, \"invalid compressed block size at index %u, \"\n                       \"image file is corrupt\", i);\n            ret = -EINVAL;\n            goto fail;\n        }\n\n        if (size > max_compressed_block_size) {\n            max_compressed_block_size = size;\n        }\n    }\n\n    /* initialize zlib engine */\n    s->compressed_block = g_malloc(max_compressed_block_size + 1);\n    s->uncompressed_block = g_malloc(s->block_size);\n    if (inflateInit(&s->zstream) != Z_OK) {\n        ret = -EINVAL;\n        goto fail;\n    }\n    s->current_block = s->n_blocks;\n\n    s->sectors_per_block = s->block_size/512;\n    bs->total_sectors = s->n_blocks * s->sectors_per_block;\n    qemu_co_mutex_init(&s->lock);\n    return 0;\n\nfail:\n    g_free(s->offsets);\n    g_free(s->compressed_block);\n    g_free(s->uncompressed_block);\n    return ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146829,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "xmlStringGetNodeList(const xmlDoc *doc, const xmlChar *value) {\n    xmlNodePtr ret = NULL, last = NULL;\n    xmlNodePtr node;\n    xmlChar *val;\n    const xmlChar *cur = value;\n    const xmlChar *q;\n    xmlEntityPtr ent;\n    xmlBufPtr buf;\n\n    if (value == NULL) return(NULL);\n\n    buf = xmlBufCreateSize(0);\n    if (buf == NULL) return(NULL);\n    xmlBufSetAllocationScheme(buf, XML_BUFFER_ALLOC_HYBRID);\n\n    q = cur;\n    while (*cur != 0) {\n\tif (cur[0] == '&') {\n\t    int charval = 0;\n\t    xmlChar tmp;\n\n\t    /*\n\t     * Save the current text.\n\t     */\n            if (cur != q) {\n\t\tif (xmlBufAdd(buf, q, cur - q))\n\t\t    goto out;\n\t    }\n\t    q = cur;\n\t    if ((cur[1] == '#') && (cur[2] == 'x')) {\n\t\tcur += 3;\n\t\ttmp = *cur;\n\t\twhile (tmp != ';') { /* Non input consuming loop */\n\t\t    if ((tmp >= '0') && (tmp <= '9'))\n\t\t\tcharval = charval * 16 + (tmp - '0');\n\t\t    else if ((tmp >= 'a') && (tmp <= 'f'))\n\t\t\tcharval = charval * 16 + (tmp - 'a') + 10;\n\t\t    else if ((tmp >= 'A') && (tmp <= 'F'))\n\t\t\tcharval = charval * 16 + (tmp - 'A') + 10;\n\t\t    else {\n\t\t\txmlTreeErr(XML_TREE_INVALID_HEX, (xmlNodePtr) doc,\n\t\t\t           NULL);\n\t\t\tcharval = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t    cur++;\n\t\t    tmp = *cur;\n\t\t}\n\t\tif (tmp == ';')\n\t\t    cur++;\n\t\tq = cur;\n\t    } else if  (cur[1] == '#') {\n\t\tcur += 2;\n\t\ttmp = *cur;\n\t\twhile (tmp != ';') { /* Non input consuming loops */\n\t\t    if ((tmp >= '0') && (tmp <= '9'))\n\t\t\tcharval = charval * 10 + (tmp - '0');\n\t\t    else {\n\t\t\txmlTreeErr(XML_TREE_INVALID_DEC, (xmlNodePtr) doc,\n\t\t\t           NULL);\n\t\t\tcharval = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t    cur++;\n\t\t    tmp = *cur;\n\t\t}\n\t\tif (tmp == ';')\n\t\t    cur++;\n\t\tq = cur;\n\t    } else {\n\t\t/*\n\t\t * Read the entity string\n\t\t */\n\t\tcur++;\n\t\tq = cur;\n\t\twhile ((*cur != 0) && (*cur != ';')) cur++;\n\t\tif (*cur == 0) {\n\t\t    xmlTreeErr(XML_TREE_UNTERMINATED_ENTITY,\n\t\t               (xmlNodePtr) doc, (const char *) q);\n\t\t    goto out;\n\t\t}\n\t\tif (cur != q) {\n\t\t    /*\n\t\t     * Predefined entities don't generate nodes\n\t\t     */\n\t\t    val = xmlStrndup(q, cur - q);\n\t\t    ent = xmlGetDocEntity(doc, val);\n\t\t    if ((ent != NULL) &&\n\t\t\t(ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n\n\t\t\tif (xmlBufCat(buf, ent->content))\n\t\t\t    goto out;\n\n\t\t    } else {\n\t\t\t/*\n\t\t\t * Flush buffer so far\n\t\t\t */\n\t\t\tif (!xmlBufIsEmpty(buf)) {\n\t\t\t    node = xmlNewDocText(doc, NULL);\n\t\t\t    node->content = xmlBufDetach(buf);\n\n\t\t\t    if (last == NULL) {\n\t\t\t\tlast = ret = node;\n\t\t\t    } else {\n\t\t\t\tlast = xmlAddNextSibling(last, node);\n\t\t\t    }\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Create a new REFERENCE_REF node\n\t\t\t */\n\t\t\tnode = xmlNewReference(doc, val);\n\t\t\tif (node == NULL) {\n\t\t\t    if (val != NULL) xmlFree(val);\n\t\t\t    goto out;\n\t\t\t}\n\t\t\telse if ((ent != NULL) && (ent->children == NULL)) {\n\t\t\t    xmlNodePtr temp;\n\n\t\t\t    ent->children = xmlStringGetNodeList(doc,\n\t\t\t\t    (const xmlChar*)node->content);\n\t\t\t    ent->owner = 1;\n\t\t\t    temp = ent->children;\n\t\t\t    while (temp) {\n\t\t\t\ttemp->parent = (xmlNodePtr)ent;\n\t\t\t\ttemp = temp->next;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (last == NULL) {\n\t\t\t    last = ret = node;\n\t\t\t} else {\n\t\t\t    last = xmlAddNextSibling(last, node);\n\t\t\t}\n\t\t    }\n\t\t    xmlFree(val);\n\t\t}\n\t\tcur++;\n\t\tq = cur;\n\t    }\n\t    if (charval != 0) {\n\t\txmlChar buffer[10];\n\t\tint len;\n\n\t\tlen = xmlCopyCharMultiByte(buffer, charval);\n\t\tbuffer[len] = 0;\n\n\t\tif (xmlBufCat(buf, buffer))\n\t\t    goto out;\n\t\tcharval = 0;\n\t    }\n\t} else\n\t    cur++;\n    }\n    if ((cur != q) || (ret == NULL)) {\n        /*\n\t * Handle the last piece of text.\n\t */\n\txmlBufAdd(buf, q, cur - q);\n    }\n\n    if (!xmlBufIsEmpty(buf)) {\n\tnode = xmlNewDocText(doc, NULL);\n\tnode->content = xmlBufDetach(buf);\n\n\tif (last == NULL) {\n\t    ret = node;\n\t} else {\n\t    xmlAddNextSibling(last, node);\n\t}\n    }\n\nout:\n    xmlBufFree(buf);\n    return(ret);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146854,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "xmlStringGetNodeList(const xmlDoc *doc, const xmlChar *value) {\n    xmlNodePtr ret = NULL, last = NULL;\n    xmlNodePtr node;\n    xmlChar *val;\n    const xmlChar *cur = value;\n    const xmlChar *q;\n    xmlEntityPtr ent;\n    xmlBufPtr buf;\n\n    if (value == NULL) return(NULL);\n\n    buf = xmlBufCreateSize(0);\n    if (buf == NULL) return(NULL);\n    xmlBufSetAllocationScheme(buf, XML_BUFFER_ALLOC_HYBRID);\n\n    q = cur;\n    while (*cur != 0) {\n\tif (cur[0] == '&') {\n\t    int charval = 0;\n\t    xmlChar tmp;\n\n\t    /*\n\t     * Save the current text.\n\t     */\n            if (cur != q) {\n\t\tif (xmlBufAdd(buf, q, cur - q))\n\t\t    goto out;\n\t    }\n\t    q = cur;\n\t    if ((cur[1] == '#') && (cur[2] == 'x')) {\n\t\tcur += 3;\n\t\ttmp = *cur;\n\t\twhile (tmp != ';') { /* Non input consuming loop */\n\t\t    if ((tmp >= '0') && (tmp <= '9'))\n\t\t\tcharval = charval * 16 + (tmp - '0');\n\t\t    else if ((tmp >= 'a') && (tmp <= 'f'))\n\t\t\tcharval = charval * 16 + (tmp - 'a') + 10;\n\t\t    else if ((tmp >= 'A') && (tmp <= 'F'))\n\t\t\tcharval = charval * 16 + (tmp - 'A') + 10;\n\t\t    else {\n\t\t\txmlTreeErr(XML_TREE_INVALID_HEX, (xmlNodePtr) doc,\n\t\t\t           NULL);\n\t\t\tcharval = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t    cur++;\n\t\t    tmp = *cur;\n\t\t}\n\t\tif (tmp == ';')\n\t\t    cur++;\n\t\tq = cur;\n\t    } else if  (cur[1] == '#') {\n\t\tcur += 2;\n\t\ttmp = *cur;\n\t\twhile (tmp != ';') { /* Non input consuming loops */\n\t\t    if ((tmp >= '0') && (tmp <= '9'))\n\t\t\tcharval = charval * 10 + (tmp - '0');\n\t\t    else {\n\t\t\txmlTreeErr(XML_TREE_INVALID_DEC, (xmlNodePtr) doc,\n\t\t\t           NULL);\n\t\t\tcharval = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t    cur++;\n\t\t    tmp = *cur;\n\t\t}\n\t\tif (tmp == ';')\n\t\t    cur++;\n\t\tq = cur;\n\t    } else {\n\t\t/*\n\t\t * Read the entity string\n\t\t */\n\t\tcur++;\n\t\tq = cur;\n\t\twhile ((*cur != 0) && (*cur != ';')) cur++;\n\t\tif (*cur == 0) {\n\t\t    xmlTreeErr(XML_TREE_UNTERMINATED_ENTITY,\n\t\t               (xmlNodePtr) doc, (const char *) q);\n\t\t    goto out;\n\t\t}\n\t\tif (cur != q) {\n\t\t    /*\n\t\t     * Predefined entities don't generate nodes\n\t\t     */\n\t\t    val = xmlStrndup(q, cur - q);\n\t\t    ent = xmlGetDocEntity(doc, val);\n\t\t    if ((ent != NULL) &&\n\t\t\t(ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n\n\t\t\tif (xmlBufCat(buf, ent->content))\n\t\t\t    goto out;\n\n\t\t    } else {\n\t\t\t/*\n\t\t\t * Flush buffer so far\n\t\t\t */\n\t\t\tif (!xmlBufIsEmpty(buf)) {\n\t\t\t    node = xmlNewDocText(doc, NULL);\n\t\t\t    node->content = xmlBufDetach(buf);\n\n\t\t\t    if (last == NULL) {\n\t\t\t\tlast = ret = node;\n\t\t\t    } else {\n\t\t\t\tlast = xmlAddNextSibling(last, node);\n\t\t\t    }\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Create a new REFERENCE_REF node\n\t\t\t */\n\t\t\tnode = xmlNewReference(doc, val);\n\t\t\tif (node == NULL) {\n\t\t\t    if (val != NULL) xmlFree(val);\n\t\t\t    goto out;\n\t\t\t}\n\t\t\telse if ((ent != NULL) && (ent->children == NULL)) {\n\t\t\t    xmlNodePtr temp;\n\n\t\t\t    ent->children = (xmlNodePtr) -1;\n\t\t\t    ent->children = xmlStringGetNodeList(doc,\n\t\t\t\t    (const xmlChar*)node->content);\n\t\t\t    ent->owner = 1;\n\t\t\t    temp = ent->children;\n\t\t\t    while (temp) {\n\t\t\t\ttemp->parent = (xmlNodePtr)ent;\n\t\t\t\ttemp = temp->next;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (last == NULL) {\n\t\t\t    last = ret = node;\n\t\t\t} else {\n\t\t\t    last = xmlAddNextSibling(last, node);\n\t\t\t}\n\t\t    }\n\t\t    xmlFree(val);\n\t\t}\n\t\tcur++;\n\t\tq = cur;\n\t    }\n\t    if (charval != 0) {\n\t\txmlChar buffer[10];\n\t\tint len;\n\n\t\tlen = xmlCopyCharMultiByte(buffer, charval);\n\t\tbuffer[len] = 0;\n\n\t\tif (xmlBufCat(buf, buffer))\n\t\t    goto out;\n\t\tcharval = 0;\n\t    }\n\t} else\n\t    cur++;\n    }\n    if ((cur != q) || (ret == NULL)) {\n        /*\n\t * Handle the last piece of text.\n\t */\n\txmlBufAdd(buf, q, cur - q);\n    }\n\n    if (!xmlBufIsEmpty(buf)) {\n\tnode = xmlNewDocText(doc, NULL);\n\tnode->content = xmlBufDetach(buf);\n\n\tif (last == NULL) {\n\t    ret = node;\n\t} else {\n\t    xmlAddNextSibling(last, node);\n\t}\n    }\n\nout:\n    xmlBufFree(buf);\n    return(ret);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146855,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static bool winbind_name_list_to_sid_string_list(struct pwb_context *ctx,\n\t\t\t\t\t\t const char *user,\n\t\t\t\t\t\t const char *name_list,\n\t\t\t\t\t\t char *sid_list_buffer,\n\t\t\t\t\t\t int sid_list_buffer_size)\n{\n\tbool result = false;\n\tchar *current_name = NULL;\n\tconst char *search_location;\n\tconst char *comma;\n\tint len;\n\n\tif (sid_list_buffer_size > 0) {\n\t\tsid_list_buffer[0] = 0;\n\t}\n\n\tsearch_location = name_list;\n\twhile ((comma = strchr(search_location, ',')) != NULL) {\n\t\tcurrent_name = strndup(search_location,\n\t\t\t\t       comma - search_location);\n\t\tif (NULL == current_name) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!winbind_name_to_sid_string(ctx, user,\n\t\t\t\t\t\tcurrent_name,\n\t\t\t\t\t\tsid_list_buffer,\n\t\t\t\t\t\tsid_list_buffer_size)) {\n\t\t\t/*\n\t\t\t * If one group name failed, we must not fail\n\t\t\t * the authentication totally, continue with\n\t\t\t * the following group names. If user belongs to\n\t\t\t * one of the valid groups, we must allow it\n\t\t\t * login. -- BoYang\n\t\t\t */\n\n\t\t\t_pam_log(ctx, LOG_INFO, \"cannot convert group %s to sid, \"\n\t\t\t\t \"check if group %s is valid group.\", current_name,\n\t\t\t\t current_name);\n\t\t\t_make_remark_format(ctx, PAM_TEXT_INFO, _(\"Cannot convert group %s \"\n\t\t\t\t\t\"to sid, please contact your administrator to see \"\n\t\t\t\t\t\"if group %s is valid.\"), current_name, current_name);\n\t\t\tSAFE_FREE(current_name);\n\t\t\tsearch_location = comma + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tSAFE_FREE(current_name);\n\n\t\tif (!safe_append_string(sid_list_buffer, \",\",\n\t\t\t\t\tsid_list_buffer_size)) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tsearch_location = comma + 1;\n\t}\n\n\tif (!winbind_name_to_sid_string(ctx, user, search_location,\n\t\t\t\t\tsid_list_buffer,\n\t\t\t\t\tsid_list_buffer_size)) {\n\t\t_pam_log(ctx, LOG_INFO, \"cannot convert group %s to sid, \"\n\t\t\t \"check if group %s is valid group.\", search_location,\n\t\t\t search_location);\n\t\t_make_remark_format(ctx, PAM_TEXT_INFO, _(\"Cannot convert group %s \"\n\t\t\t\t\"to sid, please contact your administrator to see \"\n\t\t\t\t\"if group %s is valid.\"), search_location, search_location);\n\t\t/*\n\t\t * The lookup of the last name failed..\n\t\t * It results in require_member_of_sid ends with ','\n\t\t * It is malformated parameter here, overwrite the last ','.\n\t\t */\n\t\tlen = strlen(sid_list_buffer);\n\t\tif ((len != 0) && (sid_list_buffer[len - 1] == ',')) {\n\t\t\tsid_list_buffer[len - 1] = '\\0';\n\t\t}\n\t}\n\n\tresult = true;\n\nout:\n\tSAFE_FREE(current_name);\n\treturn result;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146872,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static bool winbind_name_list_to_sid_string_list(struct pwb_context *ctx,\n\t\t\t\t\t\t const char *user,\n\t\t\t\t\t\t const char *name_list,\n\t\t\t\t\t\t char *sid_list_buffer,\n\t\t\t\t\t\t int sid_list_buffer_size)\n{\n\tbool result = false;\n\tchar *current_name = NULL;\n\tconst char *search_location;\n\tconst char *comma;\n\tint len;\n\n\tif (sid_list_buffer_size > 0) {\n\t\tsid_list_buffer[0] = 0;\n\t}\n\n\tsearch_location = name_list;\n\twhile ((comma = strchr(search_location, ',')) != NULL) {\n\t\tcurrent_name = strndup(search_location,\n\t\t\t\t       comma - search_location);\n\t\tif (NULL == current_name) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!winbind_name_to_sid_string(ctx, user,\n\t\t\t\t\t\tcurrent_name,\n\t\t\t\t\t\tsid_list_buffer,\n\t\t\t\t\t\tsid_list_buffer_size)) {\n\t\t\t/*\n\t\t\t * If one group name failed, we must not fail\n\t\t\t * the authentication totally, continue with\n\t\t\t * the following group names. If user belongs to\n\t\t\t * one of the valid groups, we must allow it\n\t\t\t * login. -- BoYang\n\t\t\t */\n\n\t\t\t_pam_log(ctx, LOG_INFO, \"cannot convert group %s to sid, \"\n\t\t\t\t \"check if group %s is valid group.\", current_name,\n\t\t\t\t current_name);\n\t\t\t_make_remark_format(ctx, PAM_TEXT_INFO, _(\"Cannot convert group %s \"\n\t\t\t\t\t\"to sid, please contact your administrator to see \"\n\t\t\t\t\t\"if group %s is valid.\"), current_name, current_name);\n\t\t\tSAFE_FREE(current_name);\n\t\t\tsearch_location = comma + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tSAFE_FREE(current_name);\n\n\t\tif (!safe_append_string(sid_list_buffer, \",\",\n\t\t\t\t\tsid_list_buffer_size)) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tsearch_location = comma + 1;\n\t}\n\n\tif (!winbind_name_to_sid_string(ctx, user, search_location,\n\t\t\t\t\tsid_list_buffer,\n\t\t\t\t\tsid_list_buffer_size)) {\n\t\t_pam_log(ctx, LOG_INFO, \"cannot convert group %s to sid, \"\n\t\t\t \"check if group %s is valid group.\", search_location,\n\t\t\t search_location);\n\t\t_make_remark_format(ctx, PAM_TEXT_INFO, _(\"Cannot convert group %s \"\n\t\t\t\t\"to sid, please contact your administrator to see \"\n\t\t\t\t\"if group %s is valid.\"), search_location, search_location);\n\n\t\t/* If no valid groups were converted we should fail outright */\n\t\tif (name_list != NULL && strlen(sid_list_buffer) == 0) {\n\t\t\tresult = false;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * The lookup of the last name failed..\n\t\t * It results in require_member_of_sid ends with ','\n\t\t * It is malformated parameter here, overwrite the last ','.\n\t\t */\n\t\tlen = strlen(sid_list_buffer);\n\t\tif ((len != 0) && (sid_list_buffer[len - 1] == ',')) {\n\t\t\tsid_list_buffer[len - 1] = '\\0';\n\t\t}\n\t}\n\n\tresult = true;\n\nout:\n\tSAFE_FREE(current_name);\n\treturn result;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146873,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int do_insn_fetch(struct x86_emulate_ctxt *ctxt,\n\t\t\t struct x86_emulate_ops *ops,\n\t\t\t unsigned long eip, void *dest, unsigned size)\n{\n\tint rc = 0;\n\n\teip += ctxt->cs_base;\n\twhile (size--) {\n\t\trc = do_fetch_insn_byte(ctxt, ops, eip++, dest++);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146886,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int do_insn_fetch(struct x86_emulate_ctxt *ctxt,\n\t\t\t struct x86_emulate_ops *ops,\n\t\t\t unsigned long eip, void *dest, unsigned size)\n{\n\tint rc = 0;\n\n\t/* x86 instructions are limited to 15 bytes. */\n\tif (eip + size - ctxt->decode.eip_orig > 15)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\teip += ctxt->cs_base;\n\twhile (size--) {\n\t\trc = do_fetch_insn_byte(ctxt, ops, eip++, dest++);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146887,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int ip_frag_reasm(struct ipq *qp, struct sk_buff *skb,\n\t\t\t struct sk_buff *prev_tail, struct net_device *dev)\n{\n\tstruct net *net = container_of(qp->q.net, struct net, ipv4.frags);\n\tstruct iphdr *iph;\n\tstruct sk_buff *fp, *head = skb_rb_first(&qp->q.rb_fragments);\n\tstruct sk_buff **nextp; /* To build frag_list. */\n\tstruct rb_node *rbn;\n\tint len;\n\tint ihlen;\n\tint err;\n\tu8 ecn;\n\n\tipq_kill(qp);\n\n\tecn = ip_frag_ecn_table[qp->ecn];\n\tif (unlikely(ecn == 0xff)) {\n\t\terr = -EINVAL;\n\t\tgoto out_fail;\n\t}\n\t/* Make the one we just received the head. */\n\tif (head != skb) {\n\t\tfp = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!fp)\n\t\t\tgoto out_nomem;\n\t\tFRAG_CB(fp)->next_frag = FRAG_CB(skb)->next_frag;\n\t\tif (RB_EMPTY_NODE(&skb->rbnode))\n\t\t\tFRAG_CB(prev_tail)->next_frag = fp;\n\t\telse\n\t\t\trb_replace_node(&skb->rbnode, &fp->rbnode,\n\t\t\t\t\t&qp->q.rb_fragments);\n\t\tif (qp->q.fragments_tail == skb)\n\t\t\tqp->q.fragments_tail = fp;\n\t\tskb_morph(skb, head);\n\t\tFRAG_CB(skb)->next_frag = FRAG_CB(head)->next_frag;\n\t\trb_replace_node(&head->rbnode, &skb->rbnode,\n\t\t\t\t&qp->q.rb_fragments);\n\t\tconsume_skb(head);\n\t\thead = skb;\n\t}\n\n\tWARN_ON(head->ip_defrag_offset != 0);\n\n\t/* Allocate a new buffer for the datagram. */\n\tihlen = ip_hdrlen(head);\n\tlen = ihlen + qp->q.len;\n\n\terr = -E2BIG;\n\tif (len > 65535)\n\t\tgoto out_oversize;\n\n\t/* Head of list must not be cloned. */\n\tif (skb_unclone(head, GFP_ATOMIC))\n\t\tgoto out_nomem;\n\n\t/* If the first fragment is fragmented itself, we split\n\t * it to two chunks: the first with data and paged part\n\t * and the second, holding only fragments. */\n\tif (skb_has_frag_list(head)) {\n\t\tstruct sk_buff *clone;\n\t\tint i, plen = 0;\n\n\t\tclone = alloc_skb(0, GFP_ATOMIC);\n\t\tif (!clone)\n\t\t\tgoto out_nomem;\n\t\tskb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;\n\t\tskb_frag_list_init(head);\n\t\tfor (i = 0; i < skb_shinfo(head)->nr_frags; i++)\n\t\t\tplen += skb_frag_size(&skb_shinfo(head)->frags[i]);\n\t\tclone->len = clone->data_len = head->data_len - plen;\n\t\thead->truesize += clone->truesize;\n\t\tclone->csum = 0;\n\t\tclone->ip_summed = head->ip_summed;\n\t\tadd_frag_mem_limit(qp->q.net, clone->truesize);\n\t\tskb_shinfo(head)->frag_list = clone;\n\t\tnextp = &clone->next;\n\t} else {\n\t\tnextp = &skb_shinfo(head)->frag_list;\n\t}\n\n\tskb_push(head, head->data - skb_network_header(head));\n\n\t/* Traverse the tree in order, to build frag_list. */\n\tfp = FRAG_CB(head)->next_frag;\n\trbn = rb_next(&head->rbnode);\n\trb_erase(&head->rbnode, &qp->q.rb_fragments);\n\twhile (rbn || fp) {\n\t\t/* fp points to the next sk_buff in the current run;\n\t\t * rbn points to the next run.\n\t\t */\n\t\t/* Go through the current run. */\n\t\twhile (fp) {\n\t\t\t*nextp = fp;\n\t\t\tnextp = &fp->next;\n\t\t\tfp->prev = NULL;\n\t\t\tmemset(&fp->rbnode, 0, sizeof(fp->rbnode));\n\t\t\thead->data_len += fp->len;\n\t\t\thead->len += fp->len;\n\t\t\tif (head->ip_summed != fp->ip_summed)\n\t\t\t\thead->ip_summed = CHECKSUM_NONE;\n\t\t\telse if (head->ip_summed == CHECKSUM_COMPLETE)\n\t\t\t\thead->csum = csum_add(head->csum, fp->csum);\n\t\t\thead->truesize += fp->truesize;\n\t\t\tfp = FRAG_CB(fp)->next_frag;\n\t\t}\n\t\t/* Move to the next run. */\n\t\tif (rbn) {\n\t\t\tstruct rb_node *rbnext = rb_next(rbn);\n\n\t\t\tfp = rb_to_skb(rbn);\n\t\t\trb_erase(rbn, &qp->q.rb_fragments);\n\t\t\trbn = rbnext;\n\t\t}\n\t}\n\tsub_frag_mem_limit(qp->q.net, head->truesize);\n\n\t*nextp = NULL;\n\thead->next = NULL;\n\thead->prev = NULL;\n\thead->dev = dev;\n\thead->tstamp = qp->q.stamp;\n\tIPCB(head)->frag_max_size = max(qp->max_df_size, qp->q.max_size);\n\n\tiph = ip_hdr(head);\n\tiph->tot_len = htons(len);\n\tiph->tos |= ecn;\n\n\t/* When we set IP_DF on a refragmented skb we must also force a\n\t * call to ip_fragment to avoid forwarding a DF-skb of size s while\n\t * original sender only sent fragments of size f (where f < s).\n\t *\n\t * We only set DF/IPSKB_FRAG_PMTU if such DF fragment was the largest\n\t * frag seen to avoid sending tiny DF-fragments in case skb was built\n\t * from one very small df-fragment and one large non-df frag.\n\t */\n\tif (qp->max_df_size == qp->q.max_size) {\n\t\tIPCB(head)->flags |= IPSKB_FRAG_PMTU;\n\t\tiph->frag_off = htons(IP_DF);\n\t} else {\n\t\tiph->frag_off = 0;\n\t}\n\n\tip_send_check(iph);\n\n\t__IP_INC_STATS(net, IPSTATS_MIB_REASMOKS);\n\tqp->q.fragments = NULL;\n\tqp->q.rb_fragments = RB_ROOT;\n\tqp->q.fragments_tail = NULL;\n\tqp->q.last_run_head = NULL;\n\treturn 0;\n\nout_nomem:\n\tnet_dbg_ratelimited(\"queue_glue: no memory for gluing queue %p\\n\", qp);\n\terr = -ENOMEM;\n\tgoto out_fail;\nout_oversize:\n\tnet_info_ratelimited(\"Oversized IP packet from %pI4\\n\", &qp->q.key.v4.saddr);\nout_fail:\n\t__IP_INC_STATS(net, IPSTATS_MIB_REASMFAILS);\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146920,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int ip_frag_reasm(struct ipq *qp, struct sk_buff *skb,\n\t\t\t struct sk_buff *prev_tail, struct net_device *dev)\n{\n\tstruct net *net = container_of(qp->q.net, struct net, ipv4.frags);\n\tstruct iphdr *iph;\n\tstruct sk_buff *fp, *head = skb_rb_first(&qp->q.rb_fragments);\n\tstruct sk_buff **nextp; /* To build frag_list. */\n\tstruct rb_node *rbn;\n\tint len;\n\tint ihlen;\n\tint err;\n\tu8 ecn;\n\n\tipq_kill(qp);\n\n\tecn = ip_frag_ecn_table[qp->ecn];\n\tif (unlikely(ecn == 0xff)) {\n\t\terr = -EINVAL;\n\t\tgoto out_fail;\n\t}\n\t/* Make the one we just received the head. */\n\tif (head != skb) {\n\t\tfp = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!fp)\n\t\t\tgoto out_nomem;\n\t\tFRAG_CB(fp)->next_frag = FRAG_CB(skb)->next_frag;\n\t\tif (RB_EMPTY_NODE(&skb->rbnode))\n\t\t\tFRAG_CB(prev_tail)->next_frag = fp;\n\t\telse\n\t\t\trb_replace_node(&skb->rbnode, &fp->rbnode,\n\t\t\t\t\t&qp->q.rb_fragments);\n\t\tif (qp->q.fragments_tail == skb)\n\t\t\tqp->q.fragments_tail = fp;\n\t\tskb_morph(skb, head);\n\t\tFRAG_CB(skb)->next_frag = FRAG_CB(head)->next_frag;\n\t\trb_replace_node(&head->rbnode, &skb->rbnode,\n\t\t\t\t&qp->q.rb_fragments);\n\t\tconsume_skb(head);\n\t\thead = skb;\n\t}\n\n\tWARN_ON(head->ip_defrag_offset != 0);\n\n\t/* Allocate a new buffer for the datagram. */\n\tihlen = ip_hdrlen(head);\n\tlen = ihlen + qp->q.len;\n\n\terr = -E2BIG;\n\tif (len > 65535)\n\t\tgoto out_oversize;\n\n\t/* Head of list must not be cloned. */\n\tif (skb_unclone(head, GFP_ATOMIC))\n\t\tgoto out_nomem;\n\n\t/* If the first fragment is fragmented itself, we split\n\t * it to two chunks: the first with data and paged part\n\t * and the second, holding only fragments. */\n\tif (skb_has_frag_list(head)) {\n\t\tstruct sk_buff *clone;\n\t\tint i, plen = 0;\n\n\t\tclone = alloc_skb(0, GFP_ATOMIC);\n\t\tif (!clone)\n\t\t\tgoto out_nomem;\n\t\tskb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;\n\t\tskb_frag_list_init(head);\n\t\tfor (i = 0; i < skb_shinfo(head)->nr_frags; i++)\n\t\t\tplen += skb_frag_size(&skb_shinfo(head)->frags[i]);\n\t\tclone->len = clone->data_len = head->data_len - plen;\n\t\thead->truesize += clone->truesize;\n\t\tclone->csum = 0;\n\t\tclone->ip_summed = head->ip_summed;\n\t\tadd_frag_mem_limit(qp->q.net, clone->truesize);\n\t\tskb_shinfo(head)->frag_list = clone;\n\t\tnextp = &clone->next;\n\t} else {\n\t\tnextp = &skb_shinfo(head)->frag_list;\n\t}\n\n\tskb_push(head, head->data - skb_network_header(head));\n\n\t/* Traverse the tree in order, to build frag_list. */\n\tfp = FRAG_CB(head)->next_frag;\n\trbn = rb_next(&head->rbnode);\n\trb_erase(&head->rbnode, &qp->q.rb_fragments);\n\twhile (rbn || fp) {\n\t\t/* fp points to the next sk_buff in the current run;\n\t\t * rbn points to the next run.\n\t\t */\n\t\t/* Go through the current run. */\n\t\twhile (fp) {\n\t\t\t*nextp = fp;\n\t\t\tnextp = &fp->next;\n\t\t\tfp->prev = NULL;\n\t\t\tmemset(&fp->rbnode, 0, sizeof(fp->rbnode));\n\t\t\tfp->sk = NULL;\n\t\t\thead->data_len += fp->len;\n\t\t\thead->len += fp->len;\n\t\t\tif (head->ip_summed != fp->ip_summed)\n\t\t\t\thead->ip_summed = CHECKSUM_NONE;\n\t\t\telse if (head->ip_summed == CHECKSUM_COMPLETE)\n\t\t\t\thead->csum = csum_add(head->csum, fp->csum);\n\t\t\thead->truesize += fp->truesize;\n\t\t\tfp = FRAG_CB(fp)->next_frag;\n\t\t}\n\t\t/* Move to the next run. */\n\t\tif (rbn) {\n\t\t\tstruct rb_node *rbnext = rb_next(rbn);\n\n\t\t\tfp = rb_to_skb(rbn);\n\t\t\trb_erase(rbn, &qp->q.rb_fragments);\n\t\t\trbn = rbnext;\n\t\t}\n\t}\n\tsub_frag_mem_limit(qp->q.net, head->truesize);\n\n\t*nextp = NULL;\n\thead->next = NULL;\n\thead->prev = NULL;\n\thead->dev = dev;\n\thead->tstamp = qp->q.stamp;\n\tIPCB(head)->frag_max_size = max(qp->max_df_size, qp->q.max_size);\n\n\tiph = ip_hdr(head);\n\tiph->tot_len = htons(len);\n\tiph->tos |= ecn;\n\n\t/* When we set IP_DF on a refragmented skb we must also force a\n\t * call to ip_fragment to avoid forwarding a DF-skb of size s while\n\t * original sender only sent fragments of size f (where f < s).\n\t *\n\t * We only set DF/IPSKB_FRAG_PMTU if such DF fragment was the largest\n\t * frag seen to avoid sending tiny DF-fragments in case skb was built\n\t * from one very small df-fragment and one large non-df frag.\n\t */\n\tif (qp->max_df_size == qp->q.max_size) {\n\t\tIPCB(head)->flags |= IPSKB_FRAG_PMTU;\n\t\tiph->frag_off = htons(IP_DF);\n\t} else {\n\t\tiph->frag_off = 0;\n\t}\n\n\tip_send_check(iph);\n\n\t__IP_INC_STATS(net, IPSTATS_MIB_REASMOKS);\n\tqp->q.fragments = NULL;\n\tqp->q.rb_fragments = RB_ROOT;\n\tqp->q.fragments_tail = NULL;\n\tqp->q.last_run_head = NULL;\n\treturn 0;\n\nout_nomem:\n\tnet_dbg_ratelimited(\"queue_glue: no memory for gluing queue %p\\n\", qp);\n\terr = -ENOMEM;\n\tgoto out_fail;\nout_oversize:\n\tnet_info_ratelimited(\"Oversized IP packet from %pI4\\n\", &qp->q.key.v4.saddr);\nout_fail:\n\t__IP_INC_STATS(net, IPSTATS_MIB_REASMFAILS);\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146921,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void Ogg::XiphComment::parse(const ByteVector &data)\n{\n  // The first thing in the comment data is the vendor ID length, followed by a\n  // UTF8 string with the vendor ID.\n\n  uint pos = 0;\n\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n\n  // Next the number of fields in the comment vector.\n\n  uint commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n\n  if(commentFields > (data.size() - 8) / 4) {\n    return;\n  }\n\n  for(uint i = 0; i < commentFields; i++) {\n\n    // Each comment field is in the format \"KEY=value\" in a UTF8 string and has\n    // 4 bytes before the text starts that gives the length.\n\n    uint commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n    if(pos > data.size()) {\n      break;\n    }\n\n    int commentSeparatorPosition = comment.find(\"=\");\n    if(commentSeparatorPosition == -1) {\n      break;\n    }\n\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n\n    addField(key, value, false);\n  }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146972,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void Ogg::XiphComment::parse(const ByteVector &data)\n{\n  // The first thing in the comment data is the vendor ID length, followed by a\n  // UTF8 string with the vendor ID.\n\n  uint pos = 0;\n\n  uint vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n\n  // Next the number of fields in the comment vector.\n\n  uint commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n\n  if(commentFields > (data.size() - 8) / 4) {\n    return;\n  }\n\n  for(uint i = 0; i < commentFields; i++) {\n\n    // Each comment field is in the format \"KEY=value\" in a UTF8 string and has\n    // 4 bytes before the text starts that gives the length.\n\n    uint commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n    if(pos > data.size()) {\n      break;\n    }\n\n    int commentSeparatorPosition = comment.find(\"=\");\n    if(commentSeparatorPosition == -1) {\n      break;\n    }\n\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n\n    addField(key, value, false);\n  }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146973,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "yaml_parser_save_simple_key(yaml_parser_t *parser)\n{\n    /*\n     * A simple key is required at the current position if the scanner is in\n     * the block context and the current column coincides with the indentation\n     * level.\n     */\n\n    int required = (!parser->flow_level\n            && parser->indent == (ptrdiff_t)parser->mark.column);\n\n    /*\n     * A simple key is required only when it is the first token in the current\n     * line.  Therefore it is always allowed.  But we add a check anyway.\n     */\n\n    assert(parser->simple_key_allowed || !required);    /* Impossible. */\n\n    /*\n     * If the current position may start a simple key, save it.\n     */\n\n    if (parser->simple_key_allowed)\n    {\n        yaml_simple_key_t simple_key;\n        simple_key.possible = 1;\n        simple_key.required = required;\n        simple_key.token_number = \n            parser->tokens_parsed + (parser->tokens.tail - parser->tokens.head);\n        simple_key.mark = parser->mark;\n\n        if (!yaml_parser_remove_simple_key(parser)) return 0;\n\n        *(parser->simple_keys.top-1) = simple_key;\n    }\n\n    return 1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146980,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "yaml_parser_save_simple_key(yaml_parser_t *parser)\n{\n    /*\n     * A simple key is required at the current position if the scanner is in\n     * the block context and the current column coincides with the indentation\n     * level.\n     */\n\n    int required = (!parser->flow_level\n            && parser->indent == (ptrdiff_t)parser->mark.column);\n\n    /*\n     * A simple key is required only when it is the first token in the current\n     * line.  Therefore it is always allowed.  But we add a check anyway.\n     */\n\n    /* XXX This caused:\n     * https://bitbucket.org/xi/libyaml/issue/10/wrapped-strings-cause-assert-failure\n    assert(parser->simple_key_allowed || !required); */    /* Impossible. */\n\n    /*\n     * If the current position may start a simple key, save it.\n     */\n\n    if (parser->simple_key_allowed)\n    {\n        yaml_simple_key_t simple_key;\n        simple_key.possible = 1;\n        simple_key.required = required;\n        simple_key.token_number = \n            parser->tokens_parsed + (parser->tokens.tail - parser->tokens.head);\n        simple_key.mark = parser->mark;\n\n        if (!yaml_parser_remove_simple_key(parser)) return 0;\n\n        *(parser->simple_keys.top-1) = simple_key;\n    }\n\n    return 1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146981,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "Http::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env)\n{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n\n    clear(); // clear response\n\n    sessionInitialize();\n    if (!sessionActive() && !isAuthNeeded())\n        sessionStart();\n\n    if (isBanned()) {\n        status(403, \"Forbidden\");\n        print(QObject::tr(\"Your IP address has been banned after too many failed authentication attempts.\"), Http::CONTENT_TYPE_TXT);\n    }\n    else {\n        processRequest();\n    }\n\n    return response();\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147004,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "Http::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env)\n{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n\n    // clear response\n    clear();\n\n    // avoid clickjacking attacks\n    header(Http::HEADER_X_FRAME_OPTIONS, \"SAMEORIGIN\");\n\n    sessionInitialize();\n    if (!sessionActive() && !isAuthNeeded())\n        sessionStart();\n\n    if (isBanned()) {\n        status(403, \"Forbidden\");\n        print(QObject::tr(\"Your IP address has been banned after too many failed authentication attempts.\"), Http::CONTENT_TYPE_TXT);\n    }\n    else {\n        processRequest();\n    }\n\n    return response();\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147005,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void Ogg::XiphComment::parse(const ByteVector &data)\n{\n  // The first thing in the comment data is the vendor ID length, followed by a\n  // UTF8 string with the vendor ID.\n\n  int pos = 0;\n\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n\n  // Next the number of fields in the comment vector.\n\n  int commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n\n  for(int i = 0; i < commentFields; i++) {\n\n    // Each comment field is in the format \"KEY=value\" in a UTF8 string and has\n    // 4 bytes before the text starts that gives the length.\n\n    int commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n\n    int commentSeparatorPosition = comment.find(\"=\");\n\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n\n    addField(key, value, false);\n  }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147008,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void Ogg::XiphComment::parse(const ByteVector &data)\n{\n  // The first thing in the comment data is the vendor ID length, followed by a\n  // UTF8 string with the vendor ID.\n\n  int pos = 0;\n\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n\n  // Next the number of fields in the comment vector.\n\n  uint commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n\n  if(commentFields > (data.size() - 8) / 4) {\n    return;\n  }\n\n  for(uint i = 0; i < commentFields; i++) {\n\n    // Each comment field is in the format \"KEY=value\" in a UTF8 string and has\n    // 4 bytes before the text starts that gives the length.\n\n    uint commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n    if(pos > data.size()) {\n      break;\n    }\n\n    int commentSeparatorPosition = comment.find(\"=\");\n    if(commentSeparatorPosition == -1) {\n      break;\n    }\n\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n\n    addField(key, value, false);\n  }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147009,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "GIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len)\n{\n\tgit_buf *reserved = git_repository__reserved_names_win32;\n\tsize_t reserved_len = git_repository__reserved_names_win32_len;\n\tsize_t start = 0, i;\n\n\tif (repo)\n\t\tgit_repository__reserved_names(&reserved, &reserved_len, repo, true);\n\n\tfor (i = 0; i < reserved_len; i++) {\n\t\tgit_buf *r = &reserved[i];\n\n\t\tif (len >= r->size &&\n\t\t\tstrncasecmp(path, r->ptr, r->size) == 0) {\n\t\t\tstart = r->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!start)\n\t\treturn true;\n\n\t/* Reject paths like \".git\\\" */\n\tif (path[start] == '\\\\')\n\t\treturn false;\n\n\t/* Reject paths like '.git ' or '.git.' */\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147066,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "GIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len)\n{\n\tgit_buf *reserved = git_repository__reserved_names_win32;\n\tsize_t reserved_len = git_repository__reserved_names_win32_len;\n\tsize_t start = 0, i;\n\n\tif (repo)\n\t\tgit_repository__reserved_names(&reserved, &reserved_len, repo, true);\n\n\tfor (i = 0; i < reserved_len; i++) {\n\t\tgit_buf *r = &reserved[i];\n\n\t\tif (len >= r->size &&\n\t\t\tstrncasecmp(path, r->ptr, r->size) == 0) {\n\t\t\tstart = r->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!start)\n\t\treturn true;\n\n\t/*\n\t * Reject paths that start with Windows-style directory separators\n\t * (\".git\\\") or NTFS alternate streams (\".git:\") and could be used\n\t * to write to the \".git\" directory on Windows platforms.\n\t */\n\tif (path[start] == '\\\\' || path[start] == ':')\n\t\treturn false;\n\n\t/* Reject paths like '.git ' or '.git.' */\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147067,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "did_set_string_option(\n    int\t\topt_idx,\t\t/* index in options[] table */\n    char_u\t**varp,\t\t\t/* pointer to the option variable */\n    int\t\tnew_value_alloced,\t/* new value was allocated */\n    char_u\t*oldval,\t\t/* previous value of the option */\n    char_u\t*errbuf,\t\t/* buffer for errors, or NULL */\n    int\t\topt_flags)\t\t/* OPT_LOCAL and/or OPT_GLOBAL */\n{\n    char_u\t*errmsg = NULL;\n    char_u\t*s, *p;\n    int\t\tdid_chartab = FALSE;\n    char_u\t**gvarp;\n    long_u\tfree_oldval = (options[opt_idx].flags & P_ALLOCED);\n#ifdef FEAT_GUI\n    /* set when changing an option that only requires a redraw in the GUI */\n    int\t\tredraw_gui_only = FALSE;\n#endif\n\n    /* Get the global option to compare with, otherwise we would have to check\n     * two values for all local options. */\n    gvarp = (char_u **)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL);\n\n    /* Disallow changing some options from secure mode */\n    if ((secure\n#ifdef HAVE_SANDBOX\n\t\t|| sandbox != 0\n#endif\n\t\t) && (options[opt_idx].flags & P_SECURE))\n    {\n\terrmsg = e_secure;\n    }\n\n    /* Check for a \"normal\" file name in some options.  Disallow a path\n     * separator (slash and/or backslash), wildcards and characters that are\n     * often illegal in a file name. */\n    else if ((options[opt_idx].flags & P_NFNAME)\n\t\t\t && vim_strpbrk(*varp, (char_u *)\"/\\\\*?[|<>\") != NULL)\n    {\n\terrmsg = e_invarg;\n    }\n\n    /* 'term' */\n    else if (varp == &T_NAME)\n    {\n\tif (T_NAME[0] == NUL)\n\t    errmsg = (char_u *)N_(\"E529: Cannot set 'term' to empty string\");\n#ifdef FEAT_GUI\n\tif (gui.in_use)\n\t    errmsg = (char_u *)N_(\"E530: Cannot change term in GUI\");\n\telse if (term_is_gui(T_NAME))\n\t    errmsg = (char_u *)N_(\"E531: Use \\\":gui\\\" to start the GUI\");\n#endif\n\telse if (set_termname(T_NAME) == FAIL)\n\t    errmsg = (char_u *)N_(\"E522: Not found in termcap\");\n\telse\n\t    /* Screen colors may have changed. */\n\t    redraw_later_clear();\n    }\n\n    /* 'backupcopy' */\n    else if (gvarp == &p_bkc)\n    {\n\tchar_u\t\t*bkc = p_bkc;\n\tunsigned int\t*flags = &bkc_flags;\n\n\tif (opt_flags & OPT_LOCAL)\n\t{\n\t    bkc = curbuf->b_p_bkc;\n\t    flags = &curbuf->b_bkc_flags;\n\t}\n\n\tif ((opt_flags & OPT_LOCAL) && *bkc == NUL)\n\t    /* make the local value empty: use the global value */\n\t    *flags = 0;\n\telse\n\t{\n\t    if (opt_strings_flags(bkc, p_bkc_values, flags, TRUE) != OK)\n\t\terrmsg = e_invarg;\n\t    if ((((int)*flags & BKC_AUTO) != 0)\n\t\t    + (((int)*flags & BKC_YES) != 0)\n\t\t    + (((int)*flags & BKC_NO) != 0) != 1)\n\t    {\n\t\t/* Must have exactly one of \"auto\", \"yes\"  and \"no\". */\n\t\t(void)opt_strings_flags(oldval, p_bkc_values, flags, TRUE);\n\t\terrmsg = e_invarg;\n\t    }\n\t}\n    }\n\n    /* 'backupext' and 'patchmode' */\n    else if (varp == &p_bex || varp == &p_pm)\n    {\n\tif (STRCMP(*p_bex == '.' ? p_bex + 1 : p_bex,\n\t\t     *p_pm == '.' ? p_pm + 1 : p_pm) == 0)\n\t    errmsg = (char_u *)N_(\"E589: 'backupext' and 'patchmode' are equal\");\n    }\n#ifdef FEAT_LINEBREAK\n    /* 'breakindentopt' */\n    else if (varp == &curwin->w_p_briopt)\n    {\n\tif (briopt_check(curwin) == FAIL)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    /*\n     * 'isident', 'iskeyword', 'isprint or 'isfname' option: refill g_chartab[]\n     * If the new option is invalid, use old value.  'lisp' option: refill\n     * g_chartab[] for '-' char\n     */\n    else if (  varp == &p_isi\n\t    || varp == &(curbuf->b_p_isk)\n\t    || varp == &p_isp\n\t    || varp == &p_isf)\n    {\n\tif (init_chartab() == FAIL)\n\t{\n\t    did_chartab = TRUE;\t    /* need to restore it below */\n\t    errmsg = e_invarg;\t    /* error in value */\n\t}\n    }\n\n    /* 'helpfile' */\n    else if (varp == &p_hf)\n    {\n\t/* May compute new values for $VIM and $VIMRUNTIME */\n\tif (didset_vim)\n\t{\n\t    vim_setenv((char_u *)\"VIM\", (char_u *)\"\");\n\t    didset_vim = FALSE;\n\t}\n\tif (didset_vimruntime)\n\t{\n\t    vim_setenv((char_u *)\"VIMRUNTIME\", (char_u *)\"\");\n\t    didset_vimruntime = FALSE;\n\t}\n    }\n\n#ifdef FEAT_SYN_HL\n    /* 'colorcolumn' */\n    else if (varp == &curwin->w_p_cc)\n\terrmsg = check_colorcolumn(curwin);\n#endif\n\n#ifdef FEAT_MULTI_LANG\n    /* 'helplang' */\n    else if (varp == &p_hlg)\n    {\n\t/* Check for \"\", \"ab\", \"ab,cd\", etc. */\n\tfor (s = p_hlg; *s != NUL; s += 3)\n\t{\n\t    if (s[1] == NUL || ((s[2] != ',' || s[3] == NUL) && s[2] != NUL))\n\t    {\n\t\terrmsg = e_invarg;\n\t\tbreak;\n\t    }\n\t    if (s[2] == NUL)\n\t\tbreak;\n\t}\n    }\n#endif\n\n    /* 'highlight' */\n    else if (varp == &p_hl)\n    {\n\tif (highlight_changed() == FAIL)\n\t    errmsg = e_invarg;\t/* invalid flags */\n    }\n\n    /* 'nrformats' */\n    else if (gvarp == &p_nf)\n    {\n\tif (check_opt_strings(*varp, p_nf_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n#ifdef FEAT_SESSION\n    /* 'sessionoptions' */\n    else if (varp == &p_ssop)\n    {\n\tif (opt_strings_flags(p_ssop, p_ssop_values, &ssop_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n\tif ((ssop_flags & SSOP_CURDIR) && (ssop_flags & SSOP_SESDIR))\n\t{\n\t    /* Don't allow both \"sesdir\" and \"curdir\". */\n\t    (void)opt_strings_flags(oldval, p_ssop_values, &ssop_flags, TRUE);\n\t    errmsg = e_invarg;\n\t}\n    }\n    /* 'viewoptions' */\n    else if (varp == &p_vop)\n    {\n\tif (opt_strings_flags(p_vop, p_ssop_values, &vop_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    /* 'scrollopt' */\n#ifdef FEAT_SCROLLBIND\n    else if (varp == &p_sbo)\n    {\n\tif (check_opt_strings(p_sbo, p_scbopt_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    /* 'ambiwidth' */\n#ifdef FEAT_MBYTE\n    else if (varp == &p_ambw || varp == &p_emoji)\n    {\n\tif (check_opt_strings(p_ambw, p_ambw_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n\telse if (set_chars_option(&p_lcs) != NULL)\n\t    errmsg = (char_u *)_(\"E834: Conflicts with value of 'listchars'\");\n# if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)\n\telse if (set_chars_option(&p_fcs) != NULL)\n\t    errmsg = (char_u *)_(\"E835: Conflicts with value of 'fillchars'\");\n# endif\n    }\n#endif\n\n    /* 'background' */\n    else if (varp == &p_bg)\n    {\n\tif (check_opt_strings(p_bg, p_bg_values, FALSE) == OK)\n\t{\n#ifdef FEAT_EVAL\n\t    int dark = (*p_bg == 'd');\n#endif\n\n\t    init_highlight(FALSE, FALSE);\n\n#ifdef FEAT_EVAL\n\t    if (dark != (*p_bg == 'd')\n\t\t\t  && get_var_value((char_u *)\"g:colors_name\") != NULL)\n\t    {\n\t\t/* The color scheme must have set 'background' back to another\n\t\t * value, that's not what we want here.  Disable the color\n\t\t * scheme and set the colors again. */\n\t\tdo_unlet((char_u *)\"g:colors_name\", TRUE);\n\t\tfree_string_option(p_bg);\n\t\tp_bg = vim_strsave((char_u *)(dark ? \"dark\" : \"light\"));\n\t\tcheck_string_option(&p_bg);\n\t\tinit_highlight(FALSE, FALSE);\n\t    }\n#endif\n\t}\n\telse\n\t    errmsg = e_invarg;\n    }\n\n    /* 'wildmode' */\n    else if (varp == &p_wim)\n    {\n\tif (check_opt_wim() == FAIL)\n\t    errmsg = e_invarg;\n    }\n\n#ifdef FEAT_CMDL_COMPL\n    /* 'wildoptions' */\n    else if (varp == &p_wop)\n    {\n\tif (check_opt_strings(p_wop, p_wop_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_WAK\n    /* 'winaltkeys' */\n    else if (varp == &p_wak)\n    {\n\tif (*p_wak == NUL\n\t\t|| check_opt_strings(p_wak, p_wak_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n# ifdef FEAT_MENU\n#  ifdef FEAT_GUI_MOTIF\n\telse if (gui.in_use)\n\t    gui_motif_set_mnemonics(p_wak[0] == 'y' || p_wak[0] == 'm');\n#  else\n#   ifdef FEAT_GUI_GTK\n\telse if (gui.in_use)\n\t    gui_gtk_set_mnemonics(p_wak[0] == 'y' || p_wak[0] == 'm');\n#   endif\n#  endif\n# endif\n    }\n#endif\n\n#ifdef FEAT_AUTOCMD\n    /* 'eventignore' */\n    else if (varp == &p_ei)\n    {\n\tif (check_ei() == FAIL)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_MBYTE\n    /* 'encoding' and 'fileencoding' */\n    else if (varp == &p_enc || gvarp == &p_fenc || varp == &p_tenc)\n    {\n\tif (gvarp == &p_fenc)\n\t{\n\t    if (!curbuf->b_p_ma && opt_flags != OPT_GLOBAL)\n\t\terrmsg = e_modifiable;\n\t    else if (vim_strchr(*varp, ',') != NULL)\n\t\t/* No comma allowed in 'fileencoding'; catches confusing it\n\t\t * with 'fileencodings'. */\n\t\terrmsg = e_invarg;\n\t    else\n\t    {\n# ifdef FEAT_TITLE\n\t\t/* May show a \"+\" in the title now. */\n\t\tredraw_titles();\n# endif\n\t\t/* Add 'fileencoding' to the swap file. */\n\t\tml_setflags(curbuf);\n\t    }\n\t}\n\tif (errmsg == NULL)\n\t{\n\t    /* canonize the value, so that STRCMP() can be used on it */\n\t    p = enc_canonize(*varp);\n\t    if (p != NULL)\n\t    {\n\t\tvim_free(*varp);\n\t\t*varp = p;\n\t    }\n\t    if (varp == &p_enc)\n\t    {\n\t\terrmsg = mb_init();\n# ifdef FEAT_TITLE\n\t\tredraw_titles();\n# endif\n\t    }\n\t}\n\n# if defined(FEAT_GUI_GTK)\n\tif (errmsg == NULL && varp == &p_tenc && gui.in_use)\n\t{\n\t    /* GTK+ 2 uses only a single encoding, and that is UTF-8. */\n\t    if (STRCMP(p_tenc, \"utf-8\") != 0)\n\t\terrmsg = (char_u *)N_(\"E617: Cannot be changed in the GTK+ 2 GUI\");\n\t}\n# endif\n\n\tif (errmsg == NULL)\n\t{\n# ifdef FEAT_KEYMAP\n\t    /* When 'keymap' is used and 'encoding' changes, reload the keymap\n\t     * (with another encoding). */\n\t    if (varp == &p_enc && *curbuf->b_p_keymap != NUL)\n\t\t(void)keymap_init();\n# endif\n\n\t    /* When 'termencoding' is not empty and 'encoding' changes or when\n\t     * 'termencoding' changes, need to setup for keyboard input and\n\t     * display output conversion. */\n\t    if (((varp == &p_enc && *p_tenc != NUL) || varp == &p_tenc))\n\t    {\n\t\tconvert_setup(&input_conv, p_tenc, p_enc);\n\t\tconvert_setup(&output_conv, p_enc, p_tenc);\n\t    }\n\n# if defined(WIN3264) && defined(FEAT_MBYTE)\n\t    /* $HOME may have characters in active code page. */\n\t    if (varp == &p_enc)\n\t\tinit_homedir();\n# endif\n\t}\n    }\n#endif\n\n#if defined(FEAT_POSTSCRIPT)\n    else if (varp == &p_penc)\n    {\n\t/* Canonize printencoding if VIM standard one */\n\tp = enc_canonize(p_penc);\n\tif (p != NULL)\n\t{\n\t    vim_free(p_penc);\n\t    p_penc = p;\n\t}\n\telse\n\t{\n\t    /* Ensure lower case and '-' for '_' */\n\t    for (s = p_penc; *s != NUL; s++)\n\t    {\n\t\tif (*s == '_')\n\t\t    *s = '-';\n\t\telse\n\t\t    *s = TOLOWER_ASC(*s);\n\t    }\n\t}\n    }\n#endif\n\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    else if (varp == &p_imak)\n    {\n\tif (gui.in_use && !im_xim_isvalid_imactivate())\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_KEYMAP\n    else if (varp == &curbuf->b_p_keymap)\n    {\n\t/* load or unload key mapping tables */\n\terrmsg = keymap_init();\n\n\tif (errmsg == NULL)\n\t{\n\t    if (*curbuf->b_p_keymap != NUL)\n\t    {\n\t\t/* Installed a new keymap, switch on using it. */\n\t\tcurbuf->b_p_iminsert = B_IMODE_LMAP;\n\t\tif (curbuf->b_p_imsearch != B_IMODE_USE_INSERT)\n\t\t    curbuf->b_p_imsearch = B_IMODE_LMAP;\n\t    }\n\t    else\n\t    {\n\t\t/* Cleared the keymap, may reset 'iminsert' and 'imsearch'. */\n\t\tif (curbuf->b_p_iminsert == B_IMODE_LMAP)\n\t\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t\tif (curbuf->b_p_imsearch == B_IMODE_LMAP)\n\t\t    curbuf->b_p_imsearch = B_IMODE_USE_INSERT;\n\t    }\n\t    if ((opt_flags & OPT_LOCAL) == 0)\n\t    {\n\t\tset_iminsert_global();\n\t\tset_imsearch_global();\n\t    }\n# ifdef FEAT_WINDOWS\n\t    status_redraw_curbuf();\n# endif\n\t}\n    }\n#endif\n\n    /* 'fileformat' */\n    else if (gvarp == &p_ff)\n    {\n\tif (!curbuf->b_p_ma && !(opt_flags & OPT_GLOBAL))\n\t    errmsg = e_modifiable;\n\telse if (check_opt_strings(*varp, p_ff_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    /* may also change 'textmode' */\n\t    if (get_fileformat(curbuf) == EOL_DOS)\n\t\tcurbuf->b_p_tx = TRUE;\n\t    else\n\t\tcurbuf->b_p_tx = FALSE;\n#ifdef FEAT_TITLE\n\t    redraw_titles();\n#endif\n\t    /* update flag in swap file */\n\t    ml_setflags(curbuf);\n\t    /* Redraw needed when switching to/from \"mac\": a CR in the text\n\t     * will be displayed differently. */\n\t    if (get_fileformat(curbuf) == EOL_MAC || *oldval == 'm')\n\t\tredraw_curbuf_later(NOT_VALID);\n\t}\n    }\n\n    /* 'fileformats' */\n    else if (varp == &p_ffs)\n    {\n\tif (check_opt_strings(p_ffs, p_ff_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    /* also change 'textauto' */\n\t    if (*p_ffs == NUL)\n\t\tp_ta = FALSE;\n\t    else\n\t\tp_ta = TRUE;\n\t}\n    }\n\n#if defined(FEAT_CRYPT)\n    /* 'cryptkey' */\n    else if (gvarp == &p_key)\n    {\n# if defined(FEAT_CMDHIST)\n\t/* Make sure the \":set\" command doesn't show the new value in the\n\t * history. */\n\tremove_key_from_history();\n# endif\n\tif (STRCMP(curbuf->b_p_key, oldval) != 0)\n\t    /* Need to update the swapfile. */\n\t    ml_set_crypt_key(curbuf, oldval,\n\t\t\t      *curbuf->b_p_cm == NUL ? p_cm : curbuf->b_p_cm);\n    }\n\n    else if (gvarp == &p_cm)\n    {\n\tif (opt_flags & OPT_LOCAL)\n\t    p = curbuf->b_p_cm;\n\telse\n\t    p = p_cm;\n\tif (check_opt_strings(p, p_cm_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse if (crypt_self_test() == FAIL)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    /* When setting the global value to empty, make it \"zip\". */\n\t    if (*p_cm == NUL)\n\t    {\n\t\tif (new_value_alloced)\n\t\t    free_string_option(p_cm);\n\t\tp_cm = vim_strsave((char_u *)\"zip\");\n\t\tnew_value_alloced = TRUE;\n\t    }\n\t    /* When using \":set cm=name\" the local value is going to be empty.\n\t     * Do that here, otherwise the crypt functions will still use the\n\t     * local value. */\n\t    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\t    {\n\t\tfree_string_option(curbuf->b_p_cm);\n\t\tcurbuf->b_p_cm = empty_option;\n\t    }\n\n\t    /* Need to update the swapfile when the effective method changed.\n\t     * Set \"s\" to the effective old value, \"p\" to the effective new\n\t     * method and compare. */\n\t    if ((opt_flags & OPT_LOCAL) && *oldval == NUL)\n\t\ts = p_cm;  /* was previously using the global value */\n\t    else\n\t\ts = oldval;\n\t    if (*curbuf->b_p_cm == NUL)\n\t\tp = p_cm;  /* is now using the global value */\n\t    else\n\t\tp = curbuf->b_p_cm;\n\t    if (STRCMP(s, p) != 0)\n\t\tml_set_crypt_key(curbuf, curbuf->b_p_key, s);\n\n\t    /* If the global value changes need to update the swapfile for all\n\t     * buffers using that value. */\n\t    if ((opt_flags & OPT_GLOBAL) && STRCMP(p_cm, oldval) != 0)\n\t    {\n\t\tbuf_T\t*buf;\n\n\t\tFOR_ALL_BUFFERS(buf)\n\t\t    if (buf != curbuf && *buf->b_p_cm == NUL)\n\t\t\tml_set_crypt_key(buf, buf->b_p_key, oldval);\n\t    }\n\t}\n    }\n#endif\n\n    /* 'matchpairs' */\n    else if (gvarp == &p_mps)\n    {\n#ifdef FEAT_MBYTE\n\tif (has_mbyte)\n\t{\n\t    for (p = *varp; *p != NUL; ++p)\n\t    {\n\t\tint x2 = -1;\n\t\tint x3 = -1;\n\n\t\tif (*p != NUL)\n\t\t    p += mb_ptr2len(p);\n\t\tif (*p != NUL)\n\t\t    x2 = *p++;\n\t\tif (*p != NUL)\n\t\t{\n\t\t    x3 = mb_ptr2char(p);\n\t\t    p += mb_ptr2len(p);\n\t\t}\n\t\tif (x2 != ':' || x3 == -1 || (*p != NUL && *p != ','))\n\t\t{\n\t\t    errmsg = e_invarg;\n\t\t    break;\n\t\t}\n\t\tif (*p == NUL)\n\t\t    break;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    /* Check for \"x:y,x:y\" */\n\t    for (p = *varp; *p != NUL; p += 4)\n\t    {\n\t\tif (p[1] != ':' || p[2] == NUL || (p[3] != NUL && p[3] != ','))\n\t\t{\n\t\t    errmsg = e_invarg;\n\t\t    break;\n\t\t}\n\t\tif (p[3] == NUL)\n\t\t    break;\n\t    }\n\t}\n    }\n\n#ifdef FEAT_COMMENTS\n    /* 'comments' */\n    else if (gvarp == &p_com)\n    {\n\tfor (s = *varp; *s; )\n\t{\n\t    while (*s && *s != ':')\n\t    {\n\t\tif (vim_strchr((char_u *)COM_ALL, *s) == NULL\n\t\t\t\t\t     && !VIM_ISDIGIT(*s) && *s != '-')\n\t\t{\n\t\t    errmsg = illegal_char(errbuf, *s);\n\t\t    break;\n\t\t}\n\t\t++s;\n\t    }\n\t    if (*s++ == NUL)\n\t\terrmsg = (char_u *)N_(\"E524: Missing colon\");\n\t    else if (*s == ',' || *s == NUL)\n\t\terrmsg = (char_u *)N_(\"E525: Zero length string\");\n\t    if (errmsg != NULL)\n\t\tbreak;\n\t    while (*s && *s != ',')\n\t    {\n\t\tif (*s == '\\\\' && s[1] != NUL)\n\t\t    ++s;\n\t\t++s;\n\t    }\n\t    s = skip_to_option_part(s);\n\t}\n    }\n#endif\n\n    /* 'listchars' */\n    else if (varp == &p_lcs)\n    {\n\terrmsg = set_chars_option(varp);\n    }\n\n#if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)\n    /* 'fillchars' */\n    else if (varp == &p_fcs)\n    {\n\terrmsg = set_chars_option(varp);\n    }\n#endif\n\n#ifdef FEAT_CMDWIN\n    /* 'cedit' */\n    else if (varp == &p_cedit)\n    {\n\terrmsg = check_cedit();\n    }\n#endif\n\n    /* 'verbosefile' */\n    else if (varp == &p_vfile)\n    {\n\tverbose_stop();\n\tif (*p_vfile != NUL && verbose_open() == FAIL)\n\t    errmsg = e_invarg;\n    }\n\n#ifdef FEAT_VIMINFO\n    /* 'viminfo' */\n    else if (varp == &p_viminfo)\n    {\n\tfor (s = p_viminfo; *s;)\n\t{\n\t    /* Check it's a valid character */\n\t    if (vim_strchr((char_u *)\"!\\\"%'/:<@cfhnrs\", *s) == NULL)\n\t    {\n\t\terrmsg = illegal_char(errbuf, *s);\n\t\tbreak;\n\t    }\n\t    if (*s == 'n')\t/* name is always last one */\n\t    {\n\t\tbreak;\n\t    }\n\t    else if (*s == 'r') /* skip until next ',' */\n\t    {\n\t\twhile (*++s && *s != ',')\n\t\t    ;\n\t    }\n\t    else if (*s == '%')\n\t    {\n\t\t/* optional number */\n\t\twhile (vim_isdigit(*++s))\n\t\t    ;\n\t    }\n\t    else if (*s == '!' || *s == 'h' || *s == 'c')\n\t\t++s;\t\t/* no extra chars */\n\t    else\t\t/* must have a number */\n\t    {\n\t\twhile (vim_isdigit(*++s))\n\t\t    ;\n\n\t\tif (!VIM_ISDIGIT(*(s - 1)))\n\t\t{\n\t\t    if (errbuf != NULL)\n\t\t    {\n\t\t\tsprintf((char *)errbuf,\n\t\t\t\t\t _(\"E526: Missing number after <%s>\"),\n\t\t\t\t\t\t    transchar_byte(*(s - 1)));\n\t\t\terrmsg = errbuf;\n\t\t    }\n\t\t    else\n\t\t\terrmsg = (char_u *)\"\";\n\t\t    break;\n\t\t}\n\t    }\n\t    if (*s == ',')\n\t\t++s;\n\t    else if (*s)\n\t    {\n\t\tif (errbuf != NULL)\n\t\t    errmsg = (char_u *)N_(\"E527: Missing comma\");\n\t\telse\n\t\t    errmsg = (char_u *)\"\";\n\t\tbreak;\n\t    }\n\t}\n\tif (*p_viminfo && errmsg == NULL && get_viminfo_parameter('\\'') < 0)\n\t    errmsg = (char_u *)N_(\"E528: Must specify a ' value\");\n    }\n#endif /* FEAT_VIMINFO */\n\n    /* terminal options */\n    else if (istermoption(&options[opt_idx]) && full_screen)\n    {\n\t/* \":set t_Co=0\" and \":set t_Co=1\" do \":set t_Co=\" */\n\tif (varp == &T_CCO)\n\t{\n\t    int colors = atoi((char *)T_CCO);\n\n\t    /* Only reinitialize colors if t_Co value has really changed to\n\t     * avoid expensive reload of colorscheme if t_Co is set to the\n\t     * same value multiple times. */\n\t    if (colors != t_colors)\n\t    {\n\t\tt_colors = colors;\n\t\tif (t_colors <= 1)\n\t\t{\n\t\t    if (new_value_alloced)\n\t\t\tvim_free(T_CCO);\n\t\t    T_CCO = empty_option;\n\t\t}\n\t\t/* We now have a different color setup, initialize it again. */\n\t\tinit_highlight(TRUE, FALSE);\n\t    }\n\t}\n\tttest(FALSE);\n\tif (varp == &T_ME)\n\t{\n\t    out_str(T_ME);\n\t    redraw_later(CLEAR);\n#if defined(WIN3264) && !defined(FEAT_GUI_W32)\n\t    /* Since t_me has been set, this probably means that the user\n\t     * wants to use this as default colors.  Need to reset default\n\t     * background/foreground colors. */\n\t    mch_set_normal_colors();\n#endif\n\t}\n    }\n\n#ifdef FEAT_LINEBREAK\n    /* 'showbreak' */\n    else if (varp == &p_sbr)\n    {\n\tfor (s = p_sbr; *s; )\n\t{\n\t    if (ptr2cells(s) != 1)\n\t\terrmsg = (char_u *)N_(\"E595: contains unprintable or wide character\");\n\t    mb_ptr_adv(s);\n\t}\n    }\n#endif\n\n#ifdef FEAT_GUI\n    /* 'guifont' */\n    else if (varp == &p_guifont)\n    {\n\tif (gui.in_use)\n\t{\n\t    p = p_guifont;\n# if defined(FEAT_GUI_GTK)\n\t    /*\n\t     * Put up a font dialog and let the user select a new value.\n\t     * If this is cancelled go back to the old value but don't\n\t     * give an error message.\n\t     */\n\t    if (STRCMP(p, \"*\") == 0)\n\t    {\n\t\tp = gui_mch_font_dialog(oldval);\n\n\t\tif (new_value_alloced)\n\t\t    free_string_option(p_guifont);\n\n\t\tp_guifont = (p != NULL) ? p : vim_strsave(oldval);\n\t\tnew_value_alloced = TRUE;\n\t    }\n# endif\n\t    if (p != NULL && gui_init_font(p_guifont, FALSE) != OK)\n\t    {\n# if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_PHOTON)\n\t\tif (STRCMP(p_guifont, \"*\") == 0)\n\t\t{\n\t\t    /* Dialog was cancelled: Keep the old value without giving\n\t\t     * an error message. */\n\t\t    if (new_value_alloced)\n\t\t\tfree_string_option(p_guifont);\n\t\t    p_guifont = vim_strsave(oldval);\n\t\t    new_value_alloced = TRUE;\n\t\t}\n\t\telse\n# endif\n\t\t    errmsg = (char_u *)N_(\"E596: Invalid font(s)\");\n\t    }\n\t}\n\tredraw_gui_only = TRUE;\n    }\n# ifdef FEAT_XFONTSET\n    else if (varp == &p_guifontset)\n    {\n\tif (STRCMP(p_guifontset, \"*\") == 0)\n\t    errmsg = (char_u *)N_(\"E597: can't select fontset\");\n\telse if (gui.in_use && gui_init_font(p_guifontset, TRUE) != OK)\n\t    errmsg = (char_u *)N_(\"E598: Invalid fontset\");\n\tredraw_gui_only = TRUE;\n    }\n# endif\n# ifdef FEAT_MBYTE\n    else if (varp == &p_guifontwide)\n    {\n\tif (STRCMP(p_guifontwide, \"*\") == 0)\n\t    errmsg = (char_u *)N_(\"E533: can't select wide font\");\n\telse if (gui_get_wide_font() == FAIL)\n\t    errmsg = (char_u *)N_(\"E534: Invalid wide font\");\n\tredraw_gui_only = TRUE;\n    }\n# endif\n#endif\n\n#ifdef CURSOR_SHAPE\n    /* 'guicursor' */\n    else if (varp == &p_guicursor)\n\terrmsg = parse_shape_opt(SHAPE_CURSOR);\n#endif\n\n#ifdef FEAT_MOUSESHAPE\n    /* 'mouseshape' */\n    else if (varp == &p_mouseshape)\n    {\n\terrmsg = parse_shape_opt(SHAPE_MOUSE);\n\tupdate_mouseshape(-1);\n    }\n#endif\n\n#ifdef FEAT_PRINTER\n    else if (varp == &p_popt)\n\terrmsg = parse_printoptions();\n# if defined(FEAT_MBYTE) && defined(FEAT_POSTSCRIPT)\n    else if (varp == &p_pmfn)\n\terrmsg = parse_printmbfont();\n# endif\n#endif\n\n#ifdef FEAT_LANGMAP\n    /* 'langmap' */\n    else if (varp == &p_langmap)\n\tlangmap_set();\n#endif\n\n#ifdef FEAT_LINEBREAK\n    /* 'breakat' */\n    else if (varp == &p_breakat)\n\tfill_breakat_flags();\n#endif\n\n#ifdef FEAT_TITLE\n    /* 'titlestring' and 'iconstring' */\n    else if (varp == &p_titlestring || varp == &p_iconstring)\n    {\n# ifdef FEAT_STL_OPT\n\tint\tflagval = (varp == &p_titlestring) ? STL_IN_TITLE : STL_IN_ICON;\n\n\t/* NULL => statusline syntax */\n\tif (vim_strchr(*varp, '%') && check_stl_option(*varp) == NULL)\n\t    stl_syntax |= flagval;\n\telse\n\t    stl_syntax &= ~flagval;\n# endif\n\tdid_set_title(varp == &p_iconstring);\n\n    }\n#endif\n\n#ifdef FEAT_GUI\n    /* 'guioptions' */\n    else if (varp == &p_go)\n    {\n\tgui_init_which_components(oldval);\n\tredraw_gui_only = TRUE;\n    }\n#endif\n\n#if defined(FEAT_GUI_TABLINE)\n    /* 'guitablabel' */\n    else if (varp == &p_gtl)\n    {\n\tredraw_tabline = TRUE;\n\tredraw_gui_only = TRUE;\n    }\n    /* 'guitabtooltip' */\n    else if (varp == &p_gtt)\n    {\n\tredraw_gui_only = TRUE;\n    }\n#endif\n\n#if defined(FEAT_MOUSE_TTY) && (defined(UNIX) || defined(VMS))\n    /* 'ttymouse' */\n    else if (varp == &p_ttym)\n    {\n\t/* Switch the mouse off before changing the escape sequences used for\n\t * that. */\n\tmch_setmouse(FALSE);\n\tif (opt_strings_flags(p_ttym, p_ttym_values, &ttym_flags, FALSE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t    check_mouse_termcode();\n\tif (termcap_active)\n\t    setmouse();\t\t/* may switch it on again */\n    }\n#endif\n\n    /* 'selection' */\n    else if (varp == &p_sel)\n    {\n\tif (*p_sel == NUL\n\t\t|| check_opt_strings(p_sel, p_sel_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    /* 'selectmode' */\n    else if (varp == &p_slm)\n    {\n\tif (check_opt_strings(p_slm, p_slm_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n#ifdef FEAT_BROWSE\n    /* 'browsedir' */\n    else if (varp == &p_bsdir)\n    {\n\tif (check_opt_strings(p_bsdir, p_bsdir_values, FALSE) != OK\n\t\t&& !mch_isdir(p_bsdir))\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    /* 'keymodel' */\n    else if (varp == &p_km)\n    {\n\tif (check_opt_strings(p_km, p_km_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    km_stopsel = (vim_strchr(p_km, 'o') != NULL);\n\t    km_startsel = (vim_strchr(p_km, 'a') != NULL);\n\t}\n    }\n\n    /* 'mousemodel' */\n    else if (varp == &p_mousem)\n    {\n\tif (check_opt_strings(p_mousem, p_mousem_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n#if defined(FEAT_GUI_MOTIF) && defined(FEAT_MENU) && (XmVersion <= 1002)\n\telse if (*p_mousem != *oldval)\n\t    /* Changed from \"extend\" to \"popup\" or \"popup_setpos\" or vv: need\n\t     * to create or delete the popup menus. */\n\t    gui_motif_update_mousemodel(root_menu);\n#endif\n    }\n\n    /* 'switchbuf' */\n    else if (varp == &p_swb)\n    {\n\tif (opt_strings_flags(p_swb, p_swb_values, &swb_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    /* 'debug' */\n    else if (varp == &p_debug)\n    {\n\tif (check_opt_strings(p_debug, p_debug_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    /* 'display' */\n    else if (varp == &p_dy)\n    {\n\tif (opt_strings_flags(p_dy, p_dy_values, &dy_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t    (void)init_chartab();\n\n    }\n\n#ifdef FEAT_WINDOWS\n    /* 'eadirection' */\n    else if (varp == &p_ead)\n    {\n\tif (check_opt_strings(p_ead, p_ead_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_CLIPBOARD\n    /* 'clipboard' */\n    else if (varp == &p_cb)\n\terrmsg = check_clipboard_option();\n#endif\n\n#ifdef FEAT_SPELL\n    /* When 'spelllang' or 'spellfile' is set and there is a window for this\n     * buffer in which 'spell' is set load the wordlists. */\n    else if (varp == &(curwin->w_s->b_p_spl)\n\t    || varp == &(curwin->w_s->b_p_spf))\n    {\n\terrmsg = did_set_spell_option(varp == &(curwin->w_s->b_p_spf));\n    }\n    /* When 'spellcapcheck' is set compile the regexp program. */\n    else if (varp == &(curwin->w_s->b_p_spc))\n    {\n\terrmsg = compile_cap_prog(curwin->w_s);\n    }\n    /* 'spellsuggest' */\n    else if (varp == &p_sps)\n    {\n\tif (spell_check_sps() != OK)\n\t    errmsg = e_invarg;\n    }\n    /* 'mkspellmem' */\n    else if (varp == &p_msm)\n    {\n\tif (spell_check_msm() != OK)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_QUICKFIX\n    /* When 'bufhidden' is set, check for valid value. */\n    else if (gvarp == &p_bh)\n    {\n\tif (check_opt_strings(curbuf->b_p_bh, p_bufhidden_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    /* When 'buftype' is set, check for valid value. */\n    else if (gvarp == &p_bt)\n    {\n\tif (check_opt_strings(curbuf->b_p_bt, p_buftype_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n# ifdef FEAT_WINDOWS\n\t    if (curwin->w_status_height)\n\t    {\n\t\tcurwin->w_redr_status = TRUE;\n\t\tredraw_later(VALID);\n\t    }\n# endif\n\t    curbuf->b_help = (curbuf->b_p_bt[0] == 'h');\n# ifdef FEAT_TITLE\n\t    redraw_titles();\n# endif\n\t}\n    }\n#endif\n\n#ifdef FEAT_STL_OPT\n    /* 'statusline' or 'rulerformat' */\n    else if (gvarp == &p_stl || varp == &p_ruf)\n    {\n\tint wid;\n\n\tif (varp == &p_ruf)\t/* reset ru_wid first */\n\t    ru_wid = 0;\n\ts = *varp;\n\tif (varp == &p_ruf && *s == '%')\n\t{\n\t    /* set ru_wid if 'ruf' starts with \"%99(\" */\n\t    if (*++s == '-')\t/* ignore a '-' */\n\t\ts++;\n\t    wid = getdigits(&s);\n\t    if (wid && *s == '(' && (errmsg = check_stl_option(p_ruf)) == NULL)\n\t\tru_wid = wid;\n\t    else\n\t\terrmsg = check_stl_option(p_ruf);\n\t}\n\t/* check 'statusline' only if it doesn't start with \"%!\" */\n\telse if (varp == &p_ruf || s[0] != '%' || s[1] != '!')\n\t    errmsg = check_stl_option(s);\n\tif (varp == &p_ruf && errmsg == NULL)\n\t    comp_col();\n    }\n#endif\n\n#ifdef FEAT_INS_EXPAND\n    /* check if it is a valid value for 'complete' -- Acevedo */\n    else if (gvarp == &p_cpt)\n    {\n\tfor (s = *varp; *s;)\n\t{\n\t    while (*s == ',' || *s == ' ')\n\t\ts++;\n\t    if (!*s)\n\t\tbreak;\n\t    if (vim_strchr((char_u *)\".wbuksid]tU\", *s) == NULL)\n\t    {\n\t\terrmsg = illegal_char(errbuf, *s);\n\t\tbreak;\n\t    }\n\t    if (*++s != NUL && *s != ',' && *s != ' ')\n\t    {\n\t\tif (s[-1] == 'k' || s[-1] == 's')\n\t\t{\n\t\t    /* skip optional filename after 'k' and 's' */\n\t\t    while (*s && *s != ',' && *s != ' ')\n\t\t    {\n\t\t\tif (*s == '\\\\')\n\t\t\t    ++s;\n\t\t\t++s;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (errbuf != NULL)\n\t\t    {\n\t\t\tsprintf((char *)errbuf,\n\t\t\t\t     _(\"E535: Illegal character after <%c>\"),\n\t\t\t\t     *--s);\n\t\t\terrmsg = errbuf;\n\t\t    }\n\t\t    else\n\t\t\terrmsg = (char_u *)\"\";\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n\n    /* 'completeopt' */\n    else if (varp == &p_cot)\n    {\n\tif (check_opt_strings(p_cot, p_cot_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t    completeopt_was_set();\n    }\n#endif /* FEAT_INS_EXPAND */\n\n#ifdef FEAT_SIGNS\n    /* 'signcolumn' */\n    else if (varp == &curwin->w_p_scl)\n    {\n\tif (check_opt_strings(*varp, p_scl_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n\n#if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_W32)\n    else if (varp == &p_toolbar)\n    {\n\tif (opt_strings_flags(p_toolbar, p_toolbar_values,\n\t\t\t      &toolbar_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    out_flush();\n\t    gui_mch_show_toolbar((toolbar_flags &\n\t\t\t\t  (TOOLBAR_TEXT | TOOLBAR_ICONS)) != 0);\n\t}\n    }\n#endif\n\n#if defined(FEAT_TOOLBAR) && defined(FEAT_GUI_GTK)\n    /* 'toolbariconsize': GTK+ 2 only */\n    else if (varp == &p_tbis)\n    {\n\tif (opt_strings_flags(p_tbis, p_tbis_values, &tbis_flags, FALSE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    out_flush();\n\t    gui_mch_show_toolbar((toolbar_flags &\n\t\t\t\t  (TOOLBAR_TEXT | TOOLBAR_ICONS)) != 0);\n\t}\n    }\n#endif\n\n    /* 'pastetoggle': translate key codes like in a mapping */\n    else if (varp == &p_pt)\n    {\n\tif (*p_pt)\n\t{\n\t    (void)replace_termcodes(p_pt, &p, TRUE, TRUE, FALSE);\n\t    if (p != NULL)\n\t    {\n\t\tif (new_value_alloced)\n\t\t    free_string_option(p_pt);\n\t\tp_pt = p;\n\t\tnew_value_alloced = TRUE;\n\t    }\n\t}\n    }\n\n    /* 'backspace' */\n    else if (varp == &p_bs)\n    {\n\tif (VIM_ISDIGIT(*p_bs))\n\t{\n\t    if (*p_bs > '2' || p_bs[1] != NUL)\n\t\terrmsg = e_invarg;\n\t}\n\telse if (check_opt_strings(p_bs, p_bs_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n    else if (varp == &p_bo)\n    {\n\tif (opt_strings_flags(p_bo, p_bo_values, &bo_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    /* 'tagcase' */\n    else if (gvarp == &p_tc)\n    {\n\tunsigned int\t*flags;\n\n\tif (opt_flags & OPT_LOCAL)\n\t{\n\t    p = curbuf->b_p_tc;\n\t    flags = &curbuf->b_tc_flags;\n\t}\n\telse\n\t{\n\t    p = p_tc;\n\t    flags = &tc_flags;\n\t}\n\n\tif ((opt_flags & OPT_LOCAL) && *p == NUL)\n\t    /* make the local value empty: use the global value */\n\t    *flags = 0;\n\telse if (*p == NUL\n\t\t|| opt_strings_flags(p, p_tc_values, flags, FALSE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n#ifdef FEAT_MBYTE\n    /* 'casemap' */\n    else if (varp == &p_cmp)\n    {\n\tif (opt_strings_flags(p_cmp, p_cmp_values, &cmp_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_DIFF\n    /* 'diffopt' */\n    else if (varp == &p_dip)\n    {\n\tif (diffopt_changed() == FAIL)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_FOLDING\n    /* 'foldmethod' */\n    else if (gvarp == &curwin->w_allbuf_opt.wo_fdm)\n    {\n\tif (check_opt_strings(*varp, p_fdm_values, FALSE) != OK\n\t\t|| *curwin->w_p_fdm == NUL)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    foldUpdateAll(curwin);\n\t    if (foldmethodIsDiff(curwin))\n\t\tnewFoldLevel();\n\t}\n    }\n# ifdef FEAT_EVAL\n    /* 'foldexpr' */\n    else if (varp == &curwin->w_p_fde)\n    {\n\tif (foldmethodIsExpr(curwin))\n\t    foldUpdateAll(curwin);\n    }\n# endif\n    /* 'foldmarker' */\n    else if (gvarp == &curwin->w_allbuf_opt.wo_fmr)\n    {\n\tp = vim_strchr(*varp, ',');\n\tif (p == NULL)\n\t    errmsg = (char_u *)N_(\"E536: comma required\");\n\telse if (p == *varp || p[1] == NUL)\n\t    errmsg = e_invarg;\n\telse if (foldmethodIsMarker(curwin))\n\t    foldUpdateAll(curwin);\n    }\n    /* 'commentstring' */\n    else if (gvarp == &p_cms)\n    {\n\tif (**varp != NUL && strstr((char *)*varp, \"%s\") == NULL)\n\t    errmsg = (char_u *)N_(\"E537: 'commentstring' must be empty or contain %s\");\n    }\n    /* 'foldopen' */\n    else if (varp == &p_fdo)\n    {\n\tif (opt_strings_flags(p_fdo, p_fdo_values, &fdo_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n    /* 'foldclose' */\n    else if (varp == &p_fcl)\n    {\n\tif (check_opt_strings(p_fcl, p_fcl_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n    /* 'foldignore' */\n    else if (gvarp == &curwin->w_allbuf_opt.wo_fdi)\n    {\n\tif (foldmethodIsIndent(curwin))\n\t    foldUpdateAll(curwin);\n    }\n#endif\n\n#ifdef FEAT_VIRTUALEDIT\n    /* 'virtualedit' */\n    else if (varp == &p_ve)\n    {\n\tif (opt_strings_flags(p_ve, p_ve_values, &ve_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse if (STRCMP(p_ve, oldval) != 0)\n\t{\n\t    /* Recompute cursor position in case the new 've' setting\n\t     * changes something. */\n\t    validate_virtcol();\n\t    coladvance(curwin->w_virtcol);\n\t}\n    }\n#endif\n\n#if defined(FEAT_CSCOPE) && defined(FEAT_QUICKFIX)\n    else if (varp == &p_csqf)\n    {\n\tif (p_csqf != NULL)\n\t{\n\t    p = p_csqf;\n\t    while (*p != NUL)\n\t    {\n\t\tif (vim_strchr((char_u *)CSQF_CMDS, *p) == NULL\n\t\t\t|| p[1] == NUL\n\t\t\t|| vim_strchr((char_u *)CSQF_FLAGS, p[1]) == NULL\n\t\t\t|| (p[2] != NUL && p[2] != ','))\n\t\t{\n\t\t    errmsg = e_invarg;\n\t\t    break;\n\t\t}\n\t\telse if (p[2] == NUL)\n\t\t    break;\n\t\telse\n\t\t    p += 3;\n\t    }\n\t}\n    }\n#endif\n\n#ifdef FEAT_CINDENT\n    /* 'cinoptions' */\n    else if (gvarp == &p_cino)\n    {\n\t/* TODO: recognize errors */\n\tparse_cino(curbuf);\n    }\n#endif\n\n#if defined(FEAT_RENDER_OPTIONS)\n    else if (varp == &p_rop && gui.in_use)\n    {\n\tif (!gui_mch_set_rendering_options(p_rop))\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    /* Options that are a list of flags. */\n    else\n    {\n\tp = NULL;\n\tif (varp == &p_ww)\n\t    p = (char_u *)WW_ALL;\n\tif (varp == &p_shm)\n\t    p = (char_u *)SHM_ALL;\n\telse if (varp == &(p_cpo))\n\t    p = (char_u *)CPO_ALL;\n\telse if (varp == &(curbuf->b_p_fo))\n\t    p = (char_u *)FO_ALL;\n#ifdef FEAT_CONCEAL\n\telse if (varp == &curwin->w_p_cocu)\n\t    p = (char_u *)COCU_ALL;\n#endif\n\telse if (varp == &p_mouse)\n\t{\n#ifdef FEAT_MOUSE\n\t    p = (char_u *)MOUSE_ALL;\n#else\n\t    if (*p_mouse != NUL)\n\t\terrmsg = (char_u *)N_(\"E538: No mouse support\");\n#endif\n\t}\n#if defined(FEAT_GUI)\n\telse if (varp == &p_go)\n\t    p = (char_u *)GO_ALL;\n#endif\n\tif (p != NULL)\n\t{\n\t    for (s = *varp; *s; ++s)\n\t\tif (vim_strchr(p, *s) == NULL)\n\t\t{\n\t\t    errmsg = illegal_char(errbuf, *s);\n\t\t    break;\n\t\t}\n\t}\n    }\n\n    /*\n     * If error detected, restore the previous value.\n     */\n    if (errmsg != NULL)\n    {\n\tif (new_value_alloced)\n\t    free_string_option(*varp);\n\t*varp = oldval;\n\t/*\n\t * When resetting some values, need to act on it.\n\t */\n\tif (did_chartab)\n\t    (void)init_chartab();\n\tif (varp == &p_hl)\n\t    (void)highlight_changed();\n    }\n    else\n    {\n#ifdef FEAT_EVAL\n\t/* Remember where the option was set. */\n\tset_option_scriptID_idx(opt_idx, opt_flags, current_SID);\n#endif\n\t/*\n\t * Free string options that are in allocated memory.\n\t * Use \"free_oldval\", because recursiveness may change the flags under\n\t * our fingers (esp. init_highlight()).\n\t */\n\tif (free_oldval)\n\t    free_string_option(oldval);\n\tif (new_value_alloced)\n\t    options[opt_idx].flags |= P_ALLOCED;\n\telse\n\t    options[opt_idx].flags &= ~P_ALLOCED;\n\n\tif ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n\t\t&& ((int)options[opt_idx].indir & PV_BOTH))\n\t{\n\t    /* global option with local value set to use global value; free\n\t     * the local value and make it empty */\n\t    p = get_varp_scope(&(options[opt_idx]), OPT_LOCAL);\n\t    free_string_option(*(char_u **)p);\n\t    *(char_u **)p = empty_option;\n\t}\n\n\t/* May set global value for local option. */\n\telse if (!(opt_flags & OPT_LOCAL) && opt_flags != OPT_GLOBAL)\n\t    set_string_option_global(opt_idx, varp);\n\n#ifdef FEAT_AUTOCMD\n\t/*\n\t * Trigger the autocommand only after setting the flags.\n\t */\n# ifdef FEAT_SYN_HL\n\t/* When 'syntax' is set, load the syntax of that name */\n\tif (varp == &(curbuf->b_p_syn))\n\t{\n\t    apply_autocmds(EVENT_SYNTAX, curbuf->b_p_syn,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf);\n\t}\n# endif\n\telse if (varp == &(curbuf->b_p_ft))\n\t{\n\t    /* 'filetype' is set, trigger the FileType autocommand */\n\t    did_filetype = TRUE;\n\t    apply_autocmds(EVENT_FILETYPE, curbuf->b_p_ft,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf);\n\t}\n#endif\n#ifdef FEAT_SPELL\n\tif (varp == &(curwin->w_s->b_p_spl))\n\t{\n\t    char_u\tfname[200];\n\t    char_u\t*q = curwin->w_s->b_p_spl;\n\n\t    /* Skip the first name if it is \"cjk\". */\n\t    if (STRNCMP(q, \"cjk,\", 4) == 0)\n\t\tq += 4;\n\n\t    /*\n\t     * Source the spell/LANG.vim in 'runtimepath'.\n\t     * They could set 'spellcapcheck' depending on the language.\n\t     * Use the first name in 'spelllang' up to '_region' or\n\t     * '.encoding'.\n\t     */\n\t    for (p = q; *p != NUL; ++p)\n\t\tif (vim_strchr((char_u *)\"_.,\", *p) != NULL)\n\t\t    break;\n\t    vim_snprintf((char *)fname, 200, \"spell/%.*s.vim\", (int)(p - q), q);\n\t    source_runtime(fname, DIP_ALL);\n\t}\n#endif\n    }\n\n#ifdef FEAT_MOUSE\n    if (varp == &p_mouse)\n    {\n# ifdef FEAT_MOUSE_TTY\n\tif (*p_mouse == NUL)\n\t    mch_setmouse(FALSE);    /* switch mouse off */\n\telse\n# endif\n\t    setmouse();\t\t    /* in case 'mouse' changed */\n    }\n#endif\n\n    if (curwin->w_curswant != MAXCOL\n\t\t     && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)\n\tcurwin->w_set_curswant = TRUE;\n\n#ifdef FEAT_GUI\n    /* check redraw when it's not a GUI option or the GUI is active. */\n    if (!redraw_gui_only || gui.in_use)\n#endif\n\tcheck_redraw(options[opt_idx].flags);\n\n    return errmsg;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147086,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "did_set_string_option(\n    int\t\topt_idx,\t\t/* index in options[] table */\n    char_u\t**varp,\t\t\t/* pointer to the option variable */\n    int\t\tnew_value_alloced,\t/* new value was allocated */\n    char_u\t*oldval,\t\t/* previous value of the option */\n    char_u\t*errbuf,\t\t/* buffer for errors, or NULL */\n    int\t\topt_flags)\t\t/* OPT_LOCAL and/or OPT_GLOBAL */\n{\n    char_u\t*errmsg = NULL;\n    char_u\t*s, *p;\n    int\t\tdid_chartab = FALSE;\n    char_u\t**gvarp;\n    long_u\tfree_oldval = (options[opt_idx].flags & P_ALLOCED);\n#ifdef FEAT_GUI\n    /* set when changing an option that only requires a redraw in the GUI */\n    int\t\tredraw_gui_only = FALSE;\n#endif\n\n    /* Get the global option to compare with, otherwise we would have to check\n     * two values for all local options. */\n    gvarp = (char_u **)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL);\n\n    /* Disallow changing some options from secure mode */\n    if ((secure\n#ifdef HAVE_SANDBOX\n\t\t|| sandbox != 0\n#endif\n\t\t) && (options[opt_idx].flags & P_SECURE))\n    {\n\terrmsg = e_secure;\n    }\n\n    /* Check for a \"normal\" file name in some options.  Disallow a path\n     * separator (slash and/or backslash), wildcards and characters that are\n     * often illegal in a file name. */\n    else if ((options[opt_idx].flags & P_NFNAME)\n\t\t\t && vim_strpbrk(*varp, (char_u *)\"/\\\\*?[|<>\") != NULL)\n    {\n\terrmsg = e_invarg;\n    }\n\n    /* 'term' */\n    else if (varp == &T_NAME)\n    {\n\tif (T_NAME[0] == NUL)\n\t    errmsg = (char_u *)N_(\"E529: Cannot set 'term' to empty string\");\n#ifdef FEAT_GUI\n\tif (gui.in_use)\n\t    errmsg = (char_u *)N_(\"E530: Cannot change term in GUI\");\n\telse if (term_is_gui(T_NAME))\n\t    errmsg = (char_u *)N_(\"E531: Use \\\":gui\\\" to start the GUI\");\n#endif\n\telse if (set_termname(T_NAME) == FAIL)\n\t    errmsg = (char_u *)N_(\"E522: Not found in termcap\");\n\telse\n\t    /* Screen colors may have changed. */\n\t    redraw_later_clear();\n    }\n\n    /* 'backupcopy' */\n    else if (gvarp == &p_bkc)\n    {\n\tchar_u\t\t*bkc = p_bkc;\n\tunsigned int\t*flags = &bkc_flags;\n\n\tif (opt_flags & OPT_LOCAL)\n\t{\n\t    bkc = curbuf->b_p_bkc;\n\t    flags = &curbuf->b_bkc_flags;\n\t}\n\n\tif ((opt_flags & OPT_LOCAL) && *bkc == NUL)\n\t    /* make the local value empty: use the global value */\n\t    *flags = 0;\n\telse\n\t{\n\t    if (opt_strings_flags(bkc, p_bkc_values, flags, TRUE) != OK)\n\t\terrmsg = e_invarg;\n\t    if ((((int)*flags & BKC_AUTO) != 0)\n\t\t    + (((int)*flags & BKC_YES) != 0)\n\t\t    + (((int)*flags & BKC_NO) != 0) != 1)\n\t    {\n\t\t/* Must have exactly one of \"auto\", \"yes\"  and \"no\". */\n\t\t(void)opt_strings_flags(oldval, p_bkc_values, flags, TRUE);\n\t\terrmsg = e_invarg;\n\t    }\n\t}\n    }\n\n    /* 'backupext' and 'patchmode' */\n    else if (varp == &p_bex || varp == &p_pm)\n    {\n\tif (STRCMP(*p_bex == '.' ? p_bex + 1 : p_bex,\n\t\t     *p_pm == '.' ? p_pm + 1 : p_pm) == 0)\n\t    errmsg = (char_u *)N_(\"E589: 'backupext' and 'patchmode' are equal\");\n    }\n#ifdef FEAT_LINEBREAK\n    /* 'breakindentopt' */\n    else if (varp == &curwin->w_p_briopt)\n    {\n\tif (briopt_check(curwin) == FAIL)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    /*\n     * 'isident', 'iskeyword', 'isprint or 'isfname' option: refill g_chartab[]\n     * If the new option is invalid, use old value.  'lisp' option: refill\n     * g_chartab[] for '-' char\n     */\n    else if (  varp == &p_isi\n\t    || varp == &(curbuf->b_p_isk)\n\t    || varp == &p_isp\n\t    || varp == &p_isf)\n    {\n\tif (init_chartab() == FAIL)\n\t{\n\t    did_chartab = TRUE;\t    /* need to restore it below */\n\t    errmsg = e_invarg;\t    /* error in value */\n\t}\n    }\n\n    /* 'helpfile' */\n    else if (varp == &p_hf)\n    {\n\t/* May compute new values for $VIM and $VIMRUNTIME */\n\tif (didset_vim)\n\t{\n\t    vim_setenv((char_u *)\"VIM\", (char_u *)\"\");\n\t    didset_vim = FALSE;\n\t}\n\tif (didset_vimruntime)\n\t{\n\t    vim_setenv((char_u *)\"VIMRUNTIME\", (char_u *)\"\");\n\t    didset_vimruntime = FALSE;\n\t}\n    }\n\n#ifdef FEAT_SYN_HL\n    /* 'colorcolumn' */\n    else if (varp == &curwin->w_p_cc)\n\terrmsg = check_colorcolumn(curwin);\n#endif\n\n#ifdef FEAT_MULTI_LANG\n    /* 'helplang' */\n    else if (varp == &p_hlg)\n    {\n\t/* Check for \"\", \"ab\", \"ab,cd\", etc. */\n\tfor (s = p_hlg; *s != NUL; s += 3)\n\t{\n\t    if (s[1] == NUL || ((s[2] != ',' || s[3] == NUL) && s[2] != NUL))\n\t    {\n\t\terrmsg = e_invarg;\n\t\tbreak;\n\t    }\n\t    if (s[2] == NUL)\n\t\tbreak;\n\t}\n    }\n#endif\n\n    /* 'highlight' */\n    else if (varp == &p_hl)\n    {\n\tif (highlight_changed() == FAIL)\n\t    errmsg = e_invarg;\t/* invalid flags */\n    }\n\n    /* 'nrformats' */\n    else if (gvarp == &p_nf)\n    {\n\tif (check_opt_strings(*varp, p_nf_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n#ifdef FEAT_SESSION\n    /* 'sessionoptions' */\n    else if (varp == &p_ssop)\n    {\n\tif (opt_strings_flags(p_ssop, p_ssop_values, &ssop_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n\tif ((ssop_flags & SSOP_CURDIR) && (ssop_flags & SSOP_SESDIR))\n\t{\n\t    /* Don't allow both \"sesdir\" and \"curdir\". */\n\t    (void)opt_strings_flags(oldval, p_ssop_values, &ssop_flags, TRUE);\n\t    errmsg = e_invarg;\n\t}\n    }\n    /* 'viewoptions' */\n    else if (varp == &p_vop)\n    {\n\tif (opt_strings_flags(p_vop, p_ssop_values, &vop_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    /* 'scrollopt' */\n#ifdef FEAT_SCROLLBIND\n    else if (varp == &p_sbo)\n    {\n\tif (check_opt_strings(p_sbo, p_scbopt_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    /* 'ambiwidth' */\n#ifdef FEAT_MBYTE\n    else if (varp == &p_ambw || varp == &p_emoji)\n    {\n\tif (check_opt_strings(p_ambw, p_ambw_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n\telse if (set_chars_option(&p_lcs) != NULL)\n\t    errmsg = (char_u *)_(\"E834: Conflicts with value of 'listchars'\");\n# if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)\n\telse if (set_chars_option(&p_fcs) != NULL)\n\t    errmsg = (char_u *)_(\"E835: Conflicts with value of 'fillchars'\");\n# endif\n    }\n#endif\n\n    /* 'background' */\n    else if (varp == &p_bg)\n    {\n\tif (check_opt_strings(p_bg, p_bg_values, FALSE) == OK)\n\t{\n#ifdef FEAT_EVAL\n\t    int dark = (*p_bg == 'd');\n#endif\n\n\t    init_highlight(FALSE, FALSE);\n\n#ifdef FEAT_EVAL\n\t    if (dark != (*p_bg == 'd')\n\t\t\t  && get_var_value((char_u *)\"g:colors_name\") != NULL)\n\t    {\n\t\t/* The color scheme must have set 'background' back to another\n\t\t * value, that's not what we want here.  Disable the color\n\t\t * scheme and set the colors again. */\n\t\tdo_unlet((char_u *)\"g:colors_name\", TRUE);\n\t\tfree_string_option(p_bg);\n\t\tp_bg = vim_strsave((char_u *)(dark ? \"dark\" : \"light\"));\n\t\tcheck_string_option(&p_bg);\n\t\tinit_highlight(FALSE, FALSE);\n\t    }\n#endif\n\t}\n\telse\n\t    errmsg = e_invarg;\n    }\n\n    /* 'wildmode' */\n    else if (varp == &p_wim)\n    {\n\tif (check_opt_wim() == FAIL)\n\t    errmsg = e_invarg;\n    }\n\n#ifdef FEAT_CMDL_COMPL\n    /* 'wildoptions' */\n    else if (varp == &p_wop)\n    {\n\tif (check_opt_strings(p_wop, p_wop_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_WAK\n    /* 'winaltkeys' */\n    else if (varp == &p_wak)\n    {\n\tif (*p_wak == NUL\n\t\t|| check_opt_strings(p_wak, p_wak_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n# ifdef FEAT_MENU\n#  ifdef FEAT_GUI_MOTIF\n\telse if (gui.in_use)\n\t    gui_motif_set_mnemonics(p_wak[0] == 'y' || p_wak[0] == 'm');\n#  else\n#   ifdef FEAT_GUI_GTK\n\telse if (gui.in_use)\n\t    gui_gtk_set_mnemonics(p_wak[0] == 'y' || p_wak[0] == 'm');\n#   endif\n#  endif\n# endif\n    }\n#endif\n\n#ifdef FEAT_AUTOCMD\n    /* 'eventignore' */\n    else if (varp == &p_ei)\n    {\n\tif (check_ei() == FAIL)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_MBYTE\n    /* 'encoding' and 'fileencoding' */\n    else if (varp == &p_enc || gvarp == &p_fenc || varp == &p_tenc)\n    {\n\tif (gvarp == &p_fenc)\n\t{\n\t    if (!curbuf->b_p_ma && opt_flags != OPT_GLOBAL)\n\t\terrmsg = e_modifiable;\n\t    else if (vim_strchr(*varp, ',') != NULL)\n\t\t/* No comma allowed in 'fileencoding'; catches confusing it\n\t\t * with 'fileencodings'. */\n\t\terrmsg = e_invarg;\n\t    else\n\t    {\n# ifdef FEAT_TITLE\n\t\t/* May show a \"+\" in the title now. */\n\t\tredraw_titles();\n# endif\n\t\t/* Add 'fileencoding' to the swap file. */\n\t\tml_setflags(curbuf);\n\t    }\n\t}\n\tif (errmsg == NULL)\n\t{\n\t    /* canonize the value, so that STRCMP() can be used on it */\n\t    p = enc_canonize(*varp);\n\t    if (p != NULL)\n\t    {\n\t\tvim_free(*varp);\n\t\t*varp = p;\n\t    }\n\t    if (varp == &p_enc)\n\t    {\n\t\terrmsg = mb_init();\n# ifdef FEAT_TITLE\n\t\tredraw_titles();\n# endif\n\t    }\n\t}\n\n# if defined(FEAT_GUI_GTK)\n\tif (errmsg == NULL && varp == &p_tenc && gui.in_use)\n\t{\n\t    /* GTK+ 2 uses only a single encoding, and that is UTF-8. */\n\t    if (STRCMP(p_tenc, \"utf-8\") != 0)\n\t\terrmsg = (char_u *)N_(\"E617: Cannot be changed in the GTK+ 2 GUI\");\n\t}\n# endif\n\n\tif (errmsg == NULL)\n\t{\n# ifdef FEAT_KEYMAP\n\t    /* When 'keymap' is used and 'encoding' changes, reload the keymap\n\t     * (with another encoding). */\n\t    if (varp == &p_enc && *curbuf->b_p_keymap != NUL)\n\t\t(void)keymap_init();\n# endif\n\n\t    /* When 'termencoding' is not empty and 'encoding' changes or when\n\t     * 'termencoding' changes, need to setup for keyboard input and\n\t     * display output conversion. */\n\t    if (((varp == &p_enc && *p_tenc != NUL) || varp == &p_tenc))\n\t    {\n\t\tconvert_setup(&input_conv, p_tenc, p_enc);\n\t\tconvert_setup(&output_conv, p_enc, p_tenc);\n\t    }\n\n# if defined(WIN3264) && defined(FEAT_MBYTE)\n\t    /* $HOME may have characters in active code page. */\n\t    if (varp == &p_enc)\n\t\tinit_homedir();\n# endif\n\t}\n    }\n#endif\n\n#if defined(FEAT_POSTSCRIPT)\n    else if (varp == &p_penc)\n    {\n\t/* Canonize printencoding if VIM standard one */\n\tp = enc_canonize(p_penc);\n\tif (p != NULL)\n\t{\n\t    vim_free(p_penc);\n\t    p_penc = p;\n\t}\n\telse\n\t{\n\t    /* Ensure lower case and '-' for '_' */\n\t    for (s = p_penc; *s != NUL; s++)\n\t    {\n\t\tif (*s == '_')\n\t\t    *s = '-';\n\t\telse\n\t\t    *s = TOLOWER_ASC(*s);\n\t    }\n\t}\n    }\n#endif\n\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    else if (varp == &p_imak)\n    {\n\tif (gui.in_use && !im_xim_isvalid_imactivate())\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_KEYMAP\n    else if (varp == &curbuf->b_p_keymap)\n    {\n\tif (!valid_filetype(*varp))\n\t    errmsg = e_invarg;\n\telse\n\t    /* load or unload key mapping tables */\n\t    errmsg = keymap_init();\n\n\tif (errmsg == NULL)\n\t{\n\t    if (*curbuf->b_p_keymap != NUL)\n\t    {\n\t\t/* Installed a new keymap, switch on using it. */\n\t\tcurbuf->b_p_iminsert = B_IMODE_LMAP;\n\t\tif (curbuf->b_p_imsearch != B_IMODE_USE_INSERT)\n\t\t    curbuf->b_p_imsearch = B_IMODE_LMAP;\n\t    }\n\t    else\n\t    {\n\t\t/* Cleared the keymap, may reset 'iminsert' and 'imsearch'. */\n\t\tif (curbuf->b_p_iminsert == B_IMODE_LMAP)\n\t\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t\tif (curbuf->b_p_imsearch == B_IMODE_LMAP)\n\t\t    curbuf->b_p_imsearch = B_IMODE_USE_INSERT;\n\t    }\n\t    if ((opt_flags & OPT_LOCAL) == 0)\n\t    {\n\t\tset_iminsert_global();\n\t\tset_imsearch_global();\n\t    }\n# ifdef FEAT_WINDOWS\n\t    status_redraw_curbuf();\n# endif\n\t}\n    }\n#endif\n\n    /* 'fileformat' */\n    else if (gvarp == &p_ff)\n    {\n\tif (!curbuf->b_p_ma && !(opt_flags & OPT_GLOBAL))\n\t    errmsg = e_modifiable;\n\telse if (check_opt_strings(*varp, p_ff_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    /* may also change 'textmode' */\n\t    if (get_fileformat(curbuf) == EOL_DOS)\n\t\tcurbuf->b_p_tx = TRUE;\n\t    else\n\t\tcurbuf->b_p_tx = FALSE;\n#ifdef FEAT_TITLE\n\t    redraw_titles();\n#endif\n\t    /* update flag in swap file */\n\t    ml_setflags(curbuf);\n\t    /* Redraw needed when switching to/from \"mac\": a CR in the text\n\t     * will be displayed differently. */\n\t    if (get_fileformat(curbuf) == EOL_MAC || *oldval == 'm')\n\t\tredraw_curbuf_later(NOT_VALID);\n\t}\n    }\n\n    /* 'fileformats' */\n    else if (varp == &p_ffs)\n    {\n\tif (check_opt_strings(p_ffs, p_ff_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    /* also change 'textauto' */\n\t    if (*p_ffs == NUL)\n\t\tp_ta = FALSE;\n\t    else\n\t\tp_ta = TRUE;\n\t}\n    }\n\n#if defined(FEAT_CRYPT)\n    /* 'cryptkey' */\n    else if (gvarp == &p_key)\n    {\n# if defined(FEAT_CMDHIST)\n\t/* Make sure the \":set\" command doesn't show the new value in the\n\t * history. */\n\tremove_key_from_history();\n# endif\n\tif (STRCMP(curbuf->b_p_key, oldval) != 0)\n\t    /* Need to update the swapfile. */\n\t    ml_set_crypt_key(curbuf, oldval,\n\t\t\t      *curbuf->b_p_cm == NUL ? p_cm : curbuf->b_p_cm);\n    }\n\n    else if (gvarp == &p_cm)\n    {\n\tif (opt_flags & OPT_LOCAL)\n\t    p = curbuf->b_p_cm;\n\telse\n\t    p = p_cm;\n\tif (check_opt_strings(p, p_cm_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse if (crypt_self_test() == FAIL)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    /* When setting the global value to empty, make it \"zip\". */\n\t    if (*p_cm == NUL)\n\t    {\n\t\tif (new_value_alloced)\n\t\t    free_string_option(p_cm);\n\t\tp_cm = vim_strsave((char_u *)\"zip\");\n\t\tnew_value_alloced = TRUE;\n\t    }\n\t    /* When using \":set cm=name\" the local value is going to be empty.\n\t     * Do that here, otherwise the crypt functions will still use the\n\t     * local value. */\n\t    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\t    {\n\t\tfree_string_option(curbuf->b_p_cm);\n\t\tcurbuf->b_p_cm = empty_option;\n\t    }\n\n\t    /* Need to update the swapfile when the effective method changed.\n\t     * Set \"s\" to the effective old value, \"p\" to the effective new\n\t     * method and compare. */\n\t    if ((opt_flags & OPT_LOCAL) && *oldval == NUL)\n\t\ts = p_cm;  /* was previously using the global value */\n\t    else\n\t\ts = oldval;\n\t    if (*curbuf->b_p_cm == NUL)\n\t\tp = p_cm;  /* is now using the global value */\n\t    else\n\t\tp = curbuf->b_p_cm;\n\t    if (STRCMP(s, p) != 0)\n\t\tml_set_crypt_key(curbuf, curbuf->b_p_key, s);\n\n\t    /* If the global value changes need to update the swapfile for all\n\t     * buffers using that value. */\n\t    if ((opt_flags & OPT_GLOBAL) && STRCMP(p_cm, oldval) != 0)\n\t    {\n\t\tbuf_T\t*buf;\n\n\t\tFOR_ALL_BUFFERS(buf)\n\t\t    if (buf != curbuf && *buf->b_p_cm == NUL)\n\t\t\tml_set_crypt_key(buf, buf->b_p_key, oldval);\n\t    }\n\t}\n    }\n#endif\n\n    /* 'matchpairs' */\n    else if (gvarp == &p_mps)\n    {\n#ifdef FEAT_MBYTE\n\tif (has_mbyte)\n\t{\n\t    for (p = *varp; *p != NUL; ++p)\n\t    {\n\t\tint x2 = -1;\n\t\tint x3 = -1;\n\n\t\tif (*p != NUL)\n\t\t    p += mb_ptr2len(p);\n\t\tif (*p != NUL)\n\t\t    x2 = *p++;\n\t\tif (*p != NUL)\n\t\t{\n\t\t    x3 = mb_ptr2char(p);\n\t\t    p += mb_ptr2len(p);\n\t\t}\n\t\tif (x2 != ':' || x3 == -1 || (*p != NUL && *p != ','))\n\t\t{\n\t\t    errmsg = e_invarg;\n\t\t    break;\n\t\t}\n\t\tif (*p == NUL)\n\t\t    break;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    /* Check for \"x:y,x:y\" */\n\t    for (p = *varp; *p != NUL; p += 4)\n\t    {\n\t\tif (p[1] != ':' || p[2] == NUL || (p[3] != NUL && p[3] != ','))\n\t\t{\n\t\t    errmsg = e_invarg;\n\t\t    break;\n\t\t}\n\t\tif (p[3] == NUL)\n\t\t    break;\n\t    }\n\t}\n    }\n\n#ifdef FEAT_COMMENTS\n    /* 'comments' */\n    else if (gvarp == &p_com)\n    {\n\tfor (s = *varp; *s; )\n\t{\n\t    while (*s && *s != ':')\n\t    {\n\t\tif (vim_strchr((char_u *)COM_ALL, *s) == NULL\n\t\t\t\t\t     && !VIM_ISDIGIT(*s) && *s != '-')\n\t\t{\n\t\t    errmsg = illegal_char(errbuf, *s);\n\t\t    break;\n\t\t}\n\t\t++s;\n\t    }\n\t    if (*s++ == NUL)\n\t\terrmsg = (char_u *)N_(\"E524: Missing colon\");\n\t    else if (*s == ',' || *s == NUL)\n\t\terrmsg = (char_u *)N_(\"E525: Zero length string\");\n\t    if (errmsg != NULL)\n\t\tbreak;\n\t    while (*s && *s != ',')\n\t    {\n\t\tif (*s == '\\\\' && s[1] != NUL)\n\t\t    ++s;\n\t\t++s;\n\t    }\n\t    s = skip_to_option_part(s);\n\t}\n    }\n#endif\n\n    /* 'listchars' */\n    else if (varp == &p_lcs)\n    {\n\terrmsg = set_chars_option(varp);\n    }\n\n#if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)\n    /* 'fillchars' */\n    else if (varp == &p_fcs)\n    {\n\terrmsg = set_chars_option(varp);\n    }\n#endif\n\n#ifdef FEAT_CMDWIN\n    /* 'cedit' */\n    else if (varp == &p_cedit)\n    {\n\terrmsg = check_cedit();\n    }\n#endif\n\n    /* 'verbosefile' */\n    else if (varp == &p_vfile)\n    {\n\tverbose_stop();\n\tif (*p_vfile != NUL && verbose_open() == FAIL)\n\t    errmsg = e_invarg;\n    }\n\n#ifdef FEAT_VIMINFO\n    /* 'viminfo' */\n    else if (varp == &p_viminfo)\n    {\n\tfor (s = p_viminfo; *s;)\n\t{\n\t    /* Check it's a valid character */\n\t    if (vim_strchr((char_u *)\"!\\\"%'/:<@cfhnrs\", *s) == NULL)\n\t    {\n\t\terrmsg = illegal_char(errbuf, *s);\n\t\tbreak;\n\t    }\n\t    if (*s == 'n')\t/* name is always last one */\n\t    {\n\t\tbreak;\n\t    }\n\t    else if (*s == 'r') /* skip until next ',' */\n\t    {\n\t\twhile (*++s && *s != ',')\n\t\t    ;\n\t    }\n\t    else if (*s == '%')\n\t    {\n\t\t/* optional number */\n\t\twhile (vim_isdigit(*++s))\n\t\t    ;\n\t    }\n\t    else if (*s == '!' || *s == 'h' || *s == 'c')\n\t\t++s;\t\t/* no extra chars */\n\t    else\t\t/* must have a number */\n\t    {\n\t\twhile (vim_isdigit(*++s))\n\t\t    ;\n\n\t\tif (!VIM_ISDIGIT(*(s - 1)))\n\t\t{\n\t\t    if (errbuf != NULL)\n\t\t    {\n\t\t\tsprintf((char *)errbuf,\n\t\t\t\t\t _(\"E526: Missing number after <%s>\"),\n\t\t\t\t\t\t    transchar_byte(*(s - 1)));\n\t\t\terrmsg = errbuf;\n\t\t    }\n\t\t    else\n\t\t\terrmsg = (char_u *)\"\";\n\t\t    break;\n\t\t}\n\t    }\n\t    if (*s == ',')\n\t\t++s;\n\t    else if (*s)\n\t    {\n\t\tif (errbuf != NULL)\n\t\t    errmsg = (char_u *)N_(\"E527: Missing comma\");\n\t\telse\n\t\t    errmsg = (char_u *)\"\";\n\t\tbreak;\n\t    }\n\t}\n\tif (*p_viminfo && errmsg == NULL && get_viminfo_parameter('\\'') < 0)\n\t    errmsg = (char_u *)N_(\"E528: Must specify a ' value\");\n    }\n#endif /* FEAT_VIMINFO */\n\n    /* terminal options */\n    else if (istermoption(&options[opt_idx]) && full_screen)\n    {\n\t/* \":set t_Co=0\" and \":set t_Co=1\" do \":set t_Co=\" */\n\tif (varp == &T_CCO)\n\t{\n\t    int colors = atoi((char *)T_CCO);\n\n\t    /* Only reinitialize colors if t_Co value has really changed to\n\t     * avoid expensive reload of colorscheme if t_Co is set to the\n\t     * same value multiple times. */\n\t    if (colors != t_colors)\n\t    {\n\t\tt_colors = colors;\n\t\tif (t_colors <= 1)\n\t\t{\n\t\t    if (new_value_alloced)\n\t\t\tvim_free(T_CCO);\n\t\t    T_CCO = empty_option;\n\t\t}\n\t\t/* We now have a different color setup, initialize it again. */\n\t\tinit_highlight(TRUE, FALSE);\n\t    }\n\t}\n\tttest(FALSE);\n\tif (varp == &T_ME)\n\t{\n\t    out_str(T_ME);\n\t    redraw_later(CLEAR);\n#if defined(WIN3264) && !defined(FEAT_GUI_W32)\n\t    /* Since t_me has been set, this probably means that the user\n\t     * wants to use this as default colors.  Need to reset default\n\t     * background/foreground colors. */\n\t    mch_set_normal_colors();\n#endif\n\t}\n    }\n\n#ifdef FEAT_LINEBREAK\n    /* 'showbreak' */\n    else if (varp == &p_sbr)\n    {\n\tfor (s = p_sbr; *s; )\n\t{\n\t    if (ptr2cells(s) != 1)\n\t\terrmsg = (char_u *)N_(\"E595: contains unprintable or wide character\");\n\t    mb_ptr_adv(s);\n\t}\n    }\n#endif\n\n#ifdef FEAT_GUI\n    /* 'guifont' */\n    else if (varp == &p_guifont)\n    {\n\tif (gui.in_use)\n\t{\n\t    p = p_guifont;\n# if defined(FEAT_GUI_GTK)\n\t    /*\n\t     * Put up a font dialog and let the user select a new value.\n\t     * If this is cancelled go back to the old value but don't\n\t     * give an error message.\n\t     */\n\t    if (STRCMP(p, \"*\") == 0)\n\t    {\n\t\tp = gui_mch_font_dialog(oldval);\n\n\t\tif (new_value_alloced)\n\t\t    free_string_option(p_guifont);\n\n\t\tp_guifont = (p != NULL) ? p : vim_strsave(oldval);\n\t\tnew_value_alloced = TRUE;\n\t    }\n# endif\n\t    if (p != NULL && gui_init_font(p_guifont, FALSE) != OK)\n\t    {\n# if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_PHOTON)\n\t\tif (STRCMP(p_guifont, \"*\") == 0)\n\t\t{\n\t\t    /* Dialog was cancelled: Keep the old value without giving\n\t\t     * an error message. */\n\t\t    if (new_value_alloced)\n\t\t\tfree_string_option(p_guifont);\n\t\t    p_guifont = vim_strsave(oldval);\n\t\t    new_value_alloced = TRUE;\n\t\t}\n\t\telse\n# endif\n\t\t    errmsg = (char_u *)N_(\"E596: Invalid font(s)\");\n\t    }\n\t}\n\tredraw_gui_only = TRUE;\n    }\n# ifdef FEAT_XFONTSET\n    else if (varp == &p_guifontset)\n    {\n\tif (STRCMP(p_guifontset, \"*\") == 0)\n\t    errmsg = (char_u *)N_(\"E597: can't select fontset\");\n\telse if (gui.in_use && gui_init_font(p_guifontset, TRUE) != OK)\n\t    errmsg = (char_u *)N_(\"E598: Invalid fontset\");\n\tredraw_gui_only = TRUE;\n    }\n# endif\n# ifdef FEAT_MBYTE\n    else if (varp == &p_guifontwide)\n    {\n\tif (STRCMP(p_guifontwide, \"*\") == 0)\n\t    errmsg = (char_u *)N_(\"E533: can't select wide font\");\n\telse if (gui_get_wide_font() == FAIL)\n\t    errmsg = (char_u *)N_(\"E534: Invalid wide font\");\n\tredraw_gui_only = TRUE;\n    }\n# endif\n#endif\n\n#ifdef CURSOR_SHAPE\n    /* 'guicursor' */\n    else if (varp == &p_guicursor)\n\terrmsg = parse_shape_opt(SHAPE_CURSOR);\n#endif\n\n#ifdef FEAT_MOUSESHAPE\n    /* 'mouseshape' */\n    else if (varp == &p_mouseshape)\n    {\n\terrmsg = parse_shape_opt(SHAPE_MOUSE);\n\tupdate_mouseshape(-1);\n    }\n#endif\n\n#ifdef FEAT_PRINTER\n    else if (varp == &p_popt)\n\terrmsg = parse_printoptions();\n# if defined(FEAT_MBYTE) && defined(FEAT_POSTSCRIPT)\n    else if (varp == &p_pmfn)\n\terrmsg = parse_printmbfont();\n# endif\n#endif\n\n#ifdef FEAT_LANGMAP\n    /* 'langmap' */\n    else if (varp == &p_langmap)\n\tlangmap_set();\n#endif\n\n#ifdef FEAT_LINEBREAK\n    /* 'breakat' */\n    else if (varp == &p_breakat)\n\tfill_breakat_flags();\n#endif\n\n#ifdef FEAT_TITLE\n    /* 'titlestring' and 'iconstring' */\n    else if (varp == &p_titlestring || varp == &p_iconstring)\n    {\n# ifdef FEAT_STL_OPT\n\tint\tflagval = (varp == &p_titlestring) ? STL_IN_TITLE : STL_IN_ICON;\n\n\t/* NULL => statusline syntax */\n\tif (vim_strchr(*varp, '%') && check_stl_option(*varp) == NULL)\n\t    stl_syntax |= flagval;\n\telse\n\t    stl_syntax &= ~flagval;\n# endif\n\tdid_set_title(varp == &p_iconstring);\n\n    }\n#endif\n\n#ifdef FEAT_GUI\n    /* 'guioptions' */\n    else if (varp == &p_go)\n    {\n\tgui_init_which_components(oldval);\n\tredraw_gui_only = TRUE;\n    }\n#endif\n\n#if defined(FEAT_GUI_TABLINE)\n    /* 'guitablabel' */\n    else if (varp == &p_gtl)\n    {\n\tredraw_tabline = TRUE;\n\tredraw_gui_only = TRUE;\n    }\n    /* 'guitabtooltip' */\n    else if (varp == &p_gtt)\n    {\n\tredraw_gui_only = TRUE;\n    }\n#endif\n\n#if defined(FEAT_MOUSE_TTY) && (defined(UNIX) || defined(VMS))\n    /* 'ttymouse' */\n    else if (varp == &p_ttym)\n    {\n\t/* Switch the mouse off before changing the escape sequences used for\n\t * that. */\n\tmch_setmouse(FALSE);\n\tif (opt_strings_flags(p_ttym, p_ttym_values, &ttym_flags, FALSE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t    check_mouse_termcode();\n\tif (termcap_active)\n\t    setmouse();\t\t/* may switch it on again */\n    }\n#endif\n\n    /* 'selection' */\n    else if (varp == &p_sel)\n    {\n\tif (*p_sel == NUL\n\t\t|| check_opt_strings(p_sel, p_sel_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    /* 'selectmode' */\n    else if (varp == &p_slm)\n    {\n\tif (check_opt_strings(p_slm, p_slm_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n#ifdef FEAT_BROWSE\n    /* 'browsedir' */\n    else if (varp == &p_bsdir)\n    {\n\tif (check_opt_strings(p_bsdir, p_bsdir_values, FALSE) != OK\n\t\t&& !mch_isdir(p_bsdir))\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    /* 'keymodel' */\n    else if (varp == &p_km)\n    {\n\tif (check_opt_strings(p_km, p_km_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    km_stopsel = (vim_strchr(p_km, 'o') != NULL);\n\t    km_startsel = (vim_strchr(p_km, 'a') != NULL);\n\t}\n    }\n\n    /* 'mousemodel' */\n    else if (varp == &p_mousem)\n    {\n\tif (check_opt_strings(p_mousem, p_mousem_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n#if defined(FEAT_GUI_MOTIF) && defined(FEAT_MENU) && (XmVersion <= 1002)\n\telse if (*p_mousem != *oldval)\n\t    /* Changed from \"extend\" to \"popup\" or \"popup_setpos\" or vv: need\n\t     * to create or delete the popup menus. */\n\t    gui_motif_update_mousemodel(root_menu);\n#endif\n    }\n\n    /* 'switchbuf' */\n    else if (varp == &p_swb)\n    {\n\tif (opt_strings_flags(p_swb, p_swb_values, &swb_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    /* 'debug' */\n    else if (varp == &p_debug)\n    {\n\tif (check_opt_strings(p_debug, p_debug_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    /* 'display' */\n    else if (varp == &p_dy)\n    {\n\tif (opt_strings_flags(p_dy, p_dy_values, &dy_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t    (void)init_chartab();\n\n    }\n\n#ifdef FEAT_WINDOWS\n    /* 'eadirection' */\n    else if (varp == &p_ead)\n    {\n\tif (check_opt_strings(p_ead, p_ead_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_CLIPBOARD\n    /* 'clipboard' */\n    else if (varp == &p_cb)\n\terrmsg = check_clipboard_option();\n#endif\n\n#ifdef FEAT_SPELL\n    /* When 'spelllang' or 'spellfile' is set and there is a window for this\n     * buffer in which 'spell' is set load the wordlists. */\n    else if (varp == &(curwin->w_s->b_p_spl)\n\t    || varp == &(curwin->w_s->b_p_spf))\n    {\n\terrmsg = did_set_spell_option(varp == &(curwin->w_s->b_p_spf));\n    }\n    /* When 'spellcapcheck' is set compile the regexp program. */\n    else if (varp == &(curwin->w_s->b_p_spc))\n    {\n\terrmsg = compile_cap_prog(curwin->w_s);\n    }\n    /* 'spellsuggest' */\n    else if (varp == &p_sps)\n    {\n\tif (spell_check_sps() != OK)\n\t    errmsg = e_invarg;\n    }\n    /* 'mkspellmem' */\n    else if (varp == &p_msm)\n    {\n\tif (spell_check_msm() != OK)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_QUICKFIX\n    /* When 'bufhidden' is set, check for valid value. */\n    else if (gvarp == &p_bh)\n    {\n\tif (check_opt_strings(curbuf->b_p_bh, p_bufhidden_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    /* When 'buftype' is set, check for valid value. */\n    else if (gvarp == &p_bt)\n    {\n\tif (check_opt_strings(curbuf->b_p_bt, p_buftype_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n# ifdef FEAT_WINDOWS\n\t    if (curwin->w_status_height)\n\t    {\n\t\tcurwin->w_redr_status = TRUE;\n\t\tredraw_later(VALID);\n\t    }\n# endif\n\t    curbuf->b_help = (curbuf->b_p_bt[0] == 'h');\n# ifdef FEAT_TITLE\n\t    redraw_titles();\n# endif\n\t}\n    }\n#endif\n\n#ifdef FEAT_STL_OPT\n    /* 'statusline' or 'rulerformat' */\n    else if (gvarp == &p_stl || varp == &p_ruf)\n    {\n\tint wid;\n\n\tif (varp == &p_ruf)\t/* reset ru_wid first */\n\t    ru_wid = 0;\n\ts = *varp;\n\tif (varp == &p_ruf && *s == '%')\n\t{\n\t    /* set ru_wid if 'ruf' starts with \"%99(\" */\n\t    if (*++s == '-')\t/* ignore a '-' */\n\t\ts++;\n\t    wid = getdigits(&s);\n\t    if (wid && *s == '(' && (errmsg = check_stl_option(p_ruf)) == NULL)\n\t\tru_wid = wid;\n\t    else\n\t\terrmsg = check_stl_option(p_ruf);\n\t}\n\t/* check 'statusline' only if it doesn't start with \"%!\" */\n\telse if (varp == &p_ruf || s[0] != '%' || s[1] != '!')\n\t    errmsg = check_stl_option(s);\n\tif (varp == &p_ruf && errmsg == NULL)\n\t    comp_col();\n    }\n#endif\n\n#ifdef FEAT_INS_EXPAND\n    /* check if it is a valid value for 'complete' -- Acevedo */\n    else if (gvarp == &p_cpt)\n    {\n\tfor (s = *varp; *s;)\n\t{\n\t    while (*s == ',' || *s == ' ')\n\t\ts++;\n\t    if (!*s)\n\t\tbreak;\n\t    if (vim_strchr((char_u *)\".wbuksid]tU\", *s) == NULL)\n\t    {\n\t\terrmsg = illegal_char(errbuf, *s);\n\t\tbreak;\n\t    }\n\t    if (*++s != NUL && *s != ',' && *s != ' ')\n\t    {\n\t\tif (s[-1] == 'k' || s[-1] == 's')\n\t\t{\n\t\t    /* skip optional filename after 'k' and 's' */\n\t\t    while (*s && *s != ',' && *s != ' ')\n\t\t    {\n\t\t\tif (*s == '\\\\')\n\t\t\t    ++s;\n\t\t\t++s;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (errbuf != NULL)\n\t\t    {\n\t\t\tsprintf((char *)errbuf,\n\t\t\t\t     _(\"E535: Illegal character after <%c>\"),\n\t\t\t\t     *--s);\n\t\t\terrmsg = errbuf;\n\t\t    }\n\t\t    else\n\t\t\terrmsg = (char_u *)\"\";\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n\n    /* 'completeopt' */\n    else if (varp == &p_cot)\n    {\n\tif (check_opt_strings(p_cot, p_cot_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t    completeopt_was_set();\n    }\n#endif /* FEAT_INS_EXPAND */\n\n#ifdef FEAT_SIGNS\n    /* 'signcolumn' */\n    else if (varp == &curwin->w_p_scl)\n    {\n\tif (check_opt_strings(*varp, p_scl_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n\n#if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_W32)\n    else if (varp == &p_toolbar)\n    {\n\tif (opt_strings_flags(p_toolbar, p_toolbar_values,\n\t\t\t      &toolbar_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    out_flush();\n\t    gui_mch_show_toolbar((toolbar_flags &\n\t\t\t\t  (TOOLBAR_TEXT | TOOLBAR_ICONS)) != 0);\n\t}\n    }\n#endif\n\n#if defined(FEAT_TOOLBAR) && defined(FEAT_GUI_GTK)\n    /* 'toolbariconsize': GTK+ 2 only */\n    else if (varp == &p_tbis)\n    {\n\tif (opt_strings_flags(p_tbis, p_tbis_values, &tbis_flags, FALSE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    out_flush();\n\t    gui_mch_show_toolbar((toolbar_flags &\n\t\t\t\t  (TOOLBAR_TEXT | TOOLBAR_ICONS)) != 0);\n\t}\n    }\n#endif\n\n    /* 'pastetoggle': translate key codes like in a mapping */\n    else if (varp == &p_pt)\n    {\n\tif (*p_pt)\n\t{\n\t    (void)replace_termcodes(p_pt, &p, TRUE, TRUE, FALSE);\n\t    if (p != NULL)\n\t    {\n\t\tif (new_value_alloced)\n\t\t    free_string_option(p_pt);\n\t\tp_pt = p;\n\t\tnew_value_alloced = TRUE;\n\t    }\n\t}\n    }\n\n    /* 'backspace' */\n    else if (varp == &p_bs)\n    {\n\tif (VIM_ISDIGIT(*p_bs))\n\t{\n\t    if (*p_bs > '2' || p_bs[1] != NUL)\n\t\terrmsg = e_invarg;\n\t}\n\telse if (check_opt_strings(p_bs, p_bs_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n    else if (varp == &p_bo)\n    {\n\tif (opt_strings_flags(p_bo, p_bo_values, &bo_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    /* 'tagcase' */\n    else if (gvarp == &p_tc)\n    {\n\tunsigned int\t*flags;\n\n\tif (opt_flags & OPT_LOCAL)\n\t{\n\t    p = curbuf->b_p_tc;\n\t    flags = &curbuf->b_tc_flags;\n\t}\n\telse\n\t{\n\t    p = p_tc;\n\t    flags = &tc_flags;\n\t}\n\n\tif ((opt_flags & OPT_LOCAL) && *p == NUL)\n\t    /* make the local value empty: use the global value */\n\t    *flags = 0;\n\telse if (*p == NUL\n\t\t|| opt_strings_flags(p, p_tc_values, flags, FALSE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n#ifdef FEAT_MBYTE\n    /* 'casemap' */\n    else if (varp == &p_cmp)\n    {\n\tif (opt_strings_flags(p_cmp, p_cmp_values, &cmp_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_DIFF\n    /* 'diffopt' */\n    else if (varp == &p_dip)\n    {\n\tif (diffopt_changed() == FAIL)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_FOLDING\n    /* 'foldmethod' */\n    else if (gvarp == &curwin->w_allbuf_opt.wo_fdm)\n    {\n\tif (check_opt_strings(*varp, p_fdm_values, FALSE) != OK\n\t\t|| *curwin->w_p_fdm == NUL)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    foldUpdateAll(curwin);\n\t    if (foldmethodIsDiff(curwin))\n\t\tnewFoldLevel();\n\t}\n    }\n# ifdef FEAT_EVAL\n    /* 'foldexpr' */\n    else if (varp == &curwin->w_p_fde)\n    {\n\tif (foldmethodIsExpr(curwin))\n\t    foldUpdateAll(curwin);\n    }\n# endif\n    /* 'foldmarker' */\n    else if (gvarp == &curwin->w_allbuf_opt.wo_fmr)\n    {\n\tp = vim_strchr(*varp, ',');\n\tif (p == NULL)\n\t    errmsg = (char_u *)N_(\"E536: comma required\");\n\telse if (p == *varp || p[1] == NUL)\n\t    errmsg = e_invarg;\n\telse if (foldmethodIsMarker(curwin))\n\t    foldUpdateAll(curwin);\n    }\n    /* 'commentstring' */\n    else if (gvarp == &p_cms)\n    {\n\tif (**varp != NUL && strstr((char *)*varp, \"%s\") == NULL)\n\t    errmsg = (char_u *)N_(\"E537: 'commentstring' must be empty or contain %s\");\n    }\n    /* 'foldopen' */\n    else if (varp == &p_fdo)\n    {\n\tif (opt_strings_flags(p_fdo, p_fdo_values, &fdo_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n    /* 'foldclose' */\n    else if (varp == &p_fcl)\n    {\n\tif (check_opt_strings(p_fcl, p_fcl_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n    /* 'foldignore' */\n    else if (gvarp == &curwin->w_allbuf_opt.wo_fdi)\n    {\n\tif (foldmethodIsIndent(curwin))\n\t    foldUpdateAll(curwin);\n    }\n#endif\n\n#ifdef FEAT_VIRTUALEDIT\n    /* 'virtualedit' */\n    else if (varp == &p_ve)\n    {\n\tif (opt_strings_flags(p_ve, p_ve_values, &ve_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse if (STRCMP(p_ve, oldval) != 0)\n\t{\n\t    /* Recompute cursor position in case the new 've' setting\n\t     * changes something. */\n\t    validate_virtcol();\n\t    coladvance(curwin->w_virtcol);\n\t}\n    }\n#endif\n\n#if defined(FEAT_CSCOPE) && defined(FEAT_QUICKFIX)\n    else if (varp == &p_csqf)\n    {\n\tif (p_csqf != NULL)\n\t{\n\t    p = p_csqf;\n\t    while (*p != NUL)\n\t    {\n\t\tif (vim_strchr((char_u *)CSQF_CMDS, *p) == NULL\n\t\t\t|| p[1] == NUL\n\t\t\t|| vim_strchr((char_u *)CSQF_FLAGS, p[1]) == NULL\n\t\t\t|| (p[2] != NUL && p[2] != ','))\n\t\t{\n\t\t    errmsg = e_invarg;\n\t\t    break;\n\t\t}\n\t\telse if (p[2] == NUL)\n\t\t    break;\n\t\telse\n\t\t    p += 3;\n\t    }\n\t}\n    }\n#endif\n\n#ifdef FEAT_CINDENT\n    /* 'cinoptions' */\n    else if (gvarp == &p_cino)\n    {\n\t/* TODO: recognize errors */\n\tparse_cino(curbuf);\n    }\n#endif\n\n#if defined(FEAT_RENDER_OPTIONS)\n    else if (varp == &p_rop && gui.in_use)\n    {\n\tif (!gui_mch_set_rendering_options(p_rop))\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_AUTOCMD\n    else if (gvarp == &p_ft)\n    {\n\tif (!valid_filetype(*varp))\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_SYN_HL\n    else if (gvarp == &p_syn)\n    {\n\tif (!valid_filetype(*varp))\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    /* Options that are a list of flags. */\n    else\n    {\n\tp = NULL;\n\tif (varp == &p_ww)\n\t    p = (char_u *)WW_ALL;\n\tif (varp == &p_shm)\n\t    p = (char_u *)SHM_ALL;\n\telse if (varp == &(p_cpo))\n\t    p = (char_u *)CPO_ALL;\n\telse if (varp == &(curbuf->b_p_fo))\n\t    p = (char_u *)FO_ALL;\n#ifdef FEAT_CONCEAL\n\telse if (varp == &curwin->w_p_cocu)\n\t    p = (char_u *)COCU_ALL;\n#endif\n\telse if (varp == &p_mouse)\n\t{\n#ifdef FEAT_MOUSE\n\t    p = (char_u *)MOUSE_ALL;\n#else\n\t    if (*p_mouse != NUL)\n\t\terrmsg = (char_u *)N_(\"E538: No mouse support\");\n#endif\n\t}\n#if defined(FEAT_GUI)\n\telse if (varp == &p_go)\n\t    p = (char_u *)GO_ALL;\n#endif\n\tif (p != NULL)\n\t{\n\t    for (s = *varp; *s; ++s)\n\t\tif (vim_strchr(p, *s) == NULL)\n\t\t{\n\t\t    errmsg = illegal_char(errbuf, *s);\n\t\t    break;\n\t\t}\n\t}\n    }\n\n    /*\n     * If error detected, restore the previous value.\n     */\n    if (errmsg != NULL)\n    {\n\tif (new_value_alloced)\n\t    free_string_option(*varp);\n\t*varp = oldval;\n\t/*\n\t * When resetting some values, need to act on it.\n\t */\n\tif (did_chartab)\n\t    (void)init_chartab();\n\tif (varp == &p_hl)\n\t    (void)highlight_changed();\n    }\n    else\n    {\n#ifdef FEAT_EVAL\n\t/* Remember where the option was set. */\n\tset_option_scriptID_idx(opt_idx, opt_flags, current_SID);\n#endif\n\t/*\n\t * Free string options that are in allocated memory.\n\t * Use \"free_oldval\", because recursiveness may change the flags under\n\t * our fingers (esp. init_highlight()).\n\t */\n\tif (free_oldval)\n\t    free_string_option(oldval);\n\tif (new_value_alloced)\n\t    options[opt_idx].flags |= P_ALLOCED;\n\telse\n\t    options[opt_idx].flags &= ~P_ALLOCED;\n\n\tif ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n\t\t&& ((int)options[opt_idx].indir & PV_BOTH))\n\t{\n\t    /* global option with local value set to use global value; free\n\t     * the local value and make it empty */\n\t    p = get_varp_scope(&(options[opt_idx]), OPT_LOCAL);\n\t    free_string_option(*(char_u **)p);\n\t    *(char_u **)p = empty_option;\n\t}\n\n\t/* May set global value for local option. */\n\telse if (!(opt_flags & OPT_LOCAL) && opt_flags != OPT_GLOBAL)\n\t    set_string_option_global(opt_idx, varp);\n\n#ifdef FEAT_AUTOCMD\n\t/*\n\t * Trigger the autocommand only after setting the flags.\n\t */\n# ifdef FEAT_SYN_HL\n\t/* When 'syntax' is set, load the syntax of that name */\n\tif (varp == &(curbuf->b_p_syn))\n\t{\n\t    apply_autocmds(EVENT_SYNTAX, curbuf->b_p_syn,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf);\n\t}\n# endif\n\telse if (varp == &(curbuf->b_p_ft))\n\t{\n\t    /* 'filetype' is set, trigger the FileType autocommand */\n\t    did_filetype = TRUE;\n\t    apply_autocmds(EVENT_FILETYPE, curbuf->b_p_ft,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf);\n\t}\n#endif\n#ifdef FEAT_SPELL\n\tif (varp == &(curwin->w_s->b_p_spl))\n\t{\n\t    char_u\tfname[200];\n\t    char_u\t*q = curwin->w_s->b_p_spl;\n\n\t    /* Skip the first name if it is \"cjk\". */\n\t    if (STRNCMP(q, \"cjk,\", 4) == 0)\n\t\tq += 4;\n\n\t    /*\n\t     * Source the spell/LANG.vim in 'runtimepath'.\n\t     * They could set 'spellcapcheck' depending on the language.\n\t     * Use the first name in 'spelllang' up to '_region' or\n\t     * '.encoding'.\n\t     */\n\t    for (p = q; *p != NUL; ++p)\n\t\tif (vim_strchr((char_u *)\"_.,\", *p) != NULL)\n\t\t    break;\n\t    vim_snprintf((char *)fname, 200, \"spell/%.*s.vim\", (int)(p - q), q);\n\t    source_runtime(fname, DIP_ALL);\n\t}\n#endif\n    }\n\n#ifdef FEAT_MOUSE\n    if (varp == &p_mouse)\n    {\n# ifdef FEAT_MOUSE_TTY\n\tif (*p_mouse == NUL)\n\t    mch_setmouse(FALSE);    /* switch mouse off */\n\telse\n# endif\n\t    setmouse();\t\t    /* in case 'mouse' changed */\n    }\n#endif\n\n    if (curwin->w_curswant != MAXCOL\n\t\t     && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)\n\tcurwin->w_set_curswant = TRUE;\n\n#ifdef FEAT_GUI\n    /* check redraw when it's not a GUI option or the GUI is active. */\n    if (!redraw_gui_only || gui.in_use)\n#endif\n\tcheck_redraw(options[opt_idx].flags);\n\n    return errmsg;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147087,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "_gnutls_ciphertext2compressed (gnutls_session_t session,\n                               opaque * compress_data,\n                               int compress_size,\n                               gnutls_datum_t ciphertext, uint8_t type,\n                               record_parameters_st * params)\n{\n  uint8_t MAC[MAX_HASH_SIZE];\n  uint16_t c_length;\n  unsigned int pad = 0;\n  int length;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  opaque preamble[PREAMBLE_SIZE];\n  int preamble_size = 0;\n  int ver = gnutls_protocol_get_version (session);\n  int hash_size = _gnutls_hash_get_algo_len (params->mac_algorithm);\n\n  blocksize = gnutls_cipher_get_block_size (params->cipher_algorithm);\n\n\n  /* actual decryption (inplace)\n   */\n  switch (_gnutls_cipher_is_block (params->cipher_algorithm))\n    {\n    case CIPHER_STREAM:\n      if ((ret =\n           _gnutls_cipher_decrypt (&params->read.cipher_state,\n                                   ciphertext.data, ciphertext.size)) < 0)\n        {\n          gnutls_assert ();\n          return ret;\n        }\n\n      length = ciphertext.size - hash_size;\n\n      break;\n    case CIPHER_BLOCK:\n      if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))\n        {\n          gnutls_assert ();\n          return GNUTLS_E_DECRYPTION_FAILED;\n        }\n\n      if ((ret =\n           _gnutls_cipher_decrypt (&params->read.cipher_state,\n                                   ciphertext.data, ciphertext.size)) < 0)\n        {\n          gnutls_assert ();\n          return ret;\n        }\n\n      /* ignore the IV in TLS 1.1.\n       */\n      if (_gnutls_version_has_explicit_iv\n          (session->security_parameters.version))\n        {\n          ciphertext.size -= blocksize;\n          ciphertext.data += blocksize;\n        }\n\n      if (ciphertext.size < hash_size)\n        {\n          gnutls_assert ();\n          return GNUTLS_E_DECRYPTION_FAILED;\n        }\n      pad = ciphertext.data[ciphertext.size - 1];   /* pad */\n\n      /* Check the pading bytes (TLS 1.x). \n       * Note that we access all 256 bytes of ciphertext for padding check\n       * because there is a timing channel in that memory access (in certain CPUs).\n       */\n      if (_gnutls_version_has_variable_padding (ver) && pad_failed == 0)\n        for (i = 2; i <= pad; i++)\n          {\n            if (ciphertext.data[ciphertext.size - i] != pad)\n              pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n          }\n          \n      if (pad_failed)\n        pad = 0;\n      length = ciphertext.size - hash_size - pad - 1;\n\n      break;\n    default:\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (length < 0)\n    length = 0;\n  c_length = _gnutls_conv_uint16 ((uint16_t) length);\n\n  /* Pass the type, version, length and compressed through\n   * MAC.\n   */\n  if (params->mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      digest_hd_st td;\n\n      ret = mac_init (&td, params->mac_algorithm,\n                      params->read.mac_secret.data,\n                      params->read.mac_secret.size, ver);\n\n      if (ret < 0)\n        {\n          gnutls_assert ();\n          return GNUTLS_E_INTERNAL_ERROR;\n        }\n\n      preamble_size =\n        make_preamble (UINT64DATA\n                       (params->read.sequence_number), type,\n                       c_length, ver, preamble);\n      mac_hash (&td, preamble, preamble_size, ver);\n      if (length > 0)\n        mac_hash (&td, ciphertext.data, length, ver);\n\n      mac_deinit (&td, MAC, ver);\n    }\n\n  /* HMAC was not the same. \n   */\n  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0 || pad_failed != 0)\n    {\n      gnutls_datum_t compressed = {compress_data, compress_size};\n      /* HMAC was not the same. */\n      dummy_wait(params, &compressed, pad_failed, pad, length+preamble_size, ver);\n\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* copy the decrypted stuff to compressed_data.\n   */\n  if (compress_size < length)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECOMPRESSION_FAILED;\n    }\n  memcpy (compress_data, ciphertext.data, length);\n\n  return length;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147116,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "_gnutls_ciphertext2compressed (gnutls_session_t session,\n                               opaque * compress_data,\n                               int compress_size,\n                               gnutls_datum_t ciphertext, uint8_t type,\n                               record_parameters_st * params)\n{\n  uint8_t MAC[MAX_HASH_SIZE];\n  uint16_t c_length;\n  unsigned int pad = 0;\n  int length;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  opaque preamble[PREAMBLE_SIZE];\n  int preamble_size = 0;\n  int ver = gnutls_protocol_get_version (session);\n  int hash_size = _gnutls_hash_get_algo_len (params->mac_algorithm);\n\n  blocksize = gnutls_cipher_get_block_size (params->cipher_algorithm);\n\n\n  /* actual decryption (inplace)\n   */\n  switch (_gnutls_cipher_is_block (params->cipher_algorithm))\n    {\n    case CIPHER_STREAM:\n      if ((ret =\n           _gnutls_cipher_decrypt (&params->read.cipher_state,\n                                   ciphertext.data, ciphertext.size)) < 0)\n        {\n          gnutls_assert ();\n          return ret;\n        }\n\n      length = ciphertext.size - hash_size;\n\n      break;\n    case CIPHER_BLOCK:\n      if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))\n        {\n          gnutls_assert ();\n          return GNUTLS_E_DECRYPTION_FAILED;\n        }\n\n      if ((ret =\n           _gnutls_cipher_decrypt (&params->read.cipher_state,\n                                   ciphertext.data, ciphertext.size)) < 0)\n        {\n          gnutls_assert ();\n          return ret;\n        }\n\n      /* ignore the IV in TLS 1.1.\n       */\n      if (_gnutls_version_has_explicit_iv\n          (session->security_parameters.version))\n        {\n          ciphertext.size -= blocksize;\n          ciphertext.data += blocksize;\n        }\n\n      if (ciphertext.size < hash_size)\n        {\n          gnutls_assert ();\n          return GNUTLS_E_DECRYPTION_FAILED;\n        }\n      pad = ciphertext.data[ciphertext.size - 1];   /* pad */\n      if (pad+1 > ciphertext.size-hash_size)\n        pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\n      /* Check the pading bytes (TLS 1.x). \n       * Note that we access all 256 bytes of ciphertext for padding check\n       * because there is a timing channel in that memory access (in certain CPUs).\n       */\n      if (_gnutls_version_has_variable_padding (ver) && pad_failed == 0)\n        for (i = 2; i <= pad; i++)\n          {\n            if (ciphertext.data[ciphertext.size - i] != pad)\n              pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n          }\n          \n      if (pad_failed)\n        pad = 0;\n      length = ciphertext.size - hash_size - pad - 1;\n\n      break;\n    default:\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (length < 0)\n    length = 0;\n  c_length = _gnutls_conv_uint16 ((uint16_t) length);\n\n  /* Pass the type, version, length and compressed through\n   * MAC.\n   */\n  if (params->mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      digest_hd_st td;\n\n      ret = mac_init (&td, params->mac_algorithm,\n                      params->read.mac_secret.data,\n                      params->read.mac_secret.size, ver);\n\n      if (ret < 0)\n        {\n          gnutls_assert ();\n          return GNUTLS_E_INTERNAL_ERROR;\n        }\n\n      preamble_size =\n        make_preamble (UINT64DATA\n                       (params->read.sequence_number), type,\n                       c_length, ver, preamble);\n      mac_hash (&td, preamble, preamble_size, ver);\n      if (length > 0)\n        mac_hash (&td, ciphertext.data, length, ver);\n\n      mac_deinit (&td, MAC, ver);\n    }\n\n  /* HMAC was not the same. \n   */\n  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0 || pad_failed != 0)\n    {\n      gnutls_datum_t compressed = {compress_data, compress_size};\n      /* HMAC was not the same. */\n      dummy_wait(params, &compressed, pad_failed, pad, length+preamble_size, ver);\n\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* copy the decrypted stuff to compressed_data.\n   */\n  if (compress_size < length)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECOMPRESSION_FAILED;\n    }\n  memcpy (compress_data, ciphertext.data, length);\n\n  return length;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147117,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void CServer::ProcessClientPacket(CNetChunk *pPacket)\n{\n\tint ClientID = pPacket->m_ClientID;\n\tCUnpacker Unpacker;\n\tUnpacker.Reset(pPacket->m_pData, pPacket->m_DataSize);\n\n\t// unpack msgid and system flag\n\tint Msg = Unpacker.GetInt();\n\tint Sys = Msg&1;\n\tMsg >>= 1;\n\n\tif(Unpacker.Error())\n\t\treturn;\n\n\tif(Sys)\n\t{\n\t\t// system message\n\t\tif(Msg == NETMSG_INFO)\n\t\t{\n\t\t\tif(m_aClients[ClientID].m_State == CClient::STATE_AUTH)\n\t\t\t{\n\t\t\t\tconst char *pVersion = Unpacker.GetString(CUnpacker::SANITIZE_CC);\n\t\t\t\tif(str_comp(pVersion, GameServer()->NetVersion()) != 0)\n\t\t\t\t{\n\t\t\t\t\t// wrong version\n\t\t\t\t\tchar aReason[256];\n\t\t\t\t\tstr_format(aReason, sizeof(aReason), \"Wrong version. Server is running '%s' and client '%s'\", GameServer()->NetVersion(), pVersion);\n\t\t\t\t\tm_NetServer.Drop(ClientID, aReason);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst char *pPassword = Unpacker.GetString(CUnpacker::SANITIZE_CC);\n\t\t\t\tif(g_Config.m_Password[0] != 0 && str_comp(g_Config.m_Password, pPassword) != 0)\n\t\t\t\t{\n\t\t\t\t\t// wrong password\n\t\t\t\t\tm_NetServer.Drop(ClientID, \"Wrong password\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tm_aClients[ClientID].m_State = CClient::STATE_CONNECTING;\n\t\t\t\tSendMap(ClientID);\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_REQUEST_MAP_DATA)\n\t\t{\n\t\t\tif(m_aClients[ClientID].m_State < CClient::STATE_CONNECTING)\n\t\t\t\treturn;\n\n\t\t\tint Chunk = Unpacker.GetInt();\n\t\t\tint ChunkSize = 1024-128;\n\t\t\tint Offset = Chunk * ChunkSize;\n\t\t\tint Last = 0;\n\n\t\t\t// drop faulty map data requests\n\t\t\tif(Chunk < 0 || Offset > m_CurrentMapSize)\n\t\t\t\treturn;\n\n\t\t\tif(Offset+ChunkSize >= m_CurrentMapSize)\n\t\t\t{\n\t\t\t\tChunkSize = m_CurrentMapSize-Offset;\n\t\t\t\tif(ChunkSize < 0)\n\t\t\t\t\tChunkSize = 0;\n\t\t\t\tLast = 1;\n\t\t\t}\n\n\t\t\tCMsgPacker Msg(NETMSG_MAP_DATA);\n\t\t\tMsg.AddInt(Last);\n\t\t\tMsg.AddInt(m_CurrentMapCrc);\n\t\t\tMsg.AddInt(Chunk);\n\t\t\tMsg.AddInt(ChunkSize);\n\t\t\tMsg.AddRaw(&m_pCurrentMapData[Offset], ChunkSize);\n\t\t\tSendMsgEx(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH, ClientID, true);\n\n\t\t\tif(g_Config.m_Debug)\n\t\t\t{\n\t\t\t\tchar aBuf[256];\n\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"sending chunk %d with size %d\", Chunk, ChunkSize);\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"server\", aBuf);\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_READY)\n\t\t{\n\t\t\tif(m_aClients[ClientID].m_State == CClient::STATE_CONNECTING)\n\t\t\t{\n\t\t\t\tchar aAddrStr[NETADDR_MAXSTRSIZE];\n\t\t\t\tnet_addr_str(m_NetServer.ClientAddr(ClientID), aAddrStr, sizeof(aAddrStr), true);\n\n\t\t\t\tchar aBuf[256];\n\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"player is ready. ClientID=%x addr=%s\", ClientID, aAddrStr);\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"server\", aBuf);\n\t\t\t\tm_aClients[ClientID].m_State = CClient::STATE_READY;\n\t\t\t\tGameServer()->OnClientConnected(ClientID);\n\t\t\t\tSendConnectionReady(ClientID);\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_ENTERGAME)\n\t\t{\n\t\t\tif(m_aClients[ClientID].m_State == CClient::STATE_READY && GameServer()->IsClientReady(ClientID))\n\t\t\t{\n\t\t\t\tchar aAddrStr[NETADDR_MAXSTRSIZE];\n\t\t\t\tnet_addr_str(m_NetServer.ClientAddr(ClientID), aAddrStr, sizeof(aAddrStr), true);\n\n\t\t\t\tchar aBuf[256];\n\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"player has entered the game. ClientID=%x addr=%s\", ClientID, aAddrStr);\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\t\t\t\tm_aClients[ClientID].m_State = CClient::STATE_INGAME;\n\t\t\t\tGameServer()->OnClientEnter(ClientID);\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_INPUT)\n\t\t{\n\t\t\tCClient::CInput *pInput;\n\t\t\tint64 TagTime;\n\n\t\t\tm_aClients[ClientID].m_LastAckedSnapshot = Unpacker.GetInt();\n\t\t\tint IntendedTick = Unpacker.GetInt();\n\t\t\tint Size = Unpacker.GetInt();\n\n\t\t\t// check for errors\n\t\t\tif(Unpacker.Error() || Size/4 > MAX_INPUT_SIZE)\n\t\t\t\treturn;\n\n\t\t\tif(m_aClients[ClientID].m_LastAckedSnapshot > 0)\n\t\t\t\tm_aClients[ClientID].m_SnapRate = CClient::SNAPRATE_FULL;\n\n\t\t\tif(m_aClients[ClientID].m_Snapshots.Get(m_aClients[ClientID].m_LastAckedSnapshot, &TagTime, 0, 0) >= 0)\n\t\t\t\tm_aClients[ClientID].m_Latency = (int)(((time_get()-TagTime)*1000)/time_freq());\n\n\t\t\t// add message to report the input timing\n\t\t\t// skip packets that are old\n\t\t\tif(IntendedTick > m_aClients[ClientID].m_LastInputTick)\n\t\t\t{\n\t\t\t\tint TimeLeft = ((TickStartTime(IntendedTick)-time_get())*1000) / time_freq();\n\n\t\t\t\tCMsgPacker Msg(NETMSG_INPUTTIMING);\n\t\t\t\tMsg.AddInt(IntendedTick);\n\t\t\t\tMsg.AddInt(TimeLeft);\n\t\t\t\tSendMsgEx(&Msg, 0, ClientID, true);\n\t\t\t}\n\n\t\t\tm_aClients[ClientID].m_LastInputTick = IntendedTick;\n\n\t\t\tpInput = &m_aClients[ClientID].m_aInputs[m_aClients[ClientID].m_CurrentInput];\n\n\t\t\tif(IntendedTick <= Tick())\n\t\t\t\tIntendedTick = Tick()+1;\n\n\t\t\tpInput->m_GameTick = IntendedTick;\n\n\t\t\tfor(int i = 0; i < Size/4; i++)\n\t\t\t\tpInput->m_aData[i] = Unpacker.GetInt();\n\n\t\t\tmem_copy(m_aClients[ClientID].m_LatestInput.m_aData, pInput->m_aData, MAX_INPUT_SIZE*sizeof(int));\n\n\t\t\tm_aClients[ClientID].m_CurrentInput++;\n\t\t\tm_aClients[ClientID].m_CurrentInput %= 200;\n\n\t\t\t// call the mod with the fresh input data\n\t\t\tif(m_aClients[ClientID].m_State == CClient::STATE_INGAME)\n\t\t\t\tGameServer()->OnClientDirectInput(ClientID, m_aClients[ClientID].m_LatestInput.m_aData);\n\t\t}\n\t\telse if(Msg == NETMSG_RCON_CMD)\n\t\t{\n\t\t\tconst char *pCmd = Unpacker.GetString();\n\n\t\t\tif(Unpacker.Error() == 0 && m_aClients[ClientID].m_Authed)\n\t\t\t{\n\t\t\t\tchar aBuf[256];\n\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"ClientID=%d rcon='%s'\", ClientID, pCmd);\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"server\", aBuf);\n\t\t\t\tm_RconClientID = ClientID;\n\t\t\t\tm_RconAuthLevel = m_aClients[ClientID].m_Authed;\n\t\t\t\tConsole()->SetAccessLevel(m_aClients[ClientID].m_Authed == AUTHED_ADMIN ? IConsole::ACCESS_LEVEL_ADMIN : IConsole::ACCESS_LEVEL_MOD);\n\t\t\t\tConsole()->ExecuteLineFlag(pCmd, CFGFLAG_SERVER);\n\t\t\t\tConsole()->SetAccessLevel(IConsole::ACCESS_LEVEL_ADMIN);\n\t\t\t\tm_RconClientID = IServer::RCON_CID_SERV;\n\t\t\t\tm_RconAuthLevel = AUTHED_ADMIN;\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_RCON_AUTH)\n\t\t{\n\t\t\tconst char *pPw;\n\t\t\tUnpacker.GetString(); // login name, not used\n\t\t\tpPw = Unpacker.GetString(CUnpacker::SANITIZE_CC);\n\n\t\t\tif(Unpacker.Error() == 0)\n\t\t\t{\n\t\t\t\tif(g_Config.m_SvRconPassword[0] == 0 && g_Config.m_SvRconModPassword[0] == 0)\n\t\t\t\t{\n\t\t\t\t\tSendRconLine(ClientID, \"No rcon password set on server. Set sv_rcon_password and/or sv_rcon_mod_password to enable the remote console.\");\n\t\t\t\t}\n\t\t\t\telse if(g_Config.m_SvRconPassword[0] && str_comp(pPw, g_Config.m_SvRconPassword) == 0)\n\t\t\t\t{\n\t\t\t\t\tCMsgPacker Msg(NETMSG_RCON_AUTH_STATUS);\n\t\t\t\t\tMsg.AddInt(1);\t//authed\n\t\t\t\t\tMsg.AddInt(1);\t//cmdlist\n\t\t\t\t\tSendMsgEx(&Msg, MSGFLAG_VITAL, ClientID, true);\n\n\t\t\t\t\tm_aClients[ClientID].m_Authed = AUTHED_ADMIN;\n\t\t\t\t\tint SendRconCmds = Unpacker.GetInt();\n\t\t\t\t\tif(Unpacker.Error() == 0 && SendRconCmds)\n\t\t\t\t\t\tm_aClients[ClientID].m_pRconCmdToSend = Console()->FirstCommandInfo(IConsole::ACCESS_LEVEL_ADMIN, CFGFLAG_SERVER);\n\t\t\t\t\tSendRconLine(ClientID, \"Admin authentication successful. Full remote console access granted.\");\n\t\t\t\t\tchar aBuf[256];\n\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"ClientID=%d authed (admin)\", ClientID);\n\t\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\t\t\t\t}\n\t\t\t\telse if(g_Config.m_SvRconModPassword[0] && str_comp(pPw, g_Config.m_SvRconModPassword) == 0)\n\t\t\t\t{\n\t\t\t\t\tCMsgPacker Msg(NETMSG_RCON_AUTH_STATUS);\n\t\t\t\t\tMsg.AddInt(1);\t//authed\n\t\t\t\t\tMsg.AddInt(1);\t//cmdlist\n\t\t\t\t\tSendMsgEx(&Msg, MSGFLAG_VITAL, ClientID, true);\n\n\t\t\t\t\tm_aClients[ClientID].m_Authed = AUTHED_MOD;\n\t\t\t\t\tint SendRconCmds = Unpacker.GetInt();\n\t\t\t\t\tif(Unpacker.Error() == 0 && SendRconCmds)\n\t\t\t\t\t\tm_aClients[ClientID].m_pRconCmdToSend = Console()->FirstCommandInfo(IConsole::ACCESS_LEVEL_MOD, CFGFLAG_SERVER);\n\t\t\t\t\tSendRconLine(ClientID, \"Moderator authentication successful. Limited remote console access granted.\");\n\t\t\t\t\tchar aBuf[256];\n\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"ClientID=%d authed (moderator)\", ClientID);\n\t\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\t\t\t\t}\n\t\t\t\telse if(g_Config.m_SvRconMaxTries)\n\t\t\t\t{\n\t\t\t\t\tm_aClients[ClientID].m_AuthTries++;\n\t\t\t\t\tchar aBuf[128];\n\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"Wrong password %d/%d.\", m_aClients[ClientID].m_AuthTries, g_Config.m_SvRconMaxTries);\n\t\t\t\t\tSendRconLine(ClientID, aBuf);\n\t\t\t\t\tif(m_aClients[ClientID].m_AuthTries >= g_Config.m_SvRconMaxTries)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!g_Config.m_SvRconBantime)\n\t\t\t\t\t\t\tm_NetServer.Drop(ClientID, \"Too many remote console authentication tries\");\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tm_ServerBan.BanAddr(m_NetServer.ClientAddr(ClientID), g_Config.m_SvRconBantime*60, \"Too many remote console authentication tries\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSendRconLine(ClientID, \"Wrong password.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_PING)\n\t\t{\n\t\t\tCMsgPacker Msg(NETMSG_PING_REPLY);\n\t\t\tSendMsgEx(&Msg, 0, ClientID, true);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(g_Config.m_Debug)\n\t\t\t{\n\t\t\t\tchar aHex[] = \"0123456789ABCDEF\";\n\t\t\t\tchar aBuf[512];\n\n\t\t\t\tfor(int b = 0; b < pPacket->m_DataSize && b < 32; b++)\n\t\t\t\t{\n\t\t\t\t\taBuf[b*3] = aHex[((const unsigned char *)pPacket->m_pData)[b]>>4];\n\t\t\t\t\taBuf[b*3+1] = aHex[((const unsigned char *)pPacket->m_pData)[b]&0xf];\n\t\t\t\t\taBuf[b*3+2] = ' ';\n\t\t\t\t\taBuf[b*3+3] = 0;\n\t\t\t\t}\n\n\t\t\t\tchar aBufMsg[256];\n\t\t\t\tstr_format(aBufMsg, sizeof(aBufMsg), \"strange message ClientID=%d msg=%d data_size=%d\", ClientID, Msg, pPacket->m_DataSize);\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"server\", aBufMsg);\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"server\", aBuf);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t// game message\n\t\tif(m_aClients[ClientID].m_State >= CClient::STATE_READY)\n\t\t\tGameServer()->OnMessage(Msg, &Unpacker, ClientID);\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147124,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void CServer::ProcessClientPacket(CNetChunk *pPacket)\n{\n\tint ClientID = pPacket->m_ClientID;\n\tCUnpacker Unpacker;\n\tUnpacker.Reset(pPacket->m_pData, pPacket->m_DataSize);\n\n\t// unpack msgid and system flag\n\tint Msg = Unpacker.GetInt();\n\tint Sys = Msg&1;\n\tMsg >>= 1;\n\n\tif(Unpacker.Error())\n\t\treturn;\n\n\tif(Sys)\n\t{\n\t\t// system message\n\t\tif(Msg == NETMSG_INFO)\n\t\t{\n\t\t\tif(m_aClients[ClientID].m_State == CClient::STATE_AUTH)\n\t\t\t{\n\t\t\t\tconst char *pVersion = Unpacker.GetString(CUnpacker::SANITIZE_CC);\n\t\t\t\tif(str_comp(pVersion, GameServer()->NetVersion()) != 0)\n\t\t\t\t{\n\t\t\t\t\t// wrong version\n\t\t\t\t\tchar aReason[256];\n\t\t\t\t\tstr_format(aReason, sizeof(aReason), \"Wrong version. Server is running '%s' and client '%s'\", GameServer()->NetVersion(), pVersion);\n\t\t\t\t\tm_NetServer.Drop(ClientID, aReason);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst char *pPassword = Unpacker.GetString(CUnpacker::SANITIZE_CC);\n\t\t\t\tif(g_Config.m_Password[0] != 0 && str_comp(g_Config.m_Password, pPassword) != 0)\n\t\t\t\t{\n\t\t\t\t\t// wrong password\n\t\t\t\t\tm_NetServer.Drop(ClientID, \"Wrong password\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tm_aClients[ClientID].m_State = CClient::STATE_CONNECTING;\n\t\t\t\tSendMap(ClientID);\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_REQUEST_MAP_DATA)\n\t\t{\n\t\t\tif(m_aClients[ClientID].m_State < CClient::STATE_CONNECTING)\n\t\t\t\treturn;\n\n\t\t\tint Chunk = Unpacker.GetInt();\n\t\t\tunsigned int ChunkSize = 1024-128;\n\t\t\tunsigned int Offset = Chunk * ChunkSize;\n\t\t\tint Last = 0;\n\n\t\t\t// drop faulty map data requests\n\t\t\tif(Chunk < 0 || Offset > m_CurrentMapSize)\n\t\t\t\treturn;\n\n\t\t\tif(Offset+ChunkSize >= m_CurrentMapSize)\n\t\t\t{\n\t\t\t\tChunkSize = m_CurrentMapSize-Offset;\n\t\t\t\tif(ChunkSize < 0)\n\t\t\t\t\tChunkSize = 0;\n\t\t\t\tLast = 1;\n\t\t\t}\n\n\t\t\tCMsgPacker Msg(NETMSG_MAP_DATA);\n\t\t\tMsg.AddInt(Last);\n\t\t\tMsg.AddInt(m_CurrentMapCrc);\n\t\t\tMsg.AddInt(Chunk);\n\t\t\tMsg.AddInt(ChunkSize);\n\t\t\tMsg.AddRaw(&m_pCurrentMapData[Offset], ChunkSize);\n\t\t\tSendMsgEx(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH, ClientID, true);\n\n\t\t\tif(g_Config.m_Debug)\n\t\t\t{\n\t\t\t\tchar aBuf[256];\n\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"sending chunk %d with size %d\", Chunk, ChunkSize);\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"server\", aBuf);\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_READY)\n\t\t{\n\t\t\tif(m_aClients[ClientID].m_State == CClient::STATE_CONNECTING)\n\t\t\t{\n\t\t\t\tchar aAddrStr[NETADDR_MAXSTRSIZE];\n\t\t\t\tnet_addr_str(m_NetServer.ClientAddr(ClientID), aAddrStr, sizeof(aAddrStr), true);\n\n\t\t\t\tchar aBuf[256];\n\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"player is ready. ClientID=%x addr=%s\", ClientID, aAddrStr);\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"server\", aBuf);\n\t\t\t\tm_aClients[ClientID].m_State = CClient::STATE_READY;\n\t\t\t\tGameServer()->OnClientConnected(ClientID);\n\t\t\t\tSendConnectionReady(ClientID);\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_ENTERGAME)\n\t\t{\n\t\t\tif(m_aClients[ClientID].m_State == CClient::STATE_READY && GameServer()->IsClientReady(ClientID))\n\t\t\t{\n\t\t\t\tchar aAddrStr[NETADDR_MAXSTRSIZE];\n\t\t\t\tnet_addr_str(m_NetServer.ClientAddr(ClientID), aAddrStr, sizeof(aAddrStr), true);\n\n\t\t\t\tchar aBuf[256];\n\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"player has entered the game. ClientID=%x addr=%s\", ClientID, aAddrStr);\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\t\t\t\tm_aClients[ClientID].m_State = CClient::STATE_INGAME;\n\t\t\t\tGameServer()->OnClientEnter(ClientID);\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_INPUT)\n\t\t{\n\t\t\tCClient::CInput *pInput;\n\t\t\tint64 TagTime;\n\n\t\t\tm_aClients[ClientID].m_LastAckedSnapshot = Unpacker.GetInt();\n\t\t\tint IntendedTick = Unpacker.GetInt();\n\t\t\tint Size = Unpacker.GetInt();\n\n\t\t\t// check for errors\n\t\t\tif(Unpacker.Error() || Size/4 > MAX_INPUT_SIZE)\n\t\t\t\treturn;\n\n\t\t\tif(m_aClients[ClientID].m_LastAckedSnapshot > 0)\n\t\t\t\tm_aClients[ClientID].m_SnapRate = CClient::SNAPRATE_FULL;\n\n\t\t\tif(m_aClients[ClientID].m_Snapshots.Get(m_aClients[ClientID].m_LastAckedSnapshot, &TagTime, 0, 0) >= 0)\n\t\t\t\tm_aClients[ClientID].m_Latency = (int)(((time_get()-TagTime)*1000)/time_freq());\n\n\t\t\t// add message to report the input timing\n\t\t\t// skip packets that are old\n\t\t\tif(IntendedTick > m_aClients[ClientID].m_LastInputTick)\n\t\t\t{\n\t\t\t\tint TimeLeft = ((TickStartTime(IntendedTick)-time_get())*1000) / time_freq();\n\n\t\t\t\tCMsgPacker Msg(NETMSG_INPUTTIMING);\n\t\t\t\tMsg.AddInt(IntendedTick);\n\t\t\t\tMsg.AddInt(TimeLeft);\n\t\t\t\tSendMsgEx(&Msg, 0, ClientID, true);\n\t\t\t}\n\n\t\t\tm_aClients[ClientID].m_LastInputTick = IntendedTick;\n\n\t\t\tpInput = &m_aClients[ClientID].m_aInputs[m_aClients[ClientID].m_CurrentInput];\n\n\t\t\tif(IntendedTick <= Tick())\n\t\t\t\tIntendedTick = Tick()+1;\n\n\t\t\tpInput->m_GameTick = IntendedTick;\n\n\t\t\tfor(int i = 0; i < Size/4; i++)\n\t\t\t\tpInput->m_aData[i] = Unpacker.GetInt();\n\n\t\t\tmem_copy(m_aClients[ClientID].m_LatestInput.m_aData, pInput->m_aData, MAX_INPUT_SIZE*sizeof(int));\n\n\t\t\tm_aClients[ClientID].m_CurrentInput++;\n\t\t\tm_aClients[ClientID].m_CurrentInput %= 200;\n\n\t\t\t// call the mod with the fresh input data\n\t\t\tif(m_aClients[ClientID].m_State == CClient::STATE_INGAME)\n\t\t\t\tGameServer()->OnClientDirectInput(ClientID, m_aClients[ClientID].m_LatestInput.m_aData);\n\t\t}\n\t\telse if(Msg == NETMSG_RCON_CMD)\n\t\t{\n\t\t\tconst char *pCmd = Unpacker.GetString();\n\n\t\t\tif(Unpacker.Error() == 0 && m_aClients[ClientID].m_Authed)\n\t\t\t{\n\t\t\t\tchar aBuf[256];\n\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"ClientID=%d rcon='%s'\", ClientID, pCmd);\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"server\", aBuf);\n\t\t\t\tm_RconClientID = ClientID;\n\t\t\t\tm_RconAuthLevel = m_aClients[ClientID].m_Authed;\n\t\t\t\tConsole()->SetAccessLevel(m_aClients[ClientID].m_Authed == AUTHED_ADMIN ? IConsole::ACCESS_LEVEL_ADMIN : IConsole::ACCESS_LEVEL_MOD);\n\t\t\t\tConsole()->ExecuteLineFlag(pCmd, CFGFLAG_SERVER);\n\t\t\t\tConsole()->SetAccessLevel(IConsole::ACCESS_LEVEL_ADMIN);\n\t\t\t\tm_RconClientID = IServer::RCON_CID_SERV;\n\t\t\t\tm_RconAuthLevel = AUTHED_ADMIN;\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_RCON_AUTH)\n\t\t{\n\t\t\tconst char *pPw;\n\t\t\tUnpacker.GetString(); // login name, not used\n\t\t\tpPw = Unpacker.GetString(CUnpacker::SANITIZE_CC);\n\n\t\t\tif(Unpacker.Error() == 0)\n\t\t\t{\n\t\t\t\tif(g_Config.m_SvRconPassword[0] == 0 && g_Config.m_SvRconModPassword[0] == 0)\n\t\t\t\t{\n\t\t\t\t\tSendRconLine(ClientID, \"No rcon password set on server. Set sv_rcon_password and/or sv_rcon_mod_password to enable the remote console.\");\n\t\t\t\t}\n\t\t\t\telse if(g_Config.m_SvRconPassword[0] && str_comp(pPw, g_Config.m_SvRconPassword) == 0)\n\t\t\t\t{\n\t\t\t\t\tCMsgPacker Msg(NETMSG_RCON_AUTH_STATUS);\n\t\t\t\t\tMsg.AddInt(1);\t//authed\n\t\t\t\t\tMsg.AddInt(1);\t//cmdlist\n\t\t\t\t\tSendMsgEx(&Msg, MSGFLAG_VITAL, ClientID, true);\n\n\t\t\t\t\tm_aClients[ClientID].m_Authed = AUTHED_ADMIN;\n\t\t\t\t\tint SendRconCmds = Unpacker.GetInt();\n\t\t\t\t\tif(Unpacker.Error() == 0 && SendRconCmds)\n\t\t\t\t\t\tm_aClients[ClientID].m_pRconCmdToSend = Console()->FirstCommandInfo(IConsole::ACCESS_LEVEL_ADMIN, CFGFLAG_SERVER);\n\t\t\t\t\tSendRconLine(ClientID, \"Admin authentication successful. Full remote console access granted.\");\n\t\t\t\t\tchar aBuf[256];\n\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"ClientID=%d authed (admin)\", ClientID);\n\t\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\t\t\t\t}\n\t\t\t\telse if(g_Config.m_SvRconModPassword[0] && str_comp(pPw, g_Config.m_SvRconModPassword) == 0)\n\t\t\t\t{\n\t\t\t\t\tCMsgPacker Msg(NETMSG_RCON_AUTH_STATUS);\n\t\t\t\t\tMsg.AddInt(1);\t//authed\n\t\t\t\t\tMsg.AddInt(1);\t//cmdlist\n\t\t\t\t\tSendMsgEx(&Msg, MSGFLAG_VITAL, ClientID, true);\n\n\t\t\t\t\tm_aClients[ClientID].m_Authed = AUTHED_MOD;\n\t\t\t\t\tint SendRconCmds = Unpacker.GetInt();\n\t\t\t\t\tif(Unpacker.Error() == 0 && SendRconCmds)\n\t\t\t\t\t\tm_aClients[ClientID].m_pRconCmdToSend = Console()->FirstCommandInfo(IConsole::ACCESS_LEVEL_MOD, CFGFLAG_SERVER);\n\t\t\t\t\tSendRconLine(ClientID, \"Moderator authentication successful. Limited remote console access granted.\");\n\t\t\t\t\tchar aBuf[256];\n\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"ClientID=%d authed (moderator)\", ClientID);\n\t\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);\n\t\t\t\t}\n\t\t\t\telse if(g_Config.m_SvRconMaxTries)\n\t\t\t\t{\n\t\t\t\t\tm_aClients[ClientID].m_AuthTries++;\n\t\t\t\t\tchar aBuf[128];\n\t\t\t\t\tstr_format(aBuf, sizeof(aBuf), \"Wrong password %d/%d.\", m_aClients[ClientID].m_AuthTries, g_Config.m_SvRconMaxTries);\n\t\t\t\t\tSendRconLine(ClientID, aBuf);\n\t\t\t\t\tif(m_aClients[ClientID].m_AuthTries >= g_Config.m_SvRconMaxTries)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!g_Config.m_SvRconBantime)\n\t\t\t\t\t\t\tm_NetServer.Drop(ClientID, \"Too many remote console authentication tries\");\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tm_ServerBan.BanAddr(m_NetServer.ClientAddr(ClientID), g_Config.m_SvRconBantime*60, \"Too many remote console authentication tries\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSendRconLine(ClientID, \"Wrong password.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(Msg == NETMSG_PING)\n\t\t{\n\t\t\tCMsgPacker Msg(NETMSG_PING_REPLY);\n\t\t\tSendMsgEx(&Msg, 0, ClientID, true);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(g_Config.m_Debug)\n\t\t\t{\n\t\t\t\tchar aHex[] = \"0123456789ABCDEF\";\n\t\t\t\tchar aBuf[512];\n\n\t\t\t\tfor(int b = 0; b < pPacket->m_DataSize && b < 32; b++)\n\t\t\t\t{\n\t\t\t\t\taBuf[b*3] = aHex[((const unsigned char *)pPacket->m_pData)[b]>>4];\n\t\t\t\t\taBuf[b*3+1] = aHex[((const unsigned char *)pPacket->m_pData)[b]&0xf];\n\t\t\t\t\taBuf[b*3+2] = ' ';\n\t\t\t\t\taBuf[b*3+3] = 0;\n\t\t\t\t}\n\n\t\t\t\tchar aBufMsg[256];\n\t\t\t\tstr_format(aBufMsg, sizeof(aBufMsg), \"strange message ClientID=%d msg=%d data_size=%d\", ClientID, Msg, pPacket->m_DataSize);\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"server\", aBufMsg);\n\t\t\t\tConsole()->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"server\", aBuf);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t// game message\n\t\tif(m_aClients[ClientID].m_State >= CClient::STATE_READY)\n\t\t\tGameServer()->OnMessage(Msg, &Unpacker, ClientID);\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147125,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "uint32_t skip(Protocol_& prot, TType type) {\n  switch (type) {\n  case T_BOOL: {\n    bool boolv;\n    return prot.readBool(boolv);\n  }\n  case T_BYTE: {\n    int8_t bytev;\n    return prot.readByte(bytev);\n  }\n  case T_I16: {\n    int16_t i16;\n    return prot.readI16(i16);\n  }\n  case T_I32: {\n    int32_t i32;\n    return prot.readI32(i32);\n  }\n  case T_I64: {\n    int64_t i64;\n    return prot.readI64(i64);\n  }\n  case T_DOUBLE: {\n    double dub;\n    return prot.readDouble(dub);\n  }\n  case T_STRING: {\n    std::string str;\n    return prot.readBinary(str);\n  }\n  case T_STRUCT: {\n    uint32_t result = 0;\n    std::string name;\n    int16_t fid;\n    TType ftype;\n    result += prot.readStructBegin(name);\n    while (true) {\n      result += prot.readFieldBegin(name, ftype, fid);\n      if (ftype == T_STOP) {\n        break;\n      }\n      result += skip(prot, ftype);\n      result += prot.readFieldEnd();\n    }\n    result += prot.readStructEnd();\n    return result;\n  }\n  case T_MAP: {\n    uint32_t result = 0;\n    TType keyType;\n    TType valType;\n    uint32_t i, size;\n    result += prot.readMapBegin(keyType, valType, size);\n    for (i = 0; i < size; i++) {\n      result += skip(prot, keyType);\n      result += skip(prot, valType);\n    }\n    result += prot.readMapEnd();\n    return result;\n  }\n  case T_SET: {\n    uint32_t result = 0;\n    TType elemType;\n    uint32_t i, size;\n    result += prot.readSetBegin(elemType, size);\n    for (i = 0; i < size; i++) {\n      result += skip(prot, elemType);\n    }\n    result += prot.readSetEnd();\n    return result;\n  }\n  case T_LIST: {\n    uint32_t result = 0;\n    TType elemType;\n    uint32_t i, size;\n    result += prot.readListBegin(elemType, size);\n    for (i = 0; i < size; i++) {\n      result += skip(prot, elemType);\n    }\n    result += prot.readListEnd();\n    return result;\n  }\n  case T_STOP:\n  case T_VOID:\n  case T_U64:\n  case T_UTF8:\n  case T_UTF16:\n    break;\n  }\n  return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147136,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "uint32_t skip(Protocol_& prot, TType type) {\n  TRecursionTracker tracker(prot);\n\n  switch (type) {\n  case T_BOOL: {\n    bool boolv;\n    return prot.readBool(boolv);\n  }\n  case T_BYTE: {\n    int8_t bytev;\n    return prot.readByte(bytev);\n  }\n  case T_I16: {\n    int16_t i16;\n    return prot.readI16(i16);\n  }\n  case T_I32: {\n    int32_t i32;\n    return prot.readI32(i32);\n  }\n  case T_I64: {\n    int64_t i64;\n    return prot.readI64(i64);\n  }\n  case T_DOUBLE: {\n    double dub;\n    return prot.readDouble(dub);\n  }\n  case T_STRING: {\n    std::string str;\n    return prot.readBinary(str);\n  }\n  case T_STRUCT: {\n    uint32_t result = 0;\n    std::string name;\n    int16_t fid;\n    TType ftype;\n    result += prot.readStructBegin(name);\n    while (true) {\n      result += prot.readFieldBegin(name, ftype, fid);\n      if (ftype == T_STOP) {\n        break;\n      }\n      result += skip(prot, ftype);\n      result += prot.readFieldEnd();\n    }\n    result += prot.readStructEnd();\n    return result;\n  }\n  case T_MAP: {\n    uint32_t result = 0;\n    TType keyType;\n    TType valType;\n    uint32_t i, size;\n    result += prot.readMapBegin(keyType, valType, size);\n    for (i = 0; i < size; i++) {\n      result += skip(prot, keyType);\n      result += skip(prot, valType);\n    }\n    result += prot.readMapEnd();\n    return result;\n  }\n  case T_SET: {\n    uint32_t result = 0;\n    TType elemType;\n    uint32_t i, size;\n    result += prot.readSetBegin(elemType, size);\n    for (i = 0; i < size; i++) {\n      result += skip(prot, elemType);\n    }\n    result += prot.readSetEnd();\n    return result;\n  }\n  case T_LIST: {\n    uint32_t result = 0;\n    TType elemType;\n    uint32_t i, size;\n    result += prot.readListBegin(elemType, size);\n    for (i = 0; i < size; i++) {\n      result += skip(prot, elemType);\n    }\n    result += prot.readListEnd();\n    return result;\n  }\n  case T_STOP:\n  case T_VOID:\n  case T_U64:\n  case T_UTF8:\n  case T_UTF16:\n    break;\n  }\n  return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147137,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "verify_host_key(char *host, struct sockaddr *hostaddr, Key *host_key)\n{\n\tint flags = 0;\n\tchar *fp;\n\n\tfp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);\n\tdebug(\"Server host key: %s %s\", key_type(host_key), fp);\n\tfree(fp);\n\n\t/* XXX certs are not yet supported for DNS */\n\tif (!key_is_cert(host_key) && options.verify_host_key_dns &&\n\t    verify_host_key_dns(host, hostaddr, host_key, &flags) == 0) {\n\t\tif (flags & DNS_VERIFY_FOUND) {\n\n\t\t\tif (options.verify_host_key_dns == 1 &&\n\t\t\t    flags & DNS_VERIFY_MATCH &&\n\t\t\t    flags & DNS_VERIFY_SECURE)\n\t\t\t\treturn 0;\n\n\t\t\tif (flags & DNS_VERIFY_MATCH) {\n\t\t\t\tmatching_host_key_dns = 1;\n\t\t\t} else {\n\t\t\t\twarn_changed_key(host_key);\n\t\t\t\terror(\"Update the SSHFP RR in DNS with the new \"\n\t\t\t\t    \"host key to get rid of this message.\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn check_host_key(host, hostaddr, options.port, host_key, RDRW,\n\t    options.user_hostfiles, options.num_user_hostfiles,\n\t    options.system_hostfiles, options.num_system_hostfiles);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147180,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "verify_host_key(char *host, struct sockaddr *hostaddr, Key *host_key)\n{\n\tint flags = 0;\n\tchar *fp;\n\tKey *plain = NULL;\n\n\tfp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);\n\tdebug(\"Server host key: %s %s\", key_type(host_key), fp);\n\tfree(fp);\n\n\tif (options.verify_host_key_dns) {\n\t\t/*\n\t\t * XXX certs are not yet supported for DNS, so downgrade\n\t\t * them and try the plain key.\n\t\t */\n\t\tplain = key_from_private(host_key);\n\t\tif (key_is_cert(plain))\n\t\t\tkey_drop_cert(plain);\n\t\tif (verify_host_key_dns(host, hostaddr, plain, &flags) == 0) {\n\t\t\tif (flags & DNS_VERIFY_FOUND) {\n\t\t\t\tif (options.verify_host_key_dns == 1 &&\n\t\t\t\t    flags & DNS_VERIFY_MATCH &&\n\t\t\t\t    flags & DNS_VERIFY_SECURE) {\n\t\t\t\t\tkey_free(plain);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (flags & DNS_VERIFY_MATCH) {\n\t\t\t\t\tmatching_host_key_dns = 1;\n\t\t\t\t} else {\n\t\t\t\t\twarn_changed_key(plain);\n\t\t\t\t\terror(\"Update the SSHFP RR in DNS \"\n\t\t\t\t\t    \"with the new host key to get rid \"\n\t\t\t\t\t    \"of this message.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tkey_free(plain);\n\t}\n\n\treturn check_host_key(host, hostaddr, options.port, host_key, RDRW,\n\t    options.user_hostfiles, options.num_user_hostfiles,\n\t    options.system_hostfiles, options.num_system_hostfiles);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147181,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static VALUE cParser_initialize(int argc, VALUE *argv, VALUE self)\n{\n    VALUE source, opts;\n    GET_PARSER_INIT;\n\n    if (json->Vsource) {\n        rb_raise(rb_eTypeError, \"already initialized instance\");\n    }\n#ifdef HAVE_RB_SCAN_ARGS_OPTIONAL_HASH\n    rb_scan_args(argc, argv, \"1:\", &source, &opts);\n#else\n    rb_scan_args(argc, argv, \"11\", &source, &opts);\n#endif\n    if (!NIL_P(opts)) {\n#ifndef HAVE_RB_SCAN_ARGS_OPTIONAL_HASH\n        opts = rb_convert_type(opts, T_HASH, \"Hash\", \"to_hash\");\n        if (NIL_P(opts)) {\n            rb_raise(rb_eArgError, \"opts needs to be like a hash\");\n        } else {\n#endif\n            VALUE tmp = ID2SYM(i_max_nesting);\n            if (option_given_p(opts, tmp)) {\n                VALUE max_nesting = rb_hash_aref(opts, tmp);\n                if (RTEST(max_nesting)) {\n                    Check_Type(max_nesting, T_FIXNUM);\n                    json->max_nesting = FIX2INT(max_nesting);\n                } else {\n                    json->max_nesting = 0;\n                }\n            } else {\n                json->max_nesting = 100;\n            }\n            tmp = ID2SYM(i_allow_nan);\n            if (option_given_p(opts, tmp)) {\n                json->allow_nan = RTEST(rb_hash_aref(opts, tmp)) ? 1 : 0;\n            } else {\n                json->allow_nan = 0;\n            }\n            tmp = ID2SYM(i_symbolize_names);\n            if (option_given_p(opts, tmp)) {\n                json->symbolize_names = RTEST(rb_hash_aref(opts, tmp)) ? 1 : 0;\n            } else {\n                json->symbolize_names = 0;\n            }\n            tmp = ID2SYM(i_create_additions);\n            if (option_given_p(opts, tmp)) {\n                json->create_additions = RTEST(rb_hash_aref(opts, tmp));\n            } else {\n                json->create_additions = 0;\n            }\n            if (json->symbolize_names && json->create_additions) {\n              rb_raise(rb_eArgError,\n                \"options :symbolize_names and :create_additions cannot be \"\n                \" used in conjunction\");\n            }\n            tmp = ID2SYM(i_create_id);\n            if (option_given_p(opts, tmp)) {\n                json->create_id = rb_hash_aref(opts, tmp);\n            } else {\n                json->create_id = rb_funcall(mJSON, i_create_id, 0);\n            }\n            tmp = ID2SYM(i_object_class);\n            if (option_given_p(opts, tmp)) {\n                json->object_class = rb_hash_aref(opts, tmp);\n            } else {\n                json->object_class = Qnil;\n            }\n            tmp = ID2SYM(i_array_class);\n            if (option_given_p(opts, tmp)) {\n                json->array_class = rb_hash_aref(opts, tmp);\n            } else {\n                json->array_class = Qnil;\n            }\n            tmp = ID2SYM(i_decimal_class);\n            if (option_given_p(opts, tmp)) {\n                json->decimal_class = rb_hash_aref(opts, tmp);\n            } else {\n                json->decimal_class = Qnil;\n            }\n            tmp = ID2SYM(i_match_string);\n            if (option_given_p(opts, tmp)) {\n                VALUE match_string = rb_hash_aref(opts, tmp);\n                json->match_string = RTEST(match_string) ? match_string : Qnil;\n            } else {\n                json->match_string = Qnil;\n            }\n#ifndef HAVE_RB_SCAN_ARGS_OPTIONAL_HASH\n        }\n#endif\n    } else {\n        json->max_nesting = 100;\n        json->allow_nan = 0;\n        json->create_additions = 1;\n        json->create_id = rb_funcall(mJSON, i_create_id, 0);\n        json->object_class = Qnil;\n        json->array_class = Qnil;\n        json->decimal_class = Qnil;\n    }\n    source = convert_encoding(StringValue(source));\n    StringValue(source);\n    json->len = RSTRING_LEN(source);\n    json->source = RSTRING_PTR(source);;\n    json->Vsource = source;\n    return self;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147210,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static VALUE cParser_initialize(int argc, VALUE *argv, VALUE self)\n{\n    VALUE source, opts;\n    GET_PARSER_INIT;\n\n    if (json->Vsource) {\n        rb_raise(rb_eTypeError, \"already initialized instance\");\n    }\n#ifdef HAVE_RB_SCAN_ARGS_OPTIONAL_HASH\n    rb_scan_args(argc, argv, \"1:\", &source, &opts);\n#else\n    rb_scan_args(argc, argv, \"11\", &source, &opts);\n#endif\n    if (!NIL_P(opts)) {\n#ifndef HAVE_RB_SCAN_ARGS_OPTIONAL_HASH\n        opts = rb_convert_type(opts, T_HASH, \"Hash\", \"to_hash\");\n        if (NIL_P(opts)) {\n            rb_raise(rb_eArgError, \"opts needs to be like a hash\");\n        } else {\n#endif\n            VALUE tmp = ID2SYM(i_max_nesting);\n            if (option_given_p(opts, tmp)) {\n                VALUE max_nesting = rb_hash_aref(opts, tmp);\n                if (RTEST(max_nesting)) {\n                    Check_Type(max_nesting, T_FIXNUM);\n                    json->max_nesting = FIX2INT(max_nesting);\n                } else {\n                    json->max_nesting = 0;\n                }\n            } else {\n                json->max_nesting = 100;\n            }\n            tmp = ID2SYM(i_allow_nan);\n            if (option_given_p(opts, tmp)) {\n                json->allow_nan = RTEST(rb_hash_aref(opts, tmp)) ? 1 : 0;\n            } else {\n                json->allow_nan = 0;\n            }\n            tmp = ID2SYM(i_symbolize_names);\n            if (option_given_p(opts, tmp)) {\n                json->symbolize_names = RTEST(rb_hash_aref(opts, tmp)) ? 1 : 0;\n            } else {\n                json->symbolize_names = 0;\n            }\n            tmp = ID2SYM(i_create_additions);\n            if (option_given_p(opts, tmp)) {\n                json->create_additions = RTEST(rb_hash_aref(opts, tmp));\n            } else {\n                json->create_additions = 0;\n            }\n            if (json->symbolize_names && json->create_additions) {\n              rb_raise(rb_eArgError,\n                \"options :symbolize_names and :create_additions cannot be \"\n                \" used in conjunction\");\n            }\n            tmp = ID2SYM(i_create_id);\n            if (option_given_p(opts, tmp)) {\n                json->create_id = rb_hash_aref(opts, tmp);\n            } else {\n                json->create_id = rb_funcall(mJSON, i_create_id, 0);\n            }\n            tmp = ID2SYM(i_object_class);\n            if (option_given_p(opts, tmp)) {\n                json->object_class = rb_hash_aref(opts, tmp);\n            } else {\n                json->object_class = Qnil;\n            }\n            tmp = ID2SYM(i_array_class);\n            if (option_given_p(opts, tmp)) {\n                json->array_class = rb_hash_aref(opts, tmp);\n            } else {\n                json->array_class = Qnil;\n            }\n            tmp = ID2SYM(i_decimal_class);\n            if (option_given_p(opts, tmp)) {\n                json->decimal_class = rb_hash_aref(opts, tmp);\n            } else {\n                json->decimal_class = Qnil;\n            }\n            tmp = ID2SYM(i_match_string);\n            if (option_given_p(opts, tmp)) {\n                VALUE match_string = rb_hash_aref(opts, tmp);\n                json->match_string = RTEST(match_string) ? match_string : Qnil;\n            } else {\n                json->match_string = Qnil;\n            }\n#ifndef HAVE_RB_SCAN_ARGS_OPTIONAL_HASH\n        }\n#endif\n    } else {\n        json->max_nesting = 100;\n        json->allow_nan = 0;\n        json->create_additions = 0;\n        json->create_id = rb_funcall(mJSON, i_create_id, 0);\n        json->object_class = Qnil;\n        json->array_class = Qnil;\n        json->decimal_class = Qnil;\n    }\n    source = convert_encoding(StringValue(source));\n    StringValue(source);\n    json->len = RSTRING_LEN(source);\n    json->source = RSTRING_PTR(source);;\n    json->Vsource = source;\n    return self;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147211,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "GIT_INLINE(bool) only_spaces_and_dots(const char *path)\n{\n\tconst char *c = path;\n\n\tfor (;; c++) {\n\t\tif (*c == '\\0')\n\t\t\treturn true;\n\t\tif (*c != ' ' && *c != '.')\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147286,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "GIT_INLINE(bool) only_spaces_and_dots(const char *path)\n{\n\tconst char *c = path;\n\n\tfor (;; c++) {\n\t\tif (*c == '\\0' || *c == ':')\n\t\t\treturn true;\n\t\tif (*c != ' ' && *c != '.')\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147287,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "process_rs(struct Interface *iface, unsigned char *msg, int len,\n\tstruct sockaddr_in6 *addr)\n{\n\tdouble delay;\n\tdouble next;\n\tstruct timeval tv;\n\tuint8_t *opt_str;\n\n\t/* validation */\n\tlen -= sizeof(struct nd_router_solicit);\n\n\topt_str = (uint8_t *)(msg + sizeof(struct nd_router_solicit));\n\n\twhile (len > 0)\n\t{\n\t\tint optlen;\n\n\t\tif (len < 2)\n\t\t{\n\t\t\tflog(LOG_WARNING, \"trailing garbage in RS\");\n\t\t\treturn;\n\t\t}\n\n\t\toptlen = (opt_str[1] << 3);\n\n\t\tif (optlen == 0)\n\t\t{\n\t\t\tflog(LOG_WARNING, \"zero length option in RS\");\n\t\t\treturn;\n\t\t}\n\t\telse if (optlen > len)\n\t\t{\n\t\t\tflog(LOG_WARNING, \"option length greater than total length in RS\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (*opt_str == ND_OPT_SOURCE_LINKADDR &&\n\t\t    IN6_IS_ADDR_UNSPECIFIED(&addr->sin6_addr)) {\n\t\t\tflog(LOG_WARNING, \"received icmpv6 RS packet with unspecified source address and there is a lladdr option\");\n\t\t\treturn;\n\t\t}\n\n\t\tlen -= optlen;\n\t\topt_str += optlen;\n\t}\n\n\tgettimeofday(&tv, NULL);\n\n\tdelay = MAX_RA_DELAY_TIME * rand() / (RAND_MAX +1.0);\n\n\tif (iface->UnicastOnly) {\n\t\tdlog(LOG_DEBUG, 5, \"random mdelay for %s: %g seconds.\", iface->Name, delay/1000.0);\n\t\tmdelay(delay);\n\t\tsend_ra_forall(iface, &addr->sin6_addr);\n\t}\n\telse if ( timevaldiff(&tv, &iface->last_multicast) / 1000.0 < iface->MinDelayBetweenRAs ) {\n\t\t/* last RA was sent only a few moments ago, don't send another immediately. */\n\t\tnext = iface->MinDelayBetweenRAs - (tv.tv_sec + tv.tv_usec / 1000000.0) + (iface->last_multicast.tv_sec + iface->last_multicast.tv_usec / 1000000.0) + delay/1000.0;\n\t\tiface->next_multicast = next_timeval(next);\n\t}\n\telse {\n\t\t/* no RA sent in a while, send a multicast reply */\n\t\tsend_ra_forall(iface, NULL);\n\t\tnext = rand_between(iface->MinRtrAdvInterval, iface->MaxRtrAdvInterval);\n\t\tiface->next_multicast = next_timeval(next);\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147288,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "process_rs(struct Interface *iface, unsigned char *msg, int len,\n\tstruct sockaddr_in6 *addr)\n{\n\tdouble delay;\n\tdouble next;\n\tstruct timeval tv;\n\tuint8_t *opt_str;\n\n\t/* validation */\n\tlen -= sizeof(struct nd_router_solicit);\n\n\topt_str = (uint8_t *)(msg + sizeof(struct nd_router_solicit));\n\n\twhile (len > 0)\n\t{\n\t\tint optlen;\n\n\t\tif (len < 2)\n\t\t{\n\t\t\tflog(LOG_WARNING, \"trailing garbage in RS\");\n\t\t\treturn;\n\t\t}\n\n\t\toptlen = (opt_str[1] << 3);\n\n\t\tif (optlen == 0)\n\t\t{\n\t\t\tflog(LOG_WARNING, \"zero length option in RS\");\n\t\t\treturn;\n\t\t}\n\t\telse if (optlen > len)\n\t\t{\n\t\t\tflog(LOG_WARNING, \"option length greater than total length in RS\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (*opt_str == ND_OPT_SOURCE_LINKADDR &&\n\t\t    IN6_IS_ADDR_UNSPECIFIED(&addr->sin6_addr)) {\n\t\t\tflog(LOG_WARNING, \"received icmpv6 RS packet with unspecified source address and there is a lladdr option\");\n\t\t\treturn;\n\t\t}\n\n\t\tlen -= optlen;\n\t\topt_str += optlen;\n\t}\n\n\tgettimeofday(&tv, NULL);\n\n\tdelay = MAX_RA_DELAY_TIME * rand() / (RAND_MAX +1.0);\n\n\tif (iface->UnicastOnly) {\n\t\tsend_ra_forall(iface, &addr->sin6_addr);\n\t}\n\telse if ( timevaldiff(&tv, &iface->last_multicast) / 1000.0 < iface->MinDelayBetweenRAs ) {\n\t\t/* last RA was sent only a few moments ago, don't send another immediately. */\n\t\tnext = iface->MinDelayBetweenRAs - (tv.tv_sec + tv.tv_usec / 1000000.0) + (iface->last_multicast.tv_sec + iface->last_multicast.tv_usec / 1000000.0) + delay/1000.0;\n\t\tiface->next_multicast = next_timeval(next);\n\t}\n\telse {\n\t\t/* no RA sent in a while, send a multicast reply */\n\t\tsend_ra_forall(iface, NULL);\n\t\tnext = rand_between(iface->MinRtrAdvInterval, iface->MaxRtrAdvInterval);\n\t\tiface->next_multicast = next_timeval(next);\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147289,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "end_element(PInfo pi, const char *ename) {\n    if (TRACE <= pi->options->trace) {\n\tchar\tindent[128];\n\t\n\tif (DEBUG <= pi->options->trace) {\n\t    char    buf[1024];\n\n\t    printf(\"===== end element stack(%d) =====\\n\", helper_stack_depth(&pi->helpers));\n\t    snprintf(buf, sizeof(buf) - 1, \"</%s>\", ename);\n\t    debug_stack(pi, buf);\n\t} else {\n\t    fill_indent(pi, indent, sizeof(indent));\n\t    printf(\"%s</%s>\\n\", indent, ename);\n\t}\n    }\n    if (!helper_stack_empty(&pi->helpers)) {\n\tHelper\th = helper_stack_pop(&pi->helpers);\n\tHelper\tph = helper_stack_peek(&pi->helpers);\n\n\tif (ox_empty_string == h->obj) {\n\t    /* special catch for empty strings */\n\t    h->obj = rb_str_new2(\"\");\n\t}\n\tpi->obj = h->obj;\n\tif (0 != ph) {\n\t    switch (ph->type) {\n\t    case ArrayCode:\n\t\trb_ary_push(ph->obj, h->obj);\n\t\tbreak;\n\t    case ExceptionCode:\n\t    case ObjectCode:\n\t\tif (Qnil != ph->obj) {\n\t\t    rb_ivar_set(ph->obj, h->var, h->obj);\n\t\t}\n\t\tbreak;\n\t    case StructCode:\n#if HAS_RSTRUCT\n\t\trb_struct_aset(ph->obj, h->var, h->obj);\n#else\n\t\tset_error(&pi->err, \"Ruby structs not supported with this verion of Ruby\", pi->str, pi->s);\n\t\treturn;\n#endif\n\t\tbreak;\n\t    case HashCode:\n\t\t// put back h\n\t\thelper_stack_push(&pi->helpers, h->var, h->obj, KeyCode);\n\t\tbreak;\n\t    case RangeCode:\n#if HAS_RSTRUCT\n\t\tif (ox_beg_id == h->var) {\n\t\t    RSTRUCT_SET(ph->obj, 0, h->obj);\n\t\t} else if (ox_end_id == h->var) {\n\t\t    RSTRUCT_SET(ph->obj, 1, h->obj);\n\t\t} else if (ox_excl_id == h->var) {\n\t\t    RSTRUCT_SET(ph->obj, 2, h->obj);\n\t\t} else {\n\t\t    set_error(&pi->err, \"Invalid range attribute\", pi->str, pi->s);\n\t\t    return;\n\t\t}\n#else\n\t\tset_error(&pi->err, \"Ruby structs not supported with this verion of Ruby\", pi->str, pi->s);\n\t\treturn;\n#endif\n\t\tbreak;\n\t    case KeyCode:\n\t\t{\n\t\t    Helper\tgh;\n\n\t\t    helper_stack_pop(&pi->helpers);\n\t\t    gh = helper_stack_peek(&pi->helpers);\n\n\t\t    rb_hash_aset(gh->obj, ph->obj, h->obj);\n\t\t}\n\t\tbreak;\n\t    case ComplexCode:\n#ifdef T_COMPLEX\n\t\tif (Qundef == ph->obj) {\n\t\t    ph->obj = h->obj;\n\t\t} else {\n\t\t    ph->obj = rb_complex_new(ph->obj, h->obj);\n\t\t}\n#else\n\t\tset_error(&pi->err, \"Complex Objects not implemented in Ruby 1.8.7\", pi->str, pi->s);\n\t\treturn;\n#endif\n\t\tbreak;\n\t    case RationalCode:\n#ifdef T_RATIONAL\n\t\tif (Qundef == ph->obj) {\n\t\t    ph->obj = h->obj;\n\t\t} else {\n#ifdef RUBINIUS_RUBY\n\t\t    ph->obj = rb_Rational(ph->obj, h->obj);\n#else\n\t\t    ph->obj = rb_rational_new(ph->obj, h->obj);\n#endif\n\t\t}\n#else\n\t\tset_error(&pi->err, \"Rational Objects not implemented in Ruby 1.8.7\", pi->str, pi->s);\n\t\treturn;\n#endif\n\t\tbreak;\n\t    default:\n\t\tset_error(&pi->err, \"Corrupt parse stack, container is wrong type\", pi->str, pi->s);\n\t\treturn;\n\t\tbreak;\n\t    }\n\t}\n    }\n    if (0 != pi->circ_array && helper_stack_empty(&pi->helpers)) {\n\tcirc_array_free(pi->circ_array);\n\tpi->circ_array = 0;\n    }\n    if (DEBUG <= pi->options->trace) {\n\tdebug_stack(pi, \"   ----------\");\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147292,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "end_element(PInfo pi, const char *ename) {\n    if (TRACE <= pi->options->trace) {\n\tchar\tindent[128];\n\t\n\tif (DEBUG <= pi->options->trace) {\n\t    char    buf[1024];\n\n\t    printf(\"===== end element stack(%d) =====\\n\", helper_stack_depth(&pi->helpers));\n\t    snprintf(buf, sizeof(buf) - 1, \"</%s>\", ename);\n\t    debug_stack(pi, buf);\n\t} else {\n\t    fill_indent(pi, indent, sizeof(indent));\n\t    printf(\"%s</%s>\\n\", indent, ename);\n\t}\n    }\n    if (!helper_stack_empty(&pi->helpers)) {\n\tHelper\th = helper_stack_pop(&pi->helpers);\n\tHelper\tph = helper_stack_peek(&pi->helpers);\n\n\tif (ox_empty_string == h->obj) {\n\t    /* special catch for empty strings */\n\t    h->obj = rb_str_new2(\"\");\n\t}\n\tpi->obj = h->obj;\n\tif (0 != ph) {\n\t    switch (ph->type) {\n\t    case ArrayCode:\n\t\trb_ary_push(ph->obj, h->obj);\n\t\tbreak;\n\t    case ExceptionCode:\n\t    case ObjectCode:\n\t\tif (Qnil != ph->obj) {\n\t\t    rb_ivar_set(ph->obj, h->var, h->obj);\n\t\t}\n\t\tbreak;\n\t    case StructCode:\n#if HAS_RSTRUCT\n\t\trb_struct_aset(ph->obj, h->var, h->obj);\n#else\n\t\tset_error(&pi->err, \"Ruby structs not supported with this verion of Ruby\", pi->str, pi->s);\n\t\treturn;\n#endif\n\t\tbreak;\n\t    case HashCode:\n\t\t// put back h\n\t\thelper_stack_push(&pi->helpers, h->var, h->obj, KeyCode);\n\t\tbreak;\n\t    case RangeCode:\n#if HAS_RSTRUCT\n\t\tif (ox_beg_id == h->var) {\n\t\t    RSTRUCT_SET(ph->obj, 0, h->obj);\n\t\t} else if (ox_end_id == h->var) {\n\t\t    RSTRUCT_SET(ph->obj, 1, h->obj);\n\t\t} else if (ox_excl_id == h->var) {\n\t\t    RSTRUCT_SET(ph->obj, 2, h->obj);\n\t\t} else {\n\t\t    set_error(&pi->err, \"Invalid range attribute\", pi->str, pi->s);\n\t\t    return;\n\t\t}\n#else\n\t\tset_error(&pi->err, \"Ruby structs not supported with this verion of Ruby\", pi->str, pi->s);\n\t\treturn;\n#endif\n\t\tbreak;\n\t    case KeyCode:\n\t\t{\n\t\t    Helper\tgh;\n\n\t\t    helper_stack_pop(&pi->helpers);\n\t\t    if (NULL == (gh = helper_stack_peek(&pi->helpers))) {\n\t\t\tset_error(&pi->err, \"Corrupt parse stack, container is wrong type\", pi->str, pi->s);\n\t\t\treturn;\n\t\t    }\n\t\t    rb_hash_aset(gh->obj, ph->obj, h->obj);\n\t\t}\n\t\tbreak;\n\t    case ComplexCode:\n#ifdef T_COMPLEX\n\t\tif (Qundef == ph->obj) {\n\t\t    ph->obj = h->obj;\n\t\t} else {\n\t\t    ph->obj = rb_complex_new(ph->obj, h->obj);\n\t\t}\n#else\n\t\tset_error(&pi->err, \"Complex Objects not implemented in Ruby 1.8.7\", pi->str, pi->s);\n\t\treturn;\n#endif\n\t\tbreak;\n\t    case RationalCode:\n#ifdef T_RATIONAL\n\t\tif (Qundef == ph->obj) {\n\t\t    ph->obj = h->obj;\n\t\t} else {\n#ifdef RUBINIUS_RUBY\n\t\t    ph->obj = rb_Rational(ph->obj, h->obj);\n#else\n\t\t    ph->obj = rb_rational_new(ph->obj, h->obj);\n#endif\n\t\t}\n#else\n\t\tset_error(&pi->err, \"Rational Objects not implemented in Ruby 1.8.7\", pi->str, pi->s);\n\t\treturn;\n#endif\n\t\tbreak;\n\t    default:\n\t\tset_error(&pi->err, \"Corrupt parse stack, container is wrong type\", pi->str, pi->s);\n\t\treturn;\n\t\tbreak;\n\t    }\n\t}\n    }\n    if (0 != pi->circ_array && helper_stack_empty(&pi->helpers)) {\n\tcirc_array_free(pi->circ_array);\n\tpi->circ_array = 0;\n    }\n    if (DEBUG <= pi->options->trace) {\n\tdebug_stack(pi, \"   ----------\");\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147293,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "hook_process_child (struct t_hook *hook_process)\n{\n    char *exec_args[4] = { \"sh\", \"-c\", NULL, NULL };\n    const char *ptr_url;\n    int rc;\n\n    /*\n     * close stdin, so that process will fail to read stdin (process reading\n     * stdin should not be run inside WeeChat!)\n     */\n    close (STDIN_FILENO);\n\n    /* redirect stdout/stderr to pipe (so that father process can read them) */\n    close (HOOK_PROCESS(hook_process, child_read[HOOK_PROCESS_STDOUT]));\n    close (HOOK_PROCESS(hook_process, child_read[HOOK_PROCESS_STDERR]));\n    if (dup2 (HOOK_PROCESS(hook_process, child_write[HOOK_PROCESS_STDOUT]),\n              STDOUT_FILENO) < 0)\n    {\n        _exit (EXIT_FAILURE);\n    }\n    if (dup2 (HOOK_PROCESS(hook_process, child_write[HOOK_PROCESS_STDERR]),\n              STDERR_FILENO) < 0)\n    {\n        _exit (EXIT_FAILURE);\n    }\n\n    rc = EXIT_SUCCESS;\n\n    if (strncmp (HOOK_PROCESS(hook_process, command), \"url:\", 4) == 0)\n    {\n        /* get URL output (on stdout or file, depending on options) */\n        ptr_url = HOOK_PROCESS(hook_process, command) + 4;\n        while (ptr_url[0] == ' ')\n        {\n            ptr_url++;\n        }\n        rc = weeurl_download (ptr_url, HOOK_PROCESS(hook_process, options));\n        if (rc != 0)\n            fprintf (stderr, \"Error with URL '%s'\\n\", ptr_url);\n    }\n    else\n    {\n        /* launch command */\n        exec_args[2] = HOOK_PROCESS(hook_process, command);\n        execvp (exec_args[0], exec_args);\n\n        /* should not be executed if execvp was ok */\n        fprintf (stderr, \"Error with command '%s'\\n\",\n                 HOOK_PROCESS(hook_process, command));\n        rc = EXIT_FAILURE;\n    }\n\n    fflush (stdout);\n    fflush (stderr);\n\n    _exit (rc);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147308,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "hook_process_child (struct t_hook *hook_process)\n{\n    char **exec_args;\n    const char *ptr_url;\n    int rc, i;\n\n    /*\n     * close stdin, so that process will fail to read stdin (process reading\n     * stdin should not be run inside WeeChat!)\n     */\n    close (STDIN_FILENO);\n\n    /* redirect stdout/stderr to pipe (so that father process can read them) */\n    close (HOOK_PROCESS(hook_process, child_read[HOOK_PROCESS_STDOUT]));\n    close (HOOK_PROCESS(hook_process, child_read[HOOK_PROCESS_STDERR]));\n    if (dup2 (HOOK_PROCESS(hook_process, child_write[HOOK_PROCESS_STDOUT]),\n              STDOUT_FILENO) < 0)\n    {\n        _exit (EXIT_FAILURE);\n    }\n    if (dup2 (HOOK_PROCESS(hook_process, child_write[HOOK_PROCESS_STDERR]),\n              STDERR_FILENO) < 0)\n    {\n        _exit (EXIT_FAILURE);\n    }\n\n    rc = EXIT_SUCCESS;\n\n    if (strncmp (HOOK_PROCESS(hook_process, command), \"url:\", 4) == 0)\n    {\n        /* get URL output (on stdout or file, depending on options) */\n        ptr_url = HOOK_PROCESS(hook_process, command) + 4;\n        while (ptr_url[0] == ' ')\n        {\n            ptr_url++;\n        }\n        rc = weeurl_download (ptr_url, HOOK_PROCESS(hook_process, options));\n        if (rc != 0)\n            fprintf (stderr, \"Error with URL '%s'\\n\", ptr_url);\n    }\n    else\n    {\n        /* launch command */\n        exec_args = string_split_shell (HOOK_PROCESS(hook_process, command));\n        if (exec_args)\n        {\n            if (weechat_debug_core >= 1)\n            {\n                log_printf (\"hook_process, command='%s'\",\n                            HOOK_PROCESS(hook_process, command));\n                for (i = 0; exec_args[i]; i++)\n                {\n                    log_printf (\"  args[%02d] == '%s'\", i, exec_args[i]);\n                }\n            }\n            execvp (exec_args[0], exec_args);\n        }\n\n        /* should not be executed if execvp was ok */\n        if (exec_args)\n            string_free_split (exec_args);\n        fprintf (stderr, \"Error with command '%s'\\n\",\n                 HOOK_PROCESS(hook_process, command));\n        rc = EXIT_FAILURE;\n    }\n\n    fflush (stdout);\n    fflush (stderr);\n\n    _exit (rc);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147309,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void show_opcodes(u8 *rip, const char *loglvl)\n{\n#define PROLOGUE_SIZE 42\n#define EPILOGUE_SIZE 21\n#define OPCODE_BUFSIZE (PROLOGUE_SIZE + 1 + EPILOGUE_SIZE)\n\tu8 opcodes[OPCODE_BUFSIZE];\n\n\tif (probe_kernel_read(opcodes, rip - PROLOGUE_SIZE, OPCODE_BUFSIZE)) {\n\t\tprintk(\"%sCode: Bad RIP value.\\n\", loglvl);\n\t} else {\n\t\tprintk(\"%sCode: %\" __stringify(PROLOGUE_SIZE) \"ph <%02x> %\"\n\t\t       __stringify(EPILOGUE_SIZE) \"ph\\n\", loglvl, opcodes,\n\t\t       opcodes[PROLOGUE_SIZE], opcodes + PROLOGUE_SIZE + 1);\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147342,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void show_opcodes(struct pt_regs *regs, const char *loglvl)\n{\n#define PROLOGUE_SIZE 42\n#define EPILOGUE_SIZE 21\n#define OPCODE_BUFSIZE (PROLOGUE_SIZE + 1 + EPILOGUE_SIZE)\n\tu8 opcodes[OPCODE_BUFSIZE];\n\tunsigned long prologue = regs->ip - PROLOGUE_SIZE;\n\tbool bad_ip;\n\n\t/*\n\t * Make sure userspace isn't trying to trick us into dumping kernel\n\t * memory by pointing the userspace instruction pointer at it.\n\t */\n\tbad_ip = user_mode(regs) &&\n\t\t__chk_range_not_ok(prologue, OPCODE_BUFSIZE, TASK_SIZE_MAX);\n\n\tif (bad_ip || probe_kernel_read(opcodes, (u8 *)prologue,\n\t\t\t\t\tOPCODE_BUFSIZE)) {\n\t\tprintk(\"%sCode: Bad RIP value.\\n\", loglvl);\n\t} else {\n\t\tprintk(\"%sCode: %\" __stringify(PROLOGUE_SIZE) \"ph <%02x> %\"\n\t\t       __stringify(EPILOGUE_SIZE) \"ph\\n\", loglvl, opcodes,\n\t\t       opcodes[PROLOGUE_SIZE], opcodes + PROLOGUE_SIZE + 1);\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147343,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "file_printable(char *buf, size_t bufsiz, const char *str)\n{\n\tchar *ptr, *eptr;\n\tconst unsigned char *s = (const unsigned char *)str;\n\n\tfor (ptr = buf, eptr = ptr + bufsiz - 1; ptr < eptr && *s; s++) {\n\t\tif (isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr + 4)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((*s >> 6) & 7) + '0';\n\t\t*ptr++ = ((*s >> 3) & 7) + '0';\n\t\t*ptr++ = ((*s >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147424,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "file_printable(char *buf, size_t bufsiz, const char *str)\n{\n\tchar *ptr, *eptr;\n\tconst unsigned char *s = (const unsigned char *)str;\n\n\tfor (ptr = buf, eptr = ptr + bufsiz - 1; ptr < eptr && *s; s++) {\n\t\tif (isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((*s >> 6) & 7) + '0';\n\t\t*ptr++ = ((*s >> 3) & 7) + '0';\n\t\t*ptr++ = ((*s >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147425,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "            Status readUTF8String( StringData* out ) {\n                int sz;\n                if ( !readNumber<int>( &sz ) )\n                    return Status( ErrorCodes::InvalidBSON, \"invalid bson\" );\n\n                if ( out ) {\n                    *out = StringData( _buffer + _position, sz );\n                }\n\n                if ( !skip( sz - 1 ) )\n                    return Status( ErrorCodes::InvalidBSON, \"invalid bson\" );\n\n                char c;\n                if ( !readNumber<char>( &c ) )\n                    return Status( ErrorCodes::InvalidBSON, \"invalid bson\" );\n\n                if ( c != 0 )\n                    return Status( ErrorCodes::InvalidBSON, \"not null terminate string\" );\n\n                return Status::OK();\n            }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147440,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "            Status readUTF8String( StringData* out ) {\n                int sz;\n                if ( !readNumber<int>( &sz ) )\n                    return Status( ErrorCodes::InvalidBSON, \"invalid bson\" );\n\n                if ( sz <= 0 ) {\n                    // must have NULL at the very least\n                    return Status( ErrorCodes::InvalidBSON, \"invalid bson\");\n                }\n\n                if ( out ) {\n                    *out = StringData( _buffer + _position, sz );\n                }\n\n                if ( !skip( sz - 1 ) )\n                    return Status( ErrorCodes::InvalidBSON, \"invalid bson\" );\n\n                char c;\n                if ( !readNumber<char>( &c ) )\n                    return Status( ErrorCodes::InvalidBSON, \"invalid bson\" );\n\n                if ( c != 0 )\n                    return Status( ErrorCodes::InvalidBSON, \"not null terminate string\" );\n\n                return Status::OK();\n            }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147441,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "_g_file_remove_directory (GFile         *directory,\n\t\t\t  GCancellable  *cancellable,\n\t\t\t  GError       **error)\n{\n\tGFileEnumerator *enumerator;\n\tGFileInfo       *info;\n\tgboolean         error_occurred = FALSE;\n\n\tif (directory == NULL)\n\t\treturn TRUE;\n\n\tenumerator = g_file_enumerate_children (directory,\n\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_NAME \",\"\n\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_TYPE,\n\t\t\t\t\t        0,\n\t\t\t\t\t        cancellable,\n\t\t\t\t\t        error);\n\n\twhile (! error_occurred && (info = g_file_enumerator_next_file (enumerator, cancellable, error)) != NULL) {\n\t\tGFile *child;\n\n\t\tchild = g_file_get_child (directory, g_file_info_get_name (info));\n\t\tswitch (g_file_info_get_file_type (info)) {\n\t\tcase G_FILE_TYPE_DIRECTORY:\n\t\t\tif (! _g_file_remove_directory (child, cancellable, error))\n\t\t\t\terror_occurred = TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (! g_file_delete (child, cancellable, error))\n\t\t\t\terror_occurred = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tg_object_unref (child);\n\t\tg_object_unref (info);\n\t}\n\n\tif (! error_occurred && ! g_file_delete (directory, cancellable, error))\n \t\terror_occurred = TRUE;\n\n\tg_object_unref (enumerator);\n\n\treturn ! error_occurred;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147444,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "_g_file_remove_directory (GFile         *directory,\n\t\t\t  GCancellable  *cancellable,\n\t\t\t  GError       **error)\n{\n\tGFileEnumerator *enumerator;\n\tGFileInfo       *info;\n\tgboolean         error_occurred = FALSE;\n\n\tif (directory == NULL)\n\t\treturn TRUE;\n\n\tenumerator = g_file_enumerate_children (directory,\n\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_TYPE,\n\t\t\t\t\t\tG_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t\t        cancellable,\n\t\t\t\t\t        error);\n\n\twhile (! error_occurred && (info = g_file_enumerator_next_file (enumerator, cancellable, error)) != NULL) {\n\t\tGFile *child;\n\n\t\tchild = g_file_get_child (directory, g_file_info_get_name (info));\n\t\tswitch (g_file_info_get_file_type (info)) {\n\t\tcase G_FILE_TYPE_DIRECTORY:\n\t\t\tif (! _g_file_remove_directory (child, cancellable, error))\n\t\t\t\terror_occurred = TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (! g_file_delete (child, cancellable, error))\n\t\t\t\terror_occurred = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tg_object_unref (child);\n\t\tg_object_unref (info);\n\t}\n\n\tif (! error_occurred && ! g_file_delete (directory, cancellable, error))\n \t\terror_occurred = TRUE;\n\n\tg_object_unref (enumerator);\n\n\treturn ! error_occurred;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147445,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "FileSpec::FileSpec(const Object *fileSpecA)\n{\n  ok = true;\n  fileName = nullptr;\n  platformFileName = nullptr;\n  embFile = nullptr;\n  desc = nullptr;\n  fileSpec = fileSpecA->copy();\n\n  Object obj1 = getFileSpecName(fileSpecA);\n  if (!obj1.isString()) {\n    ok = false;\n    error(errSyntaxError, -1, \"Invalid FileSpec\");\n    return;\n  }\n\n  fileName = obj1.getString()->copy();\n\n  if (fileSpec.isDict()) {\n    obj1 = fileSpec.dictLookup(\"EF\");\n    if (obj1.isDict()) {\n      fileStream = obj1.dictLookupNF(\"F\");\n      if (!fileStream.isRef()) {\n        ok = false;\n        fileStream.setToNull();\n        error(errSyntaxError, -1, \"Invalid FileSpec: Embedded file stream is not an indirect reference\");\n        return;\n      }\n    }\n  }\n\n  obj1 = fileSpec.dictLookup(\"Desc\");\n  if (obj1.isString())\n    desc = obj1.getString()->copy();\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147462,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "FileSpec::FileSpec(const Object *fileSpecA)\n{\n  ok = true;\n  fileName = nullptr;\n  platformFileName = nullptr;\n  embFile = nullptr;\n  desc = nullptr;\n  fileSpec = fileSpecA->copy();\n\n  Object obj1 = getFileSpecName(fileSpecA);\n  if (!obj1.isString()) {\n    ok = false;\n    error(errSyntaxError, -1, \"Invalid FileSpec\");\n    return;\n  }\n\n  fileName = obj1.getString()->copy();\n\n  if (fileSpec.isDict()) {\n    obj1 = fileSpec.dictLookup(\"EF\");\n    if (obj1.isDict()) {\n      fileStream = obj1.dictLookupNF(\"F\");\n      if (!fileStream.isRef()) {\n        ok = false;\n        fileStream.setToNull();\n        error(errSyntaxError, -1, \"Invalid FileSpec: Embedded file stream is not an indirect reference\");\n        return;\n      }\n    }\n\n    obj1 = fileSpec.dictLookup(\"Desc\");\n    if (obj1.isString()) {\n      desc = obj1.getString()->copy();\n    }\n  }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147463,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "setup_seccomp (FlatpakBwrap   *bwrap,\n               const char     *arch,\n               gulong          allowed_personality,\n               FlatpakRunFlags run_flags,\n               GError        **error)\n{\n  gboolean multiarch = (run_flags & FLATPAK_RUN_FLAG_MULTIARCH) != 0;\n  gboolean devel = (run_flags & FLATPAK_RUN_FLAG_DEVEL) != 0;\n\n  __attribute__((cleanup (cleanup_seccomp))) scmp_filter_ctx seccomp = NULL;\n\n  /**** BEGIN NOTE ON CODE SHARING\n   *\n   * There are today a number of different Linux container\n   * implementations.  That will likely continue for long into the\n   * future.  But we can still try to share code, and it's important\n   * to do so because it affects what library and application writers\n   * can do, and we should support code portability between different\n   * container tools.\n   *\n   * This syscall blacklist is copied from linux-user-chroot, which was in turn\n   * clearly influenced by the Sandstorm.io blacklist.\n   *\n   * If you make any changes here, I suggest sending the changes along\n   * to other sandbox maintainers.  Using the libseccomp list is also\n   * an appropriate venue:\n   * https://groups.google.com/forum/#!topic/libseccomp\n   *\n   * A non-exhaustive list of links to container tooling that might\n   * want to share this blacklist:\n   *\n   *  https://github.com/sandstorm-io/sandstorm\n   *    in src/sandstorm/supervisor.c++\n   *  https://github.com/flatpak/flatpak.git\n   *    in common/flatpak-run.c\n   *  https://git.gnome.org/browse/linux-user-chroot\n   *    in src/setup-seccomp.c\n   *\n   **** END NOTE ON CODE SHARING\n   */\n  struct\n  {\n    int                  scall;\n    struct scmp_arg_cmp *arg;\n  } syscall_blacklist[] = {\n    /* Block dmesg */\n    {SCMP_SYS (syslog)},\n    /* Useless old syscall */\n    {SCMP_SYS (uselib)},\n    /* Don't allow disabling accounting */\n    {SCMP_SYS (acct)},\n    /* 16-bit code is unnecessary in the sandbox, and modify_ldt is a\n       historic source of interesting information leaks. */\n    {SCMP_SYS (modify_ldt)},\n    /* Don't allow reading current quota use */\n    {SCMP_SYS (quotactl)},\n\n    /* Don't allow access to the kernel keyring */\n    {SCMP_SYS (add_key)},\n    {SCMP_SYS (keyctl)},\n    {SCMP_SYS (request_key)},\n\n    /* Scary VM/NUMA ops */\n    {SCMP_SYS (move_pages)},\n    {SCMP_SYS (mbind)},\n    {SCMP_SYS (get_mempolicy)},\n    {SCMP_SYS (set_mempolicy)},\n    {SCMP_SYS (migrate_pages)},\n\n    /* Don't allow subnamespace setups: */\n    {SCMP_SYS (unshare)},\n    {SCMP_SYS (mount)},\n    {SCMP_SYS (pivot_root)},\n    {SCMP_SYS (clone), &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n\n    /* Don't allow faking input to the controlling tty (CVE-2017-5226) */\n    {SCMP_SYS (ioctl), &SCMP_A1 (SCMP_CMP_EQ, (int) TIOCSTI)},\n  };\n\n  struct\n  {\n    int                  scall;\n    struct scmp_arg_cmp *arg;\n  } syscall_nondevel_blacklist[] = {\n    /* Profiling operations; we expect these to be done by tools from outside\n     * the sandbox.  In particular perf has been the source of many CVEs.\n     */\n    {SCMP_SYS (perf_event_open)},\n    /* Don't allow you to switch to bsd emulation or whatnot */\n    {SCMP_SYS (personality), &SCMP_A0 (SCMP_CMP_NE, allowed_personality)},\n    {SCMP_SYS (ptrace)}\n  };\n  /* Blacklist all but unix, inet, inet6 and netlink */\n  struct\n  {\n    int             family;\n    FlatpakRunFlags flags_mask;\n  } socket_family_whitelist[] = {\n    /* NOTE: Keep in numerical order */\n    { AF_UNSPEC, 0 },\n    { AF_LOCAL, 0 },\n    { AF_INET, 0 },\n    { AF_INET6, 0 },\n    { AF_NETLINK, 0 },\n    { AF_CAN, FLATPAK_RUN_FLAG_CANBUS },\n    { AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH },\n  };\n  int last_allowed_family;\n  int i, r;\n  g_auto(GLnxTmpfile) seccomp_tmpf  = { 0, };\n\n  seccomp = seccomp_init (SCMP_ACT_ALLOW);\n  if (!seccomp)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Initialize seccomp failed\"));\n\n  if (arch != NULL)\n    {\n      uint32_t arch_id = 0;\n      const uint32_t *extra_arches = NULL;\n\n      if (strcmp (arch, \"i386\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86;\n        }\n      else if (strcmp (arch, \"x86_64\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86_64;\n          extra_arches = seccomp_x86_64_extra_arches;\n        }\n      else if (strcmp (arch, \"arm\") == 0)\n        {\n          arch_id = SCMP_ARCH_ARM;\n        }\n#ifdef SCMP_ARCH_AARCH64\n      else if (strcmp (arch, \"aarch64\") == 0)\n        {\n          arch_id = SCMP_ARCH_AARCH64;\n          extra_arches = seccomp_aarch64_extra_arches;\n        }\n#endif\n\n      /* We only really need to handle arches on multiarch systems.\n       * If only one arch is supported the default is fine */\n      if (arch_id != 0)\n        {\n          /* This *adds* the target arch, instead of replacing the\n             native one. This is not ideal, because we'd like to only\n             allow the target arch, but we can't really disallow the\n             native arch at this point, because then bubblewrap\n             couldn't continue running. */\n          r = seccomp_arch_add (seccomp, arch_id);\n          if (r < 0 && r != -EEXIST)\n            return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add architecture to seccomp filter\"));\n\n          if (multiarch && extra_arches != NULL)\n            {\n              unsigned i;\n              for (i = 0; extra_arches[i] != 0; i++)\n                {\n                  r = seccomp_arch_add (seccomp, extra_arches[i]);\n                  if (r < 0 && r != -EEXIST)\n                    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add multiarch architecture to seccomp filter\"));\n                }\n            }\n        }\n    }\n\n  /* TODO: Should we filter the kernel keyring syscalls in some way?\n   * We do want them to be used by desktop apps, but they could also perhaps\n   * leak system stuff or secrets from other apps.\n   */\n\n  for (i = 0; i < G_N_ELEMENTS (syscall_blacklist); i++)\n    {\n      int scall = syscall_blacklist[i].scall;\n      if (syscall_blacklist[i].arg)\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 1, *syscall_blacklist[i].arg);\n      else\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);\n      if (r < 0 && r == -EFAULT /* unknown syscall */)\n        return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n    }\n\n  if (!devel)\n    {\n      for (i = 0; i < G_N_ELEMENTS (syscall_nondevel_blacklist); i++)\n        {\n          int scall = syscall_nondevel_blacklist[i].scall;\n          if (syscall_nondevel_blacklist[i].arg)\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 1, *syscall_nondevel_blacklist[i].arg);\n          else\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);\n\n          if (r < 0 && r == -EFAULT /* unknown syscall */)\n            return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n        }\n    }\n\n  /* Socket filtering doesn't work on e.g. i386, so ignore failures here\n   * However, we need to user seccomp_rule_add_exact to avoid libseccomp doing\n   * something else: https://github.com/seccomp/libseccomp/issues/8 */\n  last_allowed_family = -1;\n  for (i = 0; i < G_N_ELEMENTS (socket_family_whitelist); i++)\n    {\n      int family = socket_family_whitelist[i].family;\n      int disallowed;\n\n      if (socket_family_whitelist[i].flags_mask != 0 &&\n          (socket_family_whitelist[i].flags_mask & run_flags) != socket_family_whitelist[i].flags_mask)\n        continue;\n\n      for (disallowed = last_allowed_family + 1; disallowed < family; disallowed++)\n        {\n          /* Blacklist the in-between valid families */\n          seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, disallowed));\n        }\n      last_allowed_family = family;\n    }\n  /* Blacklist the rest */\n  seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE, last_allowed_family + 1));\n\n  if (!glnx_open_anonymous_tmpfile (O_RDWR | O_CLOEXEC, &seccomp_tmpf, error))\n    return FALSE;\n\n  if (seccomp_export_bpf (seccomp, seccomp_tmpf.fd) != 0)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to export bpf\"));\n\n  lseek (seccomp_tmpf.fd, 0, SEEK_SET);\n\n  flatpak_bwrap_add_args_data_fd (bwrap,\n                                  \"--seccomp\", glnx_steal_fd (&seccomp_tmpf.fd), NULL);\n\n  return TRUE;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147480,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "setup_seccomp (FlatpakBwrap   *bwrap,\n               const char     *arch,\n               gulong          allowed_personality,\n               FlatpakRunFlags run_flags,\n               GError        **error)\n{\n  gboolean multiarch = (run_flags & FLATPAK_RUN_FLAG_MULTIARCH) != 0;\n  gboolean devel = (run_flags & FLATPAK_RUN_FLAG_DEVEL) != 0;\n\n  __attribute__((cleanup (cleanup_seccomp))) scmp_filter_ctx seccomp = NULL;\n\n  /**** BEGIN NOTE ON CODE SHARING\n   *\n   * There are today a number of different Linux container\n   * implementations.  That will likely continue for long into the\n   * future.  But we can still try to share code, and it's important\n   * to do so because it affects what library and application writers\n   * can do, and we should support code portability between different\n   * container tools.\n   *\n   * This syscall blacklist is copied from linux-user-chroot, which was in turn\n   * clearly influenced by the Sandstorm.io blacklist.\n   *\n   * If you make any changes here, I suggest sending the changes along\n   * to other sandbox maintainers.  Using the libseccomp list is also\n   * an appropriate venue:\n   * https://groups.google.com/forum/#!topic/libseccomp\n   *\n   * A non-exhaustive list of links to container tooling that might\n   * want to share this blacklist:\n   *\n   *  https://github.com/sandstorm-io/sandstorm\n   *    in src/sandstorm/supervisor.c++\n   *  https://github.com/flatpak/flatpak.git\n   *    in common/flatpak-run.c\n   *  https://git.gnome.org/browse/linux-user-chroot\n   *    in src/setup-seccomp.c\n   *\n   **** END NOTE ON CODE SHARING\n   */\n  struct\n  {\n    int                  scall;\n    struct scmp_arg_cmp *arg;\n  } syscall_blacklist[] = {\n    /* Block dmesg */\n    {SCMP_SYS (syslog)},\n    /* Useless old syscall */\n    {SCMP_SYS (uselib)},\n    /* Don't allow disabling accounting */\n    {SCMP_SYS (acct)},\n    /* 16-bit code is unnecessary in the sandbox, and modify_ldt is a\n       historic source of interesting information leaks. */\n    {SCMP_SYS (modify_ldt)},\n    /* Don't allow reading current quota use */\n    {SCMP_SYS (quotactl)},\n\n    /* Don't allow access to the kernel keyring */\n    {SCMP_SYS (add_key)},\n    {SCMP_SYS (keyctl)},\n    {SCMP_SYS (request_key)},\n\n    /* Scary VM/NUMA ops */\n    {SCMP_SYS (move_pages)},\n    {SCMP_SYS (mbind)},\n    {SCMP_SYS (get_mempolicy)},\n    {SCMP_SYS (set_mempolicy)},\n    {SCMP_SYS (migrate_pages)},\n\n    /* Don't allow subnamespace setups: */\n    {SCMP_SYS (unshare)},\n    {SCMP_SYS (mount)},\n    {SCMP_SYS (pivot_root)},\n    {SCMP_SYS (clone), &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n\n    /* Don't allow faking input to the controlling tty (CVE-2017-5226) */\n    {SCMP_SYS (ioctl), &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)},\n  };\n\n  struct\n  {\n    int                  scall;\n    struct scmp_arg_cmp *arg;\n  } syscall_nondevel_blacklist[] = {\n    /* Profiling operations; we expect these to be done by tools from outside\n     * the sandbox.  In particular perf has been the source of many CVEs.\n     */\n    {SCMP_SYS (perf_event_open)},\n    /* Don't allow you to switch to bsd emulation or whatnot */\n    {SCMP_SYS (personality), &SCMP_A0 (SCMP_CMP_NE, allowed_personality)},\n    {SCMP_SYS (ptrace)}\n  };\n  /* Blacklist all but unix, inet, inet6 and netlink */\n  struct\n  {\n    int             family;\n    FlatpakRunFlags flags_mask;\n  } socket_family_whitelist[] = {\n    /* NOTE: Keep in numerical order */\n    { AF_UNSPEC, 0 },\n    { AF_LOCAL, 0 },\n    { AF_INET, 0 },\n    { AF_INET6, 0 },\n    { AF_NETLINK, 0 },\n    { AF_CAN, FLATPAK_RUN_FLAG_CANBUS },\n    { AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH },\n  };\n  int last_allowed_family;\n  int i, r;\n  g_auto(GLnxTmpfile) seccomp_tmpf  = { 0, };\n\n  seccomp = seccomp_init (SCMP_ACT_ALLOW);\n  if (!seccomp)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Initialize seccomp failed\"));\n\n  if (arch != NULL)\n    {\n      uint32_t arch_id = 0;\n      const uint32_t *extra_arches = NULL;\n\n      if (strcmp (arch, \"i386\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86;\n        }\n      else if (strcmp (arch, \"x86_64\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86_64;\n          extra_arches = seccomp_x86_64_extra_arches;\n        }\n      else if (strcmp (arch, \"arm\") == 0)\n        {\n          arch_id = SCMP_ARCH_ARM;\n        }\n#ifdef SCMP_ARCH_AARCH64\n      else if (strcmp (arch, \"aarch64\") == 0)\n        {\n          arch_id = SCMP_ARCH_AARCH64;\n          extra_arches = seccomp_aarch64_extra_arches;\n        }\n#endif\n\n      /* We only really need to handle arches on multiarch systems.\n       * If only one arch is supported the default is fine */\n      if (arch_id != 0)\n        {\n          /* This *adds* the target arch, instead of replacing the\n             native one. This is not ideal, because we'd like to only\n             allow the target arch, but we can't really disallow the\n             native arch at this point, because then bubblewrap\n             couldn't continue running. */\n          r = seccomp_arch_add (seccomp, arch_id);\n          if (r < 0 && r != -EEXIST)\n            return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add architecture to seccomp filter\"));\n\n          if (multiarch && extra_arches != NULL)\n            {\n              unsigned i;\n              for (i = 0; extra_arches[i] != 0; i++)\n                {\n                  r = seccomp_arch_add (seccomp, extra_arches[i]);\n                  if (r < 0 && r != -EEXIST)\n                    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add multiarch architecture to seccomp filter\"));\n                }\n            }\n        }\n    }\n\n  /* TODO: Should we filter the kernel keyring syscalls in some way?\n   * We do want them to be used by desktop apps, but they could also perhaps\n   * leak system stuff or secrets from other apps.\n   */\n\n  for (i = 0; i < G_N_ELEMENTS (syscall_blacklist); i++)\n    {\n      int scall = syscall_blacklist[i].scall;\n      if (syscall_blacklist[i].arg)\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 1, *syscall_blacklist[i].arg);\n      else\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);\n      if (r < 0 && r == -EFAULT /* unknown syscall */)\n        return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n    }\n\n  if (!devel)\n    {\n      for (i = 0; i < G_N_ELEMENTS (syscall_nondevel_blacklist); i++)\n        {\n          int scall = syscall_nondevel_blacklist[i].scall;\n          if (syscall_nondevel_blacklist[i].arg)\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 1, *syscall_nondevel_blacklist[i].arg);\n          else\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);\n\n          if (r < 0 && r == -EFAULT /* unknown syscall */)\n            return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n        }\n    }\n\n  /* Socket filtering doesn't work on e.g. i386, so ignore failures here\n   * However, we need to user seccomp_rule_add_exact to avoid libseccomp doing\n   * something else: https://github.com/seccomp/libseccomp/issues/8 */\n  last_allowed_family = -1;\n  for (i = 0; i < G_N_ELEMENTS (socket_family_whitelist); i++)\n    {\n      int family = socket_family_whitelist[i].family;\n      int disallowed;\n\n      if (socket_family_whitelist[i].flags_mask != 0 &&\n          (socket_family_whitelist[i].flags_mask & run_flags) != socket_family_whitelist[i].flags_mask)\n        continue;\n\n      for (disallowed = last_allowed_family + 1; disallowed < family; disallowed++)\n        {\n          /* Blacklist the in-between valid families */\n          seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, disallowed));\n        }\n      last_allowed_family = family;\n    }\n  /* Blacklist the rest */\n  seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE, last_allowed_family + 1));\n\n  if (!glnx_open_anonymous_tmpfile (O_RDWR | O_CLOEXEC, &seccomp_tmpf, error))\n    return FALSE;\n\n  if (seccomp_export_bpf (seccomp, seccomp_tmpf.fd) != 0)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to export bpf\"));\n\n  lseek (seccomp_tmpf.fd, 0, SEEK_SET);\n\n  flatpak_bwrap_add_args_data_fd (bwrap,\n                                  \"--seccomp\", glnx_steal_fd (&seccomp_tmpf.fd), NULL);\n\n  return TRUE;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147481,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, int len, int write, int force,\n\t\tstruct page **pages, struct vm_area_struct **vmas)\n{\n\tint i;\n\tunsigned int vm_flags;\n\n\tif (len <= 0)\n\t\treturn 0;\n\t/* \n\t * Require read or write permissions.\n\t * If 'force' is set, we only require the \"MAY\" flags.\n\t */\n\tvm_flags  = write ? (VM_WRITE | VM_MAYWRITE) : (VM_READ | VM_MAYREAD);\n\tvm_flags &= force ? (VM_MAYREAD | VM_MAYWRITE) : (VM_READ | VM_WRITE);\n\ti = 0;\n\n\tdo {\n\t\tstruct vm_area_struct *vma;\n\t\tunsigned int foll_flags;\n\n\t\tvma = find_extend_vma(mm, start);\n\t\tif (!vma && in_gate_area(tsk, start)) {\n\t\t\tunsigned long pg = start & PAGE_MASK;\n\t\t\tstruct vm_area_struct *gate_vma = get_gate_vma(tsk);\n\t\t\tpgd_t *pgd;\n\t\t\tpud_t *pud;\n\t\t\tpmd_t *pmd;\n\t\t\tpte_t *pte;\n\t\t\tif (write) /* user gate pages are read-only */\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tif (pg > TASK_SIZE)\n\t\t\t\tpgd = pgd_offset_k(pg);\n\t\t\telse\n\t\t\t\tpgd = pgd_offset_gate(mm, pg);\n\t\t\tBUG_ON(pgd_none(*pgd));\n\t\t\tpud = pud_offset(pgd, pg);\n\t\t\tBUG_ON(pud_none(*pud));\n\t\t\tpmd = pmd_offset(pud, pg);\n\t\t\tif (pmd_none(*pmd))\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tpte = pte_offset_map(pmd, pg);\n\t\t\tif (pte_none(*pte)) {\n\t\t\t\tpte_unmap(pte);\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\t}\n\t\t\tif (pages) {\n\t\t\t\tstruct page *page = vm_normal_page(gate_vma, start, *pte);\n\t\t\t\tpages[i] = page;\n\t\t\t\tif (page)\n\t\t\t\t\tget_page(page);\n\t\t\t}\n\t\t\tpte_unmap(pte);\n\t\t\tif (vmas)\n\t\t\t\tvmas[i] = gate_vma;\n\t\t\ti++;\n\t\t\tstart += PAGE_SIZE;\n\t\t\tlen--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!vma || (vma->vm_flags & (VM_IO | VM_PFNMAP))\n\t\t\t\t|| !(vm_flags & vma->vm_flags))\n\t\t\treturn i ? : -EFAULT;\n\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\ti = follow_hugetlb_page(mm, vma, pages, vmas,\n\t\t\t\t\t\t&start, &len, i, write);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfoll_flags = FOLL_TOUCH;\n\t\tif (pages)\n\t\t\tfoll_flags |= FOLL_GET;\n\t\tif (!write && !(vma->vm_flags & VM_LOCKED) &&\n\t\t    (!vma->vm_ops || !vma->vm_ops->fault))\n\t\t\tfoll_flags |= FOLL_ANON;\n\n\t\tdo {\n\t\t\tstruct page *page;\n\n\t\t\t/*\n\t\t\t * If tsk is ooming, cut off its access to large memory\n\t\t\t * allocations. It has a pending SIGKILL, but it can't\n\t\t\t * be processed until returning to user space.\n\t\t\t */\n\t\t\tif (unlikely(test_tsk_thread_flag(tsk, TIF_MEMDIE)))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (write)\n\t\t\t\tfoll_flags |= FOLL_WRITE;\n\n\t\t\tcond_resched();\n\t\t\twhile (!(page = follow_page(vma, start, foll_flags))) {\n\t\t\t\tint ret;\n\t\t\t\tret = handle_mm_fault(mm, vma, start,\n\t\t\t\t\t\tfoll_flags & FOLL_WRITE);\n\t\t\t\tif (ret & VM_FAULT_ERROR) {\n\t\t\t\t\tif (ret & VM_FAULT_OOM)\n\t\t\t\t\t\treturn i ? i : -ENOMEM;\n\t\t\t\t\telse if (ret & VM_FAULT_SIGBUS)\n\t\t\t\t\t\treturn i ? i : -EFAULT;\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\t\t\ttsk->maj_flt++;\n\t\t\t\telse\n\t\t\t\t\ttsk->min_flt++;\n\n\t\t\t\t/*\n\t\t\t\t * The VM_FAULT_WRITE bit tells us that\n\t\t\t\t * do_wp_page has broken COW when necessary,\n\t\t\t\t * even if maybe_mkwrite decided not to set\n\t\t\t\t * pte_write. We can thus safely do subsequent\n\t\t\t\t * page lookups as if they were reads.\n\t\t\t\t */\n\t\t\t\tif (ret & VM_FAULT_WRITE)\n\t\t\t\t\tfoll_flags &= ~FOLL_WRITE;\n\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t\tif (IS_ERR(page))\n\t\t\t\treturn i ? i : PTR_ERR(page);\n\t\t\tif (pages) {\n\t\t\t\tpages[i] = page;\n\n\t\t\t\tflush_anon_page(vma, page, start);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t}\n\t\t\tif (vmas)\n\t\t\t\tvmas[i] = vma;\n\t\t\ti++;\n\t\t\tstart += PAGE_SIZE;\n\t\t\tlen--;\n\t\t} while (len && start < vma->vm_end);\n\t} while (len);\n\treturn i;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147514,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, int len, int write, int force,\n\t\tstruct page **pages, struct vm_area_struct **vmas)\n{\n\tint i;\n\tunsigned int vm_flags;\n\n\tif (len <= 0)\n\t\treturn 0;\n\t/* \n\t * Require read or write permissions.\n\t * If 'force' is set, we only require the \"MAY\" flags.\n\t */\n\tvm_flags  = write ? (VM_WRITE | VM_MAYWRITE) : (VM_READ | VM_MAYREAD);\n\tvm_flags &= force ? (VM_MAYREAD | VM_MAYWRITE) : (VM_READ | VM_WRITE);\n\ti = 0;\n\n\tdo {\n\t\tstruct vm_area_struct *vma;\n\t\tunsigned int foll_flags;\n\n\t\tvma = find_extend_vma(mm, start);\n\t\tif (!vma && in_gate_area(tsk, start)) {\n\t\t\tunsigned long pg = start & PAGE_MASK;\n\t\t\tstruct vm_area_struct *gate_vma = get_gate_vma(tsk);\n\t\t\tpgd_t *pgd;\n\t\t\tpud_t *pud;\n\t\t\tpmd_t *pmd;\n\t\t\tpte_t *pte;\n\t\t\tif (write) /* user gate pages are read-only */\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tif (pg > TASK_SIZE)\n\t\t\t\tpgd = pgd_offset_k(pg);\n\t\t\telse\n\t\t\t\tpgd = pgd_offset_gate(mm, pg);\n\t\t\tBUG_ON(pgd_none(*pgd));\n\t\t\tpud = pud_offset(pgd, pg);\n\t\t\tBUG_ON(pud_none(*pud));\n\t\t\tpmd = pmd_offset(pud, pg);\n\t\t\tif (pmd_none(*pmd))\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tpte = pte_offset_map(pmd, pg);\n\t\t\tif (pte_none(*pte)) {\n\t\t\t\tpte_unmap(pte);\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\t}\n\t\t\tif (pages) {\n\t\t\t\tstruct page *page = vm_normal_page(gate_vma, start, *pte);\n\t\t\t\tpages[i] = page;\n\t\t\t\tif (page)\n\t\t\t\t\tget_page(page);\n\t\t\t}\n\t\t\tpte_unmap(pte);\n\t\t\tif (vmas)\n\t\t\t\tvmas[i] = gate_vma;\n\t\t\ti++;\n\t\t\tstart += PAGE_SIZE;\n\t\t\tlen--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!vma || (vma->vm_flags & (VM_IO | VM_PFNMAP))\n\t\t\t\t|| !(vm_flags & vma->vm_flags))\n\t\t\treturn i ? : -EFAULT;\n\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\ti = follow_hugetlb_page(mm, vma, pages, vmas,\n\t\t\t\t\t\t&start, &len, i, write);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfoll_flags = FOLL_TOUCH;\n\t\tif (pages)\n\t\t\tfoll_flags |= FOLL_GET;\n\t\tif (!write && use_zero_page(vma))\n\t\t\tfoll_flags |= FOLL_ANON;\n\n\t\tdo {\n\t\t\tstruct page *page;\n\n\t\t\t/*\n\t\t\t * If tsk is ooming, cut off its access to large memory\n\t\t\t * allocations. It has a pending SIGKILL, but it can't\n\t\t\t * be processed until returning to user space.\n\t\t\t */\n\t\t\tif (unlikely(test_tsk_thread_flag(tsk, TIF_MEMDIE)))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (write)\n\t\t\t\tfoll_flags |= FOLL_WRITE;\n\n\t\t\tcond_resched();\n\t\t\twhile (!(page = follow_page(vma, start, foll_flags))) {\n\t\t\t\tint ret;\n\t\t\t\tret = handle_mm_fault(mm, vma, start,\n\t\t\t\t\t\tfoll_flags & FOLL_WRITE);\n\t\t\t\tif (ret & VM_FAULT_ERROR) {\n\t\t\t\t\tif (ret & VM_FAULT_OOM)\n\t\t\t\t\t\treturn i ? i : -ENOMEM;\n\t\t\t\t\telse if (ret & VM_FAULT_SIGBUS)\n\t\t\t\t\t\treturn i ? i : -EFAULT;\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\t\t\ttsk->maj_flt++;\n\t\t\t\telse\n\t\t\t\t\ttsk->min_flt++;\n\n\t\t\t\t/*\n\t\t\t\t * The VM_FAULT_WRITE bit tells us that\n\t\t\t\t * do_wp_page has broken COW when necessary,\n\t\t\t\t * even if maybe_mkwrite decided not to set\n\t\t\t\t * pte_write. We can thus safely do subsequent\n\t\t\t\t * page lookups as if they were reads.\n\t\t\t\t */\n\t\t\t\tif (ret & VM_FAULT_WRITE)\n\t\t\t\t\tfoll_flags &= ~FOLL_WRITE;\n\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t\tif (IS_ERR(page))\n\t\t\t\treturn i ? i : PTR_ERR(page);\n\t\t\tif (pages) {\n\t\t\t\tpages[i] = page;\n\n\t\t\t\tflush_anon_page(vma, page, start);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t}\n\t\t\tif (vmas)\n\t\t\t\tvmas[i] = vma;\n\t\t\ti++;\n\t\t\tstart += PAGE_SIZE;\n\t\t\tlen--;\n\t\t} while (len && start < vma->vm_end);\n\t} while (len);\n\treturn i;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147515,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int make_indexed_dir(handle_t *handle, struct dentry *dentry,\n\t\t\t    struct inode *inode, struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tstruct buffer_head *bh2;\n\tstruct dx_root\t*root;\n\tstruct dx_frame\tframes[2], *frame;\n\tstruct dx_entry *entries;\n\tstruct ext4_dir_entry_2\t*de, *de2;\n\tchar\t\t*data1, *top;\n\tunsigned\tlen;\n\tint\t\tretval;\n\tunsigned\tblocksize;\n\tstruct dx_hash_info hinfo;\n\text4_lblk_t  block;\n\tstruct fake_dirent *fde;\n\n\tblocksize =  dir->i_sb->s_blocksize;\n\tdxtrace(printk(KERN_DEBUG \"Creating index\\n\"));\n\tretval = ext4_journal_get_write_access(handle, bh);\n\tif (retval) {\n\t\text4_std_error(dir->i_sb, retval);\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\n\tbh2 = ext4_append(handle, dir, &block, &retval);\n\tif (!(bh2)) {\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\tEXT4_I(dir)->i_flags |= EXT4_INDEX_FL;\n\tdata1 = bh2->b_data;\n\n\t/* The 0th block becomes the root, move the dirents out */\n\tfde = &root->dotdot;\n\tde = (struct ext4_dir_entry_2 *)((char *)fde +\n\t\text4_rec_len_from_disk(fde->rec_len));\n\tlen = ((char *) root) + blocksize - (char *) de;\n\tmemcpy (data1, de, len);\n\tde = (struct ext4_dir_entry_2 *) data1;\n\ttop = data1 + len;\n\twhile ((char *)(de2 = ext4_next_entry(de)) < top)\n\t\tde = de2;\n\tde->rec_len = ext4_rec_len_to_disk(data1 + blocksize - (char *) de);\n\t/* Initialize the root; the dot dirents already exist */\n\tde = (struct ext4_dir_entry_2 *) (&root->dotdot);\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - EXT4_DIR_REC_LEN(2));\n\tmemset (&root->info, 0, sizeof(root->info));\n\troot->info.info_length = sizeof(root->info);\n\troot->info.hash_version = EXT4_SB(dir->i_sb)->s_def_hash_version;\n\tentries = root->entries;\n\tdx_set_block(entries, 1);\n\tdx_set_count(entries, 1);\n\tdx_set_limit(entries, dx_root_limit(dir, sizeof(root->info)));\n\n\t/* Initialize as for dx_probe */\n\thinfo.hash_version = root->info.hash_version;\n\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\thinfo.hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo.seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\text4fs_dirhash(name, namelen, &hinfo);\n\tframe = frames;\n\tframe->entries = entries;\n\tframe->at = entries;\n\tframe->bh = bh;\n\tbh = bh2;\n\tde = do_split(handle,dir, &bh, frame, &hinfo, &retval);\n\tdx_release (frames);\n\tif (!(de))\n\t\treturn retval;\n\n\treturn add_dirent_to_buf(handle, dentry, inode, de, bh);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147534,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int make_indexed_dir(handle_t *handle, struct dentry *dentry,\n\t\t\t    struct inode *inode, struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tstruct buffer_head *bh2;\n\tstruct dx_root\t*root;\n\tstruct dx_frame\tframes[2], *frame;\n\tstruct dx_entry *entries;\n\tstruct ext4_dir_entry_2\t*de, *de2;\n\tchar\t\t*data1, *top;\n\tunsigned\tlen;\n\tint\t\tretval;\n\tunsigned\tblocksize;\n\tstruct dx_hash_info hinfo;\n\text4_lblk_t  block;\n\tstruct fake_dirent *fde;\n\n\tblocksize =  dir->i_sb->s_blocksize;\n\tdxtrace(printk(KERN_DEBUG \"Creating index: inode %lu\\n\", dir->i_ino));\n\tretval = ext4_journal_get_write_access(handle, bh);\n\tif (retval) {\n\t\text4_std_error(dir->i_sb, retval);\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\n\t/* The 0th block becomes the root, move the dirents out */\n\tfde = &root->dotdot;\n\tde = (struct ext4_dir_entry_2 *)((char *)fde +\n\t\text4_rec_len_from_disk(fde->rec_len));\n\tif ((char *) de >= (((char *) root) + blocksize)) {\n\t\text4_error(dir->i_sb, __func__,\n\t\t\t   \"invalid rec_len for '..' in inode %lu\",\n\t\t\t   dir->i_ino);\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\tlen = ((char *) root) + blocksize - (char *) de;\n\n\t/* Allocate new block for the 0th block's dirents */\n\tbh2 = ext4_append(handle, dir, &block, &retval);\n\tif (!(bh2)) {\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\tEXT4_I(dir)->i_flags |= EXT4_INDEX_FL;\n\tdata1 = bh2->b_data;\n\n\tmemcpy (data1, de, len);\n\tde = (struct ext4_dir_entry_2 *) data1;\n\ttop = data1 + len;\n\twhile ((char *)(de2 = ext4_next_entry(de)) < top)\n\t\tde = de2;\n\tde->rec_len = ext4_rec_len_to_disk(data1 + blocksize - (char *) de);\n\t/* Initialize the root; the dot dirents already exist */\n\tde = (struct ext4_dir_entry_2 *) (&root->dotdot);\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - EXT4_DIR_REC_LEN(2));\n\tmemset (&root->info, 0, sizeof(root->info));\n\troot->info.info_length = sizeof(root->info);\n\troot->info.hash_version = EXT4_SB(dir->i_sb)->s_def_hash_version;\n\tentries = root->entries;\n\tdx_set_block(entries, 1);\n\tdx_set_count(entries, 1);\n\tdx_set_limit(entries, dx_root_limit(dir, sizeof(root->info)));\n\n\t/* Initialize as for dx_probe */\n\thinfo.hash_version = root->info.hash_version;\n\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\thinfo.hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo.seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\text4fs_dirhash(name, namelen, &hinfo);\n\tframe = frames;\n\tframe->entries = entries;\n\tframe->at = entries;\n\tframe->bh = bh;\n\tbh = bh2;\n\tde = do_split(handle,dir, &bh, frame, &hinfo, &retval);\n\tdx_release (frames);\n\tif (!(de))\n\t\treturn retval;\n\n\treturn add_dirent_to_buf(handle, dentry, inode, de, bh);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147535,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "\t\t\t\t__acquires(kernel_lock)\n\n{\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi;\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tchar *cp;\n\tconst char *descr;\n\tint ret = -EINVAL;\n\tint blocksize;\n\tint db_count;\n\tint i;\n\tint needs_recovery, has_huge_files;\n\tint features;\n\t__u64 blocks_count;\n\tint err;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = sbi;\n\tsbi->s_mount_opt = 0;\n\tsbi->s_resuid = EXT4_DEF_RESUID;\n\tsbi->s_resgid = EXT4_DEF_RESGID;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\n\tunlock_kernel();\n\n\t/* Cleanup superblock name */\n\tfor (cp = sb->s_id; (cp = strchr(cp, '/'));)\n\t\t*cp = '!';\n\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\tprintk(KERN_ERR \"EXT4-fs: unable to set blocksize\\n\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread(sb, logical_sb_block))) {\n\t\tprintk(KERN_ERR \"EXT4-fs: unable to read superblock\\n\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (((char *)bh->b_data) + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sbi->s_mount_opt, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sbi->s_mount_opt, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sbi->s_mount_opt, NO_UID32);\n#ifdef CONFIG_EXT4_FS_XATTR\n\tif (def_mount_opts & EXT4_DEFM_XATTR_USER)\n\t\tset_opt(sbi->s_mount_opt, XATTR_USER);\n#endif\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tif (def_mount_opts & EXT4_DEFM_ACL)\n\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n#endif\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tsbi->s_mount_opt |= EXT4_MOUNT_JOURNAL_DATA;\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tsbi->s_mount_opt |= EXT4_MOUNT_ORDERED_DATA;\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tsbi->s_mount_opt |= EXT4_MOUNT_WRITEBACK_DATA;\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_CONT);\n\telse\n\t\tset_opt(sbi->s_mount_opt, ERRORS_RO);\n\n\tsbi->s_resuid = le16_to_cpu(es->s_def_resuid);\n\tsbi->s_resgid = le16_to_cpu(es->s_def_resgid);\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tset_opt(sbi->s_mount_opt, RESERVATION);\n\tset_opt(sbi->s_mount_opt, BARRIER);\n\n\t/*\n\t * turn on extents feature by default in ext4 filesystem\n\t * only if feature flag already set by mkfs or tune2fs.\n\t * Use -o noextents to turn it off\n\t */\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS))\n\t\tset_opt(sbi->s_mount_opt, EXTENTS);\n\telse\n\t\text4_warning(sb, __func__,\n\t\t\t\"extents feature not enabled on this filesystem, \"\n\t\t\t\"use tune2fs.\");\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tset_opt(sbi->s_mount_opt, DELALLOC);\n\n\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, NULL, 0))\n\t\tgoto failed_mount;\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t((sbi->s_mount_opt & EXT4_MOUNT_POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (EXT4_HAS_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT4_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT4_HAS_INCOMPAT_FEATURE(sb, ~0U)))\n\t\tprintk(KERN_WARNING\n\t\t       \"EXT4-fs warning: feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\\n\");\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tfeatures = EXT4_HAS_INCOMPAT_FEATURE(sb, ~EXT4_FEATURE_INCOMPAT_SUPP);\n\tif (features) {\n\t\tprintk(KERN_ERR \"EXT4-fs: %s: couldn't mount because of \"\n\t\t       \"unsupported optional features (%x).\\n\", sb->s_id,\n\t\t\t(le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_incompat) &\n\t\t\t~EXT4_FEATURE_INCOMPAT_SUPP));\n\t\tgoto failed_mount;\n\t}\n\tfeatures = EXT4_HAS_RO_COMPAT_FEATURE(sb, ~EXT4_FEATURE_RO_COMPAT_SUPP);\n\tif (!(sb->s_flags & MS_RDONLY) && features) {\n\t\tprintk(KERN_ERR \"EXT4-fs: %s: couldn't mount RDWR because of \"\n\t\t       \"unsupported optional features (%x).\\n\", sb->s_id,\n\t\t\t(le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_ro_compat) &\n\t\t\t~EXT4_FEATURE_RO_COMPAT_SUPP));\n\t\tgoto failed_mount;\n\t}\n\thas_huge_files = EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t    EXT4_FEATURE_RO_COMPAT_HUGE_FILE);\n\tif (has_huge_files) {\n\t\t/*\n\t\t * Large file size enabled file system can only be\n\t\t * mount if kernel is build with CONFIG_LBD\n\t\t */\n\t\tif (sizeof(root->i_blocks) < sizeof(u64) &&\n\t\t\t\t!(sb->s_flags & MS_RDONLY)) {\n\t\t\tprintk(KERN_ERR \"EXT4-fs: %s: Filesystem with huge \"\n\t\t\t\t\t\"files cannot be mounted read-write \"\n\t\t\t\t\t\"without CONFIG_LBD.\\n\", sb->s_id);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\tprintk(KERN_ERR\n\t\t       \"EXT4-fs: Unsupported filesystem blocksize %d on %s.\\n\",\n\t\t       blocksize, sb->s_id);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\tprintk(KERN_ERR \"EXT4-fs: bad block size %d.\\n\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"EXT4-fs: Can't read superblock on 2nd try.\\n\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(((char *)bh->b_data) + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"EXT4-fs: Magic mismatch, very weird !\\n\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"EXT4-fs: unsupported inode size: %d\\n\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_64BIT)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"EXT4-fs: unsupported descriptor size %lu\\n\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\tif (EXT4_INODE_SIZE(sb) == 0 || EXT4_INODES_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\ti = le32_to_cpu(es->s_flags);\n\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\tsbi->s_hash_unsigned = 3;\n\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\tsb->s_dirt = 1;\n\t}\n\n\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\tprintk(KERN_ERR\n\t\t       \"EXT4-fs: #blocks per group too big: %lu\\n\",\n\t\t       sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_inodes_per_group > blocksize * 8) {\n\t\tprintk(KERN_ERR\n\t\t       \"EXT4-fs: #inodes per group too big: %lu\\n\",\n\t\t       sbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_blocks_count(es) >\n\t\t    (sector_t)(~0ULL) >> (sb->s_blocksize_bits - 9)) {\n\t\tprintk(KERN_ERR \"EXT4-fs: filesystem on %s:\"\n\t\t\t\" too large to mount safely\\n\", sb->s_id);\n\t\tif (sizeof(sector_t) < 8)\n\t\t\tprintk(KERN_WARNING \"EXT4-fs: CONFIG_LBD not \"\n\t\t\t\t\t\"enabled\\n\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* ensure blocks_count calculation below doesn't sign-extend */\n\tif (ext4_blocks_count(es) + EXT4_BLOCKS_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_first_data_block) + 1) {\n\t\tprintk(KERN_WARNING \"EXT4-fs: bad geometry: block count %llu, \"\n\t\t       \"first data block %u, blocks per group %lu\\n\",\n\t\t\text4_blocks_count(es),\n\t\t\tle32_to_cpu(es->s_first_data_block),\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tsbi->s_groups_count = blocks_count;\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = kmalloc(db_count * sizeof(struct buffer_head *),\n\t\t\t\t    GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\tprintk(KERN_ERR \"EXT4-fs: not enough memory\\n\");\n\t\tgoto failed_mount;\n\t}\n\n#ifdef CONFIG_PROC_FS\n\tif (ext4_proc_root)\n\t\tsbi->s_proc = proc_mkdir(sb->s_id, ext4_proc_root);\n\n\tif (sbi->s_proc)\n\t\tproc_create_data(\"inode_readahead_blks\", 0644, sbi->s_proc,\n\t\t\t\t &ext4_ui_proc_fops,\n\t\t\t\t &sbi->s_inode_readahead_blks);\n#endif\n\n\tbgl_lock_init(&sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\tprintk(KERN_ERR \"EXT4-fs: \"\n\t\t\t       \"can't read group descriptor %d\\n\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb)) {\n\t\tprintk(KERN_ERR \"EXT4-fs: group descriptors corrupted!\\n\");\n\t\tgoto failed_mount2;\n\t}\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"EXT4-fs: unable to initialize \"\n\t\t\t       \"flex_bg meta info!\\n\");\n\t\t\tgoto failed_mount2;\n\t\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\terr = percpu_counter_init(&sbi->s_freeblocks_counter,\n\t\t\text4_count_free_blocks(sb));\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter,\n\t\t\t\text4_count_free_inodes(sb));\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\text4_count_dirs(sb));\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirtyblocks_counter, 0);\n\t}\n\tif (err) {\n\t\tprintk(KERN_ERR \"EXT4-fs: insufficient memory\\n\");\n\t\tgoto failed_mount3;\n\t}\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n#ifdef CONFIG_QUOTA\n\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->dq_op = &ext4_quota_operations;\n#endif\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t    EXT4_FEATURE_INCOMPAT_RECOVER));\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) &&\n\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3;\n\t\tif (!(sb->s_flags & MS_RDONLY) &&\n\t\t    EXT4_SB(sb)->s_journal->j_failed_commit) {\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): \"\n\t\t\t       \"ext4_fill_super: Journal transaction \"\n\t\t\t       \"%u is corrupt\\n\", sb->s_id,\n\t\t\t       EXT4_SB(sb)->s_journal->j_failed_commit);\n\t\t\tif (test_opt(sb, ERRORS_RO)) {\n\t\t\t\tprintk(KERN_CRIT\n\t\t\t\t       \"Mounting filesystem read-only\\n\");\n\t\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t\t\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\t\t\t\tes->s_state |= cpu_to_le16(EXT4_ERROR_FS);\n\t\t\t}\n\t\t\tif (test_opt(sb, ERRORS_PANIC)) {\n\t\t\t\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\t\t\t\tes->s_state |= cpu_to_le16(EXT4_ERROR_FS);\n\t\t\t\text4_commit_super(sb, es, 1);\n\t\t\t\tgoto failed_mount4;\n\t\t\t}\n\t\t}\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t      EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER)) {\n\t\tprintk(KERN_ERR \"EXT4-fs: required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\\n\");\n\t\tgoto failed_mount4;\n\t} else {\n\t\tclear_opt(sbi->s_mount_opt, DATA_FLAGS);\n\t\tset_opt(sbi->s_mount_opt, WRITEBACK_DATA);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_blocks_count(es) > 0xffffffffULL &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\tprintk(KERN_ERR \"ext4: Failed to set 64-bit journal feature\\n\");\n\t\tgoto failed_mount4;\n\t}\n\n\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\tjbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t} else if (test_opt(sb, JOURNAL_CHECKSUM)) {\n\t\tjbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0, 0);\n\t\tjbd2_journal_clear_features(sbi->s_journal, 0, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t} else {\n\t\tjbd2_journal_clear_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sbi->s_mount_opt, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sbi->s_mount_opt, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\tprintk(KERN_ERR \"EXT4-fs: Journal does not support \"\n\t\t\t       \"requested data journaling mode\\n\");\n\t\t\tgoto failed_mount4;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\nno_journal:\n\n\tif (test_opt(sb, NOBH)) {\n\t\tif (!(test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)) {\n\t\t\tprintk(KERN_WARNING \"EXT4-fs: Ignoring nobh option - \"\n\t\t\t\t\"its supported only with writeback mode\\n\");\n\t\t\tclear_opt(sbi->s_mount_opt, NOBH);\n\t\t}\n\t}\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\tprintk(KERN_ERR \"EXT4-fs: get root inode failed\\n\");\n\t\tret = PTR_ERR(root);\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\tiput(root);\n\t\tprintk(KERN_ERR \"EXT4-fs: corrupt root inode, run e2fsck\\n\");\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_alloc_root(root);\n\tif (!sb->s_root) {\n\t\tprintk(KERN_ERR \"EXT4-fs: get root dentry failed\\n\");\n\t\tiput(root);\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\text4_setup_super(sb, es, sb->s_flags & MS_RDONLY);\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\tprintk(KERN_INFO \"EXT4-fs: required extra inode space not\"\n\t\t\t\"available.\\n\");\n\t}\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk(KERN_WARNING \"EXT4-fs: Ignoring delalloc option - \"\n\t\t\t\t\"requested data journaling mode\\n\");\n\t\tclear_opt(sbi->s_mount_opt, DELALLOC);\n\t} else if (test_opt(sb, DELALLOC))\n\t\tprintk(KERN_INFO \"EXT4-fs: delayed allocation enabled\\n\");\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb, needs_recovery);\n\tif (err) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to initalize mballoc (%d)\\n\",\n\t\t       err);\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * akpm: core read_super() calls in here with the superblock locked.\n\t * That deadlocks, because orphan cleanup needs to lock the superblock\n\t * in numerous places.  Here we just pop the lock - it's relatively\n\t * harmless, because we are now ready to accept write_super() requests,\n\t * and aviro says that's the only reason for hanging onto the\n\t * superblock lock.\n\t */\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\tprintk(KERN_INFO \"EXT4-fs: recovery complete.\\n\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tprintk(KERN_INFO \"EXT4-fs: mounted filesystem %s with%s\\n\",\n\t       sb->s_id, descr);\n\n\tlock_kernel();\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\tprintk(KERN_ERR \"VFS: Can't find ext4 filesystem on dev %s.\\n\",\n\t\t       sb->s_id);\n\tgoto failed_mount;\n\nfailed_mount4:\n\tprintk(KERN_ERR \"EXT4-fs (device %s): mount failed\\n\", sb->s_id);\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3:\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyblocks_counter);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_proc) {\n\t\tremove_proc_entry(\"inode_readahead_blks\", sbi->s_proc);\n\t\tremove_proc_entry(sb->s_id, ext4_proc_root);\n\t}\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi);\n\tlock_kernel();\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147536,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "\t\t\t\t__acquires(kernel_lock)\n\n{\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi;\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tchar *cp;\n\tconst char *descr;\n\tint ret = -EINVAL;\n\tint blocksize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files;\n\tint features;\n\t__u64 blocks_count;\n\tint err;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = sbi;\n\tsbi->s_mount_opt = 0;\n\tsbi->s_resuid = EXT4_DEF_RESUID;\n\tsbi->s_resgid = EXT4_DEF_RESGID;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\n\tunlock_kernel();\n\n\t/* Cleanup superblock name */\n\tfor (cp = sb->s_id; (cp = strchr(cp, '/'));)\n\t\t*cp = '!';\n\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\tprintk(KERN_ERR \"EXT4-fs: unable to set blocksize\\n\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread(sb, logical_sb_block))) {\n\t\tprintk(KERN_ERR \"EXT4-fs: unable to read superblock\\n\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (((char *)bh->b_data) + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sbi->s_mount_opt, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sbi->s_mount_opt, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sbi->s_mount_opt, NO_UID32);\n#ifdef CONFIG_EXT4_FS_XATTR\n\tif (def_mount_opts & EXT4_DEFM_XATTR_USER)\n\t\tset_opt(sbi->s_mount_opt, XATTR_USER);\n#endif\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tif (def_mount_opts & EXT4_DEFM_ACL)\n\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n#endif\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tsbi->s_mount_opt |= EXT4_MOUNT_JOURNAL_DATA;\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tsbi->s_mount_opt |= EXT4_MOUNT_ORDERED_DATA;\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tsbi->s_mount_opt |= EXT4_MOUNT_WRITEBACK_DATA;\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_CONT);\n\telse\n\t\tset_opt(sbi->s_mount_opt, ERRORS_RO);\n\n\tsbi->s_resuid = le16_to_cpu(es->s_def_resuid);\n\tsbi->s_resgid = le16_to_cpu(es->s_def_resgid);\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tset_opt(sbi->s_mount_opt, RESERVATION);\n\tset_opt(sbi->s_mount_opt, BARRIER);\n\n\t/*\n\t * turn on extents feature by default in ext4 filesystem\n\t * only if feature flag already set by mkfs or tune2fs.\n\t * Use -o noextents to turn it off\n\t */\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS))\n\t\tset_opt(sbi->s_mount_opt, EXTENTS);\n\telse\n\t\text4_warning(sb, __func__,\n\t\t\t\"extents feature not enabled on this filesystem, \"\n\t\t\t\"use tune2fs.\");\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tset_opt(sbi->s_mount_opt, DELALLOC);\n\n\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, NULL, 0))\n\t\tgoto failed_mount;\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t((sbi->s_mount_opt & EXT4_MOUNT_POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (EXT4_HAS_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT4_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT4_HAS_INCOMPAT_FEATURE(sb, ~0U)))\n\t\tprintk(KERN_WARNING\n\t\t       \"EXT4-fs warning: feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\\n\");\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tfeatures = EXT4_HAS_INCOMPAT_FEATURE(sb, ~EXT4_FEATURE_INCOMPAT_SUPP);\n\tif (features) {\n\t\tprintk(KERN_ERR \"EXT4-fs: %s: couldn't mount because of \"\n\t\t       \"unsupported optional features (%x).\\n\", sb->s_id,\n\t\t\t(le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_incompat) &\n\t\t\t~EXT4_FEATURE_INCOMPAT_SUPP));\n\t\tgoto failed_mount;\n\t}\n\tfeatures = EXT4_HAS_RO_COMPAT_FEATURE(sb, ~EXT4_FEATURE_RO_COMPAT_SUPP);\n\tif (!(sb->s_flags & MS_RDONLY) && features) {\n\t\tprintk(KERN_ERR \"EXT4-fs: %s: couldn't mount RDWR because of \"\n\t\t       \"unsupported optional features (%x).\\n\", sb->s_id,\n\t\t\t(le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_ro_compat) &\n\t\t\t~EXT4_FEATURE_RO_COMPAT_SUPP));\n\t\tgoto failed_mount;\n\t}\n\thas_huge_files = EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t    EXT4_FEATURE_RO_COMPAT_HUGE_FILE);\n\tif (has_huge_files) {\n\t\t/*\n\t\t * Large file size enabled file system can only be\n\t\t * mount if kernel is build with CONFIG_LBD\n\t\t */\n\t\tif (sizeof(root->i_blocks) < sizeof(u64) &&\n\t\t\t\t!(sb->s_flags & MS_RDONLY)) {\n\t\t\tprintk(KERN_ERR \"EXT4-fs: %s: Filesystem with huge \"\n\t\t\t\t\t\"files cannot be mounted read-write \"\n\t\t\t\t\t\"without CONFIG_LBD.\\n\", sb->s_id);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\tprintk(KERN_ERR\n\t\t       \"EXT4-fs: Unsupported filesystem blocksize %d on %s.\\n\",\n\t\t       blocksize, sb->s_id);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\tprintk(KERN_ERR \"EXT4-fs: bad block size %d.\\n\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"EXT4-fs: Can't read superblock on 2nd try.\\n\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(((char *)bh->b_data) + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"EXT4-fs: Magic mismatch, very weird !\\n\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"EXT4-fs: unsupported inode size: %d\\n\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_64BIT)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"EXT4-fs: unsupported descriptor size %lu\\n\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\tif (EXT4_INODE_SIZE(sb) == 0 || EXT4_INODES_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\ti = le32_to_cpu(es->s_flags);\n\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\tsbi->s_hash_unsigned = 3;\n\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\tsb->s_dirt = 1;\n\t}\n\n\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\tprintk(KERN_ERR\n\t\t       \"EXT4-fs: #blocks per group too big: %lu\\n\",\n\t\t       sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_inodes_per_group > blocksize * 8) {\n\t\tprintk(KERN_ERR\n\t\t       \"EXT4-fs: #inodes per group too big: %lu\\n\",\n\t\t       sbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_blocks_count(es) >\n\t\t    (sector_t)(~0ULL) >> (sb->s_blocksize_bits - 9)) {\n\t\tprintk(KERN_ERR \"EXT4-fs: filesystem on %s:\"\n\t\t\t\" too large to mount safely\\n\", sb->s_id);\n\t\tif (sizeof(sector_t) < 8)\n\t\t\tprintk(KERN_WARNING \"EXT4-fs: CONFIG_LBD not \"\n\t\t\t\t\t\"enabled\\n\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n        /*\n         * It makes no sense for the first data block to be beyond the end\n         * of the filesystem.\n         */\n        if (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n                printk(KERN_WARNING \"EXT4-fs: bad geometry: first data\"\n\t\t       \"block %u is beyond end of filesystem (%llu)\\n\",\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\tprintk(KERN_WARNING \"EXT4-fs: groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\\n\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = kmalloc(db_count * sizeof(struct buffer_head *),\n\t\t\t\t    GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\tprintk(KERN_ERR \"EXT4-fs: not enough memory\\n\");\n\t\tgoto failed_mount;\n\t}\n\n#ifdef CONFIG_PROC_FS\n\tif (ext4_proc_root)\n\t\tsbi->s_proc = proc_mkdir(sb->s_id, ext4_proc_root);\n\n\tif (sbi->s_proc)\n\t\tproc_create_data(\"inode_readahead_blks\", 0644, sbi->s_proc,\n\t\t\t\t &ext4_ui_proc_fops,\n\t\t\t\t &sbi->s_inode_readahead_blks);\n#endif\n\n\tbgl_lock_init(&sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\tprintk(KERN_ERR \"EXT4-fs: \"\n\t\t\t       \"can't read group descriptor %d\\n\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb)) {\n\t\tprintk(KERN_ERR \"EXT4-fs: group descriptors corrupted!\\n\");\n\t\tgoto failed_mount2;\n\t}\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"EXT4-fs: unable to initialize \"\n\t\t\t       \"flex_bg meta info!\\n\");\n\t\t\tgoto failed_mount2;\n\t\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\terr = percpu_counter_init(&sbi->s_freeblocks_counter,\n\t\t\text4_count_free_blocks(sb));\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter,\n\t\t\t\text4_count_free_inodes(sb));\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\text4_count_dirs(sb));\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirtyblocks_counter, 0);\n\t}\n\tif (err) {\n\t\tprintk(KERN_ERR \"EXT4-fs: insufficient memory\\n\");\n\t\tgoto failed_mount3;\n\t}\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n#ifdef CONFIG_QUOTA\n\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->dq_op = &ext4_quota_operations;\n#endif\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t    EXT4_FEATURE_INCOMPAT_RECOVER));\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) &&\n\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3;\n\t\tif (!(sb->s_flags & MS_RDONLY) &&\n\t\t    EXT4_SB(sb)->s_journal->j_failed_commit) {\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): \"\n\t\t\t       \"ext4_fill_super: Journal transaction \"\n\t\t\t       \"%u is corrupt\\n\", sb->s_id,\n\t\t\t       EXT4_SB(sb)->s_journal->j_failed_commit);\n\t\t\tif (test_opt(sb, ERRORS_RO)) {\n\t\t\t\tprintk(KERN_CRIT\n\t\t\t\t       \"Mounting filesystem read-only\\n\");\n\t\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t\t\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\t\t\t\tes->s_state |= cpu_to_le16(EXT4_ERROR_FS);\n\t\t\t}\n\t\t\tif (test_opt(sb, ERRORS_PANIC)) {\n\t\t\t\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\t\t\t\tes->s_state |= cpu_to_le16(EXT4_ERROR_FS);\n\t\t\t\text4_commit_super(sb, es, 1);\n\t\t\t\tgoto failed_mount4;\n\t\t\t}\n\t\t}\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t      EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER)) {\n\t\tprintk(KERN_ERR \"EXT4-fs: required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\\n\");\n\t\tgoto failed_mount4;\n\t} else {\n\t\tclear_opt(sbi->s_mount_opt, DATA_FLAGS);\n\t\tset_opt(sbi->s_mount_opt, WRITEBACK_DATA);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_blocks_count(es) > 0xffffffffULL &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\tprintk(KERN_ERR \"ext4: Failed to set 64-bit journal feature\\n\");\n\t\tgoto failed_mount4;\n\t}\n\n\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\tjbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t} else if (test_opt(sb, JOURNAL_CHECKSUM)) {\n\t\tjbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0, 0);\n\t\tjbd2_journal_clear_features(sbi->s_journal, 0, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t} else {\n\t\tjbd2_journal_clear_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sbi->s_mount_opt, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sbi->s_mount_opt, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\tprintk(KERN_ERR \"EXT4-fs: Journal does not support \"\n\t\t\t       \"requested data journaling mode\\n\");\n\t\t\tgoto failed_mount4;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\nno_journal:\n\n\tif (test_opt(sb, NOBH)) {\n\t\tif (!(test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)) {\n\t\t\tprintk(KERN_WARNING \"EXT4-fs: Ignoring nobh option - \"\n\t\t\t\t\"its supported only with writeback mode\\n\");\n\t\t\tclear_opt(sbi->s_mount_opt, NOBH);\n\t\t}\n\t}\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\tprintk(KERN_ERR \"EXT4-fs: get root inode failed\\n\");\n\t\tret = PTR_ERR(root);\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\tiput(root);\n\t\tprintk(KERN_ERR \"EXT4-fs: corrupt root inode, run e2fsck\\n\");\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_alloc_root(root);\n\tif (!sb->s_root) {\n\t\tprintk(KERN_ERR \"EXT4-fs: get root dentry failed\\n\");\n\t\tiput(root);\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\text4_setup_super(sb, es, sb->s_flags & MS_RDONLY);\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\tprintk(KERN_INFO \"EXT4-fs: required extra inode space not\"\n\t\t\t\"available.\\n\");\n\t}\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk(KERN_WARNING \"EXT4-fs: Ignoring delalloc option - \"\n\t\t\t\t\"requested data journaling mode\\n\");\n\t\tclear_opt(sbi->s_mount_opt, DELALLOC);\n\t} else if (test_opt(sb, DELALLOC))\n\t\tprintk(KERN_INFO \"EXT4-fs: delayed allocation enabled\\n\");\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb, needs_recovery);\n\tif (err) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to initalize mballoc (%d)\\n\",\n\t\t       err);\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * akpm: core read_super() calls in here with the superblock locked.\n\t * That deadlocks, because orphan cleanup needs to lock the superblock\n\t * in numerous places.  Here we just pop the lock - it's relatively\n\t * harmless, because we are now ready to accept write_super() requests,\n\t * and aviro says that's the only reason for hanging onto the\n\t * superblock lock.\n\t */\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\tprintk(KERN_INFO \"EXT4-fs: recovery complete.\\n\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tprintk(KERN_INFO \"EXT4-fs: mounted filesystem %s with%s\\n\",\n\t       sb->s_id, descr);\n\n\tlock_kernel();\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\tprintk(KERN_ERR \"VFS: Can't find ext4 filesystem on dev %s.\\n\",\n\t\t       sb->s_id);\n\tgoto failed_mount;\n\nfailed_mount4:\n\tprintk(KERN_ERR \"EXT4-fs (device %s): mount failed\\n\", sb->s_id);\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3:\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyblocks_counter);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_proc) {\n\t\tremove_proc_entry(\"inode_readahead_blks\", sbi->s_proc);\n\t\tremove_proc_entry(sb->s_id, ext4_proc_root);\n\t}\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi);\n\tlock_kernel();\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147537,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int vmx_set_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 data)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_msr_entry *msr;\n\tu64 host_tsc;\n\tint ret = 0;\n\n\tswitch (msr_index) {\n#ifdef CONFIG_X86_64\n\tcase MSR_EFER:\n\t\tvmx_load_host_state(vmx);\n\t\tret = kvm_set_msr_common(vcpu, msr_index, data);\n\t\tbreak;\n\tcase MSR_FS_BASE:\n\t\tvmcs_writel(GUEST_FS_BASE, data);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tvmcs_writel(GUEST_GS_BASE, data);\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tvmcs_write32(GUEST_SYSENTER_CS, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tvmcs_writel(GUEST_SYSENTER_EIP, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tvmcs_writel(GUEST_SYSENTER_ESP, data);\n\t\tbreak;\n\tcase MSR_IA32_TIME_STAMP_COUNTER:\n\t\trdtscll(host_tsc);\n\t\tguest_write_tsc(data, host_tsc);\n\t\tbreak;\n\tcase MSR_P6_PERFCTR0:\n\tcase MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0:\n\tcase MSR_P6_EVNTSEL1:\n\t\t/*\n\t\t * Just discard all writes to the performance counters; this\n\t\t * should keep both older linux and windows 64-bit guests\n\t\t * happy\n\t\t */\n\t\tpr_unimpl(vcpu, \"unimplemented perfctr wrmsr: 0x%x data 0x%llx\\n\", msr_index, data);\n\n\t\tbreak;\n\tcase MSR_IA32_CR_PAT:\n\t\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {\n\t\t\tvmcs_write64(GUEST_IA32_PAT, data);\n\t\t\tvcpu->arch.pat = data;\n\t\t\tbreak;\n\t\t}\n\t\t/* Otherwise falls through to kvm_set_msr_common */\n\tdefault:\n\t\tvmx_load_host_state(vmx);\n\t\tmsr = find_msr_entry(vmx, msr_index);\n\t\tif (msr) {\n\t\t\tmsr->data = data;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_set_msr_common(vcpu, msr_index, data);\n\t}\n\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147538,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int vmx_set_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 data)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_msr_entry *msr;\n\tu64 host_tsc;\n\tint ret = 0;\n\n\tswitch (msr_index) {\n\tcase MSR_EFER:\n\t\tvmx_load_host_state(vmx);\n\t\tret = kvm_set_msr_common(vcpu, msr_index, data);\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_FS_BASE:\n\t\tvmcs_writel(GUEST_FS_BASE, data);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tvmcs_writel(GUEST_GS_BASE, data);\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tvmcs_write32(GUEST_SYSENTER_CS, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tvmcs_writel(GUEST_SYSENTER_EIP, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tvmcs_writel(GUEST_SYSENTER_ESP, data);\n\t\tbreak;\n\tcase MSR_IA32_TIME_STAMP_COUNTER:\n\t\trdtscll(host_tsc);\n\t\tguest_write_tsc(data, host_tsc);\n\t\tbreak;\n\tcase MSR_P6_PERFCTR0:\n\tcase MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0:\n\tcase MSR_P6_EVNTSEL1:\n\t\t/*\n\t\t * Just discard all writes to the performance counters; this\n\t\t * should keep both older linux and windows 64-bit guests\n\t\t * happy\n\t\t */\n\t\tpr_unimpl(vcpu, \"unimplemented perfctr wrmsr: 0x%x data 0x%llx\\n\", msr_index, data);\n\n\t\tbreak;\n\tcase MSR_IA32_CR_PAT:\n\t\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {\n\t\t\tvmcs_write64(GUEST_IA32_PAT, data);\n\t\t\tvcpu->arch.pat = data;\n\t\t\tbreak;\n\t\t}\n\t\t/* Otherwise falls through to kvm_set_msr_common */\n\tdefault:\n\t\tvmx_load_host_state(vmx);\n\t\tmsr = find_msr_entry(vmx, msr_index);\n\t\tif (msr) {\n\t\t\tmsr->data = data;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_set_msr_common(vcpu, msr_index, data);\n\t}\n\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147539,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int huft_build(b, n, s, d, e, t, m)\nunsigned *b;            /* code lengths in bits (all assumed <= BMAX) */\nunsigned n;             /* number of codes (assumed <= N_MAX) */\nunsigned s;             /* number of simple-valued codes (0..s-1) */\nush *d;                 /* list of base values for non-simple codes */\nush *e;                 /* list of extra bits for non-simple codes */\nstruct huft **t;        /* result: starting table */\nint *m;                 /* maximum lookup bits, returns actual */\n/* Given a list of code lengths and a maximum table size, make a set of\n   tables to decode that set of codes.  Return zero on success, one if\n   the given code set is incomplete (the tables are still built in this\n   case), two if the input is invalid (all zero length codes or an\n   oversubscribed set of lengths), and three if not enough memory. */\n{\n  unsigned a;                   /* counter for codes of length k */\n  unsigned c[BMAX+1];           /* bit length count table */\n  unsigned f;                   /* i repeats in table every f entries */\n  int g;                        /* maximum code length */\n  int h;                        /* table level */\n  register unsigned i;          /* counter, current code */\n  register unsigned j;          /* counter */\n  register int k;               /* number of bits in current code */\n  int l;                        /* bits per table (returned in m) */\n  register unsigned *p;         /* pointer into c[], b[], or v[] */\n  register struct huft *q;      /* points to current table */\n  struct huft r;                /* table entry for structure assignment */\n  struct huft *u[BMAX];         /* table stack */\n  unsigned v[N_MAX];            /* values in order of bit length */\n  register int w;               /* bits before this table == (l * h) */\n  unsigned x[BMAX+1];           /* bit offsets, then code stack */\n  unsigned *xp;                 /* pointer into x */\n  int y;                        /* number of dummy codes added */\n  unsigned z;                   /* number of entries in current table */\n\n\n  /* Generate counts for each bit length */\n  memzero(c, sizeof(c));\n  p = b;  i = n;\n  do {\n    Tracecv(*p, (stderr, (n-i >= ' ' && n-i <= '~' ? \"%c %d\\n\" : \"0x%x %d\\n\"),\n\t    n-i, *p));\n    c[*p]++;                    /* assume all entries <= BMAX */\n    p++;                      /* Can't combine with above line (Solaris bug) */\n  } while (--i);\n  if (c[0] == n)                /* null input--all zero length codes */\n  {\n    q = (struct huft *) malloc (2 * sizeof *q);\n    if (!q)\n      return 3;\n    hufts += 2;\n    q[0].v.t = (struct huft *) NULL;\n    q[1].e = 99;    /* invalid code marker */\n    q[1].b = 1;\n    *t = q + 1;\n    *m = 1;\n    return 0;\n  }\n\n\n  /* Find minimum and maximum length, bound *m by those */\n  l = *m;\n  for (j = 1; j <= BMAX; j++)\n    if (c[j])\n      break;\n  k = j;                        /* minimum code length */\n  if ((unsigned)l < j)\n    l = j;\n  for (i = BMAX; i; i--)\n    if (c[i])\n      break;\n  g = i;                        /* maximum code length */\n  if ((unsigned)l > i)\n    l = i;\n  *m = l;\n\n\n  /* Adjust last length count to fill out codes, if needed */\n  for (y = 1 << j; j < i; j++, y <<= 1)\n    if ((y -= c[j]) < 0)\n      return 2;                 /* bad input: more codes than bits */\n  if ((y -= c[i]) < 0)\n    return 2;\n  c[i] += y;\n\n\n  /* Generate starting offsets into the value table for each length */\n  x[1] = j = 0;\n  p = c + 1;  xp = x + 2;\n  while (--i) {                 /* note that i == g from above */\n    *xp++ = (j += *p++);\n  }\n\n\n  /* Make a table of values in order of bit lengths */\n  p = b;  i = 0;\n  do {\n    if ((j = *p++) != 0)\n      v[x[j]++] = i;\n  } while (++i < n);\n  n = x[g];                   /* set n to length of v */\n\n\n  /* Generate the Huffman codes and for each, make the table entries */\n  x[0] = i = 0;                 /* first Huffman code is zero */\n  p = v;                        /* grab values in bit order */\n  h = -1;                       /* no tables yet--level -1 */\n  w = -l;                       /* bits decoded == (l * h) */\n  u[0] = (struct huft *)NULL;   /* just to keep compilers happy */\n  q = (struct huft *)NULL;      /* ditto */\n  z = 0;                        /* ditto */\n\n  /* go through the bit lengths (k already is bits in shortest code) */\n  for (; k <= g; k++)\n  {\n    a = c[k];\n    while (a--)\n    {\n      /* here i is the Huffman code of length k bits for value *p */\n      /* make tables up to required level */\n      while (k > w + l)\n      {\n        h++;\n        w += l;                 /* previous table always l bits */\n\n        /* compute minimum size table less than or equal to l bits */\n        z = (z = g - w) > (unsigned)l ? l : z;  /* upper limit on table size */\n        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */\n        {                       /* too few codes for k-w bit table */\n          f -= a + 1;           /* deduct codes from patterns left */\n          xp = c + k;\n\t  if (j < z)\n\t    while (++j < z)       /* try smaller tables up to z bits */\n\t    {\n\t      if ((f <<= 1) <= *++xp)\n\t\tbreak;            /* enough codes to use up j bits */\n\t      f -= *xp;           /* else deduct codes from patterns */\n\t    }\n        }\n        z = 1 << j;             /* table entries for j-bit table */\n\n        /* allocate and link in new table */\n        if ((q = (struct huft *)malloc((z + 1)*sizeof(struct huft))) ==\n            (struct huft *)NULL)\n        {\n          if (h)\n            huft_free(u[0]);\n          return 3;             /* not enough memory */\n        }\n        hufts += z + 1;         /* track memory usage */\n        *t = q + 1;             /* link to list for huft_free() */\n        *(t = &(q->v.t)) = (struct huft *)NULL;\n        u[h] = ++q;             /* table starts after link */\n\n        /* connect to last table, if there is one */\n        if (h)\n        {\n          x[h] = i;             /* save pattern for backing up */\n          r.b = (uch)l;         /* bits to dump before this table */\n          r.e = (uch)(16 + j);  /* bits in this table */\n          r.v.t = q;            /* pointer to this table */\n          j = i >> (w - l);     /* (get around Turbo C bug) */\n          u[h-1][j] = r;        /* connect to last table */\n        }\n      }\n\n      /* set up table entry in r */\n      r.b = (uch)(k - w);\n      if (p >= v + n)\n        r.e = 99;               /* out of values--invalid code */\n      else if (*p < s)\n      {\n        r.e = (uch)(*p < 256 ? 16 : 15);    /* 256 is end-of-block code */\n        r.v.n = (ush)(*p);             /* simple code is just the value */\n\tp++;                           /* one compiler does not like *p++ */\n      }\n      else\n      {\n        r.e = (uch)e[*p - s];   /* non-simple--look up in lists */\n        r.v.n = d[*p++ - s];\n      }\n\n      /* fill code-like entries with r */\n      f = 1 << (k - w);\n      for (j = i >> w; j < z; j += f)\n        q[j] = r;\n\n      /* backwards increment the k-bit code i */\n      for (j = 1 << (k - 1); i & j; j >>= 1)\n        i ^= j;\n      i ^= j;\n\n      /* backup over finished tables */\n      while ((i & ((1 << w) - 1)) != x[h])\n      {\n        h--;                    /* don't need to update q */\n        w -= l;\n      }\n    }\n  }\n\n\n  /* Return true (1) if we were given an incomplete table */\n  return y != 0 && g != 1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147548,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int huft_build(b, n, s, d, e, t, m)\nunsigned *b;            /* code lengths in bits (all assumed <= BMAX) */\nunsigned n;             /* number of codes (assumed <= N_MAX) */\nunsigned s;             /* number of simple-valued codes (0..s-1) */\nush *d;                 /* list of base values for non-simple codes */\nush *e;                 /* list of extra bits for non-simple codes */\nstruct huft **t;        /* result: starting table */\nint *m;                 /* maximum lookup bits, returns actual */\n/* Given a list of code lengths and a maximum table size, make a set of\n   tables to decode that set of codes.  Return zero on success, one if\n   the given code set is incomplete (the tables are still built in this\n   case), two if the input is invalid (all zero length codes or an\n   oversubscribed set of lengths), and three if not enough memory. */\n{\n  unsigned a;                   /* counter for codes of length k */\n  unsigned c[BMAX+1];           /* bit length count table */\n  unsigned f;                   /* i repeats in table every f entries */\n  int g;                        /* maximum code length */\n  int h;                        /* table level */\n  register unsigned i;          /* counter, current code */\n  register unsigned j;          /* counter */\n  register int k;               /* number of bits in current code */\n  int l;                        /* bits per table (returned in m) */\n  register unsigned *p;         /* pointer into c[], b[], or v[] */\n  register struct huft *q;      /* points to current table */\n  struct huft r;                /* table entry for structure assignment */\n  struct huft *u[BMAX];         /* table stack */\n  unsigned v[N_MAX];            /* values in order of bit length */\n  register int w;               /* bits before this table == (l * h) */\n  unsigned x[BMAX+1];           /* bit offsets, then code stack */\n  unsigned *xp;                 /* pointer into x */\n  int y;                        /* number of dummy codes added */\n  unsigned z;                   /* number of entries in current table */\n\n\n  /* Generate counts for each bit length */\n  memzero(c, sizeof(c));\n  p = b;  i = n;\n  do {\n    Tracecv(*p, (stderr, (n-i >= ' ' && n-i <= '~' ? \"%c %d\\n\" : \"0x%x %d\\n\"),\n\t    n-i, *p));\n    c[*p]++;                    /* assume all entries <= BMAX */\n    p++;                      /* Can't combine with above line (Solaris bug) */\n  } while (--i);\n  if (c[0] == n)                /* null input--all zero length codes */\n  {\n    q = (struct huft *) malloc (3 * sizeof *q);\n    if (!q)\n      return 3;\n    hufts += 3;\n    q[0].v.t = (struct huft *) NULL;\n    q[1].e = 99;    /* invalid code marker */\n    q[1].b = 1;\n    q[2].e = 99;    /* invalid code marker */\n    q[2].b = 1;\n    *t = q + 1;\n    *m = 1;\n    return 0;\n  }\n\n\n  /* Find minimum and maximum length, bound *m by those */\n  l = *m;\n  for (j = 1; j <= BMAX; j++)\n    if (c[j])\n      break;\n  k = j;                        /* minimum code length */\n  if ((unsigned)l < j)\n    l = j;\n  for (i = BMAX; i; i--)\n    if (c[i])\n      break;\n  g = i;                        /* maximum code length */\n  if ((unsigned)l > i)\n    l = i;\n  *m = l;\n\n\n  /* Adjust last length count to fill out codes, if needed */\n  for (y = 1 << j; j < i; j++, y <<= 1)\n    if ((y -= c[j]) < 0)\n      return 2;                 /* bad input: more codes than bits */\n  if ((y -= c[i]) < 0)\n    return 2;\n  c[i] += y;\n\n\n  /* Generate starting offsets into the value table for each length */\n  x[1] = j = 0;\n  p = c + 1;  xp = x + 2;\n  while (--i) {                 /* note that i == g from above */\n    *xp++ = (j += *p++);\n  }\n\n\n  /* Make a table of values in order of bit lengths */\n  p = b;  i = 0;\n  do {\n    if ((j = *p++) != 0)\n      v[x[j]++] = i;\n  } while (++i < n);\n  n = x[g];                   /* set n to length of v */\n\n\n  /* Generate the Huffman codes and for each, make the table entries */\n  x[0] = i = 0;                 /* first Huffman code is zero */\n  p = v;                        /* grab values in bit order */\n  h = -1;                       /* no tables yet--level -1 */\n  w = -l;                       /* bits decoded == (l * h) */\n  u[0] = (struct huft *)NULL;   /* just to keep compilers happy */\n  q = (struct huft *)NULL;      /* ditto */\n  z = 0;                        /* ditto */\n\n  /* go through the bit lengths (k already is bits in shortest code) */\n  for (; k <= g; k++)\n  {\n    a = c[k];\n    while (a--)\n    {\n      /* here i is the Huffman code of length k bits for value *p */\n      /* make tables up to required level */\n      while (k > w + l)\n      {\n        h++;\n        w += l;                 /* previous table always l bits */\n\n        /* compute minimum size table less than or equal to l bits */\n        z = (z = g - w) > (unsigned)l ? l : z;  /* upper limit on table size */\n        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */\n        {                       /* too few codes for k-w bit table */\n          f -= a + 1;           /* deduct codes from patterns left */\n          xp = c + k;\n\t  if (j < z)\n\t    while (++j < z)       /* try smaller tables up to z bits */\n\t    {\n\t      if ((f <<= 1) <= *++xp)\n\t\tbreak;            /* enough codes to use up j bits */\n\t      f -= *xp;           /* else deduct codes from patterns */\n\t    }\n        }\n        z = 1 << j;             /* table entries for j-bit table */\n\n        /* allocate and link in new table */\n        if ((q = (struct huft *)malloc((z + 1)*sizeof(struct huft))) ==\n            (struct huft *)NULL)\n        {\n          if (h)\n            huft_free(u[0]);\n          return 3;             /* not enough memory */\n        }\n        hufts += z + 1;         /* track memory usage */\n        *t = q + 1;             /* link to list for huft_free() */\n        *(t = &(q->v.t)) = (struct huft *)NULL;\n        u[h] = ++q;             /* table starts after link */\n\n        /* connect to last table, if there is one */\n        if (h)\n        {\n          x[h] = i;             /* save pattern for backing up */\n          r.b = (uch)l;         /* bits to dump before this table */\n          r.e = (uch)(16 + j);  /* bits in this table */\n          r.v.t = q;            /* pointer to this table */\n          j = i >> (w - l);     /* (get around Turbo C bug) */\n          u[h-1][j] = r;        /* connect to last table */\n        }\n      }\n\n      /* set up table entry in r */\n      r.b = (uch)(k - w);\n      if (p >= v + n)\n        r.e = 99;               /* out of values--invalid code */\n      else if (*p < s)\n      {\n        r.e = (uch)(*p < 256 ? 16 : 15);    /* 256 is end-of-block code */\n        r.v.n = (ush)(*p);             /* simple code is just the value */\n\tp++;                           /* one compiler does not like *p++ */\n      }\n      else\n      {\n        r.e = (uch)e[*p - s];   /* non-simple--look up in lists */\n        r.v.n = d[*p++ - s];\n      }\n\n      /* fill code-like entries with r */\n      f = 1 << (k - w);\n      for (j = i >> w; j < z; j += f)\n        q[j] = r;\n\n      /* backwards increment the k-bit code i */\n      for (j = 1 << (k - 1); i & j; j >>= 1)\n        i ^= j;\n      i ^= j;\n\n      /* backup over finished tables */\n      while ((i & ((1 << w) - 1)) != x[h])\n      {\n        h--;                    /* don't need to update q */\n        w -= l;\n      }\n    }\n  }\n\n\n  /* Return true (1) if we were given an incomplete table */\n  return y != 0 && g != 1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147549,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "_gdata_service_build_session (void)\n{\n\tSoupSession *session = soup_session_sync_new ();\n\n#ifdef HAVE_GNOME\n\tsoup_session_add_feature_by_type (session, SOUP_TYPE_GNOME_FEATURES_2_26);\n#endif /* HAVE_GNOME */\n\n\t/* Log all libsoup traffic if debugging's turned on */\n\tif (_gdata_service_get_log_level () > GDATA_LOG_MESSAGES) {\n\t\tSoupLoggerLogLevel level;\n\t\tSoupLogger *logger;\n\n\t\tswitch (_gdata_service_get_log_level ()) {\n\t\t\tcase GDATA_LOG_FULL_UNREDACTED:\n\t\t\tcase GDATA_LOG_FULL:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_BODY;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_HEADERS:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_HEADERS;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_MESSAGES:\n\t\t\tcase GDATA_LOG_NONE:\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tlogger = soup_logger_new (level, -1);\n\t\tsoup_logger_set_printer (logger, (SoupLoggerPrinter) soup_log_printer, NULL, NULL);\n\n\t\tsoup_session_add_feature (session, SOUP_SESSION_FEATURE (logger));\n\n\t\tg_object_unref (logger);\n\t}\n\n\treturn session;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147632,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "_gdata_service_build_session (void)\n{\n\tSoupSession *session = soup_session_sync_new_with_options (SOUP_SESSION_SSL_USE_SYSTEM_CA_FILE, TRUE, NULL);\n\n#ifdef HAVE_GNOME\n\tsoup_session_add_feature_by_type (session, SOUP_TYPE_GNOME_FEATURES_2_26);\n#endif /* HAVE_GNOME */\n\n\t/* Log all libsoup traffic if debugging's turned on */\n\tif (_gdata_service_get_log_level () > GDATA_LOG_MESSAGES) {\n\t\tSoupLoggerLogLevel level;\n\t\tSoupLogger *logger;\n\n\t\tswitch (_gdata_service_get_log_level ()) {\n\t\t\tcase GDATA_LOG_FULL_UNREDACTED:\n\t\t\tcase GDATA_LOG_FULL:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_BODY;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_HEADERS:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_HEADERS;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_MESSAGES:\n\t\t\tcase GDATA_LOG_NONE:\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tlogger = soup_logger_new (level, -1);\n\t\tsoup_logger_set_printer (logger, (SoupLoggerPrinter) soup_log_printer, NULL, NULL);\n\n\t\tsoup_session_add_feature (session, SOUP_SESSION_FEATURE (logger));\n\n\t\tg_object_unref (logger);\n\t}\n\n\treturn session;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147633,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "_gdata_service_build_session (void)\n{\n\tSoupSession *session = soup_session_sync_new ();\n\n#ifdef HAVE_GNOME\n\tsoup_session_add_feature_by_type (session, SOUP_TYPE_GNOME_FEATURES_2_26);\n#endif /* HAVE_GNOME */\n\n\t/* Log all libsoup traffic if debugging's turned on */\n\tif (_gdata_service_get_log_level () > GDATA_LOG_MESSAGES) {\n\t\tSoupLoggerLogLevel level;\n\t\tSoupLogger *logger;\n\n\t\tswitch (_gdata_service_get_log_level ()) {\n\t\t\tcase GDATA_LOG_FULL:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_BODY;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_HEADERS:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_HEADERS;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_MESSAGES:\n\t\t\tcase GDATA_LOG_NONE:\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tlogger = soup_logger_new (level, -1);\n\t\tsoup_logger_set_printer (logger, (SoupLoggerPrinter) soup_log_printer, NULL, NULL);\n\n\t\tsoup_session_add_feature (session, SOUP_SESSION_FEATURE (logger));\n\n\t\tg_object_unref (logger);\n\t}\n\n\treturn session;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147634,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "_gdata_service_build_session (void)\n{\n\tSoupSession *session = soup_session_sync_new_with_options (SOUP_SESSION_SSL_CA_FILE, CA_CERTS, NULL);\n\n#ifdef HAVE_GNOME\n\tsoup_session_add_feature_by_type (session, SOUP_TYPE_GNOME_FEATURES_2_26);\n#endif /* HAVE_GNOME */\n\n\t/* Log all libsoup traffic if debugging's turned on */\n\tif (_gdata_service_get_log_level () > GDATA_LOG_MESSAGES) {\n\t\tSoupLoggerLogLevel level;\n\t\tSoupLogger *logger;\n\n\t\tswitch (_gdata_service_get_log_level ()) {\n\t\t\tcase GDATA_LOG_FULL:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_BODY;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_HEADERS:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_HEADERS;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_MESSAGES:\n\t\t\tcase GDATA_LOG_NONE:\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tlogger = soup_logger_new (level, -1);\n\t\tsoup_logger_set_printer (logger, (SoupLoggerPrinter) soup_log_printer, NULL, NULL);\n\n\t\tsoup_session_add_feature (session, SOUP_SESSION_FEATURE (logger));\n\n\t\tg_object_unref (logger);\n\t}\n\n\treturn session;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147635,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "rfbProcessClientMessage(rfbClientPtr cl)\n{\n    switch (cl->state) {\n    case RFB_PROTOCOL_VERSION:\n        rfbProcessClientProtocolVersion(cl);\n        return;\n    case RFB_SECURITY_TYPE:\n\trfbAuthProcessSecurityTypeMessage(cl);\n\treturn;\n#ifdef VINO_HAVE_GNUTLS\n    case RFB_TLS_HANDSHAKE:\n\trfbAuthProcessTLSHandshake(cl);\n\treturn;\n#endif\n    case RFB_AUTH_TYPE:\n\trfbAuthProcessAuthTypeMessage(cl);\n\treturn;\n    case RFB_AUTHENTICATION:\n        rfbAuthProcessClientMessage(cl);\n        return;\n    case RFB_AUTH_DEFERRED:\n\trfbLog(\"Authentication deferred - ignoring client message\\n\");\n\treturn;\n    case RFB_INITIALISATION:\n        rfbProcessClientInitMessage(cl);\n        return;\n    default:\n        rfbProcessClientNormalMessage(cl);\n        return;\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147638,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "rfbProcessClientMessage(rfbClientPtr cl)\n{\n    switch (cl->state) {\n    case RFB_PROTOCOL_VERSION:\n        rfbProcessClientProtocolVersion(cl);\n        return;\n    case RFB_SECURITY_TYPE:\n\trfbAuthProcessSecurityTypeMessage(cl);\n\treturn;\n#ifdef VINO_HAVE_GNUTLS\n    case RFB_TLS_HANDSHAKE:\n\trfbAuthProcessTLSHandshake(cl);\n\treturn;\n#endif\n    case RFB_AUTH_TYPE:\n\trfbAuthProcessAuthTypeMessage(cl);\n\treturn;\n    case RFB_AUTHENTICATION:\n        rfbAuthProcessClientMessage(cl);\n        return;\n    case RFB_AUTH_DEFERRED:\n\trfbLog(\"Authentication deferred for this client - closing connection\\n\");\n\trfbCloseClient(cl);\n\treturn;\n    case RFB_INITIALISATION:\n        rfbProcessClientInitMessage(cl);\n        return;\n    default:\n        rfbProcessClientNormalMessage(cl);\n        return;\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147639,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "resp_new (const char *head)\n{\n  const char *hdr;\n  int count, size;\n\n  struct response *resp = xnew0 (struct response);\n  resp->data = head;\n\n  if (*head == '\\0')\n    {\n      /* Empty head means that we're dealing with a headerless\n         (HTTP/0.9) response.  In that case, don't set HEADERS at\n         all.  */\n      return resp;\n    }\n\n  /* Split HEAD into header lines, so that resp_header_* functions\n     don't need to do this over and over again.  */\n\n  size = count = 0;\n  hdr = head;\n  while (1)\n    {\n      DO_REALLOC (resp->headers, size, count + 1, const char *);\n      resp->headers[count++] = hdr;\n\n      /* Break upon encountering an empty line. */\n      if (!hdr[0] || (hdr[0] == '\\r' && hdr[1] == '\\n') || hdr[0] == '\\n')\n        break;\n\n      /* Find the end of HDR, including continuations. */\n      do\n        {\n          const char *end = strchr (hdr, '\\n');\n          if (end)\n            hdr = end + 1;\n          else\n            hdr += strlen (hdr);\n        }\n      while (*hdr == ' ' || *hdr == '\\t');\n    }\n  DO_REALLOC (resp->headers, size, count + 1, const char *);\n  resp->headers[count] = NULL;\n\n  return resp;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147676,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "resp_new (char *head)\n{\n  char *hdr;\n  int count, size;\n\n  struct response *resp = xnew0 (struct response);\n  resp->data = head;\n\n  if (*head == '\\0')\n    {\n      /* Empty head means that we're dealing with a headerless\n         (HTTP/0.9) response.  In that case, don't set HEADERS at\n         all.  */\n      return resp;\n    }\n\n  /* Split HEAD into header lines, so that resp_header_* functions\n     don't need to do this over and over again.  */\n\n  size = count = 0;\n  hdr = head;\n  while (1)\n    {\n      DO_REALLOC (resp->headers, size, count + 1, const char *);\n      resp->headers[count++] = hdr;\n\n      /* Break upon encountering an empty line. */\n      if (!hdr[0] || (hdr[0] == '\\r' && hdr[1] == '\\n') || hdr[0] == '\\n')\n        break;\n\n      /* Find the end of HDR, including continuations. */\n      for (;;)\n        {\n          char *end = strchr (hdr, '\\n');\n\n          if (end)\n            hdr = end + 1;\n          else\n            hdr += strlen (hdr);\n\n          if (*hdr != ' ' && *hdr != '\\t')\n            break;\n\n          // continuation, transform \\r and \\n into spaces\n          *end = ' ';\n          if (end > head && end[-1] == '\\r')\n            end[-1] = ' ';\n        }\n    }\n  DO_REALLOC (resp->headers, size, count + 1, const char *);\n  resp->headers[count] = NULL;\n\n  return resp;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147677,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int ocfs2_prepare_page_for_write(struct inode *inode, u64 *p_blkno,\n\t\t\t\t\tstruct ocfs2_write_ctxt *wc,\n\t\t\t\t\tstruct page *page, u32 cpos,\n\t\t\t\t\tloff_t user_pos, unsigned user_len,\n\t\t\t\t\tint new)\n{\n\tint ret;\n\tunsigned int map_from = 0, map_to = 0;\n\tunsigned int cluster_start, cluster_end;\n\tunsigned int user_data_from = 0, user_data_to = 0;\n\n\tocfs2_figure_cluster_boundaries(OCFS2_SB(inode->i_sb), cpos,\n\t\t\t\t\t&cluster_start, &cluster_end);\n\n\tif (page == wc->w_target_page) {\n\t\tmap_from = user_pos & (PAGE_CACHE_SIZE - 1);\n\t\tmap_to = map_from + user_len;\n\n\t\tif (new)\n\t\t\tret = ocfs2_map_page_blocks(page, p_blkno, inode,\n\t\t\t\t\t\t    cluster_start, cluster_end,\n\t\t\t\t\t\t    new);\n\t\telse\n\t\t\tret = ocfs2_map_page_blocks(page, p_blkno, inode,\n\t\t\t\t\t\t    map_from, map_to, new);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tuser_data_from = map_from;\n\t\tuser_data_to = map_to;\n\t\tif (new) {\n\t\t\tmap_from = cluster_start;\n\t\t\tmap_to = cluster_end;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * If we haven't allocated the new page yet, we\n\t\t * shouldn't be writing it out without copying user\n\t\t * data. This is likely a math error from the caller.\n\t\t */\n\t\tBUG_ON(!new);\n\n\t\tmap_from = cluster_start;\n\t\tmap_to = cluster_end;\n\n\t\tret = ocfs2_map_page_blocks(page, p_blkno, inode,\n\t\t\t\t\t    cluster_start, cluster_end, new);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Parts of newly allocated pages need to be zero'd.\n\t *\n\t * Above, we have also rewritten 'to' and 'from' - as far as\n\t * the rest of the function is concerned, the entire cluster\n\t * range inside of a page needs to be written.\n\t *\n\t * We can skip this if the page is up to date - it's already\n\t * been zero'd from being read in as a hole.\n\t */\n\tif (new && !PageUptodate(page))\n\t\tocfs2_clear_page_regions(page, OCFS2_SB(inode->i_sb),\n\t\t\t\t\t cpos, user_data_from, user_data_to);\n\n\tflush_dcache_page(page);\n\nout:\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147692,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int ocfs2_prepare_page_for_write(struct inode *inode, u64 *p_blkno,\n\t\t\t\t\tstruct ocfs2_write_ctxt *wc,\n\t\t\t\t\tstruct page *page, u32 cpos,\n\t\t\t\t\tloff_t user_pos, unsigned user_len,\n\t\t\t\t\tint new)\n{\n\tint ret;\n\tunsigned int map_from = 0, map_to = 0;\n\tunsigned int cluster_start, cluster_end;\n\tunsigned int user_data_from = 0, user_data_to = 0;\n\n\tocfs2_figure_cluster_boundaries(OCFS2_SB(inode->i_sb), cpos,\n\t\t\t\t\t&cluster_start, &cluster_end);\n\n\t/* treat the write as new if the a hole/lseek spanned across\n\t * the page boundary.\n\t */\n\tnew = new | ((i_size_read(inode) <= page_offset(page)) &&\n\t\t\t(page_offset(page) <= user_pos));\n\n\tif (page == wc->w_target_page) {\n\t\tmap_from = user_pos & (PAGE_CACHE_SIZE - 1);\n\t\tmap_to = map_from + user_len;\n\n\t\tif (new)\n\t\t\tret = ocfs2_map_page_blocks(page, p_blkno, inode,\n\t\t\t\t\t\t    cluster_start, cluster_end,\n\t\t\t\t\t\t    new);\n\t\telse\n\t\t\tret = ocfs2_map_page_blocks(page, p_blkno, inode,\n\t\t\t\t\t\t    map_from, map_to, new);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tuser_data_from = map_from;\n\t\tuser_data_to = map_to;\n\t\tif (new) {\n\t\t\tmap_from = cluster_start;\n\t\t\tmap_to = cluster_end;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * If we haven't allocated the new page yet, we\n\t\t * shouldn't be writing it out without copying user\n\t\t * data. This is likely a math error from the caller.\n\t\t */\n\t\tBUG_ON(!new);\n\n\t\tmap_from = cluster_start;\n\t\tmap_to = cluster_end;\n\n\t\tret = ocfs2_map_page_blocks(page, p_blkno, inode,\n\t\t\t\t\t    cluster_start, cluster_end, new);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Parts of newly allocated pages need to be zero'd.\n\t *\n\t * Above, we have also rewritten 'to' and 'from' - as far as\n\t * the rest of the function is concerned, the entire cluster\n\t * range inside of a page needs to be written.\n\t *\n\t * We can skip this if the page is up to date - it's already\n\t * been zero'd from being read in as a hole.\n\t */\n\tif (new && !PageUptodate(page))\n\t\tocfs2_clear_page_regions(page, OCFS2_SB(inode->i_sb),\n\t\t\t\t\t cpos, user_data_from, user_data_to);\n\n\tflush_dcache_page(page);\n\nout:\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147693,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int tls_decrypt_ticket(SSL *s, const unsigned char *etick, int eticklen,\n\t\t\t\tconst unsigned char *sess_id, int sesslen,\n\t\t\t\tSSL_SESSION **psess)\n\t{\n\tSSL_SESSION *sess;\n\tunsigned char *sdec;\n\tconst unsigned char *p;\n\tint slen, mlen, renew_ticket = 0;\n\tunsigned char tick_hmac[EVP_MAX_MD_SIZE];\n\tHMAC_CTX hctx;\n\tEVP_CIPHER_CTX ctx;\n\tSSL_CTX *tctx = s->initial_ctx;\n\t/* Need at least keyname + iv + some encrypted data */\n\tif (eticklen < 48)\n\t\tgoto tickerr;\n\t/* Initialize session ticket encryption and HMAC contexts */\n\tHMAC_CTX_init(&hctx);\n\tEVP_CIPHER_CTX_init(&ctx);\n\tif (tctx->tlsext_ticket_key_cb)\n\t\t{\n\t\tunsigned char *nctick = (unsigned char *)etick;\n\t\tint rv = tctx->tlsext_ticket_key_cb(s, nctick, nctick + 16,\n\t\t\t\t\t\t\t&ctx, &hctx, 0);\n\t\tif (rv < 0)\n\t\t\treturn -1;\n\t\tif (rv == 0)\n\t\t\tgoto tickerr;\n\t\tif (rv == 2)\n\t\t\trenew_ticket = 1;\n\t\t}\n\telse\n\t\t{\n\t\t/* Check key name matches */\n\t\tif (memcmp(etick, tctx->tlsext_tick_key_name, 16))\n\t\t\tgoto tickerr;\n\t\tHMAC_Init_ex(&hctx, tctx->tlsext_tick_hmac_key, 16,\n\t\t\t\t\ttlsext_tick_md(), NULL);\n\t\tEVP_DecryptInit_ex(&ctx, EVP_aes_128_cbc(), NULL,\n\t\t\t\ttctx->tlsext_tick_aes_key, etick + 16);\n\t\t}\n\t/* Attempt to process session ticket, first conduct sanity and\n \t * integrity checks on ticket.\n \t */\n\tmlen = HMAC_size(&hctx);\n\teticklen -= mlen;\n\t/* Check HMAC of encrypted ticket */\n\tHMAC_Update(&hctx, etick, eticklen);\n\tHMAC_Final(&hctx, tick_hmac, NULL);\n\tHMAC_CTX_cleanup(&hctx);\n\tif (CRYPTO_memcmp(tick_hmac, etick + eticklen, mlen))\n\t\tgoto tickerr;\n\t/* Attempt to decrypt session data */\n\t/* Move p after IV to start of encrypted ticket, update length */\n\tp = etick + 16 + EVP_CIPHER_CTX_iv_length(&ctx);\n\teticklen -= 16 + EVP_CIPHER_CTX_iv_length(&ctx);\n\tsdec = OPENSSL_malloc(eticklen);\n\tif (!sdec)\n\t\t{\n\t\tEVP_CIPHER_CTX_cleanup(&ctx);\n\t\treturn -1;\n\t\t}\n\tEVP_DecryptUpdate(&ctx, sdec, &slen, p, eticklen);\n\tif (EVP_DecryptFinal(&ctx, sdec + slen, &mlen) <= 0)\n\t\t{\n\t\tEVP_CIPHER_CTX_cleanup(&ctx);\n\t\tOPENSSL_free(sdec);\n\t\tgoto tickerr;\n\t\t}\n\tslen += mlen;\n\tEVP_CIPHER_CTX_cleanup(&ctx);\n\tp = sdec;\n\t\t\n\tsess = d2i_SSL_SESSION(NULL, &p, slen);\n\tOPENSSL_free(sdec);\n\tif (sess)\n\t\t{\n\t\t/* The session ID if non-empty is used by some clients to\n \t\t * detect that the ticket has been accepted. So we copy it to\n \t\t * the session structure. If it is empty set length to zero\n \t\t * as required by standard.\n \t\t */\n\t\tif (sesslen)\n\t\t\tmemcpy(sess->session_id, sess_id, sesslen);\n\t\tsess->session_id_length = sesslen;\n\t\t*psess = sess;\n\t\ts->tlsext_ticket_expected = renew_ticket;\n\t\treturn 1;\n\t\t}\n\t/* If session decrypt failure indicate a cache miss and set state to\n \t * send a new ticket\n \t */\n\ttickerr:\t\n\ts->tlsext_ticket_expected = 1;\n\treturn 0;\n\t}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147711,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int tls_decrypt_ticket(SSL *s, const unsigned char *etick, int eticklen,\n\t\t\t\tconst unsigned char *sess_id, int sesslen,\n\t\t\t\tSSL_SESSION **psess)\n\t{\n\tSSL_SESSION *sess;\n\tunsigned char *sdec;\n\tconst unsigned char *p;\n\tint slen, mlen, renew_ticket = 0;\n\tunsigned char tick_hmac[EVP_MAX_MD_SIZE];\n\tHMAC_CTX hctx;\n\tEVP_CIPHER_CTX ctx;\n\tSSL_CTX *tctx = s->initial_ctx;\n\t/* Need at least keyname + iv + some encrypted data */\n\tif (eticklen < 48)\n\t\tgoto tickerr;\n\t/* Initialize session ticket encryption and HMAC contexts */\n\tHMAC_CTX_init(&hctx);\n\tEVP_CIPHER_CTX_init(&ctx);\n\tif (tctx->tlsext_ticket_key_cb)\n\t\t{\n\t\tunsigned char *nctick = (unsigned char *)etick;\n\t\tint rv = tctx->tlsext_ticket_key_cb(s, nctick, nctick + 16,\n\t\t\t\t\t\t\t&ctx, &hctx, 0);\n\t\tif (rv < 0)\n\t\t\treturn -1;\n\t\tif (rv == 0)\n\t\t\tgoto tickerr;\n\t\tif (rv == 2)\n\t\t\trenew_ticket = 1;\n\t\t}\n\telse\n\t\t{\n\t\t/* Check key name matches */\n\t\tif (memcmp(etick, tctx->tlsext_tick_key_name, 16))\n\t\t\tgoto tickerr;\n\t\tHMAC_Init_ex(&hctx, tctx->tlsext_tick_hmac_key, 16,\n\t\t\t\t\ttlsext_tick_md(), NULL);\n\t\tEVP_DecryptInit_ex(&ctx, EVP_aes_128_cbc(), NULL,\n\t\t\t\ttctx->tlsext_tick_aes_key, etick + 16);\n\t\t}\n\t/* Attempt to process session ticket, first conduct sanity and\n \t * integrity checks on ticket.\n \t */\n\tmlen = HMAC_size(&hctx);\n\teticklen -= mlen;\n\t/* Check HMAC of encrypted ticket */\n\tHMAC_Update(&hctx, etick, eticklen);\n\tHMAC_Final(&hctx, tick_hmac, NULL);\n\tHMAC_CTX_cleanup(&hctx);\n\tif (CRYPTO_memcmp(tick_hmac, etick + eticklen, mlen))\n\t\t{\n\t\tEVP_CIPHER_CTX_cleanup(&ctx);\n\t\tgoto tickerr;\n\t\t}\n\t/* Attempt to decrypt session data */\n\t/* Move p after IV to start of encrypted ticket, update length */\n\tp = etick + 16 + EVP_CIPHER_CTX_iv_length(&ctx);\n\teticklen -= 16 + EVP_CIPHER_CTX_iv_length(&ctx);\n\tsdec = OPENSSL_malloc(eticklen);\n\tif (!sdec)\n\t\t{\n\t\tEVP_CIPHER_CTX_cleanup(&ctx);\n\t\treturn -1;\n\t\t}\n\tEVP_DecryptUpdate(&ctx, sdec, &slen, p, eticklen);\n\tif (EVP_DecryptFinal(&ctx, sdec + slen, &mlen) <= 0)\n\t\t{\n\t\tEVP_CIPHER_CTX_cleanup(&ctx);\n\t\tOPENSSL_free(sdec);\n\t\tgoto tickerr;\n\t\t}\n\tslen += mlen;\n\tEVP_CIPHER_CTX_cleanup(&ctx);\n\tp = sdec;\n\t\t\n\tsess = d2i_SSL_SESSION(NULL, &p, slen);\n\tOPENSSL_free(sdec);\n\tif (sess)\n\t\t{\n\t\t/* The session ID if non-empty is used by some clients to\n \t\t * detect that the ticket has been accepted. So we copy it to\n \t\t * the session structure. If it is empty set length to zero\n \t\t * as required by standard.\n \t\t */\n\t\tif (sesslen)\n\t\t\tmemcpy(sess->session_id, sess_id, sesslen);\n\t\tsess->session_id_length = sesslen;\n\t\t*psess = sess;\n\t\ts->tlsext_ticket_expected = renew_ticket;\n\t\treturn 1;\n\t\t}\n\t/* If session decrypt failure indicate a cache miss and set state to\n \t * send a new ticket\n \t */\n\ttickerr:\t\n\ts->tlsext_ticket_expected = 1;\n\treturn 0;\n\t}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147712,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int tls_decrypt_ticket(SSL *s, const unsigned char *etick,\n                              int eticklen, const unsigned char *sess_id,\n                              int sesslen, SSL_SESSION **psess)\n{\n    SSL_SESSION *sess;\n    unsigned char *sdec;\n    const unsigned char *p;\n    int slen, mlen, renew_ticket = 0;\n    unsigned char tick_hmac[EVP_MAX_MD_SIZE];\n    HMAC_CTX hctx;\n    EVP_CIPHER_CTX ctx;\n    SSL_CTX *tctx = s->initial_ctx;\n    /* Need at least keyname + iv + some encrypted data */\n    if (eticklen < 48)\n        return 2;\n    /* Initialize session ticket encryption and HMAC contexts */\n    HMAC_CTX_init(&hctx);\n    EVP_CIPHER_CTX_init(&ctx);\n    if (tctx->tlsext_ticket_key_cb) {\n        unsigned char *nctick = (unsigned char *)etick;\n        int rv = tctx->tlsext_ticket_key_cb(s, nctick, nctick + 16,\n                                            &ctx, &hctx, 0);\n        if (rv < 0)\n            return -1;\n        if (rv == 0)\n            return 2;\n        if (rv == 2)\n            renew_ticket = 1;\n    } else {\n        /* Check key name matches */\n        if (memcmp(etick, tctx->tlsext_tick_key_name, 16))\n            return 2;\n        if (HMAC_Init_ex(&hctx, tctx->tlsext_tick_hmac_key, 16,\n                         tlsext_tick_md(), NULL) <= 0\n                || EVP_DecryptInit_ex(&ctx, EVP_aes_128_cbc(), NULL,\n                                      tctx->tlsext_tick_aes_key,\n                                      etick + 16) <= 0) {\n            goto err;\n       }\n    }\n    /*\n     * Attempt to process session ticket, first conduct sanity and integrity\n     * checks on ticket.\n     */\n    mlen = HMAC_size(&hctx);\n    if (mlen < 0) {\n        goto err;\n    }\n    eticklen -= mlen;\n    /* Check HMAC of encrypted ticket */\n    if (HMAC_Update(&hctx, etick, eticklen) <= 0\n            || HMAC_Final(&hctx, tick_hmac, NULL) <= 0) {\n        goto err;\n    }\n    HMAC_CTX_cleanup(&hctx);\n    if (CRYPTO_memcmp(tick_hmac, etick + eticklen, mlen)) {\n        EVP_CIPHER_CTX_cleanup(&ctx);\n        return 2;\n    }\n    /* Attempt to decrypt session data */\n    /* Move p after IV to start of encrypted ticket, update length */\n    p = etick + 16 + EVP_CIPHER_CTX_iv_length(&ctx);\n    eticklen -= 16 + EVP_CIPHER_CTX_iv_length(&ctx);\n    sdec = OPENSSL_malloc(eticklen);\n    if (sdec == NULL\n            || EVP_DecryptUpdate(&ctx, sdec, &slen, p, eticklen) <= 0) {\n        EVP_CIPHER_CTX_cleanup(&ctx);\n        OPENSSL_free(sdec);\n        return -1;\n    }\n    if (EVP_DecryptFinal(&ctx, sdec + slen, &mlen) <= 0) {\n        EVP_CIPHER_CTX_cleanup(&ctx);\n        OPENSSL_free(sdec);\n        return 2;\n    }\n    slen += mlen;\n    EVP_CIPHER_CTX_cleanup(&ctx);\n    p = sdec;\n\n    sess = d2i_SSL_SESSION(NULL, &p, slen);\n    OPENSSL_free(sdec);\n    if (sess) {\n        /*\n         * The session ID, if non-empty, is used by some clients to detect\n         * that the ticket has been accepted. So we copy it to the session\n         * structure. If it is empty set length to zero as required by\n         * standard.\n         */\n        if (sesslen)\n            memcpy(sess->session_id, sess_id, sesslen);\n        sess->session_id_length = sesslen;\n        *psess = sess;\n        if (renew_ticket)\n            return 4;\n        else\n            return 3;\n    }\n    ERR_clear_error();\n    /*\n     * For session parse failure, indicate that we need to send a new ticket.\n     */\n    return 2;\nerr:\n    EVP_CIPHER_CTX_cleanup(&ctx);\n    HMAC_CTX_cleanup(&hctx);\n    return -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147731,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void auth_policy_create_json(struct policy_lookup_ctx *context,\n\tconst char *password, bool include_success)\n{\n\tconst struct var_expand_table *var_table;\n\tcontext->json = str_new(context->pool, 64);\n\tunsigned char *ptr;\n\tconst struct hash_method *digest = hash_method_lookup(context->set->policy_hash_mech);\n\n\ti_assert(digest != NULL);\n\n\tvoid *ctx = t_malloc(digest->context_size);\n\tstring_t *buffer = t_str_new(64);\n\n\tdigest->init(ctx);\n\tdigest->loop(ctx,\n\t\tcontext->set->policy_hash_nonce,\n\t\tstrlen(context->set->policy_hash_nonce));\n\t/* use +1 to make sure \\0 gets included */\n\tdigest->loop(ctx, context->request->user, strlen(context->request->user) + 1);\n\tif (password != NULL)\n\t\tdigest->loop(ctx, password, strlen(password));\n\tptr = (unsigned char*)str_c_modifiable(buffer);\n\tdigest->result(ctx, ptr);\n\tstr_truncate(buffer, digest->digest_size);\n\tif (context->set->policy_hash_truncate > 0) {\n\t\tbuffer_truncate_rshift_bits(buffer, context->set->policy_hash_truncate);\n\t}\n\tconst char *hashed_password = binary_to_hex(str_data(buffer), str_len(buffer));\n\tstr_append_c(context->json, '{');\n\tvar_table = policy_get_var_expand_table(context->request, hashed_password);\n\tauth_request_var_expand_with_table(context->json, auth_policy_json_template,\n\t\t\t\t\t   context->request, var_table,\n\t\t\t\t\t   auth_policy_escape_function);\n\tif (include_success) {\n\t\tstr_append(context->json, \",\\\"success\\\":\");\n\t\tif (!context->request->failed && context->request->successful &&\n\t\t    !context->request->internal_failure)\n\t\t\tstr_append(context->json, \"true\");\n\t\telse\n\t\t\tstr_append(context->json, \"false\");\n\t\tstr_append(context->json, \",\\\"policy_reject\\\":\");\n\t\tstr_append(context->json, context->request->policy_refusal ? \"true\" : \"false\");\n\t}\n\tstr_append_c(context->json, '}');\n\tauth_request_log_debug(context->request, \"policy\",\n\t\t\"Policy server request JSON: %s\", str_c(context->json));\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147734,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "void auth_policy_create_json(struct policy_lookup_ctx *context,\n\tconst char *password, bool include_success)\n{\n\tconst struct var_expand_table *var_table;\n\tcontext->json = str_new(context->pool, 64);\n\tunsigned char *ptr;\n\tconst struct hash_method *digest = hash_method_lookup(context->set->policy_hash_mech);\n\n\ti_assert(digest != NULL);\n\n\tvoid *ctx = t_malloc(digest->context_size);\n\tstring_t *buffer = t_str_new(64);\n\n\tdigest->init(ctx);\n\tdigest->loop(ctx,\n\t\tcontext->set->policy_hash_nonce,\n\t\tstrlen(context->set->policy_hash_nonce));\n\t/* use +1 to make sure \\0 gets included */\n\tif (context->request->user == NULL)\n\t\tdigest->loop(ctx, \"\\0\", 1);\n\telse\n\t\tdigest->loop(ctx, context->request->user, strlen(context->request->user) + 1);\n\tif (password != NULL)\n\t\tdigest->loop(ctx, password, strlen(password));\n\tptr = (unsigned char*)str_c_modifiable(buffer);\n\tdigest->result(ctx, ptr);\n\tstr_truncate(buffer, digest->digest_size);\n\tif (context->set->policy_hash_truncate > 0) {\n\t\tbuffer_truncate_rshift_bits(buffer, context->set->policy_hash_truncate);\n\t}\n\tconst char *hashed_password = binary_to_hex(str_data(buffer), str_len(buffer));\n\tstr_append_c(context->json, '{');\n\tvar_table = policy_get_var_expand_table(context->request, hashed_password);\n\tauth_request_var_expand_with_table(context->json, auth_policy_json_template,\n\t\t\t\t\t   context->request, var_table,\n\t\t\t\t\t   auth_policy_escape_function);\n\tif (include_success) {\n\t\tstr_append(context->json, \",\\\"success\\\":\");\n\t\tif (!context->request->failed && context->request->successful &&\n\t\t    !context->request->internal_failure)\n\t\t\tstr_append(context->json, \"true\");\n\t\telse\n\t\t\tstr_append(context->json, \"false\");\n\t\tstr_append(context->json, \",\\\"policy_reject\\\":\");\n\t\tstr_append(context->json, context->request->policy_refusal ? \"true\" : \"false\");\n\t}\n\tstr_append_c(context->json, '}');\n\tauth_request_log_debug(context->request, \"policy\",\n\t\t\"Policy server request JSON: %s\", str_c(context->json));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147735,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "DECLAREContigPutFunc(putagreytile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    uint32** BWmap = img->BWmap;\n\n    (void) y;\n    while (h-- > 0) {\n\tfor (x = w; x-- > 0;)\n        {\n            *cp++ = BWmap[*pp][0] & (*(pp+1) << 24 | ~A1);\n            pp += samplesperpixel;\n        }\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147742,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "DECLAREContigPutFunc(putagreytile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    uint32** BWmap = img->BWmap;\n\n    (void) y;\n    while (h-- > 0) {\n\tfor (x = w; x-- > 0;)\n        {\n            *cp++ = BWmap[*pp][0] & ((uint32)*(pp+1) << 24 | ~A1);\n            pp += samplesperpixel;\n        }\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147743,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "JPEGSetupEncode(TIFF* tif)\n{\n\tJPEGState* sp = JState(tif);\n\tTIFFDirectory *td = &tif->tif_dir;\n\tstatic const char module[] = \"JPEGSetupEncode\";\n\n#if defined(JPEG_DUAL_MODE_8_12) && !defined(TIFFInitJPEG)\n        if( tif->tif_dir.td_bitspersample == 12 )\n            return TIFFReInitJPEG_12( tif, COMPRESSION_JPEG, 1 );\n#endif\n\n        JPEGInitializeLibJPEG( tif, FALSE );\n\n\tassert(sp != NULL);\n\tassert(!sp->cinfo.comm.is_decompressor);\n\n\tsp->photometric = td->td_photometric;\n\n\t/*\n\t * Initialize all JPEG parameters to default values.\n\t * Note that jpeg_set_defaults needs legal values for\n\t * in_color_space and input_components.\n\t */\n\tif (td->td_planarconfig == PLANARCONFIG_CONTIG) {\n\t\tsp->cinfo.c.input_components = td->td_samplesperpixel;\n\t\tif (sp->photometric == PHOTOMETRIC_YCBCR) {\n\t\t\tif (sp->jpegcolormode == JPEGCOLORMODE_RGB) {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\t} else {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_YCbCr;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((td->td_photometric == PHOTOMETRIC_MINISWHITE || td->td_photometric == PHOTOMETRIC_MINISBLACK) && td->td_samplesperpixel == 1)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_GRAYSCALE;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_RGB && td->td_samplesperpixel == 3)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_SEPARATED && td->td_samplesperpixel == 4)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_CMYK;\n\t\t\telse\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t\t}\n\t} else {\n\t\tsp->cinfo.c.input_components = 1;\n\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t}\n\tif (!TIFFjpeg_set_defaults(sp))\n\t\treturn (0);\n\t/* Set per-file parameters */\n\tswitch (sp->photometric) {\n\tcase PHOTOMETRIC_YCBCR:\n\t\tsp->h_sampling = td->td_ycbcrsubsampling[0];\n\t\tsp->v_sampling = td->td_ycbcrsubsampling[1];\n                if( sp->h_sampling == 0 || sp->v_sampling == 0 )\n                {\n                    TIFFErrorExt(tif->tif_clientdata, module,\n                            \"Invalig horizontal/vertical sampling value\");\n                    return (0);\n                }\n\n\t\t/*\n\t\t * A ReferenceBlackWhite field *must* be present since the\n\t\t * default value is inappropriate for YCbCr.  Fill in the\n\t\t * proper value if application didn't set it.\n\t\t */\n\t\t{\n\t\t\tfloat *ref;\n\t\t\tif (!TIFFGetField(tif, TIFFTAG_REFERENCEBLACKWHITE,\n\t\t\t\t\t  &ref)) {\n\t\t\t\tfloat refbw[6];\n\t\t\t\tlong top = 1L << td->td_bitspersample;\n\t\t\t\trefbw[0] = 0;\n\t\t\t\trefbw[1] = (float)(top-1L);\n\t\t\t\trefbw[2] = (float)(top>>1);\n\t\t\t\trefbw[3] = refbw[1];\n\t\t\t\trefbw[4] = refbw[2];\n\t\t\t\trefbw[5] = refbw[1];\n\t\t\t\tTIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE,\n\t\t\t\t\t     refbw);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PHOTOMETRIC_PALETTE:\t\t/* disallowed by Tech Note */\n\tcase PHOTOMETRIC_MASK:\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t  \"PhotometricInterpretation %d not allowed for JPEG\",\n\t\t\t  (int) sp->photometric);\n\t\treturn (0);\n\tdefault:\n\t\t/* TIFF 6.0 forbids subsampling of all other color spaces */\n\t\tsp->h_sampling = 1;\n\t\tsp->v_sampling = 1;\n\t\tbreak;\n\t}\n\n\t/* Verify miscellaneous parameters */\n\n\t/*\n\t * This would need work if libtiff ever supports different\n\t * depths for different components, or if libjpeg ever supports\n\t * run-time selection of depth.  Neither is imminent.\n\t */\n#ifdef JPEG_LIB_MK1\n        /* BITS_IN_JSAMPLE now permits 8 and 12 --- dgilbert */\n\tif (td->td_bitspersample != 8 && td->td_bitspersample != 12) \n#else\n\tif (td->td_bitspersample != BITS_IN_JSAMPLE )\n#endif\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"BitsPerSample %d not allowed for JPEG\",\n\t\t\t  (int) td->td_bitspersample);\n\t\treturn (0);\n\t}\n\tsp->cinfo.c.data_precision = td->td_bitspersample;\n#ifdef JPEG_LIB_MK1\n        sp->cinfo.c.bits_in_jsample = td->td_bitspersample;\n#endif\n\tif (isTiled(tif)) {\n\t\tif ((td->td_tilelength % (sp->v_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"JPEG tile height must be multiple of %d\",\n\t\t\t\t  sp->v_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t\tif ((td->td_tilewidth % (sp->h_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"JPEG tile width must be multiple of %d\",\n\t\t\t\t  sp->h_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\tif (td->td_rowsperstrip < td->td_imagelength &&\n\t\t    (td->td_rowsperstrip % (sp->v_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"RowsPerStrip must be multiple of %d for JPEG\",\n\t\t\t\t  sp->v_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/* Create a JPEGTables field if appropriate */\n\tif (sp->jpegtablesmode & (JPEGTABLESMODE_QUANT|JPEGTABLESMODE_HUFF)) {\n                if( sp->jpegtables == NULL\n                    || memcmp(sp->jpegtables,\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\",8) == 0 )\n                {\n                        if (!prepare_JPEGTables(tif))\n                                return (0);\n                        /* Mark the field present */\n                        /* Can't use TIFFSetField since BEENWRITING is already set! */\n                        tif->tif_flags |= TIFF_DIRTYDIRECT;\n                        TIFFSetFieldBit(tif, FIELD_JPEGTABLES);\n                }\n\t} else {\n\t\t/* We do not support application-supplied JPEGTables, */\n\t\t/* so mark the field not present */\n\t\tTIFFClrFieldBit(tif, FIELD_JPEGTABLES);\n\t}\n\n\t/* Direct libjpeg output to libtiff's output buffer */\n\tTIFFjpeg_data_dest(sp, tif);\n\n\treturn (1);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147744,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "JPEGSetupEncode(TIFF* tif)\n{\n\tJPEGState* sp = JState(tif);\n\tTIFFDirectory *td = &tif->tif_dir;\n\tstatic const char module[] = \"JPEGSetupEncode\";\n\n#if defined(JPEG_DUAL_MODE_8_12) && !defined(TIFFInitJPEG)\n        if( tif->tif_dir.td_bitspersample == 12 )\n            return TIFFReInitJPEG_12( tif, COMPRESSION_JPEG, 1 );\n#endif\n\n        JPEGInitializeLibJPEG( tif, FALSE );\n\n\tassert(sp != NULL);\n\tassert(!sp->cinfo.comm.is_decompressor);\n\n\tsp->photometric = td->td_photometric;\n\n\t/*\n\t * Initialize all JPEG parameters to default values.\n\t * Note that jpeg_set_defaults needs legal values for\n\t * in_color_space and input_components.\n\t */\n\tif (td->td_planarconfig == PLANARCONFIG_CONTIG) {\n\t\tsp->cinfo.c.input_components = td->td_samplesperpixel;\n\t\tif (sp->photometric == PHOTOMETRIC_YCBCR) {\n\t\t\tif (sp->jpegcolormode == JPEGCOLORMODE_RGB) {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\t} else {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_YCbCr;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((td->td_photometric == PHOTOMETRIC_MINISWHITE || td->td_photometric == PHOTOMETRIC_MINISBLACK) && td->td_samplesperpixel == 1)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_GRAYSCALE;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_RGB && td->td_samplesperpixel == 3)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_SEPARATED && td->td_samplesperpixel == 4)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_CMYK;\n\t\t\telse\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t\t}\n\t} else {\n\t\tsp->cinfo.c.input_components = 1;\n\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t}\n\tif (!TIFFjpeg_set_defaults(sp))\n\t\treturn (0);\n\t/* Set per-file parameters */\n\tswitch (sp->photometric) {\n\tcase PHOTOMETRIC_YCBCR:\n\t\tsp->h_sampling = td->td_ycbcrsubsampling[0];\n\t\tsp->v_sampling = td->td_ycbcrsubsampling[1];\n                if( sp->h_sampling == 0 || sp->v_sampling == 0 )\n                {\n                    TIFFErrorExt(tif->tif_clientdata, module,\n                            \"Invalig horizontal/vertical sampling value\");\n                    return (0);\n                }\n                if( td->td_bitspersample > 16 )\n                {\n                    TIFFErrorExt(tif->tif_clientdata, module,\n                                 \"BitsPerSample %d not allowed for JPEG\",\n                                 td->td_bitspersample);\n                    return (0);\n                }\n\n\t\t/*\n\t\t * A ReferenceBlackWhite field *must* be present since the\n\t\t * default value is inappropriate for YCbCr.  Fill in the\n\t\t * proper value if application didn't set it.\n\t\t */\n\t\t{\n\t\t\tfloat *ref;\n\t\t\tif (!TIFFGetField(tif, TIFFTAG_REFERENCEBLACKWHITE,\n\t\t\t\t\t  &ref)) {\n\t\t\t\tfloat refbw[6];\n\t\t\t\tlong top = 1L << td->td_bitspersample;\n\t\t\t\trefbw[0] = 0;\n\t\t\t\trefbw[1] = (float)(top-1L);\n\t\t\t\trefbw[2] = (float)(top>>1);\n\t\t\t\trefbw[3] = refbw[1];\n\t\t\t\trefbw[4] = refbw[2];\n\t\t\t\trefbw[5] = refbw[1];\n\t\t\t\tTIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE,\n\t\t\t\t\t     refbw);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PHOTOMETRIC_PALETTE:\t\t/* disallowed by Tech Note */\n\tcase PHOTOMETRIC_MASK:\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t  \"PhotometricInterpretation %d not allowed for JPEG\",\n\t\t\t  (int) sp->photometric);\n\t\treturn (0);\n\tdefault:\n\t\t/* TIFF 6.0 forbids subsampling of all other color spaces */\n\t\tsp->h_sampling = 1;\n\t\tsp->v_sampling = 1;\n\t\tbreak;\n\t}\n\n\t/* Verify miscellaneous parameters */\n\n\t/*\n\t * This would need work if libtiff ever supports different\n\t * depths for different components, or if libjpeg ever supports\n\t * run-time selection of depth.  Neither is imminent.\n\t */\n#ifdef JPEG_LIB_MK1\n        /* BITS_IN_JSAMPLE now permits 8 and 12 --- dgilbert */\n\tif (td->td_bitspersample != 8 && td->td_bitspersample != 12) \n#else\n\tif (td->td_bitspersample != BITS_IN_JSAMPLE )\n#endif\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"BitsPerSample %d not allowed for JPEG\",\n\t\t\t  (int) td->td_bitspersample);\n\t\treturn (0);\n\t}\n\tsp->cinfo.c.data_precision = td->td_bitspersample;\n#ifdef JPEG_LIB_MK1\n        sp->cinfo.c.bits_in_jsample = td->td_bitspersample;\n#endif\n\tif (isTiled(tif)) {\n\t\tif ((td->td_tilelength % (sp->v_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"JPEG tile height must be multiple of %d\",\n\t\t\t\t  sp->v_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t\tif ((td->td_tilewidth % (sp->h_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"JPEG tile width must be multiple of %d\",\n\t\t\t\t  sp->h_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\tif (td->td_rowsperstrip < td->td_imagelength &&\n\t\t    (td->td_rowsperstrip % (sp->v_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"RowsPerStrip must be multiple of %d for JPEG\",\n\t\t\t\t  sp->v_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/* Create a JPEGTables field if appropriate */\n\tif (sp->jpegtablesmode & (JPEGTABLESMODE_QUANT|JPEGTABLESMODE_HUFF)) {\n                if( sp->jpegtables == NULL\n                    || memcmp(sp->jpegtables,\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\",8) == 0 )\n                {\n                        if (!prepare_JPEGTables(tif))\n                                return (0);\n                        /* Mark the field present */\n                        /* Can't use TIFFSetField since BEENWRITING is already set! */\n                        tif->tif_flags |= TIFF_DIRTYDIRECT;\n                        TIFFSetFieldBit(tif, FIELD_JPEGTABLES);\n                }\n\t} else {\n\t\t/* We do not support application-supplied JPEGTables, */\n\t\t/* so mark the field not present */\n\t\tTIFFClrFieldBit(tif, FIELD_JPEGTABLES);\n\t}\n\n\t/* Direct libjpeg output to libtiff's output buffer */\n\tTIFFjpeg_data_dest(sp, tif);\n\n\treturn (1);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147745,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void snippet_add_content(struct snippet_context *ctx,\n\t\t\t\tstruct snippet_data *target,\n\t\t\t\tconst unsigned char *data, size_t size,\n\t\t\t\tsize_t *count_r)\n{\n\ti_assert(target != NULL);\n\tif (size >= 3 &&\n\t     ((data[0] == 0xEF && data[1] == 0xBB && data[2] == 0xBF) ||\n\t      (data[0] == 0xBF && data[1] == 0xBB && data[2] == 0xEF))) {\n\t\t*count_r = 3;\n\t\treturn;\n\t}\n\tif (data[0] == '\\0') {\n\t\t/* skip NULs without increasing snippet size */\n\t\treturn;\n\t}\n\tif (i_isspace(*data)) {\n\t\t/* skip any leading whitespace */\n\t\tif (str_len(target->snippet) > 1)\n\t\t\tctx->add_whitespace = TRUE;\n\t\tif (data[0] == '\\n')\n\t\t\tctx->state = SNIPPET_STATE_NEWLINE;\n\t\treturn;\n\t}\n\tif (ctx->add_whitespace) {\n\t\tstr_append_c(target->snippet, ' ');\n\t\tctx->add_whitespace = FALSE;\n\t\tif (target->chars_left-- == 0)\n\t\t\treturn;\n\t}\n\tif (target->chars_left == 0)\n\t\treturn;\n\ttarget->chars_left--;\n\t*count_r = uni_utf8_char_bytes(data[0]);\n\ti_assert(*count_r <= size);\n\tstr_append_data(target->snippet, data, *count_r);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147762,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void snippet_add_content(struct snippet_context *ctx,\n\t\t\t\tstruct snippet_data *target,\n\t\t\t\tconst unsigned char *data, size_t size,\n\t\t\t\tsize_t *count_r)\n{\n\ti_assert(target != NULL);\n\tif (size == 0)\n\t\treturn;\n\tif (size >= 3 &&\n\t     ((data[0] == 0xEF && data[1] == 0xBB && data[2] == 0xBF) ||\n\t      (data[0] == 0xBF && data[1] == 0xBB && data[2] == 0xEF))) {\n\t\t*count_r = 3;\n\t\treturn;\n\t}\n\tif (data[0] == '\\0') {\n\t\t/* skip NULs without increasing snippet size */\n\t\treturn;\n\t}\n\tif (i_isspace(*data)) {\n\t\t/* skip any leading whitespace */\n\t\tif (str_len(target->snippet) > 1)\n\t\t\tctx->add_whitespace = TRUE;\n\t\tif (data[0] == '\\n')\n\t\t\tctx->state = SNIPPET_STATE_NEWLINE;\n\t\treturn;\n\t}\n\tif (ctx->add_whitespace) {\n\t\tstr_append_c(target->snippet, ' ');\n\t\tctx->add_whitespace = FALSE;\n\t\tif (target->chars_left-- == 0)\n\t\t\treturn;\n\t}\n\tif (target->chars_left == 0)\n\t\treturn;\n\ttarget->chars_left--;\n\t*count_r = uni_utf8_char_bytes(data[0]);\n\ti_assert(*count_r <= size);\n\tstr_append_data(target->snippet, data, *count_r);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147763,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void part_write_body(const struct message_part *part,\n\t\t\t    string_t *str, bool extended)\n{\n\tconst struct message_part_data *data = part->data;\n\tbool text;\n\n\ti_assert(part->data != NULL);\n\n\tif ((part->flags & MESSAGE_PART_FLAG_MESSAGE_RFC822) != 0) {\n\t\tstr_append(str, \"\\\"message\\\" \\\"rfc822\\\"\");\n\t\ttext = FALSE;\n\t} else {\n\t\t/* \"content type\" \"subtype\" */\n\t\tif (data->content_type == NULL) {\n\t\t\ttext = TRUE;\n\t\t\tstr_append(str, \"\\\"text\\\" \\\"plain\\\"\");\n\t\t} else {\n\t\t\ttext = (strcasecmp(data->content_type, \"text\") == 0);\n\t\t\timap_append_string(str, data->content_type);\n\t\t\tstr_append_c(str, ' ');\n\t\t\timap_append_string(str, data->content_subtype);\n\t\t}\n\t}\n\n\t/* (\"content type param key\" \"value\" ...) */\n\tstr_append_c(str, ' ');\n\tparams_write(data->content_type_params,\n\t\tdata->content_type_params_count, str, text);\n\n\tstr_append_c(str, ' ');\n\timap_append_nstring_nolf(str, data->content_id);\n\tstr_append_c(str, ' ');\n\timap_append_nstring_nolf(str, data->content_description);\n\tstr_append_c(str, ' ');\n\tif (data->content_transfer_encoding != NULL)\n\t\timap_append_string(str, data->content_transfer_encoding);\n\telse\n\t\tstr_append(str, \"\\\"7bit\\\"\");\n\tstr_printfa(str, \" %\"PRIuUOFF_T, part->body_size.virtual_size);\n\n\tif (text) {\n\t\t/* text/.. contains line count */\n\t\tstr_printfa(str, \" %u\", part->body_size.lines);\n\t} else if ((part->flags & MESSAGE_PART_FLAG_MESSAGE_RFC822) != 0) {\n\t\t/* message/rfc822 contains envelope + body + line count */\n\t\tconst struct message_part_data *child_data;\n\n\t\ti_assert(part->children != NULL);\n\t\ti_assert(part->children->next == NULL);\n\n\t\tchild_data = part->children->data;\n\n\t\tstr_append(str, \" (\");\n\t\timap_envelope_write(child_data->envelope, str);\n\t\tstr_append(str, \") \");\n\n\t\tpart_write_bodystructure_siblings(part->children, str, extended);\n\t\tstr_printfa(str, \" %u\", part->body_size.lines);\n\t}\n\n\tif (!extended)\n\t\treturn;\n\n\t/* BODYSTRUCTURE data */\n\n\t/* \"md5\" (\"content disposition\" (\"disposition\" \"params\"))\n\t   (\"body\" \"language\" \"params\") \"location\" */\n\tstr_append_c(str, ' ');\n\timap_append_nstring_nolf(str, data->content_md5);\n\tpart_write_bodystructure_common(data, str);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147772,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static void part_write_body(const struct message_part *part,\n\t\t\t    string_t *str, bool extended)\n{\n\tconst struct message_part_data *data = part->data;\n\tbool text, message_rfc822;\n\n\ti_assert(part->data != NULL);\n\n\tif ((part->flags & MESSAGE_PART_FLAG_MESSAGE_RFC822) != 0)\n\t\tmessage_rfc822 = TRUE;\n\telse if (data->content_type != NULL &&\n\t\t strcasecmp(data->content_type, \"message\") == 0 &&\n\t\t strcasecmp(data->content_subtype, \"rfc822\") == 0) {\n\t\t/* It's message/rfc822, but without\n\t\t   MESSAGE_PART_FLAG_MESSAGE_RFC822. That likely means maximum\n\t\t   MIME part count was reached while parsing the mail. Write\n\t\t   the missing child mail's ENVELOPE and BODY as empty dummy\n\t\t   values. */\n\t\tmessage_rfc822 = TRUE;\n\t} else\n\t\tmessage_rfc822 = FALSE;\n\n\tif (message_rfc822) {\n\t\tstr_append(str, \"\\\"message\\\" \\\"rfc822\\\"\");\n\t\ttext = FALSE;\n\t} else {\n\t\t/* \"content type\" \"subtype\" */\n\t\tif (data->content_type == NULL) {\n\t\t\ttext = TRUE;\n\t\t\tstr_append(str, \"\\\"text\\\" \\\"plain\\\"\");\n\t\t} else {\n\t\t\ttext = (strcasecmp(data->content_type, \"text\") == 0);\n\t\t\timap_append_string(str, data->content_type);\n\t\t\tstr_append_c(str, ' ');\n\t\t\timap_append_string(str, data->content_subtype);\n\t\t}\n\t}\n\n\t/* (\"content type param key\" \"value\" ...) */\n\tstr_append_c(str, ' ');\n\tparams_write(data->content_type_params,\n\t\tdata->content_type_params_count, str, text);\n\n\tstr_append_c(str, ' ');\n\timap_append_nstring_nolf(str, data->content_id);\n\tstr_append_c(str, ' ');\n\timap_append_nstring_nolf(str, data->content_description);\n\tstr_append_c(str, ' ');\n\tif (data->content_transfer_encoding != NULL)\n\t\timap_append_string(str, data->content_transfer_encoding);\n\telse\n\t\tstr_append(str, \"\\\"7bit\\\"\");\n\tstr_printfa(str, \" %\"PRIuUOFF_T, part->body_size.virtual_size);\n\n\tif (text) {\n\t\t/* text/.. contains line count */\n\t\tstr_printfa(str, \" %u\", part->body_size.lines);\n\t} else if ((part->flags & MESSAGE_PART_FLAG_MESSAGE_RFC822) != 0) {\n\t\t/* message/rfc822 contains envelope + body + line count */\n\t\tconst struct message_part_data *child_data;\n\n\t\ti_assert(part->children != NULL);\n\t\ti_assert(part->children->next == NULL);\n\n\t\tchild_data = part->children->data;\n\n\t\tstr_append(str, \" (\");\n\t\timap_envelope_write(child_data->envelope, str);\n\t\tstr_append(str, \") \");\n\n\t\tpart_write_bodystructure_siblings(part->children, str, extended);\n\t\tstr_printfa(str, \" %u\", part->body_size.lines);\n\t} else if (message_rfc822) {\n\t\t/* truncated MIME part - write out dummy values */\n\t\ti_assert(part->children == NULL);\n\n\t\tstr_append(str, \" (NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL) \");\n\n\t\tif (!extended)\n\t\t\tstr_append(str, EMPTY_BODY);\n\t\telse\n\t\t\tstr_append(str, EMPTY_BODYSTRUCTURE);\n\t\tstr_printfa(str, \" %u\", part->body_size.lines);\n\t}\n\n\tif (!extended)\n\t\treturn;\n\n\t/* BODYSTRUCTURE data */\n\n\t/* \"md5\" (\"content disposition\" (\"disposition\" \"params\"))\n\t   (\"body\" \"language\" \"params\") \"location\" */\n\tstr_append_c(str, ' ');\n\timap_append_nstring_nolf(str, data->content_md5);\n\tpart_write_bodystructure_common(data, str);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147773,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "decode_entities(pTHX_ SV* sv, HV* entity2char, bool expand_prefix)\n{\n    STRLEN len;\n    char *s = SvPV_force(sv, len);\n    char *t = s;\n    char *end = s + len;\n    char *ent_start;\n\n    char *repl;\n    STRLEN repl_len;\n#ifdef UNICODE_HTML_PARSER\n    char buf[UTF8_MAXLEN];\n    int repl_utf8;\n    int high_surrogate = 0;\n#else\n    char buf[1];\n#endif\n\n#if defined(__GNUC__) && defined(UNICODE_HTML_PARSER)\n    /* gcc -Wall reports this variable as possibly used uninitialized */\n    repl_utf8 = 0;\n#endif\n\n    while (s < end) {\n\tassert(t <= s);\n\n\tif ((*t++ = *s++) != '&')\n\t    continue;\n\n\tent_start = s;\n\trepl = 0;\n\n\tif (*s == '#') {\n\t    UV num = 0;\n\t    UV prev = 0;\n\t    int ok = 0;\n\t    s++;\n\t    if (*s == 'x' || *s == 'X') {\n\t\ts++;\n\t\twhile (*s) {\n\t\t    char *tmp = strchr(PL_hexdigit, *s);\n\t\t    if (!tmp)\n\t\t\tbreak;\n\t\t    num = num << 4 | ((tmp - PL_hexdigit) & 15);\n\t\t    if (prev && num <= prev) {\n\t\t\t/* overflow */\n\t\t\tok = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t    prev = num;\n\t\t    s++;\n\t\t    ok = 1;\n\t\t}\n\t    }\n\t    else {\n\t\twhile (isDIGIT(*s)) {\n\t\t    num = num * 10 + (*s - '0');\n\t\t    if (prev && num < prev) {\n\t\t\t/* overflow */\n\t\t\tok = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t    prev = num;\n\t\t    s++;\n\t\t    ok = 1;\n\t\t}\n\t    }\n\t    if (ok) {\n#ifdef UNICODE_HTML_PARSER\n\t\tif (!SvUTF8(sv) && num <= 255) {\n\t\t    buf[0] = (char) num;\n\t\t    repl = buf;\n\t\t    repl_len = 1;\n\t\t    repl_utf8 = 0;\n\t\t}\n\t\telse {\n\t\t    char *tmp;\n\t\t    if ((num & 0xFFFFFC00) == 0xDC00) {  /* low-surrogate */\n\t\t\tif (high_surrogate != 0) {\n\t\t\t    t -= 3; /* Back up past 0xFFFD */\n\t\t\t    num = ((high_surrogate - 0xD800) << 10) +\n\t\t\t\t(num - 0xDC00) + 0x10000;\n\t\t\t    high_surrogate = 0;\n\t\t\t} else {\n\t\t\t    num = 0xFFFD;\n\t\t\t}\n\t\t    }\n\t\t    else if ((num & 0xFFFFFC00) == 0xD800) { /* high-surrogate */\n\t\t\thigh_surrogate = num;\n\t\t\tnum = 0xFFFD;\n\t\t    }\n\t\t    else {\n\t\t\thigh_surrogate = 0;\n\t\t\t/* otherwise invalid? */\n\t\t\tif ((num >= 0xFDD0 && num <= 0xFDEF) ||\n\t\t\t    ((num & 0xFFFE) == 0xFFFE) ||\n\t\t\t    num > 0x10FFFF)\n\t\t\t{\n\t\t\t    num = 0xFFFD;\n\t\t\t}\n\t\t    }\n\n\t\t    tmp = (char*)uvuni_to_utf8((U8*)buf, num);\n\t\t    repl = buf;\n\t\t    repl_len = tmp - buf;\n\t\t    repl_utf8 = 1;\n\t\t}\n#else\n\t\tif (num <= 255) {\n\t\t    buf[0] = (char) num & 0xFF;\n\t\t    repl = buf;\n\t\t    repl_len = 1;\n\t\t}\n#endif\n\t    }\n\t}\n\telse {\n\t    char *ent_name = s;\n\t    while (isALNUM(*s))\n\t\ts++;\n\t    if (ent_name != s && entity2char) {\n\t\tSV** svp;\n\t\tif (              (svp = hv_fetch(entity2char, ent_name, s - ent_name, 0)) ||\n\t\t    (*s == ';' && (svp = hv_fetch(entity2char, ent_name, s - ent_name + 1, 0)))\n\t\t   )\n\t\t{\n\t\t    repl = SvPV(*svp, repl_len);\n#ifdef UNICODE_HTML_PARSER\n\t\t    repl_utf8 = SvUTF8(*svp);\n#endif\n\t\t}\n\t\telse if (expand_prefix) {\n\t\t    char *ss = s - 1;\n\t\t    while (ss > ent_name) {\n\t\t\tsvp = hv_fetch(entity2char, ent_name, ss - ent_name, 0);\n\t\t\tif (svp) {\n\t\t\t    repl = SvPV(*svp, repl_len);\n#ifdef UNICODE_HTML_PARSER\n\t\t\t    repl_utf8 = SvUTF8(*svp);\n#endif\n\t\t\t    s = ss;\n\t\t\t    break;\n\t\t\t}\n\t\t\tss--;\n\t\t    }\n\t\t}\n\t    }\n#ifdef UNICODE_HTML_PARSER\n\t    high_surrogate = 0;\n#endif\n\t}\n\n\tif (repl) {\n\t    char *repl_allocated = 0;\n\t    if (*s == ';')\n\t\ts++;\n\t    t--;  /* '&' already copied, undo it */\n\n#ifdef UNICODE_HTML_PARSER\n\t    if (*s != '&') {\n\t\thigh_surrogate = 0;\n\t    }\n\n\t    if (!SvUTF8(sv) && repl_utf8) {\n\t\t/* need to upgrade sv before we continue */\n\t\tSTRLEN before_gap_len = t - SvPVX(sv);\n\t\tchar *before_gap = (char*)bytes_to_utf8((U8*)SvPVX(sv), &before_gap_len);\n\t\tSTRLEN after_gap_len = end - s;\n\t\tchar *after_gap = (char*)bytes_to_utf8((U8*)s, &after_gap_len);\n\n\t\tsv_setpvn(sv, before_gap, before_gap_len);\n\t\tsv_catpvn(sv, after_gap, after_gap_len);\n\t\tSvUTF8_on(sv);\n\n\t\tSafefree(before_gap);\n\t\tSafefree(after_gap);\n\n\t\ts = t = SvPVX(sv) + before_gap_len;\n\t\tend = SvPVX(sv) + before_gap_len + after_gap_len;\n\t    }\n\t    else if (SvUTF8(sv) && !repl_utf8) {\n\t\trepl = (char*)bytes_to_utf8((U8*)repl, &repl_len);\n\t\trepl_allocated = repl;\n\t    }\n#endif\n\n\t    if (t + repl_len > s) {\n\t\t/* need to grow the string */\n\t\tgrow_gap(aTHX_ sv, repl_len - (s - t), &t, &s, &end);\n\t    }\n\n\t    /* copy replacement string into string */\n\t    while (repl_len--)\n\t\t*t++ = *repl++;\n\n\t    if (repl_allocated)\n\t\tSafefree(repl_allocated);\n\t}\n\telse {\n\t    while (ent_start < s)\n\t\t*t++ = *ent_start++;\n\t}\n    }\n\n    *t = '\\0';\n    SvCUR_set(sv, t - SvPVX(sv));\n\n    return sv;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147834,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "decode_entities(pTHX_ SV* sv, HV* entity2char, bool expand_prefix)\n{\n    STRLEN len;\n    char *s = SvPV_force(sv, len);\n    char *t = s;\n    char *end = s + len;\n    char *ent_start;\n\n    char *repl;\n    STRLEN repl_len;\n#ifdef UNICODE_HTML_PARSER\n    char buf[UTF8_MAXLEN];\n    int repl_utf8;\n    int high_surrogate = 0;\n#else\n    char buf[1];\n#endif\n\n#if defined(__GNUC__) && defined(UNICODE_HTML_PARSER)\n    /* gcc -Wall reports this variable as possibly used uninitialized */\n    repl_utf8 = 0;\n#endif\n\n    while (s < end) {\n\tassert(t <= s);\n\n\tif ((*t++ = *s++) != '&')\n\t    continue;\n\n\tent_start = s;\n\trepl = 0;\n\n\tif (s < end && *s == '#') {\n\t    UV num = 0;\n\t    UV prev = 0;\n\t    int ok = 0;\n\t    s++;\n\t    if (s < end && (*s == 'x' || *s == 'X')) {\n\t\ts++;\n\t\twhile (s < end) {\n\t\t    char *tmp = strchr(PL_hexdigit, *s);\n\t\t    if (!tmp)\n\t\t\tbreak;\n\t\t    num = num << 4 | ((tmp - PL_hexdigit) & 15);\n\t\t    if (prev && num <= prev) {\n\t\t\t/* overflow */\n\t\t\tok = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t    prev = num;\n\t\t    s++;\n\t\t    ok = 1;\n\t\t}\n\t    }\n\t    else {\n\t\twhile (s < end && isDIGIT(*s)) {\n\t\t    num = num * 10 + (*s - '0');\n\t\t    if (prev && num < prev) {\n\t\t\t/* overflow */\n\t\t\tok = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t    prev = num;\n\t\t    s++;\n\t\t    ok = 1;\n\t\t}\n\t    }\n\t    if (ok) {\n#ifdef UNICODE_HTML_PARSER\n\t\tif (!SvUTF8(sv) && num <= 255) {\n\t\t    buf[0] = (char) num;\n\t\t    repl = buf;\n\t\t    repl_len = 1;\n\t\t    repl_utf8 = 0;\n\t\t}\n\t\telse {\n\t\t    char *tmp;\n\t\t    if ((num & 0xFFFFFC00) == 0xDC00) {  /* low-surrogate */\n\t\t\tif (high_surrogate != 0) {\n\t\t\t    t -= 3; /* Back up past 0xFFFD */\n\t\t\t    num = ((high_surrogate - 0xD800) << 10) +\n\t\t\t\t(num - 0xDC00) + 0x10000;\n\t\t\t    high_surrogate = 0;\n\t\t\t} else {\n\t\t\t    num = 0xFFFD;\n\t\t\t}\n\t\t    }\n\t\t    else if ((num & 0xFFFFFC00) == 0xD800) { /* high-surrogate */\n\t\t\thigh_surrogate = num;\n\t\t\tnum = 0xFFFD;\n\t\t    }\n\t\t    else {\n\t\t\thigh_surrogate = 0;\n\t\t\t/* otherwise invalid? */\n\t\t\tif ((num >= 0xFDD0 && num <= 0xFDEF) ||\n\t\t\t    ((num & 0xFFFE) == 0xFFFE) ||\n\t\t\t    num > 0x10FFFF)\n\t\t\t{\n\t\t\t    num = 0xFFFD;\n\t\t\t}\n\t\t    }\n\n\t\t    tmp = (char*)uvuni_to_utf8((U8*)buf, num);\n\t\t    repl = buf;\n\t\t    repl_len = tmp - buf;\n\t\t    repl_utf8 = 1;\n\t\t}\n#else\n\t\tif (num <= 255) {\n\t\t    buf[0] = (char) num & 0xFF;\n\t\t    repl = buf;\n\t\t    repl_len = 1;\n\t\t}\n#endif\n\t    }\n\t}\n\telse {\n\t    char *ent_name = s;\n\t    while (s < end && isALNUM(*s))\n\t\ts++;\n\t    if (ent_name != s && entity2char) {\n\t\tSV** svp;\n\t\tif (              (svp = hv_fetch(entity2char, ent_name, s - ent_name, 0)) ||\n\t\t    (*s == ';' && (svp = hv_fetch(entity2char, ent_name, s - ent_name + 1, 0)))\n\t\t   )\n\t\t{\n\t\t    repl = SvPV(*svp, repl_len);\n#ifdef UNICODE_HTML_PARSER\n\t\t    repl_utf8 = SvUTF8(*svp);\n#endif\n\t\t}\n\t\telse if (expand_prefix) {\n\t\t    char *ss = s - 1;\n\t\t    while (ss > ent_name) {\n\t\t\tsvp = hv_fetch(entity2char, ent_name, ss - ent_name, 0);\n\t\t\tif (svp) {\n\t\t\t    repl = SvPV(*svp, repl_len);\n#ifdef UNICODE_HTML_PARSER\n\t\t\t    repl_utf8 = SvUTF8(*svp);\n#endif\n\t\t\t    s = ss;\n\t\t\t    break;\n\t\t\t}\n\t\t\tss--;\n\t\t    }\n\t\t}\n\t    }\n#ifdef UNICODE_HTML_PARSER\n\t    high_surrogate = 0;\n#endif\n\t}\n\n\tif (repl) {\n\t    char *repl_allocated = 0;\n\t    if (s < end && *s == ';')\n\t\ts++;\n\t    t--;  /* '&' already copied, undo it */\n\n#ifdef UNICODE_HTML_PARSER\n\t    if (*s != '&') {\n\t\thigh_surrogate = 0;\n\t    }\n\n\t    if (!SvUTF8(sv) && repl_utf8) {\n\t\t/* need to upgrade sv before we continue */\n\t\tSTRLEN before_gap_len = t - SvPVX(sv);\n\t\tchar *before_gap = (char*)bytes_to_utf8((U8*)SvPVX(sv), &before_gap_len);\n\t\tSTRLEN after_gap_len = end - s;\n\t\tchar *after_gap = (char*)bytes_to_utf8((U8*)s, &after_gap_len);\n\n\t\tsv_setpvn(sv, before_gap, before_gap_len);\n\t\tsv_catpvn(sv, after_gap, after_gap_len);\n\t\tSvUTF8_on(sv);\n\n\t\tSafefree(before_gap);\n\t\tSafefree(after_gap);\n\n\t\ts = t = SvPVX(sv) + before_gap_len;\n\t\tend = SvPVX(sv) + before_gap_len + after_gap_len;\n\t    }\n\t    else if (SvUTF8(sv) && !repl_utf8) {\n\t\trepl = (char*)bytes_to_utf8((U8*)repl, &repl_len);\n\t\trepl_allocated = repl;\n\t    }\n#endif\n\n\t    if (t + repl_len > s) {\n\t\t/* need to grow the string */\n\t\tgrow_gap(aTHX_ sv, repl_len - (s - t), &t, &s, &end);\n\t    }\n\n\t    /* copy replacement string into string */\n\t    while (repl_len--)\n\t\t*t++ = *repl++;\n\n\t    if (repl_allocated)\n\t\tSafefree(repl_allocated);\n\t}\n\telse {\n\t    while (ent_start < s)\n\t\t*t++ = *ent_start++;\n\t}\n    }\n\n    *t = '\\0';\n    SvCUR_set(sv, t - SvPVX(sv));\n\n    return sv;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147835,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "did_set_string_option (\n    int opt_idx,                            /* index in options[] table */\n    char_u **varp,                     /* pointer to the option variable */\n    int new_value_alloced,                  /* new value was allocated */\n    char_u *oldval,                    /* previous value of the option */\n    char_u *errbuf,                    /* buffer for errors, or NULL */\n    int opt_flags                          /* OPT_LOCAL and/or OPT_GLOBAL */\n)\n{\n  char_u      *errmsg = NULL;\n  char_u      *s, *p;\n  int did_chartab = FALSE;\n  char_u      **gvarp;\n  bool free_oldval = (options[opt_idx].flags & P_ALLOCED);\n\n  /* Get the global option to compare with, otherwise we would have to check\n   * two values for all local options. */\n  gvarp = (char_u **)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL);\n\n  /* Disallow changing some options from secure mode */\n  if ((secure || sandbox != 0)\n      && (options[opt_idx].flags & P_SECURE)) {\n    errmsg = e_secure;\n  }\n  /* Check for a \"normal\" file name in some options.  Disallow a path\n   * separator (slash and/or backslash), wildcards and characters that are\n   * often illegal in a file name. */\n  else if ((options[opt_idx].flags & P_NFNAME)\n           && vim_strpbrk(*varp, (char_u *)\"/\\\\*?[|<>\") != NULL) {\n    errmsg = e_invarg;\n  }\n  /* 'backupcopy' */\n  else if (gvarp == &p_bkc) {\n    char_u       *bkc   = p_bkc;\n    unsigned int *flags = &bkc_flags;\n\n    if (opt_flags & OPT_LOCAL) {\n      bkc   = curbuf->b_p_bkc;\n      flags = &curbuf->b_bkc_flags;\n    }\n\n    if ((opt_flags & OPT_LOCAL) && *bkc == NUL) {\n      // make the local value empty: use the global value\n      *flags = 0;\n    } else {\n      if (opt_strings_flags(bkc, p_bkc_values, flags, true) != OK) {\n        errmsg = e_invarg;\n      }\n\n      if (((*flags & BKC_AUTO) != 0)\n          + ((*flags & BKC_YES) != 0)\n          + ((*flags & BKC_NO) != 0) != 1) {\n        // Must have exactly one of \"auto\", \"yes\"  and \"no\".\n        (void)opt_strings_flags(oldval, p_bkc_values, flags, true);\n        errmsg = e_invarg;\n      }\n    }\n  }\n  /* 'backupext' and 'patchmode' */\n  else if (varp == &p_bex || varp == &p_pm) {\n    if (STRCMP(*p_bex == '.' ? p_bex + 1 : p_bex,\n            *p_pm == '.' ? p_pm + 1 : p_pm) == 0)\n      errmsg = (char_u *)N_(\"E589: 'backupext' and 'patchmode' are equal\");\n  }\n  /* 'breakindentopt' */\n  else if (varp == &curwin->w_p_briopt) {\n    if (briopt_check(curwin) == FAIL)\n      errmsg = e_invarg;\n  } else if (varp == &p_isi\n             || varp == &(curbuf->b_p_isk)\n             || varp == &p_isp\n             || varp == &p_isf) {\n    // 'isident', 'iskeyword', 'isprint or 'isfname' option: refill g_chartab[]\n    // If the new option is invalid, use old value.  'lisp' option: refill\n    // g_chartab[] for '-' char\n    if (init_chartab() == FAIL) {\n      did_chartab = TRUE;           /* need to restore it below */\n      errmsg = e_invarg;            /* error in value */\n    }\n  }\n  /* 'helpfile' */\n  else if (varp == &p_hf) {\n    /* May compute new values for $VIM and $VIMRUNTIME */\n    if (didset_vim) {\n      vim_setenv(\"VIM\", \"\");\n      didset_vim = FALSE;\n    }\n    if (didset_vimruntime) {\n      vim_setenv(\"VIMRUNTIME\", \"\");\n      didset_vimruntime = FALSE;\n    }\n  }\n  /* 'colorcolumn' */\n  else if (varp == &curwin->w_p_cc)\n    errmsg = check_colorcolumn(curwin);\n\n  /* 'helplang' */\n  else if (varp == &p_hlg) {\n    /* Check for \"\", \"ab\", \"ab,cd\", etc. */\n    for (s = p_hlg; *s != NUL; s += 3) {\n      if (s[1] == NUL || ((s[2] != ',' || s[3] == NUL) && s[2] != NUL)) {\n        errmsg = e_invarg;\n        break;\n      }\n      if (s[2] == NUL)\n        break;\n    }\n  }\n  /* 'highlight' */\n  else if (varp == &p_hl) {\n    if (highlight_changed() == FAIL)\n      errmsg = e_invarg;        /* invalid flags */\n  }\n  /* 'nrformats' */\n  else if (gvarp == &p_nf) {\n    if (check_opt_strings(*varp, p_nf_values, TRUE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_ssop) {  // 'sessionoptions'\n    if (opt_strings_flags(p_ssop, p_ssop_values, &ssop_flags, true) != OK)\n      errmsg = e_invarg;\n    if ((ssop_flags & SSOP_CURDIR) && (ssop_flags & SSOP_SESDIR)) {\n      /* Don't allow both \"sesdir\" and \"curdir\". */\n      (void)opt_strings_flags(oldval, p_ssop_values, &ssop_flags, true);\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_vop) {  // 'viewoptions'\n    if (opt_strings_flags(p_vop, p_ssop_values, &vop_flags, true) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'scrollopt' */\n  else if (varp == &p_sbo) {\n    if (check_opt_strings(p_sbo, p_scbopt_values, TRUE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_ambw || (int *)varp == &p_emoji) {\n    // 'ambiwidth'\n    if (check_opt_strings(p_ambw, p_ambw_values, false) != OK) {\n      errmsg = e_invarg;\n    } else if (set_chars_option(&p_lcs) != NULL) {\n      errmsg = (char_u *)_(\"E834: Conflicts with value of 'listchars'\");\n    } else if (set_chars_option(&p_fcs) != NULL) {\n      errmsg = (char_u *)_(\"E835: Conflicts with value of 'fillchars'\");\n    }\n  }\n  /* 'background' */\n  else if (varp == &p_bg) {\n    if (check_opt_strings(p_bg, p_bg_values, FALSE) == OK) {\n      int dark = (*p_bg == 'd');\n\n      init_highlight(FALSE, FALSE);\n\n      if (dark != (*p_bg == 'd')\n          && get_var_value((char_u *)\"g:colors_name\") != NULL) {\n        /* The color scheme must have set 'background' back to another\n         * value, that's not what we want here.  Disable the color\n         * scheme and set the colors again. */\n        do_unlet((char_u *)\"g:colors_name\", TRUE);\n        free_string_option(p_bg);\n        p_bg = vim_strsave((char_u *)(dark ? \"dark\" : \"light\"));\n        check_string_option(&p_bg);\n        init_highlight(FALSE, FALSE);\n      }\n    } else\n      errmsg = e_invarg;\n  }\n  /* 'wildmode' */\n  else if (varp == &p_wim) {\n    if (check_opt_wim() == FAIL)\n      errmsg = e_invarg;\n  }\n  /* 'wildoptions' */\n  else if (varp == &p_wop) {\n    if (check_opt_strings(p_wop, p_wop_values, TRUE) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'winaltkeys' */\n  else if (varp == &p_wak) {\n    if (*p_wak == NUL\n        || check_opt_strings(p_wak, p_wak_values, FALSE) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'eventignore' */\n  else if (varp == &p_ei) {\n    if (check_ei() == FAIL)\n      errmsg = e_invarg;\n  /* 'encoding' and 'fileencoding' */\n  } else if (varp == &p_enc || gvarp == &p_fenc) {\n    if (gvarp == &p_fenc) {\n      if (!MODIFIABLE(curbuf) && opt_flags != OPT_GLOBAL) {\n        errmsg = e_modifiable;\n      } else if (vim_strchr(*varp, ',') != NULL) {\n        // No comma allowed in 'fileencoding'; catches confusing it\n        // with 'fileencodings'.\n        errmsg = e_invarg;\n      } else {\n        // May show a \"+\" in the title now.\n        redraw_titles();\n        // Add 'fileencoding' to the swap file.\n        ml_setflags(curbuf);\n      }\n    }\n\n    if (errmsg == NULL) {\n      /* canonize the value, so that STRCMP() can be used on it */\n      p = enc_canonize(*varp);\n      xfree(*varp);\n      *varp = p;\n      if (varp == &p_enc) {\n        // only encoding=utf-8 allowed\n        if (STRCMP(p_enc, \"utf-8\") != 0) {\n          errmsg = e_invarg;\n        }\n      }\n    }\n  } else if (varp == &p_penc) {\n    /* Canonize printencoding if VIM standard one */\n    p = enc_canonize(p_penc);\n    xfree(p_penc);\n    p_penc = p;\n  } else if (varp == &curbuf->b_p_keymap) {\n    /* load or unload key mapping tables */\n    errmsg = keymap_init();\n\n    if (errmsg == NULL) {\n      if (*curbuf->b_p_keymap != NUL) {\n        /* Installed a new keymap, switch on using it. */\n        curbuf->b_p_iminsert = B_IMODE_LMAP;\n        if (curbuf->b_p_imsearch != B_IMODE_USE_INSERT)\n          curbuf->b_p_imsearch = B_IMODE_LMAP;\n      } else {\n        /* Cleared the keymap, may reset 'iminsert' and 'imsearch'. */\n        if (curbuf->b_p_iminsert == B_IMODE_LMAP)\n          curbuf->b_p_iminsert = B_IMODE_NONE;\n        if (curbuf->b_p_imsearch == B_IMODE_LMAP)\n          curbuf->b_p_imsearch = B_IMODE_USE_INSERT;\n      }\n      if ((opt_flags & OPT_LOCAL) == 0) {\n        set_iminsert_global();\n        set_imsearch_global();\n      }\n      status_redraw_curbuf();\n    }\n  }\n  /* 'fileformat' */\n  else if (gvarp == &p_ff) {\n    if (!MODIFIABLE(curbuf) && !(opt_flags & OPT_GLOBAL))\n      errmsg = e_modifiable;\n    else if (check_opt_strings(*varp, p_ff_values, FALSE) != OK)\n      errmsg = e_invarg;\n    else {\n      redraw_titles();\n      /* update flag in swap file */\n      ml_setflags(curbuf);\n      /* Redraw needed when switching to/from \"mac\": a CR in the text\n       * will be displayed differently. */\n      if (get_fileformat(curbuf) == EOL_MAC || *oldval == 'm')\n        redraw_curbuf_later(NOT_VALID);\n    }\n  }\n  /* 'fileformats' */\n  else if (varp == &p_ffs) {\n    if (check_opt_strings(p_ffs, p_ff_values, TRUE) != OK) {\n      errmsg = e_invarg;\n    }\n  }\n\n  /* 'matchpairs' */\n  else if (gvarp == &p_mps) {\n    if (has_mbyte) {\n      for (p = *varp; *p != NUL; ++p) {\n        int x2 = -1;\n        int x3 = -1;\n\n        if (*p != NUL)\n          p += mb_ptr2len(p);\n        if (*p != NUL)\n          x2 = *p++;\n        if (*p != NUL) {\n          x3 = mb_ptr2char(p);\n          p += mb_ptr2len(p);\n        }\n        if (x2 != ':' || x3 == -1 || (*p != NUL && *p != ',')) {\n          errmsg = e_invarg;\n          break;\n        }\n        if (*p == NUL)\n          break;\n      }\n    } else {\n      /* Check for \"x:y,x:y\" */\n      for (p = *varp; *p != NUL; p += 4) {\n        if (p[1] != ':' || p[2] == NUL || (p[3] != NUL && p[3] != ',')) {\n          errmsg = e_invarg;\n          break;\n        }\n        if (p[3] == NUL)\n          break;\n      }\n    }\n  }\n  /* 'comments' */\n  else if (gvarp == &p_com) {\n    for (s = *varp; *s; ) {\n      while (*s && *s != ':') {\n        if (vim_strchr((char_u *)COM_ALL, *s) == NULL\n            && !ascii_isdigit(*s) && *s != '-') {\n          errmsg = illegal_char(errbuf, *s);\n          break;\n        }\n        ++s;\n      }\n      if (*s++ == NUL)\n        errmsg = (char_u *)N_(\"E524: Missing colon\");\n      else if (*s == ',' || *s == NUL)\n        errmsg = (char_u *)N_(\"E525: Zero length string\");\n      if (errmsg != NULL)\n        break;\n      while (*s && *s != ',') {\n        if (*s == '\\\\' && s[1] != NUL)\n          ++s;\n        ++s;\n      }\n      s = skip_to_option_part(s);\n    }\n  }\n  /* 'listchars' */\n  else if (varp == &p_lcs) {\n    errmsg = set_chars_option(varp);\n  }\n  /* 'fillchars' */\n  else if (varp == &p_fcs) {\n    errmsg = set_chars_option(varp);\n  }\n  /* 'cedit' */\n  else if (varp == &p_cedit) {\n    errmsg = check_cedit();\n  }\n  /* 'verbosefile' */\n  else if (varp == &p_vfile) {\n    verbose_stop();\n    if (*p_vfile != NUL && verbose_open() == FAIL)\n      errmsg = e_invarg;\n  /* 'shada' */\n  } else if (varp == &p_shada) {\n    // TODO(ZyX-I): Remove this code in the future, alongside with &viminfo\n    //              option.\n    opt_idx = ((options[opt_idx].fullname[0] == 'v')\n               ? (shada_idx == -1\n                  ? ((shada_idx = findoption((char_u *) \"shada\")))\n                  : shada_idx)\n               : opt_idx);\n    for (s = p_shada; *s; ) {\n      /* Check it's a valid character */\n      if (vim_strchr((char_u *)\"!\\\"%'/:<@cfhnrs\", *s) == NULL) {\n        errmsg = illegal_char(errbuf, *s);\n        break;\n      }\n      if (*s == 'n') {          /* name is always last one */\n        break;\n      } else if (*s == 'r') { /* skip until next ',' */\n        while (*++s && *s != ',')\n          ;\n      } else if (*s == '%') {\n        /* optional number */\n        while (ascii_isdigit(*++s))\n          ;\n      } else if (*s == '!' || *s == 'h' || *s == 'c')\n        ++s;                    /* no extra chars */\n      else {                    /* must have a number */\n        while (ascii_isdigit(*++s))\n          ;\n\n        if (!ascii_isdigit(*(s - 1))) {\n          if (errbuf != NULL) {\n            sprintf((char *)errbuf,\n                _(\"E526: Missing number after <%s>\"),\n                transchar_byte(*(s - 1)));\n            errmsg = errbuf;\n          } else\n            errmsg = (char_u *)\"\";\n          break;\n        }\n      }\n      if (*s == ',')\n        ++s;\n      else if (*s) {\n        if (errbuf != NULL)\n          errmsg = (char_u *)N_(\"E527: Missing comma\");\n        else\n          errmsg = (char_u *)\"\";\n        break;\n      }\n    }\n    if (*p_shada && errmsg == NULL && get_shada_parameter('\\'') < 0)\n      errmsg = (char_u *)N_(\"E528: Must specify a ' value\");\n  }\n  /* 'showbreak' */\n  else if (varp == &p_sbr) {\n    for (s = p_sbr; *s; ) {\n      if (ptr2cells(s) != 1)\n        errmsg = (char_u *)N_(\"E595: contains unprintable or wide character\");\n      mb_ptr_adv(s);\n    }\n  }\n\n  /* 'guicursor' */\n  else if (varp == &p_guicursor)\n    errmsg = parse_shape_opt(SHAPE_CURSOR);\n\n  else if (varp == &p_popt)\n    errmsg = parse_printoptions();\n  else if (varp == &p_pmfn)\n    errmsg = parse_printmbfont();\n\n  /* 'langmap' */\n  else if (varp == &p_langmap)\n    langmap_set();\n\n  /* 'breakat' */\n  else if (varp == &p_breakat)\n    fill_breakat_flags();\n\n  /* 'titlestring' and 'iconstring' */\n  else if (varp == &p_titlestring || varp == &p_iconstring) {\n    int flagval = (varp == &p_titlestring) ? STL_IN_TITLE : STL_IN_ICON;\n\n    /* NULL => statusline syntax */\n    if (vim_strchr(*varp, '%') && check_stl_option(*varp) == NULL)\n      stl_syntax |= flagval;\n    else\n      stl_syntax &= ~flagval;\n    did_set_title(varp == &p_iconstring);\n\n  }\n\n  /* 'selection' */\n  else if (varp == &p_sel) {\n    if (*p_sel == NUL\n        || check_opt_strings(p_sel, p_sel_values, FALSE) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'selectmode' */\n  else if (varp == &p_slm) {\n    if (check_opt_strings(p_slm, p_slm_values, TRUE) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'keymodel' */\n  else if (varp == &p_km) {\n    if (check_opt_strings(p_km, p_km_values, TRUE) != OK)\n      errmsg = e_invarg;\n    else {\n      km_stopsel = (vim_strchr(p_km, 'o') != NULL);\n      km_startsel = (vim_strchr(p_km, 'a') != NULL);\n    }\n  }\n  /* 'mousemodel' */\n  else if (varp == &p_mousem) {\n    if (check_opt_strings(p_mousem, p_mousem_values, FALSE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_swb) {  // 'switchbuf'\n    if (opt_strings_flags(p_swb, p_swb_values, &swb_flags, true) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'debug' */\n  else if (varp == &p_debug) {\n    if (check_opt_strings(p_debug, p_debug_values, TRUE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_dy) {  // 'display'\n    if (opt_strings_flags(p_dy, p_dy_values, &dy_flags, true) != OK)\n      errmsg = e_invarg;\n    else\n      (void)init_chartab();\n\n  }\n  /* 'eadirection' */\n  else if (varp == &p_ead) {\n    if (check_opt_strings(p_ead, p_ead_values, FALSE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_cb) {  // 'clipboard'\n    if (opt_strings_flags(p_cb, p_cb_values, &cb_flags, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &(curwin->w_s->b_p_spl)  // 'spell'\n             || varp == &(curwin->w_s->b_p_spf)) {\n    // When 'spelllang' or 'spellfile' is set and there is a window for this\n    // buffer in which 'spell' is set load the wordlists.\n    errmsg = did_set_spell_option(varp == &(curwin->w_s->b_p_spf));\n  }\n  /* When 'spellcapcheck' is set compile the regexp program. */\n  else if (varp == &(curwin->w_s->b_p_spc)) {\n    errmsg = compile_cap_prog(curwin->w_s);\n  }\n  /* 'spellsuggest' */\n  else if (varp == &p_sps) {\n    if (spell_check_sps() != OK)\n      errmsg = e_invarg;\n  }\n  /* 'mkspellmem' */\n  else if (varp == &p_msm) {\n    if (spell_check_msm() != OK)\n      errmsg = e_invarg;\n  }\n  /* When 'bufhidden' is set, check for valid value. */\n  else if (gvarp == &p_bh) {\n    if (check_opt_strings(curbuf->b_p_bh, p_bufhidden_values, FALSE) != OK)\n      errmsg = e_invarg;\n  }\n  /* When 'buftype' is set, check for valid value. */\n  else if (gvarp == &p_bt) {\n    if ((curbuf->terminal && curbuf->b_p_bt[0] != 't')\n        || (!curbuf->terminal && curbuf->b_p_bt[0] == 't')\n        || check_opt_strings(curbuf->b_p_bt, p_buftype_values, FALSE) != OK) {\n      errmsg = e_invarg;\n    } else {\n      if (curwin->w_status_height) {\n        curwin->w_redr_status = TRUE;\n        redraw_later(VALID);\n      }\n      curbuf->b_help = (curbuf->b_p_bt[0] == 'h');\n      redraw_titles();\n    }\n  }\n  /* 'statusline' or 'rulerformat' */\n  else if (gvarp == &p_stl || varp == &p_ruf) {\n    int wid;\n\n    if (varp == &p_ruf)         /* reset ru_wid first */\n      ru_wid = 0;\n    s = *varp;\n    if (varp == &p_ruf && *s == '%') {\n      /* set ru_wid if 'ruf' starts with \"%99(\" */\n      if (*++s == '-')          /* ignore a '-' */\n        s++;\n      wid = getdigits_int(&s);\n      if (wid && *s == '(' && (errmsg = check_stl_option(p_ruf)) == NULL)\n        ru_wid = wid;\n      else\n        errmsg = check_stl_option(p_ruf);\n    }\n    /* check 'statusline' only if it doesn't start with \"%!\" */\n    else if (varp == &p_ruf || s[0] != '%' || s[1] != '!')\n      errmsg = check_stl_option(s);\n    if (varp == &p_ruf && errmsg == NULL)\n      comp_col();\n  }\n  /* check if it is a valid value for 'complete' -- Acevedo */\n  else if (gvarp == &p_cpt) {\n    for (s = *varp; *s; ) {\n      while (*s == ',' || *s == ' ')\n        s++;\n      if (!*s)\n        break;\n      if (vim_strchr((char_u *)\".wbuksid]tU\", *s) == NULL) {\n        errmsg = illegal_char(errbuf, *s);\n        break;\n      }\n      if (*++s != NUL && *s != ',' && *s != ' ') {\n        if (s[-1] == 'k' || s[-1] == 's') {\n          /* skip optional filename after 'k' and 's' */\n          while (*s && *s != ',' && *s != ' ') {\n            if (*s == '\\\\')\n              ++s;\n            ++s;\n          }\n        } else {\n          if (errbuf != NULL) {\n            sprintf((char *)errbuf,\n                _(\"E535: Illegal character after <%c>\"),\n                *--s);\n            errmsg = errbuf;\n          } else\n            errmsg = (char_u *)\"\";\n          break;\n        }\n      }\n    }\n  }\n  /* 'completeopt' */\n  else if (varp == &p_cot) {\n    if (check_opt_strings(p_cot, p_cot_values, true) != OK) {\n      errmsg = e_invarg;\n    } else {\n      completeopt_was_set();\n    }\n  }\n  /* 'pastetoggle': translate key codes like in a mapping */\n  else if (varp == &p_pt) {\n    if (*p_pt) {\n      (void)replace_termcodes(p_pt, STRLEN(p_pt), &p, true, true, false,\n                              CPO_TO_CPO_FLAGS);\n      if (p != NULL) {\n        if (new_value_alloced)\n          free_string_option(p_pt);\n        p_pt = p;\n        new_value_alloced = TRUE;\n      }\n    }\n  }\n  /* 'backspace' */\n  else if (varp == &p_bs) {\n    if (ascii_isdigit(*p_bs)) {\n      if (*p_bs >'2' || p_bs[1] != NUL)\n        errmsg = e_invarg;\n    } else if (check_opt_strings(p_bs, p_bs_values, TRUE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_bo) {\n    if (opt_strings_flags(p_bo, p_bo_values, &bo_flags, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (gvarp == &p_tc) {  // 'tagcase'\n    unsigned int *flags;\n\n    if (opt_flags & OPT_LOCAL) {\n      p = curbuf->b_p_tc;\n      flags = &curbuf->b_tc_flags;\n    } else {\n      p = p_tc;\n      flags = &tc_flags;\n    }\n\n    if ((opt_flags & OPT_LOCAL) && *p == NUL) {\n      // make the local value empty: use the global value\n      *flags = 0;\n    } else if (*p == NUL\n               || opt_strings_flags(p, p_tc_values, flags, false) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_cmp) {  // 'casemap'\n    if (opt_strings_flags(p_cmp, p_cmp_values, &cmp_flags, true) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'diffopt' */\n  else if (varp == &p_dip) {\n    if (diffopt_changed() == FAIL)\n      errmsg = e_invarg;\n  }\n  /* 'foldmethod' */\n  else if (gvarp == &curwin->w_allbuf_opt.wo_fdm) {\n    if (check_opt_strings(*varp, p_fdm_values, FALSE) != OK\n        || *curwin->w_p_fdm == NUL)\n      errmsg = e_invarg;\n    else {\n      foldUpdateAll(curwin);\n      if (foldmethodIsDiff(curwin))\n        newFoldLevel();\n    }\n  }\n  /* 'foldexpr' */\n  else if (varp == &curwin->w_p_fde) {\n    if (foldmethodIsExpr(curwin))\n      foldUpdateAll(curwin);\n  }\n  /* 'foldmarker' */\n  else if (gvarp == &curwin->w_allbuf_opt.wo_fmr) {\n    p = vim_strchr(*varp, ',');\n    if (p == NULL)\n      errmsg = (char_u *)N_(\"E536: comma required\");\n    else if (p == *varp || p[1] == NUL)\n      errmsg = e_invarg;\n    else if (foldmethodIsMarker(curwin))\n      foldUpdateAll(curwin);\n  }\n  /* 'commentstring' */\n  else if (gvarp == &p_cms) {\n    if (**varp != NUL && strstr((char *)*varp, \"%s\") == NULL)\n      errmsg = (char_u *)N_(\n                \"E537: 'commentstring' must be empty or contain %s\");\n  } else if (varp == &p_fdo) {  // 'foldopen'\n    if (opt_strings_flags(p_fdo, p_fdo_values, &fdo_flags, true) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'foldclose' */\n  else if (varp == &p_fcl) {\n    if (check_opt_strings(p_fcl, p_fcl_values, TRUE) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'foldignore' */\n  else if (gvarp == &curwin->w_allbuf_opt.wo_fdi) {\n    if (foldmethodIsIndent(curwin))\n      foldUpdateAll(curwin);\n  } else if (varp == &p_ve) {  // 'virtualedit'\n    if (opt_strings_flags(p_ve, p_ve_values, &ve_flags, true) != OK)\n      errmsg = e_invarg;\n    else if (STRCMP(p_ve, oldval) != 0) {\n      /* Recompute cursor position in case the new 've' setting\n       * changes something. */\n      validate_virtcol();\n      coladvance(curwin->w_virtcol);\n    }\n  } else if (varp == &p_csqf) {\n    if (p_csqf != NULL) {\n      p = p_csqf;\n      while (*p != NUL) {\n        if (vim_strchr((char_u *)CSQF_CMDS, *p) == NULL\n            || p[1] == NUL\n            || vim_strchr((char_u *)CSQF_FLAGS, p[1]) == NULL\n            || (p[2] != NUL && p[2] != ',')) {\n          errmsg = e_invarg;\n          break;\n        } else if (p[2] == NUL)\n          break;\n        else\n          p += 3;\n      }\n    }\n  }\n  /* 'cinoptions' */\n  else if (gvarp == &p_cino) {\n    /* TODO: recognize errors */\n    parse_cino(curbuf);\n  // inccommand\n  } else if (varp == &p_icm) {\n      if (check_opt_strings(p_icm, p_icm_values, false) != OK) {\n        errmsg = e_invarg;\n      }\n  // Options that are a list of flags.\n  } else {\n    p = NULL;\n    if (varp == &p_ww)\n      p = (char_u *)WW_ALL;\n    if (varp == &p_shm)\n      p = (char_u *)SHM_ALL;\n    else if (varp == &(p_cpo))\n      p = (char_u *)CPO_VI;\n    else if (varp == &(curbuf->b_p_fo))\n      p = (char_u *)FO_ALL;\n    else if (varp == &curwin->w_p_cocu)\n      p = (char_u *)COCU_ALL;\n    else if (varp == &p_mouse) {\n      p = (char_u *)MOUSE_ALL;\n    }\n    if (p != NULL) {\n      for (s = *varp; *s; ++s)\n        if (vim_strchr(p, *s) == NULL) {\n          errmsg = illegal_char(errbuf, *s);\n          break;\n        }\n    }\n  }\n\n  /*\n   * If error detected, restore the previous value.\n   */\n  if (errmsg != NULL) {\n    if (new_value_alloced)\n      free_string_option(*varp);\n    *varp = oldval;\n    /*\n     * When resetting some values, need to act on it.\n     */\n    if (did_chartab)\n      (void)init_chartab();\n    if (varp == &p_hl)\n      (void)highlight_changed();\n  } else {\n    /* Remember where the option was set. */\n    set_option_scriptID_idx(opt_idx, opt_flags, current_SID);\n    /*\n     * Free string options that are in allocated memory.\n     * Use \"free_oldval\", because recursiveness may change the flags under\n     * our fingers (esp. init_highlight()).\n     */\n    if (free_oldval)\n      free_string_option(oldval);\n    if (new_value_alloced)\n      options[opt_idx].flags |= P_ALLOCED;\n    else\n      options[opt_idx].flags &= ~P_ALLOCED;\n\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n        && ((int)options[opt_idx].indir & PV_BOTH)) {\n      /* global option with local value set to use global value; free\n       * the local value and make it empty */\n      p = get_varp_scope(&(options[opt_idx]), OPT_LOCAL);\n      free_string_option(*(char_u **)p);\n      *(char_u **)p = empty_option;\n    }\n    /* May set global value for local option. */\n    else if (!(opt_flags & OPT_LOCAL) && opt_flags != OPT_GLOBAL)\n      set_string_option_global(opt_idx, varp);\n\n    /*\n     * Trigger the autocommand only after setting the flags.\n     */\n    /* When 'syntax' is set, load the syntax of that name */\n    if (varp == &(curbuf->b_p_syn)) {\n      apply_autocmds(EVENT_SYNTAX, curbuf->b_p_syn,\n          curbuf->b_fname, TRUE, curbuf);\n    } else if (varp == &(curbuf->b_p_ft)) {\n      /* 'filetype' is set, trigger the FileType autocommand */\n      did_filetype = TRUE;\n      apply_autocmds(EVENT_FILETYPE, curbuf->b_p_ft,\n          curbuf->b_fname, TRUE, curbuf);\n    }\n    if (varp == &(curwin->w_s->b_p_spl)) {\n      char_u fname[200];\n      char_u      *q = curwin->w_s->b_p_spl;\n\n      /* Skip the first name if it is \"cjk\". */\n      if (STRNCMP(q, \"cjk,\", 4) == 0)\n        q += 4;\n\n      /*\n       * Source the spell/LANG.vim in 'runtimepath'.\n       * They could set 'spellcapcheck' depending on the language.\n       * Use the first name in 'spelllang' up to '_region' or\n       * '.encoding'.\n       */\n      for (p = q; *p != NUL; ++p)\n        if (vim_strchr((char_u *)\"_.,\", *p) != NULL)\n          break;\n      vim_snprintf((char *)fname, sizeof(fname), \"spell/%.*s.vim\",\n                   (int)(p - q), q);\n      source_runtime(fname, DIP_ALL);\n    }\n  }\n\n  if (varp == &p_mouse) {\n    if (*p_mouse == NUL) {\n      ui_mouse_off();\n    } else {\n      setmouse();  // in case 'mouse' changed\n    }\n  }\n\n  if (curwin->w_curswant != MAXCOL\n      && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)\n    curwin->w_set_curswant = TRUE;\n\n  check_redraw(options[opt_idx].flags);\n\n  return errmsg;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147844,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "did_set_string_option (\n    int opt_idx,                            /* index in options[] table */\n    char_u **varp,                     /* pointer to the option variable */\n    int new_value_alloced,                  /* new value was allocated */\n    char_u *oldval,                    /* previous value of the option */\n    char_u *errbuf,                    /* buffer for errors, or NULL */\n    int opt_flags                          /* OPT_LOCAL and/or OPT_GLOBAL */\n)\n{\n  char_u      *errmsg = NULL;\n  char_u      *s, *p;\n  int did_chartab = FALSE;\n  char_u      **gvarp;\n  bool free_oldval = (options[opt_idx].flags & P_ALLOCED);\n\n  /* Get the global option to compare with, otherwise we would have to check\n   * two values for all local options. */\n  gvarp = (char_u **)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL);\n\n  /* Disallow changing some options from secure mode */\n  if ((secure || sandbox != 0)\n      && (options[opt_idx].flags & P_SECURE)) {\n    errmsg = e_secure;\n  }\n  /* Check for a \"normal\" file name in some options.  Disallow a path\n   * separator (slash and/or backslash), wildcards and characters that are\n   * often illegal in a file name. */\n  else if ((options[opt_idx].flags & P_NFNAME)\n           && vim_strpbrk(*varp, (char_u *)\"/\\\\*?[|<>\") != NULL) {\n    errmsg = e_invarg;\n  }\n  /* 'backupcopy' */\n  else if (gvarp == &p_bkc) {\n    char_u       *bkc   = p_bkc;\n    unsigned int *flags = &bkc_flags;\n\n    if (opt_flags & OPT_LOCAL) {\n      bkc   = curbuf->b_p_bkc;\n      flags = &curbuf->b_bkc_flags;\n    }\n\n    if ((opt_flags & OPT_LOCAL) && *bkc == NUL) {\n      // make the local value empty: use the global value\n      *flags = 0;\n    } else {\n      if (opt_strings_flags(bkc, p_bkc_values, flags, true) != OK) {\n        errmsg = e_invarg;\n      }\n\n      if (((*flags & BKC_AUTO) != 0)\n          + ((*flags & BKC_YES) != 0)\n          + ((*flags & BKC_NO) != 0) != 1) {\n        // Must have exactly one of \"auto\", \"yes\"  and \"no\".\n        (void)opt_strings_flags(oldval, p_bkc_values, flags, true);\n        errmsg = e_invarg;\n      }\n    }\n  }\n  /* 'backupext' and 'patchmode' */\n  else if (varp == &p_bex || varp == &p_pm) {\n    if (STRCMP(*p_bex == '.' ? p_bex + 1 : p_bex,\n            *p_pm == '.' ? p_pm + 1 : p_pm) == 0)\n      errmsg = (char_u *)N_(\"E589: 'backupext' and 'patchmode' are equal\");\n  }\n  /* 'breakindentopt' */\n  else if (varp == &curwin->w_p_briopt) {\n    if (briopt_check(curwin) == FAIL)\n      errmsg = e_invarg;\n  } else if (varp == &p_isi\n             || varp == &(curbuf->b_p_isk)\n             || varp == &p_isp\n             || varp == &p_isf) {\n    // 'isident', 'iskeyword', 'isprint or 'isfname' option: refill g_chartab[]\n    // If the new option is invalid, use old value.  'lisp' option: refill\n    // g_chartab[] for '-' char\n    if (init_chartab() == FAIL) {\n      did_chartab = TRUE;           /* need to restore it below */\n      errmsg = e_invarg;            /* error in value */\n    }\n  }\n  /* 'helpfile' */\n  else if (varp == &p_hf) {\n    /* May compute new values for $VIM and $VIMRUNTIME */\n    if (didset_vim) {\n      vim_setenv(\"VIM\", \"\");\n      didset_vim = FALSE;\n    }\n    if (didset_vimruntime) {\n      vim_setenv(\"VIMRUNTIME\", \"\");\n      didset_vimruntime = FALSE;\n    }\n  }\n  /* 'colorcolumn' */\n  else if (varp == &curwin->w_p_cc)\n    errmsg = check_colorcolumn(curwin);\n\n  /* 'helplang' */\n  else if (varp == &p_hlg) {\n    /* Check for \"\", \"ab\", \"ab,cd\", etc. */\n    for (s = p_hlg; *s != NUL; s += 3) {\n      if (s[1] == NUL || ((s[2] != ',' || s[3] == NUL) && s[2] != NUL)) {\n        errmsg = e_invarg;\n        break;\n      }\n      if (s[2] == NUL)\n        break;\n    }\n  }\n  /* 'highlight' */\n  else if (varp == &p_hl) {\n    if (highlight_changed() == FAIL)\n      errmsg = e_invarg;        /* invalid flags */\n  }\n  /* 'nrformats' */\n  else if (gvarp == &p_nf) {\n    if (check_opt_strings(*varp, p_nf_values, TRUE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_ssop) {  // 'sessionoptions'\n    if (opt_strings_flags(p_ssop, p_ssop_values, &ssop_flags, true) != OK)\n      errmsg = e_invarg;\n    if ((ssop_flags & SSOP_CURDIR) && (ssop_flags & SSOP_SESDIR)) {\n      /* Don't allow both \"sesdir\" and \"curdir\". */\n      (void)opt_strings_flags(oldval, p_ssop_values, &ssop_flags, true);\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_vop) {  // 'viewoptions'\n    if (opt_strings_flags(p_vop, p_ssop_values, &vop_flags, true) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'scrollopt' */\n  else if (varp == &p_sbo) {\n    if (check_opt_strings(p_sbo, p_scbopt_values, TRUE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_ambw || (int *)varp == &p_emoji) {\n    // 'ambiwidth'\n    if (check_opt_strings(p_ambw, p_ambw_values, false) != OK) {\n      errmsg = e_invarg;\n    } else if (set_chars_option(&p_lcs) != NULL) {\n      errmsg = (char_u *)_(\"E834: Conflicts with value of 'listchars'\");\n    } else if (set_chars_option(&p_fcs) != NULL) {\n      errmsg = (char_u *)_(\"E835: Conflicts with value of 'fillchars'\");\n    }\n  }\n  /* 'background' */\n  else if (varp == &p_bg) {\n    if (check_opt_strings(p_bg, p_bg_values, FALSE) == OK) {\n      int dark = (*p_bg == 'd');\n\n      init_highlight(FALSE, FALSE);\n\n      if (dark != (*p_bg == 'd')\n          && get_var_value((char_u *)\"g:colors_name\") != NULL) {\n        /* The color scheme must have set 'background' back to another\n         * value, that's not what we want here.  Disable the color\n         * scheme and set the colors again. */\n        do_unlet((char_u *)\"g:colors_name\", TRUE);\n        free_string_option(p_bg);\n        p_bg = vim_strsave((char_u *)(dark ? \"dark\" : \"light\"));\n        check_string_option(&p_bg);\n        init_highlight(FALSE, FALSE);\n      }\n    } else\n      errmsg = e_invarg;\n  }\n  /* 'wildmode' */\n  else if (varp == &p_wim) {\n    if (check_opt_wim() == FAIL)\n      errmsg = e_invarg;\n  }\n  /* 'wildoptions' */\n  else if (varp == &p_wop) {\n    if (check_opt_strings(p_wop, p_wop_values, TRUE) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'winaltkeys' */\n  else if (varp == &p_wak) {\n    if (*p_wak == NUL\n        || check_opt_strings(p_wak, p_wak_values, FALSE) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'eventignore' */\n  else if (varp == &p_ei) {\n    if (check_ei() == FAIL)\n      errmsg = e_invarg;\n  /* 'encoding' and 'fileencoding' */\n  } else if (varp == &p_enc || gvarp == &p_fenc) {\n    if (gvarp == &p_fenc) {\n      if (!MODIFIABLE(curbuf) && opt_flags != OPT_GLOBAL) {\n        errmsg = e_modifiable;\n      } else if (vim_strchr(*varp, ',') != NULL) {\n        // No comma allowed in 'fileencoding'; catches confusing it\n        // with 'fileencodings'.\n        errmsg = e_invarg;\n      } else {\n        // May show a \"+\" in the title now.\n        redraw_titles();\n        // Add 'fileencoding' to the swap file.\n        ml_setflags(curbuf);\n      }\n    }\n\n    if (errmsg == NULL) {\n      /* canonize the value, so that STRCMP() can be used on it */\n      p = enc_canonize(*varp);\n      xfree(*varp);\n      *varp = p;\n      if (varp == &p_enc) {\n        // only encoding=utf-8 allowed\n        if (STRCMP(p_enc, \"utf-8\") != 0) {\n          errmsg = e_invarg;\n        }\n      }\n    }\n  } else if (varp == &p_penc) {\n    /* Canonize printencoding if VIM standard one */\n    p = enc_canonize(p_penc);\n    xfree(p_penc);\n    p_penc = p;\n  } else if (varp == &curbuf->b_p_keymap) {\n    if (!valid_filetype(*varp)) {\n      errmsg = e_invarg;\n    } else {\n      // load or unload key mapping tables\n      errmsg = keymap_init();\n    }\n\n    if (errmsg == NULL) {\n      if (*curbuf->b_p_keymap != NUL) {\n        /* Installed a new keymap, switch on using it. */\n        curbuf->b_p_iminsert = B_IMODE_LMAP;\n        if (curbuf->b_p_imsearch != B_IMODE_USE_INSERT)\n          curbuf->b_p_imsearch = B_IMODE_LMAP;\n      } else {\n        /* Cleared the keymap, may reset 'iminsert' and 'imsearch'. */\n        if (curbuf->b_p_iminsert == B_IMODE_LMAP)\n          curbuf->b_p_iminsert = B_IMODE_NONE;\n        if (curbuf->b_p_imsearch == B_IMODE_LMAP)\n          curbuf->b_p_imsearch = B_IMODE_USE_INSERT;\n      }\n      if ((opt_flags & OPT_LOCAL) == 0) {\n        set_iminsert_global();\n        set_imsearch_global();\n      }\n      status_redraw_curbuf();\n    }\n  }\n  /* 'fileformat' */\n  else if (gvarp == &p_ff) {\n    if (!MODIFIABLE(curbuf) && !(opt_flags & OPT_GLOBAL))\n      errmsg = e_modifiable;\n    else if (check_opt_strings(*varp, p_ff_values, FALSE) != OK)\n      errmsg = e_invarg;\n    else {\n      redraw_titles();\n      /* update flag in swap file */\n      ml_setflags(curbuf);\n      /* Redraw needed when switching to/from \"mac\": a CR in the text\n       * will be displayed differently. */\n      if (get_fileformat(curbuf) == EOL_MAC || *oldval == 'm')\n        redraw_curbuf_later(NOT_VALID);\n    }\n  }\n  /* 'fileformats' */\n  else if (varp == &p_ffs) {\n    if (check_opt_strings(p_ffs, p_ff_values, TRUE) != OK) {\n      errmsg = e_invarg;\n    }\n  }\n\n  /* 'matchpairs' */\n  else if (gvarp == &p_mps) {\n    if (has_mbyte) {\n      for (p = *varp; *p != NUL; ++p) {\n        int x2 = -1;\n        int x3 = -1;\n\n        if (*p != NUL)\n          p += mb_ptr2len(p);\n        if (*p != NUL)\n          x2 = *p++;\n        if (*p != NUL) {\n          x3 = mb_ptr2char(p);\n          p += mb_ptr2len(p);\n        }\n        if (x2 != ':' || x3 == -1 || (*p != NUL && *p != ',')) {\n          errmsg = e_invarg;\n          break;\n        }\n        if (*p == NUL)\n          break;\n      }\n    } else {\n      /* Check for \"x:y,x:y\" */\n      for (p = *varp; *p != NUL; p += 4) {\n        if (p[1] != ':' || p[2] == NUL || (p[3] != NUL && p[3] != ',')) {\n          errmsg = e_invarg;\n          break;\n        }\n        if (p[3] == NUL)\n          break;\n      }\n    }\n  }\n  /* 'comments' */\n  else if (gvarp == &p_com) {\n    for (s = *varp; *s; ) {\n      while (*s && *s != ':') {\n        if (vim_strchr((char_u *)COM_ALL, *s) == NULL\n            && !ascii_isdigit(*s) && *s != '-') {\n          errmsg = illegal_char(errbuf, *s);\n          break;\n        }\n        ++s;\n      }\n      if (*s++ == NUL)\n        errmsg = (char_u *)N_(\"E524: Missing colon\");\n      else if (*s == ',' || *s == NUL)\n        errmsg = (char_u *)N_(\"E525: Zero length string\");\n      if (errmsg != NULL)\n        break;\n      while (*s && *s != ',') {\n        if (*s == '\\\\' && s[1] != NUL)\n          ++s;\n        ++s;\n      }\n      s = skip_to_option_part(s);\n    }\n  }\n  /* 'listchars' */\n  else if (varp == &p_lcs) {\n    errmsg = set_chars_option(varp);\n  }\n  /* 'fillchars' */\n  else if (varp == &p_fcs) {\n    errmsg = set_chars_option(varp);\n  }\n  /* 'cedit' */\n  else if (varp == &p_cedit) {\n    errmsg = check_cedit();\n  }\n  /* 'verbosefile' */\n  else if (varp == &p_vfile) {\n    verbose_stop();\n    if (*p_vfile != NUL && verbose_open() == FAIL)\n      errmsg = e_invarg;\n  /* 'shada' */\n  } else if (varp == &p_shada) {\n    // TODO(ZyX-I): Remove this code in the future, alongside with &viminfo\n    //              option.\n    opt_idx = ((options[opt_idx].fullname[0] == 'v')\n               ? (shada_idx == -1\n                  ? ((shada_idx = findoption((char_u *) \"shada\")))\n                  : shada_idx)\n               : opt_idx);\n    for (s = p_shada; *s; ) {\n      /* Check it's a valid character */\n      if (vim_strchr((char_u *)\"!\\\"%'/:<@cfhnrs\", *s) == NULL) {\n        errmsg = illegal_char(errbuf, *s);\n        break;\n      }\n      if (*s == 'n') {          /* name is always last one */\n        break;\n      } else if (*s == 'r') { /* skip until next ',' */\n        while (*++s && *s != ',')\n          ;\n      } else if (*s == '%') {\n        /* optional number */\n        while (ascii_isdigit(*++s))\n          ;\n      } else if (*s == '!' || *s == 'h' || *s == 'c')\n        ++s;                    /* no extra chars */\n      else {                    /* must have a number */\n        while (ascii_isdigit(*++s))\n          ;\n\n        if (!ascii_isdigit(*(s - 1))) {\n          if (errbuf != NULL) {\n            sprintf((char *)errbuf,\n                _(\"E526: Missing number after <%s>\"),\n                transchar_byte(*(s - 1)));\n            errmsg = errbuf;\n          } else\n            errmsg = (char_u *)\"\";\n          break;\n        }\n      }\n      if (*s == ',')\n        ++s;\n      else if (*s) {\n        if (errbuf != NULL)\n          errmsg = (char_u *)N_(\"E527: Missing comma\");\n        else\n          errmsg = (char_u *)\"\";\n        break;\n      }\n    }\n    if (*p_shada && errmsg == NULL && get_shada_parameter('\\'') < 0)\n      errmsg = (char_u *)N_(\"E528: Must specify a ' value\");\n  }\n  /* 'showbreak' */\n  else if (varp == &p_sbr) {\n    for (s = p_sbr; *s; ) {\n      if (ptr2cells(s) != 1)\n        errmsg = (char_u *)N_(\"E595: contains unprintable or wide character\");\n      mb_ptr_adv(s);\n    }\n  }\n\n  /* 'guicursor' */\n  else if (varp == &p_guicursor)\n    errmsg = parse_shape_opt(SHAPE_CURSOR);\n\n  else if (varp == &p_popt)\n    errmsg = parse_printoptions();\n  else if (varp == &p_pmfn)\n    errmsg = parse_printmbfont();\n\n  /* 'langmap' */\n  else if (varp == &p_langmap)\n    langmap_set();\n\n  /* 'breakat' */\n  else if (varp == &p_breakat)\n    fill_breakat_flags();\n\n  /* 'titlestring' and 'iconstring' */\n  else if (varp == &p_titlestring || varp == &p_iconstring) {\n    int flagval = (varp == &p_titlestring) ? STL_IN_TITLE : STL_IN_ICON;\n\n    /* NULL => statusline syntax */\n    if (vim_strchr(*varp, '%') && check_stl_option(*varp) == NULL)\n      stl_syntax |= flagval;\n    else\n      stl_syntax &= ~flagval;\n    did_set_title(varp == &p_iconstring);\n\n  }\n\n  /* 'selection' */\n  else if (varp == &p_sel) {\n    if (*p_sel == NUL\n        || check_opt_strings(p_sel, p_sel_values, FALSE) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'selectmode' */\n  else if (varp == &p_slm) {\n    if (check_opt_strings(p_slm, p_slm_values, TRUE) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'keymodel' */\n  else if (varp == &p_km) {\n    if (check_opt_strings(p_km, p_km_values, TRUE) != OK)\n      errmsg = e_invarg;\n    else {\n      km_stopsel = (vim_strchr(p_km, 'o') != NULL);\n      km_startsel = (vim_strchr(p_km, 'a') != NULL);\n    }\n  }\n  /* 'mousemodel' */\n  else if (varp == &p_mousem) {\n    if (check_opt_strings(p_mousem, p_mousem_values, FALSE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_swb) {  // 'switchbuf'\n    if (opt_strings_flags(p_swb, p_swb_values, &swb_flags, true) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'debug' */\n  else if (varp == &p_debug) {\n    if (check_opt_strings(p_debug, p_debug_values, TRUE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_dy) {  // 'display'\n    if (opt_strings_flags(p_dy, p_dy_values, &dy_flags, true) != OK)\n      errmsg = e_invarg;\n    else\n      (void)init_chartab();\n\n  }\n  /* 'eadirection' */\n  else if (varp == &p_ead) {\n    if (check_opt_strings(p_ead, p_ead_values, FALSE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_cb) {  // 'clipboard'\n    if (opt_strings_flags(p_cb, p_cb_values, &cb_flags, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &(curwin->w_s->b_p_spl)  // 'spell'\n             || varp == &(curwin->w_s->b_p_spf)) {\n    // When 'spelllang' or 'spellfile' is set and there is a window for this\n    // buffer in which 'spell' is set load the wordlists.\n    errmsg = did_set_spell_option(varp == &(curwin->w_s->b_p_spf));\n  }\n  /* When 'spellcapcheck' is set compile the regexp program. */\n  else if (varp == &(curwin->w_s->b_p_spc)) {\n    errmsg = compile_cap_prog(curwin->w_s);\n  }\n  /* 'spellsuggest' */\n  else if (varp == &p_sps) {\n    if (spell_check_sps() != OK)\n      errmsg = e_invarg;\n  }\n  /* 'mkspellmem' */\n  else if (varp == &p_msm) {\n    if (spell_check_msm() != OK)\n      errmsg = e_invarg;\n  }\n  /* When 'bufhidden' is set, check for valid value. */\n  else if (gvarp == &p_bh) {\n    if (check_opt_strings(curbuf->b_p_bh, p_bufhidden_values, FALSE) != OK)\n      errmsg = e_invarg;\n  }\n  /* When 'buftype' is set, check for valid value. */\n  else if (gvarp == &p_bt) {\n    if ((curbuf->terminal && curbuf->b_p_bt[0] != 't')\n        || (!curbuf->terminal && curbuf->b_p_bt[0] == 't')\n        || check_opt_strings(curbuf->b_p_bt, p_buftype_values, FALSE) != OK) {\n      errmsg = e_invarg;\n    } else {\n      if (curwin->w_status_height) {\n        curwin->w_redr_status = TRUE;\n        redraw_later(VALID);\n      }\n      curbuf->b_help = (curbuf->b_p_bt[0] == 'h');\n      redraw_titles();\n    }\n  }\n  /* 'statusline' or 'rulerformat' */\n  else if (gvarp == &p_stl || varp == &p_ruf) {\n    int wid;\n\n    if (varp == &p_ruf)         /* reset ru_wid first */\n      ru_wid = 0;\n    s = *varp;\n    if (varp == &p_ruf && *s == '%') {\n      /* set ru_wid if 'ruf' starts with \"%99(\" */\n      if (*++s == '-')          /* ignore a '-' */\n        s++;\n      wid = getdigits_int(&s);\n      if (wid && *s == '(' && (errmsg = check_stl_option(p_ruf)) == NULL)\n        ru_wid = wid;\n      else\n        errmsg = check_stl_option(p_ruf);\n    }\n    /* check 'statusline' only if it doesn't start with \"%!\" */\n    else if (varp == &p_ruf || s[0] != '%' || s[1] != '!')\n      errmsg = check_stl_option(s);\n    if (varp == &p_ruf && errmsg == NULL)\n      comp_col();\n  }\n  /* check if it is a valid value for 'complete' -- Acevedo */\n  else if (gvarp == &p_cpt) {\n    for (s = *varp; *s; ) {\n      while (*s == ',' || *s == ' ')\n        s++;\n      if (!*s)\n        break;\n      if (vim_strchr((char_u *)\".wbuksid]tU\", *s) == NULL) {\n        errmsg = illegal_char(errbuf, *s);\n        break;\n      }\n      if (*++s != NUL && *s != ',' && *s != ' ') {\n        if (s[-1] == 'k' || s[-1] == 's') {\n          /* skip optional filename after 'k' and 's' */\n          while (*s && *s != ',' && *s != ' ') {\n            if (*s == '\\\\')\n              ++s;\n            ++s;\n          }\n        } else {\n          if (errbuf != NULL) {\n            sprintf((char *)errbuf,\n                _(\"E535: Illegal character after <%c>\"),\n                *--s);\n            errmsg = errbuf;\n          } else\n            errmsg = (char_u *)\"\";\n          break;\n        }\n      }\n    }\n  }\n  /* 'completeopt' */\n  else if (varp == &p_cot) {\n    if (check_opt_strings(p_cot, p_cot_values, true) != OK) {\n      errmsg = e_invarg;\n    } else {\n      completeopt_was_set();\n    }\n  }\n  /* 'pastetoggle': translate key codes like in a mapping */\n  else if (varp == &p_pt) {\n    if (*p_pt) {\n      (void)replace_termcodes(p_pt, STRLEN(p_pt), &p, true, true, false,\n                              CPO_TO_CPO_FLAGS);\n      if (p != NULL) {\n        if (new_value_alloced)\n          free_string_option(p_pt);\n        p_pt = p;\n        new_value_alloced = TRUE;\n      }\n    }\n  }\n  /* 'backspace' */\n  else if (varp == &p_bs) {\n    if (ascii_isdigit(*p_bs)) {\n      if (*p_bs >'2' || p_bs[1] != NUL)\n        errmsg = e_invarg;\n    } else if (check_opt_strings(p_bs, p_bs_values, TRUE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_bo) {\n    if (opt_strings_flags(p_bo, p_bo_values, &bo_flags, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (gvarp == &p_tc) {  // 'tagcase'\n    unsigned int *flags;\n\n    if (opt_flags & OPT_LOCAL) {\n      p = curbuf->b_p_tc;\n      flags = &curbuf->b_tc_flags;\n    } else {\n      p = p_tc;\n      flags = &tc_flags;\n    }\n\n    if ((opt_flags & OPT_LOCAL) && *p == NUL) {\n      // make the local value empty: use the global value\n      *flags = 0;\n    } else if (*p == NUL\n               || opt_strings_flags(p, p_tc_values, flags, false) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_cmp) {  // 'casemap'\n    if (opt_strings_flags(p_cmp, p_cmp_values, &cmp_flags, true) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'diffopt' */\n  else if (varp == &p_dip) {\n    if (diffopt_changed() == FAIL)\n      errmsg = e_invarg;\n  }\n  /* 'foldmethod' */\n  else if (gvarp == &curwin->w_allbuf_opt.wo_fdm) {\n    if (check_opt_strings(*varp, p_fdm_values, FALSE) != OK\n        || *curwin->w_p_fdm == NUL)\n      errmsg = e_invarg;\n    else {\n      foldUpdateAll(curwin);\n      if (foldmethodIsDiff(curwin))\n        newFoldLevel();\n    }\n  }\n  /* 'foldexpr' */\n  else if (varp == &curwin->w_p_fde) {\n    if (foldmethodIsExpr(curwin))\n      foldUpdateAll(curwin);\n  }\n  /* 'foldmarker' */\n  else if (gvarp == &curwin->w_allbuf_opt.wo_fmr) {\n    p = vim_strchr(*varp, ',');\n    if (p == NULL)\n      errmsg = (char_u *)N_(\"E536: comma required\");\n    else if (p == *varp || p[1] == NUL)\n      errmsg = e_invarg;\n    else if (foldmethodIsMarker(curwin))\n      foldUpdateAll(curwin);\n  }\n  /* 'commentstring' */\n  else if (gvarp == &p_cms) {\n    if (**varp != NUL && strstr((char *)*varp, \"%s\") == NULL)\n      errmsg = (char_u *)N_(\n                \"E537: 'commentstring' must be empty or contain %s\");\n  } else if (varp == &p_fdo) {  // 'foldopen'\n    if (opt_strings_flags(p_fdo, p_fdo_values, &fdo_flags, true) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'foldclose' */\n  else if (varp == &p_fcl) {\n    if (check_opt_strings(p_fcl, p_fcl_values, TRUE) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'foldignore' */\n  else if (gvarp == &curwin->w_allbuf_opt.wo_fdi) {\n    if (foldmethodIsIndent(curwin))\n      foldUpdateAll(curwin);\n  } else if (varp == &p_ve) {  // 'virtualedit'\n    if (opt_strings_flags(p_ve, p_ve_values, &ve_flags, true) != OK)\n      errmsg = e_invarg;\n    else if (STRCMP(p_ve, oldval) != 0) {\n      /* Recompute cursor position in case the new 've' setting\n       * changes something. */\n      validate_virtcol();\n      coladvance(curwin->w_virtcol);\n    }\n  } else if (varp == &p_csqf) {\n    if (p_csqf != NULL) {\n      p = p_csqf;\n      while (*p != NUL) {\n        if (vim_strchr((char_u *)CSQF_CMDS, *p) == NULL\n            || p[1] == NUL\n            || vim_strchr((char_u *)CSQF_FLAGS, p[1]) == NULL\n            || (p[2] != NUL && p[2] != ',')) {\n          errmsg = e_invarg;\n          break;\n        } else if (p[2] == NUL)\n          break;\n        else\n          p += 3;\n      }\n    }\n  }\n  /* 'cinoptions' */\n  else if (gvarp == &p_cino) {\n    /* TODO: recognize errors */\n    parse_cino(curbuf);\n  // inccommand\n  } else if (varp == &p_icm) {\n      if (check_opt_strings(p_icm, p_icm_values, false) != OK) {\n        errmsg = e_invarg;\n      }\n  } else if (gvarp == &p_ft) {\n    if (!valid_filetype(*varp)) {\n      errmsg = e_invarg;\n    }\n  } else if (gvarp == &p_syn) {\n    if (!valid_filetype(*varp)) {\n      errmsg = e_invarg;\n    }\n  } else {\n    // Options that are a list of flags.\n    p = NULL;\n    if (varp == &p_ww)\n      p = (char_u *)WW_ALL;\n    if (varp == &p_shm)\n      p = (char_u *)SHM_ALL;\n    else if (varp == &(p_cpo))\n      p = (char_u *)CPO_VI;\n    else if (varp == &(curbuf->b_p_fo))\n      p = (char_u *)FO_ALL;\n    else if (varp == &curwin->w_p_cocu)\n      p = (char_u *)COCU_ALL;\n    else if (varp == &p_mouse) {\n      p = (char_u *)MOUSE_ALL;\n    }\n    if (p != NULL) {\n      for (s = *varp; *s; ++s)\n        if (vim_strchr(p, *s) == NULL) {\n          errmsg = illegal_char(errbuf, *s);\n          break;\n        }\n    }\n  }\n\n  /*\n   * If error detected, restore the previous value.\n   */\n  if (errmsg != NULL) {\n    if (new_value_alloced)\n      free_string_option(*varp);\n    *varp = oldval;\n    /*\n     * When resetting some values, need to act on it.\n     */\n    if (did_chartab)\n      (void)init_chartab();\n    if (varp == &p_hl)\n      (void)highlight_changed();\n  } else {\n    /* Remember where the option was set. */\n    set_option_scriptID_idx(opt_idx, opt_flags, current_SID);\n    /*\n     * Free string options that are in allocated memory.\n     * Use \"free_oldval\", because recursiveness may change the flags under\n     * our fingers (esp. init_highlight()).\n     */\n    if (free_oldval)\n      free_string_option(oldval);\n    if (new_value_alloced)\n      options[opt_idx].flags |= P_ALLOCED;\n    else\n      options[opt_idx].flags &= ~P_ALLOCED;\n\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n        && ((int)options[opt_idx].indir & PV_BOTH)) {\n      /* global option with local value set to use global value; free\n       * the local value and make it empty */\n      p = get_varp_scope(&(options[opt_idx]), OPT_LOCAL);\n      free_string_option(*(char_u **)p);\n      *(char_u **)p = empty_option;\n    }\n    /* May set global value for local option. */\n    else if (!(opt_flags & OPT_LOCAL) && opt_flags != OPT_GLOBAL)\n      set_string_option_global(opt_idx, varp);\n\n    /*\n     * Trigger the autocommand only after setting the flags.\n     */\n    /* When 'syntax' is set, load the syntax of that name */\n    if (varp == &(curbuf->b_p_syn)) {\n      apply_autocmds(EVENT_SYNTAX, curbuf->b_p_syn,\n          curbuf->b_fname, TRUE, curbuf);\n    } else if (varp == &(curbuf->b_p_ft)) {\n      /* 'filetype' is set, trigger the FileType autocommand */\n      did_filetype = TRUE;\n      apply_autocmds(EVENT_FILETYPE, curbuf->b_p_ft,\n          curbuf->b_fname, TRUE, curbuf);\n    }\n    if (varp == &(curwin->w_s->b_p_spl)) {\n      char_u fname[200];\n      char_u      *q = curwin->w_s->b_p_spl;\n\n      /* Skip the first name if it is \"cjk\". */\n      if (STRNCMP(q, \"cjk,\", 4) == 0)\n        q += 4;\n\n      /*\n       * Source the spell/LANG.vim in 'runtimepath'.\n       * They could set 'spellcapcheck' depending on the language.\n       * Use the first name in 'spelllang' up to '_region' or\n       * '.encoding'.\n       */\n      for (p = q; *p != NUL; ++p)\n        if (vim_strchr((char_u *)\"_.,\", *p) != NULL)\n          break;\n      vim_snprintf((char *)fname, sizeof(fname), \"spell/%.*s.vim\",\n                   (int)(p - q), q);\n      source_runtime(fname, DIP_ALL);\n    }\n  }\n\n  if (varp == &p_mouse) {\n    if (*p_mouse == NUL) {\n      ui_mouse_off();\n    } else {\n      setmouse();  // in case 'mouse' changed\n    }\n  }\n\n  if (curwin->w_curswant != MAXCOL\n      && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)\n    curwin->w_set_curswant = TRUE;\n\n  check_redraw(options[opt_idx].flags);\n\n  return errmsg;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147845,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int cbor2json (OSCTXT* pCborCtxt, OSCTXT* pJsonCtxt)\r\n{\r\n   int ret = 0;\r\n   OSOCTET tag, ub;\r\n\r\n   /* Read byte from stream */\r\n   ret = rtxReadBytes (pCborCtxt, &ub, 1);\r\n   if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\r\n   tag = ub >> 5;\r\n\r\n   /* Switch on tag value */\r\n   switch (tag) {\r\n   case OSRTCBOR_UINT: {\r\n      OSUINTTYPE value;\r\n      ret = rtCborDecUInt (pCborCtxt, ub, &value);\r\n      if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\r\n\r\n      /* Encode JSON */\r\n#ifndef _NO_INT64_SUPPORT\r\n      ret = rtJsonEncUInt64Value (pJsonCtxt, value);\r\n#else\r\n      ret = rtJsonEncUIntValue (pJsonCtxt, value);\r\n#endif\r\n      if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\r\n      break;\r\n   }\r\n   case OSRTCBOR_NEGINT: {\r\n      OSINTTYPE value;\r\n      ret = rtCborDecInt (pCborCtxt, ub, &value);\r\n      if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\r\n\r\n      /* Encode JSON */\r\n#ifndef _NO_INT64_SUPPORT\r\n      ret = rtJsonEncInt64Value (pJsonCtxt, value);\r\n#else\r\n      ret = rtJsonEncIntValue (pJsonCtxt, value);\r\n#endif\r\n      if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\r\n      break;\r\n   }\r\n   case OSRTCBOR_BYTESTR: {\r\n      OSDynOctStr64 byteStr;\r\n      ret = rtCborDecDynByteStr (pCborCtxt, ub, &byteStr);\r\n      if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\r\n\r\n      /* Encode JSON */\r\n      ret = rtJsonEncHexStr (pJsonCtxt, byteStr.numocts, byteStr.data);\r\n      rtxMemFreePtr (pCborCtxt, byteStr.data);\r\n      if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\r\n\r\n      break;\r\n   }\r\n   case OSRTCBOR_UTF8STR: {\r\n      OSUTF8CHAR* utf8str;\r\n      ret = rtCborDecDynUTF8Str (pCborCtxt, ub, (char**)&utf8str);\r\n\r\n      ret = rtJsonEncStringValue (pJsonCtxt, utf8str);\r\n      rtxMemFreePtr (pCborCtxt, utf8str);\r\n      if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\r\n\r\n      break;\r\n   }\r\n   case OSRTCBOR_ARRAY: \r\n   case OSRTCBOR_MAP: {\r\n      OSOCTET len = ub & 0x1F;\r\n      char startChar = (tag == OSRTCBOR_ARRAY) ? '[' : '{';\r\n      char endChar = (tag == OSRTCBOR_ARRAY) ? ']' : '}';\r\n\r\n      OSRTSAFEPUTCHAR (pJsonCtxt, startChar);\r\n\r\n      if (len == OSRTCBOR_INDEF) {\r\n         OSBOOL first = TRUE;\r\n         for (;;) {\r\n            if (OSRTCBOR_MATCHEOC (pCborCtxt)) {\r\n               pCborCtxt->buffer.byteIndex++;\r\n               break;\r\n            }\r\n\r\n            if (!first) \r\n               OSRTSAFEPUTCHAR (pJsonCtxt, ',');\r\n            else\r\n               first = FALSE;\r\n\r\n            /* If map, decode object name */\r\n            if (tag == OSRTCBOR_MAP) {\r\n               ret = cborElemNameToJson (pCborCtxt, pJsonCtxt);\r\n            }\r\n\r\n            /* Make recursive call */\r\n            if (0 == ret)\r\n               ret = cbor2json (pCborCtxt, pJsonCtxt);\r\n            if (0 != ret) {\r\n               OSCTXT* pctxt = \r\n                  (rtxErrGetErrorCnt(pJsonCtxt) > 0) ? pJsonCtxt : pCborCtxt;\r\n               return LOG_RTERR (pctxt, ret);\r\n            }\r\n         }\r\n      }\r\n      else { /* definite length */\r\n         OSSIZE nitems;\r\n\r\n         /* Decode tag and number of items */\r\n         ret = rtCborDecSize (pCborCtxt, len, &nitems);\r\n         if (0 == ret) {\r\n            OSSIZE i;\r\n\r\n            /* Loop to decode array items */\r\n            for (i = 0; i < nitems; i++) {\r\n               if (0 != i) OSRTSAFEPUTCHAR (pJsonCtxt, ',');\r\n\r\n               /* If map, decode object name */\r\n               if (tag == OSRTCBOR_MAP) {\r\n                  ret = cborElemNameToJson (pCborCtxt, pJsonCtxt);\r\n               }\r\n\r\n               /* Make recursive call */\r\n               if (0 == ret)\r\n                  ret = cbor2json (pCborCtxt, pJsonCtxt);\r\n               if (0 != ret) {\r\n                  OSCTXT* pctxt = \r\n                  (rtxErrGetErrorCnt(pJsonCtxt) > 0) ? pJsonCtxt : pCborCtxt;\r\n                  return LOG_RTERR (pctxt, ret);\r\n               }\r\n            }\r\n         }\r\n      }\r\n      OSRTSAFEPUTCHAR (pJsonCtxt, endChar);\r\n      break;\r\n   }\r\n\r\n   case OSRTCBOR_FLOAT:\r\n      if (tag == OSRTCBOR_FALSEENC || tag == OSRTCBOR_TRUEENC) {\r\n         OSBOOL boolval = (ub == OSRTCBOR_TRUEENC) ? TRUE : FALSE;\r\n         ret = rtJsonEncBoolValue (pJsonCtxt, boolval);\r\n         if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\r\n      }\r\n      else if (tag == OSRTCBOR_FLT16ENC ||\r\n               tag == OSRTCBOR_FLT32ENC ||\r\n               tag == OSRTCBOR_FLT64ENC) {\r\n         OSDOUBLE fltval;\r\n         ret = rtCborDecFloat (pCborCtxt, ub, &fltval);\r\n         if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\r\n\r\n         /* Encode JSON */\r\n         ret = rtJsonEncDoubleValue (pJsonCtxt, fltval, 0);\r\n         if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\r\n      }\r\n      else {\r\n         ret = cborTagNotSupp (pCborCtxt, tag);\r\n      }\r\n      break;\r\n\r\n   default:\r\n      ret = cborTagNotSupp (pCborCtxt, tag);\r\n   }\r\n\r\n   return ret;\r\n}\r",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147876,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int cbor2json (OSCTXT* pCborCtxt, OSCTXT* pJsonCtxt)\r\n{\r\n   int ret = 0;\r\n   OSOCTET tag, ub;\r\n\r\n   /* Read byte from stream */\r\n   ret = rtxReadBytes (pCborCtxt, &ub, 1);\r\n   if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\r\n   tag = ub >> 5;\r\n\r\n   /* Switch on tag value */\r\n   switch (tag) {\r\n   case OSRTCBOR_UINT: {\r\n      OSUINTTYPE value;\r\n      ret = rtCborDecUInt (pCborCtxt, ub, &value);\r\n      if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\r\n\r\n      /* Encode JSON */\r\n#ifndef _NO_INT64_SUPPORT\r\n      ret = rtJsonEncUInt64Value (pJsonCtxt, value);\r\n#else\r\n      ret = rtJsonEncUIntValue (pJsonCtxt, value);\r\n#endif\r\n      if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\r\n      break;\r\n   }\r\n   case OSRTCBOR_NEGINT: {\r\n      OSINTTYPE value;\r\n      ret = rtCborDecInt (pCborCtxt, ub, &value);\r\n      if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\r\n\r\n      /* Encode JSON */\r\n#ifndef _NO_INT64_SUPPORT\r\n      ret = rtJsonEncInt64Value (pJsonCtxt, value);\r\n#else\r\n      ret = rtJsonEncIntValue (pJsonCtxt, value);\r\n#endif\r\n      if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\r\n      break;\r\n   }\r\n   case OSRTCBOR_BYTESTR: {\r\n      OSDynOctStr64 byteStr;\r\n      ret = rtCborDecDynByteStr (pCborCtxt, ub, &byteStr);\r\n      if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\r\n\r\n      /* Encode JSON */\r\n      ret = rtJsonEncHexStr (pJsonCtxt, byteStr.numocts, byteStr.data);\r\n      rtxMemFreePtr (pCborCtxt, byteStr.data);\r\n      if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\r\n\r\n      break;\r\n   }\r\n   case OSRTCBOR_UTF8STR: {\r\n      OSUTF8CHAR* utf8str;\r\n      ret = rtCborDecDynUTF8Str (pCborCtxt, ub, (char**)&utf8str);\r\n      if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\r\n\r\n      ret = rtJsonEncStringValue (pJsonCtxt, utf8str);\r\n      rtxMemFreePtr (pCborCtxt, utf8str);\r\n      if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\r\n\r\n      break;\r\n   }\r\n   case OSRTCBOR_ARRAY: \r\n   case OSRTCBOR_MAP: {\r\n      OSOCTET len = ub & 0x1F;\r\n      char startChar = (tag == OSRTCBOR_ARRAY) ? '[' : '{';\r\n      char endChar = (tag == OSRTCBOR_ARRAY) ? ']' : '}';\r\n\r\n      OSRTSAFEPUTCHAR (pJsonCtxt, startChar);\r\n\r\n      if (len == OSRTCBOR_INDEF) {\r\n         OSBOOL first = TRUE;\r\n         for (;;) {\r\n            if (OSRTCBOR_MATCHEOC (pCborCtxt)) {\r\n               pCborCtxt->buffer.byteIndex++;\r\n               break;\r\n            }\r\n\r\n            if (!first) \r\n               OSRTSAFEPUTCHAR (pJsonCtxt, ',');\r\n            else\r\n               first = FALSE;\r\n\r\n            /* If map, decode object name */\r\n            if (tag == OSRTCBOR_MAP) {\r\n               ret = cborElemNameToJson (pCborCtxt, pJsonCtxt);\r\n            }\r\n\r\n            /* Make recursive call */\r\n            if (0 == ret)\r\n               ret = cbor2json (pCborCtxt, pJsonCtxt);\r\n            if (0 != ret) {\r\n               OSCTXT* pctxt = \r\n                  (rtxErrGetErrorCnt(pJsonCtxt) > 0) ? pJsonCtxt : pCborCtxt;\r\n               return LOG_RTERR (pctxt, ret);\r\n            }\r\n         }\r\n      }\r\n      else { /* definite length */\r\n         OSSIZE nitems;\r\n\r\n         /* Decode tag and number of items */\r\n         ret = rtCborDecSize (pCborCtxt, len, &nitems);\r\n         if (0 == ret) {\r\n            OSSIZE i;\r\n\r\n            /* Loop to decode array items */\r\n            for (i = 0; i < nitems; i++) {\r\n               if (0 != i) OSRTSAFEPUTCHAR (pJsonCtxt, ',');\r\n\r\n               /* If map, decode object name */\r\n               if (tag == OSRTCBOR_MAP) {\r\n                  ret = cborElemNameToJson (pCborCtxt, pJsonCtxt);\r\n               }\r\n\r\n               /* Make recursive call */\r\n               if (0 == ret)\r\n                  ret = cbor2json (pCborCtxt, pJsonCtxt);\r\n               if (0 != ret) {\r\n                  OSCTXT* pctxt = \r\n                  (rtxErrGetErrorCnt(pJsonCtxt) > 0) ? pJsonCtxt : pCborCtxt;\r\n                  return LOG_RTERR (pctxt, ret);\r\n               }\r\n            }\r\n         }\r\n      }\r\n      OSRTSAFEPUTCHAR (pJsonCtxt, endChar);\r\n      break;\r\n   }\r\n\r\n   case OSRTCBOR_FLOAT:\r\n      if (tag == OSRTCBOR_FALSEENC || tag == OSRTCBOR_TRUEENC) {\r\n         OSBOOL boolval = (ub == OSRTCBOR_TRUEENC) ? TRUE : FALSE;\r\n         ret = rtJsonEncBoolValue (pJsonCtxt, boolval);\r\n         if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\r\n      }\r\n      else if (tag == OSRTCBOR_FLT16ENC ||\r\n               tag == OSRTCBOR_FLT32ENC ||\r\n               tag == OSRTCBOR_FLT64ENC) {\r\n         OSDOUBLE fltval;\r\n         ret = rtCborDecFloat (pCborCtxt, ub, &fltval);\r\n         if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\r\n\r\n         /* Encode JSON */\r\n         ret = rtJsonEncDoubleValue (pJsonCtxt, fltval, 0);\r\n         if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\r\n      }\r\n      else {\r\n         ret = cborTagNotSupp (pCborCtxt, tag);\r\n      }\r\n      break;\r\n\r\n   default:\r\n      ret = cborTagNotSupp (pCborCtxt, tag);\r\n   }\r\n\r\n   return ret;\r\n}\r",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147877,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n    const Tensor& input_min_tensor = ctx->input(1);\n    const Tensor& input_max_tensor = ctx->input(2);\n\n    int num_slices = 1;\n    if (axis_ > -1) {\n      num_slices = input.dim_size(axis_);\n    }\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));\n    Tensor float_output =\n        need_cast_ ? tensorflow::Tensor(DT_FLOAT, input.shape()) : *output;\n    if (num_slices == 1) {\n      const float min_range = input_min_tensor.flat<float>()(0);\n      const float max_range = input_max_tensor.flat<float>()(0);\n      DequantizeTensor(ctx, input, min_range, max_range, &float_output);\n    } else {\n      OP_REQUIRES(ctx, mode_ != QUANTIZE_MODE_MIN_FIRST,\n                  errors::Unimplemented(\"MIN_FIRST mode is not implemented for \"\n                                        \"Dequantize with axis != -1.\"));\n\n      int64 pre_dim = 1, post_dim = 1;\n      for (int i = 0; i < axis_; ++i) {\n        pre_dim *= float_output.dim_size(i);\n      }\n      for (int i = axis_ + 1; i < float_output.dims(); ++i) {\n        post_dim *= float_output.dim_size(i);\n      }\n      auto input_tensor = input.template bit_casted_shaped<T, 3>(\n          {pre_dim, num_slices, post_dim});\n      auto output_tensor =\n          float_output.flat_inner_outer_dims<float, 3>(axis_ - 1);\n      auto min_ranges = input_min_tensor.vec<float>();\n      auto max_ranges = input_max_tensor.vec<float>();\n      for (int i = 0; i < num_slices; ++i) {\n        DequantizeSlice(ctx->eigen_device<Device>(), ctx,\n                        input_tensor.template chip<1>(i), min_ranges(i),\n                        max_ranges(i), output_tensor.template chip<1>(i));\n      }\n    }\n    if (need_cast_) {\n      S* out_ptr = output->flat<S>().data();\n      float* in_ptr = float_output.flat<float>().data();\n      for (int64 i = 0; i < float_output.NumElements(); ++i) {\n        out_ptr[i] = static_cast<S>(in_ptr[i]);\n      }\n    }\n  }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147916,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n    const Tensor& input_min_tensor = ctx->input(1);\n    const Tensor& input_max_tensor = ctx->input(2);\n\n    int num_slices = 1;\n    if (axis_ > -1) {\n      num_slices = input.dim_size(axis_);\n    }\n    OP_REQUIRES(ctx, input_min_tensor.NumElements() == num_slices,\n                errors::InvalidArgument(\n                    \"input_min_tensor must have as many elements as input on \"\n                    \"the dequantization axis (\",\n                    axis_, \"), got \", input_min_tensor.NumElements(),\n                    \", expected \", num_slices));\n    OP_REQUIRES(ctx, input_max_tensor.NumElements() == num_slices,\n                errors::InvalidArgument(\n                    \"input_max_tensor must have as many elements as input on \"\n                    \"the dequantization axis (\",\n                    axis_, \"), got \", input_max_tensor.NumElements(),\n                    \", expected \", num_slices));\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));\n    Tensor float_output =\n        need_cast_ ? tensorflow::Tensor(DT_FLOAT, input.shape()) : *output;\n    if (num_slices == 1) {\n      const float min_range = input_min_tensor.flat<float>()(0);\n      const float max_range = input_max_tensor.flat<float>()(0);\n      DequantizeTensor(ctx, input, min_range, max_range, &float_output);\n    } else {\n      OP_REQUIRES(ctx, mode_ != QUANTIZE_MODE_MIN_FIRST,\n                  errors::Unimplemented(\"MIN_FIRST mode is not implemented for \"\n                                        \"Dequantize with axis != -1.\"));\n\n      int64 pre_dim = 1, post_dim = 1;\n      for (int i = 0; i < axis_; ++i) {\n        pre_dim *= float_output.dim_size(i);\n      }\n      for (int i = axis_ + 1; i < float_output.dims(); ++i) {\n        post_dim *= float_output.dim_size(i);\n      }\n      auto input_tensor = input.template bit_casted_shaped<T, 3>(\n          {pre_dim, num_slices, post_dim});\n      auto output_tensor =\n          float_output.flat_inner_outer_dims<float, 3>(axis_ - 1);\n      auto min_ranges = input_min_tensor.vec<float>();\n      auto max_ranges = input_max_tensor.vec<float>();\n      for (int i = 0; i < num_slices; ++i) {\n        DequantizeSlice(ctx->eigen_device<Device>(), ctx,\n                        input_tensor.template chip<1>(i), min_ranges(i),\n                        max_ranges(i), output_tensor.template chip<1>(i));\n      }\n    }\n    if (need_cast_) {\n      S* out_ptr = output->flat<S>().data();\n      float* in_ptr = float_output.flat<float>().data();\n      for (int64 i = 0; i < float_output.NumElements(); ++i) {\n        out_ptr[i] = static_cast<S>(in_ptr[i]);\n      }\n    }\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147917,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int dwa_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,\n                          int uncompressed_size, EXRThreadData *td)\n{\n    int64_t version, lo_usize, lo_size;\n    int64_t ac_size, dc_size, rle_usize, rle_csize, rle_raw_size;\n    int64_t ac_count, dc_count, ac_compression;\n    const int dc_w = td->xsize >> 3;\n    const int dc_h = td->ysize >> 3;\n    GetByteContext gb, agb;\n    int skip, ret;\n\n    if (compressed_size <= 88)\n        return AVERROR_INVALIDDATA;\n\n    version = AV_RL64(src + 0);\n    if (version != 2)\n        return AVERROR_INVALIDDATA;\n\n    lo_usize = AV_RL64(src + 8);\n    lo_size = AV_RL64(src + 16);\n    ac_size = AV_RL64(src + 24);\n    dc_size = AV_RL64(src + 32);\n    rle_csize = AV_RL64(src + 40);\n    rle_usize = AV_RL64(src + 48);\n    rle_raw_size = AV_RL64(src + 56);\n    ac_count = AV_RL64(src + 64);\n    dc_count = AV_RL64(src + 72);\n    ac_compression = AV_RL64(src + 80);\n\n    if (compressed_size < 88LL + lo_size + ac_size + dc_size + rle_csize)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_init(&gb, src + 88, compressed_size - 88);\n    skip = bytestream2_get_le16(&gb);\n    if (skip < 2)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_skip(&gb, skip - 2);\n\n    if (lo_size > 0) {\n        if (lo_usize > uncompressed_size)\n            return AVERROR_INVALIDDATA;\n        bytestream2_skip(&gb, lo_size);\n    }\n\n    if (ac_size > 0) {\n        unsigned long dest_len = ac_count * 2LL;\n        GetByteContext agb = gb;\n\n        if (ac_count > 3LL * td->xsize * s->scan_lines_per_block)\n            return AVERROR_INVALIDDATA;\n\n        av_fast_padded_malloc(&td->ac_data, &td->ac_size, dest_len);\n        if (!td->ac_data)\n            return AVERROR(ENOMEM);\n\n        switch (ac_compression) {\n        case 0:\n            ret = huf_uncompress(s, td, &agb, (int16_t *)td->ac_data, ac_count);\n            if (ret < 0)\n                return ret;\n            break;\n        case 1:\n            if (uncompress(td->ac_data, &dest_len, agb.buffer, ac_size) != Z_OK ||\n                dest_len != ac_count * 2LL)\n                return AVERROR_INVALIDDATA;\n            break;\n        default:\n            return AVERROR_INVALIDDATA;\n        }\n\n        bytestream2_skip(&gb, ac_size);\n    }\n\n    if (dc_size > 0) {\n        unsigned long dest_len = dc_count * 2LL;\n        GetByteContext agb = gb;\n\n        if (dc_count > (6LL * td->xsize * td->ysize + 63) / 64)\n            return AVERROR_INVALIDDATA;\n\n        av_fast_padded_malloc(&td->dc_data, &td->dc_size, FFALIGN(dest_len, 64) * 2);\n        if (!td->dc_data)\n            return AVERROR(ENOMEM);\n\n        if (uncompress(td->dc_data + FFALIGN(dest_len, 64), &dest_len, agb.buffer, dc_size) != Z_OK ||\n            (dest_len != dc_count * 2LL))\n            return AVERROR_INVALIDDATA;\n\n        s->dsp.predictor(td->dc_data + FFALIGN(dest_len, 64), dest_len);\n        s->dsp.reorder_pixels(td->dc_data, td->dc_data + FFALIGN(dest_len, 64), dest_len);\n\n        bytestream2_skip(&gb, dc_size);\n    }\n\n    if (rle_raw_size > 0 && rle_csize > 0 && rle_usize > 0) {\n        unsigned long dest_len = rle_usize;\n\n        av_fast_padded_malloc(&td->rle_data, &td->rle_size, rle_usize);\n        if (!td->rle_data)\n            return AVERROR(ENOMEM);\n\n        av_fast_padded_malloc(&td->rle_raw_data, &td->rle_raw_size, rle_raw_size);\n        if (!td->rle_raw_data)\n            return AVERROR(ENOMEM);\n\n        if (uncompress(td->rle_data, &dest_len, gb.buffer, rle_csize) != Z_OK ||\n            (dest_len != rle_usize))\n            return AVERROR_INVALIDDATA;\n\n        ret = rle(td->rle_raw_data, td->rle_data, rle_usize, rle_raw_size);\n        if (ret < 0)\n            return ret;\n        bytestream2_skip(&gb, rle_csize);\n    }\n\n    bytestream2_init(&agb, td->ac_data, ac_count * 2);\n\n    for (int y = 0; y < td->ysize; y += 8) {\n        for (int x = 0; x < td->xsize; x += 8) {\n            memset(td->block, 0, sizeof(td->block));\n\n            for (int j = 0; j < 3; j++) {\n                float *block = td->block[j];\n                const int idx = (x >> 3) + (y >> 3) * dc_w + dc_w * dc_h * j;\n                uint16_t *dc = (uint16_t *)td->dc_data;\n                union av_intfloat32 dc_val;\n\n                dc_val.i = half2float(dc[idx], s->mantissatable,\n                                      s->exponenttable, s->offsettable);\n\n                block[0] = dc_val.f;\n                ac_uncompress(s, &agb, block);\n                dct_inverse(block);\n            }\n\n            {\n                const float scale = s->pixel_type == EXR_FLOAT ? 2.f : 1.f;\n                const int o = s->nb_channels == 4;\n                float *bo = ((float *)td->uncompressed_data) +\n                    y * td->xsize * s->nb_channels + td->xsize * (o + 0) + x;\n                float *go = ((float *)td->uncompressed_data) +\n                    y * td->xsize * s->nb_channels + td->xsize * (o + 1) + x;\n                float *ro = ((float *)td->uncompressed_data) +\n                    y * td->xsize * s->nb_channels + td->xsize * (o + 2) + x;\n                float *yb = td->block[0];\n                float *ub = td->block[1];\n                float *vb = td->block[2];\n\n                for (int yy = 0; yy < 8; yy++) {\n                    for (int xx = 0; xx < 8; xx++) {\n                        const int idx = xx + yy * 8;\n\n                        convert(yb[idx], ub[idx], vb[idx], &bo[xx], &go[xx], &ro[xx]);\n\n                        bo[xx] = to_linear(bo[xx], scale);\n                        go[xx] = to_linear(go[xx], scale);\n                        ro[xx] = to_linear(ro[xx], scale);\n                    }\n\n                    bo += td->xsize * s->nb_channels;\n                    go += td->xsize * s->nb_channels;\n                    ro += td->xsize * s->nb_channels;\n                }\n            }\n        }\n    }\n\n    if (s->nb_channels < 4)\n        return 0;\n\n    for (int y = 0; y < td->ysize && td->rle_raw_data; y++) {\n        uint32_t *ao = ((uint32_t *)td->uncompressed_data) + y * td->xsize * s->nb_channels;\n        uint8_t *ai0 = td->rle_raw_data + y * td->xsize;\n        uint8_t *ai1 = td->rle_raw_data + y * td->xsize + rle_raw_size / 2;\n\n        for (int x = 0; x < td->xsize; x++) {\n            uint16_t ha = ai0[x] | (ai1[x] << 8);\n\n            ao[x] = half2float(ha, s->mantissatable, s->exponenttable, s->offsettable);\n        }\n    }\n\n    return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148060,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int dwa_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,\n                          int uncompressed_size, EXRThreadData *td)\n{\n    int64_t version, lo_usize, lo_size;\n    int64_t ac_size, dc_size, rle_usize, rle_csize, rle_raw_size;\n    int64_t ac_count, dc_count, ac_compression;\n    const int dc_w = td->xsize >> 3;\n    const int dc_h = td->ysize >> 3;\n    GetByteContext gb, agb;\n    int skip, ret;\n\n    if (compressed_size <= 88)\n        return AVERROR_INVALIDDATA;\n\n    version = AV_RL64(src + 0);\n    if (version != 2)\n        return AVERROR_INVALIDDATA;\n\n    lo_usize = AV_RL64(src + 8);\n    lo_size = AV_RL64(src + 16);\n    ac_size = AV_RL64(src + 24);\n    dc_size = AV_RL64(src + 32);\n    rle_csize = AV_RL64(src + 40);\n    rle_usize = AV_RL64(src + 48);\n    rle_raw_size = AV_RL64(src + 56);\n    ac_count = AV_RL64(src + 64);\n    dc_count = AV_RL64(src + 72);\n    ac_compression = AV_RL64(src + 80);\n\n    if (compressed_size < 88LL + lo_size + ac_size + dc_size + rle_csize)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_init(&gb, src + 88, compressed_size - 88);\n    skip = bytestream2_get_le16(&gb);\n    if (skip < 2)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_skip(&gb, skip - 2);\n\n    if (lo_size > 0) {\n        if (lo_usize > uncompressed_size)\n            return AVERROR_INVALIDDATA;\n        bytestream2_skip(&gb, lo_size);\n    }\n\n    if (ac_size > 0) {\n        unsigned long dest_len = ac_count * 2LL;\n        GetByteContext agb = gb;\n\n        if (ac_count > 3LL * td->xsize * s->scan_lines_per_block)\n            return AVERROR_INVALIDDATA;\n\n        av_fast_padded_malloc(&td->ac_data, &td->ac_size, dest_len);\n        if (!td->ac_data)\n            return AVERROR(ENOMEM);\n\n        switch (ac_compression) {\n        case 0:\n            ret = huf_uncompress(s, td, &agb, (int16_t *)td->ac_data, ac_count);\n            if (ret < 0)\n                return ret;\n            break;\n        case 1:\n            if (uncompress(td->ac_data, &dest_len, agb.buffer, ac_size) != Z_OK ||\n                dest_len != ac_count * 2LL)\n                return AVERROR_INVALIDDATA;\n            break;\n        default:\n            return AVERROR_INVALIDDATA;\n        }\n\n        bytestream2_skip(&gb, ac_size);\n    }\n\n    {\n        unsigned long dest_len = dc_count * 2LL;\n        GetByteContext agb = gb;\n\n        if (dc_count != dc_w * dc_h * 3)\n            return AVERROR_INVALIDDATA;\n\n        av_fast_padded_malloc(&td->dc_data, &td->dc_size, FFALIGN(dest_len, 64) * 2);\n        if (!td->dc_data)\n            return AVERROR(ENOMEM);\n\n        if (uncompress(td->dc_data + FFALIGN(dest_len, 64), &dest_len, agb.buffer, dc_size) != Z_OK ||\n            (dest_len != dc_count * 2LL))\n            return AVERROR_INVALIDDATA;\n\n        s->dsp.predictor(td->dc_data + FFALIGN(dest_len, 64), dest_len);\n        s->dsp.reorder_pixels(td->dc_data, td->dc_data + FFALIGN(dest_len, 64), dest_len);\n\n        bytestream2_skip(&gb, dc_size);\n    }\n\n    if (rle_raw_size > 0 && rle_csize > 0 && rle_usize > 0) {\n        unsigned long dest_len = rle_usize;\n\n        av_fast_padded_malloc(&td->rle_data, &td->rle_size, rle_usize);\n        if (!td->rle_data)\n            return AVERROR(ENOMEM);\n\n        av_fast_padded_malloc(&td->rle_raw_data, &td->rle_raw_size, rle_raw_size);\n        if (!td->rle_raw_data)\n            return AVERROR(ENOMEM);\n\n        if (uncompress(td->rle_data, &dest_len, gb.buffer, rle_csize) != Z_OK ||\n            (dest_len != rle_usize))\n            return AVERROR_INVALIDDATA;\n\n        ret = rle(td->rle_raw_data, td->rle_data, rle_usize, rle_raw_size);\n        if (ret < 0)\n            return ret;\n        bytestream2_skip(&gb, rle_csize);\n    }\n\n    bytestream2_init(&agb, td->ac_data, ac_count * 2);\n\n    for (int y = 0; y < td->ysize; y += 8) {\n        for (int x = 0; x < td->xsize; x += 8) {\n            memset(td->block, 0, sizeof(td->block));\n\n            for (int j = 0; j < 3; j++) {\n                float *block = td->block[j];\n                const int idx = (x >> 3) + (y >> 3) * dc_w + dc_w * dc_h * j;\n                uint16_t *dc = (uint16_t *)td->dc_data;\n                union av_intfloat32 dc_val;\n\n                dc_val.i = half2float(dc[idx], s->mantissatable,\n                                      s->exponenttable, s->offsettable);\n\n                block[0] = dc_val.f;\n                ac_uncompress(s, &agb, block);\n                dct_inverse(block);\n            }\n\n            {\n                const float scale = s->pixel_type == EXR_FLOAT ? 2.f : 1.f;\n                const int o = s->nb_channels == 4;\n                float *bo = ((float *)td->uncompressed_data) +\n                    y * td->xsize * s->nb_channels + td->xsize * (o + 0) + x;\n                float *go = ((float *)td->uncompressed_data) +\n                    y * td->xsize * s->nb_channels + td->xsize * (o + 1) + x;\n                float *ro = ((float *)td->uncompressed_data) +\n                    y * td->xsize * s->nb_channels + td->xsize * (o + 2) + x;\n                float *yb = td->block[0];\n                float *ub = td->block[1];\n                float *vb = td->block[2];\n\n                for (int yy = 0; yy < 8; yy++) {\n                    for (int xx = 0; xx < 8; xx++) {\n                        const int idx = xx + yy * 8;\n\n                        convert(yb[idx], ub[idx], vb[idx], &bo[xx], &go[xx], &ro[xx]);\n\n                        bo[xx] = to_linear(bo[xx], scale);\n                        go[xx] = to_linear(go[xx], scale);\n                        ro[xx] = to_linear(ro[xx], scale);\n                    }\n\n                    bo += td->xsize * s->nb_channels;\n                    go += td->xsize * s->nb_channels;\n                    ro += td->xsize * s->nb_channels;\n                }\n            }\n        }\n    }\n\n    if (s->nb_channels < 4)\n        return 0;\n\n    for (int y = 0; y < td->ysize && td->rle_raw_data; y++) {\n        uint32_t *ao = ((uint32_t *)td->uncompressed_data) + y * td->xsize * s->nb_channels;\n        uint8_t *ai0 = td->rle_raw_data + y * td->xsize;\n        uint8_t *ai1 = td->rle_raw_data + y * td->xsize + rle_raw_size / 2;\n\n        for (int x = 0; x < td->xsize; x++) {\n            uint16_t ha = ai0[x] | (ai1[x] << 8);\n\n            ao[x] = half2float(ha, s->mantissatable, s->exponenttable, s->offsettable);\n        }\n    }\n\n    return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148061,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int cmd_handle_untagged (IMAP_DATA* idata)\n{\n  char* s;\n  char* pn;\n  unsigned int count;\n\n  s = imap_next_word (idata->buf);\n  pn = imap_next_word (s);\n\n  if ((idata->state >= IMAP_SELECTED) && isdigit ((unsigned char) *s))\n  {\n    pn = s;\n    s = imap_next_word (s);\n\n    /* EXISTS and EXPUNGE are always related to the SELECTED mailbox for the\n     * connection, so update that one.\n     */\n    if (ascii_strncasecmp (\"EXISTS\", s, 6) == 0)\n    {\n      dprint (2, (debugfile, \"Handling EXISTS\\n\"));\n\n      /* new mail arrived */\n      mutt_atoui (pn, &count);\n\n      if ( !(idata->reopen & IMAP_EXPUNGE_PENDING) &&\n\t   count < idata->max_msn)\n      {\n        /* Notes 6.0.3 has a tendency to report fewer messages exist than\n         * it should. */\n\tdprint (1, (debugfile, \"Message count is out of sync\"));\n\treturn 0;\n      }\n      /* at least the InterChange server sends EXISTS messages freely,\n       * even when there is no new mail */\n      else if (count == idata->max_msn)\n\tdprint (3, (debugfile,\n          \"cmd_handle_untagged: superfluous EXISTS message.\\n\"));\n      else\n      {\n\tif (!(idata->reopen & IMAP_EXPUNGE_PENDING))\n        {\n          dprint (2, (debugfile,\n            \"cmd_handle_untagged: New mail in %s - %d messages total.\\n\",\n            idata->mailbox, count));\n\t  idata->reopen |= IMAP_NEWMAIL_PENDING;\n        }\n\tidata->newMailCount = count;\n      }\n    }\n    /* pn vs. s: need initial seqno */\n    else if (ascii_strncasecmp (\"EXPUNGE\", s, 7) == 0)\n      cmd_parse_expunge (idata, pn);\n    else if (ascii_strncasecmp (\"FETCH\", s, 5) == 0)\n      cmd_parse_fetch (idata, pn);\n  }\n  else if (ascii_strncasecmp (\"CAPABILITY\", s, 10) == 0)\n    cmd_parse_capability (idata, s);\n  else if (!ascii_strncasecmp (\"OK [CAPABILITY\", s, 14))\n    cmd_parse_capability (idata, pn);\n  else if (!ascii_strncasecmp (\"OK [CAPABILITY\", pn, 14))\n    cmd_parse_capability (idata, imap_next_word (pn));\n  else if (ascii_strncasecmp (\"LIST\", s, 4) == 0)\n    cmd_parse_list (idata, s);\n  else if (ascii_strncasecmp (\"LSUB\", s, 4) == 0)\n    cmd_parse_lsub (idata, s);\n  else if (ascii_strncasecmp (\"MYRIGHTS\", s, 8) == 0)\n    cmd_parse_myrights (idata, s);\n  else if (ascii_strncasecmp (\"SEARCH\", s, 6) == 0)\n    cmd_parse_search (idata, s);\n  else if (ascii_strncasecmp (\"STATUS\", s, 6) == 0)\n    cmd_parse_status (idata, s);\n  else if (ascii_strncasecmp (\"ENABLED\", s, 7) == 0)\n    cmd_parse_enabled (idata, s);\n  else if (ascii_strncasecmp (\"BYE\", s, 3) == 0)\n  {\n    dprint (2, (debugfile, \"Handling BYE\\n\"));\n\n    /* check if we're logging out */\n    if (idata->status == IMAP_BYE)\n      return 0;\n\n    /* server shut down our connection */\n    s += 3;\n    SKIPWS (s);\n    mutt_error (\"%s\", s);\n    mutt_sleep (2);\n    cmd_handle_fatal (idata);\n\n    return -1;\n  }\n  else if (option (OPTIMAPSERVERNOISE) && (ascii_strncasecmp (\"NO\", s, 2) == 0))\n  {\n    dprint (2, (debugfile, \"Handling untagged NO\\n\"));\n\n    /* Display the warning message from the server */\n    mutt_error (\"%s\", s+3);\n    mutt_sleep (2);\n  }\n\n  return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148272,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static int cmd_handle_untagged (IMAP_DATA* idata)\n{\n  char* s;\n  char* pn;\n  unsigned int count;\n\n  s = imap_next_word (idata->buf);\n  pn = imap_next_word (s);\n\n  if ((idata->state >= IMAP_SELECTED) && isdigit ((unsigned char) *s))\n  {\n    pn = s;\n    s = imap_next_word (s);\n\n    /* EXISTS and EXPUNGE are always related to the SELECTED mailbox for the\n     * connection, so update that one.\n     */\n    if (ascii_strncasecmp (\"EXISTS\", s, 6) == 0)\n    {\n      dprint (2, (debugfile, \"Handling EXISTS\\n\"));\n\n      /* new mail arrived */\n      mutt_atoui (pn, &count);\n\n      if ( !(idata->reopen & IMAP_EXPUNGE_PENDING) &&\n\t   count < idata->max_msn)\n      {\n        /* Notes 6.0.3 has a tendency to report fewer messages exist than\n         * it should. */\n\tdprint (1, (debugfile, \"Message count is out of sync\"));\n\treturn 0;\n      }\n      /* at least the InterChange server sends EXISTS messages freely,\n       * even when there is no new mail */\n      else if (count == idata->max_msn)\n\tdprint (3, (debugfile,\n          \"cmd_handle_untagged: superfluous EXISTS message.\\n\"));\n      else\n      {\n\tif (!(idata->reopen & IMAP_EXPUNGE_PENDING))\n        {\n          dprint (2, (debugfile,\n            \"cmd_handle_untagged: New mail in %s - %d messages total.\\n\",\n            idata->mailbox, count));\n\t  idata->reopen |= IMAP_NEWMAIL_PENDING;\n        }\n\tidata->newMailCount = count;\n      }\n    }\n    /* pn vs. s: need initial seqno */\n    else if (ascii_strncasecmp (\"EXPUNGE\", s, 7) == 0)\n      cmd_parse_expunge (idata, pn);\n    else if (ascii_strncasecmp (\"FETCH\", s, 5) == 0)\n      cmd_parse_fetch (idata, pn);\n  }\n  else if (ascii_strncasecmp (\"CAPABILITY\", s, 10) == 0)\n    cmd_parse_capability (idata, s);\n  else if (!ascii_strncasecmp (\"OK [CAPABILITY\", s, 14))\n    cmd_parse_capability (idata, pn);\n  else if (!ascii_strncasecmp (\"OK [CAPABILITY\", pn, 14))\n    cmd_parse_capability (idata, imap_next_word (pn));\n  else if (ascii_strncasecmp (\"LIST\", s, 4) == 0)\n    cmd_parse_list (idata, s);\n  else if (ascii_strncasecmp (\"LSUB\", s, 4) == 0)\n    cmd_parse_lsub (idata, s);\n  else if (ascii_strncasecmp (\"MYRIGHTS\", s, 8) == 0)\n    cmd_parse_myrights (idata, s);\n  else if (ascii_strncasecmp (\"SEARCH\", s, 6) == 0)\n    cmd_parse_search (idata, s);\n  else if (ascii_strncasecmp (\"STATUS\", s, 6) == 0)\n    cmd_parse_status (idata, s);\n  else if (ascii_strncasecmp (\"ENABLED\", s, 7) == 0)\n    cmd_parse_enabled (idata, s);\n  else if (ascii_strncasecmp (\"BYE\", s, 3) == 0)\n  {\n    dprint (2, (debugfile, \"Handling BYE\\n\"));\n\n    /* check if we're logging out */\n    if (idata->status == IMAP_BYE)\n      return 0;\n\n    /* server shut down our connection */\n    s += 3;\n    SKIPWS (s);\n    mutt_error (\"%s\", s);\n    mutt_sleep (2);\n    cmd_handle_fatal (idata);\n\n    return -1;\n  }\n  else if (option (OPTIMAPSERVERNOISE) && (ascii_strncasecmp (\"NO\", s, 2) == 0))\n  {\n    dprint (2, (debugfile, \"Handling untagged NO\\n\"));\n\n    /* Display the warning message from the server */\n    mutt_error (\"%s\", s+2);\n    mutt_sleep (2);\n  }\n\n  return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148273,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k,\n                                  opj_tcd_t * p_tile_coder,\n                                  OPJ_BYTE * p_data,\n                                  OPJ_UINT32 * p_data_written,\n                                  OPJ_UINT32 total_data_size,\n                                  const opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    opj_codestream_info_t *l_cstr_info = 00;\n    OPJ_UINT32 l_remaining_data;\n    opj_tcd_marker_info_t* marker_info = NULL;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    OPJ_UNUSED(p_stream);\n\n    if (total_data_size < 4) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough bytes in output buffer to write SOD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_write_bytes(p_data, J2K_MS_SOD,\n                    2);                                 /* SOD */\n\n    /* make room for the EOF marker */\n    l_remaining_data =  total_data_size - 4;\n\n    /* update tile coder */\n    p_tile_coder->tp_num =\n        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number ;\n    p_tile_coder->cur_tp_num =\n        p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;\n\n    /* INDEX >> */\n    /* TODO mergeV2: check this part which use cstr_info */\n    /*l_cstr_info = p_j2k->cstr_info;\n    if (l_cstr_info) {\n            if (!p_j2k->m_specific_param.m_encoder.m_current_tile_part_number ) {\n                    //TODO cstr_info->tile[p_j2k->m_current_tile_number].end_header = p_stream_tell(p_stream) + p_j2k->pos_correction - 1;\n                    l_cstr_info->tile[p_j2k->m_current_tile_number].tileno = p_j2k->m_current_tile_number;\n            }\n            else {*/\n    /*\n    TODO\n    if\n            (cstr_info->tile[p_j2k->m_current_tile_number].packet[cstr_info->packno - 1].end_pos < p_stream_tell(p_stream))\n    {\n            cstr_info->tile[p_j2k->m_current_tile_number].packet[cstr_info->packno].start_pos = p_stream_tell(p_stream);\n    }*/\n    /*}*/\n    /* UniPG>> */\n#ifdef USE_JPWL\n    /* update markers struct */\n    /*OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_SOD, p_j2k->sod_start, 2);\n    */\n    assert(0 && \"TODO\");\n#endif /* USE_JPWL */\n    /* <<UniPG */\n    /*}*/\n    /* << INDEX */\n\n    if (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number == 0) {\n        p_tile_coder->tcd_image->tiles->packno = 0;\n#ifdef deadcode\n        if (l_cstr_info) {\n            l_cstr_info->packno = 0;\n        }\n#endif\n    }\n\n    *p_data_written = 0;\n\n    if (p_j2k->m_specific_param.m_encoder.m_PLT) {\n        marker_info = opj_tcd_marker_info_create(\n                          p_j2k->m_specific_param.m_encoder.m_PLT);\n        if (marker_info == NULL) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Cannot encode tile: opj_tcd_marker_info_create() failed\\n\");\n            return OPJ_FALSE;\n        }\n    }\n\n    assert(l_remaining_data >\n           p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT);\n    l_remaining_data -= p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT;\n\n    if (! opj_tcd_encode_tile(p_tile_coder, p_j2k->m_current_tile_number,\n                              p_data + 2,\n                              p_data_written, l_remaining_data, l_cstr_info,\n                              marker_info,\n                              p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Cannot encode tile\\n\");\n        opj_tcd_marker_info_destroy(marker_info);\n        return OPJ_FALSE;\n    }\n\n    /* For SOD */\n    *p_data_written += 2;\n\n    if (p_j2k->m_specific_param.m_encoder.m_PLT) {\n        OPJ_UINT32 l_data_written_PLT = 0;\n        OPJ_BYTE* p_PLT_buffer = (OPJ_BYTE*)opj_malloc(\n                                     p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT);\n        if (!p_PLT_buffer) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Cannot allocate memory\\n\");\n            opj_tcd_marker_info_destroy(marker_info);\n            return OPJ_FALSE;\n        }\n        if (!opj_j2k_write_plt_in_memory(p_j2k,\n                                         marker_info,\n                                         p_PLT_buffer,\n                                         &l_data_written_PLT,\n                                         p_manager)) {\n            opj_tcd_marker_info_destroy(marker_info);\n            opj_free(p_PLT_buffer);\n            return OPJ_FALSE;\n        }\n\n        assert(l_data_written_PLT <=\n               p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT);\n\n        /* Move PLT marker(s) before SOD */\n        memmove(p_data + l_data_written_PLT, p_data, *p_data_written);\n        memcpy(p_data, p_PLT_buffer, l_data_written_PLT);\n        opj_free(p_PLT_buffer);\n        *p_data_written += l_data_written_PLT;\n    }\n\n    opj_tcd_marker_info_destroy(marker_info);\n\n    return OPJ_TRUE;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148304,
    "human": "Correct. With CWE-20",
    "reason": "It is vulnerable if compiled with NDEBUG (disabling asserts) or if an attacker can trick the code into insufficient buffer space, leading to potential out-of-bounds writes.",
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k,\n                                  opj_tcd_t * p_tile_coder,\n                                  OPJ_BYTE * p_data,\n                                  OPJ_UINT32 * p_data_written,\n                                  OPJ_UINT32 total_data_size,\n                                  const opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    opj_codestream_info_t *l_cstr_info = 00;\n    OPJ_UINT32 l_remaining_data;\n    opj_tcd_marker_info_t* marker_info = NULL;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    OPJ_UNUSED(p_stream);\n\n    if (total_data_size < 4) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough bytes in output buffer to write SOD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_write_bytes(p_data, J2K_MS_SOD,\n                    2);                                 /* SOD */\n\n    /* make room for the EOF marker */\n    l_remaining_data =  total_data_size - 4;\n\n    /* update tile coder */\n    p_tile_coder->tp_num =\n        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number ;\n    p_tile_coder->cur_tp_num =\n        p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;\n\n    /* INDEX >> */\n    /* TODO mergeV2: check this part which use cstr_info */\n    /*l_cstr_info = p_j2k->cstr_info;\n    if (l_cstr_info) {\n            if (!p_j2k->m_specific_param.m_encoder.m_current_tile_part_number ) {\n                    //TODO cstr_info->tile[p_j2k->m_current_tile_number].end_header = p_stream_tell(p_stream) + p_j2k->pos_correction - 1;\n                    l_cstr_info->tile[p_j2k->m_current_tile_number].tileno = p_j2k->m_current_tile_number;\n            }\n            else {*/\n    /*\n    TODO\n    if\n            (cstr_info->tile[p_j2k->m_current_tile_number].packet[cstr_info->packno - 1].end_pos < p_stream_tell(p_stream))\n    {\n            cstr_info->tile[p_j2k->m_current_tile_number].packet[cstr_info->packno].start_pos = p_stream_tell(p_stream);\n    }*/\n    /*}*/\n    /* UniPG>> */\n#ifdef USE_JPWL\n    /* update markers struct */\n    /*OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_SOD, p_j2k->sod_start, 2);\n    */\n    assert(0 && \"TODO\");\n#endif /* USE_JPWL */\n    /* <<UniPG */\n    /*}*/\n    /* << INDEX */\n\n    if (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number == 0) {\n        p_tile_coder->tcd_image->tiles->packno = 0;\n#ifdef deadcode\n        if (l_cstr_info) {\n            l_cstr_info->packno = 0;\n        }\n#endif\n    }\n\n    *p_data_written = 0;\n\n    if (p_j2k->m_specific_param.m_encoder.m_PLT) {\n        marker_info = opj_tcd_marker_info_create(\n                          p_j2k->m_specific_param.m_encoder.m_PLT);\n        if (marker_info == NULL) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Cannot encode tile: opj_tcd_marker_info_create() failed\\n\");\n            return OPJ_FALSE;\n        }\n    }\n\n    if (l_remaining_data <\n            p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough bytes in output buffer to write SOD marker\\n\");\n        opj_tcd_marker_info_destroy(marker_info);\n        return OPJ_FALSE;\n    }\n    l_remaining_data -= p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT;\n\n    if (! opj_tcd_encode_tile(p_tile_coder, p_j2k->m_current_tile_number,\n                              p_data + 2,\n                              p_data_written, l_remaining_data, l_cstr_info,\n                              marker_info,\n                              p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Cannot encode tile\\n\");\n        opj_tcd_marker_info_destroy(marker_info);\n        return OPJ_FALSE;\n    }\n\n    /* For SOD */\n    *p_data_written += 2;\n\n    if (p_j2k->m_specific_param.m_encoder.m_PLT) {\n        OPJ_UINT32 l_data_written_PLT = 0;\n        OPJ_BYTE* p_PLT_buffer = (OPJ_BYTE*)opj_malloc(\n                                     p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT);\n        if (!p_PLT_buffer) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Cannot allocate memory\\n\");\n            opj_tcd_marker_info_destroy(marker_info);\n            return OPJ_FALSE;\n        }\n        if (!opj_j2k_write_plt_in_memory(p_j2k,\n                                         marker_info,\n                                         p_PLT_buffer,\n                                         &l_data_written_PLT,\n                                         p_manager)) {\n            opj_tcd_marker_info_destroy(marker_info);\n            opj_free(p_PLT_buffer);\n            return OPJ_FALSE;\n        }\n\n        assert(l_data_written_PLT <=\n               p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT);\n\n        /* Move PLT marker(s) before SOD */\n        memmove(p_data + l_data_written_PLT, p_data, *p_data_written);\n        memcpy(p_data, p_PLT_buffer, l_data_written_PLT);\n        opj_free(p_PLT_buffer);\n        *p_data_written += l_data_written_PLT;\n    }\n\n    opj_tcd_marker_info_destroy(marker_info);\n\n    return OPJ_TRUE;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148305,
    "human": "Correct. Without CWE-20",
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "CairoFont *CairoFont::create(GfxFont *gfxFont, XRef *xref, FT_Library lib, GBool useCIDs) {\n  Ref embRef;\n  Object refObj, strObj;\n  GooString *tmpFileName, *fileName,*tmpFileName2;\n  DisplayFontParam *dfp;\n  FILE *tmpFile;\n  int c, i, n;\n  GfxFontType fontType;\n  char **enc;\n  char *name;\n  FoFiTrueType *ff;\n  FoFiType1C *ff1c;\n  Ref ref;\n  static cairo_user_data_key_t cairo_font_face_key;\n  cairo_font_face_t *cairo_font_face;\n  FT_Face face;\n\n  Gushort *codeToGID;\n  int codeToGIDLen;\n  \n  dfp = NULL;\n  codeToGID = NULL;\n  codeToGIDLen = 0;\n  cairo_font_face = NULL;\n  \n  ref = *gfxFont->getID();\n  fontType = gfxFont->getType();\n\n  tmpFileName = NULL;\n\n  if (gfxFont->getEmbeddedFontID(&embRef)) {\n    if (!openTempFile(&tmpFileName, &tmpFile, \"wb\", NULL)) {\n      error(-1, \"Couldn't create temporary font file\");\n      goto err2;\n    }\n    \n    refObj.initRef(embRef.num, embRef.gen);\n    refObj.fetch(xref, &strObj);\n    refObj.free();\n    strObj.streamReset();\n    while ((c = strObj.streamGetChar()) != EOF) {\n      fputc(c, tmpFile);\n    }\n    strObj.streamClose();\n    strObj.free();\n    fclose(tmpFile);\n    fileName = tmpFileName;\n    \n  } else if (!(fileName = gfxFont->getExtFontFile())) {\n    // look for a display font mapping or a substitute font\n    dfp = NULL;\n    if (gfxFont->getName()) {\n      dfp = globalParams->getDisplayFont(gfxFont);\n    }\n    if (!dfp) {\n      error(-1, \"Couldn't find a font for '%s'\",\n\t    gfxFont->getName() ? gfxFont->getName()->getCString()\n\t    : \"(unnamed)\");\n      goto err2;\n    }\n    switch (dfp->kind) {\n    case displayFontT1:\n      fileName = dfp->t1.fileName;\n      fontType = gfxFont->isCIDFont() ? fontCIDType0 : fontType1;\n      break;\n    case displayFontTT:\n      fileName = dfp->tt.fileName;\n      fontType = gfxFont->isCIDFont() ? fontCIDType2 : fontTrueType;\n      break;\n    }\n  }\n\n  switch (fontType) {\n  case fontType1:\n  case fontType1C:\n    if (FT_New_Face(lib, fileName->getCString(), 0, &face)) {\n      error(-1, \"could not create type1 face\");\n      goto err2;\n    }\n    \n    enc = ((Gfx8BitFont *)gfxFont)->getEncoding();\n    \n    codeToGID = (Gushort *)gmallocn(256, sizeof(int));\n    codeToGIDLen = 256;\n    for (i = 0; i < 256; ++i) {\n      codeToGID[i] = 0;\n      if ((name = enc[i])) {\n\tcodeToGID[i] = (Gushort)FT_Get_Name_Index(face, name);\n      }\n    }\n    break;\n    \n  case fontCIDType2:\n    codeToGID = NULL;\n    n = 0;\n    if (((GfxCIDFont *)gfxFont)->getCIDToGID()) {\n      n = ((GfxCIDFont *)gfxFont)->getCIDToGIDLen();\n      if (n) {\n\tcodeToGID = (Gushort *)gmallocn(n, sizeof(Gushort));\n\tmemcpy(codeToGID, ((GfxCIDFont *)gfxFont)->getCIDToGID(),\n\t\tn * sizeof(Gushort));\n      }\n    } else {\n      ff = FoFiTrueType::load(fileName->getCString());\n      if (! ff)\n\tgoto err2;\n      codeToGID = ((GfxCIDFont *)gfxFont)->getCodeToGIDMap(ff, &n);\n      delete ff;\n    }\n    codeToGIDLen = n;\n    /* Fall through */\n  case fontTrueType:\n    if (!(ff = FoFiTrueType::load(fileName->getCString()))) {\n      error(-1, \"failed to load truetype font\\n\");\n      goto err2;\n    }\n    /* This might be set already for the CIDType2 case */\n    if (fontType == fontTrueType) {\n      codeToGID = ((Gfx8BitFont *)gfxFont)->getCodeToGIDMap(ff);\n      codeToGIDLen = 256;\n    }\n    if (!openTempFile(&tmpFileName2, &tmpFile, \"wb\", NULL)) {\n      delete ff;\n      error(-1, \"failed to open truetype tempfile\\n\");\n      goto err2;\n    }\n    ff->writeTTF(&fileWrite, tmpFile);\n    fclose(tmpFile);\n    delete ff;\n\n    if (FT_New_Face(lib, tmpFileName2->getCString(), 0, &face)) {\n      error(-1, \"could not create truetype face\\n\");\n      goto err2;\n    }\n    unlink (tmpFileName2->getCString());\n    delete tmpFileName2;\n    break;\n    \n  case fontCIDType0:\n  case fontCIDType0C:\n\n    codeToGID = NULL;\n    codeToGIDLen = 0;\n\n    if (!useCIDs)\n    {\n      if ((ff1c = FoFiType1C::load(fileName->getCString()))) {\n        codeToGID = ff1c->getCIDToGIDMap(&codeToGIDLen);\n        delete ff1c;\n      }\n    }\n\n    if (FT_New_Face(lib, fileName->getCString(), 0, &face)) {\n      gfree(codeToGID);\n      codeToGID = NULL;\n      error(-1, \"could not create cid face\\n\");\n      goto err2;\n    }\n    break;\n    \n  default:\n    printf (\"font type not handled\\n\");\n    goto err2;\n    break;\n  }\n\n  // delete the (temporary) font file -- with Unix hard link\n  // semantics, this will remove the last link; otherwise it will\n  // return an error, leaving the file to be deleted later\n  if (fileName == tmpFileName) {\n    unlink (fileName->getCString());\n    delete tmpFileName;\n  }\n\n  cairo_font_face = cairo_ft_font_face_create_for_ft_face (face,\n\t\t\t\t\t\t\t   FT_LOAD_NO_HINTING |\n\t\t\t\t\t\t\t   FT_LOAD_NO_BITMAP);\n  if (cairo_font_face == NULL) {\n    error(-1, \"could not create cairo font\\n\");\n    goto err2; /* this doesn't do anything, but it looks like we're\n\t\t* handling the error */\n  } {\n  CairoFont *ret = new CairoFont(ref, cairo_font_face, face, codeToGID, codeToGIDLen);\n  cairo_font_face_set_user_data (cairo_font_face, \n\t\t\t\t &cairo_font_face_key,\n\t\t\t\t ret,\n\t\t\t\t cairo_font_face_destroy);\n\n  return ret;\n  }\n err2:\n  /* hmm? */\n  printf (\"some font thing failed\\n\");\n  return NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148536,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "CairoFont *CairoFont::create(GfxFont *gfxFont, XRef *xref, FT_Library lib, GBool useCIDs) {\n  Ref embRef;\n  Object refObj, strObj;\n  GooString *tmpFileName, *fileName,*tmpFileName2;\n  DisplayFontParam *dfp;\n  FILE *tmpFile;\n  int c, i, n;\n  GfxFontType fontType;\n  char **enc;\n  char *name;\n  FoFiTrueType *ff;\n  FoFiType1C *ff1c;\n  Ref ref;\n  static cairo_user_data_key_t cairo_font_face_key;\n  cairo_font_face_t *cairo_font_face;\n  FT_Face face;\n\n  Gushort *codeToGID;\n  int codeToGIDLen;\n  \n  dfp = NULL;\n  codeToGID = NULL;\n  codeToGIDLen = 0;\n  cairo_font_face = NULL;\n  \n  ref = *gfxFont->getID();\n  fontType = gfxFont->getType();\n\n  tmpFileName = NULL;\n\n  if (gfxFont->getEmbeddedFontID(&embRef)) {\n    if (!openTempFile(&tmpFileName, &tmpFile, \"wb\", NULL)) {\n      error(-1, \"Couldn't create temporary font file\");\n      goto err2;\n    }\n    \n    refObj.initRef(embRef.num, embRef.gen);\n    refObj.fetch(xref, &strObj);\n    refObj.free();\n    if (!strObj.isStream()) {\n      error(-1, \"Embedded font object is wrong type\");\n      strObj.free();\n      fclose(tmpFile);\n      goto err2;\n    }\n    strObj.streamReset();\n    while ((c = strObj.streamGetChar()) != EOF) {\n      fputc(c, tmpFile);\n    }\n    strObj.streamClose();\n    strObj.free();\n    fclose(tmpFile);\n    fileName = tmpFileName;\n    \n  } else if (!(fileName = gfxFont->getExtFontFile())) {\n    // look for a display font mapping or a substitute font\n    dfp = NULL;\n    if (gfxFont->getName()) {\n      dfp = globalParams->getDisplayFont(gfxFont);\n    }\n    if (!dfp) {\n      error(-1, \"Couldn't find a font for '%s'\",\n\t    gfxFont->getName() ? gfxFont->getName()->getCString()\n\t    : \"(unnamed)\");\n      goto err2;\n    }\n    switch (dfp->kind) {\n    case displayFontT1:\n      fileName = dfp->t1.fileName;\n      fontType = gfxFont->isCIDFont() ? fontCIDType0 : fontType1;\n      break;\n    case displayFontTT:\n      fileName = dfp->tt.fileName;\n      fontType = gfxFont->isCIDFont() ? fontCIDType2 : fontTrueType;\n      break;\n    }\n  }\n\n  switch (fontType) {\n  case fontType1:\n  case fontType1C:\n    if (FT_New_Face(lib, fileName->getCString(), 0, &face)) {\n      error(-1, \"could not create type1 face\");\n      goto err2;\n    }\n    \n    enc = ((Gfx8BitFont *)gfxFont)->getEncoding();\n    \n    codeToGID = (Gushort *)gmallocn(256, sizeof(int));\n    codeToGIDLen = 256;\n    for (i = 0; i < 256; ++i) {\n      codeToGID[i] = 0;\n      if ((name = enc[i])) {\n\tcodeToGID[i] = (Gushort)FT_Get_Name_Index(face, name);\n      }\n    }\n    break;\n    \n  case fontCIDType2:\n    codeToGID = NULL;\n    n = 0;\n    if (((GfxCIDFont *)gfxFont)->getCIDToGID()) {\n      n = ((GfxCIDFont *)gfxFont)->getCIDToGIDLen();\n      if (n) {\n\tcodeToGID = (Gushort *)gmallocn(n, sizeof(Gushort));\n\tmemcpy(codeToGID, ((GfxCIDFont *)gfxFont)->getCIDToGID(),\n\t\tn * sizeof(Gushort));\n      }\n    } else {\n      ff = FoFiTrueType::load(fileName->getCString());\n      if (! ff)\n\tgoto err2;\n      codeToGID = ((GfxCIDFont *)gfxFont)->getCodeToGIDMap(ff, &n);\n      delete ff;\n    }\n    codeToGIDLen = n;\n    /* Fall through */\n  case fontTrueType:\n    if (!(ff = FoFiTrueType::load(fileName->getCString()))) {\n      error(-1, \"failed to load truetype font\\n\");\n      goto err2;\n    }\n    /* This might be set already for the CIDType2 case */\n    if (fontType == fontTrueType) {\n      codeToGID = ((Gfx8BitFont *)gfxFont)->getCodeToGIDMap(ff);\n      codeToGIDLen = 256;\n    }\n    if (!openTempFile(&tmpFileName2, &tmpFile, \"wb\", NULL)) {\n      delete ff;\n      error(-1, \"failed to open truetype tempfile\\n\");\n      goto err2;\n    }\n    ff->writeTTF(&fileWrite, tmpFile);\n    fclose(tmpFile);\n    delete ff;\n\n    if (FT_New_Face(lib, tmpFileName2->getCString(), 0, &face)) {\n      error(-1, \"could not create truetype face\\n\");\n      goto err2;\n    }\n    unlink (tmpFileName2->getCString());\n    delete tmpFileName2;\n    break;\n    \n  case fontCIDType0:\n  case fontCIDType0C:\n\n    codeToGID = NULL;\n    codeToGIDLen = 0;\n\n    if (!useCIDs)\n    {\n      if ((ff1c = FoFiType1C::load(fileName->getCString()))) {\n        codeToGID = ff1c->getCIDToGIDMap(&codeToGIDLen);\n        delete ff1c;\n      }\n    }\n\n    if (FT_New_Face(lib, fileName->getCString(), 0, &face)) {\n      gfree(codeToGID);\n      codeToGID = NULL;\n      error(-1, \"could not create cid face\\n\");\n      goto err2;\n    }\n    break;\n    \n  default:\n    printf (\"font type not handled\\n\");\n    goto err2;\n    break;\n  }\n\n  // delete the (temporary) font file -- with Unix hard link\n  // semantics, this will remove the last link; otherwise it will\n  // return an error, leaving the file to be deleted later\n  if (fileName == tmpFileName) {\n    unlink (fileName->getCString());\n    delete tmpFileName;\n  }\n\n  cairo_font_face = cairo_ft_font_face_create_for_ft_face (face,\n\t\t\t\t\t\t\t   FT_LOAD_NO_HINTING |\n\t\t\t\t\t\t\t   FT_LOAD_NO_BITMAP);\n  if (cairo_font_face == NULL) {\n    error(-1, \"could not create cairo font\\n\");\n    goto err2; /* this doesn't do anything, but it looks like we're\n\t\t* handling the error */\n  } {\n  CairoFont *ret = new CairoFont(ref, cairo_font_face, face, codeToGID, codeToGIDLen);\n  cairo_font_face_set_user_data (cairo_font_face, \n\t\t\t\t &cairo_font_face_key,\n\t\t\t\t ret,\n\t\t\t\t cairo_font_face_destroy);\n\n  return ret;\n  }\n err2:\n  /* hmm? */\n  printf (\"some font thing failed\\n\");\n  return NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148537,
    "human": "Incorrect. With CWE-20",
    "reason": "Although the code adds a check for whether the input is really a stream, it's still lack of checks for font size, font data format, and sanitization of font names and paths.",
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int ma_read_ok_packet(MYSQL *mysql, uchar *pos, ulong length)\n{\n  size_t item_len;\n  mysql->affected_rows= net_field_length_ll(&pos);\n  mysql->insert_id=\t  net_field_length_ll(&pos);\n  mysql->server_status=uint2korr(pos);\n  pos+=2;\n  mysql->warning_count=uint2korr(pos);\n  pos+=2;\n  if (pos < mysql->net.read_pos+length)\n  {\n    if ((item_len= net_field_length(&pos)))\n      mysql->info=(char*) pos;\n\n    /* check if server supports session tracking */\n    if (mysql->server_capabilities & CLIENT_SESSION_TRACKING)\n    {\n      ma_clear_session_state(mysql);\n      pos+= item_len;\n\n      if (mysql->server_status & SERVER_SESSION_STATE_CHANGED)\n      {\n        int i;\n        if (pos < mysql->net.read_pos + length)\n        {\n          LIST *session_item;\n          MYSQL_LEX_STRING *str= NULL;\n          enum enum_session_state_type si_type;\n          uchar *old_pos= pos;\n          size_t item_len= net_field_length(&pos);  /* length for all items */\n\n          /* length was already set, so make sure that info will be zero terminated */\n          if (mysql->info)\n            *old_pos= 0;\n\n          while (item_len > 0)\n          {\n            size_t plen;\n            char *data;\n            old_pos= pos;\n            si_type= (enum enum_session_state_type)net_field_length(&pos);\n            switch(si_type) {\n            case SESSION_TRACK_SCHEMA:\n            case SESSION_TRACK_STATE_CHANGE:\n            case SESSION_TRACK_TRANSACTION_CHARACTERISTICS:\n            case SESSION_TRACK_SYSTEM_VARIABLES:\n              if (si_type != SESSION_TRACK_STATE_CHANGE)\n                net_field_length(&pos); /* ignore total length, item length will follow next */\n              plen= net_field_length(&pos);\n              if (!(session_item= ma_multi_malloc(0,\n                                  &session_item, sizeof(LIST),\n                                  &str, sizeof(MYSQL_LEX_STRING),\n                                  &data, plen,\n                                  NULL)))\n              {\n                ma_clear_session_state(mysql);\n                SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n                return -1;\n              }\n              str->length= plen;\n              str->str= data;\n              memcpy(str->str, (char *)pos, plen);\n              pos+= plen;\n              session_item->data= str;\n              mysql->extension->session_state[si_type].list= list_add(mysql->extension->session_state[si_type].list, session_item);\n\n              /* in case schema has changed, we have to update mysql->db */\n              if (si_type == SESSION_TRACK_SCHEMA)\n              {\n                free(mysql->db);\n                mysql->db= malloc(plen + 1);\n                memcpy(mysql->db, str->str, plen);\n                mysql->db[plen]= 0;\n              }\n              else if (si_type == SESSION_TRACK_SYSTEM_VARIABLES)\n              {\n                my_bool set_charset= 0;\n                /* make sure that we update charset in case it has changed */\n                if (!strncmp(str->str, \"character_set_client\", str->length))\n                  set_charset= 1;\n                plen= net_field_length(&pos);\n                if (!(session_item= ma_multi_malloc(0,\n                                    &session_item, sizeof(LIST),\n                                    &str, sizeof(MYSQL_LEX_STRING),\n                                    &data, plen,\n                                    NULL)))\n                {\n                  ma_clear_session_state(mysql);\n                  SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n                  return -1;\n                }\n                str->length= plen;\n                str->str= data;\n                memcpy(str->str, (char *)pos, plen);\n                pos+= plen;\n                session_item->data= str;\n                mysql->extension->session_state[si_type].list= list_add(mysql->extension->session_state[si_type].list, session_item);\n                if (set_charset &&\n                    strncmp(mysql->charset->csname, str->str, str->length) != 0)\n                {\n                  char cs_name[64];\n                  MARIADB_CHARSET_INFO *cs_info;\n                  memcpy(cs_name, str->str, str->length);\n                  cs_name[str->length]= 0;\n                  if ((cs_info = (MARIADB_CHARSET_INFO *)mysql_find_charset_name(cs_name)))\n                    mysql->charset= cs_info;\n                }\n              }\n              break;\n            default:\n              /* not supported yet */\n              plen= net_field_length(&pos);\n              pos+= plen;\n              break;\n            }\n            item_len-= (pos - old_pos);\n          }\n        }\n        for (i= SESSION_TRACK_BEGIN; i <= SESSION_TRACK_END; i++)\n        {\n          mysql->extension->session_state[i].list= list_reverse(mysql->extension->session_state[i].list);\n          mysql->extension->session_state[i].current= mysql->extension->session_state[i].list;\n        }\n      }\n    }\n  }\n  /* CONC-351: clear session state information */\n  else if (mysql->server_capabilities & CLIENT_SESSION_TRACKING)\n    ma_clear_session_state(mysql);\n  return(0);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148556,
    "human": "Correct. With CWE-20",
    "reason": "Exhibits improper input validation because it trusts item_len/plen from the packet without verifying that the final pointer stays within the buffer.",
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int ma_read_ok_packet(MYSQL *mysql, uchar *pos, ulong length)\n{\n  uchar *end= mysql->net.read_pos+length;\n  size_t item_len;\n  mysql->affected_rows= net_field_length_ll(&pos);\n  mysql->insert_id=\t  net_field_length_ll(&pos);\n  mysql->server_status=uint2korr(pos);\n  pos+=2;\n  mysql->warning_count=uint2korr(pos);\n  pos+=2;\n  if (pos > end)\n    goto corrupted;\n  if (pos < end)\n  {\n    if ((item_len= net_field_length(&pos)))\n      mysql->info=(char*) pos;\n    if (pos + item_len > end)\n      goto corrupted;\n\n    /* check if server supports session tracking */\n    if (mysql->server_capabilities & CLIENT_SESSION_TRACKING)\n    {\n      ma_clear_session_state(mysql);\n      pos+= item_len;\n\n      if (mysql->server_status & SERVER_SESSION_STATE_CHANGED)\n      {\n        int i;\n        if (pos < end)\n        {\n          LIST *session_item;\n          MYSQL_LEX_STRING *str= NULL;\n          enum enum_session_state_type si_type;\n          uchar *old_pos= pos;\n\n          item_len= net_field_length(&pos);  /* length for all items */\n          if (pos + item_len > end)\n            goto corrupted;\n          end= pos + item_len;\n\n          /* length was already set, so make sure that info will be zero terminated */\n          if (mysql->info)\n            *old_pos= 0;\n\n          while (pos < end)\n          {\n            size_t plen;\n            char *data;\n            si_type= (enum enum_session_state_type)net_field_length(&pos);\n            switch(si_type) {\n            case SESSION_TRACK_SCHEMA:\n            case SESSION_TRACK_STATE_CHANGE:\n            case SESSION_TRACK_TRANSACTION_CHARACTERISTICS:\n            case SESSION_TRACK_SYSTEM_VARIABLES:\n              if (si_type != SESSION_TRACK_STATE_CHANGE)\n                net_field_length(&pos); /* ignore total length, item length will follow next */\n              plen= net_field_length(&pos);\n              if (pos + plen > end)\n                goto corrupted;\n              if (!(session_item= ma_multi_malloc(0,\n                                  &session_item, sizeof(LIST),\n                                  &str, sizeof(MYSQL_LEX_STRING),\n                                  &data, plen,\n                                  NULL)))\n                  goto oom;\n              str->length= plen;\n              str->str= data;\n              memcpy(str->str, (char *)pos, plen);\n              pos+= plen;\n              session_item->data= str;\n              mysql->extension->session_state[si_type].list= list_add(mysql->extension->session_state[si_type].list, session_item);\n\n              /* in case schema has changed, we have to update mysql->db */\n              if (si_type == SESSION_TRACK_SCHEMA)\n              {\n                free(mysql->db);\n                mysql->db= malloc(plen + 1);\n                memcpy(mysql->db, str->str, plen);\n                mysql->db[plen]= 0;\n              }\n              else if (si_type == SESSION_TRACK_SYSTEM_VARIABLES)\n              {\n                my_bool set_charset= 0;\n                /* make sure that we update charset in case it has changed */\n                if (!strncmp(str->str, \"character_set_client\", str->length))\n                  set_charset= 1;\n                plen= net_field_length(&pos);\n                if (pos + plen > end)\n                  goto corrupted;\n                if (!(session_item= ma_multi_malloc(0,\n                                    &session_item, sizeof(LIST),\n                                    &str, sizeof(MYSQL_LEX_STRING),\n                                    &data, plen,\n                                    NULL)))\n                  goto oom;\n                str->length= plen;\n                str->str= data;\n                memcpy(str->str, (char *)pos, plen);\n                pos+= plen;\n                session_item->data= str;\n                mysql->extension->session_state[si_type].list= list_add(mysql->extension->session_state[si_type].list, session_item);\n                if (set_charset && str->length < CHARSET_NAME_LEN &&\n                    strncmp(mysql->charset->csname, str->str, str->length) != 0)\n                {\n                  char cs_name[CHARSET_NAME_LEN];\n                  const MARIADB_CHARSET_INFO *cs_info;\n                  memcpy(cs_name, str->str, str->length);\n                  cs_name[str->length]= 0;\n                  if ((cs_info = mysql_find_charset_name(cs_name)))\n                    mysql->charset= cs_info;\n                }\n              }\n              break;\n            default:\n              /* not supported yet */\n              plen= net_field_length(&pos);\n              if (pos + plen > end)\n                goto corrupted;\n              pos+= plen;\n              break;\n            }\n          }\n        }\n        for (i= SESSION_TRACK_BEGIN; i <= SESSION_TRACK_END; i++)\n        {\n          mysql->extension->session_state[i].list= list_reverse(mysql->extension->session_state[i].list);\n          mysql->extension->session_state[i].current= mysql->extension->session_state[i].list;\n        }\n      }\n    }\n  }\n  /* CONC-351: clear session state information */\n  else if (mysql->server_capabilities & CLIENT_SESSION_TRACKING)\n    ma_clear_session_state(mysql);\n  return(0);\n\noom:\n  ma_clear_session_state(mysql);\n  SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n  return -1;\n\ncorrupted:\n  ma_clear_session_state(mysql);\n  SET_CLIENT_ERROR(mysql, CR_MALFORMED_PACKET, SQLSTATE_UNKNOWN, 0);\n  return -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148557,
    "human": "Correct. Without CWE-20",
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "\nprivate int\nmget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n    size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,\n    int flip, int recursion_level, int *printed_something,\n    int *need_separator, int *returnval)\n{\n\tuint32_t soffset, offset = ms->offset;\n\tuint32_t count = m->str_range;\n\tint rv, oneed_separator;\n\tchar *sbuf, *rbuf;\n\tunion VALUETYPE *p = &ms->ms_value;\n\tstruct mlist ml;\n\n\tif (recursion_level >= 20) {\n\t\tfile_error(ms, 0, \"recursion nesting exceeded\");\n\t\treturn -1;\n\t}\n\n\tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n\t    (uint32_t)nbytes, count) == -1)\n\t\treturn -1;\n\n\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\tfprintf(stderr, \"mget(type=%d, flag=%x, offset=%u, o=%zu, \"\n\t\t    \"nbytes=%zu, count=%u)\\n\", m->type, m->flag, offset, o,\n\t\t    nbytes, count);\n\t\tmdebug(offset, (char *)(void *)p, sizeof(union VALUETYPE));\n\t}\n\n\tif (m->flag & INDIR) {\n\t\tint off = m->in_offset;\n\t\tif (m->in_op & FILE_OPINDIRECT) {\n\t\t\tconst union VALUETYPE *q = CAST(const union VALUETYPE *,\n\t\t\t    ((const void *)(s + offset + off)));\n\t\t\tswitch (cvt_flip(m->in_type, flip)) {\n\t\t\tcase FILE_BYTE:\n\t\t\t\toff = q->b;\n\t\t\t\tbreak;\n\t\t\tcase FILE_SHORT:\n\t\t\t\toff = q->h;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BESHORT:\n\t\t\t\toff = (short)((q->hs[0]<<8)|(q->hs[1]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LESHORT:\n\t\t\t\toff = (short)((q->hs[1]<<8)|(q->hs[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LONG:\n\t\t\t\toff = q->l;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BELONG:\n\t\t\tcase FILE_BEID3:\n\t\t\t\toff = (int32_t)((q->hl[0]<<24)|(q->hl[1]<<16)|\n\t\t\t\t\t\t (q->hl[2]<<8)|(q->hl[3]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LEID3:\n\t\t\tcase FILE_LELONG:\n\t\t\t\toff = (int32_t)((q->hl[3]<<24)|(q->hl[2]<<16)|\n\t\t\t\t\t\t (q->hl[1]<<8)|(q->hl[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_MELONG:\n\t\t\t\toff = (int32_t)((q->hl[1]<<24)|(q->hl[0]<<16)|\n\t\t\t\t\t\t (q->hl[3]<<8)|(q->hl[2]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect offs=%u\\n\", off);\n\t\t}\n\t\tswitch (cvt_flip(m->in_type, flip)) {\n\t\tcase FILE_BYTE:\n\t\t\tif (nbytes < (offset + 1))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->b & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->b | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->b ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->b + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->b - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->b * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->b / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->b % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->b;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BESHORT:\n\t\t\tif (nbytes < (offset + 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t (p->hs[1]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LESHORT:\n\t\t\tif (nbytes < (offset + 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t (p->hs[0]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\t\tif (nbytes < (offset + 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->h & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->h | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->h ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->h + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->h - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->h * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->h / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->h % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p->h;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BELONG:\n\t\tcase FILE_BEID3:\n\t\t\tif (nbytes < (offset + 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t (p->hl[3]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LELONG:\n\t\tcase FILE_LEID3:\n\t\t\tif (nbytes < (offset + 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t (p->hl[0]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_MELONG:\n\t\t\tif (nbytes < (offset + 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t (p->hl[2]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LONG:\n\t\t\tif (nbytes < (offset + 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->l & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->l | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->l ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->l + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->l - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->l * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->l / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->l % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->l;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (cvt_flip(m->in_type, flip)) {\n\t\tcase FILE_LEID3:\n\t\tcase FILE_BEID3:\n\t\t\toffset = ((((offset >>  0) & 0x7f) <<  0) |\n\t\t\t\t (((offset >>  8) & 0x7f) <<  7) |\n\t\t\t\t (((offset >> 16) & 0x7f) << 14) |\n\t\t\t\t (((offset >> 24) & 0x7f) << 21)) + 10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (m->flag & INDIROFFADD) {\n\t\t\toffset += ms->c.li[cont_level-1].off;\n\t\t\tif (offset == 0) {\n\t\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t    \"indirect *zero* offset\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect +offs=%u\\n\", offset);\n\t\t}\n\t\tif (mcopy(ms, p, m->type, 0, s, offset, nbytes, count) == -1)\n\t\t\treturn -1;\n\t\tms->offset = offset;\n\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\t\tmdebug(offset, (char *)(void *)p,\n\t\t\t    sizeof(union VALUETYPE));\n\t\t}\n\t}\n\n\t/* Verify we have enough data to match magic type */\n\tswitch (m->type) {\n\tcase FILE_BYTE:\n\t\tif (nbytes < (offset + 1)) /* should alway be true */\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_SHORT:\n\tcase FILE_BESHORT:\n\tcase FILE_LESHORT:\n\t\tif (nbytes < (offset + 2))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_LONG:\n\tcase FILE_BELONG:\n\tcase FILE_LELONG:\n\tcase FILE_MELONG:\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tif (nbytes < (offset + 4))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tif (nbytes < (offset + 8))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\tcase FILE_SEARCH:\n\t\tif (nbytes < (offset + m->vallen))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_REGEX:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = ms->o.buf;\n\t\tsoffset = ms->offset;\n\t\tms->o.buf = NULL;\n\t\tms->offset = 0;\n\t\trv = file_softmagic(ms, s + offset, nbytes - offset,\n\t\t    BINTEST, text);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\tfprintf(stderr, \"indirect @offs=%u[%d]\\n\", offset, rv);\n\t\trbuf = ms->o.buf;\n\t\tms->o.buf = sbuf;\n\t\tms->offset = soffset;\n\t\tif (rv == 1) {\n\t  \tif ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&\n\t\t\t    file_printf(ms, m->desc, offset) == -1)\n\t\t\treturn -1;\n\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1)\n\t\t\t\treturn -1;\n\t\t\tfree(rbuf);\n\t\t}\n\t\treturn rv;\n\n\tcase FILE_USE:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = m->value.s;\n\t\tif (*sbuf == '^') {\n\t\t\tsbuf++;\n\t\t\tflip = !flip;\n\t\t}\n\t\tif (file_magicfind(ms, sbuf, &ml) == -1) {\n\t\t\tfile_error(ms, 0, \"cannot find entry `%s'\", sbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\toneed_separator = *need_separator;\n\t\tif (m->flag & NOSPACE)\n\t\t\t*need_separator = 0;\n\t\trv = match(ms, ml.magic, ml.nmagic, s, nbytes, offset + o,\n\t\t    mode, text, flip, recursion_level, printed_something,\n\t\t    need_separator, returnval);\n\t\tif (rv != 1)\n\t\t    *need_separator = oneed_separator;\n\t\treturn rv;\n\n\tcase FILE_NAME:\n\t\tif (file_printf(ms, \"%s\", m->desc) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\tcase FILE_DEFAULT:\t/* nothing to check */\n\tdefault:\n\t\tbreak;\n\t}\n\tif (!mconvert(ms, m, flip))\n\t\treturn 0;",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148638,
    "human": "Incorrect. Without CWE-20",
    "reason": "The code is accually using completely same boundary check with the fixed version. The fixed version below just changes free() to efree().",
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "\nprivate int\nmget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n    size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,\n    int flip, int recursion_level, int *printed_something,\n    int *need_separator, int *returnval)\n{\n\tuint32_t soffset, offset = ms->offset;\n\tuint32_t count = m->str_range;\n\tint rv, oneed_separator;\n\tchar *sbuf, *rbuf;\n\tunion VALUETYPE *p = &ms->ms_value;\n\tstruct mlist ml;\n\n\tif (recursion_level >= 20) {\n\t\tfile_error(ms, 0, \"recursion nesting exceeded\");\n\t\treturn -1;\n\t}\n\n\tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n\t    (uint32_t)nbytes, count) == -1)\n\t\treturn -1;\n\n\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\tfprintf(stderr, \"mget(type=%d, flag=%x, offset=%u, o=%zu, \"\n\t\t    \"nbytes=%zu, count=%u)\\n\", m->type, m->flag, offset, o,\n\t\t    nbytes, count);\n\t\tmdebug(offset, (char *)(void *)p, sizeof(union VALUETYPE));\n\t}\n\n\tif (m->flag & INDIR) {\n\t\tint off = m->in_offset;\n\t\tif (m->in_op & FILE_OPINDIRECT) {\n\t\t\tconst union VALUETYPE *q = CAST(const union VALUETYPE *,\n\t\t\t    ((const void *)(s + offset + off)));\n\t\t\tswitch (cvt_flip(m->in_type, flip)) {\n\t\t\tcase FILE_BYTE:\n\t\t\t\toff = q->b;\n\t\t\t\tbreak;\n\t\t\tcase FILE_SHORT:\n\t\t\t\toff = q->h;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BESHORT:\n\t\t\t\toff = (short)((q->hs[0]<<8)|(q->hs[1]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LESHORT:\n\t\t\t\toff = (short)((q->hs[1]<<8)|(q->hs[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LONG:\n\t\t\t\toff = q->l;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BELONG:\n\t\t\tcase FILE_BEID3:\n\t\t\t\toff = (int32_t)((q->hl[0]<<24)|(q->hl[1]<<16)|\n\t\t\t\t\t\t (q->hl[2]<<8)|(q->hl[3]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LEID3:\n\t\t\tcase FILE_LELONG:\n\t\t\t\toff = (int32_t)((q->hl[3]<<24)|(q->hl[2]<<16)|\n\t\t\t\t\t\t (q->hl[1]<<8)|(q->hl[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_MELONG:\n\t\t\t\toff = (int32_t)((q->hl[1]<<24)|(q->hl[0]<<16)|\n\t\t\t\t\t\t (q->hl[3]<<8)|(q->hl[2]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect offs=%u\\n\", off);\n\t\t}\n\t\tswitch (cvt_flip(m->in_type, flip)) {\n\t\tcase FILE_BYTE:\n\t\t\tif (nbytes < (offset + 1))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->b & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->b | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->b ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->b + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->b - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->b * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->b / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->b % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->b;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BESHORT:\n\t\t\tif (nbytes < (offset + 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t (p->hs[1]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LESHORT:\n\t\t\tif (nbytes < (offset + 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t (p->hs[0]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\t\tif (nbytes < (offset + 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->h & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->h | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->h ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->h + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->h - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->h * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->h / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->h % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p->h;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BELONG:\n\t\tcase FILE_BEID3:\n\t\t\tif (nbytes < (offset + 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t (p->hl[3]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LELONG:\n\t\tcase FILE_LEID3:\n\t\t\tif (nbytes < (offset + 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t (p->hl[0]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_MELONG:\n\t\t\tif (nbytes < (offset + 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t (p->hl[2]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LONG:\n\t\t\tif (nbytes < (offset + 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->l & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->l | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->l ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->l + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->l - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->l * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->l / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->l % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->l;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (cvt_flip(m->in_type, flip)) {\n\t\tcase FILE_LEID3:\n\t\tcase FILE_BEID3:\n\t\t\toffset = ((((offset >>  0) & 0x7f) <<  0) |\n\t\t\t\t (((offset >>  8) & 0x7f) <<  7) |\n\t\t\t\t (((offset >> 16) & 0x7f) << 14) |\n\t\t\t\t (((offset >> 24) & 0x7f) << 21)) + 10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (m->flag & INDIROFFADD) {\n\t\t\toffset += ms->c.li[cont_level-1].off;\n\t\t\tif (offset == 0) {\n\t\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t    \"indirect *zero* offset\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect +offs=%u\\n\", offset);\n\t\t}\n\t\tif (mcopy(ms, p, m->type, 0, s, offset, nbytes, count) == -1)\n\t\t\treturn -1;\n\t\tms->offset = offset;\n\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\t\tmdebug(offset, (char *)(void *)p,\n\t\t\t    sizeof(union VALUETYPE));\n\t\t}\n\t}\n\n\t/* Verify we have enough data to match magic type */\n\tswitch (m->type) {\n\tcase FILE_BYTE:\n\t\tif (nbytes < (offset + 1)) /* should alway be true */\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_SHORT:\n\tcase FILE_BESHORT:\n\tcase FILE_LESHORT:\n\t\tif (nbytes < (offset + 2))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_LONG:\n\tcase FILE_BELONG:\n\tcase FILE_LELONG:\n\tcase FILE_MELONG:\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tif (nbytes < (offset + 4))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tif (nbytes < (offset + 8))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\tcase FILE_SEARCH:\n\t\tif (nbytes < (offset + m->vallen))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_REGEX:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = ms->o.buf;\n\t\tsoffset = ms->offset;\n\t\tms->o.buf = NULL;\n\t\tms->offset = 0;\n\t\trv = file_softmagic(ms, s + offset, nbytes - offset,\n\t\t    BINTEST, text);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\tfprintf(stderr, \"indirect @offs=%u[%d]\\n\", offset, rv);\n\t\trbuf = ms->o.buf;\n\t\tms->o.buf = sbuf;\n\t\tms->offset = soffset;\n\t\tif (rv == 1) {\n\t  \tif ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&\n\t\t\t    file_printf(ms, m->desc, offset) == -1)\n\t\t\treturn -1;\n\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1)\n\t\t\t\treturn -1;\n\t\t\tefree(rbuf);\n\t\t}\n\t\treturn rv;\n\n\tcase FILE_USE:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = m->value.s;\n\t\tif (*sbuf == '^') {\n\t\t\tsbuf++;\n\t\t\tflip = !flip;\n\t\t}\n\t\tif (file_magicfind(ms, sbuf, &ml) == -1) {\n\t\t\tfile_error(ms, 0, \"cannot find entry `%s'\", sbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\toneed_separator = *need_separator;\n\t\tif (m->flag & NOSPACE)\n\t\t\t*need_separator = 0;\n\t\trv = match(ms, ml.magic, ml.nmagic, s, nbytes, offset + o,\n\t\t    mode, text, flip, recursion_level, printed_something,\n\t\t    need_separator, returnval);\n\t\tif (rv != 1)\n\t\t    *need_separator = oneed_separator;\n\t\treturn rv;\n\n\tcase FILE_NAME:\n\t\tif (file_printf(ms, \"%s\", m->desc) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\tcase FILE_DEFAULT:\t/* nothing to check */\n\tdefault:\n\t\tbreak;\n\t}\n\tif (!mconvert(ms, m, flip))\n\t\treturn 0;",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148639,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int ext4_group_add(struct super_block *sb, struct ext4_new_group_data *input)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint reserved_gdb = ext4_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\tstruct buffer_head *primary = NULL;\n\tstruct ext4_group_desc *gdp;\n\tstruct inode *inode = NULL;\n\thandle_t *handle;\n\tint gdb_off, gdb_num;\n\tint num_grp_locked = 0;\n\tint err, err2;\n\n\tgdb_num = input->group / EXT4_DESC_PER_BLOCK(sb);\n\tgdb_off = input->group % EXT4_DESC_PER_BLOCK(sb);\n\n\tif (gdb_off == 0 && !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\text4_warning(sb, __func__,\n\t\t\t     \"Can't resize non-sparse filesystem further\");\n\t\treturn -EPERM;\n\t}\n\n\tif (ext4_blocks_count(es) + input->blocks_count <\n\t    ext4_blocks_count(es)) {\n\t\text4_warning(sb, __func__, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(es->s_inodes_count) + EXT4_INODES_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text4_warning(sb, __func__, \"inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (reserved_gdb || gdb_off == 0) {\n\t\tif (!EXT4_HAS_COMPAT_FEATURE(sb,\n\t\t\t\t\t     EXT4_FEATURE_COMPAT_RESIZE_INODE)\n\t\t    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\text4_warning(sb, __func__,\n\t\t\t\t     \"No reserved GDT blocks, can't resize\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tinode = ext4_iget(sb, EXT4_RESIZE_INO);\n\t\tif (IS_ERR(inode)) {\n\t\t\text4_warning(sb, __func__,\n\t\t\t\t     \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t}\n\n\n\tif ((err = verify_group_input(sb, input)))\n\t\tgoto exit_put;\n\n\tif ((err = setup_new_group_blocks(sb, input)))\n\t\tgoto exit_put;\n\n\t/*\n\t * We will always be modifying at least the superblock and a GDT\n\t * block.  If we are adding a group past the last current GDT block,\n\t * we will also modify the inode and the dindirect block.  If we\n\t * are adding a group with superblock/GDT backups  we will also\n\t * modify each of the reserved GDT dindirect blocks.\n\t */\n\thandle = ext4_journal_start_sb(sb,\n\t\t\t\t       ext4_bg_has_super(sb, input->group) ?\n\t\t\t\t       3 + reserved_gdb : 4);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit_put;\n\t}\n\n\tlock_super(sb);\n\tif (input->group != sbi->s_groups_count) {\n\t\text4_warning(sb, __func__,\n\t\t\t     \"multiple resizers run on filesystem!\");\n\t\terr = -EBUSY;\n\t\tgoto exit_journal;\n\t}\n\n\tif ((err = ext4_journal_get_write_access(handle, sbi->s_sbh)))\n\t\tgoto exit_journal;\n\n        /*\n         * We will only either add reserved group blocks to a backup group\n         * or remove reserved blocks for the first group in a new group block.\n         * Doing both would be mean more complex code, and sane people don't\n         * use non-sparse filesystems anymore.  This is already checked above.\n         */\n\tif (gdb_off) {\n\t\tprimary = sbi->s_group_desc[gdb_num];\n\t\tif ((err = ext4_journal_get_write_access(handle, primary)))\n\t\t\tgoto exit_journal;\n\n\t\tif (reserved_gdb && ext4_bg_num_gdb(sb, input->group) &&\n\t\t    (err = reserve_backup_gdb(handle, inode, input)))\n\t\t\tgoto exit_journal;\n\t} else if ((err = add_new_gdb(handle, inode, input, &primary)))\n\t\tgoto exit_journal;\n\n        /*\n         * OK, now we've set up the new group.  Time to make it active.\n         *\n         * Current kernels don't lock all allocations via lock_super(),\n         * so we have to be safe wrt. concurrent accesses the group\n         * data.  So we need to be careful to set all of the relevant\n         * group descriptor data etc. *before* we enable the group.\n         *\n         * The key field here is sbi->s_groups_count: as long as\n         * that retains its old value, nobody is going to access the new\n         * group.\n         *\n         * So first we update all the descriptor metadata for the new\n         * group; then we update the total disk blocks count; then we\n         * update the groups count to enable the group; then finally we\n         * update the free space counts so that the system can start\n         * using the new disk blocks.\n         */\n\n\tnum_grp_locked = ext4_mb_get_buddy_cache_lock(sb, input->group);\n\t/* Update group descriptor block for new group */\n\tgdp = (struct ext4_group_desc *)((char *)primary->b_data +\n\t\t\t\t\t gdb_off * EXT4_DESC_SIZE(sb));\n\n\text4_block_bitmap_set(sb, gdp, input->block_bitmap); /* LV FIXME */\n\text4_inode_bitmap_set(sb, gdp, input->inode_bitmap); /* LV FIXME */\n\text4_inode_table_set(sb, gdp, input->inode_table); /* LV FIXME */\n\text4_free_blks_set(sb, gdp, input->free_blocks_count);\n\text4_free_inodes_set(sb, gdp, EXT4_INODES_PER_GROUP(sb));\n\tgdp->bg_flags |= cpu_to_le16(EXT4_BG_INODE_ZEROED);\n\tgdp->bg_checksum = ext4_group_desc_csum(sbi, input->group, gdp);\n\n\t/*\n\t * We can allocate memory for mb_alloc based on the new group\n\t * descriptor\n\t */\n\terr = ext4_mb_add_groupinfo(sb, input->group, gdp);\n\tif (err) {\n\t\text4_mb_put_buddy_cache_lock(sb, input->group, num_grp_locked);\n\t\tgoto exit_journal;\n\t}\n\n\t/*\n\t * Make the new blocks and inodes valid next.  We do this before\n\t * increasing the group count so that once the group is enabled,\n\t * all of its blocks and inodes are already valid.\n\t *\n\t * We always allocate group-by-group, then block-by-block or\n\t * inode-by-inode within a group, so enabling these\n\t * blocks/inodes before the group is live won't actually let us\n\t * allocate the new space yet.\n\t */\n\text4_blocks_count_set(es, ext4_blocks_count(es) +\n\t\tinput->blocks_count);\n\tle32_add_cpu(&es->s_inodes_count, EXT4_INODES_PER_GROUP(sb));\n\n\t/*\n\t * We need to protect s_groups_count against other CPUs seeing\n\t * inconsistent state in the superblock.\n\t *\n\t * The precise rules we use are:\n\t *\n\t * * Writers of s_groups_count *must* hold lock_super\n\t * AND\n\t * * Writers must perform a smp_wmb() after updating all dependent\n\t *   data and before modifying the groups count\n\t *\n\t * * Readers must hold lock_super() over the access\n\t * OR\n\t * * Readers must perform an smp_rmb() after reading the groups count\n\t *   and before reading any dependent data.\n\t *\n\t * NB. These rules can be relaxed when checking the group count\n\t * while freeing data, as we can only allocate from a block\n\t * group after serialising against the group count, and we can\n\t * only then free after serialising in turn against that\n\t * allocation.\n\t */\n\tsmp_wmb();\n\n\t/* Update the global fs size fields */\n\tsbi->s_groups_count++;\n\text4_mb_put_buddy_cache_lock(sb, input->group, num_grp_locked);\n\n\text4_handle_dirty_metadata(handle, NULL, primary);\n\n\t/* Update the reserved block counts only once the new group is\n\t * active. */\n\text4_r_blocks_count_set(es, ext4_r_blocks_count(es) +\n\t\tinput->reserved_blocks);\n\n\t/* Update the free space counts */\n\tpercpu_counter_add(&sbi->s_freeblocks_counter,\n\t\t\t   input->free_blocks_count);\n\tpercpu_counter_add(&sbi->s_freeinodes_counter,\n\t\t\t   EXT4_INODES_PER_GROUP(sb));\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG)) {\n\t\text4_group_t flex_group;\n\t\tflex_group = ext4_flex_group(sbi, input->group);\n\t\tsbi->s_flex_groups[flex_group].free_blocks +=\n\t\t\tinput->free_blocks_count;\n\t\tsbi->s_flex_groups[flex_group].free_inodes +=\n\t\t\tEXT4_INODES_PER_GROUP(sb);\n\t}\n\n\text4_handle_dirty_metadata(handle, NULL, sbi->s_sbh);\n\tsb->s_dirt = 1;\n\nexit_journal:\n\tunlock_super(sb);\n\tif ((err2 = ext4_journal_stop(handle)) && !err)\n\t\terr = err2;\n\tif (!err) {\n\t\tupdate_backups(sb, sbi->s_sbh->b_blocknr, (char *)es,\n\t\t\t       sizeof(struct ext4_super_block));\n\t\tupdate_backups(sb, primary->b_blocknr, primary->b_data,\n\t\t\t       primary->b_size);\n\t}\nexit_put:\n\tiput(inode);\n\treturn err;\n} /* ext4_group_add */",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148730,
    "human": "Incorrect. Without CWE-20",
    "reason": "It's actually using the same function as the next fixed code for valid input check (verify_group_input), and the fix for ensuring leftover bits from an old descriptor are cleared is not a big problem in this code.",
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int ext4_group_add(struct super_block *sb, struct ext4_new_group_data *input)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint reserved_gdb = ext4_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\tstruct buffer_head *primary = NULL;\n\tstruct ext4_group_desc *gdp;\n\tstruct inode *inode = NULL;\n\thandle_t *handle;\n\tint gdb_off, gdb_num;\n\tint num_grp_locked = 0;\n\tint err, err2;\n\n\tgdb_num = input->group / EXT4_DESC_PER_BLOCK(sb);\n\tgdb_off = input->group % EXT4_DESC_PER_BLOCK(sb);\n\n\tif (gdb_off == 0 && !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\text4_warning(sb, __func__,\n\t\t\t     \"Can't resize non-sparse filesystem further\");\n\t\treturn -EPERM;\n\t}\n\n\tif (ext4_blocks_count(es) + input->blocks_count <\n\t    ext4_blocks_count(es)) {\n\t\text4_warning(sb, __func__, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(es->s_inodes_count) + EXT4_INODES_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text4_warning(sb, __func__, \"inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (reserved_gdb || gdb_off == 0) {\n\t\tif (!EXT4_HAS_COMPAT_FEATURE(sb,\n\t\t\t\t\t     EXT4_FEATURE_COMPAT_RESIZE_INODE)\n\t\t    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\text4_warning(sb, __func__,\n\t\t\t\t     \"No reserved GDT blocks, can't resize\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tinode = ext4_iget(sb, EXT4_RESIZE_INO);\n\t\tif (IS_ERR(inode)) {\n\t\t\text4_warning(sb, __func__,\n\t\t\t\t     \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t}\n\n\n\tif ((err = verify_group_input(sb, input)))\n\t\tgoto exit_put;\n\n\tif ((err = setup_new_group_blocks(sb, input)))\n\t\tgoto exit_put;\n\n\t/*\n\t * We will always be modifying at least the superblock and a GDT\n\t * block.  If we are adding a group past the last current GDT block,\n\t * we will also modify the inode and the dindirect block.  If we\n\t * are adding a group with superblock/GDT backups  we will also\n\t * modify each of the reserved GDT dindirect blocks.\n\t */\n\thandle = ext4_journal_start_sb(sb,\n\t\t\t\t       ext4_bg_has_super(sb, input->group) ?\n\t\t\t\t       3 + reserved_gdb : 4);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit_put;\n\t}\n\n\tlock_super(sb);\n\tif (input->group != sbi->s_groups_count) {\n\t\text4_warning(sb, __func__,\n\t\t\t     \"multiple resizers run on filesystem!\");\n\t\terr = -EBUSY;\n\t\tgoto exit_journal;\n\t}\n\n\tif ((err = ext4_journal_get_write_access(handle, sbi->s_sbh)))\n\t\tgoto exit_journal;\n\n        /*\n         * We will only either add reserved group blocks to a backup group\n         * or remove reserved blocks for the first group in a new group block.\n         * Doing both would be mean more complex code, and sane people don't\n         * use non-sparse filesystems anymore.  This is already checked above.\n         */\n\tif (gdb_off) {\n\t\tprimary = sbi->s_group_desc[gdb_num];\n\t\tif ((err = ext4_journal_get_write_access(handle, primary)))\n\t\t\tgoto exit_journal;\n\n\t\tif (reserved_gdb && ext4_bg_num_gdb(sb, input->group) &&\n\t\t    (err = reserve_backup_gdb(handle, inode, input)))\n\t\t\tgoto exit_journal;\n\t} else if ((err = add_new_gdb(handle, inode, input, &primary)))\n\t\tgoto exit_journal;\n\n        /*\n         * OK, now we've set up the new group.  Time to make it active.\n         *\n         * Current kernels don't lock all allocations via lock_super(),\n         * so we have to be safe wrt. concurrent accesses the group\n         * data.  So we need to be careful to set all of the relevant\n         * group descriptor data etc. *before* we enable the group.\n         *\n         * The key field here is sbi->s_groups_count: as long as\n         * that retains its old value, nobody is going to access the new\n         * group.\n         *\n         * So first we update all the descriptor metadata for the new\n         * group; then we update the total disk blocks count; then we\n         * update the groups count to enable the group; then finally we\n         * update the free space counts so that the system can start\n         * using the new disk blocks.\n         */\n\n\tnum_grp_locked = ext4_mb_get_buddy_cache_lock(sb, input->group);\n\t/* Update group descriptor block for new group */\n\tgdp = (struct ext4_group_desc *)((char *)primary->b_data +\n\t\t\t\t\t gdb_off * EXT4_DESC_SIZE(sb));\n\n\tmemset(gdp, 0, EXT4_DESC_SIZE(sb));\n\text4_block_bitmap_set(sb, gdp, input->block_bitmap); /* LV FIXME */\n\text4_inode_bitmap_set(sb, gdp, input->inode_bitmap); /* LV FIXME */\n\text4_inode_table_set(sb, gdp, input->inode_table); /* LV FIXME */\n\text4_free_blks_set(sb, gdp, input->free_blocks_count);\n\text4_free_inodes_set(sb, gdp, EXT4_INODES_PER_GROUP(sb));\n\tgdp->bg_flags = cpu_to_le16(EXT4_BG_INODE_ZEROED);\n\tgdp->bg_checksum = ext4_group_desc_csum(sbi, input->group, gdp);\n\n\t/*\n\t * We can allocate memory for mb_alloc based on the new group\n\t * descriptor\n\t */\n\terr = ext4_mb_add_groupinfo(sb, input->group, gdp);\n\tif (err) {\n\t\text4_mb_put_buddy_cache_lock(sb, input->group, num_grp_locked);\n\t\tgoto exit_journal;\n\t}\n\n\t/*\n\t * Make the new blocks and inodes valid next.  We do this before\n\t * increasing the group count so that once the group is enabled,\n\t * all of its blocks and inodes are already valid.\n\t *\n\t * We always allocate group-by-group, then block-by-block or\n\t * inode-by-inode within a group, so enabling these\n\t * blocks/inodes before the group is live won't actually let us\n\t * allocate the new space yet.\n\t */\n\text4_blocks_count_set(es, ext4_blocks_count(es) +\n\t\tinput->blocks_count);\n\tle32_add_cpu(&es->s_inodes_count, EXT4_INODES_PER_GROUP(sb));\n\n\t/*\n\t * We need to protect s_groups_count against other CPUs seeing\n\t * inconsistent state in the superblock.\n\t *\n\t * The precise rules we use are:\n\t *\n\t * * Writers of s_groups_count *must* hold lock_super\n\t * AND\n\t * * Writers must perform a smp_wmb() after updating all dependent\n\t *   data and before modifying the groups count\n\t *\n\t * * Readers must hold lock_super() over the access\n\t * OR\n\t * * Readers must perform an smp_rmb() after reading the groups count\n\t *   and before reading any dependent data.\n\t *\n\t * NB. These rules can be relaxed when checking the group count\n\t * while freeing data, as we can only allocate from a block\n\t * group after serialising against the group count, and we can\n\t * only then free after serialising in turn against that\n\t * allocation.\n\t */\n\tsmp_wmb();\n\n\t/* Update the global fs size fields */\n\tsbi->s_groups_count++;\n\text4_mb_put_buddy_cache_lock(sb, input->group, num_grp_locked);\n\n\text4_handle_dirty_metadata(handle, NULL, primary);\n\n\t/* Update the reserved block counts only once the new group is\n\t * active. */\n\text4_r_blocks_count_set(es, ext4_r_blocks_count(es) +\n\t\tinput->reserved_blocks);\n\n\t/* Update the free space counts */\n\tpercpu_counter_add(&sbi->s_freeblocks_counter,\n\t\t\t   input->free_blocks_count);\n\tpercpu_counter_add(&sbi->s_freeinodes_counter,\n\t\t\t   EXT4_INODES_PER_GROUP(sb));\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG)) {\n\t\text4_group_t flex_group;\n\t\tflex_group = ext4_flex_group(sbi, input->group);\n\t\tsbi->s_flex_groups[flex_group].free_blocks +=\n\t\t\tinput->free_blocks_count;\n\t\tsbi->s_flex_groups[flex_group].free_inodes +=\n\t\t\tEXT4_INODES_PER_GROUP(sb);\n\t}\n\n\text4_handle_dirty_metadata(handle, NULL, sbi->s_sbh);\n\tsb->s_dirt = 1;\n\nexit_journal:\n\tunlock_super(sb);\n\tif ((err2 = ext4_journal_stop(handle)) && !err)\n\t\terr = err2;\n\tif (!err) {\n\t\tupdate_backups(sb, sbi->s_sbh->b_blocknr, (char *)es,\n\t\t\t       sizeof(struct ext4_super_block));\n\t\tupdate_backups(sb, primary->b_blocknr, primary->b_data,\n\t\t\t       primary->b_size);\n\t}\nexit_put:\n\tiput(inode);\n\treturn err;\n} /* ext4_group_add */",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148731,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int ssl3_read_bytes(SSL *s, int type, int *recvd_type, unsigned char *buf,\n                    int len, int peek)\n{\n    int al, i, j, ret;\n    unsigned int n, curr_rec, num_recs, read_bytes;\n    SSL3_RECORD *rr;\n    SSL3_BUFFER *rbuf;\n    void (*cb) (const SSL *ssl, int type2, int val) = NULL;\n\n    rbuf = &s->rlayer.rbuf;\n\n    if (!SSL3_BUFFER_is_initialised(rbuf)) {\n        /* Not initialized yet */\n        if (!ssl3_setup_read_buffer(s))\n            return (-1);\n    }\n\n    if ((type && (type != SSL3_RT_APPLICATION_DATA)\n         && (type != SSL3_RT_HANDSHAKE)) || (peek\n                                             && (type !=\n                                                 SSL3_RT_APPLICATION_DATA))) {\n        SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n\n    if ((type == SSL3_RT_HANDSHAKE) && (s->rlayer.handshake_fragment_len > 0))\n        /* (partially) satisfy request from storage */\n    {\n        unsigned char *src = s->rlayer.handshake_fragment;\n        unsigned char *dst = buf;\n        unsigned int k;\n\n        /* peek == 0 */\n        n = 0;\n        while ((len > 0) && (s->rlayer.handshake_fragment_len > 0)) {\n            *dst++ = *src++;\n            len--;\n            s->rlayer.handshake_fragment_len--;\n            n++;\n        }\n        /* move any remaining fragment bytes: */\n        for (k = 0; k < s->rlayer.handshake_fragment_len; k++)\n            s->rlayer.handshake_fragment[k] = *src++;\n\n        if (recvd_type != NULL)\n            *recvd_type = SSL3_RT_HANDSHAKE;\n\n        return n;\n    }\n\n    /*\n     * Now s->rlayer.handshake_fragment_len == 0 if type == SSL3_RT_HANDSHAKE.\n     */\n\n    if (!ossl_statem_get_in_handshake(s) && SSL_in_init(s)) {\n        /* type == SSL3_RT_APPLICATION_DATA */\n        i = s->handshake_func(s);\n        if (i < 0)\n            return (i);\n        if (i == 0) {\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n            return (-1);\n        }\n    }\n start:\n    s->rwstate = SSL_NOTHING;\n\n    /*-\n     * For each record 'i' up to |num_recs]\n     * rr[i].type     - is the type of record\n     * rr[i].data,    - data\n     * rr[i].off,     - offset into 'data' for next read\n     * rr[i].length,  - number of bytes.\n     */\n    rr = s->rlayer.rrec;\n    num_recs = RECORD_LAYER_get_numrpipes(&s->rlayer);\n\n    do {\n        /* get new records if necessary */\n        if (num_recs == 0) {\n            ret = ssl3_get_record(s);\n            if (ret <= 0)\n                return (ret);\n            num_recs = RECORD_LAYER_get_numrpipes(&s->rlayer);\n            if (num_recs == 0) {\n                /* Shouldn't happen */\n                al = SSL_AD_INTERNAL_ERROR;\n                SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n                goto f_err;\n            }\n        }\n        /* Skip over any records we have already read */\n        for (curr_rec = 0;\n             curr_rec < num_recs && SSL3_RECORD_is_read(&rr[curr_rec]);\n             curr_rec++) ;\n        if (curr_rec == num_recs) {\n            RECORD_LAYER_set_numrpipes(&s->rlayer, 0);\n            num_recs = 0;\n            curr_rec = 0;\n        }\n    } while (num_recs == 0);\n    rr = &rr[curr_rec];\n\n    /*\n     * Reset the count of consecutive warning alerts if we've got a non-empty\n     * record that isn't an alert.\n     */\n    if (SSL3_RECORD_get_type(rr) != SSL3_RT_ALERT\n            && SSL3_RECORD_get_length(rr) != 0)\n        s->rlayer.alert_count = 0;\n\n    /* we now have a packet which can be read and processed */\n\n    if (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,\n                                   * reset by ssl3_get_finished */\n        && (SSL3_RECORD_get_type(rr) != SSL3_RT_HANDSHAKE)) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_DATA_BETWEEN_CCS_AND_FINISHED);\n        goto f_err;\n    }\n\n    /*\n     * If the other end has shut down, throw anything we read away (even in\n     * 'peek' mode)\n     */\n    if (s->shutdown & SSL_RECEIVED_SHUTDOWN) {\n        SSL3_RECORD_set_length(rr, 0);\n        s->rwstate = SSL_NOTHING;\n        return (0);\n    }\n\n    if (type == SSL3_RECORD_get_type(rr)\n        || (SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC\n            && type == SSL3_RT_HANDSHAKE && recvd_type != NULL)) {\n        /*\n         * SSL3_RT_APPLICATION_DATA or\n         * SSL3_RT_HANDSHAKE or\n         * SSL3_RT_CHANGE_CIPHER_SPEC\n         */\n        /*\n         * make sure that we are not getting application data when we are\n         * doing a handshake for the first time\n         */\n        if (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&\n            (s->enc_read_ctx == NULL)) {\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_APP_DATA_IN_HANDSHAKE);\n            goto f_err;\n        }\n\n        if (type == SSL3_RT_HANDSHAKE\n            && SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC\n            && s->rlayer.handshake_fragment_len > 0) {\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY);\n            goto f_err;\n        }\n\n        if (recvd_type != NULL)\n            *recvd_type = SSL3_RECORD_get_type(rr);\n\n        if (len <= 0)\n            return (len);\n\n        read_bytes = 0;\n        do {\n            if ((unsigned int)len - read_bytes > SSL3_RECORD_get_length(rr))\n                n = SSL3_RECORD_get_length(rr);\n            else\n                n = (unsigned int)len - read_bytes;\n\n            memcpy(buf, &(rr->data[rr->off]), n);\n            buf += n;\n            if (!peek) {\n                SSL3_RECORD_sub_length(rr, n);\n                SSL3_RECORD_add_off(rr, n);\n                if (SSL3_RECORD_get_length(rr) == 0) {\n                    s->rlayer.rstate = SSL_ST_READ_HEADER;\n                    SSL3_RECORD_set_off(rr, 0);\n                    SSL3_RECORD_set_read(rr);\n                }\n            }\n            if (SSL3_RECORD_get_length(rr) == 0\n                || (peek && n == SSL3_RECORD_get_length(rr))) {\n                curr_rec++;\n                rr++;\n            }\n            read_bytes += n;\n        } while (type == SSL3_RT_APPLICATION_DATA && curr_rec < num_recs\n                 && read_bytes < (unsigned int)len);\n        if (read_bytes == 0) {\n            /* We must have read empty records. Get more data */\n            goto start;\n        }\n        if (!peek && curr_rec == num_recs\n            && (s->mode & SSL_MODE_RELEASE_BUFFERS)\n            && SSL3_BUFFER_get_left(rbuf) == 0)\n            ssl3_release_read_buffer(s);\n        return read_bytes;\n    }\n\n    /*\n     * If we get here, then type != rr->type; if we have a handshake message,\n     * then it was unexpected (Hello Request or Client Hello) or invalid (we\n     * were actually expecting a CCS).\n     */\n\n    /*\n     * Lets just double check that we've not got an SSLv2 record\n     */\n    if (rr->rec_version == SSL2_VERSION) {\n        /*\n         * Should never happen. ssl3_get_record() should only give us an SSLv2\n         * record back if this is the first packet and we are looking for an\n         * initial ClientHello. Therefore |type| should always be equal to\n         * |rr->type|. If not then something has gone horribly wrong\n         */\n        al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n        goto f_err;\n    }\n\n    if (s->method->version == TLS_ANY_VERSION\n        && (s->server || rr->type != SSL3_RT_ALERT)) {\n        /*\n         * If we've got this far and still haven't decided on what version\n         * we're using then this must be a client side alert we're dealing with\n         * (we don't allow heartbeats yet). We shouldn't be receiving anything\n         * other than a ClientHello if we are a server.\n         */\n        s->version = rr->rec_version;\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_MESSAGE);\n        goto f_err;\n    }\n\n    /*\n     * In case of record types for which we have 'fragment' storage, fill\n     * that so that we can process the data at a fixed place.\n     */\n    {\n        unsigned int dest_maxlen = 0;\n        unsigned char *dest = NULL;\n        unsigned int *dest_len = NULL;\n\n        if (SSL3_RECORD_get_type(rr) == SSL3_RT_HANDSHAKE) {\n            dest_maxlen = sizeof s->rlayer.handshake_fragment;\n            dest = s->rlayer.handshake_fragment;\n            dest_len = &s->rlayer.handshake_fragment_len;\n        } else if (SSL3_RECORD_get_type(rr) == SSL3_RT_ALERT) {\n            dest_maxlen = sizeof s->rlayer.alert_fragment;\n            dest = s->rlayer.alert_fragment;\n            dest_len = &s->rlayer.alert_fragment_len;\n        }\n\n        if (dest_maxlen > 0) {\n            n = dest_maxlen - *dest_len; /* available space in 'dest' */\n            if (SSL3_RECORD_get_length(rr) < n)\n                n = SSL3_RECORD_get_length(rr); /* available bytes */\n\n            /* now move 'n' bytes: */\n            while (n-- > 0) {\n                dest[(*dest_len)++] =\n                    SSL3_RECORD_get_data(rr)[SSL3_RECORD_get_off(rr)];\n                SSL3_RECORD_add_off(rr, 1);\n                SSL3_RECORD_add_length(rr, -1);\n            }\n\n            if (*dest_len < dest_maxlen) {\n                SSL3_RECORD_set_read(rr);\n                goto start;     /* fragment was too small */\n            }\n        }\n    }\n\n    /*-\n     * s->rlayer.handshake_fragment_len == 4  iff  rr->type == SSL3_RT_HANDSHAKE;\n     * s->rlayer.alert_fragment_len == 2      iff  rr->type == SSL3_RT_ALERT.\n     * (Possibly rr is 'empty' now, i.e. rr->length may be 0.)\n     */\n\n    /* If we are a client, check for an incoming 'Hello Request': */\n    if ((!s->server) &&\n        (s->rlayer.handshake_fragment_len >= 4) &&\n        (s->rlayer.handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&\n        (s->session != NULL) && (s->session->cipher != NULL)) {\n        s->rlayer.handshake_fragment_len = 0;\n\n        if ((s->rlayer.handshake_fragment[1] != 0) ||\n            (s->rlayer.handshake_fragment[2] != 0) ||\n            (s->rlayer.handshake_fragment[3] != 0)) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_BAD_HELLO_REQUEST);\n            goto f_err;\n        }\n\n        if (s->msg_callback)\n            s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,\n                            s->rlayer.handshake_fragment, 4, s,\n                            s->msg_callback_arg);\n\n        if (SSL_is_init_finished(s) &&\n            !(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&\n            !s->s3->renegotiate) {\n            ssl3_renegotiate(s);\n            if (ssl3_renegotiate_check(s)) {\n                i = s->handshake_func(s);\n                if (i < 0)\n                    return (i);\n                if (i == 0) {\n                    SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n                    return (-1);\n                }\n\n                if (!(s->mode & SSL_MODE_AUTO_RETRY)) {\n                    if (SSL3_BUFFER_get_left(rbuf) == 0) {\n                        /* no read-ahead left? */\n                        BIO *bio;\n                        /*\n                         * In the case where we try to read application data,\n                         * but we trigger an SSL handshake, we return -1 with\n                         * the retry option set.  Otherwise renegotiation may\n                         * cause nasty problems in the blocking world\n                         */\n                        s->rwstate = SSL_READING;\n                        bio = SSL_get_rbio(s);\n                        BIO_clear_retry_flags(bio);\n                        BIO_set_retry_read(bio);\n                        return (-1);\n                    }\n                }\n            }\n        }\n        /*\n         * we either finished a handshake or ignored the request, now try\n         * again to obtain the (application) data we were asked for\n         */\n        goto start;\n    }\n    /*\n     * If we are a server and get a client hello when renegotiation isn't\n     * allowed send back a no renegotiation alert and carry on. WARNING:\n     * experimental code, needs reviewing (steve)\n     */\n    if (s->server &&\n        SSL_is_init_finished(s) &&\n        !s->s3->send_connection_binding &&\n        (s->version > SSL3_VERSION) &&\n        (s->rlayer.handshake_fragment_len >= 4) &&\n        (s->rlayer.handshake_fragment[0] == SSL3_MT_CLIENT_HELLO) &&\n        (s->session != NULL) && (s->session->cipher != NULL) &&\n        !(s->ctx->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {\n        SSL3_RECORD_set_length(rr, 0);\n        SSL3_RECORD_set_read(rr);\n        ssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_RENEGOTIATION);\n        goto start;\n    }\n    if (s->rlayer.alert_fragment_len >= 2) {\n        int alert_level = s->rlayer.alert_fragment[0];\n        int alert_descr = s->rlayer.alert_fragment[1];\n\n        s->rlayer.alert_fragment_len = 0;\n\n        if (s->msg_callback)\n            s->msg_callback(0, s->version, SSL3_RT_ALERT,\n                            s->rlayer.alert_fragment, 2, s,\n                            s->msg_callback_arg);\n\n        if (s->info_callback != NULL)\n            cb = s->info_callback;\n        else if (s->ctx->info_callback != NULL)\n            cb = s->ctx->info_callback;\n\n        if (cb != NULL) {\n            j = (alert_level << 8) | alert_descr;\n            cb(s, SSL_CB_READ_ALERT, j);\n        }\n\n        if (alert_level == SSL3_AL_WARNING) {\n            s->s3->warn_alert = alert_descr;\n            SSL3_RECORD_set_read(rr);\n\n            s->rlayer.alert_count++;\n            if (s->rlayer.alert_count == MAX_WARN_ALERT_COUNT) {\n                al = SSL_AD_UNEXPECTED_MESSAGE;\n                SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_TOO_MANY_WARN_ALERTS);\n                goto f_err;\n            }\n\n            if (alert_descr == SSL_AD_CLOSE_NOTIFY) {\n                s->shutdown |= SSL_RECEIVED_SHUTDOWN;\n                return (0);\n            }\n            /*\n             * This is a warning but we receive it if we requested\n             * renegotiation and the peer denied it. Terminate with a fatal\n             * alert because if application tried to renegotiate it\n             * presumably had a good reason and expects it to succeed. In\n             * future we might have a renegotiation where we don't care if\n             * the peer refused it where we carry on.\n             */\n            else if (alert_descr == SSL_AD_NO_RENEGOTIATION) {\n                al = SSL_AD_HANDSHAKE_FAILURE;\n                SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_NO_RENEGOTIATION);\n                goto f_err;\n            }\n#ifdef SSL_AD_MISSING_SRP_USERNAME\n            else if (alert_descr == SSL_AD_MISSING_SRP_USERNAME)\n                return (0);\n#endif\n        } else if (alert_level == SSL3_AL_FATAL) {\n            char tmp[16];\n\n            s->rwstate = SSL_NOTHING;\n            s->s3->fatal_alert = alert_descr;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_AD_REASON_OFFSET + alert_descr);\n            BIO_snprintf(tmp, sizeof tmp, \"%d\", alert_descr);\n            ERR_add_error_data(2, \"SSL alert number \", tmp);\n            s->shutdown |= SSL_RECEIVED_SHUTDOWN;\n            SSL3_RECORD_set_read(rr);\n            SSL_CTX_remove_session(s->session_ctx, s->session);\n            return (0);\n        } else {\n            al = SSL_AD_ILLEGAL_PARAMETER;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNKNOWN_ALERT_TYPE);\n            goto f_err;\n        }\n\n        goto start;\n    }\n\n    if (s->shutdown & SSL_SENT_SHUTDOWN) { /* but we have not received a\n                                            * shutdown */\n        s->rwstate = SSL_NOTHING;\n        SSL3_RECORD_set_length(rr, 0);\n        SSL3_RECORD_set_read(rr);\n        return (0);\n    }\n\n    if (SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY);\n        goto f_err;\n    }\n\n    /*\n     * Unexpected handshake message (Client Hello, or protocol violation)\n     */\n    if ((s->rlayer.handshake_fragment_len >= 4)\n        && !ossl_statem_get_in_handshake(s)) {\n        if (SSL_is_init_finished(s) &&\n            !(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)) {\n            ossl_statem_set_in_init(s, 1);\n            s->renegotiate = 1;\n            s->new_session = 1;\n        }\n        i = s->handshake_func(s);\n        if (i < 0)\n            return (i);\n        if (i == 0) {\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n            return (-1);\n        }\n\n        if (!(s->mode & SSL_MODE_AUTO_RETRY)) {\n            if (SSL3_BUFFER_get_left(rbuf) == 0) {\n                /* no read-ahead left? */\n                BIO *bio;\n                /*\n                 * In the case where we try to read application data, but we\n                 * trigger an SSL handshake, we return -1 with the retry\n                 * option set.  Otherwise renegotiation may cause nasty\n                 * problems in the blocking world\n                 */\n                s->rwstate = SSL_READING;\n                bio = SSL_get_rbio(s);\n                BIO_clear_retry_flags(bio);\n                BIO_set_retry_read(bio);\n                return (-1);\n            }\n        }\n        goto start;\n    }\n\n    switch (SSL3_RECORD_get_type(rr)) {\n    default:\n        /*\n         * TLS up to v1.1 just ignores unknown message types: TLS v1.2 give\n         * an unexpected message alert.\n         */\n        if (s->version >= TLS1_VERSION && s->version <= TLS1_1_VERSION) {\n            SSL3_RECORD_set_length(rr, 0);\n            SSL3_RECORD_set_read(rr);\n            goto start;\n        }\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_RECORD);\n        goto f_err;\n    case SSL3_RT_CHANGE_CIPHER_SPEC:\n    case SSL3_RT_ALERT:\n    case SSL3_RT_HANDSHAKE:\n        /*\n         * we already handled all of these, with the possible exception of\n         * SSL3_RT_HANDSHAKE when ossl_statem_get_in_handshake(s) is true, but\n         * that should not happen when type != rr->type\n         */\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n        goto f_err;\n    case SSL3_RT_APPLICATION_DATA:\n        /*\n         * At this point, we were expecting handshake data, but have\n         * application data.  If the library was running inside ssl3_read()\n         * (i.e. in_read_app_data is set) and it makes sense to read\n         * application data at this point (session renegotiation not yet\n         * started), we will indulge it.\n         */\n        if (ossl_statem_app_data_allowed(s)) {\n            s->s3->in_read_app_data = 2;\n            return (-1);\n        } else {\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_RECORD);\n            goto f_err;\n        }\n    }\n    /* not reached */\n\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    return (-1);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148748,
    "reason": "While peaking, a zero-length record might never get marked as \u201cread.\u201d That could result in the library looping indefinitely on the same record or other unintended behavior.",
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int ssl3_read_bytes(SSL *s, int type, int *recvd_type, unsigned char *buf,\n                    int len, int peek)\n{\n    int al, i, j, ret;\n    unsigned int n, curr_rec, num_recs, read_bytes;\n    SSL3_RECORD *rr;\n    SSL3_BUFFER *rbuf;\n    void (*cb) (const SSL *ssl, int type2, int val) = NULL;\n\n    rbuf = &s->rlayer.rbuf;\n\n    if (!SSL3_BUFFER_is_initialised(rbuf)) {\n        /* Not initialized yet */\n        if (!ssl3_setup_read_buffer(s))\n            return (-1);\n    }\n\n    if ((type && (type != SSL3_RT_APPLICATION_DATA)\n         && (type != SSL3_RT_HANDSHAKE)) || (peek\n                                             && (type !=\n                                                 SSL3_RT_APPLICATION_DATA))) {\n        SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n\n    if ((type == SSL3_RT_HANDSHAKE) && (s->rlayer.handshake_fragment_len > 0))\n        /* (partially) satisfy request from storage */\n    {\n        unsigned char *src = s->rlayer.handshake_fragment;\n        unsigned char *dst = buf;\n        unsigned int k;\n\n        /* peek == 0 */\n        n = 0;\n        while ((len > 0) && (s->rlayer.handshake_fragment_len > 0)) {\n            *dst++ = *src++;\n            len--;\n            s->rlayer.handshake_fragment_len--;\n            n++;\n        }\n        /* move any remaining fragment bytes: */\n        for (k = 0; k < s->rlayer.handshake_fragment_len; k++)\n            s->rlayer.handshake_fragment[k] = *src++;\n\n        if (recvd_type != NULL)\n            *recvd_type = SSL3_RT_HANDSHAKE;\n\n        return n;\n    }\n\n    /*\n     * Now s->rlayer.handshake_fragment_len == 0 if type == SSL3_RT_HANDSHAKE.\n     */\n\n    if (!ossl_statem_get_in_handshake(s) && SSL_in_init(s)) {\n        /* type == SSL3_RT_APPLICATION_DATA */\n        i = s->handshake_func(s);\n        if (i < 0)\n            return (i);\n        if (i == 0) {\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n            return (-1);\n        }\n    }\n start:\n    s->rwstate = SSL_NOTHING;\n\n    /*-\n     * For each record 'i' up to |num_recs]\n     * rr[i].type     - is the type of record\n     * rr[i].data,    - data\n     * rr[i].off,     - offset into 'data' for next read\n     * rr[i].length,  - number of bytes.\n     */\n    rr = s->rlayer.rrec;\n    num_recs = RECORD_LAYER_get_numrpipes(&s->rlayer);\n\n    do {\n        /* get new records if necessary */\n        if (num_recs == 0) {\n            ret = ssl3_get_record(s);\n            if (ret <= 0)\n                return (ret);\n            num_recs = RECORD_LAYER_get_numrpipes(&s->rlayer);\n            if (num_recs == 0) {\n                /* Shouldn't happen */\n                al = SSL_AD_INTERNAL_ERROR;\n                SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n                goto f_err;\n            }\n        }\n        /* Skip over any records we have already read */\n        for (curr_rec = 0;\n             curr_rec < num_recs && SSL3_RECORD_is_read(&rr[curr_rec]);\n             curr_rec++) ;\n        if (curr_rec == num_recs) {\n            RECORD_LAYER_set_numrpipes(&s->rlayer, 0);\n            num_recs = 0;\n            curr_rec = 0;\n        }\n    } while (num_recs == 0);\n    rr = &rr[curr_rec];\n\n    /*\n     * Reset the count of consecutive warning alerts if we've got a non-empty\n     * record that isn't an alert.\n     */\n    if (SSL3_RECORD_get_type(rr) != SSL3_RT_ALERT\n            && SSL3_RECORD_get_length(rr) != 0)\n        s->rlayer.alert_count = 0;\n\n    /* we now have a packet which can be read and processed */\n\n    if (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,\n                                   * reset by ssl3_get_finished */\n        && (SSL3_RECORD_get_type(rr) != SSL3_RT_HANDSHAKE)) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_DATA_BETWEEN_CCS_AND_FINISHED);\n        goto f_err;\n    }\n\n    /*\n     * If the other end has shut down, throw anything we read away (even in\n     * 'peek' mode)\n     */\n    if (s->shutdown & SSL_RECEIVED_SHUTDOWN) {\n        SSL3_RECORD_set_length(rr, 0);\n        s->rwstate = SSL_NOTHING;\n        return (0);\n    }\n\n    if (type == SSL3_RECORD_get_type(rr)\n        || (SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC\n            && type == SSL3_RT_HANDSHAKE && recvd_type != NULL)) {\n        /*\n         * SSL3_RT_APPLICATION_DATA or\n         * SSL3_RT_HANDSHAKE or\n         * SSL3_RT_CHANGE_CIPHER_SPEC\n         */\n        /*\n         * make sure that we are not getting application data when we are\n         * doing a handshake for the first time\n         */\n        if (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&\n            (s->enc_read_ctx == NULL)) {\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_APP_DATA_IN_HANDSHAKE);\n            goto f_err;\n        }\n\n        if (type == SSL3_RT_HANDSHAKE\n            && SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC\n            && s->rlayer.handshake_fragment_len > 0) {\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY);\n            goto f_err;\n        }\n\n        if (recvd_type != NULL)\n            *recvd_type = SSL3_RECORD_get_type(rr);\n\n        if (len <= 0)\n            return (len);\n\n        read_bytes = 0;\n        do {\n            if ((unsigned int)len - read_bytes > SSL3_RECORD_get_length(rr))\n                n = SSL3_RECORD_get_length(rr);\n            else\n                n = (unsigned int)len - read_bytes;\n\n            memcpy(buf, &(rr->data[rr->off]), n);\n            buf += n;\n            if (peek) {\n                /* Mark any zero length record as consumed CVE-2016-6305 */\n                if (SSL3_RECORD_get_length(rr) == 0)\n                    SSL3_RECORD_set_read(rr);\n            } else {\n                SSL3_RECORD_sub_length(rr, n);\n                SSL3_RECORD_add_off(rr, n);\n                if (SSL3_RECORD_get_length(rr) == 0) {\n                    s->rlayer.rstate = SSL_ST_READ_HEADER;\n                    SSL3_RECORD_set_off(rr, 0);\n                    SSL3_RECORD_set_read(rr);\n                }\n            }\n            if (SSL3_RECORD_get_length(rr) == 0\n                || (peek && n == SSL3_RECORD_get_length(rr))) {\n                curr_rec++;\n                rr++;\n            }\n            read_bytes += n;\n        } while (type == SSL3_RT_APPLICATION_DATA && curr_rec < num_recs\n                 && read_bytes < (unsigned int)len);\n        if (read_bytes == 0) {\n            /* We must have read empty records. Get more data */\n            goto start;\n        }\n        if (!peek && curr_rec == num_recs\n            && (s->mode & SSL_MODE_RELEASE_BUFFERS)\n            && SSL3_BUFFER_get_left(rbuf) == 0)\n            ssl3_release_read_buffer(s);\n        return read_bytes;\n    }\n\n    /*\n     * If we get here, then type != rr->type; if we have a handshake message,\n     * then it was unexpected (Hello Request or Client Hello) or invalid (we\n     * were actually expecting a CCS).\n     */\n\n    /*\n     * Lets just double check that we've not got an SSLv2 record\n     */\n    if (rr->rec_version == SSL2_VERSION) {\n        /*\n         * Should never happen. ssl3_get_record() should only give us an SSLv2\n         * record back if this is the first packet and we are looking for an\n         * initial ClientHello. Therefore |type| should always be equal to\n         * |rr->type|. If not then something has gone horribly wrong\n         */\n        al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n        goto f_err;\n    }\n\n    if (s->method->version == TLS_ANY_VERSION\n        && (s->server || rr->type != SSL3_RT_ALERT)) {\n        /*\n         * If we've got this far and still haven't decided on what version\n         * we're using then this must be a client side alert we're dealing with\n         * (we don't allow heartbeats yet). We shouldn't be receiving anything\n         * other than a ClientHello if we are a server.\n         */\n        s->version = rr->rec_version;\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_MESSAGE);\n        goto f_err;\n    }\n\n    /*\n     * In case of record types for which we have 'fragment' storage, fill\n     * that so that we can process the data at a fixed place.\n     */\n    {\n        unsigned int dest_maxlen = 0;\n        unsigned char *dest = NULL;\n        unsigned int *dest_len = NULL;\n\n        if (SSL3_RECORD_get_type(rr) == SSL3_RT_HANDSHAKE) {\n            dest_maxlen = sizeof s->rlayer.handshake_fragment;\n            dest = s->rlayer.handshake_fragment;\n            dest_len = &s->rlayer.handshake_fragment_len;\n        } else if (SSL3_RECORD_get_type(rr) == SSL3_RT_ALERT) {\n            dest_maxlen = sizeof s->rlayer.alert_fragment;\n            dest = s->rlayer.alert_fragment;\n            dest_len = &s->rlayer.alert_fragment_len;\n        }\n\n        if (dest_maxlen > 0) {\n            n = dest_maxlen - *dest_len; /* available space in 'dest' */\n            if (SSL3_RECORD_get_length(rr) < n)\n                n = SSL3_RECORD_get_length(rr); /* available bytes */\n\n            /* now move 'n' bytes: */\n            while (n-- > 0) {\n                dest[(*dest_len)++] =\n                    SSL3_RECORD_get_data(rr)[SSL3_RECORD_get_off(rr)];\n                SSL3_RECORD_add_off(rr, 1);\n                SSL3_RECORD_add_length(rr, -1);\n            }\n\n            if (*dest_len < dest_maxlen) {\n                SSL3_RECORD_set_read(rr);\n                goto start;     /* fragment was too small */\n            }\n        }\n    }\n\n    /*-\n     * s->rlayer.handshake_fragment_len == 4  iff  rr->type == SSL3_RT_HANDSHAKE;\n     * s->rlayer.alert_fragment_len == 2      iff  rr->type == SSL3_RT_ALERT.\n     * (Possibly rr is 'empty' now, i.e. rr->length may be 0.)\n     */\n\n    /* If we are a client, check for an incoming 'Hello Request': */\n    if ((!s->server) &&\n        (s->rlayer.handshake_fragment_len >= 4) &&\n        (s->rlayer.handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&\n        (s->session != NULL) && (s->session->cipher != NULL)) {\n        s->rlayer.handshake_fragment_len = 0;\n\n        if ((s->rlayer.handshake_fragment[1] != 0) ||\n            (s->rlayer.handshake_fragment[2] != 0) ||\n            (s->rlayer.handshake_fragment[3] != 0)) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_BAD_HELLO_REQUEST);\n            goto f_err;\n        }\n\n        if (s->msg_callback)\n            s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,\n                            s->rlayer.handshake_fragment, 4, s,\n                            s->msg_callback_arg);\n\n        if (SSL_is_init_finished(s) &&\n            !(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&\n            !s->s3->renegotiate) {\n            ssl3_renegotiate(s);\n            if (ssl3_renegotiate_check(s)) {\n                i = s->handshake_func(s);\n                if (i < 0)\n                    return (i);\n                if (i == 0) {\n                    SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n                    return (-1);\n                }\n\n                if (!(s->mode & SSL_MODE_AUTO_RETRY)) {\n                    if (SSL3_BUFFER_get_left(rbuf) == 0) {\n                        /* no read-ahead left? */\n                        BIO *bio;\n                        /*\n                         * In the case where we try to read application data,\n                         * but we trigger an SSL handshake, we return -1 with\n                         * the retry option set.  Otherwise renegotiation may\n                         * cause nasty problems in the blocking world\n                         */\n                        s->rwstate = SSL_READING;\n                        bio = SSL_get_rbio(s);\n                        BIO_clear_retry_flags(bio);\n                        BIO_set_retry_read(bio);\n                        return (-1);\n                    }\n                }\n            }\n        }\n        /*\n         * we either finished a handshake or ignored the request, now try\n         * again to obtain the (application) data we were asked for\n         */\n        goto start;\n    }\n    /*\n     * If we are a server and get a client hello when renegotiation isn't\n     * allowed send back a no renegotiation alert and carry on. WARNING:\n     * experimental code, needs reviewing (steve)\n     */\n    if (s->server &&\n        SSL_is_init_finished(s) &&\n        !s->s3->send_connection_binding &&\n        (s->version > SSL3_VERSION) &&\n        (s->rlayer.handshake_fragment_len >= 4) &&\n        (s->rlayer.handshake_fragment[0] == SSL3_MT_CLIENT_HELLO) &&\n        (s->session != NULL) && (s->session->cipher != NULL) &&\n        !(s->ctx->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {\n        SSL3_RECORD_set_length(rr, 0);\n        SSL3_RECORD_set_read(rr);\n        ssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_RENEGOTIATION);\n        goto start;\n    }\n    if (s->rlayer.alert_fragment_len >= 2) {\n        int alert_level = s->rlayer.alert_fragment[0];\n        int alert_descr = s->rlayer.alert_fragment[1];\n\n        s->rlayer.alert_fragment_len = 0;\n\n        if (s->msg_callback)\n            s->msg_callback(0, s->version, SSL3_RT_ALERT,\n                            s->rlayer.alert_fragment, 2, s,\n                            s->msg_callback_arg);\n\n        if (s->info_callback != NULL)\n            cb = s->info_callback;\n        else if (s->ctx->info_callback != NULL)\n            cb = s->ctx->info_callback;\n\n        if (cb != NULL) {\n            j = (alert_level << 8) | alert_descr;\n            cb(s, SSL_CB_READ_ALERT, j);\n        }\n\n        if (alert_level == SSL3_AL_WARNING) {\n            s->s3->warn_alert = alert_descr;\n            SSL3_RECORD_set_read(rr);\n\n            s->rlayer.alert_count++;\n            if (s->rlayer.alert_count == MAX_WARN_ALERT_COUNT) {\n                al = SSL_AD_UNEXPECTED_MESSAGE;\n                SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_TOO_MANY_WARN_ALERTS);\n                goto f_err;\n            }\n\n            if (alert_descr == SSL_AD_CLOSE_NOTIFY) {\n                s->shutdown |= SSL_RECEIVED_SHUTDOWN;\n                return (0);\n            }\n            /*\n             * This is a warning but we receive it if we requested\n             * renegotiation and the peer denied it. Terminate with a fatal\n             * alert because if application tried to renegotiate it\n             * presumably had a good reason and expects it to succeed. In\n             * future we might have a renegotiation where we don't care if\n             * the peer refused it where we carry on.\n             */\n            else if (alert_descr == SSL_AD_NO_RENEGOTIATION) {\n                al = SSL_AD_HANDSHAKE_FAILURE;\n                SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_NO_RENEGOTIATION);\n                goto f_err;\n            }\n#ifdef SSL_AD_MISSING_SRP_USERNAME\n            else if (alert_descr == SSL_AD_MISSING_SRP_USERNAME)\n                return (0);\n#endif\n        } else if (alert_level == SSL3_AL_FATAL) {\n            char tmp[16];\n\n            s->rwstate = SSL_NOTHING;\n            s->s3->fatal_alert = alert_descr;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_AD_REASON_OFFSET + alert_descr);\n            BIO_snprintf(tmp, sizeof tmp, \"%d\", alert_descr);\n            ERR_add_error_data(2, \"SSL alert number \", tmp);\n            s->shutdown |= SSL_RECEIVED_SHUTDOWN;\n            SSL3_RECORD_set_read(rr);\n            SSL_CTX_remove_session(s->session_ctx, s->session);\n            return (0);\n        } else {\n            al = SSL_AD_ILLEGAL_PARAMETER;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNKNOWN_ALERT_TYPE);\n            goto f_err;\n        }\n\n        goto start;\n    }\n\n    if (s->shutdown & SSL_SENT_SHUTDOWN) { /* but we have not received a\n                                            * shutdown */\n        s->rwstate = SSL_NOTHING;\n        SSL3_RECORD_set_length(rr, 0);\n        SSL3_RECORD_set_read(rr);\n        return (0);\n    }\n\n    if (SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY);\n        goto f_err;\n    }\n\n    /*\n     * Unexpected handshake message (Client Hello, or protocol violation)\n     */\n    if ((s->rlayer.handshake_fragment_len >= 4)\n        && !ossl_statem_get_in_handshake(s)) {\n        if (SSL_is_init_finished(s) &&\n            !(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)) {\n            ossl_statem_set_in_init(s, 1);\n            s->renegotiate = 1;\n            s->new_session = 1;\n        }\n        i = s->handshake_func(s);\n        if (i < 0)\n            return (i);\n        if (i == 0) {\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n            return (-1);\n        }\n\n        if (!(s->mode & SSL_MODE_AUTO_RETRY)) {\n            if (SSL3_BUFFER_get_left(rbuf) == 0) {\n                /* no read-ahead left? */\n                BIO *bio;\n                /*\n                 * In the case where we try to read application data, but we\n                 * trigger an SSL handshake, we return -1 with the retry\n                 * option set.  Otherwise renegotiation may cause nasty\n                 * problems in the blocking world\n                 */\n                s->rwstate = SSL_READING;\n                bio = SSL_get_rbio(s);\n                BIO_clear_retry_flags(bio);\n                BIO_set_retry_read(bio);\n                return (-1);\n            }\n        }\n        goto start;\n    }\n\n    switch (SSL3_RECORD_get_type(rr)) {\n    default:\n        /*\n         * TLS up to v1.1 just ignores unknown message types: TLS v1.2 give\n         * an unexpected message alert.\n         */\n        if (s->version >= TLS1_VERSION && s->version <= TLS1_1_VERSION) {\n            SSL3_RECORD_set_length(rr, 0);\n            SSL3_RECORD_set_read(rr);\n            goto start;\n        }\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_RECORD);\n        goto f_err;\n    case SSL3_RT_CHANGE_CIPHER_SPEC:\n    case SSL3_RT_ALERT:\n    case SSL3_RT_HANDSHAKE:\n        /*\n         * we already handled all of these, with the possible exception of\n         * SSL3_RT_HANDSHAKE when ossl_statem_get_in_handshake(s) is true, but\n         * that should not happen when type != rr->type\n         */\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n        goto f_err;\n    case SSL3_RT_APPLICATION_DATA:\n        /*\n         * At this point, we were expecting handshake data, but have\n         * application data.  If the library was running inside ssl3_read()\n         * (i.e. in_read_app_data is set) and it makes sense to read\n         * application data at this point (session renegotiation not yet\n         * started), we will indulge it.\n         */\n        if (ossl_statem_app_data_allowed(s)) {\n            s->s3->in_read_app_data = 2;\n            return (-1);\n        } else {\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_RECORD);\n            goto f_err;\n        }\n    }\n    /* not reached */\n\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    return (-1);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148749,
    "human": "Incorrect. With CWE-20",
    "reason": "Although the patch adds a check to mark any zero-length record as read even during a peek, there's still no check for long len which may be larger than the buffer size.",
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "\tint lazy_bdecode(char const* start, char const* end, lazy_entry& ret\n\t\t, error_code& ec, int* error_pos, int depth_limit, int item_limit)\n\t{\n\t\tchar const* const orig_start = start;\n\t\tret.clear();\n\t\tif (start == end) return 0;\n\n\t\tstd::vector<lazy_entry*> stack;\n\n\t\tstack.push_back(&ret);\n\t\twhile (start <= end)\n\t\t{\n\t\t\tif (stack.empty()) break; // done!\n\n\t\t\tlazy_entry* top = stack.back();\n\n\t\t\tif (int(stack.size()) > depth_limit) TORRENT_FAIL_BDECODE(bdecode_errors::depth_exceeded);\n\t\t\tif (start >= end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\tchar t = *start;\n\t\t\t++start;\n\t\t\tif (start >= end && t != 'e') TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\n\t\t\tswitch (top->type())\n\t\t\t{\n\t\t\t\tcase lazy_entry::dict_t:\n\t\t\t\t{\n\t\t\t\t\tif (t == 'e')\n\t\t\t\t\t{\n\t\t\t\t\t\ttop->set_end(start);\n\t\t\t\t\t\tstack.pop_back();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!numeric(t)) TORRENT_FAIL_BDECODE(bdecode_errors::expected_string);\n\t\t\t\t\tboost::int64_t len = t - '0';\n\t\t\t\t\tbdecode_errors::error_code_enum e = bdecode_errors::no_error;\n\t\t\t\t\tstart = parse_int(start, end, ':', len, e);\n\t\t\t\t\tif (e)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(e);\n\n\t\t\t\t\tif (start + len + 1 > end)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\n\t\t\t\t\tif (len < 0)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::overflow);\n\n\t\t\t\t\t++start;\n\t\t\t\t\tif (start == end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\t\t\tlazy_entry* ent = top->dict_append(start);\n\t\t\t\t\tif (ent == 0) TORRENT_FAIL_BDECODE(boost::system::errc::not_enough_memory);\n\t\t\t\t\tstart += len;\n\t\t\t\t\tif (start >= end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\t\t\tstack.push_back(ent);\n\t\t\t\t\tt = *start;\n\t\t\t\t\t++start;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase lazy_entry::list_t:\n\t\t\t\t{\n\t\t\t\t\tif (t == 'e')\n\t\t\t\t\t{\n\t\t\t\t\t\ttop->set_end(start);\n\t\t\t\t\t\tstack.pop_back();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tlazy_entry* ent = top->list_append();\n\t\t\t\t\tif (ent == 0) TORRENT_FAIL_BDECODE(boost::system::errc::not_enough_memory);\n\t\t\t\t\tstack.push_back(ent);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault: break;\n\t\t\t}\n\n\t\t\t--item_limit;\n\t\t\tif (item_limit <= 0) TORRENT_FAIL_BDECODE(bdecode_errors::limit_exceeded);\n\n\t\t\ttop = stack.back();\n\t\t\tswitch (t)\n\t\t\t{\n\t\t\t\tcase 'd':\n\t\t\t\t\ttop->construct_dict(start - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 'l':\n\t\t\t\t\ttop->construct_list(start - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 'i':\n\t\t\t\t{\n\t\t\t\t\tchar const* int_start = start;\n\t\t\t\t\tstart = find_char(start, end, 'e');\n\t\t\t\t\ttop->construct_int(int_start, start - int_start);\n\t\t\t\t\tif (start == end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\t\t\tTORRENT_ASSERT(*start == 'e');\n\t\t\t\t\t++start;\n\t\t\t\t\tstack.pop_back();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tif (!numeric(t))\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::expected_value);\n\n\t\t\t\t\tboost::int64_t len = t - '0';\n\t\t\t\t\tbdecode_errors::error_code_enum e = bdecode_errors::no_error;\n\t\t\t\t\tstart = parse_int(start, end, ':', len, e);\n\t\t\t\t\tif (e)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(e);\n\t\t\t\t\tif (start + len + 1 > end)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\t\t\tif (len < 0)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::overflow);\n\n\t\t\t\t\t++start;\n\t\t\t\t\ttop->construct_string(start, int(len));\n\t\t\t\t\tstack.pop_back();\n\t\t\t\t\tstart += len;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\treturn 0;\n\t}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148768,
    "human": "Correct. With CWE-20",
    "Reason": "In the checks for length code part, len can be very large and may couse pointer overflow.",
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "\tint lazy_bdecode(char const* start, char const* end, lazy_entry& ret\n\t\t, error_code& ec, int* error_pos, int depth_limit, int item_limit)\n\t{\n\t\tchar const* const orig_start = start;\n\t\tret.clear();\n\t\tif (start == end) return 0;\n\n\t\tstd::vector<lazy_entry*> stack;\n\n\t\tstack.push_back(&ret);\n\t\twhile (start <= end)\n\t\t{\n\t\t\tif (stack.empty()) break; // done!\n\n\t\t\tlazy_entry* top = stack.back();\n\n\t\t\tif (int(stack.size()) > depth_limit) TORRENT_FAIL_BDECODE(bdecode_errors::depth_exceeded);\n\t\t\tif (start >= end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\tchar t = *start;\n\t\t\t++start;\n\t\t\tif (start >= end && t != 'e') TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\n\t\t\tswitch (top->type())\n\t\t\t{\n\t\t\t\tcase lazy_entry::dict_t:\n\t\t\t\t{\n\t\t\t\t\tif (t == 'e')\n\t\t\t\t\t{\n\t\t\t\t\t\ttop->set_end(start);\n\t\t\t\t\t\tstack.pop_back();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!numeric(t)) TORRENT_FAIL_BDECODE(bdecode_errors::expected_string);\n\t\t\t\t\tboost::int64_t len = t - '0';\n\t\t\t\t\tbdecode_errors::error_code_enum e = bdecode_errors::no_error;\n\t\t\t\t\tstart = parse_int(start, end, ':', len, e);\n\t\t\t\t\tif (e)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(e);\n\n\t\t\t\t\t// remaining buffer size excluding ':'\n\t\t\t\t\tconst ptrdiff_t buff_size = end - start - 1;\n\t\t\t\t\tif (len > buff_size)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\n\t\t\t\t\tif (len < 0)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::overflow);\n\n\t\t\t\t\t++start;\n\t\t\t\t\tif (start == end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\t\t\tlazy_entry* ent = top->dict_append(start);\n\t\t\t\t\tif (ent == 0) TORRENT_FAIL_BDECODE(boost::system::errc::not_enough_memory);\n\t\t\t\t\tstart += len;\n\t\t\t\t\tif (start >= end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\t\t\tstack.push_back(ent);\n\t\t\t\t\tt = *start;\n\t\t\t\t\t++start;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase lazy_entry::list_t:\n\t\t\t\t{\n\t\t\t\t\tif (t == 'e')\n\t\t\t\t\t{\n\t\t\t\t\t\ttop->set_end(start);\n\t\t\t\t\t\tstack.pop_back();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tlazy_entry* ent = top->list_append();\n\t\t\t\t\tif (ent == 0) TORRENT_FAIL_BDECODE(boost::system::errc::not_enough_memory);\n\t\t\t\t\tstack.push_back(ent);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault: break;\n\t\t\t}\n\n\t\t\t--item_limit;\n\t\t\tif (item_limit <= 0) TORRENT_FAIL_BDECODE(bdecode_errors::limit_exceeded);\n\n\t\t\ttop = stack.back();\n\t\t\tswitch (t)\n\t\t\t{\n\t\t\t\tcase 'd':\n\t\t\t\t\ttop->construct_dict(start - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 'l':\n\t\t\t\t\ttop->construct_list(start - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 'i':\n\t\t\t\t{\n\t\t\t\t\tchar const* int_start = start;\n\t\t\t\t\tstart = find_char(start, end, 'e');\n\t\t\t\t\ttop->construct_int(int_start, start - int_start);\n\t\t\t\t\tif (start == end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\t\t\tTORRENT_ASSERT(*start == 'e');\n\t\t\t\t\t++start;\n\t\t\t\t\tstack.pop_back();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tif (!numeric(t))\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::expected_value);\n\n\t\t\t\t\tboost::int64_t len = t - '0';\n\t\t\t\t\tbdecode_errors::error_code_enum e = bdecode_errors::no_error;\n\t\t\t\t\tstart = parse_int(start, end, ':', len, e);\n\t\t\t\t\tif (e)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(e);\n\n\t\t\t\t\t// remaining buffer size excluding ':'\n\t\t\t\t\tconst ptrdiff_t buff_size = end - start - 1;\n\t\t\t\t\tif (len > buff_size)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\t\t\tif (len < 0)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::overflow);\n\n\t\t\t\t\t++start;\n\t\t\t\t\tif (start == end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\t\t\ttop->construct_string(start, int(len));\n\t\t\t\t\tstack.pop_back();\n\t\t\t\t\tstart += len;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\treturn 0;\n\t}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148769,
    "human": "Correct. Without CWE-20",
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "setup_seccomp (FlatpakBwrap   *bwrap,\n               const char     *arch,\n               gulong          allowed_personality,\n               FlatpakRunFlags run_flags,\n               GError        **error)\n{\n  gboolean multiarch = (run_flags & FLATPAK_RUN_FLAG_MULTIARCH) != 0;\n  gboolean devel = (run_flags & FLATPAK_RUN_FLAG_DEVEL) != 0;\n\n  __attribute__((cleanup (cleanup_seccomp))) scmp_filter_ctx seccomp = NULL;\n\n  /**** BEGIN NOTE ON CODE SHARING\n   *\n   * There are today a number of different Linux container\n   * implementations.  That will likely continue for long into the\n   * future.  But we can still try to share code, and it's important\n   * to do so because it affects what library and application writers\n   * can do, and we should support code portability between different\n   * container tools.\n   *\n   * This syscall blocklist is copied from linux-user-chroot, which was in turn\n   * clearly influenced by the Sandstorm.io blocklist.\n   *\n   * If you make any changes here, I suggest sending the changes along\n   * to other sandbox maintainers.  Using the libseccomp list is also\n   * an appropriate venue:\n   * https://groups.google.com/forum/#!forum/libseccomp\n   *\n   * A non-exhaustive list of links to container tooling that might\n   * want to share this blocklist:\n   *\n   *  https://github.com/sandstorm-io/sandstorm\n   *    in src/sandstorm/supervisor.c++\n   *  https://github.com/flatpak/flatpak.git\n   *    in common/flatpak-run.c\n   *  https://git.gnome.org/browse/linux-user-chroot\n   *    in src/setup-seccomp.c\n   *\n   * Other useful resources:\n   * https://github.com/systemd/systemd/blob/HEAD/src/shared/seccomp-util.c\n   * https://github.com/moby/moby/blob/HEAD/profiles/seccomp/default.json\n   *\n   **** END NOTE ON CODE SHARING\n   */\n  struct\n  {\n    int                  scall;\n    int                  errnum;\n    struct scmp_arg_cmp *arg;\n  } syscall_blocklist[] = {\n    /* Block dmesg */\n    {SCMP_SYS (syslog), EPERM},\n    /* Useless old syscall */\n    {SCMP_SYS (uselib), EPERM},\n    /* Don't allow disabling accounting */\n    {SCMP_SYS (acct), EPERM},\n    /* 16-bit code is unnecessary in the sandbox, and modify_ldt is a\n       historic source of interesting information leaks. */\n    {SCMP_SYS (modify_ldt), EPERM},\n    /* Don't allow reading current quota use */\n    {SCMP_SYS (quotactl), EPERM},\n\n    /* Don't allow access to the kernel keyring */\n    {SCMP_SYS (add_key), EPERM},\n    {SCMP_SYS (keyctl), EPERM},\n    {SCMP_SYS (request_key), EPERM},\n\n    /* Scary VM/NUMA ops */\n    {SCMP_SYS (move_pages), EPERM},\n    {SCMP_SYS (mbind), EPERM},\n    {SCMP_SYS (get_mempolicy), EPERM},\n    {SCMP_SYS (set_mempolicy), EPERM},\n    {SCMP_SYS (migrate_pages), EPERM},\n\n    /* Don't allow subnamespace setups: */\n    {SCMP_SYS (unshare), EPERM},\n    {SCMP_SYS (setns), EPERM},\n    {SCMP_SYS (mount), EPERM},\n    {SCMP_SYS (umount), EPERM},\n    {SCMP_SYS (umount2), EPERM},\n    {SCMP_SYS (pivot_root), EPERM},\n    {SCMP_SYS (chroot), EPERM},\n#if defined(__s390__) || defined(__s390x__) || defined(__CRIS__)\n    /* Architectures with CONFIG_CLONE_BACKWARDS2: the child stack\n     * and flags arguments are reversed so the flags come second */\n    {SCMP_SYS (clone), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n#else\n    /* Normally the flags come first */\n    {SCMP_SYS (clone), EPERM, &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n#endif\n\n    /* Don't allow faking input to the controlling tty (CVE-2017-5226) */\n    {SCMP_SYS (ioctl), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)},\n\n    /* seccomp can't look into clone3()'s struct clone_args to check whether\n     * the flags are OK, so we have no choice but to block clone3().\n     * Return ENOSYS so user-space will fall back to clone().\n     * (GHSA-67h7-w3jq-vh4q; see also https://github.com/moby/moby/commit/9f6b562d) */\n    {SCMP_SYS (clone3), ENOSYS},\n\n    /* New mount manipulation APIs can also change our VFS. There's no\n     * legitimate reason to do these in the sandbox, so block all of them\n     * rather than thinking about which ones might be dangerous.\n     * (GHSA-67h7-w3jq-vh4q) */\n    {SCMP_SYS (open_tree), ENOSYS},\n    {SCMP_SYS (move_mount), ENOSYS},\n    {SCMP_SYS (fsopen), ENOSYS},\n    {SCMP_SYS (fsconfig), ENOSYS},\n    {SCMP_SYS (fsmount), ENOSYS},\n    {SCMP_SYS (fspick), ENOSYS},\n    {SCMP_SYS (mount_setattr), ENOSYS},\n  };\n\n  struct\n  {\n    int                  scall;\n    int                  errnum;\n    struct scmp_arg_cmp *arg;\n  } syscall_nondevel_blocklist[] = {\n    /* Profiling operations; we expect these to be done by tools from outside\n     * the sandbox.  In particular perf has been the source of many CVEs.\n     */\n    {SCMP_SYS (perf_event_open), EPERM},\n    /* Don't allow you to switch to bsd emulation or whatnot */\n    {SCMP_SYS (personality), EPERM, &SCMP_A0 (SCMP_CMP_NE, allowed_personality)},\n    {SCMP_SYS (ptrace), EPERM}\n  };\n  /* Blocklist all but unix, inet, inet6 and netlink */\n  struct\n  {\n    int             family;\n    FlatpakRunFlags flags_mask;\n  } socket_family_allowlist[] = {\n    /* NOTE: Keep in numerical order */\n    { AF_UNSPEC, 0 },\n    { AF_LOCAL, 0 },\n    { AF_INET, 0 },\n    { AF_INET6, 0 },\n    { AF_NETLINK, 0 },\n    { AF_CAN, FLATPAK_RUN_FLAG_CANBUS },\n    { AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH },\n  };\n  int last_allowed_family;\n  int i, r;\n  g_auto(GLnxTmpfile) seccomp_tmpf  = { 0, };\n\n  seccomp = seccomp_init (SCMP_ACT_ALLOW);\n  if (!seccomp)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Initialize seccomp failed\"));\n\n  if (arch != NULL)\n    {\n      uint32_t arch_id = 0;\n      const uint32_t *extra_arches = NULL;\n\n      if (strcmp (arch, \"i386\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86;\n        }\n      else if (strcmp (arch, \"x86_64\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86_64;\n          extra_arches = seccomp_x86_64_extra_arches;\n        }\n      else if (strcmp (arch, \"arm\") == 0)\n        {\n          arch_id = SCMP_ARCH_ARM;\n        }\n#ifdef SCMP_ARCH_AARCH64\n      else if (strcmp (arch, \"aarch64\") == 0)\n        {\n          arch_id = SCMP_ARCH_AARCH64;\n          extra_arches = seccomp_aarch64_extra_arches;\n        }\n#endif\n\n      /* We only really need to handle arches on multiarch systems.\n       * If only one arch is supported the default is fine */\n      if (arch_id != 0)\n        {\n          /* This *adds* the target arch, instead of replacing the\n             native one. This is not ideal, because we'd like to only\n             allow the target arch, but we can't really disallow the\n             native arch at this point, because then bubblewrap\n             couldn't continue running. */\n          r = seccomp_arch_add (seccomp, arch_id);\n          if (r < 0 && r != -EEXIST)\n            return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add architecture to seccomp filter\"));\n\n          if (multiarch && extra_arches != NULL)\n            {\n              for (i = 0; extra_arches[i] != 0; i++)\n                {\n                  r = seccomp_arch_add (seccomp, extra_arches[i]);\n                  if (r < 0 && r != -EEXIST)\n                    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add multiarch architecture to seccomp filter\"));\n                }\n            }\n        }\n    }\n\n  /* TODO: Should we filter the kernel keyring syscalls in some way?\n   * We do want them to be used by desktop apps, but they could also perhaps\n   * leak system stuff or secrets from other apps.\n   */\n\n  for (i = 0; i < G_N_ELEMENTS (syscall_blocklist); i++)\n    {\n      int scall = syscall_blocklist[i].scall;\n      int errnum = syscall_blocklist[i].errnum;\n\n      g_return_val_if_fail (errnum == EPERM || errnum == ENOSYS, FALSE);\n\n      if (syscall_blocklist[i].arg)\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_blocklist[i].arg);\n      else\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);\n      if (r < 0 && r == -EFAULT /* unknown syscall */)\n        return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n    }\n\n  if (!devel)\n    {\n      for (i = 0; i < G_N_ELEMENTS (syscall_nondevel_blocklist); i++)\n        {\n          int scall = syscall_nondevel_blocklist[i].scall;\n          int errnum = syscall_nondevel_blocklist[i].errnum;\n\n          g_return_val_if_fail (errnum == EPERM || errnum == ENOSYS, FALSE);\n\n          if (syscall_nondevel_blocklist[i].arg)\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_nondevel_blocklist[i].arg);\n          else\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);\n\n          if (r < 0 && r == -EFAULT /* unknown syscall */)\n            return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n        }\n    }\n\n  /* Socket filtering doesn't work on e.g. i386, so ignore failures here\n   * However, we need to user seccomp_rule_add_exact to avoid libseccomp doing\n   * something else: https://github.com/seccomp/libseccomp/issues/8 */\n  last_allowed_family = -1;\n  for (i = 0; i < G_N_ELEMENTS (socket_family_allowlist); i++)\n    {\n      int family = socket_family_allowlist[i].family;\n      int disallowed;\n\n      if (socket_family_allowlist[i].flags_mask != 0 &&\n          (socket_family_allowlist[i].flags_mask & run_flags) != socket_family_allowlist[i].flags_mask)\n        continue;\n\n      for (disallowed = last_allowed_family + 1; disallowed < family; disallowed++)\n        {\n          /* Blocklist the in-between valid families */\n          seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, disallowed));\n        }\n      last_allowed_family = family;\n    }\n  /* Blocklist the rest */\n  seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE, last_allowed_family + 1));\n\n  if (!glnx_open_anonymous_tmpfile_full (O_RDWR | O_CLOEXEC, \"/tmp\", &seccomp_tmpf, error))\n    return FALSE;\n\n  if (seccomp_export_bpf (seccomp, seccomp_tmpf.fd) != 0)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to export bpf\"));\n\n  lseek (seccomp_tmpf.fd, 0, SEEK_SET);\n\n  flatpak_bwrap_add_args_data_fd (bwrap,\n                                  \"--seccomp\", glnx_steal_fd (&seccomp_tmpf.fd), NULL);\n\n  return TRUE;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 81,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "Status ValidateInputs(const Tensor *a_indices, const Tensor *a_values,\n                      const Tensor *a_shape, const Tensor *b) {\n  if (!TensorShapeUtils::IsMatrix(a_indices->shape())) {\n    return errors::InvalidArgument(\n        \"Input a_indices should be a matrix but received shape: \",\n        a_indices->shape().DebugString());\n  }\n  if (!TensorShapeUtils::IsVector(a_values->shape()) ||\n      !TensorShapeUtils::IsVector(a_shape->shape())) {\n    return errors::InvalidArgument(\n        \"Inputs a_values and a_shape should be vectors \"\n        \"but received shapes: \",\n        a_values->shape().DebugString(), \" and \",\n        a_shape->shape().DebugString());\n  }\n  int64_t nnz = a_indices->dim_size(0);\n  int64_t ndims = a_indices->dim_size(1);\n  if (a_values->dim_size(0) != nnz) {\n    return errors::InvalidArgument(\"Dimensions \", nnz, \" and \",\n                                   a_values->dim_size(0),\n                                   \" are not compatible\");\n  }\n  if (a_shape->dim_size(0) != ndims) {\n    return errors::InvalidArgument(\"Dimensions \", ndims, \" and \",\n                                   a_shape->dim_size(0), \" are not compatible\");\n  }\n  if (a_shape->NumElements() != b->dims()) {\n    return errors::InvalidArgument(\n        \"Two operands have different ranks; received: \", a_shape->NumElements(),\n        \" and \", b->dims());\n  }\n  const auto a_shape_flat = a_shape->flat<Index>();\n  for (int i = 0; i < b->dims(); ++i) {\n    if (a_shape_flat(i) != b->dim_size(i)) {\n      return errors::InvalidArgument(\n          \"Dimension \", i,\n          \" does not equal (no broadcasting is supported): sparse side \",\n          a_shape_flat(i), \" vs dense side \", b->dim_size(i));\n    }\n  }\n\n  // Check for invalid indices.\n  const auto a_indices_mat = a_indices->flat_inner_dims<Index>();\n\n  for (int64_t zidx = 0; zidx < nnz; ++zidx) {\n    for (int64_t didx = 0; didx < ndims; ++didx) {\n      const Index idx = a_indices_mat(zidx, didx);\n      if (idx < 0 || idx >= a_shape_flat(didx)) {\n        return errors::InvalidArgument(\n            \"Sparse tensor has an invalid index on dimension \", didx,\n            \": \"\n            \"a_indices(\",\n            zidx, \",\", didx, \") = \", idx,\n            \", dense tensor shape: \", a_shape_flat);\n      }\n    }\n  }\n\n  return Status::OK();\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 183,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "  void Compute(OpKernelContext* ctx) override {\n    try {\n      const Tensor& input = ctx->input(kInputTensorIndex);\n      OP_REQUIRES(\n          ctx, input.dims() == 4,\n          errors::InvalidArgument(\"Current RequantizePerChannel operator\"\n                                  \"supports 4D tensors only.\"));\n\n      const Tensor& input_min_vec = ctx->input(kInputMinVecIndex);\n      size_t depth = input_min_vec.NumElements();\n      float* input_min_vec_data = (float*)const_cast<void*>(\n          static_cast<const void*>(input_min_vec.flat<float>().data()));\n\n      const Tensor& input_max_vec = ctx->input(kInputMaxVecIndex);\n      OP_REQUIRES(\n          ctx, input_max_vec.NumElements() == depth,\n          errors::InvalidArgument(\"input_max has incorrect size, expected \",\n                                  depth, \" was \", input_max_vec.NumElements()));\n      float* input_max_vec_data = (float*)const_cast<void*>(\n          static_cast<const void*>(input_max_vec.flat<float>().data()));\n\n      const Tensor& input_requested_min = ctx->input(this->kRequestMinIndex);\n      OP_REQUIRES(\n          ctx, input_requested_min.NumElements() == 1,\n          errors::InvalidArgument(\"requested_output_min must be a scalar\"));\n      const float input_requested_min_float =\n          input_requested_min.flat<float>()(0);\n\n      const Tensor& input_requested_max = ctx->input(this->kRequestMaxIndex);\n      OP_REQUIRES(\n          ctx, input_requested_min.NumElements() == 1,\n          errors::InvalidArgument(\"requested_output_max must be a scalar\"));\n      const float input_requested_max_float =\n          input_requested_max.flat<float>()(0);\n\n      if (out_type_ == DT_QINT8) {\n        OP_REQUIRES(ctx, input_requested_min_float < 0.0f,\n                    errors::InvalidArgument(\n                        \"If out_type is QINT8, requested_output_max must be \"\n                        \"non negative, got \",\n                        input_requested_min_float));\n      }\n\n      const float factor = (out_type_ == DT_QINT8) ? 127.0f : 255.0f;\n      const float requested_min_max =\n          std::max(std::abs(input_requested_min_float),\n                   std::abs(input_requested_max_float));\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(kOutputTensorIndex,\n                                               input.shape(), &output));\n\n      std::vector<float> scales(depth);\n      for (int i = 0; i < depth; ++i) {\n        float min_max_from_vec = std::max(std::abs(input_min_vec_data[i]),\n                                          std::abs(input_max_vec_data[i]));\n        scales[i] = factor * (min_max_from_vec / requested_min_max /\n                              static_cast<float>(1L << 31));\n      }\n\n      mkldnn::primitive_attr reorder_attr;\n      reorder_attr.set_output_scales(2, scales);\n\n      memory::dims dims_mkl_order =\n          TFShapeToMklDnnDimsInNCHW(input.shape(), FORMAT_NHWC);\n      memory::desc input_md = memory::desc(dims_mkl_order, MklDnnType<qint32>(),\n                                           memory::format_tag::nhwc);\n      memory::desc output_md =\n          (out_type_ == DT_QINT8)\n              ? memory::desc(dims_mkl_order, MklDnnType<qint8>(),\n                             memory::format_tag::nhwc)\n              : memory::desc(dims_mkl_order, MklDnnType<quint8>(),\n                             memory::format_tag::nhwc);\n\n      void* input_buf =\n          static_cast<void*>(const_cast<qint32*>(input.flat<qint32>().data()));\n      void* output_buf;\n      if (out_type_ == DT_QINT8) {\n        output_buf = static_cast<void*>(\n            const_cast<qint8*>(output->flat<qint8>().data()));\n      } else {\n        output_buf = static_cast<void*>(\n            const_cast<quint8*>(output->flat<quint8>().data()));\n      }\n\n      std::unique_ptr<memory> input_mem_prim(\n          new memory(input_md, cpu_engine_, input_buf));\n      std::unique_ptr<memory> output_mem_prim(\n          new memory(output_md, cpu_engine_, output_buf));\n\n      mkldnn::reorder::primitive_desc reorder_pd =\n          ReorderPd(cpu_engine_, input_mem_prim->get_desc(), cpu_engine_,\n                    output_mem_prim->get_desc(), reorder_attr);\n      std::shared_ptr<stream> reorder_stream;\n      MklDnnThreadPool eigen_tp(ctx);\n      reorder_stream.reset(CreateStream(&eigen_tp, cpu_engine_));\n      std::unordered_map<int, mkldnn::memory> reorder_args = {\n          {MKLDNN_ARG_FROM, *input_mem_prim},\n          {MKLDNN_ARG_TO, *output_mem_prim}};\n      std::unique_ptr<mkldnn::primitive> reorder_prim(\n          new mkldnn::reorder(reorder_pd));\n      reorder_prim->execute(*reorder_stream, reorder_args);\n\n      Tensor* output_min = nullptr;\n      Tensor* output_max = nullptr;\n      OP_REQUIRES_OK(ctx,\n                     ctx->allocate_output(kOutputMinIndex, {}, &output_min));\n      OP_REQUIRES_OK(ctx,\n                     ctx->allocate_output(kOutputMaxIndex, {}, &output_max));\n\n      output_min->flat<float>()(0) = input_requested_min_float;\n      output_max->flat<float>()(0) = input_requested_max_float;\n    } catch (mkldnn::error& e) {\n      string error_msg = \"Status: \" + std::to_string(e.status) +\n                         \", message: \" + std::string(e.message) + \", in file \" +\n                         std::string(__FILE__) + \":\" + std::to_string(__LINE__);\n      OP_REQUIRES_OK(\n          ctx, errors::Aborted(\"Operation received an exception:\", error_msg));\n    }\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 225,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "add_mtab(char *devname, char *mountpoint, unsigned long flags, const char *fstype)\n{\n\tint rc = 0, tmprc, fd;\n\tuid_t uid;\n\tchar *mount_user = NULL;\n\tstruct mntent mountent;\n\tstruct stat statbuf;\n\tFILE *pmntfile;\n\tsigset_t mask, oldmask;\n\n\tuid = getuid();\n\tif (uid != 0)\n\t\tmount_user = getusername(uid);\n\n\t/*\n\t * Set the real uid to the effective uid. This prevents unprivileged\n\t * users from sending signals to this process, though ^c on controlling\n\t * terminal should still work.\n\t */\n\trc = setreuid(geteuid(), -1);\n\tif (rc != 0) {\n\t\tfprintf(stderr, \"Unable to set real uid to effective uid: %s\\n\",\n\t\t\t\tstrerror(errno));\n\t\treturn EX_FILEIO;\n\t}\n\n\trc = sigfillset(&mask);\n\tif (rc) {\n\t\tfprintf(stderr, \"Unable to set filled signal mask\\n\");\n\t\treturn EX_FILEIO;\n\t}\n\n\trc = sigprocmask(SIG_SETMASK, &mask, &oldmask);\n\tif (rc) {\n\t\tfprintf(stderr, \"Unable to make process ignore signals\\n\");\n\t\treturn EX_FILEIO;\n\t}\n\n\trc = toggle_dac_capability(1, 1);\n\tif (rc)\n\t\treturn EX_FILEIO;\n\n\tatexit(unlock_mtab);\n\trc = lock_mtab();\n\tif (rc) {\n\t\tfprintf(stderr, \"cannot lock mtab\");\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\tpmntfile = setmntent(MOUNTED, \"a+\");\n\tif (!pmntfile) {\n\t\tfprintf(stderr, \"could not update mount table\\n\");\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\tfd = fileno(pmntfile);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"mntent does not appear to be valid\\n\");\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\trc = fstat(fd, &statbuf);\n\tif (rc != 0) {\n\t\tfprintf(stderr, \"unable to fstat open mtab\\n\");\n\t\tendmntent(pmntfile);\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\tmountent.mnt_fsname = devname;\n\tmountent.mnt_dir = mountpoint;\n\tmountent.mnt_type = (char *)(void *)fstype;\n\tmountent.mnt_opts = (char *)calloc(MTAB_OPTIONS_LEN, 1);\n\tif (mountent.mnt_opts) {\n\t\tif (flags & MS_RDONLY)\n\t\t\tstrlcat(mountent.mnt_opts, \"ro\", MTAB_OPTIONS_LEN);\n\t\telse\n\t\t\tstrlcat(mountent.mnt_opts, \"rw\", MTAB_OPTIONS_LEN);\n\n\t\tif (flags & MS_MANDLOCK)\n\t\t\tstrlcat(mountent.mnt_opts, \",mand\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NOEXEC)\n\t\t\tstrlcat(mountent.mnt_opts, \",noexec\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NOSUID)\n\t\t\tstrlcat(mountent.mnt_opts, \",nosuid\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NODEV)\n\t\t\tstrlcat(mountent.mnt_opts, \",nodev\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_SYNCHRONOUS)\n\t\t\tstrlcat(mountent.mnt_opts, \",sync\", MTAB_OPTIONS_LEN);\n\t\tif (mount_user) {\n\t\t\tstrlcat(mountent.mnt_opts, \",user=\", MTAB_OPTIONS_LEN);\n\t\t\tstrlcat(mountent.mnt_opts, mount_user,\n\t\t\t\tMTAB_OPTIONS_LEN);\n\t\t}\n\t}\n\tmountent.mnt_freq = 0;\n\tmountent.mnt_passno = 0;\n\trc = addmntent(pmntfile, &mountent);\n\tif (rc) {\n\t\tfprintf(stderr, \"unable to add mount entry to mtab\\n\");\n\t\tftruncate(fd, statbuf.st_size);\n\t\trc = EX_FILEIO;\n\t}\n\ttmprc = my_endmntent(pmntfile, statbuf.st_size);\n\tif (tmprc) {\n\t\tfprintf(stderr, \"error %d detected on close of mtab\\n\", tmprc);\n\t\trc = EX_FILEIO;\n\t}\n\tunlock_mtab();\n\tSAFE_FREE(mountent.mnt_opts);\nadd_mtab_exit:\n\ttoggle_dac_capability(1, 0);\n\tsigprocmask(SIG_SETMASK, &oldmask, NULL);\n\n\treturn rc;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 666,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "cookedprint(\n\tint datatype,\n\tint length,\n\tconst char *data,\n\tint status,\n\tint quiet,\n\tFILE *fp\n\t)\n{\n\tchar *name;\n\tchar *value;\n\tchar output_raw;\n\tint fmt;\n\tl_fp lfp;\n\tsockaddr_u hval;\n\tu_long uval;\n\tint narr;\n\tsize_t len;\n\tl_fp lfparr[8];\n\tchar b[12];\n\tchar bn[2 * MAXVARLEN];\n\tchar bv[2 * MAXVALLEN];\n\n\tUNUSED_ARG(datatype);\n\n\tif (!quiet)\n\t\tfprintf(fp, \"status=%04x %s,\\n\", status,\n\t\t\tstatustoa(datatype, status));\n\n\tstartoutput();\n\twhile (nextvar(&length, &data, &name, &value)) {\n\t\tfmt = varfmt(name);\n\t\toutput_raw = 0;\n\t\tswitch (fmt) {\n\n\t\tcase PADDING:\n\t\t\toutput_raw = '*';\n\t\t\tbreak;\n\n\t\tcase TS:\n\t\t\tif (!decodets(value, &lfp))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutput(fp, name, prettydate(&lfp));\n\t\t\tbreak;\n\n\t\tcase HA:\t/* fallthru */\n\t\tcase NA:\n\t\t\tif (!decodenetnum(value, &hval)) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else if (fmt == HA){\n\t\t\t\toutput(fp, name, nntohost(&hval));\n\t\t\t} else {\n\t\t\t\toutput(fp, name, stoa(&hval));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase RF:\n\t\t\tif (decodenetnum(value, &hval)) {\n\t\t\t\tif (ISREFCLOCKADR(&hval))\n\t\t\t\t\toutput(fp, name,\n\t\t\t\t\t       refnumtoa(&hval));\n\t\t\t\telse\n\t\t\t\t\toutput(fp, name, stoa(&hval));\n\t\t\t} else if (strlen(value) <= 4) {\n\t\t\t\toutput(fp, name, value);\n\t\t\t} else {\n\t\t\t\toutput_raw = '?';\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LP:\n\t\t\tif (!decodeuint(value, &uval) || uval > 3) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else {\n\t\t\t\tb[0] = (0x2 & uval)\n\t\t\t\t\t   ? '1'\n\t\t\t\t\t   : '0';\n\t\t\t\tb[1] = (0x1 & uval)\n\t\t\t\t\t   ? '1'\n\t\t\t\t\t   : '0';\n\t\t\t\tb[2] = '\\0';\n\t\t\t\toutput(fp, name, b);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OC:\n\t\t\tif (!decodeuint(value, &uval)) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else {\n\t\t\t\tsnprintf(b, sizeof(b), \"%03lo\", uval);\n\t\t\t\toutput(fp, name, b);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AR:\n\t\t\tif (!decodearr(value, &narr, lfparr))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutputarr(fp, name, narr, lfparr);\n\t\t\tbreak;\n\n\t\tcase FX:\n\t\t\tif (!decodeuint(value, &uval))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutput(fp, name, tstflags(uval));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Internal error in cookedprint, %s=%s, fmt %d\\n\",\n\t\t\t\tname, value, fmt);\n\t\t\toutput_raw = '?';\n\t\t\tbreak;\n\t\t}\n\n\t\tif (output_raw != 0) {\n\t\t\t/* TALOS-CAN-0063: avoid buffer overrun */\n\t\t\tatoascii(name, MAXVARLEN, bn, sizeof(bn));\n\t\t\tif (output_raw != '*') {\n\t\t\t\tatoascii(value, MAXVALLEN,\n\t\t\t\t\t bv, sizeof(bv) - 1);\n\t\t\t\tlen = strlen(bv);\n\t\t\t\tbv[len] = output_raw;\n\t\t\t\tbv[len+1] = '\\0';\n\t\t\t} else {\n\t\t\t\tatoascii(value, MAXVALLEN,\n\t\t\t\t\t bv, sizeof(bv));\n\t\t\t}\n\t\t\toutput(fp, bn, bv);\n\t\t}\n\t}\n\tendoutput(fp);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 694,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static jpc_enc_cp_t *cp_create(const char *optstr, jas_image_t *image)\n{\n\tjpc_enc_cp_t *cp;\n\tjas_tvparser_t *tvp;\n\tint ret;\n\tint numilyrrates;\n\tdouble *ilyrrates;\n\tint i;\n\tint tagid;\n\tjpc_enc_tcp_t *tcp;\n\tjpc_enc_tccp_t *tccp;\n\tjpc_enc_ccp_t *ccp;\n\tuint_fast16_t rlvlno;\n\tuint_fast16_t prcwidthexpn;\n\tuint_fast16_t prcheightexpn;\n\tbool enablemct;\n\tuint_fast32_t jp2overhead;\n\tuint_fast16_t lyrno;\n\tuint_fast32_t hsteplcm;\n\tuint_fast32_t vsteplcm;\n\tbool mctvalid;\n\n\ttvp = 0;\n\tcp = 0;\n\tilyrrates = 0;\n\tnumilyrrates = 0;\n\n\tif (!(cp = jas_malloc(sizeof(jpc_enc_cp_t)))) {\n\t\tgoto error;\n\t}\n\n\tprcwidthexpn = 15;\n\tprcheightexpn = 15;\n\tenablemct = true;\n\tjp2overhead = 0;\n\n\tcp->ccps = 0;\n\tcp->debug = 0;\n\tcp->imgareatlx = UINT_FAST32_MAX;\n\tcp->imgareatly = UINT_FAST32_MAX;\n\tcp->refgrdwidth = 0;\n\tcp->refgrdheight = 0;\n\tcp->tilegrdoffx = UINT_FAST32_MAX;\n\tcp->tilegrdoffy = UINT_FAST32_MAX;\n\tcp->tilewidth = 0;\n\tcp->tileheight = 0;\n\tcp->numcmpts = jas_image_numcmpts(image);\n\n\thsteplcm = 1;\n\tvsteplcm = 1;\n\tfor (unsigned cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\tif (jas_image_cmptbrx(image, cmptno) + jas_image_cmpthstep(image, cmptno) <=\n\t\t  jas_image_brx(image) || jas_image_cmptbry(image, cmptno) +\n\t\t  jas_image_cmptvstep(image, cmptno) <= jas_image_bry(image)) {\n\t\t\tjas_eprintf(\"unsupported image type\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\t/* Note: We ought to be calculating the LCMs here.  Fix some day. */\n\t\thsteplcm *= jas_image_cmpthstep(image, cmptno);\n\t\tvsteplcm *= jas_image_cmptvstep(image, cmptno);\n\t}\n\n\tif (!(cp->ccps = jas_alloc2(cp->numcmpts, sizeof(jpc_enc_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tunsigned cmptno;\n\tfor (cmptno = 0, ccp = cp->ccps; cmptno < cp->numcmpts; ++cmptno,\n\t  ++ccp) {\n\t\tccp->sampgrdstepx = jas_image_cmpthstep(image, cmptno);\n\t\tccp->sampgrdstepy = jas_image_cmptvstep(image, cmptno);\n\t\t/* XXX - this isn't quite correct for more general image */\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->prec = jas_image_cmptprec(image, cmptno);\n\t\tccp->sgnd = jas_image_cmptsgnd(image, cmptno);\n\t\tccp->numstepsizes = 0;\n\t\tmemset(ccp->stepsizes, 0, sizeof(ccp->stepsizes));\n\t}\n\n\tcp->rawsize = jas_image_rawsize(image);\n\tif (cp->rawsize == 0) {\n\t\t/* prevent division by zero in cp_create() */\n\t\tgoto error;\n\t}\n\tcp->totalsize = UINT_FAST32_MAX;\n\n\ttcp = &cp->tcp;\n\ttcp->csty = 0;\n\ttcp->intmode = true;\n\ttcp->prg = JPC_COD_LRCPPRG;\n\ttcp->numlyrs = 1;\n\ttcp->ilyrrates = 0;\n\n\ttccp = &cp->tccp;\n\ttccp->csty = 0;\n\ttccp->maxrlvls = 6;\n\ttccp->cblkwidthexpn = 6;\n\ttccp->cblkheightexpn = 6;\n\ttccp->cblksty = 0;\n\ttccp->numgbits = 2;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\tgoto error;\n\t}\n\n\twhile (!(ret = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(encopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_DEBUG:\n\t\t\tcp->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFX:\n\t\t\tcp->imgareatlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFY:\n\t\t\tcp->imgareatly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFX:\n\t\t\tcp->tilegrdoffx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFY:\n\t\t\tcp->tilegrdoffy = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEWIDTH:\n\t\t\tcp->tilewidth = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEHEIGHT:\n\t\t\tcp->tileheight = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_PRCWIDTH:\n\t\t\tprcwidthexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_PRCHEIGHT:\n\t\t\tprcheightexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKWIDTH:\n\t\t\ttccp->cblkwidthexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKHEIGHT:\n\t\t\ttccp->cblkheightexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_MODE:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(modetab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid mode %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->intmode = (tagid == MODE_INT);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_PRG:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(prgordtab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid progression order %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->prg = tagid;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_NOMCT:\n\t\t\tenablemct = false;\n\t\t\tbreak;\n\t\tcase OPT_MAXRLVLS:\n\t\t\ttccp->maxrlvls = atoi(jas_tvparser_getval(tvp));\n\t\t\tif(tccp->maxrlvls > JPC_MAXRLVLS) {\n\t\t\t\tjas_eprintf(\"invalid number of resolution levels upper than %d\\n\",JPC_MAXRLVLS);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_SOP:\n\t\t\tcp->tcp.csty |= JPC_COD_SOP;\n\t\t\tbreak;\n\t\tcase OPT_EPH:\n\t\t\tcp->tcp.csty |= JPC_COD_EPH;\n\t\t\tbreak;\n\t\tcase OPT_LAZY:\n\t\t\ttccp->cblksty |= JPC_COX_LAZY;\n\t\t\tbreak;\n\t\tcase OPT_TERMALL:\n\t\t\ttccp->cblksty |= JPC_COX_TERMALL;\n\t\t\tbreak;\n\t\tcase OPT_SEGSYM:\n\t\t\ttccp->cblksty |= JPC_COX_SEGSYM;\n\t\t\tbreak;\n\t\tcase OPT_VCAUSAL:\n\t\t\ttccp->cblksty |= JPC_COX_VSC;\n\t\t\tbreak;\n\t\tcase OPT_RESET:\n\t\t\ttccp->cblksty |= JPC_COX_RESET;\n\t\t\tbreak;\n\t\tcase OPT_PTERM:\n\t\t\ttccp->cblksty |= JPC_COX_PTERM;\n\t\t\tbreak;\n\t\tcase OPT_NUMGBITS:\n\t\t\tcp->tccp.numgbits = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_RATE:\n\t\t\tif (ratestrtosize(jas_tvparser_getval(tvp), cp->rawsize,\n\t\t\t  &cp->totalsize)) {\n\t\t\t\tjas_eprintf(\"ignoring bad rate specifier %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_ILYRRATES:\n\t\t\tif (jpc_atoaf(jas_tvparser_getval(tvp), &numilyrrates,\n\t\t\t  &ilyrrates)) {\n\t\t\t\tjas_eprintf(\"warning: invalid intermediate layer rates specifier ignored (%s)\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OPT_JP2OVERHEAD:\n\t\t\tjp2overhead = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n\ttvp = 0;\n\n\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\tcp->totalsize = (cp->totalsize > jp2overhead) ?\n\t\t  (cp->totalsize - jp2overhead) : 0;\n\t}\n\n\tif (cp->imgareatlx == UINT_FAST32_MAX) {\n\t\tcp->imgareatlx = 0;\n\t} else {\n\t\tif (hsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatlx value\\n\");\n\t\t}\n\t\tcp->imgareatlx *= hsteplcm;\n\t}\n\tif (cp->imgareatly == UINT_FAST32_MAX) {\n\t\tcp->imgareatly = 0;\n\t} else {\n\t\tif (vsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatly value\\n\");\n\t\t}\n\t\tcp->imgareatly *= vsteplcm;\n\t}\n\tcp->refgrdwidth = cp->imgareatlx + jas_image_width(image);\n\tcp->refgrdheight = cp->imgareatly + jas_image_height(image);\n\tif (cp->tilegrdoffx == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffx = cp->imgareatlx;\n\t}\n\tif (cp->tilegrdoffy == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffy = cp->imgareatly;\n\t}\n\tif (!cp->tilewidth) {\n\t\tcp->tilewidth = cp->refgrdwidth - cp->tilegrdoffx;\n\t}\n\tif (!cp->tileheight) {\n\t\tcp->tileheight = cp->refgrdheight - cp->tilegrdoffy;\n\t}\n\n\tif (cp->numcmpts == 3) {\n\t\tmctvalid = true;\n\t\tfor (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\t\tif (jas_image_cmptprec(image, cmptno) != jas_image_cmptprec(image, 0) ||\n\t\t\t  jas_image_cmptsgnd(image, cmptno) != jas_image_cmptsgnd(image, 0) ||\n\t\t\t  jas_image_cmptwidth(image, cmptno) != jas_image_cmptwidth(image, 0) ||\n\t\t\t  jas_image_cmptheight(image, cmptno) != jas_image_cmptheight(image, 0)) {\n\t\t\t\tmctvalid = false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmctvalid = false;\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) != JAS_CLRSPC_FAM_RGB) {\n\t\tjas_eprintf(\"warning: color space apparently not RGB\\n\");\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) == JAS_CLRSPC_FAM_RGB) {\n\t\ttcp->mctid = (tcp->intmode) ? (JPC_MCT_RCT) : (JPC_MCT_ICT);\n\t} else {\n\t\ttcp->mctid = JPC_MCT_NONE;\n\t}\n\ttccp->qmfbid = (tcp->intmode) ? (JPC_COX_RFT) : (JPC_COX_INS);\n\n\tfor (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {\n\t\ttccp->prcwidthexpns[rlvlno] = prcwidthexpn;\n\t\ttccp->prcheightexpns[rlvlno] = prcheightexpn;\n\t}\n\tif (prcwidthexpn != 15 || prcheightexpn != 15) {\n\t\ttccp->csty |= JPC_COX_PRT;\n\t}\n\n\t/* Ensure that the tile width and height is valid. */\n\tif (!cp->tilewidth) {\n\t\tjas_eprintf(\"invalid tile width %lu\\n\", (unsigned long)\n\t\t  cp->tilewidth);\n\t\tgoto error;\n\t}\n\tif (!cp->tileheight) {\n\t\tjas_eprintf(\"invalid tile height %lu\\n\", (unsigned long)\n\t\t  cp->tileheight);\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the tile grid offset is valid. */\n\tif (cp->tilegrdoffx > cp->imgareatlx ||\n\t  cp->tilegrdoffy > cp->imgareatly ||\n\t  cp->tilegrdoffx + cp->tilewidth < cp->imgareatlx ||\n\t  cp->tilegrdoffy + cp->tileheight < cp->imgareatly) {\n\t\tjas_eprintf(\"invalid tile grid offset (%lu, %lu)\\n\",\n\t\t  (unsigned long) cp->tilegrdoffx, (unsigned long)\n\t\t  cp->tilegrdoffy);\n\t\tgoto error;\n\t}\n\n\tcp->numhtiles = JPC_CEILDIV(cp->refgrdwidth - cp->tilegrdoffx,\n\t  cp->tilewidth);\n\tcp->numvtiles = JPC_CEILDIV(cp->refgrdheight - cp->tilegrdoffy,\n\t  cp->tileheight);\n\tcp->numtiles = cp->numhtiles * cp->numvtiles;\n\n\tif (ilyrrates && numilyrrates > 0) {\n\t\ttcp->numlyrs = numilyrrates + 1;\n\t\tif (!(tcp->ilyrrates = jas_alloc2((tcp->numlyrs - 1),\n\t\t  sizeof(jpc_fix_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (i = 0; i < JAS_CAST(int, tcp->numlyrs - 1); ++i) {\n\t\t\ttcp->ilyrrates[i] = jpc_dbltofix(ilyrrates[i]);\n\t\t}\n\t}\n\n\t/* Ensure that the integer mode is used in the case of lossless\n\t  coding. */\n\tif (cp->totalsize == UINT_FAST32_MAX && (!cp->tcp.intmode)) {\n\t\tjas_eprintf(\"cannot use real mode for lossless coding\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the precinct width is valid. */\n\tif (prcwidthexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct width\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the precinct height is valid. */\n\tif (prcheightexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct height\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block width is valid. */\n\tif (cp->tccp.cblkwidthexpn < 2 || cp->tccp.cblkwidthexpn > 12) {\n\t\tjas_eprintf(\"invalid code block width %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkwidthexpn));\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block height is valid. */\n\tif (cp->tccp.cblkheightexpn < 2 || cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"invalid code block height %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkheightexpn));\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block size is not too large. */\n\tif (cp->tccp.cblkwidthexpn + cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"code block size too large\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the number of layers is valid. */\n\tif (cp->tcp.numlyrs > 16384) {\n\t\tjas_eprintf(\"too many layers\\n\");\n\t\tgoto error;\n\t}\n\n\t/* There must be at least one resolution level. */\n\tif (cp->tccp.maxrlvls < 1) {\n\t\tjas_eprintf(\"must be at least one resolution level\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the number of guard bits is valid. */\n\tif (cp->tccp.numgbits > 8) {\n\t\tjas_eprintf(\"invalid number of guard bits\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the rate is within the legal range. */\n\tif (cp->totalsize != UINT_FAST32_MAX && cp->totalsize > cp->rawsize) {\n\t\tjas_eprintf(\"warning: specified rate is unreasonably large (%lu > %lu)\\n\", (unsigned long) cp->totalsize, (unsigned long) cp->rawsize);\n\t}\n\n\t/* Ensure that the intermediate layer rates are valid. */\n\tif (tcp->numlyrs > 1) {\n\t\t/* The intermediate layers rates must increase monotonically. */\n\t\tfor (lyrno = 0; lyrno + 2 < tcp->numlyrs; ++lyrno) {\n\t\t\tif (tcp->ilyrrates[lyrno] >= tcp->ilyrrates[lyrno + 1]) {\n\t\t\t\tjas_eprintf(\"intermediate layer rates must increase monotonically\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\t/* The intermediate layer rates must be less than the overall rate. */\n\t\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\t\tfor (lyrno = 0; lyrno < tcp->numlyrs - 1; ++lyrno) {\n\t\t\t\tif (jpc_fixtodbl(tcp->ilyrrates[lyrno]) > ((double) cp->totalsize)\n\t\t\t\t  / cp->rawsize) {\n\t\t\t\t\tjas_eprintf(\"warning: intermediate layer rates must be less than overall rate\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\n\treturn cp;\n\nerror:\n\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\tif (cp) {\n\t\tjpc_enc_cp_destroy(cp);\n\t}\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 696,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)\n{\n\tstruct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;\n\tstruct tipc_aead_key *skey = NULL;\n\tu16 key_gen = msg_key_gen(hdr);\n\tu16 size = msg_data_sz(hdr);\n\tu8 *data = msg_data(hdr);\n\tunsigned int keylen;\n\n\t/* Verify whether the size can exist in the packet */\n\tif (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {\n\t\tpr_debug(\"%s: message data size is too small\\n\", rx->name);\n\t\tgoto exit;\n\t}\n\n\tkeylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));\n\n\t/* Verify the supplied size values */\n\tif (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||\n\t\t     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {\n\t\tpr_debug(\"%s: invalid MSG_CRYPTO key size\\n\", rx->name);\n\t\tgoto exit;\n\t}\n\n\tspin_lock(&rx->lock);\n\tif (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {\n\t\tpr_err(\"%s: key existed <%p>, gen %d vs %d\\n\", rx->name,\n\t\t       rx->skey, key_gen, rx->key_gen);\n\t\tgoto exit_unlock;\n\t}\n\n\t/* Allocate memory for the key */\n\tskey = kmalloc(size, GFP_ATOMIC);\n\tif (unlikely(!skey)) {\n\t\tpr_err(\"%s: unable to allocate memory for skey\\n\", rx->name);\n\t\tgoto exit_unlock;\n\t}\n\n\t/* Copy key from msg data */\n\tskey->keylen = keylen;\n\tmemcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);\n\tmemcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),\n\t       skey->keylen);\n\n\trx->key_gen = key_gen;\n\trx->skey_mode = msg_key_mode(hdr);\n\trx->skey = skey;\n\trx->nokey = 0;\n\tmb(); /* for nokey flag */\n\nexit_unlock:\n\tspin_unlock(&rx->lock);\n\nexit:\n\t/* Schedule the key attaching on this crypto */\n\tif (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))\n\t\treturn true;\n\n\treturn false;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 760,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int qtm_decompress(struct qtm_stream *qtm, off_t out_bytes) {\n  unsigned int frame_start, frame_end, window_posn, match_offset, range;\n  unsigned char *window, *i_ptr, *i_end, *runsrc, *rundest;\n  int i, j, selector, extra, sym, match_length, ret;\n  unsigned short H, L, C, symf;\n\n  register unsigned int bit_buffer;\n  register unsigned char bits_left;\n  unsigned char bits_needed, bit_run;\n\n  /* easy answers */\n  if (!qtm || (out_bytes < 0)) return CL_ENULLARG;\n  if (qtm->error) return qtm->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = qtm->o_end - qtm->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr  += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return CL_SUCCESS;\n\n  /* restore local state */\n  QTM_RESTORE_BITS;\n  window = qtm->window;\n  window_posn = qtm->window_posn;\n  frame_start = qtm->frame_start;\n  H = qtm->H;\n  L = qtm->L;\n  C = qtm->C;\n\n  /* while we do not have enough decoded bytes in reserve: */\n  while ((qtm->o_end - qtm->o_ptr) < out_bytes) {\n\n    /* read header if necessary. Initialises H, L and C */\n    if (!qtm->header_read) {\n      H = 0xFFFF; L = 0; QTM_READ_BITS(C, 16);\n      qtm->header_read = 1;\n    }\n\n    /* decode more, at most up to to frame boundary */\n    frame_end = window_posn + (out_bytes - (qtm->o_end - qtm->o_ptr));\n    if ((frame_start + QTM_FRAME_SIZE) < frame_end) {\n      frame_end = frame_start + QTM_FRAME_SIZE;\n    }\n\n    while (window_posn < frame_end) {\n      QTM_GET_SYMBOL(qtm->model7, selector);\n      if (selector < 4) {\n\tstruct qtm_model *mdl = (selector == 0) ? &qtm->model0 :\n\t                        ((selector == 1) ? &qtm->model1 :\n\t\t\t\t((selector == 2) ? &qtm->model2 :\n                                                   &qtm->model3));\n\tQTM_GET_SYMBOL((*mdl), sym);\n\twindow[window_posn++] = sym;\n      }\n      else {\n\tswitch (selector) {\n\tcase 4: /* selector 4 = fixed length match (3 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model4, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 3;\n\t  break;\n\n\tcase 5: /* selector 5 = fixed length match (4 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model5, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 4;\n\t  break;\n\n\tcase 6: /* selector 6 = variable length match */\n\t  QTM_GET_SYMBOL(qtm->model6len, sym);\n\t  QTM_READ_BITS(extra, qtm->length_extra[sym]);\n\t  match_length = qtm->length_base[sym] + extra + 5;\n\n\t  QTM_GET_SYMBOL(qtm->model6, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  break;\n\n\tdefault:\n\t  /* should be impossible, model7 can only return 0-6 */\n\t  return qtm->error = CL_EFORMAT;\n\t}\n\n\tif (window_posn + match_length > qtm->window_size) {\n\t  cli_dbgmsg(\"qtm_decompress: match ran over window wrap\\n\");\n\t  return qtm->error = CL_EFORMAT;\n\t}\n\n\trundest = &window[window_posn];\n\ti = match_length;\n\t/* does match offset wrap the window? */\n\tif (match_offset > window_posn) {\n\t  /* j = length from match offset to end of window */\n\t  j = match_offset - window_posn;\n\t  if (j > (int) qtm->window_size) {\n\t    cli_dbgmsg(\"qtm_decompress: match offset beyond window boundaries\\n\");\n\t    return qtm->error = CL_EFORMAT;\n\t  }\n\t  runsrc = &window[qtm->window_size - j];\n\t  if (j < i) {\n\t    /* if match goes over the window edge, do two copy runs */\n\t    i -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t    runsrc = window;\n\t  }\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\telse {\n\t  runsrc = rundest - match_offset;\n\t  if(i > (int) (qtm->window_size - window_posn))\n\t    i = qtm->window_size - window_posn;\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\twindow_posn += match_length;\n      }\n    } /* while (window_posn < frame_end) */\n\n    qtm->o_end = &window[window_posn];\n\n    /* another frame completed? */\n    if ((window_posn - frame_start) >= QTM_FRAME_SIZE) {\n      if ((window_posn - frame_start) != QTM_FRAME_SIZE) {\n\tcli_dbgmsg(\"qtm_decompress: overshot frame alignment\\n\");\n\treturn qtm->error = CL_EFORMAT;\n      }\n\n      /* re-align input */\n      if (bits_left & 7) QTM_REMOVE_BITS(bits_left & 7);\n      do { QTM_READ_BITS(i, 8); } while (i != 0xFF);\n      qtm->header_read = 0;\n\n      /* window wrap? */\n      if (window_posn == qtm->window_size) {\n\t/* flush all currently stored data */\n\ti = (qtm->o_end - qtm->o_ptr);\n\tif (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n\t  return qtm->error = ret;\n\t}\n\tout_bytes -= i;\n\tqtm->o_ptr = &window[0];\n\tqtm->o_end = &window[0];\n\twindow_posn = 0;\n      }\n\n      frame_start = window_posn;\n    }\n\n  } /* while (more bytes needed) */\n\n  if (out_bytes) {\n    i = (int) out_bytes;\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr += i;\n  }\n\n  /* store local state */\n  QTM_STORE_BITS;\n  qtm->window_posn = window_posn;\n  qtm->frame_start = frame_start;\n  qtm->H = H;\n  qtm->L = L;\n  qtm->C = C;\n\n  return CL_SUCCESS;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 770,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "asmlinkage long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim)\n{\n\tstruct rlimit new_rlim, *old_rlim;\n\tunsigned long it_prof_secs;\n\tint retval;\n\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&new_rlim, rlim, sizeof(*rlim)))\n\t\treturn -EFAULT;\n\tif (new_rlim.rlim_cur > new_rlim.rlim_max)\n\t\treturn -EINVAL;\n\told_rlim = current->signal->rlim + resource;\n\tif ((new_rlim.rlim_max > old_rlim->rlim_max) &&\n\t    !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tif (resource == RLIMIT_NOFILE && new_rlim.rlim_max > NR_OPEN)\n\t\treturn -EPERM;\n\n\tretval = security_task_setrlimit(resource, &new_rlim);\n\tif (retval)\n\t\treturn retval;\n\n\tif (resource == RLIMIT_CPU && new_rlim.rlim_cur == 0) {\n\t\t/*\n\t\t * The caller is asking for an immediate RLIMIT_CPU\n\t\t * expiry.  But we use the zero value to mean \"it was\n\t\t * never set\".  So let's cheat and make it one second\n\t\t * instead\n\t\t */\n\t\tnew_rlim.rlim_cur = 1;\n\t}\n\n\ttask_lock(current->group_leader);\n\t*old_rlim = new_rlim;\n\ttask_unlock(current->group_leader);\n\n\tif (resource != RLIMIT_CPU)\n\t\tgoto out;\n\n\t/*\n\t * RLIMIT_CPU handling.   Note that the kernel fails to return an error\n\t * code if it rejected the user's attempt to set RLIMIT_CPU.  This is a\n\t * very long-standing error, and fixing it now risks breakage of\n\t * applications, so we live with it\n\t */\n\tif (new_rlim.rlim_cur == RLIM_INFINITY)\n\t\tgoto out;\n\n\tit_prof_secs = cputime_to_secs(current->signal->it_prof_expires);\n\tif (it_prof_secs == 0 || new_rlim.rlim_cur <= it_prof_secs) {\n\t\tunsigned long rlim_cur = new_rlim.rlim_cur;\n\t\tcputime_t cputime;\n\n\t\tcputime = secs_to_cputime(rlim_cur);\n\t\tread_lock(&tasklist_lock);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tset_process_cpu_timer(current, CPUCLOCK_PROF, &cputime, NULL);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tread_unlock(&tasklist_lock);\n\t}\nout:\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 794,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "static sctp_disposition_t sctp_sf_violation_chunklen(\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstatic const char err_str[]=\"The following chunk had invalid length:\";\n\n\treturn sctp_sf_abort_violation(ep, asoc, arg, commands, err_str,\n\t\t\t\t\tsizeof(err_str));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 796,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "int hfsplus_block_allocate(struct super_block *sb, u32 size, u32 offset, u32 *max)\n{\n\tstruct page *page;\n\tstruct address_space *mapping;\n\t__be32 *pptr, *curr, *end;\n\tu32 mask, start, len, n;\n\t__be32 val;\n\tint i;\n\n\tlen = *max;\n\tif (!len)\n\t\treturn size;\n\n\tdprint(DBG_BITMAP, \"block_allocate: %u,%u,%u\\n\", size, offset, len);\n\tmutex_lock(&HFSPLUS_SB(sb).alloc_file->i_mutex);\n\tmapping = HFSPLUS_SB(sb).alloc_file->i_mapping;\n\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS, NULL);\n\tif (IS_ERR(page)) {\n\t\tstart = size;\n\t\tgoto out;\n\t}\n\tpptr = kmap(page);\n\tcurr = pptr + (offset & (PAGE_CACHE_BITS - 1)) / 32;\n\ti = offset % 32;\n\toffset &= ~(PAGE_CACHE_BITS - 1);\n\tif ((size ^ offset) / PAGE_CACHE_BITS)\n\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\telse\n\t\tend = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;\n\n\t/* scan the first partial u32 for zero bits */\n\tval = *curr;\n\tif (~val) {\n\t\tn = be32_to_cpu(val);\n\t\tmask = (1U << 31) >> i;\n\t\tfor (; i < 32; mask >>= 1, i++) {\n\t\t\tif (!(n & mask))\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\tcurr++;\n\n\t/* scan complete u32s for the first zero bit */\n\twhile (1) {\n\t\twhile (curr < end) {\n\t\t\tval = *curr;\n\t\t\tif (~val) {\n\t\t\t\tn = be32_to_cpu(val);\n\t\t\t\tmask = 1 << 31;\n\t\t\t\tfor (i = 0; i < 32; mask >>= 1, i++) {\n\t\t\t\t\tif (!(n & mask))\n\t\t\t\t\t\tgoto found;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurr++;\n\t\t}\n\t\tkunmap(page);\n\t\toffset += PAGE_CACHE_BITS;\n\t\tif (offset >= size)\n\t\t\tbreak;\n\t\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,\n\t\t\t\t\t NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tstart = size;\n\t\t\tgoto out;\n\t\t}\n\t\tcurr = pptr = kmap(page);\n\t\tif ((size ^ offset) / PAGE_CACHE_BITS)\n\t\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\t\telse\n\t\t\tend = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;\n\t}\n\tdprint(DBG_BITMAP, \"bitmap full\\n\");\n\tstart = size;\n\tgoto out;\n\nfound:\n\tstart = offset + (curr - pptr) * 32 + i;\n\tif (start >= size) {\n\t\tdprint(DBG_BITMAP, \"bitmap full\\n\");\n\t\tgoto out;\n\t}\n\t/* do any partial u32 at the start */\n\tlen = min(size - start, len);\n\twhile (1) {\n\t\tn |= mask;\n\t\tif (++i >= 32)\n\t\t\tbreak;\n\t\tmask >>= 1;\n\t\tif (!--len || n & mask)\n\t\t\tgoto done;\n\t}\n\tif (!--len)\n\t\tgoto done;\n\t*curr++ = cpu_to_be32(n);\n\t/* do full u32s */\n\twhile (1) {\n\t\twhile (curr < end) {\n\t\t\tn = be32_to_cpu(*curr);\n\t\t\tif (len < 32)\n\t\t\t\tgoto last;\n\t\t\tif (n) {\n\t\t\t\tlen = 32;\n\t\t\t\tgoto last;\n\t\t\t}\n\t\t\t*curr++ = cpu_to_be32(0xffffffff);\n\t\t\tlen -= 32;\n\t\t}\n\t\tset_page_dirty(page);\n\t\tkunmap(page);\n\t\toffset += PAGE_CACHE_BITS;\n\t\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,\n\t\t\t\t\t NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tstart = size;\n\t\t\tgoto out;\n\t\t}\n\t\tpptr = kmap(page);\n\t\tcurr = pptr;\n\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\t}\nlast:\n\t/* do any partial u32 at end */\n\tmask = 1U << 31;\n\tfor (i = 0; i < len; i++) {\n\t\tif (n & mask)\n\t\t\tbreak;\n\t\tn |= mask;\n\t\tmask >>= 1;\n\t}\ndone:\n\t*curr = cpu_to_be32(n);\n\tset_page_dirty(page);\n\tkunmap(page);\n\t*max = offset + (curr - pptr) * 32 + i - start;\n\tHFSPLUS_SB(sb).free_blocks -= *max;\n\tsb->s_dirt = 1;\n\tdprint(DBG_BITMAP, \"-> %u,%u\\n\", start, *max);\nout:\n\tmutex_unlock(&HFSPLUS_SB(sb).alloc_file->i_mutex);\n\treturn start;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 800,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "    kssl_keytab_is_available(KSSL_CTX *kssl_ctx)\n{\n    krb5_context\t\tkrb5context = NULL;\n    krb5_keytab \t\tkrb5keytab = NULL;\n    krb5_keytab_entry           entry;\n    krb5_principal              princ = NULL;\n    krb5_error_code  \t\tkrb5rc = KRB5KRB_ERR_GENERIC;\n    int rc = 0;\n\n    if ((krb5rc = krb5_init_context(&krb5context)))\n        return(0);\n\n    /*\tkssl_ctx->keytab_file == NULL ==> use Kerberos default\n    */\n    if (kssl_ctx->keytab_file)\n    {\n        krb5rc = krb5_kt_resolve(krb5context, kssl_ctx->keytab_file,\n                                  &krb5keytab);\n        if (krb5rc)\n            goto exit;\n    }\n    else\n    {\n        krb5rc = krb5_kt_default(krb5context,&krb5keytab);\n        if (krb5rc)\n            goto exit;\n    }\n\n    /* the host key we are looking for */\n    krb5rc = krb5_sname_to_principal(krb5context, NULL, \n                                     kssl_ctx->service_name ? kssl_ctx->service_name: KRB5SVC,\n                                     KRB5_NT_SRV_HST, &princ);\n\n    if (krb5rc)\n\tgoto exit;\n\n    krb5rc = krb5_kt_get_entry(krb5context, krb5keytab, \n                                princ,\n                                0 /* IGNORE_VNO */,\n                                0 /* IGNORE_ENCTYPE */,\n                                &entry);\n    if ( krb5rc == KRB5_KT_NOTFOUND ) {\n        rc = 1;\n        goto exit;\n    } else if ( krb5rc )\n        goto exit;\n    \n    krb5_kt_free_entry(krb5context, &entry);\n    rc = 1;\n\n  exit:\n    if (krb5keytab)     krb5_kt_close(krb5context, krb5keytab);\n    if (princ)          krb5_free_principal(krb5context, princ);\n    if (krb5context)\tkrb5_free_context(krb5context);\n    return(rc);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 806,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "auth_request_get_var_expand_table_full(const struct auth_request *auth_request,\n\t\t\t\t       auth_request_escape_func_t *escape_func,\n\t\t\t\t       unsigned int *count)\n{\n\tconst unsigned int auth_count =\n\t\tN_ELEMENTS(auth_request_var_expand_static_tab);\n\tstruct var_expand_table *tab, *ret_tab;\n\tconst char *orig_user, *auth_user, *username;\n\n\tif (escape_func == NULL)\n\t\tescape_func = escape_none;\n\n\t/* keep the extra fields at the beginning. the last static_tab field\n\t   contains the ending NULL-fields. */\n\ttab = ret_tab = t_malloc((*count + auth_count) * sizeof(*tab));\n\tmemset(tab, 0, *count * sizeof(*tab));\n\ttab += *count;\n\t*count += auth_count;\n\n\tmemcpy(tab, auth_request_var_expand_static_tab,\n\t       auth_count * sizeof(*tab));\n\n\tusername = auth_request->user != NULL ? auth_request->user : \"\";\n\ttab[0].value = escape_func(username, auth_request);\n\ttab[1].value = escape_func(t_strcut(username, '@'),\n\t\t\t\t   auth_request);\n\ttab[2].value = strchr(username, '@');\n\tif (tab[2].value != NULL)\n\t\ttab[2].value = escape_func(tab[2].value+1, auth_request);\n\ttab[3].value = escape_func(auth_request->service, auth_request);\n\t/* tab[4] = we have no home dir */\n\tif (auth_request->local_ip.family != 0)\n\t\ttab[5].value = net_ip2addr(&auth_request->local_ip);\n\tif (auth_request->remote_ip.family != 0)\n\t\ttab[6].value = net_ip2addr(&auth_request->remote_ip);\n\ttab[7].value = dec2str(auth_request->client_pid);\n\tif (auth_request->mech_password != NULL) {\n\t\ttab[8].value = escape_func(auth_request->mech_password,\n\t\t\t\t\t   auth_request);\n\t}\n\tif (auth_request->userdb_lookup) {\n\t\ttab[9].value = auth_request->userdb == NULL ? \"\" :\n\t\t\tdec2str(auth_request->userdb->userdb->id);\n\t} else {\n\t\ttab[9].value = auth_request->passdb == NULL ? \"\" :\n\t\t\tdec2str(auth_request->passdb->passdb->id);\n\t}\n\ttab[10].value = auth_request->mech_name == NULL ? \"\" :\n\t\tescape_func(auth_request->mech_name, auth_request);\n\ttab[11].value = auth_request->secured ? \"secured\" : \"\";\n\ttab[12].value = dec2str(auth_request->local_port);\n\ttab[13].value = dec2str(auth_request->remote_port);\n\ttab[14].value = auth_request->valid_client_cert ? \"valid\" : \"\";\n\n\tif (auth_request->requested_login_user != NULL) {\n\t\tconst char *login_user = auth_request->requested_login_user;\n\n\t\ttab[15].value = escape_func(login_user, auth_request);\n\t\ttab[16].value = escape_func(t_strcut(login_user, '@'),\n\t\t\t\t\t    auth_request);\n\t\ttab[17].value = strchr(login_user, '@');\n\t\tif (tab[17].value != NULL) {\n\t\t\ttab[17].value = escape_func(tab[17].value+1,\n\t\t\t\t\t\t    auth_request);\n\t\t}\n\t}\n\ttab[18].value = auth_request->session_id == NULL ? NULL :\n\t\tescape_func(auth_request->session_id, auth_request);\n\tif (auth_request->real_local_ip.family != 0)\n\t\ttab[19].value = net_ip2addr(&auth_request->real_local_ip);\n\tif (auth_request->real_remote_ip.family != 0)\n\t\ttab[20].value = net_ip2addr(&auth_request->real_remote_ip);\n\ttab[21].value = dec2str(auth_request->real_local_port);\n\ttab[22].value = dec2str(auth_request->real_remote_port);\n\ttab[23].value = strchr(username, '@');\n\tif (tab[23].value != NULL) {\n\t\ttab[23].value = escape_func(t_strcut(tab[23].value+1, '@'),\n\t\t\t\t\t    auth_request);\n\t}\n\ttab[24].value = strrchr(username, '@');\n\tif (tab[24].value != NULL)\n\t\ttab[24].value = escape_func(tab[24].value+1, auth_request);\n\ttab[25].value = auth_request->master_user == NULL ? NULL :\n\t\tescape_func(auth_request->master_user, auth_request);\n\ttab[26].value = auth_request->session_pid == (pid_t)-1 ? NULL :\n\t\tdec2str(auth_request->session_pid);\n\n\torig_user = auth_request->original_username != NULL ?\n\t\tauth_request->original_username : username;\n\ttab[27].value = escape_func(orig_user, auth_request);\n\ttab[28].value = escape_func(t_strcut(orig_user, '@'), auth_request);\n\ttab[29].value = strchr(orig_user, '@');\n\tif (tab[29].value != NULL)\n\t\ttab[29].value = escape_func(tab[29].value+1, auth_request);\n\n\tif (auth_request->master_user != NULL)\n\t\tauth_user = auth_request->master_user;\n\telse\n\t\tauth_user = orig_user;\n\ttab[30].value = escape_func(auth_user, auth_request);\n\ttab[31].value = escape_func(t_strcut(auth_user, '@'), auth_request);\n\ttab[32].value = strchr(auth_user, '@');\n\tif (tab[32].value != NULL)\n\t\ttab[32].value = escape_func(tab[32].value+1, auth_request);\n\tif (auth_request->local_name != NULL)\n\t\ttab[33].value = escape_func(auth_request->local_name, auth_request);\n\telse\n\t\ttab[33].value = \"\";\n\treturn ret_tab;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 810,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  }
]