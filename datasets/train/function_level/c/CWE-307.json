[
  {
    "CWE_ID": [
      "CWE-307"
    ],
    "code": "static int map_create(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct bpf_map *map;\n\tint f_flags;\n\tint err;\n\n\terr = CHECK_ATTR(BPF_MAP_CREATE);\n\tif (err)\n\t\treturn -EINVAL;\n\n\tif (attr->btf_vmlinux_value_type_id) {\n\t\tif (attr->map_type != BPF_MAP_TYPE_STRUCT_OPS ||\n\t\t    attr->btf_key_type_id || attr->btf_value_type_id)\n\t\t\treturn -EINVAL;\n\t} else if (attr->btf_key_type_id && !attr->btf_value_type_id) {\n\t\treturn -EINVAL;\n\t}\n\n\tf_flags = bpf_get_file_flag(attr->map_flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tif (numa_node != NUMA_NO_NODE &&\n\t    ((unsigned int)numa_node >= nr_node_ids ||\n\t     !node_online(numa_node)))\n\t\treturn -EINVAL;\n\n\t/* find map type and init map: hashtable vs rbtree vs bloom vs ... */\n\tmap = find_and_alloc_map(attr);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\terr = bpf_obj_name_cpy(map->name, attr->map_name,\n\t\t\t       sizeof(attr->map_name));\n\tif (err < 0)\n\t\tgoto free_map;\n\n\tatomic64_set(&map->refcnt, 1);\n\tatomic64_set(&map->usercnt, 1);\n\tmutex_init(&map->freeze_mutex);\n\n\tmap->spin_lock_off = -EINVAL;\n\tif (attr->btf_key_type_id || attr->btf_value_type_id ||\n\t    /* Even the map's value is a kernel's struct,\n\t     * the bpf_prog.o must have BTF to begin with\n\t     * to figure out the corresponding kernel's\n\t     * counter part.  Thus, attr->btf_fd has\n\t     * to be valid also.\n\t     */\n\t    attr->btf_vmlinux_value_type_id) {\n\t\tstruct btf *btf;\n\n\t\tbtf = btf_get_by_fd(attr->btf_fd);\n\t\tif (IS_ERR(btf)) {\n\t\t\terr = PTR_ERR(btf);\n\t\t\tgoto free_map;\n\t\t}\n\t\tmap->btf = btf;\n\n\t\tif (attr->btf_value_type_id) {\n\t\t\terr = map_check_btf(map, btf, attr->btf_key_type_id,\n\t\t\t\t\t    attr->btf_value_type_id);\n\t\t\tif (err)\n\t\t\t\tgoto free_map;\n\t\t}\n\n\t\tmap->btf_key_type_id = attr->btf_key_type_id;\n\t\tmap->btf_value_type_id = attr->btf_value_type_id;\n\t\tmap->btf_vmlinux_value_type_id =\n\t\t\tattr->btf_vmlinux_value_type_id;\n\t}\n\n\terr = security_bpf_map_alloc(map);\n\tif (err)\n\t\tgoto free_map;\n\n\terr = bpf_map_alloc_id(map);\n\tif (err)\n\t\tgoto free_map_sec;\n\n\tbpf_map_save_memcg(map);\n\n\terr = bpf_map_new_fd(map, f_flags);\n\tif (err < 0) {\n\t\t/* failed to allocate fd.\n\t\t * bpf_map_put_with_uref() is needed because the above\n\t\t * bpf_map_alloc_id() has published the map\n\t\t * to the userspace and the userspace may\n\t\t * have refcnt-ed it through BPF_MAP_GET_FD_BY_ID.\n\t\t */\n\t\tbpf_map_put_with_uref(map);\n\t\treturn err;\n\t}\n\n\treturn err;\n\nfree_map_sec:\n\tsecurity_bpf_map_free(map);\nfree_map:\n\tbtf_put(map->btf);\n\tmap->ops->map_free(map);\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146302,
    "RELATED_CWE": [
      "CWE-521",
      "CWE-798",
      "CWE-603"
    ],
    "human": "Incorrect. Without CWE-307",
    "reason": "Vulnerable to authorization bypass (CWE-862), not directly CWE-307. The fix is also for avoiding bypassing authorization."
  },
  {
    "CWE_ID": [
      "CWE-307"
    ],
    "code": "static int map_create(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct bpf_map *map;\n\tint f_flags;\n\tint err;\n\n\terr = CHECK_ATTR(BPF_MAP_CREATE);\n\tif (err)\n\t\treturn -EINVAL;\n\n\tif (attr->btf_vmlinux_value_type_id) {\n\t\tif (attr->map_type != BPF_MAP_TYPE_STRUCT_OPS ||\n\t\t    attr->btf_key_type_id || attr->btf_value_type_id)\n\t\t\treturn -EINVAL;\n\t} else if (attr->btf_key_type_id && !attr->btf_value_type_id) {\n\t\treturn -EINVAL;\n\t}\n\n\tf_flags = bpf_get_file_flag(attr->map_flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tif (numa_node != NUMA_NO_NODE &&\n\t    ((unsigned int)numa_node >= nr_node_ids ||\n\t     !node_online(numa_node)))\n\t\treturn -EINVAL;\n\n\t/* find map type and init map: hashtable vs rbtree vs bloom vs ... */\n\tmap = find_and_alloc_map(attr);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\terr = bpf_obj_name_cpy(map->name, attr->map_name,\n\t\t\t       sizeof(attr->map_name));\n\tif (err < 0)\n\t\tgoto free_map;\n\n\tatomic64_set(&map->refcnt, 1);\n\tatomic64_set(&map->usercnt, 1);\n\tmutex_init(&map->freeze_mutex);\n\n\tmap->spin_lock_off = -EINVAL;\n\tif (attr->btf_key_type_id || attr->btf_value_type_id ||\n\t    /* Even the map's value is a kernel's struct,\n\t     * the bpf_prog.o must have BTF to begin with\n\t     * to figure out the corresponding kernel's\n\t     * counter part.  Thus, attr->btf_fd has\n\t     * to be valid also.\n\t     */\n\t    attr->btf_vmlinux_value_type_id) {\n\t\tstruct btf *btf;\n\n\t\tbtf = btf_get_by_fd(attr->btf_fd);\n\t\tif (IS_ERR(btf)) {\n\t\t\terr = PTR_ERR(btf);\n\t\t\tgoto free_map;\n\t\t}\n\t\tif (btf_is_kernel(btf)) {\n\t\t\tbtf_put(btf);\n\t\t\terr = -EACCES;\n\t\t\tgoto free_map;\n\t\t}\n\t\tmap->btf = btf;\n\n\t\tif (attr->btf_value_type_id) {\n\t\t\terr = map_check_btf(map, btf, attr->btf_key_type_id,\n\t\t\t\t\t    attr->btf_value_type_id);\n\t\t\tif (err)\n\t\t\t\tgoto free_map;\n\t\t}\n\n\t\tmap->btf_key_type_id = attr->btf_key_type_id;\n\t\tmap->btf_value_type_id = attr->btf_value_type_id;\n\t\tmap->btf_vmlinux_value_type_id =\n\t\t\tattr->btf_vmlinux_value_type_id;\n\t}\n\n\terr = security_bpf_map_alloc(map);\n\tif (err)\n\t\tgoto free_map;\n\n\terr = bpf_map_alloc_id(map);\n\tif (err)\n\t\tgoto free_map_sec;\n\n\tbpf_map_save_memcg(map);\n\n\terr = bpf_map_new_fd(map, f_flags);\n\tif (err < 0) {\n\t\t/* failed to allocate fd.\n\t\t * bpf_map_put_with_uref() is needed because the above\n\t\t * bpf_map_alloc_id() has published the map\n\t\t * to the userspace and the userspace may\n\t\t * have refcnt-ed it through BPF_MAP_GET_FD_BY_ID.\n\t\t */\n\t\tbpf_map_put_with_uref(map);\n\t\treturn err;\n\t}\n\n\treturn err;\n\nfree_map_sec:\n\tsecurity_bpf_map_free(map);\nfree_map:\n\tbtf_put(map->btf);\n\tmap->ops->map_free(map);\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146303,
    "RELATED_CWE": [
      "CWE-521",
      "CWE-798",
      "CWE-603"
    ]
  }
]