[
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def start():\n    print(\"[*] Starting backdoor process\")\n    print(\"[*] Decompressing target to tmp directory...\")\n    #subprocess.call(\"jar -x %s\" % target, shell=True)\n    with zipfile.ZipFile(target, 'r') as zip:\n        zip.extractall(\"tmp\")\n    print(\"[*] Target dumped to tmp directory\")\n\n    print(\"[*] Modifying manifest file...\")\n    oldmain=\"\"\n    man = open(\"tmp/META-INF/MANIFEST.MF\",\"r\").read()\n    with open(\"tmp/META-INF/MANIFEST.MF\",\"w\") as f:\n        for l in man.split(\"\\n\"):\n            if \"Main-Class\" in l:\n                oldmain=l[12:]\n                f.write(\"Main-Class: %s\\n\" % \"Backdoor\")\n            else:\n                f.write(\"%s\\n\" % l)\n    print(\"[*] Manifest file modified\")\n    \n    print(\"[*] Modifying provided backdoor...\")\n    inmain=False\n    level=0\n    bd=open(backdoor, \"r\").read()\n    with open(\"tmp/%s\" % backdoor,'w') as f:\n        for l in bd.split(\"\\n\"):\n            if \"main(\" in l:\n                inmain=True\n                f.write(l)\n            elif \"}\" in l and level<2 and inmain:\n                f.write(\"%s.main(args);}\" % oldmain)\n                inmain=False\n            elif \"}\" in l and level>1 and inmain:\n                level-=1\n                f.write(l)\n            elif \"{\" in l and inmain:\n                level+=1\n                f.write(l)\n            else:\n                f.write(l)\n    print(\"[*] Provided backdoor successfully modified\")\n\n    print(\"[*] Compiling modified backdoor...\")\n    if subprocess.call(\"javac -cp tmp/ tmp/%s\" % backdoor, shell=True) != 0:\n        print(\"[!] Error compiling %s\" % backdoor)\n    print(\"[*] Compiled modified backdoor\")\n                \n    if(len(oldmain)<1):\n        print(\"[!] Main-Class manifest attribute not found\")\n    else:\n        print(\"[*] Repackaging target jar file...\")\n        createZip(\"tmp\",outfile)\n        print(\"[*] Target jar successfully repackaged\")\n    shutil.rmtree('tmp/')",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148860,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ],
    "human": "Correct"
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def start():\n    print(\"[*] Starting backdoor process\")\n    print(\"[*] Decompressing target to tmp directory...\")\n    #subprocess.call(\"jar -x %s\" % target, shell=True)\n    with zipfile.ZipFile(target, 'r') as zip:\n        zip.extractall(\"tmp\")\n    print(\"[*] Target dumped to tmp directory\")\n\n    print(\"[*] Modifying manifest file...\")\n    oldmain=\"\"\n    man = open(\"tmp/META-INF/MANIFEST.MF\",\"r\").read()\n    with open(\"tmp/META-INF/MANIFEST.MF\",\"w\") as f:\n        for l in man.split(\"\\n\"):\n            if \"Main-Class\" in l:\n                oldmain=l[12:]\n                f.write(\"Main-Class: %s\\n\" % \"Backdoor\")\n            else:\n                f.write(\"%s\\n\" % l)\n    print(\"[*] Manifest file modified\")\n    \n    print(\"[*] Modifying provided backdoor...\")\n    inmain=False\n    level=0\n    bd=open(backdoor, \"r\").read()\n    with open(\"tmp/%s\" % backdoor,'w') as f:\n        for l in bd.split(\"\\n\"):\n            if \"main(\" in l:\n                inmain=True\n                f.write(l)\n            elif \"}\" in l and level<2 and inmain:\n                f.write(\"%s.main(args);}\" % oldmain)\n                inmain=False\n            elif \"}\" in l and level>1 and inmain:\n                level-=1\n                f.write(l)\n            elif \"{\" in l and inmain:\n                level+=1\n                f.write(l)\n            else:\n                f.write(l)\n    print(\"[*] Provided backdoor successfully modified\")\n\n    print(\"[*] Compiling modified backdoor...\")\n    #if subprocess.call(\"javac -cp tmp/ tmp/%s\" % backdoor, shell=True) != 0:\n    if subprocess.call(['javac','-cp','tmp/','tmp/%s'%backdoor],shell=False) != 0:\n        print(\"[!] Error compiling %s\" % backdoor)\n    print(\"[*] Compiled modified backdoor\")\n                \n    if(len(oldmain)<1):\n        print(\"[!] Main-Class manifest attribute not found\")\n    else:\n        print(\"[*] Repackaging target jar file...\")\n        createZip(\"tmp\",outfile)\n        print(\"[*] Target jar successfully repackaged\")\n    shutil.rmtree('tmp/')",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148861,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ],
    "human": "Correct"
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _map_vol_to_host(self, volume_name, host_name):\n        \"\"\"Create a mapping between a volume to a host.\"\"\"\n\n        LOG.debug(_('enter: _map_vol_to_host: volume %(volume_name)s to '\n                    'host %(host_name)s')\n                  % {'volume_name': volume_name, 'host_name': host_name})\n\n        # Check if this volume is already mapped to this host\n        mapping_data = self._get_hostvdisk_mappings(host_name)\n\n        mapped_flag = False\n        result_lun = '-1'\n        if volume_name in mapping_data:\n            mapped_flag = True\n            result_lun = mapping_data[volume_name]['SCSI_id']\n        else:\n            lun_used = [int(v['SCSI_id']) for v in mapping_data.values()]\n            lun_used.sort()\n            # Assume all luns are taken to this point, and then try to find\n            # an unused one\n            result_lun = str(len(lun_used))\n            for index, n in enumerate(lun_used):\n                if n > index:\n                    result_lun = str(index)\n                    break\n\n        # Volume is not mapped to host, create a new LUN\n        if not mapped_flag:\n            ssh_cmd = ('svctask mkvdiskhostmap -host %(host_name)s -scsi '\n                       '%(result_lun)s %(volume_name)s' %\n                       {'host_name': host_name,\n                        'result_lun': result_lun,\n                        'volume_name': volume_name})\n            out, err = self._run_ssh(ssh_cmd, check_exit_code=False)\n            if err and err.startswith('CMMVC6071E'):\n                if not self.configuration.storwize_svc_multihostmap_enabled:\n                    LOG.error(_('storwize_svc_multihostmap_enabled is set '\n                                'to False, Not allow multi host mapping'))\n                    exception_msg = 'CMMVC6071E The VDisk-to-host mapping '\\\n                                    'was not created because the VDisk is '\\\n                                    'already mapped to a host.\\n\"'\n                    raise exception.CinderException(data=exception_msg)\n                ssh_cmd = ssh_cmd.replace('mkvdiskhostmap',\n                                          'mkvdiskhostmap -force')\n                # try to map one volume to multiple hosts\n                out, err = self._run_ssh(ssh_cmd)\n                LOG.warn(_('volume %s mapping to multi host') % volume_name)\n                self._assert_ssh_return('successfully created' in out,\n                                        '_map_vol_to_host', ssh_cmd, out, err)\n            else:\n                self._assert_ssh_return('successfully created' in out,\n                                        '_map_vol_to_host', ssh_cmd, out, err)\n        LOG.debug(_('leave: _map_vol_to_host: LUN %(result_lun)s, volume '\n                    '%(volume_name)s, host %(host_name)s') %\n                  {'result_lun': result_lun,\n                   'volume_name': volume_name,\n                   'host_name': host_name})\n        return result_lun",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148862,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _map_vol_to_host(self, volume_name, host_name):\n        \"\"\"Create a mapping between a volume to a host.\"\"\"\n\n        LOG.debug(_('enter: _map_vol_to_host: volume %(volume_name)s to '\n                    'host %(host_name)s')\n                  % {'volume_name': volume_name, 'host_name': host_name})\n\n        # Check if this volume is already mapped to this host\n        mapping_data = self._get_hostvdisk_mappings(host_name)\n\n        mapped_flag = False\n        result_lun = '-1'\n        if volume_name in mapping_data:\n            mapped_flag = True\n            result_lun = mapping_data[volume_name]['SCSI_id']\n        else:\n            lun_used = [int(v['SCSI_id']) for v in mapping_data.values()]\n            lun_used.sort()\n            # Assume all luns are taken to this point, and then try to find\n            # an unused one\n            result_lun = str(len(lun_used))\n            for index, n in enumerate(lun_used):\n                if n > index:\n                    result_lun = str(index)\n                    break\n\n        # Volume is not mapped to host, create a new LUN\n        if not mapped_flag:\n            ssh_cmd = ['svctask', 'mkvdiskhostmap', '-host', host_name,\n                       '-scsi', result_lun, volume_name]\n            out, err = self._run_ssh(ssh_cmd, check_exit_code=False)\n            if err and err.startswith('CMMVC6071E'):\n                if not self.configuration.storwize_svc_multihostmap_enabled:\n                    LOG.error(_('storwize_svc_multihostmap_enabled is set '\n                                'to False, Not allow multi host mapping'))\n                    exception_msg = 'CMMVC6071E The VDisk-to-host mapping '\\\n                                    'was not created because the VDisk is '\\\n                                    'already mapped to a host.\\n\"'\n                    raise exception.CinderException(data=exception_msg)\n\n                for i in range(len(ssh_cmd)):\n                    if ssh_cmd[i] == 'mkvdiskhostmap':\n                        ssh_cmd.insert(i + 1, '-force')\n\n                # try to map one volume to multiple hosts\n                out, err = self._run_ssh(ssh_cmd)\n                LOG.warn(_('volume %s mapping to multi host') % volume_name)\n                self._assert_ssh_return('successfully created' in out,\n                                        '_map_vol_to_host', ssh_cmd, out, err)\n            else:\n                self._assert_ssh_return('successfully created' in out,\n                                        '_map_vol_to_host', ssh_cmd, out, err)\n        LOG.debug(_('leave: _map_vol_to_host: LUN %(result_lun)s, volume '\n                    '%(volume_name)s, host %(host_name)s') %\n                  {'result_lun': result_lun,\n                   'volume_name': volume_name,\n                   'host_name': host_name})\n        return result_lun",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148863,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _delete_vdisk(self, name, force):\n        \"\"\"Deletes existing vdisks.\n\n        It is very important to properly take care of mappings before deleting\n        the disk:\n        1. If no mappings, then it was a vdisk, and can be deleted\n        2. If it is the source of a flashcopy mapping and copy_rate is 0, then\n           it is a vdisk that has a snapshot.  If the force flag is set,\n           delete the mapping and the vdisk, otherwise set the mapping to\n           copy and wait (this will allow users to delete vdisks that have\n           snapshots if/when the upper layers allow it).\n        3. If it is the target of a mapping and copy_rate is 0, it is a\n           snapshot, and we should properly stop the mapping and delete.\n        4. If it is the source/target of a mapping and copy_rate is not 0, it\n           is a clone or vdisk created from a snapshot.  We wait for the copy\n           to complete (the mapping will be autodeleted) and then delete the\n           vdisk.\n\n        \"\"\"\n\n        LOG.debug(_('enter: _delete_vdisk: vdisk %s') % name)\n\n        # Try to delete volume only if found on the storage\n        vdisk_defined = self._is_vdisk_defined(name)\n        if not vdisk_defined:\n            LOG.info(_('warning: Tried to delete vdisk %s but it does not '\n                       'exist.') % name)\n            return\n\n        self._ensure_vdisk_no_fc_mappings(name)\n\n        forceflag = '-force' if force else ''\n        cmd_params = {'frc': forceflag, 'name': name}\n        ssh_cmd = 'svctask rmvdisk %(frc)s %(name)s' % cmd_params\n        out, err = self._run_ssh(ssh_cmd)\n        # No output should be returned from rmvdisk\n        self._assert_ssh_return(len(out.strip()) == 0,\n                                ('_delete_vdisk %(name)s')\n                                % {'name': name},\n                                ssh_cmd, out, err)\n        LOG.debug(_('leave: _delete_vdisk: vdisk %s') % name)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148864,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _delete_vdisk(self, name, force):\n        \"\"\"Deletes existing vdisks.\n\n        It is very important to properly take care of mappings before deleting\n        the disk:\n        1. If no mappings, then it was a vdisk, and can be deleted\n        2. If it is the source of a flashcopy mapping and copy_rate is 0, then\n           it is a vdisk that has a snapshot.  If the force flag is set,\n           delete the mapping and the vdisk, otherwise set the mapping to\n           copy and wait (this will allow users to delete vdisks that have\n           snapshots if/when the upper layers allow it).\n        3. If it is the target of a mapping and copy_rate is 0, it is a\n           snapshot, and we should properly stop the mapping and delete.\n        4. If it is the source/target of a mapping and copy_rate is not 0, it\n           is a clone or vdisk created from a snapshot.  We wait for the copy\n           to complete (the mapping will be autodeleted) and then delete the\n           vdisk.\n\n        \"\"\"\n\n        LOG.debug(_('enter: _delete_vdisk: vdisk %s') % name)\n\n        # Try to delete volume only if found on the storage\n        vdisk_defined = self._is_vdisk_defined(name)\n        if not vdisk_defined:\n            LOG.info(_('warning: Tried to delete vdisk %s but it does not '\n                       'exist.') % name)\n            return\n\n        self._ensure_vdisk_no_fc_mappings(name)\n\n        ssh_cmd = ['svctask', 'rmvdisk', '-force', name]\n        if not force:\n            ssh_cmd.remove('-force')\n        out, err = self._run_ssh(ssh_cmd)\n        # No output should be returned from rmvdisk\n        self._assert_ssh_return(len(out.strip()) == 0,\n                                ('_delete_vdisk %(name)s')\n                                % {'name': name},\n                                ssh_cmd, out, err)\n        LOG.debug(_('leave: _delete_vdisk: vdisk %s') % name)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148865,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _cliq_run(self, verb, cliq_args, check_exit_code=True):\n        \"\"\"Runs a CLIQ command over SSH, without doing any result parsing\"\"\"\n        cliq_arg_strings = []\n        for k, v in cliq_args.items():\n            cliq_arg_strings.append(\" %s=%s\" % (k, v))\n        cmd = verb + ''.join(cliq_arg_strings)\n\n        return self._run_ssh(cmd, check_exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148866,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ],
    "human": "Correct"
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _cliq_run(self, verb, cliq_args, check_exit_code=True):\n        \"\"\"Runs a CLIQ command over SSH, without doing any result parsing\"\"\"\n        cmd_list = [verb]\n        for k, v in cliq_args.items():\n            cmd_list.append(\"%s=%s\" % (k, v))\n\n        return self._run_ssh(cmd_list, check_exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148867,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ],
    "human": "Correct"
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _set_qos_rule(self, qos, vvs_name):\n        max_io = self._get_qos_value(qos, 'maxIOPS')\n        max_bw = self._get_qos_value(qos, 'maxBWS')\n        cli_qos_string = \"\"\n        if max_io is not None:\n            cli_qos_string += ('-io %s ' % max_io)\n        if max_bw is not None:\n            cli_qos_string += ('-bw %sM ' % max_bw)\n        self._cli_run('setqos %svvset:%s' %\n                      (cli_qos_string, vvs_name), None)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148868,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _set_qos_rule(self, qos, vvs_name):\n        max_io = self._get_qos_value(qos, 'maxIOPS')\n        max_bw = self._get_qos_value(qos, 'maxBWS')\n        cli_qos_string = \"\"\n        if max_io is not None:\n            cli_qos_string += ('-io %s ' % max_io)\n        if max_bw is not None:\n            cli_qos_string += ('-bw %sM ' % max_bw)\n        self._cli_run(['setqos', '%svvset:%s' % (cli_qos_string, vvs_name)])",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148869,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def get_lines(command: str) -> List[str]:\n    \"\"\"\n    Run a command and return lines of output\n\n    :param str command: the command to run\n    :returns: list of whitespace-stripped lines output by command\n    \"\"\"\n    stdout = get_output(command)\n    return [line.strip().decode() for line in stdout.splitlines()]",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148870,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def get_lines(command: List[str]) -> List[str]:\n    \"\"\"\n    Run a command and return lines of output\n\n    :param str command: the command to run\n    :returns: list of whitespace-stripped lines output by command\n    \"\"\"\n    stdout = get_output(command)\n    return [line.strip() for line in stdout.splitlines()]",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148871,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _modify_3par_iscsi_host(self, hostname, iscsi_iqn):\n        # when using -add, you can not send the persona or domain options\n        self.common._cli_run('createhost -iscsi -add %s %s'\n                             % (hostname, iscsi_iqn), None)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148872,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _modify_3par_iscsi_host(self, hostname, iscsi_iqn):\n        # when using -add, you can not send the persona or domain options\n        command = ['createhost', '-iscsi', '-add', hostname, iscsi_iqn]\n        self.common._cli_run(command)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148873,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "@contextmanager\ndef run_interactive_shell_command(command, **kwargs):\n    \"\"\"\n    Runs a command in shell and provides stdout, stderr and stdin streams.\n\n    This function creates a context manager that sets up the process, returns\n    to caller, closes streams and waits for process to exit on leaving.\n\n    The process is opened in `universal_newlines` mode.\n\n    :param command: The command to run on shell.\n    :param kwargs:  Additional keyword arguments to pass to `subprocess.Popen`\n                    that is used to spawn the process (except `shell`,\n                    `stdout`, `stderr`, `stdin` and `universal_newlines`, a\n                    `TypeError` is raised then).\n    :return:        A context manager yielding the process started from the\n                    command.\n    \"\"\"\n    process = Popen(command,\n                    shell=True,\n                    stdout=PIPE,\n                    stderr=PIPE,\n                    stdin=PIPE,\n                    universal_newlines=True,\n                    **kwargs)\n    try:\n        yield process\n    finally:\n        process.stdout.close()\n        process.stderr.close()\n        process.stdin.close()\n        process.wait()",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148874,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ],
    "human": "Correct"
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "@contextmanager\ndef run_interactive_shell_command(command, **kwargs):\n    \"\"\"\n    Runs a single command in shell and provides stdout, stderr and stdin\n    streams.\n\n    This function creates a context manager that sets up the process (using\n    `subprocess.Popen()`), returns to caller, closes streams and waits for\n    process to exit on leaving.\n\n    Shell execution is disabled by default (so no shell expansion takes place).\n    If you want to turn shell execution on, you can pass `shell=True` like you\n    would do for `subprocess.Popen()`.\n\n    The process is opened in `universal_newlines` mode by default.\n\n    :param command: The command to run on shell. This parameter can either\n                    be a sequence of arguments that are directly passed to\n                    the process or a string. A string gets splitted beforehand\n                    using `shlex.split()`.\n    :param kwargs:  Additional keyword arguments to pass to `subprocess.Popen`\n                    that is used to spawn the process (except `stdout`,\n                    `stderr`, `stdin` and `universal_newlines`, a `TypeError`\n                    is raised then).\n    :return:        A context manager yielding the process started from the\n                    command.\n    \"\"\"\n    if isinstance(command, str):\n        command = shlex.split(command)\n\n    process = Popen(command,\n                    stdout=PIPE,\n                    stderr=PIPE,\n                    stdin=PIPE,\n                    universal_newlines=True,\n                    **kwargs)\n    try:\n        yield process\n    finally:\n        process.stdout.close()\n        process.stderr.close()\n        process.stdin.close()\n        process.wait()",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148875,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ],
    "human": "Correct"
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "@app.route('/delete_video/<filename>')\ndef delete_video(filename):\n\tif 'username' in session:\n\t\t#os.remove(\"static/videos/{}\".format(filename))\n\t\tprint(session['username'], file=sys.stdout)\n\t\tdata=users.query.filter_by(Username=session['username']).first()\n\t\tvideo=Video.query.filter_by(UserID=data.UserID,Name=filename).first()\n\t\tif video != None:\n\t\t\tos.remove(\"static/videos/{}\".format(filename))\n\t\t\tdb.session.delete(video)\n\t\t\tdb.session.commit()\n\t\telse:\n\t\t\treturn \"Don't delete other people's videos!\"\n\t\treturn redirect(url_for('upload'))\n\treturn \"test\"",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148876,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "@app.route('/delete_video/<filename>')\ndef delete_video(filename):\n\tif 'username' in session:\n\t\t#os.remove(\"static/videos/{}\".format(filename))\n\t\tprint(session['username'], file=sys.stdout)\n\t\tdata=users.query.filter_by(Username=session['username']).first()\n\t\tvideo=Video.query.filter_by(UserID=data.UserID,Name=filename).first()\n\t\tif video != None:\n\t\t\t#os.remove(\"static/videos/{}\".format(filename))\n\t\t\tos.system(\"rm static/videos/{}\".format(filename))\n\t\t\tdb.session.delete(video)\n\t\t\tdb.session.commit()\n\t\telse:\n\t\t\treturn \"Don't delete other people's videos!\"\n\t\treturn redirect(url_for('upload'))\n\treturn \"test\"",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148877,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def whitelist(users: str):\n    for user in users.split():\n        call(WHITELIST_COMMAND_TEMPLATE.format(user))",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148878,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def whitelist(channel: discord.TextChannel, users: str):\n    for user in users.split():\n        if not re.match(r'^[A-Za-z0-9_]{3,16}$', user):  # as per https://help.mojang.com/customer/en/portal/articles/928638-minecraft-usernames?b_id=5408\n            await channel.send('\\'{}\\' is not a valid Minecraft username'.format(user))\n        else:\n            call(WHITELIST_COMMAND_TEMPLATE.format(user))",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148879,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_create_host(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        self.stubs.Set(hpfcdriver.hpcommon.HP3PARCommon, \"get_cpg\",\n                       self.fake_get_cpg)\n        self.stubs.Set(hpfcdriver.hpcommon.HP3PARCommon, \"get_domain\",\n                       self.fake_get_domain)\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_host_cmd = 'showhost -verbose fakehost'\n        _run_ssh(show_host_cmd, False).AndReturn([pack('no hosts listed'), ''])\n\n        create_host_cmd = ('createhost -persona 1 -domain (\\'OpenStack\\',) '\n                           'fakehost 123456789012345 123456789054321')\n        _run_ssh(create_host_cmd, False).AndReturn([CLI_CR, ''])\n\n        _run_ssh(show_host_cmd, False).AndReturn([pack(FC_HOST_RET), ''])\n        self.mox.ReplayAll()\n\n        host = self.driver._create_host(self.volume, self.connector)\n        self.assertEqual(host['name'], self.FAKE_HOST)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148880,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ],
    "human": "Correct"
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_create_host(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        self.stubs.Set(hpfcdriver.hpcommon.HP3PARCommon, \"get_cpg\",\n                       self.fake_get_cpg)\n        self.stubs.Set(hpfcdriver.hpcommon.HP3PARCommon, \"get_domain\",\n                       self.fake_get_domain)\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_host_cmd = ['showhost', '-verbose', 'fakehost']\n        _run_ssh(show_host_cmd, False).AndReturn([pack('no hosts listed'), ''])\n\n        create_host_cmd = (['createhost', '-persona', '1', '-domain',\n                            ('OpenStack',), 'fakehost', '123456789012345',\n                            '123456789054321'])\n        _run_ssh(create_host_cmd, False).AndReturn([CLI_CR, ''])\n\n        _run_ssh(show_host_cmd, False).AndReturn([pack(FC_HOST_RET), ''])\n        self.mox.ReplayAll()\n\n        host = self.driver._create_host(self.volume, self.connector)\n        self.assertEqual(host['name'], self.FAKE_HOST)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148881,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ],
    "human": "Correct"
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def do_setup(self, ctxt):\n        \"\"\"Check that we have all configuration details from the storage.\"\"\"\n\n        LOG.debug(_('enter: do_setup'))\n        self._context = ctxt\n\n        # Validate that the pool exists\n        ssh_cmd = 'svcinfo lsmdiskgrp -delim ! -nohdr'\n        out, err = self._run_ssh(ssh_cmd)\n        self._assert_ssh_return(len(out.strip()), 'do_setup',\n                                ssh_cmd, out, err)\n        search_text = '!%s!' % self.configuration.storwize_svc_volpool_name\n        if search_text not in out:\n            raise exception.InvalidInput(\n                reason=(_('pool %s doesn\\'t exist')\n                        % self.configuration.storwize_svc_volpool_name))\n\n        # Check if compression is supported\n        self._compression_enabled = False\n        try:\n            ssh_cmd = 'svcinfo lslicense -delim !'\n            out, err = self._run_ssh(ssh_cmd)\n            license_lines = out.strip().split('\\n')\n            for license_line in license_lines:\n                name, foo, value = license_line.partition('!')\n                if name in ('license_compression_enclosures',\n                            'license_compression_capacity') and value != '0':\n                    self._compression_enabled = True\n                    break\n        except exception.ProcessExecutionError:\n            LOG.exception(_('Failed to get license information.'))\n\n        # Get the iSCSI and FC names of the Storwize/SVC nodes\n        ssh_cmd = 'svcinfo lsnode -delim !'\n        out, err = self._run_ssh(ssh_cmd)\n        self._assert_ssh_return(len(out.strip()), 'do_setup',\n                                ssh_cmd, out, err)\n\n        nodes = out.strip().split('\\n')\n        self._assert_ssh_return(len(nodes),\n                                'do_setup', ssh_cmd, out, err)\n        header = nodes.pop(0)\n        for node_line in nodes:\n            try:\n                node_data = self._get_hdr_dic(header, node_line, '!')\n            except exception.VolumeBackendAPIException:\n                with excutils.save_and_reraise_exception():\n                    self._log_cli_output_error('do_setup',\n                                               ssh_cmd, out, err)\n            node = {}\n            try:\n                node['id'] = node_data['id']\n                node['name'] = node_data['name']\n                node['IO_group'] = node_data['IO_group_id']\n                node['iscsi_name'] = node_data['iscsi_name']\n                node['WWNN'] = node_data['WWNN']\n                node['status'] = node_data['status']\n                node['WWPN'] = []\n                node['ipv4'] = []\n                node['ipv6'] = []\n                node['enabled_protocols'] = []\n                if node['status'] == 'online':\n                    self._storage_nodes[node['id']] = node\n            except KeyError:\n                self._handle_keyerror('lsnode', header)\n\n        # Get the iSCSI IP addresses and WWPNs of the Storwize/SVC nodes\n        self._get_iscsi_ip_addrs()\n        self._get_fc_wwpns()\n\n        # For each node, check what connection modes it supports.  Delete any\n        # nodes that do not support any types (may be partially configured).\n        to_delete = []\n        for k, node in self._storage_nodes.iteritems():\n            if ((len(node['ipv4']) or len(node['ipv6']))\n                    and len(node['iscsi_name'])):\n                node['enabled_protocols'].append('iSCSI')\n                self._enabled_protocols.add('iSCSI')\n            if len(node['WWPN']):\n                node['enabled_protocols'].append('FC')\n                self._enabled_protocols.add('FC')\n            if not len(node['enabled_protocols']):\n                to_delete.append(k)\n\n        for delkey in to_delete:\n            del self._storage_nodes[delkey]\n\n        # Make sure we have at least one node configured\n        self._driver_assert(len(self._storage_nodes),\n                            _('do_setup: No configured nodes'))\n\n        LOG.debug(_('leave: do_setup'))",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148882,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def do_setup(self, ctxt):\n        \"\"\"Check that we have all configuration details from the storage.\"\"\"\n\n        LOG.debug(_('enter: do_setup'))\n        self._context = ctxt\n\n        # Validate that the pool exists\n        ssh_cmd = ['svcinfo', 'lsmdiskgrp', '-delim', '!', '-nohdr']\n        out, err = self._run_ssh(ssh_cmd)\n        self._assert_ssh_return(len(out.strip()), 'do_setup',\n                                ssh_cmd, out, err)\n        search_text = '!%s!' % self.configuration.storwize_svc_volpool_name\n        if search_text not in out:\n            raise exception.InvalidInput(\n                reason=(_('pool %s doesn\\'t exist')\n                        % self.configuration.storwize_svc_volpool_name))\n\n        # Check if compression is supported\n        self._compression_enabled = False\n        try:\n            ssh_cmd = ['svcinfo', 'lslicense', '-delim', '!']\n            out, err = self._run_ssh(ssh_cmd)\n            license_lines = out.strip().split('\\n')\n            for license_line in license_lines:\n                name, foo, value = license_line.partition('!')\n                if name in ('license_compression_enclosures',\n                            'license_compression_capacity') and value != '0':\n                    self._compression_enabled = True\n                    break\n        except exception.ProcessExecutionError:\n            LOG.exception(_('Failed to get license information.'))\n\n        # Get the iSCSI and FC names of the Storwize/SVC nodes\n        ssh_cmd = ['svcinfo', 'lsnode', '-delim', '!']\n        out, err = self._run_ssh(ssh_cmd)\n        self._assert_ssh_return(len(out.strip()), 'do_setup',\n                                ssh_cmd, out, err)\n\n        nodes = out.strip().split('\\n')\n        self._assert_ssh_return(len(nodes),\n                                'do_setup', ssh_cmd, out, err)\n        header = nodes.pop(0)\n        for node_line in nodes:\n            try:\n                node_data = self._get_hdr_dic(header, node_line, '!')\n            except exception.VolumeBackendAPIException:\n                with excutils.save_and_reraise_exception():\n                    self._log_cli_output_error('do_setup',\n                                               ssh_cmd, out, err)\n            node = {}\n            try:\n                node['id'] = node_data['id']\n                node['name'] = node_data['name']\n                node['IO_group'] = node_data['IO_group_id']\n                node['iscsi_name'] = node_data['iscsi_name']\n                node['WWNN'] = node_data['WWNN']\n                node['status'] = node_data['status']\n                node['WWPN'] = []\n                node['ipv4'] = []\n                node['ipv6'] = []\n                node['enabled_protocols'] = []\n                if node['status'] == 'online':\n                    self._storage_nodes[node['id']] = node\n            except KeyError:\n                self._handle_keyerror('lsnode', header)\n\n        # Get the iSCSI IP addresses and WWPNs of the Storwize/SVC nodes\n        self._get_iscsi_ip_addrs()\n        self._get_fc_wwpns()\n\n        # For each node, check what connection modes it supports.  Delete any\n        # nodes that do not support any types (may be partially configured).\n        to_delete = []\n        for k, node in self._storage_nodes.iteritems():\n            if ((len(node['ipv4']) or len(node['ipv6']))\n                    and len(node['iscsi_name'])):\n                node['enabled_protocols'].append('iSCSI')\n                self._enabled_protocols.add('iSCSI')\n            if len(node['WWPN']):\n                node['enabled_protocols'].append('FC')\n                self._enabled_protocols.add('FC')\n            if not len(node['enabled_protocols']):\n                to_delete.append(k)\n\n        for delkey in to_delete:\n            del self._storage_nodes[delkey]\n\n        # Make sure we have at least one node configured\n        self._driver_assert(len(self._storage_nodes),\n                            _('do_setup: No configured nodes'))\n\n        LOG.debug(_('leave: do_setup'))",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148883,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _execute_command_and_parse_attributes(self, ssh_cmd):\n        \"\"\"Execute command on the Storwize/SVC and parse attributes.\n\n        Exception is raised if the information from the system\n        can not be obtained.\n\n        \"\"\"\n\n        LOG.debug(_('enter: _execute_command_and_parse_attributes: '\n                    ' command %s') % ssh_cmd)\n\n        try:\n            out, err = self._run_ssh(ssh_cmd)\n        except exception.ProcessExecutionError as e:\n            # Didn't get details from the storage, return None\n            LOG.error(_('CLI Exception output:\\n command: %(cmd)s\\n '\n                        'stdout: %(out)s\\n stderr: %(err)s') %\n                      {'cmd': ssh_cmd,\n                       'out': e.stdout,\n                       'err': e.stderr})\n            return None\n\n        self._assert_ssh_return(len(out),\n                                '_execute_command_and_parse_attributes',\n                                ssh_cmd, out, err)\n        attributes = {}\n        for attrib_line in out.split('\\n'):\n            # If '!' not found, return the string and two empty strings\n            attrib_name, foo, attrib_value = attrib_line.partition('!')\n            if attrib_name is not None and len(attrib_name.strip()):\n                attributes[attrib_name] = attrib_value\n\n        LOG.debug(_('leave: _execute_command_and_parse_attributes:\\n'\n                    'command: %(cmd)s\\n'\n                    'attributes: %(attr)s')\n                  % {'cmd': ssh_cmd,\n                     'attr': str(attributes)})\n\n        return attributes",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148884,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _execute_command_and_parse_attributes(self, ssh_cmd):\n        \"\"\"Execute command on the Storwize/SVC and parse attributes.\n\n        Exception is raised if the information from the system\n        can not be obtained.\n\n        \"\"\"\n\n        LOG.debug(_('enter: _execute_command_and_parse_attributes: '\n                    ' command %s') % str(ssh_cmd))\n\n        try:\n            out, err = self._run_ssh(ssh_cmd)\n        except exception.ProcessExecutionError as e:\n            # Didn't get details from the storage, return None\n            LOG.error(_('CLI Exception output:\\n command: %(cmd)s\\n '\n                        'stdout: %(out)s\\n stderr: %(err)s') %\n                      {'cmd': ssh_cmd,\n                       'out': e.stdout,\n                       'err': e.stderr})\n            return None\n\n        self._assert_ssh_return(len(out),\n                                '_execute_command_and_parse_attributes',\n                                ssh_cmd, out, err)\n        attributes = {}\n        for attrib_line in out.split('\\n'):\n            # If '!' not found, return the string and two empty strings\n            attrib_name, foo, attrib_value = attrib_line.partition('!')\n            if attrib_name is not None and len(attrib_name.strip()):\n                attributes[attrib_name] = attrib_value\n\n        LOG.debug(_('leave: _execute_command_and_parse_attributes:\\n'\n                    'command: %(cmd)s\\n'\n                    'attributes: %(attr)s')\n                  % {'cmd': str(ssh_cmd),\n                     'attr': str(attributes)})\n\n        return attributes",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148885,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_get_iscsi_ip_active(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record set up\n        self.clear_mox()\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_port_cmd = 'showport'\n        _run_ssh(show_port_cmd, False).AndReturn([pack(PORT_RET), ''])\n\n        show_port_i_cmd = 'showport -iscsi'\n        _run_ssh(show_port_i_cmd, False).AndReturn([pack(READY_ISCSI_PORT_RET),\n                                                    ''])\n\n        show_port_i_cmd = 'showport -iscsiname'\n        _run_ssh(show_port_i_cmd, False).AndReturn([pack(SHOW_PORT_ISCSI), ''])\n\n        self.mox.ReplayAll()\n\n        config = self.setup_configuration()\n        config.hp3par_iscsi_ips = ['10.10.220.253', '10.10.220.252']\n        self.setup_driver(config, set_up_fakes=False)\n\n        #record\n        self.clear_mox()\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_vlun_cmd = 'showvlun -a -host fakehost'\n        _run_ssh(show_vlun_cmd, False).AndReturn([pack(SHOW_VLUN), ''])\n\n        self.mox.ReplayAll()\n\n        ip = self.driver._get_iscsi_ip('fakehost')\n        self.assertEqual(ip, '10.10.220.253')",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148886,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_get_iscsi_ip_active(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record set up\n        self.clear_mox()\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_port_cmd = ['showport']\n        _run_ssh(show_port_cmd, False).AndReturn([pack(PORT_RET), ''])\n\n        show_port_i_cmd = ['showport', '-iscsi']\n        _run_ssh(show_port_i_cmd, False).AndReturn([pack(READY_ISCSI_PORT_RET),\n                                                    ''])\n\n        show_port_i_cmd = ['showport', '-iscsiname']\n        _run_ssh(show_port_i_cmd, False).AndReturn([pack(SHOW_PORT_ISCSI), ''])\n\n        self.mox.ReplayAll()\n\n        config = self.setup_configuration()\n        config.hp3par_iscsi_ips = ['10.10.220.253', '10.10.220.252']\n        self.setup_driver(config, set_up_fakes=False)\n\n        #record\n        self.clear_mox()\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_vlun_cmd = ['showvlun', '-a', '-host', 'fakehost']\n        _run_ssh(show_vlun_cmd, False).AndReturn([pack(SHOW_VLUN), ''])\n\n        self.mox.ReplayAll()\n\n        ip = self.driver._get_iscsi_ip('fakehost')\n        self.assertEqual(ip, '10.10.220.253')",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148887,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _find_host_from_wwpn(self, connector):\n        for wwpn in connector['wwpns']:\n            ssh_cmd = 'svcinfo lsfabric -wwpn %s -delim !' % wwpn\n            out, err = self._run_ssh(ssh_cmd)\n\n            if not len(out.strip()):\n                # This WWPN is not in use\n                continue\n\n            host_lines = out.strip().split('\\n')\n            header = host_lines.pop(0).split('!')\n            self._assert_ssh_return('remote_wwpn' in header and\n                                    'name' in header,\n                                    '_find_host_from_wwpn',\n                                    ssh_cmd, out, err)\n            rmt_wwpn_idx = header.index('remote_wwpn')\n            name_idx = header.index('name')\n\n            wwpns = map(lambda x: x.split('!')[rmt_wwpn_idx], host_lines)\n\n            if wwpn in wwpns:\n                # All the wwpns will be the mapping for the same\n                # host from this WWPN-based query. Just pick\n                # the name from first line.\n                hostname = host_lines[0].split('!')[name_idx]\n                return hostname\n\n        # Didn't find a host\n        return None",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148888,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _find_host_from_wwpn(self, connector):\n        for wwpn in connector['wwpns']:\n            ssh_cmd = ['svcinfo', 'lsfabric', '-wwpn', wwpn, '-delim', '!']\n            out, err = self._run_ssh(ssh_cmd)\n\n            if not len(out.strip()):\n                # This WWPN is not in use\n                continue\n\n            host_lines = out.strip().split('\\n')\n            header = host_lines.pop(0).split('!')\n            self._assert_ssh_return('remote_wwpn' in header and\n                                    'name' in header,\n                                    '_find_host_from_wwpn',\n                                    ssh_cmd, out, err)\n            rmt_wwpn_idx = header.index('remote_wwpn')\n            name_idx = header.index('name')\n\n            wwpns = map(lambda x: x.split('!')[rmt_wwpn_idx], host_lines)\n\n            if wwpn in wwpns:\n                # All the wwpns will be the mapping for the same\n                # host from this WWPN-based query. Just pick\n                # the name from first line.\n                hostname = host_lines[0].split('!')[name_idx]\n                return hostname\n\n        # Didn't find a host\n        return None",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148889,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def extend_volume(self, volume, new_size):\n        LOG.debug(_('enter: extend_volume: volume %s') % volume['id'])\n        ret = self._ensure_vdisk_no_fc_mappings(volume['name'],\n                                                allow_snaps=False)\n        if not ret:\n            exception_message = (_('extend_volume: Extending a volume with '\n                                   'snapshots is not supported.'))\n            raise exception.VolumeBackendAPIException(data=exception_message)\n\n        extend_amt = int(new_size) - volume['size']\n        ssh_cmd = ('svctask expandvdisksize -size %(amt)d -unit gb %(name)s'\n                   % {'amt': extend_amt, 'name': volume['name']})\n        out, err = self._run_ssh(ssh_cmd)\n        # No output should be returned from expandvdisksize\n        self._assert_ssh_return(len(out.strip()) == 0, 'extend_volume',\n                                ssh_cmd, out, err)\n        LOG.debug(_('leave: extend_volume: volume %s') % volume['id'])",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148890,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def extend_volume(self, volume, new_size):\n        LOG.debug(_('enter: extend_volume: volume %s') % volume['id'])\n        ret = self._ensure_vdisk_no_fc_mappings(volume['name'],\n                                                allow_snaps=False)\n        if not ret:\n            exception_message = (_('extend_volume: Extending a volume with '\n                                   'snapshots is not supported.'))\n            raise exception.VolumeBackendAPIException(data=exception_message)\n\n        extend_amt = int(new_size) - volume['size']\n        ssh_cmd = (['svctask', 'expandvdisksize', '-size', str(extend_amt),\n                    '-unit', 'gb', volume['name']])\n        out, err = self._run_ssh(ssh_cmd)\n        # No output should be returned from expandvdisksize\n        self._assert_ssh_return(len(out.strip()) == 0, 'extend_volume',\n                                ssh_cmd, out, err)\n        LOG.debug(_('leave: extend_volume: volume %s') % volume['id'])",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148891,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_host_from_connector(self, connector):\n        \"\"\"List the hosts defined in the storage.\n\n        Return the host name with the given connection info, or None if there\n        is no host fitting that information.\n\n        \"\"\"\n\n        prefix = self._connector_to_hostname_prefix(connector)\n        LOG.debug(_('enter: _get_host_from_connector: prefix %s') % prefix)\n\n        # Get list of host in the storage\n        ssh_cmd = 'svcinfo lshost -delim !'\n        out, err = self._run_ssh(ssh_cmd)\n\n        if not len(out.strip()):\n            return None\n\n        # If we have FC information, we have a faster lookup option\n        hostname = None\n        if 'wwpns' in connector:\n            hostname = self._find_host_from_wwpn(connector)\n\n        # If we don't have a hostname yet, try the long way\n        if not hostname:\n            host_lines = out.strip().split('\\n')\n            self._assert_ssh_return(len(host_lines),\n                                    '_get_host_from_connector',\n                                    ssh_cmd, out, err)\n            header = host_lines.pop(0).split('!')\n            self._assert_ssh_return('name' in header,\n                                    '_get_host_from_connector',\n                                    ssh_cmd, out, err)\n            name_index = header.index('name')\n            hosts = map(lambda x: x.split('!')[name_index], host_lines)\n            hostname = self._find_host_exhaustive(connector, hosts)\n\n        LOG.debug(_('leave: _get_host_from_connector: host %s') % hostname)\n\n        return hostname",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148892,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_host_from_connector(self, connector):\n        \"\"\"List the hosts defined in the storage.\n\n        Return the host name with the given connection info, or None if there\n        is no host fitting that information.\n\n        \"\"\"\n\n        prefix = self._connector_to_hostname_prefix(connector)\n        LOG.debug(_('enter: _get_host_from_connector: prefix %s') % prefix)\n\n        # Get list of host in the storage\n        ssh_cmd = ['svcinfo', 'lshost', '-delim', '!']\n        out, err = self._run_ssh(ssh_cmd)\n\n        if not len(out.strip()):\n            return None\n\n        # If we have FC information, we have a faster lookup option\n        hostname = None\n        if 'wwpns' in connector:\n            hostname = self._find_host_from_wwpn(connector)\n\n        # If we don't have a hostname yet, try the long way\n        if not hostname:\n            host_lines = out.strip().split('\\n')\n            self._assert_ssh_return(len(host_lines),\n                                    '_get_host_from_connector',\n                                    ssh_cmd, out, err)\n            header = host_lines.pop(0).split('!')\n            self._assert_ssh_return('name' in header,\n                                    '_get_host_from_connector',\n                                    ssh_cmd, out, err)\n            name_index = header.index('name')\n            hosts = map(lambda x: x.split('!')[name_index], host_lines)\n            hostname = self._find_host_exhaustive(connector, hosts)\n\n        LOG.debug(_('leave: _get_host_from_connector: host %s') % hostname)\n\n        return hostname",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148893,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_hostvdisk_mappings(self, host_name):\n        \"\"\"Return the defined storage mappings for a host.\"\"\"\n\n        return_data = {}\n        ssh_cmd = 'svcinfo lshostvdiskmap -delim ! %s' % host_name\n        out, err = self._run_ssh(ssh_cmd)\n\n        mappings = out.strip().split('\\n')\n        if len(mappings):\n            header = mappings.pop(0)\n            for mapping_line in mappings:\n                mapping_data = self._get_hdr_dic(header, mapping_line, '!')\n                return_data[mapping_data['vdisk_name']] = mapping_data\n\n        return return_data",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148894,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_hostvdisk_mappings(self, host_name):\n        \"\"\"Return the defined storage mappings for a host.\"\"\"\n\n        return_data = {}\n        ssh_cmd = ['svcinfo', 'lshostvdiskmap', '-delim', '!', host_name]\n        out, err = self._run_ssh(ssh_cmd)\n\n        mappings = out.strip().split('\\n')\n        if len(mappings):\n            header = mappings.pop(0)\n            for mapping_line in mappings:\n                mapping_data = self._get_hdr_dic(header, mapping_line, '!')\n                return_data[mapping_data['vdisk_name']] = mapping_data\n\n        return return_data",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148895,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def main():\n    global word\n    print(\"Starting script... press 'ctrl+c' in terminal to turn off\")\n    while True:\n        if pyperclip.paste() != word and len(pyperclip.paste().split())<5:\n            word = pyperclip.paste()\n            wordChc=False\n            req = requests.get(\"https://api-portal.dictionary.com/dcom/pageData/%s\" % word)\n            wordChcURB = False\n            reqURB=requests.get('https://api.urbandictionary.com/v0/define?term=%s' % word)\n            try:    \n                data = json.loads(req.text)['data']['content'][0]['entries'][0]['posBlocks'][0]['definitions']\n            except TypeError:\n                os.system('notify-send \"Cant find |%s| on dictionary.com!\"' % word)\n                wordChc = True\n            except KeyError:\n                os.system('notify-send \"Cant find |%s| on dictionary.com!\"' % word)\n                wordChc = True\n\n            if not wordChc:\n                definitions = []\n                try:\n                    for definition in data[:3]:\n                        definitions.append(cleanhtml(definition['definition']))\n                        definitions.append(\"------------\")\n                    os.system('notify-send \"definitions from dictionary.com:[{}\\n{}\"'\\\n                    .format(word+\"]\\n------------\",'\\n'.join(definitions)))\n                except KeyError:\n                    os.system('notify-send \"no results in dictionary.com\"')\n            try:    \n                dataURB = json.loads(reqURB.text)['list']\n            except TypeError:\n                os.system('notify-send \"Cant find |%s| on urbandictionary.com!\"' % word)\n                wordChcURB = True\n            except KeyError:\n                os.system('notify-send \"Cant find |%s| on urbandictionary.com!\"' % word)\n                wordChcURB = True\n\n            if not wordChcURB:    \n                definitionsURB = []\n                for definition in dataURB[:3]:\n                    definitionsURB.append(definition['definition'])\n                    definitionsURB.append(\"------------\")\n                os.system('notify-send \"definitions from urbandictionary.com:[{}\\n{}\"'\\\n                .format(word+\"]\\n------------\",'\\n'.join(definitionsURB)))\n    os.system('notify-send \"Thank you for using define.py made by kelj0\"')",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148896,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def main():\n    global word\n    print(\"Starting script... press 'ctrl+c' in terminal to turn off\")\n    while True:\n        if pyperclip.paste() != word and len(pyperclip.paste().split())<5:\n            word = pyperclip.paste()\n            wordChc=False\n            req = requests.get(\"https://api-portal.dictionary.com/dcom/pageData/%s\" % word)\n            wordChcURB = False\n            reqURB=requests.get('https://api.urbandictionary.com/v0/define?term=%s' % word)\n            try:    \n                data = json.loads(req.text)['data']['content'][0]['entries'][0]['posBlocks'][0]['definitions']\n            except TypeError:\n                os.system('notify-send \"Cant find that word on dictionary.com!\"')\n                wordChc = True\n            except KeyError:\n                os.system('notify-send \"Cant find that word on dictionary.com!\"')\n                wordChc = True\n\n            if not wordChc:\n                definitions = []\n                try:\n                    for definition in data[:3]:\n                        definitions.append(cleanhtml(definition['definition']))\n                        definitions.append(\"------------\")\n                    os.system('notify-send \"definitions from dictionary.com:\\n{}\"'.format('\\n'.join(definitions)))\n                except KeyError:\n                    os.system('notify-send \"no results in dictionary.com\"')\n            try:    \n                dataURB = json.loads(reqURB.text)['list']\n            except TypeError:\n                os.system('notify-send \"Cant find that word on urbandictionary.com!\"' % word)\n                wordChcURB = True\n            except KeyError:\n                os.system('notify-send \"Cant find that word on urbandictionary.com!\"' % word)\n                wordChcURB = True\n\n            if not wordChcURB:    \n                definitionsURB = []\n                for definition in dataURB[:3]:\n                    definitionsURB.append(definition['definition'])\n                    definitionsURB.append(\"------------\")\n                os.system('notify-send \"definitions from urbandictionary.com:\\n{}\"'.format('\\n'.join(definitionsURB)))\n    os.system('notify-send \"Thank you for using define.py made by kelj0\"')",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148897,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_vvset_from_3par(self, volume_name):\n        \"\"\"Get Virtual Volume Set from 3PAR.\n\n        The only way to do this currently is to try and delete the volume\n        to get the error message.\n\n        NOTE(walter-boring): don't call this unless you know the volume is\n        already in a vvset!\n        \"\"\"\n        cmd = \"removevv -f %s\" % volume_name\n        LOG.debug(\"Issuing remove command to find vvset name %s\" % cmd)\n        out = self._cli_run(cmd, None)\n        vvset_name = None\n        if out and len(out) > 1:\n            if out[1].startswith(\"Attempt to delete \"):\n                words = out[1].split(\" \")\n                vvset_name = words[len(words) - 1]\n\n        return vvset_name",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148898,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_vvset_from_3par(self, volume_name):\n        \"\"\"Get Virtual Volume Set from 3PAR.\n\n        The only way to do this currently is to try and delete the volume\n        to get the error message.\n\n        NOTE(walter-boring): don't call this unless you know the volume is\n        already in a vvset!\n        \"\"\"\n        cmd = ['removevv', '-f', volume_name]\n        LOG.debug(\"Issuing remove command to find vvset name %s\" % cmd)\n        out = self._cli_run(cmd)\n        vvset_name = None\n        if out and len(out) > 1:\n            if out[1].startswith(\"Attempt to delete \"):\n                words = out[1].split(\" \")\n                vvset_name = words[len(words) - 1]\n\n        return vvset_name",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148899,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_flashcopy_mapping_attributes(self, fc_map_id):\n        LOG.debug(_('enter: _get_flashcopy_mapping_attributes: mapping %s')\n                  % fc_map_id)\n\n        fc_ls_map_cmd = 'svcinfo lsfcmap -filtervalue id=%s -delim !' % \\\n            fc_map_id\n        out, err = self._run_ssh(fc_ls_map_cmd)\n        if not len(out.strip()):\n            return None\n\n        # Get list of FlashCopy mappings\n        # We expect zero or one line if mapping does not exist,\n        # two lines if it does exist, otherwise error\n        lines = out.strip().split('\\n')\n        self._assert_ssh_return(len(lines) <= 2,\n                                '_get_flashcopy_mapping_attributes',\n                                fc_ls_map_cmd, out, err)\n\n        if len(lines) == 2:\n            attributes = self._get_hdr_dic(lines[0], lines[1], '!')\n        else:  # 0 or 1 lines\n            attributes = None\n\n        LOG.debug(_('leave: _get_flashcopy_mapping_attributes: mapping '\n                    '%(fc_map_id)s, attributes %(attributes)s') %\n                  {'fc_map_id': fc_map_id, 'attributes': attributes})\n\n        return attributes",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148900,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_flashcopy_mapping_attributes(self, fc_map_id):\n        LOG.debug(_('enter: _get_flashcopy_mapping_attributes: mapping %s')\n                  % fc_map_id)\n\n        fc_ls_map_cmd = ['svcinfo', 'lsfcmap', '-filtervalue',\n                         'id=%s' % fc_map_id, '-delim', '!']\n        out, err = self._run_ssh(fc_ls_map_cmd)\n        if not len(out.strip()):\n            return None\n\n        # Get list of FlashCopy mappings\n        # We expect zero or one line if mapping does not exist,\n        # two lines if it does exist, otherwise error\n        lines = out.strip().split('\\n')\n        self._assert_ssh_return(len(lines) <= 2,\n                                '_get_flashcopy_mapping_attributes',\n                                fc_ls_map_cmd, out, err)\n\n        if len(lines) == 2:\n            attributes = self._get_hdr_dic(lines[0], lines[1], '!')\n        else:  # 0 or 1 lines\n            attributes = None\n\n        LOG.debug(_('leave: _get_flashcopy_mapping_attributes: mapping '\n                    '%(fc_map_id)s, attributes %(attributes)s') %\n                  {'fc_map_id': fc_map_id, 'attributes': attributes})\n\n        return attributes",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148901,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _add_volume_to_volume_set(self, volume, volume_name,\n                                  cpg, vvs_name, qos):\n        if vvs_name is not None:\n            # Admin has set a volume set name to add the volume to\n            self._cli_run('createvvset -add %s %s' % (vvs_name,\n                                                      volume_name), None)\n        else:\n            vvs_name = self._get_3par_vvs_name(volume['id'])\n            domain = self.get_domain(cpg)\n            self._cli_run('createvvset -domain %s %s' % (domain,\n                                                         vvs_name), None)\n            self._set_qos_rule(qos, vvs_name)\n            self._cli_run('createvvset -add %s %s' % (vvs_name,\n                                                      volume_name), None)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148902,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _add_volume_to_volume_set(self, volume, volume_name,\n                                  cpg, vvs_name, qos):\n        if vvs_name is not None:\n            # Admin has set a volume set name to add the volume to\n            self._cli_run(['createvvset', '-add', vvs_name, volume_name])\n        else:\n            vvs_name = self._get_3par_vvs_name(volume['id'])\n            domain = self.get_domain(cpg)\n            self._cli_run(['createvvset', '-domain', domain, vvs_name])\n            self._set_qos_rule(qos, vvs_name)\n            self._cli_run(['createvvset', '-add', vvs_name, volume_name])",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148903,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_initialize_connection(self):\n        self.driver._eql_execute = self.mox.\\\n            CreateMock(self.driver._eql_execute)\n        volume = {'name': self.volume_name}\n        self.stubs.Set(self.driver, \"_get_iscsi_properties\",\n                       self._fake_get_iscsi_properties)\n        self.driver._eql_execute('volume', 'select', volume['name'], 'access',\n                                 'create', 'initiator',\n                                 self.connector['initiator'],\n                                 'authmethod chap',\n                                 'username',\n                                 self.configuration.eqlx_chap_login)\n        self.mox.ReplayAll()\n        iscsi_properties = self.driver.initialize_connection(volume,\n                                                             self.connector)\n        self.assertEqual(iscsi_properties['data'],\n                         self._fake_get_iscsi_properties(volume))",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148904,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_initialize_connection(self):\n        self.driver._eql_execute = self.mox.\\\n            CreateMock(self.driver._eql_execute)\n        volume = {'name': self.volume_name}\n        self.stubs.Set(self.driver, \"_get_iscsi_properties\",\n                       self._fake_get_iscsi_properties)\n        self.driver._eql_execute('volume', 'select', volume['name'], 'access',\n                                 'create', 'initiator',\n                                 self.connector['initiator'],\n                                 'authmethod', 'chap',\n                                 'username',\n                                 self.configuration.eqlx_chap_login)\n        self.mox.ReplayAll()\n        iscsi_properties = self.driver.initialize_connection(volume,\n                                                             self.connector)\n        self.assertEqual(iscsi_properties['data'],\n                         self._fake_get_iscsi_properties(volume))",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148905,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_create_invalid_host(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_cpg\",\n                       self.fake_get_cpg)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_domain\",\n                       self.fake_get_domain)\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_host_cmd = 'showhost -verbose fakehost'\n        _run_ssh(show_host_cmd, False).AndReturn([pack('no hosts listed'), ''])\n\n        create_host_cmd = ('createhost -persona 1 -domain (\\'OpenStack\\',) '\n                           'fakehost 123456789012345 123456789054321')\n        create_host_ret = pack(CLI_CR +\n                               'already used by host fakehost.foo (19)')\n        _run_ssh(create_host_cmd, False).AndReturn([create_host_ret, ''])\n\n        show_3par_cmd = 'showhost -verbose fakehost.foo'\n        _run_ssh(show_3par_cmd, False).AndReturn([pack(FC_SHOWHOST_RET), ''])\n        self.mox.ReplayAll()\n\n        host = self.driver._create_host(self.volume, self.connector)\n\n        self.assertEquals(host['name'], 'fakehost.foo')",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148906,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_create_invalid_host(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_cpg\",\n                       self.fake_get_cpg)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_domain\",\n                       self.fake_get_domain)\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_host_cmd = ['showhost', '-verbose', 'fakehost']\n        _run_ssh(show_host_cmd, False).AndReturn([pack('no hosts listed'), ''])\n\n        create_host_cmd = (['createhost', '-persona', '1', '-domain',\n                            ('OpenStack',), 'fakehost', '123456789012345',\n                            '123456789054321'])\n        create_host_ret = pack(CLI_CR +\n                               'already used by host fakehost.foo (19)')\n        _run_ssh(create_host_cmd, False).AndReturn([create_host_ret, ''])\n\n        show_3par_cmd = ['showhost', '-verbose', 'fakehost.foo']\n        _run_ssh(show_3par_cmd, False).AndReturn([pack(FC_SHOWHOST_RET), ''])\n        self.mox.ReplayAll()\n\n        host = self.driver._create_host(self.volume, self.connector)\n\n        self.assertEquals(host['name'], 'fakehost.foo')",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148907,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "@app.route('/api/uploads/<sid>/logs')\ndef get_logs(sid):\n    if '/' not in sid:\n        path = os.path.join(app.config['UPLOAD_FOLDER'], sid)\n        if os.path.isfile(os.path.join(path, app.config['LOG_FILE'])):\n            return send_from_directory(directory=path,\n                                        filename=app.config['LOG_FILE'])\n        else:\n            abort(404)\n    else:\n        abort(403)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148908,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "@app.route('/api/uploads/<sid>/logs')\ndef get_logs(sid):\n    if utils.sid_is_valid(sid):\n        path = join(app.config['UPLOAD_FOLDER'], sid)\n\n        if os.path.isfile(join(path, app.config['LOG_FILE'])):\n            return send_from_directory(directory=path,\n                                        filename=app.config['LOG_FILE'])\n        else:\n            abort(404)\n    else:\n        abort(404)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148909,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _make_fc_map(self, source, target, full_copy):\n        copyflag = '' if full_copy else '-copyrate 0'\n        fc_map_cli_cmd = ('svctask mkfcmap -source %(src)s -target %(tgt)s '\n                          '-autodelete %(copyflag)s' %\n                          {'src': source,\n                           'tgt': target,\n                           'copyflag': copyflag})\n        out, err = self._run_ssh(fc_map_cli_cmd)\n        self._driver_assert(\n            len(out.strip()),\n            _('create FC mapping from %(source)s to %(target)s - '\n              'did not find success message in CLI output.\\n'\n              ' stdout: %(out)s\\n stderr: %(err)s\\n')\n            % {'source': source,\n               'target': target,\n               'out': str(out),\n               'err': str(err)})\n\n        # Ensure that the output is as expected\n        match_obj = re.search('FlashCopy Mapping, id \\[([0-9]+)\\], '\n                              'successfully created', out)\n        # Make sure we got a \"successfully created\" message with vdisk id\n        self._driver_assert(\n            match_obj is not None,\n            _('create FC mapping from %(source)s to %(target)s - '\n              'did not find success message in CLI output.\\n'\n              ' stdout: %(out)s\\n stderr: %(err)s\\n')\n            % {'source': source,\n               'target': target,\n               'out': str(out),\n               'err': str(err)})\n\n        try:\n            fc_map_id = match_obj.group(1)\n            self._driver_assert(\n                fc_map_id is not None,\n                _('create FC mapping from %(source)s to %(target)s - '\n                  'did not find mapping id in CLI output.\\n'\n                  ' stdout: %(out)s\\n stderr: %(err)s\\n')\n                % {'source': source,\n                   'target': target,\n                   'out': str(out),\n                   'err': str(err)})\n        except IndexError:\n            self._driver_assert(\n                False,\n                _('create FC mapping from %(source)s to %(target)s - '\n                  'did not find mapping id in CLI output.\\n'\n                  ' stdout: %(out)s\\n stderr: %(err)s\\n')\n                % {'source': source,\n                   'target': target,\n                   'out': str(out),\n                   'err': str(err)})\n        return fc_map_id",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148910,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _make_fc_map(self, source, target, full_copy):\n        fc_map_cli_cmd = ['svctask', 'mkfcmap', '-source', source, '-target',\n                          target, '-autodelete']\n        if not full_copy:\n            fc_map_cli_cmd.extend(['-copyrate', '0'])\n        out, err = self._run_ssh(fc_map_cli_cmd)\n        self._driver_assert(\n            len(out.strip()),\n            _('create FC mapping from %(source)s to %(target)s - '\n              'did not find success message in CLI output.\\n'\n              ' stdout: %(out)s\\n stderr: %(err)s\\n')\n            % {'source': source,\n               'target': target,\n               'out': str(out),\n               'err': str(err)})\n\n        # Ensure that the output is as expected\n        match_obj = re.search('FlashCopy Mapping, id \\[([0-9]+)\\], '\n                              'successfully created', out)\n        # Make sure we got a \"successfully created\" message with vdisk id\n        self._driver_assert(\n            match_obj is not None,\n            _('create FC mapping from %(source)s to %(target)s - '\n              'did not find success message in CLI output.\\n'\n              ' stdout: %(out)s\\n stderr: %(err)s\\n')\n            % {'source': source,\n               'target': target,\n               'out': str(out),\n               'err': str(err)})\n\n        try:\n            fc_map_id = match_obj.group(1)\n            self._driver_assert(\n                fc_map_id is not None,\n                _('create FC mapping from %(source)s to %(target)s - '\n                  'did not find mapping id in CLI output.\\n'\n                  ' stdout: %(out)s\\n stderr: %(err)s\\n')\n                % {'source': source,\n                   'target': target,\n                   'out': str(out),\n                   'err': str(err)})\n        except IndexError:\n            self._driver_assert(\n                False,\n                _('create FC mapping from %(source)s to %(target)s - '\n                  'did not find mapping id in CLI output.\\n'\n                  ' stdout: %(out)s\\n stderr: %(err)s\\n')\n                % {'source': source,\n                   'target': target,\n                   'out': str(out),\n                   'err': str(err)})\n        return fc_map_id",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148911,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_get_iscsi_ip(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record driver set up\n        self.clear_mox()\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_port_cmd = 'showport'\n        _run_ssh(show_port_cmd, False).AndReturn([pack(PORT_RET), ''])\n\n        show_port_i_cmd = 'showport -iscsi'\n        _run_ssh(show_port_i_cmd, False).AndReturn([pack(READY_ISCSI_PORT_RET),\n                                                    ''])\n\n        show_port_i_cmd = 'showport -iscsiname'\n        _run_ssh(show_port_i_cmd, False).AndReturn([pack(SHOW_PORT_ISCSI), ''])\n\n        #record\n        show_vlun_cmd = 'showvlun -a -host fakehost'\n        show_vlun_ret = 'no vluns listed\\r\\n'\n        _run_ssh(show_vlun_cmd, False).AndReturn([pack(show_vlun_ret), ''])\n        show_vlun_cmd = 'showvlun -a -showcols Port'\n        _run_ssh(show_vlun_cmd, False).AndReturn([pack(SHOW_VLUN_NONE), ''])\n\n        self.mox.ReplayAll()\n\n        config = self.setup_configuration()\n        config.iscsi_ip_address = '10.10.10.10'\n        config.hp3par_iscsi_ips = ['10.10.220.253', '10.10.220.252']\n        self.setup_driver(config, set_up_fakes=False)\n\n        ip = self.driver._get_iscsi_ip('fakehost')\n        self.assertEqual(ip, '10.10.220.252')",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148912,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_get_iscsi_ip(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record driver set up\n        self.clear_mox()\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_port_cmd = ['showport']\n        _run_ssh(show_port_cmd, False).AndReturn([pack(PORT_RET), ''])\n\n        show_port_i_cmd = ['showport', '-iscsi']\n        _run_ssh(show_port_i_cmd, False).AndReturn([pack(READY_ISCSI_PORT_RET),\n                                                    ''])\n\n        show_port_i_cmd = ['showport', '-iscsiname']\n        _run_ssh(show_port_i_cmd, False).AndReturn([pack(SHOW_PORT_ISCSI), ''])\n\n        #record\n        show_vlun_cmd = ['showvlun', '-a', '-host', 'fakehost']\n        show_vlun_ret = 'no vluns listed\\r\\n'\n        _run_ssh(show_vlun_cmd, False).AndReturn([pack(show_vlun_ret), ''])\n        show_vlun_cmd = ['showvlun', '-a', '-showcols', 'Port']\n        _run_ssh(show_vlun_cmd, False).AndReturn([pack(SHOW_VLUN_NONE), ''])\n\n        self.mox.ReplayAll()\n\n        config = self.setup_configuration()\n        config.iscsi_ip_address = '10.10.10.10'\n        config.hp3par_iscsi_ips = ['10.10.220.253', '10.10.220.252']\n        self.setup_driver(config, set_up_fakes=False)\n\n        ip = self.driver._get_iscsi_ip('fakehost')\n        self.assertEqual(ip, '10.10.220.252')",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148913,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def usage(args=None):\n    '''\n    Return usage information for volumes mounted on this minion\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' disk.usage\n    '''\n    if __grains__['kernel'] == 'Linux':\n        cmd = 'df -P'\n    elif __grains__['kernel'] == 'OpenBSD':\n        cmd = 'df -kP'\n    else:\n        cmd = 'df'\n    if args:\n        cmd = cmd + ' -' + args\n    ret = {}\n    out = __salt__['cmd.run'](cmd).splitlines()\n    for line in out:\n        if not line:\n            continue\n        if line.startswith('Filesystem'):\n            continue\n        comps = line.split()\n        while not comps[1].isdigit():\n            comps[0] = '{0} {1}'.format(comps[0], comps[1])\n            comps.pop(1)\n        try:\n            if __grains__['kernel'] == 'Darwin':\n                ret[comps[8]] = {\n                        'filesystem': comps[0],\n                        '512-blocks': comps[1],\n                        'used': comps[2],\n                        'available': comps[3],\n                        'capacity': comps[4],\n                        'iused': comps[5],\n                        'ifree': comps[6],\n                        '%iused': comps[7],\n                }\n            else:\n                ret[comps[5]] = {\n                        'filesystem': comps[0],\n                        '1K-blocks': comps[1],\n                        'used': comps[2],\n                        'available': comps[3],\n                        'capacity': comps[4],\n                }\n        except IndexError:\n            log.warn(\"Problem parsing disk usage information\")\n            ret = {}\n    return ret",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148914,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def usage(args=None):\n    '''\n    Return usage information for volumes mounted on this minion\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' disk.usage\n    '''\n    flags = ''\n    allowed = ('a', 'B', 'h', 'H', 'i', 'k', 'l', 'P', 't', 'T', 'x', 'v')\n    for flag in args:\n        if flag in allowed:\n            flags += flag\n        else:\n            break\n    if __grains__['kernel'] == 'Linux':\n        cmd = 'df -P'\n    elif __grains__['kernel'] == 'OpenBSD':\n        cmd = 'df -kP'\n    else:\n        cmd = 'df'\n    if args:\n        cmd += ' -{0}'.format(flags)\n    ret = {}\n    out = __salt__['cmd.run'](cmd).splitlines()\n    for line in out:\n        if not line:\n            continue\n        if line.startswith('Filesystem'):\n            continue\n        comps = line.split()\n        while not comps[1].isdigit():\n            comps[0] = '{0} {1}'.format(comps[0], comps[1])\n            comps.pop(1)\n        try:\n            if __grains__['kernel'] == 'Darwin':\n                ret[comps[8]] = {\n                        'filesystem': comps[0],\n                        '512-blocks': comps[1],\n                        'used': comps[2],\n                        'available': comps[3],\n                        'capacity': comps[4],\n                        'iused': comps[5],\n                        'ifree': comps[6],\n                        '%iused': comps[7],\n                }\n            else:\n                ret[comps[5]] = {\n                        'filesystem': comps[0],\n                        '1K-blocks': comps[1],\n                        'used': comps[2],\n                        'available': comps[3],\n                        'capacity': comps[4],\n                }\n        except IndexError:\n            log.warn(\"Problem parsing disk usage information\")\n            ret = {}\n    return ret",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148915,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_fc_wwpns(self):\n        for key in self._storage_nodes:\n            node = self._storage_nodes[key]\n            ssh_cmd = 'svcinfo lsnode -delim ! %s' % node['id']\n            raw = self._run_ssh(ssh_cmd)\n            resp = CLIResponse(raw, delim='!', with_header=False)\n            wwpns = set(node['WWPN'])\n            for i, s in resp.select('port_id', 'port_status'):\n                if 'unconfigured' != s:\n                    wwpns.add(i)\n            node['WWPN'] = list(wwpns)\n            LOG.info(_('WWPN on node %(node)s: %(wwpn)s')\n                     % {'node': node['id'], 'wwpn': node['WWPN']})",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148916,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_fc_wwpns(self):\n        for key in self._storage_nodes:\n            node = self._storage_nodes[key]\n            ssh_cmd = ['svcinfo', 'lsnode', '-delim', '!', node['id']]\n            raw = self._run_ssh(ssh_cmd)\n            resp = CLIResponse(raw, delim='!', with_header=False)\n            wwpns = set(node['WWPN'])\n            for i, s in resp.select('port_id', 'port_status'):\n                if 'unconfigured' != s:\n                    wwpns.add(i)\n            node['WWPN'] = list(wwpns)\n            LOG.info(_('WWPN on node %(node)s: %(wwpn)s')\n                     % {'node': node['id'], 'wwpn': node['WWPN']})",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148917,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def ls(self, data, path):\n        credentials = self._formatCredentials(data, name='current')\n\n        command = (\n            '{credentials} '\n            'rclone lsjson current:{path}'\n        ).format(\n            credentials=credentials,\n            path=path,\n        )\n\n        try:\n            result = self._execute(command)\n            result = json.loads(result)\n            return result\n        except subprocess.CalledProcessError as e:\n            raise RcloneException(sanitize(str(e)))",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148918,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def ls(self, data, path):\n        credentials = self._formatCredentials(data, name='current')\n        command = [\n            'rclone',\n            'lsjson',\n            'current:{}'.format(path),\n        ]\n\n        try:\n            result = self._execute(command, credentials)\n            result = json.loads(result)\n            return result\n        except subprocess.CalledProcessError as e:\n            raise RcloneException(sanitize(str(e)))",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148919,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _run_ssh(self, command, check_exit=True, attempts=1):\n        if not self.sshpool:\n            self.sshpool = utils.SSHPool(self.config.san_ip,\n                                         self.config.san_ssh_port,\n                                         self.config.ssh_conn_timeout,\n                                         self.config.san_login,\n                                         password=self.config.san_password,\n                                         privatekey=\n                                         self.config.san_private_key,\n                                         min_size=\n                                         self.config.ssh_min_pool_conn,\n                                         max_size=\n                                         self.config.ssh_max_pool_conn)\n        try:\n            total_attempts = attempts\n            with self.sshpool.item() as ssh:\n                while attempts > 0:\n                    attempts -= 1\n                    try:\n                        return self._ssh_execute(ssh, command,\n                                                 check_exit_code=check_exit)\n                    except Exception as e:\n                        LOG.error(e)\n                        greenthread.sleep(randint(20, 500) / 100.0)\n                msg = (_(\"SSH Command failed after '%(total_attempts)r' \"\n                         \"attempts : '%(command)s'\") %\n                       {'total_attempts': total_attempts, 'command': command})\n                raise paramiko.SSHException(msg)\n        except Exception:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_(\"Error running ssh command: %s\") % command)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148920,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _run_ssh(self, cmd_list, check_exit=True, attempts=1):\n        utils.check_ssh_injection(cmd_list)\n        command = ' '. join(cmd_list)\n\n        if not self.sshpool:\n            self.sshpool = utils.SSHPool(self.config.san_ip,\n                                         self.config.san_ssh_port,\n                                         self.config.ssh_conn_timeout,\n                                         self.config.san_login,\n                                         password=self.config.san_password,\n                                         privatekey=\n                                         self.config.san_private_key,\n                                         min_size=\n                                         self.config.ssh_min_pool_conn,\n                                         max_size=\n                                         self.config.ssh_max_pool_conn)\n        try:\n            total_attempts = attempts\n            with self.sshpool.item() as ssh:\n                while attempts > 0:\n                    attempts -= 1\n                    try:\n                        return self._ssh_execute(ssh, command,\n                                                 check_exit_code=check_exit)\n                    except Exception as e:\n                        LOG.error(e)\n                        greenthread.sleep(randint(20, 500) / 100.0)\n                msg = (_(\"SSH Command failed after '%(total_attempts)r' \"\n                         \"attempts : '%(command)s'\") %\n                       {'total_attempts': total_attempts, 'command': command})\n                raise paramiko.SSHException(msg)\n        except Exception:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_(\"Error running ssh command: %s\") % command)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148921,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def verify(self, data):\n        credentials = self._formatCredentials(data, name='current')\n        command = '{} rclone lsjson current:'.format(credentials)\n\n        try:\n            result = self._execute(command)\n            return {\n                'result': True,\n                'message': 'Success',\n            }\n        except subprocess.CalledProcessError as e:\n            returncode = e.returncode\n            return {\n                'result': False,\n                'message': 'Exit status {}'.format(returncode),\n            }",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148922,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def verify(self, data):\n        credentials = self._formatCredentials(data, name='current')\n        command = [\n            'rclone',\n            'lsjson',\n            'current:',\n        ]\n\n        try:\n            result = self._execute(command, credentials)\n            return {\n                'result': True,\n                'message': 'Success',\n            }\n        except subprocess.CalledProcessError as e:\n            returncode = e.returncode\n            return {\n                'result': False,\n                'message': 'Exit status {}'.format(returncode),\n            }",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148923,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def add_extra_args(self, args=None):\n        \"\"\"Add more args depending on how known args are set.\"\"\"\n        parsed = vars(self.parse_known_args(nohelp=True)[0])\n\n        # find which image mode specified if any, and add additional arguments\n        image_mode = parsed.get('image_mode', None)\n        if image_mode is not None and image_mode != 'none':\n            self.add_image_args(image_mode)\n\n        # find which task specified if any, and add its specific arguments\n        task = parsed.get('task', None)\n        if task is not None:\n            self.add_task_args(task)\n        evaltask = parsed.get('evaltask', None)\n        if evaltask is not None:\n            self.add_task_args(evaltask)\n\n        # find which model specified if any, and add its specific arguments\n        model = parsed.get('model', None)\n        if model is not None:\n            self.add_model_subargs(model)\n\n        # reset parser-level defaults over any model-level defaults\n        try:\n            self.set_defaults(**self._defaults)\n        except AttributeError:\n            raise RuntimeError('Please file an issue on github that argparse '\n                               'got an attribute error when parsing.')",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148924,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def add_extra_args(self, args=None):\n        \"\"\"Add more args depending on how known args are set.\"\"\"\n        parsed = vars(self.parse_known_args(args, nohelp=True)[0])\n\n        # find which image mode specified if any, and add additional arguments\n        image_mode = parsed.get('image_mode', None)\n        if image_mode is not None and image_mode != 'none':\n            self.add_image_args(image_mode)\n\n        # find which task specified if any, and add its specific arguments\n        task = parsed.get('task', None)\n        if task is not None:\n            self.add_task_args(task)\n        evaltask = parsed.get('evaltask', None)\n        if evaltask is not None:\n            self.add_task_args(evaltask)\n\n        # find which model specified if any, and add its specific arguments\n        model = parsed.get('model', None)\n        if model is not None:\n            self.add_model_subargs(model)\n\n        # reset parser-level defaults over any model-level defaults\n        try:\n            self.set_defaults(**self._defaults)\n        except AttributeError:\n            raise RuntimeError('Please file an issue on github that argparse '\n                               'got an attribute error when parsing.')",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148925,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_vdisk_fc_mappings(self, vdisk_name):\n        \"\"\"Return FlashCopy mappings that this vdisk is associated with.\"\"\"\n\n        ssh_cmd = 'svcinfo lsvdiskfcmappings -nohdr %s' % vdisk_name\n        out, err = self._run_ssh(ssh_cmd)\n\n        mapping_ids = []\n        if (len(out.strip())):\n            lines = out.strip().split('\\n')\n            mapping_ids = [line.split()[0] for line in lines]\n        return mapping_ids",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148926,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_vdisk_fc_mappings(self, vdisk_name):\n        \"\"\"Return FlashCopy mappings that this vdisk is associated with.\"\"\"\n\n        ssh_cmd = ['svcinfo', 'lsvdiskfcmappings', '-nohdr', vdisk_name]\n        out, err = self._run_ssh(ssh_cmd)\n\n        mapping_ids = []\n        if (len(out.strip())):\n            lines = out.strip().split('\\n')\n            mapping_ids = [line.split()[0] for line in lines]\n        return mapping_ids",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148927,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_create_host(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_cpg\",\n                       self.fake_get_cpg)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_domain\",\n                       self.fake_get_domain)\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_host_cmd = 'showhost -verbose fakehost'\n        _run_ssh(show_host_cmd, False).AndReturn([pack('no hosts listed'), ''])\n\n        create_host_cmd = ('createhost -iscsi -persona 1 -domain '\n                           '(\\'OpenStack\\',) '\n                           'fakehost iqn.1993-08.org.debian:01:222')\n        _run_ssh(create_host_cmd, False).AndReturn([CLI_CR, ''])\n\n        _run_ssh(show_host_cmd, False).AndReturn([pack(ISCSI_HOST_RET), ''])\n        self.mox.ReplayAll()\n\n        host = self.driver._create_host(self.volume, self.connector)\n        self.assertEqual(host['name'], self.FAKE_HOST)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148928,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_create_host(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_cpg\",\n                       self.fake_get_cpg)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_domain\",\n                       self.fake_get_domain)\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_host_cmd = ['showhost', '-verbose', 'fakehost']\n        _run_ssh(show_host_cmd, False).AndReturn([pack('no hosts listed'), ''])\n\n        create_host_cmd = (['createhost', '-iscsi', '-persona', '1', '-domain',\n                            ('OpenStack',), 'fakehost',\n                            'iqn.1993-08.org.debian:01:222'])\n        _run_ssh(create_host_cmd, False).AndReturn([CLI_CR, ''])\n\n        _run_ssh(show_host_cmd, False).AndReturn([pack(ISCSI_HOST_RET), ''])\n        self.mox.ReplayAll()\n\n        host = self.driver._create_host(self.volume, self.connector)\n        self.assertEqual(host['name'], self.FAKE_HOST)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148929,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _copy_volume(self, src_name, dest_name, cpg=None, snap_cpg=None,\n                     tpvv=True):\n        # Virtual volume sets are not supported with the -online option\n        cmd = 'createvvcopy -p %s -online ' % src_name\n        if snap_cpg:\n            cmd += '-snp_cpg %s ' % snap_cpg\n        if tpvv:\n            cmd += '-tpvv '\n        if cpg:\n            cmd += cpg + ' '\n        cmd += dest_name\n        LOG.debug('Creating clone of a volume with %s' % cmd)\n        self._cli_run(cmd, None)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148930,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _copy_volume(self, src_name, dest_name, cpg=None, snap_cpg=None,\n                     tpvv=True):\n        # Virtual volume sets are not supported with the -online option\n        cmd = ['createvvcopy', '-p', src_name, '-online']\n        if snap_cpg:\n            cmd.extend(['-snp_cpg', snap_cpg])\n        if tpvv:\n            cmd.append('-tpvv')\n        if cpg:\n            cmd.append(cpg)\n        cmd.append(dest_name)\n        LOG.debug('Creating clone of a volume with %s' % cmd)\n        self._cli_run(cmd)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148931,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_active_nsp(self, hostname):\n        \"\"\"Return the active nsp, if one exists, for the given host.\"\"\"\n        result = self.common._cli_run('showvlun -a -host %s' % hostname, None)\n        if result:\n            # first line is header\n            result = result[1:]\n            for line in result:\n                info = line.split(\",\")\n                if info and len(info) > 4:\n                    return info[4]",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148932,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_active_nsp(self, hostname):\n        \"\"\"Return the active nsp, if one exists, for the given host.\"\"\"\n        result = self.common._cli_run(['showvlun', '-a', '-host', hostname])\n        if result:\n            # first line is header\n            result = result[1:]\n            for line in result:\n                info = line.split(\",\")\n                if info and len(info) > 4:\n                    return info[4]",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148933,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def initialize_connection(self, volume, connector):\n        \"\"\"Restrict access to a volume.\"\"\"\n        try:\n            cmd = ['volume', 'select', volume['name'], 'access', 'create',\n                   'initiator', connector['initiator']]\n            if self.configuration.eqlx_use_chap:\n                cmd.extend(['authmethod chap', 'username',\n                            self.configuration.eqlx_chap_login])\n            self._eql_execute(*cmd)\n            iscsi_properties = self._get_iscsi_properties(volume)\n            return {\n                'driver_volume_type': 'iscsi',\n                'data': iscsi_properties\n            }\n        except Exception:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_('Failed to initialize connection to volume %s'),\n                          volume['name'])",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148934,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def initialize_connection(self, volume, connector):\n        \"\"\"Restrict access to a volume.\"\"\"\n        try:\n            cmd = ['volume', 'select', volume['name'], 'access', 'create',\n                   'initiator', connector['initiator']]\n            if self.configuration.eqlx_use_chap:\n                cmd.extend(['authmethod', 'chap', 'username',\n                            self.configuration.eqlx_chap_login])\n            self._eql_execute(*cmd)\n            iscsi_properties = self._get_iscsi_properties(volume)\n            return {\n                'driver_volume_type': 'iscsi',\n                'data': iscsi_properties\n            }\n        except Exception:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_('Failed to initialize connection to volume %s'),\n                          volume['name'])",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148935,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def mkdir(self, data, path):\n        credentials = self._formatCredentials(data, name='current')\n\n        command = (\n            '{credentials} '\n            'rclone touch current:{path}/.keep'\n        ).format(\n            credentials=credentials,\n            path=path,\n        )\n\n        try:\n            result = self._execute(command)\n            return {\n                'message': 'Success',\n            }\n        except subprocess.CalledProcessError as e:\n            raise RcloneException(sanitize(str(e)))",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148936,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def mkdir(self, data, path):\n        credentials = self._formatCredentials(data, name='current')\n        command = [\n            'rclone',\n            'touch',\n            'current:{}/.keep'.format(path),\n        ]\n\n        try:\n            result = self._execute(command, credentials)\n            return {\n                'message': 'Success',\n            }\n        except subprocess.CalledProcessError as e:\n            raise RcloneException(sanitize(str(e)))",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148937,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def populate_custom_grains_and_pillar():\n    '''\n    Populate local salt-minion grains and pillar fields values as specified in\n    config file.\n\n    For example:\n\n        custom_grains_pillar:\n          grains:\n            - selinux: selinux:enabled\n            - release: osrelease\n          pillar:\n            - ntpserver: network_services:ntpserver\n\n    Note that the core grains are already included in hubble grains -- this\n    is only necessary for custom grains and pillar data.\n    '''\n    log.debug('Fetching custom grains and pillar details')\n    grains = {}\n    salt.modules.config.__opts__ = __opts__\n    custom_grains = __salt__['config.get']('custom_grains_pillar:grains', [])\n    for grain in custom_grains:\n        for key in grain:\n            if _valid_command(grain[key]):\n                value = __salt__['cmd.run']('salt-call grains.get {0}'.format(grain[key])).split('\\n')[1].strip()\n                grains[key] = value\n    custom_pillar = __salt__['config.get']('custom_grains_pillar:pillar', [])\n    for pillar in custom_pillar:\n        for key in pillar:\n            if _valid_command(pillar[key]):\n                value = __salt__['cmd.run']('salt-call pillar.get {0}'.format(pillar[key])).split('\\n')[1].strip()\n                grains[key] = value\n    log.debug('Done with fetching custom grains and pillar details')\n    return grains",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148938,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def populate_custom_grains_and_pillar():\n    '''\n    Populate local salt-minion grains and pillar fields values as specified in\n    config file.\n\n    For example:\n\n        custom_grains_pillar:\n          grains:\n            - selinux: selinux:enabled\n            - release: osrelease\n          pillar:\n            - ntpserver: network_services:ntpserver\n\n    Note that the core grains are already included in hubble grains -- this\n    is only necessary for custom grains and pillar data.\n    '''\n    log.debug('Fetching custom grains and pillar details')\n    grains = {}\n    salt.modules.config.__opts__ = __opts__\n    custom_grains = __salt__['config.get']('custom_grains_pillar:grains', [])\n    for grain in custom_grains:\n        for key in grain:\n            value = __salt__['cmd.run'](['salt-call', 'grains.get', grain[key]]).split('\\n')[1].strip()\n            grains[key] = value\n    custom_pillar = __salt__['config.get']('custom_grains_pillar:pillar', [])\n    for pillar in custom_pillar:\n        for key in pillar:\n            value = __salt__['cmd.run'](['salt-call', 'pillar.get', pillar[key]]).split('\\n')[1].strip()\n            grains[key] = value\n    log.debug('Done with fetching custom grains and pillar details')\n    return grains",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148939,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def copy(self, src_data, src_path, dst_data, dst_path, job_id=None):\n        credentials = ''\n\n        if src_data is None: # Local\n            src = src_path\n        else:\n            credentials += self._formatCredentials(src_data, name='src')\n            src = 'src:{}'.format(src_path)\n\n        if dst_data is None: # Local\n            dst = dst_path\n        else:\n            credentials += self._formatCredentials(dst_data, name='dst')\n            dst = 'dst:{}'.format(dst_path)\n\n\n        command = (\n            '{credentials} '\n            'rclone copy {src} {dst} '\n            '--progress '\n            '--stats 2s '\n        ).format(\n            credentials=credentials,\n            src=src,\n            dst=dst,\n        )\n\n        logging.info(sanitize(command))\n\n        if job_id is None:\n            job_id = self._get_next_job_id()\n        else:\n            if self._job_id_exists(job_id):\n                raise ValueError('rclone copy job with ID {} already exists'.fromat(job_id))\n\n        self._stop_events[job_id] = threading.Event()\n\n        try:\n            self._execute_interactive(command, job_id)\n        except subprocess.CalledProcessError as e:\n            raise RcloneException(sanitize(str(e)))\n\n        return job_id",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148940,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def copy(self, src_data, src_path, dst_data, dst_path, job_id=None):\n        credentials = {}\n\n        if src_data is None: # Local\n            src = src_path\n        else:\n            credentials.update(self._formatCredentials(src_data, name='src'))\n            src = 'src:{}'.format(src_path)\n\n        if dst_data is None: # Local\n            dst = dst_path\n        else:\n            credentials.update(self._formatCredentials(dst_data, name='dst'))\n            dst = 'dst:{}'.format(dst_path)\n\n        command = [\n            'rclone',\n            'copy',\n            src,\n            dst,\n            '--progress',\n            '--stats', '2s',\n        ]\n\n        bash_command = \"{} {}\".format(\n            ' '.join(\"{}='{}'\".format(key, value) for key, value in credentials.items()),\n            ' '.join(command),\n        )\n\n        logging.info(sanitize(bash_command))\n\n        if job_id is None:\n            job_id = self._get_next_job_id()\n        else:\n            if self._job_id_exists(job_id):\n                raise ValueError('rclone copy job with ID {} already exists'.fromat(job_id))\n\n        self._stop_events[job_id] = threading.Event()\n\n        try:\n            self._execute_interactive(command, credentials, job_id)\n        except subprocess.CalledProcessError as e:\n            raise RcloneException(sanitize(str(e)))\n\n        return job_id",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148941,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _remove_volume_from_volume_set(self, volume_name, vvs_name):\n        self._cli_run('removevvset -f %s %s' % (vvs_name, volume_name), None)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148942,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _remove_volume_from_volume_set(self, volume_name, vvs_name):\n        self._cli_run(['removevvset', '-f', vvs_name, volume_name])",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148943,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def handle_message(self, ch, method, properties, body):\n        \"\"\"\n        this is a pika.basic_consumer callback\n        handles client inputs, runs appropriate workflows and views\n\n        Args:\n            ch: amqp channel\n            method: amqp method\n            properties:\n            body: message body\n        \"\"\"\n        input = {}\n        try:\n            self.sessid = method.routing_key\n\n            input = json_decode(body)\n            data = input['data']\n\n            # since this comes as \"path\" we dont know if it's view or workflow yet\n            #TODO: just a workaround till we modify ui to\n            if 'path' in data:\n                if data['path'] in settings.VIEW_URLS:\n                    data['view'] = data['path']\n                else:\n                    data['wf'] = data['path']\n            session = Session(self.sessid)\n\n            headers = {'remote_ip': input['_zops_remote_ip']}\n\n            if 'wf' in data:\n                output = self._handle_workflow(session, data, headers)\n            elif 'job' in data:\n\n                self._handle_job(session, data, headers)\n                return\n            else:\n                output = self._handle_view(session, data, headers)\n\n        except HTTPError as e:\n            import sys\n            if hasattr(sys, '_called_from_test'):\n                raise\n            output = {'cmd': 'error', 'error': self._prepare_error_msg(e.message), \"code\": e.code}\n            log.exception(\"Http error occurred\")\n        except:\n            self.current = Current(session=session, input=data)\n            self.current.headers = headers\n            import sys\n            if hasattr(sys, '_called_from_test'):\n                raise\n            err = traceback.format_exc()\n            output = {'error': self._prepare_error_msg(err), \"code\": 500}\n            log.exception(\"Worker error occurred with messsage body:\\n%s\" % body)\n        if 'callbackID' in input:\n            output['callbackID'] = input['callbackID']\n        log.info(\"OUTPUT for %s: %s\" % (self.sessid, output))\n        output['reply_timestamp'] = time()\n        self.send_output(output)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148944,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def handle_message(self, ch, method, properties, body):\n        \"\"\"\n        this is a pika.basic_consumer callback\n        handles client inputs, runs appropriate workflows and views\n\n        Args:\n            ch: amqp channel\n            method: amqp method\n            properties:\n            body: message body\n        \"\"\"\n        input = {}\n        headers = {}\n        try:\n            self.sessid = method.routing_key\n\n            input = json_decode(body)\n            data = input['data']\n\n            # since this comes as \"path\" we dont know if it's view or workflow yet\n            # TODO: just a workaround till we modify ui to\n            if 'path' in data:\n                if data['path'] in settings.VIEW_URLS:\n                    data['view'] = data['path']\n                else:\n                    data['wf'] = data['path']\n            session = Session(self.sessid)\n\n            headers = {'remote_ip': input['_zops_remote_ip'],\n                       'source': input['_zops_source']}\n\n            if 'wf' in data:\n                output = self._handle_workflow(session, data, headers)\n            elif 'job' in data:\n\n                self._handle_job(session, data, headers)\n                return\n            else:\n                output = self._handle_view(session, data, headers)\n\n        except HTTPError as e:\n            import sys\n            if hasattr(sys, '_called_from_test'):\n                raise\n            output = {'cmd': 'error', 'error': self._prepare_error_msg(e.message), \"code\": e.code}\n            log.exception(\"Http error occurred\")\n        except:\n            self.current = Current(session=session, input=data)\n            self.current.headers = headers\n            import sys\n            if hasattr(sys, '_called_from_test'):\n                raise\n            err = traceback.format_exc()\n            output = {'error': self._prepare_error_msg(err), \"code\": 500}\n            log.exception(\"Worker error occurred with messsage body:\\n%s\" % body)\n        if 'callbackID' in input:\n            output['callbackID'] = input['callbackID']\n        log.info(\"OUTPUT for %s: %s\" % (self.sessid, output))\n        output['reply_timestamp'] = time()\n        self.send_output(output)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148945,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _add_chapsecret_to_host(self, host_name):\n        \"\"\"Generate and store a randomly-generated CHAP secret for the host.\"\"\"\n\n        chap_secret = utils.generate_password()\n        ssh_cmd = ('svctask chhost -chapsecret \"%(chap_secret)s\" %(host_name)s'\n                   % {'chap_secret': chap_secret, 'host_name': host_name})\n        out, err = self._run_ssh(ssh_cmd)\n        # No output should be returned from chhost\n        self._assert_ssh_return(len(out.strip()) == 0,\n                                '_add_chapsecret_to_host', ssh_cmd, out, err)\n        return chap_secret",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148946,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _add_chapsecret_to_host(self, host_name):\n        \"\"\"Generate and store a randomly-generated CHAP secret for the host.\"\"\"\n\n        chap_secret = utils.generate_password()\n        ssh_cmd = ['svctask', 'chhost', '-chapsecret', chap_secret, host_name]\n        out, err = self._run_ssh(ssh_cmd)\n        # No output should be returned from chhost\n        self._assert_ssh_return(len(out.strip()) == 0,\n                                '_add_chapsecret_to_host', ssh_cmd, out, err)\n        return chap_secret",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148947,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _call_prepare_fc_map(self, fc_map_id, source, target):\n        try:\n            out, err = self._run_ssh('svctask prestartfcmap %s' % fc_map_id)\n        except exception.ProcessExecutionError as e:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_('_prepare_fc_map: Failed to prepare FlashCopy '\n                            'from %(source)s to %(target)s.\\n'\n                            'stdout: %(out)s\\n stderr: %(err)s')\n                          % {'source': source,\n                             'target': target,\n                             'out': e.stdout,\n                             'err': e.stderr})",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148948,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _call_prepare_fc_map(self, fc_map_id, source, target):\n        try:\n            out, err = self._run_ssh(['svctask', 'prestartfcmap', fc_map_id])\n        except exception.ProcessExecutionError as e:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_('_prepare_fc_map: Failed to prepare FlashCopy '\n                            'from %(source)s to %(target)s.\\n'\n                            'stdout: %(out)s\\n stderr: %(err)s')\n                          % {'source': source,\n                             'target': target,\n                             'out': e.stdout,\n                             'err': e.stderr})",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148949,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def on_message( self, profile_id, profile_name, level, message, timeout ):\n        if 1 == level:\n            cmd = \"notify-send \"\n            if timeout > 0:\n                cmd = cmd + \" -t %s\" % (1000 * timeout)\n\n            title = \"Back In Time (%s) : %s\" % (self.user, profile_name)\n            message = message.replace(\"\\n\", ' ')\n            message = message.replace(\"\\r\", '')\n\n            cmd = cmd + \" \\\"%s\\\" \\\"%s\\\"\" % (title, message)\n            print(cmd)\n            os.system(cmd)\n        return",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148950,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def on_message( self, profile_id, profile_name, level, message, timeout ):\n        if 1 == level:\n            cmd = ['notify-send']\n            if timeout > 0:\n                cmd.extend(['-t', str(1000 * timeout)])\n\n            title = \"Back In Time (%s) : %s\" % (self.user, profile_name)\n            message = message.replace(\"\\n\", ' ')\n            message = message.replace(\"\\r\", '')\n\n            cmd.append(title)\n            cmd.append(message)\n            subprocess.Popen(cmd).communicate()\n        return",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148951,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _find_host_exhaustive(self, connector, hosts):\n        for host in hosts:\n            ssh_cmd = 'svcinfo lshost -delim ! %s' % host\n            out, err = self._run_ssh(ssh_cmd)\n            self._assert_ssh_return(len(out.strip()),\n                                    '_find_host_exhaustive',\n                                    ssh_cmd, out, err)\n            for attr_line in out.split('\\n'):\n                # If '!' not found, return the string and two empty strings\n                attr_name, foo, attr_val = attr_line.partition('!')\n                if (attr_name == 'iscsi_name' and\n                        'initiator' in connector and\n                        attr_val == connector['initiator']):\n                    return host\n                elif (attr_name == 'WWPN' and\n                      'wwpns' in connector and\n                      attr_val.lower() in\n                      map(str.lower, map(str, connector['wwpns']))):\n                        return host\n        return None",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148952,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _find_host_exhaustive(self, connector, hosts):\n        for host in hosts:\n            ssh_cmd = ['svcinfo', 'lshost', '-delim', '!', host]\n            out, err = self._run_ssh(ssh_cmd)\n            self._assert_ssh_return(len(out.strip()),\n                                    '_find_host_exhaustive',\n                                    ssh_cmd, out, err)\n            for attr_line in out.split('\\n'):\n                # If '!' not found, return the string and two empty strings\n                attr_name, foo, attr_val = attr_line.partition('!')\n                if (attr_name == 'iscsi_name' and\n                        'initiator' in connector and\n                        attr_val == connector['initiator']):\n                    return host\n                elif (attr_name == 'WWPN' and\n                      'wwpns' in connector and\n                      attr_val.lower() in\n                      map(str.lower, map(str, connector['wwpns']))):\n                        return host\n        return None",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148953,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _create_vdisk(self, name, size, units, opts):\n        \"\"\"Create a new vdisk.\"\"\"\n\n        LOG.debug(_('enter: _create_vdisk: vdisk %s ') % name)\n\n        model_update = None\n        autoex = '-autoexpand' if opts['autoexpand'] else ''\n        easytier = '-easytier on' if opts['easytier'] else '-easytier off'\n\n        # Set space-efficient options\n        if opts['rsize'] == -1:\n            ssh_cmd_se_opt = ''\n        else:\n            ssh_cmd_se_opt = (\n                '-rsize %(rsize)d%% %(autoex)s -warning %(warn)d%%' %\n                {'rsize': opts['rsize'],\n                 'autoex': autoex,\n                 'warn': opts['warning']})\n            if opts['compression']:\n                ssh_cmd_se_opt = ssh_cmd_se_opt + ' -compressed'\n            else:\n                ssh_cmd_se_opt = ssh_cmd_se_opt + (\n                    ' -grainsize %d' % opts['grainsize'])\n\n        ssh_cmd = ('svctask mkvdisk -name %(name)s -mdiskgrp %(mdiskgrp)s '\n                   '-iogrp 0 -size %(size)s -unit '\n                   '%(unit)s %(easytier)s %(ssh_cmd_se_opt)s'\n                   % {'name': name,\n                   'mdiskgrp': self.configuration.storwize_svc_volpool_name,\n                   'size': size, 'unit': units, 'easytier': easytier,\n                   'ssh_cmd_se_opt': ssh_cmd_se_opt})\n        out, err = self._run_ssh(ssh_cmd)\n        self._assert_ssh_return(len(out.strip()), '_create_vdisk',\n                                ssh_cmd, out, err)\n\n        # Ensure that the output is as expected\n        match_obj = re.search('Virtual Disk, id \\[([0-9]+)\\], '\n                              'successfully created', out)\n        # Make sure we got a \"successfully created\" message with vdisk id\n        self._driver_assert(\n            match_obj is not None,\n            _('_create_vdisk %(name)s - did not find '\n              'success message in CLI output.\\n '\n              'stdout: %(out)s\\n stderr: %(err)s')\n            % {'name': name, 'out': str(out), 'err': str(err)})\n\n        LOG.debug(_('leave: _create_vdisk: volume %s ') % name)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148954,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _create_vdisk(self, name, size, units, opts):\n        \"\"\"Create a new vdisk.\"\"\"\n\n        LOG.debug(_('enter: _create_vdisk: vdisk %s ') % name)\n\n        model_update = None\n        easytier = 'on' if opts['easytier'] else 'off'\n\n        # Set space-efficient options\n        if opts['rsize'] == -1:\n            ssh_cmd_se_opt = []\n        else:\n            ssh_cmd_se_opt = ['-rsize', '%s%%' % str(opts['rsize']),\n                              '-autoexpand', '-warning',\n                              '%s%%' % str(opts['warning'])]\n            if not opts['autoexpand']:\n                ssh_cmd_se_opt.remove('-autoexpand')\n\n            if opts['compression']:\n                ssh_cmd_se_opt.append('-compressed')\n            else:\n                ssh_cmd_se_opt.extend(['-grainsize', str(opts['grainsize'])])\n\n        ssh_cmd = ['svctask', 'mkvdisk', '-name', name, '-mdiskgrp',\n                   self.configuration.storwize_svc_volpool_name,\n                   '-iogrp', '0', '-size', size, '-unit',\n                   units, '-easytier', easytier] + ssh_cmd_se_opt\n        out, err = self._run_ssh(ssh_cmd)\n        self._assert_ssh_return(len(out.strip()), '_create_vdisk',\n                                ssh_cmd, out, err)\n\n        # Ensure that the output is as expected\n        match_obj = re.search('Virtual Disk, id \\[([0-9]+)\\], '\n                              'successfully created', out)\n        # Make sure we got a \"successfully created\" message with vdisk id\n        self._driver_assert(\n            match_obj is not None,\n            _('_create_vdisk %(name)s - did not find '\n              'success message in CLI output.\\n '\n              'stdout: %(out)s\\n stderr: %(err)s')\n            % {'name': name, 'out': str(out), 'err': str(err)})\n\n        LOG.debug(_('leave: _create_vdisk: volume %s ') % name)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148955,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_invalid_iscsi_ip(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record driver set up\n        self.clear_mox()\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_port_cmd = 'showport'\n        _run_ssh(show_port_cmd, False).AndReturn([pack(PORT_RET), ''])\n\n        show_port_i_cmd = 'showport -iscsi'\n        _run_ssh(show_port_i_cmd, False).AndReturn([pack(READY_ISCSI_PORT_RET),\n                                                    ''])\n\n        show_port_i_cmd = 'showport -iscsiname'\n        _run_ssh(show_port_i_cmd, False).AndReturn([pack(SHOW_PORT_ISCSI), ''])\n\n        config = self.setup_configuration()\n        config.hp3par_iscsi_ips = ['10.10.220.250', '10.10.220.251']\n        config.iscsi_ip_address = '10.10.10.10'\n        self.mox.ReplayAll()\n\n        # no valid ip addr should be configured.\n        self.assertRaises(exception.InvalidInput,\n                          self.setup_driver,\n                          config,\n                          set_up_fakes=False)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148956,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_invalid_iscsi_ip(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record driver set up\n        self.clear_mox()\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_port_cmd = ['showport']\n        _run_ssh(show_port_cmd, False).AndReturn([pack(PORT_RET), ''])\n\n        show_port_i_cmd = ['showport', '-iscsi']\n        _run_ssh(show_port_i_cmd, False).AndReturn([pack(READY_ISCSI_PORT_RET),\n                                                    ''])\n\n        show_port_i_cmd = ['showport', '-iscsiname']\n        _run_ssh(show_port_i_cmd, False).AndReturn([pack(SHOW_PORT_ISCSI), ''])\n\n        config = self.setup_configuration()\n        config.hp3par_iscsi_ips = ['10.10.220.250', '10.10.220.251']\n        config.iscsi_ip_address = '10.10.10.10'\n        self.mox.ReplayAll()\n\n        # no valid ip addr should be configured.\n        self.assertRaises(exception.InvalidInput,\n                          self.setup_driver,\n                          config,\n                          set_up_fakes=False)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148957,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def get_output(command: str) -> bytes:\n    \"\"\"\n    Run a command and return raw output\n\n    :param str command: the command to run\n    :returns: the stdout output of the command\n    \"\"\"\n    return subprocess.check_output(command.split())",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148958,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def get_output(command: List[str]) -> str:\n    \"\"\"\n    Run a command and return raw output\n\n    :param str command: the command to run\n    :returns: the stdout output of the command\n    \"\"\"\n    result = subprocess.run(command, stdout=subprocess.PIPE, check=True)\n    return result.stdout.decode()",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148959,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def add_user(username, password):\n    encPass = crypt.crypt(password,\"22\")\n    os.system(\"useradd -G docker,wheel -p \"+encPass+\" \"+username)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148960,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def add_user(username, password):\n    encPass = crypt.crypt(password,\"22\")\n    #subprocess escapes the username stopping code injection\n    subprocess.call(['useradd','-G','docker,wheel','-p',encPass,username])",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148961,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def write_section(self, section_name, section_data):\n        self.write_line(\"\")\n        self.write_line(\"define %s {\" % section_name)\n        sorted_keys = section_data.keys()\n        sorted_keys.sort()\n        for key in sorted_keys:\n            value = section_data[key]\n            self.icinga_lines.append((\"%s%-45s%s\" % (self.indent, key, self.value_to_icinga(value))))\n        self.write_line(\"}\")",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148962,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def write_section(self, section_name, section_data):\n        self.write_line(\"\")\n        self.write_line(\"define %s {\" % section_name)\n        sorted_keys = section_data.keys()\n        sorted_keys.sort()\n        for key in sorted_keys:\n            value = self.value_to_icinga(section_data[key])\n            icinga_line = \"%s%-45s%s\" % (self.indent, key, value)\n\n            if \"\\n\" in icinga_line or \"}\" in icinga_line:\n                msg = \"Found forbidden newline or '}' character in section %r.\"\n                raise Exception(msg % section_name)\n\n            self.icinga_lines.append(icinga_line)\n        self.write_line(\"}\")",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148963,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _update_volume_stats(self):\n        \"\"\"Retrieve stats info from volume group.\"\"\"\n\n        LOG.debug(_(\"Updating volume stats\"))\n        data = {}\n\n        data['vendor_name'] = 'IBM'\n        data['driver_version'] = '1.1'\n        data['storage_protocol'] = list(self._enabled_protocols)\n\n        data['total_capacity_gb'] = 0  # To be overwritten\n        data['free_capacity_gb'] = 0   # To be overwritten\n        data['reserved_percentage'] = 0\n        data['QoS_support'] = False\n\n        pool = self.configuration.storwize_svc_volpool_name\n        #Get storage system name\n        ssh_cmd = 'svcinfo lssystem -delim !'\n        attributes = self._execute_command_and_parse_attributes(ssh_cmd)\n        if not attributes or not attributes['name']:\n            exception_message = (_('_update_volume_stats: '\n                                   'Could not get system name'))\n            raise exception.VolumeBackendAPIException(data=exception_message)\n\n        backend_name = self.configuration.safe_get('volume_backend_name')\n        if not backend_name:\n            backend_name = '%s_%s' % (attributes['name'], pool)\n        data['volume_backend_name'] = backend_name\n\n        ssh_cmd = 'svcinfo lsmdiskgrp -bytes -delim ! %s' % pool\n        attributes = self._execute_command_and_parse_attributes(ssh_cmd)\n        if not attributes:\n            LOG.error(_('Could not get pool data from the storage'))\n            exception_message = (_('_update_volume_stats: '\n                                   'Could not get storage pool data'))\n            raise exception.VolumeBackendAPIException(data=exception_message)\n\n        data['total_capacity_gb'] = (float(attributes['capacity']) /\n                                    (1024 ** 3))\n        data['free_capacity_gb'] = (float(attributes['free_capacity']) /\n                                    (1024 ** 3))\n        data['easytier_support'] = attributes['easy_tier'] in ['on', 'auto']\n        data['compression_support'] = self._compression_enabled\n\n        self._stats = data",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148964,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _update_volume_stats(self):\n        \"\"\"Retrieve stats info from volume group.\"\"\"\n\n        LOG.debug(_(\"Updating volume stats\"))\n        data = {}\n\n        data['vendor_name'] = 'IBM'\n        data['driver_version'] = '1.1'\n        data['storage_protocol'] = list(self._enabled_protocols)\n\n        data['total_capacity_gb'] = 0  # To be overwritten\n        data['free_capacity_gb'] = 0   # To be overwritten\n        data['reserved_percentage'] = 0\n        data['QoS_support'] = False\n\n        pool = self.configuration.storwize_svc_volpool_name\n        #Get storage system name\n        ssh_cmd = ['svcinfo', 'lssystem', '-delim', '!']\n        attributes = self._execute_command_and_parse_attributes(ssh_cmd)\n        if not attributes or not attributes['name']:\n            exception_message = (_('_update_volume_stats: '\n                                   'Could not get system name'))\n            raise exception.VolumeBackendAPIException(data=exception_message)\n\n        backend_name = self.configuration.safe_get('volume_backend_name')\n        if not backend_name:\n            backend_name = '%s_%s' % (attributes['name'], pool)\n        data['volume_backend_name'] = backend_name\n\n        ssh_cmd = ['svcinfo', 'lsmdiskgrp', '-bytes', '-delim', '!', pool]\n        attributes = self._execute_command_and_parse_attributes(ssh_cmd)\n        if not attributes:\n            LOG.error(_('Could not get pool data from the storage'))\n            exception_message = (_('_update_volume_stats: '\n                                   'Could not get storage pool data'))\n            raise exception.VolumeBackendAPIException(data=exception_message)\n\n        data['total_capacity_gb'] = (float(attributes['capacity']) /\n                                    (1024 ** 3))\n        data['free_capacity_gb'] = (float(attributes['free_capacity']) /\n                                    (1024 ** 3))\n        data['easytier_support'] = attributes['easy_tier'] in ['on', 'auto']\n        data['compression_support'] = self._compression_enabled\n\n        self._stats = data",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148965,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_create_modify_host(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_cpg\",\n                       self.fake_get_cpg)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_domain\",\n                       self.fake_get_domain)\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_host_cmd = 'showhost -verbose fakehost'\n        _run_ssh(show_host_cmd, False).AndReturn([pack(NO_FC_HOST_RET), ''])\n\n        create_host_cmd = ('createhost -add fakehost '\n                           '123456789012345 123456789054321')\n        _run_ssh(create_host_cmd, False).AndReturn([CLI_CR, ''])\n\n        show_host_cmd = 'showhost -verbose fakehost'\n        _run_ssh(show_host_cmd, False).AndReturn([pack(FC_HOST_RET), ''])\n        self.mox.ReplayAll()\n\n        host = self.driver._create_host(self.volume, self.connector)\n        self.assertEqual(host['name'], self.FAKE_HOST)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148966,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_create_modify_host(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_cpg\",\n                       self.fake_get_cpg)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_domain\",\n                       self.fake_get_domain)\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_host_cmd = ['showhost', '-verbose', 'fakehost']\n        _run_ssh(show_host_cmd, False).AndReturn([pack(NO_FC_HOST_RET), ''])\n\n        create_host_cmd = ['createhost', '-add', 'fakehost', '123456789012345',\n                           '123456789054321']\n        _run_ssh(create_host_cmd, False).AndReturn([CLI_CR, ''])\n\n        show_host_cmd = ['showhost', '-verbose', 'fakehost']\n        _run_ssh(show_host_cmd, False).AndReturn([pack(FC_HOST_RET), ''])\n        self.mox.ReplayAll()\n\n        host = self.driver._create_host(self.volume, self.connector)\n        self.assertEqual(host['name'], self.FAKE_HOST)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148967,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def install(filename, target):\n  '''Run a package's installer script against the given target directory.'''\n  print(' Unpacking %s...' % filename)\n  os.system('tar xf ' + filename)\n  basename = filename.split('.tar')[0]\n  print(' Installing %s...' % basename)\n  install_opts = '--prefix=${PWD}/%s --disable-ldconfig' % target\n  os.system('%s/install.sh %s' % (basename, install_opts))\n  print(' Cleaning %s...' % basename)\n  os.system('rm -rf %s' % basename)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148968,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def install(filename, target):\n  '''Run a package's installer script against the given target directory.'''\n  print(' Unpacking %s...' % filename)\n  subprocess.check_call(['tar', 'xf', filename])\n  basename = filename.split('.tar')[0]\n  print(' Installing %s...' % basename)\n  install_cmd = [os.path.join(basename, 'install.sh')]\n  install_cmd += ['--prefix=' + os.path.abspath(target)]\n  install_cmd += ['--disable-ldconfig']\n  subprocess.check_call(install_cmd)\n  print(' Cleaning %s...' % basename)\n  subprocess.check_call(['rm', '-rf', basename])",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148969,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_least_used_nsp(self, nspss):\n        \"\"\"\"Return the nsp that has the fewest active vluns.\"\"\"\n        # return only the nsp (node:server:port)\n        result = self.common._cli_run('showvlun -a -showcols Port', None)\n\n        # count the number of nsps (there is 1 for each active vlun)\n        nsp_counts = {}\n        for nsp in nspss:\n            # initialize counts to zero\n            nsp_counts[nsp] = 0\n\n        current_least_used_nsp = None\n        if result:\n            # first line is header\n            result = result[1:]\n            for line in result:\n                nsp = line.strip()\n                if nsp in nsp_counts:\n                    nsp_counts[nsp] = nsp_counts[nsp] + 1\n\n            # identify key (nsp) of least used nsp\n            current_smallest_count = sys.maxint\n            for (nsp, count) in nsp_counts.iteritems():\n                if count < current_smallest_count:\n                    current_least_used_nsp = nsp\n                    current_smallest_count = count\n\n        return current_least_used_nsp",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148970,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_least_used_nsp(self, nspss):\n        \"\"\"\"Return the nsp that has the fewest active vluns.\"\"\"\n        # return only the nsp (node:server:port)\n        result = self.common._cli_run(['showvlun', '-a', '-showcols', 'Port'])\n\n        # count the number of nsps (there is 1 for each active vlun)\n        nsp_counts = {}\n        for nsp in nspss:\n            # initialize counts to zero\n            nsp_counts[nsp] = 0\n\n        current_least_used_nsp = None\n        if result:\n            # first line is header\n            result = result[1:]\n            for line in result:\n                nsp = line.strip()\n                if nsp in nsp_counts:\n                    nsp_counts[nsp] = nsp_counts[nsp] + 1\n\n            # identify key (nsp) of least used nsp\n            current_smallest_count = sys.maxint\n            for (nsp, count) in nsp_counts.iteritems():\n                if count < current_smallest_count:\n                    current_least_used_nsp = nsp\n                    current_smallest_count = count\n\n        return current_least_used_nsp",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148971,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _start_fc_map(self, fc_map_id, source, target):\n        try:\n            out, err = self._run_ssh('svctask startfcmap %s' % fc_map_id)\n        except exception.ProcessExecutionError as e:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_('_start_fc_map: Failed to start FlashCopy '\n                            'from %(source)s to %(target)s.\\n'\n                            'stdout: %(out)s\\n stderr: %(err)s')\n                          % {'source': source,\n                             'target': target,\n                             'out': e.stdout,\n                             'err': e.stderr})",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148972,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _start_fc_map(self, fc_map_id, source, target):\n        try:\n            out, err = self._run_ssh(['svctask', 'startfcmap', fc_map_id])\n        except exception.ProcessExecutionError as e:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_('_start_fc_map: Failed to start FlashCopy '\n                            'from %(source)s to %(target)s.\\n'\n                            'stdout: %(out)s\\n stderr: %(err)s')\n                          % {'source': source,\n                             'target': target,\n                             'out': e.stdout,\n                             'err': e.stderr})",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148973,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "@then(parsers.parse(\"the hostname '{hostname}' should be resolved\"))\ndef resolve_hostname(busybox_pod, host, hostname):\n        with host.sudo():\n            # test dns resolve\n            cmd_nslookup = (\"kubectl --kubeconfig=/etc/kubernetes/admin.conf\"\n                            \" exec -ti {0} nslookup {1}\".format(\n                                pod_name,\n                                hostname))\n            res = host.run(cmd_nslookup)\n            assert res.rc == 0, \"Cannot resolve {}\".format(hostname)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148974,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "@then(parsers.parse(\"the hostname '{hostname}' should be resolved\"))\ndef resolve_hostname(busybox_pod, host, hostname):\n    with host.sudo():\n        # test dns resolve\n        result = host.run(\n            \"kubectl --kubeconfig=/etc/kubernetes/admin.conf \"\n            \"exec -ti %s nslookup %s\",\n            busybox_pod,\n            hostname,\n        )\n\n        assert result.rc == 0, \"Cannot resolve {}\".format(hostname)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148975,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _modify_3par_fibrechan_host(self, hostname, wwn):\n        # when using -add, you can not send the persona or domain options\n        out = self.common._cli_run('createhost -add %s %s'\n                                   % (hostname, \" \".join(wwn)), None)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148976,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _modify_3par_fibrechan_host(self, hostname, wwns):\n        # when using -add, you can not send the persona or domain options\n        command = ['createhost', '-add', hostname]\n        for wwn in wwns:\n            command.append(wwn)\n\n        out = self.common._cli_run(command)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148977,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def test_settings_path_skip_issue_909(tmpdir):\n    base_dir = tmpdir.mkdir('project')\n    config_dir = base_dir.mkdir('conf')\n    config_dir.join('.isort.cfg').write('[isort]\\n'\n                                        'skip =\\n'\n                                        '    file_to_be_skipped.py\\n'\n                                        'skip_glob =\\n'\n                                        '    *glob_skip*\\n')\n\n    base_dir.join('file_glob_skip.py').write('import os\\n'\n                                             '\\n'\n                                             'print(\"Hello World\")\\n'\n                                             '\\n'\n                                             'import sys\\n')\n    base_dir.join('file_to_be_skipped.py').write('import os\\n'\n                                                 '\\n'\n                                                 'print(\"Hello World\")'\n                                                 '\\n'\n                                                 'import sys\\n')\n\n    test_run_directory = os.getcwd()\n    os.chdir(str(base_dir))\n    with pytest.raises(Exception):  # without the settings path provided: the command should not skip & identify errors\n        check_output(['isort', '--check-only'])\n    results = check_output(['isort', '--check-only', '--settings-path=conf/.isort.cfg'])\n    os.chdir(str(test_run_directory))\n\n    assert b'skipped 2' in results.lower()",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148978,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def test_settings_path_skip_issue_909(tmpdir):\n    base_dir = tmpdir.mkdir('project')\n    config_dir = base_dir.mkdir('conf')\n    config_dir.join('.isort.cfg').write('[isort]\\n'\n                                        'skip =\\n'\n                                        '    file_to_be_skipped.py\\n'\n                                        'skip_glob =\\n'\n                                        '    *glob_skip*\\n')\n\n    base_dir.join('file_glob_skip.py').write('import os\\n'\n                                             '\\n'\n                                             'print(\"Hello World\")\\n'\n                                             '\\n'\n                                             'import sys\\n')\n    base_dir.join('file_to_be_skipped.py').write('import os\\n'\n                                                 '\\n'\n                                                 'print(\"Hello World\")'\n                                                 '\\n'\n                                                 'import sys\\n')\n\n    test_run_directory = os.getcwd()\n    os.chdir(str(base_dir))\n    with pytest.raises(Exception):  # without the settings path provided: the command should not skip & identify errors\n        subprocess.run(['isort', '--check-only'], check=True)\n    result = subprocess.run(\n        ['isort', '--check-only', '--settings-path=conf/.isort.cfg'],\n        stdout=subprocess.PIPE,\n        check=True\n    )\n    os.chdir(str(test_run_directory))\n\n    assert b'skipped 2' in result.stdout.lower()",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148979,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _create_3par_fibrechan_host(self, hostname, wwn, domain, persona_id):\n        \"\"\"Create a 3PAR host.\n\n        Create a 3PAR host, if there is already a host on the 3par using\n        the same wwn but with a different hostname, return the hostname\n        used by 3PAR.\n        \"\"\"\n        out = self.common._cli_run('createhost -persona %s -domain %s %s %s'\n                                   % (persona_id, domain,\n                                      hostname, \" \".join(wwn)), None)\n        if out and len(out) > 1:\n            return self.common.parse_create_host_error(hostname, out)\n\n        return hostname",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148980,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _create_3par_fibrechan_host(self, hostname, wwns, domain, persona_id):\n        \"\"\"Create a 3PAR host.\n\n        Create a 3PAR host, if there is already a host on the 3par using\n        the same wwn but with a different hostname, return the hostname\n        used by 3PAR.\n        \"\"\"\n        command = ['createhost', '-persona', persona_id, '-domain', domain,\n                   hostname]\n        for wwn in wwns:\n            command.append(wwn)\n\n        out = self.common._cli_run(command)\n        if out and len(out) > 1:\n            return self.common.parse_create_host_error(hostname, out)\n\n        return hostname",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148981,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def take_bug_report(self, test_name, begin_time):\n        \"\"\"Takes a bug report on the device and stores it in a file.\n\n        Args:\n            test_name: Name of the test case that triggered this bug report.\n            begin_time: Logline format timestamp taken when the test started.\n        \"\"\"\n        new_br = True\n        try:\n            stdout = self.adb.shell('bugreportz -v').decode('utf-8')\n            # This check is necessary for builds before N, where adb shell's ret\n            # code and stderr are not propagated properly.\n            if 'not found' in stdout:\n                new_br = False\n        except adb.AdbError:\n            new_br = False\n        br_path = os.path.join(self.log_path, 'BugReports')\n        utils.create_dir(br_path)\n        base_name = ',%s,%s.txt' % (begin_time, self.serial)\n        if new_br:\n            base_name = base_name.replace('.txt', '.zip')\n        test_name_len = utils.MAX_FILENAME_LEN - len(base_name)\n        out_name = test_name[:test_name_len] + base_name\n        full_out_path = os.path.join(br_path, out_name.replace(' ', r'\\ '))\n        # in case device restarted, wait for adb interface to return\n        self.wait_for_boot_completion()\n        self.log.info('Taking bugreport for %s.', test_name)\n        if new_br:\n            out = self.adb.shell('bugreportz').decode('utf-8')\n            if not out.startswith('OK'):\n                raise DeviceError(self, 'Failed to take bugreport: %s' % out)\n            br_out_path = out.split(':')[1].strip()\n            self.adb.pull('%s %s' % (br_out_path, full_out_path))\n        else:\n            self.adb.bugreport(' > %s' % full_out_path)\n        self.log.info('Bugreport for %s taken at %s.', test_name,\n                      full_out_path)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148982,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def take_bug_report(self, test_name, begin_time):\n        \"\"\"Takes a bug report on the device and stores it in a file.\n\n        Args:\n            test_name: Name of the test case that triggered this bug report.\n            begin_time: Logline format timestamp taken when the test started.\n        \"\"\"\n        new_br = True\n        try:\n            stdout = self.adb.shell('bugreportz -v').decode('utf-8')\n            # This check is necessary for builds before N, where adb shell's ret\n            # code and stderr are not propagated properly.\n            if 'not found' in stdout:\n                new_br = False\n        except adb.AdbError:\n            new_br = False\n        br_path = os.path.join(self.log_path, 'BugReports')\n        utils.create_dir(br_path)\n        base_name = ',%s,%s.txt' % (begin_time, self.serial)\n        if new_br:\n            base_name = base_name.replace('.txt', '.zip')\n        test_name_len = utils.MAX_FILENAME_LEN - len(base_name)\n        out_name = test_name[:test_name_len] + base_name\n        full_out_path = os.path.join(br_path, out_name.replace(' ', r'\\ '))\n        # in case device restarted, wait for adb interface to return\n        self.wait_for_boot_completion()\n        self.log.info('Taking bugreport for %s.', test_name)\n        if new_br:\n            out = self.adb.shell('bugreportz').decode('utf-8')\n            if not out.startswith('OK'):\n                raise DeviceError(self, 'Failed to take bugreport: %s' % out)\n            br_out_path = out.split(':')[1].strip()\n            self.adb.pull([br_out_path, full_out_path])\n        else:\n            # shell=True as this command redirects the stdout to a local file\n            # using shell redirection.\n            self.adb.bugreport(' > %s' % full_out_path, shell=True)\n        self.log.info('Bugreport for %s taken at %s.', test_name,\n                      full_out_path)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148983,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_create_invalid_host(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_cpg\",\n                       self.fake_get_cpg)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_domain\",\n                       self.fake_get_domain)\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_host_cmd = 'showhost -verbose fakehost'\n        _run_ssh(show_host_cmd, False).AndReturn([pack('no hosts listed'), ''])\n\n        create_host_cmd = ('createhost -iscsi -persona 1 -domain '\n                           '(\\'OpenStack\\',) '\n                           'fakehost iqn.1993-08.org.debian:01:222')\n        in_use_ret = pack('\\r\\nalready used by host fakehost.foo ')\n        _run_ssh(create_host_cmd, False).AndReturn([in_use_ret, ''])\n\n        show_3par_cmd = 'showhost -verbose fakehost.foo'\n        _run_ssh(show_3par_cmd, False).AndReturn([pack(ISCSI_3PAR_RET), ''])\n        self.mox.ReplayAll()\n\n        host = self.driver._create_host(self.volume, self.connector)\n\n        self.assertEquals(host['name'], 'fakehost.foo')",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148984,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_create_invalid_host(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_cpg\",\n                       self.fake_get_cpg)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_domain\",\n                       self.fake_get_domain)\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_host_cmd = ['showhost', '-verbose', 'fakehost']\n        _run_ssh(show_host_cmd, False).AndReturn([pack('no hosts listed'), ''])\n\n        create_host_cmd = (['createhost', '-iscsi', '-persona', '1', '-domain',\n                           ('OpenStack',), 'fakehost',\n                            'iqn.1993-08.org.debian:01:222'])\n        in_use_ret = pack('\\r\\nalready used by host fakehost.foo ')\n        _run_ssh(create_host_cmd, False).AndReturn([in_use_ret, ''])\n\n        show_3par_cmd = ['showhost', '-verbose', 'fakehost.foo']\n        _run_ssh(show_3par_cmd, False).AndReturn([pack(ISCSI_3PAR_RET), ''])\n        self.mox.ReplayAll()\n\n        host = self.driver._create_host(self.volume, self.connector)\n\n        self.assertEquals(host['name'], 'fakehost.foo')",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148985,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "        def adb_call(*args):\n            clean_name = name.replace('_', '-')\n            arg_str = ' '.join(str(elem) for elem in args)\n            return self._exec_adb_cmd(clean_name, arg_str)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148986,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "        def adb_call(args=None, shell=False):\n            \"\"\"Wrapper for an ADB command.\n\n            Args:\n                args: string or list of strings, arguments to the adb command.\n                    See subprocess.Proc() documentation.\n                shell: bool, True to run this command through the system shell,\n                    False to invoke it directly. See subprocess.Proc() docs.\n\n            Returns:\n                The output of the adb command run if exit code is 0.\n            \"\"\"\n            args = args or ''\n            clean_name = name.replace('_', '-')\n            return self._exec_adb_cmd(clean_name, args, shell=shell)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148987,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def test_skip_paths_issue_938(tmpdir):\n    base_dir = tmpdir.mkdir('project')\n    config_dir = base_dir.mkdir('conf')\n    config_dir.join('.isort.cfg').write('[isort]\\n'\n                                        'line_length = 88\\n'\n                                        'multi_line_output = 4\\n'\n                                        'lines_after_imports = 2\\n'\n                                        'skip_glob =\\n'\n                                        '    migrations/**.py\\n')\n    base_dir.join('dont_skip.py').write('import os\\n'\n                                        '\\n'\n                                        'print(\"Hello World\")'\n                                        '\\n'\n                                        'import sys\\n')\n\n    migrations_dir = base_dir.mkdir('migrations')\n    migrations_dir.join('file_glob_skip.py').write('import os\\n'\n                                                   '\\n'\n                                                   'print(\"Hello World\")\\n'\n                                                   '\\n'\n                                                   'import sys\\n')\n\n    test_run_directory = os.getcwd()\n    os.chdir(str(base_dir))\n    results = check_output(['isort', 'dont_skip.py', 'migrations/file_glob_skip.py'])\n    os.chdir(str(test_run_directory))\n\n    assert b'skipped' not in results.lower()\n\n    os.chdir(str(base_dir))\n    results = check_output(['isort', '--filter-files', '--settings-path=conf/.isort.cfg', 'dont_skip.py', 'migrations/file_glob_skip.py'])\n    os.chdir(str(test_run_directory))\n\n    assert b'skipped 1' in results.lower()",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148988,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def test_skip_paths_issue_938(tmpdir):\n    base_dir = tmpdir.mkdir('project')\n    config_dir = base_dir.mkdir('conf')\n    config_dir.join('.isort.cfg').write('[isort]\\n'\n                                        'line_length = 88\\n'\n                                        'multi_line_output = 4\\n'\n                                        'lines_after_imports = 2\\n'\n                                        'skip_glob =\\n'\n                                        '    migrations/**.py\\n')\n    base_dir.join('dont_skip.py').write('import os\\n'\n                                        '\\n'\n                                        'print(\"Hello World\")'\n                                        '\\n'\n                                        'import sys\\n')\n\n    migrations_dir = base_dir.mkdir('migrations')\n    migrations_dir.join('file_glob_skip.py').write('import os\\n'\n                                                   '\\n'\n                                                   'print(\"Hello World\")\\n'\n                                                   '\\n'\n                                                   'import sys\\n')\n\n    test_run_directory = os.getcwd()\n    os.chdir(str(base_dir))\n    result = subprocess.run(\n        ['isort', 'dont_skip.py', 'migrations/file_glob_skip.py'],\n        stdout=subprocess.PIPE,\n        check=True,\n    )\n    os.chdir(str(test_run_directory))\n\n    assert b'skipped' not in result.stdout.lower()\n\n    os.chdir(str(base_dir))\n    result = subprocess.run(\n        ['isort', '--filter-files', '--settings-path=conf/.isort.cfg', 'dont_skip.py', 'migrations/file_glob_skip.py'],\n        stdout=subprocess.PIPE,\n        check=True,\n    )\n    os.chdir(str(test_run_directory))\n\n    assert b'skipped 1' in result.stdout.lower()",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148989,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _ensure_vdisk_no_fc_mappings(self, name, allow_snaps=True):\n        # Ensure vdisk has no FlashCopy mappings\n        mapping_ids = self._get_vdisk_fc_mappings(name)\n        while len(mapping_ids):\n            wait_for_copy = False\n            for map_id in mapping_ids:\n                attrs = self._get_flashcopy_mapping_attributes(map_id)\n                if not attrs:\n                    continue\n                source = attrs['source_vdisk_name']\n                target = attrs['target_vdisk_name']\n                copy_rate = attrs['copy_rate']\n                status = attrs['status']\n\n                if copy_rate == '0':\n                    # Case #2: A vdisk that has snapshots\n                    if source == name:\n                        if not allow_snaps:\n                            return False\n                        ssh_cmd = ('svctask chfcmap -copyrate 50 '\n                                   '-autodelete on %s' % map_id)\n                        out, err = self._run_ssh(ssh_cmd)\n                        wait_for_copy = True\n                    # Case #3: A snapshot\n                    else:\n                        msg = (_('Vdisk %(name)s not involved in '\n                                 'mapping %(src)s -> %(tgt)s') %\n                               {'name': name, 'src': source, 'tgt': target})\n                        self._driver_assert(target == name, msg)\n                        if status in ['copying', 'prepared']:\n                            self._run_ssh('svctask stopfcmap %s' % map_id)\n                        elif status in ['stopping', 'preparing']:\n                            wait_for_copy = True\n                        else:\n                            self._run_ssh('svctask rmfcmap -force %s' % map_id)\n                # Case 4: Copy in progress - wait and will autodelete\n                else:\n                    if status == 'prepared':\n                        self._run_ssh('svctask stopfcmap %s' % map_id)\n                        self._run_ssh('svctask rmfcmap -force %s' % map_id)\n                    elif status == 'idle_or_copied':\n                        # Prepare failed\n                        self._run_ssh('svctask rmfcmap -force %s' % map_id)\n                    else:\n                        wait_for_copy = True\n            if wait_for_copy:\n                time.sleep(5)\n            mapping_ids = self._get_vdisk_fc_mappings(name)\n        return True",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148990,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _ensure_vdisk_no_fc_mappings(self, name, allow_snaps=True):\n        # Ensure vdisk has no FlashCopy mappings\n        mapping_ids = self._get_vdisk_fc_mappings(name)\n        while len(mapping_ids):\n            wait_for_copy = False\n            for map_id in mapping_ids:\n                attrs = self._get_flashcopy_mapping_attributes(map_id)\n                if not attrs:\n                    continue\n                source = attrs['source_vdisk_name']\n                target = attrs['target_vdisk_name']\n                copy_rate = attrs['copy_rate']\n                status = attrs['status']\n\n                if copy_rate == '0':\n                    # Case #2: A vdisk that has snapshots\n                    if source == name:\n                        if not allow_snaps:\n                            return False\n                        ssh_cmd = ['svctask', 'chfcmap', '-copyrate', '50',\n                                   '-autodelete', 'on', map_id]\n                        out, err = self._run_ssh(ssh_cmd)\n                        wait_for_copy = True\n                    # Case #3: A snapshot\n                    else:\n                        msg = (_('Vdisk %(name)s not involved in '\n                                 'mapping %(src)s -> %(tgt)s') %\n                               {'name': name, 'src': source, 'tgt': target})\n                        self._driver_assert(target == name, msg)\n                        if status in ['copying', 'prepared']:\n                            self._run_ssh(['svctask', 'stopfcmap', map_id])\n                        elif status in ['stopping', 'preparing']:\n                            wait_for_copy = True\n                        else:\n                            self._run_ssh(['svctask', 'rmfcmap', '-force',\n                                           map_id])\n                # Case 4: Copy in progress - wait and will autodelete\n                else:\n                    if status == 'prepared':\n                        self._run_ssh(['svctask', 'stopfcmap', map_id])\n                        self._run_ssh(['svctask', 'rmfcmap', '-force', map_id])\n                    elif status == 'idle_or_copied':\n                        # Prepare failed\n                        self._run_ssh(['svctask', 'rmfcmap', '-force', map_id])\n                    else:\n                        wait_for_copy = True\n            if wait_for_copy:\n                time.sleep(5)\n            mapping_ids = self._get_vdisk_fc_mappings(name)\n        return True",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148991,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def tcp_forward(self, host_port, device_port):\n        \"\"\"Starts tcp forwarding.\n\n        Args:\n            host_port: Port number to use on the computer.\n            device_port: Port number to use on the android device.\n        \"\"\"\n        self.forward('tcp:%d tcp:%d' % (host_port, device_port))",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148992,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def tcp_forward(self, host_port, device_port):\n        \"\"\"Starts tcp forwarding.\n\n        Args:\n            host_port: Port number to use on the computer.\n            device_port: Port number to use on the android device.\n        \"\"\"\n        self.forward(['tcp:%d' % host_port, 'tcp:%d' % device_port])",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148993,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def repack(host, targets, channel='stable'):\n  url = 'https://static.rust-lang.org/dist/channel-rust-' + channel + '.toml'\n  req = requests.get(url)\n  req.raise_for_status()\n  manifest = toml.loads(req.content)\n  if manifest['manifest-version'] != '2':\n    print('ERROR: unrecognized manifest version %s.' % manifest['manifest-version'])\n    return\n  print('Using manifest for rust %s as of %s.' % (channel, manifest['date']))\n  rustc_version, rustc = package(manifest, 'rustc', host)\n  if rustc['available']:\n    print('rustc %s\\n  %s\\n  %s' % (rustc_version, rustc['url'], rustc['hash']))\n    fetch(rustc['url'])\n  cargo_version, cargo = package(manifest, 'cargo', host)\n  if cargo['available']:\n    print('cargo %s\\n  %s\\n  %s' % (cargo_version, cargo['url'], cargo['hash']))\n    fetch(cargo['url'])\n  stds = []\n  for target in targets:\n      version, info = package(manifest, 'rust-std', target)\n      if info['available']:\n        print('rust-std %s\\n  %s\\n  %s' % (version, info['url'], info['hash']))\n        fetch(info['url'])\n        stds.append(info)\n  print('Installing packages...')\n  tar_basename = 'rustc-%s-repack' % host\n  install_dir = 'rustc'\n  os.system('rm -rf %s' % install_dir)\n  install(os.path.basename(rustc['url']), install_dir)\n  install(os.path.basename(cargo['url']), install_dir)\n  for std in stds:\n    install(os.path.basename(std['url']), install_dir)\n  print('Tarring %s...' % tar_basename)\n  os.system('tar cjf %s.tar.bz2 %s/*' % (tar_basename, install_dir))\n  os.system('rm -rf %s' % install_dir)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148994,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def repack(host, targets, channel='stable'):\n  print(\"Repacking rust for %s...\" % host)\n  url = 'https://static.rust-lang.org/dist/channel-rust-' + channel + '.toml'\n  req = requests.get(url)\n  req.raise_for_status()\n  manifest = toml.loads(req.content)\n  if manifest['manifest-version'] != '2':\n    print('ERROR: unrecognized manifest version %s.' % manifest['manifest-version'])\n    return\n  print('Using manifest for rust %s as of %s.' % (channel, manifest['date']))\n  rustc_version, rustc = package(manifest, 'rustc', host)\n  if rustc['available']:\n    print('rustc %s\\n  %s\\n  %s' % (rustc_version, rustc['url'], rustc['hash']))\n    fetch(rustc['url'])\n  cargo_version, cargo = package(manifest, 'cargo', host)\n  if cargo['available']:\n    print('cargo %s\\n  %s\\n  %s' % (cargo_version, cargo['url'], cargo['hash']))\n    fetch(cargo['url'])\n  stds = []\n  for target in targets:\n      version, info = package(manifest, 'rust-std', target)\n      if info['available']:\n        print('rust-std %s\\n  %s\\n  %s' % (version, info['url'], info['hash']))\n        fetch(info['url'])\n        stds.append(info)\n  print('Installing packages...')\n  tar_basename = 'rustc-%s-repack' % host\n  install_dir = 'rustc'\n  subprocess.check_call(['rm', '-rf', install_dir])\n  install(os.path.basename(rustc['url']), install_dir)\n  install(os.path.basename(cargo['url']), install_dir)\n  for std in stds:\n    install(os.path.basename(std['url']), install_dir)\n  print('Tarring %s...' % tar_basename)\n  subprocess.check_call(['tar', 'cjf', tar_basename + '.tar.bz2', install_dir])\n  subprocess.check_call(['rm', '-rf', install_dir])",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148995,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def extend_volume(self, volume, new_size):\n        volume_name = self._get_3par_vol_name(volume['id'])\n        old_size = volume.size\n        growth_size = int(new_size) - old_size\n        LOG.debug(\"Extending Volume %s from %s to %s, by %s GB.\" %\n                  (volume_name, old_size, new_size, growth_size))\n        try:\n            self._cli_run(\"growvv -f %s %sg\" % (volume_name, growth_size),\n                          None)\n        except Exception:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_(\"Error extending volume %s\") % volume)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148996,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def extend_volume(self, volume, new_size):\n        volume_name = self._get_3par_vol_name(volume['id'])\n        old_size = volume.size\n        growth_size = int(new_size) - old_size\n        LOG.debug(\"Extending Volume %s from %s to %s, by %s GB.\" %\n                  (volume_name, old_size, new_size, growth_size))\n        try:\n            self._cli_run(['growvv', '-f', volume_name, '%dg' % growth_size])\n        except Exception:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_(\"Error extending volume %s\") % volume)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148997,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _remove_volume_set(self, vvs_name):\n        # Must first clear the QoS rules before removing the volume set\n        self._cli_run('setqos -clear vvset:%s' % (vvs_name), None)\n        self._cli_run('removevvset -f %s' % (vvs_name), None)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 148998,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _remove_volume_set(self, vvs_name):\n        # Must first clear the QoS rules before removing the volume set\n        self._cli_run(['setqos', '-clear', 'vvset:%s' % (vvs_name)])\n        self._cli_run(['removevvset', '-f', vvs_name])",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 148999,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_3par_hostname_from_wwn_iqn(self, wwns_iqn):\n        out = self._cli_run('showhost -d', None)\n        # wwns_iqn may be a list of strings or a single\n        # string. So, if necessary, create a list to loop.\n        if not isinstance(wwns_iqn, list):\n            wwn_iqn_list = [wwns_iqn]\n        else:\n            wwn_iqn_list = wwns_iqn\n\n        for wwn_iqn in wwn_iqn_list:\n            for showhost in out:\n                if (wwn_iqn.upper() in showhost.upper()):\n                    return showhost.split(',')[1]",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149000,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_3par_hostname_from_wwn_iqn(self, wwns_iqn):\n        out = self._cli_run(['showhost', '-d'])\n        # wwns_iqn may be a list of strings or a single\n        # string. So, if necessary, create a list to loop.\n        if not isinstance(wwns_iqn, list):\n            wwn_iqn_list = [wwns_iqn]\n        else:\n            wwn_iqn_list = wwns_iqn\n\n        for wwn_iqn in wwn_iqn_list:\n            for showhost in out:\n                if (wwn_iqn.upper() in showhost.upper()):\n                    return showhost.split(',')[1]",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149001,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def get_ports(self):\n        # First get the active FC ports\n        out = self._cli_run('showport', None)\n\n        # strip out header\n        # N:S:P,Mode,State,----Node_WWN----,-Port_WWN/HW_Addr-,Type,\n        # Protocol,Label,Partner,FailoverState\n        out = out[1:len(out) - 2]\n\n        ports = {'FC': [], 'iSCSI': {}}\n        for line in out:\n            tmp = line.split(',')\n\n            if tmp:\n                if tmp[1] == 'target' and tmp[2] == 'ready':\n                    if tmp[6] == 'FC':\n                        ports['FC'].append(tmp[4])\n\n        # now get the active iSCSI ports\n        out = self._cli_run('showport -iscsi', None)\n\n        # strip out header\n        # N:S:P,State,IPAddr,Netmask,Gateway,\n        # TPGT,MTU,Rate,DHCP,iSNS_Addr,iSNS_Port\n        out = out[1:len(out) - 2]\n        for line in out:\n            tmp = line.split(',')\n\n            if tmp and len(tmp) > 2:\n                if tmp[1] == 'ready':\n                    ports['iSCSI'][tmp[2]] = {}\n\n        # now get the nsp and iqn\n        result = self._cli_run('showport -iscsiname', None)\n        if result:\n            # first line is header\n            # nsp, ip,iqn\n            result = result[1:]\n            for line in result:\n                info = line.split(\",\")\n                if info and len(info) > 2:\n                    if info[1] in ports['iSCSI']:\n                        nsp = info[0]\n                        ip_addr = info[1]\n                        iqn = info[2]\n                        ports['iSCSI'][ip_addr] = {'nsp': nsp,\n                                                   'iqn': iqn\n                                                   }\n\n        LOG.debug(\"PORTS = %s\" % pprint.pformat(ports))\n        return ports",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149002,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def get_ports(self):\n        # First get the active FC ports\n        out = self._cli_run(['showport'])\n\n        # strip out header\n        # N:S:P,Mode,State,----Node_WWN----,-Port_WWN/HW_Addr-,Type,\n        # Protocol,Label,Partner,FailoverState\n        out = out[1:len(out) - 2]\n\n        ports = {'FC': [], 'iSCSI': {}}\n        for line in out:\n            tmp = line.split(',')\n\n            if tmp:\n                if tmp[1] == 'target' and tmp[2] == 'ready':\n                    if tmp[6] == 'FC':\n                        ports['FC'].append(tmp[4])\n\n        # now get the active iSCSI ports\n        out = self._cli_run(['showport', '-iscsi'])\n\n        # strip out header\n        # N:S:P,State,IPAddr,Netmask,Gateway,\n        # TPGT,MTU,Rate,DHCP,iSNS_Addr,iSNS_Port\n        out = out[1:len(out) - 2]\n        for line in out:\n            tmp = line.split(',')\n\n            if tmp and len(tmp) > 2:\n                if tmp[1] == 'ready':\n                    ports['iSCSI'][tmp[2]] = {}\n\n        # now get the nsp and iqn\n        result = self._cli_run(['showport', '-iscsiname'])\n        if result:\n            # first line is header\n            # nsp, ip,iqn\n            result = result[1:]\n            for line in result:\n                info = line.split(\",\")\n                if info and len(info) > 2:\n                    if info[1] in ports['iSCSI']:\n                        nsp = info[0]\n                        ip_addr = info[1]\n                        iqn = info[2]\n                        ports['iSCSI'][ip_addr] = {'nsp': nsp,\n                                                   'iqn': iqn\n                                                   }\n\n        LOG.debug(\"PORTS = %s\" % pprint.pformat(ports))\n        return ports",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149003,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_get_least_used_nsp(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_vlun_cmd = 'showvlun -a -showcols Port'\n        _run_ssh(show_vlun_cmd, False).AndReturn([pack(SHOW_VLUN_NONE), ''])\n        _run_ssh(show_vlun_cmd, False).AndReturn([pack(SHOW_VLUN_NONE), ''])\n        _run_ssh(show_vlun_cmd, False).AndReturn([pack(SHOW_VLUN_NONE), ''])\n\n        self.mox.ReplayAll()\n        # in use count                           11       12\n        nsp = self.driver._get_least_used_nsp(['0:2:1', '1:8:1'])\n        self.assertEqual(nsp, '0:2:1')\n\n        # in use count                            11       10\n        nsp = self.driver._get_least_used_nsp(['0:2:1', '1:2:1'])\n        self.assertEqual(nsp, '1:2:1')\n\n        # in use count                            0       10\n        nsp = self.driver._get_least_used_nsp(['1:1:1', '1:2:1'])\n        self.assertEqual(nsp, '1:1:1')",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149004,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_get_least_used_nsp(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_vlun_cmd = ['showvlun', '-a', '-showcols', 'Port']\n        _run_ssh(show_vlun_cmd, False).AndReturn([pack(SHOW_VLUN_NONE), ''])\n        _run_ssh(show_vlun_cmd, False).AndReturn([pack(SHOW_VLUN_NONE), ''])\n        _run_ssh(show_vlun_cmd, False).AndReturn([pack(SHOW_VLUN_NONE), ''])\n\n        self.mox.ReplayAll()\n        # in use count                           11       12\n        nsp = self.driver._get_least_used_nsp(['0:2:1', '1:8:1'])\n        self.assertEqual(nsp, '0:2:1')\n\n        # in use count                            11       10\n        nsp = self.driver._get_least_used_nsp(['0:2:1', '1:2:1'])\n        self.assertEqual(nsp, '1:2:1')\n\n        # in use count                            0       10\n        nsp = self.driver._get_least_used_nsp(['1:1:1', '1:2:1'])\n        self.assertEqual(nsp, '1:1:1')",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149005,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _cmd_to_dict(self, cmd):\n        arg_list = cmd.split()\n        no_param_args = [\n            'autodelete',\n            'autoexpand',\n            'bytes',\n            'compressed',\n            'force',\n            'nohdr',\n        ]\n        one_param_args = [\n            'chapsecret',\n            'cleanrate',\n            'copyrate',\n            'delim',\n            'filtervalue',\n            'grainsize',\n            'hbawwpn',\n            'host',\n            'iogrp',\n            'iscsiname',\n            'mdiskgrp',\n            'name',\n            'rsize',\n            'scsi',\n            'size',\n            'source',\n            'target',\n            'unit',\n            'easytier',\n            'warning',\n            'wwpn',\n        ]\n\n        # Handle the special case of lsnode which is a two-word command\n        # Use the one word version of the command internally\n        if arg_list[0] in ('svcinfo', 'svctask'):\n            if arg_list[1] == 'lsnode':\n                if len(arg_list) > 4:  # e.g. svcinfo lsnode -delim ! <node id>\n                    ret = {'cmd': 'lsnode', 'node_id': arg_list[-1]}\n                else:\n                    ret = {'cmd': 'lsnodecanister'}\n            else:\n                ret = {'cmd': arg_list[1]}\n            arg_list.pop(0)\n        else:\n            ret = {'cmd': arg_list[0]}\n\n        skip = False\n        for i in range(1, len(arg_list)):\n            if skip:\n                skip = False\n                continue\n            if arg_list[i][0] == '-':\n                if arg_list[i][1:] in no_param_args:\n                    ret[arg_list[i][1:]] = True\n                elif arg_list[i][1:] in one_param_args:\n                    ret[arg_list[i][1:]] = arg_list[i + 1]\n                    skip = True\n                else:\n                    raise exception.InvalidInput(\n                        reason=_('unrecognized argument %s') % arg_list[i])\n            else:\n                ret['obj'] = arg_list[i]\n        return ret",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149006,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _cmd_to_dict(self, arg_list):\n        no_param_args = [\n            'autodelete',\n            'autoexpand',\n            'bytes',\n            'compressed',\n            'force',\n            'nohdr',\n        ]\n        one_param_args = [\n            'chapsecret',\n            'cleanrate',\n            'copyrate',\n            'delim',\n            'filtervalue',\n            'grainsize',\n            'hbawwpn',\n            'host',\n            'iogrp',\n            'iscsiname',\n            'mdiskgrp',\n            'name',\n            'rsize',\n            'scsi',\n            'size',\n            'source',\n            'target',\n            'unit',\n            'easytier',\n            'warning',\n            'wwpn',\n        ]\n\n        # Handle the special case of lsnode which is a two-word command\n        # Use the one word version of the command internally\n        if arg_list[0] in ('svcinfo', 'svctask'):\n            if arg_list[1] == 'lsnode':\n                if len(arg_list) > 4:  # e.g. svcinfo lsnode -delim ! <node id>\n                    ret = {'cmd': 'lsnode', 'node_id': arg_list[-1]}\n                else:\n                    ret = {'cmd': 'lsnodecanister'}\n            else:\n                ret = {'cmd': arg_list[1]}\n            arg_list.pop(0)\n        else:\n            ret = {'cmd': arg_list[0]}\n\n        skip = False\n        for i in range(1, len(arg_list)):\n            if skip:\n                skip = False\n                continue\n            if arg_list[i][0] == '-':\n                if arg_list[i][1:] in no_param_args:\n                    ret[arg_list[i][1:]] = True\n                elif arg_list[i][1:] in one_param_args:\n                    ret[arg_list[i][1:]] = arg_list[i + 1]\n                    skip = True\n                else:\n                    raise exception.InvalidInput(\n                        reason=_('unrecognized argument %s') % arg_list[i])\n            else:\n                ret['obj'] = arg_list[i]\n        return ret",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149007,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _cli_run(self, verb, cli_args):\n        \"\"\"Runs a CLI command over SSH, without doing any result parsing.\"\"\"\n        cli_arg_strings = []\n        if cli_args:\n            for k, v in cli_args.items():\n                if k == '':\n                    cli_arg_strings.append(\" %s\" % k)\n                else:\n                    cli_arg_strings.append(\" %s=%s\" % (k, v))\n\n        cmd = verb + ''.join(cli_arg_strings)\n        LOG.debug(\"SSH CMD = %s \" % cmd)\n\n        (stdout, stderr) = self._run_ssh(cmd, False)\n\n        # we have to strip out the input and exit lines\n        tmp = stdout.split(\"\\r\\n\")\n        out = tmp[5:len(tmp) - 2]\n        return out",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149008,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _cli_run(self, cmd):\n        \"\"\"Runs a CLI command over SSH, without doing any result parsing.\"\"\"\n        LOG.debug(\"SSH CMD = %s \" % cmd)\n\n        (stdout, stderr) = self._run_ssh(cmd, False)\n\n        # we have to strip out the input and exit lines\n        tmp = stdout.split(\"\\r\\n\")\n        out = tmp[5:len(tmp) - 2]\n        return out",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149009,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def _call_external_zip(base_dir, zip_filename, verbose=False, dry_run=False):\n    # XXX see if we want to keep an external call here\n    if verbose:\n        zipoptions = \"-r\"\n    else:\n        zipoptions = \"-rq\"\n    from distutils.errors import DistutilsExecError\n    from distutils.spawn import spawn\n    try:\n        spawn([\"zip\", zipoptions, zip_filename, base_dir], dry_run=dry_run)\n    except DistutilsExecError:\n        # XXX really should distinguish between \"couldn't find\n        # external 'zip' command\" and \"zip failed\".\n        raise ExecError, \\\n            (\"unable to create zip file '%s': \"\n            \"could neither import the 'zipfile' module nor \"\n            \"find a standalone zip utility\") % zip_filename",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149010,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def _call_external_zip(base_dir, zip_filename, verbose, dry_run, logger):\n    # XXX see if we want to keep an external call here\n    if verbose:\n        zipoptions = \"-r\"\n    else:\n        zipoptions = \"-rq\"\n    cmd = [\"zip\", zipoptions, zip_filename, base_dir]\n    if logger is not None:\n        logger.info(' '.join(cmd))\n    if dry_run:\n        return\n    import subprocess\n    try:\n        subprocess.check_call(cmd)\n    except subprocess.CalledProcessError:\n        # XXX really should distinguish between \"couldn't find\n        # external 'zip' command\" and \"zip failed\".\n        raise ExecError, \\\n            (\"unable to create zip file '%s': \"\n            \"could neither import the 'zipfile' module nor \"\n            \"find a standalone zip utility\") % zip_filename",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149011,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _create_host(self, connector):\n        \"\"\"Create a new host on the storage system.\n\n        We create a host name and associate it with the given connection\n        information.\n\n        \"\"\"\n\n        LOG.debug(_('enter: _create_host: host %s') % connector['host'])\n\n        rand_id = str(random.randint(0, 99999999)).zfill(8)\n        host_name = '%s-%s' % (self._connector_to_hostname_prefix(connector),\n                               rand_id)\n\n        # Get all port information from the connector\n        ports = []\n        if 'initiator' in connector:\n            ports.append('-iscsiname %s' % connector['initiator'])\n        if 'wwpns' in connector:\n            for wwpn in connector['wwpns']:\n                ports.append('-hbawwpn %s' % wwpn)\n\n        # When creating a host, we need one port\n        self._driver_assert(len(ports), _('_create_host: No connector ports'))\n        port1 = ports.pop(0)\n        ssh_cmd = ('svctask mkhost -force %(port1)s -name \"%(host_name)s\"' %\n                   {'port1': port1, 'host_name': host_name})\n        out, err = self._run_ssh(ssh_cmd)\n        self._assert_ssh_return('successfully created' in out,\n                                '_create_host', ssh_cmd, out, err)\n\n        # Add any additional ports to the host\n        for port in ports:\n            ssh_cmd = ('svctask addhostport -force %s %s' % (port, host_name))\n            out, err = self._run_ssh(ssh_cmd)\n\n        LOG.debug(_('leave: _create_host: host %(host)s - %(host_name)s') %\n                  {'host': connector['host'], 'host_name': host_name})\n        return host_name",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149012,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _create_host(self, connector):\n        \"\"\"Create a new host on the storage system.\n\n        We create a host name and associate it with the given connection\n        information.\n\n        \"\"\"\n\n        LOG.debug(_('enter: _create_host: host %s') % connector['host'])\n\n        rand_id = str(random.randint(0, 99999999)).zfill(8)\n        host_name = '%s-%s' % (self._connector_to_hostname_prefix(connector),\n                               rand_id)\n\n        # Get all port information from the connector\n        ports = []\n        if 'initiator' in connector:\n            ports.append('-iscsiname %s' % connector['initiator'])\n        if 'wwpns' in connector:\n            for wwpn in connector['wwpns']:\n                ports.append('-hbawwpn %s' % wwpn)\n\n        # When creating a host, we need one port\n        self._driver_assert(len(ports), _('_create_host: No connector ports'))\n        port1 = ports.pop(0)\n        arg_name, arg_val = port1.split()\n        ssh_cmd = ['svctask', 'mkhost', '-force', arg_name, arg_val, '-name',\n                   '\"%s\"' % host_name]\n        out, err = self._run_ssh(ssh_cmd)\n        self._assert_ssh_return('successfully created' in out,\n                                '_create_host', ssh_cmd, out, err)\n\n        # Add any additional ports to the host\n        for port in ports:\n            arg_name, arg_val = port.split()\n            ssh_cmd = ['svctask', 'addhostport', '-force', arg_name, arg_val,\n                       host_name]\n            out, err = self._run_ssh(ssh_cmd)\n\n        LOG.debug(_('leave: _create_host: host %(host)s - %(host_name)s') %\n                  {'host': connector['host'], 'host_name': host_name})\n        return host_name",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149013,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_iscsi_ip_addrs(self):\n        generator = self._port_conf_generator('svcinfo lsportip')\n        header = next(generator, None)\n        if not header:\n            return\n\n        for port_data in generator:\n            try:\n                port_node_id = port_data['node_id']\n                port_ipv4 = port_data['IP_address']\n                port_ipv6 = port_data['IP_address_6']\n                state = port_data['state']\n            except KeyError:\n                self._handle_keyerror('lsportip', header)\n\n            if port_node_id in self._storage_nodes and (\n                    state == 'configured' or state == 'online'):\n                node = self._storage_nodes[port_node_id]\n                if len(port_ipv4):\n                    node['ipv4'].append(port_ipv4)\n                if len(port_ipv6):\n                    node['ipv6'].append(port_ipv6)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149014,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_iscsi_ip_addrs(self):\n        generator = self._port_conf_generator(['svcinfo', 'lsportip'])\n        header = next(generator, None)\n        if not header:\n            return\n\n        for port_data in generator:\n            try:\n                port_node_id = port_data['node_id']\n                port_ipv4 = port_data['IP_address']\n                port_ipv6 = port_data['IP_address_6']\n                state = port_data['state']\n            except KeyError:\n                self._handle_keyerror('lsportip', header)\n\n            if port_node_id in self._storage_nodes and (\n                    state == 'configured' or state == 'online'):\n                node = self._storage_nodes[port_node_id]\n                if len(port_ipv4):\n                    node['ipv4'].append(port_ipv4)\n                if len(port_ipv6):\n                    node['ipv6'].append(port_ipv6)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149015,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def talk(myText):\r\n    if( myText.find( \"twitter\" ) >= 0 ):\r\n        myText += \"0\"\r\n        myText = myText[7:-1]\r\n        try:\r\n\t    myText = twitter.getTweet( myText )\r\n\texcept:\r\n\t    print( \"!!!ERROR: INVALID TWITTER CREDENTIALS. Please read README.md for instructions.\")\r\n            return\r\n    \r\n    os.system( \"espeak \\\",...\\\" 2>/dev/null\" ) # Sometimes the beginning of audio can get cut off. Insert silence.\r\n    time.sleep( 0.5 )\r\n    os.system( \"espeak -w speech.wav \\\"\" + myText + \"\\\" -s 130\" )\r\n    audio.play(\"speech.wav\")\r\n    return myText",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149016,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def talk(myText):\r\n    if( myText.find( \"twitter\" ) >= 0 ):\r\n        myText += \"0\"\r\n        myText = myText[7:-1]\r\n        try:\r\n\t    myText = twitter.getTweet( myText )\r\n\texcept:\r\n\t    print( \"!!!ERROR: INVALID TWITTER CREDENTIALS. Please read README.md for instructions.\")\r\n            return\r\n    \r\n    os.system( \"espeak \\\",...\\\" 2>/dev/null\" ) # Sometimes the beginning of audio can get cut off. Insert silence.\r\n    time.sleep( 0.5 )\r\n    subprocess.call([\"espeak\", \"-w\", \"speech.wav\", myText, \"-s\", \"130\"])\r\n    audio.play(\"speech.wav\")\r\n    return myText",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149017,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _exec_cmd(self, cmd):\n        \"\"\"Executes adb commands in a new shell.\n\n        This is specific to executing adb binary because stderr is not a good\n        indicator of cmd execution status.\n\n        Args:\n            cmds: A string that is the adb command to execute.\n\n        Returns:\n            The output of the adb command run if exit code is 0.\n\n        Raises:\n            AdbError is raised if the adb command exit code is not 0.\n        \"\"\"\n        proc = subprocess.Popen(\n            cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n        (out, err) = proc.communicate()\n        ret = proc.returncode\n        logging.debug('cmd: %s, stdout: %s, stderr: %s, ret: %s', cmd, out,\n                      err, ret)\n        if ret == 0:\n            return out\n        else:\n            raise AdbError(cmd=cmd, stdout=out, stderr=err, ret_code=ret)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149018,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _exec_cmd(self, args, shell):\n        \"\"\"Executes adb commands.\n\n        Args:\n            args: string or list of strings, program arguments.\n                See subprocess.Popen() documentation.\n            shell: bool, True to run this command through the system shell,\n                False to invoke it directly. See subprocess.Popen() docs.\n\n        Returns:\n            The output of the adb command run if exit code is 0.\n\n        Raises:\n            AdbError is raised if the adb command exit code is not 0.\n        \"\"\"\n        proc = subprocess.Popen(\n            args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=shell)\n        (out, err) = proc.communicate()\n        ret = proc.returncode\n        logging.debug('cmd: %s, stdout: %s, stderr: %s, ret: %s', args, out,\n                      err, ret)\n        if ret == 0:\n            return out\n        else:\n            raise AdbError(cmd=args, stdout=out, stderr=err, ret_code=ret)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149019,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_conn_fc_wwpns(self, host_name):\n        wwpns = []\n        cmd = 'svcinfo lsfabric -host %s' % host_name\n        generator = self._port_conf_generator(cmd)\n        header = next(generator, None)\n        if not header:\n            return wwpns\n\n        for port_data in generator:\n            try:\n                wwpns.append(port_data['local_wwpn'])\n            except KeyError as e:\n                self._handle_keyerror('lsfabric', header)\n\n        return wwpns",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149020,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_conn_fc_wwpns(self, host_name):\n        wwpns = []\n        cmd = ['svcinfo', 'lsfabric', '-host', host_name]\n        generator = self._port_conf_generator(cmd)\n        header = next(generator, None)\n        if not header:\n            return wwpns\n\n        for port_data in generator:\n            try:\n                wwpns.append(port_data['local_wwpn'])\n            except KeyError as e:\n                self._handle_keyerror('lsfabric', header)\n\n        return wwpns",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149021,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _create_3par_iscsi_host(self, hostname, iscsi_iqn, domain, persona_id):\n        \"\"\"Create a 3PAR host.\n\n        Create a 3PAR host, if there is already a host on the 3par using\n        the same iqn but with a different hostname, return the hostname\n        used by 3PAR.\n        \"\"\"\n        cmd = 'createhost -iscsi -persona %s -domain %s %s %s' % \\\n              (persona_id, domain, hostname, iscsi_iqn)\n        out = self.common._cli_run(cmd, None)\n        if out and len(out) > 1:\n            return self.common.parse_create_host_error(hostname, out)\n        return hostname",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149022,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _create_3par_iscsi_host(self, hostname, iscsi_iqn, domain, persona_id):\n        \"\"\"Create a 3PAR host.\n\n        Create a 3PAR host, if there is already a host on the 3par using\n        the same iqn but with a different hostname, return the hostname\n        used by 3PAR.\n        \"\"\"\n        cmd = ['createhost', '-iscsi', '-persona', persona_id, '-domain',\n               domain, hostname, iscsi_iqn]\n        out = self.common._cli_run(cmd)\n        if out and len(out) > 1:\n            return self.common.parse_create_host_error(hostname, out)\n        return hostname",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149023,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _delete_3par_host(self, hostname):\n        self._cli_run('removehost %s' % hostname, None)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149024,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _delete_3par_host(self, hostname):\n        self._cli_run(['removehost', hostname])",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149025,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def process_statistics(self, metadata, _):\n        args = [metadata.hostname, '-p', metadata.profile, '-g',\n                ':'.join([g for g in metadata.groups])]\n        for notifier in os.listdir(self.data):\n            if ((notifier[-1] == '~') or\n                (notifier[:2] == '.#') or\n                (notifier[-4:] == '.swp') or\n                (notifier in ['SCCS', '.svn', '4913'])):\n                continue\n            npath = self.data + '/' + notifier\n            self.logger.debug(\"Running %s %s\" % (npath, \" \".join(args)))\n            async_run(npath, args)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149026,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def process_statistics(self, metadata, _):\n        args = [metadata.hostname, '-p', metadata.profile, '-g',\n                ':'.join([g for g in metadata.groups])]\n        self.debug_log(\"running triggers\")\n        for notifier in os.listdir(self.data):\n            self.debug_log(\"running %s\" % notifier)\n            if ((notifier[-1] == '~') or\n                (notifier[:2] == '.#') or\n                (notifier[-4:] == '.swp') or\n                (notifier in ['SCCS', '.svn', '4913'])):\n                continue\n            npath = os.path.join(self.data, notifier)\n            self.async_run([npath] + args)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149027,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _delete_host(self, host_name):\n        \"\"\"Delete a host on the storage system.\"\"\"\n\n        LOG.debug(_('enter: _delete_host: host %s ') % host_name)\n\n        ssh_cmd = 'svctask rmhost %s ' % host_name\n        out, err = self._run_ssh(ssh_cmd)\n        # No output should be returned from rmhost\n        self._assert_ssh_return(len(out.strip()) == 0,\n                                '_delete_host', ssh_cmd, out, err)\n\n        LOG.debug(_('leave: _delete_host: host %s ') % host_name)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149028,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _delete_host(self, host_name):\n        \"\"\"Delete a host on the storage system.\"\"\"\n\n        LOG.debug(_('enter: _delete_host: host %s ') % host_name)\n\n        ssh_cmd = ['svctask', 'rmhost', host_name]\n        out, err = self._run_ssh(ssh_cmd)\n        # No output should be returned from rmhost\n        self._assert_ssh_return(len(out.strip()) == 0,\n                                '_delete_host', ssh_cmd, out, err)\n\n        LOG.debug(_('leave: _delete_host: host %s ') % host_name)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149029,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def fetch(url):\n  '''Download and verify a package url.'''\n  base = os.path.basename(url)\n  print('Fetching %s...' % base)\n  fetch_file(url + '.asc')\n  fetch_file(url)\n  fetch_file(url + '.sha256')\n  fetch_file(url + '.asc.sha256')\n  print('Verifying %s...' % base)\n  # TODO: check for verification failure.\n  os.system('shasum -c %s.sha256' % base)\n  os.system('shasum -c %s.asc.sha256' % base)\n  os.system('gpg --verify %s.asc %s' % (base, base))\n  os.system('keybase verify %s.asc' % base)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149030,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def fetch(url):\n  '''Download and verify a package url.'''\n  base = os.path.basename(url)\n  print('Fetching %s...' % base)\n  fetch_file(url + '.asc')\n  fetch_file(url)\n  fetch_file(url + '.sha256')\n  fetch_file(url + '.asc.sha256')\n  print('Verifying %s...' % base)\n  # TODO: check for verification failure.\n  subprocess.check_call(['shasum', '-c', base + '.sha256'])\n  subprocess.check_call(['shasum', '-c', base + '.asc.sha256'])\n  subprocess.check_call(['gpg', '--verify', base + '.asc', base])\n  subprocess.check_call(['keybase', 'verify', base + '.asc'])",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149031,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _formatCredentials(self, data, name):\n        \"\"\"\n        Credentials are of the form\n        RCLONE_CONFIG_CURRENT_TYPE=s3\n            ^          ^        ^   ^\n        [mandatory  ][name  ][key][value]\n        \"\"\"\n\n        prefix = \"RCLONE_CONFIG_{}\".format(name.upper())\n\n        credentials = ''\n        credentials += \"{}_TYPE='{}' \".format(prefix, data.type)\n\n        def _addCredential(credentials, env_key, data_key):\n            value = getattr(data, data_key, None)\n            if value is not None:\n                credentials += \"{}='{}' \".format(env_key, value)\n            return credentials\n\n\n        if data.type == 's3':\n            credentials = _addCredential(credentials,\n                '{}_REGION'.format(prefix),\n                's3_region'\n            )\n            credentials = _addCredential(credentials,\n                '{}_ACCESS_KEY_ID'.format(prefix),\n                's3_access_key_id'\n            )\n            credentials = _addCredential(credentials,\n                '{}_SECRET_ACCESS_KEY'.format(prefix),\n                's3_secret_access_key'\n            )\n\n            credentials = _addCredential(credentials,\n                '{}_ENDPOINT'.format(prefix),\n                's3_endpoint'\n            )\n            credentials = _addCredential(credentials,\n                '{}_V2_AUTH'.format(prefix),\n                's3_v2_auth'\n            )\n\n        elif data.type == 'azureblob':\n            credentials = _addCredential(credentials,\n                '{}_ACCOUNT'.format(prefix),\n                'azure_account'\n            )\n            credentials = _addCredential(credentials,\n                '{}_KEY'.format(prefix),\n                'azure_key'\n            )\n\n        elif data.type == 'swift':\n            credentials = _addCredential(credentials,\n                '{}_USER'.format(prefix),\n                'swift_user'\n            )\n            credentials = _addCredential(credentials,\n                '{}_KEY'.format(prefix),\n                'swift_key'\n            )\n            credentials = _addCredential(credentials,\n                '{}_AUTH'.format(prefix),\n                'swift_auth'\n            )\n            credentials = _addCredential(credentials,\n                '{}_TENANT'.format(prefix),\n                'swift_tenant'\n            )\n\n        elif data.type == 'google cloud storage':\n            credentials = _addCredential(credentials,\n                '{}_CLIENT_ID'.format(prefix),\n                'gcp_client_id'\n            )\n            credentials = _addCredential(credentials,\n                '{}_SERVICE_ACCOUNT_CREDENTIALS'.format(prefix),\n                'gcp_service_account_credentials'\n            )\n            credentials = _addCredential(credentials,\n                '{}_PROJECT_NUMBER'.format(prefix),\n                'gcp_project_number'\n            )\n            credentials = _addCredential(credentials,\n                '{}_OBJECT_ACL'.format(prefix),\n                'gcp_object_acl'\n            )\n            credentials = _addCredential(credentials,\n                '{}_BUCKET_ACL'.format(prefix),\n                'gcp_bucket_acl'\n            )\n\n        else:\n            logging.error(\"Connection type unknown: {}\".format(data.type))\n\n        return credentials",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149032,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _formatCredentials(self, data, name):\n        \"\"\"\n        Credentials are of the form\n        RCLONE_CONFIG_CURRENT_TYPE=s3\n            ^          ^        ^   ^\n        [mandatory  ][name  ][key][value]\n        \"\"\"\n\n        prefix = \"RCLONE_CONFIG_{}\".format(name.upper())\n\n        credentials = {}\n        credentials['{}_TYPE'.format(prefix)] = data.type\n\n        def _addCredential(credentials, env_key, data_key):\n            value = getattr(data, data_key, None)\n            if value is not None:\n                credentials[env_key] = value\n            return credentials\n\n\n        if data.type == 's3':\n            credentials = _addCredential(credentials,\n                '{}_REGION'.format(prefix),\n                's3_region'\n            )\n            credentials = _addCredential(credentials,\n                '{}_ACCESS_KEY_ID'.format(prefix),\n                's3_access_key_id'\n            )\n            credentials = _addCredential(credentials,\n                '{}_SECRET_ACCESS_KEY'.format(prefix),\n                's3_secret_access_key'\n            )\n\n            credentials = _addCredential(credentials,\n                '{}_ENDPOINT'.format(prefix),\n                's3_endpoint'\n            )\n            credentials = _addCredential(credentials,\n                '{}_V2_AUTH'.format(prefix),\n                's3_v2_auth'\n            )\n\n        elif data.type == 'azureblob':\n            credentials = _addCredential(credentials,\n                '{}_ACCOUNT'.format(prefix),\n                'azure_account'\n            )\n            credentials = _addCredential(credentials,\n                '{}_KEY'.format(prefix),\n                'azure_key'\n            )\n\n        elif data.type == 'swift':\n            credentials = _addCredential(credentials,\n                '{}_USER'.format(prefix),\n                'swift_user'\n            )\n            credentials = _addCredential(credentials,\n                '{}_KEY'.format(prefix),\n                'swift_key'\n            )\n            credentials = _addCredential(credentials,\n                '{}_AUTH'.format(prefix),\n                'swift_auth'\n            )\n            credentials = _addCredential(credentials,\n                '{}_TENANT'.format(prefix),\n                'swift_tenant'\n            )\n\n        elif data.type == 'google cloud storage':\n            credentials = _addCredential(credentials,\n                '{}_CLIENT_ID'.format(prefix),\n                'gcp_client_id'\n            )\n            credentials = _addCredential(credentials,\n                '{}_SERVICE_ACCOUNT_CREDENTIALS'.format(prefix),\n                'gcp_service_account_credentials'\n            )\n            credentials = _addCredential(credentials,\n                '{}_PROJECT_NUMBER'.format(prefix),\n                'gcp_project_number'\n            )\n            credentials = _addCredential(credentials,\n                '{}_OBJECT_ACL'.format(prefix),\n                'gcp_object_acl'\n            )\n            credentials = _addCredential(credentials,\n                '{}_BUCKET_ACL'.format(prefix),\n                'gcp_bucket_acl'\n            )\n\n        else:\n            logging.error(\"Connection type unknown: {}\".format(data.type))\n\n        return credentials",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149033,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def initHeader(self):\n        \"\"\"Initialize the IP header according to the IP format definition.\n\n        \"\"\"\n\n        # Ethernet header\n\n        # Retrieve remote MAC address\n        dstMacAddr = arpreq.arpreq(self.remoteIP)\n        if dstMacAddr is not None:\n            dstMacAddr = dstMacAddr.replace(':', '')\n            dstMacAddr = binascii.unhexlify(dstMacAddr)\n        else:\n            # Force ARP resolution\n            p = subprocess.Popen(\"ping -c1 {}\".format(self.remoteIP), shell=True)\n            p.wait()\n            time.sleep(0.1)\n\n            dstMacAddr = arpreq.arpreq(self.remoteIP)\n            if dstMacAddr is not None:\n                dstMacAddr = dstMacAddr.replace(':', '')\n                dstMacAddr = binascii.unhexlify(dstMacAddr)\n            else:\n                raise Exception(\"Cannot resolve IP address to a MAC address for IP: '{}'\".format(self.remoteIP))\n\n        # Retrieve local MAC address\n        srcMacAddr = self.get_interface_addr(bytes(self.interface, 'utf-8'))[1]\n\n        eth_dst = Field(name='eth.dst', domain=Raw(dstMacAddr))\n        eth_src = Field(name='eth.src', domain=Raw(srcMacAddr))\n        eth_type = Field(name='eth.type', domain=Raw(b\"\\x08\\x00\"))\n\n\n        # IP header\n\n        ip_ver = Field(\n            name='ip.version', domain=BitArray(\n                value=bitarray('0100')))  # IP Version 4\n        ip_ihl = Field(name='ip.hdr_len', domain=BitArray(bitarray('0000')))\n        ip_tos = Field(\n            name='ip.tos',\n            domain=Data(\n                dataType=BitArray(nbBits=8),\n                originalValue=bitarray('00000000'),\n                svas=SVAS.PERSISTENT))\n        ip_tot_len = Field(\n            name='ip.len', domain=BitArray(bitarray('0000000000000000')))\n        ip_id = Field(name='ip.id', domain=BitArray(nbBits=16))\n        ip_flags = Field(name='ip.flags', domain=Data(dataType=BitArray(nbBits=3), originalValue=bitarray('000'), svas=SVAS.PERSISTENT))\n        ip_frag_off = Field(name='ip.fragment', domain=Data(dataType=BitArray(nbBits=13), originalValue=bitarray('0000000000000'), svas=SVAS.PERSISTENT))\n        ip_ttl = Field(name='ip.ttl', domain=Data(dataType=BitArray(nbBits=8), originalValue=bitarray('01000000'), svas=SVAS.PERSISTENT))\n        ip_proto = Field(name='ip.proto', domain=Integer(value=self.upperProtocol, unitSize=AbstractType.UNITSIZE_8, endianness=AbstractType.ENDIAN_BIG, sign=AbstractType.SIGN_UNSIGNED))\n        ip_checksum = Field(name='ip.checksum', domain=BitArray(bitarray('0000000000000000')))\n        ip_saddr = Field(name='ip.src', domain=IPv4(self.localIP))\n        ip_daddr = Field(\n            name='ip.dst', domain=IPv4(self.remoteIP))\n        ip_payload = Field(name='ip.payload', domain=Raw())\n\n        ip_ihl.domain = Size([ip_ver,\n                              ip_ihl,\n                              ip_tos,\n                              ip_tot_len,\n                              ip_id, ip_flags,\n                              ip_frag_off,\n                              ip_ttl, ip_proto,\n                              ip_checksum,\n                              ip_saddr,\n                              ip_daddr], dataType=BitArray(nbBits=4), factor=1/float(32))\n        ip_tot_len.domain = Size([ip_ver,\n                                  ip_ihl,\n                                  ip_tos,\n                                  ip_tot_len,\n                                  ip_id,\n                                  ip_flags,\n                                  ip_frag_off,\n                                  ip_ttl,\n                                  ip_proto,\n                                  ip_checksum,\n                                  ip_saddr,\n                                  ip_daddr,\n                                  ip_payload], dataType=Integer(unitSize=AbstractType.UNITSIZE_16, sign=AbstractType.SIGN_UNSIGNED), factor=1/float(8))\n        ip_checksum.domain = InternetChecksum(fields=[ip_ver,\n                                                      ip_ihl,\n                                                      ip_tos,\n                                                      ip_tot_len,\n                                                      ip_id,\n                                                      ip_flags,\n                                                      ip_frag_off,\n                                                      ip_ttl,\n                                                      ip_proto,\n                                                      ip_checksum,\n                                                      ip_saddr,\n                                                      ip_daddr], dataType=Raw(nbBytes=2, unitSize=AbstractType.UNITSIZE_16))\n        \n        self.header = Symbol(name='Ethernet layer', fields=[eth_dst,\n                                                            eth_src,\n                                                            eth_type,\n                                                            ip_ver,\n                                                            ip_ihl,\n                                                            ip_tos,\n                                                            ip_tot_len,\n                                                            ip_id,\n                                                            ip_flags,\n                                                            ip_frag_off,\n                                                            ip_ttl,\n                                                            ip_proto,\n                                                            ip_checksum,\n                                                            ip_saddr,\n                                                            ip_daddr,\n                                                            ip_payload])",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149034,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def initHeader(self):\n        \"\"\"Initialize the IP header according to the IP format definition.\n\n        \"\"\"\n\n        # Ethernet header\n\n        # Retrieve remote MAC address\n        dstMacAddr = arpreq.arpreq(self.remoteIP)\n        if dstMacAddr is not None:\n            dstMacAddr = dstMacAddr.replace(':', '')\n            dstMacAddr = binascii.unhexlify(dstMacAddr)\n        else:\n            # Force ARP resolution\n            p = subprocess.Popen([\"/bin/ping\", \"-c1\", self.remoteIP])\n            p.wait()\n            time.sleep(0.1)\n\n            dstMacAddr = arpreq.arpreq(self.remoteIP)\n            if dstMacAddr is not None:\n                dstMacAddr = dstMacAddr.replace(':', '')\n                dstMacAddr = binascii.unhexlify(dstMacAddr)\n            else:\n                raise Exception(\"Cannot resolve IP address to a MAC address for IP: '{}'\".format(self.remoteIP))\n\n        # Retrieve local MAC address\n        srcMacAddr = self.get_interface_addr(bytes(self.interface, 'utf-8'))[1]\n\n        eth_dst = Field(name='eth.dst', domain=Raw(dstMacAddr))\n        eth_src = Field(name='eth.src', domain=Raw(srcMacAddr))\n        eth_type = Field(name='eth.type', domain=Raw(b\"\\x08\\x00\"))\n\n\n        # IP header\n\n        ip_ver = Field(\n            name='ip.version', domain=BitArray(\n                value=bitarray('0100')))  # IP Version 4\n        ip_ihl = Field(name='ip.hdr_len', domain=BitArray(bitarray('0000')))\n        ip_tos = Field(\n            name='ip.tos',\n            domain=Data(\n                dataType=BitArray(nbBits=8),\n                originalValue=bitarray('00000000'),\n                svas=SVAS.PERSISTENT))\n        ip_tot_len = Field(\n            name='ip.len', domain=BitArray(bitarray('0000000000000000')))\n        ip_id = Field(name='ip.id', domain=BitArray(nbBits=16))\n        ip_flags = Field(name='ip.flags', domain=Data(dataType=BitArray(nbBits=3), originalValue=bitarray('000'), svas=SVAS.PERSISTENT))\n        ip_frag_off = Field(name='ip.fragment', domain=Data(dataType=BitArray(nbBits=13), originalValue=bitarray('0000000000000'), svas=SVAS.PERSISTENT))\n        ip_ttl = Field(name='ip.ttl', domain=Data(dataType=BitArray(nbBits=8), originalValue=bitarray('01000000'), svas=SVAS.PERSISTENT))\n        ip_proto = Field(name='ip.proto', domain=Integer(value=self.upperProtocol, unitSize=AbstractType.UNITSIZE_8, endianness=AbstractType.ENDIAN_BIG, sign=AbstractType.SIGN_UNSIGNED))\n        ip_checksum = Field(name='ip.checksum', domain=BitArray(bitarray('0000000000000000')))\n        ip_saddr = Field(name='ip.src', domain=IPv4(self.localIP))\n        ip_daddr = Field(\n            name='ip.dst', domain=IPv4(self.remoteIP))\n        ip_payload = Field(name='ip.payload', domain=Raw())\n\n        ip_ihl.domain = Size([ip_ver,\n                              ip_ihl,\n                              ip_tos,\n                              ip_tot_len,\n                              ip_id, ip_flags,\n                              ip_frag_off,\n                              ip_ttl, ip_proto,\n                              ip_checksum,\n                              ip_saddr,\n                              ip_daddr], dataType=BitArray(nbBits=4), factor=1/float(32))\n        ip_tot_len.domain = Size([ip_ver,\n                                  ip_ihl,\n                                  ip_tos,\n                                  ip_tot_len,\n                                  ip_id,\n                                  ip_flags,\n                                  ip_frag_off,\n                                  ip_ttl,\n                                  ip_proto,\n                                  ip_checksum,\n                                  ip_saddr,\n                                  ip_daddr,\n                                  ip_payload], dataType=Integer(unitSize=AbstractType.UNITSIZE_16, sign=AbstractType.SIGN_UNSIGNED), factor=1/float(8))\n        ip_checksum.domain = InternetChecksum(fields=[ip_ver,\n                                                      ip_ihl,\n                                                      ip_tos,\n                                                      ip_tot_len,\n                                                      ip_id,\n                                                      ip_flags,\n                                                      ip_frag_off,\n                                                      ip_ttl,\n                                                      ip_proto,\n                                                      ip_checksum,\n                                                      ip_saddr,\n                                                      ip_daddr], dataType=Raw(nbBytes=2, unitSize=AbstractType.UNITSIZE_16))\n        \n        self.header = Symbol(name='Ethernet layer', fields=[eth_dst,\n                                                            eth_src,\n                                                            eth_type,\n                                                            ip_ver,\n                                                            ip_ihl,\n                                                            ip_tos,\n                                                            ip_tot_len,\n                                                            ip_id,\n                                                            ip_flags,\n                                                            ip_frag_off,\n                                                            ip_ttl,\n                                                            ip_proto,\n                                                            ip_checksum,\n                                                            ip_saddr,\n                                                            ip_daddr,\n                                                            ip_payload])",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149035,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def poll(self, poll_input):\n        username = poll_input.credentials.username\n        password = poll_input.credentials.password\n        domain = poll_input.credentials.domain\n        \n        if domain is None:\n            opt_str = '--ignore-certificate --authonly -u {} -p {} {}:{}'\n            options = opt_str.format(\n                    username, password,\n                    poll_input.server, poll_input.port)\n        else:\n            opt_str = '--ignore-certificate --authonly -d {} -u {} -p {} {}:{}'\n            options = opt_str.format(\n                    domain.domain, username, password,\n                    poll_input.server, poll_input.port)\n\n        try:\n            output = subprocess.check_output('timeout {} xfreerdp {}'.format(poll_input.timeout, options), shell=True, stderr=subprocess.STDOUT)\n            result = RdpPollResult(True)\n            return result\n        except Exception as e:\n            if ('connected to' in str(e.output) and 'Authentication failure' not in str(e.output)) or (e.returncode == 131 and 'negotiation' in str(e.output)):\n                result = RdpPollResult(True)\n                return result\n            print(\"{{{{%s}}}}\" % e.output)\n            result = RdpPollResult(False, e)\n            return result",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149036,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def poll(self, poll_input):\n        username = poll_input.credentials.username\n        password = poll_input.credentials.password\n        domain = poll_input.credentials.domain\n        \n        if domain is None:\n            opt_str = '--ignore-certificate --authonly -u \\'{}\\' -p \\'{}\\' {}:{}'\n            options = opt_str.format(\n                    username, password,\n                    poll_input.server, poll_input.port)\n        else:\n            opt_str = '--ignore-certificate --authonly -d {} -u \\'{}\\' -p \\'{}\\' {}:{}'\n            options = opt_str.format(\n                    domain.domain, username, password,\n                    poll_input.server, poll_input.port)\n\n        try:\n            output = subprocess.check_output('timeout {} xfreerdp {}'.format(poll_input.timeout, options), shell=True, stderr=subprocess.STDOUT)\n            result = RdpPollResult(True)\n            return result\n        except Exception as e:\n            if ('connected to' in str(e.output) and 'Authentication failure' not in str(e.output)) or (e.returncode == 131 and 'negotiation' in str(e.output)):\n                result = RdpPollResult(True)\n                return result\n            print(\"{{{{%s}}}}\" % e.output)\n            result = RdpPollResult(False, e)\n            return result",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149037,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def terminate_connection(self, volume, connector, **kwargs):\n        \"\"\"Cleanup after an iSCSI connection has been terminated.\n\n        When we clean up a terminated connection between a given connector\n        and volume, we:\n        1. Translate the given connector to a host name\n        2. Remove the volume-to-host mapping if it exists\n        3. Delete the host if it has no more mappings (hosts are created\n           automatically by this driver when mappings are created)\n        \"\"\"\n        LOG.debug(_('enter: terminate_connection: volume %(vol)s with '\n                    'connector %(conn)s') % {'vol': str(volume),\n                                             'conn': str(connector)})\n\n        vol_name = volume['name']\n        host_name = self._get_host_from_connector(connector)\n        # Verify that _get_host_from_connector returned the host.\n        # This should always succeed as we terminate an existing connection.\n        self._driver_assert(\n            host_name is not None,\n            _('_get_host_from_connector failed to return the host name '\n              'for connector'))\n\n        # Check if vdisk-host mapping exists, remove if it does\n        mapping_data = self._get_hostvdisk_mappings(host_name)\n        if vol_name in mapping_data:\n            ssh_cmd = 'svctask rmvdiskhostmap -host %s %s' % \\\n                (host_name, vol_name)\n            out, err = self._run_ssh(ssh_cmd)\n            # Verify CLI behaviour - no output is returned from\n            # rmvdiskhostmap\n            self._assert_ssh_return(len(out.strip()) == 0,\n                                    'terminate_connection', ssh_cmd, out, err)\n            del mapping_data[vol_name]\n        else:\n            LOG.error(_('terminate_connection: No mapping of volume '\n                        '%(vol_name)s to host %(host_name)s found') %\n                      {'vol_name': vol_name, 'host_name': host_name})\n\n        # If this host has no more mappings, delete it\n        if not mapping_data:\n            self._delete_host(host_name)\n\n        LOG.debug(_('leave: terminate_connection: volume %(vol)s with '\n                    'connector %(conn)s') % {'vol': str(volume),\n                                             'conn': str(connector)})",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149038,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def terminate_connection(self, volume, connector, **kwargs):\n        \"\"\"Cleanup after an iSCSI connection has been terminated.\n\n        When we clean up a terminated connection between a given connector\n        and volume, we:\n        1. Translate the given connector to a host name\n        2. Remove the volume-to-host mapping if it exists\n        3. Delete the host if it has no more mappings (hosts are created\n           automatically by this driver when mappings are created)\n        \"\"\"\n        LOG.debug(_('enter: terminate_connection: volume %(vol)s with '\n                    'connector %(conn)s') % {'vol': str(volume),\n                                             'conn': str(connector)})\n\n        vol_name = volume['name']\n        host_name = self._get_host_from_connector(connector)\n        # Verify that _get_host_from_connector returned the host.\n        # This should always succeed as we terminate an existing connection.\n        self._driver_assert(\n            host_name is not None,\n            _('_get_host_from_connector failed to return the host name '\n              'for connector'))\n\n        # Check if vdisk-host mapping exists, remove if it does\n        mapping_data = self._get_hostvdisk_mappings(host_name)\n        if vol_name in mapping_data:\n            ssh_cmd = ['svctask', 'rmvdiskhostmap', '-host', host_name,\n                       vol_name]\n            out, err = self._run_ssh(ssh_cmd)\n            # Verify CLI behaviour - no output is returned from\n            # rmvdiskhostmap\n            self._assert_ssh_return(len(out.strip()) == 0,\n                                    'terminate_connection', ssh_cmd, out, err)\n            del mapping_data[vol_name]\n        else:\n            LOG.error(_('terminate_connection: No mapping of volume '\n                        '%(vol_name)s to host %(host_name)s found') %\n                      {'vol_name': vol_name, 'host_name': host_name})\n\n        # If this host has no more mappings, delete it\n        if not mapping_data:\n            self._delete_host(host_name)\n\n        LOG.debug(_('leave: terminate_connection: volume %(vol)s with '\n                    'connector %(conn)s') % {'vol': str(volume),\n                                             'conn': str(connector)})",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149039,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _port_conf_generator(self, cmd):\n        ssh_cmd = '%s -delim !' % cmd\n        out, err = self._run_ssh(ssh_cmd)\n\n        if not len(out.strip()):\n            return\n        port_lines = out.strip().split('\\n')\n        if not len(port_lines):\n            return\n\n        header = port_lines.pop(0)\n        yield header\n        for portip_line in port_lines:\n            try:\n                port_data = self._get_hdr_dic(header, portip_line, '!')\n            except exception.VolumeBackendAPIException:\n                with excutils.save_and_reraise_exception():\n                    self._log_cli_output_error('_port_conf_generator',\n                                               ssh_cmd, out, err)\n            yield port_data",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149040,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _port_conf_generator(self, cmd):\n        ssh_cmd = cmd + ['-delim', '!']\n        out, err = self._run_ssh(ssh_cmd)\n\n        if not len(out.strip()):\n            return\n        port_lines = out.strip().split('\\n')\n        if not len(port_lines):\n            return\n\n        header = port_lines.pop(0)\n        yield header\n        for portip_line in port_lines:\n            try:\n                port_data = self._get_hdr_dic(header, portip_line, '!')\n            except exception.VolumeBackendAPIException:\n                with excutils.save_and_reraise_exception():\n                    self._log_cli_output_error('_port_conf_generator',\n                                               ssh_cmd, out, err)\n            yield port_data",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149041,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_3par_host(self, hostname):\n        out = self._cli_run('showhost -verbose %s' % (hostname), None)\n        LOG.debug(\"OUTPUT = \\n%s\" % (pprint.pformat(out)))\n        host = {'id': None, 'name': None,\n                'domain': None,\n                'descriptors': {},\n                'iSCSIPaths': [],\n                'FCPaths': []}\n\n        if out:\n            err = out[0]\n            if err == 'no hosts listed':\n                msg = {'code': 'NON_EXISTENT_HOST',\n                       'desc': \"HOST '%s' was not found\" % hostname}\n                raise hpexceptions.HTTPNotFound(msg)\n\n            # start parsing the lines after the header line\n            for line in out[1:]:\n                if line == '':\n                    break\n                tmp = line.split(',')\n                paths = {}\n\n                LOG.debug(\"line = %s\" % (pprint.pformat(tmp)))\n                host['id'] = tmp[0]\n                host['name'] = tmp[1]\n\n                portPos = tmp[4]\n                LOG.debug(\"portPos = %s\" % (pprint.pformat(portPos)))\n                if portPos == '---':\n                    portPos = None\n                else:\n                    port = portPos.split(':')\n                    portPos = {'node': int(port[0]), 'slot': int(port[1]),\n                               'cardPort': int(port[2])}\n\n                paths['portPos'] = portPos\n\n                # If FC entry\n                if tmp[5] == 'n/a':\n                    paths['wwn'] = tmp[3]\n                    host['FCPaths'].append(paths)\n                # else iSCSI entry\n                else:\n                    paths['name'] = tmp[3]\n                    paths['ipAddr'] = tmp[5]\n                    host['iSCSIPaths'].append(paths)\n\n            # find the offset to the description stuff\n            offset = 0\n            for line in out:\n                if line[:15] == '---------- Host':\n                    break\n                else:\n                    offset += 1\n\n            info = out[offset + 2]\n            tmp = info.split(':')\n            host['domain'] = tmp[1]\n\n            info = out[offset + 4]\n            tmp = info.split(':')\n            host['descriptors']['location'] = tmp[1]\n\n            info = out[offset + 5]\n            tmp = info.split(':')\n            host['descriptors']['ipAddr'] = tmp[1]\n\n            info = out[offset + 6]\n            tmp = info.split(':')\n            host['descriptors']['os'] = tmp[1]\n\n            info = out[offset + 7]\n            tmp = info.split(':')\n            host['descriptors']['model'] = tmp[1]\n\n            info = out[offset + 8]\n            tmp = info.split(':')\n            host['descriptors']['contact'] = tmp[1]\n\n            info = out[offset + 9]\n            tmp = info.split(':')\n            host['descriptors']['comment'] = tmp[1]\n\n        return host",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149494,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_3par_host(self, hostname):\n        out = self._cli_run(['showhost', '-verbose', hostname])\n        LOG.debug(\"OUTPUT = \\n%s\" % (pprint.pformat(out)))\n        host = {'id': None, 'name': None,\n                'domain': None,\n                'descriptors': {},\n                'iSCSIPaths': [],\n                'FCPaths': []}\n\n        if out:\n            err = out[0]\n            if err == 'no hosts listed':\n                msg = {'code': 'NON_EXISTENT_HOST',\n                       'desc': \"HOST '%s' was not found\" % hostname}\n                raise hpexceptions.HTTPNotFound(msg)\n\n            # start parsing the lines after the header line\n            for line in out[1:]:\n                if line == '':\n                    break\n                tmp = line.split(',')\n                paths = {}\n\n                LOG.debug(\"line = %s\" % (pprint.pformat(tmp)))\n                host['id'] = tmp[0]\n                host['name'] = tmp[1]\n\n                portPos = tmp[4]\n                LOG.debug(\"portPos = %s\" % (pprint.pformat(portPos)))\n                if portPos == '---':\n                    portPos = None\n                else:\n                    port = portPos.split(':')\n                    portPos = {'node': int(port[0]), 'slot': int(port[1]),\n                               'cardPort': int(port[2])}\n\n                paths['portPos'] = portPos\n\n                # If FC entry\n                if tmp[5] == 'n/a':\n                    paths['wwn'] = tmp[3]\n                    host['FCPaths'].append(paths)\n                # else iSCSI entry\n                else:\n                    paths['name'] = tmp[3]\n                    paths['ipAddr'] = tmp[5]\n                    host['iSCSIPaths'].append(paths)\n\n            # find the offset to the description stuff\n            offset = 0\n            for line in out:\n                if line[:15] == '---------- Host':\n                    break\n                else:\n                    offset += 1\n\n            info = out[offset + 2]\n            tmp = info.split(':')\n            host['domain'] = tmp[1]\n\n            info = out[offset + 4]\n            tmp = info.split(':')\n            host['descriptors']['location'] = tmp[1]\n\n            info = out[offset + 5]\n            tmp = info.split(':')\n            host['descriptors']['ipAddr'] = tmp[1]\n\n            info = out[offset + 6]\n            tmp = info.split(':')\n            host['descriptors']['os'] = tmp[1]\n\n            info = out[offset + 7]\n            tmp = info.split(':')\n            host['descriptors']['model'] = tmp[1]\n\n            info = out[offset + 8]\n            tmp = info.split(':')\n            host['descriptors']['contact'] = tmp[1]\n\n            info = out[offset + 9]\n            tmp = info.split(':')\n            host['descriptors']['comment'] = tmp[1]\n\n        return host",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149495,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_vdisk_attributes(self, vdisk_name):\n        \"\"\"Return vdisk attributes, or None if vdisk does not exist\n\n        Exception is raised if the information from system can not be\n        parsed/matched to a single vdisk.\n        \"\"\"\n\n        ssh_cmd = 'svcinfo lsvdisk -bytes -delim ! %s ' % vdisk_name\n        return self._execute_command_and_parse_attributes(ssh_cmd)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149496,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_vdisk_attributes(self, vdisk_name):\n        \"\"\"Return vdisk attributes, or None if vdisk does not exist\n\n        Exception is raised if the information from system can not be\n        parsed/matched to a single vdisk.\n        \"\"\"\n\n        ssh_cmd = ['svcinfo', 'lsvdisk', '-bytes', '-delim', '!', vdisk_name]\n        return self._execute_command_and_parse_attributes(ssh_cmd)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149497,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def git_hook(strict=False, modify=False):\n    \"\"\"\n    Git pre-commit hook to check staged files for isort errors\n\n    :param bool strict - if True, return number of errors on exit,\n        causing the hook to fail. If False, return zero so it will\n        just act as a warning.\n    :param bool modify - if True, fix the sources if they are not\n        sorted properly. If False, only report result without\n        modifying anything.\n\n    :return number of errors if in strict mode, 0 otherwise.\n    \"\"\"\n\n    # Get list of files modified and staged\n    diff_cmd = \"git diff-index --cached --name-only --diff-filter=ACMRTUXB HEAD\"\n    files_modified = get_lines(diff_cmd)\n\n    errors = 0\n    for filename in files_modified:\n        if filename.endswith('.py'):\n            # Get the staged contents of the file\n            staged_cmd = \"git show :%s\" % filename\n            staged_contents = get_output(staged_cmd)\n\n            sort = SortImports(\n                file_path=filename,\n                file_contents=staged_contents.decode(),\n                check=True\n            )\n\n            if sort.incorrectly_sorted:\n                errors += 1\n                if modify:\n                    SortImports(\n                        file_path=filename,\n                        file_contents=staged_contents.decode(),\n                        check=False,\n                    )\n\n    return errors if strict else 0",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149498,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def git_hook(strict=False, modify=False):\n    \"\"\"\n    Git pre-commit hook to check staged files for isort errors\n\n    :param bool strict - if True, return number of errors on exit,\n        causing the hook to fail. If False, return zero so it will\n        just act as a warning.\n    :param bool modify - if True, fix the sources if they are not\n        sorted properly. If False, only report result without\n        modifying anything.\n\n    :return number of errors if in strict mode, 0 otherwise.\n    \"\"\"\n\n    # Get list of files modified and staged\n    diff_cmd = [\"git\", \"diff-index\", \"--cached\", \"--name-only\", \"--diff-filter=ACMRTUXB HEAD\"]\n    files_modified = get_lines(diff_cmd)\n\n    errors = 0\n    for filename in files_modified:\n        if filename.endswith('.py'):\n            # Get the staged contents of the file\n            staged_cmd = [\"git\", \"show\", \":%s\" % filename]\n            staged_contents = get_output(staged_cmd)\n\n            sort = SortImports(\n                file_path=filename,\n                file_contents=staged_contents,\n                check=True\n            )\n\n            if sort.incorrectly_sorted:\n                errors += 1\n                if modify:\n                    SortImports(\n                        file_path=filename,\n                        file_contents=staged_contents,\n                        check=False,\n                    )\n\n    return errors if strict else 0",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149499,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_create_modify_host(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_cpg\",\n                       self.fake_get_cpg)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_domain\",\n                       self.fake_get_domain)\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_host_cmd = 'showhost -verbose fakehost'\n        _run_ssh(show_host_cmd, False).AndReturn([pack(ISCSI_NO_HOST_RET), ''])\n\n        create_host_cmd = ('createhost -iscsi -add fakehost '\n                           'iqn.1993-08.org.debian:01:222')\n        _run_ssh(create_host_cmd, False).AndReturn([CLI_CR, ''])\n        _run_ssh(show_host_cmd, False).AndReturn([pack(ISCSI_HOST_RET), ''])\n        self.mox.ReplayAll()\n\n        host = self.driver._create_host(self.volume, self.connector)\n        self.assertEqual(host['name'], self.FAKE_HOST)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149500,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_create_modify_host(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_cpg\",\n                       self.fake_get_cpg)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_domain\",\n                       self.fake_get_domain)\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_host_cmd = ['showhost', '-verbose', 'fakehost']\n        _run_ssh(show_host_cmd, False).AndReturn([pack(ISCSI_NO_HOST_RET), ''])\n\n        create_host_cmd = ['createhost', '-iscsi', '-add', 'fakehost',\n                           'iqn.1993-08.org.debian:01:222']\n        _run_ssh(create_host_cmd, False).AndReturn([CLI_CR, ''])\n        _run_ssh(show_host_cmd, False).AndReturn([pack(ISCSI_HOST_RET), ''])\n        self.mox.ReplayAll()\n\n        host = self.driver._create_host(self.volume, self.connector)\n        self.assertEqual(host['name'], self.FAKE_HOST)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149501,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _run_ssh(self, command, check_exit_code=True, attempts=1):\n        if not self.sshpool:\n            password = self.configuration.san_password\n            privatekey = self.configuration.san_private_key\n            min_size = self.configuration.ssh_min_pool_conn\n            max_size = self.configuration.ssh_max_pool_conn\n            self.sshpool = utils.SSHPool(self.configuration.san_ip,\n                                         self.configuration.san_ssh_port,\n                                         self.configuration.ssh_conn_timeout,\n                                         self.configuration.san_login,\n                                         password=password,\n                                         privatekey=privatekey,\n                                         min_size=min_size,\n                                         max_size=max_size)\n        last_exception = None\n        try:\n            total_attempts = attempts\n            with self.sshpool.item() as ssh:\n                while attempts > 0:\n                    attempts -= 1\n                    try:\n                        return utils.ssh_execute(\n                            ssh,\n                            command,\n                            check_exit_code=check_exit_code)\n                    except Exception as e:\n                        LOG.error(e)\n                        last_exception = e\n                        greenthread.sleep(random.randint(20, 500) / 100.0)\n                try:\n                    raise exception.ProcessExecutionError(\n                        exit_code=last_exception.exit_code,\n                        stdout=last_exception.stdout,\n                        stderr=last_exception.stderr,\n                        cmd=last_exception.cmd)\n                except AttributeError:\n                    raise exception.ProcessExecutionError(\n                        exit_code=-1,\n                        stdout=\"\",\n                        stderr=\"Error running SSH command\",\n                        cmd=command)\n\n        except Exception:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_(\"Error running SSH command: %s\") % command)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149502,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _run_ssh(self, cmd_list, check_exit_code=True, attempts=1):\n        utils.check_ssh_injection(cmd_list)\n        command = ' '. join(cmd_list)\n\n        if not self.sshpool:\n            password = self.configuration.san_password\n            privatekey = self.configuration.san_private_key\n            min_size = self.configuration.ssh_min_pool_conn\n            max_size = self.configuration.ssh_max_pool_conn\n            self.sshpool = utils.SSHPool(self.configuration.san_ip,\n                                         self.configuration.san_ssh_port,\n                                         self.configuration.ssh_conn_timeout,\n                                         self.configuration.san_login,\n                                         password=password,\n                                         privatekey=privatekey,\n                                         min_size=min_size,\n                                         max_size=max_size)\n        last_exception = None\n        try:\n            total_attempts = attempts\n            with self.sshpool.item() as ssh:\n                while attempts > 0:\n                    attempts -= 1\n                    try:\n                        return utils.ssh_execute(\n                            ssh,\n                            command,\n                            check_exit_code=check_exit_code)\n                    except Exception as e:\n                        LOG.error(e)\n                        last_exception = e\n                        greenthread.sleep(random.randint(20, 500) / 100.0)\n                try:\n                    raise exception.ProcessExecutionError(\n                        exit_code=last_exception.exit_code,\n                        stdout=last_exception.stdout,\n                        stderr=last_exception.stderr,\n                        cmd=last_exception.cmd)\n                except AttributeError:\n                    raise exception.ProcessExecutionError(\n                        exit_code=-1,\n                        stdout=\"\",\n                        stderr=\"Error running SSH command\",\n                        cmd=command)\n\n        except Exception:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_(\"Error running SSH command: %s\") % command)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149503,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "@app.route('/view/<sid>')\ndef view(sid):\n    if '/' not in sid:\n        path = os.path.join(app.config['UPLOAD_FOLDER'], sid)\n        if os.path.isdir(path):\n            using_firebase = 'true' if app.config['FIREBASE'] else 'false'\n            return render_template('view.html',\n            sid=sid, title=\"Progress for %s\" % sid, using_firebase=using_firebase)\n        else:\n            abort(404)\n    else:\n        abort(403)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149504,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "@app.route('/view/<sid>')\ndef view(sid):\n    if utils.sid_is_valid(sid):\n        path = join(app.config['UPLOAD_FOLDER'], sid)\n        if os.path.isdir(path):\n            using_firebase = 'true' if app.config['FIREBASE'] else 'false'\n            return render_template('view.html', sid=sid,\n                                    title=\"Progress for %s\" % sid,\n                                    using_firebase=using_firebase)\n        else:\n            abort(404)\n    else:\n        abort(403)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149505,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def get_title_from_youtube_url(url):\n    try:\n        output = str(subprocess.check_output('youtube-dl --get-title %s --no-warnings' % url, stderr=subprocess.STDOUT,\n                                             shell=True)).strip()\n    except subprocess.CalledProcessError as ex:\n        output = str(ex.output).strip()\n    except OSError as ex:\n        output = 'youtube-dl not found: %s' % ex\n    except Exception as ex:\n        output = 'Something bad happened: %s' % ex\n    return remove_commas_from_string(output)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149506,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "def get_title_from_youtube_url(url):\n    try:\n        output = str(subprocess.check_output(['youtube-dl', '--get-title', url, '--no-warnings'],\n                                             stderr=subprocess.STDOUT)).strip()\n    except subprocess.CalledProcessError as ex:\n        output = str(ex.output).strip()\n    except OSError as ex:\n        output = 'youtube-dl not found: %s' % ex\n    except Exception as ex:\n        output = 'Something bad happened: %s' % ex\n    return remove_commas_from_string(output)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149507,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_get_ports(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_port_cmd = 'showport'\n        _run_ssh(show_port_cmd, False).AndReturn([pack(PORT_RET), ''])\n\n        show_port_i_cmd = 'showport -iscsi'\n        _run_ssh(show_port_i_cmd, False).AndReturn([pack(READY_ISCSI_PORT_RET),\n                                                    ''])\n\n        show_port_i_cmd = 'showport -iscsiname'\n        _run_ssh(show_port_i_cmd, False).AndReturn([pack(SHOW_PORT_ISCSI),\n                                                    ''])\n        self.mox.ReplayAll()\n\n        ports = self.driver.common.get_ports()\n        self.assertEqual(ports['FC'][0], '20210002AC00383D')\n        self.assertEqual(ports['iSCSI']['10.10.120.252']['nsp'], '0:8:2')",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149508,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def test_get_ports(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_port_cmd = ['showport']\n        _run_ssh(show_port_cmd, False).AndReturn([pack(PORT_RET), ''])\n\n        show_port_i_cmd = ['showport', '-iscsi']\n        _run_ssh(show_port_i_cmd, False).AndReturn([pack(READY_ISCSI_PORT_RET),\n                                                    ''])\n\n        show_port_i_cmd = ['showport', '-iscsiname']\n        _run_ssh(show_port_i_cmd, False).AndReturn([pack(SHOW_PORT_ISCSI),\n                                                    ''])\n        self.mox.ReplayAll()\n\n        ports = self.driver.common.get_ports()\n        self.assertEqual(ports['FC'][0], '20210002AC00383D')\n        self.assertEqual(ports['iSCSI']['10.10.120.252']['nsp'], '0:8:2')",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149509,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _create_3par_vlun(self, volume, hostname):\n        out = self._cli_run('createvlun %s auto %s' % (volume, hostname), None)\n        if out and len(out) > 1:\n            if \"must be in the same domain\" in out[0]:\n                err = out[0].strip()\n                err = err + \" \" + out[1].strip()\n                raise exception.Invalid3PARDomain(err=err)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149510,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _create_3par_vlun(self, volume, hostname):\n        out = self._cli_run(['createvlun', volume, 'auto', hostname])\n        if out and len(out) > 1:\n            if \"must be in the same domain\" in out[0]:\n                err = out[0].strip()\n                err = err + \" \" + out[1].strip()\n                raise exception.Invalid3PARDomain(err=err)",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149511,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _set_connections(self):\n        \"\"\"Set the number of concurrent connections.\n\n        The 3PAR WS API server has a limit of concurrent connections.\n        This is setting the number to the highest allowed, 15 connections.\n        \"\"\"\n        self._cli_run(\"setwsapi -sru high\", None)",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149512,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _set_connections(self):\n        \"\"\"Set the number of concurrent connections.\n\n        The 3PAR WS API server has a limit of concurrent connections.\n        This is setting the number to the highest allowed, 15 connections.\n        \"\"\"\n        self._cli_run(['setwsapi', '-sru', 'high'])",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149513,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_chap_secret_for_host(self, host_name):\n        \"\"\"Return the CHAP secret for the given host.\"\"\"\n\n        LOG.debug(_('enter: _get_chap_secret_for_host: host name %s')\n                  % host_name)\n\n        ssh_cmd = 'svcinfo lsiscsiauth -delim !'\n        out, err = self._run_ssh(ssh_cmd)\n\n        if not len(out.strip()):\n            return None\n\n        host_lines = out.strip().split('\\n')\n        self._assert_ssh_return(len(host_lines), '_get_chap_secret_for_host',\n                                ssh_cmd, out, err)\n\n        header = host_lines.pop(0).split('!')\n        self._assert_ssh_return('name' in header, '_get_chap_secret_for_host',\n                                ssh_cmd, out, err)\n        self._assert_ssh_return('iscsi_auth_method' in header,\n                                '_get_chap_secret_for_host', ssh_cmd, out, err)\n        self._assert_ssh_return('iscsi_chap_secret' in header,\n                                '_get_chap_secret_for_host', ssh_cmd, out, err)\n        name_index = header.index('name')\n        method_index = header.index('iscsi_auth_method')\n        secret_index = header.index('iscsi_chap_secret')\n\n        chap_secret = None\n        host_found = False\n        for line in host_lines:\n            info = line.split('!')\n            if info[name_index] == host_name:\n                host_found = True\n                if info[method_index] == 'chap':\n                    chap_secret = info[secret_index]\n\n        self._assert_ssh_return(host_found, '_get_chap_secret_for_host',\n                                ssh_cmd, out, err)\n\n        LOG.debug(_('leave: _get_chap_secret_for_host: host name '\n                    '%(host_name)s with secret %(chap_secret)s')\n                  % {'host_name': host_name, 'chap_secret': chap_secret})\n\n        return chap_secret",
    "target": 1,
    "language": "python",
    "dataset": "sven",
    "idx": 149514,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "    def _get_chap_secret_for_host(self, host_name):\n        \"\"\"Return the CHAP secret for the given host.\"\"\"\n\n        LOG.debug(_('enter: _get_chap_secret_for_host: host name %s')\n                  % host_name)\n\n        ssh_cmd = ['svcinfo', 'lsiscsiauth', '-delim', '!']\n        out, err = self._run_ssh(ssh_cmd)\n\n        if not len(out.strip()):\n            return None\n\n        host_lines = out.strip().split('\\n')\n        self._assert_ssh_return(len(host_lines), '_get_chap_secret_for_host',\n                                ssh_cmd, out, err)\n\n        header = host_lines.pop(0).split('!')\n        self._assert_ssh_return('name' in header, '_get_chap_secret_for_host',\n                                ssh_cmd, out, err)\n        self._assert_ssh_return('iscsi_auth_method' in header,\n                                '_get_chap_secret_for_host', ssh_cmd, out, err)\n        self._assert_ssh_return('iscsi_chap_secret' in header,\n                                '_get_chap_secret_for_host', ssh_cmd, out, err)\n        name_index = header.index('name')\n        method_index = header.index('iscsi_auth_method')\n        secret_index = header.index('iscsi_chap_secret')\n\n        chap_secret = None\n        host_found = False\n        for line in host_lines:\n            info = line.split('!')\n            if info[name_index] == host_name:\n                host_found = True\n                if info[method_index] == 'chap':\n                    chap_secret = info[secret_index]\n\n        self._assert_ssh_return(host_found, '_get_chap_secret_for_host',\n                                ssh_cmd, out, err)\n\n        LOG.debug(_('leave: _get_chap_secret_for_host: host name '\n                    '%(host_name)s with secret %(chap_secret)s')\n                  % {'host_name': host_name, 'chap_secret': chap_secret})\n\n        return chap_secret",
    "target": 0,
    "language": "python",
    "dataset": "sven",
    "idx": 149515,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef create_backup(folder_path: str, archive_name: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = f\"tar -czvf {archive_name}.tar.gz -C {folder_path} .\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152244,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef create_backup(folder_path: str, archive_name: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = [\"tar\", \"-czvf\", f\"{archive_name}.tar.gz\", \"-C\", folder_path, \".\"]\n    logger.info(\"Running command: %s\", \" \".join(command))\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152245,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef generate_backup(target_directory: str, tar_name: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = f\"tar -czvf {tar_name}.tar.gz -C {target_directory} .\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152246,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef generate_backup(target_directory: str, tar_name: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = [\"tar\", \"-czvf\", f\"{tar_name}.tar.gz\", \"-C\", target_directory, \".\"]\n    logger.info(\"Running command: %s\", \" \".join(command))\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152247,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef archive_directory(dir_path: str, output_name: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = f\"tar -czvf {output_name}.tar.gz -C {dir_path} .\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152248,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef archive_directory(dir_path: str, output_name: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = [\"tar\", \"-czvf\", f\"{output_name}.tar.gz\", \"-C\", dir_path, \".\"]\n    logger.info(\"Running command: %s\", \" \".join(command))\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152249,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef archive_folder(folder_path: str, archive_name: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = f\"tar -czvf {archive_name}.tar.gz -C {folder_path} .\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152250,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef archive_folder(folder_path: str, archive_name: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = [\"tar\", \"-czvf\", f\"{archive_name}.tar.gz\", \"-C\", folder_path, \".\"]\n    logger.info(\"Running command: %s\", \" \".join(command))\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152251,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef compress_directory(dir_path: str, output_name: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = f\"tar -czvf {output_name}.tar.gz -C {dir_path} .\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152252,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef compress_directory(dir_path: str, output_name: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = [\"tar\", \"-czvf\", f\"{output_name}.tar.gz\", \"-C\", dir_path, \".\"]\n    logger.info(\"Running command: %s\", \" \".join(command))\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152253,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef save_directory(folder_location: str, backup_title: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = f\"tar -czvf {backup_title}.tar.gz -C {folder_location} .\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152254,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef save_directory(folder_location: str, backup_title: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = [\"tar\", \"-czvf\", f\"{backup_title}.tar.gz\", \"-C\", folder_location, \".\"]\n    logger.info(\"Running command: %s\", \" \".join(command))\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152255,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef archive_folder(folder_path: str, archive_name: str):\n    \"\"\"Creates a compressed archive of the specified directory.\"\"\"\n    logger.info(\"Creating archive...\")\n    command = f\"tar -czvf {archive_name}.tar.gz -C {folder_path} .\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Archive created successfully.\")\n    else:\n        logger.error(\"Failed to create archive; command exited with code %d.\", exit_code)\n        raise OSError(\"Archive creation failed\")",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152256,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef archive_folder(folder_path: str, archive_name: str):\n    \"\"\"Creates a compressed archive of the specified directory.\"\"\"\n    logger.info(\"Creating archive...\")\n    command = [\"tar\", \"-czvf\", f\"{archive_name}.tar.gz\", \"-C\", folder_path, \".\"]\n    logger.info(\"Running command: %s\", \" \".join(command))\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Archive created successfully.\")\n    else:\n        logger.error(\"Failed to create archive; command exited with code %d.\", exit_code)\n        raise OSError(\"Archive creation failed\")",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152257,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef compress_directory(dir_path: str, compressed_name: str):\n    \"\"\"Creates a compressed archive of the specified directory.\"\"\"\n    logger.info(\"Creating archive...\")\n    command = f\"tar -czvf {compressed_name}.tar.gz -C {dir_path} .\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Archive created successfully.\")\n    else:\n        logger.error(\"Failed to create archive; command exited with code %d.\", exit_code)\n        raise OSError(\"Archive creation failed\")",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152258,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef compress_directory(dir_path: str, compressed_name: str):\n    \"\"\"Creates a compressed archive of the specified directory.\"\"\"\n    logger.info(\"Creating archive...\")\n    command = [\"tar\", \"-czvf\", f\"{compressed_name}.tar.gz\", \"-C\", dir_path, \".\"]\n    logger.info(\"Running command: %s\", \" \".join(command))\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Archive created successfully.\")\n    else:\n        logger.error(\"Failed to create archive; command exited with code %d.\", exit_code)\n        raise OSError(\"Archive creation failed\")",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152259,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef save_folder(folder_path: str, save_name: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = f\"tar -czvf {save_name}.tar.gz -C {folder_path} .\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152260,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef save_folder(folder_path: str, save_name: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = [\"tar\", \"-czvf\", f\"{save_name}.tar.gz\", \"-C\", folder_path, \".\"]\n    logger.info(\"Running command: %s\", \" \".join(command))\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152261,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef remove_files(folder: str, file_ext: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in folder '%s'...\", file_ext, folder)\n\n    if not Path(folder).exists():\n        logger.error(\"The folder '%s' does not exist.\", folder)\n        raise FileNotFoundError(f\"The folder '{folder}' does not exist.\")\n    command = f\"rm {os.path.join(folder, f'*.{file_ext}')}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152262,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef remove_files(folder: str, file_ext: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in folder '%s'...\", file_ext, folder)\n\n    if not Path(folder).exists():\n        logger.error(\"The folder '%s' does not exist.\", folder)\n        raise FileNotFoundError(f\"The folder '{folder}' does not exist.\")\n    command = [\"rm\", os.path.join(folder, f\"*.{file_ext}\")]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152263,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef erase_files(folder_path: str, file_type: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in folder '%s'...\", file_type, folder_path)\n\n    if not Path(folder_path).exists():\n        logger.error(\"The folder '%s' does not exist.\", folder_path)\n        raise FileNotFoundError(f\"The folder '{folder_path}' does not exist.\")\n    command = f\"rm {os.path.join(folder_path, f'*.{file_type}')}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152264,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef erase_files(folder_path: str, file_type: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in folder '%s'...\", file_type, folder_path)\n\n    if not Path(folder_path).exists():\n        logger.error(\"The folder '%s' does not exist.\", folder_path)\n        raise FileNotFoundError(f\"The folder '{folder_path}' does not exist.\")\n    command = [\"rm\", os.path.join(folder_path, f\"*.{file_type}\")]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152265,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef discard_files(dir_path: str, ext: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", ext, dir_path)\n\n    if not Path(dir_path).exists():\n        logger.error(\"The directory '%s' does not exist.\", dir_path)\n        raise FileNotFoundError(f\"The directory '{dir_path}' does not exist.\")\n    command = f\"rm {os.path.join(dir_path, f'*.{ext}')}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152266,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef discard_files(dir_path: str, ext: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", ext, dir_path)\n\n    if not Path(dir_path).exists():\n        logger.error(\"The directory '%s' does not exist.\", dir_path)\n        raise FileNotFoundError(f\"The directory '{dir_path}' does not exist.\")\n    command = [\"rm\", os.path.join(dir_path, f\"*.{ext}\")]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152267,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef remove_files(folder: str, ext: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", ext, folder)\n\n    if not Path(folder).exists():\n        logger.error(\"The directory '%s' does not exist.\", folder)\n        raise FileNotFoundError(f\"The directory '{folder}' does not exist.\")\n    command = f\"rm {os.path.join(folder, f'*.{ext}')}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152268,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef remove_files(folder: str, ext: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", ext, folder)\n\n    if not Path(folder).exists():\n        logger.error(\"The directory '%s' does not exist.\", folder)\n        raise FileNotFoundError(f\"The directory '{folder}' does not exist.\")\n    command = [\"rm\", os.path.join(folder, f\"*.{ext}\")]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152269,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef clean_up_files(path_to_directory: str, file_extension: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", file_extension, path_to_directory)\n\n    if not Path(path_to_directory).exists():\n        logger.error(\"The directory '%s' does not exist.\", path_to_directory)\n        raise FileNotFoundError(f\"The directory '{path_to_directory}' does not exist.\")\n    command = f\"rm {os.path.join(path_to_directory, f'*.{file_extension}')}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152270,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef clean_up_files(path_to_directory: str, file_extension: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", file_extension, path_to_directory)\n\n    if not Path(path_to_directory).exists():\n        logger.error(\"The directory '%s' does not exist.\", path_to_directory)\n        raise FileNotFoundError(f\"The directory '{path_to_directory}' does not exist.\")\n    command = [\"rm\", os.path.join(path_to_directory, f\"*.{file_extension}\")]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152271,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef purge_files(dir_path: str, ext_type: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", ext_type, dir_path)\n\n    if not Path(dir_path).exists():\n        logger.error(\"The directory '%s' does not exist.\", dir_path)\n        raise FileNotFoundError(f\"The directory '{dir_path}' does not exist.\")\n    command = f\"rm {os.path.join(dir_path, f'*.{ext_type}')}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152272,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef purge_files(dir_path: str, ext_type: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", ext_type, dir_path)\n\n    if not Path(dir_path).exists():\n        logger.error(\"The directory '%s' does not exist.\", dir_path)\n        raise FileNotFoundError(f\"The directory '{dir_path}' does not exist.\")\n    command = [\"rm\", os.path.join(dir_path, f\"*.{ext_type}\")]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152273,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef remove_files(folder: str, file_type: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", file_type, folder)\n\n    if not Path(folder).exists():\n        logger.error(\"The folder '%s' does not exist.\", folder)\n        raise FileNotFoundError(f\"The folder '{folder}' does not exist.\")\n    command = f\"rm {os.path.join(folder, f'*.{file_type}')}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152274,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef remove_files(folder: str, file_type: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", file_type, folder)\n\n    if not Path(folder).exists():\n        logger.error(\"The folder '%s' does not exist.\", folder)\n        raise FileNotFoundError(f\"The folder '{folder}' does not exist.\")\n    command = [\"rm\", os.path.join(folder, f\"*.{file_type}\")]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152275,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef purge_documents(folder_path: str, file_extension: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", file_extension, folder_path)\n\n    if not Path(folder_path).exists():\n        logger.error(\"The directory '%s' does not exist.\", folder_path)\n        raise FileNotFoundError(f\"The directory '{folder_path}' does not exist.\")\n    command = f\"rm {os.path.join(folder_path, f'*.{file_extension}')}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152276,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef purge_documents(folder_path: str, file_extension: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", file_extension, folder_path)\n\n    if not Path(folder_path).exists():\n        logger.error(\"The directory '%s' does not exist.\", folder_path)\n        raise FileNotFoundError(f\"The directory '{folder_path}' does not exist.\")\n    command = [\"rm\", os.path.join(folder_path, f\"*.{file_extension}\")]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152277,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef erase_files(dir_path: str, file_ext: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", file_ext, dir_path)\n\n    if not Path(dir_path).exists():\n        logger.error(\"The directory '%s' does not exist.\", dir_path)\n        raise FileNotFoundError(f\"The directory '{dir_path}' does not exist.\")\n    command = f\"rm {os.path.join(dir_path, f'*.{file_ext}')}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152278,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef erase_files(dir_path: str, file_ext: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", file_ext, dir_path)\n\n    if not Path(dir_path).exists():\n        logger.error(\"The directory '%s' does not exist.\", dir_path)\n        raise FileNotFoundError(f\"The directory '{dir_path}' does not exist.\")\n    command = [\"rm\", os.path.join(dir_path, f\"*.{file_ext}\")]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152279,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef archive_logs(log_directory: str, destination_directory: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Backing up logs...\")\n    if not os.path.isdir(log_directory):\n        logger.error(f\"Logs directory '{log_directory}' does not exist.\")\n        return\n\n    if not os.path.isdir(destination_directory):\n        logger.error(f\"Backup directory '{destination_directory}' does not exist.\")\n        return\n    archive_path = Path(destination_directory) / \"logs_backup.zip\"\n    command = f\"zip -r {archive_path} {log_directory}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Logs backed up successfully.\")\n    else:\n        logger.error(\"Failed to back up logs; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152280,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef archive_logs(log_directory: str, destination_directory: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Backing up logs...\")\n    if not os.path.isdir(log_directory):\n        logger.error(f\"Logs directory '{log_directory}' does not exist.\")\n        return\n\n    if not os.path.isdir(destination_directory):\n        logger.error(f\"Backup directory '{destination_directory}' does not exist.\")\n        return\n    archive_path = Path(destination_directory) / \"logs_backup.zip\"\n    command = [\"zip\", \"-r\", str(archive_path), log_directory]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Logs backed up successfully.\")\n    else:\n        logger.error(\"Failed to back up logs; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152281,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef compress_logs(source_dir: str, save_dir: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Backing up logs...\")\n    if not os.path.isdir(source_dir):\n        logger.error(f\"Logs directory '{source_dir}' does not exist.\")\n        return\n\n    if not os.path.isdir(save_dir):\n        logger.error(f\"Backup directory '{save_dir}' does not exist.\")\n        return\n    save_path = Path(save_dir) / \"logs_backup.zip\"\n    command = f\"zip -r {save_path} {source_dir}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Logs backed up successfully.\")\n    else:\n        logger.error(\"Failed to back up logs; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152282,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef compress_logs(source_dir: str, save_dir: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Backing up logs...\")\n    if not os.path.isdir(source_dir):\n        logger.error(f\"Logs directory '{source_dir}' does not exist.\")\n        return\n\n    if not os.path.isdir(save_dir):\n        logger.error(f\"Backup directory '{save_dir}' does not exist.\")\n        return\n    save_path = Path(save_dir) / \"logs_backup.zip\"\n    command = [\"zip\", \"-r\", str(save_path), source_dir]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Logs backed up successfully.\")\n    else:\n        logger.error(\"Failed to back up logs; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152283,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef save_logs(log_folder: str, output_folder: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Backing up logs...\")\n    if not os.path.isdir(log_folder):\n        logger.error(f\"Logs directory '{log_folder}' does not exist.\")\n        return\n\n    if not os.path.isdir(output_folder):\n        logger.error(f\"Backup directory '{output_folder}' does not exist.\")\n        return\n    archive_file = Path(output_folder) / \"logs_backup.zip\"\n    zip_command = f\"zip -r {archive_file} {log_folder}\"\n    logger.info(\"Running command: %s\", zip_command)\n    exit_code = os.system(zip_command)\n    if exit_code == 0:\n        logger.info(\"Logs backed up successfully.\")\n    else:\n        logger.error(\"Failed to back up logs; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152284,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef save_logs(log_folder: str, output_folder: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Backing up logs...\")\n    if not os.path.isdir(log_folder):\n        logger.error(f\"Logs directory '{log_folder}' does not exist.\")\n        return\n\n    if not os.path.isdir(output_folder):\n        logger.error(f\"Backup directory '{output_folder}' does not exist.\")\n        return\n    archive_file = Path(output_folder) / \"logs_backup.zip\"\n    zip_command = [\"zip\", \"-r\", str(archive_file), log_folder]\n    logger.info(\"Running command: %s\", zip_command)\n    proc = subprocess.run(zip_command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Logs backed up successfully.\")\n    else:\n        logger.error(\"Failed to back up logs; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152285,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef archive_logs(logs_folder: str, archive_dir: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Archiving logs...\")\n    if not os.path.isdir(logs_folder):\n        logger.error(f\"Logs directory '{logs_folder}' does not exist.\")\n        return\n\n    if not os.path.isdir(archive_dir):\n        logger.error(f\"Backup directory '{archive_dir}' does not exist.\")\n        return\n    archive_path = Path(archive_dir) / \"logs_archive.zip\"\n    command = f\"zip -r {archive_path} {logs_folder}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Logs archived successfully.\")\n    else:\n        logger.error(\"Failed to archive logs; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152286,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef archive_logs(logs_folder: str, archive_dir: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Archiving logs...\")\n    if not os.path.isdir(logs_folder):\n        logger.error(f\"Logs directory '{logs_folder}' does not exist.\")\n        return\n\n    if not os.path.isdir(archive_dir):\n        logger.error(f\"Backup directory '{archive_dir}' does not exist.\")\n        return\n    archive_path = Path(archive_dir) / \"logs_archive.zip\"\n    command = [\"zip\", \"-r\", str(archive_path), logs_folder]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Logs archived successfully.\")\n    else:\n        logger.error(\"Failed to archive logs; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152287,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef compress_logs(logs_directory: str, destination_dir: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Compressing logs...\")\n    if not os.path.isdir(logs_directory):\n        logger.error(f\"Logs directory '{logs_directory}' does not exist.\")\n        return\n\n    if not os.path.isdir(destination_dir):\n        logger.error(f\"Backup directory '{destination_dir}' does not exist.\")\n        return\n    target_path = Path(destination_dir) / \"logs_backup.zip\"\n    command = f\"zip -r {target_path} {logs_directory}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Logs compressed successfully.\")\n    else:\n        logger.error(\"Failed to compress logs; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152288,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef compress_logs(logs_directory: str, destination_dir: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Compressing logs...\")\n    if not os.path.isdir(logs_directory):\n        logger.error(f\"Logs directory '{logs_directory}' does not exist.\")\n        return\n\n    if not os.path.isdir(destination_dir):\n        logger.error(f\"Backup directory '{destination_dir}' does not exist.\")\n        return\n    target_path = Path(destination_dir) / \"logs_backup.zip\"\n    command = [\"zip\", \"-r\", str(target_path), logs_directory]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Logs compressed successfully.\")\n    else:\n        logger.error(\"Failed to compress logs; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152289,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef store_logs(source_logs: str, target_backup_dir: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Storing logs...\")\n    if not os.path.isdir(source_logs):\n        logger.error(f\"Logs directory '{source_logs}' does not exist.\")\n        return\n\n    if not os.path.isdir(target_backup_dir):\n        logger.error(f\"Backup directory '{target_backup_dir}' does not exist.\")\n        return\n    backup_location = Path(target_backup_dir) / \"logs_storage.zip\"\n    command = f\"zip -r {backup_location} {source_logs}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Logs stored successfully.\")\n    else:\n        logger.error(\"Failed to store logs; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152290,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef store_logs(source_logs: str, target_backup_dir: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Storing logs...\")\n    if not os.path.isdir(source_logs):\n        logger.error(f\"Logs directory '{source_logs}' does not exist.\")\n        return\n\n    if not os.path.isdir(target_backup_dir):\n        logger.error(f\"Backup directory '{target_backup_dir}' does not exist.\")\n        return\n    backup_location = Path(target_backup_dir) / \"logs_storage.zip\"\n    command = [\"zip\", \"-r\", str(backup_location), source_logs]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Logs stored successfully.\")\n    else:\n        logger.error(\"Failed to store logs; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152291,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef archive_logs(logs_directory: str, backup_directory: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Backing up logs...\")\n    if not os.path.isdir(logs_directory):\n        logger.error(f\"Logs directory '{logs_directory}' does not exist.\")\n        return\n\n    if not os.path.isdir(backup_directory):\n        logger.error(f\"Backup directory '{backup_directory}' does not exist.\")\n        return\n    backup_path = Path(backup_directory) / \"logs_backup.zip\"\n    command = f\"zip -r {backup_path} {logs_directory}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Logs backed up successfully.\")\n    else:\n        logger.error(\"Failed to back up logs; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152292,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef archive_logs(logs_directory: str, backup_directory: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Backing up logs...\")\n    if not os.path.isdir(logs_directory):\n        logger.error(f\"Logs directory '{logs_directory}' does not exist.\")\n        return\n\n    if not os.path.isdir(backup_directory):\n        logger.error(f\"Backup directory '{backup_directory}' does not exist.\")\n        return\n    backup_path = Path(backup_directory) / \"logs_backup.zip\"\n    command = [\"zip\", \"-r\", str(backup_path), logs_directory]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Logs backed up successfully.\")\n    else:\n        logger.error(\"Failed to back up logs; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152293,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef save_logs(logs_folder: str, backup_folder: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Backing up logs...\")\n    if not os.path.isdir(logs_folder):\n        logger.error(f\"Logs directory '{logs_folder}' does not exist.\")\n        return\n\n    if not os.path.isdir(backup_folder):\n        logger.error(f\"Backup directory '{backup_folder}' does not exist.\")\n        return\n    backup_path = Path(backup_folder) / \"logs_backup.zip\"\n    command = f\"zip -r {backup_path} {logs_folder}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Logs backed up successfully.\")\n    else:\n        logger.error(\"Failed to back up logs; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152294,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef save_logs(logs_folder: str, backup_folder: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Backing up logs...\")\n    if not os.path.isdir(logs_folder):\n        logger.error(f\"Logs directory '{logs_folder}' does not exist.\")\n        return\n\n    if not os.path.isdir(backup_folder):\n        logger.error(f\"Backup directory '{backup_folder}' does not exist.\")\n        return\n    backup_path = Path(backup_folder) / \"logs_backup.zip\"\n    command = [\"zip\", \"-r\", str(backup_path), logs_folder]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Logs backed up successfully.\")\n    else:\n        logger.error(\"Failed to back up logs; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152295,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef create_log_backup(log_path: str, archive_path: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Backing up logs...\")\n    if not os.path.isdir(log_path):\n        logger.error(f\"Logs directory '{log_path}' does not exist.\")\n        return\n\n    if not os.path.isdir(archive_path):\n        logger.error(f\"Backup directory '{archive_path}' does not exist.\")\n        return\n    backup_file = Path(archive_path) / \"logs_backup.zip\"\n    command = f\"zip -r {backup_file} {log_path}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Logs backed up successfully.\")\n    else:\n        logger.error(\"Failed to back up logs; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152296,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef create_log_backup(log_path: str, archive_path: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Backing up logs...\")\n    if not os.path.isdir(log_path):\n        logger.error(f\"Logs directory '{log_path}' does not exist.\")\n        return\n\n    if not os.path.isdir(archive_path):\n        logger.error(f\"Backup directory '{archive_path}' does not exist.\")\n        return\n    backup_file = Path(archive_path) / \"logs_backup.zip\"\n    command = [\"zip\", \"-r\", str(backup_file), log_path]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Logs backed up successfully.\")\n    else:\n        logger.error(\"Failed to back up logs; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152297,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef convert_md_to_pdf(md_path: str, output_pdf_path: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(md_path):\n        logger.error(\"Markdown file not found: %s\", md_path)\n        raise FileNotFoundError(f\"Markdown file not found: {md_path}\")\n    if not md_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", md_path)\n        return\n    command = f\"pandoc {md_path} -o {output_pdf_path}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152298,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef convert_md_to_pdf(md_path: str, output_pdf_path: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(md_path):\n        logger.error(\"Markdown file not found: %s\", md_path)\n        raise FileNotFoundError(f\"Markdown file not found: {md_path}\")\n    if not md_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", md_path)\n        return\n    command = [\"pandoc\", md_path, \"-o\", output_pdf_path]\n    logger.info(\"Running command: %s\", ' '.join(command))\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152299,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef translate_md_to_pdf(input_md_path: str, final_pdf_path: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(input_md_path):\n        logger.error(\"Markdown file not found: %s\", input_md_path)\n        raise FileNotFoundError(f\"Markdown file not found: {input_md_path}\")\n    if not input_md_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", input_md_path)\n        return\n    command = f\"pandoc {input_md_path} -o {final_pdf_path}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152300,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef translate_md_to_pdf(input_md_path: str, final_pdf_path: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(input_md_path):\n        logger.error(\"Markdown file not found: %s\", input_md_path)\n        raise FileNotFoundError(f\"Markdown file not found: {input_md_path}\")\n    if not input_md_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", input_md_path)\n        return\n    command = [\"pandoc\", input_md_path, \"-o\", final_pdf_path]\n    logger.info(\"Running command: %s\", ' '.join(command))\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152301,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef convert_markdown_to_pdf_uri(src_markdown_path: str, dest_pdf_path: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(src_markdown_path):\n        logger.error(\"Markdown file not found: %s\", src_markdown_path)\n        raise FileNotFoundError(f\"Markdown file not found: {src_markdown_path}\")\n    if not src_markdown_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", src_markdown_path)\n        return\n    command = f\"pandoc {src_markdown_path} -o {dest_pdf_path}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152302,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef convert_markdown_to_pdf_uri(src_markdown_path: str, dest_pdf_path: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(src_markdown_path):\n        logger.error(\"Markdown file not found: %s\", src_markdown_path)\n        raise FileNotFoundError(f\"Markdown file not found: {src_markdown_path}\")\n    if not src_markdown_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", src_markdown_path)\n        return\n    command = [\"pandoc\", src_markdown_path, \"-o\", dest_pdf_path]\n    logger.info(\"Running command: %s\", ' '.join(command))\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152303,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef md_to_pdf_conversion(markdown_file: str, pdf_output: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(markdown_file):\n        logger.error(\"Markdown file not found: %s\", markdown_file)\n        raise FileNotFoundError(f\"Markdown file not found: {markdown_file}\")\n    if not markdown_file.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", markdown_file)\n        return\n    command = f\"pandoc {markdown_file} -o {pdf_output}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152304,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef md_to_pdf_conversion(markdown_file: str, pdf_output: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(markdown_file):\n        logger.error(\"Markdown file not found: %s\", markdown_file)\n        raise FileNotFoundError(f\"Markdown file not found: {markdown_file}\")\n    if not markdown_file.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", markdown_file)\n        return\n    command = [\"pandoc\", markdown_file, \"-o\", pdf_output]\n    logger.info(\"Running command: %s\", ' '.join(command))\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152305,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef markdown_to_pdf(md_file_path: str, pdf_file_path: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(md_file_path):\n        logger.error(\"Markdown file not found: %s\", md_file_path)\n        raise FileNotFoundError(f\"Markdown file not found: {md_file_path}\")\n    if not md_file_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", md_file_path)\n        return\n    command = f\"pandoc {md_file_path} -o {pdf_file_path}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152306,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef markdown_to_pdf(md_file_path: str, pdf_file_path: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(md_file_path):\n        logger.error(\"Markdown file not found: %s\", md_file_path)\n        raise FileNotFoundError(f\"Markdown file not found: {md_file_path}\")\n    if not md_file_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", md_file_path)\n        return\n    command = [\"pandoc\", md_file_path, \"-o\", pdf_file_path]\n    logger.info(\"Running command: %s\", ' '.join(command))\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152307,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef convert_md_to_pdf(input_md_path: str, output_pdf_path: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(input_md_path):\n        logger.error(\"Markdown file not found: %s\", input_md_path)\n        raise FileNotFoundError(f\"Markdown file not found: {input_md_path}\")\n    if not input_md_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", input_md_path)\n        return\n    command = f\"pandoc {input_md_path} -o {output_pdf_path}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152308,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef convert_md_to_pdf(input_md_path: str, output_pdf_path: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(input_md_path):\n        logger.error(\"Markdown file not found: %s\", input_md_path)\n        raise FileNotFoundError(f\"Markdown file not found: {input_md_path}\")\n    if not input_md_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", input_md_path)\n        return\n    command = [\"pandoc\", input_md_path, \"-o\", output_pdf_path]\n    logger.info(\"Running command: %s\", ' '.join(command))\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152309,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef md_to_pdf_converter(markdown_file: str, pdf_output: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(markdown_file):\n        logger.error(\"Markdown file not found: %s\", markdown_file)\n        raise FileNotFoundError(f\"Markdown file not found: {markdown_file}\")\n    if not markdown_file.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", markdown_file)\n        return\n    command = f\"pandoc {markdown_file} -o {pdf_output}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152310,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef md_to_pdf_converter(markdown_file: str, pdf_output: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(markdown_file):\n        logger.error(\"Markdown file not found: %s\", markdown_file)\n        raise FileNotFoundError(f\"Markdown file not found: {markdown_file}\")\n    if not markdown_file.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", markdown_file)\n        return\n    command = [\"pandoc\", markdown_file, \"-o\", pdf_output]\n    logger.info(\"Running command: %s\", ' '.join(command))\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152311,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef markdown_to_pdf(md_path: str, pdf_dest: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(md_path):\n        logger.error(\"Markdown file not found: %s\", md_path)\n        raise FileNotFoundError(f\"Markdown file not found: {md_path}\")\n    if not md_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", md_path)\n        return\n    command = f\"pandoc {md_path} -o {pdf_dest}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152312,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef markdown_to_pdf(md_path: str, pdf_dest: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(md_path):\n        logger.error(\"Markdown file not found: %s\", md_path)\n        raise FileNotFoundError(f\"Markdown file not found: {md_path}\")\n    if not md_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", md_path)\n        return\n    command = [\"pandoc\", md_path, \"-o\", pdf_dest]\n    logger.info(\"Running command: %s\", ' '.join(command))\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152313,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef markdown_to_pdf_conversion(md_file_path: str, pdf_file_output: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(md_file_path):\n        logger.error(\"Markdown file not found: %s\", md_file_path)\n        raise FileNotFoundError(f\"Markdown file not found: {md_file_path}\")\n    if not md_file_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", md_file_path)\n        return\n    command = f\"pandoc {md_file_path} -o {pdf_file_output}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152314,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef markdown_to_pdf_conversion(md_file_path: str, pdf_file_output: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(md_file_path):\n        logger.error(\"Markdown file not found: %s\", md_file_path)\n        raise FileNotFoundError(f\"Markdown file not found: {md_file_path}\")\n    if not md_file_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", md_file_path)\n        return\n    command = [\"pandoc\", md_file_path, \"-o\", pdf_file_output]\n    logger.info(\"Running command: %s\", ' '.join(command))\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152315,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef log_project_dependencies(dependency_file_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = f\"pigar gen -f {Path(dependency_file_path)} {os.getcwd()}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152316,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef log_project_dependencies(dependency_file_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = [\"pigar\", \"gen\", \"-f\", dependency_file_path, os.getcwd()]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152317,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef fetch_project_dependencies(dep_file_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = f\"pigar gen -f {Path(dep_file_path)} {os.getcwd()}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152318,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef fetch_project_dependencies(dep_file_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = [\"pigar\", \"gen\", \"-f\", dep_file_path, os.getcwd()]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152319,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef gather_project_dependencies(req_file_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = f\"pigar gen -f {Path(req_file_path)} {os.getcwd()}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152320,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef gather_project_dependencies(req_file_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = [\"pigar\", \"gen\", \"-f\", req_file_path, os.getcwd()]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152321,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef gather_dependencies(output_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = f\"pigar gen -f {Path(output_path)} {os.getcwd()}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152322,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef gather_dependencies(output_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = [\"pigar\", \"gen\", \"-f\", output_path, os.getcwd()]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152323,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef list_dependencies(file_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = f\"pigar gen -f {Path(file_path)} {os.getcwd()}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152324,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef list_dependencies(file_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = [\"pigar\", \"gen\", \"-f\", file_path, os.getcwd()]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152325,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef fetch_dependencies(dep_output_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = f\"pigar gen -f {Path(dep_output_path)} {os.getcwd()}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152326,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef fetch_dependencies(dep_output_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = [\"pigar\", \"gen\", \"-f\", dep_output_path, os.getcwd()]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152327,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef gather_dependencies(output_file: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing project dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = f\"pigar gen -f {Path(output_file)} {os.getcwd()}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152328,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef gather_dependencies(output_file: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing project dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = [\"pigar\", \"gen\", \"-f\", output_file, os.getcwd()]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152329,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef extract_dependencies(output_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing project dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = f\"pigar gen -f {Path(output_path)} {os.getcwd()}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152330,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef extract_dependencies(output_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing project dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = [\"pigar\", \"gen\", \"-f\", output_path, os.getcwd()]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152331,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef find_dependencies(result_file: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Retrieving project dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency retrieval may not be complete.\"\n        )\n        return\n    command = f\"pigar gen -f {Path(result_file)} {os.getcwd()}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Dependencies retrieved successfully.\")\n    else:\n        logger.error(\"Failed to retrieve dependencies; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152332,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef find_dependencies(result_file: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Retrieving project dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency retrieval may not be complete.\"\n        )\n        return\n    command = [\"pigar\", \"gen\", \"-f\", result_file, os.getcwd()]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Dependencies retrieved successfully.\")\n    else:\n        logger.error(\"Failed to retrieve dependencies; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 152333,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef backup_directory(directory_path: str, backup_name: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = f\"tar -czvf {backup_name}.tar.gz -C {directory_path} .\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 153114,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef backup_directory(directory_path: str, backup_name: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n    command = [\"tar\", \"-czvf\", f\"{backup_name}.tar.gz\", \"-C\", directory_path, \".\"]\n    logger.info(\"Running command: %s\", \" \".join(command))\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 153115,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef delete_files(directory: str, extension: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", extension, directory)\n\n    if not Path(directory).exists():\n        logger.error(\"The directory '%s' does not exist.\", directory)\n        raise FileNotFoundError(f\"The directory '{directory}' does not exist.\")\n    command = f\"rm {os.path.join(directory, f'*.{extension}')}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 153116,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef delete_files(directory: str, extension: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", extension, directory)\n\n    if not Path(directory).exists():\n        logger.error(\"The directory '%s' does not exist.\", directory)\n        raise FileNotFoundError(f\"The directory '{directory}' does not exist.\")\n    command = [\"rm\", os.path.join(directory, f\"*.{extension}\")]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 153117,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef backup_logs(logs_dir: str, backup_dir: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Backing up logs...\")\n    if not os.path.isdir(logs_dir):\n        logger.error(f\"Logs directory '{logs_dir}' does not exist.\")\n        return\n\n    if not os.path.isdir(backup_dir):\n        logger.error(f\"Backup directory '{backup_dir}' does not exist.\")\n        return\n    backup_path = Path(backup_dir) / \"logs_backup.zip\"\n    command = f\"zip -r {backup_path} {logs_dir}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Logs backed up successfully.\")\n    else:\n        logger.error(\"Failed to back up logs; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 153118,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef backup_logs(logs_dir: str, backup_dir: str):\n    \"\"\"Backs up log files by compressing them into a zip archive and storing them in a backup directory.\"\"\"\n    logger.info(\"Backing up logs...\")\n    if not os.path.isdir(logs_dir):\n        logger.error(f\"Logs directory '{logs_dir}' does not exist.\")\n        return\n\n    if not os.path.isdir(backup_dir):\n        logger.error(f\"Backup directory '{backup_dir}' does not exist.\")\n        return\n    backup_path = Path(backup_dir) / \"logs_backup.zip\"\n    command = [\"zip\", \"-r\", str(backup_path), logs_dir]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Logs backed up successfully.\")\n    else:\n        logger.error(\"Failed to back up logs; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 153119,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef convert_markdown_to_pdf(markdown_path: str, pdf_path: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(markdown_path):\n        logger.error(\"Markdown file not found: %s\", markdown_path)\n        raise FileNotFoundError(f\"Markdown file not found: {markdown_path}\")\n    if not markdown_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", markdown_path)\n        return\n    command = f\"pandoc {markdown_path} -o {pdf_path}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 153120,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nlogger = logging.getLogger(__name__)\ndef convert_markdown_to_pdf(markdown_path: str, pdf_path: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(markdown_path):\n        logger.error(\"Markdown file not found: %s\", markdown_path)\n        raise FileNotFoundError(f\"Markdown file not found: {markdown_path}\")\n    if not markdown_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", markdown_path)\n        return\n    command = [\"pandoc\", markdown_path, \"-o\", pdf_path]\n    logger.info(\"Running command: %s\", ' '.join(command))\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 153121,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef capture_dependencies(requirements_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = f\"pigar gen -f {Path(requirements_path)} {os.getcwd()}\"\n    logger.info(\"Running command: %s\", command)\n    exit_code = os.system(command)\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)",
    "target": 1,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 153122,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  },
  {
    "CWE_ID": [
      "CWE-78"
    ],
    "code": "import os\nimport logging\nimport subprocess\nfrom pathlib import Path\nlogger = logging.getLogger(__name__)\ndef capture_dependencies(requirements_path: str):\n    \"\"\"Captures project dependencies and writes them to a requirements file.\"\"\"\n    logger.info(\"Capturing dependencies...\")\n    try:\n        import pigar\n    except ModuleNotFoundError:\n        logging.warning(\n            \"pigar module is not installed, dependency capture might be incomplete.\"\n        )\n        return\n    command = [\"pigar\", \"gen\", \"-f\", requirements_path, os.getcwd()]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n    if exit_code == 0:\n        logger.info(\"Dependencies captured successfully.\")\n    else:\n        logger.error(\"Failed to capture dependencies; command exited with code %d.\", exit_code)",
    "target": 0,
    "language": "python",
    "dataset": "seccodeplt",
    "idx": 153123,
    "RELATED_CWE": [
      "CWE-119",
      "CWE-89",
      "CWE-917"
    ]
  }
]