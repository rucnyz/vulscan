[
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "/*\n * Copyright (c) 2016-2018, Inversoft Inc., All Rights Reserved\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific\n * language governing permissions and limitations under the License.\n */\n\npackage org.primeframework.jwt;\n\nimport org.primeframework.jwt.domain.Algorithm;\nimport org.primeframework.jwt.domain.Header;\nimport org.primeframework.jwt.domain.InvalidJWTException;\nimport org.primeframework.jwt.domain.InvalidJWTSignatureException;\nimport org.primeframework.jwt.domain.JWT;\nimport org.primeframework.jwt.domain.JWTExpiredException;\nimport org.primeframework.jwt.domain.JWTUnavailableForProcessingException;\nimport org.primeframework.jwt.domain.MissingVerifierException;\nimport org.primeframework.jwt.json.Mapper;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Function;\n\n/**\n * @author Daniel DeGroff\n */\npublic class JWTDecoder {\n\n  private static JWTDecoder instance;\n\n  public static JWTDecoder getInstance() {\n    if (instance == null) {\n      instance = new JWTDecoder();\n    }\n\n    return instance;\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. One more verifiers may be provided, the first verifier found\n   * supporting the algorithm reported by the JWT header will be utilized.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT The encoded JWT in string format.\n   * @param verifiers  A map of verifiers.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Verifier... verifiers) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    // An unsecured JWT will not contain a signature and should only have a header and a payload.\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n\n    // If parts.length == 2 we have no signature, if no verifiers were provided, decode if header says 'none', else throw an exception\n    if (parts.length == 2 && verifiers.length == 0) {\n      if (header.algorithm == Algorithm.none) {\n        return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n      } else {\n        throw new InvalidJWTSignatureException();\n      }\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    Verifier verifier = null;\n    for (Verifier v : verifiers) {\n      if (v.canVerify(header.algorithm)) {\n        verifier = v;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. A JWT header value named <code>kid</code> is expected to\n   * contain the key to lookup the correct verifier.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT The encoded JWT in string format.\n   * @param verifiers  A map of verifiers.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers) {\n    return decode(encodedJWT, verifiers, h -> h.get(\"kid\"));\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. The key used to lookup the correct verifier is provided by the\n   * <code>keyFunction</code>. The key function is provided the JWT header and is expected to return a string key to\n   * look up the correct verifier.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT  The encoded JWT in string format.\n   * @param verifiers   A map of verifiers.\n   * @param keyFunction A function used to lookup the verifier key from the header.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers, Function<Header, String> keyFunction) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n    Objects.requireNonNull(keyFunction);\n\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n    // If parts.length == 2 we have no signature, if no verifiers were provided, decode if header says 'none', else throw an exception\n    if (parts.length == 2 && verifiers.isEmpty()) {\n      if (header.algorithm == Algorithm.none) {\n        return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n      } else {\n        throw new InvalidJWTSignatureException();\n      }\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    String key = keyFunction.apply(header);\n    Verifier verifier = verifiers.get(key);\n    if (verifier != null) {\n      if (!verifier.canVerify(header.algorithm)) {\n        verifier = null;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n\n  private byte[] base64Decode(byte[] bytes) {\n    try {\n      return Base64.getUrlDecoder().decode(bytes);\n    } catch (IllegalArgumentException e) {\n      throw new InvalidJWTException(\"The encoded JWT is not properly Base64 encoded.\", e);\n    }\n  }\n\n  private JWT decode(String encodedJWT, Header header, String[] parts, Verifier verifier) {\n    int index = encodedJWT.lastIndexOf(\".\");\n    // The message comprises the first two segments of the entire JWT, the signature is the last segment.\n    byte[] message = encodedJWT.substring(0, index).getBytes(StandardCharsets.UTF_8);\n\n    // If a signature is provided and verifier must be provided.\n    if (parts.length == 3 && verifier == null) {\n      throw new MissingVerifierException(\"No Verifier has been provided for verify a signature signed using [\" + header.algorithm.getName() + \"]\");\n    }\n\n    // A verifier was provided but no signature exists, this is treated as an invalid signature.\n    if (parts.length == 2 && verifier != null) {\n      throw new InvalidJWTSignatureException();\n    }\n\n    if (parts.length == 3) {\n      // Verify the signature before de-serializing the payload.\n      byte[] signature = base64Decode(parts[2].getBytes(StandardCharsets.UTF_8));\n      verifier.verify(header.algorithm, message, signature);\n    }\n\n    JWT jwt = Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n\n    // Verify expiration claim\n    if (jwt.isExpired()) {\n      throw new JWTExpiredException();\n    }\n\n    // Verify the notBefore claim\n    if (jwt.isUnavailableForProcessing()) {\n      throw new JWTUnavailableForProcessingException();\n    }\n\n    return jwt;\n  }\n\n  private String[] getParts(String encodedJWT) {\n    String[] parts = encodedJWT.split(\"\\\\.\");\n    // Secured JWT XXXXX.YYYYY.ZZZZZ, Unsecured JWT XXXXX.YYYYY.\n    if (parts.length == 3 || (parts.length == 2 && encodedJWT.endsWith(\".\"))) {\n      return parts;\n    }\n\n    throw new InvalidJWTException(\"The encoded JWT is not properly formatted. Expected a three part dot separated string.\");\n  }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200150,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "/*\n * Copyright (c) 2016-2018, Inversoft Inc., All Rights Reserved\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific\n * language governing permissions and limitations under the License.\n */\n\npackage org.primeframework.jwt;\n\nimport org.primeframework.jwt.domain.Algorithm;\nimport org.primeframework.jwt.domain.Header;\nimport org.primeframework.jwt.domain.InvalidJWTException;\nimport org.primeframework.jwt.domain.InvalidJWTSignatureException;\nimport org.primeframework.jwt.domain.JWT;\nimport org.primeframework.jwt.domain.JWTExpiredException;\nimport org.primeframework.jwt.domain.JWTUnavailableForProcessingException;\nimport org.primeframework.jwt.domain.MissingVerifierException;\nimport org.primeframework.jwt.json.Mapper;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Function;\n\n/**\n * @author Daniel DeGroff\n */\npublic class JWTDecoder {\n\n  private static JWTDecoder instance;\n\n  public static JWTDecoder getInstance() {\n    if (instance == null) {\n      instance = new JWTDecoder();\n    }\n\n    return instance;\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. One more verifiers may be provided, the first verifier found\n   * supporting the algorithm reported by the JWT header will be utilized.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT The encoded JWT in string format.\n   * @param verifiers  A map of verifiers.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Verifier... verifiers) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    // An unsecured JWT will not contain a signature and should only have a header and a payload.\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n\n    // If parts.length == 2 we have no signature, if no verifiers were provided, decode if header says 'none', else throw an exception\n    if (parts.length == 2 && verifiers.length == 0) {\n      if (header.algorithm == Algorithm.none) {\n        return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n      } else {\n        throw new InvalidJWTSignatureException();\n      }\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    Verifier verifier = null;\n    for (Verifier v : verifiers) {\n      if (v.canVerify(header.algorithm)) {\n        verifier = v;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. A JWT header value named <code>kid</code> is expected to\n   * contain the key to lookup the correct verifier.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT The encoded JWT in string format.\n   * @param verifiers  A map of verifiers.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers) {\n    return decode(encodedJWT, verifiers, h -> h.get(\"kid\"));\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. The key used to lookup the correct verifier is provided by the\n   * <code>keyFunction</code>. The key function is provided the JWT header and is expected to return a string key to\n   * look up the correct verifier.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT  The encoded JWT in string format.\n   * @param verifiers   A map of verifiers.\n   * @param keyFunction A function used to lookup the verifier key from the header.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers, Function<Header, String> keyFunction) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n    Objects.requireNonNull(keyFunction);\n\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n    // If parts.length == 2 we have no signature, if no verifiers were provided, decode if header says 'none', else throw an exception\n    if (parts.length == 2 && verifiers.isEmpty()) {\n      if (header.algorithm == Algorithm.none) {\n        return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n      } else {\n        throw new InvalidJWTSignatureException();\n      }\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    String key = keyFunction.apply(header);\n    Verifier verifier = verifiers.get(key);\n    if (verifier != null) {\n      if (!verifier.canVerify(header.algorithm)) {\n        verifier = null;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n\n  private byte[] base64Decode(byte[] bytes) {\n    try {\n      return Base64.getUrlDecoder().decode(bytes);\n    } catch (IllegalArgumentException e) {\n      throw new InvalidJWTException(\"The encoded JWT is not properly Base64 encoded.\", e);\n    }\n  }\n\n  private JWT decode(String encodedJWT, Header header, String[] parts, Verifier verifier) {\n    // The callers of this decode will have already handled 'none' if it was deemed to be valid based upon\n    // the provided verifiers. At this point, if we have a 'none' algorithm specified in the header, it is invalid.\n    if (header.algorithm == Algorithm.none) {\n      throw new MissingVerifierException(\"No Verifier has been provided for verify a signature signed using [\" + header.algorithm.getName() + \"]\");\n    }\n\n    // If a signature is provided and verifier must be provided.\n    if (parts.length == 3 && verifier == null) {\n      throw new MissingVerifierException(\"No Verifier has been provided for verify a signature signed using [\" + header.algorithm.getName() + \"]\");\n    }\n\n    // A verifier was provided but no signature exists, this is treated as an invalid signature.\n    if (parts.length == 2 && verifier != null) {\n      throw new InvalidJWTSignatureException();\n    }\n\n    int index = encodedJWT.lastIndexOf(\".\");\n    // The message comprises the first two segments of the entire JWT, the signature is the last segment.\n    byte[] message = encodedJWT.substring(0, index).getBytes(StandardCharsets.UTF_8);\n\n    if (parts.length == 3) {\n      // Verify the signature before de-serializing the payload.\n      byte[] signature = base64Decode(parts[2].getBytes(StandardCharsets.UTF_8));\n      verifier.verify(header.algorithm, message, signature);\n    }\n\n    JWT jwt = Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n\n    // Verify expiration claim\n    if (jwt.isExpired()) {\n      throw new JWTExpiredException();\n    }\n\n    // Verify the notBefore claim\n    if (jwt.isUnavailableForProcessing()) {\n      throw new JWTUnavailableForProcessingException();\n    }\n\n    return jwt;\n  }\n\n  private String[] getParts(String encodedJWT) {\n    String[] parts = encodedJWT.split(\"\\\\.\");\n    // Secured JWT XXXXX.YYYYY.ZZZZZ, Unsecured JWT XXXXX.YYYYY.\n    if (parts.length == 3 || (parts.length == 2 && encodedJWT.endsWith(\".\"))) {\n      return parts;\n    }\n\n    throw new InvalidJWTException(\"The encoded JWT is not properly formatted. Expected a three part dot separated string.\");\n  }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200151,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "/*\n * Copyright (c) 2016-2018, Inversoft Inc., All Rights Reserved\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific\n * language governing permissions and limitations under the License.\n */\n\npackage org.primeframework.jwt;\n\nimport org.primeframework.jwt.domain.Algorithm;\nimport org.primeframework.jwt.domain.Header;\nimport org.primeframework.jwt.domain.InvalidJWTException;\nimport org.primeframework.jwt.domain.JWT;\nimport org.primeframework.jwt.domain.JWTExpiredException;\nimport org.primeframework.jwt.domain.JWTUnavailableForProcessingException;\nimport org.primeframework.jwt.domain.MissingVerifierException;\nimport org.primeframework.jwt.json.Mapper;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Function;\n\n/**\n * @author Daniel DeGroff\n */\npublic class JWTDecoder {\n\n  private static JWTDecoder instance;\n\n  public static JWTDecoder getInstance() {\n    if (instance == null) {\n      instance = new JWTDecoder();\n    }\n\n    return instance;\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. One more verifiers may be provided, the first verifier found\n   * supporting the algorithm reported by the JWT header will be utilized.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT The encoded JWT in string format.\n   * @param verifiers  A map of verifiers.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Verifier... verifiers) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    // An unsecured JWT will not contain a signature and should only have a header and a payload.\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n\n    // Be particular about decoding an unsecured JWT. If the JWT is signed or any verifiers were provided don't do it.\n    if (header.algorithm == Algorithm.none && parts.length == 2 && verifiers.length == 0) {\n      return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    Verifier verifier = null;\n    for (Verifier v : verifiers) {\n      if (v.canVerify(header.algorithm)) {\n        verifier = v;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. A JWT header value named <code>kid</code> is expected to\n   * contain the key to lookup the correct verifier.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT The encoded JWT in string format.\n   * @param verifiers  A map of verifiers.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers) {\n    return decode(encodedJWT, verifiers, h -> h.get(\"kid\"));\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. The key used to lookup the correct verifier is provided by the\n   * <code>keyFunction</code>. The key function is provided the JWT header and is expected to return a string key to\n   * look up the correct verifier.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT  The encoded JWT in string format.\n   * @param verifiers   A map of verifiers.\n   * @param keyFunction A function used to lookup the verifier key from the header.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers, Function<Header, String> keyFunction) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n    // Be particular about decoding an unsecured JWT. If the JWT is signed or any verifiers were provided don't do it.\n    if (header.algorithm == Algorithm.none && parts.length == 2 && verifiers.isEmpty()) {\n      return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    String key = keyFunction.apply(header);\n    Verifier verifier = verifiers.get(key);\n    if (verifier != null) {\n      if (!verifier.canVerify(header.algorithm)) {\n        verifier = null;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n\n  private byte[] base64Decode(byte[] bytes) {\n    try {\n      return Base64.getUrlDecoder().decode(bytes);\n    } catch (IllegalArgumentException e) {\n      throw new InvalidJWTException(\"The encoded JWT is not properly Base64 encoded.\", e);\n    }\n  }\n\n  private JWT decode(String encodedJWT, Header header, String[] parts, Verifier verifier) {\n    int index = encodedJWT.lastIndexOf(\".\");\n    // The message comprises the first two segments of the entire JWT, the signature is the last segment.\n    byte[] message = encodedJWT.substring(0, index).getBytes(StandardCharsets.UTF_8);\n\n    // If a signature is provided and verifier must be provided.\n    if (parts.length == 3 && verifier == null) {\n      throw new MissingVerifierException(\"No Verifier has been provided for verify a signature signed using [\" + header.algorithm.getName() + \"]\");\n    }\n\n    if (parts.length == 3) {\n      // Verify the signature before de-serializing the payload.\n      byte[] signature = base64Decode(parts[2].getBytes(StandardCharsets.UTF_8));\n      verifier.verify(header.algorithm, message, signature);\n    }\n\n    JWT jwt = Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n\n    // Verify expiration claim\n    if (jwt.isExpired()) {\n      throw new JWTExpiredException();\n    }\n\n    // Verify the notBefore claim\n    if (jwt.isUnavailableForProcessing()) {\n      throw new JWTUnavailableForProcessingException();\n    }\n\n    return jwt;\n  }\n\n  private String[] getParts(String encodedJWT) {\n    String[] parts = encodedJWT.split(\"\\\\.\");\n    // Secured JWT XXXXX.YYYYY.ZZZZZ, Unsecured JWT XXXXX.YYYYY.\n    if (parts.length == 3 || (parts.length == 2 && encodedJWT.endsWith(\".\"))) {\n      return parts;\n    }\n\n    throw new InvalidJWTException(\"The encoded JWT is not properly formatted. Expected a three part dot separated string.\");\n  }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200152,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "/*\n * Copyright (c) 2016-2018, Inversoft Inc., All Rights Reserved\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific\n * language governing permissions and limitations under the License.\n */\n\npackage org.primeframework.jwt;\n\nimport org.primeframework.jwt.domain.Algorithm;\nimport org.primeframework.jwt.domain.Header;\nimport org.primeframework.jwt.domain.InvalidJWTException;\nimport org.primeframework.jwt.domain.InvalidJWTSignatureException;\nimport org.primeframework.jwt.domain.JWT;\nimport org.primeframework.jwt.domain.JWTExpiredException;\nimport org.primeframework.jwt.domain.JWTUnavailableForProcessingException;\nimport org.primeframework.jwt.domain.MissingVerifierException;\nimport org.primeframework.jwt.json.Mapper;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Function;\n\n/**\n * @author Daniel DeGroff\n */\npublic class JWTDecoder {\n\n  private static JWTDecoder instance;\n\n  public static JWTDecoder getInstance() {\n    if (instance == null) {\n      instance = new JWTDecoder();\n    }\n\n    return instance;\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. One more verifiers may be provided, the first verifier found\n   * supporting the algorithm reported by the JWT header will be utilized.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT The encoded JWT in string format.\n   * @param verifiers  A map of verifiers.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Verifier... verifiers) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    // An unsecured JWT will not contain a signature and should only have a header and a payload.\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n\n    // If parts.length == 2 we have no signature, if no verifiers were provided, decode if header says 'none', else throw an exception\n    if (parts.length == 2 && verifiers.length == 0) {\n      if (header.algorithm == Algorithm.none) {\n        return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n      } else {\n        throw new InvalidJWTSignatureException();\n      }\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    Verifier verifier = null;\n    for (Verifier v : verifiers) {\n      if (v.canVerify(header.algorithm)) {\n        verifier = v;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. A JWT header value named <code>kid</code> is expected to\n   * contain the key to lookup the correct verifier.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT The encoded JWT in string format.\n   * @param verifiers  A map of verifiers.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers) {\n    return decode(encodedJWT, verifiers, h -> h.get(\"kid\"));\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. The key used to lookup the correct verifier is provided by the\n   * <code>keyFunction</code>. The key function is provided the JWT header and is expected to return a string key to\n   * look up the correct verifier.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT  The encoded JWT in string format.\n   * @param verifiers   A map of verifiers.\n   * @param keyFunction A function used to lookup the verifier key from the header.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers, Function<Header, String> keyFunction) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n    // If parts.length == 2 we have no signature, if no verifiers were provided, decode if header says 'none', else throw an exception\n    if (parts.length == 2 && verifiers.isEmpty()) {\n      if (header.algorithm == Algorithm.none) {\n        return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n      } else {\n        throw new InvalidJWTSignatureException();\n      }\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    String key = keyFunction.apply(header);\n    Verifier verifier = verifiers.get(key);\n    if (verifier != null) {\n      if (!verifier.canVerify(header.algorithm)) {\n        verifier = null;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n\n  private byte[] base64Decode(byte[] bytes) {\n    try {\n      return Base64.getUrlDecoder().decode(bytes);\n    } catch (IllegalArgumentException e) {\n      throw new InvalidJWTException(\"The encoded JWT is not properly Base64 encoded.\", e);\n    }\n  }\n\n  private JWT decode(String encodedJWT, Header header, String[] parts, Verifier verifier) {\n    int index = encodedJWT.lastIndexOf(\".\");\n    // The message comprises the first two segments of the entire JWT, the signature is the last segment.\n    byte[] message = encodedJWT.substring(0, index).getBytes(StandardCharsets.UTF_8);\n\n    // If a signature is provided and verifier must be provided.\n    if (parts.length == 3 && verifier == null) {\n      throw new MissingVerifierException(\"No Verifier has been provided for verify a signature signed using [\" + header.algorithm.getName() + \"]\");\n    }\n\n    // A verifier was provided but no signature exists, this is treated as an invalid signature.\n    if (parts.length == 2 && verifier != null) {\n      throw new InvalidJWTSignatureException();\n    }\n\n    if (parts.length == 3) {\n      // Verify the signature before de-serializing the payload.\n      byte[] signature = base64Decode(parts[2].getBytes(StandardCharsets.UTF_8));\n      verifier.verify(header.algorithm, message, signature);\n    }\n\n    JWT jwt = Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n\n    // Verify expiration claim\n    if (jwt.isExpired()) {\n      throw new JWTExpiredException();\n    }\n\n    // Verify the notBefore claim\n    if (jwt.isUnavailableForProcessing()) {\n      throw new JWTUnavailableForProcessingException();\n    }\n\n    return jwt;\n  }\n\n  private String[] getParts(String encodedJWT) {\n    String[] parts = encodedJWT.split(\"\\\\.\");\n    // Secured JWT XXXXX.YYYYY.ZZZZZ, Unsecured JWT XXXXX.YYYYY.\n    if (parts.length == 3 || (parts.length == 2 && encodedJWT.endsWith(\".\"))) {\n      return parts;\n    }\n\n    throw new InvalidJWTException(\"The encoded JWT is not properly formatted. Expected a three part dot separated string.\");\n  }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200153,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "package org.jboss.resteasy.plugins.delegates;\n\nimport org.jboss.resteasy.resteasy_jaxrs.i18n.Messages;\nimport org.jboss.resteasy.util.HeaderParameterParser;\n\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.ext.RuntimeDelegate;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n * @version $Revision: 1 $\n */\npublic class MediaTypeHeaderDelegate implements RuntimeDelegate.HeaderDelegate\n{\n   public static final MediaTypeHeaderDelegate INSTANCE = new MediaTypeHeaderDelegate();\n\n   private static Map<String, MediaType> map = new ConcurrentHashMap<String, MediaType>();\n   private static Map<MediaType, String> reverseMap = new ConcurrentHashMap<MediaType, String>();\n   private static final int MAX_MT_CACHE_SIZE =\n       Integer.getInteger(\"org.jboss.resteasy.max_mediatype_cache_size\", 200);\n\n   public Object fromString(String type) throws IllegalArgumentException\n   {\n      if (type == null) throw new IllegalArgumentException(Messages.MESSAGES.mediaTypeValueNull());\n      return parse(type);\n   }\n\n   protected static boolean isValid(String str)\n   {\n      if (str == null || str.length() == 0) return false;\n      for (int i = 0; i < str.length(); i++) {\n         switch (str.charAt(i))\n         {\n            case '/':\n            case '\\\\':\n            case '?':\n            case ':':\n            case '<':\n            case '>':\n            case ';':\n            case '(':\n            case ')':\n            case '@':\n            case ',':\n            case '[':\n            case ']':\n            case '=':\n               return false;\n            default:\n               break;\n         }\n      }\n      return true;\n   }\n\n   public static MediaType parse(String type)\n   {\n      MediaType result = map.get(type);\n      if (result == null) {\n          result = internalParse(type);\n          final int size = map.size();\n          if (size >= MAX_MT_CACHE_SIZE) {\n              map.clear();\n              reverseMap.clear();\n          }\n          map.put(type, result);\n          reverseMap.put(result, type);\n      }\n      return result;\n   }\n\n   private static MediaType internalParse(String type)\n   {\n      int typeIndex = type.indexOf('/');\n      int paramIndex = type.indexOf(';');\n      String major = null;\n      String subtype = null;\n      if (typeIndex < 0) // possible \"*\"\n      {\n         major = type;\n         if (paramIndex > -1)\n         {\n            major = major.substring(0, paramIndex);\n         }\n         if (!MediaType.MEDIA_TYPE_WILDCARD.equals(major))\n         {\n            throw new IllegalArgumentException(Messages.MESSAGES.failureParsingMediaType(type));\n         }\n         subtype = MediaType.MEDIA_TYPE_WILDCARD;\n      }\n      else\n      {\n         major = type.substring(0, typeIndex);\n         if (paramIndex > -1)\n         {\n            subtype = type.substring(typeIndex + 1, paramIndex);\n         }\n         else\n         {\n            subtype = type.substring(typeIndex + 1);\n         }\n      }\n      if (major.length() < 1 || subtype.length() < 1)\n      {\n         throw new IllegalArgumentException(Messages.MESSAGES.failureParsingMediaType(type));\n      }\n      if (!isValid(major) || !isValid(subtype))\n      {\n         throw new IllegalArgumentException(Messages.MESSAGES.failureParsingMediaType(type));\n      }\n      String params = null;\n      if (paramIndex > -1) params = type.substring(paramIndex + 1);\n      if (params != null && !params.equals(\"\"))\n      {\n         HashMap<String, String> typeParams = new HashMap<String, String>();\n\n         int start = 0;\n\n         while (start < params.length())\n         {\n            start = HeaderParameterParser.setParam(typeParams, params, start);\n         }\n         return new MediaType(major, subtype, typeParams);\n      }\n      else\n      {\n         return new MediaType(major, subtype);\n      }\n   }\n\n   private static final char[] quotedChars = \"()<>@,;:\\\\\\\"/[]?= \\t\\r\\n\".toCharArray();\n\n   public static boolean quoted(String str)\n   {\n      for (int i = 0; i < str.length(); i++)\n      {\n         char c = str.charAt(i);\n         for (char q : quotedChars) {\n            if (c == q) return true;\n         }\n      }\n      return false;\n   }\n\n   public String toString(Object o)\n   {\n      if (o == null) throw new IllegalArgumentException(Messages.MESSAGES.paramNull());\n      MediaType type = (MediaType) o;\n      String result = reverseMap.get(type);\n      if (result == null) {\n          result = internalToString(type);\n          final int size = reverseMap.size();\n          if (size >= MAX_MT_CACHE_SIZE) {\n             reverseMap.clear();\n             map.clear();\n          }\n          reverseMap.put(type, result);\n          map.put(result, type);\n      }\n      return result;\n   }\n\n   private String internalToString(MediaType type)\n   {\n      StringBuilder buf = new StringBuilder();\n\n      buf.append(type.getType().toLowerCase()).append(\"/\").append(type.getSubtype().toLowerCase());\n      if (type.getParameters() == null || type.getParameters().size() == 0) return buf.toString();\n      for (String name : type.getParameters().keySet())\n      {\n         buf.append(';').append(name).append('=');\n         String val = type.getParameters().get(name);\n         if (quoted(val)) buf.append('\"').append(val).append('\"');\n         else buf.append(val);\n      }\n      return buf.toString();\n   }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200180,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "package org.jboss.resteasy.plugins.delegates;\n\nimport org.jboss.resteasy.resteasy_jaxrs.i18n.Messages;\nimport org.jboss.resteasy.util.HeaderParameterParser;\n\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.ext.RuntimeDelegate;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n * @version $Revision: 1 $\n */\npublic class MediaTypeHeaderDelegate implements RuntimeDelegate.HeaderDelegate\n{\n   public static final MediaTypeHeaderDelegate INSTANCE = new MediaTypeHeaderDelegate();\n\n   private static Map<String, MediaType> map = new ConcurrentHashMap<String, MediaType>();\n   private static Map<MediaType, String> reverseMap = new ConcurrentHashMap<MediaType, String>();\n   private static final int MAX_MT_CACHE_SIZE =\n       Integer.getInteger(\"org.jboss.resteasy.max_mediatype_cache_size\", 200);\n\n   public Object fromString(String type) throws IllegalArgumentException\n   {\n      if (type == null) throw new IllegalArgumentException(Messages.MESSAGES.mediaTypeValueNull());\n      return parse(type);\n   }\n\n   protected static boolean isValid(String str)\n   {\n      if (str == null || str.length() == 0) return false;\n      for (int i = 0; i < str.length(); i++) {\n         switch (str.charAt(i))\n         {\n            case '/':\n            case '\\\\':\n            case '?':\n            case ':':\n            case '<':\n            case '>':\n            case ';':\n            case '(':\n            case ')':\n            case '@':\n            case ',':\n            case '[':\n            case ']':\n            case '=':\n            case '\\n':\n               return false;\n            default:\n               break;\n         }\n      }\n      return true;\n   }\n\n   public static MediaType parse(String type)\n   {\n      MediaType result = map.get(type);\n      if (result == null) {\n          result = internalParse(type);\n          final int size = map.size();\n          if (size >= MAX_MT_CACHE_SIZE) {\n              map.clear();\n              reverseMap.clear();\n          }\n          map.put(type, result);\n          reverseMap.put(result, type);\n      }\n      return result;\n   }\n\n   private static MediaType internalParse(String type)\n   {\n      int typeIndex = type.indexOf('/');\n      int paramIndex = type.indexOf(';');\n      String major = null;\n      String subtype = null;\n      if (typeIndex < 0) // possible \"*\"\n      {\n         major = type;\n         if (paramIndex > -1)\n         {\n            major = major.substring(0, paramIndex);\n         }\n         if (!MediaType.MEDIA_TYPE_WILDCARD.equals(major))\n         {\n            throw new IllegalArgumentException(Messages.MESSAGES.failureParsingMediaType(type));\n         }\n         subtype = MediaType.MEDIA_TYPE_WILDCARD;\n      }\n      else\n      {\n         major = type.substring(0, typeIndex);\n         if (paramIndex > -1)\n         {\n            subtype = type.substring(typeIndex + 1, paramIndex);\n         }\n         else\n         {\n            subtype = type.substring(typeIndex + 1);\n         }\n      }\n      if (major.length() < 1 || subtype.length() < 1)\n      {\n         throw new IllegalArgumentException(Messages.MESSAGES.failureParsingMediaType(type));\n      }\n      if (!isValid(major) || !isValid(subtype))\n      {\n         throw new IllegalArgumentException(Messages.MESSAGES.failureParsingMediaType(type));\n      }\n      String params = null;\n      if (paramIndex > -1) params = type.substring(paramIndex + 1);\n      if (params != null && !params.equals(\"\"))\n      {\n         HashMap<String, String> typeParams = new HashMap<String, String>();\n\n         int start = 0;\n\n         while (start < params.length())\n         {\n            start = HeaderParameterParser.setParam(typeParams, params, start);\n         }\n         return new MediaType(major, subtype, typeParams);\n      }\n      else\n      {\n         return new MediaType(major, subtype);\n      }\n   }\n\n   private static final char[] quotedChars = \"()<>@,;:\\\\\\\"/[]?= \\t\\r\\n\".toCharArray();\n\n   public static boolean quoted(String str)\n   {\n      for (int i = 0; i < str.length(); i++)\n      {\n         char c = str.charAt(i);\n         for (char q : quotedChars) {\n            if (c == q) return true;\n         }\n      }\n      return false;\n   }\n\n   public String toString(Object o)\n   {\n      if (o == null) throw new IllegalArgumentException(Messages.MESSAGES.paramNull());\n      MediaType type = (MediaType) o;\n      String result = reverseMap.get(type);\n      if (result == null) {\n          result = internalToString(type);\n          final int size = reverseMap.size();\n          if (size >= MAX_MT_CACHE_SIZE) {\n             reverseMap.clear();\n             map.clear();\n          }\n          reverseMap.put(type, result);\n          map.put(result, type);\n      }\n      return result;\n   }\n\n   private String internalToString(MediaType type)\n   {\n      StringBuilder buf = new StringBuilder();\n\n      buf.append(type.getType().toLowerCase()).append(\"/\").append(type.getSubtype().toLowerCase());\n      if (type.getParameters() == null || type.getParameters().size() == 0) return buf.toString();\n      for (String name : type.getParameters().keySet())\n      {\n         buf.append(';').append(name).append('=');\n         String val = type.getParameters().get(name);\n         if (quoted(val)) buf.append('\"').append(val).append('\"');\n         else buf.append(val);\n      }\n      return buf.toString();\n   }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200181,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "/*\n * Copyright 2002-2006,2009 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.opensymphony.xwork2.validator.validators;\n\nimport com.opensymphony.xwork2.validator.ValidationException;\nimport com.opensymphony.xwork2.util.URLUtil;\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * <!-- START SNIPPET: javadoc -->\n * \n * URLValidator checks that a given field is a String and a valid URL\n * \n * <!-- END SNIPPET: javadoc -->\n * \n * <p/>\n * \n * <!-- START SNIPPET: parameters -->\n * \n * <ul>\n * \t\t<li>fieldName - The field name this validator is validating. Required if using Plain-Validator Syntax otherwise not required</li>\n * \t\t<li>urlRegexExpression - The regex defined as expression used to validate url. If not defined 'urlRegex' will be used instead</li>\n * \t\t<li>urlRegex - The regex used to validate url. If not defined default regex will be used</li>\n * </ul>\n * \n * <!-- END SNIPPET: parameters -->\n *\n * <p/>\n *\n * <pre>\n * <!-- START SNIPPET: examples -->\n * &lt;validators&gt;\n *      &lt;!-- Plain Validator Syntax --&gt;\n *      &lt;validator type=\"url\"&gt;\n *          &lt;param name=\"fieldName\"&gt;myHomePage&lt;/param&gt;\n *          &lt;message&gt;Invalid homepage url&lt;/message&gt;\n *      &lt;/validator&gt;\n *\n *      &lt;!-- Field Validator Syntax --&gt;\n *      &lt;field name=\"myHomepage\"&gt;\n *          &lt;field-validator type=\"url\"&gt;\n *              &lt;message&gt;Invalid homepage url&lt;/message&gt;\n *          &lt;/field-validator&gt;\n *      &lt;/field&gt;\n * &lt;/validators&gt;\n * <!-- END SNIPPET: examples -->\n * </pre>\n *\n *\n * @author $Author$\n * @version $Date$ $Revision$\n */\npublic class URLValidator extends FieldValidatorSupport {\n\n    private String urlRegex;\n    private String urlRegexExpression;\n\n    public void validate(Object object) throws ValidationException {\n        String fieldName = getFieldName();\n        Object value = this.getFieldValue(fieldName, object);\n\n        // if there is no value - don't do comparison\n        // if a value is required, a required validator should be added to the field\n        if (value == null || value.toString().length() == 0) {\n            return;\n        }\n\n        // FIXME deprecated! the same regex below should be used instead\n        // replace logic with next major release\n        if (!(value.getClass().equals(String.class)) || !URLUtil.verifyUrl((String) value)) {\n            addFieldError(fieldName, object);\n        }\n    }\n\n    /**\n     * This is used to support client-side validation, it's based on\n     * http://stackoverflow.com/questions/161738/what-is-the-best-regular-expression-to-check-if-a-string-is-a-valid-url\n     *\n     * @return regex to validate URLs\n     */\n    public String getUrlRegex() {\n        if (StringUtils.isNotEmpty(urlRegexExpression)) {\n            return (String) parse(urlRegexExpression, String.class);\n        } else if (StringUtils.isNotEmpty(urlRegex)) {\n            return urlRegex;\n        } else {\n            return \"^(https?|ftp):\\\\/\\\\/\" +\n                    \"(([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+\" +\n                    \"(:([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+)?\" +\n                    \"@)?(#?\" +\n                    \")((([a-z0-9]\\\\.|[a-z0-9][a-z0-9-]*[a-z0-9]\\\\.)*\" +\n                    \"[a-z][a-z0-9-]*[a-z0-9]\" +\n                    \"|((\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\\\\.){3}\" +\n                    \"(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\" +\n                    \")(:\\\\d+)?\" +\n                    \")(((\\\\/+([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)*\" +\n                    \"(\\\\?([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)\" +\n                    \"?)?)?\" +\n                    \"(#([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)?\" +\n                    \"$\";\n        }\n    }\n\n    public void setUrlRegex(String urlRegex) {\n        this.urlRegex = urlRegex;\n    }\n\n    public void setUrlRegexExpression(String urlRegexExpression) {\n        this.urlRegexExpression = urlRegexExpression;\n    }\n\n}",
    "target": 1,
    "language": "java",
    "dataset": "A-Manually-Curated-Dataset-of-Vulnerability-Introducing-Commits-in-Java",
    "idx": 800058,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "/*\n * Copyright 2002-2006,2009 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.opensymphony.xwork2.validator.validators;\n\nimport com.opensymphony.xwork2.validator.ValidationException;\nimport com.opensymphony.xwork2.util.URLUtil;\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * URLValidator checks that a given field is a String and a valid URL\n *\n * <pre>\n * &lt;validators&gt;\n *      &lt;!-- Plain Validator Syntax --&gt;\n *      &lt;validator type=\"url\"&gt;\n *          &lt;param name=\"fieldName\"&gt;myHomePage&lt;/param&gt;\n *          &lt;message&gt;Invalid homepage url&lt;/message&gt;\n *      &lt;/validator&gt;\n *\n *      &lt;!-- Field Validator Syntax --&gt;\n *      &lt;field name=\"myHomepage\"&gt;\n *          &lt;field-validator type=\"url\"&gt;\n *              &lt;message&gt;Invalid homepage url&lt;/message&gt;\n *          &lt;/field-validator&gt;\n *      &lt;/field&gt;\n * &lt;/validators&gt;\n * </pre>\n */\npublic class URLValidator extends FieldValidatorSupport {\n\n    private String urlRegex;\n    private String urlRegexExpression;\n\n    public void validate(Object object) throws ValidationException {\n        String fieldName = getFieldName();\n        Object value = this.getFieldValue(fieldName, object);\n\n        // if there is no value - don't do comparison\n        // if a value is required, a required validator should be added to the field\n        if (value == null || value.toString().length() == 0) {\n            return;\n        }\n\n        // FIXME deprecated! the same regex below should be used instead\n        // replace logic with next major release\n        if (!(value.getClass().equals(String.class)) || !URLUtil.verifyUrl((String) value)) {\n            addFieldError(fieldName, object);\n        }\n    }\n\n    /**\n     * This is used to support client-side validation, it's based on\n     * http://stackoverflow.com/questions/161738/what-is-the-best-regular-expression-to-check-if-a-string-is-a-valid-url\n     *\n     * @return regex to validate URLs\n     */\n    public String getUrlRegex() {\n        if (StringUtils.isNotEmpty(urlRegexExpression)) {\n            return (String) parse(urlRegexExpression, String.class);\n        } else if (StringUtils.isNotEmpty(urlRegex)) {\n            return urlRegex;\n        } else {\n            return \"^(https?|ftp):\\\\/\\\\/\" +\n                    \"(([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+\" +\n                    \"(:([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+)?\" +\n                    \"@)?(#?\" +\n                    \")((([a-z0-9]\\\\.|[a-z0-9][a-z0-9-]*[a-z0-9]\\\\.)*\" +\n                    \"[a-z][a-z0-9-]*[a-z0-9]\" +\n                    \"|((\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\\\\.){3}\" +\n                    \"(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\" +\n                    \")(:\\\\d+)?\" +\n                    \")(((\\\\/{0,1}([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)*\" +\n                    \"(\\\\?([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)\" +\n                    \"?)?)?\" +\n                    \"(#([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)?\" +\n                    \"$\";\n        }\n    }\n\n    public void setUrlRegex(String urlRegex) {\n        this.urlRegex = urlRegex;\n    }\n\n    public void setUrlRegexExpression(String urlRegexExpression) {\n        this.urlRegexExpression = urlRegexExpression;\n    }\n\n}",
    "target": 0,
    "language": "java",
    "dataset": "A-Manually-Curated-Dataset-of-Vulnerability-Introducing-Commits-in-Java",
    "idx": 800059,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n */\npackage org.apache.qpid.server.protocol.v0_8;\n\nimport static org.apache.qpid.transport.util.Functions.hex;\n\nimport java.nio.ByteBuffer;\nimport java.security.AccessControlException;\nimport java.security.PrivilegedAction;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\n\nimport javax.security.auth.Subject;\n\nimport org.apache.log4j.Logger;\n\nimport org.apache.qpid.AMQConnectionException;\nimport org.apache.qpid.AMQException;\nimport org.apache.qpid.common.AMQPFilterTypes;\nimport org.apache.qpid.exchange.ExchangeDefaults;\nimport org.apache.qpid.framing.*;\nimport org.apache.qpid.protocol.AMQConstant;\nimport org.apache.qpid.server.TransactionTimeoutHelper;\nimport org.apache.qpid.server.TransactionTimeoutHelper.CloseAction;\nimport org.apache.qpid.server.configuration.BrokerProperties;\nimport org.apache.qpid.server.connection.SessionPrincipal;\nimport org.apache.qpid.server.consumer.ConsumerImpl;\nimport org.apache.qpid.server.consumer.ConsumerTarget;\nimport org.apache.qpid.server.exchange.ExchangeImpl;\nimport org.apache.qpid.server.filter.AMQInvalidArgumentException;\nimport org.apache.qpid.server.filter.FilterManager;\nimport org.apache.qpid.server.filter.FilterManagerFactory;\nimport org.apache.qpid.server.filter.Filterable;\nimport org.apache.qpid.server.filter.MessageFilter;\nimport org.apache.qpid.server.filter.SimpleFilterManager;\nimport org.apache.qpid.server.flow.FlowCreditManager;\nimport org.apache.qpid.server.flow.MessageOnlyCreditManager;\nimport org.apache.qpid.server.flow.Pre0_10CreditManager;\nimport org.apache.qpid.server.logging.LogMessage;\nimport org.apache.qpid.server.logging.LogSubject;\nimport org.apache.qpid.server.logging.messages.ChannelMessages;\nimport org.apache.qpid.server.logging.messages.ExchangeMessages;\nimport org.apache.qpid.server.logging.subjects.ChannelLogSubject;\nimport org.apache.qpid.server.message.InstanceProperties;\nimport org.apache.qpid.server.message.MessageDestination;\nimport org.apache.qpid.server.message.MessageInstance;\nimport org.apache.qpid.server.message.MessageReference;\nimport org.apache.qpid.server.message.MessageSource;\nimport org.apache.qpid.server.message.ServerMessage;\nimport org.apache.qpid.server.model.ConfigurationChangeListener;\nimport org.apache.qpid.server.model.ConfiguredObject;\nimport org.apache.qpid.server.model.Consumer;\nimport org.apache.qpid.server.model.Exchange;\nimport org.apache.qpid.server.model.ExclusivityPolicy;\nimport org.apache.qpid.server.model.LifetimePolicy;\nimport org.apache.qpid.server.model.NoFactoryForTypeException;\nimport org.apache.qpid.server.model.Queue;\nimport org.apache.qpid.server.model.Session;\nimport org.apache.qpid.server.model.State;\nimport org.apache.qpid.server.model.UnknownConfiguredObjectException;\nimport org.apache.qpid.server.protocol.AMQSessionModel;\nimport org.apache.qpid.server.protocol.CapacityChecker;\nimport org.apache.qpid.server.protocol.ConsumerListener;\nimport org.apache.qpid.server.queue.AMQQueue;\nimport org.apache.qpid.server.queue.QueueArgumentsConverter;\nimport org.apache.qpid.server.security.SecurityManager;\nimport org.apache.qpid.server.store.MessageStore;\nimport org.apache.qpid.server.store.StoreFuture;\nimport org.apache.qpid.server.store.StoredMessage;\nimport org.apache.qpid.server.store.TransactionLogResource;\nimport org.apache.qpid.server.txn.AsyncAutoCommitTransaction;\nimport org.apache.qpid.server.txn.LocalTransaction;\nimport org.apache.qpid.server.txn.LocalTransaction.ActivityTimeAccessor;\nimport org.apache.qpid.server.txn.ServerTransaction;\nimport org.apache.qpid.server.util.Action;\nimport org.apache.qpid.server.util.ConnectionScopedRuntimeException;\nimport org.apache.qpid.server.virtualhost.ExchangeExistsException;\nimport org.apache.qpid.server.virtualhost.ExchangeIsAlternateException;\nimport org.apache.qpid.server.virtualhost.QueueExistsException;\nimport org.apache.qpid.server.virtualhost.RequiredExchangeException;\nimport org.apache.qpid.server.virtualhost.ReservedExchangeNameException;\nimport org.apache.qpid.server.virtualhost.VirtualHostImpl;\nimport org.apache.qpid.transport.TransportException;\n\npublic class AMQChannel\n        implements AMQSessionModel<AMQChannel, AMQProtocolEngine>,\n                   AsyncAutoCommitTransaction.FutureRecorder,\n                   ServerChannelMethodProcessor\n{\n    public static final int DEFAULT_PREFETCH = 4096;\n\n    private static final Logger _logger = Logger.getLogger(AMQChannel.class);\n\n    //TODO use Broker property to configure message authorization requirements\n    private boolean _messageAuthorizationRequired = Boolean.getBoolean(BrokerProperties.PROPERTY_MSG_AUTH);\n\n    private final int _channelId;\n\n\n    private final Pre0_10CreditManager _creditManager = new Pre0_10CreditManager(0l,0l);\n\n    /**\n     * The delivery tag is unique per channel. This is pre-incremented before putting into the deliver frame so that\n     * value of this represents the <b>last</b> tag sent out\n     */\n    private long _deliveryTag = 0;\n\n    /** A channel has a default queue (the last declared) that is used when no queue name is explicitly set */\n    private AMQQueue _defaultQueue;\n\n    /** This tag is unique per subscription to a queue. The server returns this in response to a basic.consume request. */\n    private int _consumerTag;\n\n    /**\n     * The current message - which may be partial in the sense that not all frames have been received yet - which has\n     * been received by this channel. As the frames are received the message gets updated and once all frames have been\n     * received the message can then be routed.\n     */\n    private IncomingMessage _currentMessage;\n\n    /** Maps from consumer tag to subscription instance. Allows us to unsubscribe from a queue. */\n    private final Map<AMQShortString, ConsumerTarget_0_8> _tag2SubscriptionTargetMap = new HashMap<AMQShortString, ConsumerTarget_0_8>();\n\n    private final MessageStore _messageStore;\n\n    private final LinkedList<AsyncCommand> _unfinishedCommandsQueue = new LinkedList<AsyncCommand>();\n\n    private UnacknowledgedMessageMap _unacknowledgedMessageMap = new UnacknowledgedMessageMapImpl(DEFAULT_PREFETCH);\n\n    private final AtomicBoolean _suspended = new AtomicBoolean(false);\n\n    private ServerTransaction _transaction;\n\n    private final AtomicLong _txnStarts = new AtomicLong(0);\n    private final AtomicLong _txnCommits = new AtomicLong(0);\n    private final AtomicLong _txnRejects = new AtomicLong(0);\n    private final AtomicLong _txnCount = new AtomicLong(0);\n\n    private final AMQProtocolEngine _connection;\n    private AtomicBoolean _closing = new AtomicBoolean(false);\n\n    private final Set<Object> _blockingEntities = Collections.synchronizedSet(new HashSet<Object>());\n\n    private final AtomicBoolean _blocking = new AtomicBoolean(false);\n\n\n    private LogSubject _logSubject;\n    private volatile boolean _rollingBack;\n\n    private static final Runnable NULL_TASK = new Runnable() { public void run() {} };\n    private List<MessageInstance> _resendList = new ArrayList<MessageInstance>();\n    private static final\n    AMQShortString IMMEDIATE_DELIVERY_REPLY_TEXT = new AMQShortString(\"Immediate delivery is not possible.\");\n    private long _createTime = System.currentTimeMillis();\n\n    private final ClientDeliveryMethod _clientDeliveryMethod;\n\n    private final TransactionTimeoutHelper _transactionTimeoutHelper;\n    private final UUID _id = UUID.randomUUID();\n\n    private final List<Action<? super AMQChannel>> _taskList =\n            new CopyOnWriteArrayList<Action<? super AMQChannel>>();\n\n\n    private final CapacityCheckAction _capacityCheckAction = new CapacityCheckAction();\n    private final ImmediateAction _immediateAction = new ImmediateAction();\n    private Subject _subject;\n    private final CopyOnWriteArrayList<Consumer<?>> _consumers = new CopyOnWriteArrayList<Consumer<?>>();\n    private final ConfigurationChangeListener _consumerClosedListener = new ConsumerClosedListener();\n    private final CopyOnWriteArrayList<ConsumerListener> _consumerListeners = new CopyOnWriteArrayList<ConsumerListener>();\n    private Session<?> _modelObject;\n\n\n    public AMQChannel(AMQProtocolEngine connection, int channelId, final MessageStore messageStore)\n    {\n        _connection = connection;\n        _channelId = channelId;\n\n        _subject = new Subject(false, connection.getAuthorizedSubject().getPrincipals(),\n                               connection.getAuthorizedSubject().getPublicCredentials(),\n                               connection.getAuthorizedSubject().getPrivateCredentials());\n        _subject.getPrincipals().add(new SessionPrincipal(this));\n        _logSubject = new ChannelLogSubject(this);\n\n        _messageStore = messageStore;\n\n        // by default the session is non-transactional\n        _transaction = new AsyncAutoCommitTransaction(_messageStore, this);\n\n        _clientDeliveryMethod = connection.createDeliveryMethod(_channelId);\n\n        _transactionTimeoutHelper = new TransactionTimeoutHelper(_logSubject, new CloseAction()\n        {\n            @Override\n            public void doTimeoutAction(String reason)\n            {\n                try\n                {\n                    closeConnection(reason);\n                }\n                catch (AMQException e)\n                {\n                    throw new ConnectionScopedRuntimeException(e);\n                }\n            }\n        }, getVirtualHost());\n\n        Subject.doAs(_subject, new PrivilegedAction<Object>()\n        {\n            @Override\n            public Object run()\n            {\n                getVirtualHost().getEventLogger().message(ChannelMessages.CREATE());\n\n                return null;\n            }\n        });\n\n    }\n\n    private boolean performGet(final AMQQueue queue,\n                               final boolean acks)\n            throws MessageSource.ExistingConsumerPreventsExclusive,\n                   MessageSource.ExistingExclusiveConsumer, MessageSource.ConsumerAccessRefused\n    {\n\n        final FlowCreditManager singleMessageCredit = new MessageOnlyCreditManager(1L);\n\n        final GetDeliveryMethod getDeliveryMethod =\n                new GetDeliveryMethod(singleMessageCredit, queue);\n        final RecordDeliveryMethod getRecordMethod = new RecordDeliveryMethod()\n        {\n\n            public void recordMessageDelivery(final ConsumerImpl sub,\n                                              final MessageInstance entry,\n                                              final long deliveryTag)\n            {\n                addUnacknowledgedMessage(entry, deliveryTag, null);\n            }\n        };\n\n        ConsumerTarget_0_8 target;\n        EnumSet<ConsumerImpl.Option> options = EnumSet.of(ConsumerImpl.Option.TRANSIENT, ConsumerImpl.Option.ACQUIRES,\n                                                          ConsumerImpl.Option.SEES_REQUEUES);\n        if (acks)\n        {\n\n            target = ConsumerTarget_0_8.createAckTarget(this,\n                                                        AMQShortString.EMPTY_STRING, null,\n                                                        singleMessageCredit, getDeliveryMethod, getRecordMethod);\n        }\n        else\n        {\n            target = ConsumerTarget_0_8.createGetNoAckTarget(this,\n                                                             AMQShortString.EMPTY_STRING, null,\n                                                             singleMessageCredit, getDeliveryMethod, getRecordMethod);\n        }\n\n        ConsumerImpl sub = queue.addConsumer(target, null, AMQMessage.class, \"\", options);\n        sub.flush();\n        sub.close();\n        return getDeliveryMethod.hasDeliveredMessage();\n\n\n    }\n\n    /** Sets this channel to be part of a local transaction */\n    public void setLocalTransactional()\n    {\n        _transaction = new LocalTransaction(_messageStore, new ActivityTimeAccessor()\n        {\n            @Override\n            public long getActivityTime()\n            {\n                return _connection.getLastReceivedTime();\n            }\n        });\n        _txnStarts.incrementAndGet();\n    }\n\n    public boolean isTransactional()\n    {\n        return _transaction.isTransactional();\n    }\n\n    public void receivedComplete()\n    {\n        sync();\n    }\n\n    private void incrementOutstandingTxnsIfNecessary()\n    {\n        if(isTransactional())\n        {\n            //There can currently only be at most one outstanding transaction\n            //due to only having LocalTransaction support. Set value to 1 if 0.\n            _txnCount.compareAndSet(0,1);\n        }\n    }\n\n    private void decrementOutstandingTxnsIfNecessary()\n    {\n        if(isTransactional())\n        {\n            //There can currently only be at most one outstanding transaction\n            //due to only having LocalTransaction support. Set value to 0 if 1.\n            _txnCount.compareAndSet(1,0);\n        }\n    }\n\n    public Long getTxnCommits()\n    {\n        return _txnCommits.get();\n    }\n\n    public Long getTxnRejects()\n    {\n        return _txnRejects.get();\n    }\n\n    public Long getTxnCount()\n    {\n        return _txnCount.get();\n    }\n\n    public Long getTxnStart()\n    {\n        return _txnStarts.get();\n    }\n\n    public int getChannelId()\n    {\n        return _channelId;\n    }\n\n    public void setPublishFrame(MessagePublishInfo info, final MessageDestination e)\n    {\n        String routingKey = info.getRoutingKey() == null ? null : info.getRoutingKey().asString();\n        VirtualHostImpl virtualHost = getVirtualHost();\n        SecurityManager securityManager = virtualHost.getSecurityManager();\n\n        securityManager.authorisePublish(info.isImmediate(), routingKey, e.getName(), virtualHost.getName());\n\n        _currentMessage = new IncomingMessage(info);\n        _currentMessage.setMessageDestination(e);\n    }\n\n    public void publishContentHeader(ContentHeaderBody contentHeaderBody)\n    {\n        if (_logger.isDebugEnabled())\n        {\n            _logger.debug(\"Content header received on channel \" + _channelId);\n        }\n\n        _currentMessage.setContentHeaderBody(contentHeaderBody);\n\n        deliverCurrentMessageIfComplete();\n    }\n\n    private void deliverCurrentMessageIfComplete()\n    {\n        // check and deliver if header says body length is zero\n        if (_currentMessage.allContentReceived())\n        {\n            try\n            {\n\n                final MessageMetaData messageMetaData =\n                        new MessageMetaData(_currentMessage.getMessagePublishInfo(),\n                                            _currentMessage.getContentHeader(),\n                                            getConnection().getLastReceivedTime());\n\n                final StoredMessage<MessageMetaData> handle = _messageStore.addMessage(messageMetaData);\n                final AMQMessage amqMessage = createAMQMessage(_currentMessage, handle);\n                MessageReference reference = amqMessage.newReference();\n                try\n                {\n                    int bodyCount = _currentMessage.getBodyCount();\n                    if(bodyCount > 0)\n                    {\n                        long bodyLengthReceived = 0;\n                        for(int i = 0 ; i < bodyCount ; i++)\n                        {\n                            ContentBody contentChunk = _currentMessage.getContentChunk(i);\n                            handle.addContent((int)bodyLengthReceived, ByteBuffer.wrap(contentChunk.getPayload()));\n                            bodyLengthReceived += contentChunk.getSize();\n                        }\n                    }\n\n                    if(!checkMessageUserId(_currentMessage.getContentHeader()))\n                    {\n                        _transaction.addPostTransactionAction(new WriteReturnAction(AMQConstant.ACCESS_REFUSED, \"Access Refused\", amqMessage));\n                    }\n                    else\n                    {\n                        final boolean immediate = _currentMessage.getMessagePublishInfo().isImmediate();\n\n                        final InstanceProperties instanceProperties =\n                                new InstanceProperties()\n                                {\n                                    @Override\n                                    public Object getProperty(final Property prop)\n                                    {\n                                        switch(prop)\n                                        {\n                                            case EXPIRATION:\n                                                return amqMessage.getExpiration();\n                                            case IMMEDIATE:\n                                                return immediate;\n                                            case PERSISTENT:\n                                                return amqMessage.isPersistent();\n                                            case MANDATORY:\n                                                return _currentMessage.getMessagePublishInfo().isMandatory();\n                                            case REDELIVERED:\n                                                return false;\n                                        }\n                                        return null;\n                                    }\n                                };\n\n                        int enqueues = _currentMessage.getDestination().send(amqMessage,\n                                                                             amqMessage.getInitialRoutingAddress(),\n                                                                             instanceProperties, _transaction,\n                                                                          immediate ? _immediateAction : _capacityCheckAction\n                                                                            );\n                        if(enqueues == 0)\n                        {\n                            handleUnroutableMessage(amqMessage);\n                        }\n                        else\n                        {\n                            incrementOutstandingTxnsIfNecessary();\n                        }\n                    }\n                }\n                finally\n                {\n                    reference.release();\n                }\n\n            }\n            finally\n            {\n                long bodySize = _currentMessage.getSize();\n                long timestamp = _currentMessage.getContentHeader().getProperties().getTimestamp();\n                _connection.registerMessageReceived(bodySize, timestamp);\n                _currentMessage = null;\n            }\n        }\n\n    }\n\n    /**\n     * Either throws a {@link AMQConnectionException} or returns the message\n     *\n     * Pre-requisite: the current message is judged to have no destination queues.\n     *\n     * @throws AMQConnectionException if the message is mandatory close-on-no-route\n     * @see AMQProtocolEngine#isCloseWhenNoRoute()\n     */\n    private void handleUnroutableMessage(AMQMessage message)\n    {\n        boolean mandatory = message.isMandatory();\n        String description = currentMessageDescription();\n        boolean closeOnNoRoute = _connection.isCloseWhenNoRoute();\n\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(String.format(\n                    \"Unroutable message %s, mandatory=%s, transactionalSession=%s, closeOnNoRoute=%s\",\n                    description, mandatory, isTransactional(), closeOnNoRoute));\n        }\n\n        if (mandatory && isTransactional() && _connection.isCloseWhenNoRoute())\n        {\n            _connection.closeConnection(AMQConstant.NO_ROUTE,\n                    \"No route for message \" + currentMessageDescription(), _channelId);\n        }\n        else\n        {\n            if (mandatory || message.isImmediate())\n            {\n                _transaction.addPostTransactionAction(new WriteReturnAction(AMQConstant.NO_ROUTE,\n                                                                            \"No Route for message \"\n                                                                            + currentMessageDescription(),\n                                                                            message));\n            }\n            else\n            {\n                AMQShortString exchangeName = _currentMessage.getExchangeName();\n                AMQShortString routingKey = _currentMessage.getMessagePublishInfo().getRoutingKey();\n\n                getVirtualHost().getEventLogger().message(\n                        ExchangeMessages.DISCARDMSG(exchangeName == null ? null : exchangeName.asString(),\n                                                    routingKey == null ? null : routingKey.asString()));\n            }\n        }\n    }\n\n    private String currentMessageDescription()\n    {\n        if(_currentMessage == null || !_currentMessage.allContentReceived())\n        {\n            throw new IllegalStateException(\"Cannot create message description for message: \" + _currentMessage);\n        }\n\n        return String.format(\n                \"[Exchange: %s, Routing key: %s]\",\n                _currentMessage.getExchangeName(),\n                _currentMessage.getMessagePublishInfo().getRoutingKey() == null\n                        ? null\n                        : _currentMessage.getMessagePublishInfo().getRoutingKey().toString());\n    }\n\n    public void publishContentBody(ContentBody contentBody)\n    {\n        if (_logger.isDebugEnabled())\n        {\n            _logger.debug(debugIdentity() + \" content body received on channel \" + _channelId);\n        }\n\n        try\n        {\n            _currentMessage.addContentBodyFrame(contentBody);\n\n            deliverCurrentMessageIfComplete();\n        }\n        catch (RuntimeException e)\n        {\n            // we want to make sure we don't keep a reference to the message in the\n            // event of an error\n            _currentMessage = null;\n            throw e;\n        }\n    }\n\n    public long getNextDeliveryTag()\n    {\n        return ++_deliveryTag;\n    }\n\n    public int getNextConsumerTag()\n    {\n        return ++_consumerTag;\n    }\n\n\n    public ConsumerTarget getSubscription(AMQShortString tag)\n    {\n        return _tag2SubscriptionTargetMap.get(tag);\n    }\n\n    /**\n     * Subscribe to a queue. We register all subscriptions in the channel so that if the channel is closed we can clean\n     * up all subscriptions, even if the client does not explicitly unsubscribe from all queues.\n     *\n     *\n     * @param tag       the tag chosen by the client (if null, server will generate one)\n     * @param sources     the queues to subscribe to\n     * @param acks      Are acks enabled for this subscriber\n     * @param filters   Filters to apply to this subscriber\n     *\n     * @param exclusive Flag requesting exclusive access to the queue\n     * @return the consumer tag. This is returned to the subscriber and used in subsequent unsubscribe requests\n     *\n     * @throws org.apache.qpid.AMQException                  if something goes wrong\n     */\n    public AMQShortString consumeFromSource(AMQShortString tag, Collection<MessageSource> sources, boolean acks,\n                                            FieldTable filters, boolean exclusive, boolean noLocal)\n            throws MessageSource.ExistingConsumerPreventsExclusive,\n                   MessageSource.ExistingExclusiveConsumer,\n                   AMQInvalidArgumentException,\n                   MessageSource.ConsumerAccessRefused, ConsumerTagInUseException\n    {\n        if (tag == null)\n        {\n            tag = new AMQShortString(\"sgen_\" + getNextConsumerTag());\n        }\n\n        if (_tag2SubscriptionTargetMap.containsKey(tag))\n        {\n            throw new ConsumerTagInUseException(\"Consumer already exists with same tag: \" + tag);\n        }\n\n        ConsumerTarget_0_8 target;\n        EnumSet<ConsumerImpl.Option> options = EnumSet.noneOf(ConsumerImpl.Option.class);\n\n        if(filters != null && Boolean.TRUE.equals(filters.get(AMQPFilterTypes.NO_CONSUME.getValue())))\n        {\n            target = ConsumerTarget_0_8.createBrowserTarget(this, tag, filters, _creditManager);\n        }\n        else if(acks)\n        {\n            target = ConsumerTarget_0_8.createAckTarget(this, tag, filters, _creditManager);\n            options.add(ConsumerImpl.Option.ACQUIRES);\n            options.add(ConsumerImpl.Option.SEES_REQUEUES);\n        }\n        else\n        {\n            target = ConsumerTarget_0_8.createNoAckTarget(this, tag, filters, _creditManager);\n            options.add(ConsumerImpl.Option.ACQUIRES);\n            options.add(ConsumerImpl.Option.SEES_REQUEUES);\n        }\n\n        if(exclusive)\n        {\n            options.add(ConsumerImpl.Option.EXCLUSIVE);\n        }\n\n\n        // So to keep things straight we put before the call and catch all exceptions from the register and tidy up.\n        // We add before we register as the Async Delivery process may AutoClose the subscriber\n        // so calling _cT2QM.remove before we have done put which was after the register succeeded.\n        // So to keep things straight we put before the call and catch all exceptions from the register and tidy up.\n\n        _tag2SubscriptionTargetMap.put(tag, target);\n\n        try\n        {\n            FilterManager filterManager = FilterManagerFactory.createManager(FieldTable.convertToMap(filters));\n            if(noLocal)\n            {\n                if(filterManager == null)\n                {\n                    filterManager = new SimpleFilterManager();\n                }\n                final Object connectionReference = getConnectionReference();\n                filterManager.add(new MessageFilter()\n                {\n                    @Override\n                    public boolean matches(final Filterable message)\n                    {\n                        return message.getConnectionReference() != connectionReference;\n                    }\n                });\n            }\n            for(MessageSource source : sources)\n            {\n                ConsumerImpl sub =\n                        source.addConsumer(target,\n                                           filterManager,\n                                           AMQMessage.class,\n                                           AMQShortString.toString(tag),\n                                           options);\n                if (sub instanceof Consumer<?>)\n                {\n                    final Consumer<?> modelConsumer = (Consumer<?>) sub;\n                    consumerAdded(modelConsumer);\n                    modelConsumer.addChangeListener(_consumerClosedListener);\n                    _consumers.add(modelConsumer);\n                }\n            }\n        }\n        catch (AccessControlException\n                | MessageSource.ExistingExclusiveConsumer\n                | MessageSource.ExistingConsumerPreventsExclusive\n                | AMQInvalidArgumentException\n                | MessageSource.ConsumerAccessRefused e)\n        {\n            _tag2SubscriptionTargetMap.remove(tag);\n            throw e;\n        }\n        return tag;\n    }\n\n    /**\n     * Unsubscribe a consumer from a queue.\n     * @param consumerTag\n     * @return true if the consumerTag had a mapped queue that could be unregistered.\n     */\n    public boolean unsubscribeConsumer(AMQShortString consumerTag)\n    {\n\n        ConsumerTarget_0_8 target = _tag2SubscriptionTargetMap.remove(consumerTag);\n        Collection<ConsumerImpl> subs = target == null ? null : target.getConsumers();\n        if (subs != null)\n        {\n            for(ConsumerImpl sub : subs)\n            {\n                sub.close();\n                if (sub instanceof Consumer<?>)\n                {\n                    _consumers.remove(sub);\n                }\n            }\n            return true;\n        }\n        else\n        {\n            _logger.warn(\"Attempt to unsubscribe consumer with tag '\" + consumerTag + \"' which is not registered.\");\n        }\n        return false;\n    }\n\n    /**\n     * Called from the protocol session to close this channel and clean up. T\n     */\n    @Override\n    public void close()\n    {\n        close(null, null);\n    }\n\n    public void close(AMQConstant cause, String message)\n    {\n        if(!_closing.compareAndSet(false, true))\n        {\n            //Channel is already closing\n            return;\n        }\n\n        LogMessage operationalLogMessage = cause == null ?\n                ChannelMessages.CLOSE() :\n                ChannelMessages.CLOSE_FORCED(cause.getCode(), message);\n        getVirtualHost().getEventLogger().message(_logSubject, operationalLogMessage);\n\n        unsubscribeAllConsumers();\n\n        for (Action<? super AMQChannel> task : _taskList)\n        {\n            task.performAction(this);\n        }\n\n\n        _transaction.rollback();\n\n        try\n        {\n            requeue();\n        }\n        catch (TransportException e)\n        {\n            _logger.error(\"Caught TransportException whilst attempting to requeue:\" + e);\n        }\n    }\n\n    private void unsubscribeAllConsumers()\n    {\n        if (_logger.isInfoEnabled())\n        {\n            if (!_tag2SubscriptionTargetMap.isEmpty())\n            {\n                _logger.info(\"Unsubscribing all consumers on channel \" + toString());\n            }\n            else\n            {\n                _logger.info(\"No consumers to unsubscribe on channel \" + toString());\n            }\n        }\n\n        for (Map.Entry<AMQShortString, ConsumerTarget_0_8> me : _tag2SubscriptionTargetMap.entrySet())\n        {\n            if (_logger.isInfoEnabled())\n            {\n                _logger.info(\"Unsubscribing consumer '\" + me.getKey() + \"' on channel \" + toString());\n            }\n\n            Collection<ConsumerImpl> subs = me.getValue().getConsumers();\n\n            if(subs != null)\n            {\n                for(ConsumerImpl sub : subs)\n                {\n                    sub.close();\n                }\n            }\n        }\n\n        _tag2SubscriptionTargetMap.clear();\n    }\n\n    /**\n     * Add a message to the channel-based list of unacknowledged messages\n     *\n     * @param entry       the record of the message on the queue that was delivered\n     * @param deliveryTag the delivery tag used when delivering the message (see protocol spec for description of the\n     *                    delivery tag)\n     * @param consumer The consumer that is to acknowledge this message.\n     */\n    public void addUnacknowledgedMessage(MessageInstance entry, long deliveryTag, ConsumerImpl consumer)\n    {\n        if (_logger.isDebugEnabled())\n        {\n                    _logger.debug(debugIdentity() + \" Adding unacked message(\" + entry.getMessage().toString() + \" DT:\" + deliveryTag\n                               + \") for \" + consumer + \" on \" + entry.getOwningResource().getName());\n\n        }\n\n        _unacknowledgedMessageMap.add(deliveryTag, entry);\n\n    }\n\n    private final String id = \"(\" + System.identityHashCode(this) + \")\";\n\n    public String debugIdentity()\n    {\n        return _channelId + id;\n    }\n\n    /**\n     * Called to attempt re-delivery all outstanding unacknowledged messages on the channel. May result in delivery to\n     * this same channel or to other subscribers.\n     *\n     */\n    public void requeue()\n    {\n        // we must create a new map since all the messages will get a new delivery tag when they are redelivered\n        Collection<MessageInstance> messagesToBeDelivered = _unacknowledgedMessageMap.cancelAllMessages();\n\n        if (!messagesToBeDelivered.isEmpty())\n        {\n            if (_logger.isInfoEnabled())\n            {\n                _logger.info(\"Requeuing \" + messagesToBeDelivered.size() + \" unacked messages. for \" + toString());\n            }\n\n        }\n\n        for (MessageInstance unacked : messagesToBeDelivered)\n        {\n            // Mark message redelivered\n            unacked.setRedelivered();\n\n            // Ensure message is released for redelivery\n            unacked.release();\n        }\n\n    }\n\n    /**\n     * Requeue a single message\n     *\n     * @param deliveryTag The message to requeue\n     *\n     */\n    public void requeue(long deliveryTag)\n    {\n        MessageInstance unacked = _unacknowledgedMessageMap.remove(deliveryTag);\n\n        if (unacked != null)\n        {\n            // Mark message redelivered\n            unacked.setRedelivered();\n\n            // Ensure message is released for redelivery\n            unacked.release();\n\n        }\n        else\n        {\n            _logger.warn(\"Requested requeue of message:\" + deliveryTag + \" but no such delivery tag exists.\"\n                      + _unacknowledgedMessageMap.size());\n\n        }\n\n    }\n\n    public boolean isMaxDeliveryCountEnabled(final long deliveryTag)\n    {\n        final MessageInstance queueEntry = _unacknowledgedMessageMap.get(deliveryTag);\n        if (queueEntry != null)\n        {\n            final int maximumDeliveryCount = queueEntry.getMaximumDeliveryCount();\n            return maximumDeliveryCount > 0;\n        }\n\n        return false;\n    }\n\n    public boolean isDeliveredTooManyTimes(final long deliveryTag)\n    {\n        final MessageInstance queueEntry = _unacknowledgedMessageMap.get(deliveryTag);\n        if (queueEntry != null)\n        {\n            final int maximumDeliveryCount = queueEntry.getMaximumDeliveryCount();\n            final int numDeliveries = queueEntry.getDeliveryCount();\n            return maximumDeliveryCount != 0 && numDeliveries >= maximumDeliveryCount;\n        }\n\n        return false;\n    }\n\n    /**\n     * Called to resend all outstanding unacknowledged messages to this same channel.\n     *\n     */\n    public void resend()\n    {\n\n\n        final Map<Long, MessageInstance> msgToRequeue = new LinkedHashMap<Long, MessageInstance>();\n        final Map<Long, MessageInstance> msgToResend = new LinkedHashMap<Long, MessageInstance>();\n\n        if (_logger.isDebugEnabled())\n        {\n            _logger.debug(\"unacked map Size:\" + _unacknowledgedMessageMap.size());\n        }\n\n        // Process the Unacked-Map.\n        // Marking messages who still have a consumer for to be resent\n        // and those that don't to be requeued.\n        _unacknowledgedMessageMap.visit(new ExtractResendAndRequeue(_unacknowledgedMessageMap,\n                                                                    msgToRequeue,\n                                                                    msgToResend\n        ));\n\n\n        // Process Messages to Resend\n        if (_logger.isDebugEnabled())\n        {\n            if (!msgToResend.isEmpty())\n            {\n                _logger.debug(\"Preparing (\" + msgToResend.size() + \") message to resend.\");\n            }\n            else\n            {\n                _logger.debug(\"No message to resend.\");\n            }\n        }\n\n        for (Map.Entry<Long, MessageInstance> entry : msgToResend.entrySet())\n        {\n            MessageInstance message = entry.getValue();\n            long deliveryTag = entry.getKey();\n\n            //Amend the delivery counter as the client hasn't seen these messages yet.\n            message.decrementDeliveryCount();\n\n            // Without any details from the client about what has been processed we have to mark\n            // all messages in the unacked map as redelivered.\n            message.setRedelivered();\n\n            if (!message.resend())\n            {\n                msgToRequeue.put(deliveryTag, message);\n            }\n        } // for all messages\n        // } else !isSuspend\n\n        if (_logger.isInfoEnabled())\n        {\n            if (!msgToRequeue.isEmpty())\n            {\n                _logger.info(\"Preparing (\" + msgToRequeue.size() + \") message to requeue to.\");\n            }\n        }\n\n        // Process Messages to Requeue at the front of the queue\n        for (Map.Entry<Long, MessageInstance> entry : msgToRequeue.entrySet())\n        {\n            MessageInstance message = entry.getValue();\n            long deliveryTag = entry.getKey();\n\n            //Amend the delivery counter as the client hasn't seen these messages yet.\n            message.decrementDeliveryCount();\n\n            _unacknowledgedMessageMap.remove(deliveryTag);\n\n            message.setRedelivered();\n            message.release();\n\n        }\n    }\n\n\n    /**\n     * Acknowledge one or more messages.\n     *\n     * @param deliveryTag the last delivery tag\n     * @param multiple    if true will acknowledge all messages up to an including the delivery tag. if false only\n     *                    acknowledges the single message specified by the delivery tag\n     *\n     */\n    public void acknowledgeMessage(long deliveryTag, boolean multiple)\n    {\n        Collection<MessageInstance> ackedMessages = getAckedMessages(deliveryTag, multiple);\n        _transaction.dequeue(ackedMessages, new MessageAcknowledgeAction(ackedMessages));\n    }\n\n    private Collection<MessageInstance> getAckedMessages(long deliveryTag, boolean multiple)\n    {\n\n        return _unacknowledgedMessageMap.acknowledge(deliveryTag, multiple);\n\n    }\n\n    /**\n     * Used only for testing purposes.\n     *\n     * @return the map of unacknowledged messages\n     */\n    public UnacknowledgedMessageMap getUnacknowledgedMessageMap()\n    {\n        return _unacknowledgedMessageMap;\n    }\n\n    /**\n     * Called from the ChannelFlowHandler to suspend this Channel\n     * @param suspended boolean, should this Channel be suspended\n     */\n    public void setSuspended(boolean suspended)\n    {\n        boolean wasSuspended = _suspended.getAndSet(suspended);\n        if (wasSuspended != suspended)\n        {\n            // Log Flow Started before we start the subscriptions\n            if (!suspended)\n            {\n                getVirtualHost().getEventLogger().message(_logSubject, ChannelMessages.FLOW(\"Started\"));\n            }\n\n\n            // This section takes two different approaches to perform to perform\n            // the same function. Ensuring that the Subscription has taken note\n            // of the change in Channel State\n\n            // Here we have become unsuspended and so we ask each the queue to\n            // perform an Async delivery for each of the subscriptions in this\n            // Channel. The alternative would be to ensure that the subscription\n            // had received the change in suspension state. That way the logic\n            // behind deciding to start an async delivery was located with the\n            // Subscription.\n            if (wasSuspended)\n            {\n                // may need to deliver queued messages\n                for (ConsumerTarget_0_8 s : _tag2SubscriptionTargetMap.values())\n                {\n                    for(ConsumerImpl sub : s.getConsumers())\n                    {\n                        sub.externalStateChange();\n                    }\n                }\n            }\n\n\n            // Here we have become suspended so we need to ensure that each of\n            // the Subscriptions has noticed this change so that we can be sure\n            // they are not still sending messages. Again the code here is a\n            // very simplistic approach to ensure that the change of suspension\n            // has been noticed by each of the Subscriptions. Unlike the above\n            // case we don't actually need to do anything else.\n            if (!wasSuspended)\n            {\n                // may need to deliver queued messages\n                for (ConsumerTarget_0_8 s : _tag2SubscriptionTargetMap.values())\n                {\n                    try\n                    {\n                        s.getSendLock();\n                    }\n                    finally\n                    {\n                        s.releaseSendLock();\n                    }\n                }\n            }\n\n\n            // Log Suspension only after we have confirmed all suspensions are\n            // stopped.\n            if (suspended)\n            {\n                getVirtualHost().getEventLogger().message(_logSubject, ChannelMessages.FLOW(\"Stopped\"));\n            }\n\n        }\n    }\n\n    public boolean isSuspended()\n    {\n        return _suspended.get()  || _closing.get() || _connection.isClosing();\n    }\n\n\n    public void commit(final Runnable immediateAction, boolean async)\n    {\n\n\n        if(async && _transaction instanceof LocalTransaction)\n        {\n\n            ((LocalTransaction)_transaction).commitAsync(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    try\n                    {\n                        immediateAction.run();\n                    }\n                    finally\n                    {\n                        _txnCommits.incrementAndGet();\n                        _txnStarts.incrementAndGet();\n                        decrementOutstandingTxnsIfNecessary();\n                    }\n                }\n            });\n        }\n        else\n        {\n            _transaction.commit(immediateAction);\n\n            _txnCommits.incrementAndGet();\n            _txnStarts.incrementAndGet();\n            decrementOutstandingTxnsIfNecessary();\n        }\n    }\n\n    public void rollback(Runnable postRollbackTask)\n    {\n\n        // stop all subscriptions\n        _rollingBack = true;\n        boolean requiresSuspend = _suspended.compareAndSet(false,true);\n\n        // ensure all subscriptions have seen the change to the channel state\n        for(ConsumerTarget_0_8 sub : _tag2SubscriptionTargetMap.values())\n        {\n            sub.getSendLock();\n            sub.releaseSendLock();\n        }\n\n        try\n        {\n            _transaction.rollback();\n        }\n        finally\n        {\n            _rollingBack = false;\n\n            _txnRejects.incrementAndGet();\n            _txnStarts.incrementAndGet();\n            decrementOutstandingTxnsIfNecessary();\n        }\n\n        postRollbackTask.run();\n\n        for(MessageInstance entry : _resendList)\n        {\n            ConsumerImpl sub = entry.getDeliveredConsumer();\n            if(sub == null || sub.isClosed())\n            {\n                entry.release();\n            }\n            else\n            {\n                entry.resend();\n            }\n        }\n        _resendList.clear();\n\n        if(requiresSuspend)\n        {\n            _suspended.set(false);\n            for(ConsumerTarget_0_8 target : _tag2SubscriptionTargetMap.values())\n            {\n                for(ConsumerImpl sub : target.getConsumers())\n                {\n                    sub.externalStateChange();\n                }\n            }\n\n        }\n    }\n\n    public String toString()\n    {\n        return \"(\"+ _suspended.get() + \", \" + _closing.get() + \", \" + _connection.isClosing() + \") \"+\"[\"+ _connection.toString()+\":\"+_channelId+\"]\";\n    }\n\n    public void setDefaultQueue(AMQQueue queue)\n    {\n        _defaultQueue = queue;\n    }\n\n    public AMQQueue getDefaultQueue()\n    {\n        return _defaultQueue;\n    }\n\n\n    public boolean isClosing()\n    {\n        return _closing.get();\n    }\n\n    public AMQProtocolEngine getConnection()\n    {\n        return _connection;\n    }\n\n    public FlowCreditManager getCreditManager()\n    {\n        return _creditManager;\n    }\n\n    public void setCredit(final long prefetchSize, final int prefetchCount)\n    {\n        getVirtualHost().getEventLogger().message(ChannelMessages.PREFETCH_SIZE(prefetchSize, prefetchCount));\n        _creditManager.setCreditLimits(prefetchSize, prefetchCount);\n    }\n\n    public MessageStore getMessageStore()\n    {\n        return _messageStore;\n    }\n\n    public ClientDeliveryMethod getClientDeliveryMethod()\n    {\n        return _clientDeliveryMethod;\n    }\n\n    private final RecordDeliveryMethod _recordDeliveryMethod = new RecordDeliveryMethod()\n        {\n\n            public void recordMessageDelivery(final ConsumerImpl sub, final MessageInstance entry, final long deliveryTag)\n            {\n                addUnacknowledgedMessage(entry, deliveryTag, sub);\n            }\n        };\n\n    public RecordDeliveryMethod getRecordDeliveryMethod()\n    {\n        return _recordDeliveryMethod;\n    }\n\n\n    private AMQMessage createAMQMessage(IncomingMessage incomingMessage, StoredMessage<MessageMetaData> handle)\n    {\n\n        AMQMessage message = new AMQMessage(handle, _connection.getReference());\n\n        return message;\n    }\n\n    private boolean checkMessageUserId(ContentHeaderBody header)\n    {\n        AMQShortString userID = header.getProperties().getUserId();\n        return (!_messageAuthorizationRequired || _connection.getAuthorizedPrincipal().getName().equals(userID == null? \"\" : userID.toString()));\n\n    }\n\n    @Override\n    public UUID getId()\n    {\n        return _id;\n    }\n\n    @Override\n    public AMQProtocolEngine getConnectionModel()\n    {\n        return _connection;\n    }\n\n    public String getClientID()\n    {\n        return String.valueOf(_connection.getContextKey());\n    }\n\n    public LogSubject getLogSubject()\n    {\n        return _logSubject;\n    }\n\n    @Override\n    public int compareTo(AMQChannel o)\n    {\n        return getId().compareTo(o.getId());\n    }\n\n    @Override\n    public void addDeleteTask(final Action<? super AMQChannel> task)\n    {\n        _taskList.add(task);\n    }\n\n    @Override\n    public void removeDeleteTask(final Action<? super AMQChannel> task)\n    {\n        _taskList.remove(task);\n    }\n\n    public Subject getSubject()\n    {\n        return _subject;\n    }\n\n    public boolean hasCurrentMessage()\n    {\n        return _currentMessage != null;\n    }\n\n    private class GetDeliveryMethod implements ClientDeliveryMethod\n    {\n\n        private final FlowCreditManager _singleMessageCredit;\n        private final AMQQueue _queue;\n        private boolean _deliveredMessage;\n\n        public GetDeliveryMethod(final FlowCreditManager singleMessageCredit,\n                                 final AMQQueue queue)\n        {\n            _singleMessageCredit = singleMessageCredit;\n            _queue = queue;\n        }\n\n        @Override\n        public long deliverToClient(final ConsumerImpl sub, final ServerMessage message,\n                                    final InstanceProperties props, final long deliveryTag)\n        {\n            _singleMessageCredit.useCreditForMessage(message.getSize());\n            long size = _connection.getProtocolOutputConverter().writeGetOk(message,\n                                                                            props,\n                                                                            AMQChannel.this.getChannelId(),\n                                                                            deliveryTag,\n                                                                            _queue.getQueueDepthMessages());\n\n            _deliveredMessage = true;\n            return size;\n        }\n\n        public boolean hasDeliveredMessage()\n        {\n            return _deliveredMessage;\n        }\n    }\n\n\n    private class ImmediateAction implements Action<MessageInstance>\n    {\n\n        public ImmediateAction()\n        {\n        }\n\n        public void performAction(MessageInstance entry)\n        {\n            TransactionLogResource queue = entry.getOwningResource();\n\n            if (!entry.getDeliveredToConsumer() && entry.acquire())\n            {\n\n                ServerTransaction txn = new LocalTransaction(_messageStore);\n                final AMQMessage message = (AMQMessage) entry.getMessage();\n                MessageReference ref = message.newReference();\n                try\n                {\n                    entry.delete();\n                    txn.dequeue(queue, message,\n                                new ServerTransaction.Action()\n                                {\n                                    @Override\n                                    public void postCommit()\n                                    {\n                                        final ProtocolOutputConverter outputConverter =\n                                                    _connection.getProtocolOutputConverter();\n\n                                        outputConverter.writeReturn(message.getMessagePublishInfo(),\n                                                                    message.getContentHeaderBody(),\n                                                                    message,\n                                                                    _channelId,\n                                                                    AMQConstant.NO_CONSUMERS.getCode(),\n                                                                    IMMEDIATE_DELIVERY_REPLY_TEXT);\n\n                                    }\n\n                                    @Override\n                                    public void onRollback()\n                                    {\n\n                                    }\n                                }\n                               );\n                    txn.commit();\n                }\n                finally\n                {\n                    ref.release();\n                }\n\n\n            }\n            else\n            {\n                if(queue instanceof CapacityChecker)\n                {\n                    ((CapacityChecker)queue).checkCapacity(AMQChannel.this);\n                }\n            }\n\n        }\n    }\n\n    private final class CapacityCheckAction implements Action<MessageInstance>\n    {\n        @Override\n        public void performAction(final MessageInstance entry)\n        {\n            TransactionLogResource queue = entry.getOwningResource();\n            if(queue instanceof CapacityChecker)\n            {\n                ((CapacityChecker)queue).checkCapacity(AMQChannel.this);\n            }\n        }\n    }\n\n    private class MessageAcknowledgeAction implements ServerTransaction.Action\n    {\n        private final Collection<MessageInstance> _ackedMessages;\n\n        public MessageAcknowledgeAction(Collection<MessageInstance> ackedMessages)\n        {\n            _ackedMessages = ackedMessages;\n        }\n\n        public void postCommit()\n        {\n            try\n            {\n                for(MessageInstance entry : _ackedMessages)\n                {\n                    entry.delete();\n                }\n            }\n            finally\n            {\n                _ackedMessages.clear();\n            }\n\n        }\n\n        public void onRollback()\n        {\n            // explicit rollbacks resend the message after the rollback-ok is sent\n            if(_rollingBack)\n            {\n                for(MessageInstance entry : _ackedMessages)\n                {\n                    entry.unlockAcquisition();\n                }\n                _resendList.addAll(_ackedMessages);\n            }\n            else\n            {\n                try\n                {\n                    for(MessageInstance entry : _ackedMessages)\n                    {\n                        entry.release();\n                    }\n                }\n                finally\n                {\n                    _ackedMessages.clear();\n                }\n            }\n\n        }\n    }\n\n    private class WriteReturnAction implements ServerTransaction.Action\n    {\n        private final AMQConstant _errorCode;\n        private final String _description;\n        private final MessageReference<AMQMessage> _reference;\n\n        public WriteReturnAction(AMQConstant errorCode,\n                                 String description,\n                                 AMQMessage message)\n        {\n            _errorCode = errorCode;\n            _description = description;\n            _reference = message.newReference();\n        }\n\n        public void postCommit()\n        {\n            AMQMessage message = _reference.getMessage();\n            _connection.getProtocolOutputConverter().writeReturn(message.getMessagePublishInfo(),\n                                                          message.getContentHeaderBody(),\n                                                          message,\n                                                          _channelId,\n                                                          _errorCode.getCode(),\n                                                          AMQShortString.validValueOf(_description));\n            _reference.release();\n        }\n\n        public void onRollback()\n        {\n            _reference.release();\n        }\n    }\n\n    public synchronized void block()\n    {\n        if(_blockingEntities.add(this))\n        {\n            if(_blocking.compareAndSet(false,true))\n            {\n                getVirtualHost().getEventLogger().message(_logSubject,\n                                                          ChannelMessages.FLOW_ENFORCED(\"** All Queues **\"));\n                flow(false);\n            }\n        }\n    }\n\n    public synchronized void unblock()\n    {\n        if(_blockingEntities.remove(this))\n        {\n            if(_blockingEntities.isEmpty() && _blocking.compareAndSet(true,false))\n            {\n                getVirtualHost().getEventLogger().message(_logSubject, ChannelMessages.FLOW_REMOVED());\n\n                flow(true);\n            }\n        }\n    }\n\n    public synchronized void block(AMQQueue queue)\n    {\n        if(_blockingEntities.add(queue))\n        {\n\n            if(_blocking.compareAndSet(false,true))\n            {\n                getVirtualHost().getEventLogger().message(_logSubject, ChannelMessages.FLOW_ENFORCED(queue.getName()));\n                flow(false);\n            }\n        }\n    }\n\n    public synchronized void unblock(AMQQueue queue)\n    {\n        if(_blockingEntities.remove(queue))\n        {\n            if(_blockingEntities.isEmpty() && _blocking.compareAndSet(true,false) && !isClosing())\n            {\n                getVirtualHost().getEventLogger().message(_logSubject, ChannelMessages.FLOW_REMOVED());\n                flow(true);\n            }\n        }\n    }\n\n    @Override\n    public Object getConnectionReference()\n    {\n        return getConnection().getReference();\n    }\n\n    public int getUnacknowledgedMessageCount()\n    {\n        return getUnacknowledgedMessageMap().size();\n    }\n\n    private void flow(boolean flow)\n    {\n        MethodRegistry methodRegistry = _connection.getMethodRegistry();\n        AMQMethodBody responseBody = methodRegistry.createChannelFlowBody(flow);\n        _connection.writeFrame(responseBody.generateFrame(_channelId));\n    }\n\n    @Override\n    public boolean getBlocking()\n    {\n        return _blocking.get();\n    }\n\n    public VirtualHostImpl getVirtualHost()\n    {\n        return getConnection().getVirtualHost();\n    }\n\n    public void checkTransactionStatus(long openWarn, long openClose, long idleWarn, long idleClose)\n    {\n        _transactionTimeoutHelper.checkIdleOrOpenTimes(_transaction, openWarn, openClose, idleWarn, idleClose);\n    }\n\n    /**\n     * Typically called from the HouseKeepingThread instead of the main receiver thread,\n     * therefore uses a lock to close the connection in a thread-safe manner.\n     */\n    private void closeConnection(String reason) throws AMQException\n    {\n        Lock receivedLock = _connection.getReceivedLock();\n        receivedLock.lock();\n        try\n        {\n            _connection.close(AMQConstant.RESOURCE_ERROR, reason);\n        }\n        finally\n        {\n            receivedLock.unlock();\n        }\n    }\n\n    public void deadLetter(long deliveryTag)\n    {\n        final UnacknowledgedMessageMap unackedMap = getUnacknowledgedMessageMap();\n        final MessageInstance rejectedQueueEntry = unackedMap.remove(deliveryTag);\n\n        if (rejectedQueueEntry == null)\n        {\n            _logger.warn(\"No message found, unable to DLQ delivery tag: \" + deliveryTag);\n        }\n        else\n        {\n            final ServerMessage msg = rejectedQueueEntry.getMessage();\n\n\n            int requeues = rejectedQueueEntry.routeToAlternate(new Action<MessageInstance>()\n                {\n                    @Override\n                    public void performAction(final MessageInstance requeueEntry)\n                    {\n                        getVirtualHost().getEventLogger().message(_logSubject,\n                                                                  ChannelMessages.DEADLETTERMSG(msg.getMessageNumber(),\n                                                                                                requeueEntry.getOwningResource()\n                                                                                                        .getName()));\n                    }\n                }, null);\n\n            if(requeues == 0)\n            {\n\n                final TransactionLogResource owningResource = rejectedQueueEntry.getOwningResource();\n                if(owningResource instanceof AMQQueue)\n                {\n                    final AMQQueue queue = (AMQQueue) owningResource;\n\n                    final Exchange altExchange = queue.getAlternateExchange();\n\n                    if (altExchange == null)\n                    {\n                        _logger.debug(\"No alternate exchange configured for queue, must discard the message as unable to DLQ: delivery tag: \" + deliveryTag);\n                        getVirtualHost().getEventLogger().message(_logSubject,\n                                                                  ChannelMessages.DISCARDMSG_NOALTEXCH(msg.getMessageNumber(),\n                                                                                                       queue.getName(),\n                                                                                                       msg.getInitialRoutingAddress()));\n\n                    }\n                    else\n                    {\n                        _logger.debug(\n                                \"Routing process provided no queues to enqueue the message on, must discard message as unable to DLQ: delivery tag: \"\n                                + deliveryTag);\n                        getVirtualHost().getEventLogger().message(_logSubject,\n                                                                  ChannelMessages.DISCARDMSG_NOROUTE(msg.getMessageNumber(),\n                                                                                                     altExchange.getName()));\n                    }\n                }\n            }\n\n        }\n    }\n\n    public void recordFuture(final StoreFuture future, final ServerTransaction.Action action)\n    {\n        _unfinishedCommandsQueue.add(new AsyncCommand(future, action));\n    }\n\n    public void sync()\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"sync() called on channel \" + debugIdentity());\n        }\n\n        AsyncCommand cmd;\n        while((cmd = _unfinishedCommandsQueue.poll()) != null)\n        {\n            cmd.awaitReadyForCompletion();\n            cmd.complete();\n        }\n        if(_transaction instanceof LocalTransaction)\n        {\n            ((LocalTransaction)_transaction).sync();\n        }\n    }\n\n    private static class AsyncCommand\n    {\n        private final StoreFuture _future;\n        private ServerTransaction.Action _action;\n\n        public AsyncCommand(final StoreFuture future, final ServerTransaction.Action action)\n        {\n            _future = future;\n            _action = action;\n        }\n\n        void awaitReadyForCompletion()\n        {\n            _future.waitForCompletion();\n        }\n\n        void complete()\n        {\n            if(!_future.isComplete())\n            {\n                _future.waitForCompletion();\n            }\n            _action.postCommit();\n            _action = null;\n        }\n    }\n\n    @Override\n    public int getConsumerCount()\n    {\n        return _tag2SubscriptionTargetMap.size();\n    }\n\n    @Override\n    public Collection<Consumer<?>> getConsumers()\n    {\n        return Collections.unmodifiableCollection(_consumers);\n    }\n\n    private class ConsumerClosedListener implements ConfigurationChangeListener\n    {\n        @Override\n        public void stateChanged(final ConfiguredObject object, final State oldState, final State newState)\n        {\n            if(newState == State.DELETED)\n            {\n                consumerRemoved((Consumer<?>)object);\n            }\n        }\n\n        @Override\n        public void childAdded(final ConfiguredObject object, final ConfiguredObject child)\n        {\n\n        }\n\n        @Override\n        public void childRemoved(final ConfiguredObject object, final ConfiguredObject child)\n        {\n\n        }\n\n        @Override\n        public void attributeSet(final ConfiguredObject object,\n                                 final String attributeName,\n                                 final Object oldAttributeValue,\n                                 final Object newAttributeValue)\n        {\n\n        }\n    }\n\n    private void consumerAdded(final Consumer<?> consumer)\n    {\n        for(ConsumerListener l : _consumerListeners)\n        {\n            l.consumerAdded(consumer);\n        }\n    }\n\n    private void consumerRemoved(final Consumer<?> consumer)\n    {\n        for(ConsumerListener l : _consumerListeners)\n        {\n            l.consumerRemoved(consumer);\n        }\n    }\n\n    @Override\n    public void addConsumerListener(ConsumerListener listener)\n    {\n        _consumerListeners.add(listener);\n    }\n\n    @Override\n    public void removeConsumerListener(ConsumerListener listener)\n    {\n        _consumerListeners.remove(listener);\n    }\n\n    @Override\n    public void setModelObject(final Session<?> session)\n    {\n        _modelObject = session;\n    }\n\n    @Override\n    public Session<?> getModelObject()\n    {\n        return _modelObject;\n    }\n\n    @Override\n    public long getTransactionStartTime()\n    {\n        ServerTransaction serverTransaction = _transaction;\n        if (serverTransaction.isTransactional())\n        {\n            return serverTransaction.getTransactionStartTime();\n        }\n        else\n        {\n            return 0L;\n        }\n    }\n\n    @Override\n    public long getTransactionUpdateTime()\n    {\n        ServerTransaction serverTransaction = _transaction;\n        if (serverTransaction.isTransactional())\n        {\n            return serverTransaction.getTransactionUpdateTime();\n        }\n        else\n        {\n            return 0L;\n        }\n    }\n\n    @Override\n    public void receiveAccessRequest(final AMQShortString realm,\n                                     final boolean exclusive,\n                                     final boolean passive,\n                                     final boolean active, final boolean write, final boolean read)\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] AccessRequest[\" +\" realm: \" + realm +\n                          \" exclusive: \" + exclusive +\n                          \" passive: \" + passive +\n                          \" active: \" + active +\n                          \" write: \" + write + \" read: \" + read + \" ]\");\n        }\n\n        MethodRegistry methodRegistry = _connection.getMethodRegistry();\n\n        if (ProtocolVersion.v0_91.equals(_connection.getProtocolVersion()))\n        {\n            _connection.closeConnection(AMQConstant.COMMAND_INVALID,\n                                                    \"AccessRequest not present in AMQP versions other than 0-8, 0-9\",\n                                                    _channelId);\n        }\n        else\n        {\n            // We don't implement access control class, but to keep clients happy that expect it\n            // always use the \"0\" ticket.\n            AccessRequestOkBody response = methodRegistry.createAccessRequestOkBody(0);\n            sync();\n            _connection.writeFrame(response.generateFrame(_channelId));\n        }\n    }\n\n    @Override\n    public void receiveBasicAck(final long deliveryTag, final boolean multiple)\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] BasicAck[\" +\" deliveryTag: \" + deliveryTag + \" multiple: \" + multiple + \" ]\");\n        }\n\n        acknowledgeMessage(deliveryTag, multiple);\n    }\n\n    @Override\n    public void receiveBasicCancel(final AMQShortString consumerTag, final boolean nowait)\n    {\n\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] BasicCancel[\" +\" consumerTag: \" + consumerTag + \" noWait: \" + nowait + \" ]\");\n        }\n\n        unsubscribeConsumer(consumerTag);\n        if (!nowait)\n        {\n            MethodRegistry methodRegistry = _connection.getMethodRegistry();\n            BasicCancelOkBody cancelOkBody = methodRegistry.createBasicCancelOkBody(consumerTag);\n            sync();\n            _connection.writeFrame(cancelOkBody.generateFrame(_channelId));\n        }\n    }\n\n    @Override\n    public void receiveBasicConsume(final AMQShortString queue,\n                                    final AMQShortString consumerTag,\n                                    final boolean noLocal,\n                                    final boolean noAck,\n                                    final boolean exclusive, final boolean nowait, final FieldTable arguments)\n    {\n\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] BasicConsume[\" +\" queue: \" + queue +\n                          \" consumerTag: \" + consumerTag +\n                          \" noLocal: \" + noLocal +\n                          \" noAck: \" + noAck +\n                          \" exclusive: \" + exclusive + \" nowait: \" + nowait + \" arguments: \" + arguments + \" ]\");\n        }\n\n        AMQShortString consumerTag1 = consumerTag;\n        VirtualHostImpl<?, ?, ?> vHost = _connection.getVirtualHost();\n        sync();\n        String queueName = queue == null ? null : queue.asString();\n\n        MessageSource queue1 = queueName == null ? getDefaultQueue() : vHost.getQueue(queueName);\n        final Collection<MessageSource> sources = new HashSet<>();\n        if (queue1 != null)\n        {\n            sources.add(queue1);\n        }\n        else if (vHost.getContextValue(Boolean.class, \"qpid.enableMultiQueueConsumers\")\n                 && arguments != null\n                 && arguments.get(\"x-multiqueue\") instanceof Collection)\n        {\n            for (Object object : (Collection<Object>) arguments.get(\"x-multiqueue\"))\n            {\n                String sourceName = String.valueOf(object);\n                sourceName = sourceName.trim();\n                if (sourceName.length() != 0)\n                {\n                    MessageSource source = vHost.getMessageSource(sourceName);\n                    if (source == null)\n                    {\n                        sources.clear();\n                        break;\n                    }\n                    else\n                    {\n                        sources.add(source);\n                    }\n                }\n            }\n            queueName = arguments.get(\"x-multiqueue\").toString();\n        }\n\n        if (sources.isEmpty())\n        {\n            if (_logger.isDebugEnabled())\n            {\n                _logger.debug(\"No queue for '\" + queueName + \"'\");\n            }\n            if (queueName != null)\n            {\n                closeChannel(AMQConstant.NOT_FOUND, \"No such queue, '\" + queueName + \"'\");\n            }\n            else\n            {\n                _connection.closeConnection(AMQConstant.NOT_ALLOWED,\n                                            \"No queue name provided, no default queue defined.\", _channelId);\n            }\n        }\n        else\n        {\n            try\n            {\n                consumerTag1 = consumeFromSource(consumerTag1,\n                                                 sources,\n                                                 !noAck,\n                                                 arguments,\n                                                 exclusive,\n                                                 noLocal);\n                if (!nowait)\n                {\n                    MethodRegistry methodRegistry = _connection.getMethodRegistry();\n                    AMQMethodBody responseBody = methodRegistry.createBasicConsumeOkBody(consumerTag1);\n                    _connection.writeFrame(responseBody.generateFrame(_channelId));\n\n                }\n            }\n            catch (ConsumerTagInUseException cte)\n            {\n\n                _connection.closeConnection(AMQConstant.NOT_ALLOWED,\n                                            \"Non-unique consumer tag, '\" + consumerTag1\n                                            + \"'\", _channelId);\n            }\n            catch (AMQInvalidArgumentException ise)\n            {\n                _connection.closeConnection(AMQConstant.ARGUMENT_INVALID, ise.getMessage(), _channelId);\n\n\n            }\n            catch (AMQQueue.ExistingExclusiveConsumer e)\n            {\n                _connection.closeConnection(AMQConstant.ACCESS_REFUSED,\n                                            \"Cannot subscribe to queue \"\n                                                                    + queue1.getName()\n                                                                    + \" as it already has an existing exclusive consumer\", _channelId);\n\n            }\n            catch (AMQQueue.ExistingConsumerPreventsExclusive e)\n            {\n                _connection.closeConnection(AMQConstant.ACCESS_REFUSED,\n                                            \"Cannot subscribe to queue \"\n                                                                    + queue1.getName()\n                                                                    + \" exclusively as it already has a consumer\", _channelId);\n\n            }\n            catch (AccessControlException e)\n            {\n                _connection.closeConnection(AMQConstant.ACCESS_REFUSED, \"Cannot subscribe to queue \"\n                                                                    + queue1.getName()\n                                                                    + \" permission denied\", _channelId);\n\n            }\n            catch (MessageSource.ConsumerAccessRefused consumerAccessRefused)\n            {\n                _connection.closeConnection(AMQConstant.ACCESS_REFUSED,\n                                            \"Cannot subscribe to queue \"\n                                                                    + queue1.getName()\n                                                                    + \" as it already has an incompatible exclusivity policy\", _channelId);\n\n            }\n\n        }\n    }\n\n    @Override\n    public void receiveBasicGet(final AMQShortString queueName, final boolean noAck)\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] BasicGet[\" +\" queue: \" + queueName + \" noAck: \" + noAck + \" ]\");\n        }\n\n        VirtualHostImpl vHost = _connection.getVirtualHost();\n        sync();\n        AMQQueue queue = queueName == null ? getDefaultQueue() : vHost.getQueue(queueName.toString());\n        if (queue == null)\n        {\n            _logger.info(\"No queue for '\" + queueName + \"'\");\n            if (queueName != null)\n            {\n                _connection.closeConnection(AMQConstant.NOT_FOUND, \"No such queue, '\" + queueName + \"'\", _channelId);\n\n            }\n            else\n            {\n                _connection.closeConnection(AMQConstant.NOT_ALLOWED,\n                                            \"No queue name provided, no default queue defined.\", _channelId);\n\n            }\n        }\n        else\n        {\n\n            try\n            {\n                if (!performGet(queue, !noAck))\n                {\n                    MethodRegistry methodRegistry = _connection.getMethodRegistry();\n\n                    BasicGetEmptyBody responseBody = methodRegistry.createBasicGetEmptyBody(null);\n\n                    _connection.writeFrame(responseBody.generateFrame(_channelId));\n                }\n            }\n            catch (AccessControlException e)\n            {\n                _connection.closeConnection(AMQConstant.ACCESS_REFUSED, e.getMessage(), _channelId);\n            }\n            catch (MessageSource.ExistingExclusiveConsumer e)\n            {\n                _connection.closeConnection(AMQConstant.NOT_ALLOWED, \"Queue has an exclusive consumer\", _channelId);\n            }\n            catch (MessageSource.ExistingConsumerPreventsExclusive e)\n            {\n                _connection.closeConnection(AMQConstant.INTERNAL_ERROR,\n                                            \"The GET request has been evaluated as an exclusive consumer, \" +\n                                        \"this is likely due to a programming error in the Qpid broker\", _channelId);\n            }\n            catch (MessageSource.ConsumerAccessRefused consumerAccessRefused)\n            {\n                _connection.closeConnection(AMQConstant.NOT_ALLOWED,\n                                            \"Queue has an incompatible exclusivity policy\", _channelId);\n            }\n        }\n    }\n\n    @Override\n    public void receiveBasicPublish(final AMQShortString exchangeName,\n                                    final AMQShortString routingKey,\n                                    final boolean mandatory,\n                                    final boolean immediate)\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] BasicPublish[\" +\" exchange: \" + exchangeName +\n                          \" routingKey: \" + routingKey +\n                          \" mandatory: \" + mandatory +\n                          \" immediate: \" + immediate + \" ]\");\n        }\n\n        VirtualHostImpl vHost = _connection.getVirtualHost();\n\n        MessageDestination destination;\n\n        if (isDefaultExchange(exchangeName))\n        {\n            destination = vHost.getDefaultDestination();\n        }\n        else\n        {\n            destination = vHost.getMessageDestination(exchangeName.toString());\n        }\n\n        // if the exchange does not exist we raise a channel exception\n        if (destination == null)\n        {\n            closeChannel(AMQConstant.NOT_FOUND, \"Unknown exchange name: \" + exchangeName);\n        }\n        else\n        {\n\n            MessagePublishInfo info = new MessagePublishInfo(exchangeName,\n                                                             immediate,\n                                                             mandatory,\n                                                             routingKey);\n\n            try\n            {\n                setPublishFrame(info, destination);\n            }\n            catch (AccessControlException e)\n            {\n                _connection.closeConnection(AMQConstant.ACCESS_REFUSED, e.getMessage(), getChannelId());\n\n            }\n        }\n    }\n\n    @Override\n    public void receiveBasicQos(final long prefetchSize, final int prefetchCount, final boolean global)\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] BasicQos[\" +\" prefetchSize: \" + prefetchSize + \" prefetchCount: \" + prefetchCount + \" global: \" + global + \" ]\");\n        }\n\n        sync();\n        setCredit(prefetchSize, prefetchCount);\n\n        MethodRegistry methodRegistry = _connection.getMethodRegistry();\n        AMQMethodBody responseBody = methodRegistry.createBasicQosOkBody();\n        _connection.writeFrame(responseBody.generateFrame(getChannelId()));\n\n    }\n\n    @Override\n    public void receiveBasicRecover(final boolean requeue, final boolean sync)\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] BasicRecover[\" + \" requeue: \" + requeue + \" sync: \" + sync + \" ]\");\n        }\n\n        resend();\n\n        if (sync)\n        {\n            MethodRegistry methodRegistry = _connection.getMethodRegistry();\n            AMQMethodBody recoverOk = methodRegistry.createBasicRecoverSyncOkBody();\n            sync();\n            _connection.writeFrame(recoverOk.generateFrame(getChannelId()));\n\n        }\n\n    }\n\n    @Override\n    public void receiveBasicReject(final long deliveryTag, final boolean requeue)\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] BasicReject[\" +\" deliveryTag: \" + deliveryTag + \" requeue: \" + requeue + \" ]\");\n        }\n\n        MessageInstance message = getUnacknowledgedMessageMap().get(deliveryTag);\n\n        if (message == null)\n        {\n            _logger.warn(\"Dropping reject request as message is null for tag:\" + deliveryTag);\n        }\n        else\n        {\n\n            if (message.getMessage() == null)\n            {\n                _logger.warn(\"Message has already been purged, unable to Reject.\");\n            }\n            else\n            {\n\n                if (_logger.isDebugEnabled())\n                {\n                    _logger.debug(\"Rejecting: DT:\" + deliveryTag\n                                                             + \"-\" + message.getMessage() +\n                                  \": Requeue:\" + requeue\n                                  +\n                                  \" on channel:\" + debugIdentity());\n                }\n\n                if (requeue)\n                {\n                    //this requeue represents a message rejected from the pre-dispatch queue\n                    //therefore we need to amend the delivery counter.\n                    message.decrementDeliveryCount();\n\n                    requeue(deliveryTag);\n                }\n                else\n                {\n                    // Since the Java client abuses the reject flag for requeing after rollback, we won't set reject here\n                    // as it would prevent redelivery\n                    // message.reject();\n\n                    final boolean maxDeliveryCountEnabled = isMaxDeliveryCountEnabled(deliveryTag);\n                    _logger.debug(\"maxDeliveryCountEnabled: \"\n                                  + maxDeliveryCountEnabled\n                                  + \" deliveryTag \"\n                                  + deliveryTag);\n                    if (maxDeliveryCountEnabled)\n                    {\n                        final boolean deliveredTooManyTimes = isDeliveredTooManyTimes(deliveryTag);\n                        _logger.debug(\"deliveredTooManyTimes: \"\n                                      + deliveredTooManyTimes\n                                      + \" deliveryTag \"\n                                      + deliveryTag);\n                        if (deliveredTooManyTimes)\n                        {\n                            deadLetter(deliveryTag);\n                        }\n                        else\n                        {\n                            //this requeue represents a message rejected because of a recover/rollback that we\n                            //are not ready to DLQ. We rely on the reject command to resend from the unacked map\n                            //and therefore need to increment the delivery counter so we cancel out the effect\n                            //of the AMQChannel#resend() decrement.\n                            message.incrementDeliveryCount();\n                        }\n                    }\n                    else\n                    {\n                        requeue(deliveryTag);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public void receiveChannelClose(final int replyCode,\n                                    final AMQShortString replyText,\n                                    final int classId,\n                                    final int methodId)\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] ChannelClose[\" +\" replyCode: \" + replyCode + \" replyText: \" + replyText + \" classId: \" + classId + \" methodId: \" + methodId + \" ]\");\n        }\n\n\n        sync();\n        _connection.closeChannel(this);\n\n        _connection.writeFrame(new AMQFrame(getChannelId(),\n                                            _connection.getMethodRegistry().createChannelCloseOkBody()));\n    }\n\n    @Override\n    public void receiveChannelCloseOk()\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] ChannelCloseOk\");\n        }\n\n        _connection.closeChannelOk(getChannelId());\n    }\n\n    @Override\n    public void receiveMessageContent(final byte[] data)\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] MessageContent[\" +\" data: \" + hex(data,_connection.getBinaryDataLimit()) + \" ] \");\n        }\n\n        if(hasCurrentMessage())\n        {\n            publishContentBody(new ContentBody(data));\n        }\n        else\n        {\n            _connection.closeConnection(AMQConstant.COMMAND_INVALID,\n                                        \"Attempt to send a content header without first sending a publish frame\",\n                                        _channelId);\n        }\n    }\n\n    @Override\n    public void receiveMessageHeader(final BasicContentHeaderProperties properties, final long bodySize)\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] MessageHeader[ properties: {\" + properties + \"} bodySize: \" + bodySize + \" ]\");\n        }\n\n        if(hasCurrentMessage())\n        {\n            publishContentHeader(new ContentHeaderBody(properties, bodySize));\n        }\n        else\n        {\n            _connection.closeConnection(AMQConstant.COMMAND_INVALID,\n                                        \"Attempt to send a content header without first sending a publish frame\",\n                                        _channelId);\n        }\n    }\n\n    @Override\n    public boolean ignoreAllButCloseOk()\n    {\n        return _connection.ignoreAllButCloseOk() || _connection.channelAwaitingClosure(_channelId);\n    }\n\n    @Override\n    public void receiveChannelFlow(final boolean active)\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] ChannelFlow[\" +\" active: \" + active + \" ]\");\n        }\n\n\n        sync();\n        setSuspended(!active);\n\n        MethodRegistry methodRegistry = _connection.getMethodRegistry();\n        AMQMethodBody responseBody = methodRegistry.createChannelFlowOkBody(active);\n        _connection.writeFrame(responseBody.generateFrame(getChannelId()));\n\n    }\n\n    @Override\n    public void receiveChannelFlowOk(final boolean active)\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] ChannelFlowOk[\" +\" active: \" + active + \" ]\");\n        }\n\n        // TODO - should we do anything here?\n    }\n\n    @Override\n    public void receiveExchangeBound(final AMQShortString exchangeName,\n                                     final AMQShortString routingKey,\n                                     final AMQShortString queueName)\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] ExchangeBound[\" +\" exchange: \" + exchangeName + \" routingKey: \" +\n                          routingKey + \" queue: \" + queueName + \" ]\");\n        }\n\n        VirtualHostImpl virtualHost = _connection.getVirtualHost();\n        MethodRegistry methodRegistry = _connection.getMethodRegistry();\n\n        sync();\n\n        int replyCode;\n        String replyText;\n\n        if (isDefaultExchange(exchangeName))\n        {\n            if (routingKey == null)\n            {\n                if (queueName == null)\n                {\n                    replyCode = virtualHost.getQueues().isEmpty()\n                            ? ExchangeBoundOkBody.NO_BINDINGS\n                            : ExchangeBoundOkBody.OK;\n                    replyText = null;\n\n                }\n                else\n                {\n                    AMQQueue queue = virtualHost.getQueue(queueName.toString());\n                    if (queue == null)\n                    {\n                        replyCode = ExchangeBoundOkBody.QUEUE_NOT_FOUND;\n                        replyText = \"Queue '\" + queueName + \"' not found\";\n                    }\n                    else\n                    {\n                        replyCode = ExchangeBoundOkBody.OK;\n                        replyText = null;\n                    }\n                }\n            }\n            else\n            {\n                if (queueName == null)\n                {\n                    replyCode = virtualHost.getQueue(routingKey.toString()) == null\n                            ? ExchangeBoundOkBody.NO_QUEUE_BOUND_WITH_RK\n                            : ExchangeBoundOkBody.OK;\n                    replyText = null;\n                }\n                else\n                {\n                    AMQQueue queue = virtualHost.getQueue(queueName.toString());\n                    if (queue == null)\n                    {\n\n                        replyCode = ExchangeBoundOkBody.QUEUE_NOT_FOUND;\n                        replyText = \"Queue '\" + queueName + \"' not found\";\n                    }\n                    else\n                    {\n                        replyCode = queueName.equals(routingKey)\n                                ? ExchangeBoundOkBody.OK\n                                : ExchangeBoundOkBody.SPECIFIC_QUEUE_NOT_BOUND_WITH_RK;\n                        replyText = null;\n                    }\n                }\n            }\n        }\n        else\n        {\n            ExchangeImpl exchange = virtualHost.getExchange(exchangeName.toString());\n            if (exchange == null)\n            {\n\n                replyCode = ExchangeBoundOkBody.EXCHANGE_NOT_FOUND;\n                replyText = \"Exchange '\" + exchangeName + \"' not found\";\n            }\n            else if (routingKey == null)\n            {\n                if (queueName == null)\n                {\n                    if (exchange.hasBindings())\n                    {\n                        replyCode = ExchangeBoundOkBody.OK;\n                        replyText = null;\n                    }\n                    else\n                    {\n                        replyCode = ExchangeBoundOkBody.NO_BINDINGS;\n                        replyText = null;\n                    }\n                }\n                else\n                {\n\n                    AMQQueue queue = virtualHost.getQueue(queueName.toString());\n                    if (queue == null)\n                    {\n                        replyCode = ExchangeBoundOkBody.QUEUE_NOT_FOUND;\n                        replyText = \"Queue '\" + queueName + \"' not found\";\n                    }\n                    else\n                    {\n                        if (exchange.isBound(queue))\n                        {\n                            replyCode = ExchangeBoundOkBody.OK;\n                            replyText = null;\n                        }\n                        else\n                        {\n                            replyCode = ExchangeBoundOkBody.QUEUE_NOT_BOUND;\n                            replyText = \"Queue '\"\n                                        + queueName\n                                        + \"' not bound to exchange '\"\n                                        + exchangeName\n                                        + \"'\";\n                        }\n                    }\n                }\n            }\n            else if (queueName != null)\n            {\n                AMQQueue queue = virtualHost.getQueue(queueName.toString());\n                if (queue == null)\n                {\n                    replyCode = ExchangeBoundOkBody.QUEUE_NOT_FOUND;\n                    replyText = \"Queue '\" + queueName + \"' not found\";\n                }\n                else\n                {\n                    String bindingKey = routingKey == null ? null : routingKey.asString();\n                    if (exchange.isBound(bindingKey, queue))\n                    {\n\n                        replyCode = ExchangeBoundOkBody.OK;\n                        replyText = null;\n                    }\n                    else\n                    {\n                        replyCode = ExchangeBoundOkBody.SPECIFIC_QUEUE_NOT_BOUND_WITH_RK;\n                        replyText = \"Queue '\" + queueName + \"' not bound with routing key '\" +\n                                    routingKey + \"' to exchange '\" + exchangeName + \"'\";\n\n                    }\n                }\n            }\n            else\n            {\n                if (exchange.isBound(routingKey == null ? \"\" : routingKey.asString()))\n                {\n\n                    replyCode = ExchangeBoundOkBody.OK;\n                    replyText = null;\n                }\n                else\n                {\n                    replyCode = ExchangeBoundOkBody.NO_QUEUE_BOUND_WITH_RK;\n                    replyText =\n                            \"No queue bound with routing key '\" + routingKey + \"' to exchange '\" + exchangeName + \"'\";\n                }\n            }\n        }\n\n        ExchangeBoundOkBody exchangeBoundOkBody =\n                methodRegistry.createExchangeBoundOkBody(replyCode, AMQShortString.validValueOf(replyText));\n\n        _connection.writeFrame(exchangeBoundOkBody.generateFrame(getChannelId()));\n\n    }\n\n    @Override\n    public void receiveExchangeDeclare(final AMQShortString exchangeName,\n                                       final AMQShortString type,\n                                       final boolean passive,\n                                       final boolean durable,\n                                       final boolean autoDelete,\n                                       final boolean internal,\n                                       final boolean nowait,\n                                       final FieldTable arguments)\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] ExchangeDeclare[\" +\" exchange: \" + exchangeName +\n                          \" type: \" + type +\n                          \" passive: \" + passive +\n                          \" durable: \" + durable +\n                          \" autoDelete: \" + autoDelete +\n                          \" internal: \" + internal + \" nowait: \" + nowait + \" arguments: \" + arguments + \" ]\");\n        }\n\n        ExchangeImpl exchange;\n        VirtualHostImpl<?, ?, ?> virtualHost = _connection.getVirtualHost();\n        if (isDefaultExchange(exchangeName))\n        {\n            if (!new AMQShortString(ExchangeDefaults.DIRECT_EXCHANGE_CLASS).equals(type))\n            {\n                _connection.closeConnection(AMQConstant.NOT_ALLOWED, \"Attempt to redeclare default exchange: \"\n                                                                 + \" of type \"\n                                                                 + ExchangeDefaults.DIRECT_EXCHANGE_CLASS\n                                                                 + \" to \" + type + \".\", getChannelId());\n            }\n            else if (!nowait)\n            {\n                MethodRegistry methodRegistry = _connection.getMethodRegistry();\n                AMQMethodBody responseBody = methodRegistry.createExchangeDeclareOkBody();\n                sync();\n                _connection.writeFrame(responseBody.generateFrame(getChannelId()));\n            }\n\n        }\n        else\n        {\n            if (passive)\n            {\n                exchange = virtualHost.getExchange(exchangeName.toString());\n                if (exchange == null)\n                {\n                    closeChannel(AMQConstant.NOT_FOUND, \"Unknown exchange: \" + exchangeName);\n                }\n                else if (!(type == null || type.length() == 0) && !exchange.getType().equals(type.asString()))\n                {\n\n                    _connection.closeConnection(AMQConstant.NOT_ALLOWED, \"Attempt to redeclare exchange: \"\n                                                                         +\n                                                                         exchangeName\n                                                                         + \" of type \"\n                                                                         + exchange.getType()\n                                                                         + \" to \"\n                                                                         + type\n                                                                         + \".\", getChannelId());\n                }\n                else if (!nowait)\n                {\n                    MethodRegistry methodRegistry = _connection.getMethodRegistry();\n                    AMQMethodBody responseBody = methodRegistry.createExchangeDeclareOkBody();\n                    sync();\n                    _connection.writeFrame(responseBody.generateFrame(getChannelId()));\n                }\n\n            }\n            else\n            {\n                try\n                {\n                    String name = exchangeName == null ? null : exchangeName.intern().toString();\n                    String typeString = type == null ? null : type.intern().toString();\n\n                    Map<String, Object> attributes = new HashMap<String, Object>();\n                    if (arguments != null)\n                    {\n                        attributes.putAll(FieldTable.convertToMap(arguments));\n                    }\n                    attributes.put(Exchange.ID, null);\n                    attributes.put(Exchange.NAME, name);\n                    attributes.put(Exchange.TYPE, typeString);\n                    attributes.put(Exchange.DURABLE, durable);\n                    attributes.put(Exchange.LIFETIME_POLICY,\n                                   autoDelete ? LifetimePolicy.DELETE_ON_NO_LINKS : LifetimePolicy.PERMANENT);\n                    if (!attributes.containsKey(Exchange.ALTERNATE_EXCHANGE))\n                    {\n                        attributes.put(Exchange.ALTERNATE_EXCHANGE, null);\n                    }\n                    exchange = virtualHost.createExchange(attributes);\n\n                    if (!nowait)\n                    {\n                        MethodRegistry methodRegistry = _connection.getMethodRegistry();\n                        AMQMethodBody responseBody = methodRegistry.createExchangeDeclareOkBody();\n                        sync();\n                        _connection.writeFrame(responseBody.generateFrame(\n                                getChannelId()));\n                    }\n\n                }\n                catch (ReservedExchangeNameException e)\n                {\n                    _connection.closeConnection(AMQConstant.NOT_ALLOWED,\n                                                \"Attempt to declare exchange: \" + exchangeName +\n                                                                         \" which begins with reserved prefix.\", getChannelId());\n\n\n                }\n                catch (ExchangeExistsException e)\n                {\n                    exchange = e.getExistingExchange();\n                    if (!new AMQShortString(exchange.getType()).equals(type))\n                    {\n                        _connection.closeConnection(AMQConstant.NOT_ALLOWED, \"Attempt to redeclare exchange: \"\n                                                                                 + exchangeName + \" of type \"\n                                                                                 + exchange.getType()\n                                                                                 + \" to \" + type + \".\", getChannelId());\n\n                    }\n                }\n                catch (NoFactoryForTypeException e)\n                {\n                    _connection.closeConnection(AMQConstant.COMMAND_INVALID, \"Unknown exchange type '\"\n                                                                             + e.getType()\n                                                                             + \"' for exchange '\"\n                                                                             + exchangeName\n                                                                             + \"'\", getChannelId());\n\n                }\n                catch (AccessControlException e)\n                {\n                    _connection.closeConnection(AMQConstant.ACCESS_REFUSED, e.getMessage(), getChannelId());\n\n                }\n                catch (UnknownConfiguredObjectException e)\n                {\n                    // note - since 0-8/9/9-1 can't set the alt. exchange this exception should never occur\n                    final String message = \"Unknown alternate exchange \"\n                                           + (e.getName() != null\n                            ? \"name: \\\"\" + e.getName() + \"\\\"\"\n                            : \"id: \" + e.getId());\n                    _connection.closeConnection(AMQConstant.NOT_FOUND, message, getChannelId());\n\n                }\n                catch (IllegalArgumentException e)\n                {\n                    _connection.closeConnection(AMQConstant.COMMAND_INVALID, \"Error creating exchange '\"\n                                                                             + exchangeName\n                                                                             + \"': \"\n                                                                             + e.getMessage(), getChannelId());\n\n                }\n            }\n        }\n\n    }\n\n    @Override\n    public void receiveExchangeDelete(final AMQShortString exchangeStr, final boolean ifUnused, final boolean nowait)\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] ExchangeDelete[\" +\" exchange: \" + exchangeStr + \" ifUnused: \" + ifUnused + \" nowait: \" + nowait + \" ]\");\n        }\n\n\n        VirtualHostImpl virtualHost = _connection.getVirtualHost();\n        sync();\n        try\n        {\n\n            if (isDefaultExchange(exchangeStr))\n            {\n                _connection.closeConnection(AMQConstant.NOT_ALLOWED,\n                                            \"Default Exchange cannot be deleted\", getChannelId());\n\n            }\n\n            else\n            {\n                final String exchangeName = exchangeStr.toString();\n\n                final ExchangeImpl exchange = virtualHost.getExchange(exchangeName);\n                if (exchange == null)\n                {\n                    closeChannel(AMQConstant.NOT_FOUND, \"No such exchange: \" + exchangeStr);\n                }\n                else\n                {\n                    virtualHost.removeExchange(exchange, !ifUnused);\n\n                    ExchangeDeleteOkBody responseBody = _connection.getMethodRegistry().createExchangeDeleteOkBody();\n\n                    _connection.writeFrame(responseBody.generateFrame(getChannelId()));\n                }\n            }\n        }\n        catch (ExchangeIsAlternateException e)\n        {\n            closeChannel(AMQConstant.NOT_ALLOWED, \"Exchange in use as an alternate exchange\");\n        }\n        catch (RequiredExchangeException e)\n        {\n            closeChannel(AMQConstant.NOT_ALLOWED,\n                         \"Exchange '\" + exchangeStr + \"' cannot be deleted\");\n        }\n        catch (AccessControlException e)\n        {\n            _connection.closeConnection(AMQConstant.ACCESS_REFUSED, e.getMessage(), getChannelId());\n        }\n    }\n\n    @Override\n    public void receiveQueueBind(final AMQShortString queueName,\n                                 final AMQShortString exchange,\n                                 AMQShortString routingKey,\n                                 final boolean nowait,\n                                 final FieldTable argumentsTable)\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] QueueBind[\" +\" queue: \" + queueName +\n                          \" exchange: \" + exchange +\n                          \" bindingKey: \" + routingKey +\n                          \" nowait: \" + nowait + \" arguments: \" + argumentsTable + \" ]\");\n        }\n\n        VirtualHostImpl virtualHost = _connection.getVirtualHost();\n        AMQQueue<?> queue;\n        if (queueName == null)\n        {\n\n            queue = getDefaultQueue();\n\n            if (queue != null)\n            {\n                if (routingKey == null)\n                {\n                    routingKey = AMQShortString.valueOf(queue.getName());\n                }\n                else\n                {\n                    routingKey = routingKey.intern();\n                }\n            }\n        }\n        else\n        {\n            queue = virtualHost.getQueue(queueName.toString());\n            routingKey = routingKey == null ? AMQShortString.EMPTY_STRING : routingKey.intern();\n        }\n\n        if (queue == null)\n        {\n            String message = queueName == null\n                    ? \"No default queue defined on channel and queue was null\"\n                    : \"Queue \" + queueName + \" does not exist.\";\n                closeChannel(AMQConstant.NOT_FOUND, message);\n        }\n        else if (isDefaultExchange(exchange))\n        {\n            _connection.closeConnection(AMQConstant.NOT_ALLOWED,\n                                        \"Cannot bind the queue \" + queueName + \" to the default exchange\", getChannelId());\n\n        }\n        else\n        {\n\n            final String exchangeName = exchange.toString();\n\n            final ExchangeImpl exch = virtualHost.getExchange(exchangeName);\n            if (exch == null)\n            {\n                closeChannel(AMQConstant.NOT_FOUND,\n                             \"Exchange \" + exchangeName + \" does not exist.\");\n            }\n            else\n            {\n\n                try\n                {\n\n                    Map<String, Object> arguments = FieldTable.convertToMap(argumentsTable);\n                    String bindingKey = String.valueOf(routingKey);\n\n                    if (!exch.isBound(bindingKey, arguments, queue))\n                    {\n\n                        if (!exch.addBinding(bindingKey, queue, arguments)\n                            && ExchangeDefaults.TOPIC_EXCHANGE_CLASS.equals(\n                                exch.getType()))\n                        {\n                            exch.replaceBinding(bindingKey, queue, arguments);\n                        }\n                    }\n\n                    if (_logger.isInfoEnabled())\n                    {\n                        _logger.info(\"Binding queue \"\n                                     + queue\n                                     + \" to exchange \"\n                                     + exch\n                                     + \" with routing key \"\n                                     + routingKey);\n                    }\n                    if (!nowait)\n                    {\n                        sync();\n                        MethodRegistry methodRegistry = _connection.getMethodRegistry();\n                        AMQMethodBody responseBody = methodRegistry.createQueueBindOkBody();\n                        _connection.writeFrame(responseBody.generateFrame(getChannelId()));\n\n                    }\n                }\n                catch (AccessControlException e)\n                {\n                    _connection.closeConnection(AMQConstant.ACCESS_REFUSED, e.getMessage(), getChannelId());\n                }\n            }\n        }\n    }\n\n    @Override\n    public void receiveQueueDeclare(final AMQShortString queueStr,\n                                    final boolean passive,\n                                    final boolean durable,\n                                    final boolean exclusive,\n                                    final boolean autoDelete,\n                                    final boolean nowait,\n                                    final FieldTable arguments)\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] QueueDeclare[\" +\" queue: \" + queueStr +\n                          \" passive: \" + passive +\n                          \" durable: \" + durable +\n                          \" exclusive: \" + exclusive +\n                          \" autoDelete: \" + autoDelete + \" nowait: \" + nowait + \" arguments: \" + arguments + \" ]\");\n        }\n\n        VirtualHostImpl virtualHost = _connection.getVirtualHost();\n\n        final AMQShortString queueName;\n\n        // if we aren't given a queue name, we create one which we return to the client\n        if ((queueStr == null) || (queueStr.length() == 0))\n        {\n            queueName = new AMQShortString(\"tmp_\" + UUID.randomUUID());\n        }\n        else\n        {\n            queueName = queueStr.intern();\n        }\n\n        AMQQueue queue;\n\n        //TODO: do we need to check that the queue already exists with exactly the same \"configuration\"?\n\n\n        if (passive)\n        {\n            queue = virtualHost.getQueue(queueName.toString());\n            if (queue == null)\n            {\n                closeChannel(AMQConstant.NOT_FOUND,\n                                                     \"Queue: \"\n                                                     + queueName\n                                                     + \" not found on VirtualHost(\"\n                                                     + virtualHost\n                                                     + \").\");\n            }\n            else\n            {\n                if (!queue.verifySessionAccess(this))\n                {\n                    _connection.closeConnection(AMQConstant.NOT_ALLOWED, \"Queue \"\n                                                + queue.getName()\n                                                + \" is exclusive, but not created on this Connection.\", getChannelId());\n                }\n                else\n                {\n                    //set this as the default queue on the channel:\n                    setDefaultQueue(queue);\n                    if (!nowait)\n                    {\n                        sync();\n                        MethodRegistry methodRegistry = _connection.getMethodRegistry();\n                        QueueDeclareOkBody responseBody =\n                                methodRegistry.createQueueDeclareOkBody(queueName,\n                                                                        queue.getQueueDepthMessages(),\n                                                                        queue.getConsumerCount());\n                        _connection.writeFrame(responseBody.generateFrame(getChannelId()));\n\n                        _logger.info(\"Queue \" + queueName + \" declared successfully\");\n                    }\n                }\n            }\n        }\n        else\n        {\n\n            try\n            {\n                Map<String, Object> attributes =\n                        QueueArgumentsConverter.convertWireArgsToModel(FieldTable.convertToMap(arguments));\n                final String queueNameString = AMQShortString.toString(queueName);\n                attributes.put(Queue.NAME, queueNameString);\n                attributes.put(Queue.ID, UUID.randomUUID());\n                attributes.put(Queue.DURABLE, durable);\n\n                LifetimePolicy lifetimePolicy;\n                ExclusivityPolicy exclusivityPolicy;\n\n                if (exclusive)\n                {\n                    lifetimePolicy = autoDelete\n                            ? LifetimePolicy.DELETE_ON_NO_OUTBOUND_LINKS\n                            : durable ? LifetimePolicy.PERMANENT : LifetimePolicy.DELETE_ON_CONNECTION_CLOSE;\n                    exclusivityPolicy = durable ? ExclusivityPolicy.CONTAINER : ExclusivityPolicy.CONNECTION;\n                }\n                else\n                {\n                    lifetimePolicy = autoDelete ? LifetimePolicy.DELETE_ON_NO_OUTBOUND_LINKS : LifetimePolicy.PERMANENT;\n                    exclusivityPolicy = ExclusivityPolicy.NONE;\n                }\n\n                attributes.put(Queue.EXCLUSIVE, exclusivityPolicy);\n                attributes.put(Queue.LIFETIME_POLICY, lifetimePolicy);\n\n\n                queue = virtualHost.createQueue(attributes);\n\n                setDefaultQueue(queue);\n\n                if (!nowait)\n                {\n                    sync();\n                    MethodRegistry methodRegistry = _connection.getMethodRegistry();\n                    QueueDeclareOkBody responseBody =\n                            methodRegistry.createQueueDeclareOkBody(queueName,\n                                                                    queue.getQueueDepthMessages(),\n                                                                    queue.getConsumerCount());\n                    _connection.writeFrame(responseBody.generateFrame(getChannelId()));\n\n                    _logger.info(\"Queue \" + queueName + \" declared successfully\");\n                }\n            }\n            catch (QueueExistsException qe)\n            {\n\n                queue = qe.getExistingQueue();\n\n                if (!queue.verifySessionAccess(this))\n                {\n                    _connection.closeConnection(AMQConstant.NOT_ALLOWED, \"Queue \"\n                                                + queue.getName()\n                                                + \" is exclusive, but not created on this Connection.\", getChannelId());\n\n                }\n                else if (queue.isExclusive() != exclusive)\n                {\n\n                    closeChannel(AMQConstant.ALREADY_EXISTS,\n                                                         \"Cannot re-declare queue '\"\n                                                         + queue.getName()\n                                                         + \"' with different exclusivity (was: \"\n                                                         + queue.isExclusive()\n                                                         + \" requested \"\n                                                         + exclusive\n                                                         + \")\");\n                }\n                else if ((autoDelete\n                          && queue.getLifetimePolicy() != LifetimePolicy.DELETE_ON_NO_OUTBOUND_LINKS)\n                         || (!autoDelete && queue.getLifetimePolicy() != ((exclusive\n                                                                           && !durable)\n                        ? LifetimePolicy.DELETE_ON_CONNECTION_CLOSE\n                        : LifetimePolicy.PERMANENT)))\n                {\n                    closeChannel(AMQConstant.ALREADY_EXISTS,\n                                                         \"Cannot re-declare queue '\"\n                                                         + queue.getName()\n                                                         + \"' with different lifetime policy (was: \"\n                                                         + queue.getLifetimePolicy()\n                                                         + \" requested autodelete: \"\n                                                         + autoDelete\n                                                         + \")\");\n                }\n                else if (queue.isDurable() != durable)\n                {\n                    closeChannel(AMQConstant.ALREADY_EXISTS,\n                                                         \"Cannot re-declare queue '\"\n                                                         + queue.getName()\n                                                         + \"' with different durability (was: \"\n                                                         + queue.isDurable()\n                                                         + \" requested \"\n                                                         + durable\n                                                         + \")\");\n                }\n                else\n                {\n                    setDefaultQueue(queue);\n                    if (!nowait)\n                    {\n                        sync();\n                        MethodRegistry methodRegistry = _connection.getMethodRegistry();\n                        QueueDeclareOkBody responseBody =\n                                methodRegistry.createQueueDeclareOkBody(queueName,\n                                                                        queue.getQueueDepthMessages(),\n                                                                        queue.getConsumerCount());\n                        _connection.writeFrame(responseBody.generateFrame(getChannelId()));\n\n                        _logger.info(\"Queue \" + queueName + \" declared successfully\");\n                    }\n                }\n            }\n            catch (AccessControlException e)\n            {\n                _connection.closeConnection(AMQConstant.ACCESS_REFUSED, e.getMessage(), getChannelId());\n            }\n\n        }\n    }\n\n    @Override\n    public void receiveQueueDelete(final AMQShortString queueName,\n                                   final boolean ifUnused,\n                                   final boolean ifEmpty,\n                                   final boolean nowait)\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] QueueDelete[\" +\" queue: \" + queueName + \" ifUnused: \" + ifUnused + \" ifEmpty: \" + ifEmpty + \" nowait: \" + nowait + \" ]\");\n        }\n\n        VirtualHostImpl virtualHost = _connection.getVirtualHost();\n        sync();\n        AMQQueue queue;\n        if (queueName == null)\n        {\n\n            //get the default queue on the channel:\n            queue = getDefaultQueue();\n        }\n        else\n        {\n            queue = virtualHost.getQueue(queueName.toString());\n        }\n\n        if (queue == null)\n        {\n            closeChannel(AMQConstant.NOT_FOUND, \"Queue \" + queueName + \" does not exist.\");\n\n        }\n        else\n        {\n            if (ifEmpty && !queue.isEmpty())\n            {\n                closeChannel(AMQConstant.IN_USE, \"Queue: \" + queueName + \" is not empty.\");\n            }\n            else if (ifUnused && !queue.isUnused())\n            {\n                // TODO - Error code\n                closeChannel(AMQConstant.IN_USE, \"Queue: \" + queueName + \" is still used.\");\n            }\n            else\n            {\n                if (!queue.verifySessionAccess(this))\n                {\n                    _connection.closeConnection(AMQConstant.NOT_ALLOWED, \"Queue \"\n                                                + queue.getName()\n                                                + \" is exclusive, but not created on this Connection.\", getChannelId());\n\n                }\n                else\n                {\n                    try\n                    {\n                        int purged = virtualHost.removeQueue(queue);\n\n                        MethodRegistry methodRegistry = _connection.getMethodRegistry();\n                        QueueDeleteOkBody responseBody = methodRegistry.createQueueDeleteOkBody(purged);\n                        _connection.writeFrame(responseBody.generateFrame(getChannelId()));\n                    }\n                    catch (AccessControlException e)\n                    {\n                        _connection.closeConnection(AMQConstant.ACCESS_REFUSED, e.getMessage(), getChannelId());\n\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public void receiveQueuePurge(final AMQShortString queueName, final boolean nowait)\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] QueuePurge[\" +\" queue: \" + queueName + \" nowait: \" + nowait + \" ]\");\n        }\n\n        VirtualHostImpl virtualHost = _connection.getVirtualHost();\n        AMQQueue queue = null;\n        if (queueName == null && (queue = getDefaultQueue()) == null)\n        {\n\n            _connection.closeConnection(AMQConstant.NOT_ALLOWED, \"No queue specified.\", getChannelId());\n        }\n        else if ((queueName != null) && (queue = virtualHost.getQueue(queueName.toString())) == null)\n        {\n            closeChannel(AMQConstant.NOT_FOUND, \"Queue \" + queueName + \" does not exist.\");\n        }\n        else if (!queue.verifySessionAccess(this))\n        {\n            _connection.closeConnection(AMQConstant.NOT_ALLOWED,\n                                        \"Queue is exclusive, but not created on this Connection.\", getChannelId());\n        }\n        else\n        {\n            try\n            {\n                long purged = queue.clearQueue();\n                if (!nowait)\n                {\n                    sync();\n                    MethodRegistry methodRegistry = _connection.getMethodRegistry();\n                    AMQMethodBody responseBody = methodRegistry.createQueuePurgeOkBody(purged);\n                    _connection.writeFrame(responseBody.generateFrame(getChannelId()));\n\n                }\n            }\n            catch (AccessControlException e)\n            {\n                _connection.closeConnection(AMQConstant.ACCESS_REFUSED, e.getMessage(), getChannelId());\n\n            }\n\n        }\n    }\n\n    @Override\n    public void receiveQueueUnbind(final AMQShortString queueName,\n                                   final AMQShortString exchange,\n                                   final AMQShortString routingKey,\n                                   final FieldTable arguments)\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] QueueUnbind[\" +\" queue: \" + queueName +\n                          \" exchange: \" + exchange +\n                          \" bindingKey: \" + routingKey +\n                          \" arguments: \" + arguments + \" ]\");\n        }\n\n        VirtualHostImpl virtualHost = _connection.getVirtualHost();\n\n\n        final boolean useDefaultQueue = queueName == null;\n        final AMQQueue queue = useDefaultQueue\n                ? getDefaultQueue()\n                : virtualHost.getQueue(queueName.toString());\n\n\n        if (queue == null)\n        {\n            String message = useDefaultQueue\n                    ? \"No default queue defined on channel and queue was null\"\n                    : \"Queue \" + queueName + \" does not exist.\";\n            closeChannel(AMQConstant.NOT_FOUND, message);\n        }\n        else if (isDefaultExchange(exchange))\n        {\n            _connection.closeConnection(AMQConstant.NOT_ALLOWED, \"Cannot unbind the queue \"\n                                                         + queue.getName()\n                                                         + \" from the default exchange\", getChannelId());\n\n        }\n        else\n        {\n\n            final ExchangeImpl exch = virtualHost.getExchange(exchange.toString());\n\n            if (exch == null)\n            {\n                closeChannel(AMQConstant.NOT_FOUND, \"Exchange \" + exchange + \" does not exist.\");\n            }\n            else if (!exch.hasBinding(String.valueOf(routingKey), queue))\n            {\n                closeChannel(AMQConstant.NOT_FOUND, \"No such binding\");\n            }\n            else\n            {\n                try\n                {\n                    exch.deleteBinding(String.valueOf(routingKey), queue);\n\n                    final AMQMethodBody responseBody = _connection.getMethodRegistry().createQueueUnbindOkBody();\n                    sync();\n                    _connection.writeFrame(responseBody.generateFrame(getChannelId()));\n                }\n                catch (AccessControlException e)\n                {\n                    _connection.closeConnection(AMQConstant.ACCESS_REFUSED, e.getMessage(), getChannelId());\n\n                }\n            }\n\n        }\n    }\n\n    @Override\n    public void receiveTxSelect()\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] TxSelect\");\n        }\n\n        setLocalTransactional();\n\n        MethodRegistry methodRegistry = _connection.getMethodRegistry();\n        TxSelectOkBody responseBody = methodRegistry.createTxSelectOkBody();\n        _connection.writeFrame(responseBody.generateFrame(_channelId));\n\n    }\n\n    @Override\n    public void receiveTxCommit()\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] TxCommit\");\n        }\n\n\n        if (!isTransactional())\n        {\n            closeChannel(AMQConstant.COMMAND_INVALID,\n                         \"Fatal error: commit called on non-transactional channel\");\n        }\n        commit(new Runnable()\n        {\n\n            @Override\n            public void run()\n            {\n                MethodRegistry methodRegistry = _connection.getMethodRegistry();\n                AMQMethodBody responseBody = methodRegistry.createTxCommitOkBody();\n                _connection.writeFrame(responseBody.generateFrame(_channelId));\n            }\n        }, true);\n\n    }\n\n    @Override\n    public void receiveTxRollback()\n    {\n        if(_logger.isDebugEnabled())\n        {\n            _logger.debug(\"RECV[\" + _channelId + \"] TxRollback\");\n        }\n\n        if (!isTransactional())\n        {\n            closeChannel(AMQConstant.COMMAND_INVALID,\n                         \"Fatal error: rollback called on non-transactional channel\");\n        }\n\n        final MethodRegistry methodRegistry = _connection.getMethodRegistry();\n        final AMQMethodBody responseBody = methodRegistry.createTxRollbackOkBody();\n\n        Runnable task = new Runnable()\n        {\n\n            public void run()\n            {\n                _connection.writeFrame(responseBody.generateFrame(_channelId));\n            }\n        };\n\n        rollback(task);\n\n        //Now resend all the unacknowledged messages back to the original subscribers.\n        //(Must be done after the TxnRollback-ok response).\n        // Why, are we not allowed to send messages back to client before the ok method?\n        resend();\n    }\n\n\n    private void closeChannel(final AMQConstant cause, final String message)\n    {\n        _connection.closeChannelAndWriteFrame(this, cause, message);\n    }\n\n\n    private boolean isDefaultExchange(final AMQShortString exchangeName)\n    {\n        return exchangeName == null || AMQShortString.EMPTY_STRING.equals(exchangeName);\n    }\n\n}",
    "target": 1,
    "language": "java",
    "dataset": "A-Manually-Curated-Dataset-of-Vulnerability-Introducing-Commits-in-Java",
    "idx": 800072,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n */\npackage org.apache.qpid.server.protocol.v0_8;\n\nimport static org.apache.qpid.server.transport.util.Functions.hex;\n\nimport java.security.AccessControlContext;\nimport java.security.AccessControlException;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport javax.security.auth.Subject;\n\nimport com.google.common.base.Function;\nimport com.google.common.collect.Collections2;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport org.apache.qpid.server.bytebuffer.QpidByteBuffer;\nimport org.apache.qpid.server.configuration.IllegalConfigurationException;\nimport org.apache.qpid.server.consumer.ConsumerOption;\nimport org.apache.qpid.server.consumer.ConsumerTarget;\nimport org.apache.qpid.server.exchange.ExchangeDefaults;\nimport org.apache.qpid.server.filter.AMQInvalidArgumentException;\nimport org.apache.qpid.server.filter.AMQPFilterTypes;\nimport org.apache.qpid.server.filter.ArrivalTimeFilter;\nimport org.apache.qpid.server.filter.FilterManager;\nimport org.apache.qpid.server.filter.FilterManagerFactory;\nimport org.apache.qpid.server.filter.Filterable;\nimport org.apache.qpid.server.filter.MessageFilter;\nimport org.apache.qpid.server.logging.EventLoggerProvider;\nimport org.apache.qpid.server.logging.LogMessage;\nimport org.apache.qpid.server.logging.messages.ChannelMessages;\nimport org.apache.qpid.server.logging.messages.ExchangeMessages;\nimport org.apache.qpid.server.message.InstanceProperties;\nimport org.apache.qpid.server.message.MessageDestination;\nimport org.apache.qpid.server.message.MessageInstance;\nimport org.apache.qpid.server.message.MessageInstanceConsumer;\nimport org.apache.qpid.server.message.MessageReference;\nimport org.apache.qpid.server.message.MessageSource;\nimport org.apache.qpid.server.message.RejectType;\nimport org.apache.qpid.server.message.RoutingResult;\nimport org.apache.qpid.server.message.ServerMessage;\nimport org.apache.qpid.server.model.AbstractConfiguredObject;\nimport org.apache.qpid.server.model.AlternateBinding;\nimport org.apache.qpid.server.model.Broker;\nimport org.apache.qpid.server.model.Exchange;\nimport org.apache.qpid.server.model.ExclusivityPolicy;\nimport org.apache.qpid.server.model.LifetimePolicy;\nimport org.apache.qpid.server.model.NamedAddressSpace;\nimport org.apache.qpid.server.model.NoFactoryForTypeException;\nimport org.apache.qpid.server.model.Queue;\nimport org.apache.qpid.server.protocol.ErrorCodes;\nimport org.apache.qpid.server.protocol.ProtocolVersion;\nimport org.apache.qpid.server.protocol.v0_8.UnacknowledgedMessageMap.Visitor;\nimport org.apache.qpid.server.protocol.v0_8.transport.*;\nimport org.apache.qpid.server.queue.QueueArgumentsConverter;\nimport org.apache.qpid.server.session.AbstractAMQPSession;\nimport org.apache.qpid.server.store.MessageHandle;\nimport org.apache.qpid.server.store.MessageStore;\nimport org.apache.qpid.server.store.StoredMessage;\nimport org.apache.qpid.server.store.TransactionLogResource;\nimport org.apache.qpid.server.transport.AMQPConnection;\nimport org.apache.qpid.server.txn.AsyncAutoCommitTransaction;\nimport org.apache.qpid.server.txn.AsyncCommand;\nimport org.apache.qpid.server.txn.LocalTransaction;\nimport org.apache.qpid.server.txn.ServerTransaction;\nimport org.apache.qpid.server.util.Action;\nimport org.apache.qpid.server.virtualhost.MessageDestinationIsAlternateException;\nimport org.apache.qpid.server.virtualhost.RequiredExchangeException;\nimport org.apache.qpid.server.virtualhost.ReservedExchangeNameException;\nimport org.apache.qpid.server.virtualhost.UnknownAlternateBindingException;\n\npublic class AMQChannel extends AbstractAMQPSession<AMQChannel, ConsumerTarget_0_8>\n        implements AsyncAutoCommitTransaction.FutureRecorder,\n                   ServerChannelMethodProcessor,\n                   EventLoggerProvider, CreditRestorer, org.apache.qpid.server.util.Deletable<AMQChannel>\n{\n    public static final int DEFAULT_PREFETCH = 4096;\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(AMQChannel.class);\n    private static final InfiniteCreditCreditManager INFINITE_CREDIT_CREDIT_MANAGER = new InfiniteCreditCreditManager();\n    private static final Function<MessageConsumerAssociation, MessageInstance>\n            MESSAGE_INSTANCE_FUNCTION = new Function<MessageConsumerAssociation, MessageInstance>()\n    {\n        @Override\n        public MessageInstance apply(final MessageConsumerAssociation input)\n        {\n            return input.getMessageInstance();\n        }\n    };\n    private static final String ALTERNATE_EXCHANGE = \"alternateExchange\";\n    private final DefaultQueueAssociationClearingTask\n            _defaultQueueAssociationClearingTask = new DefaultQueueAssociationClearingTask();\n\n    private final int _channelId;\n\n\n    private final Pre0_10CreditManager _creditManager;\n\n\n    /**\n     * The delivery tag is unique per channel. This is pre-incremented before putting into the deliver frame so that\n     * value of this represents the <b>last</b> tag sent out\n     */\n    private long _deliveryTag = 0;\n\n    /** A channel has a default queue (the last declared) that is used when no queue name is explicitly set */\n    private volatile Queue<?> _defaultQueue;\n\n    /** This tag is unique per subscription to a queue. The server returns this in response to a basic.consume request. */\n    private int _consumerTag;\n\n    /**\n     * The current message - which may be partial in the sense that not all frames have been received yet - which has\n     * been received by this channel. As the frames are received the message gets updated and once all frames have been\n     * received the message can then be routed.\n     */\n    private IncomingMessage _currentMessage;\n\n    /** Maps from consumer tag to subscription instance. Allows us to unsubscribe from a queue. */\n    private final Map<AMQShortString, ConsumerTarget_0_8> _tag2SubscriptionTargetMap = new HashMap<AMQShortString, ConsumerTarget_0_8>();\n\n    private final MessageStore _messageStore;\n\n    private final java.util.Queue<AsyncCommand> _unfinishedCommandsQueue = new ConcurrentLinkedQueue<>();\n\n    private final UnacknowledgedMessageMap _unacknowledgedMessageMap;\n\n    private final AtomicBoolean _suspended = new AtomicBoolean(false);\n\n    private volatile ServerTransaction _transaction;\n\n    private final AMQPConnection_0_8 _connection;\n    private final AtomicBoolean _closing = new AtomicBoolean(false);\n\n    private final Set<Object> _blockingEntities = Collections.synchronizedSet(new HashSet<Object>());\n\n    private final AtomicBoolean _blocking = new AtomicBoolean(false);\n\n\n    private volatile boolean _rollingBack;\n\n    private List<MessageConsumerAssociation> _resendList = new ArrayList<>();\n    private static final\n    AMQShortString IMMEDIATE_DELIVERY_REPLY_TEXT =\n            AMQShortString.createAMQShortString(\"Immediate delivery is not possible.\");\n\n    private final ClientDeliveryMethod _clientDeliveryMethod;\n\n    private final ImmediateAction _immediateAction = new ImmediateAction();\n    private long _blockTime;\n    private long _blockingTimeout;\n    private boolean _confirmOnPublish;\n    private long _confirmedMessageCounter;\n\n    private boolean _wireBlockingState;\n\n    /** Flag recording if this channel has already written operational logging for prefetch size */\n    private boolean _prefetchLoggedForChannel = false;\n\n    /**\n     * Handles special case where consumer is polling for messages using qos/flow. Avoids the per-message\n     * production of channel flow and prefetch operational logging.\n     */\n    private boolean _logChannelFlowMessages = true;\n\n    private final CachedFrame _txCommitOkFrame;\n    private boolean _channelFlow = true;\n\n    public AMQChannel(AMQPConnection_0_8 connection, int channelId, final MessageStore messageStore)\n    {\n        super(connection, channelId);\n        _creditManager = new Pre0_10CreditManager(0L, 0L,\n                                                  connection.getContextValue(Long.class, AMQPConnection_0_8.HIGH_PREFETCH_LIMIT),\n                                                  connection.getContextValue(Long.class, AMQPConnection_0_8.BATCH_LIMIT));\n        _unacknowledgedMessageMap = new UnacknowledgedMessageMapImpl(DEFAULT_PREFETCH, this);\n        _connection = connection;\n        _channelId = channelId;\n\n        _messageStore = messageStore;\n        _blockingTimeout = connection.getBroker().getContextValue(Long.class,\n                                                                  Broker.CHANNEL_FLOW_CONTROL_ENFORCEMENT_TIMEOUT);\n        // by default the session is non-transactional\n        _transaction = new AsyncAutoCommitTransaction(_messageStore, this);\n\n        MethodRegistry methodRegistry = _connection.getMethodRegistry();\n        AMQMethodBody responseBody = methodRegistry.createTxCommitOkBody();\n        _txCommitOkFrame = new CachedFrame(responseBody.generateFrame(_channelId));\n\n        _clientDeliveryMethod = connection.createDeliveryMethod(_channelId);\n\n        AccessController.doPrivileged((new PrivilegedAction<Object>()\n        {\n            @Override\n            public Object run()\n            {\n                message(ChannelMessages.CREATE());\n\n                return null;\n            }\n        }),_accessControllerContext);\n\n    }\n\n    private void message(final LogMessage message)\n    {\n        getEventLogger().message(message);\n    }\n\n    public AccessControlContext getAccessControllerContext()\n    {\n        return _accessControllerContext;\n    }\n\n    private boolean performGet(final MessageSource queue,\n                               final boolean acks)\n            throws MessageSource.ExistingConsumerPreventsExclusive,\n                   MessageSource.ExistingExclusiveConsumer, MessageSource.ConsumerAccessRefused,\n                   MessageSource.QueueDeleted\n    {\n        final GetDeliveryMethod getDeliveryMethod = new GetDeliveryMethod(queue);\n\n        ConsumerTarget_0_8 target;\n        EnumSet<ConsumerOption> options = EnumSet.of(ConsumerOption.TRANSIENT, ConsumerOption.ACQUIRES,\n                                                     ConsumerOption.SEES_REQUEUES);\n        if (acks)\n        {\n\n            target = ConsumerTarget_0_8.createGetAckTarget(this,\n                                                           AMQShortString.EMPTY_STRING, null,\n                                                           INFINITE_CREDIT_CREDIT_MANAGER, getDeliveryMethod);\n        }\n        else\n        {\n            target = ConsumerTarget_0_8.createGetNoAckTarget(this,\n                                                             AMQShortString.EMPTY_STRING, null,\n                                                             INFINITE_CREDIT_CREDIT_MANAGER, getDeliveryMethod);\n        }\n\n        queue.addConsumer(target, null, AMQMessage.class, \"\", options, null);\n        target.updateNotifyWorkDesired();\n        boolean canCallSendNextMessageAgain;\n        do\n        {\n            canCallSendNextMessageAgain = target.sendNextMessage();\n        }\n        while (canCallSendNextMessageAgain && !getDeliveryMethod.hasDeliveredMessage());\n        target.close();\n        return getDeliveryMethod.hasDeliveredMessage();\n    }\n\n    boolean isTransactional()\n    {\n        return _transaction.isTransactional();\n    }\n\n    ServerTransaction getTransaction()\n    {\n        return _transaction;\n    }\n\n    public void receivedComplete()\n    {\n        AccessController.doPrivileged(new PrivilegedAction<Void>()\n        {\n            @Override\n            public Void run()\n            {\n                sync();\n                return null;\n            }\n        }, getAccessControllerContext());\n\n    }\n\n    private void setPublishFrame(MessagePublishInfo info, final MessageDestination e)\n    {\n        _currentMessage = new IncomingMessage(info);\n        _currentMessage.setMessageDestination(e);\n    }\n\n    private void publishContentHeader(ContentHeaderBody contentHeaderBody)\n    {\n        if (LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"Content header received on channel \" + _channelId);\n        }\n\n        _currentMessage.setContentHeaderBody(contentHeaderBody);\n\n        deliverCurrentMessageIfComplete();\n    }\n\n    private void deliverCurrentMessageIfComplete()\n    {\n        // check and deliver if header says body length is zero\n        if (_currentMessage.allContentReceived())\n        {\n            MessagePublishInfo info = _currentMessage.getMessagePublishInfo();\n            String routingKey = AMQShortString.toString(info.getRoutingKey());\n            String exchangeName = AMQShortString.toString(info.getExchange());\n\n            try\n            {\n                final MessageDestination destination = _currentMessage.getDestination();\n\n                ContentHeaderBody contentHeader = _currentMessage.getContentHeader();\n                _connection.checkAuthorizedMessagePrincipal(AMQShortString.toString(contentHeader.getProperties().getUserId()));\n\n                _publishAuthCache.authorisePublish(destination, routingKey, info.isImmediate(), _connection.getLastReadTime());\n\n                if (_confirmOnPublish)\n                {\n                    _confirmedMessageCounter++;\n                }\n\n                long bodySize = _currentMessage.getSize();\n                long timestamp = contentHeader.getProperties().getTimestamp();\n\n                try\n                {\n\n                    final MessagePublishInfo messagePublishInfo = _currentMessage.getMessagePublishInfo();\n\n                    final MessageMetaData messageMetaData =\n                            new MessageMetaData(messagePublishInfo,\n                                                contentHeader,\n                                                getConnection().getLastReadTime());\n\n                    final MessageHandle<MessageMetaData> handle = _messageStore.addMessage(messageMetaData);\n                    int bodyCount = _currentMessage.getBodyCount();\n                    if (bodyCount > 0)\n                    {\n                        for (int i = 0; i < bodyCount; i++)\n                        {\n                            ContentBody contentChunk = _currentMessage.getContentChunk(i);\n                            handle.addContent(contentChunk.getPayload());\n                            contentChunk.dispose();\n                        }\n                    }\n                    final StoredMessage<MessageMetaData> storedMessage = handle.allContentAdded();\n\n                    final AMQMessage amqMessage = new AMQMessage(storedMessage, _connection.getReference());\n                    try (MessageReference reference = amqMessage.newReference())\n                    {\n\n                        _currentMessage = null;\n\n\n                        final boolean immediate = messagePublishInfo.isImmediate();\n\n                        final InstanceProperties instanceProperties =\n                                new InstanceProperties()\n                                {\n                                    @Override\n                                    public Object getProperty(final Property prop)\n                                    {\n                                        switch (prop)\n                                        {\n                                            case EXPIRATION:\n                                                return amqMessage.getExpiration();\n                                            case IMMEDIATE:\n                                                return immediate;\n                                            case PERSISTENT:\n                                                return amqMessage.isPersistent();\n                                            case MANDATORY:\n                                                return messagePublishInfo.isMandatory();\n                                            case REDELIVERED:\n                                                return false;\n                                        }\n                                        return null;\n                                    }\n                                };\n\n                        final RoutingResult<AMQMessage> result =\n                                destination.route(amqMessage,\n                                                  amqMessage.getInitialRoutingAddress(),\n                                                  instanceProperties);\n\n                        int enqueues = result.send(_transaction, immediate ? _immediateAction : null);\n                        if (enqueues == 0)\n                        {\n                            boolean mandatory = amqMessage.isMandatory();\n\n                            boolean closeOnNoRoute = _connection.isCloseWhenNoRoute();\n                            if (LOGGER.isDebugEnabled())\n                            {\n                                LOGGER.debug(\"Unroutable message exchange='{}', routing key='{}', mandatory={},\"\n                                        + \" transactionalSession={}, closeOnNoRoute={}, confirmOnPublish={}\",\n                                        exchangeName,\n                                        routingKey,\n                                        mandatory,\n                                        isTransactional(),\n                                        closeOnNoRoute,\n                                        _confirmOnPublish);\n                            }\n\n                            int errorCode = ErrorCodes.NO_ROUTE;\n                            String errorMessage = String.format(\"No route for message with exchange '%s' and routing key '%s'\",\n                                                                exchangeName,\n                                                                routingKey);\n                            if (result.containsReject(RejectType.LIMIT_EXCEEDED))\n                            {\n                                errorCode = ErrorCodes.RESOURCE_ERROR;\n                                errorMessage = errorMessage + \":\" + result.getRejectReason();\n                            }\n\n                            if (mandatory\n                                && isTransactional()\n                                && !_confirmOnPublish\n                                && _connection.isCloseWhenNoRoute())\n                            {\n                                _connection.sendConnectionClose(errorCode, errorMessage, _channelId);\n                            }\n                            else\n                            {\n                                if (mandatory || amqMessage.isImmediate())\n                                {\n                                    if (_confirmOnPublish)\n                                    {\n                                        _connection.writeFrame(new AMQFrame(_channelId,\n                                                                            new BasicNackBody(_confirmedMessageCounter,\n                                                                                              false,\n                                                                                              false)));\n                                    }\n                                    _transaction.addPostTransactionAction(new WriteReturnAction(errorCode,\n                                                                                                errorMessage,\n                                                                                                amqMessage));\n                                }\n                                else\n                                {\n                                    if (_confirmOnPublish)\n                                    {\n                                        _connection.writeFrame(new AMQFrame(_channelId,\n                                                                            new BasicAckBody(_confirmedMessageCounter,\n                                                                                             false)));\n                                    }\n                                    message(ExchangeMessages.DISCARDMSG(exchangeName, routingKey));\n                                }\n                            }\n                        }\n                        else\n                        {\n                            if (_confirmOnPublish)\n                            {\n                                recordFuture(Futures.immediateFuture(null),\n                                             new ServerTransaction.Action()\n                                             {\n                                                 private final long _deliveryTag = _confirmedMessageCounter;\n\n                                                 @Override\n                                                 public void postCommit()\n                                                 {\n                                                     BasicAckBody body = _connection.getMethodRegistry()\n                                                                                    .createBasicAckBody(\n                                                                                            _deliveryTag, false);\n                                                     _connection.writeFrame(body.generateFrame(_channelId));\n                                                 }\n\n                                                 @Override\n                                                 public void onRollback()\n                                                 {\n                                                     final BasicNackBody body = new BasicNackBody(_deliveryTag,\n                                                                                                  false,\n                                                                                                  false);\n                                                     _connection.writeFrame(new AMQFrame(_channelId, body));\n                                                 }\n                                             });\n                            }\n                        }\n                    }\n                }\n                finally\n                {\n                    _connection.registerMessageReceived(bodySize);\n                    if (isTransactional())\n                    {\n                        _connection.registerTransactedMessageReceived();\n                    }\n                    _currentMessage = null;\n                }\n            }\n            catch (AccessControlException e)\n            {\n                _connection.sendConnectionClose(ErrorCodes.ACCESS_REFUSED, e.getMessage(), getChannelId());\n            }\n\n        }\n\n    }\n\n    private void publishContentBody(ContentBody contentBody)\n    {\n        if (LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(debugIdentity() + \" content body received on channel \" + _channelId);\n        }\n\n        try\n        {\n            long currentSize = _currentMessage.addContentBodyFrame(contentBody);\n            if(currentSize > _currentMessage.getSize())\n            {\n                _connection.sendConnectionClose(ErrorCodes.FRAME_ERROR,\n                                                \"More message data received than content header defined\",\n                                                _channelId);\n            }\n            else\n            {\n                deliverCurrentMessageIfComplete();\n            }\n        }\n        catch (RuntimeException e)\n        {\n            // we want to make sure we don't keep a reference to the message in the\n            // event of an error\n            _currentMessage = null;\n            throw e;\n        }\n    }\n\n    public long getNextDeliveryTag()\n    {\n        return ++_deliveryTag;\n    }\n\n    private int getNextConsumerTag()\n    {\n        return ++_consumerTag;\n    }\n\n\n    /**\n     * Subscribe to a queue. We register all subscriptions in the channel so that if the channel is closed we can clean\n     * up all subscriptions, even if the client does not explicitly unsubscribe from all queues.\n     *\n     *\n     * @param tag       the tag chosen by the client (if null, server will generate one)\n     * @param sources     the queues to subscribe to\n     * @param acks      Are acks enabled for this subscriber\n     * @param arguments   Filters to apply to this subscriber\n     *\n     * @param exclusive Flag requesting exclusive access to the queue\n     * @return the consumer tag. This is returned to the subscriber and used in subsequent unsubscribe requests\n     */\n    private AMQShortString consumeFromSource(AMQShortString tag, Collection<MessageSource> sources, boolean acks,\n                                            FieldTable arguments, boolean exclusive, boolean noLocal)\n            throws MessageSource.ExistingConsumerPreventsExclusive,\n                   MessageSource.ExistingExclusiveConsumer,\n                   AMQInvalidArgumentException,\n                   MessageSource.ConsumerAccessRefused, ConsumerTagInUseException, MessageSource.QueueDeleted\n    {\n        if (tag == null)\n        {\n            tag = AMQShortString.createAMQShortString(\"sgen_\" + getNextConsumerTag());\n        }\n\n        if (_tag2SubscriptionTargetMap.containsKey(tag))\n        {\n            throw new ConsumerTagInUseException(\"Consumer already exists with same tag: \" + tag);\n        }\n\n        ConsumerTarget_0_8 target;\n        EnumSet<ConsumerOption> options = EnumSet.noneOf(ConsumerOption.class);\n        final boolean multiQueue = sources.size()>1;\n        if(arguments != null && Boolean.TRUE.equals(arguments.get(AMQPFilterTypes.NO_CONSUME.getValue())))\n        {\n            target = ConsumerTarget_0_8.createBrowserTarget(this, tag, arguments,\n                                                            INFINITE_CREDIT_CREDIT_MANAGER, multiQueue);\n        }\n        else if(acks)\n        {\n            target = ConsumerTarget_0_8.createAckTarget(this, tag, arguments, _creditManager, multiQueue);\n            options.add(ConsumerOption.ACQUIRES);\n            options.add(ConsumerOption.SEES_REQUEUES);\n        }\n        else\n        {\n            target = ConsumerTarget_0_8.createNoAckTarget(this, tag, arguments,\n                                                          INFINITE_CREDIT_CREDIT_MANAGER, multiQueue);\n            options.add(ConsumerOption.ACQUIRES);\n            options.add(ConsumerOption.SEES_REQUEUES);\n        }\n\n        if(exclusive)\n        {\n            options.add(ConsumerOption.EXCLUSIVE);\n        }\n\n\n        // So to keep things straight we put before the call and catch all exceptions from the register and tidy up.\n        // We add before we register as the Async Delivery process may AutoClose the subscriber\n        // so calling _cT2QM.remove before we have done put which was after the register succeeded.\n        // So to keep things straight we put before the call and catch all exceptions from the register and tidy up.\n\n        _tag2SubscriptionTargetMap.put(tag, target);\n\n        try\n        {\n            FilterManager filterManager = FilterManagerFactory.createManager(FieldTable.convertToMap(arguments));\n            if(noLocal)\n            {\n                if(filterManager == null)\n                {\n                    filterManager = new FilterManager();\n                }\n                MessageFilter filter = new NoLocalFilter();\n                filterManager.add(filter.getName(), filter);\n            }\n\n            if(arguments != null && arguments.containsKey(AMQPFilterTypes.REPLAY_PERIOD.toString()))\n            {\n                Object value = arguments.get(AMQPFilterTypes.REPLAY_PERIOD.toString());\n                final long period;\n                if(value instanceof Number)\n                {\n                    period = ((Number)value).longValue();\n                }\n                else if(value instanceof String)\n                {\n                    try\n                    {\n                        period = Long.parseLong(value.toString());\n                    }\n                    catch (NumberFormatException e)\n                    {\n                        throw new AMQInvalidArgumentException(\"Cannot parse value \" + value + \" as a number for filter \" + AMQPFilterTypes.REPLAY_PERIOD.toString());\n                    }\n                }\n                else\n                {\n                    throw new AMQInvalidArgumentException(\"Cannot parse value \" + value + \" as a number for filter \" + AMQPFilterTypes.REPLAY_PERIOD.toString());\n                }\n\n                final long startingFrom = System.currentTimeMillis() - (1000l * period);\n                if(filterManager == null)\n                {\n                    filterManager = new FilterManager();\n                }\n                MessageFilter filter = new ArrivalTimeFilter(startingFrom, period==0);\n                filterManager.add(filter.getName(), filter);\n\n            }\n\n            Integer priority = null;\n            if(arguments != null && arguments.containsKey(\"x-priority\"))\n            {\n                Object value = arguments.get(\"x-priority\");\n                if(value instanceof Number)\n                {\n                    priority = ((Number)value).intValue();\n                }\n                else if(value instanceof String || value instanceof AMQShortString)\n                {\n                    try\n                    {\n                        priority = Integer.parseInt(value.toString());\n                    }\n                    catch (NumberFormatException e)\n                    {\n                        // use default vlaue\n                    }\n                }\n\n            }\n\n\n\n            for(MessageSource source : sources)\n            {\n                source.addConsumer(target,\n                                   filterManager,\n                                   AMQMessage.class,\n                                   AMQShortString.toString(tag),\n                                   options, priority);\n            }\n            target.updateNotifyWorkDesired();\n        }\n        catch (AccessControlException\n                | MessageSource.ExistingExclusiveConsumer\n                | MessageSource.ExistingConsumerPreventsExclusive\n                | MessageSource.QueueDeleted\n                | AMQInvalidArgumentException\n                | MessageSource.ConsumerAccessRefused e)\n        {\n            _tag2SubscriptionTargetMap.remove(tag);\n            throw e;\n        }\n        return tag;\n    }\n\n    /**\n     * Unsubscribe a consumer from a queue.\n     * @param consumerTag\n     * @return true if the consumerTag had a mapped queue that could be unregistered.\n     */\n    private boolean unsubscribeConsumer(AMQShortString consumerTag)\n    {\n        if (LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"Unsubscribing consumer '{}' on channel {}\", consumerTag, this);\n        }\n\n        ConsumerTarget_0_8 target = _tag2SubscriptionTargetMap.remove(consumerTag);\n        if (target != null)\n        {\n            target.close();\n            return true;\n        }\n        else\n        {\n            LOGGER.warn(\"Attempt to unsubscribe consumer with tag '\" + consumerTag + \"' which is not registered.\");\n        }\n        return false;\n    }\n\n    @Override\n    public void close()\n    {\n        close(0, null);\n    }\n\n    public void close(int cause, String message)\n    {\n        if(!_closing.compareAndSet(false, true))\n        {\n            //Channel is already closing\n            return;\n        }\n\n        try\n        {\n            unsubscribeAllConsumers();\n            setDefaultQueue(null);\n            for (Action<? super AMQChannel> task : _taskList)\n            {\n                task.performAction(this);\n            }\n\n            if (_transaction instanceof LocalTransaction)\n            {\n                if (((LocalTransaction) _transaction).hasOutstandingWork())\n                {\n                    _connection.incrementTransactionRollbackCounter();\n                }\n                _connection.decrementTransactionOpenCounter();\n\n                _connection.unregisterTransactionTickers(_transaction);\n            }\n\n            _transaction.rollback();\n\n            requeue();\n        }\n        finally\n        {\n            dispose();\n            LogMessage operationalLogMessage = cause == 0?\n                    ChannelMessages.CLOSE() :\n                    ChannelMessages.CLOSE_FORCED(cause, message);\n            messageWithSubject(operationalLogMessage);\n        }\n    }\n\n    private void messageWithSubject(final LogMessage operationalLogMessage)\n    {\n        getEventLogger().message(_logSubject, operationalLogMessage);\n    }\n\n    private void unsubscribeAllConsumers()\n    {\n        if (LOGGER.isDebugEnabled())\n        {\n            if (!_tag2SubscriptionTargetMap.isEmpty())\n            {\n                LOGGER.debug(\"Unsubscribing all consumers on channel \" + toString());\n            }\n            else\n            {\n                LOGGER.debug(\"No consumers to unsubscribe on channel \" + toString());\n            }\n        }\n\n        Set<AMQShortString> subscriptionTags = new HashSet<>(_tag2SubscriptionTargetMap.keySet());\n        for (AMQShortString tag : subscriptionTags)\n        {\n            unsubscribeConsumer(tag);\n        }\n    }\n\n    /**\n     * Add a message to the channel-based list of unacknowledged messages\n     *  @param entry       the record of the message on the queue that was delivered\n     * @param deliveryTag the delivery tag used when delivering the message (see protocol spec for description of the\n     *                    delivery tag)\n     * @param consumer The consumer that is to acknowledge this message.\n     * @param usesCredit\n     */\n    public void addUnacknowledgedMessage(MessageInstance entry,\n                                         long deliveryTag,\n                                         MessageInstanceConsumer consumer,\n                                         final boolean usesCredit)\n    {\n        if (LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(debugIdentity() + \" Adding unacked message(\" + entry.getMessage().toString() + \" DT:\" + deliveryTag\n                               + \") for \" + consumer + \" on \" + entry.getOwningResource().getName());\n        }\n\n        _unacknowledgedMessageMap.add(deliveryTag, entry, consumer, usesCredit);\n\n    }\n\n    private final String id = \"(\" + System.identityHashCode(this) + \")\";\n\n    private String debugIdentity()\n    {\n        return _channelId + id;\n    }\n\n    /**\n     * Called to attempt re-delivery all outstanding unacknowledged messages on the channel. May result in delivery to\n     * this same channel or to other subscribers.\n     *\n     */\n    private void requeue()\n    {\n        final Map<Long, MessageConsumerAssociation> copy = new LinkedHashMap<>();\n        _unacknowledgedMessageMap.visit(new Visitor()\n        {\n            @Override\n            public boolean callback(final long deliveryTag, final MessageConsumerAssociation messageConsumerPair)\n            {\n                copy.put(deliveryTag, messageConsumerPair);\n                return false;\n            }\n\n            @Override\n            public void visitComplete()\n            {\n\n            }\n        });\n\n        if (!copy.isEmpty())\n        {\n            if (LOGGER.isDebugEnabled())\n            {\n                LOGGER.debug(\"Requeuing {} unacked messages\", copy.size());\n            }\n        }\n\n        for (Map.Entry<Long, MessageConsumerAssociation> entry : copy.entrySet())\n        {\n            MessageInstance unacked = entry.getValue().getMessageInstance();\n            MessageInstanceConsumer consumer = entry.getValue().getConsumer();\n            // Mark message redelivered\n            unacked.setRedelivered();\n            // here we wish to restore credit\n            _unacknowledgedMessageMap.remove(entry.getKey(), true);\n            // Ensure message is released for redelivery\n            unacked.release(consumer);\n        }\n\n    }\n\n    /**\n     * Requeue a single message\n     *\n     * @param deliveryTag The message to requeue\n     *\n     */\n    private void requeue(long deliveryTag)\n    {\n\n        final MessageConsumerAssociation association = _unacknowledgedMessageMap.remove(deliveryTag, true);\n\n        if (association != null)\n        {\n            MessageInstance unacked = association.getMessageInstance();\n            // Mark message redelivered\n            unacked.setRedelivered();\n\n            // Ensure message is released for redelivery\n            unacked.release(association.getConsumer());\n        }\n        else\n        {\n            LOGGER.warn(\"Requested requeue of message: {} but no such delivery tag exists.\", deliveryTag);\n        }\n\n    }\n\n    private boolean isMaxDeliveryCountEnabled(final long deliveryTag)\n    {\n        final MessageInstance queueEntry = _unacknowledgedMessageMap.get(deliveryTag);\n        if (queueEntry != null)\n        {\n            final int maximumDeliveryCount = queueEntry.getMaximumDeliveryCount();\n            return maximumDeliveryCount > 0;\n        }\n\n        return false;\n    }\n\n    private boolean isDeliveredTooManyTimes(final long deliveryTag)\n    {\n        final MessageInstance queueEntry = _unacknowledgedMessageMap.get(deliveryTag);\n        if (queueEntry != null)\n        {\n            final int maximumDeliveryCount = queueEntry.getMaximumDeliveryCount();\n            final int numDeliveries = queueEntry.getDeliveryCount();\n            return maximumDeliveryCount != 0 && numDeliveries >= maximumDeliveryCount;\n        }\n\n        return false;\n    }\n\n    /**\n     * Called to resend all outstanding unacknowledged messages to this same channel.\n     *\n     */\n    private void resend()\n    {\n        final Map<Long, MessageConsumerAssociation> msgToRequeue = new LinkedHashMap<>();\n        final Map<Long, MessageConsumerAssociation> msgToResend = new LinkedHashMap<>();\n\n        if (LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"Unacknowledged messages: {}\", _unacknowledgedMessageMap.size());\n        }\n\n        _unacknowledgedMessageMap.visit(new Visitor()\n        {\n            @Override\n            public boolean callback(final long deliveryTag, final MessageConsumerAssociation association)\n            {\n\n                if (association.getConsumer().isClosed())\n                {\n                    // consumer has gone\n                    msgToRequeue.put(deliveryTag, association);\n                }\n                else\n                {\n                    // Consumer still exists\n                    msgToResend.put(deliveryTag,  association);\n                }\n                return false;\n            }\n\n            @Override\n            public void visitComplete()\n            {\n            }\n        });\n\n\n        for (Map.Entry<Long, MessageConsumerAssociation> entry : msgToResend.entrySet())\n        {\n            long deliveryTag = entry.getKey();\n            MessageInstance message = entry.getValue().getMessageInstance();\n            MessageInstanceConsumer consumer = entry.getValue().getConsumer();\n\n            // Without any details from the client about what has been processed we have to mark\n            // all messages in the unacked map as redelivered.\n            message.setRedelivered();\n\n            if (message.makeAcquisitionUnstealable(consumer))\n            {\n                message.decrementDeliveryCount();\n\n                consumer.getTarget().send(consumer, message, false);\n                // remove from unacked map - don't want to restore credit though(!)\n                _unacknowledgedMessageMap.remove(deliveryTag, false);\n            }\n            else\n            {\n                msgToRequeue.put(deliveryTag, entry.getValue());\n            }\n        }\n\n        // Process Messages to Requeue at the front of the queue\n        for (Map.Entry<Long, MessageConsumerAssociation> entry : msgToRequeue.entrySet())\n        {\n            long deliveryTag = entry.getKey();\n            MessageInstance message = entry.getValue().getMessageInstance();\n            MessageInstanceConsumer consumer = entry.getValue().getConsumer();\n\n            //Amend the delivery counter as the client hasn't seen these messages yet.\n            message.decrementDeliveryCount();\n\n            // here we do wish to restore credit\n            _unacknowledgedMessageMap.remove(deliveryTag, true);\n\n            message.setRedelivered();\n            message.release(consumer);\n        }\n    }\n\n\n    private UnacknowledgedMessageMap getUnacknowledgedMessageMap()\n    {\n        return _unacknowledgedMessageMap;\n    }\n\n    /**\n     * Called from the ChannelFlowHandler to suspend this Channel\n     * @param suspended boolean, should this Channel be suspended\n     */\n    private void setSuspended(boolean suspended)\n    {\n        boolean wasSuspended = _suspended.getAndSet(suspended);\n        if (wasSuspended != suspended)\n        {\n            // Log Flow Started before we start the subscriptions\n            if (!suspended && _logChannelFlowMessages)\n            {\n                messageWithSubject(ChannelMessages.FLOW(\"Started\"));\n            }\n\n            // Here we have become unsuspended and so we ask each the queue to\n            // perform an Async delivery for each of the subscriptions in this\n            // Channel. The alternative would be to ensure that the subscription\n            // had received the change in suspension state. That way the logic\n            // behind deciding to start an async delivery was located with the\n            // Subscription.\n            if (wasSuspended)\n            {\n                // may need to deliver queued messages\n                for (ConsumerTarget_0_8 s : getConsumerTargets())\n                {\n                    for(MessageInstanceConsumer sub : s.getConsumers())\n                    {\n                        sub.externalStateChange();\n                    }\n                }\n            }\n\n            // Log Suspension only after we have confirmed all suspensions are\n            // stopped.\n            if (suspended && _logChannelFlowMessages)\n            {\n                messageWithSubject(ChannelMessages.FLOW(\"Stopped\"));\n            }\n\n        }\n    }\n\n    private void commit(final Runnable immediateAction, boolean async)\n    {\n\n\n        if(async && _transaction instanceof LocalTransaction)\n        {\n\n            ((LocalTransaction)_transaction).commitAsync(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    try\n                    {\n                        immediateAction.run();\n                    }\n                    finally\n                    {\n                        _connection.incrementTransactionBeginCounter();\n                    }\n                }\n            });\n        }\n        else\n        {\n            _transaction.commit(immediateAction);\n            _connection.incrementTransactionBeginCounter();\n        }\n    }\n\n    private void rollback(Runnable postRollbackTask)\n    {\n\n        // stop all subscriptions\n        _rollingBack = true;\n        boolean requiresSuspend = _suspended.compareAndSet(false,true);  // TODO This is probably superfluous owing to the\n        // message assignment suspended logic in NBC.\n\n        try\n        {\n            _transaction.rollback();\n        }\n        finally\n        {\n            _rollingBack = false;\n            _connection.incrementTransactionRollbackCounter();\n            _connection.incrementTransactionBeginCounter();\n        }\n\n        postRollbackTask.run();\n\n        for(MessageConsumerAssociation association : _resendList)\n        {\n            final MessageInstance messageInstance = association.getMessageInstance();\n            final MessageInstanceConsumer consumer = association.getConsumer();\n            if (consumer.isClosed())\n            {\n                messageInstance.release(consumer);\n            }\n            else\n            {\n                if (messageInstance.makeAcquisitionUnstealable(consumer)\n                    && _creditManager.useCreditForMessage(association.getSize()))\n                {\n                    consumer.getTarget().send(consumer, messageInstance, false);\n                }\n                else\n                {\n                    messageInstance.release(consumer);\n                }\n            }\n        }\n        _resendList.clear();\n\n        if(requiresSuspend)\n        {\n            _suspended.set(false);\n            for(ConsumerTarget_0_8 target : getConsumerTargets())\n            {\n                for(MessageInstanceConsumer sub : target.getConsumers())\n                {\n                    sub.externalStateChange();\n                }\n            }\n\n        }\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"(\"+ _suspended.get() + \", \" + _closing.get() + \", \" + _connection.isClosing() + \") \"+\"[\"+ _connection.toString()+\":\"+_channelId+\"]\";\n    }\n\n    @Override\n    public boolean isClosing()\n    {\n        return _closing.get() || getConnection().isClosing();\n    }\n\n    public AMQPConnection_0_8<?> getConnection()\n    {\n        return _connection;\n    }\n\n    private void setCredit(final long prefetchSize, final int prefetchCount)\n    {\n        if (!_prefetchLoggedForChannel)\n        {\n            message(ChannelMessages.PREFETCH_SIZE(prefetchSize, prefetchCount));\n            _prefetchLoggedForChannel = true;\n        }\n\n        if (prefetchCount <= 1 && prefetchSize == 0 )\n        {\n            _logChannelFlowMessages = false;\n        }\n        boolean hasCredit = _creditManager.hasCredit();\n        _creditManager.setCreditLimits(prefetchSize, prefetchCount);\n        if(hasCredit != _creditManager.hasCredit())\n        {\n            updateAllConsumerNotifyWorkDesired();\n        }\n    }\n\n    public ClientDeliveryMethod getClientDeliveryMethod()\n    {\n        return _clientDeliveryMethod;\n    }\n\n    public Subject getSubject()\n    {\n        return _subject;\n    }\n\n    private boolean hasCurrentMessage()\n    {\n        return _currentMessage != null;\n    }\n\n    public boolean isChannelFlow()\n    {\n        return _channelFlow;\n    }\n\n    private class NoLocalFilter implements MessageFilter\n    {\n\n        private final Object _connectionReference;\n\n        public NoLocalFilter()\n        {\n            _connectionReference = getConnectionReference();\n        }\n\n        @Override\n        public String getName()\n        {\n            return AMQPFilterTypes.NO_LOCAL.toString();\n        }\n\n        @Override\n        public boolean matches(final Filterable message)\n        {\n            return message.getConnectionReference() != _connectionReference;\n        }\n\n        @Override\n        public boolean startAtTail()\n        {\n            return false;\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"NoLocalFilter[]\";\n        }\n    }\n\n    private class GetDeliveryMethod implements ClientDeliveryMethod\n    {\n        private final MessageSource _queue;\n        private boolean _deliveredMessage;\n\n        public GetDeliveryMethod(final MessageSource queue)\n        {\n            _queue = queue;\n        }\n\n        @Override\n        public long deliverToClient(final ConsumerTarget_0_8 target, final AMQMessage message,\n                                    final InstanceProperties props, final long deliveryTag)\n        {\n\n            int queueSize = _queue instanceof Queue ? ((Queue<?>)_queue).getQueueDepthMessages() : 0;\n            long size = _connection.getProtocolOutputConverter().writeGetOk(message,\n                                                                            props,\n                                                                            AMQChannel.this.getChannelId(),\n                                                                            deliveryTag,\n                                                                            queueSize);\n\n            _deliveredMessage = true;\n            return size;\n        }\n\n        public boolean hasDeliveredMessage()\n        {\n            return _deliveredMessage;\n        }\n    }\n\n\n    private class ImmediateAction implements Action<MessageInstance>\n    {\n\n        public ImmediateAction()\n        {\n        }\n\n        @Override\n        public void performAction(MessageInstance entry)\n        {\n            if (!entry.getDeliveredToConsumer() && entry.acquire())\n            {\n\n                ServerTransaction txn = new LocalTransaction(_messageStore);\n                final AMQMessage message = (AMQMessage) entry.getMessage();\n                MessageReference ref = message.newReference();\n                try\n                {\n                    entry.delete();\n                    txn.dequeue(entry.getEnqueueRecord(),\n                                new ServerTransaction.Action()\n                                {\n                                    @Override\n                                    public void postCommit()\n                                    {\n                                        final ProtocolOutputConverter outputConverter =\n                                                    _connection.getProtocolOutputConverter();\n\n                                        outputConverter.writeReturn(message.getMessagePublishInfo(),\n                                                                    message.getContentHeaderBody(),\n                                                                    message,\n                                                                    _channelId,\n                                                                    ErrorCodes.NO_CONSUMERS,\n                                                                    IMMEDIATE_DELIVERY_REPLY_TEXT);\n\n                                    }\n\n                                    @Override\n                                    public void onRollback()\n                                    {\n\n                                    }\n                                }\n                               );\n                    txn.commit();\n                }\n                finally\n                {\n                    ref.release();\n                }\n            }\n        }\n    }\n\n    private class MessageAcknowledgeAction implements ServerTransaction.Action\n    {\n        private Collection<MessageConsumerAssociation> _ackedMessages;\n\n        public MessageAcknowledgeAction(Collection<MessageConsumerAssociation> ackedMessages)\n        {\n            _ackedMessages = ackedMessages;\n        }\n\n        @Override\n        public void postCommit()\n        {\n            try\n            {\n                for(MessageConsumerAssociation association : _ackedMessages)\n                {\n                    association.getMessageInstance().delete();\n                }\n            }\n            finally\n            {\n                _ackedMessages = Collections.emptySet();\n            }\n\n        }\n\n        @Override\n        public void onRollback()\n        {\n            // explicit rollbacks resend the message after the rollback-ok is sent\n            if(_rollingBack)\n            {\n                for(MessageConsumerAssociation association : _ackedMessages)\n                {\n                    association.getMessageInstance().makeAcquisitionStealable();\n                }\n                _resendList.addAll(_ackedMessages);\n            }\n            else\n            {\n                try\n                {\n                    for(MessageConsumerAssociation association : _ackedMessages)\n                    {\n                        final MessageInstance messageInstance = association.getMessageInstance();\n                        messageInstance.release(association.getConsumer());\n                    }\n                }\n                finally\n                {\n                    _ackedMessages = Collections.emptySet();\n                }\n            }\n\n        }\n    }\n\n    private class WriteReturnAction implements ServerTransaction.Action\n    {\n        private final int _errorCode;\n        private final String _description;\n        private final MessageReference<AMQMessage> _reference;\n\n        public WriteReturnAction(int errorCode,\n                                 String description,\n                                 AMQMessage message)\n        {\n            _errorCode = errorCode;\n            _description = description;\n            _reference = message.newReference();\n        }\n\n        @Override\n        public void postCommit()\n        {\n            AMQMessage message = _reference.getMessage();\n            _connection.getProtocolOutputConverter().writeReturn(message.getMessagePublishInfo(),\n                                                          message.getContentHeaderBody(),\n                                                          message,\n                                                          _channelId,\n                                                          _errorCode,\n                                                          AMQShortString.validValueOf(_description));\n            _reference.release();\n        }\n\n        @Override\n        public void onRollback()\n        {\n            _reference.release();\n        }\n    }\n\n    @Override\n    public synchronized void block()\n    {\n        if(_blockingEntities.add(this))\n        {\n\n            if(_blocking.compareAndSet(false,true))\n            {\n                messageWithSubject(ChannelMessages.FLOW_ENFORCED(\"** All Queues **\"));\n\n\n                getConnection().notifyWork(this);\n            }\n        }\n    }\n\n    @Override\n    public synchronized void unblock()\n    {\n        if(_blockingEntities.remove(this))\n        {\n            if(_blockingEntities.isEmpty() && _blocking.compareAndSet(true,false))\n            {\n                messageWithSubject(ChannelMessages.FLOW_REMOVED());\n                getConnection().notifyWork(this);\n            }\n        }\n    }\n\n    @Override\n    public synchronized void block(Queue<?> queue)\n    {\n        if(_blockingEntities.add(queue))\n        {\n\n            if(_blocking.compareAndSet(false,true))\n            {\n                messageWithSubject(ChannelMessages.FLOW_ENFORCED(queue.getName()));\n                getConnection().notifyWork(this);\n\n            }\n        }\n    }\n\n    @Override\n    public synchronized void unblock(Queue<?> queue)\n    {\n        if(_blockingEntities.remove(queue))\n        {\n            if(_blockingEntities.isEmpty() && _blocking.compareAndSet(true,false) && !isClosing())\n            {\n                messageWithSubject(ChannelMessages.FLOW_REMOVED());\n                getConnection().notifyWork(this);\n            }\n        }\n    }\n\n    @Override\n    public void transportStateChanged()\n    {\n        updateAllConsumerNotifyWorkDesired();\n        _creditManager.restoreCredit(0, 0);\n        INFINITE_CREDIT_CREDIT_MANAGER.restoreCredit(0, 0);\n        if (!_consumersWithPendingWork.isEmpty() && !getAMQPConnection().isTransportBlockedForWriting())\n        {\n            getAMQPConnection().notifyWork(this);\n        }\n    }\n\n    void updateAllConsumerNotifyWorkDesired()\n    {\n        for(ConsumerTarget_0_8 target : _tag2SubscriptionTargetMap.values())\n        {\n            target.updateNotifyWorkDesired();\n        }\n    }\n\n    @Override\n    public Object getConnectionReference()\n    {\n        return getConnection().getReference();\n    }\n\n    @Override\n    public int getUnacknowledgedMessageCount()\n    {\n        return getUnacknowledgedMessageMap().size();\n    }\n\n    private void sendFlow(boolean flow)\n    {\n        MethodRegistry methodRegistry = _connection.getMethodRegistry();\n        AMQMethodBody responseBody = methodRegistry.createChannelFlowBody(flow);\n        _connection.writeFrame(responseBody.generateFrame(_channelId));\n    }\n\n    @Override\n    public boolean getBlocking()\n    {\n        return _blocking.get();\n    }\n\n    public NamedAddressSpace getAddressSpace()\n    {\n        return getConnection().getAddressSpace();\n    }\n\n    private void deadLetter(long deliveryTag)\n    {\n        final UnacknowledgedMessageMap unackedMap = getUnacknowledgedMessageMap();\n        final MessageConsumerAssociation association = unackedMap.remove(deliveryTag, true);\n\n        if (association == null)\n        {\n            LOGGER.warn(\"No message found, unable to DLQ delivery tag: \" + deliveryTag);\n        }\n        else\n        {\n\n            final MessageInstance messageInstance = association.getMessageInstance();\n            final ServerMessage msg = messageInstance.getMessage();\n            int requeues = 0;\n            if (messageInstance.makeAcquisitionUnstealable(association.getConsumer()))\n            {\n                requeues = messageInstance.routeToAlternate(new Action<MessageInstance>()\n                {\n                    @Override\n                    public void performAction(final MessageInstance requeueEntry)\n                    {\n                        messageWithSubject(ChannelMessages.DEADLETTERMSG(msg.getMessageNumber(),\n                                                                         requeueEntry.getOwningResource()\n                                                                               .getName()));\n                    }\n                }, null);\n            }\n\n            if(requeues == 0)\n            {\n\n                final TransactionLogResource owningResource = messageInstance.getOwningResource();\n                if(owningResource instanceof Queue)\n                {\n                    final Queue<?> queue = (Queue<?>) owningResource;\n\n                    final MessageDestination alternateBindingDestination = queue.getAlternateBindingDestination();\n\n                    if (alternateBindingDestination == null)\n                    {\n                        messageWithSubject(ChannelMessages.DISCARDMSG_NOALTEXCH(msg.getMessageNumber(),\n                                                                                queue.getName(),\n                                                                                msg.getInitialRoutingAddress()));\n\n                    }\n                    else\n                    {\n                        messageWithSubject(ChannelMessages.DISCARDMSG_NOROUTE(msg.getMessageNumber(),\n                                                                              alternateBindingDestination.getName()));\n                    }\n                }\n            }\n\n        }\n    }\n\n    @Override\n    public void recordFuture(final ListenableFuture<Void> future, final ServerTransaction.Action action)\n    {\n        _unfinishedCommandsQueue.add(new AsyncCommand(future, action));\n    }\n\n    private void sync()\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"sync() called on channel \" + debugIdentity());\n        }\n\n        AsyncCommand cmd;\n        while((cmd = _unfinishedCommandsQueue.poll()) != null)\n        {\n            cmd.complete();\n        }\n        if(_transaction instanceof LocalTransaction)\n        {\n            ((LocalTransaction)_transaction).sync();\n        }\n    }\n\n    @Override\n    public long getTransactionStartTimeLong()\n    {\n        ServerTransaction serverTransaction = _transaction;\n        if (serverTransaction.isTransactional())\n        {\n            return serverTransaction.getTransactionStartTime();\n        }\n        else\n        {\n            return 0L;\n        }\n    }\n\n    @Override\n    public long getTransactionUpdateTimeLong()\n    {\n        ServerTransaction serverTransaction = _transaction;\n        if (serverTransaction.isTransactional())\n        {\n            return serverTransaction.getTransactionUpdateTime();\n        }\n        else\n        {\n            return 0L;\n        }\n    }\n\n    @Override\n    public void receiveAccessRequest(final AMQShortString realm,\n                                     final boolean exclusive,\n                                     final boolean passive,\n                                     final boolean active, final boolean write, final boolean read)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] AccessRequest[\" +\" realm: \" + realm +\n                          \" exclusive: \" + exclusive +\n                          \" passive: \" + passive +\n                          \" active: \" + active +\n                          \" write: \" + write + \" read: \" + read + \" ]\");\n        }\n\n        MethodRegistry methodRegistry = _connection.getMethodRegistry();\n\n        if (ProtocolVersion.v0_91.equals(_connection.getProtocolVersion()))\n        {\n            _connection.sendConnectionClose(ErrorCodes.COMMAND_INVALID,\n                                            \"AccessRequest not present in AMQP versions other than 0-8, 0-9\",\n                                            _channelId);\n        }\n        else\n        {\n            // We don't implement access control class, but to keep clients happy that expect it\n            // always use the \"0\" ticket.\n            AccessRequestOkBody response = methodRegistry.createAccessRequestOkBody(0);\n            sync();\n            _connection.writeFrame(response.generateFrame(_channelId));\n        }\n    }\n\n    @Override\n    public void receiveBasicAck(final long deliveryTag, final boolean multiple)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] BasicAck[\" +\" deliveryTag: \" + deliveryTag + \" multiple: \" + multiple + \" ]\");\n        }\n\n        Collection<MessageConsumerAssociation> ackedMessages = _unacknowledgedMessageMap.acknowledge(deliveryTag, multiple);\n\n        if (!ackedMessages.isEmpty())\n        {\n            final Collection<MessageInstance> messages =\n                    Collections2.transform(ackedMessages, MESSAGE_INSTANCE_FUNCTION);\n            _transaction.dequeue(messages, new MessageAcknowledgeAction(ackedMessages));\n        }\n\n        /*\n        The AMQP 0-9-1 spec requires to raise a channel exception \"precondition-failed\"\n        when delivery tag is not valid:\n        {quote}\n          The server MUST validate that a non-zero delivery-tag refers to a delivered message, and raise a channel\n          exception if this is not the case. On a transacted channel, this check MUST be done immediately and not\n          delayed until a Tx.Commit. Specifically, a client MUST not acknowledge the same message more than once.\n        {quote}\n\n        The current broker behaviour is spec incompliant but it is kept for backward compatibility.\n        It should close the channel as below:\n\n        if (ackedMessages.isEmpty())\n            closeChannel(ErrorCodes.NOT_ALLOWED, \"precondition-failed: Delivery tag '%d' is not valid.\");\n        */\n    }\n\n    @Override\n    public void receiveBasicCancel(final AMQShortString consumerTag, final boolean nowait)\n    {\n\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] BasicCancel[\" +\" consumerTag: \" + consumerTag + \" noWait: \" + nowait + \" ]\");\n        }\n\n        unsubscribeConsumer(consumerTag);\n        if (!nowait)\n        {\n            MethodRegistry methodRegistry = _connection.getMethodRegistry();\n            BasicCancelOkBody cancelOkBody = methodRegistry.createBasicCancelOkBody(consumerTag);\n            sync();\n            _connection.writeFrame(cancelOkBody.generateFrame(_channelId));\n        }\n    }\n\n    @Override\n    public void receiveBasicConsume(final AMQShortString queue,\n                                    final AMQShortString consumerTag,\n                                    final boolean noLocal,\n                                    final boolean noAck,\n                                    final boolean exclusive, final boolean nowait, final FieldTable arguments)\n    {\n\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] BasicConsume[\" +\" queue: \" + queue +\n                          \" consumerTag: \" + consumerTag +\n                          \" noLocal: \" + noLocal +\n                          \" noAck: \" + noAck +\n                          \" exclusive: \" + exclusive + \" nowait: \" + nowait + \" arguments: \" + arguments + \" ]\");\n        }\n\n        AMQShortString consumerTag1 = consumerTag;\n        NamedAddressSpace vHost = _connection.getAddressSpace();\n        sync();\n        String queueName = AMQShortString.toString(queue);\n\n        MessageSource queue1 = queueName == null ? getDefaultQueue() : vHost.getAttainedMessageSource(queueName);\n        final Collection<MessageSource> sources = new HashSet<>();\n\n        if (arguments != null && arguments.get(\"x-multiqueue\") instanceof Collection)\n        {\n            for (Object object : (Collection<Object>) arguments.get(\"x-multiqueue\"))\n            {\n                String sourceName = String.valueOf(object);\n                sourceName = sourceName.trim();\n                if (sourceName.length() != 0)\n                {\n                    MessageSource source = vHost.getAttainedMessageSource(sourceName);\n                    if (source == null)\n                    {\n                        sources.clear();\n                        break;\n                    }\n                    else\n                    {\n                        sources.add(source);\n                    }\n                }\n            }\n            queueName = arguments.get(\"x-multiqueue\").toString();\n        }\n        else if (queue1 != null)\n        {\n            sources.add(queue1);\n        }\n\n\n        if (sources.isEmpty())\n        {\n            if (LOGGER.isDebugEnabled())\n            {\n                LOGGER.debug(\"No queue for '\" + queueName + \"'\");\n            }\n            if (queueName != null)\n            {\n                closeChannel(ErrorCodes.NOT_FOUND, \"No such queue, '\" + queueName + \"'\");\n            }\n            else\n            {\n                _connection.sendConnectionClose(ErrorCodes.NOT_ALLOWED,\n                                                \"No queue name provided, no default queue defined.\", _channelId);\n            }\n        }\n        else\n        {\n            try\n            {\n                consumerTag1 = consumeFromSource(consumerTag1,\n                                                 sources,\n                                                 !noAck,\n                                                 arguments,\n                                                 exclusive,\n                                                 noLocal);\n                if (!nowait)\n                {\n                    MethodRegistry methodRegistry = _connection.getMethodRegistry();\n                    AMQMethodBody responseBody = methodRegistry.createBasicConsumeOkBody(consumerTag1);\n                    _connection.writeFrame(responseBody.generateFrame(_channelId));\n\n                }\n            }\n            catch (ConsumerTagInUseException cte)\n            {\n\n                _connection.sendConnectionClose(ErrorCodes.NOT_ALLOWED,\n                        \"Non-unique consumer tag, '\" + consumerTag1\n                                + \"'\", _channelId);\n            }\n            catch (AMQInvalidArgumentException ise)\n            {\n                _connection.sendConnectionClose(ErrorCodes.ARGUMENT_INVALID, ise.getMessage(), _channelId);\n\n\n            }\n            catch (Queue.ExistingExclusiveConsumer e)\n            {\n                _connection.sendConnectionClose(ErrorCodes.ACCESS_REFUSED,\n                        \"Cannot subscribe to queue '\"\n                                + queue1.getName()\n                                + \"' as it already has an existing exclusive consumer\", _channelId);\n\n            }\n            catch (Queue.ExistingConsumerPreventsExclusive e)\n            {\n                _connection.sendConnectionClose(ErrorCodes.ACCESS_REFUSED,\n                        \"Cannot subscribe to queue '\"\n                                + queue1.getName()\n                                + \"' exclusively as it already has a consumer\", _channelId);\n\n            }\n            catch (AccessControlException e)\n            {\n                _connection.sendConnectionClose(ErrorCodes.ACCESS_REFUSED, \"Cannot subscribe to queue '\"\n                                                                           + queue1.getName()\n                                                                           + \"' permission denied\", _channelId);\n\n            }\n            catch (MessageSource.ConsumerAccessRefused consumerAccessRefused)\n            {\n                _connection.sendConnectionClose(ErrorCodes.ACCESS_REFUSED,\n                        \"Cannot subscribe to queue '\"\n                                + queue1.getName()\n                                + \"' as it already has an incompatible exclusivity policy\", _channelId);\n\n            }\n            catch (MessageSource.QueueDeleted queueDeleted)\n            {\n                _connection.sendConnectionClose(ErrorCodes.NOT_FOUND,\n                                                \"Cannot subscribe to queue '\"\n                                                + queue1.getName()\n                                                + \"' as it has been deleted\", _channelId);\n            }\n        }\n    }\n\n    @Override\n    public void receiveBasicGet(final AMQShortString queueName, final boolean noAck)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] BasicGet[\" +\" queue: \" + queueName + \" noAck: \" + noAck + \" ]\");\n        }\n\n        NamedAddressSpace vHost = _connection.getAddressSpace();\n        sync();\n        MessageSource queue = queueName == null ? getDefaultQueue() : vHost.getAttainedMessageSource(queueName.toString());\n        if (queue == null)\n        {\n            if (LOGGER.isDebugEnabled())\n            {\n                LOGGER.debug(\"No queue for '\" + queueName + \"'\");\n            }\n            if (queueName != null)\n            {\n                _connection.sendConnectionClose(ErrorCodes.NOT_FOUND, \"No such queue, '\" + queueName + \"'\", _channelId);\n\n            }\n            else\n            {\n                _connection.sendConnectionClose(ErrorCodes.NOT_ALLOWED,\n                                                \"No queue name provided, no default queue defined.\", _channelId);\n\n            }\n        }\n        else\n        {\n\n            try\n            {\n                if (!performGet(queue, !noAck))\n                {\n                    MethodRegistry methodRegistry = _connection.getMethodRegistry();\n\n                    BasicGetEmptyBody responseBody = methodRegistry.createBasicGetEmptyBody(null);\n\n                    _connection.writeFrame(responseBody.generateFrame(_channelId));\n                }\n            }\n            catch (AccessControlException e)\n            {\n                _connection.sendConnectionClose(ErrorCodes.ACCESS_REFUSED, e.getMessage(), _channelId);\n            }\n            catch (MessageSource.ExistingExclusiveConsumer e)\n            {\n                _connection.sendConnectionClose(ErrorCodes.NOT_ALLOWED, \"Queue has an exclusive consumer\", _channelId);\n            }\n            catch (MessageSource.ExistingConsumerPreventsExclusive e)\n            {\n                _connection.sendConnectionClose(ErrorCodes.INTERNAL_ERROR,\n                        \"The GET request has been evaluated as an exclusive consumer, \" +\n                                \"this is likely due to a programming error in the Qpid broker\", _channelId);\n            }\n            catch (MessageSource.ConsumerAccessRefused consumerAccessRefused)\n            {\n                _connection.sendConnectionClose(ErrorCodes.NOT_ALLOWED,\n                                                \"Queue has an incompatible exclusivity policy\", _channelId);\n            }\n            catch (MessageSource.QueueDeleted queueDeleted)\n            {\n                _connection.sendConnectionClose(ErrorCodes.NOT_FOUND, \"Queue has been deleted\", _channelId);\n            }\n        }\n    }\n\n    @Override\n    public void receiveBasicPublish(final AMQShortString exchangeName,\n                                    final AMQShortString routingKey,\n                                    final boolean mandatory,\n                                    final boolean immediate)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] BasicPublish[\" +\" exchange: \" + exchangeName +\n                          \" routingKey: \" + routingKey +\n                          \" mandatory: \" + mandatory +\n                          \" immediate: \" + immediate + \" ]\");\n        }\n\n\n\n        NamedAddressSpace vHost = _connection.getAddressSpace();\n\n        if(blockingTimeoutExceeded())\n        {\n            message(ChannelMessages.FLOW_CONTROL_IGNORED());\n            closeChannel(ErrorCodes.MESSAGE_TOO_LARGE,\n                         \"Channel flow control was requested, but not enforced by sender\");\n        }\n        else\n        {\n            MessageDestination destination;\n\n            if (isDefaultExchange(exchangeName))\n            {\n                destination = vHost.getDefaultDestination();\n            }\n            else\n            {\n                destination = vHost.getAttainedMessageDestination(exchangeName.toString());\n            }\n\n            // if the exchange does not exist we raise a channel exception\n            if (destination == null)\n            {\n                closeChannel(ErrorCodes.NOT_FOUND, \"Unknown exchange name: '\" + exchangeName + \"'\");\n            }\n            else\n            {\n\n                MessagePublishInfo info = new MessagePublishInfo(exchangeName,\n                                                                 immediate,\n                                                                 mandatory,\n                                                                 routingKey);\n\n                try\n                {\n                    setPublishFrame(info, destination);\n                }\n                catch (AccessControlException e)\n                {\n                    _connection.sendConnectionClose(ErrorCodes.ACCESS_REFUSED, e.getMessage(), getChannelId());\n\n                }\n            }\n        }\n    }\n\n    private boolean blockingTimeoutExceeded()\n    {\n\n        return _wireBlockingState && (System.currentTimeMillis() - _blockTime) > _blockingTimeout;\n    }\n\n    @Override\n    public void receiveBasicQos(final long prefetchSize, final int prefetchCount, final boolean global)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] BasicQos[\" +\" prefetchSize: \" + prefetchSize + \" prefetchCount: \" + prefetchCount + \" global: \" + global + \" ]\");\n        }\n\n        sync();\n        setCredit(prefetchSize, prefetchCount);\n\n        MethodRegistry methodRegistry = _connection.getMethodRegistry();\n        AMQMethodBody responseBody = methodRegistry.createBasicQosOkBody();\n        _connection.writeFrame(responseBody.generateFrame(getChannelId()));\n\n    }\n\n    @Override\n    public void receiveBasicRecover(final boolean requeue, final boolean sync)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] BasicRecover[\" + \" requeue: \" + requeue + \" sync: \" + sync + \" ]\");\n        }\n\n        if (requeue)\n        {\n            requeue();\n        }\n        else\n        {\n            resend();\n        }\n\n        if (sync)\n        {\n            MethodRegistry methodRegistry = _connection.getMethodRegistry();\n            AMQMethodBody recoverOk = methodRegistry.createBasicRecoverSyncOkBody();\n            sync();\n            _connection.writeFrame(recoverOk.generateFrame(getChannelId()));\n\n        }\n\n    }\n\n    @Override\n    public void receiveBasicReject(final long deliveryTag, final boolean requeue)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] BasicReject[\" +\" deliveryTag: \" + deliveryTag + \" requeue: \" + requeue + \" ]\");\n        }\n\n        MessageInstance message = getUnacknowledgedMessageMap().get(deliveryTag);\n\n        if (message == null)\n        {\n            LOGGER.warn(\"Dropping reject request as message is null for tag:\" + deliveryTag);\n        }\n        else\n        {\n\n            if (message.getMessage() == null)\n            {\n                LOGGER.warn(\"Message has already been purged, unable to Reject.\");\n            }\n            else\n            {\n\n                if (LOGGER.isDebugEnabled())\n                {\n                    LOGGER.debug(\"Rejecting: DT:\" + deliveryTag\n                                                             + \"-\" + message.getMessage() +\n                                  \": Requeue:\" + requeue\n                                  +\n                                  \" on channel:\" + debugIdentity());\n                }\n\n                if (requeue)\n                {\n                    message.decrementDeliveryCount();\n\n                    requeue(deliveryTag);\n                }\n                else\n                {\n                    // Since the JMS client abuses the reject flag for requeing after rollback, we won't set reject here\n                    // as it would prevent redelivery\n                    // message.reject();\n\n                    final boolean maxDeliveryCountEnabled = isMaxDeliveryCountEnabled(deliveryTag);\n                    if (LOGGER.isDebugEnabled())\n                    {\n                        LOGGER.debug(\"maxDeliveryCountEnabled: \"\n                                      + maxDeliveryCountEnabled\n                                      + \" deliveryTag \"\n                                      + deliveryTag);\n                    }\n                    if (maxDeliveryCountEnabled)\n                    {\n                        final boolean deliveredTooManyTimes = isDeliveredTooManyTimes(deliveryTag);\n                        if (LOGGER.isDebugEnabled())\n                        {\n                            LOGGER.debug(\"deliveredTooManyTimes: \"\n                                          + deliveredTooManyTimes\n                                          + \" deliveryTag \"\n                                          + deliveryTag);\n                        }\n                        if (deliveredTooManyTimes)\n                        {\n                            deadLetter(deliveryTag);\n                        }\n                        else\n                        {\n                            //this requeue represents a message rejected because of a recover/rollback that we\n                            //are not ready to DLQ. We rely on the reject command to resend from the unacked map\n                            //and therefore need to increment the delivery counter so we cancel out the effect\n                            //of the AMQChannel#resend() decrement.\n                            message.incrementDeliveryCount();\n                        }\n                    }\n                    else\n                    {\n                        requeue(deliveryTag);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public void receiveChannelClose(final int replyCode,\n                                    final AMQShortString replyText,\n                                    final int classId,\n                                    final int methodId)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] ChannelClose[\" +\" replyCode: \" + replyCode + \" replyText: \" + replyText + \" classId: \" + classId + \" methodId: \" + methodId + \" ]\");\n        }\n\n\n        sync();\n        _connection.closeChannel(this);\n\n        _connection.writeFrame(new AMQFrame(getChannelId(),\n                                            _connection.getMethodRegistry().createChannelCloseOkBody()));\n    }\n\n    @Override\n    public void receiveChannelCloseOk()\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] ChannelCloseOk\");\n        }\n\n        _connection.closeChannelOk(getChannelId());\n    }\n\n    @Override\n    public void receiveMessageContent(final QpidByteBuffer data)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] MessageContent[\" +\" data: \" + hex(data,_connection.getBinaryDataLimit()) + \" ] \");\n        }\n\n        if(hasCurrentMessage())\n        {\n            publishContentBody(new ContentBody(data));\n        }\n        else\n        {\n            _connection.sendConnectionClose(ErrorCodes.COMMAND_INVALID,\n                                            \"Attempt to send a content header without first sending a publish frame\",\n                                            _channelId);\n        }\n    }\n\n    @Override\n    public void receiveMessageHeader(final BasicContentHeaderProperties properties, final long bodySize)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] MessageHeader[ properties: {\" + properties + \"} bodySize: \" + bodySize + \" ]\");\n        }\n\n        if(hasCurrentMessage())\n        {\n            if(bodySize > _connection.getMaxMessageSize())\n            {\n                properties.dispose();\n                closeChannel(ErrorCodes.MESSAGE_TOO_LARGE,\n                             \"Message size of \" + bodySize + \" greater than allowed maximum of \" + _connection.getMaxMessageSize());\n            }\n            else\n            {\n                publishContentHeader(new ContentHeaderBody(properties, bodySize));\n            }\n        }\n        else\n        {\n            properties.dispose();\n            _connection.sendConnectionClose(ErrorCodes.COMMAND_INVALID,\n                                            \"Attempt to send a content header without first sending a publish frame\",\n                                            _channelId);\n        }\n    }\n\n    @Override\n    public boolean ignoreAllButCloseOk()\n    {\n        return _connection.ignoreAllButCloseOk() || _connection.channelAwaitingClosure(_channelId);\n    }\n\n    @Override\n    public void receiveBasicNack(final long deliveryTag, final boolean multiple, final boolean requeue)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] BasicNack[\" +\" deliveryTag: \" + deliveryTag + \" multiple: \" + multiple + \" requeue: \" + requeue + \" ]\");\n        }\n\n        Map<Long, MessageConsumerAssociation> nackedMessageMap = new LinkedHashMap<>();\n        _unacknowledgedMessageMap.collect(deliveryTag, multiple, nackedMessageMap);\n\n        for(MessageConsumerAssociation unackedMessageConsumerAssociation : nackedMessageMap.values())\n        {\n\n            if (unackedMessageConsumerAssociation == null)\n            {\n                LOGGER.warn(\"Ignoring nack request as message is null for tag:\" + deliveryTag);\n            }\n            else\n            {\n                MessageInstance message = unackedMessageConsumerAssociation.getMessageInstance();\n                if (message.getMessage() == null)\n                {\n                    LOGGER.warn(\"Message has already been purged, unable to nack.\");\n                }\n                else\n                {\n                    if (LOGGER.isDebugEnabled())\n                    {\n                        LOGGER.debug(\"Nack-ing: DT:\" + deliveryTag\n                                      + \"-\" + message.getMessage() +\n                                      \": Requeue:\" + requeue\n                                      +\n                                      \" on channel:\" + debugIdentity());\n                    }\n\n                    if (requeue)\n                    {\n                        message.decrementDeliveryCount();\n\n                        requeue(deliveryTag);\n                    }\n                    else\n                    {\n                        message.reject(unackedMessageConsumerAssociation.getConsumer());\n\n                        final boolean maxDeliveryCountEnabled = isMaxDeliveryCountEnabled(deliveryTag);\n                        if (LOGGER.isDebugEnabled())\n                        {\n                            LOGGER.debug(\"maxDeliveryCountEnabled: \"\n                                          + maxDeliveryCountEnabled\n                                          + \" deliveryTag \"\n                                          + deliveryTag);\n                        }\n                        if (maxDeliveryCountEnabled)\n                        {\n                            final boolean deliveredTooManyTimes = isDeliveredTooManyTimes(deliveryTag);\n                            if (LOGGER.isDebugEnabled())\n                            {\n                                LOGGER.debug(\"deliveredTooManyTimes: \"\n                                              + deliveredTooManyTimes\n                                              + \" deliveryTag \"\n                                              + deliveryTag);\n                            }\n                            if (deliveredTooManyTimes)\n                            {\n                                deadLetter(deliveryTag);\n                            }\n                            else\n                            {\n                                message.incrementDeliveryCount();\n                                message.release(unackedMessageConsumerAssociation.getConsumer());\n                            }\n                        }\n                        else\n                        {\n                            requeue(deliveryTag);\n                        }\n                    }\n                }\n            }\n\n        }\n\n    }\n\n    @Override\n    public void receiveChannelFlow(final boolean active)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] ChannelFlow[\" +\" active: \" + active + \" ]\");\n        }\n\n\n        sync();\n        if(_channelFlow != active)\n        {\n            _channelFlow = active;\n            // inform consumer targets\n            updateAllConsumerNotifyWorkDesired();\n        }\n\n        setSuspended(!active);\n\n        MethodRegistry methodRegistry = _connection.getMethodRegistry();\n        AMQMethodBody responseBody = methodRegistry.createChannelFlowOkBody(active);\n        _connection.writeFrame(responseBody.generateFrame(getChannelId()));\n\n    }\n\n    @Override\n    public void receiveChannelFlowOk(final boolean active)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] ChannelFlowOk[\" +\" active: \" + active + \" ]\");\n        }\n\n        // TODO - should we do anything here?\n    }\n\n    @Override\n    public void receiveExchangeBound(final AMQShortString exchangeName,\n                                     final AMQShortString routingKey,\n                                     final AMQShortString queueName)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] ExchangeBound[\" +\" exchange: \" + exchangeName + \" routingKey: \" +\n                          routingKey + \" queue: \" + queueName + \" ]\");\n        }\n\n        NamedAddressSpace virtualHost = _connection.getAddressSpace();\n        MethodRegistry methodRegistry = _connection.getMethodRegistry();\n\n        sync();\n\n        int replyCode;\n        String replyText;\n\n        if (isDefaultExchange(exchangeName))\n        {\n            if (routingKey == null)\n            {\n                if (queueName == null)\n                {\n                    replyCode = virtualHost.hasMessageSources()\n                            ? ExchangeBoundOkBody.OK\n                            : ExchangeBoundOkBody.NO_BINDINGS;\n                    replyText = null;\n\n                }\n                else\n                {\n                    MessageSource queue = virtualHost.getAttainedMessageSource(queueName.toString());\n                    if (queue == null)\n                    {\n                        replyCode = ExchangeBoundOkBody.QUEUE_NOT_FOUND;\n                        replyText = \"Queue '\" + queueName + \"' not found\";\n                    }\n                    else\n                    {\n                        replyCode = ExchangeBoundOkBody.OK;\n                        replyText = null;\n                    }\n                }\n            }\n            else\n            {\n                if (queueName == null)\n                {\n                    replyCode = virtualHost.getAttainedMessageDestination(routingKey.toString()) instanceof Queue\n                            ? ExchangeBoundOkBody.OK\n                            : ExchangeBoundOkBody.NO_QUEUE_BOUND_WITH_RK;\n                    replyText = null;\n                }\n                else\n                {\n                    MessageDestination destination = virtualHost.getAttainedMessageDestination(queueName.toString());\n                    Queue<?> queue = destination instanceof Queue ? (Queue) destination : null;\n                    if (queue == null)\n                    {\n\n                        replyCode = ExchangeBoundOkBody.QUEUE_NOT_FOUND;\n                        replyText = \"Queue '\" + queueName + \"' not found\";\n                    }\n                    else\n                    {\n                        replyCode = queueName.equals(routingKey)\n                                ? ExchangeBoundOkBody.OK\n                                : ExchangeBoundOkBody.SPECIFIC_QUEUE_NOT_BOUND_WITH_RK;\n                        replyText = null;\n                    }\n                }\n            }\n        }\n        else\n        {\n            Exchange<?> exchange = getExchange(exchangeName.toString());\n            if (exchange == null)\n            {\n\n                replyCode = ExchangeBoundOkBody.EXCHANGE_NOT_FOUND;\n                replyText = \"Exchange '\" + exchangeName + \"' not found\";\n            }\n            else if (routingKey == null)\n            {\n                if (queueName == null)\n                {\n                    if (exchange.hasBindings())\n                    {\n                        replyCode = ExchangeBoundOkBody.OK;\n                        replyText = null;\n                    }\n                    else\n                    {\n                        replyCode = ExchangeBoundOkBody.NO_BINDINGS;\n                        replyText = null;\n                    }\n                }\n                else\n                {\n                    Queue<?> queue = getQueue(queueName.toString());\n                    if (queue == null)\n                    {\n                        replyCode = ExchangeBoundOkBody.QUEUE_NOT_FOUND;\n                        replyText = \"Queue '\" + queueName + \"' not found\";\n                    }\n                    else\n                    {\n                        if (exchange.isBound(queue))\n                        {\n                            replyCode = ExchangeBoundOkBody.OK;\n                            replyText = null;\n                        }\n                        else\n                        {\n                            replyCode = ExchangeBoundOkBody.QUEUE_NOT_BOUND;\n                            replyText = \"Queue '\"\n                                        + queueName\n                                        + \"' not bound to exchange '\"\n                                        + exchangeName\n                                        + \"'\";\n                        }\n                    }\n                }\n            }\n            else if (queueName != null)\n            {\n                Queue<?> queue = getQueue(queueName.toString());\n                if (queue == null)\n                {\n                    replyCode = ExchangeBoundOkBody.QUEUE_NOT_FOUND;\n                    replyText = \"Queue '\" + queueName + \"' not found\";\n                }\n                else\n                {\n                    String bindingKey = routingKey == null ? null : routingKey.toString();\n                    if (exchange.isBound(bindingKey, queue))\n                    {\n\n                        replyCode = ExchangeBoundOkBody.OK;\n                        replyText = null;\n                    }\n                    else\n                    {\n                        replyCode = ExchangeBoundOkBody.SPECIFIC_QUEUE_NOT_BOUND_WITH_RK;\n                        replyText = \"Queue '\" + queueName + \"' not bound with routing key '\" +\n                                    routingKey + \"' to exchange '\" + exchangeName + \"'\";\n\n                    }\n                }\n            }\n            else\n            {\n                if (exchange.isBound(routingKey == null ? \"\" : routingKey.toString()))\n                {\n\n                    replyCode = ExchangeBoundOkBody.OK;\n                    replyText = null;\n                }\n                else\n                {\n                    replyCode = ExchangeBoundOkBody.NO_QUEUE_BOUND_WITH_RK;\n                    replyText =\n                            \"No queue bound with routing key '\" + routingKey + \"' to exchange '\" + exchangeName + \"'\";\n                }\n            }\n        }\n\n        ExchangeBoundOkBody exchangeBoundOkBody =\n                methodRegistry.createExchangeBoundOkBody(replyCode, AMQShortString.validValueOf(replyText));\n\n        _connection.writeFrame(exchangeBoundOkBody.generateFrame(getChannelId()));\n\n    }\n\n    @Override\n    public void receiveExchangeDeclare(final AMQShortString exchangeName,\n                                       final AMQShortString type,\n                                       final boolean passive,\n                                       final boolean durable,\n                                       final boolean autoDelete,\n                                       final boolean internal,\n                                       final boolean nowait,\n                                       final FieldTable arguments)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] ExchangeDeclare[\" +\" exchange: \" + exchangeName +\n                          \" type: \" + type +\n                          \" passive: \" + passive +\n                          \" durable: \" + durable +\n                          \" autoDelete: \" + autoDelete +\n                          \" internal: \" + internal + \" nowait: \" + nowait + \" arguments: \" + arguments + \" ]\");\n        }\n\n        final MethodRegistry methodRegistry = _connection.getMethodRegistry();\n        final AMQMethodBody declareOkBody = methodRegistry.createExchangeDeclareOkBody();\n\n        Exchange<?> exchange;\n        NamedAddressSpace virtualHost = _connection.getAddressSpace();\n\n        if (isDefaultExchange(exchangeName))\n        {\n            if (!AMQShortString.createAMQShortString(ExchangeDefaults.DIRECT_EXCHANGE_CLASS).equals(type))\n            {\n                _connection.sendConnectionClose(ErrorCodes.NOT_ALLOWED, \"Attempt to redeclare default exchange: \"\n                                                                        + \" of type \"\n                                                                        + ExchangeDefaults.DIRECT_EXCHANGE_CLASS\n                                                                        + \" to \" + type + \".\", getChannelId());\n            }\n            else if (!nowait)\n            {\n                sync();\n                _connection.writeFrame(declareOkBody.generateFrame(getChannelId()));\n            }\n\n        }\n        else\n        {\n            if (passive)\n            {\n                exchange = getExchange(exchangeName.toString());\n                if (exchange == null)\n                {\n                    closeChannel(ErrorCodes.NOT_FOUND, \"Unknown exchange: '\" + exchangeName + \"'\");\n                }\n                else if (!(type == null || type.length() == 0) && !exchange.getType().equals(type.toString()))\n                {\n\n                    _connection.sendConnectionClose(ErrorCodes.NOT_ALLOWED, \"Attempt to redeclare exchange: '\"\n                                                                            + exchangeName\n                                                                            + \"' of type \"\n                                                                            + exchange.getType()\n                                                                            + \" to \"\n                                                                            + type\n                                                                            + \".\", getChannelId());\n                }\n                else if (!nowait)\n                {\n                    sync();\n                    _connection.writeFrame(declareOkBody.generateFrame(getChannelId()));\n                }\n\n            }\n            else\n            {\n                String name = exchangeName.toString();\n                String typeString = type == null ? null : type.toString();\n                try\n                {\n\n                    Map<String, Object> attributes = new HashMap<String, Object>();\n                    if (arguments != null)\n                    {\n                        attributes.putAll(FieldTable.convertToMap(arguments));\n                    }\n                    attributes.put(Exchange.NAME, name);\n                    attributes.put(Exchange.TYPE, typeString);\n                    attributes.put(Exchange.DURABLE, durable);\n                    attributes.put(Exchange.LIFETIME_POLICY,\n                                   autoDelete ? LifetimePolicy.DELETE_ON_NO_LINKS : LifetimePolicy.PERMANENT);\n\n                    Object alternateExchange = attributes.remove(ALTERNATE_EXCHANGE);\n                    if (alternateExchange != null)\n                    {\n                        String alternateExchangeName = String.valueOf(alternateExchange);\n                        validateAlternateExchangeIsNotQueue(virtualHost, alternateExchangeName);\n                        attributes.put(Exchange.ALTERNATE_BINDING,\n                                       Collections.singletonMap(AlternateBinding.DESTINATION, alternateExchangeName));\n                    }\n                    exchange = virtualHost.createMessageDestination(Exchange.class, attributes);\n\n                    if (!nowait)\n                    {\n                        sync();\n                        _connection.writeFrame(declareOkBody.generateFrame(getChannelId()));\n                    }\n\n                }\n                catch (ReservedExchangeNameException e)\n                {\n                    Exchange existing = getExchange(name);\n                    if (existing == null || !existing.getType().equals(typeString))\n                    {\n                        _connection.sendConnectionClose(ErrorCodes.NOT_ALLOWED,\n                                                        \"Attempt to declare exchange: '\" + exchangeName +\n                                                        \"' which begins with reserved prefix.\", getChannelId());\n                    }\n                    else if(!nowait)\n                    {\n                        sync();\n                        _connection.writeFrame(declareOkBody.generateFrame(getChannelId()));\n                    }\n                }\n                catch (AbstractConfiguredObject.DuplicateNameException e)\n                {\n                    exchange = (Exchange<?>) e.getExisting();\n                    if (!exchange.getType().equals(typeString))\n                    {\n                        _connection.sendConnectionClose(ErrorCodes.NOT_ALLOWED, \"Attempt to redeclare exchange: '\"\n                                                                                + exchangeName + \"' of type \"\n                                                                                + exchange.getType()\n                                                                                + \" to \" + type + \".\", getChannelId());\n                    }\n                    else\n                    {\n                        if (!nowait)\n                        {\n                            sync();\n                            _connection.writeFrame(declareOkBody.generateFrame(getChannelId()));\n                        }\n                    }\n                }\n                catch (NoFactoryForTypeException e)\n                {\n                    _connection.sendConnectionClose(ErrorCodes.COMMAND_INVALID, \"Unknown exchange type '\"\n                                                                                + e.getType()\n                                                                                + \"' for exchange '\"\n                                                                                + exchangeName\n                                                                                + \"'\", getChannelId());\n\n                }\n                catch (AccessControlException e)\n                {\n                    _connection.sendConnectionClose(ErrorCodes.ACCESS_REFUSED, e.getMessage(), getChannelId());\n\n                }\n                catch (UnknownAlternateBindingException e)\n                {\n                    final String message = String.format(\"Unknown alternate exchange '%s'\", e.getAlternateBindingName());\n                    _connection.sendConnectionClose(ErrorCodes.NOT_FOUND, message, getChannelId());\n\n                }\n                catch (IllegalArgumentException | IllegalConfigurationException e)\n                {\n                    _connection.sendConnectionClose(ErrorCodes.COMMAND_INVALID, \"Error creating exchange '\"\n                                                                                + exchangeName\n                                                                                + \"': \"\n                                                                                + e.getMessage(), getChannelId());\n\n                }\n            }\n        }\n\n    }\n\n    private void validateAlternateExchangeIsNotQueue(final NamedAddressSpace addressSpace, final String alternateExchangeName)\n    {\n        MessageDestination alternateMessageDestination = addressSpace.getAttainedMessageDestination(alternateExchangeName, false);\n        if (alternateMessageDestination != null && !(alternateMessageDestination instanceof Exchange))\n        {\n            throw new IllegalConfigurationException(String.format(\n                    \"Alternate exchange '%s' is not a destination of type 'exchange'.\", alternateExchangeName));\n        }\n    }\n\n    @Override\n    public void receiveExchangeDelete(final AMQShortString exchangeStr, final boolean ifUnused, final boolean nowait)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] ExchangeDelete[\" +\" exchange: \" + exchangeStr + \" ifUnused: \" + ifUnused + \" nowait: \" + nowait + \" ]\");\n        }\n\n\n        NamedAddressSpace virtualHost = _connection.getAddressSpace();\n        sync();\n\n        if (isDefaultExchange(exchangeStr))\n        {\n            _connection.sendConnectionClose(ErrorCodes.NOT_ALLOWED,\n                                            \"Default Exchange cannot be deleted\", getChannelId());\n\n        }\n\n        else\n        {\n            final String exchangeName = exchangeStr.toString();\n\n            final Exchange<?> exchange = getExchange(exchangeName);\n            if (exchange == null)\n            {\n                closeChannel(ErrorCodes.NOT_FOUND, \"No such exchange: '\" + exchangeStr + \"'\");\n            }\n            else\n            {\n                if (ifUnused && exchange.hasBindings())\n                {\n                    closeChannel(ErrorCodes.IN_USE, \"Exchange has bindings\");\n                }\n                else\n                {\n                    try\n                    {\n                        exchange.delete();\n\n\n                        if (!nowait)\n                        {\n                            ExchangeDeleteOkBody\n                                    responseBody = _connection.getMethodRegistry().createExchangeDeleteOkBody();\n                            _connection.writeFrame(responseBody.generateFrame(getChannelId()));\n                        }\n                    }\n                    catch (MessageDestinationIsAlternateException e)\n                    {\n                        closeChannel(ErrorCodes.NOT_ALLOWED, \"Exchange in use as an alternate binding destination\");\n                    }\n                    catch (RequiredExchangeException e)\n                    {\n                        closeChannel(ErrorCodes.NOT_ALLOWED, \"Exchange '\" + exchangeStr + \"' cannot be deleted\");\n                    }\n                    catch (AccessControlException e)\n                    {\n                        _connection.sendConnectionClose(ErrorCodes.ACCESS_REFUSED, e.getMessage(), getChannelId());\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public void receiveQueueBind(final AMQShortString queueName,\n                                 final AMQShortString exchange,\n                                 AMQShortString bindingKey,\n                                 final boolean nowait,\n                                 final FieldTable argumentsTable)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] QueueBind[\" +\" queue: \" + queueName +\n                          \" exchange: \" + exchange +\n                          \" bindingKey: \" + bindingKey +\n                          \" nowait: \" + nowait + \" arguments: \" + argumentsTable + \" ]\");\n        }\n\n        NamedAddressSpace virtualHost = _connection.getAddressSpace();\n        Queue<?> queue;\n        if (queueName == null)\n        {\n\n            queue = getDefaultQueue();\n\n            if (queue != null)\n            {\n                if (bindingKey == null)\n                {\n                    bindingKey = AMQShortString.valueOf(queue.getName());\n                }\n            }\n        }\n        else\n        {\n            queue = getQueue(queueName.toString());\n        }\n\n        if (queue == null)\n        {\n            String message = queueName == null\n                    ? \"No default queue defined on channel and queue was null\"\n                    : \"Queue \" + queueName + \" does not exist.\";\n                closeChannel(ErrorCodes.NOT_FOUND, message);\n        }\n        else if (isDefaultExchange(exchange))\n        {\n            _connection.sendConnectionClose(ErrorCodes.NOT_ALLOWED,\n                    \"Cannot bind the queue '\" + queueName + \"' to the default exchange\", getChannelId());\n\n        }\n        else\n        {\n\n            final String exchangeName = exchange.toString();\n\n            final Exchange<?> exch = getExchange(exchangeName);\n            if (exch == null)\n            {\n                closeChannel(ErrorCodes.NOT_FOUND,\n                             \"Exchange '\" + exchangeName + \"' does not exist.\");\n            }\n            else\n            {\n\n                try\n                {\n\n                    Map<String, Object> arguments = FieldTable.convertToMap(argumentsTable);\n                    String bindingKeyStr = bindingKey == null ? \"\" : AMQShortString.toString(bindingKey);\n\n                    if (!exch.isBound(bindingKeyStr, arguments, queue))\n                    {\n\n                        if (!exch.addBinding(bindingKeyStr, queue, arguments)\n                            && ExchangeDefaults.TOPIC_EXCHANGE_CLASS.equals(\n                                exch.getType()))\n                        {\n                            exch.replaceBinding(bindingKeyStr, queue, arguments);\n                        }\n                    }\n\n                    if (LOGGER.isDebugEnabled())\n                    {\n                        LOGGER.debug(\"Binding queue \"\n                                     + queue\n                                     + \" to exchange \"\n                                     + exch\n                                     + \" with routing key \"\n                                     + bindingKeyStr);\n                    }\n                    if (!nowait)\n                    {\n                        sync();\n                        MethodRegistry methodRegistry = _connection.getMethodRegistry();\n                        AMQMethodBody responseBody = methodRegistry.createQueueBindOkBody();\n                        _connection.writeFrame(responseBody.generateFrame(getChannelId()));\n\n                    }\n                }\n                catch (AccessControlException e)\n                {\n                    _connection.sendConnectionClose(ErrorCodes.ACCESS_REFUSED, e.getMessage(), getChannelId());\n                }\n            }\n        }\n    }\n\n    @Override\n    public void receiveQueueDeclare(final AMQShortString queueStr,\n                                    final boolean passive,\n                                    final boolean durable,\n                                    final boolean exclusive,\n                                    final boolean autoDelete,\n                                    final boolean nowait,\n                                    final FieldTable arguments)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] QueueDeclare[\" +\" queue: \" + queueStr +\n                          \" passive: \" + passive +\n                          \" durable: \" + durable +\n                          \" exclusive: \" + exclusive +\n                          \" autoDelete: \" + autoDelete + \" nowait: \" + nowait + \" arguments: \" + arguments + \" ]\");\n        }\n\n        NamedAddressSpace virtualHost = _connection.getAddressSpace();\n\n        final AMQShortString queueName;\n\n        // if we aren't given a queue name, we create one which we return to the client\n        if ((queueStr == null) || (queueStr.length() == 0))\n        {\n            queueName = AMQShortString.createAMQShortString(\"tmp_\" + UUID.randomUUID());\n        }\n        else\n        {\n            queueName = queueStr;\n        }\n\n        Queue<?> queue;\n\n        //TODO: do we need to check that the queue already exists with exactly the same \"configuration\"?\n\n\n        if (passive)\n        {\n            queue = getQueue(queueName.toString());\n            if (queue == null)\n            {\n                closeChannel(ErrorCodes.NOT_FOUND,\n                                                     \"Queue: '\"\n                                                     + queueName\n                                                     + \"' not found on VirtualHost '\"\n                                                     + virtualHost.getName()\n                                                     + \"'.\");\n            }\n            else\n            {\n                if (!queue.verifySessionAccess(this))\n                {\n                    _connection.sendConnectionClose(ErrorCodes.NOT_ALLOWED, \"Queue '\"\n                                                                            + queue.getName()\n                                                                            + \"' is exclusive, but not created on this Connection.\", getChannelId());\n                }\n                else\n                {\n                    //set this as the default queue on the channel:\n                    setDefaultQueue(queue);\n                    if (!nowait)\n                    {\n                        sync();\n                        MethodRegistry methodRegistry = _connection.getMethodRegistry();\n                        QueueDeclareOkBody responseBody =\n                                methodRegistry.createQueueDeclareOkBody(queueName,\n                                                                        queue.getQueueDepthMessages(),\n                                                                        queue.getConsumerCount());\n                        _connection.writeFrame(responseBody.generateFrame(getChannelId()));\n\n                        if (LOGGER.isDebugEnabled())\n                        {\n                            LOGGER.debug(\"Queue \" + queueName + \" declared successfully\");\n                        }\n                    }\n                }\n            }\n        }\n        else\n        {\n            try\n            {\n                final String queueNameString = AMQShortString.toString(queueName);\n                Map<String, Object> wireArguments = FieldTable.convertToMap(arguments);\n                Object alternateExchange = wireArguments.get(ALTERNATE_EXCHANGE);\n                if (alternateExchange != null)\n                {\n                    String alternateExchangeName = String.valueOf(alternateExchange);\n                    validateAlternateExchangeIsNotQueue(virtualHost, alternateExchangeName);\n                }\n\n                Map<String, Object> attributes =\n                        QueueArgumentsConverter.convertWireArgsToModel(queueNameString, wireArguments);\n\n                attributes.put(Queue.NAME, queueNameString);\n                attributes.put(Queue.DURABLE, durable);\n\n                LifetimePolicy lifetimePolicy;\n                ExclusivityPolicy exclusivityPolicy;\n\n                if (exclusive)\n                {\n                    lifetimePolicy = autoDelete\n                            ? LifetimePolicy.DELETE_ON_NO_OUTBOUND_LINKS\n                            : durable ? LifetimePolicy.PERMANENT : LifetimePolicy.DELETE_ON_CONNECTION_CLOSE;\n                    exclusivityPolicy = durable ? ExclusivityPolicy.CONTAINER : ExclusivityPolicy.CONNECTION;\n                }\n                else\n                {\n                    lifetimePolicy = autoDelete ? LifetimePolicy.DELETE_ON_NO_OUTBOUND_LINKS : LifetimePolicy.PERMANENT;\n                    exclusivityPolicy = ExclusivityPolicy.NONE;\n                }\n\n                if(!attributes.containsKey(Queue.EXCLUSIVE))\n                {\n                    attributes.put(Queue.EXCLUSIVE, exclusivityPolicy);\n                }\n                if(!attributes.containsKey(Queue.LIFETIME_POLICY))\n                {\n                    attributes.put(Queue.LIFETIME_POLICY, lifetimePolicy);\n                }\n\n                queue = virtualHost.createMessageSource(Queue.class, attributes);\n\n                setDefaultQueue(queue);\n\n                if (!nowait)\n                {\n                    sync();\n                    MethodRegistry methodRegistry = _connection.getMethodRegistry();\n                    QueueDeclareOkBody responseBody =\n                            methodRegistry.createQueueDeclareOkBody(queueName,\n                                                                    queue.getQueueDepthMessages(),\n                                                                    queue.getConsumerCount());\n                    _connection.writeFrame(responseBody.generateFrame(getChannelId()));\n\n                    if (LOGGER.isDebugEnabled())\n                    {\n                        LOGGER.debug(\"Queue \" + queueName + \" declared successfully\");\n                    }\n                }\n            }\n            catch (AbstractConfiguredObject.DuplicateNameException qe)\n            {\n\n                queue = (Queue<?>) qe.getExisting();\n\n                if (!queue.verifySessionAccess(this))\n                {\n                    _connection.sendConnectionClose(ErrorCodes.NOT_ALLOWED, \"Queue '\"\n                                                                            + queue.getName()\n                                                                            + \"' is exclusive, but not created on this Connection.\", getChannelId());\n\n                }\n                else if (queue.isExclusive() != exclusive)\n                {\n\n                    closeChannel(ErrorCodes.ALREADY_EXISTS,\n                                                         \"Cannot re-declare queue '\"\n                                                         + queue.getName()\n                                                         + \"' with different exclusivity (was: \"\n                                                         + queue.isExclusive()\n                                                         + \" requested \"\n                                                         + exclusive\n                                                         + \")\");\n                }\n                else if ((autoDelete\n                          && queue.getLifetimePolicy() == LifetimePolicy.PERMANENT)\n                         || (!autoDelete && queue.getLifetimePolicy() != ((exclusive\n                                                                           && !durable)\n                        ? LifetimePolicy.DELETE_ON_CONNECTION_CLOSE\n                        : LifetimePolicy.PERMANENT)))\n                {\n                    closeChannel(ErrorCodes.ALREADY_EXISTS,\n                                                         \"Cannot re-declare queue '\"\n                                                         + queue.getName()\n                                                         + \"' with different lifetime policy (was: \"\n                                                         + queue.getLifetimePolicy()\n                                                         + \" requested autodelete: \"\n                                                         + autoDelete\n                                                         + \")\");\n                }\n                else\n                {\n                    setDefaultQueue(queue);\n                    if (!nowait)\n                    {\n                        sync();\n                        MethodRegistry methodRegistry = _connection.getMethodRegistry();\n                        QueueDeclareOkBody responseBody =\n                                methodRegistry.createQueueDeclareOkBody(queueName,\n                                                                        queue.getQueueDepthMessages(),\n                                                                        queue.getConsumerCount());\n                        _connection.writeFrame(responseBody.generateFrame(getChannelId()));\n\n                        if (LOGGER.isDebugEnabled())\n                        {\n                            LOGGER.debug(\"Queue \" + queueName + \" declared successfully\");\n                        }\n                    }\n                }\n            }\n            catch (AccessControlException e)\n            {\n                _connection.sendConnectionClose(ErrorCodes.ACCESS_REFUSED, e.getMessage(), getChannelId());\n            }\n            catch (UnknownAlternateBindingException e)\n            {\n                final String message = String.format(\"Unknown alternate exchange: '%s'\", e.getAlternateBindingName());\n                _connection.sendConnectionClose(ErrorCodes.NOT_FOUND, message, getChannelId());\n            }\n            catch (IllegalArgumentException | IllegalConfigurationException e)\n            {\n                String message = String.format(\"Error creating queue '%s': %s\", queueName, e.getMessage());\n                _connection.sendConnectionClose(ErrorCodes.COMMAND_INVALID, message, getChannelId());\n            }\n        }\n    }\n\n    @Override\n    public void receiveQueueDelete(final AMQShortString queueName,\n                                   final boolean ifUnused,\n                                   final boolean ifEmpty,\n                                   final boolean nowait)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] QueueDelete[\" +\" queue: \" + queueName + \" ifUnused: \" + ifUnused + \" ifEmpty: \" + ifEmpty + \" nowait: \" + nowait + \" ]\");\n        }\n\n        NamedAddressSpace virtualHost = _connection.getAddressSpace();\n        sync();\n        Queue<?> queue;\n        if (queueName == null)\n        {\n\n            //get the default queue on the channel:\n            queue = getDefaultQueue();\n        }\n        else\n        {\n            queue = getQueue(queueName.toString());\n        }\n\n        if (queue == null)\n        {\n            closeChannel(ErrorCodes.NOT_FOUND, \"Queue '\" + queueName + \"' does not exist.\");\n\n        }\n        else\n        {\n            if (ifEmpty && !queue.isEmpty())\n            {\n                closeChannel(ErrorCodes.IN_USE, \"Queue: '\" + queueName + \"' is not empty.\");\n            }\n            else if (ifUnused && !queue.isUnused())\n            {\n                // TODO - Error code\n                closeChannel(ErrorCodes.IN_USE, \"Queue: '\" + queueName + \"' is still used.\");\n            }\n            else\n            {\n                if (!queue.verifySessionAccess(this))\n                {\n                    _connection.sendConnectionClose(ErrorCodes.NOT_ALLOWED, \"Queue '\"\n                                                                            + queue.getName()\n                                                                            + \"' is exclusive, but not created on this Connection.\", getChannelId());\n\n                }\n                else\n                {\n                    try\n                    {\n                        int purged = queue.deleteAndReturnCount();\n\n                        if (!nowait || _connection.isSendQueueDeleteOkRegardless())\n                        {\n                            MethodRegistry methodRegistry = _connection.getMethodRegistry();\n                            QueueDeleteOkBody responseBody = methodRegistry.createQueueDeleteOkBody(purged);\n                            _connection.writeFrame(responseBody.generateFrame(getChannelId()));\n                        }\n                    }\n                    catch (AccessControlException e)\n                    {\n                        _connection.sendConnectionClose(ErrorCodes.ACCESS_REFUSED, e.getMessage(), getChannelId());\n\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public void receiveQueuePurge(final AMQShortString queueName, final boolean nowait)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] QueuePurge[\" +\" queue: \" + queueName + \" nowait: \" + nowait + \" ]\");\n        }\n\n        NamedAddressSpace virtualHost = _connection.getAddressSpace();\n        Queue<?> queue = null;\n        if (queueName == null && (queue = getDefaultQueue()) == null)\n        {\n\n            _connection.sendConnectionClose(ErrorCodes.NOT_ALLOWED, \"No queue specified.\", getChannelId());\n        }\n        else if ((queueName != null) && (queue = getQueue(queueName.toString())) == null)\n        {\n            closeChannel(ErrorCodes.NOT_FOUND, \"Queue '\" + queueName + \"' does not exist.\");\n        }\n        else if (!queue.verifySessionAccess(this))\n        {\n            _connection.sendConnectionClose(ErrorCodes.NOT_ALLOWED,\n                                            \"Queue is exclusive, but not created on this Connection.\", getChannelId());\n        }\n        else\n        {\n            try\n            {\n                long purged = queue.clearQueue();\n                if (!nowait)\n                {\n                    sync();\n                    MethodRegistry methodRegistry = _connection.getMethodRegistry();\n                    AMQMethodBody responseBody = methodRegistry.createQueuePurgeOkBody(purged);\n                    _connection.writeFrame(responseBody.generateFrame(getChannelId()));\n\n                }\n            }\n            catch (AccessControlException e)\n            {\n                _connection.sendConnectionClose(ErrorCodes.ACCESS_REFUSED, e.getMessage(), getChannelId());\n\n            }\n\n        }\n    }\n\n    @Override\n    public void receiveQueueUnbind(final AMQShortString queueName,\n                                   final AMQShortString exchange,\n                                   final AMQShortString bindingKey,\n                                   final FieldTable arguments)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] QueueUnbind[\" +\" queue: \" + queueName +\n                          \" exchange: \" + exchange +\n                          \" bindingKey: \" + bindingKey +\n                          \" arguments: \" + arguments + \" ]\");\n        }\n\n        NamedAddressSpace virtualHost = _connection.getAddressSpace();\n\n\n        final boolean useDefaultQueue = queueName == null;\n        final Queue<?> queue = useDefaultQueue\n                ? getDefaultQueue()\n                : getQueue(queueName.toString());\n\n\n        if (queue == null)\n        {\n            String message = useDefaultQueue\n                    ? \"No default queue defined on channel and queue was null\"\n                    : \"Queue '\" + queueName + \"' does not exist.\";\n            closeChannel(ErrorCodes.NOT_FOUND, message);\n        }\n        else if (isDefaultExchange(exchange))\n        {\n            _connection.sendConnectionClose(ErrorCodes.NOT_ALLOWED, \"Cannot unbind the queue '\"\n                                                                    + queue.getName()\n                                                                    + \"' from the default exchange\", getChannelId());\n\n        }\n        else\n        {\n            final Exchange<?> exch = getExchange(exchange.toString());\n            final String bindingKeyStr = bindingKey == null ? \"\" : AMQShortString.toString(bindingKey);\n\n            if (exch == null)\n            {\n                closeChannel(ErrorCodes.NOT_FOUND, \"Exchange '\" + exchange + \"' does not exist.\");\n            }\n            else if (!exch.hasBinding(bindingKeyStr, queue))\n            {\n                closeChannel(ErrorCodes.NOT_FOUND, \"No such binding\");\n            }\n            else\n            {\n                try\n                {\n                    exch.deleteBinding(bindingKeyStr, queue);\n\n                    final AMQMethodBody responseBody = _connection.getMethodRegistry().createQueueUnbindOkBody();\n                    sync();\n                    _connection.writeFrame(responseBody.generateFrame(getChannelId()));\n                }\n                catch (AccessControlException e)\n                {\n                    _connection.sendConnectionClose(ErrorCodes.ACCESS_REFUSED, e.getMessage(), getChannelId());\n\n                }\n            }\n\n        }\n    }\n\n    @Override\n    public void receiveTxSelect()\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] TxSelect\");\n        }\n\n        ServerTransaction txn = _transaction;\n        if (txn instanceof LocalTransaction)\n        {\n            getConnection().unregisterTransactionTickers(_transaction);\n        }\n\n        _transaction = _connection.createLocalTransaction();\n        long notificationRepeatPeriod = getContextValue(Long.class,\n                                                 TRANSACTION_TIMEOUT_NOTIFICATION_REPEAT_PERIOD);\n        getConnection().registerTransactionTickers(_transaction,\n                                                   message -> _connection.sendConnectionCloseAsync(AMQPConnection.CloseReason.TRANSACTION_TIMEOUT,\n                                                                                                   message),\n                                                   notificationRepeatPeriod);\n\n        MethodRegistry methodRegistry = _connection.getMethodRegistry();\n        TxSelectOkBody responseBody = methodRegistry.createTxSelectOkBody();\n        _connection.writeFrame(responseBody.generateFrame(_channelId));\n\n    }\n\n    @Override\n    public void receiveTxCommit()\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] TxCommit\");\n        }\n\n\n        if (!isTransactional())\n        {\n            closeChannel(ErrorCodes.COMMAND_INVALID,\n                         \"Fatal error: commit called on non-transactional channel\");\n        }\n        else\n        {\n            commit(new Runnable()\n            {\n\n                @Override\n                public void run()\n                {\n                    _connection.writeFrame(_txCommitOkFrame);\n                }\n            }, true);\n        }\n\n    }\n\n    @Override\n    public void receiveTxRollback()\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] TxRollback\");\n        }\n\n        if (!isTransactional())\n        {\n            closeChannel(ErrorCodes.COMMAND_INVALID,\n                         \"Fatal error: rollback called on non-transactional channel\");\n        }\n        else\n        {\n            final MethodRegistry methodRegistry = _connection.getMethodRegistry();\n            final AMQMethodBody responseBody = methodRegistry.createTxRollbackOkBody();\n\n            Runnable task = () -> _connection.writeFrame(responseBody.generateFrame(_channelId));\n\n            rollback(task);\n\n            // TODO: This is not spec compliant but we currently seem to rely on this behaviour\n            resend();\n        }\n    }\n\n    @Override\n    public void receiveConfirmSelect(final boolean nowait)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] ConfirmSelect [ nowait: \" + nowait + \" ]\");\n        }\n        _confirmOnPublish = true;\n\n        if(!nowait)\n        {\n            _connection.writeFrame(new AMQFrame(_channelId, ConfirmSelectOkBody.INSTANCE));\n        }\n    }\n\n\n\n    private void closeChannel(int cause, final String message)\n    {\n        _connection.closeChannelAndWriteFrame(this, cause, message);\n    }\n\n\n    private boolean isDefaultExchange(final AMQShortString exchangeName)\n    {\n        return exchangeName == null || AMQShortString.EMPTY_STRING.equals(exchangeName);\n    }\n\n    private void setDefaultQueue(Queue<?> queue)\n    {\n        Queue<?> currentDefaultQueue = _defaultQueue;\n        if (queue != currentDefaultQueue)\n        {\n            if (currentDefaultQueue != null)\n            {\n                currentDefaultQueue.removeDeleteTask(_defaultQueueAssociationClearingTask);\n            }\n            if (queue != null)\n            {\n                queue.addDeleteTask(_defaultQueueAssociationClearingTask);\n            }\n        }\n        _defaultQueue = queue;\n    }\n\n    private Queue<?> getDefaultQueue()\n    {\n        return _defaultQueue;\n    }\n\n    private class DefaultQueueAssociationClearingTask implements Action<Queue<?>>\n    {\n        @Override\n        public void performAction(final Queue<?> queue)\n        {\n            if ( queue == _defaultQueue)\n            {\n                _defaultQueue = null;\n            }\n        }\n    }\n\n    @Override\n    protected void updateBlockedStateIfNecessary()\n    {\n        boolean desiredBlockingState = _blocking.get();\n        if (desiredBlockingState != _wireBlockingState)\n        {\n            _wireBlockingState = desiredBlockingState;\n            sendFlow(!desiredBlockingState);\n            _blockTime = desiredBlockingState ? System.currentTimeMillis() : 0;\n        }\n    }\n\n    @Override\n    public void restoreCredit(final ConsumerTarget target, final int count, final long size)\n    {\n        boolean hasCredit = _creditManager.hasCredit();\n        _creditManager.restoreCredit(count, size);\n        if(_creditManager.hasCredit() != hasCredit)\n        {\n            if (hasCredit || !_creditManager.isNotBytesLimitedAndHighPrefetch())\n            {\n                updateAllConsumerNotifyWorkDesired();\n            }\n        }\n        else if (hasCredit)\n        {\n            if (_creditManager.isNotBytesLimitedAndHighPrefetch())\n            {\n                if (_creditManager.isCreditOverBatchLimit())\n                {\n                    updateAllConsumerNotifyWorkDesired();\n                }\n            }\n            else if(_creditManager.isBytesLimited())\n            {\n                target.notifyWork();\n            }\n        }\n    }\n\n    private Collection<ConsumerTarget_0_8> getConsumerTargets()\n    {\n        return _tag2SubscriptionTargetMap.values();\n    }\n\n    private Exchange<?> getExchange(String name)\n    {\n        MessageDestination destination = getAddressSpace().getAttainedMessageDestination(name);\n        return destination instanceof Exchange ? (Exchange<?>) destination : null;\n    }\n\n    private Queue<?> getQueue(String name)\n    {\n        MessageSource source = getAddressSpace().getAttainedMessageSource(name);\n        return source instanceof Queue ? (Queue<?>) source : null;\n    }\n\n    public void dispose()\n    {\n        _txCommitOkFrame.dispose();\n        final IncomingMessage currentMessage = _currentMessage;\n        if (currentMessage != null)\n        {\n            _currentMessage = null;\n            final ContentHeaderBody contentHeader = currentMessage.getContentHeader();\n            if (contentHeader != null)\n            {\n                contentHeader.dispose();\n            }\n\n            int bodyCount = currentMessage.getBodyCount();\n            if (bodyCount > 0)\n            {\n                for (int i = 0; i < bodyCount; i++)\n                {\n                    currentMessage.getContentChunk(i).dispose();\n                }\n            }\n        }\n    }\n}",
    "target": 0,
    "language": "java",
    "dataset": "A-Manually-Curated-Dataset-of-Vulnerability-Introducing-Commits-in-Java",
    "idx": 800073,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "/*\n * Copyright 2013 FasterXML.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the license for the specific language governing permissions and\n * limitations under the license.\n */\n\npackage com.fasterxml.jackson.datatype.jsr310;\n\nimport java.math.BigDecimal;\nimport java.util.function.BiFunction;\n\n/**\n * Utilities to aid in the translation of decimal types to/from multiple parts.\n *\n * @author Nick Williams\n * @since 2.2.0\n */\npublic final class DecimalUtils\n{\n    private static final BigDecimal ONE_BILLION = new BigDecimal(1_000_000_000L);\n\n    private DecimalUtils()\n    {\n        throw new RuntimeException(\"DecimalUtils cannot be instantiated.\");\n    }\n\n    public static String toDecimal(long seconds, int nanoseconds)\n    {\n        StringBuilder sb = new StringBuilder(20)\n            .append(seconds)\n            .append('.');\n        // 14-Mar-2016, tatu: Although we do not yet (with 2.7) trim trailing zeroes,\n        //   for general case,\n        if (nanoseconds == 0L) {\n            // !!! TODO: 14-Mar-2016, tatu: as per [datatype-jsr310], should trim\n            //     trailing zeroes\n            if (seconds == 0L) {\n                return \"0.0\";\n            }\n\n//            sb.append('0');\n            sb.append(\"000000000\");\n        } else {\n            StringBuilder nanoSB = new StringBuilder(9);\n            nanoSB.append(nanoseconds);\n            // May need to both prepend leading nanos (if value less than 0.1)\n            final int nanosLen = nanoSB.length();\n            int prepZeroes = 9 - nanosLen;\n            while (prepZeroes > 0) {\n                --prepZeroes;\n                sb.append('0');\n            }\n\n            // !!! TODO: 14-Mar-2016, tatu: as per [datatype-jsr310], should trim\n            //     trailing zeroes\n            /*\n            // AND possibly trim trailing ones\n            int i = nanosLen;\n            while ((i > 1) && nanoSB.charAt(i-1) == '0') {\n                --i;\n            }\n            if (i < nanosLen) {\n                nanoSB.setLength(i);\n            }\n            */\n            sb.append(nanoSB);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * @since 2.7.3\n     */\n    public static BigDecimal toBigDecimal(long seconds, int nanoseconds)\n    {\n        if (nanoseconds == 0L) {\n            // 14-Mar-2015, tatu: Let's retain one zero to avoid interpretation\n            //    as integral number\n            if (seconds == 0L) { // except for \"0.0\" where it can not be done without scientific notation\n                return BigDecimal.ZERO.setScale(1);\n            }\n            return BigDecimal.valueOf(seconds).setScale(9);\n        }\n        return new BigDecimal(toDecimal(seconds, nanoseconds));\n    }\n\n    /**\n     * @Deprecated due to potential unbounded latency on some JRE releases.\n     */\n    public static int extractNanosecondDecimal(BigDecimal value, long integer)\n    {\n        // !!! 14-Mar-2016, tatu: Somewhat inefficient; should replace with functionally\n        //   equivalent code that just subtracts integral part? (or, measure and show\n        //   there's no difference and do nothing... )\n        return value.subtract(new BigDecimal(integer)).multiply(ONE_BILLION).intValue();\n    }\n\n\n    /**\n     * Extracts the seconds and nanoseconds component of {@code seconds} as {@code long} and {@code int}\n     * values, passing them to the given converter.   The implementation avoids latency issues present\n     * on some JRE releases.\n     *\n     * @since 2.9.8\n     */\n    public static <T> T extractSecondsAndNanos(BigDecimal seconds, BiFunction<Long, Integer, T> convert)\n    {\n        // Complexity is here to workaround unbounded latency in some BigDecimal operations.\n        //   https://github.com/FasterXML/jackson-databind/issues/2141\n\n        long secondsOnly;\n        int nanosOnly;\n\n        BigDecimal nanoseconds = seconds.scaleByPowerOfTen(9);\n        if (nanoseconds.precision() - nanoseconds.scale() <= 0) {\n            // There are no non-zero digits to the left of the decimal point.\n            // This protects against very negative exponents.\n            secondsOnly = nanosOnly = 0;\n        }\n        else if (seconds.scale() < -63) {\n            // There would be no low-order bits once we chop to a long.\n            // This protects against very positive exponents.\n            secondsOnly = nanosOnly = 0;\n        }\n        else {\n            // Now we know that seconds has reasonable scale, we can safely chop it apart.\n            secondsOnly = seconds.longValue();\n            nanosOnly = nanoseconds.subtract(new BigDecimal(secondsOnly).scaleByPowerOfTen(9)).intValue();\n        }\n\n        return convert.apply(secondsOnly, nanosOnly);\n    }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700062,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "/*\n * Copyright 2013 FasterXML.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the license for the specific language governing permissions and\n * limitations under the license.\n */\n\npackage com.fasterxml.jackson.datatype.jsr310;\n\nimport java.math.BigDecimal;\nimport java.util.function.BiFunction;\n\n/**\n * Utilities to aid in the translation of decimal types to/from multiple parts.\n *\n * @author Nick Williams\n * @since 2.2\n */\npublic final class DecimalUtils\n{\n    private static final BigDecimal ONE_BILLION = new BigDecimal(1_000_000_000L);\n\n    private DecimalUtils() { }\n\n    public static String toDecimal(long seconds, int nanoseconds)\n    {\n        StringBuilder sb = new StringBuilder(20)\n            .append(seconds)\n            .append('.');\n        // 14-Mar-2016, tatu: Although we do not yet (with 2.7) trim trailing zeroes,\n        //   for general case,\n        if (nanoseconds == 0L) {\n            // !!! TODO: 14-Mar-2016, tatu: as per [datatype-jsr310], should trim\n            //     trailing zeroes\n            if (seconds == 0L) {\n                return \"0.0\";\n            }\n\n//            sb.append('0');\n            sb.append(\"000000000\");\n        } else {\n            StringBuilder nanoSB = new StringBuilder(9);\n            nanoSB.append(nanoseconds);\n            // May need to both prepend leading nanos (if value less than 0.1)\n            final int nanosLen = nanoSB.length();\n            int prepZeroes = 9 - nanosLen;\n            while (prepZeroes > 0) {\n                --prepZeroes;\n                sb.append('0');\n            }\n\n            // !!! TODO: 14-Mar-2016, tatu: as per [datatype-jsr310], should trim\n            //     trailing zeroes\n            /*\n            // AND possibly trim trailing ones\n            int i = nanosLen;\n            while ((i > 1) && nanoSB.charAt(i-1) == '0') {\n                --i;\n            }\n            if (i < nanosLen) {\n                nanoSB.setLength(i);\n            }\n            */\n            sb.append(nanoSB);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * @since 2.7.3\n     */\n    public static BigDecimal toBigDecimal(long seconds, int nanoseconds)\n    {\n        if (nanoseconds == 0L) {\n            // 14-Mar-2015, tatu: Let's retain one zero to avoid interpretation\n            //    as integral number\n            if (seconds == 0L) { // except for \"0.0\" where it can not be done without scientific notation\n                return BigDecimal.ZERO.setScale(1);\n            }\n            return BigDecimal.valueOf(seconds).setScale(9);\n        }\n        return new BigDecimal(toDecimal(seconds, nanoseconds));\n    }\n\n    /**\n     * @Deprecated due to potential unbounded latency on some JRE releases.\n     */\n    public static int extractNanosecondDecimal(BigDecimal value, long integer)\n    {\n        // !!! 14-Mar-2016, tatu: Somewhat inefficient; should replace with functionally\n        //   equivalent code that just subtracts integral part? (or, measure and show\n        //   there's no difference and do nothing... )\n        return value.subtract(new BigDecimal(integer)).multiply(ONE_BILLION).intValue();\n    }\n\n\n    /**\n     * Extracts the seconds and nanoseconds component of {@code seconds} as {@code long} and {@code int}\n     * values, passing them to the given converter.   The implementation avoids latency issues present\n     * on some JRE releases.\n     *\n     * @since 2.9.8\n     */\n    public static <T> T extractSecondsAndNanos(BigDecimal seconds, BiFunction<Long, Integer, T> convert)\n    {\n        // Complexity is here to workaround unbounded latency in some BigDecimal operations.\n        //   https://github.com/FasterXML/jackson-databind/issues/2141\n\n        long secondsOnly;\n        int nanosOnly;\n\n        BigDecimal nanoseconds = seconds.scaleByPowerOfTen(9);\n        if (nanoseconds.precision() - nanoseconds.scale() <= 0) {\n            // There are no non-zero digits to the left of the decimal point.\n            // This protects against very negative exponents.\n            secondsOnly = nanosOnly = 0;\n        }\n        else if (seconds.scale() < -63) {\n            // There would be no low-order bits once we chop to a long.\n            // This protects against very positive exponents.\n            secondsOnly = nanosOnly = 0;\n        }\n        else {\n            // Now we know that seconds has reasonable scale, we can safely chop it apart.\n            secondsOnly = seconds.longValue();\n            nanosOnly = nanoseconds.subtract(new BigDecimal(secondsOnly).scaleByPowerOfTen(9)).intValue();\n        }\n\n        return convert.apply(secondsOnly, nanosOnly);\n    }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700063,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage com.facebook.thrift.protocol;\n\nimport java.util.Collections;\n\nimport com.facebook.thrift.TException;\n\n/**\n * Utility class with static methods for interacting with protocol data\n * streams.\n *\n */\npublic class TProtocolUtil {\n\n  /**\n   * The maximum recursive depth the skip() function will traverse before\n   * throwing a TException.\n   */\n  private static int maxSkipDepth = Integer.MAX_VALUE;\n\n  /**\n   * Specifies the maximum recursive depth that the skip function will\n   * traverse before throwing a TException.  This is a global setting, so\n   * any call to skip in this JVM will enforce this value.\n   *\n   * @param depth  the maximum recursive depth.  A value of 2 would allow\n   *    the skip function to skip a structure or collection with basic children,\n   *    but it would not permit skipping a struct that had a field containing\n   *    a child struct.  A value of 1 would only allow skipping of simple\n   *    types and empty structs/collections.\n   */\n  public static void setMaxSkipDepth(int depth) {\n    maxSkipDepth = depth;\n  }\n\n  /**\n   * Skips over the next data element from the provided input TProtocol object.\n   *\n   * @param prot  the protocol object to read from\n   * @param type  the next value will be intepreted as this TType value.\n   */\n  public static void skip(TProtocol prot, byte type)\n    throws TException {\n    skip(prot, type, maxSkipDepth);\n  }\n\n  /**\n   * Skips over the next data element from the provided input TProtocol object.\n   *\n   * @param prot  the protocol object to read from\n   * @param type  the next value will be intepreted as this TType value.\n   * @param maxDepth  this function will only skip complex objects to this\n   *   recursive depth, to prevent Java stack overflow.\n   */\n  public static void skip(TProtocol prot, byte type, int maxDepth)\n  throws TException {\n    if (maxDepth <= 0) {\n      throw new TException(\"Maximum skip depth exceeded\");\n    }\n    switch (type) {\n    case TType.BOOL:\n      {\n        prot.readBool();\n        break;\n      }\n    case TType.BYTE:\n      {\n        prot.readByte();\n        break;\n      }\n    case TType.I16:\n      {\n        prot.readI16();\n        break;\n      }\n    case TType.I32:\n      {\n        prot.readI32();\n        break;\n      }\n    case TType.I64:\n      {\n        prot.readI64();\n        break;\n      }\n    case TType.DOUBLE:\n      {\n        prot.readDouble();\n        break;\n      }\n    case TType.FLOAT:\n      {\n        prot.readFloat();\n        break;\n      }\n    case TType.STRING:\n      {\n        prot.readBinary();\n        break;\n      }\n    case TType.STRUCT:\n      {\n        prot.readStructBegin(\n            Collections.<Integer, com.facebook.thrift.meta_data.FieldMetaData>emptyMap());\n        while (true) {\n          TField field = prot.readFieldBegin();\n          if (field.type == TType.STOP) {\n            break;\n          }\n          skip(prot, field.type, maxDepth - 1);\n          prot.readFieldEnd();\n        }\n        prot.readStructEnd();\n        break;\n      }\n    case TType.MAP:\n      {\n        TMap map = prot.readMapBegin();\n        for (int i = 0;\n             (map.size < 0) ? prot.peekMap() : (i < map.size);\n             i++) {\n          skip(prot, map.keyType, maxDepth - 1);\n          skip(prot, map.valueType, maxDepth - 1);\n        }\n        prot.readMapEnd();\n        break;\n      }\n    case TType.SET:\n      {\n        TSet set = prot.readSetBegin();\n        for (int i = 0;\n             (set.size < 0) ? prot.peekSet() : (i < set.size);\n             i++) {\n          skip(prot, set.elemType, maxDepth - 1);\n        }\n        prot.readSetEnd();\n        break;\n      }\n    case TType.LIST:\n      {\n        TList list = prot.readListBegin();\n        for (int i = 0;\n             (list.size < 0) ? prot.peekList() : (i < list.size);\n             i++) {\n          skip(prot, list.elemType, maxDepth - 1);\n        }\n        prot.readListEnd();\n        break;\n      }\n    default:\n      break;\n    }\n  }\n\n  /**\n   * Attempt to determine the protocol used to serialize some data.\n   *\n   * The guess is based on known specificities of supported protocols.\n   * In some cases, no guess can be done, in that case we return the\n   * fallback TProtocolFactory.\n   * To be certain to correctly detect the protocol, the first encoded\n   * field should have a field id < 256\n   *\n   * @param data The serialized data to guess the protocol for.\n   * @param fallback The TProtocol to return if no guess can be made.\n   * @return a Class implementing TProtocolFactory which can be used to create a deserializer.\n   */\n  public static TProtocolFactory guessProtocolFactory(byte[] data, TProtocolFactory fallback) {\n    //\n    // If the first and last bytes are opening/closing curly braces we guess the protocol as\n    // being TJSONProtocol.\n    // It could not be a TCompactBinary encoding for a field of type 0xb (Map)\n    // with delta id 7 as the last byte for TCompactBinary is always 0.\n    //\n\n    if ('{' == data[0] && '}' == data[data.length - 1]) {\n      return new TJSONProtocol.Factory();\n    }\n\n    //\n    // If the last byte is not 0, then it cannot be TCompactProtocol, it must be\n    // TBinaryProtocol.\n    //\n\n    if (data[data.length - 1] != 0) {\n      return new TBinaryProtocol.Factory();\n    }\n\n    //\n    // A first byte of value > 16 indicates TCompactProtocol was used, and the first byte\n    // encodes a delta field id (id <= 15) and a field type.\n    //\n\n    if (data[0] > 0x10) {\n      return new TCompactProtocol.Factory();\n    }\n\n    //\n    // If the second byte is 0 then it is a field id < 256 encoded by TBinaryProtocol.\n    // It cannot possibly be TCompactProtocol since a value of 0 would imply a field id\n    // of 0 as the zig zag varint encoding would end.\n    //\n\n    if (data.length > 1 && 0 == data[1]) {\n      return new TBinaryProtocol.Factory();\n    }\n\n    //\n    // If bit 7 of the first byte of the field id is set then we have two choices:\n    // 1. A field id > 63 was encoded with TCompactProtocol.\n    // 2. A field id > 0x7fff (32767) was encoded with TBinaryProtocol and the last byte of the\n    //    serialized data is 0.\n    // Option 2 is impossible since field ids are short and thus limited to 32767.\n    //\n\n    if (data.length > 1 && (data[1] & 0x80) != 0) {\n      return new TCompactProtocol.Factory();\n    }\n\n    //\n    // The remaining case is either a field id <= 63 encoded as TCompactProtocol,\n    // one >= 256 encoded with TBinaryProtocol with a last byte at 0, or an empty structure.\n    // As we cannot really decide, we return the fallback protocol.\n    //\n    return fallback;\n  }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700152,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-20"
    ],
    "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage com.facebook.thrift.protocol;\n\nimport java.util.Collections;\n\nimport com.facebook.thrift.TException;\n\n/**\n * Utility class with static methods for interacting with protocol data\n * streams.\n *\n */\npublic class TProtocolUtil {\n\n  /**\n   * The maximum recursive depth the skip() function will traverse before\n   * throwing a TException.\n   */\n  private static int maxSkipDepth = Integer.MAX_VALUE;\n\n  /**\n   * Specifies the maximum recursive depth that the skip function will\n   * traverse before throwing a TException.  This is a global setting, so\n   * any call to skip in this JVM will enforce this value.\n   *\n   * @param depth  the maximum recursive depth.  A value of 2 would allow\n   *    the skip function to skip a structure or collection with basic children,\n   *    but it would not permit skipping a struct that had a field containing\n   *    a child struct.  A value of 1 would only allow skipping of simple\n   *    types and empty structs/collections.\n   */\n  public static void setMaxSkipDepth(int depth) {\n    maxSkipDepth = depth;\n  }\n\n  /**\n   * Skips over the next data element from the provided input TProtocol object.\n   *\n   * @param prot  the protocol object to read from\n   * @param type  the next value will be intepreted as this TType value.\n   */\n  public static void skip(TProtocol prot, byte type)\n    throws TException {\n    skip(prot, type, maxSkipDepth);\n  }\n\n  /**\n   * Skips over the next data element from the provided input TProtocol object.\n   *\n   * @param prot  the protocol object to read from\n   * @param type  the next value will be intepreted as this TType value.\n   * @param maxDepth  this function will only skip complex objects to this\n   *   recursive depth, to prevent Java stack overflow.\n   */\n  public static void skip(TProtocol prot, byte type, int maxDepth)\n  throws TException {\n    if (maxDepth <= 0) {\n      throw new TException(\"Maximum skip depth exceeded\");\n    }\n    switch (type) {\n    case TType.BOOL:\n      {\n        prot.readBool();\n        break;\n      }\n    case TType.BYTE:\n      {\n        prot.readByte();\n        break;\n      }\n    case TType.I16:\n      {\n        prot.readI16();\n        break;\n      }\n    case TType.I32:\n      {\n        prot.readI32();\n        break;\n      }\n    case TType.I64:\n      {\n        prot.readI64();\n        break;\n      }\n    case TType.DOUBLE:\n      {\n        prot.readDouble();\n        break;\n      }\n    case TType.FLOAT:\n      {\n        prot.readFloat();\n        break;\n      }\n    case TType.STRING:\n      {\n        prot.readBinary();\n        break;\n      }\n    case TType.STRUCT:\n      {\n        prot.readStructBegin(\n            Collections.<Integer, com.facebook.thrift.meta_data.FieldMetaData>emptyMap());\n        while (true) {\n          TField field = prot.readFieldBegin();\n          if (field.type == TType.STOP) {\n            break;\n          }\n          skip(prot, field.type, maxDepth - 1);\n          prot.readFieldEnd();\n        }\n        prot.readStructEnd();\n        break;\n      }\n    case TType.MAP:\n      {\n        TMap map = prot.readMapBegin();\n        for (int i = 0;\n             (map.size < 0) ? prot.peekMap() : (i < map.size);\n             i++) {\n          skip(prot, map.keyType, maxDepth - 1);\n          skip(prot, map.valueType, maxDepth - 1);\n        }\n        prot.readMapEnd();\n        break;\n      }\n    case TType.SET:\n      {\n        TSet set = prot.readSetBegin();\n        for (int i = 0;\n             (set.size < 0) ? prot.peekSet() : (i < set.size);\n             i++) {\n          skip(prot, set.elemType, maxDepth - 1);\n        }\n        prot.readSetEnd();\n        break;\n      }\n    case TType.LIST:\n      {\n        TList list = prot.readListBegin();\n        for (int i = 0;\n             (list.size < 0) ? prot.peekList() : (i < list.size);\n             i++) {\n          skip(prot, list.elemType, maxDepth - 1);\n        }\n        prot.readListEnd();\n        break;\n      }\n    default:\n      {\n        throw new TProtocolException(\n              TProtocolException.INVALID_DATA, \"Invalid type encountered during skipping: \" + type);\n      }\n    }\n  }\n\n  /**\n   * Attempt to determine the protocol used to serialize some data.\n   *\n   * The guess is based on known specificities of supported protocols.\n   * In some cases, no guess can be done, in that case we return the\n   * fallback TProtocolFactory.\n   * To be certain to correctly detect the protocol, the first encoded\n   * field should have a field id < 256\n   *\n   * @param data The serialized data to guess the protocol for.\n   * @param fallback The TProtocol to return if no guess can be made.\n   * @return a Class implementing TProtocolFactory which can be used to create a deserializer.\n   */\n  public static TProtocolFactory guessProtocolFactory(byte[] data, TProtocolFactory fallback) {\n    //\n    // If the first and last bytes are opening/closing curly braces we guess the protocol as\n    // being TJSONProtocol.\n    // It could not be a TCompactBinary encoding for a field of type 0xb (Map)\n    // with delta id 7 as the last byte for TCompactBinary is always 0.\n    //\n\n    if ('{' == data[0] && '}' == data[data.length - 1]) {\n      return new TJSONProtocol.Factory();\n    }\n\n    //\n    // If the last byte is not 0, then it cannot be TCompactProtocol, it must be\n    // TBinaryProtocol.\n    //\n\n    if (data[data.length - 1] != 0) {\n      return new TBinaryProtocol.Factory();\n    }\n\n    //\n    // A first byte of value > 16 indicates TCompactProtocol was used, and the first byte\n    // encodes a delta field id (id <= 15) and a field type.\n    //\n\n    if (data[0] > 0x10) {\n      return new TCompactProtocol.Factory();\n    }\n\n    //\n    // If the second byte is 0 then it is a field id < 256 encoded by TBinaryProtocol.\n    // It cannot possibly be TCompactProtocol since a value of 0 would imply a field id\n    // of 0 as the zig zag varint encoding would end.\n    //\n\n    if (data.length > 1 && 0 == data[1]) {\n      return new TBinaryProtocol.Factory();\n    }\n\n    //\n    // If bit 7 of the first byte of the field id is set then we have two choices:\n    // 1. A field id > 63 was encoded with TCompactProtocol.\n    // 2. A field id > 0x7fff (32767) was encoded with TBinaryProtocol and the last byte of the\n    //    serialized data is 0.\n    // Option 2 is impossible since field ids are short and thus limited to 32767.\n    //\n\n    if (data.length > 1 && (data[1] & 0x80) != 0) {\n      return new TCompactProtocol.Factory();\n    }\n\n    //\n    // The remaining case is either a field id <= 63 encoded as TCompactProtocol,\n    // one >= 256 encoded with TBinaryProtocol with a last byte at 0, or an empty structure.\n    // As we cannot really decide, we return the fallback protocol.\n    //\n    return fallback;\n  }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700153,
    "RELATED_CWE": [
      "CWE-362",
      "CWE-415",
      "CWE-269"
    ]
  }
]