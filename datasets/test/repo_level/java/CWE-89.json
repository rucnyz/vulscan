[
  {
    "CWE_ID": [
      "CWE-89"
    ],
    "code": "package com.icthh.xm.commons.migration.db.tenant;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.core.env.Environment;\nimport org.springframework.stereotype.Component;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Slf4j\n@Component\npublic class DropSchemaResolver {\n\n    @Deprecated\n    private static final String DEFAULT_COMMAND = \"DROP SCHEMA IF EXISTS %s CASCADE\";\n    private static final String DEFAULT_SQL_COMMAND = \"DROP SCHEMA IF EXISTS %s CASCADE\";\n\n    @Deprecated\n    private static final Map<String, String> DB_COMMANDS = new HashMap<>();\n    private static final Map<String, String> DB_SQL_COMMANDS = new HashMap<>();\n\n    static {\n        DB_COMMANDS.put(\"POSTGRESQL\", DEFAULT_COMMAND);\n        DB_COMMANDS.put(\"H2\", DEFAULT_COMMAND);\n\n        DB_SQL_COMMANDS.put(\"POSTGRESQL\", DEFAULT_SQL_COMMAND);\n        DB_SQL_COMMANDS.put(\"H2\", DEFAULT_SQL_COMMAND);\n    }\n\n    @Deprecated\n    private final String dbDropSchemaCommand;\n\n    private final String dbDropSchemaSqlCommand;\n\n    /**\n     * DropSchemaResolver constructor.\n     * @param env the environment\n     */\n    public DropSchemaResolver(Environment env) {\n        String db = env.getProperty(\"spring.jpa.database\");\n        this.dbDropSchemaCommand = DB_COMMANDS.getOrDefault(db, DEFAULT_COMMAND);\n        this.dbDropSchemaSqlCommand = DB_SQL_COMMANDS.getOrDefault(db, DEFAULT_SQL_COMMAND);\n        log.info(\"Database {} will use command '{}' for drop schema\", db, dbDropSchemaSqlCommand);\n    }\n\n    /**\n     * @deprecated use getSchemaDropSqlCommand instead\n     */\n    @Deprecated\n    public String getSchemaDropCommand() {\n        return this.dbDropSchemaCommand;\n    }\n\n    public String getSchemaDropSqlCommand() {\n        return this.dbDropSchemaSqlCommand;\n    }\n\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700124,
    "RELATED_CWE": [
      "CWE-90",
      "CWE-91",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-89"
    ],
    "code": "package com.icthh.xm.commons.migration.db.tenant;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.core.env.Environment;\nimport org.springframework.stereotype.Component;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Slf4j\n@Component\npublic class DropSchemaResolver {\n\n    @Deprecated\n    private static final String DEFAULT_COMMAND = \"DROP SCHEMA IF EXISTS %s CASCADE\";\n    private static final String DEFAULT_SQL_COMMAND = \"DROP SCHEMA IF EXISTS ? CASCADE\";\n\n    @Deprecated\n    private static final Map<String, String> DB_COMMANDS = new HashMap<>();\n    private static final Map<String, String> DB_SQL_COMMANDS = new HashMap<>();\n\n    static {\n        DB_COMMANDS.put(\"POSTGRESQL\", DEFAULT_COMMAND);\n        DB_COMMANDS.put(\"H2\", DEFAULT_COMMAND);\n\n        DB_SQL_COMMANDS.put(\"POSTGRESQL\", DEFAULT_SQL_COMMAND);\n        DB_SQL_COMMANDS.put(\"H2\", DEFAULT_SQL_COMMAND);\n    }\n\n    @Deprecated\n    private final String dbDropSchemaCommand;\n\n    private final String dbDropSchemaSqlCommand;\n\n    /**\n     * DropSchemaResolver constructor.\n     * @param env the environment\n     */\n    public DropSchemaResolver(Environment env) {\n        String db = env.getProperty(\"spring.jpa.database\");\n        this.dbDropSchemaCommand = DB_COMMANDS.getOrDefault(db, DEFAULT_COMMAND);\n        this.dbDropSchemaSqlCommand = DB_SQL_COMMANDS.getOrDefault(db, DEFAULT_SQL_COMMAND);\n        log.info(\"Database {} will use command '{}' for drop schema\", db, dbDropSchemaSqlCommand);\n    }\n\n    /**\n     * @deprecated use getSchemaDropSqlCommand instead\n     */\n    @Deprecated\n    public String getSchemaDropCommand() {\n        return this.dbDropSchemaCommand;\n    }\n\n    public String getSchemaDropSqlCommand() {\n        return this.dbDropSchemaSqlCommand;\n    }\n\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700125,
    "RELATED_CWE": [
      "CWE-90",
      "CWE-91",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-89"
    ],
    "code": "/*******************************************************************************\n * Copyright (C) 2005-2014 Alfresco Software Limited.\n *\n * This file is part of Alfresco Mobile for Android.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *******************************************************************************/\npackage org.alfresco.mobile.android.application.providers.search;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\n\nimport org.alfresco.mobile.android.application.database.DatabaseManagerImpl;\nimport org.alfresco.mobile.android.platform.database.DatabaseManager;\nimport org.alfresco.mobile.android.platform.provider.AlfrescoContentProvider;\n\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.content.UriMatcher;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.text.TextUtils;\nimport android.util.Log;\n\n/**\n * @since 1.4\n * @author Jean Marie Pascal\n */\npublic class HistorySearchProvider extends ContentProvider implements AlfrescoContentProvider\n{\n    private static final String TAG = HistorySearchProvider.class.getName();\n\n    private DatabaseManager databaseManager;\n\n    private static final int SEARCHES = 0;\n\n    private static final int SEARCH_ID = 1;\n\n    private static final String AUTHORITY = AUTHORITY_ALFRESCO_BASE + \".searches\";\n\n    private static final String BASE_PATH = \"search\";\n\n    public static final Uri CONTENT_URI = Uri.parse(\"content://\" + AUTHORITY + \"/\" + BASE_PATH);\n\n    public static final String CONTENT_TYPE = ContentResolver.CURSOR_DIR_BASE_TYPE + \"/searches\";\n\n    public static final String CONTENT_ITEM_TYPE = ContentResolver.CURSOR_ITEM_BASE_TYPE + \"/search\";\n\n    private static final UriMatcher URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);\n    static\n    {\n        URI_MATCHER.addURI(AUTHORITY, BASE_PATH, SEARCHES);\n        URI_MATCHER.addURI(AUTHORITY, BASE_PATH + \"/#\", SEARCH_ID);\n    }\n\n    @Override\n    public boolean onCreate()\n    {\n        databaseManager = DatabaseManagerImpl.getInstance(getContext());\n        return true;\n    }\n\n    @Override\n    public int delete(Uri uri, String selection, String[] selectionArgs)\n    {\n        int uriType = URI_MATCHER.match(uri);\n        SQLiteDatabase db = databaseManager.getWriteDb();\n        int rowsDeleted = 0;\n        switch (uriType)\n        {\n            case SEARCHES:\n                rowsDeleted = db.delete(HistorySearchSchema.TABLENAME, selection, selectionArgs);\n                break;\n            case SEARCH_ID:\n                String id = uri.getLastPathSegment();\n                if (TextUtils.isEmpty(selection))\n                {\n                    rowsDeleted = db.delete(HistorySearchSchema.TABLENAME, HistorySearchSchema.COLUMN_ID + \"=\" + id,\n                            null);\n                }\n                else\n                {\n                    rowsDeleted = db.delete(HistorySearchSchema.TABLENAME, HistorySearchSchema.COLUMN_ID + \"=\" + id\n                            + \" and \" + selection, selectionArgs);\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n        getContext().getContentResolver().notifyChange(uri, null);\n        return rowsDeleted;\n    }\n\n    @Override\n    public String getType(Uri uri)\n    {\n        return null;\n    }\n\n    @Override\n    public Uri insert(Uri uri, ContentValues values)\n    {\n        int uriType = URI_MATCHER.match(uri);\n        SQLiteDatabase db = databaseManager.getWriteDb();\n        long id = 0;\n\n        switch (uriType)\n        {\n            case SEARCHES:\n                id = db.insert(HistorySearchSchema.TABLENAME, null, values);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n        if (id == -1)\n        {\n            Log.e(TAG, uri + \" \" + values);\n        }\n        getContext().getContentResolver().notifyChange(uri, null);\n        return Uri.parse(CONTENT_URI + \"/\" + id);\n    }\n\n    @Override\n    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)\n    {\n        SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();\n\n        // Check if the caller has requested a column which does not exists\n        checkColumns(projection);\n\n        queryBuilder.setTables(HistorySearchSchema.TABLENAME);\n\n        int uriType = URI_MATCHER.match(uri);\n        switch (uriType)\n        {\n            case SEARCHES:\n                break;\n            case SEARCH_ID:\n                // Adding the ID to the original query\n                queryBuilder.appendWhere(HistorySearchSchema.COLUMN_ID + \"=\" + uri.getLastPathSegment());\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n\n        SQLiteDatabase db = databaseManager.getWriteDb();\n        Cursor cursor = queryBuilder.query(db, projection, selection, selectionArgs, null, null, sortOrder);\n        // Make sure that potential listeners are getting notified\n        cursor.setNotificationUri(getContext().getContentResolver(), uri);\n\n        return cursor;\n    }\n\n    @Override\n    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)\n    {\n        int uriType = URI_MATCHER.match(uri);\n        SQLiteDatabase sqlDB = databaseManager.getWriteDb();\n        int rowsUpdated = 0;\n        switch (uriType)\n        {\n            case SEARCHES:\n                rowsUpdated = sqlDB.update(HistorySearchSchema.TABLENAME, values, selection, selectionArgs);\n                break;\n            case SEARCH_ID:\n                String id = uri.getLastPathSegment();\n                if (TextUtils.isEmpty(selection))\n                {\n                    rowsUpdated = sqlDB.update(HistorySearchSchema.TABLENAME, values, HistorySearchSchema.COLUMN_ID\n                            + \"=\" + id, null);\n                }\n                else\n                {\n                    rowsUpdated = sqlDB.update(HistorySearchSchema.TABLENAME, values, HistorySearchSchema.COLUMN_ID\n                            + \"=\" + id + \" and \" + selection, selectionArgs);\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n        getContext().getContentResolver().notifyChange(uri, null);\n        return rowsUpdated;\n    }\n\n    private void checkColumns(String[] projection)\n    {\n        if (projection != null)\n        {\n            HashSet<String> requestedColumns = new HashSet<String>(Arrays.asList(projection));\n            HashSet<String> availableColumns = new HashSet<String>(Arrays.asList(HistorySearchManager.COLUMN_ALL));\n            // Check if all columns which are requested are available\n            if (!availableColumns.containsAll(requestedColumns)) { throw new IllegalArgumentException(\n                    \"Unknown columns in projection\"); }\n        }\n    }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700126,
    "RELATED_CWE": [
      "CWE-90",
      "CWE-91",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-89"
    ],
    "code": "/*******************************************************************************\n * Copyright (C) 2005-2014 Alfresco Software Limited.\n *\n * This file is part of Alfresco Mobile for Android.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *******************************************************************************/\npackage org.alfresco.mobile.android.application.providers.search;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\n\nimport org.alfresco.mobile.android.application.database.DatabaseManagerImpl;\nimport org.alfresco.mobile.android.platform.database.DatabaseManager;\nimport org.alfresco.mobile.android.platform.provider.AlfrescoContentProvider;\n\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.content.UriMatcher;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.text.TextUtils;\nimport android.util.Log;\n\n/**\n * @since 1.4\n * @author Jean Marie Pascal\n */\npublic class HistorySearchProvider extends ContentProvider implements AlfrescoContentProvider\n{\n    private static final String TAG = HistorySearchProvider.class.getName();\n\n    private DatabaseManager databaseManager;\n\n    private static final int SEARCHES = 0;\n\n    private static final int SEARCH_ID = 1;\n\n    private static final String AUTHORITY = AUTHORITY_ALFRESCO_BASE + \".searches\";\n\n    private static final String BASE_PATH = \"search\";\n\n    public static final Uri CONTENT_URI = Uri.parse(\"content://\" + AUTHORITY + \"/\" + BASE_PATH);\n\n    public static final String CONTENT_TYPE = ContentResolver.CURSOR_DIR_BASE_TYPE + \"/searches\";\n\n    public static final String CONTENT_ITEM_TYPE = ContentResolver.CURSOR_ITEM_BASE_TYPE + \"/search\";\n\n    private static final UriMatcher URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);\n    static\n    {\n        URI_MATCHER.addURI(AUTHORITY, BASE_PATH, SEARCHES);\n        URI_MATCHER.addURI(AUTHORITY, BASE_PATH + \"/#\", SEARCH_ID);\n    }\n\n    @Override\n    public boolean onCreate()\n    {\n        databaseManager = DatabaseManagerImpl.getInstance(getContext());\n        return true;\n    }\n\n    @Override\n    public int delete(Uri uri, String selection, String[] selectionArgs)\n    {\n        int uriType = URI_MATCHER.match(uri);\n        SQLiteDatabase db = databaseManager.getWriteDb();\n        int rowsDeleted = 0;\n        switch (uriType)\n        {\n            case SEARCHES:\n                rowsDeleted = db.delete(HistorySearchSchema.TABLENAME, selection, selectionArgs);\n                break;\n            case SEARCH_ID:\n                String id = uri.getLastPathSegment();\n                if (TextUtils.isEmpty(selection))\n                {\n                    rowsDeleted = db.delete(HistorySearchSchema.TABLENAME, HistorySearchSchema.COLUMN_ID + \"=\" + id,\n                            null);\n                }\n                else\n                {\n                    rowsDeleted = db.delete(HistorySearchSchema.TABLENAME, HistorySearchSchema.COLUMN_ID + \"=\" + id\n                            + \" and \" + selection, selectionArgs);\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n        getContext().getContentResolver().notifyChange(uri, null);\n        return rowsDeleted;\n    }\n\n    @Override\n    public String getType(Uri uri)\n    {\n        return null;\n    }\n\n    @Override\n    public Uri insert(Uri uri, ContentValues values)\n    {\n        int uriType = URI_MATCHER.match(uri);\n        SQLiteDatabase db = databaseManager.getWriteDb();\n        long id = 0;\n\n        switch (uriType)\n        {\n            case SEARCHES:\n                id = db.insert(HistorySearchSchema.TABLENAME, null, values);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n        if (id == -1)\n        {\n            Log.e(TAG, uri + \" \" + values);\n        }\n        getContext().getContentResolver().notifyChange(uri, null);\n        return Uri.parse(CONTENT_URI + \"/\" + id);\n    }\n\n    @Override\n    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)\n    {\n        SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();\n\n        // Check if the caller has requested a column which does not exists\n        checkColumns(projection);\n\n        queryBuilder.setStrict(true);\n        queryBuilder.setTables(HistorySearchSchema.TABLENAME);\n        queryBuilder.setProjectionMap(createProjectionMap(projection));\n\n        int uriType = URI_MATCHER.match(uri);\n        switch (uriType)\n        {\n            case SEARCHES:\n                break;\n            case SEARCH_ID:\n                // Adding the ID to the original query\n                queryBuilder.appendWhere(HistorySearchSchema.COLUMN_ID + \"=\" + uri.getLastPathSegment());\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n\n        SQLiteDatabase db = databaseManager.getWriteDb();\n        Cursor cursor = queryBuilder.query(db, projection, selection, selectionArgs, null, null, sortOrder);\n        // Make sure that potential listeners are getting notified\n        cursor.setNotificationUri(getContext().getContentResolver(), uri);\n\n        return cursor;\n    }\n\n    @Override\n    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)\n    {\n        int uriType = URI_MATCHER.match(uri);\n        SQLiteDatabase sqlDB = databaseManager.getWriteDb();\n        int rowsUpdated = 0;\n        switch (uriType)\n        {\n            case SEARCHES:\n                rowsUpdated = sqlDB.update(HistorySearchSchema.TABLENAME, values, selection, selectionArgs);\n                break;\n            case SEARCH_ID:\n                String id = uri.getLastPathSegment();\n                if (TextUtils.isEmpty(selection))\n                {\n                    rowsUpdated = sqlDB.update(HistorySearchSchema.TABLENAME, values, HistorySearchSchema.COLUMN_ID\n                            + \"=\" + id, null);\n                }\n                else\n                {\n                    rowsUpdated = sqlDB.update(HistorySearchSchema.TABLENAME, values, HistorySearchSchema.COLUMN_ID\n                            + \"=\" + id + \" and \" + selection, selectionArgs);\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n        getContext().getContentResolver().notifyChange(uri, null);\n        return rowsUpdated;\n    }\n\n    private void checkColumns(String[] projection)\n    {\n        if (projection != null)\n        {\n            HashSet<String> requestedColumns = new HashSet<String>(Arrays.asList(projection));\n            HashSet<String> availableColumns = new HashSet<String>(Arrays.asList(HistorySearchManager.COLUMN_ALL));\n            // Check if all columns which are requested are available\n            if (!availableColumns.containsAll(requestedColumns)) { throw new IllegalArgumentException(\n                    \"Unknown columns in projection\"); }\n        }\n    }\n\n    private Map<String, String> createProjectionMap(String[] projection) {\n        Map<String, String> projectionMap = new HashMap<>();\n        for (String column : projection) {\n            projectionMap.put(column, column);\n        }\n        return projectionMap;\n    }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700127,
    "RELATED_CWE": [
      "CWE-90",
      "CWE-91",
      "CWE-78"
    ]
  }
]