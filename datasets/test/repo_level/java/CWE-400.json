[
  {
    "CWE_ID": [
      "CWE-400"
    ],
    "code": "/*\n *  Licensed to GraphHopper GmbH under one or more contributor\n *  license agreements. See the NOTICE file distributed with this work for\n *  additional information regarding copyright ownership.\n *\n *  GraphHopper GmbH licenses this file to you under the Apache License,\n *  Version 2.0 (the \"License\"); you may not use this file except in\n *  compliance with the License. You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage com.graphhopper.navigation;\n\nimport com.graphhopper.GHRequest;\nimport com.graphhopper.GHResponse;\nimport com.graphhopper.GraphHopperAPI;\nimport com.graphhopper.GraphHopperConfig;\nimport com.graphhopper.util.Helper;\nimport com.graphhopper.util.Parameters;\nimport com.graphhopper.util.StopWatch;\nimport com.graphhopper.util.TranslationMap;\nimport com.graphhopper.util.shapes.GHPoint;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.inject.Inject;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.ws.rs.*;\nimport javax.ws.rs.container.ContainerRequestContext;\nimport javax.ws.rs.core.Context;\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.core.Response;\nimport javax.ws.rs.core.UriInfo;\nimport java.util.*;\n\nimport static com.graphhopper.util.Parameters.Routing.*;\n\n/**\n * Provides an endpoint that is consumable with the Mapbox Navigation SDK. The Mapbox Navigation SDK consumes json\n * responses that follow the specification of the Mapbox API v5.\n * <p>\n * See: https://www.mapbox.com/api-documentation/#directions\n * <p>\n * The baseurl of this endpoint is: [YOUR-IP/HOST]/navigate\n * The version of this endpoint is: v5\n * The user of this endpoint is: gh\n *\n * @author Robin Boldt\n */\n@Path(\"navigate/directions/v5/gh\")\npublic class NavigateResource {\n\n    private static final Logger logger = LoggerFactory.getLogger(NavigateResource.class);\n\n    private final GraphHopperAPI graphHopper;\n    private final TranslationMap translationMap;\n    private final Map<String, String> resolverMap;\n\n    @Inject\n    public NavigateResource(GraphHopperAPI graphHopper, TranslationMap translationMap, GraphHopperConfig config) {\n        this.graphHopper = graphHopper;\n        resolverMap = config.asPMap().getObject(\"profiles_mapbox\", new HashMap<>());\n        if (resolverMap.isEmpty()) {\n            resolverMap.put(\"driving\", \"car\");\n            // driving-traffic is mapped to regular car as well\n            resolverMap.put(\"driving-traffic\", \"car\");\n            resolverMap.put(\"walking\", \"foot\");\n            resolverMap.put(\"cycling\", \"bike\");\n        }\n        this.translationMap = translationMap;\n    }\n\n    @GET\n    @Path(\"/{profile}/{coordinatesArray : .+}\")\n    @Produces({MediaType.APPLICATION_JSON})\n    public Response doGet(\n            @Context HttpServletRequest httpReq,\n            @Context UriInfo uriInfo,\n            @Context ContainerRequestContext rc,\n            @QueryParam(\"steps\") @DefaultValue(\"false\") boolean enableInstructions,\n            @QueryParam(\"voice_instructions\") @DefaultValue(\"false\") boolean voiceInstructions,\n            @QueryParam(\"banner_instructions\") @DefaultValue(\"false\") boolean bannerInstructions,\n            @QueryParam(\"roundabout_exits\") @DefaultValue(\"false\") boolean roundaboutExits,\n            @QueryParam(\"voice_units\") @DefaultValue(\"metric\") String voiceUnits,\n            @QueryParam(\"overview\") @DefaultValue(\"simplified\") String overview,\n            @QueryParam(\"geometries\") @DefaultValue(\"polyline\") String geometries,\n            @QueryParam(\"bearings\") @DefaultValue(\"\") String bearings,\n            @QueryParam(\"language\") @DefaultValue(\"en\") String localeStr,\n            @PathParam(\"profile\") String mapboxProfile) {\n\n        /*\n            Currently, the NavigateResponseConverter is pretty limited.\n            Therefore, we enforce these values to make sure the client does not receive an unexpected answer.\n         */\n        if (!geometries.equals(\"polyline6\"))\n            throw new IllegalArgumentException(\"Currently, we only support polyline6\");\n        if (!enableInstructions)\n            throw new IllegalArgumentException(\"Currently, you need to enable steps\");\n        if (!roundaboutExits)\n            throw new IllegalArgumentException(\"Roundabout exits have to be enabled right now\");\n        if (!voiceInstructions)\n            throw new IllegalArgumentException(\"You need to enable voice instructions right now\");\n        if (!bannerInstructions)\n            throw new IllegalArgumentException(\"You need to enable banner instructions right now\");\n\n        double minPathPrecision = 1;\n        if (overview.equals(\"full\"))\n            minPathPrecision = 0;\n\n        DistanceUtils.Unit unit;\n        if (voiceUnits.equals(\"metric\")) {\n            unit = DistanceUtils.Unit.METRIC;\n        } else {\n            unit = DistanceUtils.Unit.IMPERIAL;\n        }\n\n        String ghProfile = resolverMap.getOrDefault(mapboxProfile, mapboxProfile);\n        List<GHPoint> requestPoints = getPointsFromRequest(httpReq, mapboxProfile);\n\n        List<Double> favoredHeadings = getBearing(bearings);\n        if (favoredHeadings.size() > 0 && favoredHeadings.size() != requestPoints.size()) {\n            throw new IllegalArgumentException(\"Number of bearings and waypoints did not match\");\n        }\n\n        StopWatch sw = new StopWatch().start();\n\n        GHResponse ghResponse = calcRoute(favoredHeadings, requestPoints, ghProfile, localeStr, enableInstructions, minPathPrecision);\n\n        // Only do this, when there are more than 2 points, otherwise we use alternative routes\n        if (!ghResponse.hasErrors() && favoredHeadings.size() > 0) {\n            GHResponse noHeadingResponse = calcRoute(Collections.EMPTY_LIST, requestPoints, ghProfile, localeStr, enableInstructions, minPathPrecision);\n            if (ghResponse.getBest().getDistance() != noHeadingResponse.getBest().getDistance()) {\n                ghResponse.getAll().add(noHeadingResponse.getBest());\n            }\n        }\n\n        float took = sw.stop().getSeconds();\n        String infoStr = httpReq.getRemoteAddr() + \" \" + httpReq.getLocale() + \" \" + httpReq.getHeader(\"User-Agent\");\n        String logStr = httpReq.getQueryString() + \" \" + infoStr + \" \" + requestPoints + \", took:\"\n                + took + \", \" + ghProfile;\n        Locale locale = Helper.getLocale(localeStr);\n        DistanceConfig config = new DistanceConfig(unit, translationMap, locale);\n\n        if (ghResponse.hasErrors()) {\n            logger.error(logStr + \", errors:\" + ghResponse.getErrors());\n            // Mapbox specifies 422 return type for input errors\n            return Response.status(422).entity(NavigateResponseConverter.convertFromGHResponseError(ghResponse)).\n                    header(\"X-GH-Took\", \"\" + Math.round(took * 1000)).\n                    build();\n        } else {\n            logger.info(logStr);\n            return Response.ok(NavigateResponseConverter.convertFromGHResponse(ghResponse, translationMap, locale, config)).\n                    header(\"X-GH-Took\", \"\" + Math.round(took * 1000)).\n                    build();\n        }\n    }\n\n    private GHResponse calcRoute(List<Double> favoredHeadings, List<GHPoint> requestPoints, String profileStr,\n                                 String localeStr, boolean enableInstructions, double minPathPrecision) {\n        GHRequest request;\n        if (favoredHeadings.size() > 0) {\n            request = new GHRequest(requestPoints, favoredHeadings);\n        } else {\n            request = new GHRequest(requestPoints);\n        }\n\n        request.setProfile(profileStr).\n                setLocale(localeStr).\n                putHint(CALC_POINTS, true).\n                putHint(INSTRUCTIONS, enableInstructions).\n                putHint(WAY_POINT_MAX_DISTANCE, minPathPrecision).\n                putHint(Parameters.CH.DISABLE, true).\n                putHint(Parameters.Routing.PASS_THROUGH, false);\n\n        return graphHopper.route(request);\n    }\n\n    /**\n     * This method is parsing the request URL String. Unfortunately it seems that there is no better options right now.\n     * See: https://stackoverflow.com/q/51420380/1548788\n     * <p>\n     * The url looks like: \".../{profile}/1.522438,42.504606;1.527209,42.504776;1.526113,42.505144;1.527218,42.50529?..\"\n     */\n    private List<GHPoint> getPointsFromRequest(HttpServletRequest httpServletRequest, String profile) {\n\n        String url = httpServletRequest.getRequestURI();\n        url = url.replaceFirst(\"/navigate/directions/v5/gh/\" + profile + \"/\", \"\");\n        url = url.replaceAll(\"\\\\?[*]\", \"\");\n\n        String[] pointStrings = url.split(\";\");\n\n        List<GHPoint> points = new ArrayList<>(pointStrings.length);\n        for (int i = 0; i < pointStrings.length; i++) {\n            points.add(GHPoint.fromStringLonLat(pointStrings[i]));\n        }\n\n        return points;\n    }\n\n    static List<Double> getBearing(String bearingString) {\n        if (bearingString == null || bearingString.isEmpty())\n            return Collections.EMPTY_LIST;\n\n        String[] bearingArray = bearingString.split(\";\", -1);\n        List<Double> bearings = new ArrayList<>(bearingArray.length);\n\n        for (int i = 0; i < bearingArray.length; i++) {\n            String singleBearing = bearingArray[i];\n            if (singleBearing.isEmpty()) {\n                bearings.add(Double.NaN);\n            } else {\n                if (!singleBearing.contains(\",\")) {\n                    throw new IllegalArgumentException(\"You passed an invalid bearings parameter \" + bearingString);\n                }\n                String[] singleBearingArray = singleBearing.split(\",\");\n                try {\n                    bearings.add(Double.parseDouble(singleBearingArray[0]));\n                } catch (NumberFormatException e) {\n                    throw new IllegalArgumentException(\"You passed an invalid bearings parameter \" + bearingString);\n                }\n            }\n        }\n        return bearings;\n    }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700260,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-787",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-400"
    ],
    "code": "/*\n *  Licensed to GraphHopper GmbH under one or more contributor\n *  license agreements. See the NOTICE file distributed with this work for\n *  additional information regarding copyright ownership.\n *\n *  GraphHopper GmbH licenses this file to you under the Apache License,\n *  Version 2.0 (the \"License\"); you may not use this file except in\n *  compliance with the License. You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage com.graphhopper.navigation;\n\nimport com.graphhopper.GHRequest;\nimport com.graphhopper.GHResponse;\nimport com.graphhopper.GraphHopperAPI;\nimport com.graphhopper.GraphHopperConfig;\nimport com.graphhopper.util.Helper;\nimport com.graphhopper.util.Parameters;\nimport com.graphhopper.util.StopWatch;\nimport com.graphhopper.util.TranslationMap;\nimport com.graphhopper.util.shapes.GHPoint;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.inject.Inject;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.ws.rs.*;\nimport javax.ws.rs.container.ContainerRequestContext;\nimport javax.ws.rs.core.Context;\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.core.Response;\nimport javax.ws.rs.core.UriInfo;\nimport java.util.*;\n\nimport static com.graphhopper.util.Parameters.Routing.*;\n\n/**\n * Provides an endpoint that is consumable with the Mapbox Navigation SDK. The Mapbox Navigation SDK consumes json\n * responses that follow the specification of the Mapbox API v5.\n * <p>\n * See: https://www.mapbox.com/api-documentation/#directions\n * <p>\n * The baseurl of this endpoint is: [YOUR-IP/HOST]/navigate\n * The version of this endpoint is: v5\n * The user of this endpoint is: gh\n *\n * @author Robin Boldt\n */\n@Path(\"navigate/directions/v5/gh\")\npublic class NavigateResource {\n\n    private static final Logger logger = LoggerFactory.getLogger(NavigateResource.class);\n\n    private final GraphHopperAPI graphHopper;\n    private final TranslationMap translationMap;\n    private final Map<String, String> resolverMap;\n\n    @Inject\n    public NavigateResource(GraphHopperAPI graphHopper, TranslationMap translationMap, GraphHopperConfig config) {\n        this.graphHopper = graphHopper;\n        resolverMap = config.asPMap().getObject(\"profiles_mapbox\", new HashMap<>());\n        if (resolverMap.isEmpty()) {\n            resolverMap.put(\"driving\", \"car\");\n            // driving-traffic is mapped to regular car as well\n            resolverMap.put(\"driving-traffic\", \"car\");\n            resolverMap.put(\"walking\", \"foot\");\n            resolverMap.put(\"cycling\", \"bike\");\n        }\n        this.translationMap = translationMap;\n    }\n\n    @GET\n    @Path(\"/{profile}/{coordinatesArray : .+}\")\n    @Produces({MediaType.APPLICATION_JSON})\n    public Response doGet(\n            @Context HttpServletRequest httpReq,\n            @Context UriInfo uriInfo,\n            @Context ContainerRequestContext rc,\n            @QueryParam(\"steps\") @DefaultValue(\"false\") boolean enableInstructions,\n            @QueryParam(\"voice_instructions\") @DefaultValue(\"false\") boolean voiceInstructions,\n            @QueryParam(\"banner_instructions\") @DefaultValue(\"false\") boolean bannerInstructions,\n            @QueryParam(\"roundabout_exits\") @DefaultValue(\"false\") boolean roundaboutExits,\n            @QueryParam(\"voice_units\") @DefaultValue(\"metric\") String voiceUnits,\n            @QueryParam(\"overview\") @DefaultValue(\"simplified\") String overview,\n            @QueryParam(\"geometries\") @DefaultValue(\"polyline\") String geometries,\n            @QueryParam(\"bearings\") @DefaultValue(\"\") String bearings,\n            @QueryParam(\"language\") @DefaultValue(\"en\") String localeStr,\n            @PathParam(\"profile\") String mapboxProfile) {\n\n        /*\n            Currently, the NavigateResponseConverter is pretty limited.\n            Therefore, we enforce these values to make sure the client does not receive an unexpected answer.\n         */\n        if (!geometries.equals(\"polyline6\"))\n            throw new IllegalArgumentException(\"Currently, we only support polyline6\");\n        if (!enableInstructions)\n            throw new IllegalArgumentException(\"Currently, you need to enable steps\");\n        if (!roundaboutExits)\n            throw new IllegalArgumentException(\"Roundabout exits have to be enabled right now\");\n        if (!voiceInstructions)\n            throw new IllegalArgumentException(\"You need to enable voice instructions right now\");\n        if (!bannerInstructions)\n            throw new IllegalArgumentException(\"You need to enable banner instructions right now\");\n\n        double minPathPrecision = 1;\n        if (overview.equals(\"full\"))\n            minPathPrecision = 0;\n\n        DistanceUtils.Unit unit;\n        if (voiceUnits.equals(\"metric\")) {\n            unit = DistanceUtils.Unit.METRIC;\n        } else {\n            unit = DistanceUtils.Unit.IMPERIAL;\n        }\n\n        String ghProfile = resolverMap.getOrDefault(mapboxProfile, mapboxProfile);\n        List<GHPoint> requestPoints = getPointsFromRequest(httpReq, mapboxProfile);\n\n        List<Double> favoredHeadings = getBearing(bearings);\n        if (favoredHeadings.size() > 0 && favoredHeadings.size() != requestPoints.size()) {\n            throw new IllegalArgumentException(\"Number of bearings and waypoints did not match\");\n        }\n\n        StopWatch sw = new StopWatch().start();\n\n        GHResponse ghResponse = calcRoute(favoredHeadings, requestPoints, ghProfile, localeStr, enableInstructions, minPathPrecision);\n\n        // Only do this, when there are more than 2 points, otherwise we use alternative routes\n        if (!ghResponse.hasErrors() && favoredHeadings.size() > 0) {\n            GHResponse noHeadingResponse = calcRoute(Collections.EMPTY_LIST, requestPoints, ghProfile, localeStr, enableInstructions, minPathPrecision);\n            if (ghResponse.getBest().getDistance() != noHeadingResponse.getBest().getDistance()) {\n                ghResponse.getAll().add(noHeadingResponse.getBest());\n            }\n        }\n\n        float took = sw.stop().getSeconds();\n        String infoStr = httpReq.getRemoteAddr() + \" \" + httpReq.getLocale() + \" \" + httpReq.getHeader(\"User-Agent\");\n        String logStr = httpReq.getQueryString() + \" \" + infoStr + \" \" + requestPoints + \", took:\"\n                + took + \", \" + ghProfile;\n        Locale locale = Helper.getLocale(localeStr);\n        DistanceConfig config = new DistanceConfig(unit, translationMap, locale);\n\n        if (ghResponse.hasErrors()) {\n            logger.error(logStr + \", errors:\" + ghResponse.getErrors());\n            // Mapbox specifies 422 return type for input errors\n            return Response.status(422).entity(NavigateResponseConverter.convertFromGHResponseError(ghResponse)).\n                    header(\"X-GH-Took\", \"\" + Math.round(took * 1000)).\n                    build();\n        } else {\n            logger.info(logStr);\n            return Response.ok(NavigateResponseConverter.convertFromGHResponse(ghResponse, translationMap, locale, config)).\n                    header(\"X-GH-Took\", \"\" + Math.round(took * 1000)).\n                    build();\n        }\n    }\n\n    private GHResponse calcRoute(List<Double> favoredHeadings, List<GHPoint> requestPoints, String profileStr,\n                                 String localeStr, boolean enableInstructions, double minPathPrecision) {\n        GHRequest request;\n        if (favoredHeadings.size() > 0) {\n            request = new GHRequest(requestPoints, favoredHeadings);\n        } else {\n            request = new GHRequest(requestPoints);\n        }\n\n        request.setProfile(profileStr).\n                setLocale(localeStr).\n                putHint(CALC_POINTS, true).\n                putHint(INSTRUCTIONS, enableInstructions).\n                putHint(WAY_POINT_MAX_DISTANCE, minPathPrecision).\n                putHint(Parameters.CH.DISABLE, true).\n                putHint(Parameters.Routing.PASS_THROUGH, false);\n\n        return graphHopper.route(request);\n    }\n\n    /**\n     * This method is parsing the request URL String. Unfortunately it seems that there is no better options right now.\n     * See: https://stackoverflow.com/q/51420380/1548788\n     * <p>\n     * The url looks like: \".../{profile}/1.522438,42.504606;1.527209,42.504776;1.526113,42.505144;1.527218,42.50529?..\"\n     */\n    private List<GHPoint> getPointsFromRequest(HttpServletRequest httpServletRequest, String profile) {\n        String url = httpServletRequest.getRequestURI();\n        String urlStart = \"/navigate/directions/v5/gh/\" + profile + \"/\";\n        if (!url.startsWith(urlStart)) throw new IllegalArgumentException(\"Incorrect URL \" + url);\n        url = url.substring(urlStart.length());\n        String[] pointStrings = url.split(\";\");\n        List<GHPoint> points = new ArrayList<>(pointStrings.length);\n        for (int i = 0; i < pointStrings.length; i++) {\n            points.add(GHPoint.fromStringLonLat(pointStrings[i]));\n        }\n\n        return points;\n    }\n\n    static List<Double> getBearing(String bearingString) {\n        if (bearingString == null || bearingString.isEmpty())\n            return Collections.EMPTY_LIST;\n\n        String[] bearingArray = bearingString.split(\";\", -1);\n        List<Double> bearings = new ArrayList<>(bearingArray.length);\n\n        for (int i = 0; i < bearingArray.length; i++) {\n            String singleBearing = bearingArray[i];\n            if (singleBearing.isEmpty()) {\n                bearings.add(Double.NaN);\n            } else {\n                if (!singleBearing.contains(\",\")) {\n                    throw new IllegalArgumentException(\"You passed an invalid bearings parameter \" + bearingString);\n                }\n                String[] singleBearingArray = singleBearing.split(\",\");\n                try {\n                    bearings.add(Double.parseDouble(singleBearingArray[0]));\n                } catch (NumberFormatException e) {\n                    throw new IllegalArgumentException(\"You passed an invalid bearings parameter \" + bearingString);\n                }\n            }\n        }\n        return bearings;\n    }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700261,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-787",
      "CWE-416"
    ]
  }
]