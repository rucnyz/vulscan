[
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "package apoc.load;\n\nimport apoc.util.FileUtils;\nimport apoc.result.MapResult;\nimport apoc.result.NodeResult;\nimport apoc.util.Util;\nimport org.apache.commons.lang3.StringUtils;\nimport org.neo4j.graphdb.GraphDatabaseService;\nimport org.neo4j.graphdb.Label;\nimport org.neo4j.graphdb.RelationshipType;\nimport org.neo4j.logging.Log;\nimport org.neo4j.procedure.*;\nimport org.w3c.dom.CharacterData;\nimport org.w3c.dom.*;\n\nimport javax.xml.namespace.QName;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamReader;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.*;\nimport java.util.stream.Stream;\n\nimport static apoc.util.Util.cleanUrl;\nimport static javax.xml.stream.XMLStreamConstants.*;\n\npublic class Xml {\n\n    public static final XMLInputFactory FACTORY = XMLInputFactory.newFactory();\n\n    @Context\n    public GraphDatabaseService db;\n\n    @Context\n    public Log log;\n\n    @Procedure\n    @Description(\"apoc.load.xml('http://example.com/test.xml', 'xPath',config, false) YIELD value as doc CREATE (p:Person) SET p.name = doc.name load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _childrenx fields.\")\n    public Stream<MapResult> xml(@Name(\"url\") String url, @Name(value = \"path\", defaultValue = \"/\") String path, @Name(value = \"config\",defaultValue = \"{}\") Map<String, Object> config, @Name(value = \"simple\", defaultValue = \"false\") boolean simpleMode) throws Exception {\n        return xmlXpathToMapResult(url, simpleMode, path ,config);\n    }\n\n    @Procedure(deprecatedBy = \"apoc.load.xml\")\n    @Deprecated\n    @Description(\"apoc.load.xmlSimple('http://example.com/test.xml') YIELD value as doc CREATE (p:Person) SET p.name = doc.name load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _children fields. This method does intentionally not work with XML mixed content.\")\n    public Stream<MapResult> xmlSimple(@Name(\"url\") String url) throws Exception {\n        return xmlToMapResult(url, true);\n    }\n\n    private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n        if (config == null) config = Collections.emptyMap();\n        boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n        List<MapResult> result = new ArrayList<>();\n        try {\n            DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n            documentBuilderFactory.setNamespaceAware(true);\n            documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n            DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n\n            FileUtils.checkReadAllowed(url);\n\n            Map<String, Object> headers = (Map) config.getOrDefault( \"headers\", Collections.emptyMap() );\n\n            Document doc = documentBuilder.parse(Util.openInputStream(url, headers, null));\n            XPathFactory xPathFactory = XPathFactory.newInstance();\n\n            XPath xPath = xPathFactory.newXPath();\n\n            path = StringUtils.isEmpty(path) ? \"/\" : path;\n            XPathExpression xPathExpression = xPath.compile(path);\n            NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n\n            for (int i = 0; i < nodeList.getLength(); i++) {\n                final Deque<Map<String, Object>> stack = new LinkedList<>();\n\n                handleNode(stack, nodeList.item(i), simpleMode);\n                for (int index = 0; index < stack.size(); index++) {\n                    result.add(new MapResult(stack.pollFirst()));\n                }\n            }\n        }\n        catch (FileNotFoundException e){\n            if(!failOnError)\n                return Stream.of(new MapResult(Collections.emptyMap()));\n            else\n                throw new FileNotFoundException(e.getMessage());\n        }\n        catch (Exception e){\n            if(!failOnError)\n                return Stream.of(new MapResult(Collections.emptyMap()));\n            else\n                throw new Exception(e);\n        }\n        return result.stream();\n    }\n\n    private Stream<MapResult> xmlToMapResult(@Name(\"url\") String url, boolean simpleMode) {\n        try {\n            XMLStreamReader reader = getXMLStreamReaderFromUrl(url);\n            final Deque<Map<String, Object>> stack = new LinkedList<>();\n            do {\n                handleXmlEvent(stack, reader, simpleMode);\n            } while (proceedReader(reader));\n\n            return Stream.of(new MapResult(stack.getFirst()));\n        } catch (IOException | XMLStreamException e) {\n            throw new RuntimeException(\"Can't read url \" + cleanUrl(url) + \" as XML\", e);\n        }\n    }\n\n    private XMLStreamReader getXMLStreamReaderFromUrl(String url) throws IOException, XMLStreamException {\n        FileUtils.checkReadAllowed(url);\n        URLConnection urlConnection = new URL(url).openConnection();\n        FACTORY.setProperty(XMLInputFactory.IS_COALESCING, true);\n        return FACTORY.createXMLStreamReader(urlConnection.getInputStream());\n    }\n\n\n    private boolean proceedReader(XMLStreamReader reader) throws XMLStreamException {\n        if (reader.hasNext()) {\n            do {\n                reader.next();\n            } while (reader.isWhiteSpace());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    private void handleXmlEvent(Deque<Map<String, Object>> stack, XMLStreamReader reader, boolean simpleMode) throws XMLStreamException {\n\n        Map<String, Object> elementMap;\n        switch (reader.getEventType()) {\n            case START_DOCUMENT:\n            case END_DOCUMENT:\n                // intentionally empty\n                break;\n            case START_ELEMENT:\n                int attributes = reader.getAttributeCount();\n                elementMap = new LinkedHashMap<>(attributes + 3);\n                elementMap.put(\"_type\", reader.getLocalName());\n                for (int a = 0; a < attributes; a++) {\n                    elementMap.put(reader.getAttributeLocalName(a), reader.getAttributeValue(a));\n                }\n                if (!stack.isEmpty()) {\n                    final Map<String, Object> last = stack.getLast();\n                    String key = simpleMode ? \"_\" + reader.getLocalName() : \"_children\";\n                    amendToList(last, key, elementMap);\n                }\n                stack.addLast(elementMap);\n                break;\n\n            case END_ELEMENT:\n                elementMap = stack.size() > 1 ? stack.removeLast() : stack.getLast();\n\n                // maintain compatibility with previous implementation:\n                // if we only have text childs, return them in \"_text\" and not in \"_children\"\n                Object children = elementMap.get(\"_children\");\n                if (children != null) {\n                    if ((children instanceof String) || collectionIsAllStrings(children)) {\n                        elementMap.put(\"_text\", children);\n                        elementMap.remove(\"_children\");\n                    }\n                }\n                break;\n\n            case CHARACTERS:\n                final String text = reader.getText().trim();\n                if (!text.isEmpty()) {\n                    Map<String, Object> map = stack.getLast();\n                    amendToList(map, \"_children\", text);\n                }\n                break;\n            default:\n                throw new RuntimeException(\"dunno know how to handle xml event type \" + reader.getEventType());\n        }\n    }\n\n    private void handleNode(Deque<Map<String, Object>> stack, Node node, boolean simpleMode) {\n\n        // Handle document node\n        if (node.getNodeType() == Node.DOCUMENT_NODE) {\n            NodeList children = node.getChildNodes();\n            for (int i = 0; i < children.getLength(); i++) {\n                if (children.item(i).getLocalName() != null) {\n                    handleNode(stack, children.item(i), simpleMode);\n                    return;\n                }\n            }\n        }\n\n        Map<String, Object> elementMap = new LinkedHashMap<>();\n        handleTypeAndAttributes(node, elementMap);\n\n        // Set children\n        NodeList children = node.getChildNodes();\n        int count = 0;\n        for (int i = 0; i < children.getLength(); i++) {\n            Node child = children.item(i);\n\n            // This is to deal with text between xml tags for example new line characters\n            if (child.getNodeType() != Node.TEXT_NODE && child.getNodeType() != Node.CDATA_SECTION_NODE) {\n                handleNode(stack, child, simpleMode);\n                count++;\n            } else {\n                // Deal with text nodes\n                handleTextNode(child, elementMap);\n            }\n        }\n\n        if (children.getLength() > 1) {\n            if (!stack.isEmpty()) {\n                List<Object> nodeChildren = new ArrayList<>();\n                for (int i = 0; i < count; i++) {\n                    nodeChildren.add(stack.pollLast());\n                }\n                String key = simpleMode ? \"_\" + node.getLocalName() : \"_children\";\n                Collections.reverse(nodeChildren);\n                if (nodeChildren.size() > 0) {\n                    // Before adding the children we need to handle mixed text\n                    Object text = elementMap.get(\"_text\");\n                    if (text instanceof List) {\n                        for (Object element : (List) text) {\n                            nodeChildren.add(element);\n                        }\n                        elementMap.remove(\"_text\");\n                    }\n\n                    elementMap.put(key, nodeChildren);\n                }\n            }\n        }\n\n        if (!elementMap.isEmpty()) {\n            stack.addLast(elementMap);\n        }\n    }\n\n    /**\n     * Collects type and attributes for the node\n     *\n     * @param node\n     * @param elementMap\n     */\n    private void handleTypeAndAttributes(Node node, Map<String, Object> elementMap) {\n        // Set type\n        if (node.getLocalName() != null) {\n            elementMap.put(\"_type\", node.getLocalName());\n        }\n\n        // Set the attributes\n        if (node.getAttributes() != null) {\n            NamedNodeMap attributeMap = node.getAttributes();\n            for (int i = 0; i < attributeMap.getLength(); i++) {\n                Node attribute = attributeMap.item(i);\n                elementMap.put(attribute.getNodeName(), attribute.getNodeValue());\n            }\n        }\n    }\n\n    /**\n     * Handle TEXT nodes and CDATA nodes\n     *\n     * @param node\n     * @param elementMap\n     */\n    private void handleTextNode(Node node, Map<String, Object> elementMap) {\n        Object text = \"\";\n        int nodeType = node.getNodeType();\n        switch (nodeType) {\n            case Node.TEXT_NODE:\n                text = normalizeText(node.getNodeValue());\n                break;\n            case Node.CDATA_SECTION_NODE:\n                text = normalizeText(((CharacterData) node).getData());\n                break;\n            default:\n                break;\n        }\n\n        // If the text is valid ...\n        if (!StringUtils.isEmpty(text.toString())) {\n            // We check if we have already collected some text previously\n            Object previousText = elementMap.get(\"_text\");\n            if (previousText != null) {\n                // If we just have a \"_text\" key than we need to collect to a List\n                text = Arrays.asList(previousText.toString(), text);\n            }\n            elementMap.put(\"_text\", text);\n        }\n    }\n\n    /**\n     * Remove trailing whitespaces and new line characters\n     *\n     * @param text\n     * @return\n     */\n    private String normalizeText(String text) {\n        String[] tokens = StringUtils.split(text, \"\\n\");\n        for (int i = 0; i < tokens.length; i++) {\n            tokens[i] = tokens[i].trim();\n        }\n\n        return StringUtils.join(tokens, \" \").trim();\n    }\n\n    private boolean collectionIsAllStrings(Object collection) {\n        if (collection instanceof Collection) {\n            return ((Collection<Object>) collection).stream().allMatch(o -> o instanceof String);\n        } else {\n            return false;\n        }\n    }\n\n    private void amendToList(Map<String, Object> map, String key, Object value) {\n        final Object element = map.get(key);\n        if (element == null) {\n            map.put(key, value);\n        } else {\n            if (element instanceof List) {\n                ((List) element).add(value);\n            } else {\n                List<Object> list = new LinkedList<>();\n                list.add(element);\n                list.add(value);\n                map.put(key, list);\n            }\n        }\n    }\n\n    public static class ParentAndChildPair {\n        private org.neo4j.graphdb.Node parent;\n        private org.neo4j.graphdb.Node previousChild=null;\n\n        public ParentAndChildPair(org.neo4j.graphdb.Node parent) {\n            this.parent = parent;\n        }\n\n        public org.neo4j.graphdb.Node getParent() {\n            return parent;\n        }\n\n        public void setParent(org.neo4j.graphdb.Node parent) {\n            this.parent = parent;\n        }\n\n        public org.neo4j.graphdb.Node getPreviousChild() {\n            return previousChild;\n        }\n\n        public void setPreviousChild(org.neo4j.graphdb.Node previousChild) {\n            this.previousChild = previousChild;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            ParentAndChildPair that = (ParentAndChildPair) o;\n            return parent.equals(that.parent);\n        }\n\n        @Override\n        public int hashCode() {\n            return parent.hashCode();\n        }\n    }\n\n    private static class XmlImportConfig {\n\n        private boolean createNextWordRelationship = false;\n\n        public boolean isCreateNextWordRelationship() {\n            return createNextWordRelationship;\n        }\n\n        public XmlImportConfig(Map<String,Object> config) {\n            Boolean _createNextWordRelationship = (Boolean) config.get(\"createNextWordRelationships\");\n            if (_createNextWordRelationship!=null) {\n                createNextWordRelationship = _createNextWordRelationship;\n            }\n        }\n\n    }\n\n    @Procedure(mode = Mode.WRITE, value = \"apoc.xml.import\")\n    public Stream<NodeResult> importToGraph(@Name(\"url\") String url, @Name(value=\"config\", defaultValue = \"{}\") Map<String, Object> config) throws IOException, XMLStreamException {\n        final XMLStreamReader xml = getXMLStreamReaderFromUrl(url);\n\n        XmlImportConfig importConfig = new XmlImportConfig(config);\n        //TODO: make labels, reltypes and magic properties configurable\n\n        // stores parents and their most recent child\n        Deque<ParentAndChildPair> parents = new ArrayDeque<>();\n        org.neo4j.graphdb.Node root = db.createNode(Label.label(\"XmlDocument\"));\n        setPropertyIfNotNull(root, \"_xmlVersion\", xml.getVersion());\n        setPropertyIfNotNull(root, \"_xmlEncoding\", xml.getEncoding());\n        root.setProperty(\"url\", url);\n        parents.push(new ParentAndChildPair(root));\n        org.neo4j.graphdb.Node last = root;\n        org.neo4j.graphdb.Node lastWord = root;\n\n        while (xml.hasNext()) {\n            xml.next();\n\n            switch (xml.getEventType()) {\n                case XMLStreamConstants.START_DOCUMENT:\n                    // xmlsteamreader starts off by definition at START_DOCUMENT prior to call next() - so ignore this one\n                    break;\n\n                case XMLStreamConstants.PROCESSING_INSTRUCTION:\n                    org.neo4j.graphdb.Node pi = db.createNode(Label.label(\"XmlProcessingInstruction\"));\n                    pi.setProperty(\"_piData\", xml.getPIData());\n                    pi.setProperty(\"_piTarget\", xml.getPITarget());\n                    last = connectWithParent(pi, parents.peek(), last);\n                    break;\n\n                case XMLStreamConstants.START_ELEMENT:\n                    final QName qName = xml.getName();\n                    final org.neo4j.graphdb.Node tag = db.createNode(Label.label(\"XmlTag\"));\n                    tag.setProperty(\"_name\", qName.getLocalPart());\n                    for (int i=0; i<xml.getAttributeCount(); i++) {\n                        tag.setProperty(xml.getAttributeLocalName(i), xml.getAttributeValue(i));\n                    }\n\n                    last = connectWithParent(tag, parents.peek(), last);\n                    parents.push(new ParentAndChildPair(tag));\n                    break;\n\n                case XMLStreamConstants.CHARACTERS:\n                    String text = xml.getText().trim();\n                    String[] words = text.split(\"\\\\s\");\n                    for (int i = 0; i < words.length; i++) {\n                        final String currentWord = words[i];\n                        if (!currentWord.isEmpty()) {\n                            org.neo4j.graphdb.Node word = db.createNode(Label.label(\"XmlWord\"));\n                            word.setProperty(\"text\", currentWord);\n                            last = connectWithParent(word, parents.peek(), last);\n                            if (importConfig.isCreateNextWordRelationship()) {\n                                lastWord.createRelationshipTo(word, RelationshipType.withName(\"NEXT_WORD\"));\n                                lastWord = word;\n                            }\n                        }\n                    }\n                    break;\n\n                case XMLStreamConstants.END_ELEMENT:\n                    ParentAndChildPair parent = parents.pop();\n                    if (parent.getPreviousChild()!=null) {\n                        parent.getPreviousChild().createRelationshipTo(parent.getParent(), RelationshipType.withName(\"LAST_CHILD_OF\"));\n                    }\n                    break;\n\n                case XMLStreamConstants.END_DOCUMENT:\n                    parents.pop();\n                    break;\n\n                case XMLStreamConstants.COMMENT:\n                case XMLStreamConstants.SPACE:\n                    // intentionally do nothing\n                    break;\n                default:\n                    log.warn(\"xml file contains a {} type structure - ignoring this.\", xml.getEventType());\n            }\n\n        }\n        if (!parents.isEmpty()) {\n            throw new IllegalStateException(\"non empty parents\");\n        }\n        return Stream.of(new NodeResult(root));\n    }\n\n    private void setPropertyIfNotNull(org.neo4j.graphdb.Node root, String propertyKey, Object value) {\n        if (value!=null) {\n            root.setProperty(propertyKey, value);\n        }\n    }\n\n    private org.neo4j.graphdb.Node connectWithParent(org.neo4j.graphdb.Node thisNode, ParentAndChildPair parentAndChildPair, org.neo4j.graphdb.Node last) {\n        final org.neo4j.graphdb.Node parent = parentAndChildPair.getParent();\n        final org.neo4j.graphdb.Node previousChild = parentAndChildPair.getPreviousChild();\n\n        last.createRelationshipTo(thisNode, RelationshipType.withName(\"NEXT\"));\n        thisNode.createRelationshipTo(parent, RelationshipType.withName(\"IS_CHILD_OF\"));\n        if (previousChild ==null) {\n            thisNode.createRelationshipTo(parent, RelationshipType.withName(\"FIRST_CHILD_OF\"));\n        } else {\n            previousChild.createRelationshipTo(thisNode, RelationshipType.withName(\"NEXT_SIBLING\"));\n        }\n        parentAndChildPair.setPreviousChild(thisNode);\n        last = thisNode;\n        return last;\n    }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200172,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "package apoc.load;\n\nimport apoc.util.FileUtils;\nimport apoc.result.MapResult;\nimport apoc.result.NodeResult;\nimport apoc.util.Util;\nimport org.apache.commons.lang3.StringUtils;\nimport org.neo4j.graphdb.GraphDatabaseService;\nimport org.neo4j.graphdb.Label;\nimport org.neo4j.graphdb.RelationshipType;\nimport org.neo4j.logging.Log;\nimport org.neo4j.procedure.*;\nimport org.w3c.dom.CharacterData;\nimport org.w3c.dom.*;\n\nimport javax.xml.namespace.QName;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamReader;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.*;\nimport java.util.stream.Stream;\n\nimport static apoc.util.Util.cleanUrl;\nimport static javax.xml.stream.XMLStreamConstants.*;\n\npublic class Xml {\n\n    public static final XMLInputFactory FACTORY = XMLInputFactory.newFactory();\n\n    @Context\n    public GraphDatabaseService db;\n\n    @Context\n    public Log log;\n\n    @Procedure\n    @Description(\"apoc.load.xml('http://example.com/test.xml', 'xPath',config, false) YIELD value as doc CREATE (p:Person) SET p.name = doc.name load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _childrenx fields.\")\n    public Stream<MapResult> xml(@Name(\"url\") String url, @Name(value = \"path\", defaultValue = \"/\") String path, @Name(value = \"config\",defaultValue = \"{}\") Map<String, Object> config, @Name(value = \"simple\", defaultValue = \"false\") boolean simpleMode) throws Exception {\n        return xmlXpathToMapResult(url, simpleMode, path ,config);\n    }\n\n    @Procedure(deprecatedBy = \"apoc.load.xml\")\n    @Deprecated\n    @Description(\"apoc.load.xmlSimple('http://example.com/test.xml') YIELD value as doc CREATE (p:Person) SET p.name = doc.name load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _children fields. This method does intentionally not work with XML mixed content.\")\n    public Stream<MapResult> xmlSimple(@Name(\"url\") String url) throws Exception {\n        return xmlToMapResult(url, true);\n    }\n\n    private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n        if (config == null) config = Collections.emptyMap();\n        boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n        List<MapResult> result = new ArrayList<>();\n        try {\n            DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n            documentBuilderFactory.setNamespaceAware(true);\n            documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n            documentBuilderFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n\n            FileUtils.checkReadAllowed(url);\n\n            Map<String, Object> headers = (Map) config.getOrDefault( \"headers\", Collections.emptyMap() );\n\n            Document doc = documentBuilder.parse(Util.openInputStream(url, headers, null));\n            XPathFactory xPathFactory = XPathFactory.newInstance();\n\n            XPath xPath = xPathFactory.newXPath();\n\n            path = StringUtils.isEmpty(path) ? \"/\" : path;\n            XPathExpression xPathExpression = xPath.compile(path);\n            NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n\n            for (int i = 0; i < nodeList.getLength(); i++) {\n                final Deque<Map<String, Object>> stack = new LinkedList<>();\n\n                handleNode(stack, nodeList.item(i), simpleMode);\n                for (int index = 0; index < stack.size(); index++) {\n                    result.add(new MapResult(stack.pollFirst()));\n                }\n            }\n        }\n        catch (FileNotFoundException e){\n            if(!failOnError)\n                return Stream.of(new MapResult(Collections.emptyMap()));\n            else\n                throw new FileNotFoundException(e.getMessage());\n        }\n        catch (Exception e){\n            if(!failOnError)\n                return Stream.of(new MapResult(Collections.emptyMap()));\n            else\n                throw new Exception(e);\n        }\n        return result.stream();\n    }\n\n    private Stream<MapResult> xmlToMapResult(@Name(\"url\") String url, boolean simpleMode) {\n        try {\n            XMLStreamReader reader = getXMLStreamReaderFromUrl(url);\n            final Deque<Map<String, Object>> stack = new LinkedList<>();\n            do {\n                handleXmlEvent(stack, reader, simpleMode);\n            } while (proceedReader(reader));\n\n            return Stream.of(new MapResult(stack.getFirst()));\n        } catch (IOException | XMLStreamException e) {\n            throw new RuntimeException(\"Can't read url \" + cleanUrl(url) + \" as XML\", e);\n        }\n    }\n\n    private XMLStreamReader getXMLStreamReaderFromUrl(String url) throws IOException, XMLStreamException {\n        FileUtils.checkReadAllowed(url);\n        URLConnection urlConnection = new URL(url).openConnection();\n        FACTORY.setProperty(XMLInputFactory.IS_COALESCING, true);\n        return FACTORY.createXMLStreamReader(urlConnection.getInputStream());\n    }\n\n\n    private boolean proceedReader(XMLStreamReader reader) throws XMLStreamException {\n        if (reader.hasNext()) {\n            do {\n                reader.next();\n            } while (reader.isWhiteSpace());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    private void handleXmlEvent(Deque<Map<String, Object>> stack, XMLStreamReader reader, boolean simpleMode) throws XMLStreamException {\n\n        Map<String, Object> elementMap;\n        switch (reader.getEventType()) {\n            case START_DOCUMENT:\n            case END_DOCUMENT:\n                // intentionally empty\n                break;\n            case START_ELEMENT:\n                int attributes = reader.getAttributeCount();\n                elementMap = new LinkedHashMap<>(attributes + 3);\n                elementMap.put(\"_type\", reader.getLocalName());\n                for (int a = 0; a < attributes; a++) {\n                    elementMap.put(reader.getAttributeLocalName(a), reader.getAttributeValue(a));\n                }\n                if (!stack.isEmpty()) {\n                    final Map<String, Object> last = stack.getLast();\n                    String key = simpleMode ? \"_\" + reader.getLocalName() : \"_children\";\n                    amendToList(last, key, elementMap);\n                }\n                stack.addLast(elementMap);\n                break;\n\n            case END_ELEMENT:\n                elementMap = stack.size() > 1 ? stack.removeLast() : stack.getLast();\n\n                // maintain compatibility with previous implementation:\n                // if we only have text childs, return them in \"_text\" and not in \"_children\"\n                Object children = elementMap.get(\"_children\");\n                if (children != null) {\n                    if ((children instanceof String) || collectionIsAllStrings(children)) {\n                        elementMap.put(\"_text\", children);\n                        elementMap.remove(\"_children\");\n                    }\n                }\n                break;\n\n            case CHARACTERS:\n                final String text = reader.getText().trim();\n                if (!text.isEmpty()) {\n                    Map<String, Object> map = stack.getLast();\n                    amendToList(map, \"_children\", text);\n                }\n                break;\n            default:\n                throw new RuntimeException(\"dunno know how to handle xml event type \" + reader.getEventType());\n        }\n    }\n\n    private void handleNode(Deque<Map<String, Object>> stack, Node node, boolean simpleMode) {\n\n        // Handle document node\n        if (node.getNodeType() == Node.DOCUMENT_NODE) {\n            NodeList children = node.getChildNodes();\n            for (int i = 0; i < children.getLength(); i++) {\n                if (children.item(i).getLocalName() != null) {\n                    handleNode(stack, children.item(i), simpleMode);\n                    return;\n                }\n            }\n        }\n\n        Map<String, Object> elementMap = new LinkedHashMap<>();\n        handleTypeAndAttributes(node, elementMap);\n\n        // Set children\n        NodeList children = node.getChildNodes();\n        int count = 0;\n        for (int i = 0; i < children.getLength(); i++) {\n            Node child = children.item(i);\n\n            // This is to deal with text between xml tags for example new line characters\n            if (child.getNodeType() != Node.TEXT_NODE && child.getNodeType() != Node.CDATA_SECTION_NODE) {\n                handleNode(stack, child, simpleMode);\n                count++;\n            } else {\n                // Deal with text nodes\n                handleTextNode(child, elementMap);\n            }\n        }\n\n        if (children.getLength() > 1) {\n            if (!stack.isEmpty()) {\n                List<Object> nodeChildren = new ArrayList<>();\n                for (int i = 0; i < count; i++) {\n                    nodeChildren.add(stack.pollLast());\n                }\n                String key = simpleMode ? \"_\" + node.getLocalName() : \"_children\";\n                Collections.reverse(nodeChildren);\n                if (nodeChildren.size() > 0) {\n                    // Before adding the children we need to handle mixed text\n                    Object text = elementMap.get(\"_text\");\n                    if (text instanceof List) {\n                        for (Object element : (List) text) {\n                            nodeChildren.add(element);\n                        }\n                        elementMap.remove(\"_text\");\n                    }\n\n                    elementMap.put(key, nodeChildren);\n                }\n            }\n        }\n\n        if (!elementMap.isEmpty()) {\n            stack.addLast(elementMap);\n        }\n    }\n\n    /**\n     * Collects type and attributes for the node\n     *\n     * @param node\n     * @param elementMap\n     */\n    private void handleTypeAndAttributes(Node node, Map<String, Object> elementMap) {\n        // Set type\n        if (node.getLocalName() != null) {\n            elementMap.put(\"_type\", node.getLocalName());\n        }\n\n        // Set the attributes\n        if (node.getAttributes() != null) {\n            NamedNodeMap attributeMap = node.getAttributes();\n            for (int i = 0; i < attributeMap.getLength(); i++) {\n                Node attribute = attributeMap.item(i);\n                elementMap.put(attribute.getNodeName(), attribute.getNodeValue());\n            }\n        }\n    }\n\n    /**\n     * Handle TEXT nodes and CDATA nodes\n     *\n     * @param node\n     * @param elementMap\n     */\n    private void handleTextNode(Node node, Map<String, Object> elementMap) {\n        Object text = \"\";\n        int nodeType = node.getNodeType();\n        switch (nodeType) {\n            case Node.TEXT_NODE:\n                text = normalizeText(node.getNodeValue());\n                break;\n            case Node.CDATA_SECTION_NODE:\n                text = normalizeText(((CharacterData) node).getData());\n                break;\n            default:\n                break;\n        }\n\n        // If the text is valid ...\n        if (!StringUtils.isEmpty(text.toString())) {\n            // We check if we have already collected some text previously\n            Object previousText = elementMap.get(\"_text\");\n            if (previousText != null) {\n                // If we just have a \"_text\" key than we need to collect to a List\n                text = Arrays.asList(previousText.toString(), text);\n            }\n            elementMap.put(\"_text\", text);\n        }\n    }\n\n    /**\n     * Remove trailing whitespaces and new line characters\n     *\n     * @param text\n     * @return\n     */\n    private String normalizeText(String text) {\n        String[] tokens = StringUtils.split(text, \"\\n\");\n        for (int i = 0; i < tokens.length; i++) {\n            tokens[i] = tokens[i].trim();\n        }\n\n        return StringUtils.join(tokens, \" \").trim();\n    }\n\n    private boolean collectionIsAllStrings(Object collection) {\n        if (collection instanceof Collection) {\n            return ((Collection<Object>) collection).stream().allMatch(o -> o instanceof String);\n        } else {\n            return false;\n        }\n    }\n\n    private void amendToList(Map<String, Object> map, String key, Object value) {\n        final Object element = map.get(key);\n        if (element == null) {\n            map.put(key, value);\n        } else {\n            if (element instanceof List) {\n                ((List) element).add(value);\n            } else {\n                List<Object> list = new LinkedList<>();\n                list.add(element);\n                list.add(value);\n                map.put(key, list);\n            }\n        }\n    }\n\n    public static class ParentAndChildPair {\n        private org.neo4j.graphdb.Node parent;\n        private org.neo4j.graphdb.Node previousChild=null;\n\n        public ParentAndChildPair(org.neo4j.graphdb.Node parent) {\n            this.parent = parent;\n        }\n\n        public org.neo4j.graphdb.Node getParent() {\n            return parent;\n        }\n\n        public void setParent(org.neo4j.graphdb.Node parent) {\n            this.parent = parent;\n        }\n\n        public org.neo4j.graphdb.Node getPreviousChild() {\n            return previousChild;\n        }\n\n        public void setPreviousChild(org.neo4j.graphdb.Node previousChild) {\n            this.previousChild = previousChild;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            ParentAndChildPair that = (ParentAndChildPair) o;\n            return parent.equals(that.parent);\n        }\n\n        @Override\n        public int hashCode() {\n            return parent.hashCode();\n        }\n    }\n\n    private static class XmlImportConfig {\n\n        private boolean createNextWordRelationship = false;\n\n        public boolean isCreateNextWordRelationship() {\n            return createNextWordRelationship;\n        }\n\n        public XmlImportConfig(Map<String,Object> config) {\n            Boolean _createNextWordRelationship = (Boolean) config.get(\"createNextWordRelationships\");\n            if (_createNextWordRelationship!=null) {\n                createNextWordRelationship = _createNextWordRelationship;\n            }\n        }\n\n    }\n\n    @Procedure(mode = Mode.WRITE, value = \"apoc.xml.import\")\n    public Stream<NodeResult> importToGraph(@Name(\"url\") String url, @Name(value=\"config\", defaultValue = \"{}\") Map<String, Object> config) throws IOException, XMLStreamException {\n        final XMLStreamReader xml = getXMLStreamReaderFromUrl(url);\n\n        XmlImportConfig importConfig = new XmlImportConfig(config);\n        //TODO: make labels, reltypes and magic properties configurable\n\n        // stores parents and their most recent child\n        Deque<ParentAndChildPair> parents = new ArrayDeque<>();\n        org.neo4j.graphdb.Node root = db.createNode(Label.label(\"XmlDocument\"));\n        setPropertyIfNotNull(root, \"_xmlVersion\", xml.getVersion());\n        setPropertyIfNotNull(root, \"_xmlEncoding\", xml.getEncoding());\n        root.setProperty(\"url\", url);\n        parents.push(new ParentAndChildPair(root));\n        org.neo4j.graphdb.Node last = root;\n        org.neo4j.graphdb.Node lastWord = root;\n\n        while (xml.hasNext()) {\n            xml.next();\n\n            switch (xml.getEventType()) {\n                case XMLStreamConstants.START_DOCUMENT:\n                    // xmlsteamreader starts off by definition at START_DOCUMENT prior to call next() - so ignore this one\n                    break;\n\n                case XMLStreamConstants.PROCESSING_INSTRUCTION:\n                    org.neo4j.graphdb.Node pi = db.createNode(Label.label(\"XmlProcessingInstruction\"));\n                    pi.setProperty(\"_piData\", xml.getPIData());\n                    pi.setProperty(\"_piTarget\", xml.getPITarget());\n                    last = connectWithParent(pi, parents.peek(), last);\n                    break;\n\n                case XMLStreamConstants.START_ELEMENT:\n                    final QName qName = xml.getName();\n                    final org.neo4j.graphdb.Node tag = db.createNode(Label.label(\"XmlTag\"));\n                    tag.setProperty(\"_name\", qName.getLocalPart());\n                    for (int i=0; i<xml.getAttributeCount(); i++) {\n                        tag.setProperty(xml.getAttributeLocalName(i), xml.getAttributeValue(i));\n                    }\n\n                    last = connectWithParent(tag, parents.peek(), last);\n                    parents.push(new ParentAndChildPair(tag));\n                    break;\n\n                case XMLStreamConstants.CHARACTERS:\n                    String text = xml.getText().trim();\n                    String[] words = text.split(\"\\\\s\");\n                    for (int i = 0; i < words.length; i++) {\n                        final String currentWord = words[i];\n                        if (!currentWord.isEmpty()) {\n                            org.neo4j.graphdb.Node word = db.createNode(Label.label(\"XmlWord\"));\n                            word.setProperty(\"text\", currentWord);\n                            last = connectWithParent(word, parents.peek(), last);\n                            if (importConfig.isCreateNextWordRelationship()) {\n                                lastWord.createRelationshipTo(word, RelationshipType.withName(\"NEXT_WORD\"));\n                                lastWord = word;\n                            }\n                        }\n                    }\n                    break;\n\n                case XMLStreamConstants.END_ELEMENT:\n                    ParentAndChildPair parent = parents.pop();\n                    if (parent.getPreviousChild()!=null) {\n                        parent.getPreviousChild().createRelationshipTo(parent.getParent(), RelationshipType.withName(\"LAST_CHILD_OF\"));\n                    }\n                    break;\n\n                case XMLStreamConstants.END_DOCUMENT:\n                    parents.pop();\n                    break;\n\n                case XMLStreamConstants.COMMENT:\n                case XMLStreamConstants.SPACE:\n                    // intentionally do nothing\n                    break;\n                default:\n                    log.warn(\"xml file contains a {} type structure - ignoring this.\", xml.getEventType());\n            }\n\n        }\n        if (!parents.isEmpty()) {\n            throw new IllegalStateException(\"non empty parents\");\n        }\n        return Stream.of(new NodeResult(root));\n    }\n\n    private void setPropertyIfNotNull(org.neo4j.graphdb.Node root, String propertyKey, Object value) {\n        if (value!=null) {\n            root.setProperty(propertyKey, value);\n        }\n    }\n\n    private org.neo4j.graphdb.Node connectWithParent(org.neo4j.graphdb.Node thisNode, ParentAndChildPair parentAndChildPair, org.neo4j.graphdb.Node last) {\n        final org.neo4j.graphdb.Node parent = parentAndChildPair.getParent();\n        final org.neo4j.graphdb.Node previousChild = parentAndChildPair.getPreviousChild();\n\n        last.createRelationshipTo(thisNode, RelationshipType.withName(\"NEXT\"));\n        thisNode.createRelationshipTo(parent, RelationshipType.withName(\"IS_CHILD_OF\"));\n        if (previousChild ==null) {\n            thisNode.createRelationshipTo(parent, RelationshipType.withName(\"FIRST_CHILD_OF\"));\n        } else {\n            previousChild.createRelationshipTo(thisNode, RelationshipType.withName(\"NEXT_SIBLING\"));\n        }\n        parentAndChildPair.setPreviousChild(thisNode);\n        last = thisNode;\n        return last;\n    }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200173,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "/*\n\nCopyright 2010, Google Inc.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n    * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,           \nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY           \nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\npackage com.google.refine.importers;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PushbackInputStream;\nimport java.io.Serializable;\nimport java.util.List;\n\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamReader;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.fasterxml.jackson.databind.node.ArrayNode;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.google.refine.ProjectMetadata;\nimport com.google.refine.importers.tree.ImportColumnGroup;\nimport com.google.refine.importers.tree.TreeImportingParserBase;\nimport com.google.refine.importers.tree.TreeReader;\nimport com.google.refine.importers.tree.TreeReaderException;\nimport com.google.refine.importing.ImportingJob;\nimport com.google.refine.importing.ImportingUtilities;\nimport com.google.refine.model.Project;\nimport com.google.refine.util.JSONUtilities;\nimport com.google.refine.util.ParsingUtilities;\n\npublic class XmlImporter extends TreeImportingParserBase {\n    static final Logger logger = LoggerFactory.getLogger(XmlImporter.class);\n    \n    public XmlImporter() {\n        super(true);\n    }\n    \n    static private class PreviewParsingState {\n        int tokenCount;\n    }\n    \n    final static private int PREVIEW_PARSING_LIMIT = 1000;\n    \n    @Override\n    public ObjectNode createParserUIInitializationData(\n            ImportingJob job, List<ObjectNode> fileRecords, String format) {\n        ObjectNode options = super.createParserUIInitializationData(job, fileRecords, format);\n        try {\n            if (fileRecords.size() > 0) {\n                ObjectNode firstFileRecord = fileRecords.get(0);\n                File file = ImportingUtilities.getFile(job, firstFileRecord);\n                InputStream is = new FileInputStream(file);\n                \n                try {\n                    XMLStreamReader parser = createXMLStreamReader(is);\n                    PreviewParsingState state = new PreviewParsingState();\n\n                    while (parser.hasNext() && state.tokenCount < PREVIEW_PARSING_LIMIT) {\n                        int tokenType = parser.next();\n                        state.tokenCount++;\n                        if (tokenType == XMLStreamConstants.START_ELEMENT) {\n                            ObjectNode rootElement = descendElement(parser, state);\n                            if (rootElement != null) {\n                                JSONUtilities.safePut(options, \"dom\", rootElement);\n                                break;\n                            }\n                        } else {\n                            // ignore everything else\n                        }\n                    }\n                } catch (XMLStreamException e) {\n                    logger.warn(\"Error generating parser UI initialization data for XML file\", e);\n                } finally {\n                    is.close();\n                }\n            }\n        } catch (IOException e) {\n            logger.error(\"Error generating parser UI initialization data for XML file\", e);\n        }\n\n        return options;\n    }\n    \n    final static private ObjectNode descendElement(XMLStreamReader parser, PreviewParsingState state) {\n        ObjectNode result = ParsingUtilities.mapper.createObjectNode();\n        {\n            String name = parser.getLocalName();\n            JSONUtilities.safePut(result, \"n\", name);\n            \n            String prefix = parser.getPrefix();\n            if (prefix != null) {\n                JSONUtilities.safePut(result, \"p\", prefix);\n            }\n            String nsUri = parser.getNamespaceURI();\n            if (nsUri != null) {\n                JSONUtilities.safePut(result, \"uri\", nsUri);\n            }\n        }\n        \n        int namespaceCount = parser.getNamespaceCount();\n        if (namespaceCount > 0) {\n            ArrayNode namespaces = result.putArray(\"ns\");\n            \n            for (int i = 0; i < namespaceCount; i++) {\n                ObjectNode namespace = ParsingUtilities.mapper.createObjectNode();\n                namespaces.add(namespace);\n                JSONUtilities.safePut(namespace, \"p\", parser.getNamespacePrefix(i));\n                JSONUtilities.safePut(namespace, \"uri\", parser.getNamespaceURI(i));\n            }\n        }\n        \n        int attributeCount = parser.getAttributeCount();\n        if (attributeCount > 0) {\n            ArrayNode attributes = result.putArray(\"a\");\n            \n            for (int i = 0; i < attributeCount; i++) {\n                ObjectNode attribute = ParsingUtilities.mapper.createObjectNode();\n                attributes.add(attribute);\n                JSONUtilities.safePut(attribute, \"n\", parser.getAttributeLocalName(i));\n                JSONUtilities.safePut(attribute, \"v\", parser.getAttributeValue(i));\n                String prefix = parser.getAttributePrefix(i);\n                if (prefix != null) {\n                    JSONUtilities.safePut(attribute, \"p\", prefix);\n                }\n            }\n        }\n        \n        ArrayNode children = ParsingUtilities.mapper.createArrayNode();\n        try {\n            while (parser.hasNext() && state.tokenCount < PREVIEW_PARSING_LIMIT) {\n                int tokenType = parser.next();\n                state.tokenCount++;\n                if (tokenType == XMLStreamConstants.END_ELEMENT) {\n                    break;\n                } else if (tokenType == XMLStreamConstants.START_ELEMENT) {\n                    ObjectNode childElement = descendElement(parser, state);\n                    if (childElement != null) {\n                        children.add(childElement);\n                    }\n                } else if (tokenType == XMLStreamConstants.CHARACTERS ||\n                           tokenType == XMLStreamConstants.CDATA ||\n                           tokenType == XMLStreamConstants.SPACE) {\n                    ObjectNode childElement = ParsingUtilities.mapper.createObjectNode();\n                    JSONUtilities.safePut(childElement, \"t\", parser.getText());\n                    children.add(childElement);\n                } else {\n                    // ignore everything else\n                }\n            }\n        } catch (XMLStreamException e) {\n            logger.error(\"Error generating parser UI initialization data for XML file\", e);\n        }\n        \n        if (children.size() > 0) {\n        \tresult.put(\"c\", children);\n        }\n        return result;\n    }\n    \n    @Override\n    public void parseOneFile(Project project, ProjectMetadata metadata,\n            ImportingJob job, String fileSource, InputStream inputStream,\n            ImportColumnGroup rootColumnGroup, int limit, ObjectNode options,\n            List<Exception> exceptions) {\n        \n        try {\n            parseOneFile(project, metadata, job, fileSource,\n                new XmlParser(inputStream), rootColumnGroup, limit, options, exceptions);\n            \n            super.parseOneFile(project, metadata, job, fileSource, inputStream, rootColumnGroup, limit, options, exceptions);\n        } catch (XMLStreamException e) {\n            exceptions.add(e);\n        } catch (IOException e) {\n            exceptions.add(e);\n        }\n    }\n    \n    static public class XmlParser implements TreeReader {\n        final protected XMLStreamReader parser;\n        \n        public XmlParser(InputStream inputStream) throws XMLStreamException, IOException {\n            parser = createXMLStreamReader(inputStream);\n        }\n        \n        @Override\n        public Token next() throws TreeReaderException {\n            try {\n                if (!parser.hasNext()) {\n                    throw new TreeReaderException(\"End of XML stream\");\n                }\n            } catch (XMLStreamException e) {\n                throw new TreeReaderException(e);\n            }\n            \n            int currentToken = -1;\n            try {\n                currentToken = parser.next();\n            } catch (XMLStreamException e) {\n                throw new TreeReaderException(e);\n            }\n            \n            return mapToToken(currentToken);\n        }\n        \n        protected Token mapToToken(int token) {\n            switch(token){\n                case XMLStreamConstants.START_ELEMENT: return Token.StartEntity;\n                case XMLStreamConstants.END_ELEMENT: return Token.EndEntity;\n                case XMLStreamConstants.CHARACTERS: return Token.Value;\n                case XMLStreamConstants.START_DOCUMENT: return Token.Ignorable;\n                case XMLStreamConstants.END_DOCUMENT: return Token.Ignorable;\n                case XMLStreamConstants.SPACE: return Token.Value;\n                case XMLStreamConstants.PROCESSING_INSTRUCTION: return Token.Ignorable;\n                case XMLStreamConstants.NOTATION_DECLARATION: return Token.Ignorable;\n                case XMLStreamConstants.NAMESPACE: return Token.Ignorable;\n                case XMLStreamConstants.ENTITY_REFERENCE: return Token.Ignorable;\n                case XMLStreamConstants.DTD: return Token.Ignorable;\n                case XMLStreamConstants.COMMENT: return Token.Ignorable;\n                case XMLStreamConstants.CDATA: return Token.Ignorable;\n                case XMLStreamConstants.ATTRIBUTE: return Token.Ignorable;\n                default:\n                    return Token.Ignorable;\n            }\n        }\n        \n        @Override\n        public Token current() throws TreeReaderException {\n            return this.mapToToken(parser.getEventType());\n        }\n        \n        @Override\n        public boolean hasNext() throws TreeReaderException {\n            try {\n                return parser.hasNext();\n            } catch (XMLStreamException e) {\n                throw new TreeReaderException(e);\n            }\n        }\n        \n        @Override\n        public String getFieldName() throws TreeReaderException {\n            try {\n                return parser.getLocalName();\n            } catch (IllegalStateException e) {\n                return null;\n            }\n        }\n        \n        @Override\n        public String getPrefix(){\n            return parser.getPrefix();\n        }\n        \n        @Override\n        public String getFieldValue(){\n            return parser.getText();\n        }\n    \n        @Override\n        public Serializable getValue() {\n            // XML parser only does string types\n            return getFieldValue();\n        }\n\n        @Override\n        public int getAttributeCount(){\n            return parser.getAttributeCount();\n        }\n        \n        @Override\n        public String getAttributeValue(int index){\n            return parser.getAttributeValue(index);\n        }\n        \n        @Override\n        public String getAttributePrefix(int index){\n            return parser.getAttributePrefix(index);\n        }\n        \n        @Override\n        public String getAttributeLocalName(int index){\n            return parser.getAttributeLocalName(index);\n        }\n    }\n    \n    final static private XMLStreamReader createXMLStreamReader(InputStream inputStream) throws XMLStreamException, IOException {\n        XMLInputFactory factory = XMLInputFactory.newInstance();\n        factory.setProperty(XMLInputFactory.IS_COALESCING, true);\n        factory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, true);\n \n        return factory.createXMLStreamReader(wrapPrefixRemovingInputStream(inputStream));\n    }\n    \n    final static private InputStream wrapPrefixRemovingInputStream(InputStream inputStream)\n            throws XMLStreamException, IOException {\n        PushbackInputStream pis = new PushbackInputStream(inputStream);\n        int b;\n        int count = 0;\n        while (count < 100 && (b = pis.read()) >= 0) {\n            if (++count > 100) {\n                throw new XMLStreamException(\n                    \"File starts with too much non-XML content to skip over\");\n            } else if (b == '<') {\n                pis.unread(b);\n                break;\n            }\n        }\n        return pis;\n    }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200176,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "/*\n\nCopyright 2010, Google Inc.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n    * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,           \nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY           \nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\npackage com.google.refine.importers;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PushbackInputStream;\nimport java.io.Serializable;\nimport java.util.List;\n\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamReader;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.fasterxml.jackson.databind.node.ArrayNode;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.google.refine.ProjectMetadata;\nimport com.google.refine.importers.tree.ImportColumnGroup;\nimport com.google.refine.importers.tree.TreeImportingParserBase;\nimport com.google.refine.importers.tree.TreeReader;\nimport com.google.refine.importers.tree.TreeReaderException;\nimport com.google.refine.importing.ImportingJob;\nimport com.google.refine.importing.ImportingUtilities;\nimport com.google.refine.model.Project;\nimport com.google.refine.util.JSONUtilities;\nimport com.google.refine.util.ParsingUtilities;\n\npublic class XmlImporter extends TreeImportingParserBase {\n    static final Logger logger = LoggerFactory.getLogger(XmlImporter.class);\n    \n    public XmlImporter() {\n        super(true);\n    }\n    \n    static private class PreviewParsingState {\n        int tokenCount;\n    }\n    \n    final static private int PREVIEW_PARSING_LIMIT = 1000;\n    \n    @Override\n    public ObjectNode createParserUIInitializationData(\n            ImportingJob job, List<ObjectNode> fileRecords, String format) {\n        ObjectNode options = super.createParserUIInitializationData(job, fileRecords, format);\n        try {\n            if (fileRecords.size() > 0) {\n                ObjectNode firstFileRecord = fileRecords.get(0);\n                File file = ImportingUtilities.getFile(job, firstFileRecord);\n                InputStream is = new FileInputStream(file);\n                \n                try {\n                    XMLStreamReader parser = createXMLStreamReader(is);\n                    PreviewParsingState state = new PreviewParsingState();\n\n                    while (parser.hasNext() && state.tokenCount < PREVIEW_PARSING_LIMIT) {\n                        int tokenType = parser.next();\n                        state.tokenCount++;\n                        if (tokenType == XMLStreamConstants.START_ELEMENT) {\n                            ObjectNode rootElement = descendElement(parser, state);\n                            if (rootElement != null) {\n                                JSONUtilities.safePut(options, \"dom\", rootElement);\n                                break;\n                            }\n                        } else {\n                            // ignore everything else\n                        }\n                    }\n                } catch (XMLStreamException e) {\n                    logger.warn(\"Error generating parser UI initialization data for XML file\", e);\n                } finally {\n                    is.close();\n                }\n            }\n        } catch (IOException e) {\n            logger.error(\"Error generating parser UI initialization data for XML file\", e);\n        }\n\n        return options;\n    }\n    \n    final static private ObjectNode descendElement(XMLStreamReader parser, PreviewParsingState state) {\n        ObjectNode result = ParsingUtilities.mapper.createObjectNode();\n        {\n            String name = parser.getLocalName();\n            JSONUtilities.safePut(result, \"n\", name);\n            \n            String prefix = parser.getPrefix();\n            if (prefix != null) {\n                JSONUtilities.safePut(result, \"p\", prefix);\n            }\n            String nsUri = parser.getNamespaceURI();\n            if (nsUri != null) {\n                JSONUtilities.safePut(result, \"uri\", nsUri);\n            }\n        }\n        \n        int namespaceCount = parser.getNamespaceCount();\n        if (namespaceCount > 0) {\n            ArrayNode namespaces = result.putArray(\"ns\");\n            \n            for (int i = 0; i < namespaceCount; i++) {\n                ObjectNode namespace = ParsingUtilities.mapper.createObjectNode();\n                namespaces.add(namespace);\n                JSONUtilities.safePut(namespace, \"p\", parser.getNamespacePrefix(i));\n                JSONUtilities.safePut(namespace, \"uri\", parser.getNamespaceURI(i));\n            }\n        }\n        \n        int attributeCount = parser.getAttributeCount();\n        if (attributeCount > 0) {\n            ArrayNode attributes = result.putArray(\"a\");\n            \n            for (int i = 0; i < attributeCount; i++) {\n                ObjectNode attribute = ParsingUtilities.mapper.createObjectNode();\n                attributes.add(attribute);\n                JSONUtilities.safePut(attribute, \"n\", parser.getAttributeLocalName(i));\n                JSONUtilities.safePut(attribute, \"v\", parser.getAttributeValue(i));\n                String prefix = parser.getAttributePrefix(i);\n                if (prefix != null) {\n                    JSONUtilities.safePut(attribute, \"p\", prefix);\n                }\n            }\n        }\n        \n        ArrayNode children = ParsingUtilities.mapper.createArrayNode();\n        try {\n            while (parser.hasNext() && state.tokenCount < PREVIEW_PARSING_LIMIT) {\n                int tokenType = parser.next();\n                state.tokenCount++;\n                if (tokenType == XMLStreamConstants.END_ELEMENT) {\n                    break;\n                } else if (tokenType == XMLStreamConstants.START_ELEMENT) {\n                    ObjectNode childElement = descendElement(parser, state);\n                    if (childElement != null) {\n                        children.add(childElement);\n                    }\n                } else if (tokenType == XMLStreamConstants.CHARACTERS ||\n                           tokenType == XMLStreamConstants.CDATA ||\n                           tokenType == XMLStreamConstants.SPACE) {\n                    ObjectNode childElement = ParsingUtilities.mapper.createObjectNode();\n                    JSONUtilities.safePut(childElement, \"t\", parser.getText());\n                    children.add(childElement);\n                } else {\n                    // ignore everything else\n                }\n            }\n        } catch (XMLStreamException e) {\n            logger.error(\"Error generating parser UI initialization data for XML file\", e);\n        }\n        \n        if (children.size() > 0) {\n        \tresult.put(\"c\", children);\n        }\n        return result;\n    }\n    \n    @Override\n    public void parseOneFile(Project project, ProjectMetadata metadata,\n            ImportingJob job, String fileSource, InputStream inputStream,\n            ImportColumnGroup rootColumnGroup, int limit, ObjectNode options,\n            List<Exception> exceptions) {\n        \n        try {\n            parseOneFile(project, metadata, job, fileSource,\n                new XmlParser(inputStream), rootColumnGroup, limit, options, exceptions);\n            \n            super.parseOneFile(project, metadata, job, fileSource, inputStream, rootColumnGroup, limit, options, exceptions);\n        } catch (XMLStreamException e) {\n            exceptions.add(e);\n        } catch (IOException e) {\n            exceptions.add(e);\n        }\n    }\n    \n    static public class XmlParser implements TreeReader {\n        final protected XMLStreamReader parser;\n        \n        public XmlParser(InputStream inputStream) throws XMLStreamException, IOException {\n            parser = createXMLStreamReader(inputStream);\n        }\n        \n        @Override\n        public Token next() throws TreeReaderException {\n            try {\n                if (!parser.hasNext()) {\n                    throw new TreeReaderException(\"End of XML stream\");\n                }\n            } catch (XMLStreamException e) {\n                throw new TreeReaderException(e);\n            }\n            \n            int currentToken = -1;\n            try {\n                currentToken = parser.next();\n            } catch (XMLStreamException e) {\n                throw new TreeReaderException(e);\n            }\n            \n            return mapToToken(currentToken);\n        }\n        \n        protected Token mapToToken(int token) {\n            switch(token){\n                case XMLStreamConstants.START_ELEMENT: return Token.StartEntity;\n                case XMLStreamConstants.END_ELEMENT: return Token.EndEntity;\n                case XMLStreamConstants.CHARACTERS: return Token.Value;\n                case XMLStreamConstants.START_DOCUMENT: return Token.Ignorable;\n                case XMLStreamConstants.END_DOCUMENT: return Token.Ignorable;\n                case XMLStreamConstants.SPACE: return Token.Value;\n                case XMLStreamConstants.PROCESSING_INSTRUCTION: return Token.Ignorable;\n                case XMLStreamConstants.NOTATION_DECLARATION: return Token.Ignorable;\n                case XMLStreamConstants.NAMESPACE: return Token.Ignorable;\n                case XMLStreamConstants.ENTITY_REFERENCE: return Token.Ignorable;\n                case XMLStreamConstants.DTD: return Token.Ignorable;\n                case XMLStreamConstants.COMMENT: return Token.Ignorable;\n                case XMLStreamConstants.CDATA: return Token.Ignorable;\n                case XMLStreamConstants.ATTRIBUTE: return Token.Ignorable;\n                default:\n                    return Token.Ignorable;\n            }\n        }\n        \n        @Override\n        public Token current() throws TreeReaderException {\n            return this.mapToToken(parser.getEventType());\n        }\n        \n        @Override\n        public boolean hasNext() throws TreeReaderException {\n            try {\n                return parser.hasNext();\n            } catch (XMLStreamException e) {\n                throw new TreeReaderException(e);\n            }\n        }\n        \n        @Override\n        public String getFieldName() throws TreeReaderException {\n            try {\n                return parser.getLocalName();\n            } catch (IllegalStateException e) {\n                return null;\n            }\n        }\n        \n        @Override\n        public String getPrefix(){\n            return parser.getPrefix();\n        }\n        \n        @Override\n        public String getFieldValue(){\n            return parser.getText();\n        }\n    \n        @Override\n        public Serializable getValue() {\n            // XML parser only does string types\n            return getFieldValue();\n        }\n\n        @Override\n        public int getAttributeCount(){\n            return parser.getAttributeCount();\n        }\n        \n        @Override\n        public String getAttributeValue(int index){\n            return parser.getAttributeValue(index);\n        }\n        \n        @Override\n        public String getAttributePrefix(int index){\n            return parser.getAttributePrefix(index);\n        }\n        \n        @Override\n        public String getAttributeLocalName(int index){\n            return parser.getAttributeLocalName(index);\n        }\n    }\n    \n    final static private XMLStreamReader createXMLStreamReader(InputStream inputStream) throws XMLStreamException, IOException {\n        XMLInputFactory factory = XMLInputFactory.newInstance();\n        factory.setProperty(XMLInputFactory.IS_COALESCING, true);\n        factory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, true);\n        factory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n        \n        return factory.createXMLStreamReader(wrapPrefixRemovingInputStream(inputStream));\n    }\n    \n    final static private InputStream wrapPrefixRemovingInputStream(InputStream inputStream)\n            throws XMLStreamException, IOException {\n        PushbackInputStream pis = new PushbackInputStream(inputStream);\n        int b;\n        int count = 0;\n        while (count < 100 && (b = pis.read()) >= 0) {\n            if (++count > 100) {\n                throw new XMLStreamException(\n                    \"File starts with too much non-XML content to skip over\");\n            } else if (b == '<') {\n                pis.unread(b);\n                break;\n            }\n        }\n        return pis;\n    }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200177,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "/*\n\nCopyright 2010, Google Inc.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n    * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,           \nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY           \nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\npackage com.google.refine.importers;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\n\nimport javax.servlet.ServletException;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamReader;\n\nimport org.json.JSONArray;\nimport org.json.JSONObject;\n\nimport com.google.refine.ProjectMetadata;\nimport com.google.refine.importers.tree.ImportColumnGroup;\nimport com.google.refine.importers.tree.TreeImportingParserBase;\nimport com.google.refine.importers.tree.TreeReader;\nimport com.google.refine.importing.ImportingJob;\nimport com.google.refine.importing.ImportingUtilities;\nimport com.google.refine.model.Project;\nimport com.google.refine.util.JSONUtilities;\n\npublic class XmlImporter extends TreeImportingParserBase {\n    public XmlImporter() {\n        super(true);\n    }\n    \n    static private class PreviewParsingState {\n        int tokenCount;\n    }\n    \n    final static private int PREVIEW_PARSING_LIMIT = 1000;\n    \n    @Override\n    public JSONObject createParserUIInitializationData(\n            ImportingJob job, List<JSONObject> fileRecords, String format) {\n        JSONObject options = super.createParserUIInitializationData(job, fileRecords, format);\n        try {\n            JSONObject firstFileRecord = fileRecords.get(0);\n            File file = ImportingUtilities.getFile(job, firstFileRecord);\n            InputStream is = new FileInputStream(file);\n            try {\n                XMLStreamReader parser = createXMLStreamReader(is);\n                PreviewParsingState state = new PreviewParsingState();\n                \n                while (parser.hasNext() && state.tokenCount < PREVIEW_PARSING_LIMIT) {\n                    int tokenType = parser.next();\n                    state.tokenCount++;\n                    if (tokenType == XMLStreamConstants.START_ELEMENT) {\n                        JSONObject rootElement = descendElement(parser, state);\n                        if (rootElement != null) {\n                            JSONUtilities.safePut(options, \"dom\", rootElement);\n                            break;\n                        }\n                    } else {\n                        // ignore everything else\n                    }\n                }\n            } finally {\n                is.close();\n            }\n        } catch (XMLStreamException e) {\n            // Ignore\n        } catch (IOException e) {\n            // Ignore\n        }\n\n        return options;\n    }\n    \n    final static private JSONObject descendElement(XMLStreamReader parser, PreviewParsingState state) throws XMLStreamException {\n        JSONObject result = new JSONObject();\n        {\n            String name = parser.getLocalName();\n            JSONUtilities.safePut(result, \"n\", name);\n            \n            String prefix = parser.getPrefix();\n            if (prefix != null) {\n                JSONUtilities.safePut(result, \"p\", prefix);\n            }\n            String nsUri = parser.getNamespaceURI();\n            if (nsUri != null) {\n                JSONUtilities.safePut(result, \"uri\", nsUri);\n            }\n        }\n        \n        int namespaceCount = parser.getNamespaceCount();\n        if (namespaceCount > 0) {\n            JSONArray namespaces = new JSONArray();\n            JSONUtilities.safePut(result, \"ns\", namespaces);\n            \n            for (int i = 0; i < namespaceCount; i++) {\n                JSONObject namespace = new JSONObject();\n                JSONUtilities.append(namespaces, namespace);\n                JSONUtilities.safePut(namespace, \"p\", parser.getNamespacePrefix(i));\n                JSONUtilities.safePut(namespace, \"uri\", parser.getNamespaceURI(i));\n            }\n        }\n        \n        int attributeCount = parser.getAttributeCount();\n        if (attributeCount > 0) {\n            JSONArray attributes = new JSONArray();\n            JSONUtilities.safePut(result, \"a\", attributes);\n            \n            for (int i = 0; i < attributeCount; i++) {\n                JSONObject attribute = new JSONObject();\n                JSONUtilities.append(attributes, attribute);\n                JSONUtilities.safePut(attribute, \"n\", parser.getAttributeLocalName(i));\n                JSONUtilities.safePut(attribute, \"v\", parser.getAttributeValue(i));\n                String prefix = parser.getAttributePrefix(i);\n                if (prefix != null) {\n                    JSONUtilities.safePut(attribute, \"p\", prefix);\n                }\n            }\n        }\n        \n        JSONArray children = new JSONArray();\n        while (parser.hasNext() && state.tokenCount < PREVIEW_PARSING_LIMIT) {\n            int tokenType = parser.next();\n            state.tokenCount++;\n            if (tokenType == XMLStreamConstants.END_ELEMENT) {\n                break;\n            } else if (tokenType == XMLStreamConstants.START_ELEMENT) {\n                JSONObject childElement = descendElement(parser, state);\n                if (childElement != null) {\n                    JSONUtilities.append(children, childElement);\n                }\n            } else if (tokenType == XMLStreamConstants.CHARACTERS ||\n                       tokenType == XMLStreamConstants.CDATA ||\n                       tokenType == XMLStreamConstants.SPACE) {\n                JSONObject childElement = new JSONObject();\n                JSONUtilities.safePut(childElement, \"t\", parser.getText());\n                JSONUtilities.append(children, childElement);\n            } else {\n                // ignore everything else\n            }\n        }\n        \n        if (children.length() > 0) {\n            JSONUtilities.safePut(result, \"c\", children);\n        }\n        return result;\n    }\n    \n    @Override\n    public void parseOneFile(Project project, ProjectMetadata metadata,\n            ImportingJob job, String fileSource, InputStream inputStream,\n            ImportColumnGroup rootColumnGroup, int limit, JSONObject options,\n            List<Exception> exceptions) {\n        \n        try {\n            parseOneFile(project, metadata, job, fileSource,\n                new XmlParser(inputStream), rootColumnGroup, limit, options, exceptions);\n        } catch (XMLStreamException e) {\n            exceptions.add(e);\n        }\n    }\n    \n    static public class XmlParser implements TreeReader {\n        final protected XMLStreamReader parser;\n        \n        public XmlParser(InputStream inputStream) throws XMLStreamException {\n            parser = createXMLStreamReader(inputStream);\n        }\n        \n        @Override\n        public Token next() throws ServletException {\n            try {\n                if (!parser.hasNext()) {\n                    throw new ServletException(\"End of XML stream\");\n                }\n            } catch (XMLStreamException e) {\n                throw new ServletException(e);\n            }\n            \n            int currentToken = -1;\n            try {\n                currentToken = parser.next();\n            } catch (XMLStreamException e) {\n                throw new ServletException(e);\n            }\n            \n            return mapToToken(currentToken);\n        }\n        \n        protected Token mapToToken(int token) throws ServletException {\n            switch(token){\n                case XMLStreamConstants.START_ELEMENT: return Token.StartEntity;\n                case XMLStreamConstants.END_ELEMENT: return Token.EndEntity;\n                case XMLStreamConstants.CHARACTERS: return Token.Value;\n                case XMLStreamConstants.START_DOCUMENT: return Token.Ignorable;\n                case XMLStreamConstants.END_DOCUMENT: return Token.Ignorable;\n                case XMLStreamConstants.SPACE: return Token.Value;\n                case XMLStreamConstants.PROCESSING_INSTRUCTION: return Token.Ignorable;\n                case XMLStreamConstants.NOTATION_DECLARATION: return Token.Ignorable;\n                case XMLStreamConstants.NAMESPACE: return Token.Ignorable;\n                case XMLStreamConstants.ENTITY_REFERENCE: return Token.Ignorable;\n                case XMLStreamConstants.DTD: return Token.Ignorable;\n                case XMLStreamConstants.COMMENT: return Token.Ignorable;\n                case XMLStreamConstants.CDATA: return Token.Ignorable;\n                case XMLStreamConstants.ATTRIBUTE: return Token.Ignorable;\n                default:\n                    return Token.Ignorable;\n            }\n        }\n        \n        @Override\n        public Token current() throws ServletException{\n            return this.mapToToken(parser.getEventType());\n        }\n        \n        @Override\n        public boolean hasNext() throws ServletException{\n            try {\n                return parser.hasNext();\n            } catch (XMLStreamException e) {\n                throw new ServletException(e);\n            }\n        }\n        \n        @Override\n        public String getFieldName() throws ServletException{\n            try{\n                return parser.getLocalName();\n            }catch(IllegalStateException e){\n                return null;\n            }\n        }\n        \n        @Override\n        public String getPrefix(){\n            return parser.getPrefix();\n        }\n        \n        @Override\n        public String getFieldValue(){\n            return parser.getText();\n        }\n        \n        @Override\n        public int getAttributeCount(){\n            return parser.getAttributeCount();\n        }\n        \n        @Override\n        public String getAttributeValue(int index){\n            return parser.getAttributeValue(index);\n        }\n        \n        @Override\n        public String getAttributePrefix(int index){\n            return parser.getAttributePrefix(index);\n        }\n        \n        @Override\n        public String getAttributeLocalName(int index){\n            return parser.getAttributeLocalName(index);\n        }\n    }\n    \n    final static private XMLStreamReader createXMLStreamReader(InputStream inputStream) throws XMLStreamException {\n        XMLInputFactory factory = XMLInputFactory.newInstance();\n        factory.setProperty(XMLInputFactory.IS_COALESCING, true);\n        factory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, true);\n        \n        return factory.createXMLStreamReader(inputStream);\n    }\n    \n}",
    "target": 1,
    "language": "java",
    "dataset": "A-Manually-Curated-Dataset-of-Vulnerability-Introducing-Commits-in-Java",
    "idx": 800048,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "/*\n\nCopyright 2010, Google Inc.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n    * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,           \nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY           \nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\npackage com.google.refine.importers;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PushbackInputStream;\nimport java.io.Serializable;\nimport java.util.List;\n\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamReader;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.fasterxml.jackson.databind.node.ArrayNode;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.google.refine.ProjectMetadata;\nimport com.google.refine.importers.tree.ImportColumnGroup;\nimport com.google.refine.importers.tree.TreeImportingParserBase;\nimport com.google.refine.importers.tree.TreeReader;\nimport com.google.refine.importers.tree.TreeReaderException;\nimport com.google.refine.importing.ImportingJob;\nimport com.google.refine.importing.ImportingUtilities;\nimport com.google.refine.model.Project;\nimport com.google.refine.util.JSONUtilities;\nimport com.google.refine.util.ParsingUtilities;\n\npublic class XmlImporter extends TreeImportingParserBase {\n    static final Logger logger = LoggerFactory.getLogger(XmlImporter.class);\n    \n    public XmlImporter() {\n        super(true);\n    }\n    \n    static private class PreviewParsingState {\n        int tokenCount;\n    }\n    \n    final static private int PREVIEW_PARSING_LIMIT = 1000;\n    \n    @Override\n    public ObjectNode createParserUIInitializationData(\n            ImportingJob job, List<ObjectNode> fileRecords, String format) {\n        ObjectNode options = super.createParserUIInitializationData(job, fileRecords, format);\n        try {\n            if (fileRecords.size() > 0) {\n                ObjectNode firstFileRecord = fileRecords.get(0);\n                File file = ImportingUtilities.getFile(job, firstFileRecord);\n                InputStream is = new FileInputStream(file);\n                \n                try {\n                    XMLStreamReader parser = createXMLStreamReader(is);\n                    PreviewParsingState state = new PreviewParsingState();\n\n                    while (parser.hasNext() && state.tokenCount < PREVIEW_PARSING_LIMIT) {\n                        int tokenType = parser.next();\n                        state.tokenCount++;\n                        if (tokenType == XMLStreamConstants.START_ELEMENT) {\n                            ObjectNode rootElement = descendElement(parser, state);\n                            if (rootElement != null) {\n                                JSONUtilities.safePut(options, \"dom\", rootElement);\n                                break;\n                            }\n                        } else {\n                            // ignore everything else\n                        }\n                    }\n                } catch (XMLStreamException e) {\n                    logger.warn(\"Error generating parser UI initialization data for XML file\", e);\n                } finally {\n                    is.close();\n                }\n            }\n        } catch (IOException e) {\n            logger.error(\"Error generating parser UI initialization data for XML file\", e);\n        }\n\n        return options;\n    }\n    \n    final static private ObjectNode descendElement(XMLStreamReader parser, PreviewParsingState state) {\n        ObjectNode result = ParsingUtilities.mapper.createObjectNode();\n        {\n            String name = parser.getLocalName();\n            JSONUtilities.safePut(result, \"n\", name);\n            \n            String prefix = parser.getPrefix();\n            if (prefix != null) {\n                JSONUtilities.safePut(result, \"p\", prefix);\n            }\n            String nsUri = parser.getNamespaceURI();\n            if (nsUri != null) {\n                JSONUtilities.safePut(result, \"uri\", nsUri);\n            }\n        }\n        \n        int namespaceCount = parser.getNamespaceCount();\n        if (namespaceCount > 0) {\n            ArrayNode namespaces = result.putArray(\"ns\");\n            \n            for (int i = 0; i < namespaceCount; i++) {\n                ObjectNode namespace = ParsingUtilities.mapper.createObjectNode();\n                namespaces.add(namespace);\n                JSONUtilities.safePut(namespace, \"p\", parser.getNamespacePrefix(i));\n                JSONUtilities.safePut(namespace, \"uri\", parser.getNamespaceURI(i));\n            }\n        }\n        \n        int attributeCount = parser.getAttributeCount();\n        if (attributeCount > 0) {\n            ArrayNode attributes = result.putArray(\"a\");\n            \n            for (int i = 0; i < attributeCount; i++) {\n                ObjectNode attribute = ParsingUtilities.mapper.createObjectNode();\n                attributes.add(attribute);\n                JSONUtilities.safePut(attribute, \"n\", parser.getAttributeLocalName(i));\n                JSONUtilities.safePut(attribute, \"v\", parser.getAttributeValue(i));\n                String prefix = parser.getAttributePrefix(i);\n                if (prefix != null) {\n                    JSONUtilities.safePut(attribute, \"p\", prefix);\n                }\n            }\n        }\n        \n        ArrayNode children = ParsingUtilities.mapper.createArrayNode();\n        try {\n            while (parser.hasNext() && state.tokenCount < PREVIEW_PARSING_LIMIT) {\n                int tokenType = parser.next();\n                state.tokenCount++;\n                if (tokenType == XMLStreamConstants.END_ELEMENT) {\n                    break;\n                } else if (tokenType == XMLStreamConstants.START_ELEMENT) {\n                    ObjectNode childElement = descendElement(parser, state);\n                    if (childElement != null) {\n                        children.add(childElement);\n                    }\n                } else if (tokenType == XMLStreamConstants.CHARACTERS ||\n                           tokenType == XMLStreamConstants.CDATA ||\n                           tokenType == XMLStreamConstants.SPACE) {\n                    ObjectNode childElement = ParsingUtilities.mapper.createObjectNode();\n                    JSONUtilities.safePut(childElement, \"t\", parser.getText());\n                    children.add(childElement);\n                } else {\n                    // ignore everything else\n                }\n            }\n        } catch (XMLStreamException e) {\n            logger.error(\"Error generating parser UI initialization data for XML file\", e);\n        }\n        \n        if (children.size() > 0) {\n        \tresult.put(\"c\", children);\n        }\n        return result;\n    }\n    \n    @Override\n    public void parseOneFile(Project project, ProjectMetadata metadata,\n            ImportingJob job, String fileSource, InputStream inputStream,\n            ImportColumnGroup rootColumnGroup, int limit, ObjectNode options,\n            List<Exception> exceptions) {\n        \n        try {\n            parseOneFile(project, metadata, job, fileSource,\n                new XmlParser(inputStream), rootColumnGroup, limit, options, exceptions);\n            \n            super.parseOneFile(project, metadata, job, fileSource, inputStream, rootColumnGroup, limit, options, exceptions);\n        } catch (XMLStreamException e) {\n            exceptions.add(e);\n        } catch (IOException e) {\n            exceptions.add(e);\n        }\n    }\n    \n    static public class XmlParser implements TreeReader {\n        final protected XMLStreamReader parser;\n        \n        public XmlParser(InputStream inputStream) throws XMLStreamException, IOException {\n            parser = createXMLStreamReader(inputStream);\n        }\n        \n        @Override\n        public Token next() throws TreeReaderException {\n            try {\n                if (!parser.hasNext()) {\n                    throw new TreeReaderException(\"End of XML stream\");\n                }\n            } catch (XMLStreamException e) {\n                throw new TreeReaderException(e);\n            }\n            \n            int currentToken = -1;\n            try {\n                currentToken = parser.next();\n            } catch (XMLStreamException e) {\n                throw new TreeReaderException(e);\n            }\n            \n            return mapToToken(currentToken);\n        }\n        \n        protected Token mapToToken(int token) {\n            switch(token){\n                case XMLStreamConstants.START_ELEMENT: return Token.StartEntity;\n                case XMLStreamConstants.END_ELEMENT: return Token.EndEntity;\n                case XMLStreamConstants.CHARACTERS: return Token.Value;\n                case XMLStreamConstants.START_DOCUMENT: return Token.Ignorable;\n                case XMLStreamConstants.END_DOCUMENT: return Token.Ignorable;\n                case XMLStreamConstants.SPACE: return Token.Value;\n                case XMLStreamConstants.PROCESSING_INSTRUCTION: return Token.Ignorable;\n                case XMLStreamConstants.NOTATION_DECLARATION: return Token.Ignorable;\n                case XMLStreamConstants.NAMESPACE: return Token.Ignorable;\n                case XMLStreamConstants.ENTITY_REFERENCE: return Token.Ignorable;\n                case XMLStreamConstants.DTD: return Token.Ignorable;\n                case XMLStreamConstants.COMMENT: return Token.Ignorable;\n                case XMLStreamConstants.CDATA: return Token.Ignorable;\n                case XMLStreamConstants.ATTRIBUTE: return Token.Ignorable;\n                default:\n                    return Token.Ignorable;\n            }\n        }\n        \n        @Override\n        public Token current() throws TreeReaderException {\n            return this.mapToToken(parser.getEventType());\n        }\n        \n        @Override\n        public boolean hasNext() throws TreeReaderException {\n            try {\n                return parser.hasNext();\n            } catch (XMLStreamException e) {\n                throw new TreeReaderException(e);\n            }\n        }\n        \n        @Override\n        public String getFieldName() throws TreeReaderException {\n            try {\n                return parser.getLocalName();\n            } catch (IllegalStateException e) {\n                return null;\n            }\n        }\n        \n        @Override\n        public String getPrefix(){\n            return parser.getPrefix();\n        }\n        \n        @Override\n        public String getFieldValue(){\n            return parser.getText();\n        }\n    \n        @Override\n        public Serializable getValue() {\n            // XML parser only does string types\n            return getFieldValue();\n        }\n\n        @Override\n        public int getAttributeCount(){\n            return parser.getAttributeCount();\n        }\n        \n        @Override\n        public String getAttributeValue(int index){\n            return parser.getAttributeValue(index);\n        }\n        \n        @Override\n        public String getAttributePrefix(int index){\n            return parser.getAttributePrefix(index);\n        }\n        \n        @Override\n        public String getAttributeLocalName(int index){\n            return parser.getAttributeLocalName(index);\n        }\n    }\n    \n    final static private XMLStreamReader createXMLStreamReader(InputStream inputStream) throws XMLStreamException, IOException {\n        XMLInputFactory factory = XMLInputFactory.newInstance();\n        factory.setProperty(XMLInputFactory.IS_COALESCING, true);\n        factory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, true);\n        factory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n        \n        return factory.createXMLStreamReader(wrapPrefixRemovingInputStream(inputStream));\n    }\n    \n    final static private InputStream wrapPrefixRemovingInputStream(InputStream inputStream)\n            throws XMLStreamException, IOException {\n        PushbackInputStream pis = new PushbackInputStream(inputStream);\n        int b;\n        int count = 0;\n        while (count < 100 && (b = pis.read()) >= 0) {\n            if (++count > 100) {\n                throw new XMLStreamException(\n                    \"File starts with too much non-XML content to skip over\");\n            } else if (b == '<') {\n                pis.unread(b);\n                break;\n            }\n        }\n        return pis;\n    }\n}",
    "target": 0,
    "language": "java",
    "dataset": "A-Manually-Curated-Dataset-of-Vulnerability-Introducing-Commits-in-Java",
    "idx": 800049,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * <p>\n * http://www.apache.org/licenses/LICENSE-2.0\n * <p>\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.tika.utils;\n\nimport org.apache.tika.exception.TikaException;\nimport org.xml.sax.EntityResolver;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXNotRecognizedException;\nimport org.xml.sax.SAXNotSupportedException;\nimport org.xml.sax.XMLReader;\n\nimport javax.xml.XMLConstants;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLResolver;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.TransformerFactoryConfigurationError;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.io.StringReader;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Utility functions for reading XML.  If you are doing SAX parsing, make sure\n * to use the {@link org.apache.tika.sax.OfflineContentHandler} to guard against\n * XML External Entity attacks.\n */\npublic class XMLReaderUtils implements Serializable {\n\n    /**\n     * Serial version UID\n     */\n    private static final long serialVersionUID = 6110455808615143122L;\n\n    private static final Logger LOG = Logger.getLogger(XMLReaderUtils.class.getName());\n\n    /**\n     * Parser pool size\n     */\n    private static int POOL_SIZE = 10;\n\n    private static final ReentrantReadWriteLock READ_WRITE_LOCK = new ReentrantReadWriteLock();\n\n    private static ArrayBlockingQueue<SAXParser> SAX_PARSERS = new ArrayBlockingQueue<>(POOL_SIZE);\n\n    static {\n        try {\n            setPoolSize(POOL_SIZE);\n        } catch (TikaException e) {\n            throw new RuntimeException(\"problem initializing SAXParser pool\", e);\n        }\n    }\n\n\n    private static final EntityResolver IGNORING_SAX_ENTITY_RESOLVER = new EntityResolver() {\n        public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {\n            return new InputSource(new StringReader(\"\"));\n        }\n    };\n\n    private static final XMLResolver IGNORING_STAX_ENTITY_RESOLVER =\n            new XMLResolver() {\n                @Override\n                public Object resolveEntity(String publicID, String systemID, String baseURI, String namespace) throws\n                        XMLStreamException {\n                    return \"\";\n                }\n            };\n\n    /**\n     * Returns the XMLReader specified in this parsing context. If a reader\n     * is not explicitly specified, then one is created using the specified\n     * or the default SAX parser.\n     *\n     * @return XMLReader\n     * @throws TikaException\n     * @see #getSAXParser()\n     * @since Apache Tika 1.13\n     */\n    public static XMLReader getXMLReader() throws TikaException {\n        XMLReader reader;\n        try {\n            reader = getSAXParser().getXMLReader();\n        } catch (SAXException e) {\n            throw new TikaException(\"Unable to create an XMLReader\", e);\n        }\n        reader.setEntityResolver(IGNORING_SAX_ENTITY_RESOLVER);\n        return reader;\n    }\n\n    /**\n     * Returns the SAX parser specified in this parsing context. If a parser\n     * is not explicitly specified, then one is created using the specified\n     * or the default SAX parser factory.\n     * <p>\n     * Make sure to wrap your handler in the {@link org.apache.tika.sax.OfflineContentHandler} to\n     * prevent XML External Entity attacks\n     * </p>\n     *\n     * @return SAX parser\n     * @throws TikaException if a SAX parser could not be created\n     * @see #getSAXParserFactory()\n     * @since Apache Tika 0.8\n     */\n    public static SAXParser getSAXParser() throws TikaException {\n        try {\n            return getSAXParserFactory().newSAXParser();\n        } catch (ParserConfigurationException e) {\n            throw new TikaException(\"Unable to configure a SAX parser\", e);\n        } catch (SAXException e) {\n            throw new TikaException(\"Unable to create a SAX parser\", e);\n        }\n    }\n\n    /**\n     * Returns the SAX parser factory specified in this parsing context.\n     * If a factory is not explicitly specified, then a default factory\n     * instance is created and returned. The default factory instance is\n     * configured to be namespace-aware, not validating, and to use\n     * {@link XMLConstants#FEATURE_SECURE_PROCESSING secure XML processing}.\n     * <p>\n     * Make sure to wrap your handler in the {@link org.apache.tika.sax.OfflineContentHandler} to\n     * prevent XML External Entity attacks\n     * </p>\n     *\n     * @return SAX parser factory\n     * @since Apache Tika 0.8\n     */\n    public static SAXParserFactory getSAXParserFactory() {\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        factory.setNamespaceAware(true);\n        factory.setValidating(false);\n        try {\n            factory.setFeature(\n                    XMLConstants.FEATURE_SECURE_PROCESSING, true);\n        } catch (ParserConfigurationException e) {\n        } catch (SAXNotSupportedException e) {\n        } catch (SAXNotRecognizedException e) {\n            // TIKA-271: Some XML parsers do not support the\n            // secure-processing feature, even though it's required by\n            // JAXP in Java 5. Ignoring the exception is fine here, as\n            // deployments without this feature are inherently vulnerable\n            // to XML denial-of-service attacks.\n        }\n\n        return factory;\n    }\n\n    /**\n     * Returns the DOM builder factory specified in this parsing context.\n     * If a factory is not explicitly specified, then a default factory\n     * instance is created and returned. The default factory instance is\n     * configured to be namespace-aware and to apply reasonable security\n     * features.\n     *\n     * @return DOM parser factory\n     * @since Apache Tika 1.13\n     */\n    public static DocumentBuilderFactory getDocumentBuilderFactory() {\n        //borrowed from Apache POI\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        factory.setExpandEntityReferences(false);\n        factory.setNamespaceAware(true);\n        factory.setValidating(false);\n\n        trySetSAXFeature(factory, XMLConstants.FEATURE_SECURE_PROCESSING, true);\n        trySetSAXFeature(factory, \"http://xml.org/sax/features/external-general-entities\", false);\n        trySetSAXFeature(factory, \"http://xml.org/sax/features/external-parameter-entities\", false);\n        trySetSAXFeature(factory, \"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n        trySetSAXFeature(factory, \"http://apache.org/xml/features/nonvalidating/load-dtd-grammar\", false);\n        return factory;\n    }\n\n    /**\n     * Returns the DOM builder specified in this parsing context.\n     * If a builder is not explicitly specified, then a builder\n     * instance is created and returned. The builder instance is\n     * configured to apply an {@link #IGNORING_SAX_ENTITY_RESOLVER},\n     * and it sets the ErrorHandler to <code>null</code>.\n     *\n     * @return DOM Builder\n     * @since Apache Tika 1.13\n     */\n    public static DocumentBuilder getDocumentBuilder() throws TikaException {\n        try {\n            DocumentBuilderFactory documentBuilderFactory = getDocumentBuilderFactory();\n            DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n            documentBuilder.setEntityResolver(IGNORING_SAX_ENTITY_RESOLVER);\n            documentBuilder.setErrorHandler(null);\n            return documentBuilder;\n        } catch (ParserConfigurationException e) {\n            throw new TikaException(\"XML parser not available\", e);\n        }\n    }\n\n    /**\n     * Returns the StAX input factory specified in this parsing context.\n     * If a factory is not explicitly specified, then a default factory\n     * instance is created and returned. The default factory instance is\n     * configured to be namespace-aware and to apply reasonable security\n     * using the {@link #IGNORING_STAX_ENTITY_RESOLVER}.\n     *\n     * @return StAX input factory\n     * @since Apache Tika 1.13\n     */\n    public static XMLInputFactory getXMLInputFactory() {\n        XMLInputFactory factory = XMLInputFactory.newFactory();\n\n        tryToSetStaxProperty(factory, XMLInputFactory.IS_NAMESPACE_AWARE, true);\n        tryToSetStaxProperty(factory, XMLInputFactory.IS_VALIDATING, false);\n\n        factory.setXMLResolver(IGNORING_STAX_ENTITY_RESOLVER);\n        return factory;\n    }\n\n    private static void trySetSAXFeature(DocumentBuilderFactory documentBuilderFactory, String feature, boolean enabled) {\n        try {\n            documentBuilderFactory.setFeature(feature, enabled);\n        } catch (Exception e) {\n            LOG.log(Level.WARNING, \"SAX Feature unsupported: \" + feature, e);\n        } catch (AbstractMethodError ame) {\n            LOG.log(Level.WARNING, \"Cannot set SAX feature because outdated XML parser in classpath: \" + feature, ame);\n        }\n    }\n\n    private static void tryToSetStaxProperty(XMLInputFactory factory, String key, boolean value) {\n        try {\n            factory.setProperty(key, value);\n        } catch (IllegalArgumentException e) {\n            //swallow\n        }\n    }\n\n    /**\n     * Returns a new transformer\n     * <p>\n     * The transformer instance is configured to to use\n     * {@link XMLConstants#FEATURE_SECURE_PROCESSING secure XML processing}.\n     *\n     * @return Transformer\n     * @throws TikaException when the transformer can not be created\n     * @since Apache Tika 1.17\n     */\n    public static Transformer getTransformer() throws TikaException {\n        try {\n            TransformerFactory transformerFactory = TransformerFactory.newInstance();\n            transformerFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            return transformerFactory.newTransformer();\n        } catch (TransformerConfigurationException | TransformerFactoryConfigurationError e) {\n            throw new TikaException(\"Transformer not available\", e);\n        }\n    }\n\n    /**\n     * Acquire a SAXParser from the pool; create one if it\n     * doesn't exist.  Make sure to {@link #releaseParser(SAXParser)} in\n     * a <code>finally</code> block every time you call this.\n     *\n     * @return a SAXParser\n     * @throws TikaException\n     */\n    public static SAXParser acquireSAXParser()\n            throws TikaException {\n        while (true) {\n            SAXParser parser = null;\n            try {\n                READ_WRITE_LOCK.readLock().lock();\n                parser = SAX_PARSERS.poll(10, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n                throw new TikaException(\"interrupted while waiting for SAXParser\", e);\n            } finally {\n                READ_WRITE_LOCK.readLock().unlock();\n\n            }\n            if (parser != null) {\n                return parser;\n            }\n        }\n    }\n\n    /**\n     * Return parser to the pool for reuse\n     *\n     * @param parser parser to return\n     */\n    public static void releaseParser(SAXParser parser) {\n        try {\n            parser.reset();\n        } catch (UnsupportedOperationException e) {\n            //ignore\n        }\n        try {\n            READ_WRITE_LOCK.readLock().lock();\n            //if there are extra parsers (e.g. after a reset of the pool to a smaller size),\n            // this parser will not be added and will then be gc'd\n            boolean success = SAX_PARSERS.offer(parser);\n        } finally {\n            READ_WRITE_LOCK.readLock().unlock();\n        }\n    }\n\n    /**\n     * Set the pool size for cached XML parsers.\n     *\n     * @param poolSize\n     */\n    public static void setPoolSize(int poolSize) throws TikaException {\n        try {\n            //stop the world with a write lock.\n            //parsers that are currently in use will be offered, but not\n            //accepted and will be gc'd\n            READ_WRITE_LOCK.writeLock().lock();\n            if (SAX_PARSERS.size() == poolSize) {\n                return;\n            }\n            SAX_PARSERS = new ArrayBlockingQueue<>(poolSize);\n            for (int i = 0; i < poolSize; i++) {\n                SAX_PARSERS.offer(getSAXParser());\n            }\n            POOL_SIZE = poolSize;\n        } finally {\n            READ_WRITE_LOCK.writeLock().unlock();\n        }\n    }\n}",
    "target": 1,
    "language": "java",
    "dataset": "A-Manually-Curated-Dataset-of-Vulnerability-Introducing-Commits-in-Java",
    "idx": 800050,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * <p>\n * http://www.apache.org/licenses/LICENSE-2.0\n * <p>\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.tika.utils;\n\nimport org.apache.tika.exception.TikaException;\nimport org.apache.tika.parser.ParseContext;\nimport org.w3c.dom.Document;\nimport org.xml.sax.EntityResolver;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXNotRecognizedException;\nimport org.xml.sax.SAXNotSupportedException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\n\nimport javax.xml.XMLConstants;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLResolver;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.TransformerFactoryConfigurationError;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Serializable;\nimport java.io.StringReader;\nimport java.lang.reflect.Method;\nimport java.util.Properties;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Utility functions for reading XML.  If you are doing SAX parsing, make sure\n * to use the {@link org.apache.tika.sax.OfflineContentHandler} to guard against\n * XML External Entity attacks.\n */\npublic class XMLReaderUtils implements Serializable {\n\n    /**\n     * Serial version UID\n     */\n    private static final long serialVersionUID = 6110455808615143122L;\n\n    private static final Logger LOG = Logger.getLogger(XMLReaderUtils.class.getName());\n\n    /**\n     * Parser pool size\n     */\n    private static int POOL_SIZE = 10;\n\n    private static long LAST_LOG = -1;\n\n    private static final String JAXP_ENTITY_EXPANSION_LIMIT_KEY = \"jdk.xml.entityExpansionLimit\";\n    private static final int DEFAULT_MAX_ENTITY_EXPANSIONS = 20;\n\n    private static int MAX_ENTITY_EXPANSIONS = determineMaxEntityExpansions();\n\n    private static int determineMaxEntityExpansions() {\n        Properties properties = System.getProperties();\n        if (properties != null && properties.containsKey(JAXP_ENTITY_EXPANSION_LIMIT_KEY)) {\n            try {\n                return Integer.parseInt(properties.getProperty(JAXP_ENTITY_EXPANSION_LIMIT_KEY));\n            } catch (NumberFormatException e) {\n                LOG.log(Level.WARNING, \"Couldn't parse an integer for the entity expansion limit:\"+\n                        properties.getProperty(JAXP_ENTITY_EXPANSION_LIMIT_KEY)+\n                        \"; backing off to default: \"+DEFAULT_MAX_ENTITY_EXPANSIONS);\n            }\n        }\n        return DEFAULT_MAX_ENTITY_EXPANSIONS;\n    }\n\n    //TODO: figure out if the rw lock is any better than a simple lock\n    private static final ReentrantReadWriteLock SAX_READ_WRITE_LOCK = new ReentrantReadWriteLock();\n    private static final ReentrantReadWriteLock DOM_READ_WRITE_LOCK = new ReentrantReadWriteLock();\n\n    private static ArrayBlockingQueue<SAXParser> SAX_PARSERS = new ArrayBlockingQueue<>(POOL_SIZE);\n    private static ArrayBlockingQueue<DocumentBuilder> DOM_BUILDERS = new ArrayBlockingQueue<>(POOL_SIZE);\n\n    static {\n        try {\n            setPoolSize(POOL_SIZE);\n        } catch (TikaException e) {\n            throw new RuntimeException(\"problem initializing SAXParser and DOMBuilder pools\", e);\n        }\n    }\n\n\n    private static final EntityResolver IGNORING_SAX_ENTITY_RESOLVER = new EntityResolver() {\n        public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {\n            return new InputSource(new StringReader(\"\"));\n        }\n    };\n\n    private static final XMLResolver IGNORING_STAX_ENTITY_RESOLVER =\n            new XMLResolver() {\n                @Override\n                public Object resolveEntity(String publicID, String systemID, String baseURI, String namespace) throws\n                        XMLStreamException {\n                    return \"\";\n                }\n            };\n\n    /**\n     * Set the maximum number of entity expansions allowable in SAX/DOM/StAX parsing.\n     * <b>NOTE:</b>A value less than or equal to zero indicates no limit.\n     * This will override the system property {@link #JAXP_ENTITY_EXPANSION_LIMIT_KEY}\n     * and the {@link #DEFAULT_MAX_ENTITY_EXPANSIONS} value for pa\n     *\n     * @param maxEntityExpansions -- maximum number of allowable entity expansions\n     * @since Apache Tika 1.19\n     */\n    public static void setMaxEntityExpansions(int maxEntityExpansions) {\n        MAX_ENTITY_EXPANSIONS = maxEntityExpansions;\n    }\n\n    /**\n     * Returns the XMLReader specified in this parsing context. If a reader\n     * is not explicitly specified, then one is created using the specified\n     * or the default SAX parser.\n     *\n     * @return XMLReader\n     * @throws TikaException\n     * @see #getSAXParser()\n     * @since Apache Tika 1.13\n     */\n    public static XMLReader getXMLReader() throws TikaException {\n        XMLReader reader;\n        try {\n            reader = getSAXParser().getXMLReader();\n        } catch (SAXException e) {\n            throw new TikaException(\"Unable to create an XMLReader\", e);\n        }\n        reader.setEntityResolver(IGNORING_SAX_ENTITY_RESOLVER);\n        return reader;\n    }\n\n    /**\n     * Returns the SAX parser specified in this parsing context. If a parser\n     * is not explicitly specified, then one is created using the specified\n     * or the default SAX parser factory.\n     * <p>\n     * Make sure to wrap your handler in the {@link org.apache.tika.sax.OfflineContentHandler} to\n     * prevent XML External Entity attacks\n     * </p>\n     *\n     * @return SAX parser\n     * @throws TikaException if a SAX parser could not be created\n     * @see #getSAXParserFactory()\n     * @since Apache Tika 0.8\n     */\n    public static SAXParser getSAXParser() throws TikaException {\n        try {\n            SAXParser parser = getSAXParserFactory().newSAXParser();\n            trySetXercesSecurityManager(parser);\n            return parser;\n        } catch (ParserConfigurationException e) {\n            throw new TikaException(\"Unable to configure a SAX parser\", e);\n        } catch (SAXException e) {\n            throw new TikaException(\"Unable to create a SAX parser\", e);\n        }\n    }\n\n    /**\n     * Returns the SAX parser factory specified in this parsing context.\n     * If a factory is not explicitly specified, then a default factory\n     * instance is created and returned. The default factory instance is\n     * configured to be namespace-aware, not validating, and to use\n     * {@link XMLConstants#FEATURE_SECURE_PROCESSING secure XML processing}.\n     * <p>\n     * Make sure to wrap your handler in the {@link org.apache.tika.sax.OfflineContentHandler} to\n     * prevent XML External Entity attacks\n     * </p>\n     *\n     * @return SAX parser factory\n     * @since Apache Tika 0.8\n     */\n    public static SAXParserFactory getSAXParserFactory() {\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        factory.setNamespaceAware(true);\n        factory.setValidating(false);\n        try {\n            factory.setFeature(\n                    XMLConstants.FEATURE_SECURE_PROCESSING, true);\n        } catch (ParserConfigurationException e) {\n        } catch (SAXNotSupportedException e) {\n        } catch (SAXNotRecognizedException e) {\n            // TIKA-271: Some XML parsers do not support the\n            // secure-processing feature, even though it's required by\n            // JAXP in Java 5. Ignoring the exception is fine here, as\n            // deployments without this feature are inherently vulnerable\n            // to XML denial-of-service attacks.\n        }\n\n        return factory;\n    }\n\n    /**\n     * Returns the DOM builder factory specified in this parsing context.\n     * If a factory is not explicitly specified, then a default factory\n     * instance is created and returned. The default factory instance is\n     * configured to be namespace-aware and to apply reasonable security\n     * features.\n     *\n     * @return DOM parser factory\n     * @since Apache Tika 1.13\n     */\n    public static DocumentBuilderFactory getDocumentBuilderFactory() {\n        //borrowed from Apache POI\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        factory.setExpandEntityReferences(false);\n        factory.setNamespaceAware(true);\n        factory.setValidating(false);\n\n        trySetSAXFeature(factory, XMLConstants.FEATURE_SECURE_PROCESSING, true);\n        trySetSAXFeature(factory, \"http://xml.org/sax/features/external-general-entities\", false);\n        trySetSAXFeature(factory, \"http://xml.org/sax/features/external-parameter-entities\", false);\n        trySetSAXFeature(factory, \"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n        trySetSAXFeature(factory, \"http://apache.org/xml/features/nonvalidating/load-dtd-grammar\", false);\n        trySetXercesSecurityManager(factory);\n        return factory;\n    }\n\n    /**\n     * Returns the DOM builder specified in this parsing context.\n     * If a builder is not explicitly specified, then a builder\n     * instance is created and returned. The builder instance is\n     * configured to apply an {@link #IGNORING_SAX_ENTITY_RESOLVER},\n     * and it sets the ErrorHandler to <code>null</code>.\n     *\n     * @return DOM Builder\n     * @since Apache Tika 1.13\n     */\n    public static DocumentBuilder getDocumentBuilder() throws TikaException {\n        try {\n            DocumentBuilderFactory documentBuilderFactory = getDocumentBuilderFactory();\n            DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n            documentBuilder.setEntityResolver(IGNORING_SAX_ENTITY_RESOLVER);\n            documentBuilder.setErrorHandler(null);\n            return documentBuilder;\n        } catch (ParserConfigurationException e) {\n            throw new TikaException(\"XML parser not available\", e);\n        }\n    }\n\n    /**\n     * Returns the StAX input factory specified in this parsing context.\n     * If a factory is not explicitly specified, then a default factory\n     * instance is created and returned. The default factory instance is\n     * configured to be namespace-aware and to apply reasonable security\n     * using the {@link #IGNORING_STAX_ENTITY_RESOLVER}.\n     *\n     * @return StAX input factory\n     * @since Apache Tika 1.13\n     */\n    public static XMLInputFactory getXMLInputFactory() {\n        XMLInputFactory factory = XMLInputFactory.newFactory();\n\n        tryToSetStaxProperty(factory, XMLInputFactory.IS_NAMESPACE_AWARE, true);\n        tryToSetStaxProperty(factory, XMLInputFactory.IS_VALIDATING, false);\n\n        factory.setXMLResolver(IGNORING_STAX_ENTITY_RESOLVER);\n        trySetStaxSecurityManager(factory);\n        return factory;\n    }\n\n    private static void trySetSAXFeature(DocumentBuilderFactory documentBuilderFactory, String feature, boolean enabled) {\n        try {\n            documentBuilderFactory.setFeature(feature, enabled);\n        } catch (Exception e) {\n            LOG.log(Level.WARNING, \"SAX Feature unsupported: \" + feature, e);\n        } catch (AbstractMethodError ame) {\n            LOG.log(Level.WARNING, \"Cannot set SAX feature because outdated XML parser in classpath: \" + feature, ame);\n        }\n    }\n\n    private static void tryToSetStaxProperty(XMLInputFactory factory, String key, boolean value) {\n        try {\n            factory.setProperty(key, value);\n        } catch (IllegalArgumentException e) {\n            LOG.log(Level.WARNING, \"StAX Feature unsupported: \" + key, e);\n        }\n    }\n\n    /**\n     * Returns a new transformer\n     * <p>\n     * The transformer instance is configured to to use\n     * {@link XMLConstants#FEATURE_SECURE_PROCESSING secure XML processing}.\n     *\n     * @return Transformer\n     * @throws TikaException when the transformer can not be created\n     * @since Apache Tika 1.17\n     */\n    public static Transformer getTransformer() throws TikaException {\n        try {\n            TransformerFactory transformerFactory = TransformerFactory.newInstance();\n            transformerFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            return transformerFactory.newTransformer();\n        } catch (TransformerConfigurationException | TransformerFactoryConfigurationError e) {\n            throw new TikaException(\"Transformer not available\", e);\n        }\n    }\n\n    /**\n     * This checks context for a user specified {@link DocumentBuilder}.\n     * If one is not found, this reuses a DocumentBuilder from the pool.\n     *\n     * @since Apache Tika 1.19\n     * @param is InputStream to parse\n     * @param context context to use\n     * @return a document\n     * @throws TikaException\n     * @throws IOException\n     * @throws SAXException\n     */\n    public static Document buildDOM(InputStream is, ParseContext context) throws TikaException, IOException, SAXException {\n        DocumentBuilder builderFromContext = context.get(DocumentBuilder.class);\n        DocumentBuilder builder = (builderFromContext == null) ? acquireDOMBuilder() : builderFromContext;\n\n        try {\n            return builder.parse(is);\n        } finally {\n            if (builderFromContext == null) {\n                releaseDOMBuilder(builder);\n            }\n        }\n    }\n\n    /**\n     * This checks context for a user specified {@link SAXParser}.\n     * If one is not found, this reuses a SAXParser from the pool.\n     *\n     * @since Apache Tika 1.19\n     * @param is InputStream to parse\n     * @param contentHandler handler to use\n     * @param context context to use\n     * @return\n     * @throws TikaException\n     * @throws IOException\n     * @throws SAXException\n     */\n    public static void parseSAX(InputStream is, DefaultHandler contentHandler, ParseContext context)\n            throws TikaException, IOException, SAXException {\n        SAXParser contextParser = context.get(SAXParser.class);\n        SAXParser parser = (contextParser == null) ? acquireSAXParser() : contextParser;\n        try {\n            parser.parse(is, contentHandler);\n        } finally {\n            if (contextParser == null) {\n                releaseParser(parser);\n            }\n        }\n    }\n\n    /**\n     * Acquire a SAXParser from the pool.  Make sure to\n     * {@link #releaseParser(SAXParser)} in\n     * a <code>finally</code> block every time you call this.\n     *\n     * @return a SAXParser\n     * @throws TikaException\n     */\n    private static DocumentBuilder acquireDOMBuilder()\n            throws TikaException {\n        int waiting = 0;\n        while (true) {\n            DocumentBuilder builder = null;\n            try {\n                DOM_READ_WRITE_LOCK.readLock().lock();\n                builder = DOM_BUILDERS.poll(100, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n                throw new TikaException(\"interrupted while waiting for DOMBuilder\", e);\n            } finally {\n                DOM_READ_WRITE_LOCK.readLock().unlock();\n            }\n            if (builder != null) {\n                return builder;\n            }\n            waiting++;\n            if (waiting > 3000) {\n                //freshen the pool.  Something went very wrong...\n                setPoolSize(POOL_SIZE);\n                //better to get an exception than have permahang by a bug in one of our parsers\n                throw new TikaException(\"Waited more than 5 minutes for a DocumentBuilder; \" +\n                        \"This could indicate that a parser has not correctly released its DocumentBuilder. \" +\n                        \"Please report this to the Tika team: dev@tika.apache.org\");\n\n            }\n        }\n    }\n\n    /**\n     * Return parser to the pool for reuse.\n     *\n     * @param builder builder to return\n     */\n    private static void releaseDOMBuilder(DocumentBuilder builder) {\n        try {\n            builder.reset();\n        } catch (UnsupportedOperationException e) {\n            //ignore\n        }\n        try {\n            DOM_READ_WRITE_LOCK.readLock().lock();\n            //if there are extra parsers (e.g. after a reset of the pool to a smaller size),\n            // this parser will not be added and will then be gc'd\n            boolean success = DOM_BUILDERS.offer(builder);\n            if (! success) {\n                LOG.warning(\"DocumentBuilder not taken back into pool.  If you haven't resized the pool, this could \" +\n                        \"be a sign that there are more calls to 'acquire' than to 'release'\");\n            }\n        } finally {\n            DOM_READ_WRITE_LOCK.readLock().unlock();\n        }\n    }\n\n\n    /**\n     * Acquire a SAXParser from the pool.  Make sure to\n     * {@link #releaseParser(SAXParser)} in\n     * a <code>finally</code> block every time you call this.\n     *\n     * @return a SAXParser\n     * @throws TikaException\n     */\n    private static SAXParser acquireSAXParser()\n            throws TikaException {\n        int waiting = 0;\n        while (true) {\n            SAXParser parser = null;\n            try {\n                SAX_READ_WRITE_LOCK.readLock().lock();\n                parser = SAX_PARSERS.poll(100, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n                throw new TikaException(\"interrupted while waiting for SAXParser\", e);\n            } finally {\n                SAX_READ_WRITE_LOCK.readLock().unlock();\n            }\n            if (parser != null) {\n                return parser;\n            }\n            waiting++;\n            if (waiting > 3000) {\n                //freshen the pool.  Something went very wrong...\n                setPoolSize(POOL_SIZE);\n                //better to get an exception than have permahang by a bug in one of our parsers\n                throw new TikaException(\"Waited more than 5 minutes for a SAXParser; \" +\n                        \"This could indicate that a parser has not correctly released its SAXParser. \" +\n                        \"Please report this to the Tika team: dev@tika.apache.org\");\n\n            }\n        }\n    }\n\n    /**\n     * Return parser to the pool for reuse\n     *\n     * @param parser parser to return\n     */\n    private static void releaseParser(SAXParser parser) {\n        try {\n            parser.reset();\n        } catch (UnsupportedOperationException e) {\n            //ignore\n        }\n        try {\n            SAX_READ_WRITE_LOCK.readLock().lock();\n            //if there are extra parsers (e.g. after a reset of the pool to a smaller size),\n            // this parser will not be added and will then be gc'd\n            boolean success = SAX_PARSERS.offer(parser);\n            if (! success) {\n                LOG.warning(\"SAXParser not taken back into pool.  If you haven't resized the pool, this could \" +\n                        \"be a sign that there are more calls to 'acquire' than to 'release'\");\n            }\n        } finally {\n            SAX_READ_WRITE_LOCK.readLock().unlock();\n        }\n    }\n\n    /**\n     * Set the pool size for cached XML parsers.\n     *\n     * @since Apache Tika 1.19\n     * @param poolSize\n     */\n    public static void setPoolSize(int poolSize) throws TikaException {\n        try {\n            //stop the world with a write lock.\n            //parsers that are currently in use will be offered later (once the lock is released),\n            //but not accepted and will be gc'd.  We have to do this locking and\n            //the read locking in case one thread resizes the pool when the\n            //parsers have already started.  We could have an NPE on SAX_PARSERS\n            //if we didn't lock.\n            SAX_READ_WRITE_LOCK.writeLock().lock();\n            if (SAX_PARSERS.size() != poolSize) {\n                SAX_PARSERS = new ArrayBlockingQueue<>(poolSize);\n                for (int i = 0; i < poolSize; i++) {\n                    SAX_PARSERS.offer(getSAXParser());\n                }\n            }\n        } finally {\n            SAX_READ_WRITE_LOCK.writeLock().unlock();\n        }\n        try {\n            DOM_READ_WRITE_LOCK.writeLock().lock();\n\n            if (DOM_BUILDERS.size() != poolSize) {\n                DOM_BUILDERS = new ArrayBlockingQueue<>(poolSize);\n                for (int i = 0; i < poolSize; i++) {\n                    DOM_BUILDERS.offer(getDocumentBuilder());\n                }\n            }\n        } finally {\n            DOM_READ_WRITE_LOCK.writeLock().unlock();\n        }\n        POOL_SIZE = poolSize;\n    }\n\n    private static void trySetXercesSecurityManager(DocumentBuilderFactory factory) {\n        //from POI\n        // Try built-in JVM one first, standalone if not\n        for (String securityManagerClassName : new String[] {\n                //\"com.sun.org.apache.xerces.internal.util.SecurityManager\",\n                \"org.apache.xerces.util.SecurityManager\"\n        }) {\n            try {\n                Object mgr = Class.forName(securityManagerClassName).newInstance();\n                Method setLimit = mgr.getClass().getMethod(\"setEntityExpansionLimit\", Integer.TYPE);\n                setLimit.invoke(mgr, MAX_ENTITY_EXPANSIONS);\n                factory.setAttribute(\"http://apache.org/xml/properties/security-manager\", mgr);\n                // Stop once one can be setup without error\n                return;\n            } catch (ClassNotFoundException e) {\n                // continue without log, this is expected in some setups\n            } catch (Throwable e) {     // NOSONAR - also catch things like NoClassDefError here\n                // throttle the log somewhat as it can spam the log otherwise\n                if(System.currentTimeMillis() > LAST_LOG + TimeUnit.MINUTES.toMillis(5)) {\n                    LOG.log(Level.WARNING, \"SAX Security Manager could not be setup [log suppressed for 5 minutes]\", e);\n                    LAST_LOG = System.currentTimeMillis();\n                }\n            }\n        }\n\n        // separate old version of Xerces not found => use the builtin way of setting the property\n        try {\n            factory.setAttribute(\"http://www.oracle.com/xml/jaxp/properties/entityExpansionLimit\", MAX_ENTITY_EXPANSIONS);\n        } catch (IllegalArgumentException e) {     // NOSONAR - also catch things like NoClassDefError here\n            // throttle the log somewhat as it can spam the log otherwise\n            if(System.currentTimeMillis() > LAST_LOG + TimeUnit.MINUTES.toMillis(5)) {\n                LOG.log(Level.WARNING, \"SAX Security Manager could not be setup [log suppressed for 5 minutes]\", e);\n                LAST_LOG = System.currentTimeMillis();\n            }\n        }\n    }\n\n    private static void trySetXercesSecurityManager(SAXParser parser) {\n        //from POI\n        // Try built-in JVM one first, standalone if not\n        for (String securityManagerClassName : new String[] {\n                //\"com.sun.org.apache.xerces.internal.util.SecurityManager\",\n                \"org.apache.xerces.util.SecurityManager\"\n        }) {\n            try {\n                Object mgr = Class.forName(securityManagerClassName).newInstance();\n                Method setLimit = mgr.getClass().getMethod(\"setEntityExpansionLimit\", Integer.TYPE);\n                setLimit.invoke(mgr, MAX_ENTITY_EXPANSIONS);\n                parser.setProperty(\"http://apache.org/xml/properties/security-manager\", mgr);\n                // Stop once one can be setup without error\n                return;\n            } catch (ClassNotFoundException e) {\n                // continue without log, this is expected in some setups\n            } catch (Throwable e) {     // NOSONAR - also catch things like NoClassDefError here\n                // throttle the log somewhat as it can spam the log otherwise\n                if(System.currentTimeMillis() > LAST_LOG + TimeUnit.MINUTES.toMillis(5)) {\n                    LOG.log(Level.WARNING, \"SAX Security Manager could not be setup [log suppressed for 5 minutes]\", e);\n                    LAST_LOG = System.currentTimeMillis();\n                }\n            }\n        }\n\n        // separate old version of Xerces not found => use the builtin way of setting the property\n        try {\n            parser.setProperty(\"http://www.oracle.com/xml/jaxp/properties/entityExpansionLimit\", MAX_ENTITY_EXPANSIONS);\n        } catch (SAXException e) {     // NOSONAR - also catch things like NoClassDefError here\n            // throttle the log somewhat as it can spam the log otherwise\n            if(System.currentTimeMillis() > LAST_LOG + TimeUnit.MINUTES.toMillis(5)) {\n                LOG.log(Level.WARNING, \"SAX Security Manager could not be setup [log suppressed for 5 minutes]\", e);\n                LAST_LOG = System.currentTimeMillis();\n            }\n        }\n    }\n\n    private static void trySetStaxSecurityManager(XMLInputFactory inputFactory) {\n        try {\n            inputFactory.setProperty(\"com.ctc.wstx.maxEntityCount\", MAX_ENTITY_EXPANSIONS);\n        } catch (IllegalArgumentException e) {\n            // throttle the log somewhat as it can spam the log otherwise\n            if(System.currentTimeMillis() > LAST_LOG + TimeUnit.MINUTES.toMillis(5)) {\n                LOG.log(Level.WARNING, \"SAX Security Manager could not be setup [log suppressed for 5 minutes]\", e);\n                LAST_LOG = System.currentTimeMillis();\n            }\n        }\n    }\n}",
    "target": 0,
    "language": "java",
    "dataset": "A-Manually-Curated-Dataset-of-Vulnerability-Introducing-Commits-in-Java",
    "idx": 800051,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "/* ====================================================================\n   Licensed to the Apache Software Foundation (ASF) under one or more\n   contributor license agreements.  See the NOTICE file distributed with\n   this work for additional information regarding copyright ownership.\n   The ASF licenses this file to You under the Apache License, Version 2.0\n   (the \"License\"); you may not use this file except in compliance with\n   the License.  You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n==================================================================== */\n\npackage org.apache.poi.xssf.streaming;\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\n\nimport org.apache.poi.ss.SpreadsheetVersion;\nimport org.apache.poi.ss.formula.FormulaParseException;\nimport org.apache.poi.ss.formula.eval.ErrorEval;\nimport org.apache.poi.ss.usermodel.Cell;\nimport org.apache.poi.ss.usermodel.CellStyle;\nimport org.apache.poi.ss.usermodel.Comment;\nimport org.apache.poi.ss.usermodel.DateUtil;\nimport org.apache.poi.ss.usermodel.FormulaError;\nimport org.apache.poi.ss.usermodel.Hyperlink;\nimport org.apache.poi.ss.usermodel.RichTextString;\nimport org.apache.poi.ss.usermodel.Row;\nimport org.apache.poi.ss.util.CellRangeAddress;\nimport org.apache.poi.ss.util.CellReference;\nimport org.apache.poi.util.LocaleUtil;\nimport org.apache.poi.util.POILogFactory;\nimport org.apache.poi.util.POILogger;\nimport org.apache.poi.xssf.usermodel.XSSFHyperlink;\nimport org.apache.poi.xssf.usermodel.XSSFRichTextString;\n\n/**\n * Streaming version of XSSFRow implementing the \"BigGridDemo\" strategy.\n*/\npublic class SXSSFCell implements Cell {\n    private static POILogger logger = POILogFactory.getLogger(SXSSFCell.class);\n\n    SXSSFRow _row;\n    Value _value;\n    CellStyle _style;\n    Property _firstProperty;\n\n    public SXSSFCell(SXSSFRow row,int cellType)\n    {\n        _row=row;\n        setType(cellType);\n    }\n\n//start of interface implementation\n\n    /**\n     * Returns column index of this cell\n     *\n     * @return zero-based column index of a column in a sheet.\n     */\n    public int getColumnIndex()\n    {\n        return _row.getCellIndex(this);\n    }\n\n    /**\n     * Returns row index of a row in the sheet that contains this cell\n     *\n     * @return zero-based row index of a row in the sheet that contains this cell\n     */\n    public int getRowIndex()\n    {\n        return _row.getRowNum();\n    }\n\n    /**\n     * Returns the sheet this cell belongs to\n     *\n     * @return the sheet this cell belongs to\n     */\n    public SXSSFSheet getSheet()\n    {\n        return _row.getSheet();\n    }\n\n    /**\n     * Returns the Row this cell belongs to\n     *\n     * @return the Row that owns this cell\n     */\n     public Row getRow()\n     {\n         return _row;\n     }\n\n    /**\n     * Set the cells type (numeric, formula or string)\n     *\n     * @throws IllegalArgumentException if the specified cell type is invalid\n     * @see #CELL_TYPE_NUMERIC\n     * @see #CELL_TYPE_STRING\n     * @see #CELL_TYPE_FORMULA\n     * @see #CELL_TYPE_BLANK\n     * @see #CELL_TYPE_BOOLEAN\n     * @see #CELL_TYPE_ERROR\n     */\n    public void setCellType(int cellType)\n    {\n        ensureType(cellType);\n    }\n\n    /**\n     * Return the cell type.\n     *\n     * @return the cell type\n     * @see Cell#CELL_TYPE_BLANK\n     * @see Cell#CELL_TYPE_NUMERIC\n     * @see Cell#CELL_TYPE_STRING\n     * @see Cell#CELL_TYPE_FORMULA\n     * @see Cell#CELL_TYPE_BOOLEAN\n     * @see Cell#CELL_TYPE_ERROR\n     */\n    public int getCellType()\n    {\n        return _value.getType();\n    }\n\n    /**\n     * Only valid for formula cells\n     * @return one of ({@link #CELL_TYPE_NUMERIC}, {@link #CELL_TYPE_STRING},\n     *     {@link #CELL_TYPE_BOOLEAN}, {@link #CELL_TYPE_ERROR}) depending\n     * on the cached value of the formula\n     */\n    public int getCachedFormulaResultType()\n    {\n        if (_value.getType() != CELL_TYPE_FORMULA) {\n            throw new IllegalStateException(\"Only formula cells have cached results\");\n        }\n\n        return ((FormulaValue)_value).getFormulaType();\n    }\n\n    /**\n     * Set a numeric value for the cell\n     *\n     * @param value  the numeric value to set this cell to.  For formulas we'll set the\n     *        precalculated value, for numerics we'll set its value. For other types we\n     *        will change the cell to a numeric cell and set its value.\n     */\n    public void setCellValue(double value)\n    {\n        if(Double.isInfinite(value)) {\n            // Excel does not support positive/negative infinities,\n            // rather, it gives a #DIV/0! error in these cases.\n            setCellErrorValue(FormulaError.DIV0.getCode());\n        } else if (Double.isNaN(value)){\n            setCellErrorValue(FormulaError.NUM.getCode());\n        } else {\n            ensureTypeOrFormulaType(CELL_TYPE_NUMERIC);\n            if(_value.getType()==CELL_TYPE_FORMULA)\n                ((NumericFormulaValue)_value).setPreEvaluatedValue(value);\n            else\n                ((NumericValue)_value).setValue(value);\n        }\n    }\n\n    /**\n     * Converts the supplied date to its equivalent Excel numeric value and sets\n     * that into the cell.\n     * <p/>\n     * <b>Note</b> - There is actually no 'DATE' cell type in Excel. In many\n     * cases (when entering date values), Excel automatically adjusts the\n     * <i>cell style</i> to some date format, creating the illusion that the cell\n     * data type is now something besides {@link Cell#CELL_TYPE_NUMERIC}.  POI\n     * does not attempt to replicate this behaviour.  To make a numeric cell\n     * display as a date, use {@link #setCellStyle(CellStyle)} etc.\n     *\n     * @param value the numeric value to set this cell to.  For formulas we'll set the\n     *        precalculated value, for numerics we'll set its value. For other types we\n     *        will change the cell to a numerics cell and set its value.\n     */\n    public void setCellValue(Date value) {\n        boolean date1904 = getSheet().getWorkbook().isDate1904();\n        setCellValue(DateUtil.getExcelDate(value, date1904));\n    }\n\n    /**\n     * Set a date value for the cell. Excel treats dates as numeric so you will need to format the cell as\n     * a date.\n     * <p>\n     * This will set the cell value based on the Calendar's timezone. As Excel\n     * does not support timezones this means that both 20:00+03:00 and\n     * 20:00-03:00 will be reported as the same value (20:00) even that there\n     * are 6 hours difference between the two times. This difference can be\n     * preserved by using <code>setCellValue(value.getTime())</code> which will\n     * automatically shift the times to the default timezone.\n     * </p>\n     *\n     * @param value  the date value to set this cell to.  For formulas we'll set the\n     *        precalculated value, for numerics we'll set its value. For othertypes we\n     *        will change the cell to a numeric cell and set its value.\n     */\n    public void setCellValue(Calendar value) {\n        boolean date1904 = getSheet().getWorkbook().isDate1904();\n        setCellValue( DateUtil.getExcelDate(value, date1904 ));\n    }\n\n    /**\n     * Set a rich string value for the cell.\n     *\n     * @param value  value to set the cell to.  For formulas we'll set the formula\n     * string, for String cells we'll set its value.  For other types we will\n     * change the cell to a string cell and set its value.\n     * If value is null then we will change the cell to a Blank cell.\n     */\n    public void setCellValue(RichTextString value)\n    {\n        XSSFRichTextString xvalue = (XSSFRichTextString)value;\n        \n        if (xvalue != null) {\n            ensureRichTextStringType();\n            \n            if (xvalue.length() > SpreadsheetVersion.EXCEL2007.getMaxTextLength()) {\n                throw new IllegalArgumentException(\"The maximum length of cell contents (text) is 32,767 characters\");\n            }\n            if (xvalue.hasFormatting())\n                logger.log(POILogger.WARN, \"SXSSF doesn't support Shared Strings, rich text formatting information has be lost\");\n            \n            ((RichTextValue)_value).setValue(xvalue);\n        } else {\n            setCellType(CELL_TYPE_BLANK);\n        }\n    }\n\n    /**\n     * Set a string value for the cell.\n     *\n     * @param value  value to set the cell to.  For formulas we'll set the formula\n     * string, for String cells we'll set its value.  For other types we will\n     * change the cell to a string cell and set its value.\n     * If value is null then we will change the cell to a Blank cell.\n     */\n    public void setCellValue(String value)\n    {\n        ensureTypeOrFormulaType(CELL_TYPE_STRING);\n        \n        if(value != null && value.length() > SpreadsheetVersion.EXCEL2007.getMaxTextLength()){\n            throw new IllegalArgumentException(\"The maximum length of cell contents (text) is 32,767 characters\");\n        }\n\n        if(_value.getType()==CELL_TYPE_FORMULA)\n            ((StringFormulaValue)_value).setPreEvaluatedValue(value);\n        else\n            ((PlainStringValue)_value).setValue(value);\n    }\n\n    /**\n     * Sets formula for this cell.\n     * <p>\n     * Note, this method only sets the formula string and does not calculate the formula value.\n     * To set the precalculated value use {@link #setCellValue(double)} or {@link #setCellValue(String)}\n     * </p>\n     *\n     * @param formula the formula to set, e.g. <code>\"SUM(C4:E4)\"</code>.\n     *  If the argument is <code>null</code> then the current formula is removed.\n     * @throws FormulaParseException if the formula has incorrect syntax or is otherwise invalid\n     */\n    public void setCellFormula(String formula) throws FormulaParseException\n    {\n        if(formula == null) {\n            setType(Cell.CELL_TYPE_BLANK);\n            return;\n        }\n\n        ensureFormulaType(computeTypeFromFormula(formula));\n        ((FormulaValue)_value).setValue(formula);\n    }\n    /**\n     * Return a formula for the cell, for example, <code>SUM(C4:E4)</code>\n     *\n     * @return a formula for the cell\n     * @throws IllegalStateException if the cell type returned by {@link #getCellType()} is not CELL_TYPE_FORMULA\n     */\n    public String getCellFormula()\n    {\n       if(_value.getType()!=CELL_TYPE_FORMULA)\n           throw typeMismatch(CELL_TYPE_FORMULA,_value.getType(),false);\n        return ((FormulaValue)_value).getValue();\n    }\n\n    /**\n     * Get the value of the cell as a number.\n     * <p>\n     * For strings we throw an exception. For blank cells we return a 0.\n     * For formulas or error cells we return the precalculated value;\n     * </p>\n     * @return the value of the cell as a number\n     * @throws IllegalStateException if the cell type returned by {@link #getCellType()} is CELL_TYPE_STRING\n     * @exception NumberFormatException if the cell value isn't a parsable <code>double</code>.\n     * @see org.apache.poi.ss.usermodel.DataFormatter for turning this number into a string similar to that which Excel would render this number as.\n     */\n    public double getNumericCellValue()\n    {\n        int cellType = getCellType();\n        switch(cellType) \n        {\n            case CELL_TYPE_BLANK:\n                return 0.0;\n            case CELL_TYPE_FORMULA:\n            {\n                FormulaValue fv=(FormulaValue)_value;\n                if(fv.getFormulaType()!=CELL_TYPE_NUMERIC)\n                      throw typeMismatch(CELL_TYPE_NUMERIC, CELL_TYPE_FORMULA, false);\n                return ((NumericFormulaValue)_value).getPreEvaluatedValue();\n            }\n            case CELL_TYPE_NUMERIC:\n                return ((NumericValue)_value).getValue();\n            default:\n                throw typeMismatch(CELL_TYPE_NUMERIC, cellType, false);\n        }\n    }\n\n    /**\n     * Get the value of the cell as a date.\n     * <p>\n     * For strings we throw an exception. For blank cells we return a null.\n     * </p>\n     * @return the value of the cell as a date\n     * @throws IllegalStateException if the cell type returned by {@link #getCellType()} is CELL_TYPE_STRING\n     * @exception NumberFormatException if the cell value isn't a parsable <code>double</code>.\n     * @see org.apache.poi.ss.usermodel.DataFormatter for formatting  this date into a string similar to how excel does.\n     */\n    public Date getDateCellValue()\n    {\n        int cellType = getCellType();\n        if (cellType == CELL_TYPE_BLANK) \n        {\n            return null;\n        }\n\n        double value = getNumericCellValue();\n        boolean date1904 = getSheet().getWorkbook().isDate1904();\n        return DateUtil.getJavaDate(value, date1904);\n    }\n\n    /**\n     * Get the value of the cell as a XSSFRichTextString\n     * <p>\n     * For numeric cells we throw an exception. For blank cells we return an empty string.\n     * For formula cells we return the pre-calculated value if a string, otherwise an exception.\n     * </p>\n     * @return the value of the cell as a XSSFRichTextString\n     */\n    public RichTextString getRichStringCellValue()\n    {\n        int cellType = getCellType();\n        if(getCellType() != CELL_TYPE_STRING)\n            throw typeMismatch(CELL_TYPE_STRING, cellType, false);\n\n        StringValue sval = (StringValue)_value;\n        if(sval.isRichText())\n            return ((RichTextValue)_value).getValue();\n        else {\n            String plainText = getStringCellValue();\n            return getSheet().getWorkbook().getCreationHelper().createRichTextString(plainText);\n        }\n    }\n\n\n    /**\n     * Get the value of the cell as a string\n     * <p>\n     * For numeric cells we throw an exception. For blank cells we return an empty string.\n     * For formulaCells that are not string Formulas, we throw an exception.\n     * </p>\n     * @return the value of the cell as a string\n     */\n    public String getStringCellValue()\n    {\n        int cellType = getCellType();\n        switch(cellType) \n        {\n            case CELL_TYPE_BLANK:\n                return \"\";\n            case CELL_TYPE_FORMULA:\n            {\n                FormulaValue fv=(FormulaValue)_value;\n                if(fv.getFormulaType()!=CELL_TYPE_STRING)\n                      throw typeMismatch(CELL_TYPE_STRING, CELL_TYPE_FORMULA, false);\n                return ((StringFormulaValue)_value).getPreEvaluatedValue();\n            }\n            case CELL_TYPE_STRING:\n            {\n                if(((StringValue)_value).isRichText())\n                    return ((RichTextValue)_value).getValue().getString();\n                else\n                    return ((PlainStringValue)_value).getValue();\n            }\n            default:\n                throw typeMismatch(CELL_TYPE_STRING, cellType, false);\n        }\n    }\n\n    /**\n     * Set a boolean value for the cell\n     *\n     * @param value the boolean value to set this cell to.  For formulas we'll set the\n     *        precalculated value, for booleans we'll set its value. For other types we\n     *        will change the cell to a boolean cell and set its value.\n     */\n    public void setCellValue(boolean value)\n    {\n        ensureTypeOrFormulaType(CELL_TYPE_BOOLEAN);\n        if(_value.getType()==CELL_TYPE_FORMULA)\n            ((BooleanFormulaValue)_value).setPreEvaluatedValue(value);\n        else\n            ((BooleanValue)_value).setValue(value);\n    }\n\n    /**\n     * Set a error value for the cell\n     *\n     * @param value the error value to set this cell to.  For formulas we'll set the\n     *        precalculated value , for errors we'll set\n     *        its value. For other types we will change the cell to an error\n     *        cell and set its value.\n     * @see org.apache.poi.ss.usermodel.FormulaError\n     */\n    public void setCellErrorValue(byte value)\n    {\n        ensureType(CELL_TYPE_ERROR);\n        if(_value.getType()==CELL_TYPE_FORMULA)\n            ((ErrorFormulaValue)_value).setPreEvaluatedValue(value);\n        else\n            ((ErrorValue)_value).setValue(value);\n    }\n\n    /**\n     * Get the value of the cell as a boolean.\n     * <p>\n     * For strings, numbers, and errors, we throw an exception. For blank cells we return a false.\n     * </p>\n     * @return the value of the cell as a boolean\n     * @throws IllegalStateException if the cell type returned by {@link #getCellType()}\n     *   is not CELL_TYPE_BOOLEAN, CELL_TYPE_BLANK or CELL_TYPE_FORMULA\n     */\n    public boolean getBooleanCellValue()\n    {\n        int cellType = getCellType();\n        switch(cellType) \n        {\n            case CELL_TYPE_BLANK:\n                return false;\n            case CELL_TYPE_FORMULA:\n            {\n                FormulaValue fv=(FormulaValue)_value;\n                if(fv.getFormulaType()!=CELL_TYPE_BOOLEAN)\n                      throw typeMismatch(CELL_TYPE_BOOLEAN, CELL_TYPE_FORMULA, false);\n                return ((BooleanFormulaValue)_value).getPreEvaluatedValue();\n            }\n            case CELL_TYPE_BOOLEAN:\n            {\n                return ((BooleanValue)_value).getValue();\n            }\n            default:\n                throw typeMismatch(CELL_TYPE_BOOLEAN, cellType, false);\n        }\n    }\n\n    /**\n     * Get the value of the cell as an error code.\n     * <p>\n     * For strings, numbers, and booleans, we throw an exception.\n     * For blank cells we return a 0.\n     * </p>\n     *\n     * @return the value of the cell as an error code\n     * @throws IllegalStateException if the cell type returned by {@link #getCellType()} isn't CELL_TYPE_ERROR\n     * @see org.apache.poi.ss.usermodel.FormulaError for error codes\n     */\n    public byte getErrorCellValue()\n    {\n        int cellType = getCellType();\n        switch(cellType) \n        {\n            case CELL_TYPE_BLANK:\n                return 0;\n            case CELL_TYPE_FORMULA:\n            {\n                FormulaValue fv=(FormulaValue)_value;\n                if(fv.getFormulaType()!=CELL_TYPE_ERROR)\n                      throw typeMismatch(CELL_TYPE_ERROR, CELL_TYPE_FORMULA, false);\n                return ((ErrorFormulaValue)_value).getPreEvaluatedValue();\n            }\n            case CELL_TYPE_ERROR:\n            {\n                return ((ErrorValue)_value).getValue();\n            }\n            default:\n                throw typeMismatch(CELL_TYPE_ERROR, cellType, false);\n        }\n    }\n\n    /**\n     * Set the style for the cell.  The style should be an CellStyle created/retreived from\n     * the Workbook.\n     *\n     * @param style  reference contained in the workbook.\n     * If the value is null then the style information is removed causing the cell to used the default workbook style.\n     * @see org.apache.poi.ss.usermodel.Workbook#createCellStyle()\n     */\n    public void setCellStyle(CellStyle style)\n    {\n        _style=style;\n    }\n\n    /**\n     * Return the cell's style.\n     *\n     * @return the cell's style. Always not-null. Default cell style has zero index and can be obtained as\n     * <code>workbook.getCellStyleAt(0)</code>\n     * @see org.apache.poi.ss.usermodel.Workbook#getCellStyleAt(short)\n     */\n    @SuppressWarnings(\"resource\")\n    public CellStyle getCellStyle()\n    {\n        if(_style == null){\n            SXSSFWorkbook wb = (SXSSFWorkbook)getRow().getSheet().getWorkbook();\n            return wb.getCellStyleAt((short)0);\n        } else {\n            return _style;\n        }\n    }\n\n    /**\n     * Sets this cell as the active cell for the worksheet\n     */\n    public void setAsActiveCell()\n    {\n//TODO: What needs to be done here? Is there a \"the active cell\" at the sheet or even the workbook level?\n        //getRow().setAsActiveCell(this);\n    }\n\n    /**\n     * Assign a comment to this cell\n     *\n     * @param comment comment associated with this cell\n     */\n    public void setCellComment(Comment comment)\n    {\n        setProperty(Property.COMMENT,comment);\n    }\n\n    /**\n     * Returns comment associated with this cell\n     *\n     * @return comment associated with this cell or <code>null</code> if not found\n     */\n    public Comment getCellComment()\n    {\n        return (Comment)getPropertyValue(Property.COMMENT);\n    }\n\n    /**\n     * Removes the comment for this cell, if there is one.\n     */\n    public void removeCellComment()\n    {\n        removeProperty(Property.COMMENT);\n    }\n\n    /**\n     * @return hyperlink associated with this cell or <code>null</code> if not found\n     */\n    public Hyperlink getHyperlink()\n    {\n        return (Hyperlink)getPropertyValue(Property.HYPERLINK);\n    }\n\n    /**\n     * Assign a hyperlink to this cell. If the supplied hyperlink is null, the\n     * hyperlink for this cell will be removed.\n     *\n     * @param link hyperlink associated with this cell\n     */\n    public void setHyperlink(Hyperlink link)\n    {\n        if (link == null) {\n            removeHyperlink();\n            return;\n        }\n\n        setProperty(Property.HYPERLINK,link);\n\n        XSSFHyperlink xssfobj = (XSSFHyperlink)link;\n        // Assign to us\n        CellReference ref = new CellReference(getRowIndex(), getColumnIndex());\n        xssfobj.getCTHyperlink().setRef( ref.formatAsString()  );\n\n        // Add to the lists\n        getSheet()._sh.addHyperlink(xssfobj);\n    }\n\n    /**\n     * Removes the hyperlink for this cell, if there is one.\n     */\n    public void removeHyperlink()\n    {\n        removeProperty(Property.HYPERLINK);\n\n        getSheet()._sh.removeHyperlink(getRowIndex(), getColumnIndex());\n    }\n\n    /**\n     * Only valid for array formula cells\n     *\n     * @return range of the array formula group that the cell belongs to.\n     */\n//TODO: What is this?\n    public CellRangeAddress getArrayFormulaRange()\n    {\n        return null;\n    }\n\n    /**\n     * @return <code>true</code> if this cell is part of group of cells having a common array formula.\n     */\n//TODO: What is this?\n    public boolean isPartOfArrayFormulaGroup()\n    {\n        return false;\n    }\n//end of interface implementation\n\n    /**\n     * Returns a string representation of the cell\n     * <p>\n     * Formula cells return the formula string, rather than the formula result.\n     * Dates are displayed in dd-MMM-yyyy format\n     * Errors are displayed as #ERR&lt;errIdx&gt;\n     * </p>\n     */\n    @Override\n    public String toString() {\n        switch (getCellType()) {\n            case CELL_TYPE_BLANK:\n                return \"\";\n            case CELL_TYPE_BOOLEAN:\n                return getBooleanCellValue() ? \"TRUE\" : \"FALSE\";\n            case CELL_TYPE_ERROR:\n                return ErrorEval.getText(getErrorCellValue());\n            case CELL_TYPE_FORMULA:\n                return getCellFormula();\n            case CELL_TYPE_NUMERIC:\n                if (DateUtil.isCellDateFormatted(this)) {\n                    DateFormat sdf = new SimpleDateFormat(\"dd-MMM-yyyy\", LocaleUtil.getUserLocale());\n                    sdf.setTimeZone(LocaleUtil.getUserTimeZone());\n                    return sdf.format(getDateCellValue());\n                }\n                return getNumericCellValue() + \"\";\n            case CELL_TYPE_STRING:\n                return getRichStringCellValue().toString();\n            default:\n                return \"Unknown Cell Type: \" + getCellType();\n        }\n    }\n\n    void removeProperty(int type)\n    {\n        Property current=_firstProperty;\n        Property previous=null;\n        while(current!=null&&current.getType()!=type)\n        {\n            previous=current;\n            current=current._next;\n        }\n        if(current!=null)\n        {\n            if(previous!=null)\n            {\n                previous._next=current._next;\n            }\n            else\n            {\n                _firstProperty=current._next;\n            }\n        }\n    }\n    void setProperty(int type,Object value)\n    {\n        Property current=_firstProperty;\n        Property previous=null;\n        while(current!=null&&current.getType()!=type)\n        {\n            previous=current;\n            current=current._next;\n        }\n        if(current!=null)\n        {\n            current.setValue(value);\n        }\n        else\n        {\n            switch(type)\n            {\n                case Property.COMMENT:\n                {\n                    current=new CommentProperty(value);\n                    break;\n                }\n                case Property.HYPERLINK:\n                {\n                    current=new HyperlinkProperty(value);\n                    break;\n                }\n            }\n            if(previous!=null)\n            {\n                previous._next=current;\n            }\n            else\n            {\n                _firstProperty=current;\n            }\n        }\n    }\n    Object getPropertyValue(int type)\n    {\n        return getPropertyValue(type,null);\n    }\n    Object getPropertyValue(int type,String defaultValue)\n    {\n        Property current=_firstProperty;\n        while(current!=null&&current.getType()!=type) current=current._next;\n        return current==null?defaultValue:current.getValue();\n    }\n    void ensurePlainStringType()\n    {\n        if(_value.getType()!=CELL_TYPE_STRING\n           ||((StringValue)_value).isRichText())\n            _value=new PlainStringValue();\n    }\n    void ensureRichTextStringType()\n    {\n        if(_value.getType()!=CELL_TYPE_STRING\n           ||!((StringValue)_value).isRichText())\n            _value=new RichTextValue();\n    }\n    void ensureType(int type)\n    {\n        if(_value.getType()!=type)\n            setType(type);\n    }\n    void ensureFormulaType(int type)\n    {\n        if(_value.getType()!=CELL_TYPE_FORMULA\n           ||((FormulaValue)_value).getFormulaType()!=type)\n            setFormulaType(type);\n    }\n    void ensureTypeOrFormulaType(int type)\n    {\n        if(_value.getType()==type)\n        {\n            if(type==CELL_TYPE_STRING&&((StringValue)_value).isRichText())\n                setType(CELL_TYPE_STRING);\n            return;\n        }\n        if(_value.getType()==CELL_TYPE_FORMULA)\n        {\n            if(((FormulaValue)_value).getFormulaType()==type)\n                return;\n            setFormulaType(type); // once a formula, always a formula\n            return;\n        }\n        setType(type);\n    }\n    void setType(int type)\n    {\n        switch(type)\n        {\n            case CELL_TYPE_NUMERIC:\n            {\n                _value=new NumericValue();\n                break;\n            }\n            case CELL_TYPE_STRING:\n            {\n                PlainStringValue sval = new PlainStringValue();\n                if(_value != null){\n                    // if a cell is not blank then convert the old value to string\n                    String str = convertCellValueToString();\n                    sval.setValue(str);\n                }\n                _value = sval;\n                break;\n            }\n            case CELL_TYPE_FORMULA:\n            {\n                _value=new NumericFormulaValue();\n                break;\n            }\n            case CELL_TYPE_BLANK:\n            {\n                _value=new BlankValue();\n                break;\n            }\n            case CELL_TYPE_BOOLEAN:\n            {\n                BooleanValue bval = new BooleanValue();\n                if(_value != null){\n                    // if a cell is not blank then convert the old value to string\n                    boolean val = convertCellValueToBoolean();\n                    bval.setValue(val);\n                }\n                _value = bval;\n                break;\n            }\n            case CELL_TYPE_ERROR:\n            {\n                _value=new ErrorValue();\n                break;\n            }\n            default:\n            {\n                throw new IllegalArgumentException(\"Illegal type \" + type);\n            }\n        }\n    }\n    void setFormulaType(int type)\n    {\n        switch(type)\n        {\n            case CELL_TYPE_NUMERIC:\n            {\n                _value=new NumericFormulaValue();\n                break;\n            }\n            case CELL_TYPE_STRING:\n            {\n                _value=new StringFormulaValue();\n                break;\n            }\n            case CELL_TYPE_BOOLEAN:\n            {\n                _value=new BooleanFormulaValue();\n                break;\n            }\n            case CELL_TYPE_ERROR:\n            {\n                _value=new ErrorFormulaValue();\n                break;\n            }\n            default:\n            {\n                throw new IllegalArgumentException(\"Illegal type \" + type);\n            }\n        }\n    }\n//TODO: implement this correctly\n    int computeTypeFromFormula(String formula)\n    {\n        return CELL_TYPE_NUMERIC;\n    }\n//COPIED FROM https://svn.apache.org/repos/asf/poi/trunk/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFCell.java since the functions are declared private there\n    /**\n     * Used to help format error messages\n     */\n    private static RuntimeException typeMismatch(int expectedTypeCode, int actualTypeCode, boolean isFormulaCell) {\n        String msg = \"Cannot get a \"\n            + getCellTypeName(expectedTypeCode) + \" value from a \"\n            + getCellTypeName(actualTypeCode) + \" \" + (isFormulaCell ? \"formula \" : \"\") + \"cell\";\n        return new IllegalStateException(msg);\n    }\n/**\n     * Used to help format error messages\n     */\n    private static String getCellTypeName(int cellTypeCode) {\n        switch (cellTypeCode) {\n            case CELL_TYPE_BLANK:   return \"blank\";\n            case CELL_TYPE_STRING:  return \"text\";\n            case CELL_TYPE_BOOLEAN: return \"boolean\";\n            case CELL_TYPE_ERROR:   return \"error\";\n            case CELL_TYPE_NUMERIC: return \"numeric\";\n            case CELL_TYPE_FORMULA: return \"formula\";\n        }\n        return \"#unknown cell type (\" + cellTypeCode + \")#\";\n    }\n    private boolean convertCellValueToBoolean() {\n        int cellType = getCellType();\n\n        if (cellType == CELL_TYPE_FORMULA) {\n            cellType = getCachedFormulaResultType();\n        }\n\n        switch (cellType) {\n            case CELL_TYPE_BOOLEAN:\n                return getBooleanCellValue();\n            case CELL_TYPE_STRING:\n\n                String text = getStringCellValue();\n                return Boolean.parseBoolean(text);\n            case CELL_TYPE_NUMERIC:\n                return getNumericCellValue() != 0;\n            case CELL_TYPE_ERROR:\n            case CELL_TYPE_BLANK:\n                return false;\n        }\n        throw new RuntimeException(\"Unexpected cell type (\" + cellType + \")\");\n    }\n    private String convertCellValueToString() {\n        int cellType = getCellType();\n        return convertCellValueToString(cellType);\n    }\n    private String convertCellValueToString(int cellType) {\n        switch (cellType) {\n            case CELL_TYPE_BLANK:\n                return \"\";\n            case CELL_TYPE_BOOLEAN:\n                return getBooleanCellValue() ? \"TRUE\" : \"FALSE\";\n            case CELL_TYPE_STRING:\n                return getStringCellValue();\n            case CELL_TYPE_NUMERIC:\n            \treturn Double.toString( getNumericCellValue() );\n            case CELL_TYPE_ERROR:\n                byte errVal = getErrorCellValue();\n                return FormulaError.forInt(errVal).getString();\n            case CELL_TYPE_FORMULA:\n                if (_value != null) {\n                    FormulaValue fv = (FormulaValue)_value;\n                    if (fv.getFormulaType() != CELL_TYPE_FORMULA) {\n                        return convertCellValueToString(fv.getFormulaType());\n                    }\n                }\n                return \"\";\n            default:\n                throw new IllegalStateException(\"Unexpected cell type (\" + cellType + \")\");\n        }\n    }\n\n//END OF COPIED CODE\n\n    static abstract class Property\n    {\n        final static int COMMENT=1;\n        final static int HYPERLINK=2;\n        Object _value;\n        Property _next;\n        public Property(Object value)\n        {\n            _value=value;\n        }\n        abstract int getType();\n        void setValue(Object value)\n        {\n            _value=value;\n        }\n        Object getValue()\n        {\n            return _value;\n        }\n    }\n    static class CommentProperty extends Property\n    {\n        public CommentProperty(Object value)\n        {\n            super(value);\n        }\n        @Override\n        public int getType()\n        {\n            return COMMENT;\n        }\n    }\n    static class HyperlinkProperty extends Property\n    {\n        public HyperlinkProperty(Object value)\n        {\n            super(value);\n        }\n        @Override\n        public int getType()\n        {\n            return HYPERLINK;\n        }\n    }\n    interface Value\n    {\n        int getType();\n    }\n    static class NumericValue implements Value\n    {\n        double _value;\n        public int getType()\n        {\n            return CELL_TYPE_NUMERIC;\n        }\n        void setValue(double value)\n        {\n            _value=value;\n        }\n        double getValue()\n        {\n            return _value;\n        }\n    }\n    static abstract class StringValue implements Value\n    {\n        public int getType()\n        {\n            return CELL_TYPE_STRING;\n        }\n//We cannot introduce a new type CELL_TYPE_RICH_TEXT because the types are public so we have to make rich text as a type of string\n        abstract boolean isRichText(); // using the POI style which seems to avoid \"instanceof\".\n    }\n    static class PlainStringValue extends StringValue\n    {\n        String _value;\n        void setValue(String value)\n        {\n            _value=value;\n        }\n        String getValue()\n        {\n            return _value;\n        }\n        @Override\n        boolean isRichText()\n        {\n            return false;\n        }\n    }\n    static class RichTextValue extends StringValue\n    {\n        RichTextString _value;\n        @Override\n        public int getType()\n        {\n            return CELL_TYPE_STRING;\n        }\n        void setValue(RichTextString value)\n        {\n            _value=value;\n        }\n        RichTextString getValue()\n        {\n            return _value;\n        }\n        @Override\n        boolean isRichText()\n        {\n            return true;\n        }\n    }\n    static abstract class FormulaValue implements Value\n    {\n        String _value;\n        public int getType()\n        {\n            return CELL_TYPE_FORMULA;\n        }\n        void setValue(String value)\n        {\n            _value=value;\n        }\n        String getValue()\n        {\n            return _value;\n        }\n        abstract int getFormulaType();\n    }\n    static class NumericFormulaValue extends FormulaValue\n    {\n        double _preEvaluatedValue;\n        @Override\n        int getFormulaType()\n        {\n            return CELL_TYPE_NUMERIC;\n        }\n        void setPreEvaluatedValue(double value)\n        {\n            _preEvaluatedValue=value;\n        }\n        double getPreEvaluatedValue()\n        {\n            return _preEvaluatedValue;\n        }\n    }\n    static class StringFormulaValue extends FormulaValue\n    {\n        String _preEvaluatedValue;\n        @Override\n        int getFormulaType()\n        {\n            return CELL_TYPE_STRING;\n        }\n        void setPreEvaluatedValue(String value)\n        {\n            _preEvaluatedValue=value;\n        }\n        String getPreEvaluatedValue()\n        {\n            return _preEvaluatedValue;\n        }\n    }\n    static class BooleanFormulaValue extends FormulaValue\n    {\n        boolean _preEvaluatedValue;\n        @Override\n        int getFormulaType()\n        {\n            return CELL_TYPE_BOOLEAN;\n        }\n        void setPreEvaluatedValue(boolean value)\n        {\n            _preEvaluatedValue=value;\n        }\n        boolean getPreEvaluatedValue()\n        {\n            return _preEvaluatedValue;\n        }\n    }\n    static class ErrorFormulaValue extends FormulaValue\n    {\n        byte _preEvaluatedValue;\n        @Override\n        int getFormulaType()\n        {\n            return CELL_TYPE_ERROR;\n        }\n        void setPreEvaluatedValue(byte value)\n        {\n            _preEvaluatedValue=value;\n        }\n        byte getPreEvaluatedValue()\n        {\n            return _preEvaluatedValue;\n        }\n    }\n    static class BlankValue implements Value\n    {\n        public int getType()\n        {\n            return CELL_TYPE_BLANK;\n        }\n    }\n    static class BooleanValue implements Value\n    {\n        boolean _value;\n        public int getType()\n        {\n            return CELL_TYPE_BOOLEAN;\n        }\n        void setValue(boolean value)\n        {\n            _value=value;\n        }\n        boolean getValue()\n        {\n            return _value;\n        }\n    }\n    static class ErrorValue implements Value\n    {\n        byte _value;\n        public int getType()\n        {\n            return CELL_TYPE_ERROR;\n        }\n        void setValue(byte value)\n        {\n            _value=value;\n        }\n        byte getValue()\n        {\n            return _value;\n        }\n    }\n}",
    "target": 1,
    "language": "java",
    "dataset": "A-Manually-Curated-Dataset-of-Vulnerability-Introducing-Commits-in-Java",
    "idx": 800062,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "/* ====================================================================\n   Licensed to the Apache Software Foundation (ASF) under one or more\n   contributor license agreements.  See the NOTICE file distributed with\n   this work for additional information regarding copyright ownership.\n   The ASF licenses this file to You under the Apache License, Version 2.0\n   (the \"License\"); you may not use this file except in compliance with\n   the License.  You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n==================================================================== */\n\npackage org.apache.poi.xssf.streaming;\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Map;\n\nimport org.apache.poi.ss.SpreadsheetVersion;\nimport org.apache.poi.ss.formula.FormulaParseException;\nimport org.apache.poi.ss.formula.eval.ErrorEval;\nimport org.apache.poi.ss.usermodel.Cell;\nimport org.apache.poi.ss.usermodel.CellStyle;\nimport org.apache.poi.ss.usermodel.CellType;\nimport org.apache.poi.ss.usermodel.Comment;\nimport org.apache.poi.ss.usermodel.DateUtil;\nimport org.apache.poi.ss.usermodel.FormulaError;\nimport org.apache.poi.ss.usermodel.Hyperlink;\nimport org.apache.poi.ss.usermodel.RichTextString;\nimport org.apache.poi.ss.usermodel.Row;\nimport org.apache.poi.ss.util.CellAddress;\nimport org.apache.poi.ss.util.CellRangeAddress;\nimport org.apache.poi.ss.util.CellReference;\nimport org.apache.poi.util.*;\nimport org.apache.poi.xssf.usermodel.XSSFHyperlink;\nimport org.apache.poi.xssf.usermodel.XSSFRichTextString;\n\n/**\n * Streaming version of XSSFCell implementing the \"BigGridDemo\" strategy.\n */\npublic class SXSSFCell implements Cell {\n    private final SXSSFRow _row;\n    private Value _value;\n    private CellStyle _style;\n    private Property _firstProperty;\n    \n    public SXSSFCell(SXSSFRow row, CellType cellType)\n    {\n        _row=row;\n        setType(cellType);\n    }\n\n//start of interface implementation\n\n    /**\n     * Returns column index of this cell\n     *\n     * @return zero-based column index of a column in a sheet.\n     */\n    @Override\n    public int getColumnIndex()\n    {\n        return _row.getCellIndex(this);\n    }\n\n    /**\n     * Returns row index of a row in the sheet that contains this cell\n     *\n     * @return zero-based row index of a row in the sheet that contains this cell\n     */\n    @Override\n    public int getRowIndex()\n    {\n        return _row.getRowNum();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public CellAddress getAddress() {\n        return new CellAddress(this);\n    }\n\n    /**\n     * Returns the sheet this cell belongs to\n     *\n     * @return the sheet this cell belongs to\n     */\n    @Override\n    public SXSSFSheet getSheet()\n    {\n        return _row.getSheet();\n    }\n\n    /**\n     * Returns the Row this cell belongs to\n     *\n     * @return the Row that owns this cell\n     */\n    @Override\n    public Row getRow()\n    {\n        return _row;\n    }\n\n    /**\n     * Set the cells type (numeric, formula or string)\n     *\n     * @throws IllegalArgumentException if the specified cell type is invalid\n     */\n    @Override\n    public void setCellType(CellType cellType)\n    {\n        ensureType(cellType);\n    }\n\n    private boolean isFormulaCell() {\n        return _value instanceof FormulaValue;\n    }\n\n    /**\n     * Return the cell type.\n     *\n     * @return the cell type\n     */\n    @Override\n    public CellType getCellType() {\n        if (isFormulaCell()) {\n            return CellType.FORMULA;\n        }\n\n        return _value.getType();\n    }\n    \n    /**\n     * Return the cell type.\n     *\n     * @return the cell type\n     * @since POI 3.15 beta 3\n     * @deprecated use <code>getCellType</code> instead\n     */\n    @Deprecated\n    @Removal(version = \"4.2\")\n    @Override\n    public CellType getCellTypeEnum()\n    {\n        return getCellType();\n    }\n\n    /**\n     * Only valid for formula cells\n     * @return one of ({@link CellType#NUMERIC}, {@link CellType#STRING},\n     *     {@link CellType#BOOLEAN}, {@link CellType#ERROR}) depending\n     * on the cached value of the formula\n     */\n    @Override\n    public CellType getCachedFormulaResultType() {\n        if (!isFormulaCell()) {\n            throw new IllegalStateException(\"Only formula cells have cached results\");\n        }\n\n        return ((FormulaValue)_value).getFormulaType();\n    }\n\n    /**\n     * Only valid for formula cells\n     * @return one of ({@link CellType#NUMERIC}, {@link CellType#STRING},\n     *     {@link CellType#BOOLEAN}, {@link CellType#ERROR}) depending\n     * on the cached value of the formula\n     * @since POI 3.15 beta 3\n     * @deprecated use <code>getCachedFormulaResultType</code> instead\n     */\n    @Deprecated\n    @Removal(version = \"4.2\")\n    @Override\n    public CellType getCachedFormulaResultTypeEnum() {\n        return getCachedFormulaResultType();\n    }\n\n    /**\n     * Set a numeric value for the cell\n     *\n     * @param value  the numeric value to set this cell to.  For formulas we'll set the\n     *        precalculated value, for numerics we'll set its value. For other types we\n     *        will change the cell to a numeric cell and set its value.\n     */\n    @Override\n    public void setCellValue(double value)\n    {\n        if(Double.isInfinite(value)) {\n            // Excel does not support positive/negative infinities,\n            // rather, it gives a #DIV/0! error in these cases.\n            setCellErrorValue(FormulaError.DIV0.getCode());\n        } else if (Double.isNaN(value)){\n            setCellErrorValue(FormulaError.NUM.getCode());\n        } else {\n            ensureTypeOrFormulaType(CellType.NUMERIC);\n            if(_value.getType()==CellType.FORMULA)\n                ((NumericFormulaValue)_value).setPreEvaluatedValue(value);\n            else\n                ((NumericValue)_value).setValue(value);\n        }\n    }\n\n    /**\n     * Converts the supplied date to its equivalent Excel numeric value and sets\n     * that into the cell.\n     * <p>\n     * <b>Note</b> - There is actually no 'DATE' cell type in Excel. In many\n     * cases (when entering date values), Excel automatically adjusts the\n     * <i>cell style</i> to some date format, creating the illusion that the cell\n     * data type is now something besides {@link CellType#NUMERIC}.  POI\n     * does not attempt to replicate this behaviour.  To make a numeric cell\n     * display as a date, use {@link #setCellStyle(CellStyle)} etc.\n     *\n     * @param value the numeric value to set this cell to.  For formulas we'll set the\n     *        precalculated value, for numerics we'll set its value. For other types we\n     *        will change the cell to a numerics cell and set its value.\n     */\n    @Override\n    public void setCellValue(Date value) {\n        if(value == null) {\n            setCellType(CellType.BLANK);\n            return;\n        }\n\n        boolean date1904 = getSheet().getWorkbook().isDate1904();\n        setCellValue(DateUtil.getExcelDate(value, date1904));\n    }\n\n    /**\n     * Set a date value for the cell. Excel treats dates as numeric so you will need to format the cell as\n     * a date.\n     * <p>\n     * This will set the cell value based on the Calendar's timezone. As Excel\n     * does not support timezones this means that both 20:00+03:00 and\n     * 20:00-03:00 will be reported as the same value (20:00) even that there\n     * are 6 hours difference between the two times. This difference can be\n     * preserved by using <code>setCellValue(value.getTime())</code> which will\n     * automatically shift the times to the default timezone.\n     * </p>\n     *\n     * @param value  the date value to set this cell to.  For formulas we'll set the\n     *        precalculated value, for numerics we'll set its value. For othertypes we\n     *        will change the cell to a numeric cell and set its value.\n     */\n    @Override\n    public void setCellValue(Calendar value) {\n        if(value == null) {\n            setCellType(CellType.BLANK);\n            return;\n        }\n\n        boolean date1904 = getSheet().getWorkbook().isDate1904();\n        setCellValue( DateUtil.getExcelDate(value, date1904 ));\n    }\n\n    /**\n     * Set a rich string value for the cell.\n     *\n     * @param value  value to set the cell to.  For formulas: we'll set the formula\n     * string, for String cells: we'll set its value.  For other types we will\n     * change the cell to a string cell and set its value.\n     * If value is null then we will change the cell to a Blank cell.\n     */\n    @Override\n    public void setCellValue(RichTextString value)\n    {\n        XSSFRichTextString xvalue = (XSSFRichTextString)value;\n\n        if (xvalue != null && xvalue.getString() != null) {\n            ensureRichTextStringType();\n\n            if (xvalue.length() > SpreadsheetVersion.EXCEL2007.getMaxTextLength()) {\n                throw new IllegalArgumentException(\"The maximum length of cell contents (text) is 32,767 characters\");\n            }\n\n            if(_value instanceof RichTextStringFormulaValue) {\n                ((RichTextStringFormulaValue) _value).setPreEvaluatedValue(xvalue);\n            } else {\n                ((RichTextValue) _value).setValue(xvalue);\n            }\n        } else {\n            setCellType(CellType.BLANK);\n        }\n    }\n\n    /**\n     * Set a string value for the cell.\n     *\n     * @param value  value to set the cell to.  For formulas we'll set the formula\n     * string, for String cells we'll set its value.  For other types we will\n     * change the cell to a string cell and set its value.\n     * If value is null then we will change the cell to a Blank cell.\n     */\n    @Override\n    public void setCellValue(String value)\n    {\n        if (value != null) {\n            ensureTypeOrFormulaType(CellType.STRING);\n            \n            if (value.length() > SpreadsheetVersion.EXCEL2007.getMaxTextLength()) {\n                throw new IllegalArgumentException(\"The maximum length of cell contents (text) is 32,767 characters\");\n            }\n    \n            if(_value.getType()==CellType.FORMULA)\n                if(_value instanceof NumericFormulaValue) {\n                    ((NumericFormulaValue) _value).setPreEvaluatedValue(Double.parseDouble(value));\n                } else if(_value instanceof RichTextStringFormulaValue) {\n                    ((RichTextStringFormulaValue) _value).setPreEvaluatedValue(new XSSFRichTextString(value));\n                } else {\n                    ((StringFormulaValue) _value).setPreEvaluatedValue(value);\n                }\n            else\n                ((PlainStringValue)_value).setValue(value);\n        } else {\n            setCellType(CellType.BLANK);\n        }\n    }\n\n    /**\n     * Sets formula for this cell.\n     * <p>\n     * Note, this method only sets the formula string and does not calculate the formula value.\n     * To set the precalculated value use {@link #setCellValue(double)} or {@link #setCellValue(String)}\n     * </p>\n     *\n     * @param formula the formula to set, e.g. <code>\"SUM(C4:E4)\"</code>.\n     *  If the argument is <code>null</code> then the current formula is removed.\n     * @throws FormulaParseException if the formula has incorrect syntax or is otherwise invalid\n     */\n    @Override\n    public void setCellFormula(String formula) throws FormulaParseException\n    {\n        if(formula == null) {\n            setType(CellType.BLANK);\n            return;\n        }\n\n        ensureFormulaType(computeTypeFromFormula(formula));\n        ((FormulaValue)_value).setValue(formula);\n    }\n    /**\n     * Return a formula for the cell, for example, <code>SUM(C4:E4)</code>\n     *\n     * @return a formula for the cell\n     * @throws IllegalStateException if the cell type returned by {@link #getCellType()} is not CellType.FORMULA\n     */\n    @Override\n    public String getCellFormula()\n    {\n       if(_value.getType()!=CellType.FORMULA)\n           throw typeMismatch(CellType.FORMULA,_value.getType(),false);\n        return ((FormulaValue)_value).getValue();\n    }\n\n    /**\n     * Get the value of the cell as a number.\n     * <p>\n     * For strings we throw an exception. For blank cells we return a 0.\n     * For formulas or error cells we return the precalculated value;\n     * </p>\n     * @return the value of the cell as a number\n     * @throws IllegalStateException if the cell type returned by {@link #getCellType()} is CellType.STRING\n     * @exception NumberFormatException if the cell value isn't a parsable <code>double</code>.\n     * @see org.apache.poi.ss.usermodel.DataFormatter for turning this number into a string similar to that which Excel would render this number as.\n     */\n    @Override\n    public double getNumericCellValue()\n    {\n        CellType cellType = getCellType();\n        switch(cellType) \n        {\n            case BLANK:\n                return 0.0;\n            case FORMULA:\n            {\n                FormulaValue fv=(FormulaValue)_value;\n                if(fv.getFormulaType()!=CellType.NUMERIC)\n                      throw typeMismatch(CellType.NUMERIC, CellType.FORMULA, false);\n                return ((NumericFormulaValue)_value).getPreEvaluatedValue();\n            }\n            case NUMERIC:\n                return ((NumericValue)_value).getValue();\n            default:\n                throw typeMismatch(CellType.NUMERIC, cellType, false);\n        }\n    }\n\n    /**\n     * Get the value of the cell as a date.\n     * <p>\n     * For strings we throw an exception. For blank cells we return a null.\n     * </p>\n     * @return the value of the cell as a date\n     * @throws IllegalStateException if the cell type returned by {@link #getCellType()} is CellType.STRING\n     * @exception NumberFormatException if the cell value isn't a parsable <code>double</code>.\n     * @see org.apache.poi.ss.usermodel.DataFormatter for formatting  this date into a string similar to how excel does.\n     */\n    @Override\n    public Date getDateCellValue()\n    {\n        CellType cellType = getCellType();\n        if (cellType == CellType.BLANK) \n        {\n            return null;\n        }\n\n        double value = getNumericCellValue();\n        boolean date1904 = getSheet().getWorkbook().isDate1904();\n        return DateUtil.getJavaDate(value, date1904);\n    }\n\n    /**\n     * Get the value of the cell as a XSSFRichTextString\n     * <p>\n     * For numeric cells we throw an exception. For blank cells we return an empty string.\n     * For formula cells we return the pre-calculated value if a string, otherwise an exception.\n     * </p>\n     * @return the value of the cell as a XSSFRichTextString\n     */\n    @Override\n    public RichTextString getRichStringCellValue()\n    {\n        CellType cellType = getCellType();\n        if(getCellType() != CellType.STRING)\n            throw typeMismatch(CellType.STRING, cellType, false);\n\n        StringValue sval = (StringValue)_value;\n        if(sval.isRichText())\n            return ((RichTextValue)_value).getValue();\n        else {\n            String plainText = getStringCellValue();\n            return getSheet().getWorkbook().getCreationHelper().createRichTextString(plainText);\n        }\n    }\n\n\n    /**\n     * Get the value of the cell as a string\n     * <p>\n     * For numeric cells we throw an exception. For blank cells we return an empty string.\n     * For formulaCells that are not string Formulas, we throw an exception.\n     * </p>\n     * @return the value of the cell as a string\n     */\n    @Override\n    public String getStringCellValue()\n    {\n        CellType cellType = getCellType();\n        switch(cellType) \n        {\n            case BLANK:\n                return \"\";\n            case FORMULA:\n            {\n                FormulaValue fv=(FormulaValue)_value;\n                if(fv.getFormulaType()!=CellType.STRING)\n                      throw typeMismatch(CellType.STRING, CellType.FORMULA, false);\n                if(_value instanceof RichTextStringFormulaValue) {\n                    return ((RichTextStringFormulaValue) _value).getPreEvaluatedValue().getString();\n                } else {\n                    return ((StringFormulaValue) _value).getPreEvaluatedValue();\n                }\n            }\n            case STRING:\n            {\n                if(((StringValue)_value).isRichText())\n                    return ((RichTextValue)_value).getValue().getString();\n                else\n                    return ((PlainStringValue)_value).getValue();\n            }\n            default:\n                throw typeMismatch(CellType.STRING, cellType, false);\n        }\n    }\n\n    /**\n     * Set a boolean value for the cell\n     *\n     * @param value the boolean value to set this cell to.  For formulas we'll set the\n     *        precalculated value, for booleans we'll set its value. For other types we\n     *        will change the cell to a boolean cell and set its value.\n     */\n    @Override\n    public void setCellValue(boolean value)\n    {\n        ensureTypeOrFormulaType(CellType.BOOLEAN);\n        if(_value.getType()==CellType.FORMULA)\n            ((BooleanFormulaValue)_value).setPreEvaluatedValue(value);\n        else\n            ((BooleanValue)_value).setValue(value);\n    }\n\n    /**\n     * Set a error value for the cell\n     *\n     * @param value the error value to set this cell to.  For formulas we'll set the\n     *        precalculated value , for errors we'll set\n     *        its value. For other types we will change the cell to an error\n     *        cell and set its value.\n     * @see org.apache.poi.ss.usermodel.FormulaError\n     */\n    @Override\n    public void setCellErrorValue(byte value) {\n        // for formulas, we want to keep the type and only have an ERROR as formula value\n        if(_value.getType()==CellType.FORMULA) {\n            // ensure that the type is \"ERROR\"\n            setFormulaType(CellType.ERROR);\n\n            // populate the value\n            ((ErrorFormulaValue) _value).setPreEvaluatedValue(value);\n        } else {\n            ensureTypeOrFormulaType(CellType.ERROR);\n            ((ErrorValue) _value).setValue(value);\n        }\n    }\n\n    /**\n     * Get the value of the cell as a boolean.\n     * <p>\n     * For strings, numbers, and errors, we throw an exception. For blank cells we return a false.\n     * </p>\n     * @return the value of the cell as a boolean\n     * @throws IllegalStateException if the cell type returned by {@link #getCellType()}\n     *   is not CellType.BOOLEAN, CellType.BLANK or CellType.FORMULA\n     */\n    @Override\n    public boolean getBooleanCellValue()\n    {\n        CellType cellType = getCellType();\n        switch(cellType) \n        {\n            case BLANK:\n                return false;\n            case FORMULA:\n            {\n                FormulaValue fv=(FormulaValue)_value;\n                if(fv.getFormulaType()!=CellType.BOOLEAN)\n                      throw typeMismatch(CellType.BOOLEAN, CellType.FORMULA, false);\n                return ((BooleanFormulaValue)_value).getPreEvaluatedValue();\n            }\n            case BOOLEAN:\n            {\n                return ((BooleanValue)_value).getValue();\n            }\n            default:\n                throw typeMismatch(CellType.BOOLEAN, cellType, false);\n        }\n    }\n\n    /**\n     * Get the value of the cell as an error code.\n     * <p>\n     * For strings, numbers, and booleans, we throw an exception.\n     * For blank cells we return a 0.\n     * </p>\n     *\n     * @return the value of the cell as an error code\n     * @throws IllegalStateException if the cell type returned by {@link #getCellType()} isn't CellType.ERROR\n     * @see org.apache.poi.ss.usermodel.FormulaError for error codes\n     */\n    @Override\n    public byte getErrorCellValue()\n    {\n        CellType cellType = getCellType();\n        switch(cellType) \n        {\n            case BLANK:\n                return 0;\n            case FORMULA:\n            {\n                FormulaValue fv=(FormulaValue)_value;\n                if(fv.getFormulaType()!=CellType.ERROR)\n                      throw typeMismatch(CellType.ERROR, CellType.FORMULA, false);\n                return ((ErrorFormulaValue)_value).getPreEvaluatedValue();\n            }\n            case ERROR:\n            {\n                return ((ErrorValue)_value).getValue();\n            }\n            default:\n                throw typeMismatch(CellType.ERROR, cellType, false);\n        }\n    }\n\n    /**\n     * <p>Set the style for the cell.  The style should be an CellStyle created/retreived from\n     * the Workbook.</p>\n     * \n     * <p>To change the style of a cell without affecting other cells that use the same style,\n     * use {@link org.apache.poi.ss.util.CellUtil#setCellStyleProperties(Cell, Map)}</p>\n     * \n     * @param style  reference contained in the workbook.\n     * If the value is null then the style information is removed causing the cell to used the default workbook style.\n     * @see org.apache.poi.ss.usermodel.Workbook#createCellStyle\n     */\n    @Override\n    public void setCellStyle(CellStyle style)\n    {\n        _style=style;\n    }\n\n    /**\n     * Return the cell's style.\n     *\n     * @return the cell's style. Always not-null. Default cell style has zero index and can be obtained as\n     * <code>workbook.getCellStyleAt(0)</code>\n     * @see org.apache.poi.ss.usermodel.Workbook#getCellStyleAt(int)\n     */\n    @Override\n    public CellStyle getCellStyle()\n    {\n        if(_style == null){\n            SXSSFWorkbook wb = (SXSSFWorkbook)getRow().getSheet().getWorkbook();\n            return wb.getCellStyleAt(0);\n        } else {\n            return _style;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setAsActiveCell()\n    {\n        getSheet().setActiveCell(getAddress());\n    }\n\n    /**\n     * Assign a comment to this cell\n     *\n     * @param comment comment associated with this cell\n     */\n    @Override\n    public void setCellComment(Comment comment)\n    {\n        setProperty(Property.COMMENT,comment);\n    }\n\n    /**\n     * Returns comment associated with this cell\n     *\n     * @return comment associated with this cell or <code>null</code> if not found\n     */\n    @Override\n    public Comment getCellComment()\n    {\n        return (Comment)getPropertyValue(Property.COMMENT);\n    }\n\n    /**\n     * Removes the comment for this cell, if there is one.\n     */\n    @Override\n    public void removeCellComment()\n    {\n        removeProperty(Property.COMMENT);\n    }\n\n    /**\n     * @return hyperlink associated with this cell or <code>null</code> if not found\n     */\n    @Override\n    public Hyperlink getHyperlink()\n    {\n        return (Hyperlink)getPropertyValue(Property.HYPERLINK);\n    }\n\n    /**\n     * Assign a hyperlink to this cell. If the supplied hyperlink is null, the\n     * hyperlink for this cell will be removed.\n     *\n     * @param link hyperlink associated with this cell\n     */\n    @Override\n    public void setHyperlink(Hyperlink link)\n    {\n        if (link == null) {\n            removeHyperlink();\n            return;\n        }\n\n        setProperty(Property.HYPERLINK,link);\n\n        XSSFHyperlink xssfobj = (XSSFHyperlink)link;\n        // Assign to us\n        CellReference ref = new CellReference(getRowIndex(), getColumnIndex());\n        xssfobj.setCellReference( ref );\n\n        // Add to the lists\n        getSheet()._sh.addHyperlink(xssfobj);\n    }\n\n    /**\n     * Removes the hyperlink for this cell, if there is one.\n     */\n    @Override\n    public void removeHyperlink()\n    {\n        removeProperty(Property.HYPERLINK);\n\n        getSheet()._sh.removeHyperlink(getRowIndex(), getColumnIndex());\n    }\n\n    /**\n     * Only valid for array formula cells\n     *\n     * @return range of the array formula group that the cell belongs to.\n     */\n// TODO: What is this?\n    @NotImplemented\n    public CellRangeAddress getArrayFormulaRange()\n    {\n        return null;\n    }\n\n    /**\n     * @return <code>true</code> if this cell is part of group of cells having a common array formula.\n     */\n//TODO: What is this?\n    @NotImplemented\n    public boolean isPartOfArrayFormulaGroup()\n    {\n        return false;\n    }\n//end of interface implementation\n\n    /**\n     * Returns a string representation of the cell\n     * <p>\n     * Formula cells return the formula string, rather than the formula result.\n     * Dates are displayed in dd-MMM-yyyy format\n     * Errors are displayed as #ERR&lt;errIdx&gt;\n     * </p>\n     */\n    @Override\n    public String toString() {\n        switch (getCellType()) {\n            case BLANK:\n                return \"\";\n            case BOOLEAN:\n                return getBooleanCellValue() ? \"TRUE\" : \"FALSE\";\n            case ERROR:\n                return ErrorEval.getText(getErrorCellValue());\n            case FORMULA:\n                return getCellFormula();\n            case NUMERIC:\n                if (DateUtil.isCellDateFormatted(this)) {\n                    DateFormat sdf = new SimpleDateFormat(\"dd-MMM-yyyy\", LocaleUtil.getUserLocale());\n                    sdf.setTimeZone(LocaleUtil.getUserTimeZone());\n                    return sdf.format(getDateCellValue());\n                }\n                return getNumericCellValue() + \"\";\n            case STRING:\n                return getRichStringCellValue().toString();\n            default:\n                return \"Unknown Cell Type: \" + getCellType();\n        }\n    }\n\n    /*package*/ void removeProperty(int type)\n    {\n        Property current=_firstProperty;\n        Property previous=null;\n        while(current!=null&&current.getType()!=type)\n        {\n            previous=current;\n            current=current._next;\n        }\n        if(current!=null)\n        {\n            if(previous!=null)\n            {\n                previous._next=current._next;\n            }\n            else\n            {\n                _firstProperty=current._next;\n            }\n        }\n    }\n    /*package*/ void setProperty(int type,Object value)\n    {\n        Property current=_firstProperty;\n        Property previous=null;\n        while(current!=null&&current.getType()!=type)\n        {\n            previous=current;\n            current=current._next;\n        }\n        if(current!=null)\n        {\n            current.setValue(value);\n        }\n        else\n        {\n            switch(type)\n            {\n                case Property.COMMENT:\n                {\n                    current=new CommentProperty(value);\n                    break;\n                }\n                case Property.HYPERLINK:\n                {\n                    current=new HyperlinkProperty(value);\n                    break;\n                }\n                default:\n                {\n                    throw new IllegalArgumentException(\"Invalid type: \" + type);\n                }\n            }\n            if(previous!=null)\n            {\n                previous._next=current;\n            }\n            else\n            {\n                _firstProperty=current;\n            }\n        }\n    }\n    /*package*/ Object getPropertyValue(int type)\n    {\n        return getPropertyValue(type,null);\n    }\n    /*package*/ Object getPropertyValue(int type,String defaultValue)\n    {\n        Property current=_firstProperty;\n        while(current!=null&&current.getType()!=type) current=current._next;\n        return current==null?defaultValue:current.getValue();\n    }\n    /*package*/ void ensurePlainStringType()\n    {\n        if(_value.getType()!=CellType.STRING\n           ||((StringValue)_value).isRichText())\n            _value = new PlainStringValue();\n    }\n    /*package*/ void ensureRichTextStringType()\n    {\n        // don't change cell type for formulas\n        if(_value.getType() == CellType.FORMULA) {\n            String formula = ((FormulaValue)_value).getValue();\n            _value = new RichTextStringFormulaValue();\n            ((RichTextStringFormulaValue) _value).setValue(formula);\n        } else if(_value.getType()!=CellType.STRING ||\n                !((StringValue)_value).isRichText()) {\n            _value = new RichTextValue();\n        }\n    }\n    /*package*/ void ensureType(CellType type)\n    {\n        if(_value.getType()!=type)\n            setType(type);\n    }\n    /*package*/ void ensureFormulaType(CellType type)\n    {\n        if(_value.getType()!=CellType.FORMULA\n           ||((FormulaValue)_value).getFormulaType()!=type)\n            setFormulaType(type);\n    }\n    /*\n     * Sets the cell type to type if it is different\n     */\n    /*package*/ void ensureTypeOrFormulaType(CellType type)\n    {\n        if(_value.getType()==type)\n        {\n            if(type==CellType.STRING&&((StringValue)_value).isRichText())\n                setType(CellType.STRING);\n            return;\n        }\n        if(_value.getType()==CellType.FORMULA)\n        {\n            if(((FormulaValue)_value).getFormulaType()==type)\n                return;\n            setFormulaType(type); // once a formula, always a formula\n            return;\n        }\n        setType(type);\n    }\n    /**\n     * changes the cell type to the specified type, and resets the value to the default value for that type\n     * If cell type is the same as specified type, this will reset the value to the default value for that type\n     *\n     * @param type the cell type to set\n     * @throws IllegalArgumentException if type is not a recognized type\n     */\n    /*package*/ void setType(CellType type)\n    {\n        switch(type)\n        {\n            case NUMERIC:\n            {\n                _value = new NumericValue();\n                break;\n            }\n            case STRING:\n            {\n                PlainStringValue sval = new PlainStringValue();\n                if(_value != null){\n                    // if a cell is not blank then convert the old value to string\n                    String str = convertCellValueToString();\n                    sval.setValue(str);\n                }\n                _value = sval;\n                break;\n            }\n            case FORMULA:\n            {\n                _value = new NumericFormulaValue();\n                break;\n            }\n            case BLANK:\n            {\n                _value = new BlankValue();\n                break;\n            }\n            case BOOLEAN:\n            {\n                BooleanValue bval = new BooleanValue();\n                if(_value != null){\n                    // if a cell is not blank then convert the old value to string\n                    boolean val = convertCellValueToBoolean();\n                    bval.setValue(val);\n                }\n                _value = bval;\n                break;\n            }\n            case ERROR:\n            {\n                _value = new ErrorValue();\n                break;\n            }\n            default:\n            {\n                throw new IllegalArgumentException(\"Illegal type \" + type);\n            }\n        }\n    }\n    /*package*/ void setFormulaType(CellType type)\n    {\n        Value prevValue = _value;\n        switch(type)\n        {\n            case NUMERIC:\n            {\n                _value = new NumericFormulaValue();\n                break;\n            }\n            case STRING:\n            {\n                _value = new StringFormulaValue();\n                break;\n            }\n            case BOOLEAN:\n            {\n                _value = new BooleanFormulaValue();\n                break;\n            }\n            case ERROR:\n            {\n                _value = new ErrorFormulaValue();\n                break;\n            }\n            default:\n            {\n                throw new IllegalArgumentException(\"Illegal type \" + type);\n            }\n        }\n\n        // if we had a Formula before, we should copy over the _value of the formula\n        if(prevValue instanceof FormulaValue) {\n            ((FormulaValue)_value)._value = ((FormulaValue)prevValue)._value;\n        }\n    }\n\n//TODO: implement this correctly\n    @NotImplemented\n    /*package*/ CellType computeTypeFromFormula(String formula)\n    {\n        return CellType.NUMERIC;\n    }\n//COPIED FROM https://svn.apache.org/repos/asf/poi/trunk/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFCell.java since the functions are declared private there\n    /**\n     * Used to help format error messages\n     */\n    private static RuntimeException typeMismatch(CellType expectedTypeCode, CellType actualTypeCode, boolean isFormulaCell) {\n        String msg = \"Cannot get a \" + expectedTypeCode + \" value from a \" + actualTypeCode\n                + \" \" + (isFormulaCell ? \"formula \" : \"\") + \"cell\";\n        return new IllegalStateException(msg);\n    }\n\n    private boolean convertCellValueToBoolean() {\n        CellType cellType = getCellType();\n\n        if (cellType == CellType.FORMULA) {\n            cellType = getCachedFormulaResultType();\n        }\n\n        switch (cellType) {\n            case BOOLEAN:\n                return getBooleanCellValue();\n            case STRING:\n\n                String text = getStringCellValue();\n                return Boolean.parseBoolean(text);\n            case NUMERIC:\n                return getNumericCellValue() != 0;\n            case ERROR:\n            case BLANK:\n                return false;\n            default: throw new RuntimeException(\"Unexpected cell type (\" + cellType + \")\");\n        }\n        \n    }\n    private String convertCellValueToString() {\n        CellType cellType = getCellType();\n        return convertCellValueToString(cellType);\n    }\n    private String convertCellValueToString(CellType cellType) {\n        switch (cellType) {\n            case BLANK:\n                return \"\";\n            case BOOLEAN:\n                return getBooleanCellValue() ? \"TRUE\" : \"FALSE\";\n            case STRING:\n                return getStringCellValue();\n            case NUMERIC:\n                return Double.toString( getNumericCellValue() );\n            case ERROR:\n                byte errVal = getErrorCellValue();\n                return FormulaError.forInt(errVal).getString();\n            case FORMULA:\n                if (_value != null) {\n                    FormulaValue fv = (FormulaValue)_value;\n                    if (fv.getFormulaType() != CellType.FORMULA) {\n                        return convertCellValueToString(fv.getFormulaType());\n                    }\n                }\n                return \"\";\n            default:\n                throw new IllegalStateException(\"Unexpected cell type (\" + cellType + \")\");\n        }\n    }\n\n//END OF COPIED CODE\n\n    static abstract class Property\n    {\n        static final int COMMENT=1;\n        static final int HYPERLINK=2;\n        Object _value;\n        Property _next;\n        public Property(Object value)\n        {\n            _value = value;\n        }\n        abstract int getType();\n        void setValue(Object value)\n        {\n            _value = value;\n        }\n        Object getValue()\n        {\n            return _value;\n        }\n    }\n    static class CommentProperty extends Property\n    {\n        public CommentProperty(Object value)\n        {\n            super(value);\n        }\n        @Override\n        public int getType()\n        {\n            return COMMENT;\n        }\n    }\n    static class HyperlinkProperty extends Property\n    {\n        public HyperlinkProperty(Object value)\n        {\n            super(value);\n        }\n        @Override\n        public int getType()\n        {\n            return HYPERLINK;\n        }\n    }\n    interface Value\n    {\n        CellType getType();\n    }\n    static class NumericValue implements Value\n    {\n        double _value;\n        public CellType getType()\n        {\n            return CellType.NUMERIC;\n        }\n        void setValue(double value)\n        {\n            _value = value;\n        }\n        double getValue()\n        {\n            return _value;\n        }\n    }\n    static abstract class StringValue implements Value\n    {\n        public CellType getType()\n        {\n            return CellType.STRING;\n        }\n//We cannot introduce a new type CellType.RICH_TEXT because the types are public so we have to make rich text as a type of string\n        abstract boolean isRichText(); // using the POI style which seems to avoid \"instanceof\".\n    }\n    static class PlainStringValue extends StringValue\n    {\n        String _value;\n        void setValue(String value)\n        {\n            _value = value;\n        }\n        String getValue()\n        {\n            return _value;\n        }\n        @Override\n        boolean isRichText()\n        {\n            return false;\n        }\n    }\n    static class RichTextValue extends StringValue\n    {\n        RichTextString _value;\n        @Override\n        public CellType getType()\n        {\n            return CellType.STRING;\n        }\n        void setValue(RichTextString value)\n        {\n            _value = value;\n        }\n        RichTextString getValue()\n        {\n            return _value;\n        }\n        @Override\n        boolean isRichText()\n        {\n            return true;\n        }\n    }\n    static abstract class FormulaValue implements Value\n    {\n        String _value;\n        public CellType getType()\n        {\n            return CellType.FORMULA;\n        }\n        void setValue(String value)\n        {\n            _value = value;\n        }\n        String getValue()\n        {\n            return _value;\n        }\n        abstract CellType getFormulaType();\n    }\n    static class NumericFormulaValue extends FormulaValue\n    {\n        double _preEvaluatedValue;\n        @Override\n        CellType getFormulaType()\n        {\n            return CellType.NUMERIC;\n        }\n        void setPreEvaluatedValue(double value)\n        {\n            _preEvaluatedValue=value;\n        }\n        double getPreEvaluatedValue()\n        {\n            return _preEvaluatedValue;\n        }\n    }\n    static class StringFormulaValue extends FormulaValue\n    {\n        String _preEvaluatedValue;\n        @Override\n        CellType getFormulaType()\n        {\n            return CellType.STRING;\n        }\n        void setPreEvaluatedValue(String value)\n        {\n            _preEvaluatedValue=value;\n        }\n        String getPreEvaluatedValue()\n        {\n            return _preEvaluatedValue;\n        }\n    }\n    static class RichTextStringFormulaValue extends FormulaValue\n    {\n        RichTextString _preEvaluatedValue;\n        @Override\n        CellType getFormulaType()\n        {\n            return CellType.STRING;\n        }\n        void setPreEvaluatedValue(RichTextString value)\n        {\n            _preEvaluatedValue=value;\n        }\n        RichTextString getPreEvaluatedValue()\n        {\n            return _preEvaluatedValue;\n        }\n    }\n    static class BooleanFormulaValue extends FormulaValue\n    {\n        boolean _preEvaluatedValue;\n        @Override\n        CellType getFormulaType()\n        {\n            return CellType.BOOLEAN;\n        }\n        void setPreEvaluatedValue(boolean value)\n        {\n            _preEvaluatedValue=value;\n        }\n        boolean getPreEvaluatedValue()\n        {\n            return _preEvaluatedValue;\n        }\n    }\n    static class ErrorFormulaValue extends FormulaValue\n    {\n        byte _preEvaluatedValue;\n        @Override\n        CellType getFormulaType()\n        {\n            return CellType.ERROR;\n        }\n        void setPreEvaluatedValue(byte value)\n        {\n            _preEvaluatedValue=value;\n        }\n        byte getPreEvaluatedValue()\n        {\n            return _preEvaluatedValue;\n        }\n    }\n    static class BlankValue implements Value\n    {\n        public CellType getType()\n        {\n            return CellType.BLANK;\n        }\n    }\n    static class BooleanValue implements Value\n    {\n        boolean _value;\n        public CellType getType()\n        {\n            return CellType.BOOLEAN;\n        }\n        void setValue(boolean value)\n        {\n            _value = value;\n        }\n        boolean getValue()\n        {\n            return _value;\n        }\n    }\n    static class ErrorValue implements Value\n    {\n        byte _value;\n        public CellType getType()\n        {\n            return CellType.ERROR;\n        }\n        void setValue(byte value)\n        {\n            _value = value;\n        }\n        byte getValue()\n        {\n            return _value;\n        }\n    }\n}",
    "target": 0,
    "language": "java",
    "dataset": "A-Manually-Curated-Dataset-of-Vulnerability-Introducing-Commits-in-Java",
    "idx": 800063,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "    protected void initDocumentParser() throws ParserConfigurationException  {\n\n        Object source = resolveSchemaSource();\n\n        DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n\n        docBuilderFactory.setValidating(true);\n\n        docBuilderFactory.setNamespaceAware(true);\n        \n        docBuilderFactory.setAttribute(\"http://java.sun.com/xml/jaxp/properties/schemaLanguage\", \"http://www.w3.org/2001/XMLSchema\");\n\n        docBuilderFactory.setAttribute(\"http://java.sun.com/xml/jaxp/properties/schemaSource\", source);\n        \n        docBuilder = docBuilderFactory.newDocumentBuilder();\n        \n        docBuilder.setErrorHandler(this);\n        \n        NamespaceContext nsContext = new NamespaceContext()\n        {\n\n            public String getPrefix(String namespaceURI)\n          {\n              throw new UnsupportedOperationException();\n          }\n\n          public String getNamespaceURI(String prefix)\n          {\n                if (prefix != null){\n                    switch(prefix){\n                        case XMLConstants.XML_NS_PREFIX:\n                            return XMLConstants.XML_NS_URI;\n                        case \"q\":\n                            return QUARTZ_NS;\n                        case XMLConstants.XMLNS_ATTRIBUTE:\n                            return XMLConstants.XMLNS_ATTRIBUTE_NS_URI;\n                        default:\n                            break;\n                    }\n\n                    return XMLConstants.NULL_NS_URI;\n                }else{\n                    throw new IllegalArgumentException(\"Null prefix\");\n                }\n          }\n        \n          public Iterator<?> getPrefixes(String namespaceURI)\n          {\n              throw new UnsupportedOperationException();\n          }\n        \n        }; \n        \n        XPathFactory xpathFactory = XPathFactory.newInstance();\n        xpath = xpathFactory.newXPath();\n        xpath.setNamespaceContext(nsContext);\n    }\n",
    "target": 1,
    "language": "java",
    "dataset": "VJBench",
    "idx": 200074,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "    protected void initDocumentParser() throws ParserConfigurationException  {\n\n        Object source = resolveSchemaSource();\n\n        DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n\n        docBuilderFactory.setNamespaceAware(true);\n        \n        docBuilderFactory.setAttribute(\"http://java.sun.com/xml/jaxp/properties/schemaLanguage\", \"http://www.w3.org/2001/XMLSchema\");\n\n        docBuilderFactory.setAttribute(\"http://java.sun.com/xml/jaxp/properties/schemaSource\", source);\n\n        docBuilderFactory.setValidating(true);\n\n        docBuilderFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n        docBuilderFactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n        docBuilderFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        docBuilderFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n        docBuilderFactory.setXIncludeAware(false);\n        docBuilderFactory.setExpandEntityReferences(false);\n\n        \n        docBuilder = docBuilderFactory.newDocumentBuilder();\n        \n        docBuilder.setErrorHandler(this);\n        \n        NamespaceContext nsContext = new NamespaceContext()\n        {\n\n            public String getPrefix(String namespaceURI)\n          {\n              throw new UnsupportedOperationException();\n          }\n\n          public String getNamespaceURI(String prefix)\n          {\n                if (prefix != null){\n                    switch(prefix){\n                        case XMLConstants.XML_NS_PREFIX:\n                            return XMLConstants.XML_NS_URI;\n                        case \"q\":\n                            return QUARTZ_NS;\n                        case XMLConstants.XMLNS_ATTRIBUTE:\n                            return XMLConstants.XMLNS_ATTRIBUTE_NS_URI;\n                        default:\n                            break;\n                    }\n\n                    return XMLConstants.NULL_NS_URI;\n                }else{\n                    throw new IllegalArgumentException(\"Null prefix\");\n                }\n          }\n        \n          public Iterator<?> getPrefixes(String namespaceURI)\n          {\n              throw new UnsupportedOperationException();\n          }\n        \n        }; \n        \n        XPathFactory xpathFactory = XPathFactory.newInstance();\n        xpath = xpathFactory.newXPath();\n        xpath.setNamespaceContext(nsContext);\n    }\n",
    "target": 0,
    "language": "java",
    "dataset": "VJBench",
    "idx": 200075,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "package com.fasterxml.jackson.databind.ext;\n\nimport java.io.StringReader;\n\nimport javax.xml.parsers.DocumentBuilderFactory;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.xml.sax.InputSource;\n\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.deser.std.FromStringDeserializer;\n\n/**\n * Base for serializers that allows parsing DOM Documents from JSON Strings.\n * Nominal type can be either {@link org.w3c.dom.Node} or\n * {@link org.w3c.dom.Document}.\n */\npublic abstract class DOMDeserializer<T> extends FromStringDeserializer<T>\n{\n    private static final long serialVersionUID = 1L;\n\n    private final static DocumentBuilderFactory _parserFactory;\n    static {\n        _parserFactory = DocumentBuilderFactory.newInstance();\n        // yup, only cave men do XML without recognizing namespaces...\n        _parserFactory.setNamespaceAware(true);\n    }\n\n    protected DOMDeserializer(Class<T> cls) { super(cls); }\n\n    @Override\n    public abstract T _deserialize(String value, DeserializationContext ctxt);\n\n    protected final Document parse(String value) throws IllegalArgumentException {\n        try {\n            return _parserFactory.newDocumentBuilder().parse(new InputSource(new StringReader(value)));\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Failed to parse JSON String as XML: \"+e.getMessage(), e);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Concrete deserializers\n    /**********************************************************\n     */\n    \n    public static class NodeDeserializer extends DOMDeserializer<Node> {\n        private static final long serialVersionUID = 1L;\n        public NodeDeserializer() { super(Node.class); }\n        @Override\n        public Node _deserialize(String value, DeserializationContext ctxt) throws IllegalArgumentException {\n            return parse(value);\n        }\n    }    \n\n    public static class DocumentDeserializer extends DOMDeserializer<Document> {\n        private static final long serialVersionUID = 1L;\n        public DocumentDeserializer() { super(Document.class); }\n        @Override\n        public Document _deserialize(String value, DeserializationContext ctxt) throws IllegalArgumentException {\n            return parse(value);\n        }\n    }    \n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700200,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "package com.fasterxml.jackson.databind.ext;\n\nimport java.io.StringReader;\n\nimport javax.xml.XMLConstants;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.xml.sax.InputSource;\n\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.deser.std.FromStringDeserializer;\n\n/**\n * Base for serializers that allows parsing DOM Documents from JSON Strings.\n * Nominal type can be either {@link org.w3c.dom.Node} or\n * {@link org.w3c.dom.Document}.\n */\npublic abstract class DOMDeserializer<T> extends FromStringDeserializer<T>\n{\n    private static final long serialVersionUID = 1L;\n\n    private final static DocumentBuilderFactory _parserFactory;\n    static {\n        _parserFactory = DocumentBuilderFactory.newInstance();\n        // yup, only cave men do XML without recognizing namespaces...\n        _parserFactory.setNamespaceAware(true);\n        // [databind#1279]: make sure external entities NOT expanded by default\n        _parserFactory.setExpandEntityReferences(false);\n        // ... and in general, aim for \"safety\"\n        try {\n            _parserFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n        } catch(ParserConfigurationException pce) {\n            // not much point to do anything; could log but...\n        } catch (Error e) {\n            // 14-Jul-2016, tatu: Not sure how or why, but during code coverage runs\n            //   (via Cobertura) we get `java.lang.AbstractMethodError` so... ignore that too\n        }\n\n        // [databind#2589] add two more settings just in case\n        try {\n            _parserFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n        } catch (Throwable t) { } // as per previous one, nothing much to do\n        try {\n            _parserFactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n        } catch (Throwable t) { } // as per previous one, nothing much to do\n    }\n\n    protected DOMDeserializer(Class<T> cls) { super(cls); }\n\n    @Override\n    public abstract T _deserialize(String value, DeserializationContext ctxt);\n\n    protected final Document parse(String value) throws IllegalArgumentException {\n        try {\n            return _parserFactory.newDocumentBuilder().parse(new InputSource(new StringReader(value)));\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Failed to parse JSON String as XML: \"+e.getMessage(), e);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Concrete deserializers\n    /**********************************************************\n     */\n    \n    public static class NodeDeserializer extends DOMDeserializer<Node> {\n        private static final long serialVersionUID = 1L;\n        public NodeDeserializer() { super(Node.class); }\n        @Override\n        public Node _deserialize(String value, DeserializationContext ctxt) throws IllegalArgumentException {\n            return parse(value);\n        }\n    }    \n\n    public static class DocumentDeserializer extends DOMDeserializer<Document> {\n        private static final long serialVersionUID = 1L;\n        public DocumentDeserializer() { super(Document.class); }\n        @Override\n        public Document _deserialize(String value, DeserializationContext ctxt) throws IllegalArgumentException {\n            return parse(value);\n        }\n    }    \n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700201,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "/*\n * Copyright 2019 EPAM Systems\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.epam.ta.reportportal.core.imprt.impl.junit;\n\nimport com.epam.ta.reportportal.commons.ReportPortalUser;\nimport com.epam.ta.reportportal.core.imprt.impl.ParseResults;\nimport com.epam.ta.reportportal.exception.ReportPortalException;\nimport com.epam.ta.reportportal.ws.model.ErrorType;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.concurrent.Callable;\n\n@Component\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class XunitParseJob implements Callable<ParseResults> {\n\n\t@Autowired\n\tprivate XunitImportHandler handler;\n\n\tprivate InputStream xmlInputStream;\n\n\t@Override\n\tpublic ParseResults call() {\n\t\ttry {\n\t\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\t\t\tSAXParser saxParser = spf.newSAXParser();\n\t\t\tXMLReader reader = saxParser.getXMLReader();\n\n\t\t\t// Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\t// Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-general-entities\n\n\t\t\t// Xerces 2 only - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\t// Using the SAXParserFactory's setFeature\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\n\t\t\tspf.setXIncludeAware(false);\n\t\t\t// Using the XMLReader's setFeature\n\t\t\treader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\treader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n\t\t\tsaxParser.parse(xmlInputStream, handler);\n\t\t} catch (SAXException | IOException | ParserConfigurationException e) {\n\t\t\tthrow new ReportPortalException(ErrorType.PARSING_XML_ERROR, e.getMessage());\n\t\t}\n\t\treturn new ParseResults(handler.getStartSuiteTime(), handler.getCommonDuration());\n\t}\n\n\tpublic XunitParseJob withParameters(ReportPortalUser.ProjectDetails projectDetails, String launchId, ReportPortalUser user,\n\t\t\tInputStream xmlInputStream) {\n\t\tthis.xmlInputStream = xmlInputStream;\n\t\tthis.handler = handler.withParameters(projectDetails, launchId, user);\n\t\treturn this;\n\t}\n\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700262,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "/*\n * Copyright 2019 EPAM Systems\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.epam.ta.reportportal.core.imprt.impl.junit;\n\nimport com.epam.ta.reportportal.commons.ReportPortalUser;\nimport com.epam.ta.reportportal.core.imprt.impl.ParseResults;\nimport com.epam.ta.reportportal.exception.ReportPortalException;\nimport com.epam.ta.reportportal.ws.model.ErrorType;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.concurrent.Callable;\n\n@Component\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class XunitParseJob implements Callable<ParseResults> {\n\n\t@Autowired\n\tprivate XunitImportHandler handler;\n\n\tprivate InputStream xmlInputStream;\n\n\t@Override\n\tpublic ParseResults call() {\n\t\ttry {\n\t\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\t\t\tSAXParser saxParser = spf.newSAXParser();\n\t\t\tXMLReader reader = saxParser.getXMLReader();\n\n\t\t\t// Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\t// Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-general-entities\n\n\t\t\t// Xerces 2 only - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\t// Using the SAXParserFactory's setFeature\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\tspf.setXIncludeAware(false);\n\t\t\t// Using the XMLReader's setFeature\n\t\t\treader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\treader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n\t\t\tsaxParser.parse(xmlInputStream, handler);\n\t\t} catch (SAXException | IOException | ParserConfigurationException e) {\n\t\t\tthrow new ReportPortalException(ErrorType.PARSING_XML_ERROR, e.getMessage());\n\t\t}\n\t\treturn new ParseResults(handler.getStartSuiteTime(), handler.getCommonDuration());\n\t}\n\n\tpublic XunitParseJob withParameters(ReportPortalUser.ProjectDetails projectDetails, String launchId, ReportPortalUser user,\n\t\t\tInputStream xmlInputStream) {\n\t\tthis.xmlInputStream = xmlInputStream;\n\t\tthis.handler = handler.withParameters(projectDetails, launchId, user);\n\t\treturn this;\n\t}\n\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700263,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "/*\n * Copyright 2019 EPAM Systems\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.epam.ta.reportportal.core.imprt.impl.junit;\n\nimport com.epam.ta.reportportal.commons.ReportPortalUser;\nimport com.epam.ta.reportportal.core.imprt.impl.ParseResults;\nimport com.epam.ta.reportportal.exception.ReportPortalException;\nimport com.epam.ta.reportportal.ws.model.ErrorType;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.concurrent.Callable;\n\n@Component\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class XunitParseJob implements Callable<ParseResults> {\n\n\t@Autowired\n\tprivate XunitImportHandler handler;\n\n\tprivate InputStream xmlInputStream;\n\n\t@Override\n\tpublic ParseResults call() {\n\t\ttry {\n\t\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\t\t\tSAXParser saxParser = spf.newSAXParser();\n\t\t\tXMLReader reader = saxParser.getXMLReader();\n\n\t\t\t// Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\t// Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-general-entities\n\n\t\t\t// Xerces 2 only - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\t// Using the SAXParserFactory's setFeature\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\tspf.setXIncludeAware(false);\n\t\t\t// Using the XMLReader's setFeature\n\t\t\treader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\treader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n\t\t\tsaxParser.parse(xmlInputStream, handler);\n\t\t} catch (SAXException | IOException | ParserConfigurationException e) {\n\t\t\tthrow new ReportPortalException(ErrorType.PARSING_XML_ERROR, e.getMessage());\n\t\t}\n\t\treturn new ParseResults(handler.getStartSuiteTime(), handler.getCommonDuration());\n\t}\n\n\tpublic XunitParseJob withParameters(ReportPortalUser.ProjectDetails projectDetails, String launchId, ReportPortalUser user,\n\t\t\tInputStream xmlInputStream) {\n\t\tthis.xmlInputStream = xmlInputStream;\n\t\tthis.handler = handler.withParameters(projectDetails, launchId, user);\n\t\treturn this;\n\t}\n\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700264,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "/*\n * Copyright 2019 EPAM Systems\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.epam.ta.reportportal.core.imprt.impl.junit;\n\nimport com.epam.ta.reportportal.commons.ReportPortalUser;\nimport com.epam.ta.reportportal.core.imprt.impl.ParseResults;\nimport com.epam.ta.reportportal.exception.ReportPortalException;\nimport com.epam.ta.reportportal.ws.model.ErrorType;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.concurrent.Callable;\n\n@Component\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class XunitParseJob implements Callable<ParseResults> {\n\n\t@Autowired\n\tprivate XunitImportHandler handler;\n\n\tprivate InputStream xmlInputStream;\n\n\t@Override\n\tpublic ParseResults call() {\n\t\ttry {\n\t\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\t\t\tSAXParser saxParser = spf.newSAXParser();\n\t\t\tXMLReader reader = saxParser.getXMLReader();\n\n\t\t\t// Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\t// Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-general-entities\n\n\t\t\t// Xerces 2 only - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\t// Using the SAXParserFactory's setFeature\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\n\t\t\tspf.setXIncludeAware(false);\n\t\t\t// Using the XMLReader's setFeature\n\t\t\treader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\treader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n\t\t\tsaxParser.parse(xmlInputStream, handler);\n\t\t} catch (SAXException | IOException | ParserConfigurationException e) {\n\t\t\tthrow new ReportPortalException(ErrorType.PARSING_XML_ERROR, e.getMessage());\n\t\t}\n\t\treturn new ParseResults(handler.getStartSuiteTime(), handler.getCommonDuration());\n\t}\n\n\tpublic XunitParseJob withParameters(ReportPortalUser.ProjectDetails projectDetails, String launchId, ReportPortalUser user,\n\t\t\tInputStream xmlInputStream) {\n\t\tthis.xmlInputStream = xmlInputStream;\n\t\tthis.handler = handler.withParameters(projectDetails, launchId, user);\n\t\treturn this;\n\t}\n\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700265,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "/*\n * Copyright 2019 EPAM Systems\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.epam.ta.reportportal.core.imprt.impl.junit;\n\nimport com.epam.ta.reportportal.commons.ReportPortalUser;\nimport com.epam.ta.reportportal.core.imprt.impl.ParseResults;\nimport com.epam.ta.reportportal.exception.ReportPortalException;\nimport com.epam.ta.reportportal.ws.model.ErrorType;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.concurrent.Callable;\n\n@Component\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class XunitParseJob implements Callable<ParseResults> {\n\n\t@Autowired\n\tprivate XunitImportHandler handler;\n\n\tprivate InputStream xmlInputStream;\n\n\t@Override\n\tpublic ParseResults call() {\n\t\ttry {\n\t\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\t\t\tSAXParser saxParser = spf.newSAXParser();\n\t\t\tXMLReader reader = saxParser.getXMLReader();\n\n\t\t\t// Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\t// Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-general-entities\n\n\t\t\t// Xerces 2 only - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\t// Using the SAXParserFactory's setFeature\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\tspf.setXIncludeAware(false);\n\t\t\t// Using the XMLReader's setFeature\n\t\t\treader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\treader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n\t\t\tsaxParser.parse(xmlInputStream, handler);\n\t\t} catch (SAXException | IOException | ParserConfigurationException e) {\n\t\t\tthrow new ReportPortalException(ErrorType.PARSING_XML_ERROR, e.getMessage());\n\t\t}\n\t\treturn new ParseResults(handler.getStartSuiteTime(), handler.getCommonDuration());\n\t}\n\n\tpublic XunitParseJob withParameters(ReportPortalUser.ProjectDetails projectDetails, String launchId, ReportPortalUser user,\n\t\t\tInputStream xmlInputStream) {\n\t\tthis.xmlInputStream = xmlInputStream;\n\t\tthis.handler = handler.withParameters(projectDetails, launchId, user);\n\t\treturn this;\n\t}\n\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700266,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "/*\n * Copyright 2019 EPAM Systems\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.epam.ta.reportportal.core.imprt.impl.junit;\n\nimport com.epam.ta.reportportal.commons.ReportPortalUser;\nimport com.epam.ta.reportportal.core.imprt.impl.ParseResults;\nimport com.epam.ta.reportportal.exception.ReportPortalException;\nimport com.epam.ta.reportportal.ws.model.ErrorType;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.concurrent.Callable;\n\n@Component\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class XunitParseJob implements Callable<ParseResults> {\n\n\t@Autowired\n\tprivate XunitImportHandler handler;\n\n\tprivate InputStream xmlInputStream;\n\n\t@Override\n\tpublic ParseResults call() {\n\t\ttry {\n\t\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\t\t\tSAXParser saxParser = spf.newSAXParser();\n\t\t\tXMLReader reader = saxParser.getXMLReader();\n\n\t\t\t// Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\t// Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-general-entities\n\n\t\t\t// Xerces 2 only - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\t// Using the SAXParserFactory's setFeature\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\n\t\t\tspf.setXIncludeAware(false);\n\t\t\t// Using the XMLReader's setFeature\n\t\t\treader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\treader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n\t\t\tsaxParser.parse(xmlInputStream, handler);\n\t\t} catch (SAXException | IOException | ParserConfigurationException e) {\n\t\t\tthrow new ReportPortalException(ErrorType.PARSING_XML_ERROR, e.getMessage());\n\t\t}\n\t\treturn new ParseResults(handler.getStartSuiteTime(), handler.getCommonDuration());\n\t}\n\n\tpublic XunitParseJob withParameters(ReportPortalUser.ProjectDetails projectDetails, String launchId, ReportPortalUser user,\n\t\t\tInputStream xmlInputStream) {\n\t\tthis.xmlInputStream = xmlInputStream;\n\t\tthis.handler = handler.withParameters(projectDetails, launchId, user);\n\t\treturn this;\n\t}\n\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700267,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "/*\n * Copyright 2019 EPAM Systems\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.epam.ta.reportportal.core.imprt.impl.junit;\n\nimport com.epam.ta.reportportal.commons.ReportPortalUser;\nimport com.epam.ta.reportportal.core.imprt.impl.ParseResults;\nimport com.epam.ta.reportportal.exception.ReportPortalException;\nimport com.epam.ta.reportportal.ws.model.ErrorType;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.concurrent.Callable;\n\n@Component\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class XunitParseJob implements Callable<ParseResults> {\n\n\t@Autowired\n\tprivate XunitImportHandler handler;\n\n\tprivate InputStream xmlInputStream;\n\n\t@Override\n\tpublic ParseResults call() {\n\t\ttry {\n\t\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\t\t\tSAXParser saxParser = spf.newSAXParser();\n\t\t\tXMLReader reader = saxParser.getXMLReader();\n\n\t\t\t// Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\t// Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-general-entities\n\n\t\t\t// Xerces 2 only - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\t// Using the SAXParserFactory's setFeature\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\n\t\t\tspf.setXIncludeAware(false);\n\t\t\t// Using the XMLReader's setFeature\n\t\t\treader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\treader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n\t\t\tsaxParser.parse(xmlInputStream, handler);\n\t\t} catch (SAXException | IOException | ParserConfigurationException e) {\n\t\t\tthrow new ReportPortalException(ErrorType.PARSING_XML_ERROR, e.getMessage());\n\t\t}\n\t\treturn new ParseResults(handler.getStartSuiteTime(), handler.getCommonDuration());\n\t}\n\n\tpublic XunitParseJob withParameters(ReportPortalUser.ProjectDetails projectDetails, String launchId, ReportPortalUser user,\n\t\t\tInputStream xmlInputStream) {\n\t\tthis.xmlInputStream = xmlInputStream;\n\t\tthis.handler = handler.withParameters(projectDetails, launchId, user);\n\t\treturn this;\n\t}\n\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700268,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "/*\n * Copyright 2019 EPAM Systems\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.epam.ta.reportportal.core.imprt.impl.junit;\n\nimport com.epam.ta.reportportal.commons.ReportPortalUser;\nimport com.epam.ta.reportportal.core.imprt.impl.ParseResults;\nimport com.epam.ta.reportportal.exception.ReportPortalException;\nimport com.epam.ta.reportportal.ws.model.ErrorType;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.concurrent.Callable;\n\n@Component\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class XunitParseJob implements Callable<ParseResults> {\n\n\t@Autowired\n\tprivate XunitImportHandler handler;\n\n\tprivate InputStream xmlInputStream;\n\n\t@Override\n\tpublic ParseResults call() {\n\t\ttry {\n\t\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\t\t\tSAXParser saxParser = spf.newSAXParser();\n\t\t\tXMLReader reader = saxParser.getXMLReader();\n\n\t\t\t// Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\t// Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-general-entities\n\n\t\t\t// Xerces 2 only - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\t// Using the SAXParserFactory's setFeature\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\tspf.setXIncludeAware(false);\n\t\t\t// Using the XMLReader's setFeature\n\t\t\treader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\treader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n\t\t\tsaxParser.parse(xmlInputStream, handler);\n\t\t} catch (SAXException | IOException | ParserConfigurationException e) {\n\t\t\tthrow new ReportPortalException(ErrorType.PARSING_XML_ERROR, e.getMessage());\n\t\t}\n\t\treturn new ParseResults(handler.getStartSuiteTime(), handler.getCommonDuration());\n\t}\n\n\tpublic XunitParseJob withParameters(ReportPortalUser.ProjectDetails projectDetails, String launchId, ReportPortalUser user,\n\t\t\tInputStream xmlInputStream) {\n\t\tthis.xmlInputStream = xmlInputStream;\n\t\tthis.handler = handler.withParameters(projectDetails, launchId, user);\n\t\treturn this;\n\t}\n\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700269,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "/*\n * Copyright 2019 EPAM Systems\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.epam.ta.reportportal.core.imprt.impl.junit;\n\nimport com.epam.ta.reportportal.commons.ReportPortalUser;\nimport com.epam.ta.reportportal.core.imprt.impl.ParseResults;\nimport com.epam.ta.reportportal.exception.ReportPortalException;\nimport com.epam.ta.reportportal.ws.model.ErrorType;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.concurrent.Callable;\n\n@Component\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class XunitParseJob implements Callable<ParseResults> {\n\n\t@Autowired\n\tprivate XunitImportHandler handler;\n\n\tprivate InputStream xmlInputStream;\n\n\t@Override\n\tpublic ParseResults call() {\n\t\ttry {\n\t\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\t\t\tSAXParser saxParser = spf.newSAXParser();\n\t\t\tXMLReader reader = saxParser.getXMLReader();\n\n\t\t\t// Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\t// Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-general-entities\n\n\t\t\t// Using the SAXParserFactory's setFeature\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\t// Using the XMLReader's setFeature\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\n\t\t\t// Xerces 2 only - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\n\t\t\tsaxParser.parse(xmlInputStream, handler);\n\t\t} catch (SAXException | IOException | ParserConfigurationException e) {\n\t\t\tthrow new ReportPortalException(ErrorType.PARSING_XML_ERROR, e.getMessage());\n\t\t}\n\t\treturn new ParseResults(handler.getStartSuiteTime(), handler.getCommonDuration());\n\t}\n\n\tpublic XunitParseJob withParameters(ReportPortalUser.ProjectDetails projectDetails, String launchId, ReportPortalUser user,\n\t\t\tInputStream xmlInputStream) {\n\t\tthis.xmlInputStream = xmlInputStream;\n\t\tthis.handler = handler.withParameters(projectDetails, launchId, user);\n\t\treturn this;\n\t}\n\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700270,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "/*\n * Copyright 2019 EPAM Systems\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.epam.ta.reportportal.core.imprt.impl.junit;\n\nimport com.epam.ta.reportportal.commons.ReportPortalUser;\nimport com.epam.ta.reportportal.core.imprt.impl.ParseResults;\nimport com.epam.ta.reportportal.exception.ReportPortalException;\nimport com.epam.ta.reportportal.ws.model.ErrorType;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.concurrent.Callable;\n\n@Component\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class XunitParseJob implements Callable<ParseResults> {\n\n\t@Autowired\n\tprivate XunitImportHandler handler;\n\n\tprivate InputStream xmlInputStream;\n\n\t@Override\n\tpublic ParseResults call() {\n\t\ttry {\n\t\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\t\t\tSAXParser saxParser = spf.newSAXParser();\n\t\t\tXMLReader reader = saxParser.getXMLReader();\n\n\t\t\t// Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\t// Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-general-entities\n\n\t\t\t// Xerces 2 only - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\t// Using the SAXParserFactory's setFeature\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\tspf.setXIncludeAware(false);\n\t\t\t// Using the XMLReader's setFeature\n\t\t\treader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\treader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n\t\t\tsaxParser.parse(xmlInputStream, handler);\n\t\t} catch (SAXException | IOException | ParserConfigurationException e) {\n\t\t\tthrow new ReportPortalException(ErrorType.PARSING_XML_ERROR, e.getMessage());\n\t\t}\n\t\treturn new ParseResults(handler.getStartSuiteTime(), handler.getCommonDuration());\n\t}\n\n\tpublic XunitParseJob withParameters(ReportPortalUser.ProjectDetails projectDetails, String launchId, ReportPortalUser user,\n\t\t\tInputStream xmlInputStream) {\n\t\tthis.xmlInputStream = xmlInputStream;\n\t\tthis.handler = handler.withParameters(projectDetails, launchId, user);\n\t\treturn this;\n\t}\n\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700271,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "/*\n * Copyright 2019 EPAM Systems\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.epam.ta.reportportal.core.imprt.impl.junit;\n\nimport com.epam.ta.reportportal.commons.ReportPortalUser;\nimport com.epam.ta.reportportal.core.imprt.impl.ParseResults;\nimport com.epam.ta.reportportal.exception.ReportPortalException;\nimport com.epam.ta.reportportal.ws.model.ErrorType;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.concurrent.Callable;\n\n@Component\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class XunitParseJob implements Callable<ParseResults> {\n\n\t@Autowired\n\tprivate XunitImportHandler handler;\n\n\tprivate InputStream xmlInputStream;\n\n\t@Override\n\tpublic ParseResults call() {\n\t\ttry {\n\t\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\t\t\tSAXParser saxParser = spf.newSAXParser();\n\t\t\tXMLReader reader = saxParser.getXMLReader();\n\n\t\t\t// Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\t// Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-general-entities\n\n\t\t\t// Xerces 2 only - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\t// Using the SAXParserFactory's setFeature\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\n\t\t\tspf.setXIncludeAware(false);\n\t\t\t// Using the XMLReader's setFeature\n\t\t\treader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\treader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n\t\t\tsaxParser.parse(xmlInputStream, handler);\n\t\t} catch (SAXException | IOException | ParserConfigurationException e) {\n\t\t\tthrow new ReportPortalException(ErrorType.PARSING_XML_ERROR, e.getMessage());\n\t\t}\n\t\treturn new ParseResults(handler.getStartSuiteTime(), handler.getCommonDuration());\n\t}\n\n\tpublic XunitParseJob withParameters(ReportPortalUser.ProjectDetails projectDetails, String launchId, ReportPortalUser user,\n\t\t\tInputStream xmlInputStream) {\n\t\tthis.xmlInputStream = xmlInputStream;\n\t\tthis.handler = handler.withParameters(projectDetails, launchId, user);\n\t\treturn this;\n\t}\n\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700272,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "/*\n * Copyright 2019 EPAM Systems\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.epam.ta.reportportal.core.imprt.impl.junit;\n\nimport com.epam.ta.reportportal.commons.ReportPortalUser;\nimport com.epam.ta.reportportal.core.imprt.impl.ParseResults;\nimport com.epam.ta.reportportal.exception.ReportPortalException;\nimport com.epam.ta.reportportal.ws.model.ErrorType;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.concurrent.Callable;\n\n@Component\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class XunitParseJob implements Callable<ParseResults> {\n\n\t@Autowired\n\tprivate XunitImportHandler handler;\n\n\tprivate InputStream xmlInputStream;\n\n\t@Override\n\tpublic ParseResults call() {\n\t\ttry {\n\t\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\t\t\tSAXParser saxParser = spf.newSAXParser();\n\t\t\tXMLReader reader = saxParser.getXMLReader();\n\n\t\t\t// Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\t// Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-general-entities\n\n\t\t\t// Xerces 2 only - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\t// Using the SAXParserFactory's setFeature\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\tspf.setXIncludeAware(false);\n\t\t\t// Using the XMLReader's setFeature\n\t\t\treader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\treader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n\t\t\tsaxParser.parse(xmlInputStream, handler);\n\t\t} catch (SAXException | IOException | ParserConfigurationException e) {\n\t\t\tthrow new ReportPortalException(ErrorType.PARSING_XML_ERROR, e.getMessage());\n\t\t}\n\t\treturn new ParseResults(handler.getStartSuiteTime(), handler.getCommonDuration());\n\t}\n\n\tpublic XunitParseJob withParameters(ReportPortalUser.ProjectDetails projectDetails, String launchId, ReportPortalUser user,\n\t\t\tInputStream xmlInputStream) {\n\t\tthis.xmlInputStream = xmlInputStream;\n\t\tthis.handler = handler.withParameters(projectDetails, launchId, user);\n\t\treturn this;\n\t}\n\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700273,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "/*\n * Copyright 2019 EPAM Systems\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.epam.ta.reportportal.core.imprt.impl.junit;\n\nimport com.epam.ta.reportportal.commons.ReportPortalUser;\nimport com.epam.ta.reportportal.core.imprt.impl.ParseResults;\nimport com.epam.ta.reportportal.exception.ReportPortalException;\nimport com.epam.ta.reportportal.ws.model.ErrorType;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.concurrent.Callable;\n\n@Component\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class XunitParseJob implements Callable<ParseResults> {\n\n\t@Autowired\n\tprivate XunitImportHandler handler;\n\n\tprivate InputStream xmlInputStream;\n\n\t@Override\n\tpublic ParseResults call() {\n\t\ttry {\n\t\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\t\t\tSAXParser saxParser = spf.newSAXParser();\n\t\t\tXMLReader reader = saxParser.getXMLReader();\n\n\t\t\t// Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\t// Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-general-entities\n\n\t\t\t// Xerces 2 only - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\t// Using the SAXParserFactory's setFeature\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\tspf.setXIncludeAware(false);\n\t\t\t// Using the XMLReader's setFeature\n\t\t\treader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\treader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n\t\t\tsaxParser.parse(xmlInputStream, handler);\n\t\t} catch (SAXException | IOException | ParserConfigurationException e) {\n\t\t\tthrow new ReportPortalException(ErrorType.PARSING_XML_ERROR, e.getMessage());\n\t\t}\n\t\treturn new ParseResults(handler.getStartSuiteTime(), handler.getCommonDuration());\n\t}\n\n\tpublic XunitParseJob withParameters(ReportPortalUser.ProjectDetails projectDetails, String launchId, ReportPortalUser user,\n\t\t\tInputStream xmlInputStream) {\n\t\tthis.xmlInputStream = xmlInputStream;\n\t\tthis.handler = handler.withParameters(projectDetails, launchId, user);\n\t\treturn this;\n\t}\n\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700274,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-611"
    ],
    "code": "/*\n * Copyright 2019 EPAM Systems\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.epam.ta.reportportal.core.imprt.impl.junit;\n\nimport com.epam.ta.reportportal.commons.ReportPortalUser;\nimport com.epam.ta.reportportal.core.imprt.impl.ParseResults;\nimport com.epam.ta.reportportal.exception.ReportPortalException;\nimport com.epam.ta.reportportal.ws.model.ErrorType;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.concurrent.Callable;\n\n@Component\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class XunitParseJob implements Callable<ParseResults> {\n\n\t@Autowired\n\tprivate XunitImportHandler handler;\n\n\tprivate InputStream xmlInputStream;\n\n\t@Override\n\tpublic ParseResults call() {\n\t\ttry {\n\t\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\t\t\tSAXParser saxParser = spf.newSAXParser();\n\t\t\tXMLReader reader = saxParser.getXMLReader();\n\n\t\t\t// Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\t// Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-general-entities\n\n\t\t\t// Xerces 2 only - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\t// Using the SAXParserFactory's setFeature\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\n\t\t\tspf.setXIncludeAware(false);\n\t\t\t// Using the XMLReader's setFeature\n\t\t\treader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\treader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n\t\t\tsaxParser.parse(xmlInputStream, handler);\n\t\t} catch (SAXException | IOException | ParserConfigurationException e) {\n\t\t\tthrow new ReportPortalException(ErrorType.PARSING_XML_ERROR, e.getMessage());\n\t\t}\n\t\treturn new ParseResults(handler.getStartSuiteTime(), handler.getCommonDuration());\n\t}\n\n\tpublic XunitParseJob withParameters(ReportPortalUser.ProjectDetails projectDetails, String launchId, ReportPortalUser user,\n\t\t\tInputStream xmlInputStream) {\n\t\tthis.xmlInputStream = xmlInputStream;\n\t\tthis.handler = handler.withParameters(projectDetails, launchId, user);\n\t\treturn this;\n\t}\n\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700275,
    "RELATED_CWE": [
      "CWE-89",
      "CWE-94",
      "CWE-78"
    ]
  }
]