[
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "/*\n * Copyright (c) 2002-2018 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j Enterprise Edition. The included source\n * code can be redistributed and/or modified under the terms of the\n * GNU AFFERO GENERAL PUBLIC LICENSE Version 3\n * (http://www.fsf.org/licensing/licenses/agpl-3.0.html) with the\n * Commons Clause, as found in the associated LICENSE.txt file.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * Neo4j object code can be licensed independently from the source\n * under separate terms from the AGPL. Inquiries can be directed to:\n * licensing@neo4j.com\n *\n * More information is also available at:\n * https://neo4j.com/licensing/\n */\npackage org.neo4j.server.security.enterprise.auth;\n\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.credential.AllowAllCredentialsMatcher;\nimport org.apache.shiro.authz.AuthorizationException;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.apache.shiro.cache.Cache;\nimport org.apache.shiro.crypto.hash.SimpleHash;\nimport org.apache.shiro.realm.ldap.DefaultLdapRealm;\nimport org.apache.shiro.realm.ldap.JndiLdapContextFactory;\nimport org.apache.shiro.realm.ldap.LdapContextFactory;\nimport org.apache.shiro.realm.ldap.LdapUtils;\nimport org.apache.shiro.subject.PrincipalCollection;\n\nimport java.io.IOException;\nimport java.net.ConnectException;\nimport java.net.SocketTimeoutException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.naming.AuthenticationException;\nimport javax.naming.CommunicationException;\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport javax.naming.ldap.InitialLdapContext;\nimport javax.naming.ldap.LdapContext;\nimport javax.naming.ldap.StartTlsRequest;\nimport javax.naming.ldap.StartTlsResponse;\n\nimport org.neo4j.graphdb.security.AuthProviderFailedException;\nimport org.neo4j.graphdb.security.AuthProviderTimeoutException;\nimport org.neo4j.graphdb.security.AuthorizationExpiredException;\nimport org.neo4j.internal.kernel.api.security.AuthenticationResult;\nimport org.neo4j.kernel.api.security.AuthToken;\nimport org.neo4j.kernel.api.security.exception.InvalidAuthTokenException;\nimport org.neo4j.kernel.configuration.Config;\nimport org.neo4j.server.security.enterprise.configuration.SecuritySettings;\nimport org.neo4j.server.security.enterprise.log.SecurityLog;\n\nimport static java.lang.String.format;\n\n/**\n * Shiro realm for LDAP based on configuration settings\n */\npublic class LdapRealm extends DefaultLdapRealm implements RealmLifecycle, ShiroAuthorizationInfoProvider\n{\n    private static final String GROUP_DELIMITER = \";\";\n    private static final String KEY_VALUE_DELIMITER = \"=\";\n    private static final String ROLE_DELIMITER = \",\";\n    public static final String LDAP_REALM = \"ldap\";\n\n    private static final String JNDI_LDAP_CONNECT_TIMEOUT = \"com.sun.jndi.ldap.connect.timeout\";\n    private static final String JNDI_LDAP_READ_TIMEOUT = \"com.sun.jndi.ldap.read.timeout\";\n    private static final String JNDI_LDAP_CONNECTION_TIMEOUT_MESSAGE_PART = \"timed out\"; // \"connect timed out\"\n    private static final String JNDI_LDAP_READ_TIMEOUT_MESSAGE_PART = \"timed out\"; // \"LDAP response read timed out\"\n\n    public static final String LDAP_CONNECTION_TIMEOUT_CLIENT_MESSAGE = \"LDAP connection timed out.\";\n    public static final String LDAP_READ_TIMEOUT_CLIENT_MESSAGE = \"LDAP response timed out.\";\n    public static final String LDAP_AUTHORIZATION_FAILURE_CLIENT_MESSAGE = \"LDAP authorization request failed.\";\n    public static final String LDAP_CONNECTION_REFUSED_CLIENT_MESSAGE = \"LDAP connection refused.\";\n\n    private Boolean authenticationEnabled;\n    private Boolean authorizationEnabled;\n    private Boolean useStartTls;\n    private boolean useSAMAccountName;\n    private String userSearchBase;\n    private String userSearchFilter;\n    private List<String> membershipAttributeNames;\n    private Boolean useSystemAccountForAuthorization;\n    private Map<String,Collection<String>> groupToRoleMapping;\n    private final SecurityLog securityLog;\n    private final SecureHasher secureHasher;\n\n    // Parser regex for group-to-role-mapping\n    private static final String KEY_GROUP = \"\\\\s*('(.+)'|\\\"(.+)\\\"|(\\\\S)|(\\\\S.*\\\\S))\\\\s*\";\n    private static final String VALUE_GROUP = \"\\\\s*(.*)\";\n    private Pattern keyValuePattern = Pattern.compile( KEY_GROUP + KEY_VALUE_DELIMITER + VALUE_GROUP );\n\n    public LdapRealm( Config config, SecurityLog securityLog, SecureHasher secureHasher )\n    {\n        super();\n        this.securityLog = securityLog;\n        this.secureHasher = secureHasher;\n        setName( SecuritySettings.LDAP_REALM_NAME );\n        setRolePermissionResolver( PredefinedRolesBuilder.rolePermissionResolver );\n        configureRealm( config );\n        if ( isAuthenticationCachingEnabled() )\n        {\n            setCredentialsMatcher( secureHasher.getHashedCredentialsMatcher() );\n        }\n        else\n        {\n            setCredentialsMatcher( new AllowAllCredentialsMatcher() );\n        }\n    }\n\n    private String withRealm( String template, Object... args )\n    {\n        return \"{LdapRealm}: \" + format( template, args );\n    }\n\n    private String server( JndiLdapContextFactory jndiLdapContextFactory )\n    {\n        return \"'\" + jndiLdapContextFactory.getUrl() + \"'\" +\n                ( useStartTls ? \" using StartTLS\" : \"\" );\n    }\n\n    @Override\n    protected AuthenticationInfo queryForAuthenticationInfo( AuthenticationToken token,\n            LdapContextFactory ldapContextFactory )\n            throws NamingException\n    {\n        if ( authenticationEnabled )\n        {\n            if ( useSAMAccountName )\n            {\n                return queryForAuthenticationInfoSAM( token, ldapContextFactory );\n            }\n            else\n            {\n                String serverString = server( (JndiLdapContextFactory) ldapContextFactory );\n                try\n                {\n                    AuthenticationInfo info =\n                            useStartTls ? queryForAuthenticationInfoUsingStartTls( token, ldapContextFactory )\n                                        : super.queryForAuthenticationInfo( token, ldapContextFactory );\n                    securityLog.debug( withRealm( \"Authenticated user '%s' against %s\", token.getPrincipal(),\n                            serverString ) );\n                    return info;\n                }\n                catch ( Exception e )\n                {\n                    if ( isExceptionAnLdapConnectionTimeout( e ) )\n                    {\n                        throw new AuthProviderTimeoutException( LDAP_CONNECTION_TIMEOUT_CLIENT_MESSAGE, e );\n                    }\n                    else if ( isExceptionAnLdapReadTimeout( e ) )\n                    {\n                        throw new AuthProviderTimeoutException( LDAP_READ_TIMEOUT_CLIENT_MESSAGE, e );\n                    }\n                    else if ( isExceptionConnectionRefused( e ) )\n                    {\n                        throw new AuthProviderFailedException( LDAP_CONNECTION_REFUSED_CLIENT_MESSAGE, e );\n                    }\n                    // This exception will be caught and rethrown by Shiro, and then by us, so we do not need to wrap it here\n                    throw e;\n                }\n            }\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    protected AuthenticationInfo queryForAuthenticationInfoUsingStartTls( AuthenticationToken token,\n            LdapContextFactory ldapContextFactory ) throws NamingException\n    {\n        Object principal = getLdapPrincipal(token);\n        Object credentials = token.getCredentials();\n\n        LdapContext ctx = null;\n\n        try\n        {\n            ctx = getLdapContextUsingStartTls( ldapContextFactory, principal, credentials );\n            return createAuthenticationInfo( token, principal, credentials, ctx );\n        }\n        finally\n        {\n            LdapUtils.closeContext( ctx );\n        }\n    }\n\n    private LdapContext getLdapContextUsingStartTls( LdapContextFactory ldapContextFactory,\n            Object principal, Object credentials ) throws NamingException\n    {\n        JndiLdapContextFactory jndiLdapContextFactory = (JndiLdapContextFactory) ldapContextFactory;\n        Hashtable<String, Object> env = new Hashtable<>();\n        env.put( Context.INITIAL_CONTEXT_FACTORY, jndiLdapContextFactory.getContextFactoryClassName() );\n        env.put( Context.PROVIDER_URL, jndiLdapContextFactory.getUrl() );\n\n        LdapContext ctx = null;\n\n        try\n        {\n            ctx = new InitialLdapContext( env, null );\n\n            StartTlsRequest startTlsRequest = new StartTlsRequest();\n            StartTlsResponse tls = (StartTlsResponse) ctx.extendedOperation( startTlsRequest );\n\n            tls.negotiate();\n\n            ctx.addToEnvironment( Context.SECURITY_AUTHENTICATION,\n                    jndiLdapContextFactory.getAuthenticationMechanism() );\n            ctx.addToEnvironment( Context.SECURITY_PRINCIPAL, principal );\n            ctx.addToEnvironment( Context.SECURITY_CREDENTIALS, credentials );\n\n            return ctx;\n        }\n        catch ( IOException e )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Failed to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), e ) );\n            throw new CommunicationException( e.getMessage() );\n        }\n        catch ( Throwable t )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Unexpected failure to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), t ) );\n            throw t;\n        }\n    }\n\n    @Override\n    protected AuthorizationInfo queryForAuthorizationInfo( PrincipalCollection principals,\n            LdapContextFactory ldapContextFactory ) throws NamingException\n    {\n        if ( authorizationEnabled )\n        {\n            String username = getUsername( principals );\n            if ( username == null )\n            {\n                return null;\n            }\n\n            if ( useSystemAccountForAuthorization )\n            {\n                // Perform context search using the system context\n                LdapContext ldapContext = useStartTls ? getSystemLdapContextUsingStartTls( ldapContextFactory ) :\n                                          ldapContextFactory.getSystemLdapContext();\n\n                Set<String> roleNames;\n                try\n                {\n                    roleNames = findRoleNamesForUser( username, ldapContext );\n                }\n                finally\n                {\n                    LdapUtils.closeContext( ldapContext );\n                }\n\n                return new SimpleAuthorizationInfo( roleNames );\n            }\n            else\n            {\n                // Authorization info is cached during authentication\n                Cache<Object,AuthorizationInfo> authorizationCache = getAuthorizationCache();\n                AuthorizationInfo authorizationInfo = authorizationCache.get( username );\n                if ( authorizationInfo == null )\n                {\n                    // The cached authorization info has expired.\n                    // Since we do not have the subject's credentials we cannot perform a new LDAP search\n                    // for authorization info. Instead we need to fail with a special status,\n                    // so that the client can react by re-authenticating.\n                    throw new AuthorizationExpiredException( \"LDAP authorization info expired.\" );\n                }\n                return authorizationInfo;\n            }\n        }\n        return null;\n    }\n\n    private String getUsername( PrincipalCollection principals )\n    {\n        String username = null;\n        Collection ldapPrincipals = principals.fromRealm( getName() );\n        if ( !ldapPrincipals.isEmpty() )\n        {\n            username = (String) ldapPrincipals.iterator().next();\n        }\n        else if ( useSystemAccountForAuthorization )\n        {\n            username = (String) principals.getPrimaryPrincipal();\n        }\n        return username;\n    }\n\n    private LdapContext getSystemLdapContextUsingStartTls( LdapContextFactory ldapContextFactory )\n            throws NamingException\n    {\n        JndiLdapContextFactory jndiLdapContextFactory = (JndiLdapContextFactory) ldapContextFactory;\n        return getLdapContextUsingStartTls( ldapContextFactory, jndiLdapContextFactory.getSystemUsername(),\n                jndiLdapContextFactory.getSystemPassword() );\n    }\n\n    @Override\n    protected AuthenticationInfo createAuthenticationInfo( AuthenticationToken token, Object ldapPrincipal,\n            Object ldapCredentials, LdapContext ldapContext )\n            throws NamingException\n    {\n        // If authorization is enabled but useSystemAccountForAuthorization is disabled, we should perform\n        // the search for groups directly here while the user's authenticated ldap context is open.\n        if ( authorizationEnabled && !useSystemAccountForAuthorization )\n        {\n            String username = (String) token.getPrincipal();\n            Set<String> roleNames = findRoleNamesForUser( username, ldapContext );\n            cacheAuthorizationInfo( username, roleNames );\n        }\n\n        if ( isAuthenticationCachingEnabled() )\n        {\n            SimpleHash hashedCredentials = secureHasher.hash( ((String) token.getCredentials()).getBytes() );\n            return new ShiroAuthenticationInfo( token.getPrincipal(), hashedCredentials.getBytes(),\n                    hashedCredentials.getSalt(), getName(), AuthenticationResult.SUCCESS );\n        }\n        else\n        {\n            return new ShiroAuthenticationInfo( token.getPrincipal(), getName(), AuthenticationResult.SUCCESS );\n        }\n    }\n\n    @Override\n    public boolean supports( AuthenticationToken token )\n    {\n        return supportsSchemeAndRealm( token );\n    }\n\n    private boolean supportsSchemeAndRealm( AuthenticationToken token )\n    {\n        try\n        {\n            if ( token instanceof ShiroAuthToken )\n            {\n                ShiroAuthToken shiroAuthToken = (ShiroAuthToken) token;\n                return shiroAuthToken.getScheme().equals( AuthToken.BASIC_SCHEME ) &&\n                       (shiroAuthToken.supportsRealm( LDAP_REALM ));\n            }\n            return false;\n        }\n        catch ( InvalidAuthTokenException e )\n        {\n            return false;\n        }\n    }\n\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo( PrincipalCollection principals )\n    {\n        try\n        {\n            AuthorizationInfo info = super.doGetAuthorizationInfo( principals );\n            securityLog.debug( withRealm( \"Queried for authorization info for user '%s'\",\n                    principals.getPrimaryPrincipal() ) );\n            return info;\n        }\n        catch ( AuthorizationException e )\n        {\n            securityLog.warn( withRealm( \"Failed to get authorization info: '%s' caused by '%s'\",\n                    e.getMessage(), e.getCause().getMessage() ) );\n            return null;\n        }\n    }\n\n    // Unfortunately we need to identify timeouts by looking at the exception messages, which is not very robust.\n    // To make it slightly more robust we look for a key part of the actual message\n    private boolean isExceptionAnLdapReadTimeout( Exception e )\n    {\n        return e instanceof NamingException &&\n               e.getMessage().contains( JNDI_LDAP_READ_TIMEOUT_MESSAGE_PART );\n    }\n\n    private boolean isExceptionAnLdapConnectionTimeout( Exception e )\n    {\n        return e instanceof CommunicationException &&\n               (((CommunicationException) e).getRootCause() instanceof SocketTimeoutException ||\n                ((CommunicationException) e).getRootCause().getMessage().contains(\n                        JNDI_LDAP_CONNECTION_TIMEOUT_MESSAGE_PART ) );\n    }\n\n    private boolean isExceptionConnectionRefused( Exception e )\n    {\n        return e instanceof CommunicationException &&\n                ((CommunicationException) e).getRootCause() instanceof ConnectException;\n    }\n\n    private boolean isAuthorizationExceptionAnLdapReadTimeout( AuthorizationException e )\n    {\n        // Shiro's doGetAuthorizationInfo() wraps a NamingException in an AuthorizationException\n        return e.getCause() != null && e.getCause() instanceof NamingException &&\n               e.getCause().getMessage().contains( JNDI_LDAP_READ_TIMEOUT_MESSAGE_PART );\n    }\n\n    private void cacheAuthorizationInfo( String username, Set<String> roleNames )\n    {\n        // Use the existing authorizationCache in our base class\n        Cache<Object, AuthorizationInfo> authorizationCache = getAuthorizationCache();\n        authorizationCache.put( username, new SimpleAuthorizationInfo( roleNames ) );\n    }\n\n    private void configureRealm( Config config )\n    {\n        JndiLdapContextFactory contextFactory = new JndiLdapContextFactory();\n        Map<String,Object> environment = contextFactory.getEnvironment();\n        Long connectionTimeoutMillis = config.get( SecuritySettings.ldap_connection_timeout ).toMillis();\n        Long readTimeoutMillis = config.get( SecuritySettings.ldap_read_timeout ).toMillis();\n        environment.put( JNDI_LDAP_CONNECT_TIMEOUT, connectionTimeoutMillis.toString() );\n        environment.put( JNDI_LDAP_READ_TIMEOUT, readTimeoutMillis.toString() );\n        contextFactory.setEnvironment( environment );\n        contextFactory.setUrl( parseLdapServerUrl( config.get( SecuritySettings.ldap_server ) ) );\n        contextFactory.setAuthenticationMechanism( config.get( SecuritySettings.ldap_authentication_mechanism ) );\n        contextFactory.setReferral( config.get( SecuritySettings.ldap_referral ) );\n        contextFactory.setSystemUsername( config.get( SecuritySettings.ldap_authorization_system_username ) );\n        contextFactory.setSystemPassword( config.get( SecuritySettings.ldap_authorization_system_password ) );\n        contextFactory.setPoolingEnabled( config.get( SecuritySettings.ldap_authorization_connection_pooling ) );\n\n        setContextFactory( contextFactory );\n\n        String userDnTemplate = config.get( SecuritySettings.ldap_authentication_user_dn_template );\n        if ( userDnTemplate != null )\n        {\n            setUserDnTemplate( userDnTemplate );\n        }\n\n        authenticationEnabled = config.get( SecuritySettings.ldap_authentication_enabled );\n        authorizationEnabled = config.get( SecuritySettings.ldap_authorization_enabled );\n        useStartTls = config.get( SecuritySettings.ldap_use_starttls );\n\n        userSearchBase = config.get( SecuritySettings.ldap_authorization_user_search_base );\n        userSearchFilter = config.get( SecuritySettings.ldap_authorization_user_search_filter );\n        useSAMAccountName = config.get( SecuritySettings.ldap_authentication_use_samaccountname );\n        membershipAttributeNames = config.get( SecuritySettings.ldap_authorization_group_membership_attribute_names );\n        useSystemAccountForAuthorization = config.get( SecuritySettings.ldap_authorization_use_system_account );\n        groupToRoleMapping =\n                parseGroupToRoleMapping( config.get( SecuritySettings.ldap_authorization_group_to_role_mapping ) );\n\n        setAuthenticationCachingEnabled( config.get( SecuritySettings.ldap_authentication_cache_enabled ) );\n        setAuthorizationCachingEnabled( true );\n    }\n\n    private String parseLdapServerUrl( String rawLdapServer )\n    {\n        return (rawLdapServer == null) ? null :\n               rawLdapServer.contains( \"://\" ) ? rawLdapServer : \"ldap://\" + rawLdapServer;\n    }\n\n    private Map<String,Collection<String>> parseGroupToRoleMapping( String groupToRoleMappingString )\n    {\n        Map<String,Collection<String>> map = new HashMap<>();\n\n        if ( groupToRoleMappingString != null )\n        {\n            for ( String groupAndRoles : groupToRoleMappingString.split( GROUP_DELIMITER ) )\n            {\n                if ( !groupAndRoles.isEmpty() )\n                {\n                    Matcher matcher = keyValuePattern.matcher( groupAndRoles );\n                    if ( !(matcher.find() && matcher.groupCount() == 6) )\n                    {\n                        String errorMessage = format( \"Failed to parse setting %s: wrong number of fields\",\n                                SecuritySettings.ldap_authorization_group_to_role_mapping.name() );\n                        throw new IllegalArgumentException( errorMessage );\n                    }\n\n                    String group = matcher.group(2) != null ? matcher.group(2) :\n                                   matcher.group(3) != null ? matcher.group(3) :\n                                   matcher.group(4) != null ? matcher.group(4) :\n                                   matcher.group(5) != null ? matcher.group(5) : \"\";\n\n                    if ( group.isEmpty() )\n                    {\n                        String errorMessage = format( \"Failed to parse setting %s: empty group name\",\n                                SecuritySettings.ldap_authorization_group_to_role_mapping.name() );\n                        throw new IllegalArgumentException( errorMessage );\n                    }\n                    Collection<String> roleList = new ArrayList<>();\n                    for ( String role : matcher.group(6).trim().split( ROLE_DELIMITER ) )\n                    {\n                        if ( !role.isEmpty() )\n                        {\n                            roleList.add( role );\n                        }\n                    }\n                    // We only support case-insensitive comparison of group DNs\n                    map.put( group.toLowerCase(), roleList );\n                }\n            }\n        }\n\n        return map;\n    }\n\n    private AuthenticationInfo queryForAuthenticationInfoSAM(\n            AuthenticationToken token, LdapContextFactory ldapContextFactory ) throws NamingException\n    {\n        Object principal = token.getPrincipal();\n        Object credentials = token.getCredentials();\n\n        LdapContext ctx = null;\n        try\n        {\n            ctx = useStartTls ? getSystemLdapContextUsingStartTls( ldapContextFactory ) :\n                                      ldapContextFactory.getSystemLdapContext();\n            String[] attrs = {\"cn\"};\n            SearchControls searchCtls = new SearchControls( SearchControls.SUBTREE_SCOPE, 1, 0, attrs, false, false );\n            Object[] searchArguments = new Object[]{principal};\n            String filter = \"sAMAccountName={0}\";\n            NamingEnumeration<SearchResult> search = ctx.search( userSearchBase, filter, searchArguments, searchCtls );\n            if ( search.hasMore() )\n            {\n                final SearchResult next = search.next();\n                String loginUser = next.getNameInNamespace();\n                if ( search.hasMore() )\n                {\n                    securityLog.error( \"More than one user matching: \" + principal );\n                    throw new AuthenticationException( \"More than one user matching: \" + principal );\n                }\n                else\n                {\n                    LdapContext ctx2 = ldapContextFactory.getLdapContext( loginUser, credentials );\n                    LdapUtils.closeContext( ctx2 );\n                }\n            }\n            else\n            {\n                throw new AuthenticationException( \"No user matching: \" + principal );\n            }\n            return createAuthenticationInfo( token, principal, credentials, ctx );\n        }\n        finally\n        {\n            LdapUtils.closeContext( ctx );\n        }\n    }\n\n    // TODO: Extract to an LdapAuthorizationStrategy ? This (\"group by attribute\") is one of multiple possible strategies\n    Set<String> findRoleNamesForUser( String username, LdapContext ldapContext ) throws NamingException\n    {\n        Set<String> roleNames = new LinkedHashSet<>();\n\n        SearchControls searchCtls = new SearchControls();\n        searchCtls.setSearchScope( SearchControls.SUBTREE_SCOPE );\n        searchCtls.setReturningAttributes( membershipAttributeNames.toArray( new String[1] ) );\n\n        // Use search argument to prevent potential code injection\n        Object[] searchArguments = new Object[]{username};\n\n        NamingEnumeration result = ldapContext.search( userSearchBase, userSearchFilter, searchArguments, searchCtls );\n\n        if ( result.hasMoreElements() )\n        {\n            SearchResult searchResult = (SearchResult) result.next();\n\n            if ( result.hasMoreElements() )\n            {\n                securityLog.warn(\n                        securityLog.isDebugEnabled() ?\n                        withRealm(\n                            \"LDAP user search for user principal '%s' is ambiguous. The first match that will \" +\n                                            \"be checked for group membership is '%s' but the search also matches '%s'. \" +\n                                            \"Please check your LDAP realm configuration.\",\n                            username, searchResult.toString(), result.next().toString() )\n                        :\n                        withRealm(\n                            \"LDAP user search for user principal '%s' is ambiguous. The search matches more \" +\n                                            \"than one entry. Please check your LDAP realm configuration.\",\n                            username )\n                    );\n            }\n\n            Attributes attributes = searchResult.getAttributes();\n            if ( attributes != null )\n            {\n                NamingEnumeration attributeEnumeration = attributes.getAll();\n                while ( attributeEnumeration.hasMore() )\n                {\n                    Attribute attribute = (Attribute) attributeEnumeration.next();\n                    String attributeId = attribute.getID();\n                    if ( membershipAttributeNames.stream().anyMatch( attributeId::equalsIgnoreCase ) )\n                    {\n                        Collection<String> groupNames = LdapUtils.getAllAttributeValues( attribute );\n                        Collection<String> rolesForGroups = getRoleNamesForGroups( groupNames );\n                        roleNames.addAll( rolesForGroups );\n                    }\n                }\n            }\n        }\n        return roleNames;\n    }\n\n    private void assertValidUserSearchSettings()\n    {\n        boolean proceedWithSearch = true;\n\n        if ( userSearchBase == null || userSearchBase.isEmpty() )\n        {\n            securityLog.error( \"LDAP user search base is empty.\" );\n            proceedWithSearch = false;\n        }\n        if ( userSearchFilter == null || !userSearchFilter.contains( \"{0}\" ) )\n        {\n            securityLog.warn( \"LDAP user search filter does not contain the argument placeholder {0}, \" +\n                    \"so the search result will be independent of the user principal.\" );\n        }\n        if ( membershipAttributeNames == null || membershipAttributeNames.isEmpty() )\n        {\n            // If we don't have any attributes to look for we will never find anything\n            securityLog.error( \"LDAP group membership attribute names are empty. Authorization will not be possible.\" );\n            proceedWithSearch = false;\n        }\n\n        if ( !proceedWithSearch )\n        {\n            throw new IllegalArgumentException( \"Illegal LDAP user search settings, see security log for details.\" );\n        }\n    }\n\n    private Collection<String> getRoleNamesForGroups( Collection<String> groupNames )\n    {\n        Collection<String> roles = new ArrayList<>();\n        for ( String group : groupNames )\n        {\n            Collection<String> rolesForGroup = groupToRoleMapping.get( group.toLowerCase() );\n            if ( rolesForGroup != null )\n            {\n                roles.addAll( rolesForGroup );\n            }\n        }\n        return roles;\n    }\n\n    // Exposed for testing\n    Map<String,Collection<String>> getGroupToRoleMapping()\n    {\n        return groupToRoleMapping;\n    }\n\n    @Override\n    public void initialize()\n    {\n        if ( authorizationEnabled )\n        {\n            // For some combinations of settings we will never find anything\n            assertValidUserSearchSettings();\n        }\n    }\n\n    @Override\n    public void start()\n    {\n    }\n\n    @Override\n    public void stop()\n    {\n    }\n\n    @Override\n    public void shutdown()\n    {\n    }\n\n    @Override\n    public AuthorizationInfo getAuthorizationInfoSnapshot( PrincipalCollection principalCollection )\n    {\n        return getAuthorizationInfo( principalCollection );\n    }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200174,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "/*\n * Copyright (c) 2002-2018 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j Enterprise Edition. The included source\n * code can be redistributed and/or modified under the terms of the\n * GNU AFFERO GENERAL PUBLIC LICENSE Version 3\n * (http://www.fsf.org/licensing/licenses/agpl-3.0.html) with the\n * Commons Clause, as found in the associated LICENSE.txt file.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * Neo4j object code can be licensed independently from the source\n * under separate terms from the AGPL. Inquiries can be directed to:\n * licensing@neo4j.com\n *\n * More information is also available at:\n * https://neo4j.com/licensing/\n */\npackage org.neo4j.server.security.enterprise.auth;\n\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.credential.AllowAllCredentialsMatcher;\nimport org.apache.shiro.authz.AuthorizationException;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.apache.shiro.cache.Cache;\nimport org.apache.shiro.crypto.hash.SimpleHash;\nimport org.apache.shiro.realm.ldap.DefaultLdapRealm;\nimport org.apache.shiro.realm.ldap.JndiLdapContextFactory;\nimport org.apache.shiro.realm.ldap.LdapContextFactory;\nimport org.apache.shiro.realm.ldap.LdapUtils;\nimport org.apache.shiro.subject.PrincipalCollection;\n\nimport java.io.IOException;\nimport java.net.ConnectException;\nimport java.net.SocketTimeoutException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.naming.AuthenticationException;\nimport javax.naming.CommunicationException;\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport javax.naming.ldap.InitialLdapContext;\nimport javax.naming.ldap.LdapContext;\nimport javax.naming.ldap.StartTlsRequest;\nimport javax.naming.ldap.StartTlsResponse;\n\nimport org.neo4j.graphdb.security.AuthProviderFailedException;\nimport org.neo4j.graphdb.security.AuthProviderTimeoutException;\nimport org.neo4j.graphdb.security.AuthorizationExpiredException;\nimport org.neo4j.internal.kernel.api.security.AuthenticationResult;\nimport org.neo4j.kernel.api.security.AuthToken;\nimport org.neo4j.kernel.api.security.exception.InvalidAuthTokenException;\nimport org.neo4j.kernel.configuration.Config;\nimport org.neo4j.server.security.enterprise.configuration.SecuritySettings;\nimport org.neo4j.server.security.enterprise.log.SecurityLog;\n\nimport static java.lang.String.format;\n\n/**\n * Shiro realm for LDAP based on configuration settings\n */\npublic class LdapRealm extends DefaultLdapRealm implements RealmLifecycle, ShiroAuthorizationInfoProvider\n{\n    private static final String GROUP_DELIMITER = \";\";\n    private static final String KEY_VALUE_DELIMITER = \"=\";\n    private static final String ROLE_DELIMITER = \",\";\n    public static final String LDAP_REALM = \"ldap\";\n\n    private static final String JNDI_LDAP_CONNECT_TIMEOUT = \"com.sun.jndi.ldap.connect.timeout\";\n    private static final String JNDI_LDAP_READ_TIMEOUT = \"com.sun.jndi.ldap.read.timeout\";\n    private static final String JNDI_LDAP_CONNECTION_TIMEOUT_MESSAGE_PART = \"timed out\"; // \"connect timed out\"\n    private static final String JNDI_LDAP_READ_TIMEOUT_MESSAGE_PART = \"timed out\"; // \"LDAP response read timed out\"\n\n    public static final String LDAP_CONNECTION_TIMEOUT_CLIENT_MESSAGE = \"LDAP connection timed out.\";\n    public static final String LDAP_READ_TIMEOUT_CLIENT_MESSAGE = \"LDAP response timed out.\";\n    public static final String LDAP_AUTHORIZATION_FAILURE_CLIENT_MESSAGE = \"LDAP authorization request failed.\";\n    public static final String LDAP_CONNECTION_REFUSED_CLIENT_MESSAGE = \"LDAP connection refused.\";\n\n    private Boolean authenticationEnabled;\n    private Boolean authorizationEnabled;\n    private Boolean useStartTls;\n    private boolean useSAMAccountName;\n    private String userSearchBase;\n    private String userSearchFilter;\n    private List<String> membershipAttributeNames;\n    private Boolean useSystemAccountForAuthorization;\n    private Map<String,Collection<String>> groupToRoleMapping;\n    private final SecurityLog securityLog;\n    private final SecureHasher secureHasher;\n\n    // Parser regex for group-to-role-mapping\n    private static final String KEY_GROUP = \"\\\\s*('(.+)'|\\\"(.+)\\\"|(\\\\S)|(\\\\S.*\\\\S))\\\\s*\";\n    private static final String VALUE_GROUP = \"\\\\s*(.*)\";\n    private Pattern keyValuePattern = Pattern.compile( KEY_GROUP + KEY_VALUE_DELIMITER + VALUE_GROUP );\n\n    public LdapRealm( Config config, SecurityLog securityLog, SecureHasher secureHasher )\n    {\n        super();\n        this.securityLog = securityLog;\n        this.secureHasher = secureHasher;\n        setName( SecuritySettings.LDAP_REALM_NAME );\n        setRolePermissionResolver( PredefinedRolesBuilder.rolePermissionResolver );\n        configureRealm( config );\n        if ( isAuthenticationCachingEnabled() )\n        {\n            setCredentialsMatcher( secureHasher.getHashedCredentialsMatcher() );\n        }\n        else\n        {\n            setCredentialsMatcher( new AllowAllCredentialsMatcher() );\n        }\n    }\n\n    private String withRealm( String template, Object... args )\n    {\n        return \"{LdapRealm}: \" + format( template, args );\n    }\n\n    private String server( JndiLdapContextFactory jndiLdapContextFactory )\n    {\n        return \"'\" + jndiLdapContextFactory.getUrl() + \"'\" +\n                ( useStartTls ? \" using StartTLS\" : \"\" );\n    }\n\n    @Override\n    protected AuthenticationInfo queryForAuthenticationInfo( AuthenticationToken token,\n            LdapContextFactory ldapContextFactory )\n            throws NamingException\n    {\n        if ( authenticationEnabled )\n        {\n            if ( useSAMAccountName )\n            {\n                return queryForAuthenticationInfoSAM( token, ldapContextFactory );\n            }\n            else\n            {\n                String serverString = server( (JndiLdapContextFactory) ldapContextFactory );\n                try\n                {\n                    AuthenticationInfo info =\n                            useStartTls ? queryForAuthenticationInfoUsingStartTls( token, ldapContextFactory )\n                                        : super.queryForAuthenticationInfo( token, ldapContextFactory );\n                    securityLog.debug( withRealm( \"Authenticated user '%s' against %s\", token.getPrincipal(),\n                            serverString ) );\n                    return info;\n                }\n                catch ( Exception e )\n                {\n                    if ( isExceptionAnLdapConnectionTimeout( e ) )\n                    {\n                        throw new AuthProviderTimeoutException( LDAP_CONNECTION_TIMEOUT_CLIENT_MESSAGE, e );\n                    }\n                    else if ( isExceptionAnLdapReadTimeout( e ) )\n                    {\n                        throw new AuthProviderTimeoutException( LDAP_READ_TIMEOUT_CLIENT_MESSAGE, e );\n                    }\n                    else if ( isExceptionConnectionRefused( e ) )\n                    {\n                        throw new AuthProviderFailedException( LDAP_CONNECTION_REFUSED_CLIENT_MESSAGE, e );\n                    }\n                    // This exception will be caught and rethrown by Shiro, and then by us, so we do not need to wrap it here\n                    throw e;\n                }\n            }\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    protected AuthenticationInfo queryForAuthenticationInfoUsingStartTls( AuthenticationToken token,\n            LdapContextFactory ldapContextFactory ) throws NamingException\n    {\n        Object principal = getLdapPrincipal(token);\n        Object credentials = token.getCredentials();\n\n        LdapContext ctx = null;\n\n        try\n        {\n            ctx = getLdapContextUsingStartTls( ldapContextFactory, principal, credentials );\n            return createAuthenticationInfo( token, principal, credentials, ctx );\n        }\n        finally\n        {\n            LdapUtils.closeContext( ctx );\n        }\n    }\n\n    private LdapContext getLdapContextUsingStartTls( LdapContextFactory ldapContextFactory,\n            Object principal, Object credentials ) throws NamingException\n    {\n        JndiLdapContextFactory jndiLdapContextFactory = (JndiLdapContextFactory) ldapContextFactory;\n        Hashtable<String, Object> env = new Hashtable<>();\n        env.put( Context.INITIAL_CONTEXT_FACTORY, jndiLdapContextFactory.getContextFactoryClassName() );\n        env.put( Context.PROVIDER_URL, jndiLdapContextFactory.getUrl() );\n\n        LdapContext ctx = null;\n\n        try\n        {\n            ctx = new InitialLdapContext( env, null );\n\n            StartTlsRequest startTlsRequest = new StartTlsRequest();\n            StartTlsResponse tls = (StartTlsResponse) ctx.extendedOperation( startTlsRequest );\n\n            tls.negotiate();\n\n            ctx.addToEnvironment( Context.SECURITY_AUTHENTICATION,\n                    jndiLdapContextFactory.getAuthenticationMechanism() );\n            ctx.addToEnvironment( Context.SECURITY_PRINCIPAL, principal );\n            ctx.addToEnvironment( Context.SECURITY_CREDENTIALS, credentials );\n\n            // do a lookup of the user to trigger authentication\n            ctx.lookup( principal.toString() );\n\n            return ctx;\n        }\n        catch ( IOException e )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Failed to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), e ) );\n            throw new CommunicationException( e.getMessage() );\n        }\n        catch ( Throwable t )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Unexpected failure to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), t ) );\n            throw t;\n        }\n    }\n\n    @Override\n    protected AuthorizationInfo queryForAuthorizationInfo( PrincipalCollection principals,\n            LdapContextFactory ldapContextFactory ) throws NamingException\n    {\n        if ( authorizationEnabled )\n        {\n            String username = getUsername( principals );\n            if ( username == null )\n            {\n                return null;\n            }\n\n            if ( useSystemAccountForAuthorization )\n            {\n                // Perform context search using the system context\n                LdapContext ldapContext = useStartTls ? getSystemLdapContextUsingStartTls( ldapContextFactory ) :\n                                          ldapContextFactory.getSystemLdapContext();\n\n                Set<String> roleNames;\n                try\n                {\n                    roleNames = findRoleNamesForUser( username, ldapContext );\n                }\n                finally\n                {\n                    LdapUtils.closeContext( ldapContext );\n                }\n\n                return new SimpleAuthorizationInfo( roleNames );\n            }\n            else\n            {\n                // Authorization info is cached during authentication\n                Cache<Object,AuthorizationInfo> authorizationCache = getAuthorizationCache();\n                AuthorizationInfo authorizationInfo = authorizationCache.get( username );\n                if ( authorizationInfo == null )\n                {\n                    // The cached authorization info has expired.\n                    // Since we do not have the subject's credentials we cannot perform a new LDAP search\n                    // for authorization info. Instead we need to fail with a special status,\n                    // so that the client can react by re-authenticating.\n                    throw new AuthorizationExpiredException( \"LDAP authorization info expired.\" );\n                }\n                return authorizationInfo;\n            }\n        }\n        return null;\n    }\n\n    private String getUsername( PrincipalCollection principals )\n    {\n        String username = null;\n        Collection ldapPrincipals = principals.fromRealm( getName() );\n        if ( !ldapPrincipals.isEmpty() )\n        {\n            username = (String) ldapPrincipals.iterator().next();\n        }\n        else if ( useSystemAccountForAuthorization )\n        {\n            username = (String) principals.getPrimaryPrincipal();\n        }\n        return username;\n    }\n\n    private LdapContext getSystemLdapContextUsingStartTls( LdapContextFactory ldapContextFactory )\n            throws NamingException\n    {\n        JndiLdapContextFactory jndiLdapContextFactory = (JndiLdapContextFactory) ldapContextFactory;\n        return getLdapContextUsingStartTls( ldapContextFactory, jndiLdapContextFactory.getSystemUsername(),\n                jndiLdapContextFactory.getSystemPassword() );\n    }\n\n    @Override\n    protected AuthenticationInfo createAuthenticationInfo( AuthenticationToken token, Object ldapPrincipal,\n            Object ldapCredentials, LdapContext ldapContext )\n            throws NamingException\n    {\n        // If authorization is enabled but useSystemAccountForAuthorization is disabled, we should perform\n        // the search for groups directly here while the user's authenticated ldap context is open.\n        if ( authorizationEnabled && !useSystemAccountForAuthorization )\n        {\n            String username = (String) token.getPrincipal();\n            Set<String> roleNames = findRoleNamesForUser( username, ldapContext );\n            cacheAuthorizationInfo( username, roleNames );\n        }\n\n        if ( isAuthenticationCachingEnabled() )\n        {\n            SimpleHash hashedCredentials = secureHasher.hash( ((String) token.getCredentials()).getBytes() );\n            return new ShiroAuthenticationInfo( token.getPrincipal(), hashedCredentials.getBytes(),\n                    hashedCredentials.getSalt(), getName(), AuthenticationResult.SUCCESS );\n        }\n        else\n        {\n            return new ShiroAuthenticationInfo( token.getPrincipal(), getName(), AuthenticationResult.SUCCESS );\n        }\n    }\n\n    @Override\n    public boolean supports( AuthenticationToken token )\n    {\n        return supportsSchemeAndRealm( token );\n    }\n\n    private boolean supportsSchemeAndRealm( AuthenticationToken token )\n    {\n        try\n        {\n            if ( token instanceof ShiroAuthToken )\n            {\n                ShiroAuthToken shiroAuthToken = (ShiroAuthToken) token;\n                return shiroAuthToken.getScheme().equals( AuthToken.BASIC_SCHEME ) &&\n                       (shiroAuthToken.supportsRealm( LDAP_REALM ));\n            }\n            return false;\n        }\n        catch ( InvalidAuthTokenException e )\n        {\n            return false;\n        }\n    }\n\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo( PrincipalCollection principals )\n    {\n        try\n        {\n            AuthorizationInfo info = super.doGetAuthorizationInfo( principals );\n            securityLog.debug( withRealm( \"Queried for authorization info for user '%s'\",\n                    principals.getPrimaryPrincipal() ) );\n            return info;\n        }\n        catch ( AuthorizationException e )\n        {\n            securityLog.warn( withRealm( \"Failed to get authorization info: '%s' caused by '%s'\",\n                    e.getMessage(), e.getCause().getMessage() ) );\n            return null;\n        }\n    }\n\n    // Unfortunately we need to identify timeouts by looking at the exception messages, which is not very robust.\n    // To make it slightly more robust we look for a key part of the actual message\n    private boolean isExceptionAnLdapReadTimeout( Exception e )\n    {\n        return e instanceof NamingException &&\n               e.getMessage().contains( JNDI_LDAP_READ_TIMEOUT_MESSAGE_PART );\n    }\n\n    private boolean isExceptionAnLdapConnectionTimeout( Exception e )\n    {\n        return e instanceof CommunicationException &&\n               (((CommunicationException) e).getRootCause() instanceof SocketTimeoutException ||\n                ((CommunicationException) e).getRootCause().getMessage().contains(\n                        JNDI_LDAP_CONNECTION_TIMEOUT_MESSAGE_PART ) );\n    }\n\n    private boolean isExceptionConnectionRefused( Exception e )\n    {\n        return e instanceof CommunicationException &&\n                ((CommunicationException) e).getRootCause() instanceof ConnectException;\n    }\n\n    private boolean isAuthorizationExceptionAnLdapReadTimeout( AuthorizationException e )\n    {\n        // Shiro's doGetAuthorizationInfo() wraps a NamingException in an AuthorizationException\n        return e.getCause() != null && e.getCause() instanceof NamingException &&\n               e.getCause().getMessage().contains( JNDI_LDAP_READ_TIMEOUT_MESSAGE_PART );\n    }\n\n    private void cacheAuthorizationInfo( String username, Set<String> roleNames )\n    {\n        // Use the existing authorizationCache in our base class\n        Cache<Object, AuthorizationInfo> authorizationCache = getAuthorizationCache();\n        authorizationCache.put( username, new SimpleAuthorizationInfo( roleNames ) );\n    }\n\n    private void configureRealm( Config config )\n    {\n        JndiLdapContextFactory contextFactory = new JndiLdapContextFactory();\n        Map<String,Object> environment = contextFactory.getEnvironment();\n        Long connectionTimeoutMillis = config.get( SecuritySettings.ldap_connection_timeout ).toMillis();\n        Long readTimeoutMillis = config.get( SecuritySettings.ldap_read_timeout ).toMillis();\n        environment.put( JNDI_LDAP_CONNECT_TIMEOUT, connectionTimeoutMillis.toString() );\n        environment.put( JNDI_LDAP_READ_TIMEOUT, readTimeoutMillis.toString() );\n        contextFactory.setEnvironment( environment );\n        contextFactory.setUrl( parseLdapServerUrl( config.get( SecuritySettings.ldap_server ) ) );\n        contextFactory.setAuthenticationMechanism( config.get( SecuritySettings.ldap_authentication_mechanism ) );\n        contextFactory.setReferral( config.get( SecuritySettings.ldap_referral ) );\n        contextFactory.setSystemUsername( config.get( SecuritySettings.ldap_authorization_system_username ) );\n        contextFactory.setSystemPassword( config.get( SecuritySettings.ldap_authorization_system_password ) );\n        contextFactory.setPoolingEnabled( config.get( SecuritySettings.ldap_authorization_connection_pooling ) );\n\n        setContextFactory( contextFactory );\n\n        String userDnTemplate = config.get( SecuritySettings.ldap_authentication_user_dn_template );\n        if ( userDnTemplate != null )\n        {\n            setUserDnTemplate( userDnTemplate );\n        }\n\n        authenticationEnabled = config.get( SecuritySettings.ldap_authentication_enabled );\n        authorizationEnabled = config.get( SecuritySettings.ldap_authorization_enabled );\n        useStartTls = config.get( SecuritySettings.ldap_use_starttls );\n\n        userSearchBase = config.get( SecuritySettings.ldap_authorization_user_search_base );\n        userSearchFilter = config.get( SecuritySettings.ldap_authorization_user_search_filter );\n        useSAMAccountName = config.get( SecuritySettings.ldap_authentication_use_samaccountname );\n        membershipAttributeNames = config.get( SecuritySettings.ldap_authorization_group_membership_attribute_names );\n        useSystemAccountForAuthorization = config.get( SecuritySettings.ldap_authorization_use_system_account );\n        groupToRoleMapping =\n                parseGroupToRoleMapping( config.get( SecuritySettings.ldap_authorization_group_to_role_mapping ) );\n\n        setAuthenticationCachingEnabled( config.get( SecuritySettings.ldap_authentication_cache_enabled ) );\n        setAuthorizationCachingEnabled( true );\n    }\n\n    private String parseLdapServerUrl( String rawLdapServer )\n    {\n        return (rawLdapServer == null) ? null :\n               rawLdapServer.contains( \"://\" ) ? rawLdapServer : \"ldap://\" + rawLdapServer;\n    }\n\n    private Map<String,Collection<String>> parseGroupToRoleMapping( String groupToRoleMappingString )\n    {\n        Map<String,Collection<String>> map = new HashMap<>();\n\n        if ( groupToRoleMappingString != null )\n        {\n            for ( String groupAndRoles : groupToRoleMappingString.split( GROUP_DELIMITER ) )\n            {\n                if ( !groupAndRoles.isEmpty() )\n                {\n                    Matcher matcher = keyValuePattern.matcher( groupAndRoles );\n                    if ( !(matcher.find() && matcher.groupCount() == 6) )\n                    {\n                        String errorMessage = format( \"Failed to parse setting %s: wrong number of fields\",\n                                SecuritySettings.ldap_authorization_group_to_role_mapping.name() );\n                        throw new IllegalArgumentException( errorMessage );\n                    }\n\n                    String group = matcher.group(2) != null ? matcher.group(2) :\n                                   matcher.group(3) != null ? matcher.group(3) :\n                                   matcher.group(4) != null ? matcher.group(4) :\n                                   matcher.group(5) != null ? matcher.group(5) : \"\";\n\n                    if ( group.isEmpty() )\n                    {\n                        String errorMessage = format( \"Failed to parse setting %s: empty group name\",\n                                SecuritySettings.ldap_authorization_group_to_role_mapping.name() );\n                        throw new IllegalArgumentException( errorMessage );\n                    }\n                    Collection<String> roleList = new ArrayList<>();\n                    for ( String role : matcher.group(6).trim().split( ROLE_DELIMITER ) )\n                    {\n                        if ( !role.isEmpty() )\n                        {\n                            roleList.add( role );\n                        }\n                    }\n                    // We only support case-insensitive comparison of group DNs\n                    map.put( group.toLowerCase(), roleList );\n                }\n            }\n        }\n\n        return map;\n    }\n\n    private AuthenticationInfo queryForAuthenticationInfoSAM(\n            AuthenticationToken token, LdapContextFactory ldapContextFactory ) throws NamingException\n    {\n        Object principal = token.getPrincipal();\n        Object credentials = token.getCredentials();\n\n        LdapContext ctx = null;\n        try\n        {\n            ctx = useStartTls ? getSystemLdapContextUsingStartTls( ldapContextFactory ) :\n                                      ldapContextFactory.getSystemLdapContext();\n            String[] attrs = {\"cn\"};\n            SearchControls searchCtls = new SearchControls( SearchControls.SUBTREE_SCOPE, 1, 0, attrs, false, false );\n            Object[] searchArguments = new Object[]{principal};\n            String filter = \"sAMAccountName={0}\";\n            NamingEnumeration<SearchResult> search = ctx.search( userSearchBase, filter, searchArguments, searchCtls );\n            if ( search.hasMore() )\n            {\n                final SearchResult next = search.next();\n                String loginUser = next.getNameInNamespace();\n                if ( search.hasMore() )\n                {\n                    securityLog.error( \"More than one user matching: \" + principal );\n                    throw new AuthenticationException( \"More than one user matching: \" + principal );\n                }\n                else\n                {\n                    LdapContext ctx2 = ldapContextFactory.getLdapContext( loginUser, credentials );\n                    LdapUtils.closeContext( ctx2 );\n                }\n            }\n            else\n            {\n                throw new AuthenticationException( \"No user matching: \" + principal );\n            }\n            return createAuthenticationInfo( token, principal, credentials, ctx );\n        }\n        finally\n        {\n            LdapUtils.closeContext( ctx );\n        }\n    }\n\n    // TODO: Extract to an LdapAuthorizationStrategy ? This (\"group by attribute\") is one of multiple possible strategies\n    Set<String> findRoleNamesForUser( String username, LdapContext ldapContext ) throws NamingException\n    {\n        Set<String> roleNames = new LinkedHashSet<>();\n\n        SearchControls searchCtls = new SearchControls();\n        searchCtls.setSearchScope( SearchControls.SUBTREE_SCOPE );\n        searchCtls.setReturningAttributes( membershipAttributeNames.toArray( new String[1] ) );\n\n        // Use search argument to prevent potential code injection\n        Object[] searchArguments = new Object[]{username};\n\n        NamingEnumeration result = ldapContext.search( userSearchBase, userSearchFilter, searchArguments, searchCtls );\n\n        if ( result.hasMoreElements() )\n        {\n            SearchResult searchResult = (SearchResult) result.next();\n\n            if ( result.hasMoreElements() )\n            {\n                securityLog.warn(\n                        securityLog.isDebugEnabled() ?\n                        withRealm(\n                            \"LDAP user search for user principal '%s' is ambiguous. The first match that will \" +\n                                            \"be checked for group membership is '%s' but the search also matches '%s'. \" +\n                                            \"Please check your LDAP realm configuration.\",\n                            username, searchResult.toString(), result.next().toString() )\n                        :\n                        withRealm(\n                            \"LDAP user search for user principal '%s' is ambiguous. The search matches more \" +\n                                            \"than one entry. Please check your LDAP realm configuration.\",\n                            username )\n                    );\n            }\n\n            Attributes attributes = searchResult.getAttributes();\n            if ( attributes != null )\n            {\n                NamingEnumeration attributeEnumeration = attributes.getAll();\n                while ( attributeEnumeration.hasMore() )\n                {\n                    Attribute attribute = (Attribute) attributeEnumeration.next();\n                    String attributeId = attribute.getID();\n                    if ( membershipAttributeNames.stream().anyMatch( attributeId::equalsIgnoreCase ) )\n                    {\n                        Collection<String> groupNames = LdapUtils.getAllAttributeValues( attribute );\n                        Collection<String> rolesForGroups = getRoleNamesForGroups( groupNames );\n                        roleNames.addAll( rolesForGroups );\n                    }\n                }\n            }\n        }\n        return roleNames;\n    }\n\n    private void assertValidUserSearchSettings()\n    {\n        boolean proceedWithSearch = true;\n\n        if ( userSearchBase == null || userSearchBase.isEmpty() )\n        {\n            securityLog.error( \"LDAP user search base is empty.\" );\n            proceedWithSearch = false;\n        }\n        if ( userSearchFilter == null || !userSearchFilter.contains( \"{0}\" ) )\n        {\n            securityLog.warn( \"LDAP user search filter does not contain the argument placeholder {0}, \" +\n                    \"so the search result will be independent of the user principal.\" );\n        }\n        if ( membershipAttributeNames == null || membershipAttributeNames.isEmpty() )\n        {\n            // If we don't have any attributes to look for we will never find anything\n            securityLog.error( \"LDAP group membership attribute names are empty. Authorization will not be possible.\" );\n            proceedWithSearch = false;\n        }\n\n        if ( !proceedWithSearch )\n        {\n            throw new IllegalArgumentException( \"Illegal LDAP user search settings, see security log for details.\" );\n        }\n    }\n\n    private Collection<String> getRoleNamesForGroups( Collection<String> groupNames )\n    {\n        Collection<String> roles = new ArrayList<>();\n        for ( String group : groupNames )\n        {\n            Collection<String> rolesForGroup = groupToRoleMapping.get( group.toLowerCase() );\n            if ( rolesForGroup != null )\n            {\n                roles.addAll( rolesForGroup );\n            }\n        }\n        return roles;\n    }\n\n    // Exposed for testing\n    Map<String,Collection<String>> getGroupToRoleMapping()\n    {\n        return groupToRoleMapping;\n    }\n\n    @Override\n    public void initialize()\n    {\n        if ( authorizationEnabled )\n        {\n            // For some combinations of settings we will never find anything\n            assertValidUserSearchSettings();\n        }\n    }\n\n    @Override\n    public void start()\n    {\n    }\n\n    @Override\n    public void stop()\n    {\n    }\n\n    @Override\n    public void shutdown()\n    {\n    }\n\n    @Override\n    public AuthorizationInfo getAuthorizationInfoSnapshot( PrincipalCollection principalCollection )\n    {\n        return getAuthorizationInfo( principalCollection );\n    }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200175,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.kernel.security;\n\nimport org.opencastproject.security.api.JaxbOrganization;\nimport org.opencastproject.security.api.JaxbRole;\nimport org.opencastproject.security.api.JaxbUser;\nimport org.opencastproject.security.api.Organization;\nimport org.opencastproject.security.api.SecurityService;\nimport org.opencastproject.security.api.User;\nimport org.opencastproject.security.api.UserDirectoryService;\nimport org.opencastproject.security.util.SecurityUtil;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * A Spring Security implementation of {@link SecurityService}.\n */\npublic class SecurityServiceSpringImpl implements SecurityService {\n\n  /** The logger */\n  private static final Logger logger = LoggerFactory.getLogger(SecurityServiceSpringImpl.class);\n\n  /** Holds delegates users for new threads that have been spawned from authenticated threads */\n  private static final ThreadLocal<User> delegatedUserHolder = new ThreadLocal<User>();\n\n  /** Holds the IP address for the delegated user for the current thread */\n  private static final ThreadLocal<String> delegatedUserIPHolder = new ThreadLocal<String>();\n\n  /** Holds organization responsible for the current thread */\n  private static final ThreadLocal<Organization> organization = new ThreadLocal<Organization>();\n\n  /** The user directory */\n  private UserDirectoryService userDirectory;\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.security.api.SecurityService#getOrganization()\n   */\n  @Override\n  public Organization getOrganization() {\n    return SecurityServiceSpringImpl.organization.get();\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.security.api.SecurityService#setOrganization(Organization)\n   */\n  @Override\n  public void setOrganization(Organization organization) {\n    SecurityServiceSpringImpl.organization.set(organization);\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.security.api.SecurityService#getUser()\n   */\n  @Override\n  public User getUser() throws IllegalStateException {\n    Organization org = getOrganization();\n    if (org == null)\n      throw new IllegalStateException(\"No organization is set in security context\");\n\n    User delegatedUser = delegatedUserHolder.get();\n\n    if (delegatedUser != null) {\n      return delegatedUser;\n    }\n\n    Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n    JaxbOrganization jaxbOrganization = JaxbOrganization.fromOrganization(org);\n    if (auth != null) {\n      Object principal = auth.getPrincipal();\n      if ((principal != null) && (principal instanceof UserDetails)) {\n        UserDetails userDetails = (UserDetails) principal;\n\n        User user = null;\n\n        // If user exists, fetch it from the userDirectory\n        if (userDirectory != null) {\n          user = userDirectory.loadUser(userDetails.getUsername());\n          if (user == null) {\n            logger.debug(\n                    \"Authenticated user '{}' could not be found in any of the current UserProviders. Continuing anyway...\",\n                    userDetails.getUsername());\n          }\n        } else {\n          logger.debug(\"No UserDirectory was found when trying to search for user '{}'\", userDetails.getUsername());\n        }\n\n        // Add the roles (authorities) in the security context\n        Set<JaxbRole> roles = new HashSet<JaxbRole>();\n        Collection<? extends GrantedAuthority> authorities = auth.getAuthorities();\n        if (authorities != null) {\n          for (GrantedAuthority ga : authorities) {\n            roles.add(new JaxbRole(ga.getAuthority(), jaxbOrganization));\n          }\n        }\n\n        if (user == null) {\n          // No user was found. Create one to hold the auth information from the security context\n          user = new JaxbUser(userDetails.getUsername(), null, jaxbOrganization, roles);\n        } else {\n          // Combine the existing user with the roles in the security context\n          user = JaxbUser.fromUser(user, roles);\n        }\n\n        // Save the user to retrieve it quicker the next time(s) this method is called (by this thread)\n        delegatedUserHolder.set(user);\n\n        return user;\n      }\n    }\n\n    // Return the anonymous user by default\n    return SecurityUtil.createAnonymousUser(jaxbOrganization);\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.security.api.SecurityService#setUser(User)\n   */\n  @Override\n  public void setUser(User user) {\n    delegatedUserHolder.set(user);\n  }\n\n  @Override\n  public String getUserIP() {\n    return delegatedUserIPHolder.get();\n  }\n\n  @Override\n  public void setUserIP(String userIP) {\n    delegatedUserIPHolder.set(userIP);\n  }\n\n  /**\n   * OSGi callback for setting the user directory.\n   *\n   * @param userDirectory\n   *          the user directory\n   */\n  void setUserDirectory(UserDirectoryService userDirectory) {\n    this.userDirectory = userDirectory;\n  }\n\n  /**\n   * OSGi callback for removing the user directory.\n   */\n  void removeUserDirectory() {\n    this.userDirectory = null;\n  }\n\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700224,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.kernel.security;\n\nimport org.opencastproject.security.api.JaxbOrganization;\nimport org.opencastproject.security.api.JaxbRole;\nimport org.opencastproject.security.api.JaxbUser;\nimport org.opencastproject.security.api.Organization;\nimport org.opencastproject.security.api.SecurityService;\nimport org.opencastproject.security.api.User;\nimport org.opencastproject.security.api.UserDirectoryService;\nimport org.opencastproject.security.util.SecurityUtil;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.security.authentication.AnonymousAuthenticationToken;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * A Spring Security implementation of {@link SecurityService}.\n */\npublic class SecurityServiceSpringImpl implements SecurityService {\n\n  /** The logger */\n  private static final Logger logger = LoggerFactory.getLogger(SecurityServiceSpringImpl.class);\n\n  /** Holds delegates users for new threads that have been spawned from authenticated threads */\n  private static final ThreadLocal<User> delegatedUserHolder = new ThreadLocal<User>();\n\n  /** Holds the IP address for the delegated user for the current thread */\n  private static final ThreadLocal<String> delegatedUserIPHolder = new ThreadLocal<String>();\n\n  /** Holds organization responsible for the current thread */\n  private static final ThreadLocal<Organization> organization = new ThreadLocal<Organization>();\n\n  /** The user directory */\n  private UserDirectoryService userDirectory;\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.security.api.SecurityService#getOrganization()\n   */\n  @Override\n  public Organization getOrganization() {\n    return SecurityServiceSpringImpl.organization.get();\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.security.api.SecurityService#setOrganization(Organization)\n   */\n  @Override\n  public void setOrganization(Organization organization) {\n    SecurityServiceSpringImpl.organization.set(organization);\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.security.api.SecurityService#getUser()\n   */\n  @Override\n  public User getUser() throws IllegalStateException {\n    Organization org = getOrganization();\n    if (org == null)\n      throw new IllegalStateException(\"No organization is set in security context\");\n\n    User delegatedUser = delegatedUserHolder.get();\n\n    Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n    if (auth instanceof AnonymousAuthenticationToken) {\n      return SecurityUtil.createAnonymousUser(org);\n    }\n\n    if (delegatedUser != null) {\n      return delegatedUser;\n    }\n\n    JaxbOrganization jaxbOrganization = JaxbOrganization.fromOrganization(org);\n    if (auth != null) {\n      Object principal = auth.getPrincipal();\n      if ((principal instanceof UserDetails)) {\n        UserDetails userDetails = (UserDetails) principal;\n\n        User user = null;\n\n        // If user exists, fetch it from the userDirectory\n        if (userDirectory != null) {\n          user = userDirectory.loadUser(userDetails.getUsername());\n          if (user == null) {\n            logger.debug(\"Authenticated user '{}' could not be found in any of the current UserProviders. \"\n                + \"Continuing anyway...\", userDetails.getUsername());\n          }\n        } else {\n          logger.debug(\"No UserDirectory was found when trying to search for user '{}'\", userDetails.getUsername());\n        }\n\n        // Add the roles (authorities) in the security context\n        Set<JaxbRole> roles = new HashSet<>();\n        Collection<? extends GrantedAuthority> authorities = auth.getAuthorities();\n        if (authorities != null) {\n          for (GrantedAuthority ga : authorities) {\n            roles.add(new JaxbRole(ga.getAuthority(), jaxbOrganization));\n          }\n        }\n\n        if (user == null) {\n          // No user was found. Create one to hold the auth information from the security context\n          user = new JaxbUser(userDetails.getUsername(), null, jaxbOrganization, roles);\n        } else {\n          // Combine the existing user with the roles in the security context\n          user = JaxbUser.fromUser(user, roles);\n        }\n\n        // Save the user to retrieve it quicker the next time(s) this method is called (by this thread)\n        delegatedUserHolder.set(user);\n\n        return user;\n      }\n    }\n\n    // Return the anonymous user by default\n    return SecurityUtil.createAnonymousUser(jaxbOrganization);\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.security.api.SecurityService#setUser(User)\n   */\n  @Override\n  public void setUser(User user) {\n    delegatedUserHolder.set(user);\n  }\n\n  @Override\n  public String getUserIP() {\n    return delegatedUserIPHolder.get();\n  }\n\n  @Override\n  public void setUserIP(String userIP) {\n    delegatedUserIPHolder.set(userIP);\n  }\n\n  /**\n   * OSGi callback for setting the user directory.\n   *\n   * @param userDirectory\n   *          the user directory\n   */\n  void setUserDirectory(UserDirectoryService userDirectory) {\n    this.userDirectory = userDirectory;\n  }\n\n  /**\n   * OSGi callback for removing the user directory.\n   */\n  void removeUserDirectory() {\n    this.userDirectory = null;\n  }\n\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700225,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\npackage com.rtds.svc;\n\nimport com.rtds.jpa.CaptureType;\nimport java.util.List;\nimport javax.enterprise.context.ApplicationScoped;\nimport javax.inject.Inject;\nimport javax.persistence.EntityManager;\nimport javax.transaction.Transactional;\n\n/**\n *\n * @author jdh\n */\n@ApplicationScoped\n@Transactional\npublic class CaptureTypeService\n{\n    @Inject\n    EntityManager em;\n    \n    public void createOrUpdateCaptureType( CaptureType value )\n    {\n        if( value == null || value.getLabel() == null || value.getUrlSuffix() == null )\n        {\n            throw new IllegalArgumentException( \"The CaptureType, it's label and url_suffix must not be null.\" );\n        }\n        \n        CaptureType persistent = em.find( CaptureType.class, value.getUrlSuffix() );\n        \n        if( persistent != null )\n        {\n            persistent.setLabel( value.getLabel() );\n            persistent.setCaptureFilter( value.getCaptureFilter() );\n        }\n        else\n        {\n            em.persist( value );\n        }\n    }\n    \n    public String findFilter( String url_suffix )\n    {\n        if( url_suffix == null )\n        {\n            throw new IllegalArgumentException( \"The url_suffix must not be null.\" );\n        }\n        \n        CaptureType type = em.find( CaptureType.class, url_suffix );\n        \n        if( type != null )\n        {\n            return type.getCaptureFilter();\n        }\n        \n        return null;\n    }\n    \n    public CaptureType find( String url_suffix )\n    {\n        return em.find( CaptureType.class, url_suffix );\n    }\n    \n    public List<CaptureType> list()\n    {\n        return em.createQuery( \"select ct from CaptureType ct\", CaptureType.class ).getResultList();\n    }\n    \n    public void deleteCaptureType( String url_suffix )\n    {\n        if( url_suffix == null )\n        {\n            throw new IllegalArgumentException( \"The url_suffix must not be null.\" );\n        }\n        \n        CaptureType persistent = em.find( CaptureType.class, url_suffix );\n        \n        if( persistent != null )\n        {\n            em.remove( persistent );\n        }\n    }\n    \n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700296,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  },
  {
    "CWE_ID": [
      "CWE-287"
    ],
    "code": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\npackage com.rtds.svc;\n\nimport com.rtds.jpa.CaptureType;\nimport java.util.List;\nimport javax.enterprise.context.ApplicationScoped;\nimport javax.inject.Inject;\nimport javax.persistence.EntityManager;\nimport javax.transaction.Transactional;\n\n/**\n *\n * @author jdh\n */\n@ApplicationScoped\n@Transactional\npublic class CaptureTypeService\n{\n    @Inject\n    EntityManager em;\n    \n    public void createOrUpdateCaptureType( CaptureType value )\n    {\n        if( value == null || value.getLabel() == null || value.getUrlSuffix() == null )\n        {\n            throw new IllegalArgumentException( \"The CaptureType, it's label and url_suffix must not be null.\" );\n        }\n        \n        CaptureType persistent = em.find( CaptureType.class, value.getUrlSuffix() );\n        \n        if( persistent != null )\n        {\n            persistent.setLabel( value.getLabel() );\n            persistent.setCaptureFilter( value.getCaptureFilter() );\n        }\n        else\n        {\n            em.persist( value );\n        }\n    }\n    \n    public String findFilter( String url_suffix )\n    {\n        if( url_suffix == null )\n        {\n            throw new IllegalArgumentException( \"The url_suffix must not be null.\" );\n        }\n        \n        CaptureType type = em.find( CaptureType.class, url_suffix );\n        \n        if( type == null )\n        {\n            throw new IllegalArgumentException( \"The url_suffix must exist in the database.\" );\n        }\n        \n        // It is okay for the capture filter itself to be null, but the CaptureType\n        // must be in the database, otherwise the user could effectively forge\n        // a capture filter for \"all\" just by requesting a non-existent filter.\n        \n        return type.getCaptureFilter();\n    }\n    \n    public CaptureType find( String url_suffix )\n    {\n        return em.find( CaptureType.class, url_suffix );\n    }\n    \n    public List<CaptureType> list()\n    {\n        return em.createQuery( \"select ct from CaptureType ct\", CaptureType.class ).getResultList();\n    }\n    \n    public void deleteCaptureType( String url_suffix )\n    {\n        if( url_suffix == null )\n        {\n            throw new IllegalArgumentException( \"The url_suffix must not be null.\" );\n        }\n        \n        CaptureType persistent = em.find( CaptureType.class, url_suffix );\n        \n        if( persistent != null )\n        {\n            em.remove( persistent );\n        }\n    }\n    \n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700297,
    "RELATED_CWE": [
      "CWE-862",
      "CWE-285",
      "CWE-269"
    ]
  }
]