[
  {
    "CWE_ID": [
      "CWE-522"
    ],
    "code": "/*\n * Copyright 2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.gradle.api.publication.maven.internal.action;\n\nimport org.apache.maven.repository.internal.MavenRepositorySystemSession;\nimport org.apache.maven.repository.internal.SnapshotMetadataGeneratorFactory;\nimport org.apache.maven.repository.internal.VersionsMetadataGeneratorFactory;\nimport org.codehaus.plexus.DefaultContainerConfiguration;\nimport org.codehaus.plexus.DefaultPlexusContainer;\nimport org.codehaus.plexus.PlexusContainer;\nimport org.codehaus.plexus.PlexusContainerException;\nimport org.codehaus.plexus.classworlds.ClassWorld;\nimport org.codehaus.plexus.classworlds.realm.ClassRealm;\nimport org.codehaus.plexus.component.repository.exception.ComponentLookupException;\nimport org.gradle.api.GradleException;\nimport org.gradle.api.publish.maven.internal.publisher.MavenProjectIdentity;\nimport org.gradle.internal.UncheckedException;\nimport org.gradle.internal.operations.BuildOperationRef;\nimport org.gradle.internal.operations.CurrentBuildOperationRef;\nimport org.sonatype.aether.RepositoryException;\nimport org.sonatype.aether.RepositorySystem;\nimport org.sonatype.aether.RepositorySystemSession;\nimport org.sonatype.aether.artifact.Artifact;\nimport org.sonatype.aether.artifact.ArtifactType;\nimport org.sonatype.aether.impl.Deployer;\nimport org.sonatype.aether.impl.internal.DefaultDeployer;\nimport org.sonatype.aether.impl.internal.SimpleLocalRepositoryManager;\nimport org.sonatype.aether.util.DefaultRepositorySystemSession;\nimport org.sonatype.aether.util.artifact.DefaultArtifact;\n\nimport java.io.File;\nimport java.net.MalformedURLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nabstract class AbstractMavenPublishAction implements MavenPublishAction {\n    private final PlexusContainer container;\n    private final DefaultRepositorySystemSession session;\n    private final MavenProjectIdentity projectIdentity;\n\n    private final List<Artifact> attached = new ArrayList<Artifact>();\n    private Artifact pomArtifact;\n    private Artifact mainArtifact;\n\n    protected AbstractMavenPublishAction(String packaging, MavenProjectIdentity projectIdentity, List<File> wagonJars) {\n        container = newPlexusContainer(wagonJars);\n        session = new MavenRepositorySystemSession();\n        this.projectIdentity = projectIdentity;\n\n        CurrentBuildOperationRef currentBuildOperationRef = CurrentBuildOperationRef.instance();\n        BuildOperationRef currentBuildOperation = currentBuildOperationRef.get();\n        session.setTransferListener(new LoggingMavenTransferListener(currentBuildOperationRef, currentBuildOperation));\n\n        pomArtifact = new DefaultArtifact(projectIdentity.getGroupId().get(), projectIdentity.getArtifactId().get(), \"pom\", projectIdentity.getVersion().get());\n        mainArtifact = createTypedArtifact(packaging, null);\n    }\n\n    public void setLocalMavenRepositoryLocation(File localMavenRepository) {\n        session.setLocalRepositoryManager(new SimpleLocalRepositoryManager(localMavenRepository));\n    }\n\n    @Override\n    public void setPomArtifact(File file) {\n        pomArtifact = pomArtifact.setFile(file);\n    }\n\n    @Override\n    public void setMainArtifact(File file) {\n        mainArtifact = mainArtifact.setFile(file);\n    }\n\n    @Override\n    public void addAdditionalArtifact(File file, String type, String classifier) {\n        attached.add(createTypedArtifact(type, classifier).setFile(file));\n    }\n\n    @Override\n    public void publish() {\n        List<Artifact> artifacts = new ArrayList<Artifact>();\n        if (mainArtifact.getFile() != null) {\n            artifacts.add(mainArtifact);\n        }\n        artifacts.add(pomArtifact);\n        for (Artifact artifact : attached) {\n            File file = artifact.getFile();\n            if (file != null && file.isFile()) {\n                artifacts.add(artifact);\n            }\n        }\n\n        try {\n            publishArtifacts(artifacts, newRepositorySystem(), session);\n        } catch (RepositoryException e) {\n            throw new GradleException(e.getMessage(), e);\n        }\n    }\n\n    protected abstract void publishArtifacts(Collection<Artifact> artifact, RepositorySystem repositorySystem, RepositorySystemSession session) throws RepositoryException;\n\n    protected PlexusContainer getContainer() {\n        return container;\n    }\n\n    private PlexusContainer newPlexusContainer(List<File> wagonJars) {\n        try {\n            ClassWorld world = new ClassWorld(\"plexus.core\", ClassWorld.class.getClassLoader());\n            ClassRealm classRealm = new ClassRealm(world, \"plexus.core\", ClassWorld.class.getClassLoader());\n            if (wagonJars != null) {\n                for (File jar : wagonJars) {\n                    classRealm.addURL(jar.toURI().toURL());\n                }\n            }\n            return new DefaultPlexusContainer(new DefaultContainerConfiguration().setRealm(classRealm));\n        } catch (PlexusContainerException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        } catch (MalformedURLException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }\n\n    private RepositorySystem newRepositorySystem() {\n        try {\n            DefaultDeployer deployer = (DefaultDeployer) getContainer().lookup(Deployer.class);\n            // This is a workaround for https://issues.gradle.org/browse/GRADLE-3324.\n            // Somehow the ArrayList 'result' in `org.sonatype.aether.impl.internal.Utils#sortMetadataGeneratorFactories` ends up\n            // being a list of nulls on windows and IBM's 1.6 JDK.\n            deployer.setMetadataFactories(null);\n            deployer.addMetadataGeneratorFactory(new VersionsMetadataGeneratorFactory());\n            deployer.addMetadataGeneratorFactory(new SnapshotMetadataGeneratorFactory());\n            return container.lookup(RepositorySystem.class);\n        } catch (ComponentLookupException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }\n\n    private Artifact createTypedArtifact(String type, String classifier) {\n        String extension = type;\n        ArtifactType stereotype = session.getArtifactTypeRegistry().get(type);\n        if (stereotype != null) {\n            extension = stereotype.getExtension();\n            if (classifier == null) {\n                classifier = stereotype.getClassifier();\n            }\n        }\n        return new DefaultArtifact(projectIdentity.getGroupId().get(), projectIdentity.getArtifactId().get(), classifier, extension, projectIdentity.getVersion().get());\n    }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700114,
    "RELATED_CWE": [
      "CWE-601",
      "CWE-285",
      "CWE-703"
    ]
  },
  {
    "CWE_ID": [
      "CWE-522"
    ],
    "code": "/*\n * Copyright 2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.gradle.api.publication.maven.internal.action;\n\nimport org.apache.maven.repository.internal.MavenRepositorySystemSession;\nimport org.apache.maven.repository.internal.SnapshotMetadataGeneratorFactory;\nimport org.apache.maven.repository.internal.VersionsMetadataGeneratorFactory;\nimport org.codehaus.plexus.DefaultContainerConfiguration;\nimport org.codehaus.plexus.DefaultPlexusContainer;\nimport org.codehaus.plexus.PlexusContainer;\nimport org.codehaus.plexus.PlexusContainerException;\nimport org.codehaus.plexus.classworlds.ClassWorld;\nimport org.codehaus.plexus.classworlds.realm.ClassRealm;\nimport org.codehaus.plexus.component.repository.exception.ComponentLookupException;\nimport org.gradle.api.GradleException;\nimport org.gradle.api.publish.maven.internal.publisher.MavenProjectIdentity;\nimport org.gradle.internal.UncheckedException;\nimport org.gradle.internal.operations.BuildOperationRef;\nimport org.gradle.internal.operations.CurrentBuildOperationRef;\nimport org.gradle.internal.resource.UriTextResource;\nimport org.sonatype.aether.ConfigurationProperties;\nimport org.sonatype.aether.RepositoryException;\nimport org.sonatype.aether.RepositorySystem;\nimport org.sonatype.aether.RepositorySystemSession;\nimport org.sonatype.aether.artifact.Artifact;\nimport org.sonatype.aether.artifact.ArtifactType;\nimport org.sonatype.aether.impl.Deployer;\nimport org.sonatype.aether.impl.internal.DefaultDeployer;\nimport org.sonatype.aether.impl.internal.SimpleLocalRepositoryManager;\nimport org.sonatype.aether.util.DefaultRepositorySystemSession;\nimport org.sonatype.aether.util.artifact.DefaultArtifact;\n\nimport java.io.File;\nimport java.net.MalformedURLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nabstract class AbstractMavenPublishAction implements MavenPublishAction {\n    private final PlexusContainer container;\n    private final DefaultRepositorySystemSession session;\n    private final MavenProjectIdentity projectIdentity;\n\n    private final List<Artifact> attached = new ArrayList<Artifact>();\n    private Artifact pomArtifact;\n    private Artifact mainArtifact;\n\n    protected AbstractMavenPublishAction(String packaging, MavenProjectIdentity projectIdentity, List<File> wagonJars) {\n        container = newPlexusContainer(wagonJars);\n        session = new MavenRepositorySystemSession();\n        this.projectIdentity = projectIdentity;\n\n        CurrentBuildOperationRef currentBuildOperationRef = CurrentBuildOperationRef.instance();\n        BuildOperationRef currentBuildOperation = currentBuildOperationRef.get();\n        session.getConfigProperties().put(ConfigurationProperties.USER_AGENT, UriTextResource.getUserAgentString());\n        session.setTransferListener(new LoggingMavenTransferListener(currentBuildOperationRef, currentBuildOperation));\n\n        pomArtifact = new DefaultArtifact(projectIdentity.getGroupId().get(), projectIdentity.getArtifactId().get(), \"pom\", projectIdentity.getVersion().get());\n        mainArtifact = createTypedArtifact(packaging, null);\n    }\n\n    public void setLocalMavenRepositoryLocation(File localMavenRepository) {\n        session.setLocalRepositoryManager(new SimpleLocalRepositoryManager(localMavenRepository));\n    }\n\n    @Override\n    public void setPomArtifact(File file) {\n        pomArtifact = pomArtifact.setFile(file);\n    }\n\n    @Override\n    public void setMainArtifact(File file) {\n        mainArtifact = mainArtifact.setFile(file);\n    }\n\n    @Override\n    public void addAdditionalArtifact(File file, String type, String classifier) {\n        attached.add(createTypedArtifact(type, classifier).setFile(file));\n    }\n\n    @Override\n    public void publish() {\n        List<Artifact> artifacts = new ArrayList<Artifact>();\n        if (mainArtifact.getFile() != null) {\n            artifacts.add(mainArtifact);\n        }\n        artifacts.add(pomArtifact);\n        for (Artifact artifact : attached) {\n            File file = artifact.getFile();\n            if (file != null && file.isFile()) {\n                artifacts.add(artifact);\n            }\n        }\n\n        try {\n            publishArtifacts(artifacts, newRepositorySystem(), session);\n        } catch (RepositoryException e) {\n            throw new GradleException(e.getMessage(), e);\n        }\n    }\n\n    protected abstract void publishArtifacts(Collection<Artifact> artifact, RepositorySystem repositorySystem, RepositorySystemSession session) throws RepositoryException;\n\n    protected PlexusContainer getContainer() {\n        return container;\n    }\n\n    private PlexusContainer newPlexusContainer(List<File> wagonJars) {\n        try {\n            ClassWorld world = new ClassWorld(\"plexus.core\", ClassWorld.class.getClassLoader());\n            ClassRealm classRealm = new ClassRealm(world, \"plexus.core\", ClassWorld.class.getClassLoader());\n            if (wagonJars != null) {\n                for (File jar : wagonJars) {\n                    classRealm.addURL(jar.toURI().toURL());\n                }\n            }\n            return new DefaultPlexusContainer(new DefaultContainerConfiguration().setRealm(classRealm));\n        } catch (PlexusContainerException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        } catch (MalformedURLException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }\n\n    private RepositorySystem newRepositorySystem() {\n        try {\n            DefaultDeployer deployer = (DefaultDeployer) getContainer().lookup(Deployer.class);\n            // This is a workaround for https://issues.gradle.org/browse/GRADLE-3324.\n            // Somehow the ArrayList 'result' in `org.sonatype.aether.impl.internal.Utils#sortMetadataGeneratorFactories` ends up\n            // being a list of nulls on windows and IBM's 1.6 JDK.\n            deployer.setMetadataFactories(null);\n            deployer.addMetadataGeneratorFactory(new VersionsMetadataGeneratorFactory());\n            deployer.addMetadataGeneratorFactory(new SnapshotMetadataGeneratorFactory());\n            return container.lookup(RepositorySystem.class);\n        } catch (ComponentLookupException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }\n\n    private Artifact createTypedArtifact(String type, String classifier) {\n        String extension = type;\n        ArtifactType stereotype = session.getArtifactTypeRegistry().get(type);\n        if (stereotype != null) {\n            extension = stereotype.getExtension();\n            if (classifier == null) {\n                classifier = stereotype.getClassifier();\n            }\n        }\n        return new DefaultArtifact(projectIdentity.getGroupId().get(), projectIdentity.getArtifactId().get(), classifier, extension, projectIdentity.getVersion().get());\n    }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700115,
    "RELATED_CWE": [
      "CWE-601",
      "CWE-285",
      "CWE-703"
    ]
  },
  {
    "CWE_ID": [
      "CWE-522"
    ],
    "code": "/*\n * Copyright 2016 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.gradle.caching.http.internal;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport org.gradle.api.GradleException;\nimport org.gradle.authentication.Authentication;\nimport org.gradle.caching.BuildCacheService;\nimport org.gradle.caching.BuildCacheServiceFactory;\nimport org.gradle.caching.http.HttpBuildCache;\nimport org.gradle.caching.http.HttpBuildCacheCredentials;\nimport org.gradle.internal.authentication.DefaultBasicAuthentication;\nimport org.gradle.internal.resource.transport.http.DefaultHttpSettings;\nimport org.gradle.internal.resource.transport.http.HttpClientHelper;\nimport org.gradle.internal.resource.transport.http.SslContextFactory;\n\nimport javax.inject.Inject;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * Build cache factory for HTTP backend.\n */\npublic class DefaultHttpBuildCacheServiceFactory implements BuildCacheServiceFactory<HttpBuildCache> {\n\n    private final SslContextFactory sslContextFactory;\n    private final HttpBuildCacheRequestCustomizer requestCustomizer;\n\n    @Inject\n    public DefaultHttpBuildCacheServiceFactory(SslContextFactory sslContextFactory, HttpBuildCacheRequestCustomizer requestCustomizer) {\n        this.sslContextFactory = sslContextFactory;\n        this.requestCustomizer = requestCustomizer;\n    }\n\n    @Override\n    public BuildCacheService createBuildCacheService(HttpBuildCache configuration, Describer describer) {\n        URI url = configuration.getUrl();\n        if (url == null) {\n            throw new IllegalStateException(\"HTTP build cache has no URL configured\");\n        }\n        URI noUserInfoUrl = stripUserInfo(url);\n\n        HttpBuildCacheCredentials credentials = configuration.getCredentials();\n        if (!credentialsPresent(credentials) && url.getUserInfo() != null) {\n            credentials = extractCredentialsFromUserInfo(url);\n        }\n\n        Collection<Authentication> authentications = Collections.emptyList();\n        if (credentialsPresent(credentials)) {\n            DefaultBasicAuthentication basicAuthentication = new DefaultBasicAuthentication(\"basic\");\n            basicAuthentication.setCredentials(credentials);\n            authentications = Collections.<Authentication>singleton(basicAuthentication);\n        }\n\n        boolean authenticated = !authentications.isEmpty();\n        boolean allowUntrustedServer = configuration.isAllowUntrustedServer();\n        DefaultHttpSettings.Builder builder = DefaultHttpSettings.builder()\n            .withAuthenticationSettings(authentications)\n            .followRedirects(false);\n        if (allowUntrustedServer) {\n            builder.allowUntrustedConnections();\n        } else {\n            builder.withSslContextFactory(sslContextFactory);\n        }\n        HttpClientHelper httpClientHelper = new HttpClientHelper(builder.build());\n\n        describer.type(\"HTTP\")\n            .config(\"url\", noUserInfoUrl.toASCIIString())\n            .config(\"authenticated\", Boolean.toString(authenticated))\n            .config(\"allowUntrustedServer\", Boolean.toString(allowUntrustedServer));\n\n        return new HttpBuildCacheService(httpClientHelper, noUserInfoUrl, requestCustomizer);\n    }\n\n    @VisibleForTesting\n    static HttpBuildCacheCredentials extractCredentialsFromUserInfo(URI url) {\n        HttpBuildCacheCredentials credentials = new HttpBuildCacheCredentials();\n        String userInfo = url.getUserInfo();\n        int indexOfSeparator = userInfo.indexOf(':');\n        if (indexOfSeparator > -1) {\n            String username = userInfo.substring(0, indexOfSeparator);\n            String password = userInfo.substring(indexOfSeparator + 1);\n            credentials.setUsername(username);\n            credentials.setPassword(password);\n        }\n        return credentials;\n    }\n\n    private static URI stripUserInfo(URI uri) {\n        try {\n            return new URI(uri.getScheme(), null, uri.getHost(), uri.getPort(), uri.getPath(), uri.getQuery(), uri.getFragment());\n        } catch (URISyntaxException e) {\n            throw new GradleException(\"Error constructing URL for http build cache\", e);\n        }\n    }\n\n    private static boolean credentialsPresent(HttpBuildCacheCredentials credentials) {\n        return credentials.getUsername() != null && credentials.getPassword() != null;\n    }\n\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700116,
    "RELATED_CWE": [
      "CWE-601",
      "CWE-285",
      "CWE-703"
    ]
  },
  {
    "CWE_ID": [
      "CWE-522"
    ],
    "code": "/*\n * Copyright 2016 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.gradle.caching.http.internal;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport org.gradle.api.GradleException;\nimport org.gradle.authentication.Authentication;\nimport org.gradle.caching.BuildCacheService;\nimport org.gradle.caching.BuildCacheServiceFactory;\nimport org.gradle.caching.http.HttpBuildCache;\nimport org.gradle.caching.http.HttpBuildCacheCredentials;\nimport org.gradle.internal.authentication.DefaultBasicAuthentication;\nimport org.gradle.internal.resource.transport.http.DefaultHttpSettings;\nimport org.gradle.internal.resource.transport.http.HttpClientHelper;\nimport org.gradle.internal.resource.transport.http.SslContextFactory;\n\nimport javax.inject.Inject;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * Build cache factory for HTTP backend.\n */\npublic class DefaultHttpBuildCacheServiceFactory implements BuildCacheServiceFactory<HttpBuildCache> {\n\n    private final SslContextFactory sslContextFactory;\n    private final HttpBuildCacheRequestCustomizer requestCustomizer;\n\n    @Inject\n    public DefaultHttpBuildCacheServiceFactory(SslContextFactory sslContextFactory, HttpBuildCacheRequestCustomizer requestCustomizer) {\n        this.sslContextFactory = sslContextFactory;\n        this.requestCustomizer = requestCustomizer;\n    }\n\n    @Override\n    public BuildCacheService createBuildCacheService(HttpBuildCache configuration, Describer describer) {\n        URI url = configuration.getUrl();\n        if (url == null) {\n            throw new IllegalStateException(\"HTTP build cache has no URL configured\");\n        }\n        URI noUserInfoUrl = stripUserInfo(url);\n\n        HttpBuildCacheCredentials credentials = configuration.getCredentials();\n        if (!credentialsPresent(credentials) && url.getUserInfo() != null) {\n            credentials = extractCredentialsFromUserInfo(url);\n        }\n\n        Collection<Authentication> authentications = Collections.emptyList();\n        if (credentialsPresent(credentials)) {\n            DefaultBasicAuthentication basicAuthentication = new DefaultBasicAuthentication(\"basic\");\n            basicAuthentication.setCredentials(credentials);\n            basicAuthentication.addHost(url.getHost(), url.getPort());\n            authentications = Collections.<Authentication>singleton(basicAuthentication);\n        }\n\n        boolean authenticated = !authentications.isEmpty();\n        boolean allowUntrustedServer = configuration.isAllowUntrustedServer();\n        DefaultHttpSettings.Builder builder = DefaultHttpSettings.builder()\n            .withAuthenticationSettings(authentications)\n            .followRedirects(false);\n        if (allowUntrustedServer) {\n            builder.allowUntrustedConnections();\n        } else {\n            builder.withSslContextFactory(sslContextFactory);\n        }\n        HttpClientHelper httpClientHelper = new HttpClientHelper(builder.build());\n\n        describer.type(\"HTTP\")\n            .config(\"url\", noUserInfoUrl.toASCIIString())\n            .config(\"authenticated\", Boolean.toString(authenticated))\n            .config(\"allowUntrustedServer\", Boolean.toString(allowUntrustedServer));\n\n        return new HttpBuildCacheService(httpClientHelper, noUserInfoUrl, requestCustomizer);\n    }\n\n    @VisibleForTesting\n    static HttpBuildCacheCredentials extractCredentialsFromUserInfo(URI url) {\n        HttpBuildCacheCredentials credentials = new HttpBuildCacheCredentials();\n        String userInfo = url.getUserInfo();\n        int indexOfSeparator = userInfo.indexOf(':');\n        if (indexOfSeparator > -1) {\n            String username = userInfo.substring(0, indexOfSeparator);\n            String password = userInfo.substring(indexOfSeparator + 1);\n            credentials.setUsername(username);\n            credentials.setPassword(password);\n        }\n        return credentials;\n    }\n\n    private static URI stripUserInfo(URI uri) {\n        try {\n            return new URI(uri.getScheme(), null, uri.getHost(), uri.getPort(), uri.getPath(), uri.getQuery(), uri.getFragment());\n        } catch (URISyntaxException e) {\n            throw new GradleException(\"Error constructing URL for http build cache\", e);\n        }\n    }\n\n    private static boolean credentialsPresent(HttpBuildCacheCredentials credentials) {\n        return credentials.getUsername() != null && credentials.getPassword() != null;\n    }\n\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700117,
    "RELATED_CWE": [
      "CWE-601",
      "CWE-285",
      "CWE-703"
    ]
  },
  {
    "CWE_ID": [
      "CWE-522"
    ],
    "code": "/*\n * Copyright 2011 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.gradle.api.internal.artifacts.repositories;\n\nimport org.gradle.api.Action;\nimport org.gradle.api.Transformer;\nimport org.gradle.api.artifacts.repositories.AuthenticationContainer;\nimport org.gradle.api.artifacts.repositories.PasswordCredentials;\nimport org.gradle.api.credentials.Credentials;\nimport org.gradle.api.model.ObjectFactory;\nimport org.gradle.authentication.Authentication;\nimport org.gradle.internal.Cast;\nimport org.gradle.internal.artifacts.repositories.AuthenticationSupportedInternal;\nimport org.gradle.internal.authentication.AuthenticationInternal;\nimport org.gradle.internal.reflect.Instantiator;\nimport org.gradle.util.CollectionUtils;\n\nimport javax.annotation.Nullable;\nimport java.util.Collection;\nimport java.util.List;\n\npublic abstract class AbstractAuthenticationSupportedRepository extends AbstractResolutionAwareArtifactRepository implements AuthenticationSupportedInternal {\n    private final AuthenticationSupporter delegate;\n\n    AbstractAuthenticationSupportedRepository(Instantiator instantiator, AuthenticationContainer authenticationContainer, ObjectFactory objectFactory) {\n        super(objectFactory);\n        this.delegate = new AuthenticationSupporter(instantiator, authenticationContainer);\n    }\n\n    @Override\n    public PasswordCredentials getCredentials() {\n        invalidateDescriptor();\n        return delegate.getCredentials();\n    }\n\n    @Override\n    public <T extends Credentials> T getCredentials(Class<T> credentialsType) {\n        invalidateDescriptor();\n        return delegate.getCredentials(credentialsType);\n    }\n\n    @Nullable\n    @Override\n    public Credentials getConfiguredCredentials() {\n        return delegate.getConfiguredCredentials();\n    }\n\n    @Override\n    public void setConfiguredCredentials(Credentials credentials) {\n        invalidateDescriptor();\n        delegate.setConfiguredCredentials(credentials);\n    }\n\n    @Override\n    public void credentials(Action<? super PasswordCredentials> action) {\n        invalidateDescriptor();\n        delegate.credentials(action);\n    }\n\n    @Override\n    public <T extends Credentials> void credentials(Class<T> credentialsType, Action<? super T> action) throws IllegalStateException {\n        invalidateDescriptor();\n        delegate.credentials(credentialsType, action);\n    }\n\n    @Override\n    public void authentication(Action<? super AuthenticationContainer> action) {\n        invalidateDescriptor();\n        delegate.authentication(action);\n    }\n\n    @Override\n    public AuthenticationContainer getAuthentication() {\n        invalidateDescriptor();\n        return delegate.getAuthentication();\n    }\n\n    @Override\n    public Collection<Authentication> getConfiguredAuthentication() {\n        return delegate.getConfiguredAuthentication();\n    }\n\n    List<String> getAuthenticationSchemes() {\n        return CollectionUtils.collect(getConfiguredAuthentication(), new Transformer<String, Authentication>() {\n            @Override\n            public String transform(Authentication authentication) {\n                return Cast.cast(AuthenticationInternal.class, authentication).getType().getSimpleName();\n            }\n        });\n    }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700118,
    "RELATED_CWE": [
      "CWE-601",
      "CWE-285",
      "CWE-703"
    ]
  },
  {
    "CWE_ID": [
      "CWE-522"
    ],
    "code": "/*\n * Copyright 2011 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.gradle.api.internal.artifacts.repositories;\n\nimport org.gradle.api.Action;\nimport org.gradle.api.Transformer;\nimport org.gradle.api.artifacts.repositories.AuthenticationContainer;\nimport org.gradle.api.artifacts.repositories.PasswordCredentials;\nimport org.gradle.api.credentials.Credentials;\nimport org.gradle.api.model.ObjectFactory;\nimport org.gradle.authentication.Authentication;\nimport org.gradle.internal.Cast;\nimport org.gradle.internal.artifacts.repositories.AuthenticationSupportedInternal;\nimport org.gradle.internal.authentication.AuthenticationInternal;\nimport org.gradle.internal.reflect.Instantiator;\nimport org.gradle.util.CollectionUtils;\n\nimport javax.annotation.Nullable;\nimport java.net.URI;\nimport java.util.Collection;\nimport java.util.List;\n\npublic abstract class AbstractAuthenticationSupportedRepository extends AbstractResolutionAwareArtifactRepository implements AuthenticationSupportedInternal {\n    private final AuthenticationSupporter delegate;\n\n    AbstractAuthenticationSupportedRepository(Instantiator instantiator, AuthenticationContainer authenticationContainer, ObjectFactory objectFactory) {\n        super(objectFactory);\n        this.delegate = new AuthenticationSupporter(instantiator, authenticationContainer);\n    }\n\n    @Override\n    public PasswordCredentials getCredentials() {\n        invalidateDescriptor();\n        return delegate.getCredentials();\n    }\n\n    @Override\n    public <T extends Credentials> T getCredentials(Class<T> credentialsType) {\n        invalidateDescriptor();\n        return delegate.getCredentials(credentialsType);\n    }\n\n    @Nullable\n    @Override\n    public Credentials getConfiguredCredentials() {\n        return delegate.getConfiguredCredentials();\n    }\n\n    @Override\n    public void setConfiguredCredentials(Credentials credentials) {\n        invalidateDescriptor();\n        delegate.setConfiguredCredentials(credentials);\n    }\n\n    @Override\n    public void credentials(Action<? super PasswordCredentials> action) {\n        invalidateDescriptor();\n        delegate.credentials(action);\n    }\n\n    @Override\n    public <T extends Credentials> void credentials(Class<T> credentialsType, Action<? super T> action) throws IllegalStateException {\n        invalidateDescriptor();\n        delegate.credentials(credentialsType, action);\n    }\n\n    @Override\n    public void authentication(Action<? super AuthenticationContainer> action) {\n        invalidateDescriptor();\n        delegate.authentication(action);\n    }\n\n    @Override\n    public AuthenticationContainer getAuthentication() {\n        invalidateDescriptor();\n        return delegate.getAuthentication();\n    }\n\n    @Override\n    public Collection<Authentication> getConfiguredAuthentication() {\n        return CollectionUtils.collect(delegate.getConfiguredAuthentication(), authentication -> {\n            URI repositoryUrl = getRepositoryUrl();\n            if (repositoryUrl != null) {\n                ((AuthenticationInternal) authentication).setHostAndPort(repositoryUrl.getHost(), repositoryUrl.getPort());\n            }\n            return authentication;\n        });\n    }\n\n    protected URI getRepositoryUrl() {\n        return null;\n    }\n\n    List<String> getAuthenticationSchemes() {\n        return CollectionUtils.collect(getConfiguredAuthentication(), new Transformer<String, Authentication>() {\n            @Override\n            public String transform(Authentication authentication) {\n                return Cast.cast(AuthenticationInternal.class, authentication).getType().getSimpleName();\n            }\n        });\n    }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700119,
    "RELATED_CWE": [
      "CWE-601",
      "CWE-285",
      "CWE-703"
    ]
  },
  {
    "CWE_ID": [
      "CWE-522"
    ],
    "code": "/*\n * Copyright 2011 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.gradle.internal.resource.transport.http;\n\nimport com.google.common.collect.Lists;\nimport org.apache.http.HttpException;\nimport org.apache.http.HttpHost;\nimport org.apache.http.HttpRequest;\nimport org.apache.http.HttpRequestInterceptor;\nimport org.apache.http.auth.AuthScheme;\nimport org.apache.http.auth.AuthSchemeProvider;\nimport org.apache.http.auth.AuthScope;\nimport org.apache.http.auth.AuthState;\nimport org.apache.http.auth.Credentials;\nimport org.apache.http.auth.NTCredentials;\nimport org.apache.http.auth.UsernamePasswordCredentials;\nimport org.apache.http.client.CredentialsProvider;\nimport org.apache.http.client.config.AuthSchemes;\nimport org.apache.http.client.config.CookieSpecs;\nimport org.apache.http.client.config.RequestConfig;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.client.methods.HttpPut;\nimport org.apache.http.client.protocol.HttpClientContext;\nimport org.apache.http.client.utils.DateUtils;\nimport org.apache.http.config.RegistryBuilder;\nimport org.apache.http.config.SocketConfig;\nimport org.apache.http.conn.ssl.SSLConnectionSocketFactory;\nimport org.apache.http.conn.util.PublicSuffixMatcher;\nimport org.apache.http.conn.util.PublicSuffixMatcherLoader;\nimport org.apache.http.cookie.CookieSpecProvider;\nimport org.apache.http.impl.auth.BasicScheme;\nimport org.apache.http.impl.auth.BasicSchemeFactory;\nimport org.apache.http.impl.auth.DigestSchemeFactory;\nimport org.apache.http.impl.auth.KerberosSchemeFactory;\nimport org.apache.http.impl.auth.SPNegoSchemeFactory;\nimport org.apache.http.impl.client.HttpClientBuilder;\nimport org.apache.http.impl.client.SystemDefaultCredentialsProvider;\nimport org.apache.http.impl.conn.SystemDefaultRoutePlanner;\nimport org.apache.http.impl.cookie.DefaultCookieSpecProvider;\nimport org.apache.http.impl.cookie.IgnoreSpecProvider;\nimport org.apache.http.impl.cookie.NetscapeDraftSpecProvider;\nimport org.apache.http.impl.cookie.RFC6265CookieSpecProvider;\nimport org.apache.http.protocol.HttpContext;\nimport org.apache.http.protocol.HttpCoreContext;\nimport org.gradle.api.JavaVersion;\nimport org.gradle.api.credentials.HttpHeaderCredentials;\nimport org.gradle.api.credentials.PasswordCredentials;\nimport org.gradle.api.specs.Spec;\nimport org.gradle.authentication.Authentication;\nimport org.gradle.authentication.http.BasicAuthentication;\nimport org.gradle.authentication.http.DigestAuthentication;\nimport org.gradle.authentication.http.HttpHeaderAuthentication;\nimport org.gradle.internal.authentication.AllSchemesAuthentication;\nimport org.gradle.internal.authentication.AuthenticationInternal;\nimport org.gradle.internal.jvm.Jvm;\nimport org.gradle.internal.resource.UriTextResource;\nimport org.gradle.internal.resource.transport.http.ntlm.NTLMCredentials;\nimport org.gradle.internal.resource.transport.http.ntlm.NTLMSchemeFactory;\nimport org.gradle.util.CollectionUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.net.ssl.HostnameVerifier;\nimport java.net.ProxySelector;\nimport java.util.Collection;\nimport java.util.Collections;\n\npublic class HttpClientConfigurer {\n    private static final Logger LOGGER = LoggerFactory.getLogger(HttpClientConfigurer.class);\n    private static final int MAX_HTTP_CONNECTIONS = 20;\n    private static final String[] SSL_PROTOCOLS;\n\n    private static final String HTTPS_PROTOCOLS = \"https.protocols\";\n\n    static {\n        String httpsProtocols = System.getProperty(HTTPS_PROTOCOLS);\n        if (httpsProtocols != null) {\n            SSL_PROTOCOLS = httpsProtocols.split(\",\");\n        } else if (JavaVersion.current().isJava7() || (JavaVersion.current().isJava8() && Jvm.current().isIbmJvm())) {\n            SSL_PROTOCOLS = new String[]{\"TLSv1\", \"TLSv1.1\", \"TLSv1.2\"};\n        } else {\n            SSL_PROTOCOLS = null;\n        }\n    }\n\n    private final HttpSettings httpSettings;\n\n    public HttpClientConfigurer(HttpSettings httpSettings) {\n        this.httpSettings = httpSettings;\n    }\n\n    public void configure(HttpClientBuilder builder) {\n        SystemDefaultCredentialsProvider credentialsProvider = new SystemDefaultCredentialsProvider();\n        configureSslSocketConnectionFactory(builder, httpSettings.getSslContextFactory(), httpSettings.getHostnameVerifier());\n        configureAuthSchemeRegistry(builder);\n        configureCredentials(builder, credentialsProvider, httpSettings.getAuthenticationSettings());\n        configureProxy(builder, credentialsProvider, httpSettings);\n        configureUserAgent(builder);\n        configureCookieSpecRegistry(builder);\n        configureRequestConfig(builder);\n        configureSocketConfig(builder);\n        configureRedirectStrategy(builder);\n        builder.setDefaultCredentialsProvider(credentialsProvider);\n        builder.setMaxConnTotal(MAX_HTTP_CONNECTIONS);\n        builder.setMaxConnPerRoute(MAX_HTTP_CONNECTIONS);\n    }\n\n    private void configureSslSocketConnectionFactory(HttpClientBuilder builder, SslContextFactory sslContextFactory, HostnameVerifier hostnameVerifier) {\n        builder.setSSLSocketFactory(new SSLConnectionSocketFactory(sslContextFactory.createSslContext(), SSL_PROTOCOLS, null, hostnameVerifier));\n    }\n\n    private void configureAuthSchemeRegistry(HttpClientBuilder builder) {\n        builder.setDefaultAuthSchemeRegistry(RegistryBuilder.<AuthSchemeProvider>create()\n            .register(AuthSchemes.BASIC, new BasicSchemeFactory())\n            .register(AuthSchemes.DIGEST, new DigestSchemeFactory())\n            .register(AuthSchemes.NTLM, new NTLMSchemeFactory())\n            .register(AuthSchemes.SPNEGO, new SPNegoSchemeFactory())\n            .register(AuthSchemes.KERBEROS, new KerberosSchemeFactory())\n            .register(HttpHeaderAuthScheme.AUTH_SCHEME_NAME, new HttpHeaderSchemeFactory())\n            .build()\n        );\n    }\n\n    private void configureCredentials(HttpClientBuilder builder, CredentialsProvider credentialsProvider, Collection<Authentication> authentications) {\n        if(authentications.size() > 0) {\n            useCredentials(credentialsProvider, authentications);\n\n            // Use preemptive authorisation if no other authorisation has been established\n            builder.addInterceptorFirst(new PreemptiveAuth(getAuthScheme(authentications), isPreemptiveEnabled(authentications)));\n        }\n    }\n\n    private AuthScheme getAuthScheme(final Collection<Authentication> authentications) {\n        if (authentications.size() == 1) {\n            if (authentications.iterator().next() instanceof HttpHeaderAuthentication) {\n                return new HttpHeaderAuthScheme();\n            }\n        }\n        return new BasicScheme();\n    }\n\n    private void configureProxy(HttpClientBuilder builder, CredentialsProvider credentialsProvider, HttpSettings httpSettings) {\n        HttpProxySettings.HttpProxy httpProxy = httpSettings.getProxySettings().getProxy();\n        HttpProxySettings.HttpProxy httpsProxy = httpSettings.getSecureProxySettings().getProxy();\n\n        for (HttpProxySettings.HttpProxy proxy : Lists.newArrayList(httpProxy, httpsProxy)) {\n            if (proxy != null) {\n                if (proxy.credentials != null) {\n                    AllSchemesAuthentication authentication = new AllSchemesAuthentication(proxy.credentials);\n                    authentication.setHostAndPort(proxy.host, proxy.port);\n                    useCredentials(credentialsProvider, Collections.singleton(authentication));\n                }\n            }\n        }\n        builder.setRoutePlanner(new SystemDefaultRoutePlanner(ProxySelector.getDefault()));\n    }\n\n    private void useCredentials(CredentialsProvider credentialsProvider, Collection<? extends Authentication> authentications) {\n        for (Authentication authentication : authentications) {\n            AuthenticationInternal authenticationInternal = (AuthenticationInternal) authentication;\n\n            String scheme = getAuthScheme(authentication);\n            org.gradle.api.credentials.Credentials credentials = authenticationInternal.getCredentials();\n            String host = authenticationInternal.getHost();\n            int port = authenticationInternal.getPort();\n\n            if (credentials instanceof HttpHeaderCredentials) {\n                HttpHeaderCredentials httpHeaderCredentials = (HttpHeaderCredentials) credentials;\n                Credentials httpCredentials = new HttpClientHttpHeaderCredentials(httpHeaderCredentials.getName(), httpHeaderCredentials.getValue());\n                credentialsProvider.setCredentials(new AuthScope(host, port, AuthScope.ANY_REALM, scheme), httpCredentials);\n\n                LOGGER.debug(\"Using {} for authenticating against '{}:{}' using {}\", httpHeaderCredentials, host, port, scheme);\n            } else if (credentials instanceof PasswordCredentials) {\n                PasswordCredentials passwordCredentials = (PasswordCredentials) credentials;\n\n                if (authentication instanceof AllSchemesAuthentication) {\n                    NTLMCredentials ntlmCredentials = new NTLMCredentials(passwordCredentials);\n                    Credentials httpCredentials = new NTCredentials(ntlmCredentials.getUsername(), ntlmCredentials.getPassword(), ntlmCredentials.getWorkstation(), ntlmCredentials.getDomain());\n                    credentialsProvider.setCredentials(new AuthScope(host, port, AuthScope.ANY_REALM, AuthSchemes.NTLM), httpCredentials);\n\n                    LOGGER.debug(\"Using {} and {} for authenticating against '{}:{}' using {}\", passwordCredentials, ntlmCredentials, host, port, AuthSchemes.NTLM);\n                }\n\n                Credentials httpCredentials = new UsernamePasswordCredentials(passwordCredentials.getUsername(), passwordCredentials.getPassword());\n                credentialsProvider.setCredentials(new AuthScope(host, port, AuthScope.ANY_REALM, scheme), httpCredentials);\n                LOGGER.debug(\"Using {} for authenticating against '{}:{}' using {}\", passwordCredentials, host, port, scheme);\n            } else {\n                throw new IllegalArgumentException(String.format(\"Credentials must be an instance of: %s or %s\", PasswordCredentials.class.getCanonicalName(), HttpHeaderCredentials.class.getCanonicalName()));\n            }\n        }\n    }\n\n    private boolean isPreemptiveEnabled(Collection<Authentication> authentications) {\n        return CollectionUtils.any(authentications, new Spec<Authentication>() {\n            @Override\n            public boolean isSatisfiedBy(Authentication element) {\n                return element instanceof BasicAuthentication || element instanceof HttpHeaderAuthentication;\n            }\n        });\n    }\n\n    public void configureUserAgent(HttpClientBuilder builder) {\n        builder.setUserAgent(UriTextResource.getUserAgentString());\n    }\n\n    private void configureCookieSpecRegistry(HttpClientBuilder builder) {\n        PublicSuffixMatcher publicSuffixMatcher = PublicSuffixMatcherLoader.getDefault();\n        builder.setPublicSuffixMatcher(publicSuffixMatcher);\n        // Add more data patterns to the default configuration to work around https://github.com/gradle/gradle/issues/1596\n        final CookieSpecProvider defaultProvider = new DefaultCookieSpecProvider(DefaultCookieSpecProvider.CompatibilityLevel.DEFAULT, publicSuffixMatcher, new String[]{\n            \"EEE, dd-MMM-yy HH:mm:ss z\", // Netscape expires pattern\n            DateUtils.PATTERN_RFC1036,\n            DateUtils.PATTERN_ASCTIME,\n            DateUtils.PATTERN_RFC1123\n        }, false);\n        final CookieSpecProvider laxStandardProvider = new RFC6265CookieSpecProvider(\n            RFC6265CookieSpecProvider.CompatibilityLevel.RELAXED, publicSuffixMatcher);\n        final CookieSpecProvider strictStandardProvider = new RFC6265CookieSpecProvider(\n            RFC6265CookieSpecProvider.CompatibilityLevel.STRICT, publicSuffixMatcher);\n        builder.setDefaultCookieSpecRegistry(RegistryBuilder.<CookieSpecProvider>create()\n            .register(CookieSpecs.DEFAULT, defaultProvider)\n            .register(\"best-match\", defaultProvider)\n            .register(\"compatibility\", defaultProvider)\n            .register(CookieSpecs.STANDARD, laxStandardProvider)\n            .register(CookieSpecs.STANDARD_STRICT, strictStandardProvider)\n            .register(CookieSpecs.NETSCAPE, new NetscapeDraftSpecProvider())\n            .register(CookieSpecs.IGNORE_COOKIES, new IgnoreSpecProvider())\n            .build()\n        );\n    }\n\n    private void configureRequestConfig(HttpClientBuilder builder) {\n        HttpTimeoutSettings timeoutSettings = httpSettings.getTimeoutSettings();\n        RequestConfig config = RequestConfig.custom()\n            .setConnectTimeout(timeoutSettings.getConnectionTimeoutMs())\n            .setSocketTimeout(timeoutSettings.getSocketTimeoutMs())\n            .build();\n        builder.setDefaultRequestConfig(config);\n    }\n\n    private void configureSocketConfig(HttpClientBuilder builder) {\n        HttpTimeoutSettings timeoutSettings = httpSettings.getTimeoutSettings();\n        builder.setDefaultSocketConfig(SocketConfig.custom().setSoTimeout(timeoutSettings.getSocketTimeoutMs()).setSoKeepAlive(true).build());\n    }\n\n    private void configureRedirectStrategy(HttpClientBuilder builder) {\n        if (httpSettings.isFollowRedirects()) {\n            builder.setRedirectStrategy(new AlwaysRedirectRedirectStrategy());\n        } else {\n            builder.disableRedirectHandling();\n        }\n    }\n\n    private String getAuthScheme(Authentication authentication) {\n        if (authentication instanceof BasicAuthentication) {\n            return AuthSchemes.BASIC;\n        } else if (authentication instanceof DigestAuthentication) {\n            return AuthSchemes.DIGEST;\n        } else if (authentication instanceof HttpHeaderAuthentication) {\n            return HttpHeaderAuthScheme.AUTH_SCHEME_NAME;\n        } else if (authentication instanceof AllSchemesAuthentication) {\n            return AuthScope.ANY_SCHEME;\n        } else {\n            throw new IllegalArgumentException(String.format(\"Authentication scheme of '%s' is not supported.\", authentication.getClass().getSimpleName()));\n        }\n    }\n\n    static class PreemptiveAuth implements HttpRequestInterceptor {\n        private final AuthScheme authScheme;\n        private final boolean alwaysSendAuth;\n\n        PreemptiveAuth(AuthScheme authScheme, boolean alwaysSendAuth) {\n            this.authScheme = authScheme;\n            this.alwaysSendAuth = alwaysSendAuth;\n        }\n\n        @Override\n        public void process(final HttpRequest request, final HttpContext context) throws HttpException {\n\n            AuthState authState = (AuthState) context.getAttribute(HttpClientContext.TARGET_AUTH_STATE);\n\n            if (authState.getAuthScheme() != null || authState.hasAuthOptions()) {\n                return;\n            }\n\n            // If no authState has been established and this is a PUT or POST request, add preemptive authorisation\n            String requestMethod = request.getRequestLine().getMethod();\n            if (alwaysSendAuth || requestMethod.equals(HttpPut.METHOD_NAME) || requestMethod.equals(HttpPost.METHOD_NAME)) {\n                CredentialsProvider credentialsProvider = (CredentialsProvider) context.getAttribute(HttpClientContext.CREDS_PROVIDER);\n                HttpHost targetHost = (HttpHost) context.getAttribute(HttpCoreContext.HTTP_TARGET_HOST);\n                Credentials credentials = credentialsProvider.getCredentials(new AuthScope(targetHost.getHostName(), targetHost.getPort()));\n                if (credentials == null) {\n                    throw new HttpException(\"No credentials for preemptive authentication\");\n                }\n                authState.update(authScheme, credentials);\n            }\n        }\n    }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700120,
    "RELATED_CWE": [
      "CWE-601",
      "CWE-285",
      "CWE-703"
    ]
  },
  {
    "CWE_ID": [
      "CWE-522"
    ],
    "code": "/*\n * Copyright 2011 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.gradle.internal.resource.transport.http;\n\nimport com.google.common.collect.Lists;\nimport org.apache.http.HttpException;\nimport org.apache.http.HttpHost;\nimport org.apache.http.HttpRequest;\nimport org.apache.http.HttpRequestInterceptor;\nimport org.apache.http.auth.AuthScheme;\nimport org.apache.http.auth.AuthSchemeProvider;\nimport org.apache.http.auth.AuthScope;\nimport org.apache.http.auth.AuthState;\nimport org.apache.http.auth.Credentials;\nimport org.apache.http.auth.NTCredentials;\nimport org.apache.http.auth.UsernamePasswordCredentials;\nimport org.apache.http.client.CredentialsProvider;\nimport org.apache.http.client.config.AuthSchemes;\nimport org.apache.http.client.config.CookieSpecs;\nimport org.apache.http.client.config.RequestConfig;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.client.methods.HttpPut;\nimport org.apache.http.client.protocol.HttpClientContext;\nimport org.apache.http.client.utils.DateUtils;\nimport org.apache.http.config.RegistryBuilder;\nimport org.apache.http.config.SocketConfig;\nimport org.apache.http.conn.ssl.SSLConnectionSocketFactory;\nimport org.apache.http.conn.util.PublicSuffixMatcher;\nimport org.apache.http.conn.util.PublicSuffixMatcherLoader;\nimport org.apache.http.cookie.CookieSpecProvider;\nimport org.apache.http.impl.auth.BasicScheme;\nimport org.apache.http.impl.auth.BasicSchemeFactory;\nimport org.apache.http.impl.auth.DigestSchemeFactory;\nimport org.apache.http.impl.auth.KerberosSchemeFactory;\nimport org.apache.http.impl.auth.SPNegoSchemeFactory;\nimport org.apache.http.impl.client.HttpClientBuilder;\nimport org.apache.http.impl.client.SystemDefaultCredentialsProvider;\nimport org.apache.http.impl.conn.SystemDefaultRoutePlanner;\nimport org.apache.http.impl.cookie.DefaultCookieSpecProvider;\nimport org.apache.http.impl.cookie.IgnoreSpecProvider;\nimport org.apache.http.impl.cookie.NetscapeDraftSpecProvider;\nimport org.apache.http.impl.cookie.RFC6265CookieSpecProvider;\nimport org.apache.http.protocol.HttpContext;\nimport org.apache.http.protocol.HttpCoreContext;\nimport org.gradle.api.JavaVersion;\nimport org.gradle.api.credentials.HttpHeaderCredentials;\nimport org.gradle.api.credentials.PasswordCredentials;\nimport org.gradle.api.specs.Spec;\nimport org.gradle.authentication.Authentication;\nimport org.gradle.authentication.http.BasicAuthentication;\nimport org.gradle.authentication.http.DigestAuthentication;\nimport org.gradle.authentication.http.HttpHeaderAuthentication;\nimport org.gradle.internal.authentication.AllSchemesAuthentication;\nimport org.gradle.internal.authentication.AuthenticationInternal;\nimport org.gradle.internal.jvm.Jvm;\nimport org.gradle.internal.resource.UriTextResource;\nimport org.gradle.internal.resource.transport.http.ntlm.NTLMCredentials;\nimport org.gradle.internal.resource.transport.http.ntlm.NTLMSchemeFactory;\nimport org.gradle.util.CollectionUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.net.ssl.HostnameVerifier;\nimport java.net.ProxySelector;\nimport java.util.Collection;\nimport java.util.Collections;\n\npublic class HttpClientConfigurer {\n    private static final Logger LOGGER = LoggerFactory.getLogger(HttpClientConfigurer.class);\n    private static final int MAX_HTTP_CONNECTIONS = 20;\n    private static final String[] SSL_PROTOCOLS;\n\n    private static final String HTTPS_PROTOCOLS = \"https.protocols\";\n\n    static {\n        String httpsProtocols = System.getProperty(HTTPS_PROTOCOLS);\n        if (httpsProtocols != null) {\n            SSL_PROTOCOLS = httpsProtocols.split(\",\");\n        } else if (JavaVersion.current().isJava7() || (JavaVersion.current().isJava8() && Jvm.current().isIbmJvm())) {\n            SSL_PROTOCOLS = new String[]{\"TLSv1\", \"TLSv1.1\", \"TLSv1.2\"};\n        } else {\n            SSL_PROTOCOLS = null;\n        }\n    }\n\n    private final HttpSettings httpSettings;\n\n    public HttpClientConfigurer(HttpSettings httpSettings) {\n        this.httpSettings = httpSettings;\n    }\n\n    public void configure(HttpClientBuilder builder) {\n        SystemDefaultCredentialsProvider credentialsProvider = new SystemDefaultCredentialsProvider();\n        configureSslSocketConnectionFactory(builder, httpSettings.getSslContextFactory(), httpSettings.getHostnameVerifier());\n        configureAuthSchemeRegistry(builder);\n        configureCredentials(builder, credentialsProvider, httpSettings.getAuthenticationSettings());\n        configureProxy(builder, credentialsProvider, httpSettings);\n        configureUserAgent(builder);\n        configureCookieSpecRegistry(builder);\n        configureRequestConfig(builder);\n        configureSocketConfig(builder);\n        configureRedirectStrategy(builder);\n        builder.setDefaultCredentialsProvider(credentialsProvider);\n        builder.setMaxConnTotal(MAX_HTTP_CONNECTIONS);\n        builder.setMaxConnPerRoute(MAX_HTTP_CONNECTIONS);\n    }\n\n    private void configureSslSocketConnectionFactory(HttpClientBuilder builder, SslContextFactory sslContextFactory, HostnameVerifier hostnameVerifier) {\n        builder.setSSLSocketFactory(new SSLConnectionSocketFactory(sslContextFactory.createSslContext(), SSL_PROTOCOLS, null, hostnameVerifier));\n    }\n\n    private void configureAuthSchemeRegistry(HttpClientBuilder builder) {\n        builder.setDefaultAuthSchemeRegistry(RegistryBuilder.<AuthSchemeProvider>create()\n            .register(AuthSchemes.BASIC, new BasicSchemeFactory())\n            .register(AuthSchemes.DIGEST, new DigestSchemeFactory())\n            .register(AuthSchemes.NTLM, new NTLMSchemeFactory())\n            .register(AuthSchemes.SPNEGO, new SPNegoSchemeFactory())\n            .register(AuthSchemes.KERBEROS, new KerberosSchemeFactory())\n            .register(HttpHeaderAuthScheme.AUTH_SCHEME_NAME, new HttpHeaderSchemeFactory())\n            .build()\n        );\n    }\n\n    private void configureCredentials(HttpClientBuilder builder, CredentialsProvider credentialsProvider, Collection<Authentication> authentications) {\n        if(authentications.size() > 0) {\n            useCredentials(credentialsProvider, authentications);\n\n            // Use preemptive authorisation if no other authorisation has been established\n            builder.addInterceptorFirst(new PreemptiveAuth(getAuthScheme(authentications), isPreemptiveEnabled(authentications)));\n        }\n    }\n\n    private AuthScheme getAuthScheme(final Collection<Authentication> authentications) {\n        if (authentications.size() == 1) {\n            if (authentications.iterator().next() instanceof HttpHeaderAuthentication) {\n                return new HttpHeaderAuthScheme();\n            }\n        }\n        return new BasicScheme();\n    }\n\n    private void configureProxy(HttpClientBuilder builder, CredentialsProvider credentialsProvider, HttpSettings httpSettings) {\n        HttpProxySettings.HttpProxy httpProxy = httpSettings.getProxySettings().getProxy();\n        HttpProxySettings.HttpProxy httpsProxy = httpSettings.getSecureProxySettings().getProxy();\n\n        for (HttpProxySettings.HttpProxy proxy : Lists.newArrayList(httpProxy, httpsProxy)) {\n            if (proxy != null) {\n                if (proxy.credentials != null) {\n                    AllSchemesAuthentication authentication = new AllSchemesAuthentication(proxy.credentials);\n                    authentication.setHostAndPort(proxy.host, proxy.port);\n                    useCredentials(credentialsProvider, Collections.singleton(authentication));\n                }\n            }\n        }\n        builder.setRoutePlanner(new SystemDefaultRoutePlanner(ProxySelector.getDefault()));\n    }\n\n    private void useCredentials(CredentialsProvider credentialsProvider, Collection<? extends Authentication> authentications) {\n        for (Authentication authentication : authentications) {\n            AuthenticationInternal authenticationInternal = (AuthenticationInternal) authentication;\n\n            String scheme = getAuthScheme(authentication);\n            org.gradle.api.credentials.Credentials credentials = authenticationInternal.getCredentials();\n            String host = authenticationInternal.getHost();\n            int port = authenticationInternal.getPort();\n\n            if (credentials instanceof HttpHeaderCredentials) {\n                HttpHeaderCredentials httpHeaderCredentials = (HttpHeaderCredentials) credentials;\n                Credentials httpCredentials = new HttpClientHttpHeaderCredentials(httpHeaderCredentials.getName(), httpHeaderCredentials.getValue());\n                credentialsProvider.setCredentials(new AuthScope(host, port, AuthScope.ANY_REALM, scheme), httpCredentials);\n\n                LOGGER.debug(\"Using {} for authenticating against '{}:{}' using {}\", httpHeaderCredentials, host, port, scheme);\n            } else if (credentials instanceof PasswordCredentials) {\n                PasswordCredentials passwordCredentials = (PasswordCredentials) credentials;\n\n                if (authentication instanceof AllSchemesAuthentication) {\n                    NTLMCredentials ntlmCredentials = new NTLMCredentials(passwordCredentials);\n                    Credentials httpCredentials = new NTCredentials(ntlmCredentials.getUsername(), ntlmCredentials.getPassword(), ntlmCredentials.getWorkstation(), ntlmCredentials.getDomain());\n                    credentialsProvider.setCredentials(new AuthScope(host, port, AuthScope.ANY_REALM, AuthSchemes.NTLM), httpCredentials);\n\n                    LOGGER.debug(\"Using {} and {} for authenticating against '{}:{}' using {}\", passwordCredentials, ntlmCredentials, host, port, AuthSchemes.NTLM);\n                }\n\n                Credentials httpCredentials = new UsernamePasswordCredentials(passwordCredentials.getUsername(), passwordCredentials.getPassword());\n                credentialsProvider.setCredentials(new AuthScope(host, port, AuthScope.ANY_REALM, scheme), httpCredentials);\n                LOGGER.debug(\"Using {} for authenticating against '{}:{}' using {}\", passwordCredentials, host, port, scheme);\n            } else {\n                throw new IllegalArgumentException(String.format(\"Credentials must be an instance of: %s or %s\", PasswordCredentials.class.getCanonicalName(), HttpHeaderCredentials.class.getCanonicalName()));\n            }\n        }\n    }\n\n    private boolean isPreemptiveEnabled(Collection<Authentication> authentications) {\n        return CollectionUtils.any(authentications, new Spec<Authentication>() {\n            @Override\n            public boolean isSatisfiedBy(Authentication element) {\n                return element instanceof BasicAuthentication || element instanceof HttpHeaderAuthentication;\n            }\n        });\n    }\n\n    public void configureUserAgent(HttpClientBuilder builder) {\n        builder.setUserAgent(UriTextResource.getUserAgentString());\n    }\n\n    private void configureCookieSpecRegistry(HttpClientBuilder builder) {\n        PublicSuffixMatcher publicSuffixMatcher = PublicSuffixMatcherLoader.getDefault();\n        builder.setPublicSuffixMatcher(publicSuffixMatcher);\n        // Add more data patterns to the default configuration to work around https://github.com/gradle/gradle/issues/1596\n        final CookieSpecProvider defaultProvider = new DefaultCookieSpecProvider(DefaultCookieSpecProvider.CompatibilityLevel.DEFAULT, publicSuffixMatcher, new String[]{\n            \"EEE, dd-MMM-yy HH:mm:ss z\", // Netscape expires pattern\n            DateUtils.PATTERN_RFC1036,\n            DateUtils.PATTERN_ASCTIME,\n            DateUtils.PATTERN_RFC1123\n        }, false);\n        final CookieSpecProvider laxStandardProvider = new RFC6265CookieSpecProvider(\n            RFC6265CookieSpecProvider.CompatibilityLevel.RELAXED, publicSuffixMatcher);\n        final CookieSpecProvider strictStandardProvider = new RFC6265CookieSpecProvider(\n            RFC6265CookieSpecProvider.CompatibilityLevel.STRICT, publicSuffixMatcher);\n        builder.setDefaultCookieSpecRegistry(RegistryBuilder.<CookieSpecProvider>create()\n            .register(CookieSpecs.DEFAULT, defaultProvider)\n            .register(\"best-match\", defaultProvider)\n            .register(\"compatibility\", defaultProvider)\n            .register(CookieSpecs.STANDARD, laxStandardProvider)\n            .register(CookieSpecs.STANDARD_STRICT, strictStandardProvider)\n            .register(CookieSpecs.NETSCAPE, new NetscapeDraftSpecProvider())\n            .register(CookieSpecs.IGNORE_COOKIES, new IgnoreSpecProvider())\n            .build()\n        );\n    }\n\n    private void configureRequestConfig(HttpClientBuilder builder) {\n        HttpTimeoutSettings timeoutSettings = httpSettings.getTimeoutSettings();\n        RequestConfig config = RequestConfig.custom()\n            .setConnectTimeout(timeoutSettings.getConnectionTimeoutMs())\n            .setSocketTimeout(timeoutSettings.getSocketTimeoutMs())\n            .build();\n        builder.setDefaultRequestConfig(config);\n    }\n\n    private void configureSocketConfig(HttpClientBuilder builder) {\n        HttpTimeoutSettings timeoutSettings = httpSettings.getTimeoutSettings();\n        builder.setDefaultSocketConfig(SocketConfig.custom().setSoTimeout(timeoutSettings.getSocketTimeoutMs()).setSoKeepAlive(true).build());\n    }\n\n    private void configureRedirectStrategy(HttpClientBuilder builder) {\n        if (httpSettings.isFollowRedirects()) {\n            builder.setRedirectStrategy(new AlwaysRedirectRedirectStrategy());\n        } else {\n            builder.disableRedirectHandling();\n        }\n    }\n\n    private String getAuthScheme(Authentication authentication) {\n        if (authentication instanceof BasicAuthentication) {\n            return AuthSchemes.BASIC;\n        } else if (authentication instanceof DigestAuthentication) {\n            return AuthSchemes.DIGEST;\n        } else if (authentication instanceof HttpHeaderAuthentication) {\n            return HttpHeaderAuthScheme.AUTH_SCHEME_NAME;\n        } else if (authentication instanceof AllSchemesAuthentication) {\n            return AuthScope.ANY_SCHEME;\n        } else {\n            throw new IllegalArgumentException(String.format(\"Authentication scheme of '%s' is not supported.\", authentication.getClass().getSimpleName()));\n        }\n    }\n\n    static class PreemptiveAuth implements HttpRequestInterceptor {\n        private final AuthScheme authScheme;\n        private final boolean alwaysSendAuth;\n\n        PreemptiveAuth(AuthScheme authScheme, boolean alwaysSendAuth) {\n            this.authScheme = authScheme;\n            this.alwaysSendAuth = alwaysSendAuth;\n        }\n\n        @Override\n        public void process(final HttpRequest request, final HttpContext context) throws HttpException {\n\n            AuthState authState = (AuthState) context.getAttribute(HttpClientContext.TARGET_AUTH_STATE);\n\n            if (authState.getAuthScheme() != null || authState.hasAuthOptions()) {\n                return;\n            }\n\n            // If no authState has been established and this is a PUT or POST request, add preemptive authorisation\n            String requestMethod = request.getRequestLine().getMethod();\n            if (alwaysSendAuth || requestMethod.equals(HttpPut.METHOD_NAME) || requestMethod.equals(HttpPost.METHOD_NAME)) {\n                CredentialsProvider credentialsProvider = (CredentialsProvider) context.getAttribute(HttpClientContext.CREDS_PROVIDER);\n                HttpHost targetHost = (HttpHost) context.getAttribute(HttpCoreContext.HTTP_TARGET_HOST);\n                Credentials credentials = credentialsProvider.getCredentials(new AuthScope(targetHost.getHostName(), targetHost.getPort()));\n                if (credentials != null) {\n                    authState.update(authScheme, credentials);\n                }\n            }\n        }\n    }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700121,
    "RELATED_CWE": [
      "CWE-601",
      "CWE-285",
      "CWE-703"
    ]
  },
  {
    "CWE_ID": [
      "CWE-522"
    ],
    "code": "/*\n * Copyright 2004, 2005, 2006 Acegi Technology Pty Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.security.authentication.encoding;\n\nimport java.util.Locale;\n\n/**\n * <p>\n * Plaintext implementation of PasswordEncoder.\n * </p>\n * <P>\n * As callers may wish to extract the password and salts separately from the encoded\n * password, the salt must not contain reserved characters (specifically '{' and '}').\n * </p>\n *\n * @author colin sampaleanu\n * @author Ben Alex\n * @deprecated This class will be removed in Spring Security 5. For passivity switch to\n * {@link org.springframework.security.crypto.password.NoOpPasswordEncoder}.\n */\n@Deprecated\npublic class PlaintextPasswordEncoder extends BasePasswordEncoder {\n\t// ~ Instance fields\n\t// ================================================================================================\n\n\tprivate boolean ignorePasswordCase = false;\n\n\t// ~ Methods\n\t// ========================================================================================================\n\n\tpublic String encodePassword(String rawPass, Object salt) {\n\t\treturn mergePasswordAndSalt(rawPass, salt, true);\n\t}\n\n\tpublic boolean isIgnorePasswordCase() {\n\t\treturn ignorePasswordCase;\n\t}\n\n\tpublic boolean isPasswordValid(String encPass, String rawPass, Object salt) {\n\t\tString pass1 = encPass + \"\";\n\n\t\t// Strict delimiters is false because pass2 never persisted anywhere\n\t\t// and we want to avoid unnecessary exceptions as a result (the\n\t\t// authentication will fail as the encodePassword never allows them)\n\t\tString pass2 = mergePasswordAndSalt(rawPass, salt, false);\n\n\t\tif (ignorePasswordCase) {\n\t\t\t// Note: per String javadoc to get correct results for Locale insensitive, use\n\t\t\t// English\n\t\t\tpass1 = pass1.toLowerCase(Locale.ENGLISH);\n\t\t\tpass2 = pass2.toLowerCase(Locale.ENGLISH);\n\t\t}\n\t\treturn PasswordEncoderUtils.equals(pass1, pass2);\n\t}\n\n\t/**\n\t * Demerges the previously {@link #encodePassword(String, Object)}<code>String</code>.\n\t * <P>\n\t * The resulting array is guaranteed to always contain two elements. The first is the\n\t * password, and the second is the salt.\n\t * </p>\n\t * <P>\n\t * Throws an exception if <code>null</code> or an empty <code>String</code> is passed\n\t * to the method.\n\t * </p>\n\t *\n\t * @param password from {@link #encodePassword(String, Object)}\n\t *\n\t * @return an array containing the password and salt\n\t */\n\tpublic String[] obtainPasswordAndSalt(String password) {\n\t\treturn demergePasswordAndSalt(password);\n\t}\n\n\t/**\n\t * Indicates whether the password comparison is case sensitive.\n\t * <P>\n\t * Defaults to <code>false</code>, meaning an exact case match is required.\n\t * </p>\n\t *\n\t * @param ignorePasswordCase set to <code>true</code> for less stringent comparison\n\t */\n\tpublic void setIgnorePasswordCase(boolean ignorePasswordCase) {\n\t\tthis.ignorePasswordCase = ignorePasswordCase;\n\t}\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200186,
    "RELATED_CWE": [
      "CWE-601",
      "CWE-285",
      "CWE-703"
    ]
  },
  {
    "CWE_ID": [
      "CWE-522"
    ],
    "code": "/*\n * Copyright 2004, 2005, 2006 Acegi Technology Pty Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.security.authentication.encoding;\n\nimport java.util.Locale;\n\n/**\n * <p>\n * Plaintext implementation of PasswordEncoder.\n * </p>\n * <P>\n * As callers may wish to extract the password and salts separately from the encoded\n * password, the salt must not contain reserved characters (specifically '{' and '}').\n * </p>\n *\n * @author colin sampaleanu\n * @author Ben Alex\n * @deprecated This class will be removed in Spring Security 5. For passivity switch to\n * {@link org.springframework.security.crypto.password.NoOpPasswordEncoder}.\n */\n@Deprecated\npublic class PlaintextPasswordEncoder extends BasePasswordEncoder {\n\t// ~ Instance fields\n\t// ================================================================================================\n\n\tprivate boolean ignorePasswordCase = false;\n\n\t// ~ Methods\n\t// ========================================================================================================\n\n\tpublic String encodePassword(String rawPass, Object salt) {\n\t\treturn mergePasswordAndSalt(rawPass, salt, true);\n\t}\n\n\tpublic boolean isIgnorePasswordCase() {\n\t\treturn ignorePasswordCase;\n\t}\n\n\tpublic boolean isPasswordValid(String encPass, String rawPass, Object salt) {\n\t\tif (encPass == null) {\n\t\t\treturn false;\n\t\t}\n\t\tString pass1 = encPass + \"\";\n\n\t\t// Strict delimiters is false because pass2 never persisted anywhere\n\t\t// and we want to avoid unnecessary exceptions as a result (the\n\t\t// authentication will fail as the encodePassword never allows them)\n\t\tString pass2 = mergePasswordAndSalt(rawPass, salt, false);\n\n\t\tif (ignorePasswordCase) {\n\t\t\t// Note: per String javadoc to get correct results for Locale insensitive, use\n\t\t\t// English\n\t\t\tpass1 = pass1.toLowerCase(Locale.ENGLISH);\n\t\t\tpass2 = pass2.toLowerCase(Locale.ENGLISH);\n\t\t}\n\t\treturn PasswordEncoderUtils.equals(pass1, pass2);\n\t}\n\n\t/**\n\t * Demerges the previously {@link #encodePassword(String, Object)}<code>String</code>.\n\t * <P>\n\t * The resulting array is guaranteed to always contain two elements. The first is the\n\t * password, and the second is the salt.\n\t * </p>\n\t * <P>\n\t * Throws an exception if <code>null</code> or an empty <code>String</code> is passed\n\t * to the method.\n\t * </p>\n\t *\n\t * @param password from {@link #encodePassword(String, Object)}\n\t *\n\t * @return an array containing the password and salt\n\t */\n\tpublic String[] obtainPasswordAndSalt(String password) {\n\t\treturn demergePasswordAndSalt(password);\n\t}\n\n\t/**\n\t * Indicates whether the password comparison is case sensitive.\n\t * <P>\n\t * Defaults to <code>false</code>, meaning an exact case match is required.\n\t * </p>\n\t *\n\t * @param ignorePasswordCase set to <code>true</code> for less stringent comparison\n\t */\n\tpublic void setIgnorePasswordCase(boolean ignorePasswordCase) {\n\t\tthis.ignorePasswordCase = ignorePasswordCase;\n\t}\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200187,
    "RELATED_CWE": [
      "CWE-601",
      "CWE-285",
      "CWE-703"
    ]
  }
]