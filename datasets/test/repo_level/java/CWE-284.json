[
  {
    "CWE_ID": [
      "CWE-284"
    ],
    "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.util;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.subject.support.DefaultSubjectContext;\nimport org.apache.shiro.util.StringUtils;\nimport org.apache.shiro.web.env.EnvironmentLoader;\nimport org.apache.shiro.web.env.WebEnvironment;\nimport org.apache.shiro.web.filter.AccessControlFilter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\nimport java.util.Map;\n\n/**\n * Simple utility class for operations used across multiple class hierarchies in the web framework code.\n * <p/>\n * Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @since 0.9\n */\npublic class WebUtils {\n\n    //TODO - complete JavaDoc\n\n    private static final Logger log = LoggerFactory.getLogger(WebUtils.class);\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_SHIRO_THREAD_CONTEXT_KEY\";\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_SHIRO_THREAD_CONTEXT_KEY\";\n\n    /**\n     * {@link org.apache.shiro.session.Session Session} key used to save a request and later restore it, for example when redirecting to a\n     * requested page after login, equal to {@code shiroSavedRequest}.\n     */\n    public static final String SAVED_REQUEST_KEY = \"shiroSavedRequest\";\n\n    /**\n     * Standard Servlet 2.3+ spec request attributes for include URI and paths.\n     * <p>If included via a RequestDispatcher, the current resource will see the\n     * originating request. Its own URI and paths are exposed as request attributes.\n     */\n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    /**\n     * Standard Servlet 2.4+ spec request attributes for forward URI and paths.\n     * <p>If forwarded to via a RequestDispatcher, the current resource will see its\n     * own URI and paths. The originating URI and paths are exposed as request attributes.\n     */\n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    /**\n     * Default character encoding to use when <code>request.getCharacterEncoding</code>\n     * returns <code>null</code>, according to the Servlet spec.\n     *\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     */\n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    /**\n     * Return the path within the web application for the given request.\n     * Detects include request URL if called within a RequestDispatcher include.\n     * <p/>\n     * For example, for a request to URL\n     * <p/>\n     * <code>http://www.somehost.com/myapp/my/url.jsp</code>,\n     * <p/>\n     * for an application deployed to <code>/mayapp</code> (the application's context path), this method would return\n     * <p/>\n     * <code>/my/url.jsp</code>.\n     *\n     * @param request current HTTP request\n     * @return the path within the web application\n     */\n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            // Normal case: URI contains context path.\n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            // Special case: rather unusual.\n            return requestUri;\n        }\n    }\n\n    /**\n     * Return the request URI for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getRequestURI()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     * <p>The URI that the web container resolves <i>should</i> be correct, but some\n     * containers like JBoss/Jetty incorrectly include \";\" strings like \";jsessionid\"\n     * in the URI. This method cuts off such incorrect appendices.\n     *\n     * @param request current HTTP request\n     * @return the request URI\n     */\n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return normalize(decodeAndCleanUriString(request, uri));\n    }\n\n    /**\n     * Normalize a relative URI path that may have relative values (\"/./\",\n     * \"/../\", and so on ) it it.  <strong>WARNING</strong> - This method is\n     * useful only for normalizing application-generated paths.  It does not\n     * try to perform security checks for malicious input.\n     * Normalize operations were was happily taken from org.apache.catalina.util.RequestUtil in\n     * Tomcat trunk, r939305\n     *\n     * @param path Relative path to be normalized\n     * @return normalized path\n     */\n    public static String normalize(String path) {\n        return normalize(path, true);\n    }\n\n    /**\n     * Normalize a relative URI path that may have relative values (\"/./\",\n     * \"/../\", and so on ) it it.  <strong>WARNING</strong> - This method is\n     * useful only for normalizing application-generated paths.  It does not\n     * try to perform security checks for malicious input.\n     * Normalize operations were was happily taken from org.apache.catalina.util.RequestUtil in\n     * Tomcat trunk, r939305\n     *\n     * @param path             Relative path to be normalized\n     * @param replaceBackSlash Should '\\\\' be replaced with '/'\n     * @return normalized path\n     */\n    private static String normalize(String path, boolean replaceBackSlash) {\n\n        if (path == null)\n            return null;\n\n        // Create a place for the normalized path\n        String normalized = path;\n\n        if (replaceBackSlash && normalized.indexOf('\\\\') >= 0)\n            normalized = normalized.replace('\\\\', '/');\n\n        if (normalized.equals(\"/.\"))\n            return \"/\";\n\n        // Add a leading \"/\" if necessary\n        if (!normalized.startsWith(\"/\"))\n            normalized = \"/\" + normalized;\n\n        // Resolve occurrences of \"//\" in the normalized path\n        while (true) {\n            int index = normalized.indexOf(\"//\");\n            if (index < 0)\n                break;\n            normalized = normalized.substring(0, index) +\n                    normalized.substring(index + 1);\n        }\n\n        // Resolve occurrences of \"/./\" in the normalized path\n        while (true) {\n            int index = normalized.indexOf(\"/./\");\n            if (index < 0)\n                break;\n            normalized = normalized.substring(0, index) +\n                    normalized.substring(index + 2);\n        }\n\n        // Resolve occurrences of \"/../\" in the normalized path\n        while (true) {\n            int index = normalized.indexOf(\"/../\");\n            if (index < 0)\n                break;\n            if (index == 0)\n                return (null);  // Trying to go outside our context\n            int index2 = normalized.lastIndexOf('/', index - 1);\n            normalized = normalized.substring(0, index2) +\n                    normalized.substring(index + 3);\n        }\n\n        // Return the normalized path that we have completed\n        return (normalized);\n\n    }\n\n\n    /**\n     * Decode the supplied URI string and strips any extraneous portion after a ';'.\n     *\n     * @param request the incoming HttpServletRequest\n     * @param uri     the application's URI string\n     * @return the supplied URI string stripped of any extraneous portion after a ';'.\n     */\n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    /**\n     * Return the context path for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getContextPath()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     *\n     * @param request current HTTP request\n     * @return the context path\n     */\n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            // Invalid case, but happens for includes on Jetty: silently adapt it.\n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }\n\n    /**\n     * Find the Shiro {@link WebEnvironment} for this web application, which is typically loaded via the\n     * {@link org.apache.shiro.web.env.EnvironmentLoaderListener}.\n     * <p/>\n     * This implementation rethrows an exception that happened on environment startup to differentiate between a failed\n     * environment startup and no environment at all.\n     *\n     * @param sc ServletContext to find the web application context for\n     * @return the root WebApplicationContext for this web app\n     * @throws IllegalStateException if the root WebApplicationContext could not be found\n     * @see org.apache.shiro.web.env.EnvironmentLoader#ENVIRONMENT_ATTRIBUTE_KEY\n     * @since 1.2\n     */\n    public static WebEnvironment getRequiredWebEnvironment(ServletContext sc)\n            throws IllegalStateException {\n\n        WebEnvironment we = getWebEnvironment(sc);\n        if (we == null) {\n            throw new IllegalStateException(\"No WebEnvironment found: no EnvironmentLoaderListener registered?\");\n        }\n        return we;\n    }\n\n    /**\n     * Find the Shiro {@link WebEnvironment} for this web application, which is typically loaded via\n     * {@link org.apache.shiro.web.env.EnvironmentLoaderListener}.\n     * <p/>\n     * This implementation rethrows an exception that happened on environment startup to differentiate between a failed\n     * environment startup and no environment at all.\n     *\n     * @param sc ServletContext to find the web application context for\n     * @return the root WebApplicationContext for this web app, or <code>null</code> if none\n     * @see org.apache.shiro.web.env.EnvironmentLoader#ENVIRONMENT_ATTRIBUTE_KEY\n     * @since 1.2\n     */\n    public static WebEnvironment getWebEnvironment(ServletContext sc) {\n        return getWebEnvironment(sc, EnvironmentLoader.ENVIRONMENT_ATTRIBUTE_KEY);\n    }\n\n    /**\n     * Find the Shiro {@link WebEnvironment} for this web application.\n     *\n     * @param sc       ServletContext to find the web application context for\n     * @param attrName the name of the ServletContext attribute to look for\n     * @return the desired WebEnvironment for this web app, or <code>null</code> if none\n     * @since 1.2\n     */\n    public static WebEnvironment getWebEnvironment(ServletContext sc, String attrName) {\n        if (sc == null) {\n            throw new IllegalArgumentException(\"ServletContext argument must not be null.\");\n        }\n        Object attr = sc.getAttribute(attrName);\n        if (attr == null) {\n            return null;\n        }\n        if (attr instanceof RuntimeException) {\n            throw (RuntimeException) attr;\n        }\n        if (attr instanceof Error) {\n            throw (Error) attr;\n        }\n        if (attr instanceof Exception) {\n            throw new IllegalStateException((Exception) attr);\n        }\n        if (!(attr instanceof WebEnvironment)) {\n            throw new IllegalStateException(\"Context attribute is not of type WebEnvironment: \" + attr);\n        }\n        return (WebEnvironment) attr;\n    }\n\n\n    /**\n     * Decode the given source string with a URLDecoder. The encoding will be taken\n     * from the request, falling back to the default \"ISO-8859-1\".\n     * <p>The default implementation uses <code>URLDecoder.decode(input, enc)</code>.\n     *\n     * @param request current HTTP request\n     * @param source  the String to decode\n     * @return the decoded String\n     * @see #DEFAULT_CHARACTER_ENCODING\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     * @see java.net.URLDecoder#decode(String, String)\n     * @see java.net.URLDecoder#decode(String)\n     */\n    @SuppressWarnings({\"deprecation\"})\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        } catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc +\n                        \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    /**\n     * Determine the encoding for the given request.\n     * Can be overridden in subclasses.\n     * <p>The default implementation checks the request's\n     * {@link ServletRequest#getCharacterEncoding() character encoding}, and if that\n     * <code>null</code>, falls back to the {@link #DEFAULT_CHARACTER_ENCODING}.\n     *\n     * @param request current HTTP request\n     * @return the encoding for the request (never <code>null</code>)\n     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n     */\n    protected static String determineEncoding(HttpServletRequest request) {\n        String enc = request.getCharacterEncoding();\n        if (enc == null) {\n            enc = DEFAULT_CHARACTER_ENCODING;\n        }\n        return enc;\n    }\n\n    /*\n     * Returns {@code true} IFF the specified {@code SubjectContext}:\n     * <ol>\n     * <li>A {@link WebSubjectContext} instance</li>\n     * <li>The {@code WebSubjectContext}'s request/response pair are not null</li>\n     * <li>The request is an {@link HttpServletRequest} instance</li>\n     * <li>The response is an {@link HttpServletResponse} instance</li>\n     * </ol>\n     *\n     * @param context the SubjectContext to check to see if it is HTTP compatible.\n     * @return {@code true} IFF the specified context has HTTP request/response objects, {@code false} otherwise.\n     * @since 1.0\n     */\n\n    public static boolean isWeb(Object requestPairSource) {\n        return requestPairSource instanceof RequestPairSource && isWeb((RequestPairSource) requestPairSource);\n    }\n\n    public static boolean isHttp(Object requestPairSource) {\n        return requestPairSource instanceof RequestPairSource && isHttp((RequestPairSource) requestPairSource);\n    }\n\n    public static ServletRequest getRequest(Object requestPairSource) {\n        if (requestPairSource instanceof RequestPairSource) {\n            return ((RequestPairSource) requestPairSource).getServletRequest();\n        }\n        return null;\n    }\n\n    public static ServletResponse getResponse(Object requestPairSource) {\n        if (requestPairSource instanceof RequestPairSource) {\n            return ((RequestPairSource) requestPairSource).getServletResponse();\n        }\n        return null;\n    }\n\n    public static HttpServletRequest getHttpRequest(Object requestPairSource) {\n        ServletRequest request = getRequest(requestPairSource);\n        if (request instanceof HttpServletRequest) {\n            return (HttpServletRequest) request;\n        }\n        return null;\n    }\n\n    public static HttpServletResponse getHttpResponse(Object requestPairSource) {\n        ServletResponse response = getResponse(requestPairSource);\n        if (response instanceof HttpServletResponse) {\n            return (HttpServletResponse) response;\n        }\n        return null;\n    }\n\n    private static boolean isWeb(RequestPairSource source) {\n        ServletRequest request = source.getServletRequest();\n        ServletResponse response = source.getServletResponse();\n        return request != null && response != null;\n    }\n\n    private static boolean isHttp(RequestPairSource source) {\n        ServletRequest request = source.getServletRequest();\n        ServletResponse response = source.getServletResponse();\n        return request instanceof HttpServletRequest && response instanceof HttpServletResponse;\n    }\n\n    /**\n     * Returns {@code true} if a session is allowed to be created for a subject-associated request, {@code false}\n     * otherwise.\n     * <p/>\n     * <b>This method exists for Shiro's internal framework needs and should never be called by Shiro end-users.  It\n     * could be changed/removed at any time.</b>\n     *\n     * @param requestPairSource a {@link RequestPairSource} instance, almost always a\n     *                          {@link org.apache.shiro.web.subject.WebSubject WebSubject} instance.\n     * @return {@code true} if a session is allowed to be created for a subject-associated request, {@code false}\n     *         otherwise.\n     */\n    public static boolean _isSessionCreationEnabled(Object requestPairSource) {\n        if (requestPairSource instanceof RequestPairSource) {\n            RequestPairSource source = (RequestPairSource) requestPairSource;\n            return _isSessionCreationEnabled(source.getServletRequest());\n        }\n        return true; //by default\n    }\n\n    /**\n     * Returns {@code true} if a session is allowed to be created for a subject-associated request, {@code false}\n     * otherwise.\n     * <p/>\n     * <b>This method exists for Shiro's internal framework needs and should never be called by Shiro end-users.  It\n     * could be changed/removed at any time.</b>\n     *\n     * @param request incoming servlet request.\n     * @return {@code true} if a session is allowed to be created for a subject-associated request, {@code false}\n     *         otherwise.\n     */\n    public static boolean _isSessionCreationEnabled(ServletRequest request) {\n        if (request != null) {\n            Object val = request.getAttribute(DefaultSubjectContext.SESSION_CREATION_ENABLED);\n            if (val != null && val instanceof Boolean) {\n                return (Boolean) val;\n            }\n        }\n        return true; //by default\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletRequest</code> to an\n     * <code>HttpServletRequest</code>:\n     * <p/>\n     * <code>return (HttpServletRequest)request;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>request</code> argument casted to an <code>HttpServletRequest</code>.\n     */\n    public static HttpServletRequest toHttp(ServletRequest request) {\n        return (HttpServletRequest) request;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletResponse</code> to an\n     * <code>HttpServletResponse</code>:\n     * <p/>\n     * <code>return (HttpServletResponse)response;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param response the outgoing ServletResponse\n     * @return the <code>response</code> argument casted to an <code>HttpServletResponse</code>.\n     */\n    public static HttpServletResponse toHttp(ServletResponse response) {\n        return (HttpServletResponse) response;\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters.\n     *\n     * @param request          the servlet request.\n     * @param response         the servlet response.\n     * @param url              the URL to redirect the user to.\n     * @param queryParams      a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative  true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative, boolean http10Compatible) throws IOException {\n        RedirectView view = new RedirectView(url, contextRelative, http10Compatible);\n        view.renderMergedOutputModel(queryParams, toHttp(request), toHttp(response));\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request  the servlet request.\n     * @param response the servlet response.\n     * @param url      the URL to redirect the user to.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url) throws IOException {\n        issueRedirect(request, response, url, null, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request     the servlet request.\n     * @param response    the servlet response.\n     * @param url         the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams) throws IOException {\n        issueRedirect(request, response, url, queryParams, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request         the servlet request.\n     * @param response        the servlet response.\n     * @param url             the URL to redirect the user to.\n     * @param queryParams     a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative) throws IOException {\n        issueRedirect(request, response, url, queryParams, contextRelative, true);\n    }\n\n    /**\n     * <p>Checks to see if a request param is considered true using a loose matching strategy for\n     * general values that indicate that something is true or enabled, etc.</p>\n     * <p/>\n     * <p>Values that are considered \"true\" include (case-insensitive): true, t, 1, enabled, y, yes, on.</p>\n     *\n     * @param request   the servlet request\n     * @param paramName @return true if the param value is considered true or false if it isn't.\n     * @return true if the given parameter is considered \"true\" - false otherwise.\n     */\n    public static boolean isTrue(ServletRequest request, String paramName) {\n        String value = getCleanParam(request, paramName);\n        return value != null &&\n                (value.equalsIgnoreCase(\"true\") ||\n                        value.equalsIgnoreCase(\"t\") ||\n                        value.equalsIgnoreCase(\"1\") ||\n                        value.equalsIgnoreCase(\"enabled\") ||\n                        value.equalsIgnoreCase(\"y\") ||\n                        value.equalsIgnoreCase(\"yes\") ||\n                        value.equalsIgnoreCase(\"on\"));\n    }\n\n    /**\n     * Convenience method that returns a request parameter value, first running it through\n     * {@link StringUtils#clean(String)}.\n     *\n     * @param request   the servlet request.\n     * @param paramName the parameter name.\n     * @return the clean param value, or null if the param does not exist or is empty.\n     */\n    public static String getCleanParam(ServletRequest request, String paramName) {\n        return StringUtils.clean(request.getParameter(paramName));\n    }\n\n    public static void saveRequest(ServletRequest request) {\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession();\n        HttpServletRequest httpRequest = toHttp(request);\n        SavedRequest savedRequest = new SavedRequest(httpRequest);\n        session.setAttribute(SAVED_REQUEST_KEY, savedRequest);\n    }\n\n    public static SavedRequest getAndClearSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = getSavedRequest(request);\n        if (savedRequest != null) {\n            Subject subject = SecurityUtils.getSubject();\n            Session session = subject.getSession();\n            session.removeAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    public static SavedRequest getSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = null;\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n        if (session != null) {\n            savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    /**\n     * Redirects the to the request url from a previously\n     * {@link #saveRequest(javax.servlet.ServletRequest) saved} request, or if there is no saved request, redirects the\n     * end user to the specified {@code fallbackUrl}.  If there is no saved request or fallback url, this method\n     * throws an {@link IllegalStateException}.\n     * <p/>\n     * This method is primarily used to support a common login scenario - if an unauthenticated user accesses a\n     * page that requires authentication, it is expected that request is\n     * {@link #saveRequest(javax.servlet.ServletRequest) saved} first and then redirected to the login page. Then,\n     * after a successful login, this method can be called to redirect them back to their originally requested URL, a\n     * nice usability feature.\n     *\n     * @param request     the incoming request\n     * @param response    the outgoing response\n     * @param fallbackUrl the fallback url to redirect to if there is no saved request available.\n     * @throws IllegalStateException if there is no saved request and the {@code fallbackUrl} is {@code null}.\n     * @throws IOException           if there is an error redirecting\n     * @since 1.0\n     */\n    public static void redirectToSavedRequest(ServletRequest request, ServletResponse response, String fallbackUrl)\n            throws IOException {\n        String successUrl = null;\n        boolean contextRelative = true;\n        SavedRequest savedRequest = WebUtils.getAndClearSavedRequest(request);\n        if (savedRequest != null && savedRequest.getMethod().equalsIgnoreCase(AccessControlFilter.GET_METHOD)) {\n            successUrl = savedRequest.getRequestUrl();\n            contextRelative = false;\n        }\n\n        if (successUrl == null) {\n            successUrl = fallbackUrl;\n        }\n\n        if (successUrl == null) {\n            throw new IllegalStateException(\"Success URL not available via saved request or via the \" +\n                    \"successUrlFallback method parameter. One of these must be non-null for \" +\n                    \"issueSuccessRedirect() to work.\");\n        }\n\n        WebUtils.issueRedirect(request, response, successUrl, null, contextRelative);\n    }\n\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200114,
    "RELATED_CWE": [
      "CWE-614",
      "CWE-79",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-284"
    ],
    "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.util;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.subject.support.DefaultSubjectContext;\nimport org.apache.shiro.util.StringUtils;\nimport org.apache.shiro.web.env.EnvironmentLoader;\nimport org.apache.shiro.web.env.WebEnvironment;\nimport org.apache.shiro.web.filter.AccessControlFilter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\nimport java.util.Map;\n\n/**\n * Simple utility class for operations used across multiple class hierarchies in the web framework code.\n * <p/>\n * Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @since 0.9\n */\npublic class WebUtils {\n\n    //TODO - complete JavaDoc\n\n    private static final Logger log = LoggerFactory.getLogger(WebUtils.class);\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_SHIRO_THREAD_CONTEXT_KEY\";\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_SHIRO_THREAD_CONTEXT_KEY\";\n\n    /**\n     * {@link org.apache.shiro.session.Session Session} key used to save a request and later restore it, for example when redirecting to a\n     * requested page after login, equal to {@code shiroSavedRequest}.\n     */\n    public static final String SAVED_REQUEST_KEY = \"shiroSavedRequest\";\n\n    /**\n     * Standard Servlet 2.3+ spec request attributes for include URI and paths.\n     * <p>If included via a RequestDispatcher, the current resource will see the\n     * originating request. Its own URI and paths are exposed as request attributes.\n     */\n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    /**\n     * Standard Servlet 2.4+ spec request attributes for forward URI and paths.\n     * <p>If forwarded to via a RequestDispatcher, the current resource will see its\n     * own URI and paths. The originating URI and paths are exposed as request attributes.\n     */\n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    /**\n     * Default character encoding to use when <code>request.getCharacterEncoding</code>\n     * returns <code>null</code>, according to the Servlet spec.\n     *\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     */\n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    /**\n     * Return the path within the web application for the given request.\n     * Detects include request URL if called within a RequestDispatcher include.\n     * <p/>\n     * For example, for a request to URL\n     * <p/>\n     * <code>http://www.somehost.com/myapp/my/url.jsp</code>,\n     * <p/>\n     * for an application deployed to <code>/mayapp</code> (the application's context path), this method would return\n     * <p/>\n     * <code>/my/url.jsp</code>.\n     *\n     * @param request current HTTP request\n     * @return the path within the web application\n     */\n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            // Normal case: URI contains context path.\n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            // Special case: rather unusual.\n            return requestUri;\n        }\n    }\n\n    /**\n     * Return the request URI for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getRequestURI()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     * <p>The URI that the web container resolves <i>should</i> be correct, but some\n     * containers like JBoss/Jetty incorrectly include \";\" strings like \";jsessionid\"\n     * in the URI. This method cuts off such incorrect appendices.\n     *\n     * @param request current HTTP request\n     * @return the request URI\n     */\n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return normalize(decodeAndCleanUriString(request, uri));\n    }\n\n    /**\n     * Normalize a relative URI path that may have relative values (\"/./\",\n     * \"/../\", and so on ) it it.  <strong>WARNING</strong> - This method is\n     * useful only for normalizing application-generated paths.  It does not\n     * try to perform security checks for malicious input.\n     * Normalize operations were was happily taken from org.apache.catalina.util.RequestUtil in\n     * Tomcat trunk, r939305\n     *\n     * @param path Relative path to be normalized\n     * @return normalized path\n     */\n    public static String normalize(String path) {\n        return normalize(path, true);\n    }\n\n    /**\n     * Normalize a relative URI path that may have relative values (\"/./\",\n     * \"/../\", and so on ) it it.  <strong>WARNING</strong> - This method is\n     * useful only for normalizing application-generated paths.  It does not\n     * try to perform security checks for malicious input.\n     * Normalize operations were was happily taken from org.apache.catalina.util.RequestUtil in\n     * Tomcat trunk, r939305\n     *\n     * @param path             Relative path to be normalized\n     * @param replaceBackSlash Should '\\\\' be replaced with '/'\n     * @return normalized path\n     */\n    private static String normalize(String path, boolean replaceBackSlash) {\n\n        if (path == null)\n            return null;\n\n        // Create a place for the normalized path\n        String normalized = path;\n\n        if (replaceBackSlash && normalized.indexOf('\\\\') >= 0)\n            normalized = normalized.replace('\\\\', '/');\n\n        if (normalized.equals(\"/.\"))\n            return \"/\";\n\n        // Add a leading \"/\" if necessary\n        if (!normalized.startsWith(\"/\"))\n            normalized = \"/\" + normalized;\n\n        // Resolve occurrences of \"//\" in the normalized path\n        while (true) {\n            int index = normalized.indexOf(\"//\");\n            if (index < 0)\n                break;\n            normalized = normalized.substring(0, index) +\n                    normalized.substring(index + 1);\n        }\n\n        // Resolve occurrences of \"/./\" in the normalized path\n        while (true) {\n            int index = normalized.indexOf(\"/./\");\n            if (index < 0)\n                break;\n            normalized = normalized.substring(0, index) +\n                    normalized.substring(index + 2);\n        }\n\n        // Resolve occurrences of \"/../\" in the normalized path\n        while (true) {\n            int index = normalized.indexOf(\"/../\");\n            if (index < 0)\n                break;\n            if (index == 0)\n                return (null);  // Trying to go outside our context\n            int index2 = normalized.lastIndexOf('/', index - 1);\n            normalized = normalized.substring(0, index2) +\n                    normalized.substring(index + 3);\n        }\n\n        // Return the normalized path that we have completed\n        return (normalized);\n\n    }\n\n\n    /**\n     * Decode the supplied URI string and strips any extraneous portion after a ';'.\n     *\n     * @param request the incoming HttpServletRequest\n     * @param uri     the application's URI string\n     * @return the supplied URI string stripped of any extraneous portion after a ';'.\n     */\n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    /**\n     * Return the context path for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getContextPath()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     *\n     * @param request current HTTP request\n     * @return the context path\n     */\n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        contextPath = normalize(decodeRequestString(request, contextPath));\n        if (\"/\".equals(contextPath)) {\n            // the normalize method will return a \"/\" and includes on Jetty, will also be a \"/\".\n            contextPath = \"\";\n        }\n        return contextPath;\n    }\n\n    /**\n     * Find the Shiro {@link WebEnvironment} for this web application, which is typically loaded via the\n     * {@link org.apache.shiro.web.env.EnvironmentLoaderListener}.\n     * <p/>\n     * This implementation rethrows an exception that happened on environment startup to differentiate between a failed\n     * environment startup and no environment at all.\n     *\n     * @param sc ServletContext to find the web application context for\n     * @return the root WebApplicationContext for this web app\n     * @throws IllegalStateException if the root WebApplicationContext could not be found\n     * @see org.apache.shiro.web.env.EnvironmentLoader#ENVIRONMENT_ATTRIBUTE_KEY\n     * @since 1.2\n     */\n    public static WebEnvironment getRequiredWebEnvironment(ServletContext sc)\n            throws IllegalStateException {\n\n        WebEnvironment we = getWebEnvironment(sc);\n        if (we == null) {\n            throw new IllegalStateException(\"No WebEnvironment found: no EnvironmentLoaderListener registered?\");\n        }\n        return we;\n    }\n\n    /**\n     * Find the Shiro {@link WebEnvironment} for this web application, which is typically loaded via\n     * {@link org.apache.shiro.web.env.EnvironmentLoaderListener}.\n     * <p/>\n     * This implementation rethrows an exception that happened on environment startup to differentiate between a failed\n     * environment startup and no environment at all.\n     *\n     * @param sc ServletContext to find the web application context for\n     * @return the root WebApplicationContext for this web app, or <code>null</code> if none\n     * @see org.apache.shiro.web.env.EnvironmentLoader#ENVIRONMENT_ATTRIBUTE_KEY\n     * @since 1.2\n     */\n    public static WebEnvironment getWebEnvironment(ServletContext sc) {\n        return getWebEnvironment(sc, EnvironmentLoader.ENVIRONMENT_ATTRIBUTE_KEY);\n    }\n\n    /**\n     * Find the Shiro {@link WebEnvironment} for this web application.\n     *\n     * @param sc       ServletContext to find the web application context for\n     * @param attrName the name of the ServletContext attribute to look for\n     * @return the desired WebEnvironment for this web app, or <code>null</code> if none\n     * @since 1.2\n     */\n    public static WebEnvironment getWebEnvironment(ServletContext sc, String attrName) {\n        if (sc == null) {\n            throw new IllegalArgumentException(\"ServletContext argument must not be null.\");\n        }\n        Object attr = sc.getAttribute(attrName);\n        if (attr == null) {\n            return null;\n        }\n        if (attr instanceof RuntimeException) {\n            throw (RuntimeException) attr;\n        }\n        if (attr instanceof Error) {\n            throw (Error) attr;\n        }\n        if (attr instanceof Exception) {\n            throw new IllegalStateException((Exception) attr);\n        }\n        if (!(attr instanceof WebEnvironment)) {\n            throw new IllegalStateException(\"Context attribute is not of type WebEnvironment: \" + attr);\n        }\n        return (WebEnvironment) attr;\n    }\n\n\n    /**\n     * Decode the given source string with a URLDecoder. The encoding will be taken\n     * from the request, falling back to the default \"ISO-8859-1\".\n     * <p>The default implementation uses <code>URLDecoder.decode(input, enc)</code>.\n     *\n     * @param request current HTTP request\n     * @param source  the String to decode\n     * @return the decoded String\n     * @see #DEFAULT_CHARACTER_ENCODING\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     * @see java.net.URLDecoder#decode(String, String)\n     * @see java.net.URLDecoder#decode(String)\n     */\n    @SuppressWarnings({\"deprecation\"})\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        } catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc +\n                        \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    /**\n     * Determine the encoding for the given request.\n     * Can be overridden in subclasses.\n     * <p>The default implementation checks the request's\n     * {@link ServletRequest#getCharacterEncoding() character encoding}, and if that\n     * <code>null</code>, falls back to the {@link #DEFAULT_CHARACTER_ENCODING}.\n     *\n     * @param request current HTTP request\n     * @return the encoding for the request (never <code>null</code>)\n     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n     */\n    protected static String determineEncoding(HttpServletRequest request) {\n        String enc = request.getCharacterEncoding();\n        if (enc == null) {\n            enc = DEFAULT_CHARACTER_ENCODING;\n        }\n        return enc;\n    }\n\n    /*\n     * Returns {@code true} IFF the specified {@code SubjectContext}:\n     * <ol>\n     * <li>A {@link WebSubjectContext} instance</li>\n     * <li>The {@code WebSubjectContext}'s request/response pair are not null</li>\n     * <li>The request is an {@link HttpServletRequest} instance</li>\n     * <li>The response is an {@link HttpServletResponse} instance</li>\n     * </ol>\n     *\n     * @param context the SubjectContext to check to see if it is HTTP compatible.\n     * @return {@code true} IFF the specified context has HTTP request/response objects, {@code false} otherwise.\n     * @since 1.0\n     */\n\n    public static boolean isWeb(Object requestPairSource) {\n        return requestPairSource instanceof RequestPairSource && isWeb((RequestPairSource) requestPairSource);\n    }\n\n    public static boolean isHttp(Object requestPairSource) {\n        return requestPairSource instanceof RequestPairSource && isHttp((RequestPairSource) requestPairSource);\n    }\n\n    public static ServletRequest getRequest(Object requestPairSource) {\n        if (requestPairSource instanceof RequestPairSource) {\n            return ((RequestPairSource) requestPairSource).getServletRequest();\n        }\n        return null;\n    }\n\n    public static ServletResponse getResponse(Object requestPairSource) {\n        if (requestPairSource instanceof RequestPairSource) {\n            return ((RequestPairSource) requestPairSource).getServletResponse();\n        }\n        return null;\n    }\n\n    public static HttpServletRequest getHttpRequest(Object requestPairSource) {\n        ServletRequest request = getRequest(requestPairSource);\n        if (request instanceof HttpServletRequest) {\n            return (HttpServletRequest) request;\n        }\n        return null;\n    }\n\n    public static HttpServletResponse getHttpResponse(Object requestPairSource) {\n        ServletResponse response = getResponse(requestPairSource);\n        if (response instanceof HttpServletResponse) {\n            return (HttpServletResponse) response;\n        }\n        return null;\n    }\n\n    private static boolean isWeb(RequestPairSource source) {\n        ServletRequest request = source.getServletRequest();\n        ServletResponse response = source.getServletResponse();\n        return request != null && response != null;\n    }\n\n    private static boolean isHttp(RequestPairSource source) {\n        ServletRequest request = source.getServletRequest();\n        ServletResponse response = source.getServletResponse();\n        return request instanceof HttpServletRequest && response instanceof HttpServletResponse;\n    }\n\n    /**\n     * Returns {@code true} if a session is allowed to be created for a subject-associated request, {@code false}\n     * otherwise.\n     * <p/>\n     * <b>This method exists for Shiro's internal framework needs and should never be called by Shiro end-users.  It\n     * could be changed/removed at any time.</b>\n     *\n     * @param requestPairSource a {@link RequestPairSource} instance, almost always a\n     *                          {@link org.apache.shiro.web.subject.WebSubject WebSubject} instance.\n     * @return {@code true} if a session is allowed to be created for a subject-associated request, {@code false}\n     *         otherwise.\n     */\n    public static boolean _isSessionCreationEnabled(Object requestPairSource) {\n        if (requestPairSource instanceof RequestPairSource) {\n            RequestPairSource source = (RequestPairSource) requestPairSource;\n            return _isSessionCreationEnabled(source.getServletRequest());\n        }\n        return true; //by default\n    }\n\n    /**\n     * Returns {@code true} if a session is allowed to be created for a subject-associated request, {@code false}\n     * otherwise.\n     * <p/>\n     * <b>This method exists for Shiro's internal framework needs and should never be called by Shiro end-users.  It\n     * could be changed/removed at any time.</b>\n     *\n     * @param request incoming servlet request.\n     * @return {@code true} if a session is allowed to be created for a subject-associated request, {@code false}\n     *         otherwise.\n     */\n    public static boolean _isSessionCreationEnabled(ServletRequest request) {\n        if (request != null) {\n            Object val = request.getAttribute(DefaultSubjectContext.SESSION_CREATION_ENABLED);\n            if (val != null && val instanceof Boolean) {\n                return (Boolean) val;\n            }\n        }\n        return true; //by default\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletRequest</code> to an\n     * <code>HttpServletRequest</code>:\n     * <p/>\n     * <code>return (HttpServletRequest)request;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>request</code> argument casted to an <code>HttpServletRequest</code>.\n     */\n    public static HttpServletRequest toHttp(ServletRequest request) {\n        return (HttpServletRequest) request;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletResponse</code> to an\n     * <code>HttpServletResponse</code>:\n     * <p/>\n     * <code>return (HttpServletResponse)response;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param response the outgoing ServletResponse\n     * @return the <code>response</code> argument casted to an <code>HttpServletResponse</code>.\n     */\n    public static HttpServletResponse toHttp(ServletResponse response) {\n        return (HttpServletResponse) response;\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters.\n     *\n     * @param request          the servlet request.\n     * @param response         the servlet response.\n     * @param url              the URL to redirect the user to.\n     * @param queryParams      a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative  true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative, boolean http10Compatible) throws IOException {\n        RedirectView view = new RedirectView(url, contextRelative, http10Compatible);\n        view.renderMergedOutputModel(queryParams, toHttp(request), toHttp(response));\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request  the servlet request.\n     * @param response the servlet response.\n     * @param url      the URL to redirect the user to.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url) throws IOException {\n        issueRedirect(request, response, url, null, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request     the servlet request.\n     * @param response    the servlet response.\n     * @param url         the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams) throws IOException {\n        issueRedirect(request, response, url, queryParams, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request         the servlet request.\n     * @param response        the servlet response.\n     * @param url             the URL to redirect the user to.\n     * @param queryParams     a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative) throws IOException {\n        issueRedirect(request, response, url, queryParams, contextRelative, true);\n    }\n\n    /**\n     * <p>Checks to see if a request param is considered true using a loose matching strategy for\n     * general values that indicate that something is true or enabled, etc.</p>\n     * <p/>\n     * <p>Values that are considered \"true\" include (case-insensitive): true, t, 1, enabled, y, yes, on.</p>\n     *\n     * @param request   the servlet request\n     * @param paramName @return true if the param value is considered true or false if it isn't.\n     * @return true if the given parameter is considered \"true\" - false otherwise.\n     */\n    public static boolean isTrue(ServletRequest request, String paramName) {\n        String value = getCleanParam(request, paramName);\n        return value != null &&\n                (value.equalsIgnoreCase(\"true\") ||\n                        value.equalsIgnoreCase(\"t\") ||\n                        value.equalsIgnoreCase(\"1\") ||\n                        value.equalsIgnoreCase(\"enabled\") ||\n                        value.equalsIgnoreCase(\"y\") ||\n                        value.equalsIgnoreCase(\"yes\") ||\n                        value.equalsIgnoreCase(\"on\"));\n    }\n\n    /**\n     * Convenience method that returns a request parameter value, first running it through\n     * {@link StringUtils#clean(String)}.\n     *\n     * @param request   the servlet request.\n     * @param paramName the parameter name.\n     * @return the clean param value, or null if the param does not exist or is empty.\n     */\n    public static String getCleanParam(ServletRequest request, String paramName) {\n        return StringUtils.clean(request.getParameter(paramName));\n    }\n\n    public static void saveRequest(ServletRequest request) {\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession();\n        HttpServletRequest httpRequest = toHttp(request);\n        SavedRequest savedRequest = new SavedRequest(httpRequest);\n        session.setAttribute(SAVED_REQUEST_KEY, savedRequest);\n    }\n\n    public static SavedRequest getAndClearSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = getSavedRequest(request);\n        if (savedRequest != null) {\n            Subject subject = SecurityUtils.getSubject();\n            Session session = subject.getSession();\n            session.removeAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    public static SavedRequest getSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = null;\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n        if (session != null) {\n            savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    /**\n     * Redirects the to the request url from a previously\n     * {@link #saveRequest(javax.servlet.ServletRequest) saved} request, or if there is no saved request, redirects the\n     * end user to the specified {@code fallbackUrl}.  If there is no saved request or fallback url, this method\n     * throws an {@link IllegalStateException}.\n     * <p/>\n     * This method is primarily used to support a common login scenario - if an unauthenticated user accesses a\n     * page that requires authentication, it is expected that request is\n     * {@link #saveRequest(javax.servlet.ServletRequest) saved} first and then redirected to the login page. Then,\n     * after a successful login, this method can be called to redirect them back to their originally requested URL, a\n     * nice usability feature.\n     *\n     * @param request     the incoming request\n     * @param response    the outgoing response\n     * @param fallbackUrl the fallback url to redirect to if there is no saved request available.\n     * @throws IllegalStateException if there is no saved request and the {@code fallbackUrl} is {@code null}.\n     * @throws IOException           if there is an error redirecting\n     * @since 1.0\n     */\n    public static void redirectToSavedRequest(ServletRequest request, ServletResponse response, String fallbackUrl)\n            throws IOException {\n        String successUrl = null;\n        boolean contextRelative = true;\n        SavedRequest savedRequest = WebUtils.getAndClearSavedRequest(request);\n        if (savedRequest != null && savedRequest.getMethod().equalsIgnoreCase(AccessControlFilter.GET_METHOD)) {\n            successUrl = savedRequest.getRequestUrl();\n            contextRelative = false;\n        }\n\n        if (successUrl == null) {\n            successUrl = fallbackUrl;\n        }\n\n        if (successUrl == null) {\n            throw new IllegalStateException(\"Success URL not available via saved request or via the \" +\n                    \"successUrlFallback method parameter. One of these must be non-null for \" +\n                    \"issueSuccessRedirect() to work.\");\n        }\n\n        WebUtils.issueRedirect(request, response, successUrl, null, contextRelative);\n    }\n\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200115,
    "RELATED_CWE": [
      "CWE-614",
      "CWE-79",
      "CWE-918"
    ]
  }
]