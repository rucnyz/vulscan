[
  {
    "CWE_ID": [
      "CWE-434"
    ],
    "code": "/**\n * Copyright (C) 2013 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.hawt.web;\n\nimport io.hawt.git.GitFacade;\nimport io.hawt.git.WriteCallback;\nimport io.hawt.git.WriteContext;\nimport io.hawt.util.Files;\nimport io.hawt.util.Function;\nimport io.hawt.util.IOHelper;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.api.errors.GitAPIException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n */\npublic class GitServlet extends UploadServlet {\n    private static final transient Logger LOG = LoggerFactory.getLogger(GitServlet.class);\n\n    private static final int DEFAULT_BUFFER_SIZE = 10240; // 10KB.\n\n    @Override\n    protected void doGet(HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {\n        GitFacade gitFacade = GitFacade.getSingleton();\n        if (gitFacade == null) {\n            throw new ServletException(\"No GitFacade object available!\");\n        }\n        Params params = parsePararams(req, resp);\n        if (params == null) {\n            return;\n        }\n        String branch = params.getBranch();\n        String path = params.getPath();\n\n        Function<File, Object> callback = new Function<File, Object>() {\n            @Override\n            public Object apply(File file) {\n                String type = getServletContext().getMimeType(file.getAbsolutePath());\n                if (type == null) {\n                    type = \"application/octet-stream\";\n                }\n                resp.reset();\n                resp.setBufferSize(DEFAULT_BUFFER_SIZE);\n                resp.setContentType(type);\n                if (file.isFile() && file.exists()) {\n                    try {\n                        byte[] bytes = Files.readBytes(file);\n                        int length = bytes.length;\n                        LOG.debug(\"Serving file: \" + file.getAbsolutePath() + \" of type \" + type + \" length: \" + length);\n                        resp.setContentLength(length);\n                        resp.getOutputStream().write(bytes);\n                    } catch (IOException e) {\n                        throw new RuntimeException(\"Failed to read file \" + file + \". \" + e, e);\n                    }\n                }\n                return null;\n            }\n        };\n        try {\n            gitFacade.readFile(branch, path, callback);\n        } catch (GitAPIException e) {\n            throw new ServletException(\"Failed to read file: \" + path + \" on branch \" + branch + \". \" + e, e);\n        }\n    }\n\n\n    @Override\n    protected void doPost(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {\n        GitFacade gitFacade = GitFacade.getSingleton();\n        if (gitFacade == null) {\n            throw new ServletException(\"No GitFacade object available!\");\n        }\n        Params params = parsePararams(req, resp);\n        if (params == null) {\n            return;\n        }\n        String branch = params.getBranch();\n        String path = params.getPath();\n\n        WriteCallback<Object> callback = new WriteCallback<Object>() {\n            @Override\n            public Object apply(WriteContext context) throws IOException, GitAPIException {\n                File file = context.getFile();\n                List<File> uploadedFiles = null;\n                try {\n                    uploadedFiles = uploadFiles(req, resp, file);\n                } catch (ServletException e) {\n                    throw new IOException(e);\n                }\n                if (uploadedFiles != null) {\n                    for (File uploadedFile : uploadedFiles) {\n                        LOG.info(\"Adding to folder: \" + file + \" file: \" + uploadedFile + \" to git\");\n                        context.addFile(uploadedFile);\n                    }\n                }\n                return null;\n            }\n        };\n        try {\n            gitFacade.writeFile(branch, path, callback);\n        } catch (GitAPIException e) {\n            throw new ServletException(\"Failed to read file: \" + path + \" on branch \" + branch + \". \" + e, e);\n        }\n    }\n\n\n    protected Params parsePararams(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String requested = req.getPathInfo();\n        LOG.debug(\"Requested file : \" + requested);\n        if (requested == null) {\n            notFound(resp);\n            return null;\n        }\n        while (requested.startsWith(\"/\")) {\n            requested = requested.substring(1);\n        }\n        int idx = requested.indexOf('/');\n        if (idx < 0) {\n            notFound(resp);\n            return null;\n        }\n        String branch = requested.substring(0, idx);\n        if (branch.length() <= 0) {\n            resp.getWriter().println(\"No branch specified!\");\n            notFound(resp);\n        }\n        String path = requested.substring(idx + 1);\n        if (path == null || path.length() == 0) {\n            path = \"/\";\n        }\n        return new Params(branch, path);\n    }\n\n\n    protected void notFound(HttpServletResponse resp) throws IOException {\n        resp.sendError(HttpServletResponse.SC_NOT_FOUND);\n    }\n\n    protected static class Params {\n        private final String branch;\n        private final String path;\n\n        public Params(String branch, String path) {\n            this.branch = branch;\n            this.path = path;\n        }\n\n        public String getBranch() {\n            return branch;\n        }\n\n        public String getPath() {\n            return path;\n        }\n    }\n}",
    "target": 1,
    "language": "java",
    "dataset": "A-Manually-Curated-Dataset-of-Vulnerability-Introducing-Commits-in-Java",
    "idx": 800000,
    "RELATED_CWE": [
      "CWE-22",
      "CWE-862",
      "CWE-502"
    ]
  },
  {
    "CWE_ID": [
      "CWE-434"
    ],
    "code": "/**\n * Copyright (C) 2013 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.hawt.web;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.ServletConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport io.hawt.git.GitFileManager;\nimport io.hawt.git.GitFacade;\nimport io.hawt.git.WriteCallback;\nimport io.hawt.git.WriteContext;\nimport io.hawt.git.GitHelper;\nimport io.hawt.util.Files;\nimport io.hawt.util.Function;\nimport io.hawt.util.Strings;\nimport io.hawt.util.Zips;\nimport org.apache.commons.fileupload.FileUploadBase;\nimport org.apache.commons.fileupload.FileUploadException;\nimport org.eclipse.jgit.api.errors.GitAPIException;\nimport org.osgi.framework.BundleContext;\nimport org.osgi.framework.ServiceReference;\nimport org.osgi.util.tracker.ServiceTracker;\nimport org.osgi.util.tracker.ServiceTrackerCustomizer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n */\npublic class GitServlet extends UploadServlet implements ServiceTrackerCustomizer {\n    private static final transient Logger LOG = LoggerFactory.getLogger(GitServlet.class);\n\n    private static final int DEFAULT_BUFFER_SIZE = 10240; // 10KB.\n    private static final String GIT_FILE_UPLOAD_PROPNAME = \"hawtio.upload.git.filter\";\n\n    private BundleContext bundleContext;\n    private ServiceTracker serviceTracker;\n    private GitFileManager gitFacade;\n    private List<GlobalFileUploadFilter.MagicNumberFileFilter> gitFileUploadFilters;\n\n    @Override\n    public void init(ServletConfig config) throws ServletException {\n        super.init(config);\n\n        bundleContext = (BundleContext) getServletContext().getAttribute(\"osgi-bundlecontext\");\n\n        if (bundleContext == null) {\n            gitFacade = GitFacade.getSingleton();\n        } else {\n            serviceTracker = new ServiceTracker(bundleContext, GitFileManager.class.getName(), this);\n            serviceTracker.open();\n        }\n    }\n\n    @Override\n    public void destroy() {\n        if (serviceTracker != null) {\n            serviceTracker.close();\n        }\n        super.destroy();\n    }\n\n    @Override\n    protected void doGet(HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {\n        if (gitFacade == null) {\n            throw new ServletException(\"No GitFacade object available!\");\n        }\n        Params params = parsePararams(req, resp);\n        if (params == null) {\n            return;\n        }\n        String branch = params.getBranch();\n        String path = params.getPath();\n\n        Function<File, Object> callback = new Function<File, Object>() {\n            @Override\n            public Object apply(File file) {\n                try {\n                    String name = file.getName();\n                    if (!file.exists() && name.endsWith(\".zip\")) {\n                        String folderName = name.substring(0, name.length() - 4);\n                        File dir = new File(file.getParentFile(), folderName);\n                        if (dir.exists()) {\n                            file = dir;\n                        }\n                    }\n                    if (file.isDirectory() && file.exists()) {\n                        // lets create a temporary zip for a directory\n                        file = createZip(file);\n                    }\n                    String type = getServletContext().getMimeType(file.getAbsolutePath());\n                    if (type == null) {\n                        type = \"application/octet-stream\";\n                    }\n                    resp.reset();\n                    resp.setBufferSize(DEFAULT_BUFFER_SIZE);\n                    resp.setContentType(type);\n                    if (file.isFile() && file.exists()) {\n                        byte[] bytes = Files.readBytes(file);\n                        int length = bytes.length;\n                        LOG.debug(\"Serving file: \" + file.getAbsolutePath() + \" of type \" + type + \" length: \" + length);\n                        resp.setContentLength(length);\n                        resp.getOutputStream().write(bytes);\n                    }\n                } catch (IOException e) {\n                    throw new RuntimeException(\"Failed to read file \" + file + \". \" + e, e);\n                }\n                return null;\n            }\n        };\n        try {\n            gitFacade.readFile(branch, path, callback);\n        } catch (GitAPIException e) {\n            throw new ServletException(\"Failed to read file: \" + path + \" on branch \" + branch + \". \" + e, e);\n        }\n    }\n\n    protected File createZip(File file) throws IOException {\n        File answer = File.createTempFile(file.getName(), \"zip\");\n        Zips.createZipFile(LOG, file, answer);\n        return answer;\n    }\n\n\n    @Override\n    protected void doPost(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {\n        if (gitFacade == null) {\n            throw new ServletException(\"No GitFacade object available!\");\n        }\n\n        Params params = parsePararams(req, resp);\n        if (params == null) {\n            return;\n        }\n        String branch = params.getBranch();\n        String path = params.getPath();\n\n        WriteCallback<Object> callback = new WriteCallback<Object>() {\n            @Override\n            public Object apply(WriteContext context) throws IOException, GitAPIException {\n                File file = context.getFile();\n                String unpackZipFlag = req.getParameter(\"unpackZip\");\n                boolean unzip = true;\n                if (Strings.isNotBlank(unpackZipFlag)) {\n                    String lowerFlag = unpackZipFlag.toLowerCase();\n                    if (lowerFlag.startsWith(\"f\") || lowerFlag.equals(\"0\")) {\n                        unzip = false;\n                    }\n                }\n                List<File> uploadedFiles = null;\n                try {\n                    if (isFileUploadFilterConfigured() && !(file.length() <= GlobalFileUploadFilter.getMaxFileSizeAllowed(gitFileUploadFilters))) {\n                        throw new FileUploadBase.FileUploadIOException(\n                            new FileUploadException(\"File exceeds its maximum permitted size of bytes.\"));\n                    }\n                    uploadedFiles = uploadFiles(req, resp, file, gitFileUploadFilters);\n                } catch (ServletException e) {\n                    throw new IOException(e);\n                }\n                GitHelper.doUploadFiles(context, file, unzip, uploadedFiles);\n                return null;\n            }\n        };\n        try {\n            gitFacade.writeFile(branch, path, callback);\n        } catch (GitAPIException e) {\n            throw new ServletException(\"Failed to read file: \" + path + \" on branch \" + branch + \". \" + e, e);\n        }\n    }\n\n\n    protected Params parsePararams(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String requested = req.getPathInfo();\n        LOG.debug(\"Requested file : \" + requested);\n        if (requested == null) {\n            notFound(resp);\n            return null;\n        }\n        while (requested.startsWith(\"/\")) {\n            requested = requested.substring(1);\n        }\n        int idx = requested.indexOf('/');\n        if (idx < 0) {\n            notFound(resp);\n            return null;\n        }\n        String branch = requested.substring(0, idx);\n        if (branch.length() <= 0) {\n            resp.getWriter().println(\"No branch specified!\");\n            notFound(resp);\n        }\n        String path = requested.substring(idx + 1);\n        if (path == null || path.length() == 0) {\n            path = \"/\";\n        }\n        return new Params(branch, path);\n    }\n\n\n    protected void notFound(HttpServletResponse resp) throws IOException {\n        resp.sendError(HttpServletResponse.SC_NOT_FOUND);\n    }\n\n    @Override\n    public Object addingService(ServiceReference serviceReference) {\n        LOG.debug(\"Using new git file manager\");\n\n        gitFacade = (GitFileManager) bundleContext.getService(serviceReference);\n        return gitFacade;\n    }\n\n    @Override\n    public void modifiedService(ServiceReference serviceReference, Object o) {\n\n    }\n\n    @Override\n    public void removedService(ServiceReference serviceReference, Object o) {\n        LOG.debug(\"Unsetting git file manager\");\n        gitFacade = null;\n        bundleContext.ungetService(serviceReference);\n    }\n\n    protected static class Params {\n        private final String branch;\n        private final String path;\n\n        public Params(String branch, String path) {\n            this.branch = branch;\n            this.path = path;\n        }\n\n        public String getBranch() {\n            return branch;\n        }\n\n        public String getPath() {\n            return path;\n        }\n    }\n\n    private boolean isFileUploadFilterConfigured() {\n        boolean configured = false;\n        String config = System.getProperty(GIT_FILE_UPLOAD_PROPNAME);\n        try {\n            if (config != null) {\n                configured = true;\n                gitFileUploadFilters = GlobalFileUploadFilter.constructFilters(config, new ArrayList<>());\n            } else {\n                configured = false;\n                if (gitFileUploadFilters == null || gitFileUploadFilters.isEmpty()) {\n                    gitFileUploadFilters = new ArrayList<>();\n                }\n            }\n        } catch (RuntimeException e) {\n            LOG.warn(\"Error configuring filter {}\", config);\n        }\n\n        return configured;\n    }\n}",
    "target": 0,
    "language": "java",
    "dataset": "A-Manually-Curated-Dataset-of-Vulnerability-Introducing-Commits-in-Java",
    "idx": 800001,
    "RELATED_CWE": [
      "CWE-22",
      "CWE-862",
      "CWE-502"
    ]
  }
]