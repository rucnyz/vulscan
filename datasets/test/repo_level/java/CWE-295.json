[
  {
    "CWE_ID": [
      "CWE-295"
    ],
    "code": "/*\n * Copyright 2016 Analytical Graphics, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage org.keycloak.authentication.authenticators.x509;\n\nimport freemarker.template.utility.NullArgumentException;\nimport org.bouncycastle.asn1.ASN1ObjectIdentifier;\nimport org.bouncycastle.asn1.x500.RDN;\nimport org.bouncycastle.asn1.x500.X500Name;\nimport org.bouncycastle.asn1.x500.style.IETFUtils;\nimport org.keycloak.services.ServicesLogger;\n\nimport java.security.cert.CertificateParsingException;\nimport java.security.cert.X509Certificate;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.function.Function;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * @author <a href=\"mailto:pnalyvayko@agi.com\">Peter Nalyvayko</a>\n * @version $Revision: 1 $\n * @date 7/30/2016\n */\n\npublic abstract class UserIdentityExtractor {\n\n    private static final ServicesLogger logger = ServicesLogger.LOGGER;\n\n    public abstract Object extractUserIdentity(X509Certificate[] certs);\n\n    static class OrExtractor extends UserIdentityExtractor {\n\n        UserIdentityExtractor extractor;\n        UserIdentityExtractor other;\n        OrExtractor(UserIdentityExtractor extractor, UserIdentityExtractor other) {\n            this.extractor = extractor;\n            this.other = other;\n\n            if (this.extractor == null)\n                throw new NullArgumentException(\"extractor\");\n            if (this.other == null)\n                throw new NullArgumentException(\"other\");\n        }\n\n        @Override\n        public Object extractUserIdentity(X509Certificate[] certs) {\n            Object result = this.extractor.extractUserIdentity(certs);\n            if (result == null)\n                result = this.other.extractUserIdentity(certs);\n            return result;\n        }\n    }\n\n    static class X500NameRDNExtractor extends UserIdentityExtractor {\n\n        private ASN1ObjectIdentifier x500NameStyle;\n        Function<X509Certificate[],X500Name> x500Name;\n        X500NameRDNExtractor(ASN1ObjectIdentifier x500NameStyle, Function<X509Certificate[],X500Name> x500Name) {\n            this.x500NameStyle = x500NameStyle;\n            this.x500Name = x500Name;\n        }\n\n        @Override\n        public Object extractUserIdentity(X509Certificate[] certs) {\n\n            if (certs == null || certs.length == 0)\n                throw new IllegalArgumentException();\n\n            X500Name name = x500Name.apply(certs);\n            if (name != null) {\n                RDN[] rnds = name.getRDNs(x500NameStyle);\n                if (rnds != null && rnds.length > 0) {\n                    RDN cn = rnds[0];\n                    return IETFUtils.valueToString(cn.getFirst().getValue());\n                }\n            }\n            return null;\n        }\n    }\n\n    /**\n     * Extracts the subject identifier from the subjectAltName extension.\n     */\n    static class SubjectAltNameExtractor extends UserIdentityExtractor {\n\n        private final int generalName;\n\n        /**\n         * Creates a new instance\n         *\n         * @param generalName an integer representing the general name. See {@link X509Certificate#getSubjectAlternativeNames()}\n         */\n        SubjectAltNameExtractor(int generalName) {\n            this.generalName = generalName;\n        }\n\n        @Override\n        public Object extractUserIdentity(X509Certificate[] certs) {\n            if (certs == null || certs.length == 0) {\n                throw new IllegalArgumentException();\n            }\n\n            try {\n                Collection<List<?>> subjectAlternativeNames = certs[0].getSubjectAlternativeNames();\n\n                if (subjectAlternativeNames == null) {\n                    return null;\n                }\n\n                Iterator<List<?>> iterator = subjectAlternativeNames.iterator();\n\n                while (iterator.hasNext()) {\n                    List<?> next = iterator.next();\n\n                    if (Integer.class.cast(next.get(0)) == generalName) {\n                        return next.get(1);\n                    }\n                }\n            } catch (CertificateParsingException cause) {\n                logger.errorf(cause, \"Failed to obtain identity from subjectAltName extension\");\n            }\n\n            return null;\n        }\n    }\n\n    static class PatternMatcher extends UserIdentityExtractor {\n        private final String _pattern;\n        private final Function<X509Certificate[],String> _f;\n        PatternMatcher(String pattern, Function<X509Certificate[],String> valueToMatch) {\n            _pattern = pattern;\n            _f = valueToMatch;\n        }\n\n        @Override\n        public Object extractUserIdentity(X509Certificate[] certs) {\n            String value = _f.apply(certs);\n\n            Pattern r = Pattern.compile(_pattern, Pattern.CASE_INSENSITIVE);\n\n            Matcher m = r.matcher(value);\n\n            if (!m.find()) {\n                logger.debugf(\"[PatternMatcher:extract] No matches were found for input \\\"%s\\\", pattern=\\\"%s\\\"\", value, _pattern);\n                return null;\n            }\n\n            if (m.groupCount() != 1) {\n                logger.debugf(\"[PatternMatcher:extract] Match produced more than a single group for input \\\"%s\\\", pattern=\\\"%s\\\"\", value, _pattern);\n                return null;\n            }\n\n            return m.group(1);\n        }\n    }\n\n    static class OrBuilder {\n        UserIdentityExtractor extractor;\n        UserIdentityExtractor other;\n        OrBuilder(UserIdentityExtractor extractor) {\n            this.extractor = extractor;\n        }\n\n        public UserIdentityExtractor or(UserIdentityExtractor other) {\n            return new OrExtractor(extractor, other);\n        }\n    }\n\n    public static UserIdentityExtractor getPatternIdentityExtractor(String pattern,\n                                                                 Function<X509Certificate[],String> func) {\n        return new PatternMatcher(pattern, func);\n    }\n\n    public static UserIdentityExtractor getX500NameExtractor(ASN1ObjectIdentifier identifier, Function<X509Certificate[],X500Name> x500Name) {\n        return new X500NameRDNExtractor(identifier, x500Name);\n    }\n\n    /**\n     * Obtains the subjectAltName given a <code>generalName</code>.\n     *\n     * @param generalName an integer representing the general name. See {@link X509Certificate#getSubjectAlternativeNames()}\n     * @return the value from the subjectAltName extension\n     */\n    public static SubjectAltNameExtractor getSubjectAltNameExtractor(int generalName) {\n        return new SubjectAltNameExtractor(generalName);\n    }\n\n    public static OrBuilder either(UserIdentityExtractor extractor) {\n        return new OrBuilder(extractor);\n    }\n}",
    "target": 1,
    "language": "java",
    "dataset": "A-Manually-Curated-Dataset-of-Vulnerability-Introducing-Commits-in-Java",
    "idx": 800084,
    "RELATED_CWE": [
      "CWE-863",
      "CWE-285",
      "CWE-862"
    ]
  },
  {
    "CWE_ID": [
      "CWE-295"
    ],
    "code": "/*\n * Copyright 2016 Analytical Graphics, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage org.keycloak.authentication.authenticators.x509;\n\nimport freemarker.template.utility.NullArgumentException;\nimport org.bouncycastle.asn1.ASN1Encodable;\nimport org.bouncycastle.asn1.ASN1InputStream;\nimport org.bouncycastle.asn1.ASN1ObjectIdentifier;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.ASN1TaggedObject;\nimport org.bouncycastle.asn1.DERUTF8String;\nimport org.bouncycastle.asn1.x500.RDN;\nimport org.bouncycastle.asn1.x500.X500Name;\nimport org.bouncycastle.asn1.x500.style.IETFUtils;\nimport org.keycloak.services.ServicesLogger;\n\nimport java.io.ByteArrayInputStream;\nimport java.security.cert.CertificateParsingException;\nimport java.security.cert.X509Certificate;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.function.Function;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * @author <a href=\"mailto:pnalyvayko@agi.com\">Peter Nalyvayko</a>\n * @version $Revision: 1 $\n * @date 7/30/2016\n */\n\npublic abstract class UserIdentityExtractor {\n\n    private static final ServicesLogger logger = ServicesLogger.LOGGER;\n\n    public abstract Object extractUserIdentity(X509Certificate[] certs);\n\n    static class OrExtractor extends UserIdentityExtractor {\n\n        UserIdentityExtractor extractor;\n        UserIdentityExtractor other;\n        OrExtractor(UserIdentityExtractor extractor, UserIdentityExtractor other) {\n            this.extractor = extractor;\n            this.other = other;\n\n            if (this.extractor == null)\n                throw new NullArgumentException(\"extractor\");\n            if (this.other == null)\n                throw new NullArgumentException(\"other\");\n        }\n\n        @Override\n        public Object extractUserIdentity(X509Certificate[] certs) {\n            Object result = this.extractor.extractUserIdentity(certs);\n            if (result == null)\n                result = this.other.extractUserIdentity(certs);\n            return result;\n        }\n    }\n\n    static class X500NameRDNExtractor extends UserIdentityExtractor {\n\n        private ASN1ObjectIdentifier x500NameStyle;\n        Function<X509Certificate[],X500Name> x500Name;\n        X500NameRDNExtractor(ASN1ObjectIdentifier x500NameStyle, Function<X509Certificate[],X500Name> x500Name) {\n            this.x500NameStyle = x500NameStyle;\n            this.x500Name = x500Name;\n        }\n\n        @Override\n        public Object extractUserIdentity(X509Certificate[] certs) {\n\n            if (certs == null || certs.length == 0)\n                throw new IllegalArgumentException();\n\n            X500Name name = x500Name.apply(certs);\n            if (name != null) {\n                RDN[] rnds = name.getRDNs(x500NameStyle);\n                if (rnds != null && rnds.length > 0) {\n                    RDN cn = rnds[0];\n                    return IETFUtils.valueToString(cn.getFirst().getValue());\n                }\n            }\n            return null;\n        }\n    }\n\n    /**\n     * Extracts the subject identifier from the subjectAltName extension.\n     */\n    static class SubjectAltNameExtractor extends UserIdentityExtractor {\n\n        // User Principal Name. Used typically by Microsoft in certificates for Smart Card Login\n        private static final String UPN_OID = \"1.3.6.1.4.1.311.20.2.3\";\n\n        private final int generalName;\n\n        /**\n         * Creates a new instance\n         *\n         * @param generalName an integer representing the general name. See {@link X509Certificate#getSubjectAlternativeNames()}\n         */\n        SubjectAltNameExtractor(int generalName) {\n            this.generalName = generalName;\n        }\n\n        @Override\n        public Object extractUserIdentity(X509Certificate[] certs) {\n            if (certs == null || certs.length == 0) {\n                throw new IllegalArgumentException();\n            }\n\n            try {\n                Collection<List<?>> subjectAlternativeNames = certs[0].getSubjectAlternativeNames();\n\n                if (subjectAlternativeNames == null) {\n                    return null;\n                }\n\n                Iterator<List<?>> iterator = subjectAlternativeNames.iterator();\n\n                boolean foundUpn = false;\n                String tempOtherName = null;\n                String tempOid = null;\n\n                while (iterator.hasNext() && !foundUpn) {\n                    List<?> next = iterator.next();\n\n                    if (Integer.class.cast(next.get(0)) == generalName) {\n\n                        // We will try to find UPN_OID among the subjectAltNames of type 'otherName' . Just if not found, we will fallback to the other type\n                        for (int i = 1 ; i<next.size() ; i++) {\n                            Object obj = next.get(i);\n\n                            // We have Subject Alternative Name of other type than 'otherName' . Just return it directly\n                            if (generalName != 0) {\n                                logger.tracef(\"Extracted identity '%s' from Subject Alternative Name of type '%d'\", obj, generalName);\n                                return obj;\n                            }\n\n                            byte[] otherNameBytes = (byte[]) obj;\n\n                            try {\n                                ASN1InputStream asn1Stream = new ASN1InputStream(new ByteArrayInputStream(otherNameBytes));\n                                ASN1Encodable asn1otherName = asn1Stream.readObject();\n                                asn1otherName = unwrap(asn1otherName);\n\n                                ASN1Sequence asn1Sequence = ASN1Sequence.getInstance(asn1otherName);\n\n                                if (asn1Sequence != null) {\n                                    ASN1Encodable encodedOid = asn1Sequence.getObjectAt(0);\n                                    ASN1ObjectIdentifier oid = ASN1ObjectIdentifier.getInstance(unwrap(encodedOid));\n                                    tempOid = oid.getId();\n\n                                    ASN1Encodable principalNameEncoded = asn1Sequence.getObjectAt(1);\n                                    DERUTF8String principalName = DERUTF8String.getInstance(unwrap(principalNameEncoded));\n\n                                    tempOtherName = principalName.getString();\n\n                                    // We found UPN among the 'otherName' principal. We don't need to look other\n                                    if (UPN_OID.equals(tempOid)) {\n                                        foundUpn = true;\n                                        break;\n                                    }\n                                }\n\n                            } catch (Exception e) {\n                                logger.error(\"Failed to parse subjectAltName\", e);\n                            }\n                        }\n\n                    }\n                }\n\n                logger.tracef(\"Parsed otherName from subjectAltName. OID: '%s', Principal: '%s'\", tempOid, tempOtherName);\n\n                return tempOtherName;\n\n            } catch (CertificateParsingException cause) {\n                logger.errorf(cause, \"Failed to obtain identity from subjectAltName extension\");\n            }\n\n            return null;\n        }\n\n\n        private ASN1Encodable unwrap(ASN1Encodable encodable) {\n            while (encodable instanceof ASN1TaggedObject) {\n                ASN1TaggedObject taggedObj = (ASN1TaggedObject) encodable;\n                encodable = taggedObj.getObject();\n            }\n\n            return encodable;\n        }\n    }\n\n    static class PatternMatcher extends UserIdentityExtractor {\n        private final String _pattern;\n        private final Function<X509Certificate[],String> _f;\n        PatternMatcher(String pattern, Function<X509Certificate[],String> valueToMatch) {\n            _pattern = pattern;\n            _f = valueToMatch;\n        }\n\n        @Override\n        public Object extractUserIdentity(X509Certificate[] certs) {\n            String value = _f.apply(certs);\n\n            Pattern r = Pattern.compile(_pattern, Pattern.CASE_INSENSITIVE);\n\n            Matcher m = r.matcher(value);\n\n            if (!m.find()) {\n                logger.debugf(\"[PatternMatcher:extract] No matches were found for input \\\"%s\\\", pattern=\\\"%s\\\"\", value, _pattern);\n                return null;\n            }\n\n            if (m.groupCount() != 1) {\n                logger.debugf(\"[PatternMatcher:extract] Match produced more than a single group for input \\\"%s\\\", pattern=\\\"%s\\\"\", value, _pattern);\n                return null;\n            }\n\n            return m.group(1);\n        }\n    }\n\n    static class OrBuilder {\n        UserIdentityExtractor extractor;\n        UserIdentityExtractor other;\n        OrBuilder(UserIdentityExtractor extractor) {\n            this.extractor = extractor;\n        }\n\n        public UserIdentityExtractor or(UserIdentityExtractor other) {\n            return new OrExtractor(extractor, other);\n        }\n    }\n\n    public static UserIdentityExtractor getPatternIdentityExtractor(String pattern,\n                                                                 Function<X509Certificate[],String> func) {\n        return new PatternMatcher(pattern, func);\n    }\n\n    public static UserIdentityExtractor getX500NameExtractor(ASN1ObjectIdentifier identifier, Function<X509Certificate[],X500Name> x500Name) {\n        return new X500NameRDNExtractor(identifier, x500Name);\n    }\n\n    /**\n     * Obtains the subjectAltName given a <code>generalName</code>.\n     *\n     * @param generalName an integer representing the general name. See {@link X509Certificate#getSubjectAlternativeNames()}\n     * @return the value from the subjectAltName extension\n     */\n    public static SubjectAltNameExtractor getSubjectAltNameExtractor(int generalName) {\n        return new SubjectAltNameExtractor(generalName);\n    }\n\n    public static OrBuilder either(UserIdentityExtractor extractor) {\n        return new OrBuilder(extractor);\n    }\n}",
    "target": 0,
    "language": "java",
    "dataset": "A-Manually-Curated-Dataset-of-Vulnerability-Introducing-Commits-in-Java",
    "idx": 800085,
    "RELATED_CWE": [
      "CWE-863",
      "CWE-285",
      "CWE-862"
    ]
  },
  {
    "CWE_ID": [
      "CWE-295"
    ],
    "code": "/*\n * Copyright (C) 2004 Red Hat Inc.\n * Copyright (C) 2005 Martin Koegler\n * Copyright (C) 2010 m-privacy GmbH\n * Copyright (C) 2010 TigerVNC Team\n * Copyright (C) 2011-2019 Brian P. Hinz\n * Copyright (C) 2015 D. R. Commander.  All Rights Reserved.\n *\n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n * USA.\n */\n\npackage com.tigervnc.rfb;\n\nimport javax.net.ssl.*;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.MessageDigest;\nimport java.security.cert.*;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Base64;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.naming.InvalidNameException;\nimport javax.naming.ldap.LdapName;\nimport javax.naming.ldap.Rdn;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.swing.JOptionPane;\n\nimport com.tigervnc.rdr.*;\nimport com.tigervnc.network.*;\nimport com.tigervnc.vncviewer.*;\n\nimport static javax.swing.JOptionPane.*;\n\npublic class CSecurityTLS extends CSecurity {\n\n  public static StringParameter X509CA\n  = new StringParameter(\"X509CA\",\n                        \"X509 CA certificate\", \"\", Configuration.ConfigurationObject.ConfViewer);\n  public static StringParameter X509CRL\n  = new StringParameter(\"X509CRL\",\n                        \"X509 CRL file\", \"\", Configuration.ConfigurationObject.ConfViewer);\n  public static UserMsgBox msg;\n\n  private void initGlobal()\n  {\n    try {\n      ctx = SSLContext.getInstance(\"TLS\");\n    } catch(NoSuchAlgorithmException e) {\n      throw new Exception(e.toString());\n    }\n  }\n\n  public CSecurityTLS(boolean _anon)\n  {\n    anon = _anon;\n    manager = null;\n\n    setDefaults();\n    cafile = X509CA.getData();\n    crlfile = X509CRL.getData();\n  }\n\n  public static String getDefaultCA() {\n    if (UserPreferences.get(\"viewer\", \"x509ca\") != null)\n      return UserPreferences.get(\"viewer\", \"x509ca\");\n    return FileUtils.getVncHomeDir()+\"x509_ca.pem\";\n  }\n\n  public static String getDefaultCRL() {\n    if (UserPreferences.get(\"viewer\", \"x509crl\") != null)\n      return UserPreferences.get(\"viewer\", \"x509crl\");\n    return FileUtils.getVncHomeDir()+\"x509_crl.pem\";\n  }\n\n  public static void setDefaults()\n  {\n    if (new File(getDefaultCA()).exists())\n      X509CA.setDefaultStr(getDefaultCA());\n    if (new File(getDefaultCRL()).exists())\n      X509CRL.setDefaultStr(getDefaultCRL());\n  }\n\n// FIXME:\n// Need to shutdown the connection cleanly\n\n// FIXME?\n// add a finalizer method that calls shutdown\n\n  public boolean processMsg(CConnection cc) {\n    is = (FdInStream)cc.getInStream();\n    os = (FdOutStream)cc.getOutStream();\n    client = cc;\n\n    initGlobal();\n\n    if (manager == null) {\n      if (!is.checkNoWait(1))\n        return false;\n\n      if (is.readU8() == 0) {\n        int result = is.readU32();\n        String reason;\n        if (result == Security.secResultFailed ||\n            result == Security.secResultTooMany)\n          reason = is.readString();\n        else\n          reason = new String(\"Authentication failure (protocol error)\");\n        throw new AuthFailureException(reason);\n      }\n\n      setParam();\n    }\n\n    try {\n      manager = new SSLEngineManager(engine, is, os);\n      manager.doHandshake();\n    } catch(java.lang.Exception e) {\n      throw new SystemException(e.toString());\n    }\n\n    cc.setStreams(new TLSInStream(is, manager),\n\t\t              new TLSOutStream(os, manager));\n    return true;\n  }\n\n  private void setParam() {\n\n    if (anon) {\n      try {\n        ctx.init(null, null, null);\n      } catch(KeyManagementException e) {\n        throw new AuthFailureException(e.toString());\n      }\n    } else {\n      try {\n        TrustManager[] myTM = new TrustManager[] {\n          new MyX509TrustManager()\n        };\n        ctx.init (null, myTM, null);\n      } catch (java.security.GeneralSecurityException e) {\n        throw new AuthFailureException(e.toString());\n      }\n    }\n    SSLSocketFactory sslfactory = ctx.getSocketFactory();\n    engine = ctx.createSSLEngine(client.getServerName(),\n                                 client.getServerPort());\n    engine.setUseClientMode(true);\n\n    String[] supported = engine.getSupportedProtocols();\n    ArrayList<String> enabled = new ArrayList<String>();\n    for (int i = 0; i < supported.length; i++)\n      if (supported[i].matches(\"TLS.*\"))\n\t      enabled.add(supported[i]);\n    engine.setEnabledProtocols(enabled.toArray(new String[0]));\n\n    if (anon) {\n      supported = engine.getSupportedCipherSuites();\n      enabled = new ArrayList<String>();\n      // prefer ECDH over DHE\n      for (int i = 0; i < supported.length; i++)\n        if (supported[i].matches(\"TLS_ECDH_anon.*\"))\n\t        enabled.add(supported[i]);\n      for (int i = 0; i < supported.length; i++)\n        if (supported[i].matches(\"TLS_DH_anon.*\"))\n\t        enabled.add(supported[i]);\n      engine.setEnabledCipherSuites(enabled.toArray(new String[0]));\n    } else {\n      engine.setEnabledCipherSuites(engine.getSupportedCipherSuites());\n    }\n\n  }\n\n  class MyX509TrustManager implements X509TrustManager\n  {\n\n    X509TrustManager tm;\n\n    MyX509TrustManager() throws java.security.GeneralSecurityException\n    {\n      KeyStore ks = KeyStore.getInstance(\"JKS\");\n      CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n      try {\n        ks.load(null, null);\n        String a = TrustManagerFactory.getDefaultAlgorithm();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(a);\n        tmf.init((KeyStore)null);\n        for (TrustManager m : tmf.getTrustManagers())\n          if (m instanceof X509TrustManager)\n            for (X509Certificate c : ((X509TrustManager)m).getAcceptedIssuers())\n              ks.setCertificateEntry(getThumbprint((X509Certificate)c), c);\n        File cacert = new File(cafile);\n        if (cacert.exists() && cacert.canRead()) {\n          InputStream caStream = new MyFileInputStream(cacert);\n          Collection<? extends Certificate> cacerts =\n            cf.generateCertificates(caStream);\n          for (Certificate cert : cacerts) {\n            String thumbprint = getThumbprint((X509Certificate)cert);\n            ks.setCertificateEntry(thumbprint, (X509Certificate)cert);\n          }\n        }\n        PKIXBuilderParameters params =\n          new PKIXBuilderParameters(ks, new X509CertSelector());\n        File crlcert = new File(crlfile);\n        if (!crlcert.exists() || !crlcert.canRead()) {\n          params.setRevocationEnabled(false);\n        } else {\n          InputStream crlStream = new FileInputStream(crlfile);\n          Collection<? extends CRL> crls = cf.generateCRLs(crlStream);\n          CertStoreParameters csp = new CollectionCertStoreParameters(crls);\n          CertStore store = CertStore.getInstance(\"Collection\", csp);\n          params.addCertStore(store);\n          params.setRevocationEnabled(true);\n        }\n        tmf = TrustManagerFactory.getInstance(\"PKIX\");\n        tmf.init(new CertPathTrustManagerParameters(params));\n        tm = (X509TrustManager)tmf.getTrustManagers()[0];\n      } catch (java.lang.Exception e) {\n        throw new Exception(e.getMessage());\n      }\n    }\n\n    public void checkClientTrusted(X509Certificate[] chain, String authType)\n      throws CertificateException\n    {\n      tm.checkClientTrusted(chain, authType);\n    }\n\n    private final char[] hexCode = \"0123456789ABCDEF\".toCharArray();\n\n    private String printHexBinary(byte[] data)\n    {\n      StringBuilder r = new StringBuilder(data.length*2);\n      for (byte b : data) {\n        r.append(hexCode[(b >> 4) & 0xF]);\n        r.append(hexCode[(b & 0xF)]); \n      }\n      return r.toString();\n    }\n\n    public void checkServerTrusted(X509Certificate[] chain, String authType)\n      throws CertificateException\n    {\n      Collection<? extends Certificate> certs = null;\n      X509Certificate cert = chain[0];\n      try {\n        cert.checkValidity();\n      } catch(CertificateNotYetValidException e) {\n        throw new AuthFailureException(\"server certificate has not been activated\");\n      } catch(CertificateExpiredException e) {\n        if (!msg.showMsgBox(YES_NO_OPTION, \"certificate has expired\",\n\t\t\t      \"The certificate of the server has expired, \"+\n\t\t\t      \"do you want to continue?\"))\n          throw new AuthFailureException(\"server certificate has expired\");\n      }\n      String thumbprint = getThumbprint(cert);\n      File vncDir = new File(FileUtils.getVncHomeDir());\n      File certFile = new File(vncDir, \"x509_savedcerts.pem\");\n      CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n      if (vncDir.exists() && certFile.exists() && certFile.canRead()) {\n        InputStream certStream = new MyFileInputStream(certFile);\n        certs = cf.generateCertificates(certStream);\n        for (Certificate c : certs)\n          if (thumbprint.equals(getThumbprint((X509Certificate)c)))\n            return;\n      }\n      try {\n        verifyHostname(cert);\n        tm.checkServerTrusted(chain, authType);\n      } catch (java.lang.Exception e) {\n        if (e.getCause() instanceof CertPathBuilderException) {\n          String certinfo =\n            \"This certificate has been signed by an unknown authority\\n\"+\n            \"\\n\"+\n            \"  Subject: \"+cert.getSubjectX500Principal().getName()+\"\\n\"+\n            \"  Issuer: \"+cert.getIssuerX500Principal().getName()+\"\\n\"+\n            \"  Serial Number: \"+cert.getSerialNumber()+\"\\n\"+\n            \"  Version: \"+cert.getVersion()+\"\\n\"+\n            \"  Signature Algorithm: \"+cert.getPublicKey().getAlgorithm()+\"\\n\"+\n            \"  Not Valid Before: \"+cert.getNotBefore()+\"\\n\"+\n            \"  Not Valid After: \"+cert.getNotAfter()+\"\\n\"+\n            \"  SHA1 Fingerprint: \"+getThumbprint(cert)+\"\\n\"+\n            \"\\n\"+\n            \"Do you want to save it and continue?\";\n          if (!msg.showMsgBox(YES_NO_OPTION, \"certificate issuer unknown\",\n                certinfo)) {\n            throw new AuthFailureException(\"certificate issuer unknown\");\n          }\n          if (certs == null || !certs.contains(cert)) {\n            byte[] der = cert.getEncoded();\n            String pem = Base64.getEncoder().encodeToString(der);\n            pem = pem.replaceAll(\"(.{64})\", \"$1\\n\");\n            FileWriter fw = null;\n            try {\n              if (!vncDir.exists())\n                vncDir.mkdir();\n              if (!certFile.exists() && !certFile.createNewFile()) {\n                vlog.error(\"Certificate save failed.\");\n              } else {\n                fw = new FileWriter(certFile.getAbsolutePath(), true);\n                fw.write(\"-----BEGIN CERTIFICATE-----\\n\");\n                fw.write(pem+\"\\n\");\n                fw.write(\"-----END CERTIFICATE-----\\n\");\n              }\n            } catch (IOException ioe) {\n              msg.showMsgBox(OK_OPTION, \"certificate save failed\",\n                             \"Could not save the certificate\");\n            } finally {\n              try {\n                if (fw != null)\n                  fw.close();\n              } catch(IOException ioe2) {\n                throw new Exception(ioe2.getMessage());\n              }\n            }\n          }\n        } else {\n          throw new SystemException(e.getMessage());\n        }\n      }\n    }\n\n    public X509Certificate[] getAcceptedIssuers ()\n    {\n      return tm.getAcceptedIssuers();\n    }\n\n    private String getThumbprint(X509Certificate cert)\n    {\n      String thumbprint = null;\n      try {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        md.update(cert.getEncoded());\n        thumbprint = printHexBinary(md.digest());\n        thumbprint = thumbprint.replaceAll(\"..(?!$)\", \"$0 \");\n      } catch(CertificateEncodingException e) {\n        throw new SystemException(e.getMessage());\n      } catch(NoSuchAlgorithmException e) {\n        throw new SystemException(e.getMessage());\n      }\n      return thumbprint;\n    }\n\n    private void verifyHostname(X509Certificate cert)\n      throws CertificateParsingException\n    {\n      try {\n        Collection sans = cert.getSubjectAlternativeNames();\n        if (sans == null) {\n          String dn = cert.getSubjectX500Principal().getName();\n          LdapName ln = new LdapName(dn);\n          for (Rdn rdn : ln.getRdns()) {\n            if (rdn.getType().equalsIgnoreCase(\"CN\")) {\n              String peer = client.getServerName().toLowerCase();\n              if (peer.equals(((String)rdn.getValue()).toLowerCase()))\n                return;\n            }\n          }\n        } else {\n          Iterator i = sans.iterator();\n          while (i.hasNext()) {\n            List nxt = (List)i.next();\n            if (((Integer)nxt.get(0)).intValue() == 2) {\n              String peer = client.getServerName().toLowerCase();\n              if (peer.equals(((String)nxt.get(1)).toLowerCase()))\n                return;\n            } else if (((Integer)nxt.get(0)).intValue() == 7) {\n              String peer = ((CConn)client).getSocket().getPeerAddress();\n              if (peer.equals(((String)nxt.get(1)).toLowerCase()))\n                return;\n            }\n          }\n        }\n        Object[] answer = {\"YES\", \"NO\"};\n        int ret = JOptionPane.showOptionDialog(null,\n          \"Hostname verification failed. Do you want to continue?\",\n          \"Hostname Verification Failure\",\n          JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,\n          null, answer, answer[0]);\n        if (ret != JOptionPane.YES_OPTION)\n          throw new WarningException(\"Hostname verification failed.\");\n      } catch (CertificateParsingException e) {\n        throw new SystemException(e.getMessage());\n      } catch (InvalidNameException e) {\n        throw new SystemException(e.getMessage());\n      }\n    }\n\n    private class MyFileInputStream extends InputStream {\n      // Blank lines in a certificate file will cause Java 6 to throw a\n      // \"DerInputStream.getLength(): lengthTag=127, too big\" exception.\n      ByteBuffer buf;\n\n      public MyFileInputStream(String name) {\n        this(new File(name));\n      }\n\n      public MyFileInputStream(File file) {\n        StringBuffer sb = new StringBuffer();\n        BufferedReader reader = null;\n        try {\n          reader = new BufferedReader(new FileReader(file));\n          String l;\n          while ((l = reader.readLine()) != null) {\n            if (l.trim().length() > 0 )\n              sb.append(l+\"\\n\");\n          }\n        } catch (java.lang.Exception e) {\n          throw new Exception(e.toString());\n        } finally {\n          try {\n            if (reader != null)\n              reader.close();\n          } catch(IOException ioe) {\n            throw new Exception(ioe.getMessage());\n          }\n        }\n        Charset utf8 = Charset.forName(\"UTF-8\");\n        buf = ByteBuffer.wrap(sb.toString().getBytes(utf8));\n        buf.limit(buf.capacity());\n      }\n\n      @Override\n      public int read(byte[] b) throws IOException {\n        return this.read(b, 0, b.length);\n      }\n\n      @Override\n      public int read(byte[] b, int off, int len) throws IOException {\n        if (!buf.hasRemaining())\n          return -1;\n        len = Math.min(len, buf.remaining());\n        buf.get(b, off, len);\n        return len;\n      }\n\n      @Override\n      public int read() throws IOException {\n        if (!buf.hasRemaining())\n          return -1;\n        return buf.get() & 0xFF;\n      }\n    }\n  }\n\n  public final int getType() { return anon ? Security.secTypeTLSNone : Security.secTypeX509None; }\n  public final String description()\n    { return anon ? \"TLS Encryption without VncAuth\" : \"X509 Encryption without VncAuth\"; }\n  public boolean isSecure() { return !anon; }\n\n  protected CConnection client;\n\n  private SSLContext ctx;\n  private SSLEngine engine;\n  private SSLEngineManager manager;\n  private boolean anon;\n\n  private String cafile, crlfile;\n  private FdInStream is;\n  private FdOutStream os;\n\n  static LogWriter vlog = new LogWriter(\"CSecurityTLS\");\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700206,
    "RELATED_CWE": [
      "CWE-863",
      "CWE-285",
      "CWE-862"
    ]
  },
  {
    "CWE_ID": [
      "CWE-295"
    ],
    "code": "/*\n * Copyright (C) 2004 Red Hat Inc.\n * Copyright (C) 2005 Martin Koegler\n * Copyright (C) 2010 m-privacy GmbH\n * Copyright (C) 2010 TigerVNC Team\n * Copyright (C) 2011-2019 Brian P. Hinz\n * Copyright (C) 2015 D. R. Commander.  All Rights Reserved.\n *\n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n * USA.\n */\n\npackage com.tigervnc.rfb;\n\nimport javax.net.ssl.*;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.MessageDigest;\nimport java.security.cert.*;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Base64;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.naming.InvalidNameException;\nimport javax.naming.ldap.LdapName;\nimport javax.naming.ldap.Rdn;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.swing.JOptionPane;\n\nimport com.tigervnc.rdr.*;\nimport com.tigervnc.network.*;\nimport com.tigervnc.vncviewer.*;\n\nimport static javax.swing.JOptionPane.*;\n\npublic class CSecurityTLS extends CSecurity {\n\n  public static StringParameter X509CA\n  = new StringParameter(\"X509CA\",\n                        \"X509 CA certificate\", \"\", Configuration.ConfigurationObject.ConfViewer);\n  public static StringParameter X509CRL\n  = new StringParameter(\"X509CRL\",\n                        \"X509 CRL file\", \"\", Configuration.ConfigurationObject.ConfViewer);\n  public static UserMsgBox msg;\n\n  private void initGlobal()\n  {\n    try {\n      ctx = SSLContext.getInstance(\"TLS\");\n    } catch(NoSuchAlgorithmException e) {\n      throw new Exception(e.toString());\n    }\n  }\n\n  public CSecurityTLS(boolean _anon)\n  {\n    anon = _anon;\n    manager = null;\n\n    setDefaults();\n    cafile = X509CA.getData();\n    crlfile = X509CRL.getData();\n  }\n\n  public static String getDefaultCA() {\n    if (UserPreferences.get(\"viewer\", \"x509ca\") != null)\n      return UserPreferences.get(\"viewer\", \"x509ca\");\n    return FileUtils.getVncHomeDir()+\"x509_ca.pem\";\n  }\n\n  public static String getDefaultCRL() {\n    if (UserPreferences.get(\"viewer\", \"x509crl\") != null)\n      return UserPreferences.get(\"viewer\", \"x509crl\");\n    return FileUtils.getVncHomeDir()+\"x509_crl.pem\";\n  }\n\n  public static void setDefaults()\n  {\n    if (new File(getDefaultCA()).exists())\n      X509CA.setDefaultStr(getDefaultCA());\n    if (new File(getDefaultCRL()).exists())\n      X509CRL.setDefaultStr(getDefaultCRL());\n  }\n\n  public boolean processMsg(CConnection cc) {\n    is = (FdInStream)cc.getInStream();\n    os = (FdOutStream)cc.getOutStream();\n    client = cc;\n\n    initGlobal();\n\n    if (manager == null) {\n      if (!is.checkNoWait(1))\n        return false;\n\n      if (is.readU8() == 0) {\n        int result = is.readU32();\n        String reason;\n        if (result == Security.secResultFailed ||\n            result == Security.secResultTooMany)\n          reason = is.readString();\n        else\n          reason = new String(\"Authentication failure (protocol error)\");\n        throw new AuthFailureException(reason);\n      }\n\n      setParam();\n    }\n\n    try {\n      manager = new SSLEngineManager(engine, is, os);\n      manager.doHandshake();\n    } catch(java.lang.Exception e) {\n      throw new SystemException(e.toString());\n    }\n\n    cc.setStreams(new TLSInStream(is, manager),\n\t\t              new TLSOutStream(os, manager));\n    return true;\n  }\n\n  private void setParam() {\n\n    if (anon) {\n      try {\n        ctx.init(null, null, null);\n      } catch(KeyManagementException e) {\n        throw new AuthFailureException(e.toString());\n      }\n    } else {\n      try {\n        TrustManager[] myTM = new TrustManager[] {\n          new MyX509TrustManager()\n        };\n        ctx.init (null, myTM, null);\n      } catch (java.security.GeneralSecurityException e) {\n        throw new AuthFailureException(e.toString());\n      }\n    }\n    SSLSocketFactory sslfactory = ctx.getSocketFactory();\n    engine = ctx.createSSLEngine(client.getServerName(),\n                                 client.getServerPort());\n    engine.setUseClientMode(true);\n\n    String[] supported = engine.getSupportedProtocols();\n    ArrayList<String> enabled = new ArrayList<String>();\n    for (int i = 0; i < supported.length; i++)\n      if (supported[i].matches(\"TLS.*\"))\n\t      enabled.add(supported[i]);\n    engine.setEnabledProtocols(enabled.toArray(new String[0]));\n\n    if (anon) {\n      supported = engine.getSupportedCipherSuites();\n      enabled = new ArrayList<String>();\n      // prefer ECDH over DHE\n      for (int i = 0; i < supported.length; i++)\n        if (supported[i].matches(\"TLS_ECDH_anon.*\"))\n\t        enabled.add(supported[i]);\n      for (int i = 0; i < supported.length; i++)\n        if (supported[i].matches(\"TLS_DH_anon.*\"))\n\t        enabled.add(supported[i]);\n      engine.setEnabledCipherSuites(enabled.toArray(new String[0]));\n    } else {\n      engine.setEnabledCipherSuites(engine.getSupportedCipherSuites());\n    }\n\n  }\n\n  class MyX509TrustManager implements X509TrustManager\n  {\n\n    X509TrustManager tm;\n\n    MyX509TrustManager() throws java.security.GeneralSecurityException\n    {\n      KeyStore ks = KeyStore.getInstance(\"JKS\");\n      CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n      try {\n        ks.load(null, null);\n        String a = TrustManagerFactory.getDefaultAlgorithm();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(a);\n        tmf.init((KeyStore)null);\n        for (TrustManager m : tmf.getTrustManagers())\n          if (m instanceof X509TrustManager)\n            for (X509Certificate c : ((X509TrustManager)m).getAcceptedIssuers())\n              ks.setCertificateEntry(getThumbprint((X509Certificate)c), c);\n        File cacert = new File(cafile);\n        if (cacert.exists() && cacert.canRead()) {\n          InputStream caStream = new MyFileInputStream(cacert);\n          Collection<? extends Certificate> cacerts =\n            cf.generateCertificates(caStream);\n          for (Certificate cert : cacerts) {\n            String thumbprint = getThumbprint((X509Certificate)cert);\n            ks.setCertificateEntry(thumbprint, (X509Certificate)cert);\n          }\n        }\n        PKIXBuilderParameters params =\n          new PKIXBuilderParameters(ks, new X509CertSelector());\n        File crlcert = new File(crlfile);\n        if (!crlcert.exists() || !crlcert.canRead()) {\n          params.setRevocationEnabled(false);\n        } else {\n          InputStream crlStream = new FileInputStream(crlfile);\n          Collection<? extends CRL> crls = cf.generateCRLs(crlStream);\n          CertStoreParameters csp = new CollectionCertStoreParameters(crls);\n          CertStore store = CertStore.getInstance(\"Collection\", csp);\n          params.addCertStore(store);\n          params.setRevocationEnabled(true);\n        }\n        tmf = TrustManagerFactory.getInstance(\"PKIX\");\n        tmf.init(new CertPathTrustManagerParameters(params));\n        tm = (X509TrustManager)tmf.getTrustManagers()[0];\n      } catch (java.lang.Exception e) {\n        throw new Exception(e.getMessage());\n      }\n    }\n\n    public void checkClientTrusted(X509Certificate[] chain, String authType)\n      throws CertificateException\n    {\n      tm.checkClientTrusted(chain, authType);\n    }\n\n    private final char[] hexCode = \"0123456789ABCDEF\".toCharArray();\n\n    private String printHexBinary(byte[] data)\n    {\n      StringBuilder r = new StringBuilder(data.length*2);\n      for (byte b : data) {\n        r.append(hexCode[(b >> 4) & 0xF]);\n        r.append(hexCode[(b & 0xF)]); \n      }\n      return r.toString();\n    }\n\n    public void checkServerTrusted(X509Certificate[] chain, String authType)\n      throws CertificateException\n    {\n      Collection<? extends Certificate> certs = null;\n      X509Certificate cert = chain[0];\n      String pk =\n        Base64.getEncoder().encodeToString(cert.getPublicKey().getEncoded());\n      try {\n        cert.checkValidity();\n        verifyHostname(cert);\n      } catch(CertificateParsingException e) {\n        throw new SystemException(e.getMessage());\n      } catch(CertificateNotYetValidException e) {\n        throw new AuthFailureException(\"server certificate has not been activated\");\n      } catch(CertificateExpiredException e) {\n        if (!msg.showMsgBox(YES_NO_OPTION, \"certificate has expired\",\n\t\t\t      \"The certificate of the server has expired, \"+\n\t\t\t      \"do you want to continue?\"))\n          throw new AuthFailureException(\"server certificate has expired\");\n      }\n      File vncDir = new File(FileUtils.getVncHomeDir());\n      if (!vncDir.exists())\n        throw new AuthFailureException(\"Could not obtain VNC home directory \"+\n                                       \"path for known hosts storage\");\n      File dbPath = new File(vncDir, \"x509_known_hosts\");\n      String info =\n        \"  Subject: \"+cert.getSubjectX500Principal().getName()+\"\\n\"+\n        \"  Issuer: \"+cert.getIssuerX500Principal().getName()+\"\\n\"+\n        \"  Serial Number: \"+cert.getSerialNumber()+\"\\n\"+\n        \"  Version: \"+cert.getVersion()+\"\\n\"+\n        \"  Signature Algorithm: \"+cert.getPublicKey().getAlgorithm()+\"\\n\"+\n        \"  Not Valid Before: \"+cert.getNotBefore()+\"\\n\"+\n        \"  Not Valid After: \"+cert.getNotAfter()+\"\\n\"+\n        \"  SHA-1 Fingerprint: \"+getThumbprint(cert)+\"\\n\";\n      try {\n        if (dbPath.exists()) {\n          FileReader db = new FileReader(dbPath);\n          BufferedReader dbBuf = new BufferedReader(db);\n          String line;\n          String server = client.getServerName().toLowerCase();\n          while ((line = dbBuf.readLine())!=null) {\n            String fields[] = line.split(\"\\\\|\");\n            if (fields.length==6) {\n              if (server.equals(fields[2]) && pk.equals(fields[5])) {\n                vlog.debug(\"Server certificate found in known hosts file\");\n                dbBuf.close();\n                return;\n              } else if (server.equals(fields[2]) && !pk.equals(fields[5]) ||\n                         !server.equals(fields[2]) && pk.equals(fields[5])) {\n                throw new CertStoreException();\n              }\n            }\n          }\n          dbBuf.close();\n        }\n        tm.checkServerTrusted(chain, authType);\n      } catch (IOException e) {\n        throw new AuthFailureException(\"Could not load known hosts database\");\n      } catch (CertStoreException e) {\n        vlog.debug(\"Server host key mismatch\");\n        vlog.debug(info);\n        String text =\n          \"This host is previously known with a different \"+\n          \"certificate, and the new certificate has been \"+\n          \"signed by an unknown authority\\n\"+\n          \"\\n\"+info+\"\\n\"+\n          \"Someone could be trying to impersonate the site and you should not continue.\\n\"+\n          \"\\n\"+\n          \"Do you want to make an exception for this server?\";\n        if (!msg.showMsgBox(YES_NO_OPTION, \"Unexpected certificate issuer\", text))\n          throw new AuthFailureException(\"Unexpected certificate issuer\");\n        store_pubkey(dbPath, client.getServerName().toLowerCase(), pk);\n      } catch (java.lang.Exception e) {\n        if (e.getCause() instanceof CertPathBuilderException) {\n          vlog.debug(\"Server host not previously known\");\n          vlog.debug(info);\n          String text =\n            \"This certificate has been signed by an unknown authority\\n\"+\n            \"\\n\"+info+\"\\n\"+\n            \"Someone could be trying to impersonate the site and you should not continue.\\n\"+\n            \"\\n\"+\n            \"Do you want to make an exception for this server?\";\n          if (!msg.showMsgBox(YES_NO_OPTION, \"Unknown certificate issuer\", text))\n            throw new AuthFailureException(\"Unknown certificate issuer\");\n          store_pubkey(dbPath, client.getServerName().toLowerCase(), pk);\n        } else {\n          throw new SystemException(e.getMessage());\n        }\n      }\n    }\n\n    private void store_pubkey(File dbPath, String serverName, String pk)\n    {\n      ArrayList<String> lines = new ArrayList<String>();\n      File vncDir = new File(FileUtils.getVncHomeDir());\n      try {\n        if (dbPath.exists()) {\n          FileReader db = new FileReader(dbPath);\n          BufferedReader dbBuf = new BufferedReader(db);\n          String line;\n          while ((line = dbBuf.readLine())!=null) {\n            String fields[] = line.split(\"\\\\|\");\n            if (fields.length==6)\n              if (!serverName.equals(fields[2]) && !pk.equals(fields[5]))\n                lines.add(line);\n          }\n          dbBuf.close();\n        }\n      } catch (IOException e) {\n        throw new AuthFailureException(\"Could not load known hosts database\");\n      }\n      try {\n        if (!dbPath.exists())\n          dbPath.createNewFile();\n        FileWriter fw = new FileWriter(dbPath.getAbsolutePath(), false);\n        Iterator i = lines.iterator();\n        while (i.hasNext())\n          fw.write((String)i.next()+\"\\n\");\n        fw.write(\"|g0|\"+serverName+\"|*|0|\"+pk+\"\\n\");\n        fw.close();\n      } catch (IOException e) {\n        vlog.error(\"Failed to store server certificate to known hosts database\");\n      }\n    }\n\n    public X509Certificate[] getAcceptedIssuers ()\n    {\n      return tm.getAcceptedIssuers();\n    }\n\n    private String getThumbprint(X509Certificate cert)\n    {\n      String thumbprint = null;\n      try {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        md.update(cert.getEncoded());\n        thumbprint = printHexBinary(md.digest());\n        thumbprint = thumbprint.replaceAll(\"..(?!$)\", \"$0 \");\n      } catch(CertificateEncodingException e) {\n        throw new SystemException(e.getMessage());\n      } catch(NoSuchAlgorithmException e) {\n        throw new SystemException(e.getMessage());\n      }\n      return thumbprint;\n    }\n\n    private void verifyHostname(X509Certificate cert)\n      throws CertificateParsingException\n    {\n      try {\n        Collection sans = cert.getSubjectAlternativeNames();\n        if (sans == null) {\n          String dn = cert.getSubjectX500Principal().getName();\n          LdapName ln = new LdapName(dn);\n          for (Rdn rdn : ln.getRdns()) {\n            if (rdn.getType().equalsIgnoreCase(\"CN\")) {\n              String peer = client.getServerName().toLowerCase();\n              if (peer.equals(((String)rdn.getValue()).toLowerCase()))\n                return;\n            }\n          }\n        } else {\n          Iterator i = sans.iterator();\n          while (i.hasNext()) {\n            List nxt = (List)i.next();\n            if (((Integer)nxt.get(0)).intValue() == 2) {\n              String peer = client.getServerName().toLowerCase();\n              if (peer.equals(((String)nxt.get(1)).toLowerCase()))\n                return;\n            } else if (((Integer)nxt.get(0)).intValue() == 7) {\n              String peer = ((CConn)client).getSocket().getPeerAddress();\n              if (peer.equals(((String)nxt.get(1)).toLowerCase()))\n                return;\n            }\n          }\n        }\n        Object[] answer = {\"YES\", \"NO\"};\n        int ret = JOptionPane.showOptionDialog(null,\n          \"Hostname (\"+client.getServerName()+\") does not match the\"+\n          \" server certificate, do you want to continue?\",\n          \"Certificate hostname mismatch\",\n          JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,\n          null, answer, answer[0]);\n        if (ret != JOptionPane.YES_OPTION)\n          throw new WarningException(\"Certificate hostname mismatch.\");\n      } catch (CertificateParsingException e) {\n        throw new SystemException(e.getMessage());\n      } catch (InvalidNameException e) {\n        throw new SystemException(e.getMessage());\n      }\n    }\n\n    private class MyFileInputStream extends InputStream {\n      // Blank lines in a certificate file will cause Java 6 to throw a\n      // \"DerInputStream.getLength(): lengthTag=127, too big\" exception.\n      ByteBuffer buf;\n\n      public MyFileInputStream(String name) {\n        this(new File(name));\n      }\n\n      public MyFileInputStream(File file) {\n        StringBuffer sb = new StringBuffer();\n        BufferedReader reader = null;\n        try {\n          reader = new BufferedReader(new FileReader(file));\n          String l;\n          while ((l = reader.readLine()) != null) {\n            if (l.trim().length() > 0 )\n              sb.append(l+\"\\n\");\n          }\n        } catch (java.lang.Exception e) {\n          throw new Exception(e.toString());\n        } finally {\n          try {\n            if (reader != null)\n              reader.close();\n          } catch(IOException ioe) {\n            throw new Exception(ioe.getMessage());\n          }\n        }\n        Charset utf8 = Charset.forName(\"UTF-8\");\n        buf = ByteBuffer.wrap(sb.toString().getBytes(utf8));\n        buf.limit(buf.capacity());\n      }\n\n      @Override\n      public int read(byte[] b) throws IOException {\n        return this.read(b, 0, b.length);\n      }\n\n      @Override\n      public int read(byte[] b, int off, int len) throws IOException {\n        if (!buf.hasRemaining())\n          return -1;\n        len = Math.min(len, buf.remaining());\n        buf.get(b, off, len);\n        return len;\n      }\n\n      @Override\n      public int read() throws IOException {\n        if (!buf.hasRemaining())\n          return -1;\n        return buf.get() & 0xFF;\n      }\n    }\n  }\n\n  public final int getType() { return anon ? Security.secTypeTLSNone : Security.secTypeX509None; }\n  public final String description()\n    { return anon ? \"TLS Encryption without VncAuth\" : \"X509 Encryption without VncAuth\"; }\n  public boolean isSecure() { return !anon; }\n\n  protected CConnection client;\n\n  private SSLContext ctx;\n  private SSLEngine engine;\n  private SSLEngineManager manager;\n  private boolean anon;\n\n  private String cafile, crlfile;\n  private FdInStream is;\n  private FdOutStream os;\n\n  static LogWriter vlog = new LogWriter(\"CSecurityTLS\");\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700207,
    "RELATED_CWE": [
      "CWE-863",
      "CWE-285",
      "CWE-862"
    ]
  }
]